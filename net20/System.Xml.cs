
// C:\WINDOWS\assembly\GAC_MSIL\System.Xml\2.0.0.0__b77a5c561934e089\System.Xml.dll
// System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v2.0.50727
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 00000000000000000400000000000000

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Configuration;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Security.Policy;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Xml.Serialization.Advanced;
using System.Xml.Serialization.Configuration;
using System.Xml.Utils;
using System.Xml.XmlConfiguration;
using System.Xml.XPath;
using System.Xml.Xsl;
using System.Xml.Xsl.Qil;
using System.Xml.Xsl.Runtime;
using System.Xml.Xsl.Xslt;
using System.Xml.Xsl.XsltOld;
using System.Xml.Xsl.XsltOld.Debugger;
using Microsoft.CSharp;
using Microsoft.Win32;
using MS.Internal.Xml.Cache;
using MS.Internal.Xml.XPath;

[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyDescription("System.Xml.dll")]
[assembly: AssemblyTitle("System.Xml.dll")]
[assembly: AssemblyFileVersion("2.0.50727.9149")]
[assembly: AssemblyDefaultAlias("System.Xml.dll")]
[assembly: AllowPartiallyTrustedCallers]
[assembly: CLSCompliant(true)]
[assembly: ComVisible(false)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: CompilationRelaxations(8)]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: InternalsVisibleTo("System.Data.SqlXml, PublicKey=00000000000000000400000000000000")]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: AssemblyKeyFile("f:\\dd\\Tools\\devdiv\\EcmaPublicKey.snk")]
[assembly: AssemblyDelaySign(true)]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: SatelliteContractVersion("2.0.0.0")]
[assembly: AssemblyInformationalVersion("2.0.50727.9149")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("2.0.0.0")]
[module: UnverifiableCode]
internal static class FXAssembly
{
	internal const string Version = "2.0.0.0";
}
internal static class ThisAssembly
{
	internal const string Title = "System.Xml.dll";

	internal const string Description = "System.Xml.dll";

	internal const string DefaultAlias = "System.Xml.dll";

	internal const string Copyright = "© Microsoft Corporation.  All rights reserved.";

	internal const string Version = "2.0.0.0";

	internal const string InformationalVersion = "2.0.50727.9149";

	internal const int DailyBuildNumber = 50727;
}
internal static class AssemblyRef
{
	internal const string EcmaPublicKey = "b77a5c561934e089";

	internal const string EcmaPublicKeyToken = "b77a5c561934e089";

	internal const string EcmaPublicKeyFull = "00000000000000000400000000000000";

	internal const string Mscorlib = "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemData = "System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemDataOracleClient = "System.Data.OracleClient, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string System = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeRemoting = "System.Runtime.Remoting, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWindowsForms = "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemXml = "System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string MicrosoftPublicKey = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyToken = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyFull = "002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293";

	internal const string SystemConfiguration = "System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemConfigurationInstall = "System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDeployment = "System.Deployment, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDesign = "System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDirectoryServices = "System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawingDesign = "System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawing = "System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemEnterpriseServices = "System.EnterpriseServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemManagement = "System.Management, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemMessaging = "System.Messaging, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeSerializationFormattersSoap = "System.Runtime.Serialization.Formatters.Soap, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemSecurity = "System.Security, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemServiceProcess = "System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWeb = "System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebMobile = "System.Web.Mobile, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRegularExpressions = "System.Web.RegularExpressions, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebServices = "System.Web.Services, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudio = "Microsoft.VisualStudio, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWindowsForms = "Microsoft.VisualStudio.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string VJSharpCodeProvider = "VJSharpCodeProvider, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string ASPBrowserCapsPublicKey = "b7bd7678b977bd8f";

	internal const string ASPBrowserCapsFactory = "ASP.BrowserCapsFactory, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b7bd7678b977bd8f";

	internal const string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWeb = "Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVSDesignerMobile = "Microsoft.VSDesigner.Mobile, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftJScript = "Microsoft.JScript, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
}
namespace System.Xml
{
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class ResDescriptionAttribute : DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = Res.GetString(base.Description);
				}
				return base.Description;
			}
		}

		public ResDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class ResCategoryAttribute : CategoryAttribute
	{
		public ResCategoryAttribute(string category)
			: base(category)
		{
		}

		protected override string GetLocalizedString(string value)
		{
			return Res.GetString(value);
		}
	}
	internal sealed class Res
	{
		internal const string Xml_UserException = "Xml_UserException";

		internal const string Xml_DefaultException = "Xml_DefaultException";

		internal const string Xml_InvalidOperation = "Xml_InvalidOperation";

		internal const string Xml_StackOverflow = "Xml_StackOverflow";

		internal const string Xml_ErrorFilePosition = "Xml_ErrorFilePosition";

		internal const string Xslt_NoStylesheetLoaded = "Xslt_NoStylesheetLoaded";

		internal const string Xslt_NotCompiledStylesheet = "Xslt_NotCompiledStylesheet";

		internal const string Xml_UnclosedQuote = "Xml_UnclosedQuote";

		internal const string Xml_UnexpectedEOF = "Xml_UnexpectedEOF";

		internal const string Xml_UnexpectedEOF1 = "Xml_UnexpectedEOF1";

		internal const string Xml_UnexpectedEOFInElementContent = "Xml_UnexpectedEOFInElementContent";

		internal const string Xml_BadStartNameChar = "Xml_BadStartNameChar";

		internal const string Xml_BadNameChar = "Xml_BadNameChar";

		internal const string Xml_BadNameCharWithPos = "Xml_BadNameCharWithPos";

		internal const string Xml_BadDecimalEntity = "Xml_BadDecimalEntity";

		internal const string Xml_BadHexEntity = "Xml_BadHexEntity";

		internal const string Xml_MissingByteOrderMark = "Xml_MissingByteOrderMark";

		internal const string Xml_UnknownEncoding = "Xml_UnknownEncoding";

		internal const string Xml_InternalError = "Xml_InternalError";

		internal const string Xml_InvalidCharInThisEncoding = "Xml_InvalidCharInThisEncoding";

		internal const string Xml_ErrorPosition = "Xml_ErrorPosition";

		internal const string Xml_UnexpectedTokenEx = "Xml_UnexpectedTokenEx";

		internal const string Xml_UnexpectedTokens2 = "Xml_UnexpectedTokens2";

		internal const string Xml_ExpectingWhiteSpace = "Xml_ExpectingWhiteSpace";

		internal const string Xml_TagMismatch = "Xml_TagMismatch";

		internal const string Xml_UnexpectedEndTag = "Xml_UnexpectedEndTag";

		internal const string Xml_UnknownNs = "Xml_UnknownNs";

		internal const string Xml_BadAttributeChar = "Xml_BadAttributeChar";

		internal const string Xml_MissingRoot = "Xml_MissingRoot";

		internal const string Xml_MultipleRoots = "Xml_MultipleRoots";

		internal const string Xml_InvalidRootData = "Xml_InvalidRootData";

		internal const string Xml_XmlDeclNotFirst = "Xml_XmlDeclNotFirst";

		internal const string Xml_InvalidXmlDecl = "Xml_InvalidXmlDecl";

		internal const string Xml_InvalidNodeType = "Xml_InvalidNodeType";

		internal const string Xml_InvalidPIName = "Xml_InvalidPIName";

		internal const string Xml_InvalidXmlSpace = "Xml_InvalidXmlSpace";

		internal const string Xml_InvalidVersionNumber = "Xml_InvalidVersionNumber";

		internal const string Xml_DupAttributeName = "Xml_DupAttributeName";

		internal const string Xml_BadDTDLocation = "Xml_BadDTDLocation";

		internal const string Xml_ElementNotFound = "Xml_ElementNotFound";

		internal const string Xml_ElementNotFoundNs = "Xml_ElementNotFoundNs";

		internal const string Xml_PartialContentNodeTypeNotSupportedEx = "Xml_PartialContentNodeTypeNotSupportedEx";

		internal const string Xml_MultipleDTDsProvided = "Xml_MultipleDTDsProvided";

		internal const string Xml_CanNotBindToReservedNamespace = "Xml_CanNotBindToReservedNamespace";

		internal const string Xml_XmlnsBelongsToReservedNs = "Xml_XmlnsBelongsToReservedNs";

		internal const string Xml_InvalidCharacter = "Xml_InvalidCharacter";

		internal const string Xml_ExpectDtdMarkup = "Xml_ExpectDtdMarkup";

		internal const string Xml_InvalidBinHexValue = "Xml_InvalidBinHexValue";

		internal const string Xml_InvalidBinHexValueOddCount = "Xml_InvalidBinHexValueOddCount";

		internal const string Xml_InvalidTextDecl = "Xml_InvalidTextDecl";

		internal const string Xml_InvalidBase64Value = "Xml_InvalidBase64Value";

		internal const string Xml_ExpectExternalOrPublicId = "Xml_ExpectExternalOrPublicId";

		internal const string Xml_ExpectExternalIdOrEntityValue = "Xml_ExpectExternalIdOrEntityValue";

		internal const string Xml_ExpectAttType = "Xml_ExpectAttType";

		internal const string Xml_ExpectIgnoreOrInclude = "Xml_ExpectIgnoreOrInclude";

		internal const string Xml_ExpectSubOrClose = "Xml_ExpectSubOrClose";

		internal const string Xml_ExpectExternalOrClose = "Xml_ExpectExternalOrClose";

		internal const string Xml_ExpectOp = "Xml_ExpectOp";

		internal const string Xml_ExpectNoWhitespace = "Xml_ExpectNoWhitespace";

		internal const string Xml_ExpectPcData = "Xml_ExpectPcData";

		internal const string Xml_UndeclaredParEntity = "Xml_UndeclaredParEntity";

		internal const string Xml_UndeclaredEntity = "Xml_UndeclaredEntity";

		internal const string Xml_RecursiveParEntity = "Xml_RecursiveParEntity";

		internal const string Xml_RecursiveGenEntity = "Xml_RecursiveGenEntity";

		internal const string Xml_ExternalEntityInAttValue = "Xml_ExternalEntityInAttValue";

		internal const string Xml_UnparsedEntityRef = "Xml_UnparsedEntityRef";

		internal const string Xml_InvalidConditionalSection = "Xml_InvalidConditionalSection";

		internal const string Xml_UnclosedConditionalSection = "Xml_UnclosedConditionalSection";

		internal const string Xml_InvalidParEntityRef = "Xml_InvalidParEntityRef";

		internal const string Xml_InvalidContentModel = "Xml_InvalidContentModel";

		internal const string Xml_InvalidXmlDocument = "Xml_InvalidXmlDocument";

		internal const string Xml_FragmentId = "Xml_FragmentId";

		internal const string Xml_ColonInLocalName = "Xml_ColonInLocalName";

		internal const string Xml_InvalidAttributeType = "Xml_InvalidAttributeType";

		internal const string Xml_InvalidAttributeType1 = "Xml_InvalidAttributeType1";

		internal const string Xml_UnexpectedCDataEnd = "Xml_UnexpectedCDataEnd";

		internal const string Xml_EnumerationRequired = "Xml_EnumerationRequired";

		internal const string Xml_NotSameNametable = "Xml_NotSameNametable";

		internal const string Xml_NametableMismatch = "Xml_NametableMismatch";

		internal const string Xml_NoDTDPresent = "Xml_NoDTDPresent";

		internal const string Xml_MultipleValidaitonTypes = "Xml_MultipleValidaitonTypes";

		internal const string Xml_BadNamespaceDecl = "Xml_BadNamespaceDecl";

		internal const string Xml_ErrorParsingEntityName = "Xml_ErrorParsingEntityName";

		internal const string Xml_NoValidation = "Xml_NoValidation";

		internal const string Xml_WhitespaceHandling = "Xml_WhitespaceHandling";

		internal const string Xml_InvalidResetStateCall = "Xml_InvalidResetStateCall";

		internal const string Xml_EntityHandling = "Xml_EntityHandling";

		internal const string Xml_InvalidNmToken = "Xml_InvalidNmToken";

		internal const string Xml_EntityRefNesting = "Xml_EntityRefNesting";

		internal const string Xml_CannotResolveEntity = "Xml_CannotResolveEntity";

		internal const string Xml_CannotResolveExternalSubset = "Xml_CannotResolveExternalSubset";

		internal const string Xml_CannotResolveUrl = "Xml_CannotResolveUrl";

		internal const string Xml_CDATAEndInText = "Xml_CDATAEndInText";

		internal const string Xml_ExternalEntityInStandAloneDocument = "Xml_ExternalEntityInStandAloneDocument";

		internal const string Xml_DtdAfterRootElement = "Xml_DtdAfterRootElement";

		internal const string Xml_ReadOnlyProperty = "Xml_ReadOnlyProperty";

		internal const string Xml_DtdIsProhibited = "Xml_DtdIsProhibited";

		internal const string Xml_DtdIsProhibitedEx = "Xml_DtdIsProhibitedEx";

		internal const string Xml_AttlistDuplEnumValue = "Xml_AttlistDuplEnumValue";

		internal const string Xml_AttlistDuplNotationValue = "Xml_AttlistDuplNotationValue";

		internal const string Xml_EncodingSwitchAfterResetState = "Xml_EncodingSwitchAfterResetState";

		internal const string Xml_ReadSubtreeNotOnElement = "Xml_ReadSubtreeNotOnElement";

		internal const string Xml_DtdNotAllowedInFragment = "Xml_DtdNotAllowedInFragment";

		internal const string Xml_CannotStartDocumentOnFragment = "Xml_CannotStartDocumentOnFragment";

		internal const string Xml_InvalidWhitespaceCharacter = "Xml_InvalidWhitespaceCharacter";

		internal const string Xml_IncompatibleConformanceLevel = "Xml_IncompatibleConformanceLevel";

		internal const string Xml_BinaryXmlReadAsText = "Xml_BinaryXmlReadAsText";

		internal const string Xml_UnexpectedNodeType = "Xml_UnexpectedNodeType";

		internal const string Xml_ErrorOpeningExternalDtd = "Xml_ErrorOpeningExternalDtd";

		internal const string Xml_ErrorOpeningExternalEntity = "Xml_ErrorOpeningExternalEntity";

		internal const string Xml_ReadBinaryContentNotSupported = "Xml_ReadBinaryContentNotSupported";

		internal const string Xml_ReadValueChunkNotSupported = "Xml_ReadValueChunkNotSupported";

		internal const string Xml_InvalidReadContentAs = "Xml_InvalidReadContentAs";

		internal const string Xml_InvalidReadElementContentAs = "Xml_InvalidReadElementContentAs";

		internal const string Xml_MixedReadElementContentAs = "Xml_MixedReadElementContentAs";

		internal const string Xml_MixingReadValueChunkWithBinary = "Xml_MixingReadValueChunkWithBinary";

		internal const string Xml_MixingBinaryContentMethods = "Xml_MixingBinaryContentMethods";

		internal const string Xml_MixingV1StreamingWithV2Binary = "Xml_MixingV1StreamingWithV2Binary";

		internal const string Xml_InvalidReadValueChunk = "Xml_InvalidReadValueChunk";

		internal const string Xml_ReadContentAsFormatException = "Xml_ReadContentAsFormatException";

		internal const string Xml_DoubleBaseUri = "Xml_DoubleBaseUri";

		internal const string Xml_NotEnoughSpaceForSurrogatePair = "Xml_NotEnoughSpaceForSurrogatePair";

		internal const string Xml_EmptyUrl = "Xml_EmptyUrl";

		internal const string Xml_UnexpectedNodeInSimpleContent = "Xml_UnexpectedNodeInSimpleContent";

		internal const string Xml_UnsupportedClass = "Xml_UnsupportedClass";

		internal const string Xml_NullResolver = "Xml_NullResolver";

		internal const string Xml_UntrustedCodeSettingResolver = "Xml_UntrustedCodeSettingResolver";

		internal const string Xml_InvalidQuote = "Xml_InvalidQuote";

		internal const string Xml_UndefPrefix = "Xml_UndefPrefix";

		internal const string Xml_PrefixForEmptyNs = "Xml_PrefixForEmptyNs";

		internal const string Xml_NoNamespaces = "Xml_NoNamespaces";

		internal const string Xml_InvalidCDataChars = "Xml_InvalidCDataChars";

		internal const string Xml_InvalidCommentChars = "Xml_InvalidCommentChars";

		internal const string Xml_NotTheFirst = "Xml_NotTheFirst";

		internal const string Xml_InvalidPiChars = "Xml_InvalidPiChars";

		internal const string Xml_UndefNamespace = "Xml_UndefNamespace";

		internal const string Xml_EmptyName = "Xml_EmptyName";

		internal const string Xml_EmptyLocalName = "Xml_EmptyLocalName";

		internal const string Xml_InvalidNameChars = "Xml_InvalidNameChars";

		internal const string Xml_InvalidNameCharsDetail = "Xml_InvalidNameCharsDetail";

		internal const string Xml_NoStartTag = "Xml_NoStartTag";

		internal const string Xml_Closed = "Xml_Closed";

		internal const string Xml_ClosedOrError = "Xml_ClosedOrError";

		internal const string Xml_WrongToken = "Xml_WrongToken";

		internal const string Xml_InvalidPrefix = "Xml_InvalidPrefix";

		internal const string Xml_XmlPrefix = "Xml_XmlPrefix";

		internal const string Xml_XmlnsPrefix = "Xml_XmlnsPrefix";

		internal const string Xml_NamespaceDeclXmlXmlns = "Xml_NamespaceDeclXmlXmlns";

		internal const string Xml_NonWhitespace = "Xml_NonWhitespace";

		internal const string Xml_DupXmlDecl = "Xml_DupXmlDecl";

		internal const string Xml_CannotWriteXmlDecl = "Xml_CannotWriteXmlDecl";

		internal const string Xml_NoRoot = "Xml_NoRoot";

		internal const string Xml_InvalidIndentation = "Xml_InvalidIndentation";

		internal const string Xml_NotInWriteState = "Xml_NotInWriteState";

		internal const string Xml_InvalidPosition = "Xml_InvalidPosition";

		internal const string Xml_IncompleteEntity = "Xml_IncompleteEntity";

		internal const string Xml_IncompleteDtdContent = "Xml_IncompleteDtdContent";

		internal const string Xml_InvalidSurrogateHighChar = "Xml_InvalidSurrogateHighChar";

		internal const string Xml_InvalidSurrogateMissingLowChar = "Xml_InvalidSurrogateMissingLowChar";

		internal const string Xml_InvalidSurrogatePairWithArgs = "Xml_InvalidSurrogatePairWithArgs";

		internal const string Xml_SurrogatePairSplit = "Xml_SurrogatePairSplit";

		internal const string Xml_NoMultipleRoots = "Xml_NoMultipleRoots";

		internal const string Xml_RedefinePrefix = "Xml_RedefinePrefix";

		internal const string Xml_DtdAlreadyWritten = "Xml_DtdAlreadyWritten";

		internal const string XmlBadName = "XmlBadName";

		internal const string XmlNoNameAllowed = "XmlNoNameAllowed";

		internal const string Xml_InvalidCharsInIndent = "Xml_InvalidCharsInIndent";

		internal const string Xml_IndentCharsNotWhitespace = "Xml_IndentCharsNotWhitespace";

		internal const string Xml_ConformanceLevelFragment = "Xml_ConformanceLevelFragment";

		internal const string XmlDocument_ValidateInvalidNodeType = "XmlDocument_ValidateInvalidNodeType";

		internal const string XmlDocument_NodeNotFromDocument = "XmlDocument_NodeNotFromDocument";

		internal const string XmlDocument_NoNodeSchemaInfo = "XmlDocument_NoNodeSchemaInfo";

		internal const string XmlDocument_NoSchemaInfo = "XmlDocument_NoSchemaInfo";

		internal const string Sch_DefaultException = "Sch_DefaultException";

		internal const string Sch_ParEntityRefNesting = "Sch_ParEntityRefNesting";

		internal const string Sch_DupElementDecl = "Sch_DupElementDecl";

		internal const string Sch_IdAttrDeclared = "Sch_IdAttrDeclared";

		internal const string Sch_RootMatchDocType = "Sch_RootMatchDocType";

		internal const string Sch_DupId = "Sch_DupId";

		internal const string Sch_UndeclaredElement = "Sch_UndeclaredElement";

		internal const string Sch_UndeclaredAttribute = "Sch_UndeclaredAttribute";

		internal const string Sch_UndeclaredNotation = "Sch_UndeclaredNotation";

		internal const string Sch_UndeclaredId = "Sch_UndeclaredId";

		internal const string Sch_SchemaRootExpected = "Sch_SchemaRootExpected";

		internal const string Sch_XSDSchemaRootExpected = "Sch_XSDSchemaRootExpected";

		internal const string Sch_UnsupportedAttribute = "Sch_UnsupportedAttribute";

		internal const string Sch_UnsupportedElement = "Sch_UnsupportedElement";

		internal const string Sch_MissAttribute = "Sch_MissAttribute";

		internal const string Sch_AnnotationLocation = "Sch_AnnotationLocation";

		internal const string Sch_DataTypeTextOnly = "Sch_DataTypeTextOnly";

		internal const string Sch_UnknownModel = "Sch_UnknownModel";

		internal const string Sch_UnknownOrder = "Sch_UnknownOrder";

		internal const string Sch_UnknownContent = "Sch_UnknownContent";

		internal const string Sch_UnknownRequired = "Sch_UnknownRequired";

		internal const string Sch_UnknownDtType = "Sch_UnknownDtType";

		internal const string Sch_MixedMany = "Sch_MixedMany";

		internal const string Sch_GroupDisabled = "Sch_GroupDisabled";

		internal const string Sch_MissDtvalue = "Sch_MissDtvalue";

		internal const string Sch_MissDtvaluesAttribute = "Sch_MissDtvaluesAttribute";

		internal const string Sch_DupDtType = "Sch_DupDtType";

		internal const string Sch_DupAttribute = "Sch_DupAttribute";

		internal const string Sch_RequireEnumeration = "Sch_RequireEnumeration";

		internal const string Sch_DefaultIdValue = "Sch_DefaultIdValue";

		internal const string Sch_ElementNotAllowed = "Sch_ElementNotAllowed";

		internal const string Sch_ElementMissing = "Sch_ElementMissing";

		internal const string Sch_ManyMaxOccurs = "Sch_ManyMaxOccurs";

		internal const string Sch_MaxOccursInvalid = "Sch_MaxOccursInvalid";

		internal const string Sch_MinOccursInvalid = "Sch_MinOccursInvalid";

		internal const string Sch_DtMaxLengthInvalid = "Sch_DtMaxLengthInvalid";

		internal const string Sch_DtMinLengthInvalid = "Sch_DtMinLengthInvalid";

		internal const string Sch_DupDtMaxLength = "Sch_DupDtMaxLength";

		internal const string Sch_DupDtMinLength = "Sch_DupDtMinLength";

		internal const string Sch_DtMinMaxLength = "Sch_DtMinMaxLength";

		internal const string Sch_DupElement = "Sch_DupElement";

		internal const string Sch_DupGroupParticle = "Sch_DupGroupParticle";

		internal const string Sch_InvalidValue = "Sch_InvalidValue";

		internal const string Sch_InvalidValueDetailed = "Sch_InvalidValueDetailed";

		internal const string Sch_MissRequiredAttribute = "Sch_MissRequiredAttribute";

		internal const string Sch_FixedAttributeValue = "Sch_FixedAttributeValue";

		internal const string Sch_FixedElementValue = "Sch_FixedElementValue";

		internal const string Sch_AttributeValueDataTypeDetailed = "Sch_AttributeValueDataTypeDetailed";

		internal const string Sch_AttributeDefaultDataType = "Sch_AttributeDefaultDataType";

		internal const string Sch_IncludeLocation = "Sch_IncludeLocation";

		internal const string Sch_ImportLocation = "Sch_ImportLocation";

		internal const string Sch_RedefineLocation = "Sch_RedefineLocation";

		internal const string Sch_InvalidBlockDefaultValue = "Sch_InvalidBlockDefaultValue";

		internal const string Sch_InvalidFinalDefaultValue = "Sch_InvalidFinalDefaultValue";

		internal const string Sch_InvalidElementBlockValue = "Sch_InvalidElementBlockValue";

		internal const string Sch_InvalidElementFinalValue = "Sch_InvalidElementFinalValue";

		internal const string Sch_InvalidSimpleTypeFinalValue = "Sch_InvalidSimpleTypeFinalValue";

		internal const string Sch_InvalidComplexTypeBlockValue = "Sch_InvalidComplexTypeBlockValue";

		internal const string Sch_InvalidComplexTypeFinalValue = "Sch_InvalidComplexTypeFinalValue";

		internal const string Sch_DupIdentityConstraint = "Sch_DupIdentityConstraint";

		internal const string Sch_DupGlobalElement = "Sch_DupGlobalElement";

		internal const string Sch_DupGlobalAttribute = "Sch_DupGlobalAttribute";

		internal const string Sch_DupSimpleType = "Sch_DupSimpleType";

		internal const string Sch_DupComplexType = "Sch_DupComplexType";

		internal const string Sch_DupGroup = "Sch_DupGroup";

		internal const string Sch_DupAttributeGroup = "Sch_DupAttributeGroup";

		internal const string Sch_DupNotation = "Sch_DupNotation";

		internal const string Sch_DefaultFixedAttributes = "Sch_DefaultFixedAttributes";

		internal const string Sch_FixedInRef = "Sch_FixedInRef";

		internal const string Sch_FixedDefaultInRef = "Sch_FixedDefaultInRef";

		internal const string Sch_DupXsdElement = "Sch_DupXsdElement";

		internal const string Sch_ForbiddenAttribute = "Sch_ForbiddenAttribute";

		internal const string Sch_AttributeIgnored = "Sch_AttributeIgnored";

		internal const string Sch_ElementRef = "Sch_ElementRef";

		internal const string Sch_TypeMutualExclusive = "Sch_TypeMutualExclusive";

		internal const string Sch_ElementNameRef = "Sch_ElementNameRef";

		internal const string Sch_AttributeNameRef = "Sch_AttributeNameRef";

		internal const string Sch_TextNotAllowed = "Sch_TextNotAllowed";

		internal const string Sch_UndeclaredType = "Sch_UndeclaredType";

		internal const string Sch_UndeclaredSimpleType = "Sch_UndeclaredSimpleType";

		internal const string Sch_UndeclaredEquivClass = "Sch_UndeclaredEquivClass";

		internal const string Sch_AttListPresence = "Sch_AttListPresence";

		internal const string Sch_NotationValue = "Sch_NotationValue";

		internal const string Sch_EnumerationValue = "Sch_EnumerationValue";

		internal const string Sch_EmptyAttributeValue = "Sch_EmptyAttributeValue";

		internal const string Sch_InvalidLanguageId = "Sch_InvalidLanguageId";

		internal const string Sch_XmlSpace = "Sch_XmlSpace";

		internal const string Sch_InvalidXsdAttributeValue = "Sch_InvalidXsdAttributeValue";

		internal const string Sch_InvalidXsdAttributeDatatypeValue = "Sch_InvalidXsdAttributeDatatypeValue";

		internal const string Sch_ElementValueDataTypeDetailed = "Sch_ElementValueDataTypeDetailed";

		internal const string Sch_InvalidElementDefaultValue = "Sch_InvalidElementDefaultValue";

		internal const string Sch_NonDeterministic = "Sch_NonDeterministic";

		internal const string Sch_NonDeterministicAnyEx = "Sch_NonDeterministicAnyEx";

		internal const string Sch_NonDeterministicAnyAny = "Sch_NonDeterministicAnyAny";

		internal const string Sch_StandAlone = "Sch_StandAlone";

		internal const string Sch_XmlNsAttribute = "Sch_XmlNsAttribute";

		internal const string Sch_AllElement = "Sch_AllElement";

		internal const string Sch_MismatchTargetNamespaceInclude = "Sch_MismatchTargetNamespaceInclude";

		internal const string Sch_MismatchTargetNamespaceImport = "Sch_MismatchTargetNamespaceImport";

		internal const string Sch_MismatchTargetNamespaceEx = "Sch_MismatchTargetNamespaceEx";

		internal const string Sch_XsiTypeNotFound = "Sch_XsiTypeNotFound";

		internal const string Sch_XsiTypeAbstract = "Sch_XsiTypeAbstract";

		internal const string Sch_ListFromNonatomic = "Sch_ListFromNonatomic";

		internal const string Sch_UnionFromUnion = "Sch_UnionFromUnion";

		internal const string Sch_DupLengthFacet = "Sch_DupLengthFacet";

		internal const string Sch_DupMinLengthFacet = "Sch_DupMinLengthFacet";

		internal const string Sch_DupMaxLengthFacet = "Sch_DupMaxLengthFacet";

		internal const string Sch_DupWhiteSpaceFacet = "Sch_DupWhiteSpaceFacet";

		internal const string Sch_DupMaxInclusiveFacet = "Sch_DupMaxInclusiveFacet";

		internal const string Sch_DupMaxExclusiveFacet = "Sch_DupMaxExclusiveFacet";

		internal const string Sch_DupMinInclusiveFacet = "Sch_DupMinInclusiveFacet";

		internal const string Sch_DupMinExclusiveFacet = "Sch_DupMinExclusiveFacet";

		internal const string Sch_DupTotalDigitsFacet = "Sch_DupTotalDigitsFacet";

		internal const string Sch_DupFractionDigitsFacet = "Sch_DupFractionDigitsFacet";

		internal const string Sch_LengthFacetProhibited = "Sch_LengthFacetProhibited";

		internal const string Sch_MinLengthFacetProhibited = "Sch_MinLengthFacetProhibited";

		internal const string Sch_MaxLengthFacetProhibited = "Sch_MaxLengthFacetProhibited";

		internal const string Sch_PatternFacetProhibited = "Sch_PatternFacetProhibited";

		internal const string Sch_EnumerationFacetProhibited = "Sch_EnumerationFacetProhibited";

		internal const string Sch_WhiteSpaceFacetProhibited = "Sch_WhiteSpaceFacetProhibited";

		internal const string Sch_MaxInclusiveFacetProhibited = "Sch_MaxInclusiveFacetProhibited";

		internal const string Sch_MaxExclusiveFacetProhibited = "Sch_MaxExclusiveFacetProhibited";

		internal const string Sch_MinInclusiveFacetProhibited = "Sch_MinInclusiveFacetProhibited";

		internal const string Sch_MinExclusiveFacetProhibited = "Sch_MinExclusiveFacetProhibited";

		internal const string Sch_TotalDigitsFacetProhibited = "Sch_TotalDigitsFacetProhibited";

		internal const string Sch_FractionDigitsFacetProhibited = "Sch_FractionDigitsFacetProhibited";

		internal const string Sch_LengthFacetInvalid = "Sch_LengthFacetInvalid";

		internal const string Sch_MinLengthFacetInvalid = "Sch_MinLengthFacetInvalid";

		internal const string Sch_MaxLengthFacetInvalid = "Sch_MaxLengthFacetInvalid";

		internal const string Sch_MaxInclusiveFacetInvalid = "Sch_MaxInclusiveFacetInvalid";

		internal const string Sch_MaxExclusiveFacetInvalid = "Sch_MaxExclusiveFacetInvalid";

		internal const string Sch_MinInclusiveFacetInvalid = "Sch_MinInclusiveFacetInvalid";

		internal const string Sch_MinExclusiveFacetInvalid = "Sch_MinExclusiveFacetInvalid";

		internal const string Sch_TotalDigitsFacetInvalid = "Sch_TotalDigitsFacetInvalid";

		internal const string Sch_FractionDigitsFacetInvalid = "Sch_FractionDigitsFacetInvalid";

		internal const string Sch_PatternFacetInvalid = "Sch_PatternFacetInvalid";

		internal const string Sch_EnumerationFacetInvalid = "Sch_EnumerationFacetInvalid";

		internal const string Sch_InvalidWhiteSpace = "Sch_InvalidWhiteSpace";

		internal const string Sch_UnknownFacet = "Sch_UnknownFacet";

		internal const string Sch_LengthAndMinMax = "Sch_LengthAndMinMax";

		internal const string Sch_MinLengthGtMaxLength = "Sch_MinLengthGtMaxLength";

		internal const string Sch_FractionDigitsGtTotalDigits = "Sch_FractionDigitsGtTotalDigits";

		internal const string Sch_LengthConstraintFailed = "Sch_LengthConstraintFailed";

		internal const string Sch_MinLengthConstraintFailed = "Sch_MinLengthConstraintFailed";

		internal const string Sch_MaxLengthConstraintFailed = "Sch_MaxLengthConstraintFailed";

		internal const string Sch_PatternConstraintFailed = "Sch_PatternConstraintFailed";

		internal const string Sch_EnumerationConstraintFailed = "Sch_EnumerationConstraintFailed";

		internal const string Sch_MaxInclusiveConstraintFailed = "Sch_MaxInclusiveConstraintFailed";

		internal const string Sch_MaxExclusiveConstraintFailed = "Sch_MaxExclusiveConstraintFailed";

		internal const string Sch_MinInclusiveConstraintFailed = "Sch_MinInclusiveConstraintFailed";

		internal const string Sch_MinExclusiveConstraintFailed = "Sch_MinExclusiveConstraintFailed";

		internal const string Sch_TotalDigitsConstraintFailed = "Sch_TotalDigitsConstraintFailed";

		internal const string Sch_FractionDigitsConstraintFailed = "Sch_FractionDigitsConstraintFailed";

		internal const string Sch_UnionFailedEx = "Sch_UnionFailedEx";

		internal const string Sch_NotationRequired = "Sch_NotationRequired";

		internal const string Sch_DupNotationAttribute = "Sch_DupNotationAttribute";

		internal const string Sch_MissingPublicSystemAttribute = "Sch_MissingPublicSystemAttribute";

		internal const string Sch_NotationAttributeOnEmptyElement = "Sch_NotationAttributeOnEmptyElement";

		internal const string Sch_RefNotInScope = "Sch_RefNotInScope";

		internal const string Sch_UndeclaredIdentityConstraint = "Sch_UndeclaredIdentityConstraint";

		internal const string Sch_RefInvalidIdentityConstraint = "Sch_RefInvalidIdentityConstraint";

		internal const string Sch_RefInvalidCardin = "Sch_RefInvalidCardin";

		internal const string Sch_ReftoKeyref = "Sch_ReftoKeyref";

		internal const string Sch_EmptyXPath = "Sch_EmptyXPath";

		internal const string Sch_UnresolvedPrefix = "Sch_UnresolvedPrefix";

		internal const string Sch_UnresolvedKeyref = "Sch_UnresolvedKeyref";

		internal const string Sch_ICXpathError = "Sch_ICXpathError";

		internal const string Sch_SelectorAttr = "Sch_SelectorAttr";

		internal const string Sch_FieldSimpleTypeExpected = "Sch_FieldSimpleTypeExpected";

		internal const string Sch_FieldSingleValueExpected = "Sch_FieldSingleValueExpected";

		internal const string Sch_MissingKey = "Sch_MissingKey";

		internal const string Sch_DuplicateKey = "Sch_DuplicateKey";

		internal const string Sch_TargetNamespaceXsi = "Sch_TargetNamespaceXsi";

		internal const string Sch_UndeclaredEntity = "Sch_UndeclaredEntity";

		internal const string Sch_UnparsedEntityRef = "Sch_UnparsedEntityRef";

		internal const string Sch_MaxOccursInvalidXsd = "Sch_MaxOccursInvalidXsd";

		internal const string Sch_MinOccursInvalidXsd = "Sch_MinOccursInvalidXsd";

		internal const string Sch_MaxInclusiveExclusive = "Sch_MaxInclusiveExclusive";

		internal const string Sch_MinInclusiveExclusive = "Sch_MinInclusiveExclusive";

		internal const string Sch_MinInclusiveGtMaxInclusive = "Sch_MinInclusiveGtMaxInclusive";

		internal const string Sch_MinExclusiveGtMaxExclusive = "Sch_MinExclusiveGtMaxExclusive";

		internal const string Sch_MinInclusiveGtMaxExclusive = "Sch_MinInclusiveGtMaxExclusive";

		internal const string Sch_MinExclusiveGtMaxInclusive = "Sch_MinExclusiveGtMaxInclusive";

		internal const string Sch_SimpleTypeRestriction = "Sch_SimpleTypeRestriction";

		internal const string Sch_InvalidFacetPosition = "Sch_InvalidFacetPosition";

		internal const string Sch_AttributeMutuallyExclusive = "Sch_AttributeMutuallyExclusive";

		internal const string Sch_AnyAttributeLastChild = "Sch_AnyAttributeLastChild";

		internal const string Sch_ComplexTypeContentModel = "Sch_ComplexTypeContentModel";

		internal const string Sch_ComplexContentContentModel = "Sch_ComplexContentContentModel";

		internal const string Sch_NotNormalizedString = "Sch_NotNormalizedString";

		internal const string Sch_NotTokenString = "Sch_NotTokenString";

		internal const string Sch_FractionDigitsNotOnDecimal = "Sch_FractionDigitsNotOnDecimal";

		internal const string Sch_ContentInNill = "Sch_ContentInNill";

		internal const string Sch_NoElementSchemaFound = "Sch_NoElementSchemaFound";

		internal const string Sch_NoAttributeSchemaFound = "Sch_NoAttributeSchemaFound";

		internal const string Sch_InvalidNamespace = "Sch_InvalidNamespace";

		internal const string Sch_InvalidTargetNamespaceAttribute = "Sch_InvalidTargetNamespaceAttribute";

		internal const string Sch_InvalidNamespaceAttribute = "Sch_InvalidNamespaceAttribute";

		internal const string Sch_InvalidSchemaLocation = "Sch_InvalidSchemaLocation";

		internal const string Sch_ImportTargetNamespace = "Sch_ImportTargetNamespace";

		internal const string Sch_ImportTargetNamespaceNull = "Sch_ImportTargetNamespaceNull";

		internal const string Sch_GroupDoubleRedefine = "Sch_GroupDoubleRedefine";

		internal const string Sch_ComponentRedefineNotFound = "Sch_ComponentRedefineNotFound";

		internal const string Sch_GroupRedefineNotFound = "Sch_GroupRedefineNotFound";

		internal const string Sch_AttrGroupDoubleRedefine = "Sch_AttrGroupDoubleRedefine";

		internal const string Sch_AttrGroupRedefineNotFound = "Sch_AttrGroupRedefineNotFound";

		internal const string Sch_ComplexTypeDoubleRedefine = "Sch_ComplexTypeDoubleRedefine";

		internal const string Sch_ComplexTypeRedefineNotFound = "Sch_ComplexTypeRedefineNotFound";

		internal const string Sch_SimpleToComplexTypeRedefine = "Sch_SimpleToComplexTypeRedefine";

		internal const string Sch_SimpleTypeDoubleRedefine = "Sch_SimpleTypeDoubleRedefine";

		internal const string Sch_ComplexToSimpleTypeRedefine = "Sch_ComplexToSimpleTypeRedefine";

		internal const string Sch_SimpleTypeRedefineNotFound = "Sch_SimpleTypeRedefineNotFound";

		internal const string Sch_MinMaxGroupRedefine = "Sch_MinMaxGroupRedefine";

		internal const string Sch_MultipleGroupSelfRef = "Sch_MultipleGroupSelfRef";

		internal const string Sch_MultipleAttrGroupSelfRef = "Sch_MultipleAttrGroupSelfRef";

		internal const string Sch_InvalidTypeRedefine = "Sch_InvalidTypeRedefine";

		internal const string Sch_InvalidElementRef = "Sch_InvalidElementRef";

		internal const string Sch_MinGtMax = "Sch_MinGtMax";

		internal const string Sch_DupSelector = "Sch_DupSelector";

		internal const string Sch_IdConstraintNoSelector = "Sch_IdConstraintNoSelector";

		internal const string Sch_IdConstraintNoFields = "Sch_IdConstraintNoFields";

		internal const string Sch_IdConstraintNoRefer = "Sch_IdConstraintNoRefer";

		internal const string Sch_SelectorBeforeFields = "Sch_SelectorBeforeFields";

		internal const string Sch_NoSimpleTypeContent = "Sch_NoSimpleTypeContent";

		internal const string Sch_SimpleTypeRestRefBase = "Sch_SimpleTypeRestRefBase";

		internal const string Sch_SimpleTypeRestRefBaseNone = "Sch_SimpleTypeRestRefBaseNone";

		internal const string Sch_SimpleTypeListRefBase = "Sch_SimpleTypeListRefBase";

		internal const string Sch_SimpleTypeListRefBaseNone = "Sch_SimpleTypeListRefBaseNone";

		internal const string Sch_SimpleTypeUnionNoBase = "Sch_SimpleTypeUnionNoBase";

		internal const string Sch_NoRestOrExtQName = "Sch_NoRestOrExtQName";

		internal const string Sch_NoRestOrExt = "Sch_NoRestOrExt";

		internal const string Sch_NoGroupParticle = "Sch_NoGroupParticle";

		internal const string Sch_InvalidAllMin = "Sch_InvalidAllMin";

		internal const string Sch_InvalidAllMax = "Sch_InvalidAllMax";

		internal const string Sch_InvalidFacet = "Sch_InvalidFacet";

		internal const string Sch_AbstractElement = "Sch_AbstractElement";

		internal const string Sch_XsiTypeBlockedEx = "Sch_XsiTypeBlockedEx";

		internal const string Sch_InvalidXsiNill = "Sch_InvalidXsiNill";

		internal const string Sch_SubstitutionNotAllowed = "Sch_SubstitutionNotAllowed";

		internal const string Sch_SubstitutionBlocked = "Sch_SubstitutionBlocked";

		internal const string Sch_InvalidElementInEmptyEx = "Sch_InvalidElementInEmptyEx";

		internal const string Sch_InvalidElementInTextOnlyEx = "Sch_InvalidElementInTextOnlyEx";

		internal const string Sch_InvalidTextInElement = "Sch_InvalidTextInElement";

		internal const string Sch_InvalidElementContent = "Sch_InvalidElementContent";

		internal const string Sch_InvalidElementContentComplex = "Sch_InvalidElementContentComplex";

		internal const string Sch_IncompleteContent = "Sch_IncompleteContent";

		internal const string Sch_IncompleteContentComplex = "Sch_IncompleteContentComplex";

		internal const string Sch_InvalidTextInElementExpecting = "Sch_InvalidTextInElementExpecting";

		internal const string Sch_InvalidElementContentExpecting = "Sch_InvalidElementContentExpecting";

		internal const string Sch_InvalidElementContentExpectingComplex = "Sch_InvalidElementContentExpectingComplex";

		internal const string Sch_IncompleteContentExpecting = "Sch_IncompleteContentExpecting";

		internal const string Sch_IncompleteContentExpectingComplex = "Sch_IncompleteContentExpectingComplex";

		internal const string Sch_InvalidElementSubstitution = "Sch_InvalidElementSubstitution";

		internal const string Sch_ElementNameAndNamespace = "Sch_ElementNameAndNamespace";

		internal const string Sch_ElementName = "Sch_ElementName";

		internal const string Sch_ContinuationString = "Sch_ContinuationString";

		internal const string Sch_AnyElementNS = "Sch_AnyElementNS";

		internal const string Sch_AnyElement = "Sch_AnyElement";

		internal const string Sch_InvalidTextInEmpty = "Sch_InvalidTextInEmpty";

		internal const string Sch_InvalidWhitespaceInEmpty = "Sch_InvalidWhitespaceInEmpty";

		internal const string Sch_InvalidPIComment = "Sch_InvalidPIComment";

		internal const string Sch_InvalidAttributeRef = "Sch_InvalidAttributeRef";

		internal const string Sch_OptionalDefaultAttribute = "Sch_OptionalDefaultAttribute";

		internal const string Sch_AttributeCircularRef = "Sch_AttributeCircularRef";

		internal const string Sch_IdentityConstraintCircularRef = "Sch_IdentityConstraintCircularRef";

		internal const string Sch_SubstitutionCircularRef = "Sch_SubstitutionCircularRef";

		internal const string Sch_InvalidAnyAttribute = "Sch_InvalidAnyAttribute";

		internal const string Sch_DupIdAttribute = "Sch_DupIdAttribute";

		internal const string Sch_InvalidAllElementMax = "Sch_InvalidAllElementMax";

		internal const string Sch_InvalidAny = "Sch_InvalidAny";

		internal const string Sch_InvalidAnyDetailed = "Sch_InvalidAnyDetailed";

		internal const string Sch_InvalidExamplar = "Sch_InvalidExamplar";

		internal const string Sch_NoExamplar = "Sch_NoExamplar";

		internal const string Sch_InvalidSubstitutionMember = "Sch_InvalidSubstitutionMember";

		internal const string Sch_RedefineNoSchema = "Sch_RedefineNoSchema";

		internal const string Sch_ProhibitedAttribute = "Sch_ProhibitedAttribute";

		internal const string Sch_TypeCircularRef = "Sch_TypeCircularRef";

		internal const string Sch_TwoIdAttrUses = "Sch_TwoIdAttrUses";

		internal const string Sch_AttrUseAndWildId = "Sch_AttrUseAndWildId";

		internal const string Sch_MoreThanOneWildId = "Sch_MoreThanOneWildId";

		internal const string Sch_BaseFinalExtension = "Sch_BaseFinalExtension";

		internal const string Sch_NotSimpleContent = "Sch_NotSimpleContent";

		internal const string Sch_NotComplexContent = "Sch_NotComplexContent";

		internal const string Sch_BaseFinalRestriction = "Sch_BaseFinalRestriction";

		internal const string Sch_BaseFinalList = "Sch_BaseFinalList";

		internal const string Sch_BaseFinalUnion = "Sch_BaseFinalUnion";

		internal const string Sch_UndefBaseRestriction = "Sch_UndefBaseRestriction";

		internal const string Sch_UndefBaseExtension = "Sch_UndefBaseExtension";

		internal const string Sch_DifContentType = "Sch_DifContentType";

		internal const string Sch_InvalidContentRestriction = "Sch_InvalidContentRestriction";

		internal const string Sch_InvalidContentRestrictionDetailed = "Sch_InvalidContentRestrictionDetailed";

		internal const string Sch_InvalidBaseToEmpty = "Sch_InvalidBaseToEmpty";

		internal const string Sch_InvalidBaseToMixed = "Sch_InvalidBaseToMixed";

		internal const string Sch_DupAttributeUse = "Sch_DupAttributeUse";

		internal const string Sch_InvalidParticleRestriction = "Sch_InvalidParticleRestriction";

		internal const string Sch_InvalidParticleRestrictionDetailed = "Sch_InvalidParticleRestrictionDetailed";

		internal const string Sch_ForbiddenDerivedParticleForAll = "Sch_ForbiddenDerivedParticleForAll";

		internal const string Sch_ForbiddenDerivedParticleForElem = "Sch_ForbiddenDerivedParticleForElem";

		internal const string Sch_ForbiddenDerivedParticleForChoice = "Sch_ForbiddenDerivedParticleForChoice";

		internal const string Sch_ForbiddenDerivedParticleForSeq = "Sch_ForbiddenDerivedParticleForSeq";

		internal const string Sch_ElementFromElement = "Sch_ElementFromElement";

		internal const string Sch_ElementFromAnyRule1 = "Sch_ElementFromAnyRule1";

		internal const string Sch_ElementFromAnyRule2 = "Sch_ElementFromAnyRule2";

		internal const string Sch_AnyFromAnyRule1 = "Sch_AnyFromAnyRule1";

		internal const string Sch_AnyFromAnyRule2 = "Sch_AnyFromAnyRule2";

		internal const string Sch_AnyFromAnyRule3 = "Sch_AnyFromAnyRule3";

		internal const string Sch_GroupBaseFromAny1 = "Sch_GroupBaseFromAny1";

		internal const string Sch_GroupBaseFromAny2 = "Sch_GroupBaseFromAny2";

		internal const string Sch_ElementFromGroupBase1 = "Sch_ElementFromGroupBase1";

		internal const string Sch_ElementFromGroupBase2 = "Sch_ElementFromGroupBase2";

		internal const string Sch_ElementFromGroupBase3 = "Sch_ElementFromGroupBase3";

		internal const string Sch_GroupBaseRestRangeInvalid = "Sch_GroupBaseRestRangeInvalid";

		internal const string Sch_GroupBaseRestNoMap = "Sch_GroupBaseRestNoMap";

		internal const string Sch_GroupBaseRestNotEmptiable = "Sch_GroupBaseRestNotEmptiable";

		internal const string Sch_SeqFromAll = "Sch_SeqFromAll";

		internal const string Sch_SeqFromChoice = "Sch_SeqFromChoice";

		internal const string Sch_UndefGroupRef = "Sch_UndefGroupRef";

		internal const string Sch_GroupCircularRef = "Sch_GroupCircularRef";

		internal const string Sch_AllRefNotRoot = "Sch_AllRefNotRoot";

		internal const string Sch_AllRefMinMax = "Sch_AllRefMinMax";

		internal const string Sch_NotAllAlone = "Sch_NotAllAlone";

		internal const string Sch_AttributeGroupCircularRef = "Sch_AttributeGroupCircularRef";

		internal const string Sch_UndefAttributeGroupRef = "Sch_UndefAttributeGroupRef";

		internal const string Sch_InvalidAttributeExtension = "Sch_InvalidAttributeExtension";

		internal const string Sch_InvalidAnyAttributeRestriction = "Sch_InvalidAnyAttributeRestriction";

		internal const string Sch_AttributeRestrictionProhibited = "Sch_AttributeRestrictionProhibited";

		internal const string Sch_AttributeRestrictionInvalid = "Sch_AttributeRestrictionInvalid";

		internal const string Sch_AttributeFixedInvalid = "Sch_AttributeFixedInvalid";

		internal const string Sch_AttributeUseInvalid = "Sch_AttributeUseInvalid";

		internal const string Sch_AttributeRestrictionInvalidFromWildcard = "Sch_AttributeRestrictionInvalidFromWildcard";

		internal const string Sch_NoDerivedAttribute = "Sch_NoDerivedAttribute";

		internal const string Sch_UnexpressibleAnyAttribute = "Sch_UnexpressibleAnyAttribute";

		internal const string Sch_RefInvalidAttribute = "Sch_RefInvalidAttribute";

		internal const string Sch_ElementCircularRef = "Sch_ElementCircularRef";

		internal const string Sch_RefInvalidElement = "Sch_RefInvalidElement";

		internal const string Sch_ElementCannotHaveValue = "Sch_ElementCannotHaveValue";

		internal const string Sch_ElementInMixedWithFixed = "Sch_ElementInMixedWithFixed";

		internal const string Sch_ElementTypeCollision = "Sch_ElementTypeCollision";

		internal const string Sch_InvalidIncludeLocation = "Sch_InvalidIncludeLocation";

		internal const string Sch_CannotLoadSchema = "Sch_CannotLoadSchema";

		internal const string Sch_CannotLoadSchemaLocation = "Sch_CannotLoadSchemaLocation";

		internal const string Sch_LengthGtBaseLength = "Sch_LengthGtBaseLength";

		internal const string Sch_MinLengthGtBaseMinLength = "Sch_MinLengthGtBaseMinLength";

		internal const string Sch_MaxLengthGtBaseMaxLength = "Sch_MaxLengthGtBaseMaxLength";

		internal const string Sch_MaxMinLengthBaseLength = "Sch_MaxMinLengthBaseLength";

		internal const string Sch_MaxInclusiveMismatch = "Sch_MaxInclusiveMismatch";

		internal const string Sch_MaxExclusiveMismatch = "Sch_MaxExclusiveMismatch";

		internal const string Sch_MinInclusiveMismatch = "Sch_MinInclusiveMismatch";

		internal const string Sch_MinExclusiveMismatch = "Sch_MinExclusiveMismatch";

		internal const string Sch_MinExlIncMismatch = "Sch_MinExlIncMismatch";

		internal const string Sch_MinExlMaxExlMismatch = "Sch_MinExlMaxExlMismatch";

		internal const string Sch_MinIncMaxExlMismatch = "Sch_MinIncMaxExlMismatch";

		internal const string Sch_MinIncExlMismatch = "Sch_MinIncExlMismatch";

		internal const string Sch_MaxIncExlMismatch = "Sch_MaxIncExlMismatch";

		internal const string Sch_MaxExlIncMismatch = "Sch_MaxExlIncMismatch";

		internal const string Sch_TotalDigitsMismatch = "Sch_TotalDigitsMismatch";

		internal const string Sch_FacetBaseFixed = "Sch_FacetBaseFixed";

		internal const string Sch_WhiteSpaceRestriction1 = "Sch_WhiteSpaceRestriction1";

		internal const string Sch_WhiteSpaceRestriction2 = "Sch_WhiteSpaceRestriction2";

		internal const string Sch_UnSpecifiedDefaultAttributeInExternalStandalone = "Sch_UnSpecifiedDefaultAttributeInExternalStandalone";

		internal const string Sch_StandAloneNormalization = "Sch_StandAloneNormalization";

		internal const string Sch_XsiNilAndFixed = "Sch_XsiNilAndFixed";

		internal const string Sch_MixSchemaTypes = "Sch_MixSchemaTypes";

		internal const string Sch_XSDSchemaOnly = "Sch_XSDSchemaOnly";

		internal const string Sch_InvalidPublicAttribute = "Sch_InvalidPublicAttribute";

		internal const string Sch_InvalidSystemAttribute = "Sch_InvalidSystemAttribute";

		internal const string Sch_TypeAfterConstraints = "Sch_TypeAfterConstraints";

		internal const string Sch_XsiNilAndType = "Sch_XsiNilAndType";

		internal const string Sch_DupSimpleTypeChild = "Sch_DupSimpleTypeChild";

		internal const string Sch_InvalidIdAttribute = "Sch_InvalidIdAttribute";

		internal const string Sch_InvalidNameAttributeEx = "Sch_InvalidNameAttributeEx";

		internal const string Sch_InvalidAttribute = "Sch_InvalidAttribute";

		internal const string Sch_EmptyChoice = "Sch_EmptyChoice";

		internal const string Sch_DerivedNotFromBase = "Sch_DerivedNotFromBase";

		internal const string Sch_NeedSimpleTypeChild = "Sch_NeedSimpleTypeChild";

		internal const string Sch_InvalidCollection = "Sch_InvalidCollection";

		internal const string Sch_UnrefNS = "Sch_UnrefNS";

		internal const string Sch_InvalidSimpleTypeRestriction = "Sch_InvalidSimpleTypeRestriction";

		internal const string Sch_MultipleRedefine = "Sch_MultipleRedefine";

		internal const string Sch_NullValue = "Sch_NullValue";

		internal const string Sch_ComplexContentModel = "Sch_ComplexContentModel";

		internal const string Sch_SchemaNotPreprocessed = "Sch_SchemaNotPreprocessed";

		internal const string Sch_SchemaNotRemoved = "Sch_SchemaNotRemoved";

		internal const string Sch_ComponentAlreadySeenForNS = "Sch_ComponentAlreadySeenForNS";

		internal const string Sch_DefaultAttributeNotApplied = "Sch_DefaultAttributeNotApplied";

		internal const string Sch_NotXsiAttribute = "Sch_NotXsiAttribute";

		internal const string Sch_XsdDateTimeCompare = "Sch_XsdDateTimeCompare";

		internal const string Sch_InvalidNullCast = "Sch_InvalidNullCast";

		internal const string Sch_SchemaDoesNotExist = "Sch_SchemaDoesNotExist";

		internal const string Sch_InvalidDateTimeOption = "Sch_InvalidDateTimeOption";

		internal const string Sch_InvalidStartTransition = "Sch_InvalidStartTransition";

		internal const string Sch_InvalidStateTransition = "Sch_InvalidStateTransition";

		internal const string Sch_InvalidEndValidation = "Sch_InvalidEndValidation";

		internal const string Sch_InvalidEndElementCall = "Sch_InvalidEndElementCall";

		internal const string Sch_InvalidEndElementCallTyped = "Sch_InvalidEndElementCallTyped";

		internal const string Sch_InvalidEndElementMultiple = "Sch_InvalidEndElementMultiple";

		internal const string Sch_DuplicateAttribute = "Sch_DuplicateAttribute";

		internal const string Sch_InvalidPartialValidationType = "Sch_InvalidPartialValidationType";

		internal const string Sch_SchemaElementNameMismatch = "Sch_SchemaElementNameMismatch";

		internal const string Sch_SchemaAttributeNameMismatch = "Sch_SchemaAttributeNameMismatch";

		internal const string Sch_ValidateAttributeInvalidCall = "Sch_ValidateAttributeInvalidCall";

		internal const string Sch_ValidateElementInvalidCall = "Sch_ValidateElementInvalidCall";

		internal const string Sch_EnumNotStarted = "Sch_EnumNotStarted";

		internal const string Sch_EnumFinished = "Sch_EnumFinished";

		internal const string SchInf_schema = "SchInf_schema";

		internal const string SchInf_entity = "SchInf_entity";

		internal const string SchInf_simplecontent = "SchInf_simplecontent";

		internal const string SchInf_extension = "SchInf_extension";

		internal const string SchInf_particle = "SchInf_particle";

		internal const string SchInf_ct = "SchInf_ct";

		internal const string SchInf_seq = "SchInf_seq";

		internal const string SchInf_noseq = "SchInf_noseq";

		internal const string SchInf_noct = "SchInf_noct";

		internal const string SchInf_UnknownParticle = "SchInf_UnknownParticle";

		internal const string SchInf_schematype = "SchInf_schematype";

		internal const string SchInf_NoElement = "SchInf_NoElement";

		internal const string Xp_UnclosedString = "Xp_UnclosedString";

		internal const string Xp_ExprExpected = "Xp_ExprExpected";

		internal const string Xp_InvalidArgumentType = "Xp_InvalidArgumentType";

		internal const string Xp_InvalidNumArgs = "Xp_InvalidNumArgs";

		internal const string Xp_InvalidName = "Xp_InvalidName";

		internal const string Xp_InvalidToken = "Xp_InvalidToken";

		internal const string Xp_NodeSetExpected = "Xp_NodeSetExpected";

		internal const string Xp_NotSupported = "Xp_NotSupported";

		internal const string Xp_InvalidPattern = "Xp_InvalidPattern";

		internal const string Xp_InvalidKeyPattern = "Xp_InvalidKeyPattern";

		internal const string Xp_BadQueryObject = "Xp_BadQueryObject";

		internal const string Xp_UndefinedXsltContext = "Xp_UndefinedXsltContext";

		internal const string Xp_NoContext = "Xp_NoContext";

		internal const string Xp_UndefVar = "Xp_UndefVar";

		internal const string Xp_UndefFunc = "Xp_UndefFunc";

		internal const string Xp_FunctionFailed = "Xp_FunctionFailed";

		internal const string Xp_CurrentNotAllowed = "Xp_CurrentNotAllowed";

		internal const string Xdom_DualDocumentTypeNode = "Xdom_DualDocumentTypeNode";

		internal const string Xdom_DualDocumentElementNode = "Xdom_DualDocumentElementNode";

		internal const string Xdom_DualDeclarationNode = "Xdom_DualDeclarationNode";

		internal const string Xdom_Import = "Xdom_Import";

		internal const string Xdom_Import_NullNode = "Xdom_Import_NullNode";

		internal const string Xdom_NoRootEle = "Xdom_NoRootEle";

		internal const string Xdom_Attr_Name = "Xdom_Attr_Name";

		internal const string Xdom_AttrCol_Object = "Xdom_AttrCol_Object";

		internal const string Xdom_AttrCol_Insert = "Xdom_AttrCol_Insert";

		internal const string Xdom_NamedNode_Context = "Xdom_NamedNode_Context";

		internal const string Xdom_Version = "Xdom_Version";

		internal const string Xdom_standalone = "Xdom_standalone";

		internal const string Xdom_Ele_Prefix = "Xdom_Ele_Prefix";

		internal const string Xdom_Ent_Innertext = "Xdom_Ent_Innertext";

		internal const string Xdom_EntRef_SetVal = "Xdom_EntRef_SetVal";

		internal const string Xdom_WS_Char = "Xdom_WS_Char";

		internal const string Xdom_Node_SetVal = "Xdom_Node_SetVal";

		internal const string Xdom_Empty_LocalName = "Xdom_Empty_LocalName";

		internal const string Xdom_Set_InnerXml = "Xdom_Set_InnerXml";

		internal const string Xdom_Attr_InUse = "Xdom_Attr_InUse";

		internal const string Xdom_Enum_ElementList = "Xdom_Enum_ElementList";

		internal const string Xdom_Invalid_NT_String = "Xdom_Invalid_NT_String";

		internal const string Xdom_InvalidCharacter_EntityReference = "Xdom_InvalidCharacter_EntityReference";

		internal const string Xdom_IndexOutOfRange = "Xdom_IndexOutOfRange";

		internal const string Xpn_BadPosition = "Xpn_BadPosition";

		internal const string Xpn_MissingParent = "Xpn_MissingParent";

		internal const string Xpn_NoContent = "Xpn_NoContent";

		internal const string Xdom_Load_NoDocument = "Xdom_Load_NoDocument";

		internal const string Xdom_Load_NoReader = "Xdom_Load_NoReader";

		internal const string Xdom_Node_Null_Doc = "Xdom_Node_Null_Doc";

		internal const string Xdom_Node_Insert_Child = "Xdom_Node_Insert_Child";

		internal const string Xdom_Node_Insert_Contain = "Xdom_Node_Insert_Contain";

		internal const string Xdom_Node_Insert_Path = "Xdom_Node_Insert_Path";

		internal const string Xdom_Node_Insert_Context = "Xdom_Node_Insert_Context";

		internal const string Xdom_Node_Insert_Location = "Xdom_Node_Insert_Location";

		internal const string Xdom_Node_Insert_TypeConflict = "Xdom_Node_Insert_TypeConflict";

		internal const string Xdom_Node_Remove_Contain = "Xdom_Node_Remove_Contain";

		internal const string Xdom_Node_Remove_Child = "Xdom_Node_Remove_Child";

		internal const string Xdom_Node_Modify_ReadOnly = "Xdom_Node_Modify_ReadOnly";

		internal const string Xdom_TextNode_SplitText = "Xdom_TextNode_SplitText";

		internal const string Xdom_Attr_Reserved_XmlNS = "Xdom_Attr_Reserved_XmlNS";

		internal const string Xdom_Node_Cloning = "Xdom_Node_Cloning";

		internal const string Xnr_ResolveEntity = "Xnr_ResolveEntity";

		internal const string XmlMissingType = "XmlMissingType";

		internal const string XmlUnsupportedType = "XmlUnsupportedType";

		internal const string XmlSerializerUnsupportedType = "XmlSerializerUnsupportedType";

		internal const string XmlSerializerUnsupportedMember = "XmlSerializerUnsupportedMember";

		internal const string XmlUnsupportedTypeKind = "XmlUnsupportedTypeKind";

		internal const string XmlUnsupportedSoapTypeKind = "XmlUnsupportedSoapTypeKind";

		internal const string XmlUnsupportedIDictionary = "XmlUnsupportedIDictionary";

		internal const string XmlUnsupportedIDictionaryDetails = "XmlUnsupportedIDictionaryDetails";

		internal const string XmlDuplicateTypeName = "XmlDuplicateTypeName";

		internal const string XmlSerializableNameMissing1 = "XmlSerializableNameMissing1";

		internal const string XmlConstructorInaccessible = "XmlConstructorInaccessible";

		internal const string XmlTypeInaccessible = "XmlTypeInaccessible";

		internal const string XmlTypeStatic = "XmlTypeStatic";

		internal const string XmlNoDefaultAccessors = "XmlNoDefaultAccessors";

		internal const string XmlNoAddMethod = "XmlNoAddMethod";

		internal const string XmlAttributeSetAgain = "XmlAttributeSetAgain";

		internal const string XmlIllegalWildcard = "XmlIllegalWildcard";

		internal const string XmlIllegalArrayElement = "XmlIllegalArrayElement";

		internal const string XmlIllegalForm = "XmlIllegalForm";

		internal const string XmlBareTextMember = "XmlBareTextMember";

		internal const string XmlBareAttributeMember = "XmlBareAttributeMember";

		internal const string XmlReflectionError = "XmlReflectionError";

		internal const string XmlTypeReflectionError = "XmlTypeReflectionError";

		internal const string XmlPropertyReflectionError = "XmlPropertyReflectionError";

		internal const string XmlFieldReflectionError = "XmlFieldReflectionError";

		internal const string XmlInvalidDataTypeUsage = "XmlInvalidDataTypeUsage";

		internal const string XmlInvalidXsdDataType = "XmlInvalidXsdDataType";

		internal const string XmlDataTypeMismatch = "XmlDataTypeMismatch";

		internal const string XmlIllegalTypeContext = "XmlIllegalTypeContext";

		internal const string XmlUdeclaredXsdType = "XmlUdeclaredXsdType";

		internal const string XmlAnyElementNamespace = "XmlAnyElementNamespace";

		internal const string XmlInvalidConstantAttribute = "XmlInvalidConstantAttribute";

		internal const string XmlIllegalDefault = "XmlIllegalDefault";

		internal const string XmlIllegalAttributesArrayAttribute = "XmlIllegalAttributesArrayAttribute";

		internal const string XmlIllegalElementsArrayAttribute = "XmlIllegalElementsArrayAttribute";

		internal const string XmlIllegalArrayArrayAttribute = "XmlIllegalArrayArrayAttribute";

		internal const string XmlIllegalAttribute = "XmlIllegalAttribute";

		internal const string XmlIllegalType = "XmlIllegalType";

		internal const string XmlIllegalAttrOrText = "XmlIllegalAttrOrText";

		internal const string XmlIllegalSoapAttribute = "XmlIllegalSoapAttribute";

		internal const string XmlIllegalAttrOrTextInterface = "XmlIllegalAttrOrTextInterface";

		internal const string XmlIllegalAttributeFlagsArray = "XmlIllegalAttributeFlagsArray";

		internal const string XmlIllegalAnyElement = "XmlIllegalAnyElement";

		internal const string XmlInvalidIsNullable = "XmlInvalidIsNullable";

		internal const string XmlInvalidNotNullable = "XmlInvalidNotNullable";

		internal const string XmlInvalidFormUnqualified = "XmlInvalidFormUnqualified";

		internal const string XmlDuplicateNamespace = "XmlDuplicateNamespace";

		internal const string XmlElementHasNoName = "XmlElementHasNoName";

		internal const string XmlAttributeHasNoName = "XmlAttributeHasNoName";

		internal const string XmlElementImportedTwice = "XmlElementImportedTwice";

		internal const string XmlHiddenMember = "XmlHiddenMember";

		internal const string XmlInvalidXmlOverride = "XmlInvalidXmlOverride";

		internal const string XmlMembersDeriveError = "XmlMembersDeriveError";

		internal const string XmlTypeUsedTwice = "XmlTypeUsedTwice";

		internal const string XmlMissingGroup = "XmlMissingGroup";

		internal const string XmlMissingAttributeGroup = "XmlMissingAttributeGroup";

		internal const string XmlMissingDataType = "XmlMissingDataType";

		internal const string XmlInvalidEncoding = "XmlInvalidEncoding";

		internal const string XmlMissingElement = "XmlMissingElement";

		internal const string XmlMissingAttribute = "XmlMissingAttribute";

		internal const string XmlMissingMethodEnum = "XmlMissingMethodEnum";

		internal const string XmlNoAttributeHere = "XmlNoAttributeHere";

		internal const string XmlNeedAttributeHere = "XmlNeedAttributeHere";

		internal const string XmlElementNameMismatch = "XmlElementNameMismatch";

		internal const string XmlUnsupportedDefaultType = "XmlUnsupportedDefaultType";

		internal const string XmlUnsupportedDefaultValue = "XmlUnsupportedDefaultValue";

		internal const string XmlInvalidDefaultValue = "XmlInvalidDefaultValue";

		internal const string XmlInvalidDefaultEnumValue = "XmlInvalidDefaultEnumValue";

		internal const string XmlUnknownNode = "XmlUnknownNode";

		internal const string XmlUnknownConstant = "XmlUnknownConstant";

		internal const string XmlSerializeError = "XmlSerializeError";

		internal const string XmlSerializeErrorDetails = "XmlSerializeErrorDetails";

		internal const string XmlCompilerError = "XmlCompilerError";

		internal const string XmlSchemaDuplicateNamespace = "XmlSchemaDuplicateNamespace";

		internal const string XmlSchemaCompiled = "XmlSchemaCompiled";

		internal const string XmlInvalidSchemaExtension = "XmlInvalidSchemaExtension";

		internal const string XmlInvalidArrayDimentions = "XmlInvalidArrayDimentions";

		internal const string XmlInvalidArrayTypeName = "XmlInvalidArrayTypeName";

		internal const string XmlInvalidArrayTypeNamespace = "XmlInvalidArrayTypeNamespace";

		internal const string XmlMissingArrayType = "XmlMissingArrayType";

		internal const string XmlEmptyArrayType = "XmlEmptyArrayType";

		internal const string XmlInvalidArraySyntax = "XmlInvalidArraySyntax";

		internal const string XmlInvalidArrayTypeSyntax = "XmlInvalidArrayTypeSyntax";

		internal const string XmlMismatchedArrayBrackets = "XmlMismatchedArrayBrackets";

		internal const string XmlInvalidArrayLength = "XmlInvalidArrayLength";

		internal const string XmlMissingHref = "XmlMissingHref";

		internal const string XmlInvalidHref = "XmlInvalidHref";

		internal const string XmlUnknownType = "XmlUnknownType";

		internal const string XmlAbstractType = "XmlAbstractType";

		internal const string XmlMappingsScopeMismatch = "XmlMappingsScopeMismatch";

		internal const string XmlMethodTypeNameConflict = "XmlMethodTypeNameConflict";

		internal const string XmlCannotReconcileAccessor = "XmlCannotReconcileAccessor";

		internal const string XmlCannotReconcileAttributeAccessor = "XmlCannotReconcileAttributeAccessor";

		internal const string XmlCannotReconcileAccessorDefault = "XmlCannotReconcileAccessorDefault";

		internal const string XmlInvalidTypeAttributes = "XmlInvalidTypeAttributes";

		internal const string XmlInvalidAttributeUse = "XmlInvalidAttributeUse";

		internal const string XmlTypesDuplicate = "XmlTypesDuplicate";

		internal const string XmlInvalidSoapArray = "XmlInvalidSoapArray";

		internal const string XmlCannotIncludeInSchema = "XmlCannotIncludeInSchema";

		internal const string XmlSoapCannotIncludeInSchema = "XmlSoapCannotIncludeInSchema";

		internal const string XmlInvalidSerializable = "XmlInvalidSerializable";

		internal const string XmlInvalidUseOfType = "XmlInvalidUseOfType";

		internal const string XmlUnxpectedType = "XmlUnxpectedType";

		internal const string XmlUnknownAnyElement = "XmlUnknownAnyElement";

		internal const string XmlMultipleAttributeOverrides = "XmlMultipleAttributeOverrides";

		internal const string XmlInvalidEnumAttribute = "XmlInvalidEnumAttribute";

		internal const string XmlInvalidReturnPosition = "XmlInvalidReturnPosition";

		internal const string XmlInvalidElementAttribute = "XmlInvalidElementAttribute";

		internal const string XmlInvalidVoid = "XmlInvalidVoid";

		internal const string XmlInvalidContent = "XmlInvalidContent";

		internal const string XmlInvalidSchemaElementType = "XmlInvalidSchemaElementType";

		internal const string XmlInvalidSubstitutionGroupUse = "XmlInvalidSubstitutionGroupUse";

		internal const string XmlElementMissingType = "XmlElementMissingType";

		internal const string XmlInvalidAnyAttributeUse = "XmlInvalidAnyAttributeUse";

		internal const string XmlSoapInvalidAttributeUse = "XmlSoapInvalidAttributeUse";

		internal const string XmlSoapInvalidChoice = "XmlSoapInvalidChoice";

		internal const string XmlSoapUnsupportedGroupRef = "XmlSoapUnsupportedGroupRef";

		internal const string XmlSoapUnsupportedGroupRepeat = "XmlSoapUnsupportedGroupRepeat";

		internal const string XmlSoapUnsupportedGroupNested = "XmlSoapUnsupportedGroupNested";

		internal const string XmlSoapUnsupportedGroupAny = "XmlSoapUnsupportedGroupAny";

		internal const string XmlInvalidEnumContent = "XmlInvalidEnumContent";

		internal const string XmlInvalidAttributeType = "XmlInvalidAttributeType";

		internal const string XmlInvalidBaseType = "XmlInvalidBaseType";

		internal const string XmlPrimitiveBaseType = "XmlPrimitiveBaseType";

		internal const string XmlInvalidIdentifier = "XmlInvalidIdentifier";

		internal const string XmlGenError = "XmlGenError";

		internal const string XmlInvalidXmlns = "XmlInvalidXmlns";

		internal const string XmlCircularReference = "XmlCircularReference";

		internal const string XmlCircularReference2 = "XmlCircularReference2";

		internal const string XmlAnonymousBaseType = "XmlAnonymousBaseType";

		internal const string XmlMissingSchema = "XmlMissingSchema";

		internal const string XmlNoSerializableMembers = "XmlNoSerializableMembers";

		internal const string XmlIllegalOverride = "XmlIllegalOverride";

		internal const string XmlReadOnlyCollection = "XmlReadOnlyCollection";

		internal const string XmlRpcNestedValueType = "XmlRpcNestedValueType";

		internal const string XmlRpcRefsInValueType = "XmlRpcRefsInValueType";

		internal const string XmlRpcArrayOfValueTypes = "XmlRpcArrayOfValueTypes";

		internal const string XmlDuplicateElementName = "XmlDuplicateElementName";

		internal const string XmlDuplicateAttributeName = "XmlDuplicateAttributeName";

		internal const string XmlBadBaseElement = "XmlBadBaseElement";

		internal const string XmlBadBaseType = "XmlBadBaseType";

		internal const string XmlUndefinedAlias = "XmlUndefinedAlias";

		internal const string XmlChoiceIdentifierType = "XmlChoiceIdentifierType";

		internal const string XmlChoiceIdentifierArrayType = "XmlChoiceIdentifierArrayType";

		internal const string XmlChoiceIdentifierTypeEnum = "XmlChoiceIdentifierTypeEnum";

		internal const string XmlChoiceIdentiferMemberMissing = "XmlChoiceIdentiferMemberMissing";

		internal const string XmlChoiceIdentiferAmbiguous = "XmlChoiceIdentiferAmbiguous";

		internal const string XmlChoiceIdentiferMissing = "XmlChoiceIdentiferMissing";

		internal const string XmlChoiceMissingValue = "XmlChoiceMissingValue";

		internal const string XmlChoiceMissingAnyValue = "XmlChoiceMissingAnyValue";

		internal const string XmlChoiceMismatchChoiceException = "XmlChoiceMismatchChoiceException";

		internal const string XmlArrayItemAmbiguousTypes = "XmlArrayItemAmbiguousTypes";

		internal const string XmlUnsupportedInterface = "XmlUnsupportedInterface";

		internal const string XmlUnsupportedInterfaceDetails = "XmlUnsupportedInterfaceDetails";

		internal const string XmlUnsupportedRank = "XmlUnsupportedRank";

		internal const string XmlUnsupportedInheritance = "XmlUnsupportedInheritance";

		internal const string XmlIllegalMultipleText = "XmlIllegalMultipleText";

		internal const string XmlIllegalMultipleTextMembers = "XmlIllegalMultipleTextMembers";

		internal const string XmlIllegalArrayTextAttribute = "XmlIllegalArrayTextAttribute";

		internal const string XmlIllegalTypedTextAttribute = "XmlIllegalTypedTextAttribute";

		internal const string XmlIllegalSimpleContentExtension = "XmlIllegalSimpleContentExtension";

		internal const string XmlInvalidCast = "XmlInvalidCast";

		internal const string XmlInvalidCastWithId = "XmlInvalidCastWithId";

		internal const string XmlInvalidArrayRef = "XmlInvalidArrayRef";

		internal const string XmlInvalidNullCast = "XmlInvalidNullCast";

		internal const string XmlMultipleXmlns = "XmlMultipleXmlns";

		internal const string XmlMultipleXmlnsMembers = "XmlMultipleXmlnsMembers";

		internal const string XmlXmlnsInvalidType = "XmlXmlnsInvalidType";

		internal const string XmlSoleXmlnsAttribute = "XmlSoleXmlnsAttribute";

		internal const string XmlConstructorHasSecurityAttributes = "XmlConstructorHasSecurityAttributes";

		internal const string XmlPropertyHasSecurityAttributes = "XmlPropertyHasSecurityAttributes";

		internal const string XmlMethodHasSecurityAttributes = "XmlMethodHasSecurityAttributes";

		internal const string XmlDefaultAccessorHasSecurityAttributes = "XmlDefaultAccessorHasSecurityAttributes";

		internal const string XmlInvalidChoiceIdentifierValue = "XmlInvalidChoiceIdentifierValue";

		internal const string XmlAnyElementDuplicate = "XmlAnyElementDuplicate";

		internal const string XmlChoiceIdDuplicate = "XmlChoiceIdDuplicate";

		internal const string XmlChoiceIdentifierMismatch = "XmlChoiceIdentifierMismatch";

		internal const string XmlUnsupportedRedefine = "XmlUnsupportedRedefine";

		internal const string XmlDuplicateElementInScope = "XmlDuplicateElementInScope";

		internal const string XmlDuplicateElementInScope1 = "XmlDuplicateElementInScope1";

		internal const string XmlNoPartialTrust = "XmlNoPartialTrust";

		internal const string XmlInvalidEncodingNotEncoded1 = "XmlInvalidEncodingNotEncoded1";

		internal const string XmlInvalidEncoding3 = "XmlInvalidEncoding3";

		internal const string XmlInvalidSpecifiedType = "XmlInvalidSpecifiedType";

		internal const string XmlUnsupportedOpenGenericType = "XmlUnsupportedOpenGenericType";

		internal const string XmlMismatchSchemaObjects = "XmlMismatchSchemaObjects";

		internal const string XmlCircularTypeReference = "XmlCircularTypeReference";

		internal const string XmlCircularGroupReference = "XmlCircularGroupReference";

		internal const string XmlRpcLitElementNamespace = "XmlRpcLitElementNamespace";

		internal const string XmlRpcLitElementNullable = "XmlRpcLitElementNullable";

		internal const string XmlRpcLitElements = "XmlRpcLitElements";

		internal const string XmlRpcLitArrayElement = "XmlRpcLitArrayElement";

		internal const string XmlRpcLitAttributeAttributes = "XmlRpcLitAttributeAttributes";

		internal const string XmlRpcLitAttributes = "XmlRpcLitAttributes";

		internal const string XmlSequenceMembers = "XmlSequenceMembers";

		internal const string XmlRpcLitXmlns = "XmlRpcLitXmlns";

		internal const string XmlDuplicateNs = "XmlDuplicateNs";

		internal const string XmlAnonymousInclude = "XmlAnonymousInclude";

		internal const string XmlSchemaIncludeLocation = "XmlSchemaIncludeLocation";

		internal const string XmlSerializableSchemaError = "XmlSerializableSchemaError";

		internal const string XmlGetSchemaMethodName = "XmlGetSchemaMethodName";

		internal const string XmlGetSchemaMethodMissing = "XmlGetSchemaMethodMissing";

		internal const string XmlGetSchemaMethodReturnType = "XmlGetSchemaMethodReturnType";

		internal const string XmlGetSchemaEmptyTypeName = "XmlGetSchemaEmptyTypeName";

		internal const string XmlGetSchemaTypeMissing = "XmlGetSchemaTypeMissing";

		internal const string XmlGetSchemaInclude = "XmlGetSchemaInclude";

		internal const string XmlSerializableAttributes = "XmlSerializableAttributes";

		internal const string XmlSerializableMergeItem = "XmlSerializableMergeItem";

		internal const string XmlSerializableBadDerivation = "XmlSerializableBadDerivation";

		internal const string XmlSerializableMissingClrType = "XmlSerializableMissingClrType";

		internal const string XmlCircularDerivation = "XmlCircularDerivation";

		internal const string XmlSerializerAccessDenied = "XmlSerializerAccessDenied";

		internal const string XmlIdentityAccessDenied = "XmlIdentityAccessDenied";

		internal const string XmlMelformMapping = "XmlMelformMapping";

		internal const string XmlSerializableWriteLess = "XmlSerializableWriteLess";

		internal const string XmlSerializableWriteMore = "XmlSerializableWriteMore";

		internal const string XmlSerializableReadMore = "XmlSerializableReadMore";

		internal const string XmlSerializableReadLess = "XmlSerializableReadLess";

		internal const string XmlSerializableIllegalOperation = "XmlSerializableIllegalOperation";

		internal const string XmlSchemaSyntaxErrorDetails = "XmlSchemaSyntaxErrorDetails";

		internal const string XmlSchemaElementReference = "XmlSchemaElementReference";

		internal const string XmlSchemaAttributeReference = "XmlSchemaAttributeReference";

		internal const string XmlSchemaItem = "XmlSchemaItem";

		internal const string XmlSchemaNamedItem = "XmlSchemaNamedItem";

		internal const string XmlSchemaContentDef = "XmlSchemaContentDef";

		internal const string XmlSchema = "XmlSchema";

		internal const string XmlSerializerCompileFailed = "XmlSerializerCompileFailed";

		internal const string XmlSerializableRootDupName = "XmlSerializableRootDupName";

		internal const string XmlDropDefaultAttribute = "XmlDropDefaultAttribute";

		internal const string XmlDropAttributeValue = "XmlDropAttributeValue";

		internal const string XmlDropArrayAttributeValue = "XmlDropArrayAttributeValue";

		internal const string XmlDropNonPrimitiveAttributeValue = "XmlDropNonPrimitiveAttributeValue";

		internal const string XmlNotKnownDefaultValue = "XmlNotKnownDefaultValue";

		internal const string XmlRemarks = "XmlRemarks";

		internal const string XmlCodegenWarningDetails = "XmlCodegenWarningDetails";

		internal const string XmlExtensionComment = "XmlExtensionComment";

		internal const string XmlExtensionDuplicateDefinition = "XmlExtensionDuplicateDefinition";

		internal const string XmlImporterExtensionBadLocalTypeName = "XmlImporterExtensionBadLocalTypeName";

		internal const string XmlImporterExtensionBadTypeName = "XmlImporterExtensionBadTypeName";

		internal const string XmlConfigurationDuplicateExtension = "XmlConfigurationDuplicateExtension";

		internal const string XmlPregenMissingDirectory = "XmlPregenMissingDirectory";

		internal const string XmlPregenMissingTempDirectory = "XmlPregenMissingTempDirectory";

		internal const string XmlPregenTypeDynamic = "XmlPregenTypeDynamic";

		internal const string XmlSerializerExpiredDetails = "XmlSerializerExpiredDetails";

		internal const string XmlSerializerExpired = "XmlSerializerExpired";

		internal const string XmlPregenAssemblyDynamic = "XmlPregenAssemblyDynamic";

		internal const string XmlNotSerializable = "XmlNotSerializable";

		internal const string XmlPregenOrphanType = "XmlPregenOrphanType";

		internal const string XmlPregenCannotLoad = "XmlPregenCannotLoad";

		internal const string XmlPregenInvalidXmlSerializerAssemblyAttribute = "XmlPregenInvalidXmlSerializerAssemblyAttribute";

		internal const string XmlSequenceInconsistent = "XmlSequenceInconsistent";

		internal const string XmlSequenceUnique = "XmlSequenceUnique";

		internal const string XmlSequenceHierarchy = "XmlSequenceHierarchy";

		internal const string XmlSequenceMatch = "XmlSequenceMatch";

		internal const string XmlDisallowNegativeValues = "XmlDisallowNegativeValues";

		internal const string XmlInternalError = "XmlInternalError";

		internal const string XmlInternalErrorDetails = "XmlInternalErrorDetails";

		internal const string XmlInternalErrorMethod = "XmlInternalErrorMethod";

		internal const string XmlInternalErrorReaderAdvance = "XmlInternalErrorReaderAdvance";

		internal const string XmlNonCLSCompliantException = "XmlNonCLSCompliantException";

		internal const string XmlConvert_BadFormat = "XmlConvert_BadFormat";

		internal const string XmlConvert_Overflow = "XmlConvert_Overflow";

		internal const string XmlConvert_TypeBadMapping = "XmlConvert_TypeBadMapping";

		internal const string XmlConvert_TypeBadMapping2 = "XmlConvert_TypeBadMapping2";

		internal const string XmlConvert_TypeListBadMapping = "XmlConvert_TypeListBadMapping";

		internal const string XmlConvert_TypeListBadMapping2 = "XmlConvert_TypeListBadMapping2";

		internal const string XmlConvert_TypeToString = "XmlConvert_TypeToString";

		internal const string XmlConvert_TypeFromString = "XmlConvert_TypeFromString";

		internal const string XmlConvert_TypeNoPrefix = "XmlConvert_TypeNoPrefix";

		internal const string XmlConvert_TypeNoNamespace = "XmlConvert_TypeNoNamespace";

		internal const string RefSyntaxNotSupportedForElements0 = "RefSyntaxNotSupportedForElements0";

		internal const string XPathDocument_MissingSchemas = "XPathDocument_MissingSchemas";

		internal const string XPathDocument_NotEnoughSchemaInfo = "XPathDocument_NotEnoughSchemaInfo";

		internal const string XPathDocument_ValidateInvalidNodeType = "XPathDocument_ValidateInvalidNodeType";

		internal const string XPathDocument_SchemaSetNotAllowed = "XPathDocument_SchemaSetNotAllowed";

		internal const string XmlBin_MissingEndCDATA = "XmlBin_MissingEndCDATA";

		internal const string XmlBin_InvalidQNameID = "XmlBin_InvalidQNameID";

		internal const string XmlBinary_UnexpectedToken = "XmlBinary_UnexpectedToken";

		internal const string XmlBinary_InvalidSqlDecimal = "XmlBinary_InvalidSqlDecimal";

		internal const string XmlBinary_InvalidSignature = "XmlBinary_InvalidSignature";

		internal const string XmlBinary_InvalidProtocolVersion = "XmlBinary_InvalidProtocolVersion";

		internal const string XmlBinary_UnsupportedCodePage = "XmlBinary_UnsupportedCodePage";

		internal const string XmlBinary_InvalidStandalone = "XmlBinary_InvalidStandalone";

		internal const string XmlBinary_NoParserContext = "XmlBinary_NoParserContext";

		internal const string XmlBinary_ListsOfValuesNotSupported = "XmlBinary_ListsOfValuesNotSupported";

		internal const string XmlBinary_CastNotSupported = "XmlBinary_CastNotSupported";

		internal const string XmlBinary_NoRemapPrefix = "XmlBinary_NoRemapPrefix";

		internal const string XmlBinary_AttrWithNsNoPrefix = "XmlBinary_AttrWithNsNoPrefix";

		internal const string XmlBinary_ValueTooBig = "XmlBinary_ValueTooBig";

		internal const string SqlTypes_ArithOverflow = "SqlTypes_ArithOverflow";

		internal const string SqlTypes_ArithTruncation = "SqlTypes_ArithTruncation";

		internal const string SqlTypes_DivideByZero = "SqlTypes_DivideByZero";

		internal const string Enc_InvalidByteInEncoding = "Enc_InvalidByteInEncoding";

		internal const string Arg_ExpectingXmlTextReader = "Arg_ExpectingXmlTextReader";

		internal const string Arg_CannotCreateNode = "Arg_CannotCreateNode";

		internal const string Xml_BadComment = "Xml_BadComment";

		internal const string Xml_NumEntityOverflow = "Xml_NumEntityOverflow";

		internal const string Xml_UnexpectedCharacter = "Xml_UnexpectedCharacter";

		internal const string Xml_UnexpectedToken1 = "Xml_UnexpectedToken1";

		internal const string Xml_TagMismatchFileName = "Xml_TagMismatchFileName";

		internal const string Xml_ReservedNs = "Xml_ReservedNs";

		internal const string Xml_BadElementData = "Xml_BadElementData";

		internal const string Xml_UnexpectedElement = "Xml_UnexpectedElement";

		internal const string Xml_TagNotInTheSameEntity = "Xml_TagNotInTheSameEntity";

		internal const string Xml_InvalidPartialContentData = "Xml_InvalidPartialContentData";

		internal const string Xml_CanNotStartWithXmlInNamespace = "Xml_CanNotStartWithXmlInNamespace";

		internal const string Xml_UnparsedEntity = "Xml_UnparsedEntity";

		internal const string Xml_InvalidContentForThisNode = "Xml_InvalidContentForThisNode";

		internal const string Xml_MissingEncodingDecl = "Xml_MissingEncodingDecl";

		internal const string Xml_InvalidSurrogatePair = "Xml_InvalidSurrogatePair";

		internal const string Sch_ErrorPosition = "Sch_ErrorPosition";

		internal const string Sch_ReservedNsDecl = "Sch_ReservedNsDecl";

		internal const string Sch_NotInSchemaCollection = "Sch_NotInSchemaCollection";

		internal const string Sch_NotationNotAttr = "Sch_NotationNotAttr";

		internal const string Sch_InvalidContent = "Sch_InvalidContent";

		internal const string Sch_InvalidContentExpecting = "Sch_InvalidContentExpecting";

		internal const string Sch_InvalidTextWhiteSpace = "Sch_InvalidTextWhiteSpace";

		internal const string Sch_XSCHEMA = "Sch_XSCHEMA";

		internal const string Sch_DubSchema = "Sch_DubSchema";

		internal const string Xp_TokenExpected = "Xp_TokenExpected";

		internal const string Xp_NodeTestExpected = "Xp_NodeTestExpected";

		internal const string Xp_NumberExpected = "Xp_NumberExpected";

		internal const string Xp_QueryExpected = "Xp_QueryExpected";

		internal const string Xp_InvalidArgument = "Xp_InvalidArgument";

		internal const string Xp_FunctionExpected = "Xp_FunctionExpected";

		internal const string Xp_InvalidPatternString = "Xp_InvalidPatternString";

		internal const string Xp_BadQueryString = "Xp_BadQueryString";

		internal const string XdomXpNav_NullParam = "XdomXpNav_NullParam";

		internal const string Xdom_Load_NodeType = "Xdom_Load_NodeType";

		internal const string XmlMissingMethod = "XmlMissingMethod";

		internal const string XmlIncludeSerializableError = "XmlIncludeSerializableError";

		internal const string XmlCompilerDynModule = "XmlCompilerDynModule";

		internal const string XmlInvalidSchemaType = "XmlInvalidSchemaType";

		internal const string XmlInvalidAnyUse = "XmlInvalidAnyUse";

		internal const string XmlSchemaSyntaxError = "XmlSchemaSyntaxError";

		internal const string XmlDuplicateChoiceElement = "XmlDuplicateChoiceElement";

		internal const string XmlConvert_BadTimeSpan = "XmlConvert_BadTimeSpan";

		internal const string XmlConvert_BadBoolean = "XmlConvert_BadBoolean";

		internal const string XmlConvert_BadUri = "XmlConvert_BadUri";

		internal const string Xml_UnexpectedToken = "Xml_UnexpectedToken";

		internal const string Xml_PartialContentNodeTypeNotSupported = "Xml_PartialContentNodeTypeNotSupported";

		internal const string Sch_AttributeValueDataType = "Sch_AttributeValueDataType";

		internal const string Sch_ElementValueDataType = "Sch_ElementValueDataType";

		internal const string Sch_NonDeterministicAny = "Sch_NonDeterministicAny";

		internal const string Sch_MismatchTargetNamespace = "Sch_MismatchTargetNamespace";

		internal const string Sch_UnionFailed = "Sch_UnionFailed";

		internal const string Sch_XsiTypeBlocked = "Sch_XsiTypeBlocked";

		internal const string Sch_InvalidElementInEmpty = "Sch_InvalidElementInEmpty";

		internal const string Sch_InvalidElementInTextOnly = "Sch_InvalidElementInTextOnly";

		internal const string Sch_InvalidNameAttribute = "Sch_InvalidNameAttribute";

		private static Res loader;

		private ResourceManager resources;

		private static object s_InternalSyncObject;

		private static object InternalSyncObject
		{
			get
			{
				if (s_InternalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref s_InternalSyncObject, value, null);
				}
				return s_InternalSyncObject;
			}
		}

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal Res()
		{
			resources = new ResourceManager("System.Xml", GetType().Assembly);
		}

		private static Res GetLoader()
		{
			if (loader == null)
			{
				lock (InternalSyncObject)
				{
					if (loader == null)
					{
						loader = new Res();
					}
				}
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			Res res = GetLoader();
			if (res == null)
			{
				return null;
			}
			string @string = res.resources.GetString(name, Culture);
			if (args != null && args.Length > 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System
{
	internal static class HResults
	{
		internal const int Configuration = -2146232062;

		internal const int Xml = -2146232000;

		internal const int XmlSchema = -2146231999;

		internal const int XmlXslt = -2146231998;

		internal const int XmlXPath = -2146231997;

		internal const int Data = -2146232032;

		internal const int DataDeletedRowInaccessible = -2146232031;

		internal const int DataDuplicateName = -2146232030;

		internal const int DataInRowChangingEvent = -2146232029;

		internal const int DataInvalidConstraint = -2146232028;

		internal const int DataMissingPrimaryKey = -2146232027;

		internal const int DataNoNullAllowed = -2146232026;

		internal const int DataReadOnly = -2146232025;

		internal const int DataRowNotInTable = -2146232024;

		internal const int DataVersionNotFound = -2146232023;

		internal const int DataConstraint = -2146232022;

		internal const int StrongTyping = -2146232021;

		internal const int SqlType = -2146232016;

		internal const int SqlNullValue = -2146232015;

		internal const int SqlTruncate = -2146232014;

		internal const int AdapterMapping = -2146232013;

		internal const int DataAdapter = -2146232012;

		internal const int DBConcurrency = -2146232011;

		internal const int OperationAborted = -2146232010;

		internal const int InvalidUdt = -2146232009;

		internal const int SqlException = -2146232060;

		internal const int OdbcException = -2146232009;

		internal const int OracleException = -2146232008;

		internal const int NteBadKeySet = -2146893802;

		internal const int Win32AccessDenied = -2147024891;

		internal const int Win32InvalidHandle = -2147024890;

		internal const int License = -2146232063;

		internal const int InternalBufferOverflow = -2146232059;

		internal const int ServiceControllerTimeout = -2146232058;

		internal const int Install = -2146232057;

		internal const int EFail = -2147467259;
	}
	[Serializable]
	internal class InvariantComparer : IComparer
	{
		private CompareInfo m_compareInfo;

		internal static readonly InvariantComparer Default = new InvariantComparer();

		internal InvariantComparer()
		{
			m_compareInfo = CultureInfo.InvariantCulture.CompareInfo;
		}

		public int Compare(object a, object b)
		{
			string text = a as string;
			string text2 = b as string;
			if (text != null && text2 != null)
			{
				return m_compareInfo.Compare(text, text2);
			}
			return Comparer.Default.Compare(a, b);
		}
	}
}
namespace System.Configuration
{
	[ConfigurationPermission(SecurityAction.Assert, Unrestricted = true)]
	internal static class PrivilegedConfigurationManager
	{
		internal static ConnectionStringSettingsCollection ConnectionStrings => ConfigurationManager.ConnectionStrings;

		internal static object GetSection(string sectionName)
		{
			return ConfigurationManager.GetSection(sectionName);
		}
	}
}
namespace System.Xml
{
	internal abstract class IncrementalReadDecoder
	{
		internal abstract int DecodedCount { get; }

		internal abstract bool IsFull { get; }

		internal abstract void SetNextOutputBuffer(Array array, int offset, int len);

		internal abstract int Decode(char[] chars, int startPos, int len);

		internal abstract int Decode(string str, int startPos, int len);

		internal abstract void Reset();
	}
	internal class Base64Decoder : IncrementalReadDecoder
	{
		private const int MaxValidChar = 122;

		private const byte Invalid = byte.MaxValue;

		private byte[] buffer;

		private int startIndex;

		private int curIndex;

		private int endIndex;

		private int bits;

		private int bitsFilled;

		private static readonly string CharsBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

		private static readonly byte[] MapBase64 = ConstructMapBase64();

		internal override int DecodedCount => curIndex - startIndex;

		internal override bool IsFull => curIndex == endIndex;

		internal unsafe override int Decode(char[] chars, int startPos, int len)
		{
			if (len == 0)
			{
				return 0;
			}
			int charsDecoded;
			int bytesDecoded;
			fixed (char* ptr = &chars[startPos])
			{
				fixed (byte* ptr2 = &buffer[curIndex])
				{
					Decode(ptr, ptr + len, ptr2, ptr2 + (endIndex - curIndex), out charsDecoded, out bytesDecoded);
				}
			}
			curIndex += bytesDecoded;
			return charsDecoded;
		}

		internal unsafe override int Decode(string str, int startPos, int len)
		{
			if (len == 0)
			{
				return 0;
			}
			int charsDecoded;
			int bytesDecoded;
			fixed (char* ptr = str)
			{
				fixed (byte* ptr2 = &buffer[curIndex])
				{
					Decode(ptr + startPos, ptr + startPos + len, ptr2, ptr2 + (endIndex - curIndex), out charsDecoded, out bytesDecoded);
				}
			}
			curIndex += bytesDecoded;
			return charsDecoded;
		}

		internal override void Reset()
		{
			bitsFilled = 0;
			bits = 0;
		}

		internal override void SetNextOutputBuffer(Array buffer, int index, int count)
		{
			this.buffer = (byte[])buffer;
			startIndex = index;
			curIndex = index;
			endIndex = index + count;
		}

		private static byte[] ConstructMapBase64()
		{
			byte[] array = new byte[123];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = byte.MaxValue;
			}
			for (int j = 0; j < CharsBase64.Length; j++)
			{
				array[(uint)CharsBase64[j]] = (byte)j;
			}
			return array;
		}

		private unsafe void Decode(char* pChars, char* pCharsEndPos, byte* pBytes, byte* pBytesEndPos, out int charsDecoded, out int bytesDecoded)
		{
			byte* ptr = pBytes;
			char* ptr2 = pChars;
			int num = bits;
			int num2 = bitsFilled;
			XmlCharType instance = XmlCharType.Instance;
			while (true)
			{
				if (ptr2 < pCharsEndPos && ptr < pBytesEndPos)
				{
					char c = *ptr2;
					if (c != '=')
					{
						ptr2++;
						if (((uint)instance.charProperties[(int)c] & (true ? 1u : 0u)) != 0)
						{
							continue;
						}
						int num3;
						if (c > 'z' || (num3 = MapBase64[(uint)c]) == 255)
						{
							throw new XmlException("Xml_InvalidBase64Value", new string(pChars, 0, (int)(pCharsEndPos - pChars)));
						}
						num = (num << 6) | num3;
						num2 += 6;
						if (num2 >= 8)
						{
							*(ptr++) = (byte)((uint)(num >> num2 - 8) & 0xFFu);
							num2 -= 8;
							if (ptr == pBytesEndPos)
							{
								break;
							}
						}
						continue;
					}
				}
				if (ptr2 >= pCharsEndPos || *ptr2 != '=')
				{
					break;
				}
				num2 = 0;
				do
				{
					ptr2++;
				}
				while (ptr2 < pCharsEndPos && *ptr2 == '=');
				if (ptr2 >= pCharsEndPos)
				{
					break;
				}
				do
				{
					byte* charProperties = instance.charProperties;
					char* intPtr = ptr2;
					ptr2 = intPtr + 1;
					if ((charProperties[(int)(*intPtr)] & 1) == 0)
					{
						throw new XmlException("Xml_InvalidBase64Value", new string(pChars, 0, (int)(pCharsEndPos - pChars)));
					}
				}
				while (ptr2 < pCharsEndPos);
				break;
			}
			bits = num;
			bitsFilled = num2;
			bytesDecoded = (int)(ptr - pBytes);
			charsDecoded = (int)(ptr2 - pChars);
		}
	}
	internal abstract class Base64Encoder
	{
		internal const int Base64LineSize = 76;

		internal const int LineSizeInBytes = 57;

		private byte[] leftOverBytes;

		private int leftOverBytesCount;

		private char[] charsLine;

		internal Base64Encoder()
		{
			charsLine = new char[76];
		}

		internal abstract void WriteChars(char[] chars, int index, int count);

		internal void Encode(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count > buffer.Length - index)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (leftOverBytesCount > 0)
			{
				int num = leftOverBytesCount;
				while (num < 3 && count > 0)
				{
					leftOverBytes[num++] = buffer[index++];
					count--;
				}
				if (count == 0 && num < 3)
				{
					leftOverBytesCount = num;
					return;
				}
				int count2 = Convert.ToBase64CharArray(leftOverBytes, 0, 3, charsLine, 0);
				WriteChars(charsLine, 0, count2);
			}
			leftOverBytesCount = count % 3;
			if (leftOverBytesCount > 0)
			{
				count -= leftOverBytesCount;
				if (leftOverBytes == null)
				{
					leftOverBytes = new byte[3];
				}
				for (int i = 0; i < leftOverBytesCount; i++)
				{
					leftOverBytes[i] = buffer[index + count + i];
				}
			}
			int num2 = index + count;
			int num3 = 57;
			while (index < num2)
			{
				if (index + num3 > num2)
				{
					num3 = num2 - index;
				}
				int count3 = Convert.ToBase64CharArray(buffer, index, num3, charsLine, 0);
				WriteChars(charsLine, 0, count3);
				index += num3;
			}
		}

		internal void Flush()
		{
			if (leftOverBytesCount > 0)
			{
				int count = Convert.ToBase64CharArray(leftOverBytes, 0, leftOverBytesCount, charsLine, 0);
				WriteChars(charsLine, 0, count);
				leftOverBytesCount = 0;
			}
		}
	}
	internal class XmlRawWriterBase64Encoder : Base64Encoder
	{
		private XmlRawWriter rawWriter;

		internal XmlRawWriterBase64Encoder(XmlRawWriter rawWriter)
		{
			this.rawWriter = rawWriter;
		}

		internal override void WriteChars(char[] chars, int index, int count)
		{
			rawWriter.WriteRaw(chars, index, count);
		}
	}
	internal class XmlTextWriterBase64Encoder : Base64Encoder
	{
		private XmlTextEncoder xmlTextEncoder;

		internal XmlTextWriterBase64Encoder(XmlTextEncoder xmlTextEncoder)
		{
			this.xmlTextEncoder = xmlTextEncoder;
		}

		internal override void WriteChars(char[] chars, int index, int count)
		{
			xmlTextEncoder.WriteRaw(chars, index, count);
		}
	}
	internal class BinHexDecoder : IncrementalReadDecoder
	{
		private byte[] buffer;

		private int startIndex;

		private int curIndex;

		private int endIndex;

		private bool hasHalfByteCached;

		private byte cachedHalfByte;

		internal override int DecodedCount => curIndex - startIndex;

		internal override bool IsFull => curIndex == endIndex;

		internal unsafe override int Decode(char[] chars, int startPos, int len)
		{
			if (len == 0)
			{
				return 0;
			}
			int charsDecoded;
			int bytesDecoded;
			fixed (char* ptr = &chars[startPos])
			{
				fixed (byte* ptr2 = &buffer[curIndex])
				{
					Decode(ptr, ptr + len, ptr2, ptr2 + (endIndex - curIndex), ref hasHalfByteCached, ref cachedHalfByte, out charsDecoded, out bytesDecoded);
				}
			}
			curIndex += bytesDecoded;
			return charsDecoded;
		}

		internal unsafe override int Decode(string str, int startPos, int len)
		{
			if (len == 0)
			{
				return 0;
			}
			int charsDecoded;
			int bytesDecoded;
			fixed (char* ptr = str)
			{
				fixed (byte* ptr2 = &buffer[curIndex])
				{
					Decode(ptr + startPos, ptr + startPos + len, ptr2, ptr2 + (endIndex - curIndex), ref hasHalfByteCached, ref cachedHalfByte, out charsDecoded, out bytesDecoded);
				}
			}
			curIndex += bytesDecoded;
			return charsDecoded;
		}

		internal override void Reset()
		{
			hasHalfByteCached = false;
			cachedHalfByte = 0;
		}

		internal override void SetNextOutputBuffer(Array buffer, int index, int count)
		{
			this.buffer = (byte[])buffer;
			startIndex = index;
			curIndex = index;
			endIndex = index + count;
		}

		public unsafe static byte[] Decode(char[] chars, bool allowOddChars)
		{
			if (chars == null)
			{
				throw new ArgumentException("chars");
			}
			int num = chars.Length;
			if (num == 0)
			{
				return new byte[0];
			}
			byte[] array = new byte[(num + 1) / 2];
			bool flag = false;
			byte b = 0;
			int bytesDecoded;
			fixed (char* ptr = &chars[0])
			{
				fixed (byte* ptr2 = &array[0])
				{
					Decode(ptr, ptr + num, ptr2, ptr2 + array.Length, ref flag, ref b, out var _, out bytesDecoded);
				}
			}
			if (flag && !allowOddChars)
			{
				throw new XmlException("Xml_InvalidBinHexValueOddCount", new string(chars));
			}
			if (bytesDecoded < array.Length)
			{
				byte[] array2 = new byte[bytesDecoded];
				Buffer.BlockCopy(array, 0, array2, 0, bytesDecoded);
				array = array2;
			}
			return array;
		}

		private unsafe static void Decode(char* pChars, char* pCharsEndPos, byte* pBytes, byte* pBytesEndPos, ref bool hasHalfByteCached, ref byte cachedHalfByte, out int charsDecoded, out int bytesDecoded)
		{
			char* ptr = pChars;
			byte* ptr2 = pBytes;
			XmlCharType instance = XmlCharType.Instance;
			while (ptr < pCharsEndPos && ptr2 < pBytesEndPos)
			{
				char* intPtr = ptr;
				ptr = intPtr + 1;
				char c = *intPtr;
				byte b;
				if (c >= 'a' && c <= 'f')
				{
					b = (byte)(c - 97 + 10);
				}
				else if (c >= 'A' && c <= 'F')
				{
					b = (byte)(c - 65 + 10);
				}
				else
				{
					if (c < '0' || c > '9')
					{
						if ((instance.charProperties[(int)c] & 1) == 0)
						{
							throw new XmlException("Xml_InvalidBinHexValue", new string(pChars, 0, (int)(pCharsEndPos - pChars)));
						}
						continue;
					}
					b = (byte)(c - 48);
				}
				if (hasHalfByteCached)
				{
					*(ptr2++) = (byte)((cachedHalfByte << 4) + b);
					hasHalfByteCached = false;
				}
				else
				{
					cachedHalfByte = b;
					hasHalfByteCached = true;
				}
			}
			bytesDecoded = (int)(ptr2 - pBytes);
			charsDecoded = (int)(ptr - pChars);
		}
	}
	internal abstract class BinHexEncoder
	{
		private const string s_hexDigits = "0123456789ABCDEF";

		private const int CharsChunkSize = 128;

		internal static void Encode(byte[] buffer, int index, int count, XmlWriter writer)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count > buffer.Length - index)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			char[] array = new char[(count * 2 < 128) ? (count * 2) : 128];
			int num = index + count;
			while (index < num)
			{
				int num2 = ((count < 64) ? count : 64);
				int count2 = Encode(buffer, index, num2, array);
				writer.WriteRaw(array, 0, count2);
				index += num2;
				count -= num2;
			}
		}

		internal static string Encode(byte[] inArray, int offsetIn, int count)
		{
			if (inArray == null)
			{
				throw new ArgumentNullException("inArray");
			}
			if (0 > offsetIn)
			{
				throw new ArgumentOutOfRangeException("offsetIn");
			}
			if (0 > count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count > inArray.Length - offsetIn)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			char[] array = new char[2 * count];
			int length = Encode(inArray, offsetIn, count, array);
			return new string(array, 0, length);
		}

		private static int Encode(byte[] inArray, int offsetIn, int count, char[] outArray)
		{
			int num = 0;
			int num2 = 0;
			int num3 = outArray.Length;
			for (int i = 0; i < count; i++)
			{
				byte b = inArray[offsetIn++];
				outArray[num++] = "0123456789ABCDEF"[b >> 4];
				if (num == num3)
				{
					break;
				}
				outArray[num++] = "0123456789ABCDEF"[b & 0xF];
				if (num == num3)
				{
					break;
				}
			}
			return num - num2;
		}
	}
	internal static class Bits
	{
		private static readonly uint MASK_0101010101010101 = 1431655765u;

		private static readonly uint MASK_0011001100110011 = 858993459u;

		private static readonly uint MASK_0000111100001111 = 252645135u;

		private static readonly uint MASK_0000000011111111 = 16711935u;

		private static readonly uint MASK_1111111111111111 = 65535u;

		public static int Count(uint num)
		{
			num = (num & MASK_0101010101010101) + ((num >> 1) & MASK_0101010101010101);
			num = (num & MASK_0011001100110011) + ((num >> 2) & MASK_0011001100110011);
			num = (num & MASK_0000111100001111) + ((num >> 4) & MASK_0000111100001111);
			num = (num & MASK_0000000011111111) + ((num >> 8) & MASK_0000000011111111);
			num = (num & MASK_1111111111111111) + (num >> 16);
			return (int)num;
		}

		public static bool ExactlyOne(uint num)
		{
			if (num != 0)
			{
				return (num & (num - 1)) == 0;
			}
			return false;
		}

		public static bool MoreThanOne(uint num)
		{
			return (num & (num - 1)) != 0;
		}

		public static uint ClearLeast(uint num)
		{
			return num & (num - 1);
		}

		public static int LeastPosition(uint num)
		{
			if (num == 0)
			{
				return 0;
			}
			return Count(num ^ (num - 1));
		}
	}
	internal class BitStack
	{
		private uint[] bitStack;

		private int stackPos;

		private uint curr;

		public bool IsEmpty => curr == 1;

		public BitStack()
		{
			curr = 1u;
		}

		public void PushBit(bool bit)
		{
			if ((curr & 0x80000000u) != 0)
			{
				PushCurr();
			}
			curr = (curr << 1) | (bit ? 1u : 0u);
		}

		public bool PopBit()
		{
			bool result = (curr & 1) != 0;
			curr >>= 1;
			if (curr == 1)
			{
				PopCurr();
			}
			return result;
		}

		public bool PeekBit()
		{
			return (curr & 1) != 0;
		}

		private void PushCurr()
		{
			if (bitStack == null)
			{
				bitStack = new uint[16];
			}
			bitStack[stackPos++] = curr;
			curr = 1u;
			int num = bitStack.Length;
			if (stackPos >= num)
			{
				uint[] destinationArray = new uint[2 * num];
				Array.Copy(bitStack, destinationArray, num);
				bitStack = destinationArray;
			}
		}

		private void PopCurr()
		{
			if (stackPos > 0)
			{
				curr = bitStack[--stackPos];
			}
		}
	}
	internal class BufferBuilder
	{
		private struct Buffer
		{
			internal char[] buffer;

			internal WeakReference recycledBuffer;
		}

		private const int BufferSize = 65536;

		private const int InitialBufferArrayLength = 4;

		private const int MaxStringBuilderLength = 65536;

		private const int DefaultSBCapacity = 16;

		private StringBuilder stringBuilder;

		private Buffer[] buffers;

		private int buffersCount;

		private char[] lastBuffer;

		private int lastBufferIndex;

		private int length;

		public int Length
		{
			get
			{
				return length;
			}
			set
			{
				if (value < 0 || value > length)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				if (value == 0)
				{
					Clear();
				}
				else
				{
					SetLength(value);
				}
			}
		}

		public void Append(char value)
		{
			if (length + 1 <= 65536)
			{
				if (stringBuilder == null)
				{
					stringBuilder = new StringBuilder();
				}
				stringBuilder.Append(value);
			}
			else
			{
				if (lastBuffer == null)
				{
					CreateBuffers();
				}
				if (lastBufferIndex == lastBuffer.Length)
				{
					AddBuffer();
				}
				lastBuffer[lastBufferIndex++] = value;
			}
			length++;
		}

		public void Append(char[] value)
		{
			Append(value, 0, value.Length);
		}

		public unsafe void Append(char[] value, int start, int count)
		{
			if (value == null)
			{
				if (start != 0 || count != 0)
				{
					throw new ArgumentNullException("value");
				}
			}
			else
			{
				if (count == 0)
				{
					return;
				}
				if (start < 0)
				{
					throw new ArgumentOutOfRangeException("start");
				}
				if (count < 0 || start + count > value.Length)
				{
					throw new ArgumentOutOfRangeException("count");
				}
				if (length + count <= 65536)
				{
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder((count < 16) ? 16 : count);
					}
					stringBuilder.Append(value, start, count);
					length += count;
				}
				else
				{
					fixed (char* pSource = &value[start])
					{
						AppendHelper(pSource, count);
					}
				}
			}
		}

		public void Append(string value)
		{
			Append(value, 0, value.Length);
		}

		public unsafe void Append(string value, int start, int count)
		{
			if (value == null)
			{
				if (start != 0 || count != 0)
				{
					throw new ArgumentNullException("value");
				}
			}
			else
			{
				if (count == 0)
				{
					return;
				}
				if (start < 0)
				{
					throw new ArgumentOutOfRangeException("start");
				}
				if (count < 0 || start + count > value.Length)
				{
					throw new ArgumentOutOfRangeException("count");
				}
				if (length + count <= 65536)
				{
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(value, start, count, 0);
					}
					else
					{
						stringBuilder.Append(value, start, count);
					}
					length += count;
				}
				else
				{
					fixed (char* ptr = value)
					{
						AppendHelper(ptr + start, count);
					}
				}
			}
		}

		public void Clear()
		{
			if (length <= 65536)
			{
				if (stringBuilder != null)
				{
					stringBuilder.Length = 0;
				}
			}
			else
			{
				if (lastBuffer != null)
				{
					ClearBuffers();
				}
				stringBuilder = null;
			}
			length = 0;
		}

		internal void ClearBuffers()
		{
			if (buffers != null)
			{
				for (int i = 0; i < buffersCount; i++)
				{
					Recycle(buffers[i]);
				}
				lastBuffer = null;
			}
			lastBufferIndex = 0;
			buffersCount = 0;
		}

		public override string ToString()
		{
			if (length <= 65536 || (buffersCount == 1 && lastBufferIndex == 0))
			{
				return (stringBuilder != null) ? stringBuilder.ToString() : string.Empty;
			}
			if (stringBuilder == null)
			{
				stringBuilder = new StringBuilder(length);
			}
			else
			{
				stringBuilder.Capacity = length;
			}
			int num = length - stringBuilder.Length;
			for (int i = 0; i < buffersCount - 1; i++)
			{
				char[] buffer = buffers[i].buffer;
				stringBuilder.Append(buffer, 0, buffer.Length);
				num -= buffer.Length;
			}
			stringBuilder.Append(buffers[buffersCount - 1].buffer, 0, num);
			ClearBuffers();
			return stringBuilder.ToString();
		}

		public string ToString(int startIndex, int len)
		{
			if (startIndex < 0 || startIndex >= length)
			{
				throw new ArgumentOutOfRangeException("startIndex");
			}
			if (len < 0 || startIndex + len > length)
			{
				throw new ArgumentOutOfRangeException("len");
			}
			if (length <= 65536 || (buffersCount == 1 && lastBufferIndex == 0))
			{
				if (this.stringBuilder == null)
				{
					return string.Empty;
				}
				return this.stringBuilder.ToString(startIndex, len);
			}
			StringBuilder stringBuilder = new StringBuilder(len);
			if (this.stringBuilder != null)
			{
				if (startIndex < this.stringBuilder.Length)
				{
					if (len < this.stringBuilder.Length)
					{
						return this.stringBuilder.ToString(startIndex, len);
					}
					stringBuilder.Append(this.stringBuilder.ToString(startIndex, this.stringBuilder.Length));
					startIndex = 0;
				}
				else
				{
					startIndex -= this.stringBuilder.Length;
				}
			}
			int i;
			for (i = 0; i < buffersCount && startIndex >= buffers[i].buffer.Length; i++)
			{
				startIndex -= buffers[i].buffer.Length;
			}
			if (i < buffersCount)
			{
				int num = len;
				for (; i < buffersCount; i++)
				{
					if (num <= 0)
					{
						break;
					}
					char[] buffer = buffers[i].buffer;
					int num2 = ((buffer.Length < num) ? buffer.Length : num);
					stringBuilder.Append(buffer, startIndex, num2);
					startIndex = 0;
					num -= num2;
				}
			}
			return stringBuilder.ToString();
		}

		private void CreateBuffers()
		{
			if (buffers == null)
			{
				lastBuffer = new char[65536];
				buffers = new Buffer[4];
				buffers[0].buffer = lastBuffer;
				buffersCount = 1;
			}
			else
			{
				AddBuffer();
			}
		}

		private unsafe void AppendHelper(char* pSource, int count)
		{
			if (lastBuffer == null)
			{
				CreateBuffers();
			}
			int num = 0;
			while (count > 0)
			{
				if (lastBufferIndex >= lastBuffer.Length)
				{
					AddBuffer();
				}
				num = count;
				int num2 = lastBuffer.Length - lastBufferIndex;
				if (num2 < num)
				{
					num = num2;
				}
				fixed (char* dmem = &lastBuffer[lastBufferIndex])
				{
					wstrcpy(dmem, pSource, num);
				}
				pSource += num;
				length += num;
				lastBufferIndex += num;
				count -= num;
			}
		}

		private void AddBuffer()
		{
			if (buffersCount + 1 == buffers.Length)
			{
				Buffer[] destinationArray = new Buffer[buffers.Length * 2];
				Array.Copy(buffers, 0, destinationArray, 0, buffers.Length);
				buffers = destinationArray;
			}
			char[] array;
			if (buffers[buffersCount].recycledBuffer != null)
			{
				array = (char[])buffers[buffersCount].recycledBuffer.Target;
				if (array != null)
				{
					buffers[buffersCount].recycledBuffer.Target = null;
					goto IL_00a4;
				}
			}
			array = new char[65536];
			goto IL_00a4;
			IL_00a4:
			lastBuffer = array;
			buffers[buffersCount++].buffer = array;
			lastBufferIndex = 0;
		}

		private void Recycle(Buffer buf)
		{
			if (buf.recycledBuffer == null)
			{
				buf.recycledBuffer = new WeakReference(buf.buffer);
			}
			else
			{
				buf.recycledBuffer.Target = buf.buffer;
			}
			buf.buffer = null;
		}

		private void SetLength(int newLength)
		{
			if (newLength == length)
			{
				return;
			}
			if (length <= 65536)
			{
				stringBuilder.Length = newLength;
			}
			else
			{
				int num = newLength;
				int i;
				for (i = 0; i < buffersCount && num >= buffers[i].buffer.Length; i++)
				{
					num -= buffers[i].buffer.Length;
				}
				if (i < buffersCount)
				{
					lastBuffer = buffers[i].buffer;
					lastBufferIndex = num;
					i++;
					int num2 = i;
					for (; i < buffersCount; i++)
					{
						Recycle(buffers[i]);
					}
					buffersCount = num2;
				}
			}
			length = newLength;
		}

		internal unsafe static void wstrcpy(char* dmem, char* smem, int charCount)
		{
			if (charCount <= 0)
			{
				return;
			}
			if ((((int)dmem ^ (int)smem) & 3) == 0)
			{
				while (((uint)(int)dmem & 3u) != 0 && charCount > 0)
				{
					*dmem = *smem;
					dmem++;
					smem++;
					charCount--;
				}
				if (charCount >= 8)
				{
					charCount -= 8;
					do
					{
						*(int*)dmem = *(int*)smem;
						*(int*)(dmem + 2) = *(int*)(smem + 2);
						*(int*)(dmem + 4) = *(int*)(smem + 4);
						*(int*)(dmem + 6) = *(int*)(smem + 6);
						dmem += 8;
						smem += 8;
						charCount -= 8;
					}
					while (charCount >= 0);
				}
				if (((uint)charCount & 4u) != 0)
				{
					*(int*)dmem = *(int*)smem;
					*(int*)(dmem + 2) = *(int*)(smem + 2);
					dmem += 4;
					smem += 4;
				}
				if (((uint)charCount & 2u) != 0)
				{
					*(int*)dmem = *(int*)smem;
					dmem += 2;
					smem += 2;
				}
			}
			else
			{
				if (charCount >= 8)
				{
					charCount -= 8;
					do
					{
						*dmem = *smem;
						dmem[1] = smem[1];
						dmem[2] = smem[2];
						dmem[3] = smem[3];
						dmem[4] = smem[4];
						dmem[5] = smem[5];
						dmem[6] = smem[6];
						dmem[7] = smem[7];
						dmem += 8;
						smem += 8;
						charCount -= 8;
					}
					while (charCount >= 0);
				}
				if (((uint)charCount & 4u) != 0)
				{
					*dmem = *smem;
					dmem[1] = smem[1];
					dmem[2] = smem[2];
					dmem[3] = smem[3];
					dmem += 4;
					smem += 4;
				}
				if (((uint)charCount & 2u) != 0)
				{
					*dmem = *smem;
					dmem[1] = smem[1];
					dmem += 2;
					smem += 2;
				}
			}
			if (((uint)charCount & (true ? 1u : 0u)) != 0)
			{
				*dmem = *smem;
			}
		}
	}
	internal class ByteStack
	{
		private byte[] stack;

		private int growthRate;

		private int top;

		private int size;

		public int Length => top;

		public ByteStack(int growthRate)
		{
			this.growthRate = growthRate;
			top = 0;
			stack = new byte[growthRate];
			size = growthRate;
		}

		public void Push(byte data)
		{
			if (size == top)
			{
				byte[] dst = new byte[size + growthRate];
				if (top > 0)
				{
					Buffer.BlockCopy(stack, 0, dst, 0, top);
				}
				stack = dst;
				size += growthRate;
			}
			stack[top++] = data;
		}

		public byte Pop()
		{
			if (top > 0)
			{
				return stack[--top];
			}
			return 0;
		}

		public byte Peek()
		{
			if (top > 0)
			{
				return stack[top - 1];
			}
			return 0;
		}
	}
	internal static class DiagnosticsSwitches
	{
		private static BooleanSwitch xmlSchemaContentModel;

		private static TraceSwitch xmlSchema;

		private static BooleanSwitch keepTempFiles;

		private static BooleanSwitch pregenEventLog;

		private static TraceSwitch xmlSerialization;

		private static TraceSwitch xslTypeInference;

		private static BooleanSwitch nonRecursiveTypeLoading;

		public static BooleanSwitch XmlSchemaContentModel
		{
			get
			{
				if (xmlSchemaContentModel == null)
				{
					xmlSchemaContentModel = new BooleanSwitch("XmlSchemaContentModel", "Enable tracing for the XmlSchema content model.");
				}
				return xmlSchemaContentModel;
			}
		}

		public static TraceSwitch XmlSchema
		{
			get
			{
				if (xmlSchema == null)
				{
					xmlSchema = new TraceSwitch("XmlSchema", "Enable tracing for the XmlSchema class.");
				}
				return xmlSchema;
			}
		}

		public static BooleanSwitch KeepTempFiles
		{
			get
			{
				if (keepTempFiles == null)
				{
					keepTempFiles = new BooleanSwitch("XmlSerialization.Compilation", "Keep XmlSerialization generated (temp) files.");
				}
				return keepTempFiles;
			}
		}

		public static BooleanSwitch PregenEventLog
		{
			get
			{
				if (pregenEventLog == null)
				{
					pregenEventLog = new BooleanSwitch("XmlSerialization.PregenEventLog", "Log failures while loading pre-generated XmlSerialization assembly.");
				}
				return pregenEventLog;
			}
		}

		public static TraceSwitch XmlSerialization
		{
			get
			{
				if (xmlSerialization == null)
				{
					xmlSerialization = new TraceSwitch("XmlSerialization", "Enable tracing for the System.Xml.Serialization component.");
				}
				return xmlSerialization;
			}
		}

		public static TraceSwitch XslTypeInference
		{
			get
			{
				if (xslTypeInference == null)
				{
					xslTypeInference = new TraceSwitch("XslTypeInference", "Enable tracing for the XSLT type inference algorithm.");
				}
				return xslTypeInference;
			}
		}

		public static BooleanSwitch NonRecursiveTypeLoading
		{
			get
			{
				if (nonRecursiveTypeLoading == null)
				{
					nonRecursiveTypeLoading = new BooleanSwitch("XmlSerialization.NonRecursiveTypeLoading", "Turn on non-recursive algorithm generating XmlMappings for CLR types.");
				}
				return nonRecursiveTypeLoading;
			}
		}
	}
	internal sealed class EmptyEnumerator : IEnumerator
	{
		object IEnumerator.Current
		{
			get
			{
				throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
			}
		}

		bool IEnumerator.MoveNext()
		{
			return false;
		}

		void IEnumerator.Reset()
		{
		}
	}
	internal class HWStack : ICloneable
	{
		private object[] stack;

		private int growthRate;

		private int used;

		private int size;

		private int limit;

		internal object this[int index]
		{
			get
			{
				if (index >= 0 && index < used)
				{
					return stack[index];
				}
				throw new IndexOutOfRangeException();
			}
			set
			{
				if (index >= 0 && index < used)
				{
					stack[index] = value;
					return;
				}
				throw new IndexOutOfRangeException();
			}
		}

		internal int Length => used;

		internal HWStack(int GrowthRate)
			: this(GrowthRate, int.MaxValue)
		{
		}

		internal HWStack(int GrowthRate, int limit)
		{
			growthRate = GrowthRate;
			used = 0;
			stack = new object[GrowthRate];
			size = GrowthRate;
			this.limit = limit;
		}

		internal object Push()
		{
			if (used == size)
			{
				if (limit <= used)
				{
					throw new XmlException("Xml_StackOverflow", string.Empty);
				}
				object[] destinationArray = new object[size + growthRate];
				if (used > 0)
				{
					Array.Copy(stack, 0, destinationArray, 0, used);
				}
				stack = destinationArray;
				size += growthRate;
			}
			return stack[used++];
		}

		internal object Pop()
		{
			if (0 < used)
			{
				used--;
				return stack[used];
			}
			return null;
		}

		internal object Peek()
		{
			if (used <= 0)
			{
				return null;
			}
			return stack[used - 1];
		}

		internal void AddToTop(object o)
		{
			if (used > 0)
			{
				stack[used - 1] = o;
			}
		}

		private HWStack(object[] stack, int growthRate, int used, int size)
		{
			this.stack = stack;
			this.growthRate = growthRate;
			this.used = used;
			this.size = size;
		}

		public object Clone()
		{
			return new HWStack((object[])stack.Clone(), growthRate, used, size);
		}
	}
	public interface IHasXmlNode
	{
		XmlNode GetNode();
	}
	public interface IXmlLineInfo
	{
		int LineNumber { get; }

		int LinePosition { get; }

		bool HasLineInfo();
	}
	internal class PositionInfo : IXmlLineInfo
	{
		public virtual int LineNumber => 0;

		public virtual int LinePosition => 0;

		public virtual bool HasLineInfo()
		{
			return false;
		}

		public static PositionInfo GetPositionInfo(object o)
		{
			if (o is IXmlLineInfo lineInfo)
			{
				return new ReaderPositionInfo(lineInfo);
			}
			return new PositionInfo();
		}
	}
	internal class ReaderPositionInfo : PositionInfo
	{
		private IXmlLineInfo lineInfo;

		public override int LineNumber => lineInfo.LineNumber;

		public override int LinePosition => lineInfo.LinePosition;

		public ReaderPositionInfo(IXmlLineInfo lineInfo)
		{
			this.lineInfo = lineInfo;
		}

		public override bool HasLineInfo()
		{
			return lineInfo.HasLineInfo();
		}
	}
	public interface IXmlNamespaceResolver
	{
		IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope);

		string LookupNamespace(string prefix);

		string LookupPrefix(string namespaceName);
	}
	internal struct LineInfo
	{
		internal int lineNo;

		internal int linePos;

		public LineInfo(int lineNo, int linePos)
		{
			this.lineNo = lineNo;
			this.linePos = linePos;
		}

		public void Set(int lineNo, int linePos)
		{
			this.lineNo = lineNo;
			this.linePos = linePos;
		}
	}
	internal abstract class ListBase<T> : IList<T>, ICollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable
	{
		public abstract int Count { get; }

		public abstract T this[int index] { get; set; }

		public virtual bool IsFixedSize => true;

		public virtual bool IsReadOnly => true;

		bool ICollection.IsSynchronized => IsReadOnly;

		object ICollection.SyncRoot => this;

		object IList.this[int index]
		{
			get
			{
				return this[index];
			}
			set
			{
				if (!IsCompatibleType(value.GetType()))
				{
					throw new ArgumentException();
				}
				this[index] = (T)value;
			}
		}

		public virtual bool Contains(T value)
		{
			return IndexOf(value) != -1;
		}

		public virtual int IndexOf(T value)
		{
			for (int i = 0; i < Count; i++)
			{
				if (value.Equals(this[i]))
				{
					return i;
				}
			}
			return -1;
		}

		public virtual void CopyTo(T[] array, int index)
		{
			for (int i = 0; i < Count; i++)
			{
				array[index + i] = this[i];
			}
		}

		public virtual IListEnumerator<T> GetEnumerator()
		{
			return new IListEnumerator<T>(this);
		}

		public virtual void Add(T value)
		{
			Insert(Count, value);
		}

		public virtual void Insert(int index, T value)
		{
			throw new NotSupportedException();
		}

		public virtual bool Remove(T value)
		{
			int num = IndexOf(value);
			if (num >= 0)
			{
				RemoveAt(num);
				return true;
			}
			return false;
		}

		public virtual void RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		public virtual void Clear()
		{
			for (int num = Count - 1; num >= 0; num--)
			{
				RemoveAt(num);
			}
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return new IListEnumerator<T>(this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new IListEnumerator<T>(this);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			for (int i = 0; i < Count; i++)
			{
				array.SetValue(this[i], index);
			}
		}

		int IList.Add(object value)
		{
			if (!IsCompatibleType(value.GetType()))
			{
				throw new ArgumentException();
			}
			Add((T)value);
			return Count - 1;
		}

		void IList.Clear()
		{
			Clear();
		}

		bool IList.Contains(object value)
		{
			if (!IsCompatibleType(value.GetType()))
			{
				return false;
			}
			return Contains((T)value);
		}

		int IList.IndexOf(object value)
		{
			if (!IsCompatibleType(value.GetType()))
			{
				return -1;
			}
			return IndexOf((T)value);
		}

		void IList.Insert(int index, object value)
		{
			if (!IsCompatibleType(value.GetType()))
			{
				throw new ArgumentException();
			}
			Insert(index, (T)value);
		}

		void IList.Remove(object value)
		{
			if (!IsCompatibleType(value.GetType()))
			{
				throw new ArgumentException();
			}
			Remove((T)value);
		}

		private static bool IsCompatibleType(object value)
		{
			if ((value == null && !typeof(T).IsValueType) || value is T)
			{
				return true;
			}
			return false;
		}
	}
	internal struct IListEnumerator<T> : IEnumerator<T>, IDisposable, IEnumerator
	{
		private IList<T> sequence;

		private int index;

		private T current;

		public T Current => current;

		object IEnumerator.Current
		{
			get
			{
				if (index == 0)
				{
					throw new InvalidOperationException(Res.GetString("Sch_EnumNotStarted", string.Empty));
				}
				if (index > sequence.Count)
				{
					throw new InvalidOperationException(Res.GetString("Sch_EnumFinished", string.Empty));
				}
				return current;
			}
		}

		public IListEnumerator(IList<T> sequence)
		{
			this.sequence = sequence;
			index = 0;
			current = default(T);
		}

		public void Dispose()
		{
		}

		public bool MoveNext()
		{
			if (index < sequence.Count)
			{
				current = sequence[index];
				index++;
				return true;
			}
			current = default(T);
			return false;
		}

		void IEnumerator.Reset()
		{
			index = 0;
			current = default(T);
		}
	}
}
namespace System
{
	internal static class MarvinHash
	{
		private unsafe delegate long ComputeHashImpl(byte* data, int count, ulong seed);

		private static readonly ComputeHashImpl ComputeHash = (IsItanium() ? new ComputeHashImpl(ComputeHashIA64) : new ComputeHashImpl(ComputeHashNonAligned));

		public static readonly ulong DefaultSeed = GenerateSeed();

		private static bool IsItanium()
		{
			typeof(object).Module.GetPEKind(out var _, out var machine);
			return machine == ImageFileMachine.IA64;
		}

		public unsafe static int ComputeHash32(string key, ulong seed)
		{
			int result;
			fixed (char* data = key)
			{
				result = ComputeHash32((byte*)data, 2 * key.Length, seed);
			}
			return result;
		}

		public unsafe static int ComputeHash32(char[] key, int start, int len, ulong seed)
		{
			int result;
			fixed (char* data = &key[start])
			{
				result = ComputeHash32((byte*)data, 2 * len, seed);
			}
			return result;
		}

		private unsafe static int ComputeHash32(byte* data, int count, ulong seed)
		{
			long num = ComputeHash(data, count, seed);
			return (int)(num >> 32) ^ (int)num;
		}

		private unsafe static long ComputeHashNonAligned(byte* data, int count, ulong seed)
		{
			uint num = (uint)count;
			uint rp = (uint)seed;
			uint rp2 = (uint)(seed >> 32);
			int num2 = 0;
			while (num >= 8)
			{
				rp += *(uint*)(data + num2);
				Block(ref rp, ref rp2);
				rp += *(uint*)(data + num2 + 4);
				Block(ref rp, ref rp2);
				num2 += 8;
				num -= 8;
			}
			switch (num)
			{
			case 4u:
				rp += *(uint*)(data + num2);
				Block(ref rp, ref rp2);
				goto case 0u;
			case 0u:
				rp += 128;
				break;
			case 5u:
				rp += *(uint*)(data + num2);
				num2 += 4;
				Block(ref rp, ref rp2);
				goto case 1u;
			case 1u:
				rp += (uint)(0x8000 | data[num2]);
				break;
			case 6u:
				rp += *(uint*)(data + num2);
				num2 += 4;
				Block(ref rp, ref rp2);
				goto case 2u;
			case 2u:
				rp += (uint)(0x800000 | *(ushort*)(data + num2));
				break;
			case 7u:
				rp += *(uint*)(data + num2);
				num2 += 4;
				Block(ref rp, ref rp2);
				goto case 3u;
			case 3u:
				rp += (uint)(int.MinValue | ((data + num2)[2] << 16) | *(ushort*)(data + num2));
				break;
			}
			Block(ref rp, ref rp2);
			Block(ref rp, ref rp2);
			return (long)(((ulong)rp2 << 32) | rp);
		}

		private unsafe static long ComputeHashIA64(byte* data, int count, ulong seed)
		{
			uint num = (uint)count;
			uint rp = (uint)seed;
			uint rp2 = (uint)(seed >> 32);
			byte* ptr = data;
			while (num >= 4)
			{
				rp += (uint)(*ptr | (ptr[1] << 8) | (ptr[2] << 16) | (ptr[3] << 24));
				Block(ref rp, ref rp2);
				ptr += 4;
				num -= 4;
			}
			switch (num)
			{
			case 0u:
				rp += 128;
				break;
			case 1u:
				rp += (uint)(0x8000 | *ptr);
				break;
			case 2u:
				rp += (uint)(0x800000 | *ptr | (ptr[1] << 8));
				break;
			case 3u:
				rp += (uint)(int.MinValue | *ptr | (ptr[1] << 8) | (ptr[2] << 16));
				break;
			}
			Block(ref rp, ref rp2);
			Block(ref rp, ref rp2);
			return (long)(((ulong)rp2 << 32) | rp);
		}

		private static void Block(ref uint rp0, ref uint rp1)
		{
			uint num = rp0;
			uint num2 = rp1;
			num2 ^= num;
			num = _rotl(num, 20);
			num += num2;
			num2 = _rotl(num2, 9);
			num2 ^= num;
			num = _rotl(num, 27);
			num += num2;
			num2 = _rotl(num2, 19);
			rp0 = num;
			rp1 = num2;
		}

		private static uint _rotl(uint value, int shift)
		{
			return (value << shift) | (value >> 32 - shift);
		}

		public unsafe static ulong GenerateSeed()
		{
			byte[] array = new byte[8];
			RandomNumberGenerator randomNumberGenerator = RandomNumberGenerator.Create();
			try
			{
				randomNumberGenerator.GetBytes(array);
				fixed (byte* ptr = array)
				{
					return *(ulong*)ptr;
				}
			}
			finally
			{
				if (randomNumberGenerator is IDisposable disposable)
				{
					disposable.Dispose();
				}
			}
		}
	}
}
namespace System.Xml
{
	public abstract class XmlNameTable
	{
		public abstract string Get(char[] array, int offset, int length);

		public abstract string Get(string array);

		public abstract string Add(char[] array, int offset, int length);

		public abstract string Add(string array);
	}
	public class NameTable : XmlNameTable
	{
		private class Entry
		{
			internal string str;

			internal int hashCode;

			internal Entry next;

			internal Entry(string str, int hashCode, Entry next)
			{
				this.str = str;
				this.hashCode = hashCode;
				this.next = next;
			}
		}

		private Entry[] entries;

		private int count;

		private int mask;

		private int hashCodeRandomizer;

		private ulong marvinHashSeed;

		public NameTable()
		{
			mask = 31;
			entries = new Entry[mask + 1];
			marvinHashSeed = MarvinHash.DefaultSeed;
		}

		public override string Add(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (key.Length == 0)
			{
				return string.Empty;
			}
			int num = ComputeHash32(key);
			for (Entry entry = entries[num & mask]; entry != null; entry = entry.next)
			{
				if (entry.hashCode == num && entry.str.Equals(key))
				{
					return entry.str;
				}
			}
			return AddEntry(key, num);
		}

		public override string Add(char[] key, int start, int len)
		{
			if (len == 0)
			{
				return string.Empty;
			}
			if (start >= key.Length || start < 0 || (long)start + (long)len > key.Length)
			{
				throw new IndexOutOfRangeException();
			}
			if (len < 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			int num = ComputeHash32(key, start, len);
			for (Entry entry = entries[num & mask]; entry != null; entry = entry.next)
			{
				if (entry.hashCode == num && TextEquals(entry.str, key, start, len))
				{
					return entry.str;
				}
			}
			return AddEntry(new string(key, start, len), num);
		}

		public override string Get(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value.Length == 0)
			{
				return string.Empty;
			}
			int num = ComputeHash32(value);
			for (Entry entry = entries[num & mask]; entry != null; entry = entry.next)
			{
				if (entry.hashCode == num && entry.str.Equals(value))
				{
					return entry.str;
				}
			}
			return null;
		}

		public override string Get(char[] key, int start, int len)
		{
			if (len == 0)
			{
				return string.Empty;
			}
			if (start >= key.Length || start < 0 || (long)start + (long)len > key.Length)
			{
				throw new IndexOutOfRangeException();
			}
			if (len < 0)
			{
				return null;
			}
			int num = ComputeHash32(key, start, len);
			for (Entry entry = entries[num & mask]; entry != null; entry = entry.next)
			{
				if (entry.hashCode == num && TextEquals(entry.str, key, start, len))
				{
					return entry.str;
				}
			}
			return null;
		}

		private string AddEntry(string str, int hashCode)
		{
			int num = hashCode & mask;
			Entry entry = new Entry(str, hashCode, entries[num]);
			entries[num] = entry;
			if (count++ == mask)
			{
				Grow();
			}
			return entry.str;
		}

		private void Grow()
		{
			int num = mask * 2 + 1;
			Entry[] array = entries;
			Entry[] array2 = new Entry[num + 1];
			for (int i = 0; i < array.Length; i++)
			{
				Entry entry = array[i];
				while (entry != null)
				{
					int num2 = entry.hashCode & num;
					Entry next = entry.next;
					entry.next = array2[num2];
					array2[num2] = entry;
					entry = next;
				}
			}
			entries = array2;
			mask = num;
		}

		private static bool TextEquals(string str1, char[] str2, int str2Start, int str2Length)
		{
			if (str1.Length != str2Length)
			{
				return false;
			}
			for (int i = 0; i < str1.Length; i++)
			{
				if (str1[i] != str2[str2Start + i])
				{
					return false;
				}
			}
			return true;
		}

		private int ComputeHash32(string key)
		{
			return MarvinHash.ComputeHash32(key, marvinHashSeed);
		}

		private int ComputeHash32(char[] key, int start, int len)
		{
			return MarvinHash.ComputeHash32(key, start, len, marvinHashSeed);
		}
	}
	internal abstract class Ref
	{
		public static bool Equal(string strA, string strB)
		{
			return (object)strA == strB;
		}
	}
	internal class ValidateNames
	{
		public enum Flags
		{
			NCNames = 1,
			CheckLocalName = 2,
			CheckPrefixMapping = 4,
			All = 7,
			AllExceptNCNames = 6,
			AllExceptPrefixMapping = 3
		}

		private ValidateNames()
		{
		}

		public unsafe static int ParseNCName(string s, int offset)
		{
			int num = offset;
			XmlCharType instance = XmlCharType.Instance;
			if (offset < s.Length && (instance.charProperties[(int)s[offset]] & 4u) != 0)
			{
				offset++;
				while (offset < s.Length && (instance.charProperties[(int)s[offset]] & 8u) != 0)
				{
					offset++;
				}
			}
			return offset - num;
		}

		public static string ParseNCNameThrow(string s)
		{
			ParseNCNameInternal(s, throwOnError: true);
			return s;
		}

		private static bool ParseNCNameInternal(string s, bool throwOnError)
		{
			int num = ParseNCName(s, 0);
			if (num == 0 || num != s.Length)
			{
				if (throwOnError)
				{
					ThrowInvalidName(s, 0, num);
				}
				return false;
			}
			return true;
		}

		public static int ParseQName(string s, int offset, out int colonOffset)
		{
			colonOffset = 0;
			int num = ParseNCName(s, offset);
			if (num != 0)
			{
				offset += num;
				if (offset < s.Length && s[offset] == ':')
				{
					int num2 = ParseNCName(s, offset + 1);
					if (num2 != 0)
					{
						colonOffset = offset;
						num += num2 + 1;
					}
				}
			}
			return num;
		}

		public static void ParseQNameThrow(string s, out string prefix, out string localName)
		{
			int colonOffset;
			int num = ParseQName(s, 0, out colonOffset);
			if (num == 0 || num != s.Length)
			{
				ThrowInvalidName(s, 0, num);
			}
			if (colonOffset != 0)
			{
				prefix = s.Substring(0, colonOffset);
				localName = s.Substring(colonOffset + 1);
			}
			else
			{
				prefix = "";
				localName = s;
			}
		}

		public static void ParseNameTestThrow(string s, out string prefix, out string localName)
		{
			int num;
			if (s.Length != 0 && s[0] == '*')
			{
				prefix = (localName = null);
				num = 1;
			}
			else
			{
				num = ParseNCName(s, 0);
				if (num != 0)
				{
					localName = s.Substring(0, num);
					if (num < s.Length && s[num] == ':')
					{
						prefix = localName;
						int num2 = num + 1;
						if (num2 < s.Length && s[num2] == '*')
						{
							localName = null;
							num += 2;
						}
						else
						{
							int num3 = ParseNCName(s, num2);
							if (num3 != 0)
							{
								localName = s.Substring(num2, num3);
								num += num3 + 1;
							}
						}
					}
					else
					{
						prefix = string.Empty;
					}
				}
				else
				{
					prefix = (localName = null);
				}
			}
			if (num == 0 || num != s.Length)
			{
				ThrowInvalidName(s, 0, num);
			}
		}

		public static void ThrowInvalidName(string s, int offsetStartChar, int offsetBadChar)
		{
			if (offsetStartChar >= s.Length)
			{
				throw new XmlException("Xml_EmptyName", string.Empty);
			}
			if (XmlCharType.Instance.IsNCNameChar(s[offsetBadChar]) && !XmlCharType.Instance.IsStartNCNameChar(s[offsetBadChar]))
			{
				throw new XmlException("Xml_BadStartNameChar", XmlException.BuildCharExceptionStr(s[offsetBadChar]));
			}
			throw new XmlException("Xml_BadNameChar", XmlException.BuildCharExceptionStr(s[offsetBadChar]));
		}

		public static Exception GetInvalidNameException(string s, int offsetStartChar, int offsetBadChar)
		{
			if (offsetStartChar >= s.Length)
			{
				return new XmlException("Xml_EmptyName", string.Empty);
			}
			if (XmlCharType.Instance.IsNCNameChar(s[offsetBadChar]) && !XmlCharType.Instance.IsStartNCNameChar(s[offsetBadChar]))
			{
				return new XmlException("Xml_BadStartNameChar", XmlException.BuildCharExceptionStr(s[offsetBadChar]));
			}
			return new XmlException("Xml_BadNameChar", XmlException.BuildCharExceptionStr(s[offsetBadChar]));
		}

		public static bool StartsWithXml(string s)
		{
			if (s.Length < 3)
			{
				return false;
			}
			if (s[0] != 'x' && s[0] != 'X')
			{
				return false;
			}
			if (s[1] != 'm' && s[1] != 'M')
			{
				return false;
			}
			if (s[2] != 'l' && s[2] != 'L')
			{
				return false;
			}
			return true;
		}

		public static bool IsReservedNamespace(string s)
		{
			if (!s.Equals("http://www.w3.org/XML/1998/namespace"))
			{
				return s.Equals("http://www.w3.org/2000/xmlns/");
			}
			return true;
		}

		public static void ValidateNameThrow(string prefix, string localName, string ns, XPathNodeType nodeKind, Flags flags)
		{
			ValidateNameInternal(prefix, localName, ns, nodeKind, flags, throwOnError: true);
		}

		public static bool ValidateName(string prefix, string localName, string ns, XPathNodeType nodeKind, Flags flags)
		{
			return ValidateNameInternal(prefix, localName, ns, nodeKind, flags, throwOnError: false);
		}

		private static bool ValidateNameInternal(string prefix, string localName, string ns, XPathNodeType nodeKind, Flags flags, bool throwOnError)
		{
			if ((flags & Flags.NCNames) != 0)
			{
				if (prefix.Length != 0 && !ParseNCNameInternal(prefix, throwOnError))
				{
					return false;
				}
				if (localName.Length != 0 && !ParseNCNameInternal(localName, throwOnError))
				{
					return false;
				}
			}
			if ((flags & Flags.CheckLocalName) != 0)
			{
				switch (nodeKind)
				{
				case XPathNodeType.Element:
					if (localName.Length == 0)
					{
						if (throwOnError)
						{
							throw new XmlException("Xdom_Empty_LocalName", string.Empty);
						}
						return false;
					}
					break;
				case XPathNodeType.Attribute:
					if (ns.Length == 0 && localName.Equals("xmlns"))
					{
						if (throwOnError)
						{
							throw new XmlException("XmlBadName", new string[2]
							{
								nodeKind.ToString(),
								localName
							});
						}
						return false;
					}
					goto case XPathNodeType.Element;
				case XPathNodeType.ProcessingInstruction:
					if (localName.Length == 0 || (localName.Length == 3 && StartsWithXml(localName)))
					{
						if (throwOnError)
						{
							throw new XmlException("Xml_InvalidPIName", localName);
						}
						return false;
					}
					break;
				default:
					if (localName.Length != 0)
					{
						if (throwOnError)
						{
							throw new XmlException("XmlNoNameAllowed", nodeKind.ToString());
						}
						return false;
					}
					break;
				}
			}
			if ((flags & Flags.CheckPrefixMapping) != 0)
			{
				switch (nodeKind)
				{
				case XPathNodeType.Element:
				case XPathNodeType.Attribute:
				case XPathNodeType.Namespace:
					if (ns.Length == 0)
					{
						if (prefix.Length != 0)
						{
							if (throwOnError)
							{
								throw new XmlException("Xml_PrefixForEmptyNs", string.Empty);
							}
							return false;
						}
						break;
					}
					if (prefix.Length == 0 && nodeKind == XPathNodeType.Attribute)
					{
						if (throwOnError)
						{
							throw new XmlException("XmlBadName", new string[2]
							{
								nodeKind.ToString(),
								localName
							});
						}
						return false;
					}
					if (prefix.Equals("xml"))
					{
						if (!ns.Equals("http://www.w3.org/XML/1998/namespace"))
						{
							if (throwOnError)
							{
								throw new XmlException("Xml_XmlPrefix", string.Empty);
							}
							return false;
						}
						break;
					}
					if (prefix.Equals("xmlns"))
					{
						if (throwOnError)
						{
							throw new XmlException("Xml_XmlnsPrefix", string.Empty);
						}
						return false;
					}
					if (IsReservedNamespace(ns))
					{
						if (throwOnError)
						{
							throw new XmlException("Xml_NamespaceDeclXmlXmlns", string.Empty);
						}
						return false;
					}
					break;
				case XPathNodeType.ProcessingInstruction:
					if (prefix.Length != 0 || ns.Length != 0)
					{
						if (throwOnError)
						{
							throw new XmlException("Xml_InvalidPIName", CreateName(prefix, localName));
						}
						return false;
					}
					break;
				default:
					if (prefix.Length != 0 || ns.Length != 0)
					{
						if (throwOnError)
						{
							throw new XmlException("XmlNoNameAllowed", nodeKind.ToString());
						}
						return false;
					}
					break;
				}
			}
			return true;
		}

		private static string CreateName(string prefix, string localName)
		{
			if (prefix.Length == 0)
			{
				return localName;
			}
			return prefix + ":" + localName;
		}

		internal static void SplitQName(string name, out string prefix, out string lname)
		{
			int num = name.IndexOf(':');
			if (-1 == num)
			{
				prefix = string.Empty;
				lname = name;
				return;
			}
			if (num == 0 || name.Length - 1 == num)
			{
				throw new ArgumentException(Res.GetString("Xml_BadNameChar", XmlException.BuildCharExceptionStr(':')), "name");
			}
			prefix = name.Substring(0, num);
			num++;
			lname = name.Substring(num, name.Length - num);
		}
	}
	internal struct XmlCharType
	{
		internal const int fWhitespace = 1;

		internal const int fLetter = 2;

		internal const int fNCStartName = 4;

		internal const int fNCName = 8;

		internal const int fCharData = 16;

		internal const int fPublicId = 32;

		internal const int fText = 64;

		internal const int fAttrValue = 128;

		private const uint CharPropertiesSize = 65536u;

		private static object s_Lock;

		private unsafe static byte* s_CharProperties;

		internal unsafe byte* charProperties;

		private static object StaticLock
		{
			get
			{
				if (s_Lock == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref s_Lock, value, null);
				}
				return s_Lock;
			}
		}

		internal unsafe static XmlCharType Instance
		{
			get
			{
				if (s_CharProperties == null)
				{
					InitInstance();
				}
				return new XmlCharType(s_CharProperties);
			}
		}

		private unsafe static void InitInstance()
		{
			lock (StaticLock)
			{
				if (s_CharProperties == null)
				{
					UnmanagedMemoryStream unmanagedMemoryStream = (UnmanagedMemoryStream)Assembly.GetExecutingAssembly().GetManifestResourceStream("XmlCharType.bin");
					byte* positionPointer = unmanagedMemoryStream.PositionPointer;
					Thread.MemoryBarrier();
					s_CharProperties = positionPointer;
				}
			}
		}

		private unsafe XmlCharType(byte* charProperties)
		{
			this.charProperties = charProperties;
		}

		public unsafe bool IsWhiteSpace(char ch)
		{
			return (charProperties[(int)ch] & 1) != 0;
		}

		public unsafe bool IsLetter(char ch)
		{
			return (charProperties[(int)ch] & 2) != 0;
		}

		public bool IsExtender(char ch)
		{
			return ch == '·';
		}

		public unsafe bool IsNCNameChar(char ch)
		{
			return (charProperties[(int)ch] & 8) != 0;
		}

		public unsafe bool IsStartNCNameChar(char ch)
		{
			return (charProperties[(int)ch] & 4) != 0;
		}

		public unsafe bool IsCharData(char ch)
		{
			return (charProperties[(int)ch] & 0x10) != 0;
		}

		public unsafe bool IsPubidChar(char ch)
		{
			return (charProperties[(int)ch] & 0x20) != 0;
		}

		internal unsafe bool IsTextChar(char ch)
		{
			return (charProperties[(int)ch] & 0x40) != 0;
		}

		internal unsafe bool IsAttributeValueChar(char ch)
		{
			return (charProperties[(int)ch] & 0x80) != 0;
		}

		public bool IsNameChar(char ch)
		{
			if (!IsNCNameChar(ch))
			{
				return ch == ':';
			}
			return true;
		}

		public bool IsStartNameChar(char ch)
		{
			if (!IsStartNCNameChar(ch))
			{
				return ch == ':';
			}
			return true;
		}

		public bool IsDigit(char ch)
		{
			if (ch >= '0')
			{
				return ch <= '9';
			}
			return false;
		}

		public bool IsHexDigit(char ch)
		{
			if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))
			{
				if (ch >= 'A')
				{
					return ch <= 'F';
				}
				return false;
			}
			return true;
		}

		internal bool IsOnlyWhitespace(string str)
		{
			return IsOnlyWhitespaceWithPos(str) == -1;
		}

		internal unsafe int IsOnlyWhitespaceWithPos(string str)
		{
			if (str != null)
			{
				for (int i = 0; i < str.Length; i++)
				{
					if ((charProperties[(int)str[i]] & 1) == 0)
					{
						return i;
					}
				}
			}
			return -1;
		}

		internal bool IsName(string str)
		{
			if (str.Length == 0 || !IsStartNameChar(str[0]))
			{
				return false;
			}
			for (int i = 1; i < str.Length; i++)
			{
				if (!IsNameChar(str[i]))
				{
					return false;
				}
			}
			return true;
		}

		internal unsafe bool IsNmToken(string str)
		{
			if (str.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < str.Length; i++)
			{
				if ((charProperties[(int)str[i]] & 8) == 0 && str[i] != ':')
				{
					return false;
				}
			}
			return true;
		}

		internal unsafe int IsOnlyCharData(string str)
		{
			if (str != null)
			{
				for (int i = 0; i < str.Length; i++)
				{
					if ((charProperties[(int)str[i]] & 0x10) == 0)
					{
						return i;
					}
				}
			}
			return -1;
		}

		internal unsafe int IsPublicId(string str)
		{
			if (str != null)
			{
				for (int i = 0; i < str.Length; i++)
				{
					if ((charProperties[(int)str[i]] & 0x20) == 0)
					{
						return i;
					}
				}
			}
			return -1;
		}
	}
	internal static class XmlComplianceUtil
	{
		public static string NonCDataNormalize(string value)
		{
			int length = value.Length;
			if (length <= 0)
			{
				return string.Empty;
			}
			int num = 0;
			StringBuilder stringBuilder = null;
			XmlCharType instance = XmlCharType.Instance;
			while (instance.IsWhiteSpace(value[num]))
			{
				num++;
				if (num == length)
				{
					return " ";
				}
			}
			int num2 = num;
			while (num2 < length)
			{
				if (!instance.IsWhiteSpace(value[num2]))
				{
					num2++;
					continue;
				}
				int i;
				for (i = num2 + 1; i < length && instance.IsWhiteSpace(value[i]); i++)
				{
				}
				if (i == length)
				{
					if (stringBuilder == null)
					{
						return value.Substring(num, num2 - num);
					}
					stringBuilder.Append(value, num, num2 - num);
					return stringBuilder.ToString();
				}
				if (i > num2 + 1 || value[num2] != ' ')
				{
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(length);
					}
					stringBuilder.Append(value, num, num2 - num);
					stringBuilder.Append(' ');
					num = i;
					num2 = i;
				}
				else
				{
					num2++;
				}
			}
			if (stringBuilder != null)
			{
				if (num < num2)
				{
					stringBuilder.Append(value, num, num2 - num);
				}
				return stringBuilder.ToString();
			}
			if (num > 0)
			{
				return value.Substring(num, length - num);
			}
			return value;
		}

		public static string CDataNormalize(string value)
		{
			int length = value.Length;
			if (length <= 0)
			{
				return string.Empty;
			}
			int num = 0;
			int num2 = 0;
			StringBuilder stringBuilder = null;
			while (num < length)
			{
				char c = value[num];
				switch (c)
				{
				default:
					num++;
					break;
				case '\t':
				case '\n':
				case '\r':
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(length);
					}
					if (num2 < num)
					{
						stringBuilder.Append(value, num2, num - num2);
					}
					stringBuilder.Append(' ');
					num = ((c != '\r' || num + 1 >= length || value[num + 1] != '\n') ? (num + 1) : (num + 2));
					num2 = num;
					break;
				}
			}
			if (stringBuilder == null)
			{
				return value;
			}
			if (num > num2)
			{
				stringBuilder.Append(value, num2, num - num2);
			}
			return stringBuilder.ToString();
		}

		public static string StripSpaces(string value)
		{
			int length = value.Length;
			if (length <= 0)
			{
				return string.Empty;
			}
			int num = 0;
			StringBuilder stringBuilder = null;
			while (value[num] == ' ')
			{
				num++;
				if (num == length)
				{
					return " ";
				}
			}
			int i;
			for (i = num; i < length; i++)
			{
				if (value[i] != ' ')
				{
					continue;
				}
				int j;
				for (j = i + 1; j < length && value[j] == ' '; j++)
				{
				}
				if (j == length)
				{
					if (stringBuilder == null)
					{
						return value.Substring(num, i - num);
					}
					stringBuilder.Append(value, num, i - num);
					return stringBuilder.ToString();
				}
				if (j > i + 1)
				{
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(length);
					}
					stringBuilder.Append(value, num, i - num + 1);
					num = j;
					i = j - 1;
				}
			}
			if (stringBuilder == null)
			{
				if (num != 0)
				{
					return value.Substring(num, length - num);
				}
				return value;
			}
			if (i > num)
			{
				stringBuilder.Append(value, num, i - num);
			}
			return stringBuilder.ToString();
		}

		public static void StripSpaces(char[] value, int index, ref int len)
		{
			if (len <= 0)
			{
				return;
			}
			int num = index;
			int num2 = index + len;
			while (value[num] == ' ')
			{
				num++;
				if (num == num2)
				{
					len = 1;
					return;
				}
			}
			int num3 = num - index;
			for (int i = num; i < num2; i++)
			{
				char c;
				if ((c = value[i]) == ' ')
				{
					int j;
					for (j = i + 1; j < num2 && value[j] == ' '; j++)
					{
					}
					if (j == num2)
					{
						num3 += j - i;
						break;
					}
					if (j > i + 1)
					{
						num3 += j - i - 1;
						i = j - 1;
					}
				}
				value[i - num3] = c;
			}
			len -= num3;
		}

		public static bool IsValidLanguageID(char[] value, int startPos, int length)
		{
			int num = length;
			if (num < 2)
			{
				return false;
			}
			bool flag = false;
			int num2 = startPos;
			XmlCharType instance = XmlCharType.Instance;
			char c = value[num2];
			if (instance.IsLetter(c))
			{
				if (instance.IsLetter(value[++num2]))
				{
					if (num == 2)
					{
						return true;
					}
					num--;
					num2++;
				}
				else if ('I' != c && 'i' != c && 'X' != c && 'x' != c)
				{
					return false;
				}
				if (value[num2] != '-')
				{
					return false;
				}
				num -= 2;
				while (num-- > 0)
				{
					c = value[++num2];
					if (instance.IsLetter(c))
					{
						flag = true;
						continue;
					}
					if (c == '-' && flag)
					{
						flag = false;
						continue;
					}
					return false;
				}
				if (flag)
				{
					return true;
				}
			}
			return false;
		}
	}
	internal enum ExceptionType
	{
		ArgumentException,
		XmlException
	}
	public enum XmlDateTimeSerializationMode
	{
		Local,
		Utc,
		Unspecified,
		RoundtripKind
	}
	public class XmlConvert
	{
		internal const int SurHighStart = 55296;

		internal const int SurHighEnd = 56319;

		internal const int SurLowStart = 56320;

		internal const int SurLowEnd = 57343;

		internal const int SurMask = 64512;

		internal static char[] crt = new char[3] { '\n', '\r', '\t' };

		private static readonly int c_EncodedCharLength = 7;

		private static Regex c_EncodeCharPattern;

		private static Regex c_DecodeCharPattern;

		private static string[] s_allDateTimeFormats;

		internal static readonly char[] WhitespaceChars = new char[4] { ' ', '\t', '\n', '\r' };

		private static string[] AllDateTimeFormats
		{
			get
			{
				if (s_allDateTimeFormats == null)
				{
					CreateAllDateTimeFormats();
				}
				return s_allDateTimeFormats;
			}
		}

		public static string EncodeName(string name)
		{
			return EncodeName(name, first: true, local: false);
		}

		public static string EncodeNmToken(string name)
		{
			return EncodeName(name, first: false, local: false);
		}

		public static string EncodeLocalName(string name)
		{
			return EncodeName(name, first: true, local: true);
		}

		public static string DecodeName(string name)
		{
			if (name == null || name.Length == 0)
			{
				return name;
			}
			StringBuilder stringBuilder = null;
			int length = name.Length;
			int num = 0;
			int num2 = name.IndexOf('_');
			MatchCollection matchCollection = null;
			IEnumerator enumerator = null;
			if (num2 >= 0)
			{
				if (c_DecodeCharPattern == null)
				{
					c_DecodeCharPattern = new Regex("_[Xx]([0-9a-fA-F]{4}|[0-9a-fA-F]{8})_");
				}
				matchCollection = c_DecodeCharPattern.Matches(name, num2);
				enumerator = matchCollection.GetEnumerator();
				int num3 = -1;
				if (enumerator != null && enumerator.MoveNext())
				{
					Match match = (Match)enumerator.Current;
					num3 = match.Index;
				}
				for (int i = 0; i < length - c_EncodedCharLength + 1; i++)
				{
					if (i != num3)
					{
						continue;
					}
					if (enumerator.MoveNext())
					{
						Match match2 = (Match)enumerator.Current;
						num3 = match2.Index;
					}
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(length + 20);
					}
					stringBuilder.Append(name, num, i - num);
					if (name[i + 6] != '_')
					{
						int num4 = FromHex(name[i + 2]) * 268435456 + FromHex(name[i + 3]) * 16777216 + FromHex(name[i + 4]) * 1048576 + FromHex(name[i + 5]) * 65536 + FromHex(name[i + 6]) * 4096 + FromHex(name[i + 7]) * 256 + FromHex(name[i + 8]) * 16 + FromHex(name[i + 9]);
						if (num4 >= 65536)
						{
							if (num4 <= 1114111)
							{
								num = i + c_EncodedCharLength + 4;
								char c = (char)((num4 - 65536) / 1024 + 55296);
								char value = (char)(num4 - (c - 55296) * 1024 - 65536 + 56320);
								stringBuilder.Append(c);
								stringBuilder.Append(value);
							}
						}
						else
						{
							num = i + c_EncodedCharLength + 4;
							stringBuilder.Append((char)num4);
						}
						i += c_EncodedCharLength - 1 + 4;
					}
					else
					{
						num = i + c_EncodedCharLength;
						stringBuilder.Append((char)(FromHex(name[i + 2]) * 4096 + FromHex(name[i + 3]) * 256 + FromHex(name[i + 4]) * 16 + FromHex(name[i + 5])));
						i += c_EncodedCharLength - 1;
					}
				}
				if (num == 0)
				{
					return name;
				}
				if (num < length)
				{
					stringBuilder.Append(name, num, length - num);
				}
				return stringBuilder.ToString();
			}
			return name;
		}

		private static string EncodeName(string name, bool first, bool local)
		{
			if (name == null)
			{
				return name;
			}
			if (name.Length == 0)
			{
				if (!first)
				{
					throw new XmlException("Xml_InvalidNmToken", name);
				}
				return name;
			}
			StringBuilder stringBuilder = null;
			int length = name.Length;
			int num = 0;
			int i = 0;
			XmlCharType instance = XmlCharType.Instance;
			int num2 = name.IndexOf('_');
			MatchCollection matchCollection = null;
			IEnumerator enumerator = null;
			if (num2 >= 0)
			{
				if (c_EncodeCharPattern == null)
				{
					c_EncodeCharPattern = new Regex("(?<=_)[Xx]([0-9a-fA-F]{4}|[0-9a-fA-F]{8})_");
				}
				matchCollection = c_EncodeCharPattern.Matches(name, num2);
				enumerator = matchCollection.GetEnumerator();
			}
			int num3 = -1;
			if (enumerator != null && enumerator.MoveNext())
			{
				Match match = (Match)enumerator.Current;
				num3 = match.Index - 1;
			}
			if (first && ((!instance.IsStartNCNameChar(name[0]) && (local || (!local && name[0] != ':'))) || num3 == 0))
			{
				if (stringBuilder == null)
				{
					stringBuilder = new StringBuilder(length + 20);
				}
				stringBuilder.Append("_x");
				if (length > 1 && name[0] >= '\ud800' && name[0] <= '\udbff' && name[1] >= '\udc00' && name[1] <= '\udfff')
				{
					int num4 = name[0];
					int num5 = name[1];
					stringBuilder.Append(((num4 - 55296) * 1024 + (num5 - 56320) + 65536).ToString("X8", CultureInfo.InvariantCulture));
					i++;
					num = 2;
				}
				else
				{
					stringBuilder.Append(((int)name[0]).ToString("X4", CultureInfo.InvariantCulture));
					num = 1;
				}
				stringBuilder.Append("_");
				i++;
				if (num3 == 0 && enumerator.MoveNext())
				{
					Match match2 = (Match)enumerator.Current;
					num3 = match2.Index - 1;
				}
			}
			for (; i < length; i++)
			{
				if ((local && !instance.IsNCNameChar(name[i])) || (!local && !instance.IsNameChar(name[i])) || num3 == i)
				{
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(length + 20);
					}
					if (num3 == i && enumerator.MoveNext())
					{
						Match match3 = (Match)enumerator.Current;
						num3 = match3.Index - 1;
					}
					stringBuilder.Append(name, num, i - num);
					stringBuilder.Append("_x");
					if (length > i + 1 && name[i] >= '\ud800' && name[i] <= '\udbff' && name[i + 1] >= '\udc00' && name[i + 1] <= '\udfff')
					{
						int num6 = name[i];
						int num7 = name[i + 1];
						stringBuilder.Append(((num6 - 55296) * 1024 + (num7 - 56320) + 65536).ToString("X8", CultureInfo.InvariantCulture));
						num = i + 2;
						i++;
					}
					else
					{
						stringBuilder.Append(((int)name[i]).ToString("X4", CultureInfo.InvariantCulture));
						num = i + 1;
					}
					stringBuilder.Append("_");
				}
			}
			if (num == 0)
			{
				return name;
			}
			if (num < length)
			{
				stringBuilder.Append(name, num, length - num);
			}
			return stringBuilder.ToString();
		}

		private static int FromHex(char digit)
		{
			if (digit > '9')
			{
				return ((digit <= 'F') ? (digit - 65) : (digit - 97)) + 10;
			}
			return digit - 48;
		}

		internal static byte[] FromBinHexString(string s)
		{
			return FromBinHexString(s, allowOddCount: true);
		}

		internal static byte[] FromBinHexString(string s, bool allowOddCount)
		{
			return BinHexDecoder.Decode(s.ToCharArray(), allowOddCount);
		}

		internal static string ToBinHexString(byte[] inArray)
		{
			return BinHexEncoder.Encode(inArray, 0, inArray.Length);
		}

		public unsafe static string VerifyName(string name)
		{
			if (name == null || name.Length == 0)
			{
				throw new ArgumentNullException("name");
			}
			XmlCharType instance = XmlCharType.Instance;
			char c = name[0];
			if ((instance.charProperties[(int)c] & 4) == 0 && c != ':')
			{
				throw new XmlException("Xml_BadStartNameChar", XmlException.BuildCharExceptionStr(c));
			}
			for (int i = 1; i < name.Length; i++)
			{
				if ((instance.charProperties[(int)name[i]] & 8) == 0 && name[i] != ':')
				{
					throw new XmlException("Xml_BadNameChar", XmlException.BuildCharExceptionStr(name[i]));
				}
			}
			return name;
		}

		internal static Exception TryVerifyName(string name)
		{
			if (name == null || name.Length == 0)
			{
				return new XmlException("Xml_EmptyName", string.Empty);
			}
			XmlCharType instance = XmlCharType.Instance;
			char c = name[0];
			if (!instance.IsStartNameChar(c) && c != ':')
			{
				return new XmlException("Xml_BadStartNameChar", XmlException.BuildCharExceptionStr(c));
			}
			for (int i = 1; i < name.Length; i++)
			{
				c = name[i];
				if (!instance.IsNameChar(c) && c != ':')
				{
					return new XmlException("Xml_BadNameChar", XmlException.BuildCharExceptionStr(c));
				}
			}
			return null;
		}

		internal static string VerifyQName(string name)
		{
			return VerifyQName(name, ExceptionType.XmlException);
		}

		internal unsafe static string VerifyQName(string name, ExceptionType exceptionType)
		{
			if (name == null || name.Length == 0)
			{
				throw new ArgumentException("name");
			}
			XmlCharType instance = XmlCharType.Instance;
			int length = name.Length;
			int i = 0;
			int num = -1;
			for (; (instance.charProperties[(int)name[i]] & 4u) != 0; i++)
			{
				for (i++; i < length && (instance.charProperties[(int)name[i]] & 8u) != 0; i++)
				{
				}
				if (i == length)
				{
					return name;
				}
				if (name[i] != ':' || num != -1 || i + 1 >= length)
				{
					break;
				}
				num = i;
			}
			throw CreateException("Xml_BadNameChar", XmlException.BuildCharExceptionStr(name[i]), exceptionType);
		}

		public static string VerifyNCName(string name)
		{
			if (name == null || name.Length == 0)
			{
				throw new ArgumentNullException("name");
			}
			return ValidateNames.ParseNCNameThrow(name);
		}

		internal static Exception TryVerifyNCName(string name)
		{
			int num = ValidateNames.ParseNCName(name, 0);
			if (num == 0 || num != name.Length)
			{
				return ValidateNames.GetInvalidNameException(name, 0, num);
			}
			return null;
		}

		public static string VerifyTOKEN(string token)
		{
			if (token == null || token.Length == 0)
			{
				return token;
			}
			if (token[0] == ' ' || token[token.Length - 1] == ' ' || token.IndexOfAny(crt) != -1 || token.IndexOf("  ", StringComparison.Ordinal) != -1)
			{
				throw new XmlException("Sch_NotTokenString", token);
			}
			return token;
		}

		internal static Exception TryVerifyTOKEN(string token)
		{
			if (token == null || token.Length == 0)
			{
				return null;
			}
			if (token[0] == ' ' || token[token.Length - 1] == ' ' || token.IndexOfAny(crt) != -1 || token.IndexOf("  ", StringComparison.Ordinal) != -1)
			{
				return new XmlException("Sch_NotTokenString", token);
			}
			return null;
		}

		public static string VerifyNMTOKEN(string name)
		{
			return VerifyNMTOKEN(name, ExceptionType.XmlException);
		}

		internal static string VerifyNMTOKEN(string name, ExceptionType exceptionType)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (name.Length == 0)
			{
				throw CreateException("Xml_InvalidNmToken", name, exceptionType);
			}
			XmlCharType instance = XmlCharType.Instance;
			for (int i = 0; i < name.Length; i++)
			{
				if (!instance.IsNameChar(name[i]))
				{
					throw CreateException("Xml_BadNameChar", XmlException.BuildCharExceptionStr(name[i]), exceptionType);
				}
			}
			return name;
		}

		internal static Exception TryVerifyNMTOKEN(string name)
		{
			if (name == null || name.Length == 0)
			{
				return new XmlException("Xml_EmptyName", string.Empty);
			}
			XmlCharType instance = XmlCharType.Instance;
			for (int i = 0; i < name.Length; i++)
			{
				if (!instance.IsNameChar(name[i]))
				{
					return new XmlException("Xml_BadNameChar", XmlException.BuildCharExceptionStr(name[i]));
				}
			}
			return null;
		}

		internal static string VerifyNormalizedString(string str)
		{
			if (str.IndexOfAny(crt) != -1)
			{
				throw new XmlSchemaException("Sch_NotNormalizedString", str);
			}
			return str;
		}

		internal static Exception TryVerifyNormalizedString(string str)
		{
			if (str.IndexOfAny(crt) != -1)
			{
				return new XmlSchemaException("Sch_NotNormalizedString", str);
			}
			return null;
		}

		public static string ToString(bool value)
		{
			if (!value)
			{
				return "false";
			}
			return "true";
		}

		public static string ToString(char value)
		{
			return value.ToString(null);
		}

		public static string ToString(decimal value)
		{
			return value.ToString(null, NumberFormatInfo.InvariantInfo);
		}

		[CLSCompliant(false)]
		public static string ToString(sbyte value)
		{
			return value.ToString(null, NumberFormatInfo.InvariantInfo);
		}

		public static string ToString(short value)
		{
			return value.ToString(null, NumberFormatInfo.InvariantInfo);
		}

		public static string ToString(int value)
		{
			return value.ToString(null, NumberFormatInfo.InvariantInfo);
		}

		public static string ToString(long value)
		{
			return value.ToString(null, NumberFormatInfo.InvariantInfo);
		}

		public static string ToString(byte value)
		{
			return value.ToString(null, NumberFormatInfo.InvariantInfo);
		}

		[CLSCompliant(false)]
		public static string ToString(ushort value)
		{
			return value.ToString(null, NumberFormatInfo.InvariantInfo);
		}

		[CLSCompliant(false)]
		public static string ToString(uint value)
		{
			return value.ToString(null, NumberFormatInfo.InvariantInfo);
		}

		[CLSCompliant(false)]
		public static string ToString(ulong value)
		{
			return value.ToString(null, NumberFormatInfo.InvariantInfo);
		}

		public static string ToString(float value)
		{
			if (float.IsNegativeInfinity(value))
			{
				return "-INF";
			}
			if (float.IsPositiveInfinity(value))
			{
				return "INF";
			}
			if (IsNegativeZero(value))
			{
				return "-0";
			}
			return value.ToString("R", NumberFormatInfo.InvariantInfo);
		}

		public static string ToString(double value)
		{
			if (double.IsNegativeInfinity(value))
			{
				return "-INF";
			}
			if (double.IsPositiveInfinity(value))
			{
				return "INF";
			}
			if (IsNegativeZero(value))
			{
				return "-0";
			}
			return value.ToString("R", NumberFormatInfo.InvariantInfo);
		}

		public static string ToString(TimeSpan value)
		{
			return new XsdDuration(value).ToString();
		}

		[Obsolete("Use XmlConvert.ToString() that takes in XmlDateTimeSerializationMode")]
		public static string ToString(DateTime value)
		{
			return ToString(value, "yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz");
		}

		public static string ToString(DateTime value, string format)
		{
			return value.ToString(format, DateTimeFormatInfo.InvariantInfo);
		}

		public static string ToString(DateTime value, XmlDateTimeSerializationMode dateTimeOption)
		{
			switch (dateTimeOption)
			{
			case XmlDateTimeSerializationMode.Local:
				value = SwitchToLocalTime(value);
				break;
			case XmlDateTimeSerializationMode.Utc:
				value = SwitchToUtcTime(value);
				break;
			case XmlDateTimeSerializationMode.Unspecified:
				value = new DateTime(value.Ticks, DateTimeKind.Unspecified);
				break;
			default:
				throw new ArgumentException(Res.GetString("Sch_InvalidDateTimeOption", dateTimeOption));
			case XmlDateTimeSerializationMode.RoundtripKind:
				break;
			}
			return new XsdDateTime(value, XsdDateTimeFlags.DateTime).ToString();
		}

		public static string ToString(DateTimeOffset value)
		{
			return new XsdDateTime(value).ToString();
		}

		public static string ToString(DateTimeOffset value, string format)
		{
			return value.ToString(format, DateTimeFormatInfo.InvariantInfo);
		}

		public static string ToString(Guid value)
		{
			return value.ToString();
		}

		public static bool ToBoolean(string s)
		{
			s = TrimString(s);
			switch (s)
			{
			case "1":
			case "true":
				return true;
			case "0":
			case "false":
				return false;
			default:
				throw new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Boolean"));
			}
		}

		internal static Exception TryToBoolean(string s, out bool result)
		{
			s = TrimString(s);
			switch (s)
			{
			case "0":
			case "false":
				result = false;
				return null;
			case "1":
			case "true":
				result = true;
				return null;
			default:
				result = false;
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Boolean"));
			}
		}

		public static char ToChar(string s)
		{
			return char.Parse(s);
		}

		internal static Exception TryToChar(string s, out char result)
		{
			if (!char.TryParse(s, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Char"));
			}
			return null;
		}

		public static decimal ToDecimal(string s)
		{
			return decimal.Parse(s, NumberStyles.Integer | NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo);
		}

		internal static Exception TryToDecimal(string s, out decimal result)
		{
			if (!decimal.TryParse(s, NumberStyles.Integer | NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Decimal"));
			}
			return null;
		}

		internal static decimal ToInteger(string s)
		{
			return decimal.Parse(s, NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
		}

		internal static Exception TryToInteger(string s, out decimal result)
		{
			if (!decimal.TryParse(s, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Integer"));
			}
			return null;
		}

		[CLSCompliant(false)]
		public static sbyte ToSByte(string s)
		{
			return sbyte.Parse(s, NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
		}

		internal static Exception TryToSByte(string s, out sbyte result)
		{
			if (!sbyte.TryParse(s, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "SByte"));
			}
			return null;
		}

		public static short ToInt16(string s)
		{
			return short.Parse(s, NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
		}

		internal static Exception TryToInt16(string s, out short result)
		{
			if (!short.TryParse(s, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Int16"));
			}
			return null;
		}

		public static int ToInt32(string s)
		{
			return int.Parse(s, NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
		}

		internal static Exception TryToInt32(string s, out int result)
		{
			if (!int.TryParse(s, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Int32"));
			}
			return null;
		}

		public static long ToInt64(string s)
		{
			return long.Parse(s, NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
		}

		internal static Exception TryToInt64(string s, out long result)
		{
			if (!long.TryParse(s, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Int64"));
			}
			return null;
		}

		public static byte ToByte(string s)
		{
			return byte.Parse(s, NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
		}

		internal static Exception TryToByte(string s, out byte result)
		{
			if (!byte.TryParse(s, NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Byte"));
			}
			return null;
		}

		[CLSCompliant(false)]
		public static ushort ToUInt16(string s)
		{
			return ushort.Parse(s, NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
		}

		internal static Exception TryToUInt16(string s, out ushort result)
		{
			if (!ushort.TryParse(s, NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "UInt16"));
			}
			return null;
		}

		[CLSCompliant(false)]
		public static uint ToUInt32(string s)
		{
			return uint.Parse(s, NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
		}

		internal static Exception TryToUInt32(string s, out uint result)
		{
			if (!uint.TryParse(s, NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "UInt32"));
			}
			return null;
		}

		[CLSCompliant(false)]
		public static ulong ToUInt64(string s)
		{
			return ulong.Parse(s, NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo);
		}

		internal static Exception TryToUInt64(string s, out ulong result)
		{
			if (!ulong.TryParse(s, NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "UInt64"));
			}
			return null;
		}

		public static float ToSingle(string s)
		{
			s = TrimString(s);
			if (s == "-INF")
			{
				return float.NegativeInfinity;
			}
			if (s == "INF")
			{
				return float.PositiveInfinity;
			}
			float num = float.Parse(s, NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent, NumberFormatInfo.InvariantInfo);
			if (num == 0f && s[0] == '-')
			{
				return -0f;
			}
			return num;
		}

		internal static Exception TryToSingle(string s, out float result)
		{
			s = TrimString(s);
			if (s == "-INF")
			{
				result = float.NegativeInfinity;
				return null;
			}
			if (s == "INF")
			{
				result = float.PositiveInfinity;
				return null;
			}
			if (!float.TryParse(s, NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Single"));
			}
			if (result == 0f && s[0] == '-')
			{
				result = -0f;
			}
			return null;
		}

		public static double ToDouble(string s)
		{
			s = TrimString(s);
			if (s == "-INF")
			{
				return double.NegativeInfinity;
			}
			if (s == "INF")
			{
				return double.PositiveInfinity;
			}
			double num = double.Parse(s, NumberStyles.Float, NumberFormatInfo.InvariantInfo);
			if (num == 0.0 && s[0] == '-')
			{
				return -0.0;
			}
			return num;
		}

		internal static Exception TryToDouble(string s, out double result)
		{
			s = TrimString(s);
			if (s == "-INF")
			{
				result = double.NegativeInfinity;
				return null;
			}
			if (s == "INF")
			{
				result = double.PositiveInfinity;
				return null;
			}
			if (!double.TryParse(s, NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent, NumberFormatInfo.InvariantInfo, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Double"));
			}
			if (result == 0.0 && s[0] == '-')
			{
				result = -0.0;
			}
			return null;
		}

		internal static double ToXPathDouble(object o)
		{
			if (o is string value)
			{
				string text = TrimString(value);
				if (text.Length != 0 && text[0] != '+' && double.TryParse(text, NumberStyles.AllowTrailingWhite | NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint, NumberFormatInfo.InvariantInfo, out var result))
				{
					return result;
				}
				return double.NaN;
			}
			if (o is double)
			{
				return (double)o;
			}
			if (o is bool)
			{
				if (!(bool)o)
				{
					return 0.0;
				}
				return 1.0;
			}
			try
			{
				return Convert.ToDouble(o, NumberFormatInfo.InvariantInfo);
			}
			catch (FormatException)
			{
			}
			catch (OverflowException)
			{
			}
			catch (ArgumentNullException)
			{
			}
			return double.NaN;
		}

		internal static string ToXPathString(object value)
		{
			if (value is string result)
			{
				return result;
			}
			if (value is double num)
			{
				return num.ToString("R", NumberFormatInfo.InvariantInfo);
			}
			if (value is bool)
			{
				if (!(bool)value)
				{
					return "false";
				}
				return "true";
			}
			return Convert.ToString(value, NumberFormatInfo.InvariantInfo);
		}

		internal static double XPathRound(double value)
		{
			double num = Math.Round(value);
			if (value - num != 0.5)
			{
				return num;
			}
			return num + 1.0;
		}

		public static TimeSpan ToTimeSpan(string s)
		{
			XsdDuration xsdDuration;
			try
			{
				xsdDuration = new XsdDuration(s);
			}
			catch (Exception)
			{
				throw new FormatException(Res.GetString("XmlConvert_BadFormat", s, "TimeSpan"));
			}
			return xsdDuration.ToTimeSpan();
		}

		internal static Exception TryToTimeSpan(string s, out TimeSpan result)
		{
			XsdDuration result2;
			Exception ex = XsdDuration.TryParse(s, out result2);
			if (ex != null)
			{
				result = TimeSpan.MinValue;
				return ex;
			}
			return result2.TryToTimeSpan(out result);
		}

		private static void CreateAllDateTimeFormats()
		{
			if (s_allDateTimeFormats == null)
			{
				s_allDateTimeFormats = new string[24]
				{
					"yyyy-MM-ddTHH:mm:ss.FFFFFFFzzzzzz", "yyyy-MM-ddTHH:mm:ss.FFFFFFF", "yyyy-MM-ddTHH:mm:ss.FFFFFFFZ", "HH:mm:ss.FFFFFFF", "HH:mm:ss.FFFFFFFZ", "HH:mm:ss.FFFFFFFzzzzzz", "yyyy-MM-dd", "yyyy-MM-ddZ", "yyyy-MM-ddzzzzzz", "yyyy-MM",
					"yyyy-MMZ", "yyyy-MMzzzzzz", "yyyy", "yyyyZ", "yyyyzzzzzz", "--MM-dd", "--MM-ddZ", "--MM-ddzzzzzz", "---dd", "---ddZ",
					"---ddzzzzzz", "--MM--", "--MM--Z", "--MM--zzzzzz"
				};
			}
		}

		[Obsolete("Use XmlConvert.ToDateTime() that takes in XmlDateTimeSerializationMode")]
		public static DateTime ToDateTime(string s)
		{
			return ToDateTime(s, AllDateTimeFormats);
		}

		public static DateTime ToDateTime(string s, string format)
		{
			return DateTime.ParseExact(s, format, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowLeadingWhite | DateTimeStyles.AllowTrailingWhite);
		}

		public static DateTime ToDateTime(string s, string[] formats)
		{
			return DateTime.ParseExact(s, formats, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowLeadingWhite | DateTimeStyles.AllowTrailingWhite);
		}

		public static DateTime ToDateTime(string s, XmlDateTimeSerializationMode dateTimeOption)
		{
			XsdDateTime xsdDateTime = new XsdDateTime(s, XsdDateTimeFlags.AllXsd);
			DateTime dateTime = xsdDateTime;
			switch (dateTimeOption)
			{
			case XmlDateTimeSerializationMode.Local:
				dateTime = SwitchToLocalTime(dateTime);
				break;
			case XmlDateTimeSerializationMode.Utc:
				dateTime = SwitchToUtcTime(dateTime);
				break;
			case XmlDateTimeSerializationMode.Unspecified:
				dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Unspecified);
				break;
			default:
				throw new ArgumentException(Res.GetString("Sch_InvalidDateTimeOption", dateTimeOption));
			case XmlDateTimeSerializationMode.RoundtripKind:
				break;
			}
			return dateTime;
		}

		public static DateTimeOffset ToDateTimeOffset(string s)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			XsdDateTime xsdDateTime = new XsdDateTime(s, XsdDateTimeFlags.AllXsd);
			return xsdDateTime;
		}

		public static DateTimeOffset ToDateTimeOffset(string s, string format)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			return DateTimeOffset.ParseExact(s, format, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowLeadingWhite | DateTimeStyles.AllowTrailingWhite);
		}

		public static DateTimeOffset ToDateTimeOffset(string s, string[] formats)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			return DateTimeOffset.ParseExact(s, formats, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowLeadingWhite | DateTimeStyles.AllowTrailingWhite);
		}

		public static Guid ToGuid(string s)
		{
			return new Guid(s);
		}

		internal static Exception TryToGuid(string s, out Guid result)
		{
			Exception result2 = null;
			result = Guid.Empty;
			try
			{
				result = new Guid(s);
				return result2;
			}
			catch (ArgumentException)
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Guid"));
			}
			catch (FormatException)
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Guid"));
			}
		}

		private static DateTime SwitchToLocalTime(DateTime value)
		{
			return value.Kind switch
			{
				DateTimeKind.Local => value, 
				DateTimeKind.Unspecified => new DateTime(value.Ticks, DateTimeKind.Local), 
				DateTimeKind.Utc => value.ToLocalTime(), 
				_ => value, 
			};
		}

		private static DateTime SwitchToUtcTime(DateTime value)
		{
			return value.Kind switch
			{
				DateTimeKind.Utc => value, 
				DateTimeKind.Unspecified => new DateTime(value.Ticks, DateTimeKind.Utc), 
				DateTimeKind.Local => value.ToUniversalTime(), 
				_ => value, 
			};
		}

		internal static Uri ToUri(string s)
		{
			if (s != null && s.Length > 0)
			{
				s = TrimString(s);
				if (s.Length == 0 || s.IndexOf("##", StringComparison.Ordinal) != -1)
				{
					throw new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Uri"));
				}
			}
			if (!Uri.TryCreate(s, UriKind.RelativeOrAbsolute, out var result))
			{
				throw new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Uri"));
			}
			return result;
		}

		internal static Exception TryToUri(string s, out Uri result)
		{
			result = null;
			if (s != null && s.Length > 0)
			{
				s = TrimString(s);
				if (s.Length == 0 || s.IndexOf("##", StringComparison.Ordinal) != -1)
				{
					return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Uri"));
				}
			}
			if (!Uri.TryCreate(s, UriKind.RelativeOrAbsolute, out result))
			{
				return new FormatException(Res.GetString("XmlConvert_BadFormat", s, "Uri"));
			}
			return null;
		}

		internal static bool StrEqual(char[] chars, int strPos1, int strLen1, string str2)
		{
			if (strLen1 != str2.Length)
			{
				return false;
			}
			int i;
			for (i = 0; i < strLen1 && chars[strPos1 + i] == str2[i]; i++)
			{
			}
			return i == strLen1;
		}

		internal static string TrimString(string value)
		{
			return value.Trim(WhitespaceChars);
		}

		internal static string[] SplitString(string value)
		{
			return value.Split(WhitespaceChars, StringSplitOptions.RemoveEmptyEntries);
		}

		internal static bool IsNegativeZero(double value)
		{
			if (value == 0.0 && BitConverter.DoubleToInt64Bits(value) == BitConverter.DoubleToInt64Bits(-0.0))
			{
				return true;
			}
			return false;
		}

		internal unsafe static void VerifyCharData(string data, ExceptionType exceptionType)
		{
			if (data == null || data.Length == 0)
			{
				return;
			}
			XmlCharType instance = XmlCharType.Instance;
			int num = 0;
			int length = data.Length;
			while (true)
			{
				if (num < length && (instance.charProperties[(int)data[num]] & 0x10u) != 0)
				{
					num++;
					continue;
				}
				if (num == length)
				{
					return;
				}
				char c = data[num];
				if (c < '\ud800' || c > '\udbff')
				{
					break;
				}
				if (num + 1 == length)
				{
					throw CreateException("Xml_InvalidSurrogateMissingLowChar", exceptionType);
				}
				c = data[num + 1];
				if (c >= '\udc00' && c <= '\udfff')
				{
					num += 2;
					continue;
				}
				throw CreateInvalidSurrogatePairException(data[num + 1], data[num], exceptionType);
			}
			throw CreateInvalidCharException(data[num]);
		}

		internal unsafe static void VerifyCharData(char[] data, int offset, int len, ExceptionType exceptionType)
		{
			if (data == null || len == 0)
			{
				return;
			}
			XmlCharType instance = XmlCharType.Instance;
			int num = offset;
			int num2 = offset + len;
			while (true)
			{
				if (num < num2 && (instance.charProperties[(int)data[num]] & 0x10u) != 0)
				{
					num++;
					continue;
				}
				if (num == num2)
				{
					return;
				}
				char c = data[num];
				if (c < '\ud800' || c > '\udbff')
				{
					break;
				}
				if (num + 1 == num2)
				{
					throw CreateException("Xml_InvalidSurrogateMissingLowChar", exceptionType);
				}
				c = data[num + 1];
				if (c >= '\udc00' && c <= '\udfff')
				{
					num += 2;
					continue;
				}
				throw CreateInvalidSurrogatePairException(data[num + 1], data[num], exceptionType);
			}
			throw CreateInvalidCharException(data[num]);
		}

		internal static string EscapeValueForDebuggerDisplay(string value)
		{
			StringBuilder stringBuilder = null;
			int i = 0;
			int num = 0;
			for (; i < value.Length; i++)
			{
				char c = value[i];
				if (c < ' ' || c == '"')
				{
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(value.Length + 4);
					}
					if (i - num > 0)
					{
						stringBuilder.Append(value, num, i - num);
					}
					num = i + 1;
					switch (c)
					{
					case '"':
						stringBuilder.Append("\\\"");
						break;
					case '\r':
						stringBuilder.Append("\\r");
						break;
					case '\n':
						stringBuilder.Append("\\n");
						break;
					case '\t':
						stringBuilder.Append("\\t");
						break;
					default:
						stringBuilder.Append(c);
						break;
					}
				}
			}
			if (stringBuilder == null)
			{
				return value;
			}
			if (i - num > 0)
			{
				stringBuilder.Append(value, num, i - num);
			}
			return stringBuilder.ToString();
		}

		internal static Exception CreateException(string res, ExceptionType exceptionType)
		{
			return exceptionType switch
			{
				ExceptionType.ArgumentException => new ArgumentException(Res.GetString(res)), 
				_ => new XmlException(res, string.Empty), 
			};
		}

		internal static Exception CreateException(string res, string arg, ExceptionType exceptionType)
		{
			return exceptionType switch
			{
				ExceptionType.ArgumentException => new ArgumentException(Res.GetString(res, arg)), 
				_ => new XmlException(res, arg), 
			};
		}

		internal static Exception CreateException(string res, string[] args, ExceptionType exceptionType)
		{
			return exceptionType switch
			{
				ExceptionType.ArgumentException => new ArgumentException(Res.GetString(res, args)), 
				_ => new XmlException(res, args), 
			};
		}

		internal static Exception CreateInvalidSurrogatePairException(char low, char hi)
		{
			return CreateInvalidSurrogatePairException(low, hi, ExceptionType.ArgumentException);
		}

		internal static Exception CreateInvalidSurrogatePairException(char low, char hi, ExceptionType exceptionType)
		{
			string[] array = new string[2];
			uint num = hi;
			array[0] = num.ToString("X", CultureInfo.InvariantCulture);
			uint num2 = low;
			array[1] = num2.ToString("X", CultureInfo.InvariantCulture);
			string[] args = array;
			return CreateException("Xml_InvalidSurrogatePairWithArgs", args, exceptionType);
		}

		internal static Exception CreateInvalidHighSurrogateCharException(char hi)
		{
			return CreateInvalidHighSurrogateCharException(hi, ExceptionType.ArgumentException);
		}

		internal static Exception CreateInvalidHighSurrogateCharException(char hi, ExceptionType exceptionType)
		{
			uint num = hi;
			return CreateException("Xml_InvalidSurrogateHighChar", num.ToString("X", CultureInfo.InvariantCulture), exceptionType);
		}

		internal static Exception CreateInvalidCharException(char invChar)
		{
			return CreateInvalidCharException(invChar, ExceptionType.ArgumentException);
		}

		internal static Exception CreateInvalidCharException(char invChar, ExceptionType exceptionType)
		{
			return CreateException("Xml_InvalidCharacter", XmlException.BuildCharExceptionStr(invChar), exceptionType);
		}

		internal static ArgumentException CreateInvalidNameArgumentException(string name, string argumentName)
		{
			if (name != null)
			{
				return new ArgumentException(Res.GetString("Xml_EmptyName"), argumentName);
			}
			return new ArgumentNullException(argumentName);
		}
	}
	internal class XmlDownloadManager
	{
		private Hashtable connections;

		internal Stream GetStream(Uri uri, ICredentials credentials)
		{
			if (uri.Scheme == "file")
			{
				return new FileStream(uri.LocalPath, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
			}
			return GetNonFileStream(uri, credentials);
		}

		private Stream GetNonFileStream(Uri uri, ICredentials credentials)
		{
			WebRequest webRequest = WebRequest.Create(uri);
			if (credentials != null)
			{
				webRequest.Credentials = credentials;
			}
			WebResponse response = webRequest.GetResponse();
			if (webRequest is HttpWebRequest httpWebRequest)
			{
				lock (this)
				{
					if (connections == null)
					{
						connections = new Hashtable();
					}
					OpenedHost openedHost = (OpenedHost)connections[httpWebRequest.Address.Host];
					if (openedHost == null)
					{
						openedHost = new OpenedHost();
					}
					if (openedHost.nonCachedConnectionsCount < httpWebRequest.ServicePoint.ConnectionLimit - 1)
					{
						if (openedHost.nonCachedConnectionsCount == 0)
						{
							connections.Add(httpWebRequest.Address.Host, openedHost);
						}
						openedHost.nonCachedConnectionsCount++;
						return new XmlRegisteredNonCachedStream(response.GetResponseStream(), this, httpWebRequest.Address.Host);
					}
					return new XmlCachedStream(response.ResponseUri, response.GetResponseStream());
				}
			}
			return response.GetResponseStream();
		}

		internal void Remove(string host)
		{
			lock (this)
			{
				OpenedHost openedHost = (OpenedHost)connections[host];
				if (openedHost != null && --openedHost.nonCachedConnectionsCount == 0)
				{
					connections.Remove(host);
				}
			}
		}
	}
	internal class OpenedHost
	{
		internal int nonCachedConnectionsCount;
	}
	internal class XmlRegisteredNonCachedStream : Stream
	{
		protected Stream stream;

		private XmlDownloadManager downloadManager;

		private string host;

		public override bool CanRead => stream.CanRead;

		public override bool CanSeek => stream.CanSeek;

		public override bool CanWrite => stream.CanWrite;

		public override long Length => stream.Length;

		public override long Position
		{
			get
			{
				return stream.Position;
			}
			set
			{
				stream.Position = value;
			}
		}

		internal XmlRegisteredNonCachedStream(Stream stream, XmlDownloadManager downloadManager, string host)
		{
			this.stream = stream;
			this.downloadManager = downloadManager;
			this.host = host;
		}

		~XmlRegisteredNonCachedStream()
		{
			if (downloadManager != null)
			{
				downloadManager.Remove(host);
			}
			stream = null;
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (disposing && stream != null)
				{
					if (downloadManager != null)
					{
						downloadManager.Remove(host);
					}
					stream.Close();
				}
				stream = null;
				GC.SuppressFinalize(this);
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			return stream.BeginRead(buffer, offset, count, callback, state);
		}

		public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			return BeginWrite(buffer, offset, count, callback, state);
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			return stream.EndRead(asyncResult);
		}

		public override void EndWrite(IAsyncResult asyncResult)
		{
			stream.EndWrite(asyncResult);
		}

		public override void Flush()
		{
			stream.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			return stream.Read(buffer, offset, count);
		}

		public override int ReadByte()
		{
			return stream.ReadByte();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			return stream.Seek(offset, origin);
		}

		public override void SetLength(long value)
		{
			stream.SetLength(value);
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			stream.Write(buffer, offset, count);
		}

		public override void WriteByte(byte value)
		{
			stream.WriteByte(value);
		}
	}
	internal class XmlCachedStream : MemoryStream
	{
		private const int MoveBufferSize = 4096;

		private Uri uri;

		internal XmlCachedStream(Uri uri, Stream stream)
		{
			this.uri = uri;
			try
			{
				byte[] buffer = new byte[4096];
				int num = 0;
				while ((num = stream.Read(buffer, 0, 4096)) > 0)
				{
					Write(buffer, 0, num);
				}
				base.Position = 0L;
			}
			finally
			{
				stream.Close();
			}
		}
	}
	internal class UTF16Decoder : Decoder
	{
		private const int CharSize = 2;

		private bool bigEndian;

		private int lastByte;

		public UTF16Decoder(bool bigEndian)
		{
			lastByte = -1;
			this.bigEndian = bigEndian;
		}

		public override int GetCharCount(byte[] bytes, int index, int count)
		{
			return GetCharCount(bytes, index, count, flush: false);
		}

		public override int GetCharCount(byte[] bytes, int index, int count, bool flush)
		{
			int num = count + ((lastByte >= 0) ? 1 : 0);
			if (flush && num % 2 != 0)
			{
				throw new ArgumentException(Res.GetString("Enc_InvalidByteInEncoding", -1), (string)null);
			}
			return num / 2;
		}

		public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
		{
			int charCount = GetCharCount(bytes, byteIndex, byteCount);
			if (lastByte >= 0)
			{
				if (byteCount == 0)
				{
					return charCount;
				}
				int num = bytes[byteIndex++];
				byteCount--;
				chars[charIndex++] = (bigEndian ? ((char)((lastByte << 8) | num)) : ((char)((num << 8) | lastByte)));
				lastByte = -1;
			}
			if (((uint)byteCount & (true ? 1u : 0u)) != 0)
			{
				lastByte = bytes[byteIndex + --byteCount];
			}
			if (bigEndian == BitConverter.IsLittleEndian)
			{
				int num2 = byteIndex + byteCount;
				if (bigEndian)
				{
					while (byteIndex < num2)
					{
						int num3 = bytes[byteIndex++];
						int num4 = bytes[byteIndex++];
						chars[charIndex++] = (char)((num3 << 8) | num4);
					}
				}
				else
				{
					while (byteIndex < num2)
					{
						int num5 = bytes[byteIndex++];
						int num6 = bytes[byteIndex++];
						chars[charIndex++] = (char)((num6 << 8) | num5);
					}
				}
			}
			else
			{
				Buffer.BlockCopy(bytes, byteIndex, chars, charIndex * 2, byteCount);
			}
			return charCount;
		}

		public override void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed)
		{
			charsUsed = 0;
			bytesUsed = 0;
			if (lastByte >= 0)
			{
				if (byteCount == 0)
				{
					completed = true;
					return;
				}
				int num = bytes[byteIndex++];
				byteCount--;
				bytesUsed++;
				chars[charIndex++] = (bigEndian ? ((char)((lastByte << 8) | num)) : ((char)((num << 8) | lastByte)));
				charCount--;
				charsUsed++;
				lastByte = -1;
			}
			if (charCount * 2 < byteCount)
			{
				byteCount = charCount * 2;
				completed = false;
			}
			else
			{
				completed = true;
			}
			if (bigEndian == BitConverter.IsLittleEndian)
			{
				int num2 = byteIndex;
				int num3 = num2 + (byteCount & -2);
				if (bigEndian)
				{
					while (num2 < num3)
					{
						int num4 = bytes[num2++];
						int num5 = bytes[num2++];
						chars[charIndex++] = (char)((num4 << 8) | num5);
					}
				}
				else
				{
					while (num2 < num3)
					{
						int num6 = bytes[num2++];
						int num7 = bytes[num2++];
						chars[charIndex++] = (char)((num7 << 8) | num6);
					}
				}
			}
			else
			{
				Buffer.BlockCopy(bytes, byteIndex, chars, charIndex * 2, byteCount & -2);
			}
			charsUsed += byteCount / 2;
			bytesUsed += byteCount;
			if (((uint)byteCount & (true ? 1u : 0u)) != 0)
			{
				lastByte = bytes[byteIndex + byteCount - 1];
			}
		}
	}
	internal class SafeAsciiDecoder : Decoder
	{
		public override int GetCharCount(byte[] bytes, int index, int count)
		{
			return count;
		}

		public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
		{
			int num = byteIndex;
			int num2 = charIndex;
			while (num < byteIndex + byteCount)
			{
				chars[num2++] = (char)bytes[num++];
			}
			return byteCount;
		}

		public override void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed)
		{
			if (charCount < byteCount)
			{
				byteCount = charCount;
				completed = false;
			}
			else
			{
				completed = true;
			}
			int num = byteIndex;
			int num2 = charIndex;
			int num3 = byteIndex + byteCount;
			while (num < num3)
			{
				chars[num2++] = (char)bytes[num++];
			}
			charsUsed = byteCount;
			bytesUsed = byteCount;
		}
	}
	internal class Ucs4Encoding : Encoding
	{
		internal Ucs4Decoder ucs4Decoder;

		public override int CodePage => 0;

		internal static Encoding UCS4_Littleendian => new Ucs4Encoding4321();

		internal static Encoding UCS4_Bigendian => new Ucs4Encoding1234();

		internal static Encoding UCS4_2143 => new Ucs4Encoding2143();

		internal static Encoding UCS4_3412 => new Ucs4Encoding3412();

		public override Decoder GetDecoder()
		{
			return ucs4Decoder;
		}

		public override int GetByteCount(char[] chars, int index, int count)
		{
			return checked(count * 4);
		}

		public override int GetByteCount(char[] chars)
		{
			return chars.Length * 4;
		}

		public override byte[] GetBytes(string s)
		{
			return null;
		}

		public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
		{
			return 0;
		}

		public override int GetMaxByteCount(int charCount)
		{
			return 0;
		}

		public override int GetCharCount(byte[] bytes, int index, int count)
		{
			return ucs4Decoder.GetCharCount(bytes, index, count);
		}

		public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
		{
			return ucs4Decoder.GetChars(bytes, byteIndex, byteCount, chars, charIndex);
		}

		public override int GetMaxCharCount(int byteCount)
		{
			return (byteCount + 3) / 4;
		}

		public override int GetCharCount(byte[] bytes)
		{
			return bytes.Length / 4;
		}

		public override Encoder GetEncoder()
		{
			return null;
		}
	}
	internal class Ucs4Encoding1234 : Ucs4Encoding
	{
		public override string EncodingName => "ucs-4 (Bigendian)";

		public Ucs4Encoding1234()
		{
			ucs4Decoder = new Ucs4Decoder1234();
		}

		public override byte[] GetPreamble()
		{
			return new byte[4] { 0, 0, 254, 255 };
		}
	}
	internal class Ucs4Encoding4321 : Ucs4Encoding
	{
		public override string EncodingName => "ucs-4";

		public Ucs4Encoding4321()
		{
			ucs4Decoder = new Ucs4Decoder4321();
		}

		public override byte[] GetPreamble()
		{
			return new byte[4] { 255, 254, 0, 0 };
		}
	}
	internal class Ucs4Encoding2143 : Ucs4Encoding
	{
		public override string EncodingName => "ucs-4 (order 2143)";

		public Ucs4Encoding2143()
		{
			ucs4Decoder = new Ucs4Decoder2143();
		}

		public override byte[] GetPreamble()
		{
			return new byte[4] { 0, 0, 255, 254 };
		}
	}
	internal class Ucs4Encoding3412 : Ucs4Encoding
	{
		public override string EncodingName => "ucs-4 (order 3412)";

		public Ucs4Encoding3412()
		{
			ucs4Decoder = new Ucs4Decoder3412();
		}

		public override byte[] GetPreamble()
		{
			return new byte[4] { 254, 255, 0, 0 };
		}
	}
	internal abstract class Ucs4Decoder : Decoder
	{
		internal byte[] lastBytes = new byte[4];

		internal int lastBytesCount;

		public override int GetCharCount(byte[] bytes, int index, int count)
		{
			return (count + lastBytesCount) / 4;
		}

		internal abstract int GetFullChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);

		public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
		{
			int num = lastBytesCount;
			if (lastBytesCount > 0)
			{
				while (lastBytesCount < 4 && byteCount > 0)
				{
					lastBytes[lastBytesCount] = bytes[byteIndex];
					byteIndex++;
					byteCount--;
					lastBytesCount++;
				}
				if (lastBytesCount < 4)
				{
					return 0;
				}
				num = GetFullChars(lastBytes, 0, 4, chars, charIndex);
				charIndex += num;
				lastBytesCount = 0;
			}
			else
			{
				num = 0;
			}
			num = GetFullChars(bytes, byteIndex, byteCount, chars, charIndex) + num;
			int num2 = byteCount & 3;
			if (num2 >= 0)
			{
				for (int i = 0; i < num2; i++)
				{
					lastBytes[i] = bytes[byteIndex + byteCount - num2 + i];
				}
				lastBytesCount = num2;
			}
			return num;
		}

		public override void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed)
		{
			bytesUsed = 0;
			charsUsed = 0;
			int num = 0;
			int i = lastBytesCount;
			if (i > 0)
			{
				for (; i < 4; i++)
				{
					if (byteCount <= 0)
					{
						break;
					}
					lastBytes[i] = bytes[byteIndex];
					byteIndex++;
					byteCount--;
					bytesUsed++;
				}
				if (i < 4)
				{
					lastBytesCount = i;
					completed = true;
					return;
				}
				num = GetFullChars(lastBytes, 0, 4, chars, charIndex);
				charIndex += num;
				charCount -= num;
				charsUsed = num;
				lastBytesCount = 0;
				if (charCount == 0)
				{
					completed = byteCount == 0;
					return;
				}
			}
			else
			{
				num = 0;
			}
			if (charCount * 4 < byteCount)
			{
				byteCount = charCount * 4;
				completed = false;
			}
			else
			{
				completed = true;
			}
			bytesUsed += byteCount;
			charsUsed = GetFullChars(bytes, byteIndex, byteCount, chars, charIndex) + num;
			int num2 = byteCount & 3;
			if (num2 >= 0)
			{
				for (int j = 0; j < num2; j++)
				{
					lastBytes[j] = bytes[byteIndex + byteCount - num2 + j];
				}
				lastBytesCount = num2;
			}
		}

		internal char UnicodeToUTF16(uint code)
		{
			byte b = (byte)(55232 + (code >> 10));
			byte b2 = (byte)(0xDC00u | (code & 0x3FFu));
			return (char)((b2 << 8) | b);
		}
	}
	internal class Ucs4Decoder4321 : Ucs4Decoder
	{
		internal override int GetFullChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
		{
			byteCount += byteIndex;
			int i = byteIndex;
			int num = charIndex;
			for (; i + 3 < byteCount; i += 4)
			{
				uint num2 = (uint)((bytes[i + 3] << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | bytes[i]);
				if (num2 > 1114111)
				{
					throw new ArgumentException(Res.GetString("Enc_InvalidByteInEncoding", i), (string)null);
				}
				if (num2 > 65535)
				{
					chars[num] = UnicodeToUTF16(num2);
					num++;
				}
				else
				{
					if (num2 >= 55296 && num2 <= 57343)
					{
						throw new XmlException("Xml_InvalidCharInThisEncoding", string.Empty);
					}
					chars[num] = (char)num2;
				}
				num++;
			}
			return num - charIndex;
		}
	}
	internal class Ucs4Decoder1234 : Ucs4Decoder
	{
		internal override int GetFullChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
		{
			byteCount += byteIndex;
			int i = byteIndex;
			int num = charIndex;
			for (; i + 3 < byteCount; i += 4)
			{
				uint num2 = (uint)((bytes[i] << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | bytes[i + 3]);
				if (num2 > 1114111)
				{
					throw new ArgumentException(Res.GetString("Enc_InvalidByteInEncoding", i), (string)null);
				}
				if (num2 > 65535)
				{
					chars[num] = UnicodeToUTF16(num2);
					num++;
				}
				else
				{
					if (num2 >= 55296 && num2 <= 57343)
					{
						throw new XmlException("Xml_InvalidCharInThisEncoding", string.Empty);
					}
					chars[num] = (char)num2;
				}
				num++;
			}
			return num - charIndex;
		}
	}
	internal class Ucs4Decoder2143 : Ucs4Decoder
	{
		internal override int GetFullChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
		{
			byteCount += byteIndex;
			int i = byteIndex;
			int num = charIndex;
			for (; i + 3 < byteCount; i += 4)
			{
				uint num2 = (uint)((bytes[i + 1] << 24) | (bytes[i] << 16) | (bytes[i + 3] << 8) | bytes[i + 2]);
				if (num2 > 1114111)
				{
					throw new ArgumentException(Res.GetString("Enc_InvalidByteInEncoding", i), (string)null);
				}
				if (num2 > 65535)
				{
					chars[num] = UnicodeToUTF16(num2);
					num++;
				}
				else
				{
					if (num2 >= 55296 && num2 <= 57343)
					{
						throw new XmlException("Xml_InvalidCharInThisEncoding", string.Empty);
					}
					chars[num] = (char)num2;
				}
				num++;
			}
			return num - charIndex;
		}
	}
	internal class Ucs4Decoder3412 : Ucs4Decoder
	{
		internal override int GetFullChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
		{
			byteCount += byteIndex;
			int i = byteIndex;
			int num = charIndex;
			for (; i + 3 < byteCount; i += 4)
			{
				uint num2 = (uint)((bytes[i + 2] << 24) | (bytes[i + 3] << 16) | (bytes[i] << 8) | bytes[i + 1]);
				if (num2 > 1114111)
				{
					throw new ArgumentException(Res.GetString("Enc_InvalidByteInEncoding", i), (string)null);
				}
				if (num2 > 65535)
				{
					chars[num] = UnicodeToUTF16(num2);
					num++;
				}
				else
				{
					if (num2 >= 55296 && num2 <= 57343)
					{
						throw new XmlException("Xml_InvalidCharInThisEncoding", string.Empty);
					}
					chars[num] = (char)num2;
				}
				num++;
			}
			return num - charIndex;
		}
	}
	[Serializable]
	public class XmlException : SystemException
	{
		private string res;

		private string[] args;

		private int lineNumber;

		private int linePosition;

		[OptionalField]
		private string sourceUri;

		private string message;

		public int LineNumber => lineNumber;

		public int LinePosition => linePosition;

		public string SourceUri => sourceUri;

		public override string Message
		{
			get
			{
				if (message != null)
				{
					return message;
				}
				return base.Message;
			}
		}

		internal string ResString => res;

		protected XmlException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			res = (string)info.GetValue("res", typeof(string));
			args = (string[])info.GetValue("args", typeof(string[]));
			lineNumber = (int)info.GetValue("lineNumber", typeof(int));
			linePosition = (int)info.GetValue("linePosition", typeof(int));
			sourceUri = string.Empty;
			string text = null;
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				switch (current.Name)
				{
				case "sourceUri":
					sourceUri = (string)current.Value;
					break;
				case "version":
					text = (string)current.Value;
					break;
				}
			}
			if (text == null)
			{
				message = CreateMessage(res, args, lineNumber, linePosition);
			}
			else
			{
				message = null;
			}
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("res", res);
			info.AddValue("args", args);
			info.AddValue("lineNumber", lineNumber);
			info.AddValue("linePosition", linePosition);
			info.AddValue("sourceUri", sourceUri);
			info.AddValue("version", "2.0");
		}

		public XmlException()
			: this(null)
		{
		}

		public XmlException(string message)
			: this(message, (Exception)null, 0, 0)
		{
		}

		public XmlException(string message, Exception innerException)
			: this(message, innerException, 0, 0)
		{
		}

		public XmlException(string message, Exception innerException, int lineNumber, int linePosition)
			: this(message, innerException, lineNumber, linePosition, null)
		{
		}

		internal XmlException(string message, Exception innerException, int lineNumber, int linePosition, string sourceUri)
			: this((message == null) ? "Xml_DefaultException" : "Xml_UserException", new string[1] { message }, innerException, lineNumber, linePosition, sourceUri)
		{
		}

		internal XmlException(string res, string[] args)
			: this(res, args, null, 0, 0, null)
		{
		}

		internal XmlException(string res, string[] args, string sourceUri)
			: this(res, args, null, 0, 0, sourceUri)
		{
		}

		internal XmlException(string res, string arg)
			: this(res, new string[1] { arg }, null, 0, 0, null)
		{
		}

		internal XmlException(string res, string arg, string sourceUri)
			: this(res, new string[1] { arg }, null, 0, 0, sourceUri)
		{
		}

		internal XmlException(string res, string arg, IXmlLineInfo lineInfo)
			: this(res, new string[1] { arg }, lineInfo, null)
		{
		}

		internal XmlException(string res, string arg, Exception innerException, IXmlLineInfo lineInfo)
			: this(res, new string[1] { arg }, innerException, lineInfo?.LineNumber ?? 0, lineInfo?.LinePosition ?? 0, null)
		{
		}

		internal XmlException(string res, string arg, IXmlLineInfo lineInfo, string sourceUri)
			: this(res, new string[1] { arg }, lineInfo, sourceUri)
		{
		}

		internal XmlException(string res, string[] args, IXmlLineInfo lineInfo)
			: this(res, args, lineInfo, null)
		{
		}

		internal XmlException(string res, string[] args, IXmlLineInfo lineInfo, string sourceUri)
			: this(res, args, null, lineInfo?.LineNumber ?? 0, lineInfo?.LinePosition ?? 0, sourceUri)
		{
		}

		internal XmlException(string res, int lineNumber, int linePosition)
			: this(res, null, null, lineNumber, linePosition)
		{
		}

		internal XmlException(string res, string arg, int lineNumber, int linePosition)
			: this(res, new string[1] { arg }, null, lineNumber, linePosition, null)
		{
		}

		internal XmlException(string res, string arg, int lineNumber, int linePosition, string sourceUri)
			: this(res, new string[1] { arg }, null, lineNumber, linePosition, sourceUri)
		{
		}

		internal XmlException(string res, string[] args, int lineNumber, int linePosition)
			: this(res, args, null, lineNumber, linePosition, null)
		{
		}

		internal XmlException(string res, string[] args, int lineNumber, int linePosition, string sourceUri)
			: this(res, args, null, lineNumber, linePosition, sourceUri)
		{
		}

		internal XmlException(string res, string[] args, Exception innerException, int lineNumber, int linePosition)
			: this(res, args, innerException, lineNumber, linePosition, null)
		{
		}

		internal XmlException(string res, string[] args, Exception innerException, int lineNumber, int linePosition, string sourceUri)
			: base(CreateMessage(res, args, lineNumber, linePosition), innerException)
		{
			base.HResult = -2146232000;
			this.res = res;
			this.args = args;
			this.sourceUri = sourceUri;
			this.lineNumber = lineNumber;
			this.linePosition = linePosition;
		}

		private static string CreateMessage(string res, string[] args, int lineNumber, int linePosition)
		{
			try
			{
				string text = Res.GetString(res, args);
				if (lineNumber != 0)
				{
					text = text + " " + Res.GetString("Xml_ErrorPosition", lineNumber.ToString(CultureInfo.InvariantCulture), linePosition.ToString(CultureInfo.InvariantCulture));
				}
				return text;
			}
			catch (MissingManifestResourceException)
			{
				return "UNKNOWN(" + res + ")";
			}
		}

		internal static string[] BuildCharExceptionStr(char ch)
		{
			string[] array = new string[2];
			if (ch == '\0')
			{
				array[0] = ".";
			}
			else
			{
				array[0] = ch.ToString(CultureInfo.InvariantCulture);
			}
			int num = ch;
			array[1] = "0x" + num.ToString("X2", CultureInfo.InvariantCulture);
			return array;
		}

		internal static bool IsCatchableException(Exception e)
		{
			if (!(e is StackOverflowException) && !(e is OutOfMemoryException) && !(e is ThreadAbortException) && !(e is ThreadInterruptedException) && !(e is NullReferenceException))
			{
				return !(e is AccessViolationException);
			}
			return false;
		}
	}
	public class XmlNamespaceManager : IXmlNamespaceResolver, IEnumerable
	{
		private struct NamespaceDeclaration
		{
			public string prefix;

			public string uri;

			public int scopeId;

			public int previousNsIndex;

			public void Set(string prefix, string uri, int scopeId, int previousNsIndex)
			{
				this.prefix = prefix;
				this.uri = uri;
				this.scopeId = scopeId;
				this.previousNsIndex = previousNsIndex;
			}
		}

		private const int MinDeclsCountForHashtable = 16;

		private static IXmlNamespaceResolver s_EmptyResolver;

		private NamespaceDeclaration[] nsdecls;

		private int lastDecl;

		private XmlNameTable nameTable;

		private int scopeId;

		private Dictionary<string, int> hashTable;

		private bool useHashtable;

		private string xml;

		private string xmlNs;

		internal static IXmlNamespaceResolver EmptyResolver
		{
			get
			{
				if (s_EmptyResolver == null)
				{
					s_EmptyResolver = new XmlNamespaceManager(new NameTable());
				}
				return s_EmptyResolver;
			}
		}

		public virtual XmlNameTable NameTable => nameTable;

		public virtual string DefaultNamespace
		{
			get
			{
				string text = LookupNamespace(string.Empty);
				if (text != null)
				{
					return text;
				}
				return string.Empty;
			}
		}

		internal XmlNamespaceManager()
		{
		}

		public XmlNamespaceManager(XmlNameTable nameTable)
		{
			this.nameTable = nameTable;
			xml = nameTable.Add("xml");
			xmlNs = nameTable.Add("xmlns");
			nsdecls = new NamespaceDeclaration[8];
			string text = nameTable.Add(string.Empty);
			nsdecls[0].Set(text, text, -1, -1);
			nsdecls[1].Set(xmlNs, nameTable.Add("http://www.w3.org/2000/xmlns/"), -1, -1);
			nsdecls[2].Set(xml, nameTable.Add("http://www.w3.org/XML/1998/namespace"), 0, -1);
			lastDecl = 2;
			scopeId = 1;
		}

		public virtual void PushScope()
		{
			scopeId++;
		}

		public virtual bool PopScope()
		{
			int num = lastDecl;
			if (scopeId == 1)
			{
				return false;
			}
			while (nsdecls[num].scopeId == scopeId)
			{
				if (useHashtable)
				{
					hashTable[nsdecls[num].prefix] = nsdecls[num].previousNsIndex;
				}
				num--;
			}
			lastDecl = num;
			scopeId--;
			return true;
		}

		public virtual void AddNamespace(string prefix, string uri)
		{
			if (uri == null)
			{
				throw new ArgumentNullException("uri");
			}
			if (prefix == null)
			{
				throw new ArgumentNullException("prefix");
			}
			prefix = nameTable.Add(prefix);
			uri = nameTable.Add(uri);
			if (Ref.Equal(xml, prefix) && !uri.Equals("http://www.w3.org/XML/1998/namespace"))
			{
				throw new ArgumentException(Res.GetString("Xml_XmlPrefix"));
			}
			if (Ref.Equal(xmlNs, prefix))
			{
				throw new ArgumentException(Res.GetString("Xml_XmlnsPrefix"));
			}
			int num = LookupNamespaceDecl(prefix);
			int previousNsIndex = -1;
			if (num != -1)
			{
				if (nsdecls[num].scopeId == scopeId)
				{
					nsdecls[num].uri = uri;
					return;
				}
				previousNsIndex = num;
			}
			if (lastDecl == nsdecls.Length - 1)
			{
				NamespaceDeclaration[] destinationArray = new NamespaceDeclaration[nsdecls.Length * 2];
				Array.Copy(nsdecls, 0, destinationArray, 0, nsdecls.Length);
				nsdecls = destinationArray;
			}
			nsdecls[++lastDecl].Set(prefix, uri, scopeId, previousNsIndex);
			if (useHashtable)
			{
				hashTable[prefix] = lastDecl;
			}
			else if (lastDecl >= 16)
			{
				hashTable = new Dictionary<string, int>(lastDecl);
				for (int i = 0; i <= lastDecl; i++)
				{
					hashTable[nsdecls[i].prefix] = i;
				}
				useHashtable = true;
			}
		}

		public virtual void RemoveNamespace(string prefix, string uri)
		{
			if (uri == null)
			{
				throw new ArgumentNullException("uri");
			}
			if (prefix == null)
			{
				throw new ArgumentNullException("prefix");
			}
			for (int num = LookupNamespaceDecl(prefix); num != -1; num = nsdecls[num].previousNsIndex)
			{
				if (string.Equals(nsdecls[num].uri, uri) && nsdecls[num].scopeId == scopeId)
				{
					nsdecls[num].uri = null;
				}
			}
		}

		public virtual IEnumerator GetEnumerator()
		{
			Hashtable hashtable = new Hashtable(lastDecl + 1);
			for (int i = 0; i <= lastDecl; i++)
			{
				if (nsdecls[i].uri != null)
				{
					hashtable[nsdecls[i].prefix] = nsdecls[i].prefix;
				}
			}
			return hashtable.Keys.GetEnumerator();
		}

		public virtual IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope)
		{
			int i = 0;
			switch (scope)
			{
			case XmlNamespaceScope.All:
				i = 2;
				break;
			case XmlNamespaceScope.ExcludeXml:
				i = 3;
				break;
			case XmlNamespaceScope.Local:
				i = lastDecl;
				while (nsdecls[i].scopeId == scopeId)
				{
					i--;
				}
				i++;
				break;
			}
			Dictionary<string, string> dictionary = new Dictionary<string, string>(lastDecl - i + 1);
			for (; i <= lastDecl; i++)
			{
				string prefix = nsdecls[i].prefix;
				string uri = nsdecls[i].uri;
				if (uri != null)
				{
					if (uri.Length > 0 || prefix.Length > 0 || scope == XmlNamespaceScope.Local)
					{
						dictionary[prefix] = uri;
					}
					else
					{
						dictionary.Remove(prefix);
					}
				}
			}
			return dictionary;
		}

		public virtual string LookupNamespace(string prefix)
		{
			int num = LookupNamespaceDecl(prefix);
			if (num != -1)
			{
				return nsdecls[num].uri;
			}
			return null;
		}

		private int LookupNamespaceDecl(string prefix)
		{
			if (useHashtable)
			{
				if (hashTable.TryGetValue(prefix, out var value))
				{
					while (value != -1 && nsdecls[value].uri == null)
					{
						value = nsdecls[value].previousNsIndex;
					}
					return value;
				}
				return -1;
			}
			for (int num = lastDecl; num >= 0; num--)
			{
				if ((object)nsdecls[num].prefix == prefix && nsdecls[num].uri != null)
				{
					return num;
				}
			}
			for (int num2 = lastDecl; num2 >= 0; num2--)
			{
				if (string.Equals(nsdecls[num2].prefix, prefix) && nsdecls[num2].uri != null)
				{
					return num2;
				}
			}
			return -1;
		}

		public virtual string LookupPrefix(string uri)
		{
			for (int num = lastDecl; num >= 0; num--)
			{
				if (string.Equals(nsdecls[num].uri, uri))
				{
					string prefix = nsdecls[num].prefix;
					if (string.Equals(LookupNamespace(prefix), uri))
					{
						return prefix;
					}
				}
			}
			return null;
		}

		public virtual bool HasNamespace(string prefix)
		{
			int num = lastDecl;
			while (nsdecls[num].scopeId == scopeId)
			{
				if (string.Equals(nsdecls[num].prefix, prefix) && nsdecls[num].uri != null)
				{
					if (prefix.Length > 0 || nsdecls[num].uri.Length > 0)
					{
						return true;
					}
					return false;
				}
				num--;
			}
			return false;
		}

		internal bool GetNamespaceDeclaration(int idx, out string prefix, out string uri)
		{
			idx = lastDecl - idx;
			if (idx < 0)
			{
				prefix = (uri = null);
				return false;
			}
			prefix = nsdecls[idx].prefix;
			uri = nsdecls[idx].uri;
			return true;
		}
	}
	public enum XmlNamespaceScope
	{
		All,
		ExcludeXml,
		Local
	}
	public enum XmlNodeOrder
	{
		Before,
		After,
		Same,
		Unknown
	}
	public enum XmlNodeType
	{
		None,
		Element,
		Attribute,
		Text,
		CDATA,
		EntityReference,
		Entity,
		ProcessingInstruction,
		Comment,
		Document,
		DocumentType,
		DocumentFragment,
		Notation,
		Whitespace,
		SignificantWhitespace,
		EndElement,
		EndEntity,
		XmlDeclaration
	}
	public abstract class XmlResolver
	{
		public abstract ICredentials Credentials { set; }

		public abstract object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn);

		public virtual Uri ResolveUri(Uri baseUri, string relativeUri)
		{
			if (baseUri == null || (!baseUri.IsAbsoluteUri && baseUri.OriginalString.Length == 0))
			{
				Uri uri = new Uri(relativeUri, UriKind.RelativeOrAbsolute);
				if (!uri.IsAbsoluteUri && uri.OriginalString.Length > 0)
				{
					uri = new Uri(Path.GetFullPath(relativeUri));
				}
				return uri;
			}
			if (relativeUri == null || relativeUri.Length == 0)
			{
				return baseUri;
			}
			return new Uri(baseUri, relativeUri);
		}
	}
	public class XmlUrlResolver : XmlResolver
	{
		private static object s_DownloadManager;

		private ICredentials _credentials;

		private static XmlDownloadManager DownloadManager
		{
			get
			{
				if (s_DownloadManager == null)
				{
					object value = new XmlDownloadManager();
					Interlocked.CompareExchange(ref s_DownloadManager, value, null);
				}
				return (XmlDownloadManager)s_DownloadManager;
			}
		}

		public override ICredentials Credentials
		{
			set
			{
				_credentials = value;
			}
		}

		public override object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn)
		{
			if (ofObjectToReturn == null || ofObjectToReturn == typeof(Stream))
			{
				return DownloadManager.GetStream(absoluteUri, _credentials);
			}
			throw new XmlException("Xml_UnsupportedClass", string.Empty);
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		public override Uri ResolveUri(Uri baseUri, string relativeUri)
		{
			return base.ResolveUri(baseUri, relativeUri);
		}
	}
	internal class XmlNullResolver : XmlUrlResolver
	{
		public static readonly XmlNullResolver Singleton = new XmlNullResolver();

		public override object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn)
		{
			throw new XmlException("Xml_NullResolver", string.Empty);
		}
	}
	[Serializable]
	public class XmlQualifiedName
	{
		private delegate int HashCodeOfStringDelegate(string s, int sLen, long additionalEntropy);

		private static HashCodeOfStringDelegate hashCodeDelegate = null;

		private string name;

		private string ns;

		[NonSerialized]
		private int hash;

		public static readonly XmlQualifiedName Empty = new XmlQualifiedName(string.Empty);

		public string Namespace => ns;

		public string Name => name;

		public bool IsEmpty
		{
			get
			{
				if (Name.Length == 0)
				{
					return Namespace.Length == 0;
				}
				return false;
			}
		}

		public XmlQualifiedName()
			: this(string.Empty, string.Empty)
		{
		}

		public XmlQualifiedName(string name)
			: this(name, string.Empty)
		{
		}

		public XmlQualifiedName(string name, string ns)
		{
			this.ns = ((ns == null) ? string.Empty : ns);
			this.name = ((name == null) ? string.Empty : name);
		}

		public override int GetHashCode()
		{
			if (hash == 0)
			{
				if (hashCodeDelegate == null)
				{
					hashCodeDelegate = GetHashCodeDelegate();
				}
				hash = hashCodeDelegate(Name, Name.Length, 0L);
			}
			return hash;
		}

		public override string ToString()
		{
			if (Namespace.Length != 0)
			{
				return Namespace + ":" + Name;
			}
			return Name;
		}

		public override bool Equals(object other)
		{
			if (this == other)
			{
				return true;
			}
			XmlQualifiedName xmlQualifiedName = other as XmlQualifiedName;
			if (xmlQualifiedName != null)
			{
				if (Name == xmlQualifiedName.Name)
				{
					return Namespace == xmlQualifiedName.Namespace;
				}
				return false;
			}
			return false;
		}

		public static bool operator ==(XmlQualifiedName a, XmlQualifiedName b)
		{
			if ((object)a == b)
			{
				return true;
			}
			if ((object)a == null || (object)b == null)
			{
				return false;
			}
			if (a.Name == b.Name)
			{
				return a.Namespace == b.Namespace;
			}
			return false;
		}

		public static bool operator !=(XmlQualifiedName a, XmlQualifiedName b)
		{
			return !(a == b);
		}

		public static string ToString(string name, string ns)
		{
			if (ns != null && ns.Length != 0)
			{
				return ns + ":" + name;
			}
			return name;
		}

		[SecuritySafeCritical]
		[ReflectionPermission(SecurityAction.Assert, Unrestricted = true)]
		private static HashCodeOfStringDelegate GetHashCodeDelegate()
		{
			if (!IsRandomizedHashingDisabled())
			{
				MethodInfo method = typeof(string).GetMethod("InternalMarvin32HashString", BindingFlags.Static | BindingFlags.NonPublic);
				if (method != null)
				{
					return (HashCodeOfStringDelegate)Delegate.CreateDelegate(typeof(HashCodeOfStringDelegate), method);
				}
			}
			return GetHashCodeOfString;
		}

		[SecuritySafeCritical]
		[RegistryPermission(SecurityAction.Assert, Unrestricted = true)]
		private static bool IsRandomizedHashingDisabled()
		{
			bool value = false;
			if (!ReadBoolFromXmlRegistrySettings(Registry.CurrentUser, "DisableRandomizedHashingOnXmlQualifiedName", ref value))
			{
				ReadBoolFromXmlRegistrySettings(Registry.LocalMachine, "DisableRandomizedHashingOnXmlQualifiedName", ref value);
			}
			return value;
		}

		[SecurityCritical]
		private static bool ReadBoolFromXmlRegistrySettings(RegistryKey hive, string regValueName, ref bool value)
		{
			try
			{
				using RegistryKey registryKey = hive.OpenSubKey("SOFTWARE\\Microsoft\\.NETFramework\\XML", writable: false);
				if (registryKey != null && registryKey.GetValueKind(regValueName) == RegistryValueKind.DWord)
				{
					value = (int)registryKey.GetValue(regValueName) == 1;
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		private static int GetHashCodeOfString(string s, int length, long additionalEntropy)
		{
			return s.GetHashCode();
		}

		internal void Init(string name, string ns)
		{
			this.name = name;
			this.ns = ns;
			hash = 0;
		}

		internal void SetNamespace(string ns)
		{
			this.ns = ns;
		}

		internal void Verify()
		{
			XmlConvert.VerifyNCName(name);
			if (ns.Length != 0)
			{
				XmlConvert.ToUri(ns);
			}
		}

		internal void Atomize(XmlNameTable nameTable)
		{
			name = nameTable.Add(name);
			ns = nameTable.Add(ns);
		}

		internal static XmlQualifiedName Parse(string s, IXmlNamespaceResolver nsmgr, out string prefix)
		{
			ValidateNames.ParseQNameThrow(s, out prefix, out var localName);
			string text = nsmgr.LookupNamespace(prefix);
			if (text == null)
			{
				if (prefix.Length != 0)
				{
					throw new XmlException("Xml_UnknownNs", prefix);
				}
				text = string.Empty;
			}
			return new XmlQualifiedName(localName, text);
		}

		internal XmlQualifiedName Clone()
		{
			return (XmlQualifiedName)MemberwiseClone();
		}

		internal static int Compare(XmlQualifiedName a, XmlQualifiedName b)
		{
			if (null == a)
			{
				if (!(null == b))
				{
					return -1;
				}
				return 0;
			}
			if (null == b)
			{
				return 1;
			}
			int num = string.CompareOrdinal(a.Namespace, b.Namespace);
			if (num == 0)
			{
				num = string.CompareOrdinal(a.Name, b.Name);
			}
			return num;
		}
	}
	internal abstract class XmlReservedNs
	{
		internal const string NsDataType = "urn:schemas-microsoft-com:datatypes";

		internal const string NsDataTypeAlias = "uuid:C2F41010-65B3-11D1-A29F-00AA00C14882";

		internal const string NsDataTypeOld = "urn:uuid:C2F41010-65B3-11D1-A29F-00AA00C14882/";

		internal const string NsMsxsl = "urn:schemas-microsoft-com:xslt";

		internal const string NsXdr = "urn:schemas-microsoft-com:xml-data";

		internal const string NsXslDebug = "urn:schemas-microsoft-com:xslt-debug";

		internal const string NsXdrAlias = "uuid:BDC6E3F0-6DA3-11D1-A2A3-00AA00C14882";

		internal const string NsWdXsl = "http://www.w3.org/TR/WD-xsl";

		internal const string NsXml = "http://www.w3.org/XML/1998/namespace";

		internal const string NsXmlNs = "http://www.w3.org/2000/xmlns/";

		internal const string NsXs = "http://www.w3.org/2001/XMLSchema";

		internal const string NsXsd = "http://www.w3.org/2001/XMLSchema-datatypes";

		internal const string NsXsi = "http://www.w3.org/2001/XMLSchema-instance";

		internal const string NsXslt = "http://www.w3.org/1999/XSL/Transform";

		internal const string NsExsltCommon = "http://exslt.org/common";

		internal const string NsExsltDates = "http://exslt.org/dates-and-times";

		internal const string NsExsltMath = "http://exslt.org/math";

		internal const string NsExsltRegExps = "http://exslt.org/regular-expressions";

		internal const string NsExsltSets = "http://exslt.org/sets";

		internal const string NsExsltStrings = "http://exslt.org/strings";

		internal const string NsXQueryFunc = "http://www.w3.org/2003/11/xpath-functions";

		internal const string NsXQueryDataType = "http://www.w3.org/2003/11/xpath-datatypes";

		internal const string NsCollationBase = "http://collations.microsoft.com";

		internal const string NsCollCodePoint = "http://www.w3.org/2004/10/xpath-functions/collation/codepoint";

		internal const string NsXsltInternal = "http://schemas.microsoft.com/framework/2003/xml/xslt/internal";
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class XmlSecureResolver : XmlResolver
	{
		private XmlResolver resolver;

		private PermissionSet permissionSet;

		public override ICredentials Credentials
		{
			set
			{
				resolver.Credentials = value;
			}
		}

		public XmlSecureResolver(XmlResolver resolver, string securityUrl)
			: this(resolver, CreateEvidenceForUrl(securityUrl))
		{
		}

		public XmlSecureResolver(XmlResolver resolver, Evidence evidence)
			: this(resolver, SecurityManager.ResolvePolicy(evidence))
		{
		}

		public XmlSecureResolver(XmlResolver resolver, PermissionSet permissionSet)
		{
			this.resolver = resolver;
			this.permissionSet = permissionSet;
		}

		public override object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn)
		{
			permissionSet.PermitOnly();
			return resolver.GetEntity(absoluteUri, role, ofObjectToReturn);
		}

		public override Uri ResolveUri(Uri baseUri, string relativeUri)
		{
			return resolver.ResolveUri(baseUri, relativeUri);
		}

		public static Evidence CreateEvidenceForUrl(string securityUrl)
		{
			Evidence evidence = new Evidence();
			if (securityUrl != null && securityUrl.Length > 0)
			{
				evidence.AddHost(new Url(securityUrl));
				evidence.AddHost(Zone.CreateFromUrl(securityUrl));
				Uri uri = new Uri(securityUrl, UriKind.RelativeOrAbsolute);
				if (uri.IsAbsoluteUri && !uri.IsFile)
				{
					evidence.AddHost(Site.CreateFromUrl(securityUrl));
				}
			}
			return evidence;
		}
	}
	internal class CharEntityEncoderFallback : EncoderFallback
	{
		private CharEntityEncoderFallbackBuffer fallbackBuffer;

		private int[] textContentMarks;

		private int endMarkPos;

		private int curMarkPos;

		private int startOffset;

		public override int MaxCharCount => 12;

		internal int StartOffset
		{
			get
			{
				return startOffset;
			}
			set
			{
				startOffset = value;
			}
		}

		internal CharEntityEncoderFallback()
		{
		}

		public override EncoderFallbackBuffer CreateFallbackBuffer()
		{
			if (fallbackBuffer == null)
			{
				fallbackBuffer = new CharEntityEncoderFallbackBuffer(this);
			}
			return fallbackBuffer;
		}

		internal void Reset(int[] textContentMarks, int endMarkPos)
		{
			this.textContentMarks = textContentMarks;
			this.endMarkPos = endMarkPos;
			curMarkPos = 0;
		}

		internal bool CanReplaceAt(int index)
		{
			int i = curMarkPos;
			for (int num = startOffset + index; i < endMarkPos && num >= textContentMarks[i + 1]; i++)
			{
			}
			curMarkPos = i;
			return (i & 1) != 0;
		}
	}
	internal class CharEntityEncoderFallbackBuffer : EncoderFallbackBuffer
	{
		private CharEntityEncoderFallback parent;

		private string charEntity = string.Empty;

		private int charEntityIndex = -1;

		public override int Remaining
		{
			get
			{
				if (charEntityIndex == -1)
				{
					return 0;
				}
				return charEntity.Length - charEntityIndex;
			}
		}

		internal CharEntityEncoderFallbackBuffer(CharEntityEncoderFallback parent)
		{
			this.parent = parent;
		}

		public override bool Fallback(char charUnknown, int index)
		{
			if (charEntityIndex >= 0)
			{
				new EncoderExceptionFallbackBuffer().Fallback(charUnknown, index);
			}
			if (parent.CanReplaceAt(index))
			{
				charEntity = string.Format(CultureInfo.InvariantCulture, "&#x{0:X};", (int)charUnknown);
				charEntityIndex = 0;
				return true;
			}
			EncoderFallbackBuffer encoderFallbackBuffer = new EncoderExceptionFallback().CreateFallbackBuffer();
			encoderFallbackBuffer.Fallback(charUnknown, index);
			return false;
		}

		public override bool Fallback(char charUnknownHigh, char charUnknownLow, int index)
		{
			if (!char.IsSurrogatePair(charUnknownHigh, charUnknownLow))
			{
				throw XmlConvert.CreateInvalidSurrogatePairException(charUnknownHigh, charUnknownLow);
			}
			if (charEntityIndex >= 0)
			{
				new EncoderExceptionFallbackBuffer().Fallback(charUnknownHigh, charUnknownLow, index);
			}
			if (parent.CanReplaceAt(index))
			{
				charEntity = string.Format(CultureInfo.InvariantCulture, "&#x{0:X};", char.ConvertToUtf32(charUnknownHigh, charUnknownLow));
				charEntityIndex = 0;
				return true;
			}
			EncoderFallbackBuffer encoderFallbackBuffer = new EncoderExceptionFallback().CreateFallbackBuffer();
			encoderFallbackBuffer.Fallback(charUnknownHigh, charUnknownLow, index);
			return false;
		}

		public override char GetNextChar()
		{
			if (charEntityIndex == -1)
			{
				return '\0';
			}
			char result = charEntity[charEntityIndex++];
			if (charEntityIndex == charEntity.Length)
			{
				charEntityIndex = -1;
			}
			return result;
		}

		public override bool MovePrevious()
		{
			if (charEntityIndex == -1)
			{
				return false;
			}
			if (charEntityIndex > 0)
			{
				charEntityIndex--;
				return true;
			}
			return false;
		}

		public override void Reset()
		{
			charEntityIndex = -1;
		}
	}
	public enum ConformanceLevel
	{
		Auto,
		Fragment,
		Document
	}
	public enum EntityHandling
	{
		ExpandEntities = 1,
		ExpandCharEntities
	}
	public abstract class XmlWriter : IDisposable
	{
		private const int WriteNodeBufferSize = 1024;

		private char[] writeNodeBuffer;

		public virtual XmlWriterSettings Settings => null;

		public abstract WriteState WriteState { get; }

		public virtual XmlSpace XmlSpace => XmlSpace.Default;

		public virtual string XmlLang => string.Empty;

		public abstract void WriteStartDocument();

		public abstract void WriteStartDocument(bool standalone);

		public abstract void WriteEndDocument();

		public abstract void WriteDocType(string name, string pubid, string sysid, string subset);

		public void WriteStartElement(string localName, string ns)
		{
			WriteStartElement(null, localName, ns);
		}

		public abstract void WriteStartElement(string prefix, string localName, string ns);

		public void WriteStartElement(string localName)
		{
			WriteStartElement(null, localName, null);
		}

		public abstract void WriteEndElement();

		public abstract void WriteFullEndElement();

		public void WriteAttributeString(string localName, string ns, string value)
		{
			WriteStartAttribute(null, localName, ns);
			WriteString(value);
			WriteEndAttribute();
		}

		public void WriteAttributeString(string localName, string value)
		{
			WriteStartAttribute(null, localName, null);
			WriteString(value);
			WriteEndAttribute();
		}

		public void WriteAttributeString(string prefix, string localName, string ns, string value)
		{
			WriteStartAttribute(prefix, localName, ns);
			WriteString(value);
			WriteEndAttribute();
		}

		public void WriteStartAttribute(string localName, string ns)
		{
			WriteStartAttribute(null, localName, ns);
		}

		public abstract void WriteStartAttribute(string prefix, string localName, string ns);

		public void WriteStartAttribute(string localName)
		{
			WriteStartAttribute(null, localName, null);
		}

		public abstract void WriteEndAttribute();

		public abstract void WriteCData(string text);

		public abstract void WriteComment(string text);

		public abstract void WriteProcessingInstruction(string name, string text);

		public abstract void WriteEntityRef(string name);

		public abstract void WriteCharEntity(char ch);

		public abstract void WriteWhitespace(string ws);

		public abstract void WriteString(string text);

		public abstract void WriteSurrogateCharEntity(char lowChar, char highChar);

		public abstract void WriteChars(char[] buffer, int index, int count);

		public abstract void WriteRaw(char[] buffer, int index, int count);

		public abstract void WriteRaw(string data);

		public abstract void WriteBase64(byte[] buffer, int index, int count);

		public virtual void WriteBinHex(byte[] buffer, int index, int count)
		{
			BinHexEncoder.Encode(buffer, index, count, this);
		}

		public abstract void Close();

		public abstract void Flush();

		public abstract string LookupPrefix(string ns);

		public virtual void WriteNmToken(string name)
		{
			if (name == null || name.Length == 0)
			{
				throw new ArgumentException(Res.GetString("Xml_EmptyName"));
			}
			WriteString(XmlConvert.VerifyNMTOKEN(name, ExceptionType.ArgumentException));
		}

		public virtual void WriteName(string name)
		{
			WriteString(XmlConvert.VerifyQName(name, ExceptionType.ArgumentException));
		}

		public virtual void WriteQualifiedName(string localName, string ns)
		{
			if (ns != null && ns.Length > 0)
			{
				string text = LookupPrefix(ns);
				if (text == null)
				{
					throw new ArgumentException(Res.GetString("Xml_UndefNamespace", ns));
				}
				WriteString(text);
				WriteString(":");
			}
			WriteString(localName);
		}

		public virtual void WriteValue(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			WriteString(XmlUntypedConverter.Untyped.ToString(value, null));
		}

		public virtual void WriteValue(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			WriteString(value);
		}

		public virtual void WriteValue(bool value)
		{
			WriteString(XmlUntypedConverter.Untyped.ToString(value));
		}

		public virtual void WriteValue(DateTime value)
		{
			WriteString(XmlUntypedConverter.Untyped.ToString(value));
		}

		public virtual void WriteValue(double value)
		{
			WriteString(XmlUntypedConverter.Untyped.ToString(value));
		}

		public virtual void WriteValue(float value)
		{
			WriteString(XmlUntypedConverter.Untyped.ToString(value));
		}

		public virtual void WriteValue(decimal value)
		{
			WriteString(XmlUntypedConverter.Untyped.ToString(value));
		}

		public virtual void WriteValue(int value)
		{
			WriteString(XmlUntypedConverter.Untyped.ToString(value));
		}

		public virtual void WriteValue(long value)
		{
			WriteString(XmlUntypedConverter.Untyped.ToString(value));
		}

		public virtual void WriteAttributes(XmlReader reader, bool defattr)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			if (reader.NodeType == XmlNodeType.Element || reader.NodeType == XmlNodeType.XmlDeclaration)
			{
				if (reader.MoveToFirstAttribute())
				{
					WriteAttributes(reader, defattr);
					reader.MoveToElement();
				}
				return;
			}
			if (reader.NodeType != XmlNodeType.Attribute)
			{
				throw new XmlException("Xml_InvalidPosition", string.Empty);
			}
			do
			{
				IXmlSchemaInfo schemaInfo;
				if (!defattr && (reader.IsDefault || ((schemaInfo = reader.SchemaInfo) != null && schemaInfo.IsDefault)))
				{
					continue;
				}
				WriteStartAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI);
				while (reader.ReadAttributeValue())
				{
					if (reader.NodeType == XmlNodeType.EntityReference)
					{
						WriteEntityRef(reader.Name);
					}
					else
					{
						WriteString(reader.Value);
					}
				}
				WriteEndAttribute();
			}
			while (reader.MoveToNextAttribute());
		}

		public virtual void WriteNode(XmlReader reader, bool defattr)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			bool canReadValueChunk = reader.CanReadValueChunk;
			int num = ((reader.NodeType == XmlNodeType.None) ? (-1) : reader.Depth);
			do
			{
				switch (reader.NodeType)
				{
				case XmlNodeType.Element:
					WriteStartElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
					WriteAttributes(reader, defattr);
					if (reader.IsEmptyElement)
					{
						WriteEndElement();
					}
					break;
				case XmlNodeType.Text:
					if (canReadValueChunk)
					{
						if (writeNodeBuffer == null)
						{
							writeNodeBuffer = new char[1024];
						}
						int count;
						while ((count = reader.ReadValueChunk(writeNodeBuffer, 0, 1024)) > 0)
						{
							WriteChars(writeNodeBuffer, 0, count);
						}
					}
					else
					{
						WriteString(reader.Value);
					}
					break;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					WriteWhitespace(reader.Value);
					break;
				case XmlNodeType.CDATA:
					WriteCData(reader.Value);
					break;
				case XmlNodeType.EntityReference:
					WriteEntityRef(reader.Name);
					break;
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.XmlDeclaration:
					WriteProcessingInstruction(reader.Name, reader.Value);
					break;
				case XmlNodeType.DocumentType:
					WriteDocType(reader.Name, reader.GetAttribute("PUBLIC"), reader.GetAttribute("SYSTEM"), reader.Value);
					break;
				case XmlNodeType.Comment:
					WriteComment(reader.Value);
					break;
				case XmlNodeType.EndElement:
					WriteFullEndElement();
					break;
				}
			}
			while (reader.Read() && (num < reader.Depth || (num == reader.Depth && reader.NodeType == XmlNodeType.EndElement)));
		}

		public virtual void WriteNode(XPathNavigator navigator, bool defattr)
		{
			if (navigator == null)
			{
				throw new ArgumentNullException("navigator");
			}
			int num = 0;
			navigator = navigator.Clone();
			while (true)
			{
				bool flag = false;
				switch (navigator.NodeType)
				{
				case XPathNodeType.Element:
					WriteStartElement(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
					if (navigator.MoveToFirstAttribute())
					{
						do
						{
							IXmlSchemaInfo schemaInfo = navigator.SchemaInfo;
							if (defattr || schemaInfo == null || !schemaInfo.IsDefault)
							{
								WriteStartAttribute(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
								WriteString(navigator.Value);
								WriteEndAttribute();
							}
						}
						while (navigator.MoveToNextAttribute());
						navigator.MoveToParent();
					}
					if (navigator.MoveToFirstNamespace(XPathNamespaceScope.Local))
					{
						WriteLocalNamespaces(navigator);
						navigator.MoveToParent();
					}
					flag = true;
					break;
				case XPathNodeType.Text:
					WriteString(navigator.Value);
					break;
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
					WriteWhitespace(navigator.Value);
					break;
				case XPathNodeType.Root:
					flag = true;
					break;
				case XPathNodeType.Comment:
					WriteComment(navigator.Value);
					break;
				case XPathNodeType.ProcessingInstruction:
					WriteProcessingInstruction(navigator.LocalName, navigator.Value);
					break;
				}
				if (flag)
				{
					if (navigator.MoveToFirstChild())
					{
						num++;
						continue;
					}
					if (navigator.NodeType == XPathNodeType.Element)
					{
						if (navigator.IsEmptyElement)
						{
							WriteEndElement();
						}
						else
						{
							WriteFullEndElement();
						}
					}
				}
				while (true)
				{
					if (num == 0)
					{
						return;
					}
					if (navigator.MoveToNext())
					{
						break;
					}
					num--;
					navigator.MoveToParent();
					if (navigator.NodeType == XPathNodeType.Element)
					{
						WriteFullEndElement();
					}
				}
			}
		}

		public void WriteElementString(string localName, string value)
		{
			WriteElementString(localName, null, value);
		}

		public void WriteElementString(string localName, string ns, string value)
		{
			WriteStartElement(localName, ns);
			if (value != null && value.Length != 0)
			{
				WriteString(value);
			}
			WriteEndElement();
		}

		public void WriteElementString(string prefix, string localName, string ns, string value)
		{
			WriteStartElement(prefix, localName, ns);
			if (value != null && value.Length != 0)
			{
				WriteString(value);
			}
			WriteEndElement();
		}

		void IDisposable.Dispose()
		{
			Dispose(disposing: true);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (WriteState != WriteState.Closed)
			{
				try
				{
					Close();
				}
				catch
				{
				}
			}
		}

		private void WriteLocalNamespaces(XPathNavigator nsNav)
		{
			string localName = nsNav.LocalName;
			string value = nsNav.Value;
			if (nsNav.MoveToNextNamespace(XPathNamespaceScope.Local))
			{
				WriteLocalNamespaces(nsNav);
			}
			if (localName.Length == 0)
			{
				WriteAttributeString(string.Empty, "xmlns", "http://www.w3.org/2000/xmlns/", value);
			}
			else
			{
				WriteAttributeString("xmlns", localName, "http://www.w3.org/2000/xmlns/", value);
			}
		}

		public static XmlWriter Create(string outputFileName)
		{
			return Create(outputFileName, null);
		}

		public static XmlWriter Create(string outputFileName, XmlWriterSettings settings)
		{
			if (outputFileName == null)
			{
				throw new ArgumentNullException("outputFileName");
			}
			if (settings == null)
			{
				settings = new XmlWriterSettings();
			}
			FileStream fileStream = null;
			try
			{
				fileStream = new FileStream(outputFileName, FileMode.Create, FileAccess.Write, FileShare.Read);
				return CreateWriterImpl(fileStream, settings.Encoding, closeOutput: true, settings);
			}
			catch
			{
				fileStream?.Close();
				throw;
			}
		}

		public static XmlWriter Create(Stream output)
		{
			return Create(output, null);
		}

		public static XmlWriter Create(Stream output, XmlWriterSettings settings)
		{
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			if (settings == null)
			{
				settings = new XmlWriterSettings();
			}
			return CreateWriterImpl(output, settings.Encoding, settings.CloseOutput, settings);
		}

		public static XmlWriter Create(TextWriter output)
		{
			return Create(output, null);
		}

		public static XmlWriter Create(TextWriter output, XmlWriterSettings settings)
		{
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			if (settings == null)
			{
				settings = new XmlWriterSettings();
			}
			return CreateWriterImpl(output, settings);
		}

		public static XmlWriter Create(StringBuilder output)
		{
			return Create(output, null);
		}

		public static XmlWriter Create(StringBuilder output, XmlWriterSettings settings)
		{
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			if (settings == null)
			{
				settings = new XmlWriterSettings();
			}
			return CreateWriterImpl(new StringWriter(output, CultureInfo.InvariantCulture), settings);
		}

		public static XmlWriter Create(XmlWriter output)
		{
			return Create(output, null);
		}

		public static XmlWriter Create(XmlWriter output, XmlWriterSettings settings)
		{
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			if (settings == null)
			{
				settings = new XmlWriterSettings();
			}
			return AddConformanceWrapper(output, output.Settings, settings);
		}

		private static XmlWriter CreateWriterImpl(Stream output, Encoding encoding, bool closeOutput, XmlWriterSettings settings)
		{
			XmlWriter xmlWriter;
			if (encoding.CodePage == 65001)
			{
				switch (settings.OutputMethod)
				{
				case XmlOutputMethod.Xml:
					xmlWriter = ((!settings.Indent) ? new XmlUtf8RawTextWriter(output, encoding, settings, closeOutput) : new XmlUtf8RawTextWriterIndent(output, encoding, settings, closeOutput));
					break;
				case XmlOutputMethod.Html:
					xmlWriter = ((!settings.Indent) ? new HtmlUtf8RawTextWriter(output, encoding, settings, closeOutput) : new HtmlUtf8RawTextWriterIndent(output, encoding, settings, closeOutput));
					break;
				case XmlOutputMethod.Text:
					xmlWriter = new TextUtf8RawTextWriter(output, encoding, settings, closeOutput);
					break;
				case XmlOutputMethod.AutoDetect:
					xmlWriter = new XmlAutoDetectWriter(output, encoding, settings);
					break;
				default:
					return null;
				}
			}
			else
			{
				switch (settings.OutputMethod)
				{
				case XmlOutputMethod.Xml:
					xmlWriter = ((!settings.Indent) ? new XmlEncodedRawTextWriter(output, encoding, settings, closeOutput) : new XmlEncodedRawTextWriterIndent(output, encoding, settings, closeOutput));
					break;
				case XmlOutputMethod.Html:
					xmlWriter = ((!settings.Indent) ? new HtmlEncodedRawTextWriter(output, encoding, settings, closeOutput) : new HtmlEncodedRawTextWriterIndent(output, encoding, settings, closeOutput));
					break;
				case XmlOutputMethod.Text:
					xmlWriter = new TextEncodedRawTextWriter(output, encoding, settings, closeOutput);
					break;
				case XmlOutputMethod.AutoDetect:
					xmlWriter = new XmlAutoDetectWriter(output, encoding, settings);
					break;
				default:
					return null;
				}
			}
			if (settings.OutputMethod != XmlOutputMethod.AutoDetect && settings.IsQuerySpecific)
			{
				xmlWriter = new QueryOutputWriter((XmlRawWriter)xmlWriter, settings);
			}
			return new XmlWellFormedWriter(xmlWriter, settings);
		}

		private static XmlWriter CreateWriterImpl(TextWriter output, XmlWriterSettings settings)
		{
			XmlWriter xmlWriter;
			switch (settings.OutputMethod)
			{
			case XmlOutputMethod.Xml:
				xmlWriter = ((!settings.Indent) ? new XmlEncodedRawTextWriter(output, settings) : new XmlEncodedRawTextWriterIndent(output, settings));
				break;
			case XmlOutputMethod.Html:
				xmlWriter = ((!settings.Indent) ? new HtmlEncodedRawTextWriter(output, settings) : new HtmlEncodedRawTextWriterIndent(output, settings));
				break;
			case XmlOutputMethod.Text:
				xmlWriter = new TextEncodedRawTextWriter(output, settings);
				break;
			case XmlOutputMethod.AutoDetect:
				xmlWriter = new XmlAutoDetectWriter(output, settings);
				break;
			default:
				return null;
			}
			if (settings.OutputMethod != XmlOutputMethod.AutoDetect && settings.IsQuerySpecific)
			{
				xmlWriter = new QueryOutputWriter((XmlRawWriter)xmlWriter, settings);
			}
			return new XmlWellFormedWriter(xmlWriter, settings);
		}

		private static XmlWriter AddConformanceWrapper(XmlWriter baseWriter, XmlWriterSettings baseWriterSettings, XmlWriterSettings settings)
		{
			ConformanceLevel conformanceLevel = ConformanceLevel.Auto;
			bool flag = false;
			bool checkNames = false;
			bool flag2 = false;
			bool flag3 = false;
			if (baseWriterSettings == null)
			{
				if (settings.NewLineHandling == NewLineHandling.Replace)
				{
					flag2 = true;
					flag3 = true;
				}
				if (settings.CheckCharacters)
				{
					flag = true;
					flag3 = true;
				}
			}
			else
			{
				if (settings.ConformanceLevel != baseWriterSettings.ConformanceLevel)
				{
					conformanceLevel = settings.ConformanceLevel;
					flag3 = true;
				}
				if (settings.CheckCharacters && !baseWriterSettings.CheckCharacters)
				{
					flag = true;
					checkNames = conformanceLevel == ConformanceLevel.Auto;
					flag3 = true;
				}
				if (settings.NewLineHandling == NewLineHandling.Replace && baseWriterSettings.NewLineHandling == NewLineHandling.None)
				{
					flag2 = true;
					flag3 = true;
				}
			}
			if (flag3)
			{
				XmlWriter xmlWriter = baseWriter;
				if (conformanceLevel != 0)
				{
					xmlWriter = new XmlWellFormedWriter(xmlWriter, settings);
				}
				if (flag || flag2)
				{
					xmlWriter = new XmlCharCheckingWriter(xmlWriter, flag, checkNames, flag2, settings.NewLineChars);
				}
				return xmlWriter;
			}
			return baseWriter;
		}
	}
	internal abstract class XmlRawWriter : XmlWriter
	{
		internal const int SurHighStart = 55296;

		internal const int SurHighEnd = 56319;

		internal const int SurLowStart = 56320;

		internal const int SurLowEnd = 57343;

		internal const int SurMask = 64512;

		protected XmlRawWriterBase64Encoder base64Encoder;

		protected IXmlNamespaceResolver resolver;

		public override WriteState WriteState
		{
			get
			{
				throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
			}
		}

		public override XmlSpace XmlSpace
		{
			get
			{
				throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
			}
		}

		public override string XmlLang
		{
			get
			{
				throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
			}
		}

		internal virtual IXmlNamespaceResolver NamespaceResolver
		{
			get
			{
				return resolver;
			}
			set
			{
				resolver = value;
			}
		}

		public override void WriteStartDocument()
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteStartDocument(bool standalone)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteEndDocument()
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
		}

		public override void WriteEndElement()
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteFullEndElement()
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteBase64(byte[] buffer, int index, int count)
		{
			if (base64Encoder == null)
			{
				base64Encoder = new XmlRawWriterBase64Encoder(this);
			}
			base64Encoder.Encode(buffer, index, count);
		}

		public override string LookupPrefix(string ns)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteNmToken(string name)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteName(string name)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteQualifiedName(string localName, string ns)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteCData(string text)
		{
			WriteString(text);
		}

		public override void WriteCharEntity(char ch)
		{
			WriteString(new string(new char[1] { ch }));
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			WriteString(new string(new char[2] { lowChar, highChar }));
		}

		public override void WriteWhitespace(string ws)
		{
			WriteString(ws);
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			WriteString(new string(buffer, index, count));
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			WriteString(new string(buffer, index, count));
		}

		public override void WriteRaw(string data)
		{
			WriteString(data);
		}

		public override void WriteValue(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			WriteString(XmlUntypedConverter.Untyped.ToString(value, resolver));
		}

		public override void WriteValue(string value)
		{
			WriteString(value);
		}

		public override void WriteAttributes(XmlReader reader, bool defattr)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteNode(XmlReader reader, bool defattr)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteNode(XPathNavigator navigator, bool defattr)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		internal virtual void WriteXmlDeclaration(XmlStandalone standalone)
		{
		}

		internal virtual void WriteXmlDeclaration(string xmldecl)
		{
		}

		internal abstract void StartElementContent();

		internal virtual void OnRootElement(ConformanceLevel conformanceLevel)
		{
		}

		internal abstract void WriteEndElement(string prefix, string localName, string ns);

		internal virtual void WriteFullEndElement(string prefix, string localName, string ns)
		{
			WriteEndElement(prefix, localName, ns);
		}

		internal virtual void WriteQualifiedName(string prefix, string localName, string ns)
		{
			if (prefix.Length != 0)
			{
				WriteString(prefix);
				WriteString(":");
			}
			WriteString(localName);
		}

		internal abstract void WriteNamespaceDeclaration(string prefix, string ns);

		internal virtual void WriteEndBase64()
		{
			base64Encoder.Flush();
		}

		internal virtual void Close(WriteState currentState)
		{
			Close();
		}
	}
	internal class XmlEncodedRawTextWriter : XmlRawWriter
	{
		private const int BUFSIZE = 6144;

		private const int OVERFLOW = 32;

		private const int INIT_MARKS_COUNT = 64;

		protected byte[] bufBytes;

		protected Stream stream;

		protected Encoding encoding;

		protected XmlCharType xmlCharType = XmlCharType.Instance;

		protected int bufPos = 1;

		protected int textPos = 1;

		protected int contentPos;

		protected int cdataPos;

		protected int attrEndPos;

		protected int bufLen = 6144;

		protected bool writeToNull;

		protected bool hadDoubleBracket;

		protected bool inAttributeValue;

		protected int bufBytesUsed;

		protected char[] bufChars;

		protected Encoder encoder;

		protected TextWriter writer;

		protected bool trackTextContent;

		protected bool inTextContent;

		private int lastMarkPos;

		private int[] textContentMarks;

		private CharEntityEncoderFallback charEntityFallback;

		protected NewLineHandling newLineHandling;

		protected bool closeOutput;

		protected bool omitXmlDeclaration;

		protected bool autoXmlDeclaration;

		protected string newLineChars;

		protected XmlStandalone standalone;

		protected XmlOutputMethod outputMethod;

		protected bool checkCharacters;

		protected bool mergeCDataSections;

		public override XmlWriterSettings Settings
		{
			get
			{
				XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
				xmlWriterSettings.Encoding = encoding;
				xmlWriterSettings.OmitXmlDeclaration = omitXmlDeclaration;
				xmlWriterSettings.NewLineHandling = newLineHandling;
				xmlWriterSettings.NewLineChars = newLineChars;
				xmlWriterSettings.CloseOutput = closeOutput;
				xmlWriterSettings.ConformanceLevel = ConformanceLevel.Auto;
				xmlWriterSettings.AutoXmlDeclaration = autoXmlDeclaration;
				xmlWriterSettings.Standalone = standalone;
				xmlWriterSettings.OutputMethod = outputMethod;
				xmlWriterSettings.CheckCharacters = checkCharacters;
				xmlWriterSettings.ReadOnly = true;
				return xmlWriterSettings;
			}
		}

		protected XmlEncodedRawTextWriter(XmlWriterSettings settings, bool closeOutput)
		{
			newLineHandling = settings.NewLineHandling;
			omitXmlDeclaration = settings.OmitXmlDeclaration;
			newLineChars = settings.NewLineChars;
			standalone = settings.Standalone;
			outputMethod = settings.OutputMethod;
			checkCharacters = settings.CheckCharacters;
			mergeCDataSections = settings.MergeCDataSections;
			this.closeOutput = closeOutput;
			if (checkCharacters && newLineHandling == NewLineHandling.Replace)
			{
				ValidateContentChars(newLineChars, "NewLineChars", allowOnlyWhitespace: false);
			}
		}

		public XmlEncodedRawTextWriter(TextWriter writer, XmlWriterSettings settings)
			: this(settings, settings.CloseOutput)
		{
			this.writer = writer;
			encoding = writer.Encoding;
			bufChars = new char[6176];
			if (settings.AutoXmlDeclaration)
			{
				WriteXmlDeclaration(standalone);
				autoXmlDeclaration = true;
			}
		}

		public XmlEncodedRawTextWriter(Stream stream, Encoding encoding, XmlWriterSettings settings, bool closeOutput)
			: this(settings, closeOutput)
		{
			this.stream = stream;
			this.encoding = encoding;
			bufChars = new char[6176];
			bufBytes = new byte[bufChars.Length];
			bufBytesUsed = 0;
			trackTextContent = true;
			inTextContent = false;
			lastMarkPos = 0;
			textContentMarks = new int[64];
			textContentMarks[0] = 1;
			charEntityFallback = new CharEntityEncoderFallback();
			encoding = (Encoding)encoding.Clone();
			encoding.EncoderFallback = charEntityFallback;
			this.encoding = encoding;
			encoder = encoding.GetEncoder();
			if (!stream.CanSeek || stream.Position == 0)
			{
				byte[] preamble = encoding.GetPreamble();
				if (preamble.Length != 0)
				{
					this.stream.Write(preamble, 0, preamble.Length);
				}
			}
			if (settings.AutoXmlDeclaration)
			{
				WriteXmlDeclaration(standalone);
				autoXmlDeclaration = true;
			}
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
			if (!omitXmlDeclaration && !autoXmlDeclaration)
			{
				if (trackTextContent && inTextContent)
				{
					ChangeTextContentMark(value: false);
				}
				RawText("<?xml version=\"");
				RawText("1.0");
				if (encoding != null)
				{
					RawText("\" encoding=\"");
					RawText((encoding.CodePage == 1201) ? "UTF-16BE" : encoding.WebName);
				}
				if (standalone != 0)
				{
					RawText("\" standalone=\"");
					RawText((standalone == XmlStandalone.Yes) ? "yes" : "no");
				}
				RawText("\"?>");
			}
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
			if (!omitXmlDeclaration && !autoXmlDeclaration)
			{
				WriteProcessingInstruction("xml", xmldecl);
			}
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			RawText("<!DOCTYPE ");
			RawText(name);
			if (pubid != null)
			{
				RawText(" PUBLIC \"");
				RawText(pubid);
				RawText("\" \"");
				if (sysid != null)
				{
					RawText(sysid);
				}
				bufChars[bufPos++] = '"';
			}
			else if (sysid != null)
			{
				RawText(" SYSTEM \"");
				RawText(sysid);
				bufChars[bufPos++] = '"';
			}
			else
			{
				bufChars[bufPos++] = ' ';
			}
			if (subset != null)
			{
				bufChars[bufPos++] = '[';
				RawText(subset);
				bufChars[bufPos++] = ']';
			}
			bufChars[bufPos++] = '>';
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			bufChars[bufPos++] = '<';
			if (prefix != null && prefix.Length != 0)
			{
				RawText(prefix);
				bufChars[bufPos++] = ':';
			}
			RawText(localName);
			attrEndPos = bufPos;
		}

		internal override void StartElementContent()
		{
			bufChars[bufPos++] = '>';
			contentPos = bufPos;
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			if (contentPos != bufPos)
			{
				bufChars[bufPos++] = '<';
				bufChars[bufPos++] = '/';
				if (prefix != null && prefix.Length != 0)
				{
					RawText(prefix);
					bufChars[bufPos++] = ':';
				}
				RawText(localName);
				bufChars[bufPos++] = '>';
			}
			else
			{
				bufPos--;
				bufChars[bufPos++] = ' ';
				bufChars[bufPos++] = '/';
				bufChars[bufPos++] = '>';
			}
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			bufChars[bufPos++] = '<';
			bufChars[bufPos++] = '/';
			if (prefix != null && prefix.Length != 0)
			{
				RawText(prefix);
				bufChars[bufPos++] = ':';
			}
			RawText(localName);
			bufChars[bufPos++] = '>';
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			if (attrEndPos == bufPos)
			{
				bufChars[bufPos++] = ' ';
			}
			if (prefix != null && prefix.Length > 0)
			{
				RawText(prefix);
				bufChars[bufPos++] = ':';
			}
			RawText(localName);
			bufChars[bufPos++] = '=';
			bufChars[bufPos++] = '"';
			inAttributeValue = true;
		}

		public override void WriteEndAttribute()
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			bufChars[bufPos++] = '"';
			inAttributeValue = false;
			attrEndPos = bufPos;
		}

		internal override void WriteNamespaceDeclaration(string prefix, string namespaceName)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			if (prefix.Length == 0)
			{
				RawText(" xmlns=\"");
			}
			else
			{
				RawText(" xmlns:");
				RawText(prefix);
				bufChars[bufPos++] = '=';
				bufChars[bufPos++] = '"';
			}
			inAttributeValue = true;
			if (trackTextContent && !inTextContent)
			{
				ChangeTextContentMark(value: true);
			}
			WriteString(namespaceName);
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			inAttributeValue = false;
			bufChars[bufPos++] = '"';
			attrEndPos = bufPos;
		}

		public override void WriteCData(string text)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			if (mergeCDataSections && bufPos == cdataPos)
			{
				bufPos -= 3;
			}
			else
			{
				bufChars[bufPos++] = '<';
				bufChars[bufPos++] = '!';
				bufChars[bufPos++] = '[';
				bufChars[bufPos++] = 'C';
				bufChars[bufPos++] = 'D';
				bufChars[bufPos++] = 'A';
				bufChars[bufPos++] = 'T';
				bufChars[bufPos++] = 'A';
				bufChars[bufPos++] = '[';
			}
			WriteCDataSection(text);
			bufChars[bufPos++] = ']';
			bufChars[bufPos++] = ']';
			bufChars[bufPos++] = '>';
			textPos = bufPos;
			cdataPos = bufPos;
		}

		public override void WriteComment(string text)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			bufChars[bufPos++] = '<';
			bufChars[bufPos++] = '!';
			bufChars[bufPos++] = '-';
			bufChars[bufPos++] = '-';
			WriteCommentOrPi(text, 45);
			bufChars[bufPos++] = '-';
			bufChars[bufPos++] = '-';
			bufChars[bufPos++] = '>';
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			bufChars[bufPos++] = '<';
			bufChars[bufPos++] = '?';
			RawText(name);
			if (text.Length > 0)
			{
				bufChars[bufPos++] = ' ';
				WriteCommentOrPi(text, 63);
			}
			bufChars[bufPos++] = '?';
			bufChars[bufPos++] = '>';
		}

		public override void WriteEntityRef(string name)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			bufChars[bufPos++] = '&';
			RawText(name);
			bufChars[bufPos++] = ';';
			if (bufPos > bufLen)
			{
				FlushBuffer();
			}
			textPos = bufPos;
		}

		public override void WriteCharEntity(char ch)
		{
			int num = ch;
			string s = num.ToString("X", NumberFormatInfo.InvariantInfo);
			if (checkCharacters && !xmlCharType.IsCharData(ch))
			{
				throw XmlConvert.CreateInvalidCharException(ch);
			}
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			bufChars[bufPos++] = '&';
			bufChars[bufPos++] = '#';
			bufChars[bufPos++] = 'x';
			RawText(s);
			bufChars[bufPos++] = ';';
			if (bufPos > bufLen)
			{
				FlushBuffer();
			}
			textPos = bufPos;
		}

		public unsafe override void WriteWhitespace(string ws)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			fixed (char* ptr = ws)
			{
				char* pSrcEnd = ptr + ws.Length;
				if (inAttributeValue)
				{
					WriteAttributeTextBlock(ptr, pSrcEnd);
				}
				else
				{
					WriteElementTextBlock(ptr, pSrcEnd);
				}
			}
		}

		public unsafe override void WriteString(string text)
		{
			if (trackTextContent && !inTextContent)
			{
				ChangeTextContentMark(value: true);
			}
			fixed (char* ptr = text)
			{
				char* pSrcEnd = ptr + text.Length;
				if (inAttributeValue)
				{
					WriteAttributeTextBlock(ptr, pSrcEnd);
				}
				else
				{
					WriteElementTextBlock(ptr, pSrcEnd);
				}
			}
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			int num = (lowChar - 56320) | ((highChar - 55296 << 10) + 65536);
			bufChars[bufPos++] = '&';
			bufChars[bufPos++] = '#';
			bufChars[bufPos++] = 'x';
			RawText(num.ToString("X", NumberFormatInfo.InvariantInfo));
			bufChars[bufPos++] = ';';
			textPos = bufPos;
		}

		public unsafe override void WriteChars(char[] buffer, int index, int count)
		{
			if (trackTextContent && !inTextContent)
			{
				ChangeTextContentMark(value: true);
			}
			fixed (char* ptr = &buffer[index])
			{
				if (inAttributeValue)
				{
					WriteAttributeTextBlock(ptr, ptr + count);
				}
				else
				{
					WriteElementTextBlock(ptr, ptr + count);
				}
			}
		}

		public unsafe override void WriteRaw(char[] buffer, int index, int count)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			fixed (char* ptr = &buffer[index])
			{
				WriteRawWithCharChecking(ptr, ptr + count);
			}
			textPos = bufPos;
		}

		public unsafe override void WriteRaw(string data)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			fixed (char* ptr = data)
			{
				WriteRawWithCharChecking(ptr, ptr + data.Length);
			}
			textPos = bufPos;
		}

		public override void Close()
		{
			FlushBuffer();
			FlushEncoder();
			writeToNull = true;
			if (stream != null)
			{
				stream.Flush();
				if (closeOutput)
				{
					stream.Close();
				}
				stream = null;
			}
			else if (writer != null)
			{
				writer.Flush();
				if (closeOutput)
				{
					writer.Close();
				}
				writer = null;
			}
		}

		public override void Flush()
		{
			FlushBuffer();
			FlushEncoder();
			if (stream != null)
			{
				stream.Flush();
			}
			else if (writer != null)
			{
				writer.Flush();
			}
		}

		protected virtual void FlushBuffer()
		{
			try
			{
				if (writeToNull)
				{
					return;
				}
				if (stream != null)
				{
					if (trackTextContent)
					{
						charEntityFallback.Reset(textContentMarks, lastMarkPos);
						if (((uint)lastMarkPos & (true ? 1u : 0u)) != 0)
						{
							textContentMarks[1] = 1;
							lastMarkPos = 1;
						}
						else
						{
							lastMarkPos = 0;
						}
					}
					EncodeChars(1, bufPos, writeAllToStream: true);
				}
				else
				{
					writer.Write(bufChars, 1, bufPos - 1);
				}
			}
			catch
			{
				writeToNull = true;
				throw;
			}
			finally
			{
				bufChars[0] = bufChars[bufPos - 1];
				textPos = ((textPos == bufPos) ? 1 : 0);
				attrEndPos = ((attrEndPos == bufPos) ? 1 : 0);
				contentPos = 0;
				cdataPos = 0;
				bufPos = 1;
			}
		}

		private void EncodeChars(int startOffset, int endOffset, bool writeAllToStream)
		{
			while (startOffset < endOffset)
			{
				if (charEntityFallback != null)
				{
					charEntityFallback.StartOffset = startOffset;
				}
				encoder.Convert(bufChars, startOffset, endOffset - startOffset, bufBytes, bufBytesUsed, bufBytes.Length - bufBytesUsed, flush: false, out var charsUsed, out var bytesUsed, out var _);
				startOffset += charsUsed;
				bufBytesUsed += bytesUsed;
				if (bufBytesUsed >= bufBytes.Length - 16)
				{
					stream.Write(bufBytes, 0, bufBytesUsed);
					bufBytesUsed = 0;
				}
			}
			if (writeAllToStream && bufBytesUsed > 0)
			{
				stream.Write(bufBytes, 0, bufBytesUsed);
				bufBytesUsed = 0;
			}
		}

		private void FlushEncoder()
		{
			if (stream != null)
			{
				encoder.Convert(bufChars, 1, 0, bufBytes, 0, bufBytes.Length, flush: true, out var _, out var bytesUsed, out var _);
				if (bytesUsed != 0)
				{
					stream.Write(bufBytes, 0, bytesUsed);
				}
			}
		}

		protected unsafe void WriteAttributeTextBlock(char* pSrc, char* pSrcEnd)
		{
			fixed (char* ptr = bufChars)
			{
				char* ptr2 = ptr + bufPos;
				int num = 0;
				while (true)
				{
					char* ptr3 = ptr2 + (pSrcEnd - pSrc);
					if (ptr3 > ptr + bufLen)
					{
						ptr3 = ptr + bufLen;
					}
					while (ptr2 < ptr3 && (xmlCharType.charProperties[num = *pSrc] & 0x80u) != 0)
					{
						*ptr2 = (char)num;
						ptr2++;
						pSrc++;
					}
					if (pSrc >= pSrcEnd)
					{
						break;
					}
					if (ptr2 >= ptr3)
					{
						bufPos = (int)(ptr2 - ptr);
						FlushBuffer();
						ptr2 = ptr + 1;
						continue;
					}
					switch (num)
					{
					case 38:
						ptr2 = AmpEntity(ptr2);
						break;
					case 60:
						ptr2 = LtEntity(ptr2);
						break;
					case 62:
						ptr2 = GtEntity(ptr2);
						break;
					case 34:
						ptr2 = QuoteEntity(ptr2);
						break;
					case 39:
						*ptr2 = (char)num;
						ptr2++;
						break;
					case 9:
						if (newLineHandling == NewLineHandling.None)
						{
							*ptr2 = (char)num;
							ptr2++;
						}
						else
						{
							ptr2 = TabEntity(ptr2);
						}
						break;
					case 13:
						if (newLineHandling == NewLineHandling.None)
						{
							*ptr2 = (char)num;
							ptr2++;
						}
						else
						{
							ptr2 = CarriageReturnEntity(ptr2);
						}
						break;
					case 10:
						if (newLineHandling == NewLineHandling.None)
						{
							*ptr2 = (char)num;
							ptr2++;
						}
						else
						{
							ptr2 = LineFeedEntity(ptr2);
						}
						break;
					default:
						if (InRange(num, 55296, 57343))
						{
							ptr2 = EncodeSurrogate(pSrc, pSrcEnd, ptr2);
							pSrc += 2;
						}
						else if (num <= 127 || num >= 65534)
						{
							ptr2 = InvalidXmlChar(num, ptr2, entitize: true);
							pSrc++;
						}
						else
						{
							*ptr2 = (char)num;
							ptr2++;
							pSrc++;
						}
						continue;
					}
					pSrc++;
				}
				bufPos = (int)(ptr2 - ptr);
			}
		}

		protected unsafe void WriteElementTextBlock(char* pSrc, char* pSrcEnd)
		{
			fixed (char* ptr = bufChars)
			{
				char* ptr2 = ptr + bufPos;
				int num = 0;
				while (true)
				{
					char* ptr3 = ptr2 + (pSrcEnd - pSrc);
					if (ptr3 > ptr + bufLen)
					{
						ptr3 = ptr + bufLen;
					}
					while (ptr2 < ptr3 && (xmlCharType.charProperties[num = *pSrc] & 0x80u) != 0)
					{
						*ptr2 = (char)num;
						ptr2++;
						pSrc++;
					}
					if (pSrc >= pSrcEnd)
					{
						break;
					}
					if (ptr2 >= ptr3)
					{
						bufPos = (int)(ptr2 - ptr);
						FlushBuffer();
						ptr2 = ptr + 1;
						continue;
					}
					switch (num)
					{
					case 38:
						ptr2 = AmpEntity(ptr2);
						break;
					case 60:
						ptr2 = LtEntity(ptr2);
						break;
					case 62:
						ptr2 = GtEntity(ptr2);
						break;
					case 9:
					case 34:
					case 39:
						*ptr2 = (char)num;
						ptr2++;
						break;
					case 10:
						if (newLineHandling == NewLineHandling.Replace)
						{
							ptr2 = WriteNewLine(ptr2);
							break;
						}
						*ptr2 = (char)num;
						ptr2++;
						break;
					case 13:
						switch (newLineHandling)
						{
						case NewLineHandling.Replace:
							if (pSrc[1] == '\n')
							{
								pSrc++;
							}
							ptr2 = WriteNewLine(ptr2);
							break;
						case NewLineHandling.Entitize:
							ptr2 = CarriageReturnEntity(ptr2);
							break;
						case NewLineHandling.None:
							*ptr2 = (char)num;
							ptr2++;
							break;
						}
						break;
					default:
						if (InRange(num, 55296, 57343))
						{
							ptr2 = EncodeSurrogate(pSrc, pSrcEnd, ptr2);
							pSrc += 2;
						}
						else if (num <= 127 || num >= 65534)
						{
							ptr2 = InvalidXmlChar(num, ptr2, entitize: true);
							pSrc++;
						}
						else
						{
							*ptr2 = (char)num;
							ptr2++;
							pSrc++;
						}
						continue;
					}
					pSrc++;
				}
				bufPos = (int)(ptr2 - ptr);
				textPos = bufPos;
				contentPos = 0;
			}
		}

		protected unsafe void RawText(string s)
		{
			fixed (char* ptr = s)
			{
				RawText(ptr, ptr + s.Length);
			}
		}

		protected unsafe void RawText(char* pSrcBegin, char* pSrcEnd)
		{
			fixed (char* ptr = bufChars)
			{
				char* ptr2 = ptr + bufPos;
				char* ptr3 = pSrcBegin;
				int num = 0;
				while (true)
				{
					char* ptr4 = ptr2 + (pSrcEnd - ptr3);
					if (ptr4 > ptr + bufLen)
					{
						ptr4 = ptr + bufLen;
					}
					for (; ptr2 < ptr4; ptr2++)
					{
						if ((num = *ptr3) >= 55296)
						{
							break;
						}
						ptr3++;
						*ptr2 = (char)num;
					}
					if (ptr3 >= pSrcEnd)
					{
						break;
					}
					if (ptr2 >= ptr4)
					{
						bufPos = (int)(ptr2 - ptr);
						FlushBuffer();
						ptr2 = ptr + 1;
					}
					else if (InRange(num, 55296, 57343))
					{
						ptr2 = EncodeSurrogate(ptr3, pSrcEnd, ptr2);
						ptr3 += 2;
					}
					else if (num <= 127 || num >= 65534)
					{
						ptr2 = InvalidXmlChar(num, ptr2, entitize: false);
						ptr3++;
					}
					else
					{
						*ptr2 = (char)num;
						ptr2++;
						ptr3++;
					}
				}
				bufPos = (int)(ptr2 - ptr);
			}
		}

		protected unsafe void WriteRawWithCharChecking(char* pSrcBegin, char* pSrcEnd)
		{
			fixed (char* ptr2 = bufChars)
			{
				char* ptr = pSrcBegin;
				char* ptr3 = ptr2 + bufPos;
				int num = 0;
				while (true)
				{
					char* ptr4 = ptr3 + (pSrcEnd - ptr);
					if (ptr4 > ptr2 + bufLen)
					{
						ptr4 = ptr2 + bufLen;
					}
					while (ptr3 < ptr4 && (xmlCharType.charProperties[num = *ptr] & 0x40u) != 0)
					{
						*ptr3 = (char)num;
						ptr3++;
						ptr++;
					}
					if (ptr >= pSrcEnd)
					{
						break;
					}
					if (ptr3 >= ptr4)
					{
						bufPos = (int)(ptr3 - ptr2);
						FlushBuffer();
						ptr3 = ptr2 + 1;
						continue;
					}
					switch (num)
					{
					case 9:
					case 38:
					case 60:
					case 93:
						*ptr3 = (char)num;
						ptr3++;
						break;
					case 13:
						if (newLineHandling == NewLineHandling.Replace)
						{
							if (ptr[1] == '\n')
							{
								ptr++;
							}
							ptr3 = WriteNewLine(ptr3);
						}
						else
						{
							*ptr3 = (char)num;
							ptr3++;
						}
						break;
					case 10:
						if (newLineHandling == NewLineHandling.Replace)
						{
							ptr3 = WriteNewLine(ptr3);
							break;
						}
						*ptr3 = (char)num;
						ptr3++;
						break;
					default:
						if (InRange(num, 55296, 57343))
						{
							ptr3 = EncodeSurrogate(ptr, pSrcEnd, ptr3);
							ptr += 2;
						}
						else if (num <= 127 || num >= 65534)
						{
							ptr3 = InvalidXmlChar(num, ptr3, entitize: false);
							ptr++;
						}
						else
						{
							*ptr3 = (char)num;
							ptr3++;
							ptr++;
						}
						continue;
					}
					ptr++;
				}
				bufPos = (int)(ptr3 - ptr2);
			}
		}

		protected unsafe void WriteCommentOrPi(string text, int stopChar)
		{
			fixed (char* ptr = text)
			{
				fixed (char* ptr4 = bufChars)
				{
					char* ptr2 = ptr;
					char* ptr3 = ptr + text.Length;
					char* ptr5 = ptr4 + bufPos;
					int num = 0;
					while (true)
					{
						char* ptr6 = ptr5 + (ptr3 - ptr2);
						if (ptr6 > ptr4 + bufLen)
						{
							ptr6 = ptr4 + bufLen;
						}
						while (ptr5 < ptr6 && (xmlCharType.charProperties[num = *ptr2] & 0x40u) != 0 && num != stopChar)
						{
							*ptr5 = (char)num;
							ptr5++;
							ptr2++;
						}
						if (ptr2 >= ptr3)
						{
							break;
						}
						if (ptr5 >= ptr6)
						{
							bufPos = (int)(ptr5 - ptr4);
							FlushBuffer();
							ptr5 = ptr4 + 1;
							continue;
						}
						switch (num)
						{
						case 45:
							*ptr5 = '-';
							ptr5++;
							if (num == stopChar && (ptr2 + 1 == ptr3 || ptr2[1] == '-'))
							{
								*ptr5 = ' ';
								ptr5++;
							}
							break;
						case 63:
							*ptr5 = '?';
							ptr5++;
							if (num == stopChar && ptr2 + 1 < ptr3 && ptr2[1] == '>')
							{
								*ptr5 = ' ';
								ptr5++;
							}
							break;
						case 93:
							*ptr5 = ']';
							ptr5++;
							break;
						case 13:
							if (newLineHandling == NewLineHandling.Replace)
							{
								if (ptr2[1] == '\n')
								{
									ptr2++;
								}
								ptr5 = WriteNewLine(ptr5);
							}
							else
							{
								*ptr5 = (char)num;
								ptr5++;
							}
							break;
						case 10:
							if (newLineHandling == NewLineHandling.Replace)
							{
								ptr5 = WriteNewLine(ptr5);
								break;
							}
							*ptr5 = (char)num;
							ptr5++;
							break;
						case 9:
						case 38:
						case 60:
							*ptr5 = (char)num;
							ptr5++;
							break;
						default:
							if (InRange(num, 55296, 57343))
							{
								ptr5 = EncodeSurrogate(ptr2, ptr3, ptr5);
								ptr2 += 2;
							}
							else if (num <= 127 || num >= 65534)
							{
								ptr5 = InvalidXmlChar(num, ptr5, entitize: false);
								ptr2++;
							}
							else
							{
								*ptr5 = (char)num;
								ptr5++;
								ptr2++;
							}
							continue;
						}
						ptr2++;
					}
					bufPos = (int)(ptr5 - ptr4);
				}
			}
		}

		protected unsafe void WriteCDataSection(string text)
		{
			fixed (char* ptr = text)
			{
				fixed (char* ptr4 = bufChars)
				{
					char* ptr2 = ptr;
					char* ptr3 = ptr + text.Length;
					char* ptr5 = ptr4 + bufPos;
					int num = 0;
					while (true)
					{
						char* ptr6 = ptr5 + (ptr3 - ptr2);
						if (ptr6 > ptr4 + bufLen)
						{
							ptr6 = ptr4 + bufLen;
						}
						while (ptr5 < ptr6 && (xmlCharType.charProperties[num = *ptr2] & 0x80u) != 0 && num != 93)
						{
							*ptr5 = (char)num;
							ptr5++;
							ptr2++;
						}
						if (ptr2 >= ptr3)
						{
							break;
						}
						if (ptr5 >= ptr6)
						{
							bufPos = (int)(ptr5 - ptr4);
							FlushBuffer();
							ptr5 = ptr4 + 1;
							continue;
						}
						switch (num)
						{
						case 62:
							if (hadDoubleBracket && *(ushort*)((byte*)ptr5 + -2) == 93)
							{
								ptr5 = RawEndCData(ptr5);
								ptr5 = RawStartCData(ptr5);
							}
							*ptr5 = '>';
							ptr5++;
							break;
						case 93:
							if (*(ushort*)((byte*)ptr5 + -2) == 93)
							{
								hadDoubleBracket = true;
							}
							else
							{
								hadDoubleBracket = false;
							}
							*ptr5 = ']';
							ptr5++;
							break;
						case 13:
							if (newLineHandling == NewLineHandling.Replace)
							{
								if (ptr2[1] == '\n')
								{
									ptr2++;
								}
								ptr5 = WriteNewLine(ptr5);
							}
							else
							{
								*ptr5 = (char)num;
								ptr5++;
							}
							break;
						case 10:
							if (newLineHandling == NewLineHandling.Replace)
							{
								ptr5 = WriteNewLine(ptr5);
								break;
							}
							*ptr5 = (char)num;
							ptr5++;
							break;
						case 9:
						case 34:
						case 38:
						case 39:
						case 60:
							*ptr5 = (char)num;
							ptr5++;
							break;
						default:
							if (InRange(num, 55296, 57343))
							{
								ptr5 = EncodeSurrogate(ptr2, ptr3, ptr5);
								ptr2 += 2;
							}
							else if (num <= 127 || num >= 65534)
							{
								ptr5 = InvalidXmlChar(num, ptr5, entitize: false);
								ptr2++;
							}
							else
							{
								*ptr5 = (char)num;
								ptr5++;
								ptr2++;
							}
							continue;
						}
						ptr2++;
					}
					bufPos = (int)(ptr5 - ptr4);
				}
			}
		}

		private unsafe static char* EncodeSurrogate(char* pSrc, char* pSrcEnd, char* pDst)
		{
			int num = *pSrc;
			if (num <= 56319)
			{
				if (pSrc + 1 < pSrcEnd)
				{
					int num2 = pSrc[1];
					if (num2 >= 56320)
					{
						*pDst = (char)num;
						pDst[1] = (char)num2;
						pDst += 2;
						return pDst;
					}
					throw XmlConvert.CreateInvalidSurrogatePairException((char)num2, (char)num);
				}
				throw new ArgumentException(Res.GetString("Xml_InvalidSurrogateMissingLowChar"));
			}
			throw XmlConvert.CreateInvalidHighSurrogateCharException((char)num);
		}

		private unsafe char* InvalidXmlChar(int ch, char* pDst, bool entitize)
		{
			if (checkCharacters)
			{
				throw XmlConvert.CreateInvalidCharException((char)ch);
			}
			if (entitize)
			{
				return CharEntity(pDst, (char)ch);
			}
			*pDst = (char)ch;
			pDst++;
			return pDst;
		}

		internal unsafe void EncodeChar(ref char* pSrc, char* pSrcEnd, ref char* pDst)
		{
			int num = *pSrc;
			if (InRange(num, 55296, 57343))
			{
				pDst = EncodeSurrogate(pSrc, pSrcEnd, pDst);
				pSrc += 2;
			}
			else if (num <= 127 || num >= 65534)
			{
				pDst = InvalidXmlChar(num, pDst, entitize: false);
				pSrc++;
			}
			else
			{
				*pDst = (char)num;
				pDst++;
				pSrc++;
			}
		}

		protected void ChangeTextContentMark(bool value)
		{
			inTextContent = value;
			if (lastMarkPos + 1 == textContentMarks.Length)
			{
				GrowTextContentMarks();
			}
			textContentMarks[++lastMarkPos] = bufPos;
		}

		private void GrowTextContentMarks()
		{
			int[] destinationArray = new int[textContentMarks.Length * 2];
			Array.Copy(textContentMarks, destinationArray, textContentMarks.Length);
			textContentMarks = destinationArray;
		}

		protected unsafe char* WriteNewLine(char* pDst)
		{
			fixed (char* ptr = bufChars)
			{
				bufPos = (int)(pDst - ptr);
				RawText(newLineChars);
				return ptr + bufPos;
			}
		}

		protected unsafe static char* LtEntity(char* pDst)
		{
			*pDst = '&';
			pDst[1] = 'l';
			pDst[2] = 't';
			pDst[3] = ';';
			return pDst + 4;
		}

		protected unsafe static char* GtEntity(char* pDst)
		{
			*pDst = '&';
			pDst[1] = 'g';
			pDst[2] = 't';
			pDst[3] = ';';
			return pDst + 4;
		}

		protected unsafe static char* AmpEntity(char* pDst)
		{
			*pDst = '&';
			pDst[1] = 'a';
			pDst[2] = 'm';
			pDst[3] = 'p';
			pDst[4] = ';';
			return pDst + 5;
		}

		protected unsafe static char* QuoteEntity(char* pDst)
		{
			*pDst = '&';
			pDst[1] = 'q';
			pDst[2] = 'u';
			pDst[3] = 'o';
			pDst[4] = 't';
			pDst[5] = ';';
			return pDst + 6;
		}

		protected unsafe static char* TabEntity(char* pDst)
		{
			*pDst = '&';
			pDst[1] = '#';
			pDst[2] = 'x';
			pDst[3] = '9';
			pDst[4] = ';';
			return pDst + 5;
		}

		protected unsafe static char* LineFeedEntity(char* pDst)
		{
			*pDst = '&';
			pDst[1] = '#';
			pDst[2] = 'x';
			pDst[3] = 'A';
			pDst[4] = ';';
			return pDst + 5;
		}

		protected unsafe static char* CarriageReturnEntity(char* pDst)
		{
			*pDst = '&';
			pDst[1] = '#';
			pDst[2] = 'x';
			pDst[3] = 'D';
			pDst[4] = ';';
			return pDst + 5;
		}

		private unsafe static char* CharEntity(char* pDst, char ch)
		{
			int num = ch;
			string text = num.ToString("X", NumberFormatInfo.InvariantInfo);
			*pDst = '&';
			pDst[1] = '#';
			pDst[2] = 'x';
			pDst += 3;
			fixed (char* ptr = text)
			{
				char* ptr2 = ptr;
				char c;
				do
				{
					char* intPtr = pDst;
					pDst = intPtr + 1;
					char* intPtr2 = ptr2;
					ptr2 = intPtr2 + 1;
					*intPtr = (c = *intPtr2);
				}
				while (c != 0);
			}
			*(short*)((byte*)pDst + -2) = 59;
			return pDst;
		}

		protected unsafe static char* RawStartCData(char* pDst)
		{
			*pDst = '<';
			pDst[1] = '!';
			pDst[2] = '[';
			pDst[3] = 'C';
			pDst[4] = 'D';
			pDst[5] = 'A';
			pDst[6] = 'T';
			pDst[7] = 'A';
			pDst[8] = '[';
			return pDst + 9;
		}

		protected unsafe static char* RawEndCData(char* pDst)
		{
			*pDst = ']';
			pDst[1] = ']';
			pDst[2] = '>';
			return pDst + 3;
		}

		private static bool InRange(int ch, int start, int end)
		{
			return (uint)(ch - start) <= (uint)(end - start);
		}

		protected void ValidateContentChars(string chars, string propertyName, bool allowOnlyWhitespace)
		{
			if (allowOnlyWhitespace)
			{
				if (!xmlCharType.IsOnlyWhitespace(chars))
				{
					throw new ArgumentException(Res.GetString("Xml_IndentCharsNotWhitespace", propertyName));
				}
				return;
			}
			string text = null;
			int num = 0;
			while (true)
			{
				if (num >= chars.Length)
				{
					return;
				}
				if (!xmlCharType.IsTextChar(chars[num]))
				{
					switch (chars[num])
					{
					case '&':
					case '<':
					case ']':
						text = Res.GetString("Xml_InvalidCharacter", XmlException.BuildCharExceptionStr(chars[num]));
						break;
					default:
						if (chars[num] >= '\ud800' && chars[num] <= '\udbff')
						{
							if (num + 1 < chars.Length && chars[num + 1] >= '\udc00' && chars[num + 1] <= '\udfff')
							{
								num++;
								goto IL_0152;
							}
							text = Res.GetString("Xml_InvalidSurrogateMissingLowChar");
						}
						else
						{
							if (chars[num] < '\udc00' || chars[num] > '\udfff')
							{
								goto IL_0152;
							}
							text = Res.GetString("Xml_InvalidSurrogateHighChar", ((uint)chars[num]).ToString("X", CultureInfo.InvariantCulture));
						}
						break;
					case '\t':
					case '\n':
					case '\r':
						goto IL_0152;
					}
					break;
				}
				goto IL_0152;
				IL_0152:
				num++;
			}
			throw new ArgumentException(Res.GetString("Xml_InvalidCharsInIndent", propertyName, text));
		}
	}
	internal class HtmlEncodedRawTextWriter : XmlEncodedRawTextWriter
	{
		private const int StackIncrement = 10;

		protected ByteStack elementScope;

		protected ElementProperties currentElementProperties;

		private AttributeProperties currentAttributeProperties;

		private bool endsWithAmpersand;

		private byte[] uriEscapingBuffer;

		private string mediaType;

		private bool doNotEscapeUriAttributes;

		protected static TernaryTreeReadOnly elementPropertySearch;

		protected static TernaryTreeReadOnly attributePropertySearch;

		public HtmlEncodedRawTextWriter(TextWriter writer, XmlWriterSettings settings)
			: base(writer, settings)
		{
			Init(settings);
		}

		public HtmlEncodedRawTextWriter(Stream stream, Encoding encoding, XmlWriterSettings settings, bool closeOutput)
			: base(stream, encoding, settings, closeOutput)
		{
			Init(settings);
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			RawText("<!DOCTYPE ");
			if (name == "HTML")
			{
				RawText("HTML");
			}
			else
			{
				RawText("html");
			}
			if (pubid != null)
			{
				RawText(" PUBLIC \"");
				RawText(pubid);
				if (sysid != null)
				{
					RawText("\" \"");
					RawText(sysid);
				}
				bufChars[bufPos++] = '"';
			}
			else if (sysid != null)
			{
				RawText(" SYSTEM \"");
				RawText(sysid);
				bufChars[bufPos++] = '"';
			}
			else
			{
				bufChars[bufPos++] = ' ';
			}
			if (subset != null)
			{
				bufChars[bufPos++] = '[';
				RawText(subset);
				bufChars[bufPos++] = ']';
			}
			bufChars[bufPos++] = '>';
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			elementScope.Push((byte)currentElementProperties);
			if (ns.Length == 0)
			{
				if (trackTextContent && inTextContent)
				{
					ChangeTextContentMark(value: false);
				}
				currentElementProperties = (ElementProperties)elementPropertySearch.FindCaseInsensitiveString(localName);
				bufChars[bufPos++] = '<';
				RawText(localName);
				attrEndPos = bufPos;
			}
			else
			{
				currentElementProperties = ElementProperties.HAS_NS;
				base.WriteStartElement(prefix, localName, ns);
			}
		}

		internal override void StartElementContent()
		{
			bufChars[bufPos++] = '>';
			contentPos = bufPos;
			if ((currentElementProperties & ElementProperties.HEAD) != 0)
			{
				WriteMetaElement();
			}
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			if (ns.Length == 0)
			{
				if (trackTextContent && inTextContent)
				{
					ChangeTextContentMark(value: false);
				}
				if ((currentElementProperties & ElementProperties.EMPTY) == 0)
				{
					bufChars[bufPos++] = '<';
					bufChars[bufPos++] = '/';
					RawText(localName);
					bufChars[bufPos++] = '>';
				}
			}
			else
			{
				base.WriteEndElement(prefix, localName, ns);
			}
			currentElementProperties = (ElementProperties)elementScope.Pop();
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			if (ns.Length == 0)
			{
				if (trackTextContent && inTextContent)
				{
					ChangeTextContentMark(value: false);
				}
				if ((currentElementProperties & ElementProperties.EMPTY) == 0)
				{
					bufChars[bufPos++] = '<';
					bufChars[bufPos++] = '/';
					RawText(localName);
					bufChars[bufPos++] = '>';
				}
			}
			else
			{
				base.WriteFullEndElement(prefix, localName, ns);
			}
			currentElementProperties = (ElementProperties)elementScope.Pop();
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (ns.Length == 0)
			{
				if (trackTextContent && inTextContent)
				{
					ChangeTextContentMark(value: false);
				}
				if (attrEndPos == bufPos)
				{
					bufChars[bufPos++] = ' ';
				}
				RawText(localName);
				if ((currentElementProperties & (ElementProperties)7u) != 0)
				{
					currentAttributeProperties = (AttributeProperties)((uint)attributePropertySearch.FindCaseInsensitiveString(localName) & (uint)currentElementProperties);
					if ((currentAttributeProperties & AttributeProperties.BOOLEAN) != 0)
					{
						inAttributeValue = true;
						return;
					}
				}
				else
				{
					currentAttributeProperties = AttributeProperties.DEFAULT;
				}
				bufChars[bufPos++] = '=';
				bufChars[bufPos++] = '"';
			}
			else
			{
				base.WriteStartAttribute(prefix, localName, ns);
				currentAttributeProperties = AttributeProperties.DEFAULT;
			}
			inAttributeValue = true;
		}

		public override void WriteEndAttribute()
		{
			if ((currentAttributeProperties & AttributeProperties.BOOLEAN) != 0)
			{
				attrEndPos = bufPos;
			}
			else
			{
				if (endsWithAmpersand)
				{
					OutputRestAmps();
					endsWithAmpersand = false;
				}
				if (trackTextContent && inTextContent)
				{
					ChangeTextContentMark(value: false);
				}
				bufChars[bufPos++] = '"';
			}
			inAttributeValue = false;
			attrEndPos = bufPos;
		}

		public override void WriteProcessingInstruction(string target, string text)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			bufChars[bufPos++] = '<';
			bufChars[bufPos++] = '?';
			RawText(target);
			bufChars[bufPos++] = ' ';
			WriteCommentOrPi(text, 63);
			bufChars[bufPos++] = '>';
			if (bufPos > bufLen)
			{
				FlushBuffer();
			}
		}

		public unsafe override void WriteString(string text)
		{
			if (trackTextContent && !inTextContent)
			{
				ChangeTextContentMark(value: true);
			}
			fixed (char* ptr = text)
			{
				char* pSrcEnd = ptr + text.Length;
				if (inAttributeValue)
				{
					WriteHtmlAttributeTextBlock(ptr, pSrcEnd);
				}
				else
				{
					WriteHtmlElementTextBlock(ptr, pSrcEnd);
				}
			}
		}

		public override void WriteEntityRef(string name)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteCharEntity(char ch)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public unsafe override void WriteChars(char[] buffer, int index, int count)
		{
			if (trackTextContent && !inTextContent)
			{
				ChangeTextContentMark(value: true);
			}
			fixed (char* ptr = &buffer[index])
			{
				if (inAttributeValue)
				{
					WriteAttributeTextBlock(ptr, ptr + count);
				}
				else
				{
					WriteElementTextBlock(ptr, ptr + count);
				}
			}
		}

		private void Init(XmlWriterSettings settings)
		{
			if (elementPropertySearch == null)
			{
				attributePropertySearch = new TernaryTreeReadOnly(HtmlTernaryTree.htmlAttributes);
				elementPropertySearch = new TernaryTreeReadOnly(HtmlTernaryTree.htmlElements);
			}
			elementScope = new ByteStack(10);
			uriEscapingBuffer = new byte[5];
			currentElementProperties = ElementProperties.DEFAULT;
			mediaType = settings.MediaType;
			doNotEscapeUriAttributes = settings.DoNotEscapeUriAttributes;
		}

		protected void WriteMetaElement()
		{
			RawText("<META http-equiv=\"Content-Type\"");
			if (mediaType == null)
			{
				mediaType = "text/html";
			}
			RawText(" content=\"");
			RawText(mediaType);
			RawText("; charset=");
			RawText(encoding.WebName);
			RawText("\">");
		}

		protected unsafe void WriteHtmlElementTextBlock(char* pSrc, char* pSrcEnd)
		{
			if ((currentElementProperties & ElementProperties.NO_ENTITIES) != 0)
			{
				RawText(pSrc, pSrcEnd);
			}
			else
			{
				WriteElementTextBlock(pSrc, pSrcEnd);
			}
		}

		protected unsafe void WriteHtmlAttributeTextBlock(char* pSrc, char* pSrcEnd)
		{
			if ((currentAttributeProperties & (AttributeProperties)7u) != 0)
			{
				if ((currentAttributeProperties & AttributeProperties.BOOLEAN) == 0)
				{
					if ((currentAttributeProperties & (AttributeProperties)5u) != 0 && !doNotEscapeUriAttributes)
					{
						WriteUriAttributeText(pSrc, pSrcEnd);
					}
					else
					{
						WriteHtmlAttributeText(pSrc, pSrcEnd);
					}
				}
			}
			else if ((currentElementProperties & ElementProperties.HAS_NS) != 0)
			{
				WriteAttributeTextBlock(pSrc, pSrcEnd);
			}
			else
			{
				WriteHtmlAttributeText(pSrc, pSrcEnd);
			}
		}

		private unsafe void WriteHtmlAttributeText(char* pSrc, char* pSrcEnd)
		{
			if (endsWithAmpersand)
			{
				if (pSrcEnd - pSrc > 0 && *pSrc != '{')
				{
					OutputRestAmps();
				}
				endsWithAmpersand = false;
			}
			fixed (char* ptr = bufChars)
			{
				char* pDst = ptr + bufPos;
				char c = '\0';
				while (true)
				{
					char* ptr2 = pDst + (pSrcEnd - pSrc);
					if (ptr2 > ptr + bufLen)
					{
						ptr2 = ptr + bufLen;
					}
					while (pDst < ptr2 && (xmlCharType.charProperties[(int)(c = *pSrc)] & 0x80u) != 0)
					{
						char* intPtr = pDst;
						pDst = intPtr + 1;
						*intPtr = c;
						pSrc++;
					}
					if (pSrc >= pSrcEnd)
					{
						break;
					}
					if (pDst >= ptr2)
					{
						bufPos = (int)(pDst - ptr);
						FlushBuffer();
						pDst = ptr + 1;
						continue;
					}
					switch (c)
					{
					case '&':
					{
						if (pSrc + 1 == pSrcEnd)
						{
							endsWithAmpersand = true;
						}
						else if (pSrc[1] != '{')
						{
							pDst = XmlEncodedRawTextWriter.AmpEntity(pDst);
							break;
						}
						char* intPtr3 = pDst;
						pDst = intPtr3 + 1;
						*intPtr3 = c;
						break;
					}
					case '"':
						pDst = XmlEncodedRawTextWriter.QuoteEntity(pDst);
						break;
					case '\t':
					case '\'':
					case '<':
					case '>':
					{
						char* intPtr2 = pDst;
						pDst = intPtr2 + 1;
						*intPtr2 = c;
						break;
					}
					case '\r':
						pDst = XmlEncodedRawTextWriter.CarriageReturnEntity(pDst);
						break;
					case '\n':
						pDst = XmlEncodedRawTextWriter.LineFeedEntity(pDst);
						break;
					default:
						EncodeChar(ref pSrc, pSrcEnd, ref pDst);
						continue;
					}
					pSrc++;
				}
				bufPos = (int)(pDst - ptr);
			}
		}

		private unsafe void WriteUriAttributeText(char* pSrc, char* pSrcEnd)
		{
			if (endsWithAmpersand)
			{
				if (pSrcEnd - pSrc > 0 && *pSrc != '{')
				{
					OutputRestAmps();
				}
				endsWithAmpersand = false;
			}
			fixed (char* ptr = bufChars)
			{
				char* ptr2 = ptr + bufPos;
				char c = '\0';
				while (true)
				{
					char* ptr3 = ptr2 + (pSrcEnd - pSrc);
					if (ptr3 > ptr + bufLen)
					{
						ptr3 = ptr + bufLen;
					}
					while (ptr2 < ptr3 && (xmlCharType.charProperties[(int)(c = *pSrc)] & 0x80u) != 0 && c < '\u0080')
					{
						char* intPtr = ptr2;
						ptr2 = intPtr + 1;
						*intPtr = c;
						pSrc++;
					}
					if (pSrc >= pSrcEnd)
					{
						break;
					}
					if (ptr2 >= ptr3)
					{
						bufPos = (int)(ptr2 - ptr);
						FlushBuffer();
						ptr2 = ptr + 1;
						continue;
					}
					switch (c)
					{
					case '&':
					{
						if (pSrc + 1 == pSrcEnd)
						{
							endsWithAmpersand = true;
						}
						else if (pSrc[1] != '{')
						{
							ptr2 = XmlEncodedRawTextWriter.AmpEntity(ptr2);
							break;
						}
						char* intPtr6 = ptr2;
						ptr2 = intPtr6 + 1;
						*intPtr6 = c;
						break;
					}
					case '"':
						ptr2 = XmlEncodedRawTextWriter.QuoteEntity(ptr2);
						break;
					case '\t':
					case '\'':
					case '<':
					case '>':
					{
						char* intPtr5 = ptr2;
						ptr2 = intPtr5 + 1;
						*intPtr5 = c;
						break;
					}
					case '\r':
						ptr2 = XmlEncodedRawTextWriter.CarriageReturnEntity(ptr2);
						break;
					case '\n':
						ptr2 = XmlEncodedRawTextWriter.LineFeedEntity(ptr2);
						break;
					default:
						fixed (byte* ptr4 = uriEscapingBuffer)
						{
							byte* ptr5 = ptr4;
							byte* pDst = ptr5;
							XmlUtf8RawTextWriter.CharToUTF8(ref pSrc, pSrcEnd, ref pDst);
							for (; ptr5 < pDst; ptr5++)
							{
								char* intPtr2 = ptr2;
								ptr2 = intPtr2 + 1;
								*intPtr2 = '%';
								char* intPtr3 = ptr2;
								ptr2 = intPtr3 + 1;
								*intPtr3 = "0123456789ABCDEF"[*ptr5 >> 4];
								char* intPtr4 = ptr2;
								ptr2 = intPtr4 + 1;
								*intPtr4 = "0123456789ABCDEF"[*ptr5 & 0xF];
							}
						}
						continue;
					}
					pSrc++;
				}
				bufPos = (int)(ptr2 - ptr);
			}
		}

		private void OutputRestAmps()
		{
			bufChars[bufPos++] = 'a';
			bufChars[bufPos++] = 'm';
			bufChars[bufPos++] = 'p';
			bufChars[bufPos++] = ';';
		}
	}
	internal class HtmlEncodedRawTextWriterIndent : HtmlEncodedRawTextWriter
	{
		private int indentLevel;

		private int endBlockPos;

		private string indentChars;

		private bool newLineOnAttributes;

		public HtmlEncodedRawTextWriterIndent(TextWriter writer, XmlWriterSettings settings)
			: base(writer, settings)
		{
			Init(settings);
		}

		public HtmlEncodedRawTextWriterIndent(Stream stream, Encoding encoding, XmlWriterSettings settings, bool closeOutput)
			: base(stream, encoding, settings, closeOutput)
		{
			Init(settings);
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			base.WriteDocType(name, pubid, sysid, subset);
			endBlockPos = bufPos;
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			if (trackTextContent && inTextContent)
			{
				ChangeTextContentMark(value: false);
			}
			elementScope.Push((byte)currentElementProperties);
			if (ns.Length == 0)
			{
				currentElementProperties = (ElementProperties)HtmlEncodedRawTextWriter.elementPropertySearch.FindCaseInsensitiveString(localName);
				if (endBlockPos == bufPos && (currentElementProperties & ElementProperties.BLOCK_WS) != 0)
				{
					WriteIndent();
				}
				indentLevel++;
				bufChars[bufPos++] = '<';
			}
			else
			{
				currentElementProperties = (ElementProperties)192u;
				if (endBlockPos == bufPos)
				{
					WriteIndent();
				}
				indentLevel++;
				bufChars[bufPos++] = '<';
				if (prefix.Length != 0)
				{
					RawText(prefix);
					bufChars[bufPos++] = ':';
				}
			}
			RawText(localName);
			attrEndPos = bufPos;
		}

		internal override void StartElementContent()
		{
			bufChars[bufPos++] = '>';
			contentPos = bufPos;
			if ((currentElementProperties & ElementProperties.HEAD) != 0)
			{
				WriteIndent();
				WriteMetaElement();
				endBlockPos = bufPos;
			}
			else if ((currentElementProperties & ElementProperties.BLOCK_WS) != 0)
			{
				endBlockPos = bufPos;
			}
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			indentLevel--;
			bool flag = (currentElementProperties & ElementProperties.BLOCK_WS) != 0;
			if (flag && endBlockPos == bufPos && contentPos != bufPos)
			{
				WriteIndent();
			}
			base.WriteEndElement(prefix, localName, ns);
			contentPos = 0;
			if (flag)
			{
				endBlockPos = bufPos;
			}
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (newLineOnAttributes)
			{
				RawText(newLineChars);
				indentLevel++;
				WriteIndent();
				indentLevel--;
			}
			base.WriteStartAttribute(prefix, localName, ns);
		}

		protected override void FlushBuffer()
		{
			endBlockPos = ((endBlockPos == bufPos) ? 1 : 0);
			base.FlushBuffer();
		}

		private void Init(XmlWriterSettings settings)
		{
			indentLevel = 0;
			indentChars = settings.IndentChars;
			newLineOnAttributes = settings.NewLineOnAttributes;
		}

		private void WriteIndent()
		{
			RawText(newLineChars);
			for (int num = indentLevel; num > 0; num--)
			{
				RawText(indentChars);
			}
		}
	}
	internal abstract class HtmlTernaryTree
	{
		internal static byte[] htmlElements = new byte[1212]
		{
			73, 4, 147, 0, 77, 140, 162, 0, 71, 0,
			0, 0, 0, 0, 0, 11, 68, 4, 85, 0,
			73, 71, 92, 0, 86, 81, 0, 0, 0, 0,
			0, 64, 66, 3, 45, 0, 82, 21, 55, 0,
			0, 0, 0, 8, 65, 0, 0, 0, 82, 4,
			0, 0, 69, 0, 0, 0, 65, 0, 0, 0,
			0, 0, 0, 75, 68, 7, 8, 0, 68, 0,
			0, 0, 82, 0, 0, 0, 69, 0, 0, 0,
			83, 0, 0, 0, 83, 0, 0, 0, 0, 0,
			0, 64, 0, 0, 0, 1, 80, 0, 0, 0,
			80, 0, 0, 0, 76, 0, 0, 0, 69, 0,
			0, 0, 84, 0, 0, 0, 0, 0, 0, 64,
			65, 0, 9, 0, 83, 0, 0, 0, 69, 0,
			0, 0, 70, 5, 0, 0, 79, 0, 0, 0,
			78, 0, 0, 0, 84, 0, 0, 0, 0, 0,
			0, 72, 0, 0, 0, 73, 76, 0, 10, 0,
			79, 0, 0, 0, 67, 0, 0, 0, 75, 0,
			0, 0, 81, 0, 0, 0, 85, 0, 0, 0,
			79, 0, 0, 0, 84, 0, 0, 0, 69, 0,
			0, 0, 0, 0, 0, 65, 79, 0, 0, 0,
			68, 0, 0, 0, 89, 0, 0, 0, 0, 0,
			0, 64, 67, 0, 0, 0, 79, 3, 0, 0,
			76, 0, 0, 0, 0, 0, 22, 72, 65, 0,
			13, 0, 80, 0, 0, 0, 84, 0, 0, 0,
			73, 0, 0, 0, 79, 0, 0, 0, 78, 0,
			0, 0, 0, 0, 0, 64, 85, 0, 0, 0,
			84, 0, 0, 0, 84, 0, 0, 0, 79, 0,
			0, 0, 78, 0, 0, 0, 0, 0, 0, 2,
			69, 0, 0, 0, 78, 0, 0, 0, 84, 0,
			0, 0, 69, 0, 0, 0, 82, 0, 0, 0,
			0, 0, 0, 64, 68, 0, 8, 0, 0, 0,
			0, 64, 71, 0, 0, 0, 82, 0, 0, 0,
			79, 0, 0, 0, 85, 0, 0, 0, 80, 0,
			0, 0, 0, 0, 0, 64, 69, 0, 0, 0,
			76, 0, 0, 0, 0, 0, 0, 65, 82, 0,
			0, 0, 0, 0, 0, 66, 72, 3, 0, 0,
			50, 31, 33, 0, 0, 0, 0, 64, 70, 0,
			0, 0, 79, 8, 16, 0, 78, 0, 20, 0,
			84, 0, 0, 0, 0, 0, 0, 64, 84, 2,
			0, 0, 0, 0, 0, 64, 76, 0, 0, 0,
			0, 0, 0, 66, 73, 0, 0, 0, 69, 0,
			0, 0, 76, 0, 0, 0, 68, 0, 0, 0,
			83, 0, 0, 0, 69, 0, 0, 0, 84, 0,
			0, 0, 0, 0, 0, 64, 82, 0, 0, 0,
			65, 0, 0, 0, 77, 0, 0, 0, 69, 0,
			0, 0, 0, 0, 4, 74, 82, 0, 0, 0,
			77, 0, 0, 0, 0, 0, 0, 65, 83, 0,
			0, 0, 69, 0, 0, 0, 84, 0, 0, 0,
			0, 0, 0, 64, 49, 0, 0, 0, 0, 0,
			0, 64, 54, 2, 8, 0, 0, 0, 0, 64,
			52, 2, 4, 0, 0, 0, 0, 64, 51, 0,
			0, 0, 0, 0, 0, 64, 53, 0, 0, 0,
			0, 0, 0, 64, 82, 2, 6, 0, 0, 0,
			0, 74, 69, 0, 0, 0, 65, 0, 0, 0,
			68, 0, 0, 0, 0, 0, 0, 97, 84, 0,
			0, 0, 77, 0, 0, 0, 76, 0, 0, 0,
			0, 0, 0, 64, 70, 0, 0, 0, 82, 0,
			0, 0, 65, 0, 0, 0, 77, 0, 0, 0,
			69, 0, 0, 0, 0, 0, 0, 64, 80, 4,
			84, 0, 82, 77, 0, 0, 69, 0, 0, 0,
			0, 0, 0, 64, 77, 5, 37, 0, 69, 30,
			0, 0, 84, 32, 0, 0, 65, 0, 0, 0,
			0, 0, 0, 72, 76, 0, 0, 0, 69, 0,
			20, 0, 71, 0, 0, 0, 69, 0, 0, 0,
			78, 0, 0, 0, 68, 0, 0, 0, 0, 0,
			0, 64, 78, 0, 7, 0, 83, 2, 0, 0,
			0, 0, 0, 65, 80, 0, 0, 0, 85, 0,
			0, 0, 84, 0, 0, 0, 0, 0, 0, 11,
			83, 0, 0, 0, 73, 0, 0, 0, 78, 0,
			0, 0, 68, 0, 0, 0, 69, 0, 0, 0,
			88, 0, 0, 0, 0, 0, 0, 72, 73, 0,
			0, 0, 78, 3, 0, 0, 75, 0, 0, 0,
			0, 0, 0, 73, 0, 0, 0, 64, 65, 0,
			0, 0, 80, 0, 0, 0, 0, 0, 0, 64,
			78, 0, 0, 0, 85, 0, 0, 0, 0, 0,
			0, 66, 79, 3, 0, 0, 76, 18, 24, 0,
			0, 0, 0, 66, 78, 0, 0, 0, 79, 0,
			0, 0, 83, 7, 0, 0, 67, 0, 0, 0,
			82, 0, 0, 0, 73, 0, 0, 0, 80, 0,
			0, 0, 84, 0, 0, 0, 0, 0, 0, 64,
			70, 0, 0, 0, 82, 0, 0, 0, 65, 0,
			0, 0, 77, 0, 0, 0, 69, 0, 0, 0,
			83, 0, 0, 0, 0, 0, 0, 64, 66, 0,
			0, 0, 74, 0, 0, 0, 69, 0, 0, 0,
			67, 0, 0, 0, 84, 0, 0, 0, 0, 0,
			0, 3, 80, 0, 0, 0, 84, 0, 0, 0,
			73, 4, 0, 0, 79, 0, 0, 0, 78, 0,
			0, 0, 0, 0, 0, 66, 71, 0, 0, 0,
			82, 0, 0, 0, 79, 0, 0, 0, 85, 0,
			0, 0, 80, 0, 0, 0, 0, 0, 0, 66,
			0, 0, 1, 64, 65, 0, 0, 0, 82, 0,
			0, 0, 65, 0, 0, 0, 77, 0, 0, 0,
			0, 0, 0, 72, 84, 3, 65, 0, 68, 28,
			38, 0, 0, 0, 0, 66, 83, 8, 0, 0,
			69, 6, 15, 0, 76, 0, 0, 0, 69, 0,
			0, 0, 67, 0, 0, 0, 84, 0, 0, 0,
			0, 0, 0, 2, 0, 0, 3, 64, 81, 0,
			0, 0, 0, 0, 0, 1, 67, 0, 0, 0,
			82, 0, 0, 0, 73, 0, 0, 0, 80, 0,
			0, 0, 84, 0, 0, 0, 0, 0, 0, 19,
			84, 0, 0, 0, 89, 4, 0, 0, 76, 0,
			0, 0, 69, 0, 0, 0, 0, 0, 0, 80,
			82, 0, 0, 0, 73, 0, 0, 0, 75, 0,
			0, 0, 69, 0, 0, 0, 0, 0, 0, 64,
			65, 0, 5, 0, 66, 0, 0, 0, 76, 0,
			0, 0, 69, 0, 0, 0, 0, 0, 0, 65,
			66, 0, 0, 0, 79, 0, 0, 0, 68, 0,
			0, 0, 89, 0, 0, 0, 0, 0, 0, 64,
			72, 5, 19, 0, 69, 17, 0, 0, 65, 0,
			0, 0, 68, 0, 0, 0, 0, 0, 0, 64,
			70, 5, 0, 0, 79, 0, 0, 0, 79, 0,
			0, 0, 84, 0, 0, 0, 0, 0, 0, 64,
			69, 0, 0, 0, 88, 0, 0, 0, 84, 0,
			0, 0, 65, 0, 0, 0, 82, 0, 0, 0,
			69, 0, 0, 0, 65, 0, 0, 0, 0, 0,
			0, 2, 0, 0, 0, 66, 82, 2, 0, 0,
			0, 0, 0, 64, 73, 0, 0, 0, 84, 0,
			0, 0, 76, 0, 0, 0, 69, 0, 0, 0,
			0, 0, 0, 64, 85, 0, 3, 0, 76, 0,
			0, 0, 0, 0, 0, 66, 88, 0, 0, 0,
			77, 0, 0, 0, 80, 0, 0, 0, 0, 0,
			0, 64
		};

		internal static byte[] htmlAttributes = new byte[664]
		{
			72, 5, 77, 0, 82, 0, 0, 0, 69, 0,
			0, 0, 70, 0, 0, 0, 0, 0, 0, 1,
			67, 12, 40, 0, 79, 7, 0, 0, 77, 31,
			0, 0, 80, 0, 0, 0, 65, 0, 0, 0,
			67, 0, 0, 0, 84, 0, 0, 0, 0, 0,
			0, 2, 73, 11, 18, 0, 84, 0, 0, 0,
			69, 0, 0, 0, 0, 0, 0, 1, 65, 0,
			0, 0, 67, 0, 0, 0, 84, 0, 0, 0,
			73, 0, 0, 0, 79, 0, 0, 0, 78, 0,
			0, 0, 0, 0, 0, 1, 72, 0, 0, 0,
			69, 0, 0, 0, 67, 0, 0, 0, 75, 0,
			0, 0, 69, 0, 0, 0, 68, 0, 0, 0,
			0, 0, 0, 2, 76, 0, 0, 0, 65, 0,
			0, 0, 83, 0, 0, 0, 83, 0, 0, 0,
			73, 0, 0, 0, 68, 0, 0, 0, 0, 0,
			0, 1, 68, 0, 0, 0, 69, 0, 0, 0,
			66, 0, 0, 0, 65, 0, 0, 0, 83, 0,
			0, 0, 69, 0, 0, 0, 0, 0, 0, 1,
			68, 0, 28, 0, 69, 7, 15, 0, 67, 0,
			22, 0, 76, 0, 0, 0, 65, 0, 0, 0,
			82, 0, 0, 0, 69, 0, 0, 0, 0, 0,
			0, 2, 65, 0, 0, 0, 84, 0, 0, 0,
			65, 0, 0, 0, 0, 0, 1, 1, 83, 0,
			0, 0, 82, 0, 0, 0, 67, 0, 0, 0,
			0, 0, 0, 1, 73, 0, 0, 0, 83, 0,
			0, 0, 65, 0, 0, 0, 66, 0, 0, 0,
			76, 0, 0, 0, 69, 0, 0, 0, 68, 0,
			0, 0, 0, 0, 0, 2, 70, 0, 0, 0,
			69, 0, 0, 0, 82, 0, 0, 0, 0, 0,
			0, 2, 70, 0, 0, 0, 79, 0, 0, 0,
			82, 0, 0, 0, 0, 0, 0, 1, 78, 8,
			48, 0, 79, 36, 0, 0, 83, 30, 55, 0,
			72, 0, 0, 0, 65, 0, 0, 0, 68, 0,
			0, 0, 69, 0, 0, 0, 0, 0, 0, 2,
			77, 9, 0, 0, 85, 0, 0, 0, 76, 0,
			0, 0, 84, 0, 0, 0, 73, 0, 0, 0,
			80, 0, 0, 0, 76, 0, 0, 0, 69, 0,
			0, 0, 0, 0, 0, 2, 73, 0, 6, 0,
			83, 0, 0, 0, 77, 0, 0, 0, 65, 0,
			0, 0, 80, 0, 0, 0, 0, 0, 0, 2,
			76, 0, 0, 0, 79, 0, 0, 0, 78, 0,
			0, 0, 71, 0, 0, 0, 68, 0, 0, 0,
			69, 0, 0, 0, 83, 0, 0, 0, 67, 0,
			0, 0, 0, 0, 0, 1, 72, 0, 9, 0,
			82, 0, 0, 0, 69, 0, 0, 0, 70, 0,
			0, 0, 0, 0, 0, 2, 65, 0, 0, 0,
			77, 0, 0, 0, 69, 0, 0, 0, 0, 0,
			0, 1, 82, 0, 0, 0, 69, 0, 0, 0,
			83, 0, 0, 0, 73, 0, 0, 0, 90, 0,
			0, 0, 69, 0, 0, 0, 0, 0, 0, 2,
			82, 14, 22, 0, 69, 0, 0, 0, 65, 0,
			0, 0, 68, 0, 0, 0, 79, 0, 0, 0,
			78, 0, 0, 0, 76, 0, 0, 0, 89, 0,
			0, 0, 0, 0, 0, 2, 87, 0, 0, 0,
			82, 0, 0, 0, 65, 0, 0, 0, 80, 0,
			0, 0, 0, 0, 0, 2, 80, 0, 0, 0,
			82, 0, 0, 0, 79, 0, 0, 0, 70, 0,
			0, 0, 73, 0, 0, 0, 76, 0, 0, 0,
			69, 0, 0, 0, 0, 0, 0, 1, 83, 0,
			12, 0, 82, 3, 0, 0, 67, 0, 0, 0,
			0, 0, 0, 1, 69, 0, 0, 0, 76, 0,
			0, 0, 69, 0, 0, 0, 67, 0, 0, 0,
			84, 0, 0, 0, 69, 0, 0, 0, 68, 0,
			0, 0, 0, 0, 0, 2, 85, 0, 0, 0,
			83, 0, 0, 0, 69, 0, 0, 0, 77, 0,
			0, 0, 65, 0, 0, 0, 80, 0, 0, 0,
			0, 0, 0, 1
		};
	}
	internal class XmlUtf8RawTextWriter : XmlRawWriter
	{
		private const int BUFSIZE = 6144;

		private const int OVERFLOW = 32;

		private const int INIT_MARKS_COUNT = 64;

		protected byte[] bufBytes;

		protected Stream stream;

		protected Encoding encoding;

		protected XmlCharType xmlCharType = XmlCharType.Instance;

		protected int bufPos = 1;

		protected int textPos = 1;

		protected int contentPos;

		protected int cdataPos;

		protected int attrEndPos;

		protected int bufLen = 6144;

		protected bool writeToNull;

		protected bool hadDoubleBracket;

		protected bool inAttributeValue;

		protected NewLineHandling newLineHandling;

		protected bool closeOutput;

		protected bool omitXmlDeclaration;

		protected bool autoXmlDeclaration;

		protected string newLineChars;

		protected XmlStandalone standalone;

		protected XmlOutputMethod outputMethod;

		protected bool checkCharacters;

		protected bool mergeCDataSections;

		public override XmlWriterSettings Settings
		{
			get
			{
				XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
				xmlWriterSettings.Encoding = encoding;
				xmlWriterSettings.OmitXmlDeclaration = omitXmlDeclaration;
				xmlWriterSettings.NewLineHandling = newLineHandling;
				xmlWriterSettings.NewLineChars = newLineChars;
				xmlWriterSettings.CloseOutput = closeOutput;
				xmlWriterSettings.ConformanceLevel = ConformanceLevel.Auto;
				xmlWriterSettings.AutoXmlDeclaration = autoXmlDeclaration;
				xmlWriterSettings.Standalone = standalone;
				xmlWriterSettings.OutputMethod = outputMethod;
				xmlWriterSettings.CheckCharacters = checkCharacters;
				xmlWriterSettings.ReadOnly = true;
				return xmlWriterSettings;
			}
		}

		protected XmlUtf8RawTextWriter(XmlWriterSettings settings, bool closeOutput)
		{
			newLineHandling = settings.NewLineHandling;
			omitXmlDeclaration = settings.OmitXmlDeclaration;
			newLineChars = settings.NewLineChars;
			standalone = settings.Standalone;
			outputMethod = settings.OutputMethod;
			checkCharacters = settings.CheckCharacters;
			mergeCDataSections = settings.MergeCDataSections;
			this.closeOutput = closeOutput;
			if (checkCharacters && newLineHandling == NewLineHandling.Replace)
			{
				ValidateContentChars(newLineChars, "NewLineChars", allowOnlyWhitespace: false);
			}
		}

		public XmlUtf8RawTextWriter(Stream stream, Encoding encoding, XmlWriterSettings settings, bool closeOutput)
			: this(settings, closeOutput)
		{
			this.stream = stream;
			this.encoding = encoding;
			bufBytes = new byte[6176];
			if (!stream.CanSeek || stream.Position == 0)
			{
				byte[] preamble = encoding.GetPreamble();
				if (preamble.Length != 0)
				{
					Buffer.BlockCopy(preamble, 0, bufBytes, 1, preamble.Length);
					bufPos += preamble.Length;
					textPos += preamble.Length;
				}
			}
			if (settings.AutoXmlDeclaration)
			{
				WriteXmlDeclaration(standalone);
				autoXmlDeclaration = true;
			}
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
			if (!omitXmlDeclaration && !autoXmlDeclaration)
			{
				RawText("<?xml version=\"");
				RawText("1.0");
				if (encoding != null)
				{
					RawText("\" encoding=\"");
					RawText((encoding.CodePage == 1201) ? "UTF-16BE" : encoding.WebName);
				}
				if (standalone != 0)
				{
					RawText("\" standalone=\"");
					RawText((standalone == XmlStandalone.Yes) ? "yes" : "no");
				}
				RawText("\"?>");
			}
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
			if (!omitXmlDeclaration && !autoXmlDeclaration)
			{
				WriteProcessingInstruction("xml", xmldecl);
			}
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			RawText("<!DOCTYPE ");
			RawText(name);
			if (pubid != null)
			{
				RawText(" PUBLIC \"");
				RawText(pubid);
				RawText("\" \"");
				if (sysid != null)
				{
					RawText(sysid);
				}
				bufBytes[bufPos++] = 34;
			}
			else if (sysid != null)
			{
				RawText(" SYSTEM \"");
				RawText(sysid);
				bufBytes[bufPos++] = 34;
			}
			else
			{
				bufBytes[bufPos++] = 32;
			}
			if (subset != null)
			{
				bufBytes[bufPos++] = 91;
				RawText(subset);
				bufBytes[bufPos++] = 93;
			}
			bufBytes[bufPos++] = 62;
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			bufBytes[bufPos++] = 60;
			if (prefix != null && prefix.Length != 0)
			{
				RawText(prefix);
				bufBytes[bufPos++] = 58;
			}
			RawText(localName);
			attrEndPos = bufPos;
		}

		internal override void StartElementContent()
		{
			bufBytes[bufPos++] = 62;
			contentPos = bufPos;
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			if (contentPos != bufPos)
			{
				bufBytes[bufPos++] = 60;
				bufBytes[bufPos++] = 47;
				if (prefix != null && prefix.Length != 0)
				{
					RawText(prefix);
					bufBytes[bufPos++] = 58;
				}
				RawText(localName);
				bufBytes[bufPos++] = 62;
			}
			else
			{
				bufPos--;
				bufBytes[bufPos++] = 32;
				bufBytes[bufPos++] = 47;
				bufBytes[bufPos++] = 62;
			}
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			bufBytes[bufPos++] = 60;
			bufBytes[bufPos++] = 47;
			if (prefix != null && prefix.Length != 0)
			{
				RawText(prefix);
				bufBytes[bufPos++] = 58;
			}
			RawText(localName);
			bufBytes[bufPos++] = 62;
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (attrEndPos == bufPos)
			{
				bufBytes[bufPos++] = 32;
			}
			if (prefix != null && prefix.Length > 0)
			{
				RawText(prefix);
				bufBytes[bufPos++] = 58;
			}
			RawText(localName);
			bufBytes[bufPos++] = 61;
			bufBytes[bufPos++] = 34;
			inAttributeValue = true;
		}

		public override void WriteEndAttribute()
		{
			bufBytes[bufPos++] = 34;
			inAttributeValue = false;
			attrEndPos = bufPos;
		}

		internal override void WriteNamespaceDeclaration(string prefix, string namespaceName)
		{
			if (prefix.Length == 0)
			{
				RawText(" xmlns=\"");
			}
			else
			{
				RawText(" xmlns:");
				RawText(prefix);
				bufBytes[bufPos++] = 61;
				bufBytes[bufPos++] = 34;
			}
			inAttributeValue = true;
			WriteString(namespaceName);
			inAttributeValue = false;
			bufBytes[bufPos++] = 34;
			attrEndPos = bufPos;
		}

		public override void WriteCData(string text)
		{
			if (mergeCDataSections && bufPos == cdataPos)
			{
				bufPos -= 3;
			}
			else
			{
				bufBytes[bufPos++] = 60;
				bufBytes[bufPos++] = 33;
				bufBytes[bufPos++] = 91;
				bufBytes[bufPos++] = 67;
				bufBytes[bufPos++] = 68;
				bufBytes[bufPos++] = 65;
				bufBytes[bufPos++] = 84;
				bufBytes[bufPos++] = 65;
				bufBytes[bufPos++] = 91;
			}
			WriteCDataSection(text);
			bufBytes[bufPos++] = 93;
			bufBytes[bufPos++] = 93;
			bufBytes[bufPos++] = 62;
			textPos = bufPos;
			cdataPos = bufPos;
		}

		public override void WriteComment(string text)
		{
			bufBytes[bufPos++] = 60;
			bufBytes[bufPos++] = 33;
			bufBytes[bufPos++] = 45;
			bufBytes[bufPos++] = 45;
			WriteCommentOrPi(text, 45);
			bufBytes[bufPos++] = 45;
			bufBytes[bufPos++] = 45;
			bufBytes[bufPos++] = 62;
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			bufBytes[bufPos++] = 60;
			bufBytes[bufPos++] = 63;
			RawText(name);
			if (text.Length > 0)
			{
				bufBytes[bufPos++] = 32;
				WriteCommentOrPi(text, 63);
			}
			bufBytes[bufPos++] = 63;
			bufBytes[bufPos++] = 62;
		}

		public override void WriteEntityRef(string name)
		{
			bufBytes[bufPos++] = 38;
			RawText(name);
			bufBytes[bufPos++] = 59;
			if (bufPos > bufLen)
			{
				FlushBuffer();
			}
			textPos = bufPos;
		}

		public override void WriteCharEntity(char ch)
		{
			int num = ch;
			string s = num.ToString("X", NumberFormatInfo.InvariantInfo);
			if (checkCharacters && !xmlCharType.IsCharData(ch))
			{
				throw XmlConvert.CreateInvalidCharException(ch);
			}
			bufBytes[bufPos++] = 38;
			bufBytes[bufPos++] = 35;
			bufBytes[bufPos++] = 120;
			RawText(s);
			bufBytes[bufPos++] = 59;
			if (bufPos > bufLen)
			{
				FlushBuffer();
			}
			textPos = bufPos;
		}

		public unsafe override void WriteWhitespace(string ws)
		{
			fixed (char* ptr = ws)
			{
				char* pSrcEnd = ptr + ws.Length;
				if (inAttributeValue)
				{
					WriteAttributeTextBlock(ptr, pSrcEnd);
				}
				else
				{
					WriteElementTextBlock(ptr, pSrcEnd);
				}
			}
		}

		public unsafe override void WriteString(string text)
		{
			fixed (char* ptr = text)
			{
				char* pSrcEnd = ptr + text.Length;
				if (inAttributeValue)
				{
					WriteAttributeTextBlock(ptr, pSrcEnd);
				}
				else
				{
					WriteElementTextBlock(ptr, pSrcEnd);
				}
			}
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			int num = (lowChar - 56320) | ((highChar - 55296 << 10) + 65536);
			bufBytes[bufPos++] = 38;
			bufBytes[bufPos++] = 35;
			bufBytes[bufPos++] = 120;
			RawText(num.ToString("X", NumberFormatInfo.InvariantInfo));
			bufBytes[bufPos++] = 59;
			textPos = bufPos;
		}

		public unsafe override void WriteChars(char[] buffer, int index, int count)
		{
			fixed (char* ptr = &buffer[index])
			{
				if (inAttributeValue)
				{
					WriteAttributeTextBlock(ptr, ptr + count);
				}
				else
				{
					WriteElementTextBlock(ptr, ptr + count);
				}
			}
		}

		public unsafe override void WriteRaw(char[] buffer, int index, int count)
		{
			fixed (char* ptr = &buffer[index])
			{
				WriteRawWithCharChecking(ptr, ptr + count);
			}
			textPos = bufPos;
		}

		public unsafe override void WriteRaw(string data)
		{
			fixed (char* ptr = data)
			{
				WriteRawWithCharChecking(ptr, ptr + data.Length);
			}
			textPos = bufPos;
		}

		public override void Close()
		{
			FlushBuffer();
			FlushEncoder();
			writeToNull = true;
			if (stream != null)
			{
				stream.Flush();
				if (closeOutput)
				{
					stream.Close();
				}
				stream = null;
			}
		}

		public override void Flush()
		{
			FlushBuffer();
			FlushEncoder();
			if (stream != null)
			{
				stream.Flush();
			}
		}

		protected virtual void FlushBuffer()
		{
			try
			{
				if (!writeToNull)
				{
					stream.Write(bufBytes, 1, bufPos - 1);
				}
			}
			catch
			{
				writeToNull = true;
				throw;
			}
			finally
			{
				bufBytes[0] = bufBytes[bufPos - 1];
				if (IsSurrogateByte(bufBytes[0]))
				{
					bufBytes[1] = bufBytes[bufPos];
					bufBytes[2] = bufBytes[bufPos + 1];
					bufBytes[3] = bufBytes[bufPos + 2];
				}
				textPos = ((textPos == bufPos) ? 1 : 0);
				attrEndPos = ((attrEndPos == bufPos) ? 1 : 0);
				contentPos = 0;
				cdataPos = 0;
				bufPos = 1;
			}
		}

		private void FlushEncoder()
		{
		}

		protected unsafe void WriteAttributeTextBlock(char* pSrc, char* pSrcEnd)
		{
			fixed (byte* ptr = bufBytes)
			{
				byte* ptr2 = ptr + bufPos;
				int num = 0;
				while (true)
				{
					byte* ptr3 = ptr2 + (pSrcEnd - pSrc);
					if (ptr3 > ptr + bufLen)
					{
						ptr3 = ptr + bufLen;
					}
					while (ptr2 < ptr3 && (xmlCharType.charProperties[num = *pSrc] & 0x80u) != 0 && num <= 127)
					{
						*ptr2 = (byte)num;
						ptr2++;
						pSrc++;
					}
					if (pSrc >= pSrcEnd)
					{
						break;
					}
					if (ptr2 >= ptr3)
					{
						bufPos = (int)(ptr2 - ptr);
						FlushBuffer();
						ptr2 = ptr + 1;
						continue;
					}
					switch (num)
					{
					case 38:
						ptr2 = AmpEntity(ptr2);
						break;
					case 60:
						ptr2 = LtEntity(ptr2);
						break;
					case 62:
						ptr2 = GtEntity(ptr2);
						break;
					case 34:
						ptr2 = QuoteEntity(ptr2);
						break;
					case 39:
						*ptr2 = (byte)num;
						ptr2++;
						break;
					case 9:
						if (newLineHandling == NewLineHandling.None)
						{
							*ptr2 = (byte)num;
							ptr2++;
						}
						else
						{
							ptr2 = TabEntity(ptr2);
						}
						break;
					case 13:
						if (newLineHandling == NewLineHandling.None)
						{
							*ptr2 = (byte)num;
							ptr2++;
						}
						else
						{
							ptr2 = CarriageReturnEntity(ptr2);
						}
						break;
					case 10:
						if (newLineHandling == NewLineHandling.None)
						{
							*ptr2 = (byte)num;
							ptr2++;
						}
						else
						{
							ptr2 = LineFeedEntity(ptr2);
						}
						break;
					default:
						if (InRange(num, 55296, 57343))
						{
							ptr2 = EncodeSurrogate(pSrc, pSrcEnd, ptr2);
							pSrc += 2;
						}
						else if (num <= 127 || num >= 65534)
						{
							ptr2 = InvalidXmlChar(num, ptr2, entitize: true);
							pSrc++;
						}
						else
						{
							ptr2 = EncodeMultibyteUTF8(num, ptr2);
							pSrc++;
						}
						continue;
					}
					pSrc++;
				}
				bufPos = (int)(ptr2 - ptr);
			}
		}

		protected unsafe void WriteElementTextBlock(char* pSrc, char* pSrcEnd)
		{
			fixed (byte* ptr = bufBytes)
			{
				byte* ptr2 = ptr + bufPos;
				int num = 0;
				while (true)
				{
					byte* ptr3 = ptr2 + (pSrcEnd - pSrc);
					if (ptr3 > ptr + bufLen)
					{
						ptr3 = ptr + bufLen;
					}
					while (ptr2 < ptr3 && (xmlCharType.charProperties[num = *pSrc] & 0x80u) != 0 && num <= 127)
					{
						*ptr2 = (byte)num;
						ptr2++;
						pSrc++;
					}
					if (pSrc >= pSrcEnd)
					{
						break;
					}
					if (ptr2 >= ptr3)
					{
						bufPos = (int)(ptr2 - ptr);
						FlushBuffer();
						ptr2 = ptr + 1;
						continue;
					}
					switch (num)
					{
					case 38:
						ptr2 = AmpEntity(ptr2);
						break;
					case 60:
						ptr2 = LtEntity(ptr2);
						break;
					case 62:
						ptr2 = GtEntity(ptr2);
						break;
					case 9:
					case 34:
					case 39:
						*ptr2 = (byte)num;
						ptr2++;
						break;
					case 10:
						if (newLineHandling == NewLineHandling.Replace)
						{
							ptr2 = WriteNewLine(ptr2);
							break;
						}
						*ptr2 = (byte)num;
						ptr2++;
						break;
					case 13:
						switch (newLineHandling)
						{
						case NewLineHandling.Replace:
							if (pSrc[1] == '\n')
							{
								pSrc++;
							}
							ptr2 = WriteNewLine(ptr2);
							break;
						case NewLineHandling.Entitize:
							ptr2 = CarriageReturnEntity(ptr2);
							break;
						case NewLineHandling.None:
							*ptr2 = (byte)num;
							ptr2++;
							break;
						}
						break;
					default:
						if (InRange(num, 55296, 57343))
						{
							ptr2 = EncodeSurrogate(pSrc, pSrcEnd, ptr2);
							pSrc += 2;
						}
						else if (num <= 127 || num >= 65534)
						{
							ptr2 = InvalidXmlChar(num, ptr2, entitize: true);
							pSrc++;
						}
						else
						{
							ptr2 = EncodeMultibyteUTF8(num, ptr2);
							pSrc++;
						}
						continue;
					}
					pSrc++;
				}
				bufPos = (int)(ptr2 - ptr);
				textPos = bufPos;
				contentPos = 0;
			}
		}

		protected unsafe void RawText(string s)
		{
			fixed (char* ptr = s)
			{
				RawText(ptr, ptr + s.Length);
			}
		}

		protected unsafe void RawText(char* pSrcBegin, char* pSrcEnd)
		{
			fixed (byte* ptr = bufBytes)
			{
				byte* ptr2 = ptr + bufPos;
				char* ptr3 = pSrcBegin;
				int num = 0;
				while (true)
				{
					byte* ptr4 = ptr2 + (pSrcEnd - ptr3);
					if (ptr4 > ptr + bufLen)
					{
						ptr4 = ptr + bufLen;
					}
					for (; ptr2 < ptr4; ptr2++)
					{
						if ((num = *ptr3) > 127)
						{
							break;
						}
						ptr3++;
						*ptr2 = (byte)num;
					}
					if (ptr3 >= pSrcEnd)
					{
						break;
					}
					if (ptr2 >= ptr4)
					{
						bufPos = (int)(ptr2 - ptr);
						FlushBuffer();
						ptr2 = ptr + 1;
					}
					else if (InRange(num, 55296, 57343))
					{
						ptr2 = EncodeSurrogate(ptr3, pSrcEnd, ptr2);
						ptr3 += 2;
					}
					else if (num <= 127 || num >= 65534)
					{
						ptr2 = InvalidXmlChar(num, ptr2, entitize: false);
						ptr3++;
					}
					else
					{
						ptr2 = EncodeMultibyteUTF8(num, ptr2);
						ptr3++;
					}
				}
				bufPos = (int)(ptr2 - ptr);
			}
		}

		protected unsafe void WriteRawWithCharChecking(char* pSrcBegin, char* pSrcEnd)
		{
			fixed (byte* ptr2 = bufBytes)
			{
				char* ptr = pSrcBegin;
				byte* ptr3 = ptr2 + bufPos;
				int num = 0;
				while (true)
				{
					byte* ptr4 = ptr3 + (pSrcEnd - ptr);
					if (ptr4 > ptr2 + bufLen)
					{
						ptr4 = ptr2 + bufLen;
					}
					while (ptr3 < ptr4 && (xmlCharType.charProperties[num = *ptr] & 0x40u) != 0 && num <= 127)
					{
						*ptr3 = (byte)num;
						ptr3++;
						ptr++;
					}
					if (ptr >= pSrcEnd)
					{
						break;
					}
					if (ptr3 >= ptr4)
					{
						bufPos = (int)(ptr3 - ptr2);
						FlushBuffer();
						ptr3 = ptr2 + 1;
						continue;
					}
					switch (num)
					{
					case 9:
					case 38:
					case 60:
					case 93:
						*ptr3 = (byte)num;
						ptr3++;
						break;
					case 13:
						if (newLineHandling == NewLineHandling.Replace)
						{
							if (ptr[1] == '\n')
							{
								ptr++;
							}
							ptr3 = WriteNewLine(ptr3);
						}
						else
						{
							*ptr3 = (byte)num;
							ptr3++;
						}
						break;
					case 10:
						if (newLineHandling == NewLineHandling.Replace)
						{
							ptr3 = WriteNewLine(ptr3);
							break;
						}
						*ptr3 = (byte)num;
						ptr3++;
						break;
					default:
						if (InRange(num, 55296, 57343))
						{
							ptr3 = EncodeSurrogate(ptr, pSrcEnd, ptr3);
							ptr += 2;
						}
						else if (num <= 127 || num >= 65534)
						{
							ptr3 = InvalidXmlChar(num, ptr3, entitize: false);
							ptr++;
						}
						else
						{
							ptr3 = EncodeMultibyteUTF8(num, ptr3);
							ptr++;
						}
						continue;
					}
					ptr++;
				}
				bufPos = (int)(ptr3 - ptr2);
			}
		}

		protected unsafe void WriteCommentOrPi(string text, int stopChar)
		{
			fixed (char* ptr = text)
			{
				fixed (byte* ptr4 = bufBytes)
				{
					char* ptr2 = ptr;
					char* ptr3 = ptr + text.Length;
					byte* ptr5 = ptr4 + bufPos;
					int num = 0;
					while (true)
					{
						byte* ptr6 = ptr5 + (ptr3 - ptr2);
						if (ptr6 > ptr4 + bufLen)
						{
							ptr6 = ptr4 + bufLen;
						}
						while (ptr5 < ptr6 && (xmlCharType.charProperties[num = *ptr2] & 0x40u) != 0 && num != stopChar && num <= 127)
						{
							*ptr5 = (byte)num;
							ptr5++;
							ptr2++;
						}
						if (ptr2 >= ptr3)
						{
							break;
						}
						if (ptr5 >= ptr6)
						{
							bufPos = (int)(ptr5 - ptr4);
							FlushBuffer();
							ptr5 = ptr4 + 1;
							continue;
						}
						switch (num)
						{
						case 45:
							*ptr5 = 45;
							ptr5++;
							if (num == stopChar && (ptr2 + 1 == ptr3 || ptr2[1] == '-'))
							{
								*ptr5 = 32;
								ptr5++;
							}
							break;
						case 63:
							*ptr5 = 63;
							ptr5++;
							if (num == stopChar && ptr2 + 1 < ptr3 && ptr2[1] == '>')
							{
								*ptr5 = 32;
								ptr5++;
							}
							break;
						case 93:
							*ptr5 = 93;
							ptr5++;
							break;
						case 13:
							if (newLineHandling == NewLineHandling.Replace)
							{
								if (ptr2[1] == '\n')
								{
									ptr2++;
								}
								ptr5 = WriteNewLine(ptr5);
							}
							else
							{
								*ptr5 = (byte)num;
								ptr5++;
							}
							break;
						case 10:
							if (newLineHandling == NewLineHandling.Replace)
							{
								ptr5 = WriteNewLine(ptr5);
								break;
							}
							*ptr5 = (byte)num;
							ptr5++;
							break;
						case 9:
						case 38:
						case 60:
							*ptr5 = (byte)num;
							ptr5++;
							break;
						default:
							if (InRange(num, 55296, 57343))
							{
								ptr5 = EncodeSurrogate(ptr2, ptr3, ptr5);
								ptr2 += 2;
							}
							else if (num <= 127 || num >= 65534)
							{
								ptr5 = InvalidXmlChar(num, ptr5, entitize: false);
								ptr2++;
							}
							else
							{
								ptr5 = EncodeMultibyteUTF8(num, ptr5);
								ptr2++;
							}
							continue;
						}
						ptr2++;
					}
					bufPos = (int)(ptr5 - ptr4);
				}
			}
		}

		protected unsafe void WriteCDataSection(string text)
		{
			fixed (char* ptr = text)
			{
				fixed (byte* ptr4 = bufBytes)
				{
					char* ptr2 = ptr;
					char* ptr3 = ptr + text.Length;
					byte* ptr5 = ptr4 + bufPos;
					int num = 0;
					while (true)
					{
						byte* ptr6 = ptr5 + (ptr3 - ptr2);
						if (ptr6 > ptr4 + bufLen)
						{
							ptr6 = ptr4 + bufLen;
						}
						while (ptr5 < ptr6 && (xmlCharType.charProperties[num = *ptr2] & 0x80u) != 0 && num != 93 && num <= 127)
						{
							*ptr5 = (byte)num;
							ptr5++;
							ptr2++;
						}
						if (ptr2 >= ptr3)
						{
							break;
						}
						if (ptr5 >= ptr6)
						{
							bufPos = (int)(ptr5 - ptr4);
							FlushBuffer();
							ptr5 = ptr4 + 1;
							continue;
						}
						switch (num)
						{
						case 62:
							if (hadDoubleBracket && ptr5[-1] == 93)
							{
								ptr5 = RawEndCData(ptr5);
								ptr5 = RawStartCData(ptr5);
							}
							*ptr5 = 62;
							ptr5++;
							break;
						case 93:
							if (ptr5[-1] == 93)
							{
								hadDoubleBracket = true;
							}
							else
							{
								hadDoubleBracket = false;
							}
							*ptr5 = 93;
							ptr5++;
							break;
						case 13:
							if (newLineHandling == NewLineHandling.Replace)
							{
								if (ptr2[1] == '\n')
								{
									ptr2++;
								}
								ptr5 = WriteNewLine(ptr5);
							}
							else
							{
								*ptr5 = (byte)num;
								ptr5++;
							}
							break;
						case 10:
							if (newLineHandling == NewLineHandling.Replace)
							{
								ptr5 = WriteNewLine(ptr5);
								break;
							}
							*ptr5 = (byte)num;
							ptr5++;
							break;
						case 9:
						case 34:
						case 38:
						case 39:
						case 60:
							*ptr5 = (byte)num;
							ptr5++;
							break;
						default:
							if (InRange(num, 55296, 57343))
							{
								ptr5 = EncodeSurrogate(ptr2, ptr3, ptr5);
								ptr2 += 2;
							}
							else if (num <= 127 || num >= 65534)
							{
								ptr5 = InvalidXmlChar(num, ptr5, entitize: false);
								ptr2++;
							}
							else
							{
								ptr5 = EncodeMultibyteUTF8(num, ptr5);
								ptr2++;
							}
							continue;
						}
						ptr2++;
					}
					bufPos = (int)(ptr5 - ptr4);
				}
			}
		}

		private static bool IsSurrogateByte(byte b)
		{
			return (b & 0xF8) == 240;
		}

		private unsafe static byte* EncodeSurrogate(char* pSrc, char* pSrcEnd, byte* pDst)
		{
			int num = *pSrc;
			if (num <= 56319)
			{
				if (pSrc + 1 < pSrcEnd)
				{
					int num2 = pSrc[1];
					if (num2 >= 56320)
					{
						num = num2 + (num << 10) + -56613888;
						*pDst = (byte)(0xF0u | (uint)(num >> 18));
						pDst[1] = (byte)(0x80u | ((uint)(num >> 12) & 0x3Fu));
						pDst[2] = (byte)(0x80u | ((uint)(num >> 6) & 0x3Fu));
						pDst[3] = (byte)(0x80u | ((uint)num & 0x3Fu));
						pDst += 4;
						return pDst;
					}
					throw XmlConvert.CreateInvalidSurrogatePairException((char)num2, (char)num);
				}
				throw new ArgumentException(Res.GetString("Xml_InvalidSurrogateMissingLowChar"));
			}
			throw XmlConvert.CreateInvalidHighSurrogateCharException((char)num);
		}

		private unsafe byte* InvalidXmlChar(int ch, byte* pDst, bool entitize)
		{
			if (checkCharacters)
			{
				throw XmlConvert.CreateInvalidCharException((char)ch);
			}
			if (entitize)
			{
				return CharEntity(pDst, (char)ch);
			}
			if (ch < 128)
			{
				*pDst = (byte)ch;
				pDst++;
			}
			else
			{
				pDst = EncodeMultibyteUTF8(ch, pDst);
			}
			return pDst;
		}

		internal unsafe void EncodeChar(ref char* pSrc, char* pSrcEnd, ref byte* pDst)
		{
			int num = *pSrc;
			if (InRange(num, 55296, 57343))
			{
				pDst = EncodeSurrogate(pSrc, pSrcEnd, pDst);
				pSrc += 2;
			}
			else if (num <= 127 || num >= 65534)
			{
				pDst = InvalidXmlChar(num, pDst, entitize: false);
				pSrc++;
			}
			else
			{
				pDst = EncodeMultibyteUTF8(num, pDst);
				pSrc++;
			}
		}

		internal unsafe static byte* EncodeMultibyteUTF8(int ch, byte* pDst)
		{
			if (ch < 2048)
			{
				*pDst = (byte)(0xFFFFFFC0u | (uint)(ch >> 6));
			}
			else
			{
				*pDst = (byte)(0xFFFFFFE0u | (uint)(ch >> 12));
				pDst++;
				*pDst = (byte)(0xFFFFFF80u | ((uint)(ch >> 6) & 0x3Fu));
			}
			pDst++;
			*pDst = (byte)(0x80u | ((uint)ch & 0x3Fu));
			return pDst + 1;
		}

		internal unsafe static void CharToUTF8(ref char* pSrc, char* pSrcEnd, ref byte* pDst)
		{
			int num = *pSrc;
			if (num <= 127)
			{
				*pDst = (byte)num;
				pDst++;
				pSrc++;
			}
			else if (num >= 55296 && num <= 57343)
			{
				pDst = EncodeSurrogate(pSrc, pSrcEnd, pDst);
				pSrc += 2;
			}
			else
			{
				pDst = EncodeMultibyteUTF8(num, pDst);
				pSrc++;
			}
		}

		protected unsafe byte* WriteNewLine(byte* pDst)
		{
			fixed (byte* ptr = bufBytes)
			{
				bufPos = (int)(pDst - ptr);
				RawText(newLineChars);
				return ptr + bufPos;
			}
		}

		protected unsafe static byte* LtEntity(byte* pDst)
		{
			*pDst = 38;
			pDst[1] = 108;
			pDst[2] = 116;
			pDst[3] = 59;
			return pDst + 4;
		}

		protected unsafe static byte* GtEntity(byte* pDst)
		{
			*pDst = 38;
			pDst[1] = 103;
			pDst[2] = 116;
			pDst[3] = 59;
			return pDst + 4;
		}

		protected unsafe static byte* AmpEntity(byte* pDst)
		{
			*pDst = 38;
			pDst[1] = 97;
			pDst[2] = 109;
			pDst[3] = 112;
			pDst[4] = 59;
			return pDst + 5;
		}

		protected unsafe static byte* QuoteEntity(byte* pDst)
		{
			*pDst = 38;
			pDst[1] = 113;
			pDst[2] = 117;
			pDst[3] = 111;
			pDst[4] = 116;
			pDst[5] = 59;
			return pDst + 6;
		}

		protected unsafe static byte* TabEntity(byte* pDst)
		{
			*pDst = 38;
			pDst[1] = 35;
			pDst[2] = 120;
			pDst[3] = 57;
			pDst[4] = 59;
			return pDst + 5;
		}

		protected unsafe static byte* LineFeedEntity(byte* pDst)
		{
			*pDst = 38;
			pDst[1] = 35;
			pDst[2] = 120;
			pDst[3] = 65;
			pDst[4] = 59;
			return pDst + 5;
		}

		protected unsafe static byte* CarriageReturnEntity(byte* pDst)
		{
			*pDst = 38;
			pDst[1] = 35;
			pDst[2] = 120;
			pDst[3] = 68;
			pDst[4] = 59;
			return pDst + 5;
		}

		private unsafe static byte* CharEntity(byte* pDst, char ch)
		{
			int num = ch;
			string text = num.ToString("X", NumberFormatInfo.InvariantInfo);
			*pDst = 38;
			pDst[1] = 35;
			pDst[2] = 120;
			pDst += 3;
			fixed (char* ptr = text)
			{
				char* ptr2 = ptr;
				byte b;
				do
				{
					byte* intPtr = pDst++;
					char* intPtr2 = ptr2;
					ptr2 = intPtr2 + 1;
					*intPtr = (b = (byte)(*intPtr2));
				}
				while (b != 0);
			}
			pDst[-1] = 59;
			return pDst;
		}

		protected unsafe static byte* RawStartCData(byte* pDst)
		{
			*pDst = 60;
			pDst[1] = 33;
			pDst[2] = 91;
			pDst[3] = 67;
			pDst[4] = 68;
			pDst[5] = 65;
			pDst[6] = 84;
			pDst[7] = 65;
			pDst[8] = 91;
			return pDst + 9;
		}

		protected unsafe static byte* RawEndCData(byte* pDst)
		{
			*pDst = 93;
			pDst[1] = 93;
			pDst[2] = 62;
			return pDst + 3;
		}

		private static bool InRange(int ch, int start, int end)
		{
			return (uint)(ch - start) <= (uint)(end - start);
		}

		protected void ValidateContentChars(string chars, string propertyName, bool allowOnlyWhitespace)
		{
			if (allowOnlyWhitespace)
			{
				if (!xmlCharType.IsOnlyWhitespace(chars))
				{
					throw new ArgumentException(Res.GetString("Xml_IndentCharsNotWhitespace", propertyName));
				}
				return;
			}
			string text = null;
			int num = 0;
			while (true)
			{
				if (num >= chars.Length)
				{
					return;
				}
				if (!xmlCharType.IsTextChar(chars[num]))
				{
					switch (chars[num])
					{
					case '&':
					case '<':
					case ']':
						text = Res.GetString("Xml_InvalidCharacter", XmlException.BuildCharExceptionStr(chars[num]));
						break;
					default:
						if (chars[num] >= '\ud800' && chars[num] <= '\udbff')
						{
							if (num + 1 < chars.Length && chars[num + 1] >= '\udc00' && chars[num + 1] <= '\udfff')
							{
								num++;
								goto IL_0152;
							}
							text = Res.GetString("Xml_InvalidSurrogateMissingLowChar");
						}
						else
						{
							if (chars[num] < '\udc00' || chars[num] > '\udfff')
							{
								goto IL_0152;
							}
							text = Res.GetString("Xml_InvalidSurrogateHighChar", ((uint)chars[num]).ToString("X", CultureInfo.InvariantCulture));
						}
						break;
					case '\t':
					case '\n':
					case '\r':
						goto IL_0152;
					}
					break;
				}
				goto IL_0152;
				IL_0152:
				num++;
			}
			throw new ArgumentException(Res.GetString("Xml_InvalidCharsInIndent", propertyName, text));
		}
	}
	internal class HtmlUtf8RawTextWriter : XmlUtf8RawTextWriter
	{
		private const int StackIncrement = 10;

		protected ByteStack elementScope;

		protected ElementProperties currentElementProperties;

		private AttributeProperties currentAttributeProperties;

		private bool endsWithAmpersand;

		private byte[] uriEscapingBuffer;

		private string mediaType;

		private bool doNotEscapeUriAttributes;

		protected static TernaryTreeReadOnly elementPropertySearch;

		protected static TernaryTreeReadOnly attributePropertySearch;

		public HtmlUtf8RawTextWriter(Stream stream, Encoding encoding, XmlWriterSettings settings, bool closeOutput)
			: base(stream, encoding, settings, closeOutput)
		{
			Init(settings);
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			RawText("<!DOCTYPE ");
			if (name == "HTML")
			{
				RawText("HTML");
			}
			else
			{
				RawText("html");
			}
			if (pubid != null)
			{
				RawText(" PUBLIC \"");
				RawText(pubid);
				if (sysid != null)
				{
					RawText("\" \"");
					RawText(sysid);
				}
				bufBytes[bufPos++] = 34;
			}
			else if (sysid != null)
			{
				RawText(" SYSTEM \"");
				RawText(sysid);
				bufBytes[bufPos++] = 34;
			}
			else
			{
				bufBytes[bufPos++] = 32;
			}
			if (subset != null)
			{
				bufBytes[bufPos++] = 91;
				RawText(subset);
				bufBytes[bufPos++] = 93;
			}
			bufBytes[bufPos++] = 62;
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			elementScope.Push((byte)currentElementProperties);
			if (ns.Length == 0)
			{
				currentElementProperties = (ElementProperties)elementPropertySearch.FindCaseInsensitiveString(localName);
				bufBytes[bufPos++] = 60;
				RawText(localName);
				attrEndPos = bufPos;
			}
			else
			{
				currentElementProperties = ElementProperties.HAS_NS;
				base.WriteStartElement(prefix, localName, ns);
			}
		}

		internal override void StartElementContent()
		{
			bufBytes[bufPos++] = 62;
			contentPos = bufPos;
			if ((currentElementProperties & ElementProperties.HEAD) != 0)
			{
				WriteMetaElement();
			}
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			if (ns.Length == 0)
			{
				if ((currentElementProperties & ElementProperties.EMPTY) == 0)
				{
					bufBytes[bufPos++] = 60;
					bufBytes[bufPos++] = 47;
					RawText(localName);
					bufBytes[bufPos++] = 62;
				}
			}
			else
			{
				base.WriteEndElement(prefix, localName, ns);
			}
			currentElementProperties = (ElementProperties)elementScope.Pop();
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			if (ns.Length == 0)
			{
				if ((currentElementProperties & ElementProperties.EMPTY) == 0)
				{
					bufBytes[bufPos++] = 60;
					bufBytes[bufPos++] = 47;
					RawText(localName);
					bufBytes[bufPos++] = 62;
				}
			}
			else
			{
				base.WriteFullEndElement(prefix, localName, ns);
			}
			currentElementProperties = (ElementProperties)elementScope.Pop();
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (ns.Length == 0)
			{
				if (attrEndPos == bufPos)
				{
					bufBytes[bufPos++] = 32;
				}
				RawText(localName);
				if ((currentElementProperties & (ElementProperties)7u) != 0)
				{
					currentAttributeProperties = (AttributeProperties)((uint)attributePropertySearch.FindCaseInsensitiveString(localName) & (uint)currentElementProperties);
					if ((currentAttributeProperties & AttributeProperties.BOOLEAN) != 0)
					{
						inAttributeValue = true;
						return;
					}
				}
				else
				{
					currentAttributeProperties = AttributeProperties.DEFAULT;
				}
				bufBytes[bufPos++] = 61;
				bufBytes[bufPos++] = 34;
			}
			else
			{
				base.WriteStartAttribute(prefix, localName, ns);
				currentAttributeProperties = AttributeProperties.DEFAULT;
			}
			inAttributeValue = true;
		}

		public override void WriteEndAttribute()
		{
			if ((currentAttributeProperties & AttributeProperties.BOOLEAN) != 0)
			{
				attrEndPos = bufPos;
			}
			else
			{
				if (endsWithAmpersand)
				{
					OutputRestAmps();
					endsWithAmpersand = false;
				}
				bufBytes[bufPos++] = 34;
			}
			inAttributeValue = false;
			attrEndPos = bufPos;
		}

		public override void WriteProcessingInstruction(string target, string text)
		{
			bufBytes[bufPos++] = 60;
			bufBytes[bufPos++] = 63;
			RawText(target);
			bufBytes[bufPos++] = 32;
			WriteCommentOrPi(text, 63);
			bufBytes[bufPos++] = 62;
			if (bufPos > bufLen)
			{
				FlushBuffer();
			}
		}

		public unsafe override void WriteString(string text)
		{
			fixed (char* ptr = text)
			{
				char* pSrcEnd = ptr + text.Length;
				if (inAttributeValue)
				{
					WriteHtmlAttributeTextBlock(ptr, pSrcEnd);
				}
				else
				{
					WriteHtmlElementTextBlock(ptr, pSrcEnd);
				}
			}
		}

		public override void WriteEntityRef(string name)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteCharEntity(char ch)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public unsafe override void WriteChars(char[] buffer, int index, int count)
		{
			fixed (char* ptr = &buffer[index])
			{
				if (inAttributeValue)
				{
					WriteAttributeTextBlock(ptr, ptr + count);
				}
				else
				{
					WriteElementTextBlock(ptr, ptr + count);
				}
			}
		}

		private void Init(XmlWriterSettings settings)
		{
			if (elementPropertySearch == null)
			{
				attributePropertySearch = new TernaryTreeReadOnly(HtmlTernaryTree.htmlAttributes);
				elementPropertySearch = new TernaryTreeReadOnly(HtmlTernaryTree.htmlElements);
			}
			elementScope = new ByteStack(10);
			uriEscapingBuffer = new byte[5];
			currentElementProperties = ElementProperties.DEFAULT;
			mediaType = settings.MediaType;
			doNotEscapeUriAttributes = settings.DoNotEscapeUriAttributes;
		}

		protected void WriteMetaElement()
		{
			RawText("<META http-equiv=\"Content-Type\"");
			if (mediaType == null)
			{
				mediaType = "text/html";
			}
			RawText(" content=\"");
			RawText(mediaType);
			RawText("; charset=");
			RawText(encoding.WebName);
			RawText("\">");
		}

		protected unsafe void WriteHtmlElementTextBlock(char* pSrc, char* pSrcEnd)
		{
			if ((currentElementProperties & ElementProperties.NO_ENTITIES) != 0)
			{
				RawText(pSrc, pSrcEnd);
			}
			else
			{
				WriteElementTextBlock(pSrc, pSrcEnd);
			}
		}

		protected unsafe void WriteHtmlAttributeTextBlock(char* pSrc, char* pSrcEnd)
		{
			if ((currentAttributeProperties & (AttributeProperties)7u) != 0)
			{
				if ((currentAttributeProperties & AttributeProperties.BOOLEAN) == 0)
				{
					if ((currentAttributeProperties & (AttributeProperties)5u) != 0 && !doNotEscapeUriAttributes)
					{
						WriteUriAttributeText(pSrc, pSrcEnd);
					}
					else
					{
						WriteHtmlAttributeText(pSrc, pSrcEnd);
					}
				}
			}
			else if ((currentElementProperties & ElementProperties.HAS_NS) != 0)
			{
				WriteAttributeTextBlock(pSrc, pSrcEnd);
			}
			else
			{
				WriteHtmlAttributeText(pSrc, pSrcEnd);
			}
		}

		private unsafe void WriteHtmlAttributeText(char* pSrc, char* pSrcEnd)
		{
			if (endsWithAmpersand)
			{
				if (pSrcEnd - pSrc > 0 && *pSrc != '{')
				{
					OutputRestAmps();
				}
				endsWithAmpersand = false;
			}
			fixed (byte* ptr = bufBytes)
			{
				byte* pDst = ptr + bufPos;
				char c = '\0';
				while (true)
				{
					byte* ptr2 = pDst + (pSrcEnd - pSrc);
					if (ptr2 > ptr + bufLen)
					{
						ptr2 = ptr + bufLen;
					}
					while (pDst < ptr2 && (xmlCharType.charProperties[(int)(c = *pSrc)] & 0x80u) != 0 && c <= '\u007f')
					{
						*(pDst++) = (byte)c;
						pSrc++;
					}
					if (pSrc >= pSrcEnd)
					{
						break;
					}
					if (pDst >= ptr2)
					{
						bufPos = (int)(pDst - ptr);
						FlushBuffer();
						pDst = ptr + 1;
						continue;
					}
					switch (c)
					{
					case '&':
						if (pSrc + 1 == pSrcEnd)
						{
							endsWithAmpersand = true;
						}
						else if (pSrc[1] != '{')
						{
							pDst = XmlUtf8RawTextWriter.AmpEntity(pDst);
							break;
						}
						*(pDst++) = (byte)c;
						break;
					case '"':
						pDst = XmlUtf8RawTextWriter.QuoteEntity(pDst);
						break;
					case '\t':
					case '\'':
					case '<':
					case '>':
						*(pDst++) = (byte)c;
						break;
					case '\r':
						pDst = XmlUtf8RawTextWriter.CarriageReturnEntity(pDst);
						break;
					case '\n':
						pDst = XmlUtf8RawTextWriter.LineFeedEntity(pDst);
						break;
					default:
						EncodeChar(ref pSrc, pSrcEnd, ref pDst);
						continue;
					}
					pSrc++;
				}
				bufPos = (int)(pDst - ptr);
			}
		}

		private unsafe void WriteUriAttributeText(char* pSrc, char* pSrcEnd)
		{
			if (endsWithAmpersand)
			{
				if (pSrcEnd - pSrc > 0 && *pSrc != '{')
				{
					OutputRestAmps();
				}
				endsWithAmpersand = false;
			}
			fixed (byte* ptr = bufBytes)
			{
				byte* ptr2 = ptr + bufPos;
				char c = '\0';
				while (true)
				{
					byte* ptr3 = ptr2 + (pSrcEnd - pSrc);
					if (ptr3 > ptr + bufLen)
					{
						ptr3 = ptr + bufLen;
					}
					while (ptr2 < ptr3 && (xmlCharType.charProperties[(int)(c = *pSrc)] & 0x80u) != 0 && c < '\u0080')
					{
						*(ptr2++) = (byte)c;
						pSrc++;
					}
					if (pSrc >= pSrcEnd)
					{
						break;
					}
					if (ptr2 >= ptr3)
					{
						bufPos = (int)(ptr2 - ptr);
						FlushBuffer();
						ptr2 = ptr + 1;
						continue;
					}
					switch (c)
					{
					case '&':
						if (pSrc + 1 == pSrcEnd)
						{
							endsWithAmpersand = true;
						}
						else if (pSrc[1] != '{')
						{
							ptr2 = XmlUtf8RawTextWriter.AmpEntity(ptr2);
							break;
						}
						*(ptr2++) = (byte)c;
						break;
					case '"':
						ptr2 = XmlUtf8RawTextWriter.QuoteEntity(ptr2);
						break;
					case '\t':
					case '\'':
					case '<':
					case '>':
						*(ptr2++) = (byte)c;
						break;
					case '\r':
						ptr2 = XmlUtf8RawTextWriter.CarriageReturnEntity(ptr2);
						break;
					case '\n':
						ptr2 = XmlUtf8RawTextWriter.LineFeedEntity(ptr2);
						break;
					default:
						fixed (byte* ptr4 = uriEscapingBuffer)
						{
							byte* ptr5 = ptr4;
							byte* pDst = ptr5;
							XmlUtf8RawTextWriter.CharToUTF8(ref pSrc, pSrcEnd, ref pDst);
							for (; ptr5 < pDst; ptr5++)
							{
								*(ptr2++) = 37;
								*(ptr2++) = (byte)"0123456789ABCDEF"[*ptr5 >> 4];
								*(ptr2++) = (byte)"0123456789ABCDEF"[*ptr5 & 0xF];
							}
						}
						continue;
					}
					pSrc++;
				}
				bufPos = (int)(ptr2 - ptr);
			}
		}

		private void OutputRestAmps()
		{
			bufBytes[bufPos++] = 97;
			bufBytes[bufPos++] = 109;
			bufBytes[bufPos++] = 112;
			bufBytes[bufPos++] = 59;
		}
	}
	internal class HtmlUtf8RawTextWriterIndent : HtmlUtf8RawTextWriter
	{
		private int indentLevel;

		private int endBlockPos;

		private string indentChars;

		private bool newLineOnAttributes;

		public HtmlUtf8RawTextWriterIndent(Stream stream, Encoding encoding, XmlWriterSettings settings, bool closeOutput)
			: base(stream, encoding, settings, closeOutput)
		{
			Init(settings);
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			base.WriteDocType(name, pubid, sysid, subset);
			endBlockPos = bufPos;
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			elementScope.Push((byte)currentElementProperties);
			if (ns.Length == 0)
			{
				currentElementProperties = (ElementProperties)HtmlUtf8RawTextWriter.elementPropertySearch.FindCaseInsensitiveString(localName);
				if (endBlockPos == bufPos && (currentElementProperties & ElementProperties.BLOCK_WS) != 0)
				{
					WriteIndent();
				}
				indentLevel++;
				bufBytes[bufPos++] = 60;
			}
			else
			{
				currentElementProperties = (ElementProperties)192u;
				if (endBlockPos == bufPos)
				{
					WriteIndent();
				}
				indentLevel++;
				bufBytes[bufPos++] = 60;
				if (prefix.Length != 0)
				{
					RawText(prefix);
					bufBytes[bufPos++] = 58;
				}
			}
			RawText(localName);
			attrEndPos = bufPos;
		}

		internal override void StartElementContent()
		{
			bufBytes[bufPos++] = 62;
			contentPos = bufPos;
			if ((currentElementProperties & ElementProperties.HEAD) != 0)
			{
				WriteIndent();
				WriteMetaElement();
				endBlockPos = bufPos;
			}
			else if ((currentElementProperties & ElementProperties.BLOCK_WS) != 0)
			{
				endBlockPos = bufPos;
			}
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			indentLevel--;
			bool flag = (currentElementProperties & ElementProperties.BLOCK_WS) != 0;
			if (flag && endBlockPos == bufPos && contentPos != bufPos)
			{
				WriteIndent();
			}
			base.WriteEndElement(prefix, localName, ns);
			contentPos = 0;
			if (flag)
			{
				endBlockPos = bufPos;
			}
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (newLineOnAttributes)
			{
				RawText(newLineChars);
				indentLevel++;
				WriteIndent();
				indentLevel--;
			}
			base.WriteStartAttribute(prefix, localName, ns);
		}

		protected override void FlushBuffer()
		{
			endBlockPos = ((endBlockPos == bufPos) ? 1 : 0);
			base.FlushBuffer();
		}

		private void Init(XmlWriterSettings settings)
		{
			indentLevel = 0;
			indentChars = settings.IndentChars;
			newLineOnAttributes = settings.NewLineOnAttributes;
		}

		private void WriteIndent()
		{
			RawText(newLineChars);
			for (int num = indentLevel; num > 0; num--)
			{
				RawText(indentChars);
			}
		}
	}
	internal class IncrementalReadDummyDecoder : IncrementalReadDecoder
	{
		internal override int DecodedCount => -1;

		internal override bool IsFull => false;

		internal override void SetNextOutputBuffer(Array array, int offset, int len)
		{
		}

		internal override int Decode(char[] chars, int startPos, int len)
		{
			return len;
		}

		internal override int Decode(string str, int startPos, int len)
		{
			return len;
		}

		internal override void Reset()
		{
		}
	}
	internal class IncrementalReadCharsDecoder : IncrementalReadDecoder
	{
		private char[] buffer;

		private int startIndex;

		private int curIndex;

		private int endIndex;

		internal override int DecodedCount => curIndex - startIndex;

		internal override bool IsFull => curIndex == endIndex;

		internal IncrementalReadCharsDecoder()
		{
		}

		internal override int Decode(char[] chars, int startPos, int len)
		{
			int num = endIndex - curIndex;
			if (num > len)
			{
				num = len;
			}
			Buffer.BlockCopy(chars, startPos * 2, buffer, curIndex * 2, num * 2);
			curIndex += num;
			return num;
		}

		internal override int Decode(string str, int startPos, int len)
		{
			int num = endIndex - curIndex;
			if (num > len)
			{
				num = len;
			}
			str.CopyTo(startPos, buffer, curIndex, num);
			curIndex += num;
			return num;
		}

		internal override void Reset()
		{
		}

		internal override void SetNextOutputBuffer(Array buffer, int index, int count)
		{
			this.buffer = (char[])buffer;
			startIndex = index;
			curIndex = index;
			endIndex = index + count;
		}
	}
	public enum NewLineHandling
	{
		Replace,
		Entitize,
		None
	}
	internal delegate void OnRemoveWriter(XmlRawWriter writer);
	internal interface IRemovableWriter
	{
		OnRemoveWriter OnRemoveWriterEvent { get; set; }
	}
	internal class QueryOutputWriter : XmlRawWriter
	{
		private XmlRawWriter wrapped;

		private bool inCDataSection;

		private Dictionary<XmlQualifiedName, int> lookupCDataElems;

		private BitStack bitsCData;

		private XmlQualifiedName qnameCData;

		private bool outputDocType;

		private bool checkWellFormedDoc;

		private bool hasDocElem;

		private bool inAttr;

		private string systemId;

		private string publicId;

		private int depth;

		internal override IXmlNamespaceResolver NamespaceResolver
		{
			get
			{
				return resolver;
			}
			set
			{
				resolver = value;
				wrapped.NamespaceResolver = value;
			}
		}

		public override XmlWriterSettings Settings
		{
			get
			{
				XmlWriterSettings settings = wrapped.Settings;
				settings.ReadOnly = false;
				settings.DocTypeSystem = systemId;
				settings.DocTypePublic = publicId;
				settings.ReadOnly = true;
				return settings;
			}
		}

		public QueryOutputWriter(XmlRawWriter writer, XmlWriterSettings settings)
		{
			wrapped = writer;
			systemId = settings.DocTypeSystem;
			publicId = settings.DocTypePublic;
			if (settings.OutputMethod == XmlOutputMethod.Xml)
			{
				if (systemId != null)
				{
					outputDocType = true;
					checkWellFormedDoc = true;
				}
				if (settings.AutoXmlDeclaration && settings.Standalone == XmlStandalone.Yes)
				{
					checkWellFormedDoc = true;
				}
				if (settings.CDataSectionElements.Count <= 0)
				{
					return;
				}
				bitsCData = new BitStack();
				lookupCDataElems = new Dictionary<XmlQualifiedName, int>();
				qnameCData = new XmlQualifiedName();
				foreach (XmlQualifiedName cDataSectionElement in settings.CDataSectionElements)
				{
					lookupCDataElems[cDataSectionElement] = 0;
				}
				bitsCData.PushBit(bit: false);
			}
			else if (settings.OutputMethod == XmlOutputMethod.Html && (systemId != null || publicId != null))
			{
				outputDocType = true;
			}
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
			wrapped.WriteXmlDeclaration(standalone);
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
			wrapped.WriteXmlDeclaration(xmldecl);
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			if (publicId == null && systemId == null)
			{
				wrapped.WriteDocType(name, pubid, sysid, subset);
			}
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			EndCDataSection();
			if (checkWellFormedDoc)
			{
				if (depth == 0 && hasDocElem)
				{
					throw new XmlException("Xml_NoMultipleRoots", string.Empty);
				}
				depth++;
				hasDocElem = true;
			}
			if (outputDocType)
			{
				wrapped.WriteDocType((prefix.Length != 0) ? (prefix + ":" + localName) : localName, publicId, systemId, null);
				outputDocType = false;
			}
			wrapped.WriteStartElement(prefix, localName, ns);
			if (lookupCDataElems != null)
			{
				qnameCData.Init(localName, ns);
				bitsCData.PushBit(lookupCDataElems.ContainsKey(qnameCData));
			}
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			EndCDataSection();
			wrapped.WriteEndElement(prefix, localName, ns);
			if (checkWellFormedDoc)
			{
				depth--;
			}
			if (lookupCDataElems != null)
			{
				bitsCData.PopBit();
			}
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			EndCDataSection();
			wrapped.WriteFullEndElement(prefix, localName, ns);
			if (checkWellFormedDoc)
			{
				depth--;
			}
			if (lookupCDataElems != null)
			{
				bitsCData.PopBit();
			}
		}

		internal override void StartElementContent()
		{
			wrapped.StartElementContent();
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			inAttr = true;
			wrapped.WriteStartAttribute(prefix, localName, ns);
		}

		public override void WriteEndAttribute()
		{
			inAttr = false;
			wrapped.WriteEndAttribute();
		}

		internal override void WriteNamespaceDeclaration(string prefix, string ns)
		{
			wrapped.WriteNamespaceDeclaration(prefix, ns);
		}

		public override void WriteCData(string text)
		{
			wrapped.WriteCData(text);
		}

		public override void WriteComment(string text)
		{
			EndCDataSection();
			wrapped.WriteComment(text);
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			EndCDataSection();
			wrapped.WriteProcessingInstruction(name, text);
		}

		public override void WriteWhitespace(string ws)
		{
			if (!inAttr && (inCDataSection || StartCDataSection()))
			{
				wrapped.WriteCData(ws);
			}
			else
			{
				wrapped.WriteWhitespace(ws);
			}
		}

		public override void WriteString(string text)
		{
			if (!inAttr && (inCDataSection || StartCDataSection()))
			{
				wrapped.WriteCData(text);
			}
			else
			{
				wrapped.WriteString(text);
			}
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			if (!inAttr && (inCDataSection || StartCDataSection()))
			{
				wrapped.WriteCData(new string(buffer, index, count));
			}
			else
			{
				wrapped.WriteChars(buffer, index, count);
			}
		}

		public override void WriteEntityRef(string name)
		{
			EndCDataSection();
			wrapped.WriteEntityRef(name);
		}

		public override void WriteCharEntity(char ch)
		{
			EndCDataSection();
			wrapped.WriteCharEntity(ch);
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			EndCDataSection();
			wrapped.WriteSurrogateCharEntity(lowChar, highChar);
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			if (!inAttr && (inCDataSection || StartCDataSection()))
			{
				wrapped.WriteCData(new string(buffer, index, count));
			}
			else
			{
				wrapped.WriteRaw(buffer, index, count);
			}
		}

		public override void WriteRaw(string data)
		{
			if (!inAttr && (inCDataSection || StartCDataSection()))
			{
				wrapped.WriteCData(data);
			}
			else
			{
				wrapped.WriteRaw(data);
			}
		}

		public override void Close()
		{
			wrapped.Close();
			if (checkWellFormedDoc && !hasDocElem)
			{
				throw new XmlException("Xml_NoRoot", string.Empty);
			}
		}

		public override void Flush()
		{
			wrapped.Flush();
		}

		private bool StartCDataSection()
		{
			if (lookupCDataElems != null && bitsCData.PeekBit())
			{
				inCDataSection = true;
				return true;
			}
			return false;
		}

		private void EndCDataSection()
		{
			inCDataSection = false;
		}
	}
	internal class ReadContentAsBinaryHelper
	{
		private enum State
		{
			None,
			InReadContent,
			InReadElementContent
		}

		private const int ChunkSize = 256;

		private XmlReader reader;

		private State state;

		private int valueOffset;

		private bool isEnd;

		private bool canReadValueChunk;

		private char[] valueChunk;

		private int valueChunkLength;

		private IncrementalReadDecoder decoder;

		private Base64Decoder base64Decoder;

		private BinHexDecoder binHexDecoder;

		internal ReadContentAsBinaryHelper(XmlReader reader)
		{
			this.reader = reader;
			canReadValueChunk = reader.CanReadValueChunk;
			if (canReadValueChunk)
			{
				valueChunk = new char[256];
			}
		}

		internal static ReadContentAsBinaryHelper CreateOrReset(ReadContentAsBinaryHelper helper, XmlReader reader)
		{
			if (helper == null)
			{
				return new ReadContentAsBinaryHelper(reader);
			}
			helper.Reset();
			return helper;
		}

		internal int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (buffer.Length - index < count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			switch (state)
			{
			case State.None:
				if (!reader.CanReadContentAs())
				{
					throw reader.CreateReadContentAsException("ReadContentAsBase64");
				}
				if (!Init())
				{
					return 0;
				}
				break;
			case State.InReadContent:
				if (decoder == base64Decoder)
				{
					return ReadContentAsBinary(buffer, index, count);
				}
				break;
			case State.InReadElementContent:
				throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
			default:
				return 0;
			}
			InitBase64Decoder();
			return ReadContentAsBinary(buffer, index, count);
		}

		internal int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (buffer.Length - index < count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			switch (state)
			{
			case State.None:
				if (!reader.CanReadContentAs())
				{
					throw reader.CreateReadContentAsException("ReadContentAsBinHex");
				}
				if (!Init())
				{
					return 0;
				}
				break;
			case State.InReadContent:
				if (decoder == binHexDecoder)
				{
					return ReadContentAsBinary(buffer, index, count);
				}
				break;
			case State.InReadElementContent:
				throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
			default:
				return 0;
			}
			InitBinHexDecoder();
			return ReadContentAsBinary(buffer, index, count);
		}

		internal int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (buffer.Length - index < count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			switch (state)
			{
			case State.None:
				if (reader.NodeType != XmlNodeType.Element)
				{
					throw reader.CreateReadElementContentAsException("ReadElementContentAsBase64");
				}
				if (!InitOnElement())
				{
					return 0;
				}
				break;
			case State.InReadContent:
				throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
			case State.InReadElementContent:
				if (decoder == base64Decoder)
				{
					return ReadElementContentAsBinary(buffer, index, count);
				}
				break;
			default:
				return 0;
			}
			InitBase64Decoder();
			return ReadElementContentAsBinary(buffer, index, count);
		}

		internal int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (buffer.Length - index < count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			switch (state)
			{
			case State.None:
				if (reader.NodeType != XmlNodeType.Element)
				{
					throw reader.CreateReadElementContentAsException("ReadElementContentAsBinHex");
				}
				if (!InitOnElement())
				{
					return 0;
				}
				break;
			case State.InReadContent:
				throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
			case State.InReadElementContent:
				if (decoder == binHexDecoder)
				{
					return ReadElementContentAsBinary(buffer, index, count);
				}
				break;
			default:
				return 0;
			}
			InitBinHexDecoder();
			return ReadElementContentAsBinary(buffer, index, count);
		}

		internal void Finish()
		{
			if (state != 0)
			{
				while (MoveToNextContentNode(moveIfOnContentNode: true))
				{
				}
				if (state == State.InReadElementContent)
				{
					if (reader.NodeType != XmlNodeType.EndElement)
					{
						throw new XmlException("Xml_InvalidNodeType", reader.NodeType.ToString(), reader as IXmlLineInfo);
					}
					reader.Read();
				}
			}
			Reset();
		}

		internal void Reset()
		{
			state = State.None;
			isEnd = false;
			valueOffset = 0;
		}

		private bool Init()
		{
			if (!MoveToNextContentNode(moveIfOnContentNode: false))
			{
				return false;
			}
			state = State.InReadContent;
			isEnd = false;
			return true;
		}

		private bool InitOnElement()
		{
			bool isEmptyElement = reader.IsEmptyElement;
			reader.Read();
			if (isEmptyElement)
			{
				return false;
			}
			if (!MoveToNextContentNode(moveIfOnContentNode: false))
			{
				if (reader.NodeType != XmlNodeType.EndElement)
				{
					throw new XmlException("Xml_InvalidNodeType", reader.NodeType.ToString(), reader as IXmlLineInfo);
				}
				reader.Read();
				return false;
			}
			state = State.InReadElementContent;
			isEnd = false;
			return true;
		}

		private void InitBase64Decoder()
		{
			if (base64Decoder == null)
			{
				base64Decoder = new Base64Decoder();
			}
			else
			{
				base64Decoder.Reset();
			}
			decoder = base64Decoder;
		}

		private void InitBinHexDecoder()
		{
			if (binHexDecoder == null)
			{
				binHexDecoder = new BinHexDecoder();
			}
			else
			{
				binHexDecoder.Reset();
			}
			decoder = binHexDecoder;
		}

		private int ReadContentAsBinary(byte[] buffer, int index, int count)
		{
			if (isEnd)
			{
				Reset();
				return 0;
			}
			decoder.SetNextOutputBuffer(buffer, index, count);
			do
			{
				if (canReadValueChunk)
				{
					while (true)
					{
						if (valueOffset < valueChunkLength)
						{
							int num = decoder.Decode(valueChunk, valueOffset, valueChunkLength - valueOffset);
							valueOffset += num;
						}
						if (decoder.IsFull)
						{
							return decoder.DecodedCount;
						}
						if ((valueChunkLength = reader.ReadValueChunk(valueChunk, 0, 256)) == 0)
						{
							break;
						}
						valueOffset = 0;
					}
				}
				else
				{
					string value = reader.Value;
					int num2 = decoder.Decode(value, valueOffset, value.Length - valueOffset);
					valueOffset += num2;
					if (decoder.IsFull)
					{
						return decoder.DecodedCount;
					}
				}
				valueOffset = 0;
			}
			while (MoveToNextContentNode(moveIfOnContentNode: true));
			isEnd = true;
			return decoder.DecodedCount;
		}

		private int ReadElementContentAsBinary(byte[] buffer, int index, int count)
		{
			if (count == 0)
			{
				return 0;
			}
			int num = ReadContentAsBinary(buffer, index, count);
			if (num > 0)
			{
				return num;
			}
			if (reader.NodeType != XmlNodeType.EndElement)
			{
				throw new XmlException("Xml_InvalidNodeType", reader.NodeType.ToString(), reader as IXmlLineInfo);
			}
			reader.Read();
			state = State.None;
			return 0;
		}

		private bool MoveToNextContentNode(bool moveIfOnContentNode)
		{
			do
			{
				switch (reader.NodeType)
				{
				case XmlNodeType.Attribute:
					return !moveIfOnContentNode;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					if (!moveIfOnContentNode)
					{
						return true;
					}
					goto IL_0078;
				case XmlNodeType.EntityReference:
					if (!reader.CanResolveEntity)
					{
						break;
					}
					reader.ResolveEntity();
					goto IL_0078;
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.Comment:
				case XmlNodeType.EndEntity:
					goto IL_0078;
				}
				return false;
				IL_0078:
				moveIfOnContentNode = false;
			}
			while (reader.Read());
			return false;
		}
	}
	internal enum TernaryTreeByte
	{
		characterByte,
		leftTree,
		rightTree,
		data
	}
	internal enum ElementProperties : uint
	{
		DEFAULT = 0u,
		URI_PARENT = 1u,
		BOOL_PARENT = 2u,
		NAME_PARENT = 4u,
		EMPTY = 8u,
		NO_ENTITIES = 0x10u,
		HEAD = 0x20u,
		BLOCK_WS = 0x40u,
		HAS_NS = 0x80u
	}
	internal enum AttributeProperties : uint
	{
		DEFAULT = 0u,
		URI = 1u,
		BOOLEAN = 2u,
		NAME = 4u
	}
	internal class TernaryTreeReadOnly
	{
		private byte[] nodeBuffer;

		public TernaryTreeReadOnly(byte[] nodeBuffer)
		{
			this.nodeBuffer = nodeBuffer;
		}

		public byte FindCaseInsensitiveString(string stringToFind)
		{
			int num = 0;
			int num2 = 0;
			byte[] array = nodeBuffer;
			int num3 = stringToFind[num];
			if (num3 > 122)
			{
				return 0;
			}
			if (num3 >= 97)
			{
				num3 -= 32;
			}
			while (true)
			{
				int num4 = num2 * 4;
				int num5 = array[num4];
				if (num3 < num5)
				{
					if (array[num4 + 1] == 0)
					{
						break;
					}
					num2 += array[num4 + 1];
					continue;
				}
				if (num3 > num5)
				{
					if (array[num4 + 2] == 0)
					{
						break;
					}
					num2 += array[num4 + 2];
					continue;
				}
				if (num3 == 0)
				{
					return array[num4 + 3];
				}
				num2++;
				num++;
				if (num == stringToFind.Length)
				{
					num3 = 0;
					continue;
				}
				num3 = stringToFind[num];
				if (num3 > 122)
				{
					return 0;
				}
				if (num3 >= 97)
				{
					num3 -= 32;
				}
			}
			return 0;
		}
	}
	public enum ReadState
	{
		Initial,
		Interactive,
		Error,
		EndOfFile,
		Closed
	}
	internal class SecureStringHasher : IEqualityComparer<string>
	{
		private int hashCodeRandomizer;

		public SecureStringHasher()
		{
			hashCodeRandomizer = Environment.TickCount;
		}

		public SecureStringHasher(int hashCodeRandomizer)
		{
			this.hashCodeRandomizer = hashCodeRandomizer;
		}

		public int Compare(string x, string y)
		{
			return string.Compare(x, y, StringComparison.Ordinal);
		}

		public bool Equals(string x, string y)
		{
			return string.Equals(x, y, StringComparison.Ordinal);
		}

		public int GetHashCode(string key)
		{
			int num = hashCodeRandomizer;
			for (int i = 0; i < key.Length; i++)
			{
				num += (num << 7) ^ key[i];
			}
			num -= num >> 17;
			num -= num >> 11;
			return num - (num >> 5);
		}
	}
	internal class TextEncodedRawTextWriter : XmlEncodedRawTextWriter
	{
		public TextEncodedRawTextWriter(TextWriter writer, XmlWriterSettings settings)
			: base(writer, settings)
		{
		}

		public TextEncodedRawTextWriter(Stream stream, Encoding encoding, XmlWriterSettings settings, bool closeOutput)
			: base(stream, encoding, settings, closeOutput)
		{
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
		}

		internal override void StartElementContent()
		{
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			inAttributeValue = true;
		}

		public override void WriteEndAttribute()
		{
			inAttributeValue = false;
		}

		internal override void WriteNamespaceDeclaration(string prefix, string ns)
		{
		}

		public override void WriteCData(string text)
		{
			base.WriteRaw(text);
		}

		public override void WriteComment(string text)
		{
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
		}

		public override void WriteEntityRef(string name)
		{
		}

		public override void WriteCharEntity(char ch)
		{
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
		}

		public override void WriteWhitespace(string ws)
		{
			if (!inAttributeValue)
			{
				base.WriteRaw(ws);
			}
		}

		public override void WriteString(string textBlock)
		{
			if (!inAttributeValue)
			{
				base.WriteRaw(textBlock);
			}
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			if (!inAttributeValue)
			{
				base.WriteRaw(buffer, index, count);
			}
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			if (!inAttributeValue)
			{
				base.WriteRaw(buffer, index, count);
			}
		}

		public override void WriteRaw(string data)
		{
			if (!inAttributeValue)
			{
				base.WriteRaw(data);
			}
		}
	}
	internal class TextUtf8RawTextWriter : XmlUtf8RawTextWriter
	{
		public TextUtf8RawTextWriter(Stream stream, Encoding encoding, XmlWriterSettings settings, bool closeOutput)
			: base(stream, encoding, settings, closeOutput)
		{
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
		}

		internal override void StartElementContent()
		{
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			inAttributeValue = true;
		}

		public override void WriteEndAttribute()
		{
			inAttributeValue = false;
		}

		internal override void WriteNamespaceDeclaration(string prefix, string ns)
		{
		}

		public override void WriteCData(string text)
		{
			base.WriteRaw(text);
		}

		public override void WriteComment(string text)
		{
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
		}

		public override void WriteEntityRef(string name)
		{
		}

		public override void WriteCharEntity(char ch)
		{
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
		}

		public override void WriteWhitespace(string ws)
		{
			if (!inAttributeValue)
			{
				base.WriteRaw(ws);
			}
		}

		public override void WriteString(string textBlock)
		{
			if (!inAttributeValue)
			{
				base.WriteRaw(textBlock);
			}
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			if (!inAttributeValue)
			{
				base.WriteRaw(buffer, index, count);
			}
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			if (!inAttributeValue)
			{
				base.WriteRaw(buffer, index, count);
			}
		}

		public override void WriteRaw(string data)
		{
			if (!inAttributeValue)
			{
				base.WriteRaw(data);
			}
		}
	}
	internal class ValidatingReaderNodeData
	{
		private string localName;

		private string namespaceUri;

		private string prefix;

		private string nameWPrefix;

		private string rawValue;

		private string originalStringValue;

		private int depth;

		private AttributePSVIInfo attributePSVIInfo;

		private XmlNodeType nodeType;

		private int lineNo;

		private int linePos;

		public string LocalName
		{
			get
			{
				return localName;
			}
			set
			{
				localName = value;
			}
		}

		public string Namespace
		{
			get
			{
				return namespaceUri;
			}
			set
			{
				namespaceUri = value;
			}
		}

		public string Prefix
		{
			get
			{
				return prefix;
			}
			set
			{
				prefix = value;
			}
		}

		public int Depth
		{
			get
			{
				return depth;
			}
			set
			{
				depth = value;
			}
		}

		public string RawValue
		{
			get
			{
				return rawValue;
			}
			set
			{
				rawValue = value;
			}
		}

		public string OriginalStringValue
		{
			get
			{
				return originalStringValue;
			}
			set
			{
				originalStringValue = value;
			}
		}

		public XmlNodeType NodeType
		{
			get
			{
				return nodeType;
			}
			set
			{
				nodeType = value;
			}
		}

		public AttributePSVIInfo AttInfo
		{
			get
			{
				return attributePSVIInfo;
			}
			set
			{
				attributePSVIInfo = value;
			}
		}

		public int LineNumber => lineNo;

		public int LinePosition => linePos;

		public ValidatingReaderNodeData()
		{
			Clear(XmlNodeType.None);
		}

		public ValidatingReaderNodeData(XmlNodeType nodeType)
		{
			Clear(nodeType);
		}

		public string GetAtomizedNameWPrefix(XmlNameTable nameTable)
		{
			if (nameWPrefix == null)
			{
				if (prefix.Length == 0)
				{
					nameWPrefix = localName;
				}
				else
				{
					nameWPrefix = nameTable.Add(prefix + ":" + localName);
				}
			}
			return nameWPrefix;
		}

		internal void Clear(XmlNodeType nodeType)
		{
			this.nodeType = nodeType;
			localName = string.Empty;
			prefix = string.Empty;
			namespaceUri = string.Empty;
			rawValue = string.Empty;
			if (attributePSVIInfo != null)
			{
				attributePSVIInfo.Reset();
			}
			nameWPrefix = null;
			lineNo = 0;
			linePos = 0;
		}

		internal void ClearName()
		{
			localName = string.Empty;
			prefix = string.Empty;
			namespaceUri = string.Empty;
		}

		internal void SetLineInfo(int lineNo, int linePos)
		{
			this.lineNo = lineNo;
			this.linePos = linePos;
		}

		internal void SetLineInfo(IXmlLineInfo lineInfo)
		{
			if (lineInfo != null)
			{
				lineNo = lineInfo.LineNumber;
				linePos = lineInfo.LinePosition;
			}
		}

		internal void SetItemData(string localName, string prefix, string ns, string value)
		{
			this.localName = localName;
			this.prefix = prefix;
			namespaceUri = ns;
			rawValue = value;
		}

		internal void SetItemData(string localName, string prefix, string ns, int depth)
		{
			this.localName = localName;
			this.prefix = prefix;
			namespaceUri = ns;
			this.depth = depth;
			rawValue = string.Empty;
		}

		internal void SetItemData(string value)
		{
			SetItemData(value, value);
		}

		internal void SetItemData(string value, string originalStringValue)
		{
			rawValue = value;
			this.originalStringValue = originalStringValue;
		}
	}
	public enum ValidationType
	{
		None,
		[Obsolete("Validation type should be specified as DTD or Schema.")]
		Auto,
		DTD,
		[Obsolete("XDR Validation through XmlValidatingReader is obsoleted")]
		XDR,
		Schema
	}
	public enum WhitespaceHandling
	{
		All,
		Significant,
		None
	}
	internal class XmlAutoDetectWriter : XmlRawWriter, IRemovableWriter
	{
		private XmlRawWriter wrapped;

		private OnRemoveWriter onRemove;

		private XmlWriterSettings writerSettings;

		private XmlEventCache eventCache;

		private TextWriter textWriter;

		private Stream strm;

		public OnRemoveWriter OnRemoveWriterEvent
		{
			get
			{
				return onRemove;
			}
			set
			{
				onRemove = value;
			}
		}

		public override XmlWriterSettings Settings => writerSettings;

		internal override IXmlNamespaceResolver NamespaceResolver
		{
			get
			{
				return resolver;
			}
			set
			{
				resolver = value;
				if (wrapped == null)
				{
					eventCache.NamespaceResolver = value;
				}
				else
				{
					wrapped.NamespaceResolver = value;
				}
			}
		}

		private XmlAutoDetectWriter(XmlWriterSettings writerSettings, Encoding encoding)
		{
			this.writerSettings = writerSettings.Clone();
			this.writerSettings.Encoding = encoding;
			this.writerSettings.ReadOnly = true;
			eventCache = new XmlEventCache(string.Empty, hasRootNode: true);
		}

		public XmlAutoDetectWriter(TextWriter textWriter, XmlWriterSettings writerSettings)
			: this(writerSettings, textWriter.Encoding)
		{
			this.textWriter = textWriter;
		}

		public XmlAutoDetectWriter(Stream strm, Encoding encoding, XmlWriterSettings writerSettings)
			: this(writerSettings, encoding)
		{
			this.strm = strm;
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteDocType(name, pubid, sysid, subset);
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			if (wrapped == null)
			{
				if (ns.Length == 0 && IsHtmlTag(localName))
				{
					CreateWrappedWriter(XmlOutputMethod.Html);
				}
				else
				{
					CreateWrappedWriter(XmlOutputMethod.Xml);
				}
			}
			wrapped.WriteStartElement(prefix, localName, ns);
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteStartAttribute(prefix, localName, ns);
		}

		public override void WriteEndAttribute()
		{
			wrapped.WriteEndAttribute();
		}

		public override void WriteCData(string text)
		{
			if (TextBlockCreatesWriter(text))
			{
				wrapped.WriteCData(text);
			}
			else
			{
				eventCache.WriteCData(text);
			}
		}

		public override void WriteComment(string text)
		{
			if (wrapped == null)
			{
				eventCache.WriteComment(text);
			}
			else
			{
				wrapped.WriteComment(text);
			}
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			if (wrapped == null)
			{
				eventCache.WriteProcessingInstruction(name, text);
			}
			else
			{
				wrapped.WriteProcessingInstruction(name, text);
			}
		}

		public override void WriteWhitespace(string ws)
		{
			if (wrapped == null)
			{
				eventCache.WriteWhitespace(ws);
			}
			else
			{
				wrapped.WriteWhitespace(ws);
			}
		}

		public override void WriteString(string text)
		{
			if (TextBlockCreatesWriter(text))
			{
				wrapped.WriteString(text);
			}
			else
			{
				eventCache.WriteString(text);
			}
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			WriteString(new string(buffer, index, count));
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			WriteRaw(new string(buffer, index, count));
		}

		public override void WriteRaw(string data)
		{
			if (TextBlockCreatesWriter(data))
			{
				wrapped.WriteRaw(data);
			}
			else
			{
				eventCache.WriteRaw(data);
			}
		}

		public override void WriteEntityRef(string name)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteEntityRef(name);
		}

		public override void WriteCharEntity(char ch)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteCharEntity(ch);
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteSurrogateCharEntity(lowChar, highChar);
		}

		public override void WriteBase64(byte[] buffer, int index, int count)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteBase64(buffer, index, count);
		}

		public override void WriteBinHex(byte[] buffer, int index, int count)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteBinHex(buffer, index, count);
		}

		public override void Close()
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.Close();
		}

		public override void Flush()
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.Flush();
		}

		public override void WriteValue(object value)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteValue(value);
		}

		public override void WriteValue(string value)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteValue(value);
		}

		public override void WriteValue(bool value)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteValue(value);
		}

		public override void WriteValue(DateTime value)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteValue(value);
		}

		public override void WriteValue(double value)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteValue(value);
		}

		public override void WriteValue(float value)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteValue(value);
		}

		public override void WriteValue(decimal value)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteValue(value);
		}

		public override void WriteValue(int value)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteValue(value);
		}

		public override void WriteValue(long value)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteValue(value);
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteXmlDeclaration(standalone);
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteXmlDeclaration(xmldecl);
		}

		internal override void StartElementContent()
		{
			wrapped.StartElementContent();
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			wrapped.WriteEndElement(prefix, localName, ns);
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			wrapped.WriteFullEndElement(prefix, localName, ns);
		}

		internal override void WriteNamespaceDeclaration(string prefix, string ns)
		{
			EnsureWrappedWriter(XmlOutputMethod.Xml);
			wrapped.WriteNamespaceDeclaration(prefix, ns);
		}

		private static bool IsHtmlTag(string tagName)
		{
			if (tagName.Length != 4)
			{
				return false;
			}
			if (tagName[0] != 'H' && tagName[0] != 'h')
			{
				return false;
			}
			if (tagName[1] != 'T' && tagName[1] != 't')
			{
				return false;
			}
			if (tagName[2] != 'M' && tagName[2] != 'm')
			{
				return false;
			}
			if (tagName[3] != 'L' && tagName[3] != 'l')
			{
				return false;
			}
			return true;
		}

		private void EnsureWrappedWriter(XmlOutputMethod outMethod)
		{
			if (wrapped == null)
			{
				CreateWrappedWriter(outMethod);
			}
		}

		private bool TextBlockCreatesWriter(string textBlock)
		{
			if (wrapped == null)
			{
				if (XmlCharType.Instance.IsOnlyWhitespace(textBlock))
				{
					return false;
				}
				CreateWrappedWriter(XmlOutputMethod.Xml);
			}
			return true;
		}

		private void CreateWrappedWriter(XmlOutputMethod outMethod)
		{
			writerSettings.ReadOnly = false;
			writerSettings.OutputMethod = outMethod;
			if (outMethod == XmlOutputMethod.Html && writerSettings.InternalIndent == TriState.Unknown)
			{
				writerSettings.Indent = true;
			}
			writerSettings.ReadOnly = true;
			if (textWriter != null)
			{
				wrapped = ((XmlWellFormedWriter)XmlWriter.Create(textWriter, writerSettings)).RawWriter;
			}
			else
			{
				wrapped = ((XmlWellFormedWriter)XmlWriter.Create(strm, writerSettings)).RawWriter;
			}
			eventCache.EndEvents();
			eventCache.EventsToWriter(wrapped);
			if (onRemove != null)
			{
				onRemove(wrapped);
			}
		}
	}
	[DebuggerDisplay("{debuggerDisplayProxy}")]
	public abstract class XmlReader : IDisposable
	{
		[DebuggerDisplay("{ToString()}")]
		private struct DebuggerDisplayProxy
		{
			private XmlReader reader;

			internal DebuggerDisplayProxy(XmlReader reader)
			{
				this.reader = reader;
			}

			public override string ToString()
			{
				XmlNodeType nodeType = reader.NodeType;
				string text = nodeType.ToString();
				switch (nodeType)
				{
				case XmlNodeType.Element:
				case XmlNodeType.EntityReference:
				case XmlNodeType.EndElement:
				case XmlNodeType.EndEntity:
				{
					object obj6 = text;
					text = string.Concat(obj6, ", Name=\"", reader.Name, '"');
					break;
				}
				case XmlNodeType.Attribute:
				case XmlNodeType.ProcessingInstruction:
				{
					object obj5 = text;
					text = string.Concat(obj5, ", Name=\"", reader.Name, "\", Value=\"", XmlConvert.EscapeValueForDebuggerDisplay(reader.Value), '"');
					break;
				}
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Comment:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
				case XmlNodeType.XmlDeclaration:
				{
					object obj4 = text;
					text = string.Concat(obj4, ", Value=\"", XmlConvert.EscapeValueForDebuggerDisplay(reader.Value), '"');
					break;
				}
				case XmlNodeType.DocumentType:
				{
					text = text + ", Name=\"" + reader.Name + "'";
					object obj = text;
					text = string.Concat(obj, ", SYSTEM=\"", reader.GetAttribute("SYSTEM"), '"');
					object obj2 = text;
					text = string.Concat(obj2, ", PUBLIC=\"", reader.GetAttribute("PUBLIC"), '"');
					object obj3 = text;
					text = string.Concat(obj3, ", Value=\"", XmlConvert.EscapeValueForDebuggerDisplay(reader.Value), '"');
					break;
				}
				}
				return text;
			}
		}

		internal const int DefaultBufferSize = 4096;

		internal const int BiggerBufferSize = 8192;

		internal const int MaxStreamLengthForDefaultBufferSize = 65536;

		private static uint IsTextualNodeBitmap = 24600u;

		private static uint CanReadContentAsBitmap = 123324u;

		private static uint HasValueBitmap = 157084u;

		public virtual XmlReaderSettings Settings => null;

		public abstract XmlNodeType NodeType { get; }

		public virtual string Name
		{
			get
			{
				if (Prefix.Length == 0)
				{
					return LocalName;
				}
				return NameTable.Add(Prefix + ":" + LocalName);
			}
		}

		public abstract string LocalName { get; }

		public abstract string NamespaceURI { get; }

		public abstract string Prefix { get; }

		public abstract bool HasValue { get; }

		public abstract string Value { get; }

		public abstract int Depth { get; }

		public abstract string BaseURI { get; }

		public abstract bool IsEmptyElement { get; }

		public virtual bool IsDefault => false;

		public virtual char QuoteChar => '"';

		public virtual XmlSpace XmlSpace => XmlSpace.None;

		public virtual string XmlLang => string.Empty;

		public virtual IXmlSchemaInfo SchemaInfo => this as IXmlSchemaInfo;

		public virtual Type ValueType => typeof(string);

		public abstract int AttributeCount { get; }

		public virtual string this[int i] => GetAttribute(i);

		public virtual string this[string name] => GetAttribute(name);

		public virtual string this[string name, string namespaceURI] => GetAttribute(name, namespaceURI);

		public abstract bool EOF { get; }

		public abstract ReadState ReadState { get; }

		public abstract XmlNameTable NameTable { get; }

		public virtual bool CanResolveEntity => false;

		public virtual bool CanReadBinaryContent => false;

		public virtual bool CanReadValueChunk => false;

		public virtual bool HasAttributes => AttributeCount > 0;

		internal virtual XmlNamespaceManager NamespaceManager => null;

		private object debuggerDisplayProxy => new DebuggerDisplayProxy(this);

		public virtual object ReadContentAsObject()
		{
			if (!CanReadContentAs())
			{
				throw CreateReadContentAsException("ReadContentAsObject");
			}
			return InternalReadContentAsString();
		}

		public virtual bool ReadContentAsBoolean()
		{
			if (!CanReadContentAs())
			{
				throw CreateReadContentAsException("ReadContentAsBoolean");
			}
			try
			{
				return XmlConvert.ToBoolean(InternalReadContentAsString());
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Boolean", innerException, this as IXmlLineInfo);
			}
		}

		public virtual DateTime ReadContentAsDateTime()
		{
			if (!CanReadContentAs())
			{
				throw CreateReadContentAsException("ReadContentAsDateTime");
			}
			try
			{
				return XmlConvert.ToDateTime(InternalReadContentAsString(), XmlDateTimeSerializationMode.RoundtripKind);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "DateTime", innerException, this as IXmlLineInfo);
			}
		}

		public virtual double ReadContentAsDouble()
		{
			if (!CanReadContentAs())
			{
				throw CreateReadContentAsException("ReadContentAsDouble");
			}
			try
			{
				return XmlConvert.ToDouble(InternalReadContentAsString());
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Double", innerException, this as IXmlLineInfo);
			}
		}

		public virtual float ReadContentAsFloat()
		{
			if (!CanReadContentAs())
			{
				throw CreateReadContentAsException("ReadContentAsFloat");
			}
			try
			{
				return XmlConvert.ToSingle(InternalReadContentAsString());
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Float", innerException, this as IXmlLineInfo);
			}
		}

		public virtual decimal ReadContentAsDecimal()
		{
			if (!CanReadContentAs())
			{
				throw CreateReadContentAsException("ReadContentAsDecimal");
			}
			try
			{
				return XmlConvert.ToDecimal(InternalReadContentAsString());
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Decimal", innerException, this as IXmlLineInfo);
			}
		}

		public virtual int ReadContentAsInt()
		{
			if (!CanReadContentAs())
			{
				throw CreateReadContentAsException("ReadContentAsInt");
			}
			try
			{
				return XmlConvert.ToInt32(InternalReadContentAsString());
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Int", innerException, this as IXmlLineInfo);
			}
		}

		public virtual long ReadContentAsLong()
		{
			if (!CanReadContentAs())
			{
				throw CreateReadContentAsException("ReadContentAsLong");
			}
			try
			{
				return XmlConvert.ToInt64(InternalReadContentAsString());
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Long", innerException, this as IXmlLineInfo);
			}
		}

		public virtual string ReadContentAsString()
		{
			if (!CanReadContentAs())
			{
				throw CreateReadContentAsException("ReadContentAsString");
			}
			return InternalReadContentAsString();
		}

		public virtual object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver)
		{
			if (!CanReadContentAs())
			{
				throw CreateReadContentAsException("ReadContentAs");
			}
			string text = InternalReadContentAsString();
			if (returnType == typeof(string))
			{
				return text;
			}
			try
			{
				return XmlUntypedConverter.Untyped.ChangeType(text, returnType, this as IXmlNamespaceResolver);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException, this as IXmlLineInfo);
			}
			catch (InvalidCastException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException2, this as IXmlLineInfo);
			}
		}

		public virtual object ReadElementContentAsObject()
		{
			if (SetupReadElementContentAsXxx("ReadElementContentAsObject"))
			{
				object result = ReadContentAsObject();
				FinishReadElementContentAsXxx();
				return result;
			}
			return string.Empty;
		}

		public virtual object ReadElementContentAsObject(string localName, string namespaceURI)
		{
			CheckElement(localName, namespaceURI);
			return ReadElementContentAsObject();
		}

		public virtual bool ReadElementContentAsBoolean()
		{
			if (SetupReadElementContentAsXxx("ReadElementContentAsBoolean"))
			{
				bool result = ReadContentAsBoolean();
				FinishReadElementContentAsXxx();
				return result;
			}
			return XmlConvert.ToBoolean(string.Empty);
		}

		public virtual bool ReadElementContentAsBoolean(string localName, string namespaceURI)
		{
			CheckElement(localName, namespaceURI);
			return ReadElementContentAsBoolean();
		}

		public virtual DateTime ReadElementContentAsDateTime()
		{
			if (SetupReadElementContentAsXxx("ReadElementContentAsDateTime"))
			{
				DateTime result = ReadContentAsDateTime();
				FinishReadElementContentAsXxx();
				return result;
			}
			return XmlConvert.ToDateTime(string.Empty, XmlDateTimeSerializationMode.RoundtripKind);
		}

		public virtual DateTime ReadElementContentAsDateTime(string localName, string namespaceURI)
		{
			CheckElement(localName, namespaceURI);
			return ReadElementContentAsDateTime();
		}

		public virtual double ReadElementContentAsDouble()
		{
			if (SetupReadElementContentAsXxx("ReadElementContentAsDouble"))
			{
				double result = ReadContentAsDouble();
				FinishReadElementContentAsXxx();
				return result;
			}
			return XmlConvert.ToDouble(string.Empty);
		}

		public virtual double ReadElementContentAsDouble(string localName, string namespaceURI)
		{
			CheckElement(localName, namespaceURI);
			return ReadElementContentAsDouble();
		}

		public virtual float ReadElementContentAsFloat()
		{
			if (SetupReadElementContentAsXxx("ReadElementContentAsFloat"))
			{
				float result = ReadContentAsFloat();
				FinishReadElementContentAsXxx();
				return result;
			}
			return XmlConvert.ToSingle(string.Empty);
		}

		public virtual float ReadElementContentAsFloat(string localName, string namespaceURI)
		{
			CheckElement(localName, namespaceURI);
			return ReadElementContentAsFloat();
		}

		public virtual decimal ReadElementContentAsDecimal()
		{
			if (SetupReadElementContentAsXxx("ReadElementContentAsDecimal"))
			{
				decimal result = ReadContentAsDecimal();
				FinishReadElementContentAsXxx();
				return result;
			}
			return XmlConvert.ToDecimal(string.Empty);
		}

		public virtual decimal ReadElementContentAsDecimal(string localName, string namespaceURI)
		{
			CheckElement(localName, namespaceURI);
			return ReadElementContentAsDecimal();
		}

		public virtual int ReadElementContentAsInt()
		{
			if (SetupReadElementContentAsXxx("ReadElementContentAsInt"))
			{
				int result = ReadContentAsInt();
				FinishReadElementContentAsXxx();
				return result;
			}
			return XmlConvert.ToInt32(string.Empty);
		}

		public virtual int ReadElementContentAsInt(string localName, string namespaceURI)
		{
			CheckElement(localName, namespaceURI);
			return ReadElementContentAsInt();
		}

		public virtual long ReadElementContentAsLong()
		{
			if (SetupReadElementContentAsXxx("ReadElementContentAsLong"))
			{
				long result = ReadContentAsLong();
				FinishReadElementContentAsXxx();
				return result;
			}
			return XmlConvert.ToInt64(string.Empty);
		}

		public virtual long ReadElementContentAsLong(string localName, string namespaceURI)
		{
			CheckElement(localName, namespaceURI);
			return ReadElementContentAsLong();
		}

		public virtual string ReadElementContentAsString()
		{
			if (SetupReadElementContentAsXxx("ReadElementContentAsString"))
			{
				string result = ReadContentAsString();
				FinishReadElementContentAsXxx();
				return result;
			}
			return string.Empty;
		}

		public virtual string ReadElementContentAsString(string localName, string namespaceURI)
		{
			CheckElement(localName, namespaceURI);
			return ReadElementContentAsString();
		}

		public virtual object ReadElementContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver)
		{
			if (SetupReadElementContentAsXxx("ReadElementContentAs"))
			{
				object result = ReadContentAs(returnType, namespaceResolver);
				FinishReadElementContentAsXxx();
				return result;
			}
			if (returnType != typeof(string))
			{
				return XmlUntypedConverter.Untyped.ChangeType(string.Empty, returnType, namespaceResolver);
			}
			return string.Empty;
		}

		public virtual object ReadElementContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI)
		{
			CheckElement(localName, namespaceURI);
			return ReadElementContentAs(returnType, namespaceResolver);
		}

		public abstract string GetAttribute(string name);

		public abstract string GetAttribute(string name, string namespaceURI);

		public abstract string GetAttribute(int i);

		public abstract bool MoveToAttribute(string name);

		public abstract bool MoveToAttribute(string name, string ns);

		public virtual void MoveToAttribute(int i)
		{
			if (i < 0 || i >= AttributeCount)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			MoveToElement();
			MoveToFirstAttribute();
			for (int j = 0; j < i; j++)
			{
				MoveToNextAttribute();
			}
		}

		public abstract bool MoveToFirstAttribute();

		public abstract bool MoveToNextAttribute();

		public abstract bool MoveToElement();

		public abstract bool ReadAttributeValue();

		public abstract bool Read();

		public abstract void Close();

		public virtual void Skip()
		{
			SkipSubtree();
		}

		public abstract string LookupNamespace(string prefix);

		public abstract void ResolveEntity();

		public virtual int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			throw new NotSupportedException(Res.GetString("Xml_ReadBinaryContentNotSupported", "ReadContentAsBase64"));
		}

		public virtual int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			throw new NotSupportedException(Res.GetString("Xml_ReadBinaryContentNotSupported", "ReadElementContentAsBase64"));
		}

		public virtual int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			throw new NotSupportedException(Res.GetString("Xml_ReadBinaryContentNotSupported", "ReadContentAsBinHex"));
		}

		public virtual int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			throw new NotSupportedException(Res.GetString("Xml_ReadBinaryContentNotSupported", "ReadElementContentAsBinHex"));
		}

		public virtual int ReadValueChunk(char[] buffer, int index, int count)
		{
			throw new NotSupportedException(Res.GetString("Xml_ReadValueChunkNotSupported"));
		}

		public virtual string ReadString()
		{
			if (ReadState != ReadState.Interactive)
			{
				return string.Empty;
			}
			MoveToElement();
			if (NodeType == XmlNodeType.Element)
			{
				if (IsEmptyElement)
				{
					return string.Empty;
				}
				if (!Read())
				{
					throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
				}
				if (NodeType == XmlNodeType.EndElement)
				{
					return string.Empty;
				}
			}
			string text = string.Empty;
			while (IsTextualNode(NodeType))
			{
				text += Value;
				if (!Read())
				{
					break;
				}
			}
			return text;
		}

		public virtual XmlNodeType MoveToContent()
		{
			do
			{
				switch (NodeType)
				{
				case XmlNodeType.Attribute:
					MoveToElement();
					break;
				case XmlNodeType.Element:
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.EntityReference:
				case XmlNodeType.EndElement:
				case XmlNodeType.EndEntity:
					break;
				default:
					continue;
				}
				return NodeType;
			}
			while (Read());
			return NodeType;
		}

		public virtual void ReadStartElement()
		{
			if (MoveToContent() != XmlNodeType.Element)
			{
				throw new XmlException("Xml_InvalidNodeType", NodeType.ToString(), this as IXmlLineInfo);
			}
			Read();
		}

		public virtual void ReadStartElement(string name)
		{
			if (MoveToContent() != XmlNodeType.Element)
			{
				throw new XmlException("Xml_InvalidNodeType", NodeType.ToString(), this as IXmlLineInfo);
			}
			if (Name == name)
			{
				Read();
				return;
			}
			throw new XmlException("Xml_ElementNotFound", name, this as IXmlLineInfo);
		}

		public virtual void ReadStartElement(string localname, string ns)
		{
			if (MoveToContent() != XmlNodeType.Element)
			{
				throw new XmlException("Xml_InvalidNodeType", NodeType.ToString(), this as IXmlLineInfo);
			}
			if (LocalName == localname && NamespaceURI == ns)
			{
				Read();
				return;
			}
			throw new XmlException("Xml_ElementNotFoundNs", new string[2] { localname, ns }, this as IXmlLineInfo);
		}

		public virtual string ReadElementString()
		{
			string result = string.Empty;
			if (MoveToContent() != XmlNodeType.Element)
			{
				throw new XmlException("Xml_InvalidNodeType", NodeType.ToString(), this as IXmlLineInfo);
			}
			if (!IsEmptyElement)
			{
				Read();
				result = ReadString();
				if (NodeType != XmlNodeType.EndElement)
				{
					throw new XmlException("Xml_UnexpectedNodeInSimpleContent", new string[2]
					{
						NodeType.ToString(),
						"ReadElementString"
					}, this as IXmlLineInfo);
				}
				Read();
			}
			else
			{
				Read();
			}
			return result;
		}

		public virtual string ReadElementString(string name)
		{
			string result = string.Empty;
			if (MoveToContent() != XmlNodeType.Element)
			{
				throw new XmlException("Xml_InvalidNodeType", NodeType.ToString(), this as IXmlLineInfo);
			}
			if (Name != name)
			{
				throw new XmlException("Xml_ElementNotFound", name, this as IXmlLineInfo);
			}
			if (!IsEmptyElement)
			{
				result = ReadString();
				if (NodeType != XmlNodeType.EndElement)
				{
					throw new XmlException("Xml_InvalidNodeType", NodeType.ToString(), this as IXmlLineInfo);
				}
				Read();
			}
			else
			{
				Read();
			}
			return result;
		}

		public virtual string ReadElementString(string localname, string ns)
		{
			string result = string.Empty;
			if (MoveToContent() != XmlNodeType.Element)
			{
				throw new XmlException("Xml_InvalidNodeType", NodeType.ToString(), this as IXmlLineInfo);
			}
			if (LocalName != localname || NamespaceURI != ns)
			{
				throw new XmlException("Xml_ElementNotFoundNs", new string[2] { localname, ns }, this as IXmlLineInfo);
			}
			if (!IsEmptyElement)
			{
				result = ReadString();
				if (NodeType != XmlNodeType.EndElement)
				{
					throw new XmlException("Xml_InvalidNodeType", NodeType.ToString(), this as IXmlLineInfo);
				}
				Read();
			}
			else
			{
				Read();
			}
			return result;
		}

		public virtual void ReadEndElement()
		{
			if (MoveToContent() != XmlNodeType.EndElement)
			{
				throw new XmlException("Xml_InvalidNodeType", NodeType.ToString(), this as IXmlLineInfo);
			}
			Read();
		}

		public virtual bool IsStartElement()
		{
			return MoveToContent() == XmlNodeType.Element;
		}

		public virtual bool IsStartElement(string name)
		{
			if (MoveToContent() == XmlNodeType.Element)
			{
				return Name == name;
			}
			return false;
		}

		public virtual bool IsStartElement(string localname, string ns)
		{
			if (MoveToContent() == XmlNodeType.Element)
			{
				if (LocalName == localname)
				{
					return NamespaceURI == ns;
				}
				return false;
			}
			return false;
		}

		public virtual bool ReadToFollowing(string name)
		{
			if (name == null || name.Length == 0)
			{
				throw XmlConvert.CreateInvalidNameArgumentException(name, "name");
			}
			name = NameTable.Add(name);
			while (Read())
			{
				if (NodeType == XmlNodeType.Element && Ref.Equal(name, Name))
				{
					return true;
				}
			}
			return false;
		}

		public virtual bool ReadToFollowing(string localName, string namespaceURI)
		{
			if (localName == null || localName.Length == 0)
			{
				throw XmlConvert.CreateInvalidNameArgumentException(localName, "localName");
			}
			if (namespaceURI == null)
			{
				throw new ArgumentNullException("namespaceURI");
			}
			localName = NameTable.Add(localName);
			namespaceURI = NameTable.Add(namespaceURI);
			while (Read())
			{
				if (NodeType == XmlNodeType.Element && Ref.Equal(localName, LocalName) && Ref.Equal(namespaceURI, NamespaceURI))
				{
					return true;
				}
			}
			return false;
		}

		public virtual bool ReadToDescendant(string name)
		{
			if (name == null || name.Length == 0)
			{
				throw XmlConvert.CreateInvalidNameArgumentException(name, "name");
			}
			int num = Depth;
			if (NodeType != XmlNodeType.Element)
			{
				if (ReadState != 0)
				{
					return false;
				}
				num--;
			}
			else if (IsEmptyElement)
			{
				return false;
			}
			name = NameTable.Add(name);
			while (Read() && Depth > num)
			{
				if (NodeType == XmlNodeType.Element && Ref.Equal(name, Name))
				{
					return true;
				}
			}
			return false;
		}

		public virtual bool ReadToDescendant(string localName, string namespaceURI)
		{
			if (localName == null || localName.Length == 0)
			{
				throw XmlConvert.CreateInvalidNameArgumentException(localName, "localName");
			}
			if (namespaceURI == null)
			{
				throw new ArgumentNullException("namespaceURI");
			}
			int num = Depth;
			if (NodeType != XmlNodeType.Element)
			{
				if (ReadState != 0)
				{
					return false;
				}
				num--;
			}
			else if (IsEmptyElement)
			{
				return false;
			}
			localName = NameTable.Add(localName);
			namespaceURI = NameTable.Add(namespaceURI);
			while (Read() && Depth > num)
			{
				if (NodeType == XmlNodeType.Element && Ref.Equal(localName, LocalName) && Ref.Equal(namespaceURI, NamespaceURI))
				{
					return true;
				}
			}
			return false;
		}

		public virtual bool ReadToNextSibling(string name)
		{
			if (name == null || name.Length == 0)
			{
				throw XmlConvert.CreateInvalidNameArgumentException(name, "name");
			}
			name = NameTable.Add(name);
			XmlNodeType nodeType;
			do
			{
				SkipSubtree();
				nodeType = NodeType;
				if (nodeType == XmlNodeType.Element && Ref.Equal(name, Name))
				{
					return true;
				}
			}
			while (nodeType != XmlNodeType.EndElement && !EOF);
			return false;
		}

		public virtual bool ReadToNextSibling(string localName, string namespaceURI)
		{
			if (localName == null || localName.Length == 0)
			{
				throw XmlConvert.CreateInvalidNameArgumentException(localName, "localName");
			}
			if (namespaceURI == null)
			{
				throw new ArgumentNullException("namespaceURI");
			}
			localName = NameTable.Add(localName);
			namespaceURI = NameTable.Add(namespaceURI);
			XmlNodeType nodeType;
			do
			{
				SkipSubtree();
				nodeType = NodeType;
				if (nodeType == XmlNodeType.Element && Ref.Equal(localName, LocalName) && Ref.Equal(namespaceURI, NamespaceURI))
				{
					return true;
				}
			}
			while (nodeType != XmlNodeType.EndElement && !EOF);
			return false;
		}

		public static bool IsName(string str)
		{
			return XmlCharType.Instance.IsName(str);
		}

		public static bool IsNameToken(string str)
		{
			return XmlCharType.Instance.IsNmToken(str);
		}

		public virtual string ReadInnerXml()
		{
			if (ReadState != ReadState.Interactive)
			{
				return string.Empty;
			}
			if (NodeType != XmlNodeType.Attribute && NodeType != XmlNodeType.Element)
			{
				Read();
				return string.Empty;
			}
			StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			XmlTextWriter xmlTextWriter = new XmlTextWriter(stringWriter);
			try
			{
				SetNamespacesFlag(xmlTextWriter);
				if (NodeType == XmlNodeType.Attribute)
				{
					xmlTextWriter.QuoteChar = QuoteChar;
					WriteAttributeValue(xmlTextWriter);
				}
				if (NodeType == XmlNodeType.Element)
				{
					WriteNode(xmlTextWriter, defattr: false);
				}
			}
			finally
			{
				xmlTextWriter.Close();
			}
			return stringWriter.ToString();
		}

		private void WriteNode(XmlTextWriter xtw, bool defattr)
		{
			int num = ((NodeType == XmlNodeType.None) ? (-1) : Depth);
			while (Read() && num < Depth)
			{
				switch (NodeType)
				{
				case XmlNodeType.Element:
					xtw.WriteStartElement(Prefix, LocalName, NamespaceURI);
					xtw.QuoteChar = QuoteChar;
					xtw.WriteAttributes(this, defattr);
					if (IsEmptyElement)
					{
						xtw.WriteEndElement();
					}
					break;
				case XmlNodeType.Text:
					xtw.WriteString(Value);
					break;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					xtw.WriteWhitespace(Value);
					break;
				case XmlNodeType.CDATA:
					xtw.WriteCData(Value);
					break;
				case XmlNodeType.EntityReference:
					xtw.WriteEntityRef(Name);
					break;
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.XmlDeclaration:
					xtw.WriteProcessingInstruction(Name, Value);
					break;
				case XmlNodeType.DocumentType:
					xtw.WriteDocType(Name, GetAttribute("PUBLIC"), GetAttribute("SYSTEM"), Value);
					break;
				case XmlNodeType.Comment:
					xtw.WriteComment(Value);
					break;
				case XmlNodeType.EndElement:
					xtw.WriteFullEndElement();
					break;
				}
			}
			if (num == Depth && NodeType == XmlNodeType.EndElement)
			{
				Read();
			}
		}

		private void WriteAttributeValue(XmlTextWriter xtw)
		{
			string name = Name;
			while (ReadAttributeValue())
			{
				if (NodeType == XmlNodeType.EntityReference)
				{
					xtw.WriteEntityRef(Name);
				}
				else
				{
					xtw.WriteString(Value);
				}
			}
			MoveToAttribute(name);
		}

		public virtual string ReadOuterXml()
		{
			if (ReadState != ReadState.Interactive)
			{
				return string.Empty;
			}
			if (NodeType != XmlNodeType.Attribute && NodeType != XmlNodeType.Element)
			{
				Read();
				return string.Empty;
			}
			StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			XmlTextWriter xmlTextWriter = new XmlTextWriter(stringWriter);
			try
			{
				SetNamespacesFlag(xmlTextWriter);
				if (NodeType == XmlNodeType.Attribute)
				{
					xmlTextWriter.WriteStartAttribute(Prefix, LocalName, NamespaceURI);
					WriteAttributeValue(xmlTextWriter);
					xmlTextWriter.WriteEndAttribute();
				}
				else
				{
					xmlTextWriter.WriteNode(this, defattr: false);
				}
			}
			finally
			{
				xmlTextWriter.Close();
			}
			return stringWriter.ToString();
		}

		private void SetNamespacesFlag(XmlTextWriter xtw)
		{
			if (this is XmlTextReader xmlTextReader)
			{
				xtw.Namespaces = xmlTextReader.Namespaces;
			}
			else if (this is XmlValidatingReader xmlValidatingReader)
			{
				xtw.Namespaces = xmlValidatingReader.Namespaces;
			}
		}

		public virtual XmlReader ReadSubtree()
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw new InvalidOperationException(Res.GetString("Xml_ReadSubtreeNotOnElement"));
			}
			return new XmlSubtreeReader(this);
		}

		void IDisposable.Dispose()
		{
			Dispose(disposing: true);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (ReadState != ReadState.Closed)
			{
				Close();
			}
		}

		internal static bool IsTextualNode(XmlNodeType nodeType)
		{
			return 0 != (IsTextualNodeBitmap & (1 << (int)nodeType));
		}

		internal static bool CanReadContentAs(XmlNodeType nodeType)
		{
			return 0 != (CanReadContentAsBitmap & (1 << (int)nodeType));
		}

		internal static bool HasValueInternal(XmlNodeType nodeType)
		{
			return 0 != (HasValueBitmap & (1 << (int)nodeType));
		}

		private void SkipSubtree()
		{
			if (ReadState != ReadState.Interactive)
			{
				return;
			}
			MoveToElement();
			if (NodeType == XmlNodeType.Element && !IsEmptyElement)
			{
				int depth = Depth;
				while (Read() && depth < Depth)
				{
				}
				if (NodeType == XmlNodeType.EndElement)
				{
					Read();
				}
			}
			else
			{
				Read();
			}
		}

		internal void CheckElement(string localName, string namespaceURI)
		{
			if (localName == null || localName.Length == 0)
			{
				throw XmlConvert.CreateInvalidNameArgumentException(localName, "localName");
			}
			if (namespaceURI == null)
			{
				throw new ArgumentNullException("namespaceURI");
			}
			if (NodeType != XmlNodeType.Element)
			{
				throw new XmlException("Xml_InvalidNodeType", NodeType.ToString(), this as IXmlLineInfo);
			}
			if (LocalName != localName || NamespaceURI != namespaceURI)
			{
				throw new XmlException("Xml_ElementNotFoundNs", new string[2] { localName, namespaceURI }, this as IXmlLineInfo);
			}
		}

		internal Exception CreateReadContentAsException(string methodName)
		{
			return CreateReadContentAsException(methodName, NodeType, this as IXmlLineInfo);
		}

		internal Exception CreateReadElementContentAsException(string methodName)
		{
			return CreateReadElementContentAsException(methodName, NodeType, this as IXmlLineInfo);
		}

		internal bool CanReadContentAs()
		{
			return CanReadContentAs(NodeType);
		}

		internal static Exception CreateReadContentAsException(string methodName, XmlNodeType nodeType, IXmlLineInfo lineInfo)
		{
			return new InvalidOperationException(AddLineInfo(Res.GetString("Xml_InvalidReadContentAs", methodName, nodeType.ToString()), lineInfo));
		}

		internal static Exception CreateReadElementContentAsException(string methodName, XmlNodeType nodeType, IXmlLineInfo lineInfo)
		{
			return new InvalidOperationException(AddLineInfo(Res.GetString("Xml_InvalidReadElementContentAs", methodName, nodeType.ToString()), lineInfo));
		}

		private static string AddLineInfo(string message, IXmlLineInfo lineInfo)
		{
			if (lineInfo != null)
			{
				message = message + " " + Res.GetString("Xml_ErrorPosition", lineInfo.LineNumber.ToString(CultureInfo.InvariantCulture), lineInfo.LinePosition.ToString(CultureInfo.InvariantCulture));
			}
			return message;
		}

		internal string InternalReadContentAsString()
		{
			string text = string.Empty;
			BufferBuilder bufferBuilder = null;
			bool num;
			do
			{
				switch (NodeType)
				{
				case XmlNodeType.Attribute:
					return Value;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					if (text.Length == 0)
					{
						text = Value;
					}
					else
					{
						if (bufferBuilder == null)
						{
							bufferBuilder = new BufferBuilder();
							bufferBuilder.Append(text);
						}
						bufferBuilder.Append(Value);
					}
					goto case XmlNodeType.ProcessingInstruction;
				case XmlNodeType.EntityReference:
					if (!CanResolveEntity)
					{
						break;
					}
					ResolveEntity();
					goto case XmlNodeType.ProcessingInstruction;
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.Comment:
				case XmlNodeType.EndEntity:
					num = ((AttributeCount != 0) ? ReadAttributeValue() : Read());
					continue;
				}
				break;
			}
			while (num);
			if (bufferBuilder != null)
			{
				return bufferBuilder.ToString();
			}
			return text;
		}

		private bool SetupReadElementContentAsXxx(string methodName)
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException(methodName);
			}
			bool isEmptyElement = IsEmptyElement;
			Read();
			if (isEmptyElement)
			{
				return false;
			}
			switch (NodeType)
			{
			case XmlNodeType.EndElement:
				Read();
				return false;
			case XmlNodeType.Element:
				throw new XmlException("Xml_MixedReadElementContentAs", string.Empty, this as IXmlLineInfo);
			default:
				return true;
			}
		}

		private void FinishReadElementContentAsXxx()
		{
			if (NodeType != XmlNodeType.EndElement)
			{
				throw new XmlException("Xml_InvalidNodeType", NodeType.ToString());
			}
			Read();
		}

		internal static SchemaInfo GetDtdSchemaInfo(XmlReader reader)
		{
			if (reader is XmlWrappingReader xmlWrappingReader)
			{
				return xmlWrappingReader.DtdSchemaInfo;
			}
			return GetXmlTextReaderImpl(reader)?.DtdSchemaInfo;
		}

		internal static Encoding GetEncoding(XmlReader reader)
		{
			return GetXmlTextReaderImpl(reader)?.Encoding;
		}

		internal static ConformanceLevel GetV1ConformanceLevel(XmlReader reader)
		{
			return GetXmlTextReaderImpl(reader)?.V1ComformanceLevel ?? ConformanceLevel.Document;
		}

		private static XmlTextReaderImpl GetXmlTextReaderImpl(XmlReader reader)
		{
			if (reader is XmlTextReaderImpl result)
			{
				return result;
			}
			if (reader is XmlTextReader xmlTextReader)
			{
				return xmlTextReader.Impl;
			}
			if (reader is XmlValidatingReaderImpl xmlValidatingReaderImpl)
			{
				return xmlValidatingReaderImpl.ReaderImpl;
			}
			if (reader is XmlValidatingReader xmlValidatingReader)
			{
				return xmlValidatingReader.Impl.ReaderImpl;
			}
			return null;
		}

		public static XmlReader Create(string inputUri)
		{
			return Create(inputUri, null, null);
		}

		public static XmlReader Create(string inputUri, XmlReaderSettings settings)
		{
			return Create(inputUri, settings, null);
		}

		public static XmlReader Create(string inputUri, XmlReaderSettings settings, XmlParserContext inputContext)
		{
			if (inputUri == null)
			{
				throw new ArgumentNullException("inputUri");
			}
			if (inputUri.Length == 0)
			{
				throw new ArgumentException(Res.GetString("XmlConvert_BadUri"), "inputUri");
			}
			if (settings == null)
			{
				settings = new XmlReaderSettings();
			}
			XmlResolver xmlResolver = settings.GetXmlResolver();
			if (xmlResolver == null)
			{
				xmlResolver = new XmlUrlResolver();
			}
			Uri uri = xmlResolver.ResolveUri(null, inputUri);
			Stream stream = (Stream)xmlResolver.GetEntity(uri, string.Empty, typeof(Stream));
			if (stream == null)
			{
				throw new XmlException("Xml_CannotResolveUrl", inputUri);
			}
			try
			{
				return CreateReaderImpl(stream, settings, uri, uri.ToString(), inputContext, closeInput: true);
			}
			catch
			{
				stream.Close();
				throw;
			}
		}

		public static XmlReader Create(Stream input)
		{
			XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
			return CreateReaderImpl(input, xmlReaderSettings, null, string.Empty, null, xmlReaderSettings.CloseInput);
		}

		public static XmlReader Create(Stream input, XmlReaderSettings settings)
		{
			return Create(input, settings, string.Empty);
		}

		public static XmlReader Create(Stream input, XmlReaderSettings settings, string baseUri)
		{
			if (settings == null)
			{
				settings = new XmlReaderSettings();
			}
			return CreateReaderImpl(input, settings, null, baseUri, null, settings.CloseInput);
		}

		public static XmlReader Create(Stream input, XmlReaderSettings settings, XmlParserContext inputContext)
		{
			if (settings == null)
			{
				settings = new XmlReaderSettings();
			}
			return CreateReaderImpl(input, settings, null, string.Empty, inputContext, settings.CloseInput);
		}

		public static XmlReader Create(TextReader input)
		{
			return CreateReaderImpl(input, null, string.Empty, null);
		}

		public static XmlReader Create(TextReader input, XmlReaderSettings settings)
		{
			return Create(input, settings, string.Empty);
		}

		public static XmlReader Create(TextReader input, XmlReaderSettings settings, string baseUri)
		{
			return CreateReaderImpl(input, settings, baseUri, null);
		}

		public static XmlReader Create(TextReader input, XmlReaderSettings settings, XmlParserContext inputContext)
		{
			return CreateReaderImpl(input, settings, string.Empty, inputContext);
		}

		public static XmlReader Create(XmlReader reader, XmlReaderSettings settings)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			if (settings == null)
			{
				settings = new XmlReaderSettings();
			}
			return CreateReaderImpl(reader, settings);
		}

		internal static XmlReader CreateSqlReader(Stream input, XmlReaderSettings settings, XmlParserContext inputContext)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (settings == null)
			{
				settings = new XmlReaderSettings();
			}
			byte[] array = new byte[CalcBufferSize(input)];
			int num = 0;
			int num2;
			do
			{
				num2 = input.Read(array, num, array.Length - num);
				num += num2;
			}
			while (num2 > 0 && num < 2);
			XmlReader xmlReader;
			if (num >= 2 && array[0] == 223 && array[1] == byte.MaxValue)
			{
				if (inputContext != null)
				{
					throw new ArgumentException(Res.GetString("XmlBinary_NoParserContext"), "inputContext");
				}
				xmlReader = new XmlSqlBinaryReader(input, array, num, string.Empty, settings.CloseInput, settings);
			}
			else
			{
				xmlReader = new XmlTextReaderImpl(input, array, num, settings, null, string.Empty, inputContext, settings.CloseInput);
			}
			if (settings.ValidationType != 0)
			{
				xmlReader = AddValidation(xmlReader, settings);
			}
			return xmlReader;
		}

		private static XmlReader CreateReaderImpl(Stream input, XmlReaderSettings settings, Uri baseUri, string baseUriStr, XmlParserContext inputContext, bool closeInput)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (baseUriStr == null)
			{
				baseUriStr = string.Empty;
			}
			XmlReader xmlReader = new XmlTextReaderImpl(input, null, 0, settings, baseUri, baseUriStr, inputContext, closeInput);
			if (settings.ValidationType != 0)
			{
				xmlReader = AddValidation(xmlReader, settings);
			}
			return xmlReader;
		}

		private static XmlReader AddValidation(XmlReader reader, XmlReaderSettings settings)
		{
			if (settings.ValidationType == ValidationType.Schema)
			{
				reader = new XsdValidatingReader(reader, settings.GetXmlResolver_CheckConfig(), settings);
			}
			else if (settings.ValidationType == ValidationType.DTD)
			{
				reader = CreateDtdValidatingReader(reader, settings);
			}
			return reader;
		}

		internal static int CalcBufferSize(Stream input)
		{
			int num = 4096;
			if (input.CanSeek)
			{
				long length = input.Length;
				if (length < num)
				{
					num = checked((int)length);
				}
				else if (length > 65536)
				{
					num = 8192;
				}
			}
			return num;
		}

		private static XmlReader CreateReaderImpl(TextReader input, XmlReaderSettings settings, string baseUriStr, XmlParserContext context)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			if (settings == null)
			{
				settings = new XmlReaderSettings();
			}
			if (baseUriStr == null)
			{
				baseUriStr = string.Empty;
			}
			XmlReader xmlReader = new XmlTextReaderImpl(input, settings, baseUriStr, context);
			if (settings.ValidationType == ValidationType.Schema)
			{
				xmlReader = new XsdValidatingReader(xmlReader, settings.GetXmlResolver_CheckConfig(), settings);
			}
			else if (settings.ValidationType == ValidationType.DTD)
			{
				xmlReader = CreateDtdValidatingReader(xmlReader, settings);
			}
			return xmlReader;
		}

		private static XmlReader CreateReaderImpl(XmlReader baseReader, XmlReaderSettings settings)
		{
			XmlReader xmlReader = baseReader;
			if (settings.ValidationType == ValidationType.DTD)
			{
				xmlReader = CreateDtdValidatingReader(xmlReader, settings);
			}
			xmlReader = AddWrapper(xmlReader, settings, xmlReader.Settings);
			if (settings.ValidationType == ValidationType.Schema)
			{
				xmlReader = new XsdValidatingReader(xmlReader, settings.GetXmlResolver_CheckConfig(), settings);
			}
			return xmlReader;
		}

		private static XmlValidatingReaderImpl CreateDtdValidatingReader(XmlReader baseReader, XmlReaderSettings settings)
		{
			return new XmlValidatingReaderImpl(baseReader, settings.GetEventHandler(), (settings.ValidationFlags & XmlSchemaValidationFlags.ProcessIdentityConstraints) != 0);
		}

		private static XmlReader AddWrapper(XmlReader baseReader, XmlReaderSettings settings, XmlReaderSettings baseReaderSettings)
		{
			bool checkCharacters = false;
			bool ignoreWhitespace = false;
			bool ignoreComments = false;
			bool ignorePis = false;
			bool flag = false;
			bool prohibitDtd = false;
			if (baseReaderSettings == null)
			{
				if (settings.ConformanceLevel != 0 && settings.ConformanceLevel != GetV1ConformanceLevel(baseReader))
				{
					throw new InvalidOperationException(Res.GetString("Xml_IncompatibleConformanceLevel", settings.ConformanceLevel.ToString()));
				}
				if (settings.IgnoreWhitespace)
				{
					WhitespaceHandling whitespaceHandling = WhitespaceHandling.All;
					if (baseReader is XmlTextReader xmlTextReader)
					{
						whitespaceHandling = xmlTextReader.WhitespaceHandling;
					}
					else if (baseReader is XmlValidatingReader xmlValidatingReader)
					{
						whitespaceHandling = ((XmlTextReader)xmlValidatingReader.Reader).WhitespaceHandling;
					}
					if (whitespaceHandling == WhitespaceHandling.All)
					{
						ignoreWhitespace = true;
						flag = true;
					}
				}
				if (settings.IgnoreComments)
				{
					ignoreComments = true;
					flag = true;
				}
				if (settings.IgnoreProcessingInstructions)
				{
					ignorePis = true;
					flag = true;
				}
				if (settings.ProhibitDtd)
				{
					XmlTextReader xmlTextReader2 = baseReader as XmlTextReader;
					if (xmlTextReader2 == null && baseReader is XmlValidatingReader xmlValidatingReader2)
					{
						xmlTextReader2 = (XmlTextReader)xmlValidatingReader2.Reader;
					}
					if (xmlTextReader2 == null || !xmlTextReader2.ProhibitDtd)
					{
						prohibitDtd = true;
						flag = true;
					}
				}
			}
			else
			{
				if (settings.ConformanceLevel != baseReaderSettings.ConformanceLevel && settings.ConformanceLevel != 0)
				{
					throw new InvalidOperationException(Res.GetString("Xml_IncompatibleConformanceLevel", settings.ConformanceLevel.ToString()));
				}
				if (settings.CheckCharacters && !baseReaderSettings.CheckCharacters)
				{
					checkCharacters = true;
					flag = true;
				}
				if (settings.IgnoreWhitespace && !baseReaderSettings.IgnoreWhitespace)
				{
					ignoreWhitespace = true;
					flag = true;
				}
				if (settings.IgnoreComments && !baseReaderSettings.IgnoreComments)
				{
					ignoreComments = true;
					flag = true;
				}
				if (settings.IgnoreProcessingInstructions && !baseReaderSettings.IgnoreProcessingInstructions)
				{
					ignorePis = true;
					flag = true;
				}
				if (settings.ProhibitDtd && !baseReaderSettings.ProhibitDtd)
				{
					prohibitDtd = true;
					flag = true;
				}
			}
			if (flag)
			{
				if (baseReader is IXmlNamespaceResolver readerAsNSResolver)
				{
					return new XmlCharCheckingReaderWithNS(baseReader, readerAsNSResolver, checkCharacters, ignoreWhitespace, ignoreComments, ignorePis, prohibitDtd);
				}
				return new XmlCharCheckingReader(baseReader, checkCharacters, ignoreWhitespace, ignoreComments, ignorePis, prohibitDtd);
			}
			return baseReader;
		}
	}
	internal class XmlWrappingReader : XmlReader, IXmlLineInfo
	{
		protected XmlReader reader;

		protected IXmlLineInfo readerAsIXmlLineInfo;

		public override XmlReaderSettings Settings => reader.Settings;

		public override XmlNodeType NodeType => reader.NodeType;

		public override string Name => reader.Name;

		public override string LocalName => reader.LocalName;

		public override string NamespaceURI => reader.NamespaceURI;

		public override string Prefix => reader.Prefix;

		public override bool HasValue => reader.HasValue;

		public override string Value => reader.Value;

		public override int Depth => reader.Depth;

		public override string BaseURI => reader.BaseURI;

		public override bool IsEmptyElement => reader.IsEmptyElement;

		public override bool IsDefault => reader.IsDefault;

		public override char QuoteChar => reader.QuoteChar;

		public override XmlSpace XmlSpace => reader.XmlSpace;

		public override string XmlLang => reader.XmlLang;

		public override IXmlSchemaInfo SchemaInfo => reader.SchemaInfo;

		public override Type ValueType => reader.ValueType;

		public override int AttributeCount => reader.AttributeCount;

		public override bool CanResolveEntity => reader.CanResolveEntity;

		public override bool EOF => reader.EOF;

		public override ReadState ReadState => reader.ReadState;

		public override bool HasAttributes => reader.HasAttributes;

		public override XmlNameTable NameTable => reader.NameTable;

		public virtual int LineNumber
		{
			get
			{
				if (readerAsIXmlLineInfo != null)
				{
					return readerAsIXmlLineInfo.LineNumber;
				}
				return 0;
			}
		}

		public virtual int LinePosition
		{
			get
			{
				if (readerAsIXmlLineInfo != null)
				{
					return readerAsIXmlLineInfo.LinePosition;
				}
				return 0;
			}
		}

		protected XmlReader Reader
		{
			get
			{
				return reader;
			}
			set
			{
				reader = value;
				readerAsIXmlLineInfo = value as IXmlLineInfo;
			}
		}

		internal virtual SchemaInfo DtdSchemaInfo => XmlReader.GetDtdSchemaInfo(reader);

		internal XmlWrappingReader(XmlReader baseReader)
		{
			Reader = baseReader;
		}

		public override string GetAttribute(string name)
		{
			return reader.GetAttribute(name);
		}

		public override string GetAttribute(string name, string namespaceURI)
		{
			return reader.GetAttribute(name, namespaceURI);
		}

		public override string GetAttribute(int i)
		{
			return reader.GetAttribute(i);
		}

		public override bool MoveToAttribute(string name)
		{
			return reader.MoveToAttribute(name);
		}

		public override bool MoveToAttribute(string name, string ns)
		{
			return reader.MoveToAttribute(name, ns);
		}

		public override void MoveToAttribute(int i)
		{
			reader.MoveToAttribute(i);
		}

		public override bool MoveToFirstAttribute()
		{
			return reader.MoveToFirstAttribute();
		}

		public override bool MoveToNextAttribute()
		{
			return reader.MoveToNextAttribute();
		}

		public override bool MoveToElement()
		{
			return reader.MoveToElement();
		}

		public override bool Read()
		{
			return reader.Read();
		}

		public override void Close()
		{
			reader.Close();
		}

		public override void Skip()
		{
			reader.Skip();
		}

		public override string LookupNamespace(string prefix)
		{
			return reader.LookupNamespace(prefix);
		}

		public override void ResolveEntity()
		{
			reader.ResolveEntity();
		}

		public override bool ReadAttributeValue()
		{
			return reader.ReadAttributeValue();
		}

		protected override void Dispose(bool disposing)
		{
			((IDisposable)reader).Dispose();
		}

		public virtual bool HasLineInfo()
		{
			if (readerAsIXmlLineInfo != null)
			{
				return readerAsIXmlLineInfo.HasLineInfo();
			}
			return false;
		}
	}
	internal class XmlCharCheckingReader : XmlWrappingReader
	{
		private enum State
		{
			Initial,
			InReadBinary,
			Error,
			Interactive
		}

		private State state;

		private bool checkCharacters;

		private bool ignoreWhitespace;

		private bool ignoreComments;

		private bool ignorePis;

		private bool prohibitDtd;

		private XmlNodeType lastNodeType;

		private XmlCharType xmlCharType;

		private ReadContentAsBinaryHelper readBinaryHelper;

		public override XmlReaderSettings Settings
		{
			get
			{
				XmlReaderSettings settings = reader.Settings;
				settings = ((settings != null) ? settings.Clone() : new XmlReaderSettings());
				if (checkCharacters)
				{
					settings.CheckCharacters = true;
				}
				if (ignoreWhitespace)
				{
					settings.IgnoreWhitespace = true;
				}
				if (ignoreComments)
				{
					settings.IgnoreComments = true;
				}
				if (ignorePis)
				{
					settings.IgnoreProcessingInstructions = true;
				}
				if (prohibitDtd)
				{
					settings.ProhibitDtd = true;
				}
				settings.ReadOnly = true;
				return settings;
			}
		}

		public override ReadState ReadState => state switch
		{
			State.Initial => ReadState.Initial, 
			State.Error => ReadState.Error, 
			_ => reader.ReadState, 
		};

		public override bool CanReadBinaryContent => true;

		internal XmlCharCheckingReader(XmlReader reader, bool checkCharacters, bool ignoreWhitespace, bool ignoreComments, bool ignorePis, bool prohibitDtd)
			: base(reader)
		{
			state = State.Initial;
			this.checkCharacters = checkCharacters;
			this.ignoreWhitespace = ignoreWhitespace;
			this.ignoreComments = ignoreComments;
			this.ignorePis = ignorePis;
			this.prohibitDtd = prohibitDtd;
			lastNodeType = XmlNodeType.None;
			if (checkCharacters)
			{
				xmlCharType = XmlCharType.Instance;
			}
		}

		public override bool MoveToAttribute(string name)
		{
			if (state == State.InReadBinary)
			{
				FinishReadBinary();
			}
			return reader.MoveToAttribute(name);
		}

		public override bool MoveToAttribute(string name, string ns)
		{
			if (state == State.InReadBinary)
			{
				FinishReadBinary();
			}
			return reader.MoveToAttribute(name, ns);
		}

		public override void MoveToAttribute(int i)
		{
			if (state == State.InReadBinary)
			{
				FinishReadBinary();
			}
			reader.MoveToAttribute(i);
		}

		public override bool MoveToFirstAttribute()
		{
			if (state == State.InReadBinary)
			{
				FinishReadBinary();
			}
			return reader.MoveToFirstAttribute();
		}

		public override bool MoveToNextAttribute()
		{
			if (state == State.InReadBinary)
			{
				FinishReadBinary();
			}
			return reader.MoveToNextAttribute();
		}

		public override bool MoveToElement()
		{
			if (state == State.InReadBinary)
			{
				FinishReadBinary();
			}
			return reader.MoveToElement();
		}

		public override bool Read()
		{
			switch (state)
			{
			case State.Initial:
				state = State.Interactive;
				if (reader.ReadState != 0)
				{
					break;
				}
				goto case State.Interactive;
			case State.Error:
				return false;
			case State.InReadBinary:
				FinishReadBinary();
				state = State.Interactive;
				goto case State.Interactive;
			case State.Interactive:
				if (!reader.Read())
				{
					return false;
				}
				break;
			default:
				return false;
			}
			XmlNodeType nodeType = reader.NodeType;
			if (!checkCharacters)
			{
				switch (nodeType)
				{
				case XmlNodeType.Comment:
					if (ignoreComments)
					{
						return Read();
					}
					break;
				case XmlNodeType.Whitespace:
					if (ignoreWhitespace)
					{
						return Read();
					}
					break;
				case XmlNodeType.ProcessingInstruction:
					if (ignorePis)
					{
						return Read();
					}
					break;
				case XmlNodeType.DocumentType:
					if (prohibitDtd)
					{
						Throw("Xml_DtdIsProhibited", string.Empty);
					}
					break;
				}
				return true;
			}
			switch (nodeType)
			{
			case XmlNodeType.Element:
				if (!checkCharacters)
				{
					break;
				}
				ValidateQName(reader.Prefix, reader.LocalName);
				if (reader.MoveToFirstAttribute())
				{
					do
					{
						ValidateQName(reader.Prefix, reader.LocalName);
						CheckCharacters(reader.Value);
					}
					while (reader.MoveToNextAttribute());
					reader.MoveToElement();
				}
				break;
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
				if (checkCharacters)
				{
					CheckCharacters(reader.Value);
				}
				break;
			case XmlNodeType.EntityReference:
				if (checkCharacters)
				{
					ValidateQName(reader.Name);
				}
				break;
			case XmlNodeType.ProcessingInstruction:
				if (ignorePis)
				{
					return Read();
				}
				if (checkCharacters)
				{
					ValidateQName(reader.Name);
					CheckCharacters(reader.Value);
				}
				break;
			case XmlNodeType.Comment:
				if (ignoreComments)
				{
					return Read();
				}
				if (checkCharacters)
				{
					CheckCharacters(reader.Value);
				}
				break;
			case XmlNodeType.DocumentType:
				if (prohibitDtd)
				{
					Throw("Xml_DtdIsProhibited", string.Empty);
				}
				if (checkCharacters)
				{
					ValidateQName(reader.Name);
					CheckCharacters(reader.Value);
					string attribute = reader.GetAttribute("SYSTEM");
					if (attribute != null)
					{
						CheckCharacters(attribute);
					}
					attribute = reader.GetAttribute("PUBLIC");
					int index;
					if (attribute != null && (index = xmlCharType.IsPublicId(attribute)) >= 0)
					{
						Throw("Xml_InvalidCharacter", XmlException.BuildCharExceptionStr(attribute[index]));
					}
				}
				break;
			case XmlNodeType.Whitespace:
				if (ignoreWhitespace)
				{
					return Read();
				}
				if (checkCharacters)
				{
					CheckWhitespace(reader.Value);
				}
				break;
			case XmlNodeType.SignificantWhitespace:
				if (checkCharacters)
				{
					CheckWhitespace(reader.Value);
				}
				break;
			case XmlNodeType.EndElement:
				if (checkCharacters)
				{
					ValidateQName(reader.Prefix, reader.LocalName);
				}
				break;
			}
			lastNodeType = nodeType;
			return true;
		}

		public override void ResolveEntity()
		{
			reader.ResolveEntity();
		}

		public override bool ReadAttributeValue()
		{
			if (state == State.InReadBinary)
			{
				FinishReadBinary();
			}
			return reader.ReadAttributeValue();
		}

		public override int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (state != State.InReadBinary)
			{
				if (base.CanReadBinaryContent && !checkCharacters)
				{
					readBinaryHelper = null;
					state = State.InReadBinary;
					return base.ReadContentAsBase64(buffer, index, count);
				}
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
			}
			else if (readBinaryHelper == null)
			{
				return base.ReadContentAsBase64(buffer, index, count);
			}
			state = State.Interactive;
			int result = readBinaryHelper.ReadContentAsBase64(buffer, index, count);
			state = State.InReadBinary;
			return result;
		}

		public override int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (state != State.InReadBinary)
			{
				if (base.CanReadBinaryContent && !checkCharacters)
				{
					readBinaryHelper = null;
					state = State.InReadBinary;
					return base.ReadContentAsBinHex(buffer, index, count);
				}
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
			}
			else if (readBinaryHelper == null)
			{
				return base.ReadContentAsBinHex(buffer, index, count);
			}
			state = State.Interactive;
			int result = readBinaryHelper.ReadContentAsBinHex(buffer, index, count);
			state = State.InReadBinary;
			return result;
		}

		public override int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (state != State.InReadBinary)
			{
				if (base.CanReadBinaryContent && !checkCharacters)
				{
					readBinaryHelper = null;
					state = State.InReadBinary;
					return base.ReadElementContentAsBase64(buffer, index, count);
				}
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
			}
			else if (readBinaryHelper == null)
			{
				return base.ReadElementContentAsBase64(buffer, index, count);
			}
			state = State.Interactive;
			int result = readBinaryHelper.ReadElementContentAsBase64(buffer, index, count);
			state = State.InReadBinary;
			return result;
		}

		public override int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (state != State.InReadBinary)
			{
				if (base.CanReadBinaryContent && !checkCharacters)
				{
					readBinaryHelper = null;
					state = State.InReadBinary;
					return base.ReadElementContentAsBinHex(buffer, index, count);
				}
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
			}
			else if (readBinaryHelper == null)
			{
				return base.ReadElementContentAsBinHex(buffer, index, count);
			}
			state = State.Interactive;
			int result = readBinaryHelper.ReadElementContentAsBinHex(buffer, index, count);
			state = State.InReadBinary;
			return result;
		}

		private void Throw(string res, string arg)
		{
			state = State.Error;
			throw new XmlException(res, arg, (IXmlLineInfo)null);
		}

		private void Throw(string res, string[] args)
		{
			state = State.Error;
			throw new XmlException(res, args, (IXmlLineInfo)null);
		}

		private void CheckWhitespace(string value)
		{
			int index;
			if ((index = xmlCharType.IsOnlyWhitespaceWithPos(value)) != -1)
			{
				Throw("Xml_InvalidWhitespaceCharacter", XmlException.BuildCharExceptionStr(reader.Value[index]));
			}
		}

		private void ValidateQName(string name)
		{
			ValidateNames.ParseQNameThrow(name, out var _, out var _);
		}

		private void ValidateQName(string prefix, string localName)
		{
			try
			{
				if (prefix.Length > 0)
				{
					ValidateNames.ParseNCNameThrow(prefix);
				}
				ValidateNames.ParseNCNameThrow(localName);
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		private void CheckCharacters(string value)
		{
			XmlConvert.VerifyCharData(value, ExceptionType.XmlException);
		}

		private void FinishReadBinary()
		{
			state = State.Interactive;
			if (readBinaryHelper != null)
			{
				readBinaryHelper.Finish();
			}
		}
	}
	internal class XmlCharCheckingReaderWithNS : XmlCharCheckingReader, IXmlNamespaceResolver
	{
		internal IXmlNamespaceResolver readerAsNSResolver;

		internal XmlCharCheckingReaderWithNS(XmlReader reader, IXmlNamespaceResolver readerAsNSResolver, bool checkCharacters, bool ignoreWhitespace, bool ignoreComments, bool ignorePis, bool prohibitDtd)
			: base(reader, checkCharacters, ignoreWhitespace, ignoreComments, ignorePis, prohibitDtd)
		{
			this.readerAsNSResolver = readerAsNSResolver;
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return readerAsNSResolver.GetNamespacesInScope(scope);
		}

		string IXmlNamespaceResolver.LookupNamespace(string prefix)
		{
			return readerAsNSResolver.LookupNamespace(prefix);
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			return readerAsNSResolver.LookupPrefix(namespaceName);
		}
	}
	internal class XmlWrappingWriter : XmlWriter
	{
		protected XmlWriter writer;

		public override XmlWriterSettings Settings => writer.Settings;

		public override WriteState WriteState => writer.WriteState;

		public override XmlSpace XmlSpace => writer.XmlSpace;

		public override string XmlLang => writer.XmlLang;

		protected XmlWriter Writer
		{
			get
			{
				return writer;
			}
			set
			{
				writer = value;
			}
		}

		internal XmlWrappingWriter(XmlWriter baseWriter)
		{
			Writer = baseWriter;
		}

		public override void WriteStartDocument()
		{
			writer.WriteStartDocument();
		}

		public override void WriteStartDocument(bool standalone)
		{
			writer.WriteStartDocument(standalone);
		}

		public override void WriteEndDocument()
		{
			writer.WriteEndDocument();
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			writer.WriteDocType(name, pubid, sysid, subset);
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			writer.WriteStartElement(prefix, localName, ns);
		}

		public override void WriteEndElement()
		{
			writer.WriteEndElement();
		}

		public override void WriteFullEndElement()
		{
			writer.WriteFullEndElement();
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			writer.WriteStartAttribute(prefix, localName, ns);
		}

		public override void WriteEndAttribute()
		{
			writer.WriteEndAttribute();
		}

		public override void WriteCData(string text)
		{
			writer.WriteCData(text);
		}

		public override void WriteComment(string text)
		{
			writer.WriteComment(text);
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			writer.WriteProcessingInstruction(name, text);
		}

		public override void WriteEntityRef(string name)
		{
			writer.WriteEntityRef(name);
		}

		public override void WriteCharEntity(char ch)
		{
			writer.WriteCharEntity(ch);
		}

		public override void WriteWhitespace(string ws)
		{
			writer.WriteWhitespace(ws);
		}

		public override void WriteString(string text)
		{
			writer.WriteString(text);
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			writer.WriteSurrogateCharEntity(lowChar, highChar);
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			writer.WriteChars(buffer, index, count);
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			writer.WriteRaw(buffer, index, count);
		}

		public override void WriteRaw(string data)
		{
			writer.WriteRaw(data);
		}

		public override void WriteBase64(byte[] buffer, int index, int count)
		{
			writer.WriteBase64(buffer, index, count);
		}

		public override void Close()
		{
			writer.Close();
		}

		public override void Flush()
		{
			writer.Flush();
		}

		public override string LookupPrefix(string ns)
		{
			return writer.LookupPrefix(ns);
		}

		public override void WriteValue(object value)
		{
			writer.WriteValue(value);
		}

		public override void WriteValue(string value)
		{
			writer.WriteValue(value);
		}

		public override void WriteValue(bool value)
		{
			writer.WriteValue(value);
		}

		public override void WriteValue(DateTime value)
		{
			writer.WriteValue(value);
		}

		public override void WriteValue(double value)
		{
			writer.WriteValue(value);
		}

		public override void WriteValue(float value)
		{
			writer.WriteValue(value);
		}

		public override void WriteValue(decimal value)
		{
			writer.WriteValue(value);
		}

		public override void WriteValue(int value)
		{
			writer.WriteValue(value);
		}

		public override void WriteValue(long value)
		{
			writer.WriteValue(value);
		}

		protected override void Dispose(bool disposing)
		{
			((IDisposable)writer).Dispose();
		}
	}
	internal class XmlCharCheckingWriter : XmlWrappingWriter
	{
		private bool checkValues;

		private bool checkNames;

		private bool replaceNewLines;

		private string newLineChars;

		private XmlCharType xmlCharType;

		public override XmlWriterSettings Settings
		{
			get
			{
				XmlWriterSettings settings = writer.Settings;
				settings = ((settings != null) ? settings.Clone() : new XmlWriterSettings());
				if (checkValues)
				{
					settings.CheckCharacters = true;
				}
				if (replaceNewLines)
				{
					settings.NewLineHandling = NewLineHandling.Replace;
					settings.NewLineChars = newLineChars;
				}
				settings.ReadOnly = true;
				return settings;
			}
		}

		internal XmlCharCheckingWriter(XmlWriter baseWriter, bool checkValues, bool checkNames, bool replaceNewLines, string newLineChars)
			: base(baseWriter)
		{
			this.checkValues = checkValues;
			this.checkNames = checkNames;
			this.replaceNewLines = replaceNewLines;
			this.newLineChars = newLineChars;
			if (checkValues)
			{
				xmlCharType = XmlCharType.Instance;
			}
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			if (checkNames)
			{
				ValidateQName(name);
			}
			if (checkValues)
			{
				int index;
				if (pubid != null && (index = xmlCharType.IsPublicId(pubid)) >= 0)
				{
					throw XmlConvert.CreateInvalidCharException(pubid[index]);
				}
				if (sysid != null)
				{
					CheckCharacters(sysid);
				}
				if (subset != null)
				{
					CheckCharacters(subset);
				}
			}
			if (replaceNewLines)
			{
				sysid = ReplaceNewLines(sysid);
				pubid = ReplaceNewLines(pubid);
				subset = ReplaceNewLines(subset);
			}
			writer.WriteDocType(name, pubid, sysid, subset);
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			if (checkNames)
			{
				if (localName == null || localName.Length == 0)
				{
					throw new ArgumentException(Res.GetString("Xml_EmptyLocalName"));
				}
				ValidateNCName(localName);
				if (prefix != null && prefix.Length > 0)
				{
					ValidateNCName(prefix);
				}
			}
			writer.WriteStartElement(prefix, localName, ns);
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (checkNames)
			{
				if (localName == null || localName.Length == 0)
				{
					throw new ArgumentException(Res.GetString("Xml_EmptyLocalName"));
				}
				ValidateNCName(localName);
				if (prefix != null && prefix.Length > 0)
				{
					ValidateNCName(prefix);
				}
			}
			writer.WriteStartAttribute(prefix, localName, ns);
		}

		public override void WriteCData(string text)
		{
			if (text != null)
			{
				if (checkValues)
				{
					CheckCharacters(text);
				}
				if (replaceNewLines)
				{
					text = ReplaceNewLines(text);
				}
				int num;
				while ((num = text.IndexOf("]]>", StringComparison.Ordinal)) >= 0)
				{
					writer.WriteCData(text.Substring(0, num + 2));
					text = text.Substring(num + 2);
				}
			}
			writer.WriteCData(text);
		}

		public override void WriteComment(string text)
		{
			if (text != null)
			{
				if (checkValues)
				{
					CheckCharacters(text);
					text = InterleaveInvalidChars(text, '-', '-');
				}
				if (replaceNewLines)
				{
					text = ReplaceNewLines(text);
				}
			}
			writer.WriteComment(text);
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			if (checkNames)
			{
				ValidateNCName(name);
			}
			if (text != null)
			{
				if (checkValues)
				{
					CheckCharacters(text);
					text = InterleaveInvalidChars(text, '?', '>');
				}
				if (replaceNewLines)
				{
					text = ReplaceNewLines(text);
				}
			}
			writer.WriteProcessingInstruction(name, text);
		}

		public override void WriteEntityRef(string name)
		{
			if (checkNames)
			{
				ValidateQName(name);
			}
			writer.WriteEntityRef(name);
		}

		public override void WriteWhitespace(string ws)
		{
			int index;
			if (checkNames && (index = xmlCharType.IsOnlyWhitespaceWithPos(ws)) != -1)
			{
				throw new ArgumentException(Res.GetString("Xml_InvalidWhitespaceCharacter", XmlException.BuildCharExceptionStr(ws[index])));
			}
			writer.WriteWhitespace(ws);
		}

		public override void WriteString(string text)
		{
			if (text != null)
			{
				if (checkValues)
				{
					CheckCharacters(text);
				}
				if (replaceNewLines && WriteState != WriteState.Attribute)
				{
					text = ReplaceNewLines(text);
				}
			}
			writer.WriteString(text);
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			writer.WriteSurrogateCharEntity(lowChar, highChar);
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			if (checkValues)
			{
				CheckCharacters(buffer, index, count);
			}
			if (replaceNewLines && WriteState != WriteState.Attribute)
			{
				string text = ReplaceNewLines(buffer, index, count);
				if (text != null)
				{
					WriteString(text);
					return;
				}
			}
			writer.WriteChars(buffer, index, count);
		}

		public override void WriteNmToken(string name)
		{
			if (checkNames)
			{
				if (name == null || name.Length == 0)
				{
					throw new ArgumentException(Res.GetString("Xml_EmptyName"));
				}
				XmlConvert.VerifyNMTOKEN(name);
			}
			writer.WriteNmToken(name);
		}

		public override void WriteName(string name)
		{
			if (checkNames)
			{
				XmlConvert.VerifyQName(name);
			}
			writer.WriteName(name);
		}

		public override void WriteQualifiedName(string localName, string ns)
		{
			if (checkNames)
			{
				ValidateNCName(localName);
			}
			writer.WriteQualifiedName(localName, ns);
		}

		private void CheckCharacters(string str)
		{
			XmlConvert.VerifyCharData(str, ExceptionType.ArgumentException);
		}

		private void CheckCharacters(char[] data, int offset, int len)
		{
			XmlConvert.VerifyCharData(data, offset, len, ExceptionType.ArgumentException);
		}

		private void ValidateNCName(string ncname)
		{
			if (ncname.Length == 0)
			{
				throw new ArgumentException(Res.GetString("Xml_EmptyName"));
			}
			int num = ValidateNames.ParseNCName(ncname, 0);
			if (num != ncname.Length)
			{
				throw new ArgumentException(Res.GetString((num == 0) ? "Xml_BadStartNameChar" : "Xml_BadNameChar", XmlException.BuildCharExceptionStr(ncname[num])));
			}
		}

		private void ValidateQName(string name)
		{
			if (name.Length == 0)
			{
				throw new ArgumentException(Res.GetString("Xml_EmptyName"));
			}
			int colonOffset;
			int num = ValidateNames.ParseQName(name, 0, out colonOffset);
			if (num != name.Length)
			{
				string name2 = ((num == 0 || (colonOffset > -1 && num == colonOffset + 1)) ? "Xml_BadStartNameChar" : "Xml_BadNameChar");
				throw new ArgumentException(Res.GetString(name2, XmlException.BuildCharExceptionStr(name[num])));
			}
		}

		private string ReplaceNewLines(string str)
		{
			if (str == null)
			{
				return null;
			}
			StringBuilder stringBuilder = null;
			int num = 0;
			int i;
			for (i = 0; i < str.Length; i++)
			{
				char c;
				if ((c = str[i]) >= ' ')
				{
					continue;
				}
				if (c == '\n')
				{
					if (newLineChars == "\n")
					{
						continue;
					}
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(str.Length + 5);
					}
					stringBuilder.Append(str, num, i - num);
				}
				else
				{
					if (c != '\r')
					{
						continue;
					}
					if (i + 1 < str.Length && str[i + 1] == '\n')
					{
						if (newLineChars == "\r\n")
						{
							i++;
							continue;
						}
						if (stringBuilder == null)
						{
							stringBuilder = new StringBuilder(str.Length + 5);
						}
						stringBuilder.Append(str, num, i - num);
						i++;
					}
					else
					{
						if (newLineChars == "\r")
						{
							continue;
						}
						if (stringBuilder == null)
						{
							stringBuilder = new StringBuilder(str.Length + 5);
						}
						stringBuilder.Append(str, num, i - num);
					}
				}
				stringBuilder.Append(newLineChars);
				num = i + 1;
			}
			if (stringBuilder == null)
			{
				return str;
			}
			stringBuilder.Append(str, num, i - num);
			return stringBuilder.ToString();
		}

		private string ReplaceNewLines(char[] data, int offset, int len)
		{
			if (data == null)
			{
				return null;
			}
			StringBuilder stringBuilder = null;
			int num = offset;
			int num2 = offset + len;
			int i;
			for (i = offset; i < num2; i++)
			{
				char c;
				if ((c = data[i]) >= ' ')
				{
					continue;
				}
				if (c == '\n')
				{
					if (newLineChars == "\n")
					{
						continue;
					}
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(len + 5);
					}
					stringBuilder.Append(data, num, i - num);
				}
				else
				{
					if (c != '\r')
					{
						continue;
					}
					if (i + 1 < num2 && data[i + 1] == '\n')
					{
						if (newLineChars == "\r\n")
						{
							continue;
						}
						if (stringBuilder == null)
						{
							stringBuilder = new StringBuilder(len + 5);
						}
						stringBuilder.Append(data, num, i - num);
						i++;
					}
					else
					{
						if (newLineChars == "\r")
						{
							continue;
						}
						if (stringBuilder == null)
						{
							stringBuilder = new StringBuilder(len + 5);
						}
						stringBuilder.Append(data, num, i - num);
					}
				}
				stringBuilder.Append(newLineChars);
				num = i + 1;
			}
			if (stringBuilder == null)
			{
				return null;
			}
			stringBuilder.Append(data, num, i - num);
			return stringBuilder.ToString();
		}

		private string InterleaveInvalidChars(string text, char invChar1, char invChar2)
		{
			StringBuilder stringBuilder = null;
			int num = 0;
			int i;
			for (i = 0; i < text.Length; i++)
			{
				if (text[i] == invChar2 && i > 0 && text[i - 1] == invChar1)
				{
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(text.Length + 5);
					}
					stringBuilder.Append(text, num, i - num);
					stringBuilder.Append(' ');
					num = i;
				}
			}
			if (stringBuilder == null)
			{
				if (i != 0 && text[i - 1] == invChar1)
				{
					return text + ' ';
				}
				return text;
			}
			stringBuilder.Append(text, num, i - num);
			if (i > 0 && text[i - 1] == invChar1)
			{
				stringBuilder.Append(' ');
			}
			return stringBuilder.ToString();
		}
	}
}
namespace System.Xml.XmlConfiguration
{
	internal static class XmlConfigurationString
	{
		internal const string XmlReaderSectionName = "xmlReader";

		internal const string XmlTextReaderSectionName = "xmlTextReader";

		internal const string XsltSectionName = "xslt";

		internal const string ProhibitDefaultResolverName = "prohibitDefaultResolver";

		internal const string LimitCharactersFromEntitiesName = "limitCharactersFromEntities";

		internal const string LimitXPathComplexityName = "limitXPathComplexity";

		internal const string EnableMemberAccessForXslCompiledTransformName = "enableMemberAccessForXslCompiledTransform";

		internal const string XmlConfigurationSectionName = "system.xml";

		internal static string XmlReaderSectionPath = string.Format(CultureInfo.InvariantCulture, "{0}/{1}", "system.xml", "xmlReader");

		internal static string XmlTextReaderSectionPath = string.Format(CultureInfo.InvariantCulture, "{0}/{1}", "system.xml", "xmlTextReader");

		internal static string XsltSectionPath = string.Format(CultureInfo.InvariantCulture, "{0}/{1}", "system.xml", "xslt");
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	internal sealed class XmlReaderSection : ConfigurationSection
	{
		[ConfigurationProperty("prohibitDefaultResolver", DefaultValue = "false")]
		internal string ProhibitDefaultResolverString
		{
			get
			{
				return (string)base["prohibitDefaultResolver"];
			}
			set
			{
				base["prohibitDefaultResolver"] = value;
			}
		}

		private bool _ProhibitDefaultResolver
		{
			get
			{
				string prohibitDefaultResolverString = ProhibitDefaultResolverString;
				XmlConvert.TryToBoolean(prohibitDefaultResolverString, out var result);
				return result;
			}
		}

		internal static bool ProhibitDefaultUrlResolver
		{
			get
			{
				if (!(ConfigurationManager.GetSection(XmlConfigurationString.XmlReaderSectionPath) is XmlReaderSection xmlReaderSection))
				{
					return false;
				}
				return xmlReaderSection._ProhibitDefaultResolver;
			}
		}

		internal static XmlResolver CreateDefaultResolver()
		{
			if (ProhibitDefaultUrlResolver)
			{
				return null;
			}
			return new XmlUrlResolver();
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	internal sealed class XmlTextReaderSection : ConfigurationSection
	{
		[ConfigurationProperty("limitCharactersFromEntities", DefaultValue = "true")]
		internal string LimitCharactersFromEntitiesString
		{
			get
			{
				return (string)base["limitCharactersFromEntities"];
			}
			set
			{
				base["limitCharactersFromEntities"] = value;
			}
		}

		private bool _LimitCharactersFromEntities
		{
			get
			{
				string limitCharactersFromEntitiesString = LimitCharactersFromEntitiesString;
				bool result = true;
				XmlConvert.TryToBoolean(limitCharactersFromEntitiesString, out result);
				return result;
			}
		}

		internal static bool LimitCharactersFromEntities
		{
			get
			{
				if (!(ConfigurationManager.GetSection(XmlConfigurationString.XmlTextReaderSectionPath) is XmlTextReaderSection xmlTextReaderSection))
				{
					return true;
				}
				return xmlTextReaderSection._LimitCharactersFromEntities;
			}
		}
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	internal sealed class XsltConfigSection : ConfigurationSection
	{
		[ConfigurationProperty("prohibitDefaultResolver", DefaultValue = "false")]
		internal string ProhibitDefaultResolverString
		{
			get
			{
				return (string)base["prohibitDefaultResolver"];
			}
			set
			{
				base["prohibitDefaultResolver"] = value;
			}
		}

		private bool _ProhibitDefaultResolver
		{
			get
			{
				string prohibitDefaultResolverString = ProhibitDefaultResolverString;
				XmlConvert.TryToBoolean(prohibitDefaultResolverString, out var result);
				return result;
			}
		}

		private static bool s_ProhibitDefaultUrlResolver
		{
			get
			{
				if (!(ConfigurationManager.GetSection(XmlConfigurationString.XsltSectionPath) is XsltConfigSection xsltConfigSection))
				{
					return false;
				}
				return xsltConfigSection._ProhibitDefaultResolver;
			}
		}

		[ConfigurationProperty("limitXPathComplexity", DefaultValue = "true")]
		internal string LimitXPathComplexityString
		{
			get
			{
				return (string)base["limitXPathComplexity"];
			}
			set
			{
				base["limitXPathComplexity"] = value;
			}
		}

		private bool _LimitXPathComplexity
		{
			get
			{
				string limitXPathComplexityString = LimitXPathComplexityString;
				bool result = true;
				XmlConvert.TryToBoolean(limitXPathComplexityString, out result);
				return result;
			}
		}

		public static bool LimitXPathComplexity
		{
			get
			{
				if (!(ConfigurationManager.GetSection(XmlConfigurationString.XsltSectionPath) is XsltConfigSection xsltConfigSection))
				{
					return true;
				}
				return xsltConfigSection._LimitXPathComplexity;
			}
		}

		[ConfigurationProperty("enableMemberAccessForXslCompiledTransform", DefaultValue = "False")]
		internal string EnableMemberAccessForXslCompiledTransformString
		{
			get
			{
				return (string)base["enableMemberAccessForXslCompiledTransform"];
			}
			set
			{
				base["enableMemberAccessForXslCompiledTransform"] = value;
			}
		}

		private bool _EnableMemberAccessForXslCompiledTransform
		{
			get
			{
				string enableMemberAccessForXslCompiledTransformString = EnableMemberAccessForXslCompiledTransformString;
				bool result = false;
				XmlConvert.TryToBoolean(enableMemberAccessForXslCompiledTransformString, out result);
				return result;
			}
		}

		internal static bool EnableMemberAccessForXslCompiledTransform
		{
			get
			{
				if (!(ConfigurationManager.GetSection(XmlConfigurationString.XsltSectionPath) is XsltConfigSection xsltConfigSection))
				{
					return false;
				}
				return xsltConfigSection._EnableMemberAccessForXslCompiledTransform;
			}
		}

		internal static XmlResolver CreateDefaultResolver()
		{
			if (s_ProhibitDefaultUrlResolver)
			{
				return XmlNullResolver.Singleton;
			}
			return new XmlUrlResolver();
		}
	}
}
namespace System.Xml
{
	internal class XmlEncodedRawTextWriterIndent : XmlEncodedRawTextWriter
	{
		protected int indentLevel;

		protected bool newLineOnAttributes;

		protected string indentChars;

		protected bool mixedContent;

		private BitStack mixedContentStack;

		protected ConformanceLevel conformanceLevel;

		public override XmlWriterSettings Settings
		{
			get
			{
				XmlWriterSettings settings = base.Settings;
				settings.ReadOnly = false;
				settings.Indent = true;
				settings.IndentChars = indentChars;
				settings.NewLineOnAttributes = newLineOnAttributes;
				settings.ReadOnly = true;
				return settings;
			}
		}

		public XmlEncodedRawTextWriterIndent(TextWriter writer, XmlWriterSettings settings)
			: base(writer, settings)
		{
			Init(settings);
		}

		public XmlEncodedRawTextWriterIndent(Stream stream, Encoding encoding, XmlWriterSettings settings, bool closeOutput)
			: base(stream, encoding, settings, closeOutput)
		{
			Init(settings);
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			if (!mixedContent && textPos != bufPos)
			{
				WriteIndent();
			}
			base.WriteDocType(name, pubid, sysid, subset);
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			if (!mixedContent && textPos != bufPos)
			{
				WriteIndent();
			}
			indentLevel++;
			mixedContentStack.PushBit(mixedContent);
			base.WriteStartElement(prefix, localName, ns);
		}

		internal override void StartElementContent()
		{
			if (indentLevel == 1 && conformanceLevel == ConformanceLevel.Document)
			{
				mixedContent = false;
			}
			else
			{
				mixedContent = mixedContentStack.PeekBit();
			}
			base.StartElementContent();
		}

		internal override void OnRootElement(ConformanceLevel currentConformanceLevel)
		{
			conformanceLevel = currentConformanceLevel;
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			indentLevel--;
			if (!mixedContent && contentPos != bufPos && textPos != bufPos)
			{
				WriteIndent();
			}
			mixedContent = mixedContentStack.PopBit();
			base.WriteEndElement(prefix, localName, ns);
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			indentLevel--;
			if (!mixedContent && contentPos != bufPos && textPos != bufPos)
			{
				WriteIndent();
			}
			mixedContent = mixedContentStack.PopBit();
			base.WriteFullEndElement(prefix, localName, ns);
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (newLineOnAttributes)
			{
				WriteIndent();
			}
			base.WriteStartAttribute(prefix, localName, ns);
		}

		public override void WriteCData(string text)
		{
			mixedContent = true;
			base.WriteCData(text);
		}

		public override void WriteComment(string text)
		{
			if (!mixedContent && textPos != bufPos)
			{
				WriteIndent();
			}
			base.WriteComment(text);
		}

		public override void WriteProcessingInstruction(string target, string text)
		{
			if (!mixedContent && textPos != bufPos)
			{
				WriteIndent();
			}
			base.WriteProcessingInstruction(target, text);
		}

		public override void WriteEntityRef(string name)
		{
			mixedContent = true;
			base.WriteEntityRef(name);
		}

		public override void WriteCharEntity(char ch)
		{
			mixedContent = true;
			base.WriteCharEntity(ch);
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			mixedContent = true;
			base.WriteSurrogateCharEntity(lowChar, highChar);
		}

		public override void WriteWhitespace(string ws)
		{
			mixedContent = true;
			base.WriteWhitespace(ws);
		}

		public override void WriteString(string text)
		{
			mixedContent = true;
			base.WriteString(text);
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			mixedContent = true;
			base.WriteChars(buffer, index, count);
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			mixedContent = true;
			base.WriteRaw(buffer, index, count);
		}

		public override void WriteRaw(string data)
		{
			mixedContent = true;
			base.WriteRaw(data);
		}

		public override void WriteBase64(byte[] buffer, int index, int count)
		{
			mixedContent = true;
			base.WriteBase64(buffer, index, count);
		}

		private void Init(XmlWriterSettings settings)
		{
			indentLevel = 0;
			indentChars = settings.IndentChars;
			newLineOnAttributes = settings.NewLineOnAttributes;
			mixedContentStack = new BitStack();
			if (!checkCharacters)
			{
				return;
			}
			if (newLineOnAttributes)
			{
				ValidateContentChars(indentChars, "IndentChars", allowOnlyWhitespace: true);
				ValidateContentChars(newLineChars, "NewLineChars", allowOnlyWhitespace: true);
				return;
			}
			ValidateContentChars(indentChars, "IndentChars", allowOnlyWhitespace: false);
			if (newLineHandling != 0)
			{
				ValidateContentChars(newLineChars, "NewLineChars", allowOnlyWhitespace: false);
			}
		}

		private void WriteIndent()
		{
			RawText(newLineChars);
			for (int num = indentLevel; num > 0; num--)
			{
				RawText(indentChars);
			}
		}
	}
	internal sealed class XmlEventCache : XmlRawWriter
	{
		private enum XmlEventType
		{
			Unknown,
			DocType,
			StartElem,
			StartAttr,
			EndAttr,
			CData,
			Comment,
			PI,
			Whitespace,
			String,
			Raw,
			EntRef,
			CharEnt,
			SurrCharEnt,
			Base64,
			BinHex,
			XmlDecl1,
			XmlDecl2,
			StartContent,
			EndElem,
			FullEndElem,
			Nmsp,
			EndBase64,
			Close,
			Flush,
			Dispose
		}

		private struct XmlEvent
		{
			private XmlEventType eventType;

			private string s1;

			private string s2;

			private string s3;

			private object o;

			public XmlEventType EventType => eventType;

			public string String1 => s1;

			public string String2 => s2;

			public string String3 => s3;

			public object Object => o;

			public void InitEvent(XmlEventType eventType)
			{
				this.eventType = eventType;
			}

			public void InitEvent(XmlEventType eventType, string s1)
			{
				this.eventType = eventType;
				this.s1 = s1;
			}

			public void InitEvent(XmlEventType eventType, string s1, string s2)
			{
				this.eventType = eventType;
				this.s1 = s1;
				this.s2 = s2;
			}

			public void InitEvent(XmlEventType eventType, string s1, string s2, string s3)
			{
				this.eventType = eventType;
				this.s1 = s1;
				this.s2 = s2;
				this.s3 = s3;
			}

			public void InitEvent(XmlEventType eventType, string s1, string s2, string s3, object o)
			{
				this.eventType = eventType;
				this.s1 = s1;
				this.s2 = s2;
				this.s3 = s3;
				this.o = o;
			}

			public void InitEvent(XmlEventType eventType, object o)
			{
				this.eventType = eventType;
				this.o = o;
			}
		}

		private const int InitialPageSize = 32;

		private ArrayList pages;

		private XmlEvent[] pageCurr;

		private int pageSize;

		private bool hasRootNode;

		private StringConcat singleText;

		private string baseUri;

		public string BaseUri => baseUri;

		public bool HasRootNode => hasRootNode;

		public override XmlWriterSettings Settings => null;

		public XmlEventCache(string baseUri, bool hasRootNode)
		{
			this.baseUri = baseUri;
			this.hasRootNode = hasRootNode;
		}

		public void EndEvents()
		{
			if (singleText.Count == 0)
			{
				AddEvent(XmlEventType.Unknown);
			}
		}

		public void EventsToWriter(XmlWriter writer)
		{
			if (singleText.Count != 0)
			{
				writer.WriteString(singleText.GetResult());
				return;
			}
			XmlRawWriter xmlRawWriter = writer as XmlRawWriter;
			for (int i = 0; i < pages.Count; i++)
			{
				XmlEvent[] array = pages[i] as XmlEvent[];
				for (int j = 0; j < array.Length; j++)
				{
					switch (array[j].EventType)
					{
					case XmlEventType.Unknown:
						return;
					case XmlEventType.DocType:
						writer.WriteDocType(array[j].String1, array[j].String2, array[j].String3, (string)array[j].Object);
						break;
					case XmlEventType.StartElem:
						writer.WriteStartElement(array[j].String1, array[j].String2, array[j].String3);
						break;
					case XmlEventType.StartAttr:
						writer.WriteStartAttribute(array[j].String1, array[j].String2, array[j].String3);
						break;
					case XmlEventType.EndAttr:
						writer.WriteEndAttribute();
						break;
					case XmlEventType.CData:
						writer.WriteCData(array[j].String1);
						break;
					case XmlEventType.Comment:
						writer.WriteComment(array[j].String1);
						break;
					case XmlEventType.PI:
						writer.WriteProcessingInstruction(array[j].String1, array[j].String2);
						break;
					case XmlEventType.Whitespace:
						writer.WriteWhitespace(array[j].String1);
						break;
					case XmlEventType.String:
						writer.WriteString(array[j].String1);
						break;
					case XmlEventType.Raw:
						writer.WriteRaw(array[j].String1);
						break;
					case XmlEventType.EntRef:
						writer.WriteEntityRef(array[j].String1);
						break;
					case XmlEventType.CharEnt:
						writer.WriteCharEntity((char)array[j].Object);
						break;
					case XmlEventType.SurrCharEnt:
					{
						char[] array3 = (char[])array[j].Object;
						writer.WriteSurrogateCharEntity(array3[0], array3[1]);
						break;
					}
					case XmlEventType.Base64:
					{
						byte[] array2 = (byte[])array[j].Object;
						writer.WriteBase64(array2, 0, array2.Length);
						break;
					}
					case XmlEventType.BinHex:
					{
						byte[] array2 = (byte[])array[j].Object;
						writer.WriteBinHex(array2, 0, array2.Length);
						break;
					}
					case XmlEventType.XmlDecl1:
						xmlRawWriter?.WriteXmlDeclaration((XmlStandalone)array[j].Object);
						break;
					case XmlEventType.XmlDecl2:
						xmlRawWriter?.WriteXmlDeclaration(array[j].String1);
						break;
					case XmlEventType.StartContent:
						xmlRawWriter?.StartElementContent();
						break;
					case XmlEventType.EndElem:
						if (xmlRawWriter != null)
						{
							xmlRawWriter.WriteEndElement(array[j].String1, array[j].String2, array[j].String3);
						}
						else
						{
							writer.WriteEndElement();
						}
						break;
					case XmlEventType.FullEndElem:
						if (xmlRawWriter != null)
						{
							xmlRawWriter.WriteFullEndElement(array[j].String1, array[j].String2, array[j].String3);
						}
						else
						{
							writer.WriteFullEndElement();
						}
						break;
					case XmlEventType.Nmsp:
						if (xmlRawWriter != null)
						{
							xmlRawWriter.WriteNamespaceDeclaration(array[j].String1, array[j].String2);
						}
						else
						{
							writer.WriteAttributeString("xmlns", array[j].String1, "http://www.w3.org/2000/xmlns/", array[j].String2);
						}
						break;
					case XmlEventType.EndBase64:
						xmlRawWriter?.WriteEndBase64();
						break;
					case XmlEventType.Close:
						writer.Close();
						break;
					case XmlEventType.Flush:
						writer.Flush();
						break;
					case XmlEventType.Dispose:
						((IDisposable)writer).Dispose();
						break;
					}
				}
			}
		}

		public string EventsToString()
		{
			if (singleText.Count != 0)
			{
				return singleText.GetResult();
			}
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = false;
			for (int i = 0; i < pages.Count; i++)
			{
				XmlEvent[] array = pages[i] as XmlEvent[];
				for (int j = 0; j < array.Length; j++)
				{
					switch (array[j].EventType)
					{
					case XmlEventType.Unknown:
						return stringBuilder.ToString();
					case XmlEventType.CData:
					case XmlEventType.Whitespace:
					case XmlEventType.String:
					case XmlEventType.Raw:
						if (!flag)
						{
							stringBuilder.Append(array[j].String1);
						}
						break;
					case XmlEventType.StartAttr:
						flag = true;
						break;
					case XmlEventType.EndAttr:
						flag = false;
						break;
					}
				}
			}
			return string.Empty;
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			AddEvent(XmlEventType.DocType, name, pubid, sysid, subset);
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			AddEvent(XmlEventType.StartElem, prefix, localName, ns);
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			AddEvent(XmlEventType.StartAttr, prefix, localName, ns);
		}

		public override void WriteEndAttribute()
		{
			AddEvent(XmlEventType.EndAttr);
		}

		public override void WriteCData(string text)
		{
			AddEvent(XmlEventType.CData, text);
		}

		public override void WriteComment(string text)
		{
			AddEvent(XmlEventType.Comment, text);
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			AddEvent(XmlEventType.PI, name, text);
		}

		public override void WriteWhitespace(string ws)
		{
			AddEvent(XmlEventType.Whitespace, ws);
		}

		public override void WriteString(string text)
		{
			if (pages == null)
			{
				singleText.ConcatNoDelimiter(text);
			}
			else
			{
				AddEvent(XmlEventType.String, text);
			}
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			WriteString(new string(buffer, index, count));
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			WriteRaw(new string(buffer, index, count));
		}

		public override void WriteRaw(string data)
		{
			AddEvent(XmlEventType.Raw, data);
		}

		public override void WriteEntityRef(string name)
		{
			AddEvent(XmlEventType.EntRef, name);
		}

		public override void WriteCharEntity(char ch)
		{
			AddEvent(XmlEventType.CharEnt, ch);
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			char[] o = new char[2] { lowChar, highChar };
			AddEvent(XmlEventType.SurrCharEnt, o);
		}

		public override void WriteBase64(byte[] buffer, int index, int count)
		{
			AddEvent(XmlEventType.Base64, ToBytes(buffer, index, count));
		}

		public override void WriteBinHex(byte[] buffer, int index, int count)
		{
			AddEvent(XmlEventType.BinHex, ToBytes(buffer, index, count));
		}

		public override void Close()
		{
			AddEvent(XmlEventType.Close);
		}

		public override void Flush()
		{
			AddEvent(XmlEventType.Flush);
		}

		public override void WriteValue(object value)
		{
			WriteString(XmlUntypedConverter.Untyped.ToString(value, resolver));
		}

		public override void WriteValue(string value)
		{
			WriteString(value);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				AddEvent(XmlEventType.Dispose);
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
			AddEvent(XmlEventType.XmlDecl1, standalone);
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
			AddEvent(XmlEventType.XmlDecl2, xmldecl);
		}

		internal override void StartElementContent()
		{
			AddEvent(XmlEventType.StartContent);
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			AddEvent(XmlEventType.EndElem, prefix, localName, ns);
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			AddEvent(XmlEventType.FullEndElem, prefix, localName, ns);
		}

		internal override void WriteNamespaceDeclaration(string prefix, string ns)
		{
			AddEvent(XmlEventType.Nmsp, prefix, ns);
		}

		internal override void WriteEndBase64()
		{
			AddEvent(XmlEventType.EndBase64);
		}

		private void AddEvent(XmlEventType eventType)
		{
			int num = NewEvent();
			pageCurr[num].InitEvent(eventType);
		}

		private void AddEvent(XmlEventType eventType, string s1)
		{
			int num = NewEvent();
			pageCurr[num].InitEvent(eventType, s1);
		}

		private void AddEvent(XmlEventType eventType, string s1, string s2)
		{
			int num = NewEvent();
			pageCurr[num].InitEvent(eventType, s1, s2);
		}

		private void AddEvent(XmlEventType eventType, string s1, string s2, string s3)
		{
			int num = NewEvent();
			pageCurr[num].InitEvent(eventType, s1, s2, s3);
		}

		private void AddEvent(XmlEventType eventType, string s1, string s2, string s3, object o)
		{
			int num = NewEvent();
			pageCurr[num].InitEvent(eventType, s1, s2, s3, o);
		}

		private void AddEvent(XmlEventType eventType, object o)
		{
			int num = NewEvent();
			pageCurr[num].InitEvent(eventType, o);
		}

		private int NewEvent()
		{
			if (pages == null)
			{
				pages = new ArrayList();
				pageCurr = new XmlEvent[32];
				pages.Add(pageCurr);
				if (singleText.Count != 0)
				{
					pageCurr[0].InitEvent(XmlEventType.String, singleText.GetResult());
					pageSize++;
					singleText.Clear();
				}
			}
			else if (pageSize >= pageCurr.Length)
			{
				pageCurr = new XmlEvent[pageSize * 2];
				pages.Add(pageCurr);
				pageSize = 0;
			}
			return pageSize++;
		}

		private static byte[] ToBytes(byte[] buffer, int index, int count)
		{
			if (index != 0 || count != buffer.Length)
			{
				if (buffer.Length - index > count)
				{
					count = buffer.Length - index;
				}
				byte[] array = new byte[count];
				Array.Copy(buffer, index, array, 0, count);
				return array;
			}
			return buffer;
		}
	}
	public class XmlParserContext
	{
		private XmlNameTable _nt;

		private XmlNamespaceManager _nsMgr;

		private string _docTypeName = string.Empty;

		private string _pubId = string.Empty;

		private string _sysId = string.Empty;

		private string _internalSubset = string.Empty;

		private string _xmlLang = string.Empty;

		private XmlSpace _xmlSpace;

		private string _baseURI = string.Empty;

		private Encoding _encoding;

		public XmlNameTable NameTable
		{
			get
			{
				return _nt;
			}
			set
			{
				_nt = value;
			}
		}

		public XmlNamespaceManager NamespaceManager
		{
			get
			{
				return _nsMgr;
			}
			set
			{
				_nsMgr = value;
			}
		}

		public string DocTypeName
		{
			get
			{
				return _docTypeName;
			}
			set
			{
				_docTypeName = ((value == null) ? string.Empty : value);
			}
		}

		public string PublicId
		{
			get
			{
				return _pubId;
			}
			set
			{
				_pubId = ((value == null) ? string.Empty : value);
			}
		}

		public string SystemId
		{
			get
			{
				return _sysId;
			}
			set
			{
				_sysId = ((value == null) ? string.Empty : value);
			}
		}

		public string BaseURI
		{
			get
			{
				return _baseURI;
			}
			set
			{
				_baseURI = ((value == null) ? string.Empty : value);
			}
		}

		public string InternalSubset
		{
			get
			{
				return _internalSubset;
			}
			set
			{
				_internalSubset = ((value == null) ? string.Empty : value);
			}
		}

		public string XmlLang
		{
			get
			{
				return _xmlLang;
			}
			set
			{
				_xmlLang = ((value == null) ? string.Empty : value);
			}
		}

		public XmlSpace XmlSpace
		{
			get
			{
				return _xmlSpace;
			}
			set
			{
				_xmlSpace = value;
			}
		}

		public Encoding Encoding
		{
			get
			{
				return _encoding;
			}
			set
			{
				_encoding = value;
			}
		}

		internal bool HasDtdInfo
		{
			get
			{
				if (!(_internalSubset != string.Empty) && !(_pubId != string.Empty))
				{
					return _sysId != string.Empty;
				}
				return true;
			}
		}

		public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string xmlLang, XmlSpace xmlSpace)
			: this(nt, nsMgr, null, null, null, null, string.Empty, xmlLang, xmlSpace)
		{
		}

		public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string xmlLang, XmlSpace xmlSpace, Encoding enc)
			: this(nt, nsMgr, null, null, null, null, string.Empty, xmlLang, xmlSpace, enc)
		{
		}

		public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string docTypeName, string pubId, string sysId, string internalSubset, string baseURI, string xmlLang, XmlSpace xmlSpace)
			: this(nt, nsMgr, docTypeName, pubId, sysId, internalSubset, baseURI, xmlLang, xmlSpace, null)
		{
		}

		public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string docTypeName, string pubId, string sysId, string internalSubset, string baseURI, string xmlLang, XmlSpace xmlSpace, Encoding enc)
		{
			if (nsMgr != null)
			{
				if (nt == null)
				{
					_nt = nsMgr.NameTable;
				}
				else
				{
					if (nt != nsMgr.NameTable)
					{
						throw new XmlException("Xml_NotSameNametable", string.Empty);
					}
					_nt = nt;
				}
			}
			else
			{
				_nt = nt;
			}
			_nsMgr = nsMgr;
			_docTypeName = ((docTypeName == null) ? string.Empty : docTypeName);
			_pubId = ((pubId == null) ? string.Empty : pubId);
			_sysId = ((sysId == null) ? string.Empty : sysId);
			_internalSubset = ((internalSubset == null) ? string.Empty : internalSubset);
			_baseURI = ((baseURI == null) ? string.Empty : baseURI);
			_xmlLang = ((xmlLang == null) ? string.Empty : xmlLang);
			_xmlSpace = xmlSpace;
			_encoding = enc;
		}
	}
	public sealed class XmlReaderSettings
	{
		private XmlNameTable nameTable;

		private XmlResolver xmlResolver;

		private int lineNumberOffset;

		private int linePositionOffset;

		private ConformanceLevel conformanceLevel;

		private bool checkCharacters;

		private long maxCharactersInDocument;

		private long maxCharactersFromEntities;

		private ValidationType validationType;

		private XmlSchemaValidationFlags validationFlags;

		private XmlSchemaSet schemas;

		private ValidationEventHandler valEventHandler;

		private bool ignoreWhitespace;

		private bool ignorePIs;

		private bool ignoreComments;

		private bool prohibitDtd;

		private bool closeInput;

		private bool isReadOnly;

		private bool isXmlResolverSet;

		public XmlNameTable NameTable
		{
			get
			{
				return nameTable;
			}
			set
			{
				CheckReadOnly("NameTable");
				nameTable = value;
			}
		}

		internal bool IsXmlResolverSet
		{
			get
			{
				return isXmlResolverSet;
			}
			private set
			{
				isXmlResolverSet = value;
			}
		}

		public XmlResolver XmlResolver
		{
			set
			{
				CheckReadOnly("XmlResolver");
				xmlResolver = value;
				IsXmlResolverSet = true;
			}
		}

		public int LineNumberOffset
		{
			get
			{
				return lineNumberOffset;
			}
			set
			{
				CheckReadOnly("LineNumberOffset");
				if (lineNumberOffset < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				lineNumberOffset = value;
			}
		}

		public int LinePositionOffset
		{
			get
			{
				return linePositionOffset;
			}
			set
			{
				CheckReadOnly("LinePositionOffset");
				if (linePositionOffset < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				linePositionOffset = value;
			}
		}

		public ConformanceLevel ConformanceLevel
		{
			get
			{
				return conformanceLevel;
			}
			set
			{
				CheckReadOnly("ConformanceLevel");
				if ((uint)value > 2u)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				conformanceLevel = value;
			}
		}

		public bool CheckCharacters
		{
			get
			{
				return checkCharacters;
			}
			set
			{
				CheckReadOnly("CheckCharacters");
				checkCharacters = value;
			}
		}

		public long MaxCharactersInDocument
		{
			get
			{
				return maxCharactersInDocument;
			}
			set
			{
				CheckReadOnly("MaxCharactersInDocument");
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				maxCharactersInDocument = value;
			}
		}

		public long MaxCharactersFromEntities
		{
			get
			{
				return maxCharactersFromEntities;
			}
			set
			{
				CheckReadOnly("MaxCharactersFromEntities");
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				maxCharactersFromEntities = value;
			}
		}

		public ValidationType ValidationType
		{
			get
			{
				return validationType;
			}
			set
			{
				CheckReadOnly("ValidationType");
				if ((uint)value > 4u)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				validationType = value;
			}
		}

		public XmlSchemaValidationFlags ValidationFlags
		{
			get
			{
				return validationFlags;
			}
			set
			{
				CheckReadOnly("ValidationFlags");
				if ((uint)value > 31u)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				validationFlags = value;
			}
		}

		public XmlSchemaSet Schemas
		{
			get
			{
				if (schemas == null)
				{
					schemas = new XmlSchemaSet();
				}
				return schemas;
			}
			set
			{
				CheckReadOnly("Schemas");
				schemas = value;
			}
		}

		public bool IgnoreWhitespace
		{
			get
			{
				return ignoreWhitespace;
			}
			set
			{
				CheckReadOnly("IgnoreWhitespace");
				ignoreWhitespace = value;
			}
		}

		public bool IgnoreProcessingInstructions
		{
			get
			{
				return ignorePIs;
			}
			set
			{
				CheckReadOnly("IgnoreProcessingInstructions");
				ignorePIs = value;
			}
		}

		public bool IgnoreComments
		{
			get
			{
				return ignoreComments;
			}
			set
			{
				CheckReadOnly("IgnoreComments");
				ignoreComments = value;
			}
		}

		public bool ProhibitDtd
		{
			get
			{
				return prohibitDtd;
			}
			set
			{
				CheckReadOnly("ProhibitDtd");
				prohibitDtd = value;
			}
		}

		public bool CloseInput
		{
			get
			{
				return closeInput;
			}
			set
			{
				CheckReadOnly("CloseInput");
				closeInput = value;
			}
		}

		internal bool ReadOnly
		{
			get
			{
				return isReadOnly;
			}
			set
			{
				isReadOnly = value;
			}
		}

		internal bool CanResolveExternals
		{
			get
			{
				if (!prohibitDtd)
				{
					return xmlResolver != null;
				}
				return false;
			}
		}

		public event ValidationEventHandler ValidationEventHandler
		{
			add
			{
				CheckReadOnly("ValidationEventHandler");
				valEventHandler = (ValidationEventHandler)Delegate.Combine(valEventHandler, value);
			}
			remove
			{
				CheckReadOnly("ValidationEventHandler");
				valEventHandler = (ValidationEventHandler)Delegate.Remove(valEventHandler, value);
			}
		}

		public XmlReaderSettings()
		{
			Reset();
		}

		internal XmlResolver GetXmlResolver()
		{
			return xmlResolver;
		}

		internal XmlResolver GetXmlResolver_CheckConfig()
		{
			if (XmlReaderSection.ProhibitDefaultUrlResolver && !IsXmlResolverSet)
			{
				return null;
			}
			return xmlResolver;
		}

		public void Reset()
		{
			CheckReadOnly("Reset");
			nameTable = null;
			xmlResolver = CreateDefaultResolver();
			lineNumberOffset = 0;
			linePositionOffset = 0;
			checkCharacters = true;
			conformanceLevel = ConformanceLevel.Document;
			schemas = null;
			validationType = ValidationType.None;
			validationFlags = XmlSchemaValidationFlags.ProcessIdentityConstraints;
			validationFlags |= XmlSchemaValidationFlags.AllowXmlAttributes;
			ignoreWhitespace = false;
			ignorePIs = false;
			ignoreComments = false;
			prohibitDtd = true;
			closeInput = false;
			maxCharactersFromEntities = 0L;
			maxCharactersInDocument = 0L;
			isReadOnly = false;
			IsXmlResolverSet = false;
		}

		private static XmlResolver CreateDefaultResolver()
		{
			return new XmlUrlResolver();
		}

		public XmlReaderSettings Clone()
		{
			XmlReaderSettings xmlReaderSettings = MemberwiseClone() as XmlReaderSettings;
			xmlReaderSettings.isReadOnly = false;
			return xmlReaderSettings;
		}

		internal ValidationEventHandler GetEventHandler()
		{
			return valEventHandler;
		}

		private void CheckReadOnly(string propertyName)
		{
			if (isReadOnly)
			{
				throw new XmlException("Xml_ReadOnlyProperty", "XmlReaderSettings." + propertyName);
			}
		}
	}
	public enum XmlSpace
	{
		None,
		Default,
		Preserve
	}
	internal sealed class XmlSubtreeReader : XmlWrappingReader, IXmlNamespaceResolver
	{
		private class NodeData
		{
			internal XmlNodeType type;

			internal string localName;

			internal string prefix;

			internal string name;

			internal string namespaceUri;

			internal string value;

			internal NodeData()
			{
			}

			internal void Set(XmlNodeType nodeType, string localName, string prefix, string name, string namespaceUri, string value)
			{
				type = nodeType;
				this.localName = localName;
				this.prefix = prefix;
				this.name = name;
				this.namespaceUri = namespaceUri;
				this.value = value;
			}
		}

		private enum State
		{
			Initial,
			Interactive,
			Error,
			EndOfFile,
			Closed,
			PopNamespaceScope,
			ClearNsAttributes,
			ReadElementContentAsBase64,
			ReadElementContentAsBinHex,
			ReadContentAsBase64,
			ReadContentAsBinHex
		}

		private const int AttributeActiveStates = 98;

		private const int NamespaceActiveStates = 2018;

		private int initialDepth;

		private State state;

		private XmlNamespaceManager nsManager;

		private NodeData[] nsAttributes;

		private int nsAttrCount;

		private int curNsAttr = -1;

		private string xmlns;

		private string xmlnsUri;

		private bool useCurNode;

		private NodeData curNode;

		private NodeData tmpNode;

		internal int InitialNamespaceAttributeCount = 4;

		public override XmlReaderSettings Settings => reader.Settings;

		public override XmlNodeType NodeType
		{
			get
			{
				if (!useCurNode)
				{
					return reader.NodeType;
				}
				return curNode.type;
			}
		}

		public override string Name
		{
			get
			{
				if (!useCurNode)
				{
					return reader.Name;
				}
				return curNode.name;
			}
		}

		public override string LocalName
		{
			get
			{
				if (!useCurNode)
				{
					return reader.LocalName;
				}
				return curNode.localName;
			}
		}

		public override string NamespaceURI
		{
			get
			{
				if (!useCurNode)
				{
					return reader.NamespaceURI;
				}
				return curNode.namespaceUri;
			}
		}

		public override string Prefix
		{
			get
			{
				if (!useCurNode)
				{
					return reader.Prefix;
				}
				return curNode.prefix;
			}
		}

		public override string Value
		{
			get
			{
				if (!useCurNode)
				{
					return reader.Value;
				}
				return curNode.value;
			}
		}

		public override int Depth
		{
			get
			{
				int num = reader.Depth - initialDepth;
				if (curNsAttr != -1)
				{
					num = ((curNode.type != XmlNodeType.Text) ? (num + 1) : (num + 2));
				}
				return num;
			}
		}

		public override string BaseURI => reader.BaseURI;

		public override bool CanResolveEntity => reader.CanResolveEntity;

		public override bool EOF
		{
			get
			{
				if (state != State.EndOfFile)
				{
					return state == State.Closed;
				}
				return true;
			}
		}

		public override ReadState ReadState
		{
			get
			{
				if (reader.ReadState == ReadState.Error)
				{
					return ReadState.Error;
				}
				if (state <= State.Closed)
				{
					return (ReadState)state;
				}
				return ReadState.Interactive;
			}
		}

		public override XmlNameTable NameTable => reader.NameTable;

		public override int AttributeCount
		{
			get
			{
				if (!InAttributeActiveState)
				{
					return 0;
				}
				return reader.AttributeCount + nsAttrCount;
			}
		}

		public override bool CanReadBinaryContent => reader.CanReadBinaryContent;

		public override bool CanReadValueChunk => reader.CanReadValueChunk;

		public override int LineNumber
		{
			get
			{
				if (readerAsIXmlLineInfo != null && !useCurNode)
				{
					return readerAsIXmlLineInfo.LineNumber;
				}
				return 0;
			}
		}

		public override int LinePosition
		{
			get
			{
				if (readerAsIXmlLineInfo != null && !useCurNode)
				{
					return readerAsIXmlLineInfo.LinePosition;
				}
				return 0;
			}
		}

		internal override SchemaInfo DtdSchemaInfo => null;

		private bool InAttributeActiveState => 0 != (0x62 & (1 << (int)state));

		private bool InNamespaceActiveState => 0 != (0x7E2 & (1 << (int)state));

		internal XmlSubtreeReader(XmlReader reader)
			: base(reader)
		{
			initialDepth = reader.Depth;
			state = State.Initial;
			nsManager = new XmlNamespaceManager(reader.NameTable);
			xmlns = reader.NameTable.Add("xmlns");
			xmlnsUri = reader.NameTable.Add("http://www.w3.org/2000/xmlns/");
			tmpNode = new NodeData();
			tmpNode.Set(XmlNodeType.None, string.Empty, string.Empty, string.Empty, string.Empty, string.Empty);
			SetCurrentNode(tmpNode);
		}

		public override string GetAttribute(string name)
		{
			if (!InAttributeActiveState)
			{
				return null;
			}
			string attribute = reader.GetAttribute(name);
			if (attribute != null)
			{
				return attribute;
			}
			for (int i = 0; i < nsAttrCount; i++)
			{
				if (name == nsAttributes[i].name)
				{
					return nsAttributes[i].value;
				}
			}
			return null;
		}

		public override string GetAttribute(string name, string namespaceURI)
		{
			if (!InAttributeActiveState)
			{
				return null;
			}
			string attribute = reader.GetAttribute(name, namespaceURI);
			if (attribute != null)
			{
				return attribute;
			}
			for (int i = 0; i < nsAttrCount; i++)
			{
				if (name == nsAttributes[i].localName && namespaceURI == xmlnsUri)
				{
					return nsAttributes[i].value;
				}
			}
			return null;
		}

		public override string GetAttribute(int i)
		{
			if (!InAttributeActiveState)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			int attributeCount = reader.AttributeCount;
			if (i < attributeCount)
			{
				return reader.GetAttribute(i);
			}
			if (i - attributeCount < nsAttrCount)
			{
				return nsAttributes[i - attributeCount].value;
			}
			throw new ArgumentOutOfRangeException("i");
		}

		public override bool MoveToAttribute(string name)
		{
			if (!InAttributeActiveState)
			{
				return false;
			}
			if (reader.MoveToAttribute(name))
			{
				curNsAttr = -1;
				useCurNode = false;
				return true;
			}
			for (int i = 0; i < nsAttrCount; i++)
			{
				if (name == nsAttributes[i].name)
				{
					MoveToNsAttribute(i);
					return true;
				}
			}
			return false;
		}

		public override bool MoveToAttribute(string name, string ns)
		{
			if (!InAttributeActiveState)
			{
				return false;
			}
			if (reader.MoveToAttribute(name, ns))
			{
				curNsAttr = -1;
				useCurNode = false;
				return true;
			}
			for (int i = 0; i < nsAttrCount; i++)
			{
				if (name == nsAttributes[i].localName && ns == xmlnsUri)
				{
					MoveToNsAttribute(i);
					return true;
				}
			}
			return false;
		}

		public override void MoveToAttribute(int i)
		{
			if (!InAttributeActiveState)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			int attributeCount = reader.AttributeCount;
			if (i < attributeCount)
			{
				reader.MoveToAttribute(i);
				curNsAttr = -1;
				useCurNode = false;
				return;
			}
			if (i - attributeCount < nsAttrCount)
			{
				MoveToNsAttribute(i - attributeCount);
				return;
			}
			throw new ArgumentOutOfRangeException("i");
		}

		public override bool MoveToFirstAttribute()
		{
			if (!InAttributeActiveState)
			{
				return false;
			}
			if (reader.MoveToFirstAttribute())
			{
				useCurNode = false;
				return true;
			}
			if (nsAttrCount > 0)
			{
				MoveToNsAttribute(0);
				return true;
			}
			return false;
		}

		public override bool MoveToNextAttribute()
		{
			if (!InAttributeActiveState)
			{
				return false;
			}
			if (curNsAttr == -1 && reader.MoveToNextAttribute())
			{
				return true;
			}
			if (curNsAttr + 1 < nsAttrCount)
			{
				MoveToNsAttribute(curNsAttr + 1);
				return true;
			}
			return false;
		}

		public override bool MoveToElement()
		{
			if (!InAttributeActiveState)
			{
				return false;
			}
			curNsAttr = -1;
			useCurNode = false;
			return reader.MoveToElement();
		}

		public override bool ReadAttributeValue()
		{
			if (!InAttributeActiveState)
			{
				return false;
			}
			if (curNsAttr == -1)
			{
				return reader.ReadAttributeValue();
			}
			if (curNode.type == XmlNodeType.Text)
			{
				return false;
			}
			tmpNode.type = XmlNodeType.Text;
			tmpNode.value = curNode.value;
			SetCurrentNode(tmpNode);
			return true;
		}

		public override bool Read()
		{
			switch (state)
			{
			case State.Initial:
				useCurNode = false;
				state = State.Interactive;
				ProcessNamespaces();
				return true;
			case State.Interactive:
				curNsAttr = -1;
				useCurNode = false;
				reader.MoveToElement();
				if (reader.Depth == initialDepth && (reader.NodeType == XmlNodeType.EndElement || (reader.NodeType == XmlNodeType.Element && reader.IsEmptyElement)))
				{
					state = State.EndOfFile;
					SetEmptyNode();
					return false;
				}
				if (reader.Read())
				{
					ProcessNamespaces();
					return true;
				}
				SetEmptyNode();
				return false;
			case State.EndOfFile:
			case State.Closed:
				return false;
			case State.PopNamespaceScope:
				nsManager.PopScope();
				goto case State.ClearNsAttributes;
			case State.ClearNsAttributes:
				nsAttrCount = 0;
				state = State.Interactive;
				goto case State.Interactive;
			case State.ReadElementContentAsBase64:
			case State.ReadElementContentAsBinHex:
				if (!FinishReadElementContentAsBinary())
				{
					return false;
				}
				return Read();
			case State.ReadContentAsBase64:
			case State.ReadContentAsBinHex:
				if (!FinishReadContentAsBinary())
				{
					return false;
				}
				return Read();
			default:
				return false;
			}
		}

		public override void Close()
		{
			if (state == State.Closed)
			{
				return;
			}
			try
			{
				if (state != State.EndOfFile)
				{
					reader.MoveToElement();
					if (reader.Depth == initialDepth && reader.NodeType == XmlNodeType.Element && !reader.IsEmptyElement)
					{
						reader.Read();
					}
					while (reader.Depth > initialDepth && reader.Read())
					{
					}
				}
			}
			catch
			{
			}
			finally
			{
				curNsAttr = -1;
				useCurNode = false;
				state = State.Closed;
				SetEmptyNode();
			}
		}

		public override void Skip()
		{
			switch (state)
			{
			case State.Initial:
				Read();
				break;
			case State.Interactive:
				curNsAttr = -1;
				useCurNode = false;
				reader.MoveToElement();
				if (reader.Depth == initialDepth)
				{
					if (reader.NodeType == XmlNodeType.Element && !reader.IsEmptyElement && reader.Read())
					{
						while (reader.NodeType != XmlNodeType.EndElement && reader.Depth > initialDepth)
						{
							reader.Skip();
						}
					}
					state = State.EndOfFile;
					SetEmptyNode();
				}
				else
				{
					if (reader.NodeType == XmlNodeType.Element && !reader.IsEmptyElement)
					{
						nsManager.PopScope();
					}
					reader.Skip();
					ProcessNamespaces();
				}
				break;
			case State.EndOfFile:
			case State.Closed:
				break;
			case State.PopNamespaceScope:
				nsManager.PopScope();
				goto case State.ClearNsAttributes;
			case State.ClearNsAttributes:
				nsAttrCount = 0;
				state = State.Interactive;
				goto case State.Interactive;
			case State.ReadElementContentAsBase64:
			case State.ReadElementContentAsBinHex:
				if (FinishReadElementContentAsBinary())
				{
					Skip();
				}
				break;
			case State.ReadContentAsBase64:
			case State.ReadContentAsBinHex:
				if (FinishReadContentAsBinary())
				{
					Skip();
				}
				break;
			case State.Error:
				break;
			}
		}

		public override object ReadContentAsObject()
		{
			try
			{
				InitReadContentAsType("ReadContentAsObject");
				object result = reader.ReadContentAsObject();
				FinishReadContentAsType();
				return result;
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		public override bool ReadContentAsBoolean()
		{
			try
			{
				InitReadContentAsType("ReadContentAsBoolean");
				bool result = reader.ReadContentAsBoolean();
				FinishReadContentAsType();
				return result;
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		public override DateTime ReadContentAsDateTime()
		{
			try
			{
				InitReadContentAsType("ReadContentAsDateTime");
				DateTime result = reader.ReadContentAsDateTime();
				FinishReadContentAsType();
				return result;
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		public override double ReadContentAsDouble()
		{
			try
			{
				InitReadContentAsType("ReadContentAsDouble");
				double result = reader.ReadContentAsDouble();
				FinishReadContentAsType();
				return result;
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		public override float ReadContentAsFloat()
		{
			try
			{
				InitReadContentAsType("ReadContentAsFloat");
				float result = reader.ReadContentAsFloat();
				FinishReadContentAsType();
				return result;
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		public override decimal ReadContentAsDecimal()
		{
			try
			{
				InitReadContentAsType("ReadContentAsDecimal");
				decimal result = reader.ReadContentAsDecimal();
				FinishReadContentAsType();
				return result;
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		public override int ReadContentAsInt()
		{
			try
			{
				InitReadContentAsType("ReadContentAsInt");
				int result = reader.ReadContentAsInt();
				FinishReadContentAsType();
				return result;
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		public override long ReadContentAsLong()
		{
			try
			{
				InitReadContentAsType("ReadContentAsLong");
				long result = reader.ReadContentAsLong();
				FinishReadContentAsType();
				return result;
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		public override string ReadContentAsString()
		{
			try
			{
				InitReadContentAsType("ReadContentAsString");
				string result = reader.ReadContentAsString();
				FinishReadContentAsType();
				return result;
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		public override object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver)
		{
			try
			{
				InitReadContentAsType("ReadContentAs");
				object result = reader.ReadContentAs(returnType, namespaceResolver);
				FinishReadContentAsType();
				return result;
			}
			catch
			{
				state = State.Error;
				throw;
			}
		}

		public override int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			switch (state)
			{
			case State.Initial:
			case State.EndOfFile:
			case State.Closed:
				return 0;
			case State.PopNamespaceScope:
			case State.ClearNsAttributes:
				switch (NodeType)
				{
				case XmlNodeType.Element:
					throw CreateReadContentAsException("ReadContentAsBase64");
				case XmlNodeType.EndElement:
					return 0;
				case XmlNodeType.Attribute:
				case XmlNodeType.Text:
					return reader.ReadContentAsBase64(buffer, index, count);
				default:
					return 0;
				}
			case State.Interactive:
				state = State.ReadContentAsBase64;
				goto case State.ReadContentAsBase64;
			case State.ReadContentAsBase64:
			{
				int num = reader.ReadContentAsBase64(buffer, index, count);
				if (num == 0)
				{
					state = State.Interactive;
					ProcessNamespaces();
				}
				return num;
			}
			case State.ReadElementContentAsBase64:
			case State.ReadElementContentAsBinHex:
			case State.ReadContentAsBinHex:
				throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
			default:
				return 0;
			}
		}

		public override int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			switch (state)
			{
			case State.Initial:
			case State.EndOfFile:
			case State.Closed:
				return 0;
			case State.Interactive:
			case State.PopNamespaceScope:
			case State.ClearNsAttributes:
				if (!InitReadElementContentAsBinary(State.ReadElementContentAsBase64))
				{
					return 0;
				}
				goto case State.ReadElementContentAsBase64;
			case State.ReadElementContentAsBase64:
			{
				int num = reader.ReadContentAsBase64(buffer, index, count);
				if (num > 0)
				{
					return num;
				}
				if (NodeType != XmlNodeType.EndElement)
				{
					throw new XmlException("Xml_InvalidNodeType", reader.NodeType.ToString(), reader as IXmlLineInfo);
				}
				state = State.Interactive;
				ProcessNamespaces();
				if (reader.Depth == initialDepth)
				{
					state = State.EndOfFile;
					SetEmptyNode();
				}
				else
				{
					Read();
				}
				return 0;
			}
			case State.ReadElementContentAsBinHex:
			case State.ReadContentAsBase64:
			case State.ReadContentAsBinHex:
				throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
			default:
				return 0;
			}
		}

		public override int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			switch (state)
			{
			case State.Initial:
			case State.EndOfFile:
			case State.Closed:
				return 0;
			case State.PopNamespaceScope:
			case State.ClearNsAttributes:
				switch (NodeType)
				{
				case XmlNodeType.Element:
					throw CreateReadContentAsException("ReadContentAsBinHex");
				case XmlNodeType.EndElement:
					return 0;
				case XmlNodeType.Attribute:
				case XmlNodeType.Text:
					return reader.ReadContentAsBinHex(buffer, index, count);
				default:
					return 0;
				}
			case State.Interactive:
				state = State.ReadContentAsBinHex;
				goto case State.ReadContentAsBinHex;
			case State.ReadContentAsBinHex:
			{
				int num = reader.ReadContentAsBinHex(buffer, index, count);
				if (num == 0)
				{
					state = State.Interactive;
					ProcessNamespaces();
				}
				return num;
			}
			case State.ReadElementContentAsBase64:
			case State.ReadElementContentAsBinHex:
			case State.ReadContentAsBase64:
				throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
			default:
				return 0;
			}
		}

		public override int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			switch (state)
			{
			case State.Initial:
			case State.EndOfFile:
			case State.Closed:
				return 0;
			case State.Interactive:
			case State.PopNamespaceScope:
			case State.ClearNsAttributes:
				if (!InitReadElementContentAsBinary(State.ReadElementContentAsBinHex))
				{
					return 0;
				}
				goto case State.ReadElementContentAsBinHex;
			case State.ReadElementContentAsBinHex:
			{
				int num = reader.ReadContentAsBinHex(buffer, index, count);
				if (num > 0)
				{
					return num;
				}
				if (NodeType != XmlNodeType.EndElement)
				{
					throw new XmlException("Xml_InvalidNodeType", reader.NodeType.ToString(), reader as IXmlLineInfo);
				}
				state = State.Interactive;
				ProcessNamespaces();
				if (reader.Depth == initialDepth)
				{
					state = State.EndOfFile;
					SetEmptyNode();
				}
				else
				{
					Read();
				}
				return 0;
			}
			case State.ReadElementContentAsBase64:
			case State.ReadContentAsBase64:
			case State.ReadContentAsBinHex:
				throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
			default:
				return 0;
			}
		}

		public override int ReadValueChunk(char[] buffer, int index, int count)
		{
			switch (state)
			{
			case State.Initial:
			case State.Error:
			case State.EndOfFile:
			case State.Closed:
				return 0;
			case State.Interactive:
			case State.PopNamespaceScope:
			case State.ClearNsAttributes:
				return reader.ReadValueChunk(buffer, index, count);
			case State.ReadElementContentAsBase64:
			case State.ReadElementContentAsBinHex:
			case State.ReadContentAsBase64:
			case State.ReadContentAsBinHex:
				throw new InvalidOperationException(Res.GetString("Xml_MixingReadValueChunkWithBinary"));
			default:
				return 0;
			}
		}

		protected override void Dispose(bool disposing)
		{
			Close();
		}

		public override string LookupNamespace(string prefix)
		{
			return ((IXmlNamespaceResolver)this).LookupNamespace(prefix);
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			if (!InNamespaceActiveState)
			{
				return new Dictionary<string, string>();
			}
			return nsManager.GetNamespacesInScope(scope);
		}

		string IXmlNamespaceResolver.LookupNamespace(string prefix)
		{
			if (!InNamespaceActiveState)
			{
				return null;
			}
			return nsManager.LookupNamespace(prefix);
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			if (!InNamespaceActiveState)
			{
				return null;
			}
			return nsManager.LookupPrefix(namespaceName);
		}

		private void ProcessNamespaces()
		{
			switch (reader.NodeType)
			{
			case XmlNodeType.Element:
			{
				nsManager.PushScope();
				string prefix = reader.Prefix;
				string namespaceURI = reader.NamespaceURI;
				if (nsManager.LookupNamespace(prefix) != namespaceURI)
				{
					AddNamespace(prefix, namespaceURI);
				}
				if (reader.MoveToFirstAttribute())
				{
					do
					{
						prefix = reader.Prefix;
						namespaceURI = reader.NamespaceURI;
						if (Ref.Equal(namespaceURI, xmlnsUri))
						{
							if (prefix.Length == 0)
							{
								nsManager.AddNamespace(string.Empty, reader.Value);
								RemoveNamespace(string.Empty, xmlns);
							}
							else
							{
								prefix = reader.LocalName;
								nsManager.AddNamespace(prefix, reader.Value);
								RemoveNamespace(xmlns, prefix);
							}
						}
						else if (prefix.Length != 0 && nsManager.LookupNamespace(prefix) != namespaceURI)
						{
							AddNamespace(prefix, namespaceURI);
						}
					}
					while (reader.MoveToNextAttribute());
					reader.MoveToElement();
				}
				if (reader.IsEmptyElement)
				{
					state = State.PopNamespaceScope;
				}
				break;
			}
			case XmlNodeType.EndElement:
				state = State.PopNamespaceScope;
				break;
			}
		}

		private void AddNamespace(string prefix, string ns)
		{
			nsManager.AddNamespace(prefix, ns);
			int num = nsAttrCount++;
			if (nsAttributes == null)
			{
				nsAttributes = new NodeData[InitialNamespaceAttributeCount];
			}
			if (num == nsAttributes.Length)
			{
				NodeData[] destinationArray = new NodeData[nsAttributes.Length * 2];
				Array.Copy(nsAttributes, 0, destinationArray, 0, num);
				nsAttributes = destinationArray;
			}
			if (nsAttributes[num] == null)
			{
				nsAttributes[num] = new NodeData();
			}
			if (prefix.Length == 0)
			{
				nsAttributes[num].Set(XmlNodeType.Attribute, xmlns, string.Empty, xmlns, "http://www.w3.org/2000/xmlns/", ns);
			}
			else
			{
				nsAttributes[num].Set(XmlNodeType.Attribute, prefix, xmlns, xmlns + ":" + prefix, "http://www.w3.org/2000/xmlns/", ns);
			}
			state = State.ClearNsAttributes;
			curNsAttr = -1;
		}

		private void RemoveNamespace(string prefix, string localName)
		{
			for (int i = 0; i < nsAttrCount; i++)
			{
				if (Ref.Equal(prefix, nsAttributes[i].prefix) && Ref.Equal(localName, nsAttributes[i].localName))
				{
					if (i < nsAttrCount - 1)
					{
						NodeData nodeData = nsAttributes[i];
						nsAttributes[i] = nsAttributes[nsAttrCount - 1];
						nsAttributes[nsAttrCount - 1] = nodeData;
					}
					nsAttrCount--;
					break;
				}
			}
		}

		private void MoveToNsAttribute(int index)
		{
			reader.MoveToElement();
			curNsAttr = index;
			SetCurrentNode(nsAttributes[index]);
		}

		private bool InitReadElementContentAsBinary(State binaryState)
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw reader.CreateReadElementContentAsException("ReadElementContentAsBase64");
			}
			bool isEmptyElement = IsEmptyElement;
			if (!Read() || isEmptyElement)
			{
				return false;
			}
			switch (NodeType)
			{
			case XmlNodeType.Element:
				throw new XmlException("Xml_InvalidNodeType", reader.NodeType.ToString(), reader as IXmlLineInfo);
			case XmlNodeType.EndElement:
				ProcessNamespaces();
				Read();
				return false;
			default:
				state = binaryState;
				return true;
			}
		}

		private bool FinishReadElementContentAsBinary()
		{
			byte[] buffer = new byte[256];
			if (state == State.ReadElementContentAsBase64)
			{
				while (reader.ReadContentAsBase64(buffer, 0, 256) > 0)
				{
				}
			}
			else
			{
				while (reader.ReadContentAsBinHex(buffer, 0, 256) > 0)
				{
				}
			}
			if (NodeType != XmlNodeType.EndElement)
			{
				throw new XmlException("Xml_InvalidNodeType", reader.NodeType.ToString(), reader as IXmlLineInfo);
			}
			state = State.Interactive;
			ProcessNamespaces();
			if (reader.Depth == initialDepth)
			{
				state = State.EndOfFile;
				SetEmptyNode();
				return false;
			}
			return Read();
		}

		private bool FinishReadContentAsBinary()
		{
			byte[] buffer = new byte[256];
			if (state == State.ReadContentAsBase64)
			{
				while (reader.ReadContentAsBase64(buffer, 0, 256) > 0)
				{
				}
			}
			else
			{
				while (reader.ReadContentAsBinHex(buffer, 0, 256) > 0)
				{
				}
			}
			state = State.Interactive;
			ProcessNamespaces();
			if (reader.Depth == initialDepth)
			{
				state = State.EndOfFile;
				SetEmptyNode();
				return false;
			}
			return true;
		}

		private void SetEmptyNode()
		{
			tmpNode.type = XmlNodeType.None;
			tmpNode.value = string.Empty;
			curNode = tmpNode;
			useCurNode = true;
		}

		private void SetCurrentNode(NodeData node)
		{
			curNode = node;
			useCurNode = true;
		}

		private void InitReadContentAsType(string methodName)
		{
			switch (state)
			{
			case State.Interactive:
			case State.PopNamespaceScope:
			case State.ClearNsAttributes:
				break;
			case State.ReadElementContentAsBase64:
			case State.ReadElementContentAsBinHex:
			case State.ReadContentAsBase64:
			case State.ReadContentAsBinHex:
				throw new InvalidOperationException(Res.GetString("Xml_MixingReadValueChunkWithBinary"));
			default:
				throw CreateReadContentAsException(methodName);
			}
		}

		private void FinishReadContentAsType()
		{
			switch (NodeType)
			{
			case XmlNodeType.Element:
				ProcessNamespaces();
				break;
			case XmlNodeType.EndElement:
				state = State.PopNamespaceScope;
				break;
			}
		}
	}
	internal class XmlTextEncoder
	{
		private const int SurHighStart = 55296;

		private const int SurHighEnd = 56319;

		private const int SurLowStart = 56320;

		private const int SurLowEnd = 57343;

		private TextWriter textWriter;

		private bool inAttribute;

		private char quoteChar;

		private BufferBuilder attrValue;

		private bool cacheAttrValue;

		private XmlCharType xmlCharType;

		internal char QuoteChar
		{
			set
			{
				quoteChar = value;
			}
		}

		internal string AttributeValue
		{
			get
			{
				if (cacheAttrValue)
				{
					return attrValue.ToString();
				}
				return string.Empty;
			}
		}

		internal XmlTextEncoder(TextWriter textWriter)
		{
			this.textWriter = textWriter;
			quoteChar = '"';
			xmlCharType = XmlCharType.Instance;
		}

		internal void StartAttribute(bool cacheAttrValue)
		{
			inAttribute = true;
			this.cacheAttrValue = cacheAttrValue;
			if (cacheAttrValue)
			{
				if (attrValue == null)
				{
					attrValue = new BufferBuilder();
				}
				else
				{
					attrValue.Clear();
				}
			}
		}

		internal void EndAttribute()
		{
			if (cacheAttrValue)
			{
				attrValue.Clear();
			}
			inAttribute = false;
			cacheAttrValue = false;
		}

		internal void WriteSurrogateChar(char lowChar, char highChar)
		{
			if (lowChar < '\udc00' || lowChar > '\udfff' || highChar < '\ud800' || highChar > '\udbff')
			{
				throw XmlConvert.CreateInvalidSurrogatePairException(lowChar, highChar);
			}
			textWriter.Write(highChar);
			textWriter.Write(lowChar);
		}

		internal unsafe void Write(char[] array, int offset, int count)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (0 > offset)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (0 > count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count > array.Length - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (cacheAttrValue)
			{
				attrValue.Append(array, offset, count);
			}
			int num = offset + count;
			int i = offset;
			char c = '\0';
			while (true)
			{
				int num2 = i;
				for (; i < num; i++)
				{
					if ((xmlCharType.charProperties[(int)(c = array[i])] & 0x80) == 0)
					{
						break;
					}
				}
				if (num2 < i)
				{
					textWriter.Write(array, num2, i - num2);
				}
				if (i == num)
				{
					break;
				}
				switch (c)
				{
				case '\t':
					textWriter.Write(c);
					break;
				case '\n':
				case '\r':
					if (inAttribute)
					{
						WriteCharEntityImpl(c);
					}
					else
					{
						textWriter.Write(c);
					}
					break;
				case '<':
					WriteEntityRefImpl("lt");
					break;
				case '>':
					WriteEntityRefImpl("gt");
					break;
				case '&':
					WriteEntityRefImpl("amp");
					break;
				case '\'':
					if (inAttribute && quoteChar == c)
					{
						WriteEntityRefImpl("apos");
					}
					else
					{
						textWriter.Write('\'');
					}
					break;
				case '"':
					if (inAttribute && quoteChar == c)
					{
						WriteEntityRefImpl("quot");
					}
					else
					{
						textWriter.Write('"');
					}
					break;
				default:
					if (c >= '\ud800' && c <= '\udbff')
					{
						if (i + 1 >= num)
						{
							throw new ArgumentException(Res.GetString("Xml_SurrogatePairSplit"));
						}
						WriteSurrogateChar(array[++i], c);
					}
					else
					{
						if (c >= '\udc00' && c <= '\udfff')
						{
							throw XmlConvert.CreateInvalidHighSurrogateCharException(c);
						}
						WriteCharEntityImpl(c);
					}
					break;
				}
				i++;
			}
		}

		internal unsafe void Write(char ch)
		{
			if (cacheAttrValue)
			{
				attrValue.Append(ch);
			}
			if ((xmlCharType.charProperties[(int)ch] & 0x80u) != 0)
			{
				textWriter.Write(ch);
				return;
			}
			switch (ch)
			{
			case '\t':
				textWriter.Write(ch);
				return;
			case '\n':
			case '\r':
				if (inAttribute)
				{
					WriteCharEntityImpl(ch);
				}
				else
				{
					textWriter.Write(ch);
				}
				return;
			case '<':
				WriteEntityRefImpl("lt");
				return;
			case '>':
				WriteEntityRefImpl("gt");
				return;
			case '&':
				WriteEntityRefImpl("amp");
				return;
			case '\'':
				if (inAttribute && quoteChar == ch)
				{
					WriteEntityRefImpl("apos");
				}
				else
				{
					textWriter.Write('\'');
				}
				return;
			case '"':
				if (inAttribute && quoteChar == ch)
				{
					WriteEntityRefImpl("quot");
				}
				else
				{
					textWriter.Write('"');
				}
				return;
			}
			if (ch >= '\ud800' && ch <= '\udbff')
			{
				throw new ArgumentException(Res.GetString("Xml_InvalidSurrogateMissingLowChar"));
			}
			if (ch >= '\udc00' && ch <= '\udfff')
			{
				throw XmlConvert.CreateInvalidHighSurrogateCharException(ch);
			}
			WriteCharEntityImpl(ch);
		}

		internal void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			if (lowChar < '\udc00' || lowChar > '\udfff' || highChar < '\ud800' || highChar > '\udbff')
			{
				throw XmlConvert.CreateInvalidSurrogatePairException(lowChar, highChar);
			}
			int num = (lowChar - 56320) | ((highChar - 55296 << 10) + 65536);
			if (cacheAttrValue)
			{
				attrValue.Append(highChar);
				attrValue.Append(lowChar);
			}
			textWriter.Write("&#x");
			textWriter.Write(num.ToString("X", NumberFormatInfo.InvariantInfo));
			textWriter.Write(';');
		}

		internal unsafe void Write(string text)
		{
			if (text == null)
			{
				return;
			}
			if (cacheAttrValue)
			{
				attrValue.Append(text);
			}
			int length = text.Length;
			int i = 0;
			int num = 0;
			char c = '\0';
			while (true)
			{
				if (i < length && (xmlCharType.charProperties[(int)(c = text[i])] & 0x80u) != 0)
				{
					i++;
					continue;
				}
				if (i == length)
				{
					textWriter.Write(text);
					return;
				}
				if (inAttribute)
				{
					if (c != '\t')
					{
						break;
					}
					i++;
				}
				else
				{
					if (c != '\t' && c != '\n' && c != '\r' && c != '"' && c != '\'')
					{
						break;
					}
					i++;
				}
			}
			char[] helperBuffer = new char[256];
			while (true)
			{
				if (num < i)
				{
					WriteStringFragment(text, num, i - num, helperBuffer);
				}
				if (i == length)
				{
					break;
				}
				switch (c)
				{
				case '\t':
					textWriter.Write(c);
					break;
				case '\n':
				case '\r':
					if (inAttribute)
					{
						WriteCharEntityImpl(c);
					}
					else
					{
						textWriter.Write(c);
					}
					break;
				case '<':
					WriteEntityRefImpl("lt");
					break;
				case '>':
					WriteEntityRefImpl("gt");
					break;
				case '&':
					WriteEntityRefImpl("amp");
					break;
				case '\'':
					if (inAttribute && quoteChar == c)
					{
						WriteEntityRefImpl("apos");
					}
					else
					{
						textWriter.Write('\'');
					}
					break;
				case '"':
					if (inAttribute && quoteChar == c)
					{
						WriteEntityRefImpl("quot");
					}
					else
					{
						textWriter.Write('"');
					}
					break;
				default:
					if (c >= '\ud800' && c <= '\udbff')
					{
						if (i + 1 >= length)
						{
							throw XmlConvert.CreateInvalidSurrogatePairException(text[i], c);
						}
						WriteSurrogateChar(text[++i], c);
					}
					else
					{
						if (c >= '\udc00' && c <= '\udfff')
						{
							throw XmlConvert.CreateInvalidHighSurrogateCharException(c);
						}
						WriteCharEntityImpl(c);
					}
					break;
				}
				i++;
				num = i;
				for (; i < length; i++)
				{
					if ((xmlCharType.charProperties[(int)(c = text[i])] & 0x80) == 0)
					{
						break;
					}
				}
			}
		}

		internal unsafe void WriteRawWithSurrogateChecking(string text)
		{
			if (text == null)
			{
				return;
			}
			if (cacheAttrValue)
			{
				attrValue.Append(text);
			}
			int length = text.Length;
			int num = 0;
			char c = '\0';
			while (true)
			{
				if (num < length && ((xmlCharType.charProperties[(int)(c = text[num])] & 0x10u) != 0 || c < ' '))
				{
					num++;
					continue;
				}
				if (num == length)
				{
					break;
				}
				if (c >= '\ud800' && c <= '\udbff')
				{
					if (num + 1 >= length)
					{
						throw new ArgumentException(Res.GetString("Xml_InvalidSurrogateMissingLowChar"));
					}
					char c2 = text[num + 1];
					if (c2 < '\udc00' || c2 > '\udfff')
					{
						throw XmlConvert.CreateInvalidSurrogatePairException(c2, c);
					}
					num += 2;
				}
				else
				{
					if (c >= '\udc00' && c <= '\udfff')
					{
						throw XmlConvert.CreateInvalidHighSurrogateCharException(c);
					}
					num++;
				}
			}
			textWriter.Write(text);
		}

		internal void WriteRaw(string value)
		{
			if (cacheAttrValue)
			{
				attrValue.Append(value);
			}
			textWriter.Write(value);
		}

		internal void WriteRaw(char[] array, int offset, int count)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (0 > count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (0 > offset)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count > array.Length - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (cacheAttrValue)
			{
				attrValue.Append(array, offset, count);
			}
			textWriter.Write(array, offset, count);
		}

		internal void WriteCharEntity(char ch)
		{
			if (ch >= '\ud800' && ch <= '\udfff')
			{
				throw new ArgumentException(Res.GetString("Xml_InvalidSurrogateMissingLowChar"));
			}
			int num = ch;
			string text = num.ToString("X", NumberFormatInfo.InvariantInfo);
			if (cacheAttrValue)
			{
				attrValue.Append("&#x");
				attrValue.Append(text);
				attrValue.Append(';');
			}
			WriteCharEntityImpl(text);
		}

		internal void WriteEntityRef(string name)
		{
			if (cacheAttrValue)
			{
				attrValue.Append('&');
				attrValue.Append(name);
				attrValue.Append(';');
			}
			WriteEntityRefImpl(name);
		}

		internal void Flush()
		{
		}

		private void WriteStringFragment(string str, int offset, int count, char[] helperBuffer)
		{
			int num = helperBuffer.Length;
			while (count > 0)
			{
				int num2 = count;
				if (num2 > num)
				{
					num2 = num;
				}
				str.CopyTo(offset, helperBuffer, 0, num2);
				textWriter.Write(helperBuffer, 0, num2);
				offset += num2;
				count -= num2;
			}
		}

		private void WriteCharEntityImpl(char ch)
		{
			int num = ch;
			WriteCharEntityImpl(num.ToString("X", NumberFormatInfo.InvariantInfo));
		}

		private void WriteCharEntityImpl(string strVal)
		{
			textWriter.Write("&#x");
			textWriter.Write(strVal);
			textWriter.Write(';');
		}

		private void WriteEntityRefImpl(string name)
		{
			textWriter.Write('&');
			textWriter.Write(name);
			textWriter.Write(';');
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class XmlTextReader : XmlReader, IXmlLineInfo, IXmlNamespaceResolver
	{
		private XmlTextReaderImpl impl;

		public override XmlReaderSettings Settings => null;

		public override XmlNodeType NodeType => impl.NodeType;

		public override string Name => impl.Name;

		public override string LocalName => impl.LocalName;

		public override string NamespaceURI => impl.NamespaceURI;

		public override string Prefix => impl.Prefix;

		public override bool HasValue => impl.HasValue;

		public override string Value => impl.Value;

		public override int Depth => impl.Depth;

		public override string BaseURI => impl.BaseURI;

		public override bool IsEmptyElement => impl.IsEmptyElement;

		public override bool IsDefault => impl.IsDefault;

		public override char QuoteChar => impl.QuoteChar;

		public override XmlSpace XmlSpace => impl.XmlSpace;

		public override string XmlLang => impl.XmlLang;

		public override int AttributeCount => impl.AttributeCount;

		public override bool EOF => impl.EOF;

		public override ReadState ReadState => impl.ReadState;

		public override XmlNameTable NameTable => impl.NameTable;

		public override bool CanResolveEntity => true;

		public override bool CanReadBinaryContent => true;

		public override bool CanReadValueChunk => false;

		public int LineNumber => impl.LineNumber;

		public int LinePosition => impl.LinePosition;

		public bool Namespaces
		{
			get
			{
				return impl.Namespaces;
			}
			set
			{
				impl.Namespaces = value;
			}
		}

		public bool Normalization
		{
			get
			{
				return impl.Normalization;
			}
			set
			{
				impl.Normalization = value;
			}
		}

		public Encoding Encoding => impl.Encoding;

		public WhitespaceHandling WhitespaceHandling
		{
			get
			{
				return impl.WhitespaceHandling;
			}
			set
			{
				impl.WhitespaceHandling = value;
			}
		}

		public bool ProhibitDtd
		{
			get
			{
				return impl.ProhibitDtd;
			}
			set
			{
				impl.ProhibitDtd = value;
			}
		}

		public EntityHandling EntityHandling
		{
			get
			{
				return impl.EntityHandling;
			}
			set
			{
				impl.EntityHandling = value;
			}
		}

		public XmlResolver XmlResolver
		{
			set
			{
				impl.XmlResolver = value;
			}
		}

		internal XmlTextReaderImpl Impl => impl;

		internal override XmlNamespaceManager NamespaceManager => impl.NamespaceManager;

		internal bool XmlValidatingReaderCompatibilityMode
		{
			set
			{
				impl.XmlValidatingReaderCompatibilityMode = value;
			}
		}

		protected XmlTextReader()
		{
			impl = new XmlTextReaderImpl();
			impl.OuterReader = this;
		}

		protected XmlTextReader(XmlNameTable nt)
		{
			impl = new XmlTextReaderImpl(nt);
			impl.OuterReader = this;
		}

		public XmlTextReader(Stream input)
		{
			impl = new XmlTextReaderImpl(input);
			impl.OuterReader = this;
		}

		public XmlTextReader(string url, Stream input)
		{
			impl = new XmlTextReaderImpl(url, input);
			impl.OuterReader = this;
		}

		public XmlTextReader(Stream input, XmlNameTable nt)
		{
			impl = new XmlTextReaderImpl(input, nt);
			impl.OuterReader = this;
		}

		public XmlTextReader(string url, Stream input, XmlNameTable nt)
		{
			impl = new XmlTextReaderImpl(url, input, nt);
			impl.OuterReader = this;
		}

		public XmlTextReader(TextReader input)
		{
			impl = new XmlTextReaderImpl(input);
			impl.OuterReader = this;
		}

		public XmlTextReader(string url, TextReader input)
		{
			impl = new XmlTextReaderImpl(url, input);
			impl.OuterReader = this;
		}

		public XmlTextReader(TextReader input, XmlNameTable nt)
		{
			impl = new XmlTextReaderImpl(input, nt);
			impl.OuterReader = this;
		}

		public XmlTextReader(string url, TextReader input, XmlNameTable nt)
		{
			impl = new XmlTextReaderImpl(url, input, nt);
			impl.OuterReader = this;
		}

		public XmlTextReader(Stream xmlFragment, XmlNodeType fragType, XmlParserContext context)
		{
			impl = new XmlTextReaderImpl(xmlFragment, fragType, context);
			impl.OuterReader = this;
		}

		public XmlTextReader(string xmlFragment, XmlNodeType fragType, XmlParserContext context)
		{
			impl = new XmlTextReaderImpl(xmlFragment, fragType, context);
			impl.OuterReader = this;
		}

		public XmlTextReader(string url)
		{
			impl = new XmlTextReaderImpl(url, new NameTable());
			impl.OuterReader = this;
		}

		public XmlTextReader(string url, XmlNameTable nt)
		{
			impl = new XmlTextReaderImpl(url, nt);
			impl.OuterReader = this;
		}

		public override string GetAttribute(string name)
		{
			return impl.GetAttribute(name);
		}

		public override string GetAttribute(string localName, string namespaceURI)
		{
			return impl.GetAttribute(localName, namespaceURI);
		}

		public override string GetAttribute(int i)
		{
			return impl.GetAttribute(i);
		}

		public override bool MoveToAttribute(string name)
		{
			return impl.MoveToAttribute(name);
		}

		public override bool MoveToAttribute(string localName, string namespaceURI)
		{
			return impl.MoveToAttribute(localName, namespaceURI);
		}

		public override void MoveToAttribute(int i)
		{
			impl.MoveToAttribute(i);
		}

		public override bool MoveToFirstAttribute()
		{
			return impl.MoveToFirstAttribute();
		}

		public override bool MoveToNextAttribute()
		{
			return impl.MoveToNextAttribute();
		}

		public override bool MoveToElement()
		{
			return impl.MoveToElement();
		}

		public override bool ReadAttributeValue()
		{
			return impl.ReadAttributeValue();
		}

		public override bool Read()
		{
			return impl.Read();
		}

		public override void Close()
		{
			impl.Close();
		}

		public override void Skip()
		{
			impl.Skip();
		}

		public override string LookupNamespace(string prefix)
		{
			string text = impl.LookupNamespace(prefix);
			if (text != null && text.Length == 0)
			{
				text = null;
			}
			return text;
		}

		public override void ResolveEntity()
		{
			impl.ResolveEntity();
		}

		public override int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			return impl.ReadContentAsBase64(buffer, index, count);
		}

		public override int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			return impl.ReadElementContentAsBase64(buffer, index, count);
		}

		public override int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			return impl.ReadContentAsBinHex(buffer, index, count);
		}

		public override int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			return impl.ReadElementContentAsBinHex(buffer, index, count);
		}

		public override string ReadString()
		{
			impl.MoveOffEntityReference();
			return base.ReadString();
		}

		public bool HasLineInfo()
		{
			return true;
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return impl.GetNamespacesInScope(scope);
		}

		string IXmlNamespaceResolver.LookupNamespace(string prefix)
		{
			return impl.LookupNamespace(prefix);
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			return impl.LookupPrefix(namespaceName);
		}

		public IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return impl.GetNamespacesInScope(scope);
		}

		public void ResetState()
		{
			impl.ResetState();
		}

		public TextReader GetRemainder()
		{
			return impl.GetRemainder();
		}

		public int ReadChars(char[] buffer, int index, int count)
		{
			return impl.ReadChars(buffer, index, count);
		}

		public int ReadBase64(byte[] array, int offset, int len)
		{
			return impl.ReadBase64(array, offset, len);
		}

		public int ReadBinHex(byte[] array, int offset, int len)
		{
			return impl.ReadBinHex(array, offset, len);
		}
	}
	internal class XmlTextReaderImpl : XmlReader, IXmlLineInfo, IXmlNamespaceResolver
	{
		private enum ParsingFunction
		{
			ElementContent,
			NoData,
			OpenUrl,
			SwitchToInteractive,
			SwitchToInteractiveXmlDecl,
			DocumentContent,
			MoveToElementContent,
			PopElementContext,
			PopEmptyElementContext,
			ResetAttributesRootLevel,
			Error,
			Eof,
			ReaderClosed,
			EntityReference,
			InIncrementalRead,
			FragmentAttribute,
			ReportEndEntity,
			AfterResolveEntityInContent,
			AfterResolveEmptyEntityInContent,
			XmlDeclarationFragment,
			GoToEof,
			PartialTextValue,
			InReadAttributeValue,
			InReadValueChunk,
			InReadContentAsBinary,
			InReadElementContentAsBinary
		}

		private enum ParsingMode
		{
			Full,
			SkipNode,
			SkipContent
		}

		private enum EntityType
		{
			CharacterDec,
			CharacterHex,
			CharacterNamed,
			Expanded,
			ExpandedInAttribute,
			Skipped,
			Unexpanded,
			FakeExpanded
		}

		private enum EntityExpandType
		{
			OnlyGeneral,
			OnlyCharacter,
			All
		}

		private enum IncrementalReadState
		{
			Text,
			StartTag,
			PI,
			CDATA,
			Comment,
			Attributes,
			AttributeValue,
			ReadData,
			EndElement,
			End,
			ReadValueChunk_OnCachedValue,
			ReadValueChunk_OnPartialValue,
			ReadContentAsBinary_OnCachedValue,
			ReadContentAsBinary_OnPartialValue,
			ReadContentAsBinary_End
		}

		private struct ParsingState
		{
			internal char[] chars;

			internal int charPos;

			internal int charsUsed;

			internal Encoding encoding;

			internal bool appendMode;

			internal Stream stream;

			internal Decoder decoder;

			internal byte[] bytes;

			internal int bytePos;

			internal int bytesUsed;

			internal TextReader textReader;

			internal int lineNo;

			internal int lineStartPos;

			internal string baseUriStr;

			internal Uri baseUri;

			internal bool isEof;

			internal bool isStreamEof;

			internal SchemaEntity entity;

			internal int entityId;

			internal bool eolNormalized;

			internal bool entityResolvedManually;

			internal int LineNo => lineNo;

			internal int LinePos => charPos - lineStartPos;

			internal void Clear()
			{
				chars = null;
				charPos = 0;
				charsUsed = 0;
				encoding = null;
				stream = null;
				decoder = null;
				bytes = null;
				bytePos = 0;
				bytesUsed = 0;
				textReader = null;
				lineNo = 1;
				lineStartPos = -1;
				baseUriStr = string.Empty;
				baseUri = null;
				isEof = false;
				isStreamEof = false;
				eolNormalized = true;
				entityResolvedManually = false;
			}

			internal void Close(bool closeInput)
			{
				if (closeInput)
				{
					if (stream != null)
					{
						stream.Close();
					}
					else if (textReader != null)
					{
						textReader.Close();
					}
				}
			}
		}

		private class XmlContext
		{
			internal XmlSpace xmlSpace;

			internal string xmlLang;

			internal string defaultNamespace;

			internal XmlContext previousContext;

			internal XmlContext()
			{
				xmlSpace = XmlSpace.None;
				xmlLang = string.Empty;
				defaultNamespace = string.Empty;
				previousContext = null;
			}

			internal XmlContext(XmlContext previousContext)
			{
				xmlSpace = previousContext.xmlSpace;
				xmlLang = previousContext.xmlLang;
				defaultNamespace = previousContext.defaultNamespace;
				this.previousContext = previousContext;
			}
		}

		private class NoNamespaceManager : XmlNamespaceManager
		{
			public override string DefaultNamespace => string.Empty;

			public override void PushScope()
			{
			}

			public override bool PopScope()
			{
				return false;
			}

			public override void AddNamespace(string prefix, string uri)
			{
			}

			public override void RemoveNamespace(string prefix, string uri)
			{
			}

			public override IEnumerator GetEnumerator()
			{
				return null;
			}

			public override IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope)
			{
				return null;
			}

			public override string LookupNamespace(string prefix)
			{
				return string.Empty;
			}

			public override string LookupPrefix(string uri)
			{
				return null;
			}

			public override bool HasNamespace(string prefix)
			{
				return false;
			}
		}

		internal class DtdParserProxy : IDtdParserAdapter
		{
			private XmlTextReaderImpl reader;

			private DtdParser dtdParser;

			private SchemaInfo schemaInfo;

			internal SchemaInfo DtdSchemaInfo
			{
				get
				{
					if (dtdParser == null)
					{
						return schemaInfo;
					}
					return dtdParser.SchemaInfo;
				}
			}

			internal string InternalDtdSubset
			{
				get
				{
					if (dtdParser == null)
					{
						throw new InvalidOperationException();
					}
					return dtdParser.InternalSubset;
				}
			}

			XmlNameTable IDtdParserAdapter.NameTable => reader.DtdParserProxy_NameTable;

			XmlNamespaceManager IDtdParserAdapter.NamespaceManager => reader.DtdParserProxy_NamespaceManager;

			bool IDtdParserAdapter.DtdValidation => reader.DtdParserProxy_DtdValidation;

			bool IDtdParserAdapter.Normalization => reader.DtdParserProxy_Normalization;

			bool IDtdParserAdapter.Namespaces => reader.DtdParserProxy_Namespaces;

			bool IDtdParserAdapter.V1CompatibilityMode => reader.DtdParserProxy_V1CompatibilityMode;

			Uri IDtdParserAdapter.BaseUri => reader.DtdParserProxy_BaseUri;

			bool IDtdParserAdapter.IsEof => reader.DtdParserProxy_IsEof;

			char[] IDtdParserAdapter.ParsingBuffer => reader.DtdParserProxy_ParsingBuffer;

			int IDtdParserAdapter.ParsingBufferLength => reader.DtdParserProxy_ParsingBufferLength;

			int IDtdParserAdapter.CurrentPosition
			{
				get
				{
					return reader.DtdParserProxy_CurrentPosition;
				}
				set
				{
					reader.DtdParserProxy_CurrentPosition = value;
				}
			}

			int IDtdParserAdapter.EntityStackLength => reader.DtdParserProxy_EntityStackLength;

			bool IDtdParserAdapter.IsEntityEolNormalized => reader.DtdParserProxy_IsEntityEolNormalized;

			ValidationEventHandler IDtdParserAdapter.EventHandler
			{
				get
				{
					return reader.DtdParserProxy_EventHandler;
				}
				set
				{
					reader.DtdParserProxy_EventHandler = value;
				}
			}

			int IDtdParserAdapter.LineNo => reader.DtdParserProxy_LineNo;

			int IDtdParserAdapter.LineStartPosition => reader.DtdParserProxy_LineStartPosition;

			internal DtdParserProxy(XmlTextReaderImpl reader)
			{
				this.reader = reader;
				dtdParser = new DtdParser(this);
			}

			internal DtdParserProxy(XmlTextReaderImpl reader, SchemaInfo schemaInfo)
			{
				this.reader = reader;
				this.schemaInfo = schemaInfo;
			}

			internal DtdParserProxy(string baseUri, string docTypeName, string publicId, string systemId, string internalSubset, XmlTextReaderImpl reader)
			{
				this.reader = reader;
				dtdParser = new DtdParser(baseUri, docTypeName, publicId, systemId, internalSubset, this);
			}

			internal void Parse(bool saveInternalSubset)
			{
				if (dtdParser == null)
				{
					throw new InvalidOperationException();
				}
				dtdParser.Parse(saveInternalSubset);
			}

			void IDtdParserAdapter.OnNewLine(int pos)
			{
				reader.DtdParserProxy_OnNewLine(pos);
			}

			int IDtdParserAdapter.ReadData()
			{
				return reader.DtdParserProxy_ReadData();
			}

			void IDtdParserAdapter.SendValidationEvent(XmlSeverityType severity, XmlSchemaException exception)
			{
				reader.DtdParserProxy_SendValidationEvent(severity, exception);
			}

			int IDtdParserAdapter.ParseNumericCharRef(BufferBuilder internalSubsetBuilder)
			{
				return reader.DtdParserProxy_ParseNumericCharRef(internalSubsetBuilder);
			}

			int IDtdParserAdapter.ParseNamedCharRef(bool expand, BufferBuilder internalSubsetBuilder)
			{
				return reader.DtdParserProxy_ParseNamedCharRef(expand, internalSubsetBuilder);
			}

			void IDtdParserAdapter.ParsePI(BufferBuilder sb)
			{
				reader.DtdParserProxy_ParsePI(sb);
			}

			void IDtdParserAdapter.ParseComment(BufferBuilder sb)
			{
				reader.DtdParserProxy_ParseComment(sb);
			}

			bool IDtdParserAdapter.PushEntity(SchemaEntity entity, int entityId)
			{
				return reader.DtdParserProxy_PushEntity(entity, entityId);
			}

			bool IDtdParserAdapter.PopEntity(out SchemaEntity oldEntity, out int newEntityId)
			{
				return reader.DtdParserProxy_PopEntity(out oldEntity, out newEntityId);
			}

			bool IDtdParserAdapter.PushExternalSubset(string systemId, string publicId)
			{
				return reader.DtdParserProxy_PushExternalSubset(systemId, publicId);
			}

			void IDtdParserAdapter.PushInternalDtd(string baseUri, string internalDtd)
			{
				reader.DtdParserProxy_PushInternalDtd(baseUri, internalDtd);
			}

			void IDtdParserAdapter.Throw(Exception e)
			{
				reader.DtdParserProxy_Throw(e);
			}

			void IDtdParserAdapter.OnSystemId(string systemId, LineInfo keywordLineInfo, LineInfo systemLiteralLineInfo)
			{
				reader.DtdParserProxy_OnSystemId(systemId, keywordLineInfo, systemLiteralLineInfo);
			}

			void IDtdParserAdapter.OnPublicId(string publicId, LineInfo keywordLineInfo, LineInfo publicLiteralLineInfo)
			{
				reader.DtdParserProxy_OnPublicId(publicId, keywordLineInfo, publicLiteralLineInfo);
			}
		}

		private class NodeData : IComparable
		{
			private static NodeData s_None;

			internal XmlNodeType type;

			internal string localName;

			internal string prefix;

			internal string ns;

			internal string nameWPrefix;

			private string value;

			private char[] chars;

			private int valueStartPos;

			private int valueLength;

			internal LineInfo lineInfo;

			internal LineInfo lineInfo2;

			internal char quoteChar;

			internal int depth;

			private bool isEmptyOrDefault;

			internal int entityId;

			internal bool xmlContextPushed;

			internal NodeData nextAttrValueChunk;

			internal object schemaType;

			internal object typedValue;

			internal static NodeData None
			{
				get
				{
					if (s_None == null)
					{
						s_None = new NodeData();
					}
					return s_None;
				}
			}

			internal int LineNo => lineInfo.lineNo;

			internal int LinePos => lineInfo.linePos;

			internal bool IsEmptyElement
			{
				get
				{
					if (type == XmlNodeType.Element)
					{
						return isEmptyOrDefault;
					}
					return false;
				}
				set
				{
					isEmptyOrDefault = value;
				}
			}

			internal bool IsDefaultAttribute
			{
				get
				{
					if (type == XmlNodeType.Attribute)
					{
						return isEmptyOrDefault;
					}
					return false;
				}
				set
				{
					isEmptyOrDefault = value;
				}
			}

			internal bool ValueBuffered => value == null;

			internal string StringValue
			{
				get
				{
					if (value == null)
					{
						value = new string(chars, valueStartPos, valueLength);
					}
					return value;
				}
			}

			internal NodeData()
			{
				Clear(XmlNodeType.None);
				xmlContextPushed = false;
			}

			internal void TrimSpacesInValue()
			{
				if (ValueBuffered)
				{
					XmlComplianceUtil.StripSpaces(chars, valueStartPos, ref valueLength);
				}
				else
				{
					value = XmlComplianceUtil.StripSpaces(value);
				}
			}

			internal void Clear(XmlNodeType type)
			{
				this.type = type;
				ClearName();
				value = string.Empty;
				valueStartPos = -1;
				nameWPrefix = string.Empty;
				schemaType = null;
				typedValue = null;
			}

			internal void ClearName()
			{
				localName = string.Empty;
				prefix = string.Empty;
				ns = string.Empty;
				nameWPrefix = string.Empty;
			}

			internal void SetLineInfo(int lineNo, int linePos)
			{
				lineInfo.Set(lineNo, linePos);
			}

			internal void SetLineInfo2(int lineNo, int linePos)
			{
				lineInfo2.Set(lineNo, linePos);
			}

			internal void SetValueNode(XmlNodeType type, string value)
			{
				this.type = type;
				ClearName();
				this.value = value;
				valueStartPos = -1;
			}

			internal void SetValueNode(XmlNodeType type, char[] chars, int startPos, int len)
			{
				this.type = type;
				ClearName();
				value = null;
				this.chars = chars;
				valueStartPos = startPos;
				valueLength = len;
			}

			internal void SetNamedNode(XmlNodeType type, string localName)
			{
				SetNamedNode(type, localName, string.Empty, localName);
			}

			internal void SetNamedNode(XmlNodeType type, string localName, string prefix, string nameWPrefix)
			{
				this.type = type;
				this.localName = localName;
				this.prefix = prefix;
				this.nameWPrefix = nameWPrefix;
				ns = string.Empty;
				value = string.Empty;
				valueStartPos = -1;
			}

			internal void SetValue(string value)
			{
				valueStartPos = -1;
				this.value = value;
			}

			internal void SetValue(char[] chars, int startPos, int len)
			{
				value = null;
				this.chars = chars;
				valueStartPos = startPos;
				valueLength = len;
			}

			internal void OnBufferInvalidated()
			{
				if (value == null)
				{
					value = new string(chars, valueStartPos, valueLength);
				}
				valueStartPos = -1;
			}

			internal void CopyTo(BufferBuilder sb)
			{
				CopyTo(0, sb);
			}

			internal void CopyTo(int valueOffset, BufferBuilder sb)
			{
				if (value == null)
				{
					sb.Append(chars, valueStartPos + valueOffset, valueLength - valueOffset);
				}
				else if (valueOffset <= 0)
				{
					sb.Append(value);
				}
				else
				{
					sb.Append(value, valueOffset, value.Length - valueOffset);
				}
			}

			internal int CopyTo(int valueOffset, char[] buffer, int offset, int length)
			{
				if (value == null)
				{
					int num = valueLength - valueOffset;
					if (num > length)
					{
						num = length;
					}
					Buffer.BlockCopy(chars, (valueStartPos + valueOffset) * 2, buffer, offset * 2, num * 2);
					return num;
				}
				int num2 = value.Length - valueOffset;
				if (num2 > length)
				{
					num2 = length;
				}
				value.CopyTo(valueOffset, buffer, offset, num2);
				return num2;
			}

			internal int CopyToBinary(IncrementalReadDecoder decoder, int valueOffset)
			{
				if (value == null)
				{
					return decoder.Decode(chars, valueStartPos + valueOffset, valueLength - valueOffset);
				}
				return decoder.Decode(value, valueOffset, value.Length - valueOffset);
			}

			internal void AdjustLineInfo(int valueOffset, bool isNormalized, ref LineInfo lineInfo)
			{
				if (valueOffset != 0)
				{
					if (valueStartPos != -1)
					{
						XmlTextReaderImpl.AdjustLineInfo(chars, valueStartPos, valueStartPos + valueOffset, isNormalized, ref lineInfo);
						return;
					}
					char[] array = value.ToCharArray(0, valueOffset);
					XmlTextReaderImpl.AdjustLineInfo(array, 0, array.Length, isNormalized, ref lineInfo);
				}
			}

			internal string GetNameWPrefix(XmlNameTable nt)
			{
				if (nameWPrefix != null)
				{
					return nameWPrefix;
				}
				return CreateNameWPrefix(nt);
			}

			internal string CreateNameWPrefix(XmlNameTable nt)
			{
				if (prefix.Length == 0)
				{
					nameWPrefix = localName;
				}
				else
				{
					nameWPrefix = nt.Add(prefix + ":" + localName);
				}
				return nameWPrefix;
			}

			int IComparable.CompareTo(object obj)
			{
				NodeData nodeData = obj as NodeData;
				if (nodeData != null)
				{
					if (Ref.Equal(localName, nodeData.localName))
					{
						if (Ref.Equal(ns, nodeData.ns))
						{
							return 0;
						}
						return string.CompareOrdinal(ns, nodeData.ns);
					}
					return string.CompareOrdinal(localName, nodeData.localName);
				}
				return GetHashCode().CompareTo(nodeData.GetHashCode());
			}
		}

		private class SchemaAttDefToNodeDataComparer : IComparer
		{
			private static IComparer s_instance = new SchemaAttDefToNodeDataComparer();

			internal static IComparer Instance => s_instance;

			public int Compare(object x, object y)
			{
				if (x == null)
				{
					if (y != null)
					{
						return -1;
					}
					return 0;
				}
				if (y == null)
				{
					return 1;
				}
				string strA;
				string prefix;
				if (x is NodeData nodeData)
				{
					strA = nodeData.localName;
					prefix = nodeData.prefix;
				}
				else
				{
					if (!(x is SchemaAttDef schemaAttDef))
					{
						throw new XmlException("Xml_DefaultException", string.Empty);
					}
					strA = schemaAttDef.Name.Name;
					prefix = schemaAttDef.Prefix;
				}
				string strB;
				string prefix2;
				if (y is NodeData nodeData2)
				{
					strB = nodeData2.localName;
					prefix2 = nodeData2.prefix;
				}
				else
				{
					if (!(y is SchemaAttDef schemaAttDef2))
					{
						throw new XmlException("Xml_DefaultException", string.Empty);
					}
					strB = schemaAttDef2.Name.Name;
					prefix2 = schemaAttDef2.Prefix;
				}
				int num = string.Compare(strA, strB, StringComparison.Ordinal);
				if (num != 0)
				{
					return num;
				}
				return string.Compare(prefix, prefix2, StringComparison.Ordinal);
			}
		}

		private const int MaxBytesToMove = 128;

		private const int ApproxXmlDeclLength = 80;

		private const int NodesInitialSize = 8;

		private const int InitialAttributesCount = 4;

		private const int InitialParsingStateStackSize = 2;

		private const int InitialParsingStatesDepth = 2;

		private const int DtdChidrenInitialSize = 2;

		private const int MaxByteSequenceLen = 6;

		private const int MaxAttrDuplWalkCount = 250;

		private const int MinWhitespaceLookahedCount = 4096;

		private const string XmlDeclarationBegining = "<?xml";

		internal const int SurHighStart = 55296;

		internal const int SurHighEnd = 56319;

		internal const int SurLowStart = 56320;

		internal const int SurLowEnd = 57343;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		private ParsingState ps;

		private ParsingFunction parsingFunction;

		private ParsingFunction nextParsingFunction;

		private ParsingFunction nextNextParsingFunction;

		private NodeData[] nodes;

		private NodeData curNode;

		private int index;

		private int curAttrIndex = -1;

		private int attrCount;

		private int attrHashtable;

		private int attrDuplWalkCount;

		private bool attrNeedNamespaceLookup;

		private bool fullAttrCleanup;

		private NodeData[] attrDuplSortingArray;

		private XmlNameTable nameTable;

		private bool nameTableFromSettings;

		private XmlResolver xmlResolver;

		private string url = string.Empty;

		private CompressedStack compressedStack;

		private bool normalize;

		private bool supportNamespaces = true;

		private WhitespaceHandling whitespaceHandling;

		private bool prohibitDtd;

		private EntityHandling entityHandling;

		private bool ignorePIs;

		private bool ignoreComments;

		private bool checkCharacters;

		private int lineNumberOffset;

		private int linePositionOffset;

		private bool closeInput;

		private long maxCharactersInDocument;

		private long maxCharactersFromEntities;

		private bool v1Compat;

		private XmlNamespaceManager namespaceManager;

		private string lastPrefix = string.Empty;

		private XmlContext xmlContext;

		private ParsingState[] parsingStatesStack;

		private int parsingStatesStackTop = -1;

		private string reportedBaseUri;

		private Encoding reportedEncoding;

		private DtdParserProxy dtdParserProxy;

		private XmlNodeType fragmentType = XmlNodeType.Document;

		private bool fragment;

		private XmlParserContext fragmentParserContext;

		private IncrementalReadDecoder incReadDecoder;

		private IncrementalReadState incReadState;

		private int incReadDepth;

		private int incReadLeftStartPos;

		private int incReadLeftEndPos;

		private LineInfo incReadLineInfo;

		private IncrementalReadCharsDecoder readCharsDecoder;

		private BinHexDecoder binHexDecoder;

		private Base64Decoder base64Decoder;

		private int attributeValueBaseEntityId;

		private bool emptyEntityInAttributeResolved;

		private ValidationEventHandler validationEventHandler;

		private bool validatingReaderCompatFlag;

		private bool addDefaultAttributesAndNormalize;

		private XmlQualifiedName qName;

		private BufferBuilder stringBuilder;

		private bool rootElementParsed;

		private bool standalone;

		private int nextEntityId = 1;

		private ParsingMode parsingMode;

		private ReadState readState;

		private SchemaEntity lastEntity;

		private bool afterResetState;

		private int documentStartBytePos;

		private int readValueOffset;

		private long charactersInDocument;

		private long charactersFromEntities;

		private bool disableUndeclaredEntityCheck;

		private XmlReader outerReader;

		private bool xmlResolverIsSet;

		private string Xml;

		private string XmlNs;

		public override XmlReaderSettings Settings
		{
			get
			{
				if (v1Compat)
				{
					return null;
				}
				XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
				if (nameTableFromSettings)
				{
					xmlReaderSettings.NameTable = nameTable;
				}
				switch (fragmentType)
				{
				default:
					xmlReaderSettings.ConformanceLevel = ConformanceLevel.Auto;
					break;
				case XmlNodeType.Element:
					xmlReaderSettings.ConformanceLevel = ConformanceLevel.Fragment;
					break;
				case XmlNodeType.Document:
					xmlReaderSettings.ConformanceLevel = ConformanceLevel.Document;
					break;
				}
				xmlReaderSettings.CheckCharacters = checkCharacters;
				xmlReaderSettings.LineNumberOffset = lineNumberOffset;
				xmlReaderSettings.LinePositionOffset = linePositionOffset;
				xmlReaderSettings.IgnoreWhitespace = whitespaceHandling == WhitespaceHandling.Significant;
				xmlReaderSettings.IgnoreProcessingInstructions = ignorePIs;
				xmlReaderSettings.IgnoreComments = ignoreComments;
				xmlReaderSettings.ProhibitDtd = prohibitDtd;
				xmlReaderSettings.MaxCharactersInDocument = maxCharactersInDocument;
				xmlReaderSettings.MaxCharactersFromEntities = maxCharactersFromEntities;
				xmlReaderSettings.ReadOnly = true;
				return xmlReaderSettings;
			}
		}

		public override XmlNodeType NodeType => curNode.type;

		public override string Name => curNode.GetNameWPrefix(nameTable);

		public override string LocalName => curNode.localName;

		public override string NamespaceURI => curNode.ns;

		public override string Prefix => curNode.prefix;

		public override bool HasValue => XmlReader.HasValueInternal(curNode.type);

		public override string Value
		{
			get
			{
				if (parsingFunction >= ParsingFunction.PartialTextValue)
				{
					if (parsingFunction == ParsingFunction.PartialTextValue)
					{
						FinishPartialValue();
						parsingFunction = nextParsingFunction;
					}
					else
					{
						FinishOtherValueIterator();
					}
				}
				return curNode.StringValue;
			}
		}

		public override int Depth => curNode.depth;

		public override string BaseURI => reportedBaseUri;

		public override bool IsEmptyElement => curNode.IsEmptyElement;

		public override bool IsDefault => curNode.IsDefaultAttribute;

		public override char QuoteChar
		{
			get
			{
				if (curNode.type != XmlNodeType.Attribute)
				{
					return '"';
				}
				return curNode.quoteChar;
			}
		}

		public override XmlSpace XmlSpace => xmlContext.xmlSpace;

		public override string XmlLang => xmlContext.xmlLang;

		public override ReadState ReadState => readState;

		public override bool EOF => parsingFunction == ParsingFunction.Eof;

		public override XmlNameTable NameTable => nameTable;

		public override bool CanResolveEntity => true;

		public override int AttributeCount => attrCount;

		internal XmlReader OuterReader
		{
			get
			{
				return outerReader;
			}
			set
			{
				outerReader = value;
			}
		}

		public override bool CanReadBinaryContent => true;

		public override bool CanReadValueChunk => true;

		public int LineNumber => curNode.LineNo;

		public int LinePosition => curNode.LinePos;

		internal bool Namespaces
		{
			get
			{
				return supportNamespaces;
			}
			set
			{
				if (readState != 0)
				{
					throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
				}
				supportNamespaces = value;
				if (value)
				{
					if (namespaceManager is NoNamespaceManager)
					{
						if (fragment && fragmentParserContext != null && fragmentParserContext.NamespaceManager != null)
						{
							namespaceManager = fragmentParserContext.NamespaceManager;
						}
						else
						{
							namespaceManager = new XmlNamespaceManager(nameTable);
						}
					}
					xmlContext.defaultNamespace = namespaceManager.LookupNamespace(string.Empty);
				}
				else
				{
					if (!(namespaceManager is NoNamespaceManager))
					{
						namespaceManager = new NoNamespaceManager();
					}
					xmlContext.defaultNamespace = string.Empty;
				}
			}
		}

		internal bool Normalization
		{
			get
			{
				return normalize;
			}
			set
			{
				if (readState == ReadState.Closed)
				{
					throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
				}
				normalize = value;
				if (ps.entity == null || ps.entity.IsExternal)
				{
					ps.eolNormalized = !value;
				}
			}
		}

		internal Encoding Encoding
		{
			get
			{
				if (readState != ReadState.Interactive)
				{
					return null;
				}
				return reportedEncoding;
			}
		}

		internal WhitespaceHandling WhitespaceHandling
		{
			get
			{
				return whitespaceHandling;
			}
			set
			{
				if (readState == ReadState.Closed)
				{
					throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
				}
				if ((uint)value > 2u)
				{
					throw new XmlException("Xml_WhitespaceHandling", string.Empty);
				}
				whitespaceHandling = value;
			}
		}

		internal bool ProhibitDtd
		{
			get
			{
				return prohibitDtd;
			}
			set
			{
				prohibitDtd = value;
			}
		}

		internal EntityHandling EntityHandling
		{
			get
			{
				return entityHandling;
			}
			set
			{
				if (value != EntityHandling.ExpandEntities && value != EntityHandling.ExpandCharEntities)
				{
					throw new XmlException("Xml_EntityHandling", string.Empty);
				}
				entityHandling = value;
			}
		}

		internal XmlResolver XmlResolver
		{
			set
			{
				xmlResolver = value;
				xmlResolverIsSet = true;
				ps.baseUri = null;
				for (int i = 0; i <= parsingStatesStackTop; i++)
				{
					parsingStatesStack[i].baseUri = null;
				}
			}
		}

		internal XmlNameTable DtdParserProxy_NameTable => nameTable;

		internal XmlNamespaceManager DtdParserProxy_NamespaceManager => namespaceManager;

		internal bool DtdParserProxy_DtdValidation => DtdValidation;

		internal bool DtdParserProxy_Normalization => normalize;

		internal bool DtdParserProxy_Namespaces => supportNamespaces;

		internal bool DtdParserProxy_V1CompatibilityMode => v1Compat;

		internal Uri DtdParserProxy_BaseUri
		{
			get
			{
				if (ps.baseUriStr.Length > 0 && ps.baseUri == null && xmlResolver != null)
				{
					ps.baseUri = xmlResolver.ResolveUri(null, ps.baseUriStr);
				}
				return ps.baseUri;
			}
		}

		internal bool DtdParserProxy_IsEof => ps.isEof;

		internal char[] DtdParserProxy_ParsingBuffer => ps.chars;

		internal int DtdParserProxy_ParsingBufferLength => ps.charsUsed;

		internal int DtdParserProxy_CurrentPosition
		{
			get
			{
				return ps.charPos;
			}
			set
			{
				ps.charPos = value;
			}
		}

		internal int DtdParserProxy_EntityStackLength => parsingStatesStackTop + 1;

		internal bool DtdParserProxy_IsEntityEolNormalized => ps.eolNormalized;

		internal ValidationEventHandler DtdParserProxy_EventHandler
		{
			get
			{
				return validationEventHandler;
			}
			set
			{
				validationEventHandler = value;
			}
		}

		internal int DtdParserProxy_LineNo => ps.LineNo;

		internal int DtdParserProxy_LineStartPosition => ps.lineStartPos;

		private bool IsResolverNull
		{
			get
			{
				if (xmlResolver != null)
				{
					if (XmlReaderSection.ProhibitDefaultUrlResolver)
					{
						return !xmlResolverIsSet;
					}
					return false;
				}
				return true;
			}
		}

		private bool InAttributeValueIterator
		{
			get
			{
				if (attrCount > 0)
				{
					return parsingFunction >= ParsingFunction.InReadAttributeValue;
				}
				return false;
			}
		}

		private bool DtdValidation => validationEventHandler != null;

		private bool InEntity => parsingStatesStackTop >= 0;

		internal SchemaInfo DtdSchemaInfo
		{
			get
			{
				if (dtdParserProxy != null)
				{
					return dtdParserProxy.DtdSchemaInfo;
				}
				return null;
			}
			set
			{
				if (value != null)
				{
					dtdParserProxy = new DtdParserProxy(this, value);
					if ((validatingReaderCompatFlag || !v1Compat) && (value.HasDefaultAttributes || value.HasNonCDataAttributes))
					{
						addDefaultAttributesAndNormalize = true;
						qName = new XmlQualifiedName();
					}
				}
				else
				{
					dtdParserProxy = null;
				}
			}
		}

		internal bool XmlValidatingReaderCompatibilityMode
		{
			set
			{
				validatingReaderCompatFlag = value;
				if (value)
				{
					nameTable.Add("http://www.w3.org/2001/XMLSchema");
					nameTable.Add("http://www.w3.org/2001/XMLSchema-instance");
					nameTable.Add("urn:schemas-microsoft-com:datatypes");
				}
			}
		}

		internal ValidationEventHandler ValidationEventHandler
		{
			set
			{
				validationEventHandler = value;
			}
		}

		internal XmlNodeType FragmentType => fragmentType;

		internal object InternalSchemaType
		{
			get
			{
				return curNode.schemaType;
			}
			set
			{
				curNode.schemaType = value;
			}
		}

		internal object InternalTypedValue
		{
			get
			{
				return curNode.typedValue;
			}
			set
			{
				curNode.typedValue = value;
			}
		}

		internal bool StandAlone => standalone;

		internal override XmlNamespaceManager NamespaceManager => namespaceManager;

		internal bool V1Compat => v1Compat;

		internal ConformanceLevel V1ComformanceLevel
		{
			get
			{
				if (fragmentType != XmlNodeType.Element)
				{
					return ConformanceLevel.Document;
				}
				return ConformanceLevel.Fragment;
			}
		}

		internal bool DisableUndeclaredEntityCheck
		{
			set
			{
				disableUndeclaredEntityCheck = value;
			}
		}

		internal XmlTextReaderImpl()
		{
			curNode = new NodeData();
			parsingFunction = ParsingFunction.NoData;
		}

		internal XmlTextReaderImpl(XmlNameTable nt)
		{
			v1Compat = true;
			outerReader = this;
			nameTable = nt;
			nt.Add(string.Empty);
			xmlResolver = new XmlUrlResolver();
			Xml = nt.Add("xml");
			XmlNs = nt.Add("xmlns");
			nodes = new NodeData[8];
			nodes[0] = new NodeData();
			curNode = nodes[0];
			stringBuilder = new BufferBuilder();
			xmlContext = new XmlContext();
			parsingFunction = ParsingFunction.SwitchToInteractiveXmlDecl;
			nextParsingFunction = ParsingFunction.DocumentContent;
			entityHandling = EntityHandling.ExpandCharEntities;
			whitespaceHandling = WhitespaceHandling.All;
			closeInput = true;
			maxCharactersInDocument = 0L;
			maxCharactersFromEntities = 10000000L;
			charactersInDocument = 0L;
			charactersFromEntities = 0L;
			ps.lineNo = 1;
			ps.lineStartPos = -1;
		}

		private XmlTextReaderImpl(XmlResolver resolver, XmlReaderSettings settings, XmlParserContext context)
		{
			v1Compat = false;
			outerReader = this;
			xmlContext = new XmlContext();
			XmlNameTable xmlNameTable = settings.NameTable;
			if (context == null)
			{
				if (xmlNameTable == null)
				{
					xmlNameTable = new NameTable();
				}
				else
				{
					nameTableFromSettings = true;
				}
				nameTable = xmlNameTable;
				namespaceManager = new XmlNamespaceManager(xmlNameTable);
			}
			else
			{
				SetupFromParserContext(context, settings);
				xmlNameTable = nameTable;
			}
			xmlNameTable.Add(string.Empty);
			Xml = xmlNameTable.Add("xml");
			XmlNs = xmlNameTable.Add("xmlns");
			xmlResolver = resolver;
			nodes = new NodeData[8];
			nodes[0] = new NodeData();
			curNode = nodes[0];
			stringBuilder = new BufferBuilder();
			entityHandling = EntityHandling.ExpandEntities;
			xmlResolverIsSet = settings.IsXmlResolverSet;
			whitespaceHandling = (settings.IgnoreWhitespace ? WhitespaceHandling.Significant : WhitespaceHandling.All);
			normalize = true;
			ignorePIs = settings.IgnoreProcessingInstructions;
			ignoreComments = settings.IgnoreComments;
			checkCharacters = settings.CheckCharacters;
			lineNumberOffset = settings.LineNumberOffset;
			linePositionOffset = settings.LinePositionOffset;
			ps.lineNo = lineNumberOffset + 1;
			ps.lineStartPos = -linePositionOffset - 1;
			curNode.SetLineInfo(ps.LineNo - 1, ps.LinePos - 1);
			prohibitDtd = settings.ProhibitDtd;
			maxCharactersInDocument = settings.MaxCharactersInDocument;
			maxCharactersFromEntities = settings.MaxCharactersFromEntities;
			charactersInDocument = 0L;
			charactersFromEntities = 0L;
			fragmentParserContext = context;
			parsingFunction = ParsingFunction.SwitchToInteractiveXmlDecl;
			nextParsingFunction = ParsingFunction.DocumentContent;
			switch (settings.ConformanceLevel)
			{
			case ConformanceLevel.Auto:
				fragmentType = XmlNodeType.None;
				fragment = true;
				break;
			case ConformanceLevel.Fragment:
				fragmentType = XmlNodeType.Element;
				fragment = true;
				break;
			default:
				fragmentType = XmlNodeType.Document;
				break;
			}
		}

		internal XmlTextReaderImpl(Stream input)
			: this(string.Empty, input, new NameTable())
		{
		}

		internal XmlTextReaderImpl(Stream input, XmlNameTable nt)
			: this(string.Empty, input, nt)
		{
		}

		internal XmlTextReaderImpl(string url, Stream input)
			: this(url, input, new NameTable())
		{
		}

		internal XmlTextReaderImpl(string url, Stream input, XmlNameTable nt)
			: this(nt)
		{
			namespaceManager = new XmlNamespaceManager(nt);
			if (url == null || url.Length == 0)
			{
				InitStreamInput(input, null);
			}
			else
			{
				InitStreamInput(url, input, null);
			}
			reportedBaseUri = ps.baseUriStr;
			reportedEncoding = ps.encoding;
		}

		internal XmlTextReaderImpl(TextReader input)
			: this(string.Empty, input, new NameTable())
		{
		}

		internal XmlTextReaderImpl(TextReader input, XmlNameTable nt)
			: this(string.Empty, input, nt)
		{
		}

		internal XmlTextReaderImpl(string url, TextReader input)
			: this(url, input, new NameTable())
		{
		}

		internal XmlTextReaderImpl(string url, TextReader input, XmlNameTable nt)
			: this(nt)
		{
			namespaceManager = new XmlNamespaceManager(nt);
			reportedBaseUri = ((url != null) ? url : string.Empty);
			InitTextReaderInput(reportedBaseUri, input);
			reportedEncoding = ps.encoding;
		}

		internal XmlTextReaderImpl(Stream xmlFragment, XmlNodeType fragType, XmlParserContext context)
			: this((context != null && context.NameTable != null) ? context.NameTable : new NameTable())
		{
			Encoding encoding = context?.Encoding;
			if (context == null || context.BaseURI == null || context.BaseURI.Length == 0)
			{
				InitStreamInput(xmlFragment, encoding);
			}
			else
			{
				InitStreamInput(xmlResolver.ResolveUri(null, context.BaseURI), xmlFragment, encoding);
			}
			InitFragmentReader(fragType, context, allowXmlDeclFragment: false);
			reportedBaseUri = ps.baseUriStr;
			reportedEncoding = ps.encoding;
		}

		internal XmlTextReaderImpl(string xmlFragment, XmlNodeType fragType, XmlParserContext context)
			: this((context == null || context.NameTable == null) ? new NameTable() : context.NameTable)
		{
			if (context == null)
			{
				InitStringInput(string.Empty, Encoding.Unicode, xmlFragment);
			}
			else
			{
				reportedBaseUri = context.BaseURI;
				InitStringInput(context.BaseURI, Encoding.Unicode, xmlFragment);
			}
			InitFragmentReader(fragType, context, allowXmlDeclFragment: false);
			reportedEncoding = ps.encoding;
		}

		internal XmlTextReaderImpl(string xmlFragment, XmlParserContext context)
			: this((context == null || context.NameTable == null) ? new NameTable() : context.NameTable)
		{
			InitStringInput((context == null) ? string.Empty : context.BaseURI, Encoding.Unicode, "<?xml " + xmlFragment + "?>");
			InitFragmentReader(XmlNodeType.XmlDeclaration, context, allowXmlDeclFragment: true);
		}

		public XmlTextReaderImpl(string url)
			: this(url, new NameTable())
		{
		}

		public XmlTextReaderImpl(string url, XmlNameTable nt)
			: this(nt)
		{
			if (url == null)
			{
				throw new ArgumentNullException("url");
			}
			if (url.Length == 0)
			{
				throw new ArgumentException(Res.GetString("Xml_EmptyUrl"), "url");
			}
			namespaceManager = new XmlNamespaceManager(nt);
			compressedStack = CompressedStack.Capture();
			this.url = url;
			ps.baseUri = xmlResolver.ResolveUri(null, url);
			ps.baseUriStr = ps.baseUri.ToString();
			reportedBaseUri = ps.baseUriStr;
			parsingFunction = ParsingFunction.OpenUrl;
		}

		internal XmlTextReaderImpl(Stream stream, byte[] bytes, int byteCount, XmlReaderSettings settings, Uri baseUri, string baseUriStr, XmlParserContext context, bool closeInput)
			: this(settings.GetXmlResolver(), settings, context)
		{
			Encoding encoding = null;
			if (context != null)
			{
				if (context.BaseURI != null && context.BaseURI.Length > 0 && !UriEqual(baseUri, baseUriStr, context.BaseURI, settings.GetXmlResolver()))
				{
					if (baseUriStr.Length > 0)
					{
						Throw("Xml_DoubleBaseUri");
					}
					baseUriStr = context.BaseURI;
				}
				encoding = context.Encoding;
			}
			InitStreamInput(baseUri, baseUriStr, stream, bytes, byteCount, encoding);
			this.closeInput = closeInput;
			reportedBaseUri = ps.baseUriStr;
			reportedEncoding = ps.encoding;
			if (context != null && context.HasDtdInfo)
			{
				if (prohibitDtd)
				{
					ThrowWithoutLineInfo("Xml_DtdIsProhibitedEx", string.Empty);
				}
				ParseDtdFromParserContext();
			}
		}

		internal XmlTextReaderImpl(TextReader input, XmlReaderSettings settings, string baseUriStr, XmlParserContext context)
			: this(settings.GetXmlResolver(), settings, context)
		{
			if (context != null && context.BaseURI != null)
			{
				baseUriStr = context.BaseURI;
			}
			InitTextReaderInput(baseUriStr, input);
			closeInput = settings.CloseInput;
			reportedBaseUri = ps.baseUriStr;
			reportedEncoding = ps.encoding;
			if (context != null && context.HasDtdInfo)
			{
				if (prohibitDtd)
				{
					ThrowWithoutLineInfo("Xml_DtdIsProhibitedEx", string.Empty);
				}
				ParseDtdFromParserContext();
			}
		}

		internal XmlTextReaderImpl(string xmlFragment, XmlParserContext context, XmlReaderSettings settings)
			: this(null, settings, context)
		{
			InitStringInput(string.Empty, Encoding.Unicode, xmlFragment);
			reportedBaseUri = ps.baseUriStr;
			reportedEncoding = ps.encoding;
		}

		public override string GetAttribute(string name)
		{
			int num = ((name.IndexOf(':') != -1) ? GetIndexOfAttributeWithPrefix(name) : GetIndexOfAttributeWithoutPrefix(name));
			if (num < 0)
			{
				return null;
			}
			return nodes[num].StringValue;
		}

		public override string GetAttribute(string localName, string namespaceURI)
		{
			namespaceURI = ((namespaceURI == null) ? string.Empty : nameTable.Get(namespaceURI));
			localName = nameTable.Get(localName);
			for (int i = index + 1; i < index + attrCount + 1; i++)
			{
				if (Ref.Equal(nodes[i].localName, localName) && Ref.Equal(nodes[i].ns, namespaceURI))
				{
					return nodes[i].StringValue;
				}
			}
			return null;
		}

		public override string GetAttribute(int i)
		{
			if (i < 0 || i >= attrCount)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			return nodes[index + i + 1].StringValue;
		}

		public override bool MoveToAttribute(string name)
		{
			int num = ((name.IndexOf(':') != -1) ? GetIndexOfAttributeWithPrefix(name) : GetIndexOfAttributeWithoutPrefix(name));
			if (num >= 0)
			{
				if (InAttributeValueIterator)
				{
					FinishAttributeValueIterator();
				}
				curAttrIndex = num - index - 1;
				curNode = nodes[num];
				return true;
			}
			return false;
		}

		public override bool MoveToAttribute(string localName, string namespaceURI)
		{
			namespaceURI = ((namespaceURI == null) ? string.Empty : nameTable.Get(namespaceURI));
			localName = nameTable.Get(localName);
			for (int i = index + 1; i < index + attrCount + 1; i++)
			{
				if (Ref.Equal(nodes[i].localName, localName) && Ref.Equal(nodes[i].ns, namespaceURI))
				{
					curAttrIndex = i - index - 1;
					curNode = nodes[i];
					if (InAttributeValueIterator)
					{
						FinishAttributeValueIterator();
					}
					return true;
				}
			}
			return false;
		}

		public override void MoveToAttribute(int i)
		{
			if (i < 0 || i >= attrCount)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			if (InAttributeValueIterator)
			{
				FinishAttributeValueIterator();
			}
			curAttrIndex = i;
			curNode = nodes[index + 1 + curAttrIndex];
		}

		public override bool MoveToFirstAttribute()
		{
			if (attrCount == 0)
			{
				return false;
			}
			if (InAttributeValueIterator)
			{
				FinishAttributeValueIterator();
			}
			curAttrIndex = 0;
			curNode = nodes[index + 1];
			return true;
		}

		public override bool MoveToNextAttribute()
		{
			if (curAttrIndex + 1 < attrCount)
			{
				if (InAttributeValueIterator)
				{
					FinishAttributeValueIterator();
				}
				curNode = nodes[index + 1 + ++curAttrIndex];
				return true;
			}
			return false;
		}

		public override bool MoveToElement()
		{
			if (InAttributeValueIterator)
			{
				FinishAttributeValueIterator();
			}
			else if (curNode.type != XmlNodeType.Attribute)
			{
				return false;
			}
			curAttrIndex = -1;
			curNode = nodes[index];
			return true;
		}

		public override bool Read()
		{
			while (true)
			{
				switch (parsingFunction)
				{
				case ParsingFunction.ElementContent:
					return ParseElementContent();
				case ParsingFunction.DocumentContent:
					return ParseDocumentContent();
				case ParsingFunction.OpenUrl:
					OpenUrl();
					goto case ParsingFunction.SwitchToInteractiveXmlDecl;
				case ParsingFunction.SwitchToInteractive:
					readState = ReadState.Interactive;
					parsingFunction = nextParsingFunction;
					break;
				case ParsingFunction.SwitchToInteractiveXmlDecl:
					readState = ReadState.Interactive;
					parsingFunction = nextParsingFunction;
					if (ParseXmlDeclaration(isTextDecl: false))
					{
						reportedEncoding = ps.encoding;
						return true;
					}
					reportedEncoding = ps.encoding;
					break;
				case ParsingFunction.ResetAttributesRootLevel:
					ResetAttributes();
					curNode = nodes[index];
					parsingFunction = ((index == 0) ? ParsingFunction.DocumentContent : ParsingFunction.ElementContent);
					break;
				case ParsingFunction.MoveToElementContent:
					ResetAttributes();
					index++;
					curNode = AddNode(index, index);
					parsingFunction = ParsingFunction.ElementContent;
					break;
				case ParsingFunction.PopElementContext:
					PopElementContext();
					parsingFunction = nextParsingFunction;
					break;
				case ParsingFunction.PopEmptyElementContext:
					curNode = nodes[index];
					curNode.IsEmptyElement = false;
					ResetAttributes();
					PopElementContext();
					parsingFunction = nextParsingFunction;
					break;
				case ParsingFunction.EntityReference:
					parsingFunction = nextParsingFunction;
					ParseEntityReference();
					return true;
				case ParsingFunction.ReportEndEntity:
					SetupEndEntityNodeInContent();
					parsingFunction = nextParsingFunction;
					return true;
				case ParsingFunction.AfterResolveEntityInContent:
					curNode = AddNode(index, index);
					reportedEncoding = ps.encoding;
					reportedBaseUri = ps.baseUriStr;
					parsingFunction = nextParsingFunction;
					break;
				case ParsingFunction.AfterResolveEmptyEntityInContent:
					curNode = AddNode(index, index);
					curNode.SetValueNode(XmlNodeType.Text, string.Empty);
					curNode.SetLineInfo(ps.lineNo, ps.LinePos);
					reportedEncoding = ps.encoding;
					reportedBaseUri = ps.baseUriStr;
					parsingFunction = nextParsingFunction;
					return true;
				case ParsingFunction.InReadAttributeValue:
					FinishAttributeValueIterator();
					curNode = nodes[index];
					break;
				case ParsingFunction.InIncrementalRead:
					FinishIncrementalRead();
					return true;
				case ParsingFunction.FragmentAttribute:
					return ParseFragmentAttribute();
				case ParsingFunction.XmlDeclarationFragment:
					ParseXmlDeclarationFragment();
					parsingFunction = ParsingFunction.GoToEof;
					return true;
				case ParsingFunction.GoToEof:
					OnEof();
					return false;
				case ParsingFunction.Error:
				case ParsingFunction.Eof:
				case ParsingFunction.ReaderClosed:
					return false;
				case ParsingFunction.NoData:
					ThrowWithoutLineInfo("Xml_MissingRoot");
					return false;
				case ParsingFunction.PartialTextValue:
					SkipPartialTextValue();
					break;
				case ParsingFunction.InReadValueChunk:
					FinishReadValueChunk();
					break;
				case ParsingFunction.InReadContentAsBinary:
					FinishReadContentAsBinary();
					break;
				case ParsingFunction.InReadElementContentAsBinary:
					FinishReadElementContentAsBinary();
					break;
				}
			}
		}

		public override void Close()
		{
			Close(closeInput);
		}

		public override void Skip()
		{
			if (readState != ReadState.Interactive)
			{
				return;
			}
			if (InAttributeValueIterator)
			{
				FinishAttributeValueIterator();
				curNode = nodes[index];
			}
			else
			{
				switch (parsingFunction)
				{
				case ParsingFunction.InIncrementalRead:
					FinishIncrementalRead();
					break;
				case ParsingFunction.PartialTextValue:
					SkipPartialTextValue();
					break;
				case ParsingFunction.InReadValueChunk:
					FinishReadValueChunk();
					break;
				case ParsingFunction.InReadContentAsBinary:
					FinishReadContentAsBinary();
					break;
				case ParsingFunction.InReadElementContentAsBinary:
					FinishReadElementContentAsBinary();
					break;
				}
			}
			switch (curNode.type)
			{
			case XmlNodeType.Element:
				if (!curNode.IsEmptyElement)
				{
					int num = index;
					parsingMode = ParsingMode.SkipContent;
					while (outerReader.Read() && index > num)
					{
					}
					parsingMode = ParsingMode.Full;
				}
				break;
			case XmlNodeType.Attribute:
				outerReader.MoveToElement();
				goto case XmlNodeType.Element;
			}
			outerReader.Read();
		}

		public override string LookupNamespace(string prefix)
		{
			if (!supportNamespaces)
			{
				return null;
			}
			return namespaceManager.LookupNamespace(prefix);
		}

		public override bool ReadAttributeValue()
		{
			if (parsingFunction != ParsingFunction.InReadAttributeValue)
			{
				if (curNode.type != XmlNodeType.Attribute)
				{
					return false;
				}
				if (readState != ReadState.Interactive || curAttrIndex < 0)
				{
					return false;
				}
				if (parsingFunction == ParsingFunction.InReadValueChunk)
				{
					FinishReadValueChunk();
				}
				if (parsingFunction == ParsingFunction.InReadContentAsBinary)
				{
					FinishReadContentAsBinary();
				}
				if (curNode.nextAttrValueChunk == null || entityHandling == EntityHandling.ExpandEntities)
				{
					NodeData nodeData = AddNode(index + attrCount + 1, curNode.depth + 1);
					nodeData.SetValueNode(XmlNodeType.Text, curNode.StringValue);
					nodeData.lineInfo = curNode.lineInfo2;
					nodeData.depth = curNode.depth + 1;
					nodeData.nextAttrValueChunk = null;
					curNode = nodeData;
				}
				else
				{
					curNode = curNode.nextAttrValueChunk;
					AddNode(index + attrCount + 1, index + 2);
					nodes[index + attrCount + 1] = curNode;
					fullAttrCleanup = true;
				}
				nextParsingFunction = parsingFunction;
				parsingFunction = ParsingFunction.InReadAttributeValue;
				attributeValueBaseEntityId = ps.entityId;
				return true;
			}
			if (ps.entityId == attributeValueBaseEntityId)
			{
				if (curNode.nextAttrValueChunk != null)
				{
					curNode = curNode.nextAttrValueChunk;
					nodes[index + attrCount + 1] = curNode;
					return true;
				}
				return false;
			}
			return ParseAttributeValueChunk();
		}

		public override void ResolveEntity()
		{
			if (curNode.type != XmlNodeType.EntityReference)
			{
				throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
			}
			if (parsingFunction == ParsingFunction.InReadAttributeValue || parsingFunction == ParsingFunction.FragmentAttribute)
			{
				switch (HandleGeneralEntityReference(curNode.localName, isInAttributeValue: true, pushFakeEntityIfNullResolver: true, curNode.LinePos))
				{
				case EntityType.Expanded:
				case EntityType.ExpandedInAttribute:
					if (ps.charsUsed - ps.charPos == 0)
					{
						emptyEntityInAttributeResolved = true;
					}
					break;
				case EntityType.FakeExpanded:
					emptyEntityInAttributeResolved = true;
					break;
				default:
					throw new XmlException("Xml_InternalError");
				}
			}
			else
			{
				switch (HandleGeneralEntityReference(curNode.localName, isInAttributeValue: false, pushFakeEntityIfNullResolver: true, curNode.LinePos))
				{
				case EntityType.Expanded:
				case EntityType.ExpandedInAttribute:
					nextParsingFunction = parsingFunction;
					if (ps.charsUsed - ps.charPos == 0 && !ps.entity.IsExternal)
					{
						parsingFunction = ParsingFunction.AfterResolveEmptyEntityInContent;
					}
					else
					{
						parsingFunction = ParsingFunction.AfterResolveEntityInContent;
					}
					break;
				case EntityType.FakeExpanded:
					nextParsingFunction = parsingFunction;
					parsingFunction = ParsingFunction.AfterResolveEmptyEntityInContent;
					break;
				default:
					throw new XmlException("Xml_InternalError");
				}
			}
			ps.entityResolvedManually = true;
			index++;
		}

		internal void MoveOffEntityReference()
		{
			if (outerReader.NodeType == XmlNodeType.EntityReference && parsingFunction == ParsingFunction.AfterResolveEntityInContent && !outerReader.Read())
			{
				throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
			}
		}

		public override string ReadString()
		{
			MoveOffEntityReference();
			return base.ReadString();
		}

		public override int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (buffer.Length - index < count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (parsingFunction == ParsingFunction.InReadContentAsBinary)
			{
				if (incReadDecoder == base64Decoder)
				{
					return ReadContentAsBinary(buffer, index, count);
				}
			}
			else
			{
				if (readState != ReadState.Interactive)
				{
					return 0;
				}
				if (parsingFunction == ParsingFunction.InReadElementContentAsBinary)
				{
					throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
				}
				if (!XmlReader.CanReadContentAs(curNode.type))
				{
					throw CreateReadContentAsException("ReadContentAsBase64");
				}
				if (!InitReadContentAsBinary())
				{
					return 0;
				}
			}
			InitBase64Decoder();
			return ReadContentAsBinary(buffer, index, count);
		}

		public override int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (buffer.Length - index < count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (parsingFunction == ParsingFunction.InReadContentAsBinary)
			{
				if (incReadDecoder == binHexDecoder)
				{
					return ReadContentAsBinary(buffer, index, count);
				}
			}
			else
			{
				if (readState != ReadState.Interactive)
				{
					return 0;
				}
				if (parsingFunction == ParsingFunction.InReadElementContentAsBinary)
				{
					throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
				}
				if (!XmlReader.CanReadContentAs(curNode.type))
				{
					throw CreateReadContentAsException("ReadContentAsBinHex");
				}
				if (!InitReadContentAsBinary())
				{
					return 0;
				}
			}
			InitBinHexDecoder();
			return ReadContentAsBinary(buffer, index, count);
		}

		public override int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (buffer.Length - index < count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (parsingFunction == ParsingFunction.InReadElementContentAsBinary)
			{
				if (incReadDecoder == base64Decoder)
				{
					return ReadElementContentAsBinary(buffer, index, count);
				}
			}
			else
			{
				if (readState != ReadState.Interactive)
				{
					return 0;
				}
				if (parsingFunction == ParsingFunction.InReadContentAsBinary)
				{
					throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
				}
				if (curNode.type != XmlNodeType.Element)
				{
					throw CreateReadElementContentAsException("ReadElementContentAsBinHex");
				}
				if (!InitReadElementContentAsBinary())
				{
					return 0;
				}
			}
			InitBase64Decoder();
			return ReadElementContentAsBinary(buffer, index, count);
		}

		public override int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (buffer.Length - index < count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (parsingFunction == ParsingFunction.InReadElementContentAsBinary)
			{
				if (incReadDecoder == binHexDecoder)
				{
					return ReadElementContentAsBinary(buffer, index, count);
				}
			}
			else
			{
				if (readState != ReadState.Interactive)
				{
					return 0;
				}
				if (parsingFunction == ParsingFunction.InReadContentAsBinary)
				{
					throw new InvalidOperationException(Res.GetString("Xml_MixingBinaryContentMethods"));
				}
				if (curNode.type != XmlNodeType.Element)
				{
					throw CreateReadElementContentAsException("ReadElementContentAsBinHex");
				}
				if (!InitReadElementContentAsBinary())
				{
					return 0;
				}
			}
			InitBinHexDecoder();
			return ReadElementContentAsBinary(buffer, index, count);
		}

		public override int ReadValueChunk(char[] buffer, int index, int count)
		{
			if (!XmlReader.HasValueInternal(curNode.type))
			{
				throw new InvalidOperationException(Res.GetString("Xml_InvalidReadValueChunk", curNode.type));
			}
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (buffer.Length - index < count)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (parsingFunction != ParsingFunction.InReadValueChunk)
			{
				if (readState != ReadState.Interactive)
				{
					return 0;
				}
				if (parsingFunction == ParsingFunction.PartialTextValue)
				{
					incReadState = IncrementalReadState.ReadValueChunk_OnPartialValue;
				}
				else
				{
					incReadState = IncrementalReadState.ReadValueChunk_OnCachedValue;
					nextNextParsingFunction = nextParsingFunction;
					nextParsingFunction = parsingFunction;
				}
				parsingFunction = ParsingFunction.InReadValueChunk;
				readValueOffset = 0;
			}
			if (count == 0)
			{
				return 0;
			}
			int num = 0;
			int num2 = curNode.CopyTo(readValueOffset, buffer, index + num, count - num);
			num += num2;
			readValueOffset += num2;
			if (num == count)
			{
				char c = buffer[index + count - 1];
				if (c >= '\ud800' && c <= '\udbff')
				{
					num--;
					readValueOffset--;
					if (num == 0)
					{
						Throw("Xml_NotEnoughSpaceForSurrogatePair");
					}
				}
				return num;
			}
			if (incReadState == IncrementalReadState.ReadValueChunk_OnPartialValue)
			{
				curNode.SetValue(string.Empty);
				bool flag = false;
				int startPos = 0;
				int endPos = 0;
				while (num < count && !flag)
				{
					int outOrChars = 0;
					flag = ParseText(out startPos, out endPos, ref outOrChars);
					int num3 = count - num;
					if (num3 > endPos - startPos)
					{
						num3 = endPos - startPos;
					}
					Buffer.BlockCopy(ps.chars, startPos * 2, buffer, (index + num) * 2, num3 * 2);
					num += num3;
					startPos += num3;
				}
				incReadState = (flag ? IncrementalReadState.ReadValueChunk_OnCachedValue : IncrementalReadState.ReadValueChunk_OnPartialValue);
				if (num == count)
				{
					char c2 = buffer[index + count - 1];
					if (c2 >= '\ud800' && c2 <= '\udbff')
					{
						num--;
						startPos--;
						if (num == 0)
						{
							Throw("Xml_NotEnoughSpaceForSurrogatePair");
						}
					}
				}
				readValueOffset = 0;
				curNode.SetValue(ps.chars, startPos, endPos - startPos);
			}
			return num;
		}

		public bool HasLineInfo()
		{
			return true;
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return GetNamespacesInScope(scope);
		}

		string IXmlNamespaceResolver.LookupNamespace(string prefix)
		{
			return LookupNamespace(prefix);
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			return LookupPrefix(namespaceName);
		}

		internal IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return namespaceManager.GetNamespacesInScope(scope);
		}

		internal string LookupPrefix(string namespaceName)
		{
			return namespaceManager.LookupPrefix(namespaceName);
		}

		internal void ResetState()
		{
			if (fragment)
			{
				Throw(new InvalidOperationException(Res.GetString("Xml_InvalidResetStateCall")));
			}
			if (readState != 0)
			{
				ResetAttributes();
				while (namespaceManager.PopScope())
				{
				}
				while (InEntity)
				{
					HandleEntityEnd(checkEntityNesting: true);
				}
				readState = ReadState.Initial;
				parsingFunction = ParsingFunction.SwitchToInteractiveXmlDecl;
				nextParsingFunction = ParsingFunction.DocumentContent;
				curNode = nodes[0];
				curNode.Clear(XmlNodeType.None);
				curNode.SetLineInfo(0, 0);
				index = 0;
				rootElementParsed = false;
				charactersInDocument = 0L;
				charactersFromEntities = 0L;
				afterResetState = true;
			}
		}

		internal TextReader GetRemainder()
		{
			switch (parsingFunction)
			{
			case ParsingFunction.Eof:
			case ParsingFunction.ReaderClosed:
				return new StringReader(string.Empty);
			case ParsingFunction.OpenUrl:
				OpenUrl();
				break;
			case ParsingFunction.InIncrementalRead:
				if (!InEntity)
				{
					stringBuilder.Append(ps.chars, incReadLeftStartPos, incReadLeftEndPos - incReadLeftStartPos);
				}
				break;
			}
			while (InEntity)
			{
				HandleEntityEnd(checkEntityNesting: true);
			}
			ps.appendMode = false;
			do
			{
				stringBuilder.Append(ps.chars, ps.charPos, ps.charsUsed - ps.charPos);
				ps.charPos = ps.charsUsed;
			}
			while (ReadData() != 0);
			OnEof();
			string s = stringBuilder.ToString();
			stringBuilder.Length = 0;
			return new StringReader(s);
		}

		internal int ReadChars(char[] buffer, int index, int count)
		{
			if (parsingFunction == ParsingFunction.InIncrementalRead)
			{
				if (incReadDecoder != readCharsDecoder)
				{
					if (readCharsDecoder == null)
					{
						readCharsDecoder = new IncrementalReadCharsDecoder();
					}
					readCharsDecoder.Reset();
					incReadDecoder = readCharsDecoder;
				}
				return IncrementalRead(buffer, index, count);
			}
			if (curNode.type != XmlNodeType.Element)
			{
				return 0;
			}
			if (curNode.IsEmptyElement)
			{
				outerReader.Read();
				return 0;
			}
			if (readCharsDecoder == null)
			{
				readCharsDecoder = new IncrementalReadCharsDecoder();
			}
			InitIncrementalRead(readCharsDecoder);
			return IncrementalRead(buffer, index, count);
		}

		internal int ReadBase64(byte[] array, int offset, int len)
		{
			if (parsingFunction == ParsingFunction.InIncrementalRead)
			{
				if (incReadDecoder != base64Decoder)
				{
					InitBase64Decoder();
				}
				return IncrementalRead(array, offset, len);
			}
			if (curNode.type != XmlNodeType.Element)
			{
				return 0;
			}
			if (curNode.IsEmptyElement)
			{
				outerReader.Read();
				return 0;
			}
			if (base64Decoder == null)
			{
				base64Decoder = new Base64Decoder();
			}
			InitIncrementalRead(base64Decoder);
			return IncrementalRead(array, offset, len);
		}

		internal int ReadBinHex(byte[] array, int offset, int len)
		{
			if (parsingFunction == ParsingFunction.InIncrementalRead)
			{
				if (incReadDecoder != binHexDecoder)
				{
					InitBinHexDecoder();
				}
				return IncrementalRead(array, offset, len);
			}
			if (curNode.type != XmlNodeType.Element)
			{
				return 0;
			}
			if (curNode.IsEmptyElement)
			{
				outerReader.Read();
				return 0;
			}
			if (binHexDecoder == null)
			{
				binHexDecoder = new BinHexDecoder();
			}
			InitIncrementalRead(binHexDecoder);
			return IncrementalRead(array, offset, len);
		}

		internal void DtdParserProxy_OnNewLine(int pos)
		{
			OnNewLine(pos);
		}

		internal int DtdParserProxy_ReadData()
		{
			return ReadData();
		}

		internal void DtdParserProxy_SendValidationEvent(XmlSeverityType severity, XmlSchemaException exception)
		{
			if (DtdValidation)
			{
				SendValidationEvent(severity, exception);
			}
		}

		internal int DtdParserProxy_ParseNumericCharRef(BufferBuilder internalSubsetBuilder)
		{
			EntityType entityType;
			return ParseNumericCharRef(expand: true, internalSubsetBuilder, out entityType);
		}

		internal int DtdParserProxy_ParseNamedCharRef(bool expand, BufferBuilder internalSubsetBuilder)
		{
			return ParseNamedCharRef(expand, internalSubsetBuilder);
		}

		internal void DtdParserProxy_ParsePI(BufferBuilder sb)
		{
			if (sb == null)
			{
				ParsingMode parsingMode = this.parsingMode;
				this.parsingMode = ParsingMode.SkipNode;
				ParsePI(null);
				this.parsingMode = parsingMode;
			}
			else
			{
				ParsePI(sb);
			}
		}

		internal void DtdParserProxy_ParseComment(BufferBuilder sb)
		{
			try
			{
				if (sb == null)
				{
					ParsingMode parsingMode = this.parsingMode;
					this.parsingMode = ParsingMode.SkipNode;
					ParseCDataOrComment(XmlNodeType.Comment);
					this.parsingMode = parsingMode;
				}
				else
				{
					NodeData nodeData = curNode;
					curNode = AddNode(index + attrCount + 1, index);
					ParseCDataOrComment(XmlNodeType.Comment);
					curNode.CopyTo(sb);
					curNode = nodeData;
				}
			}
			catch (XmlException ex)
			{
				if (ex.ResString == "Xml_UnexpectedEOF" && ps.entity != null)
				{
					SendValidationEvent(XmlSeverityType.Error, "Sch_ParEntityRefNesting", null, ps.LineNo, ps.LinePos);
					return;
				}
				throw;
			}
		}

		internal bool DtdParserProxy_PushEntity(SchemaEntity entity, int entityId)
		{
			if (entity.IsExternal)
			{
				if (IsResolverNull)
				{
					return false;
				}
				return PushExternalEntity(entity, entityId);
			}
			PushInternalEntity(entity, entityId);
			return true;
		}

		internal bool DtdParserProxy_PopEntity(out SchemaEntity oldEntity, out int newEntityId)
		{
			if (parsingStatesStackTop == -1)
			{
				oldEntity = null;
				newEntityId = -1;
				return false;
			}
			oldEntity = ps.entity;
			PopEntity();
			newEntityId = ps.entityId;
			return true;
		}

		internal bool DtdParserProxy_PushExternalSubset(string systemId, string publicId)
		{
			if (IsResolverNull)
			{
				return false;
			}
			if (ps.baseUriStr.Length > 0 && ps.baseUri == null)
			{
				ps.baseUri = xmlResolver.ResolveUri(null, ps.baseUriStr);
			}
			Stream stream = null;
			Uri uri;
			if (publicId == null || publicId.Length == 0)
			{
				uri = xmlResolver.ResolveUri(ps.baseUri, systemId);
				try
				{
					stream = OpenStream(uri);
				}
				catch (Exception ex)
				{
					if (v1Compat)
					{
						throw;
					}
					Throw(new XmlException("Xml_ErrorOpeningExternalDtd", new string[2]
					{
						uri.ToString(),
						ex.Message
					}, ex, 0, 0));
				}
			}
			else
			{
				try
				{
					uri = xmlResolver.ResolveUri(ps.baseUri, publicId);
					stream = OpenStream(uri);
				}
				catch (Exception)
				{
					uri = xmlResolver.ResolveUri(ps.baseUri, systemId);
					try
					{
						stream = OpenStream(uri);
					}
					catch (Exception ex2)
					{
						if (v1Compat)
						{
							throw;
						}
						Throw(new XmlException("Xml_ErrorOpeningExternalDtd", new string[2]
						{
							uri.ToString(),
							ex2.Message
						}, ex2, 0, 0));
					}
				}
			}
			if (stream == null)
			{
				ThrowWithoutLineInfo("Xml_CannotResolveExternalSubset", new string[2]
				{
					(publicId != null) ? publicId : string.Empty,
					systemId
				});
			}
			PushParsingState();
			if (v1Compat)
			{
				InitStreamInput(uri, stream, null);
			}
			else
			{
				InitStreamInput(uri, stream, null);
			}
			ps.entity = null;
			ps.entityId = 0;
			int charPos = ps.charPos;
			if (v1Compat)
			{
				EatWhitespaces(null);
			}
			if (!ParseXmlDeclaration(isTextDecl: true))
			{
				ps.charPos = charPos;
			}
			return true;
		}

		internal void DtdParserProxy_PushInternalDtd(string baseUri, string internalDtd)
		{
			PushParsingState();
			RegisterConsumedCharacters(internalDtd.Length, inEntityReference: false);
			InitStringInput(baseUri, Encoding.Unicode, internalDtd);
			ps.entity = null;
			ps.entityId = 0;
			ps.eolNormalized = false;
		}

		internal void DtdParserProxy_Throw(Exception e)
		{
			Throw(e);
		}

		internal void DtdParserProxy_OnSystemId(string systemId, LineInfo keywordLineInfo, LineInfo systemLiteralLineInfo)
		{
			NodeData nodeData = AddAttributeNoChecks("SYSTEM", index);
			nodeData.SetValue(systemId);
			nodeData.lineInfo = keywordLineInfo;
			nodeData.lineInfo2 = systemLiteralLineInfo;
		}

		internal void DtdParserProxy_OnPublicId(string publicId, LineInfo keywordLineInfo, LineInfo publicLiteralLineInfo)
		{
			NodeData nodeData = AddAttributeNoChecks("PUBLIC", index);
			nodeData.SetValue(publicId);
			nodeData.lineInfo = keywordLineInfo;
			nodeData.lineInfo2 = publicLiteralLineInfo;
		}

		private void Throw(int pos, string res, string arg)
		{
			ps.charPos = pos;
			Throw(res, arg);
		}

		private void Throw(int pos, string res, string[] args)
		{
			ps.charPos = pos;
			Throw(res, args);
		}

		private void Throw(int pos, string res)
		{
			ps.charPos = pos;
			Throw(res, string.Empty);
		}

		private void Throw(string res)
		{
			Throw(res, string.Empty);
		}

		private void Throw(string res, int lineNo, int linePos)
		{
			Throw(new XmlException(res, string.Empty, lineNo, linePos, ps.baseUriStr));
		}

		private void Throw(string res, string arg)
		{
			Throw(new XmlException(res, arg, ps.LineNo, ps.LinePos, ps.baseUriStr));
		}

		private void Throw(string res, string arg, int lineNo, int linePos)
		{
			Throw(new XmlException(res, arg, lineNo, linePos, ps.baseUriStr));
		}

		private void Throw(string res, string[] args)
		{
			Throw(new XmlException(res, args, ps.LineNo, ps.LinePos, ps.baseUriStr));
		}

		private void Throw(Exception e)
		{
			SetErrorState();
			if (e is XmlException ex)
			{
				curNode.SetLineInfo(ex.LineNumber, ex.LinePosition);
			}
			throw e;
		}

		private void ReThrow(Exception e, int lineNo, int linePos)
		{
			Throw(new XmlException(e.Message, (Exception)null, lineNo, linePos, ps.baseUriStr));
		}

		private void ThrowWithoutLineInfo(string res)
		{
			Throw(new XmlException(res, string.Empty, ps.baseUriStr));
		}

		private void ThrowWithoutLineInfo(string res, string arg)
		{
			Throw(new XmlException(res, arg, ps.baseUriStr));
		}

		private void ThrowWithoutLineInfo(string res, string[] args)
		{
			Throw(new XmlException(res, args, ps.baseUriStr));
		}

		private void ThrowInvalidChar(int pos, char invChar)
		{
			if (pos == 0 && curNode.type == XmlNodeType.None && ps.textReader != null && ps.charsUsed >= 2 && ((ps.chars[0] == '\u0001' && ps.chars[1] == '\u0004') || ps.chars[0] == 'ß' || ps.chars[1] == 'ÿ'))
			{
				Throw(pos, "Xml_BinaryXmlReadAsText", XmlException.BuildCharExceptionStr(invChar));
			}
			else
			{
				Throw(pos, "Xml_InvalidCharacter", XmlException.BuildCharExceptionStr(invChar));
			}
		}

		private void SetErrorState()
		{
			parsingFunction = ParsingFunction.Error;
			readState = ReadState.Error;
		}

		private void SendValidationEvent(XmlSeverityType severity, string code, string arg, int lineNo, int linePos)
		{
			SendValidationEvent(severity, new XmlSchemaException(code, arg, ps.baseUriStr, lineNo, linePos));
		}

		private void SendValidationEvent(XmlSeverityType severity, XmlSchemaException exception)
		{
			if (validationEventHandler != null)
			{
				validationEventHandler(this, new ValidationEventArgs(exception, severity));
			}
		}

		private void FinishAttributeValueIterator()
		{
			if (parsingFunction == ParsingFunction.InReadValueChunk)
			{
				FinishReadValueChunk();
			}
			else if (parsingFunction == ParsingFunction.InReadContentAsBinary)
			{
				FinishReadContentAsBinary();
			}
			if (parsingFunction == ParsingFunction.InReadAttributeValue)
			{
				while (ps.entityId != attributeValueBaseEntityId)
				{
					HandleEntityEnd(checkEntityNesting: false);
				}
				parsingFunction = nextParsingFunction;
				nextParsingFunction = ((index <= 0) ? ParsingFunction.DocumentContent : ParsingFunction.ElementContent);
				emptyEntityInAttributeResolved = false;
			}
		}

		private void InitStreamInput(Stream stream, Encoding encoding)
		{
			InitStreamInput(null, string.Empty, stream, null, 0, encoding);
		}

		private void InitStreamInput(string baseUriStr, Stream stream, Encoding encoding)
		{
			InitStreamInput(null, baseUriStr, stream, null, 0, encoding);
		}

		private void InitStreamInput(Uri baseUri, Stream stream, Encoding encoding)
		{
			InitStreamInput(baseUri, baseUri.ToString(), stream, null, 0, encoding);
		}

		private void InitStreamInput(Uri baseUri, string baseUriStr, Stream stream, Encoding encoding)
		{
			InitStreamInput(baseUri, baseUriStr, stream, null, 0, encoding);
		}

		private void InitStreamInput(Uri baseUri, string baseUriStr, Stream stream, byte[] bytes, int byteCount, Encoding encoding)
		{
			ps.stream = stream;
			ps.baseUri = baseUri;
			ps.baseUriStr = baseUriStr;
			int num;
			if (bytes != null)
			{
				ps.bytes = bytes;
				ps.bytesUsed = byteCount;
				num = ps.bytes.Length;
			}
			else
			{
				num = XmlReader.CalcBufferSize(stream);
				if (ps.bytes == null || ps.bytes.Length < num)
				{
					ps.bytes = new byte[num];
				}
			}
			if (ps.chars == null || ps.chars.Length < num + 1)
			{
				ps.chars = new char[num + 1];
			}
			ps.bytePos = 0;
			while (ps.bytesUsed < 4 && ps.bytes.Length - ps.bytesUsed > 0)
			{
				int num2 = stream.Read(ps.bytes, ps.bytesUsed, ps.bytes.Length - ps.bytesUsed);
				if (num2 == 0)
				{
					ps.isStreamEof = true;
					break;
				}
				ps.bytesUsed += num2;
			}
			if (encoding == null)
			{
				encoding = DetectEncoding();
			}
			SetupEncoding(encoding);
			byte[] preamble = ps.encoding.GetPreamble();
			int num3 = preamble.Length;
			int i;
			for (i = 0; i < num3 && i < ps.bytesUsed && ps.bytes[i] == preamble[i]; i++)
			{
			}
			if (i == num3)
			{
				ps.bytePos = num3;
			}
			documentStartBytePos = ps.bytePos;
			ps.eolNormalized = !normalize;
			ps.appendMode = true;
			ReadData();
		}

		private void InitTextReaderInput(string baseUriStr, TextReader input)
		{
			ps.textReader = input;
			ps.baseUriStr = baseUriStr;
			ps.baseUri = null;
			if (ps.chars == null)
			{
				ps.chars = new char[4097];
			}
			ps.encoding = Encoding.Unicode;
			ps.eolNormalized = !normalize;
			ps.appendMode = true;
			ReadData();
		}

		private void InitStringInput(string baseUriStr, Encoding originalEncoding, string str)
		{
			ps.baseUriStr = baseUriStr;
			ps.baseUri = null;
			int length = str.Length;
			ps.chars = new char[length + 1];
			str.CopyTo(0, ps.chars, 0, str.Length);
			ps.charsUsed = length;
			ps.chars[length] = '\0';
			ps.encoding = originalEncoding;
			ps.eolNormalized = !normalize;
			ps.isEof = true;
		}

		private void InitFragmentReader(XmlNodeType fragmentType, XmlParserContext parserContext, bool allowXmlDeclFragment)
		{
			fragmentParserContext = parserContext;
			if (parserContext != null)
			{
				if (parserContext.NamespaceManager != null)
				{
					namespaceManager = parserContext.NamespaceManager;
					xmlContext.defaultNamespace = namespaceManager.LookupNamespace(string.Empty);
				}
				else
				{
					namespaceManager = new XmlNamespaceManager(nameTable);
				}
				ps.baseUriStr = parserContext.BaseURI;
				ps.baseUri = null;
				xmlContext.xmlLang = parserContext.XmlLang;
				xmlContext.xmlSpace = parserContext.XmlSpace;
			}
			else
			{
				namespaceManager = new XmlNamespaceManager(nameTable);
				ps.baseUriStr = string.Empty;
				ps.baseUri = null;
			}
			reportedBaseUri = ps.baseUriStr;
			switch (fragmentType)
			{
			case XmlNodeType.Attribute:
				ps.appendMode = false;
				parsingFunction = ParsingFunction.SwitchToInteractive;
				nextParsingFunction = ParsingFunction.FragmentAttribute;
				break;
			case XmlNodeType.Element:
				nextParsingFunction = ParsingFunction.DocumentContent;
				break;
			case XmlNodeType.XmlDeclaration:
				if (allowXmlDeclFragment)
				{
					ps.appendMode = false;
					parsingFunction = ParsingFunction.SwitchToInteractive;
					nextParsingFunction = ParsingFunction.XmlDeclarationFragment;
					break;
				}
				goto default;
			default:
				Throw("Xml_PartialContentNodeTypeNotSupportedEx", fragmentType.ToString());
				return;
			case XmlNodeType.Document:
				break;
			}
			this.fragmentType = fragmentType;
			fragment = true;
		}

		private void OpenUrl()
		{
			XmlResolver xmlResolver;
			if (ps.baseUri != null)
			{
				xmlResolver = this.xmlResolver;
			}
			else
			{
				xmlResolver = ((this.xmlResolver == null) ? new XmlUrlResolver() : this.xmlResolver);
				ps.baseUri = xmlResolver.ResolveUri(null, url);
				ps.baseUriStr = ps.baseUri.ToString();
			}
			try
			{
				CompressedStack.Run(compressedStack, OpenUrlDelegate, xmlResolver);
			}
			catch
			{
				SetErrorState();
				throw;
			}
			if (ps.stream == null)
			{
				ThrowWithoutLineInfo("Xml_CannotResolveUrl", ps.baseUriStr);
			}
			InitStreamInput(ps.baseUri, ps.baseUriStr, ps.stream, null);
			reportedEncoding = ps.encoding;
		}

		private void OpenUrlDelegate(object xmlResolver)
		{
			ps.stream = (Stream)((XmlResolver)xmlResolver).GetEntity(ps.baseUri, null, typeof(Stream));
		}

		private Encoding DetectEncoding()
		{
			if (ps.bytesUsed < 2)
			{
				return null;
			}
			int num = (ps.bytes[0] << 8) | ps.bytes[1];
			int num2 = ((ps.bytesUsed >= 4) ? ((ps.bytes[2] << 8) | ps.bytes[3]) : 0);
			switch (num)
			{
			case 0:
				switch (num2)
				{
				case 65279:
					return Ucs4Encoding.UCS4_Bigendian;
				case 60:
					return Ucs4Encoding.UCS4_Bigendian;
				case 65534:
					return Ucs4Encoding.UCS4_2143;
				case 15360:
					return Ucs4Encoding.UCS4_2143;
				}
				break;
			case 65279:
				if (num2 == 0)
				{
					return Ucs4Encoding.UCS4_3412;
				}
				return Encoding.BigEndianUnicode;
			case 65534:
				if (num2 == 0)
				{
					return Ucs4Encoding.UCS4_Littleendian;
				}
				return Encoding.Unicode;
			case 15360:
				switch (num2)
				{
				case 0:
					return Ucs4Encoding.UCS4_Littleendian;
				case 16128:
					return Encoding.Unicode;
				}
				break;
			case 60:
				switch (num2)
				{
				case 0:
					return Ucs4Encoding.UCS4_3412;
				case 63:
					return Encoding.BigEndianUnicode;
				}
				break;
			case 19567:
				if (num2 == 42900)
				{
					Throw("Xml_UnknownEncoding", "ebcdic");
				}
				break;
			case 61371:
				if ((num2 & 0xFF00) == 48896)
				{
					return new UTF8Encoding(encoderShouldEmitUTF8Identifier: true, throwOnInvalidBytes: true);
				}
				break;
			}
			return null;
		}

		private void SetupEncoding(Encoding encoding)
		{
			if (encoding == null)
			{
				ps.encoding = Encoding.UTF8;
				ps.decoder = new SafeAsciiDecoder();
				return;
			}
			ps.encoding = encoding;
			switch (ps.encoding.CodePage)
			{
			case 1200:
				ps.decoder = new UTF16Decoder(bigEndian: false);
				break;
			case 1201:
				ps.decoder = new UTF16Decoder(bigEndian: true);
				break;
			default:
				ps.decoder = encoding.GetDecoder();
				break;
			}
		}

		private void SwitchEncoding(Encoding newEncoding)
		{
			if ((newEncoding.CodePage != ps.encoding.CodePage || ps.decoder is SafeAsciiDecoder) && !afterResetState)
			{
				UnDecodeChars();
				ps.appendMode = false;
				SetupEncoding(newEncoding);
				ReadData();
			}
		}

		private Encoding CheckEncoding(string newEncodingName)
		{
			if (ps.stream == null)
			{
				return ps.encoding;
			}
			if (string.Compare(newEncodingName, "ucs-2", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(newEncodingName, "utf-16", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(newEncodingName, "iso-10646-ucs-2", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(newEncodingName, "ucs-4", StringComparison.OrdinalIgnoreCase) == 0)
			{
				if (ps.encoding.CodePage != Encoding.BigEndianUnicode.CodePage && ps.encoding.CodePage != Encoding.Unicode.CodePage && string.Compare(newEncodingName, "ucs-4", StringComparison.OrdinalIgnoreCase) != 0)
				{
					if (afterResetState)
					{
						Throw("Xml_EncodingSwitchAfterResetState", newEncodingName);
					}
					else
					{
						ThrowWithoutLineInfo("Xml_MissingByteOrderMark");
					}
				}
				return ps.encoding;
			}
			Encoding encoding = null;
			if (string.Compare(newEncodingName, "utf-8", StringComparison.OrdinalIgnoreCase) == 0)
			{
				encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: true, throwOnInvalidBytes: true);
			}
			else
			{
				try
				{
					encoding = Encoding.GetEncoding(newEncodingName);
					if (encoding.CodePage == -1)
					{
						Throw("Xml_UnknownEncoding", newEncodingName);
					}
				}
				catch (NotSupportedException)
				{
					Throw("Xml_UnknownEncoding", newEncodingName);
				}
				catch (ArgumentException)
				{
					Throw("Xml_UnknownEncoding", newEncodingName);
				}
			}
			if (afterResetState && ps.encoding.CodePage != encoding.CodePage)
			{
				Throw("Xml_EncodingSwitchAfterResetState", newEncodingName);
			}
			return encoding;
		}

		private void UnDecodeChars()
		{
			if (maxCharactersInDocument > 0)
			{
				charactersInDocument -= ps.charsUsed - ps.charPos;
			}
			if (maxCharactersFromEntities > 0 && InEntity)
			{
				charactersFromEntities -= ps.charsUsed - ps.charPos;
			}
			ps.bytePos = documentStartBytePos;
			if (ps.charPos > 0)
			{
				ps.bytePos += ps.encoding.GetByteCount(ps.chars, 0, ps.charPos);
			}
			ps.charsUsed = ps.charPos;
			ps.isEof = false;
		}

		private void SwitchEncodingToUTF8()
		{
			SwitchEncoding(new UTF8Encoding(encoderShouldEmitUTF8Identifier: true, throwOnInvalidBytes: true));
		}

		private int ReadData()
		{
			if (ps.isEof)
			{
				return 0;
			}
			int num;
			if (ps.appendMode)
			{
				if (ps.charsUsed == ps.chars.Length - 1)
				{
					for (int i = 0; i < attrCount; i++)
					{
						nodes[index + i + 1].OnBufferInvalidated();
					}
					char[] array = new char[ps.chars.Length * 2];
					Buffer.BlockCopy(ps.chars, 0, array, 0, ps.chars.Length * 2);
					ps.chars = array;
				}
				if (ps.stream != null && ps.bytesUsed - ps.bytePos < 6 && ps.bytes.Length - ps.bytesUsed < 6)
				{
					byte[] array2 = new byte[ps.bytes.Length * 2];
					Buffer.BlockCopy(ps.bytes, 0, array2, 0, ps.bytesUsed);
					ps.bytes = array2;
				}
				num = ps.chars.Length - ps.charsUsed - 1;
				if (num > 80)
				{
					num = 80;
				}
			}
			else
			{
				int num2 = ps.chars.Length;
				if (num2 - ps.charsUsed <= num2 / 2)
				{
					for (int j = 0; j < attrCount; j++)
					{
						nodes[index + j + 1].OnBufferInvalidated();
					}
					int num3 = ps.charsUsed - ps.charPos;
					if (num3 < num2 - 1)
					{
						ps.lineStartPos -= ps.charPos;
						if (num3 > 0)
						{
							Buffer.BlockCopy(ps.chars, ps.charPos * 2, ps.chars, 0, num3 * 2);
						}
						ps.charPos = 0;
						ps.charsUsed = num3;
					}
					else
					{
						char[] array3 = new char[ps.chars.Length * 2];
						Buffer.BlockCopy(ps.chars, 0, array3, 0, ps.chars.Length * 2);
						ps.chars = array3;
					}
				}
				if (ps.stream != null)
				{
					int num4 = ps.bytesUsed - ps.bytePos;
					if (num4 <= 128)
					{
						if (num4 == 0)
						{
							ps.bytesUsed = 0;
						}
						else
						{
							Buffer.BlockCopy(ps.bytes, ps.bytePos, ps.bytes, 0, num4);
							ps.bytesUsed = num4;
						}
						ps.bytePos = 0;
					}
				}
				num = ps.chars.Length - ps.charsUsed - 1;
			}
			if (ps.stream != null)
			{
				if (!ps.isStreamEof && ps.bytePos == ps.bytesUsed && ps.bytes.Length - ps.bytesUsed > 0)
				{
					int num5 = ps.stream.Read(ps.bytes, ps.bytesUsed, ps.bytes.Length - ps.bytesUsed);
					if (num5 == 0)
					{
						ps.isStreamEof = true;
					}
					ps.bytesUsed += num5;
				}
				int bytePos = ps.bytePos;
				num = GetChars(num);
				if (num == 0 && ps.bytePos != bytePos)
				{
					return ReadData();
				}
			}
			else if (ps.textReader != null)
			{
				num = ps.textReader.Read(ps.chars, ps.charsUsed, ps.chars.Length - ps.charsUsed - 1);
				ps.charsUsed += num;
			}
			else
			{
				num = 0;
			}
			RegisterConsumedCharacters(num, InEntity);
			if (num == 0)
			{
				ps.isEof = true;
			}
			ps.chars[ps.charsUsed] = '\0';
			return num;
		}

		private int GetChars(int maxCharsCount)
		{
			int bytesUsed = ps.bytesUsed - ps.bytePos;
			if (bytesUsed == 0)
			{
				return 0;
			}
			int charsUsed;
			try
			{
				ps.decoder.Convert(ps.bytes, ps.bytePos, bytesUsed, ps.chars, ps.charsUsed, maxCharsCount, flush: false, out bytesUsed, out charsUsed, out var _);
			}
			catch (ArgumentException)
			{
				InvalidCharRecovery(ref bytesUsed, out charsUsed);
			}
			ps.bytePos += bytesUsed;
			ps.charsUsed += charsUsed;
			return charsUsed;
		}

		private void InvalidCharRecovery(ref int bytesCount, out int charsCount)
		{
			int num = 0;
			int i = 0;
			try
			{
				int bytesUsed;
				for (; i < bytesCount; i += bytesUsed)
				{
					ps.decoder.Convert(ps.bytes, ps.bytePos + i, 1, ps.chars, ps.charsUsed + num, 1, flush: false, out bytesUsed, out var charsUsed, out var _);
					num += charsUsed;
				}
			}
			catch (ArgumentException)
			{
			}
			if (num == 0)
			{
				Throw(ps.charsUsed, "Xml_InvalidCharInThisEncoding");
			}
			charsCount = num;
			bytesCount = i;
		}

		internal void Close(bool closeInput)
		{
			if (parsingFunction != ParsingFunction.ReaderClosed)
			{
				while (InEntity)
				{
					PopParsingState();
				}
				ps.Close(closeInput);
				curNode = NodeData.None;
				parsingFunction = ParsingFunction.ReaderClosed;
				reportedEncoding = null;
				reportedBaseUri = string.Empty;
				readState = ReadState.Closed;
				fullAttrCleanup = false;
				ResetAttributes();
			}
		}

		private void ShiftBuffer(int sourcePos, int destPos, int count)
		{
			Buffer.BlockCopy(ps.chars, sourcePos * 2, ps.chars, destPos * 2, count * 2);
		}

		private unsafe bool ParseXmlDeclaration(bool isTextDecl)
		{
			do
			{
				if (ps.charsUsed - ps.charPos < 6)
				{
					continue;
				}
				if (!XmlConvert.StrEqual(ps.chars, ps.charPos, 5, "<?xml") || xmlCharType.IsNameChar(ps.chars[ps.charPos + 5]))
				{
					break;
				}
				if (!isTextDecl)
				{
					curNode.SetLineInfo(ps.LineNo, ps.LinePos + 2);
					curNode.SetNamedNode(XmlNodeType.XmlDeclaration, Xml);
				}
				ps.charPos += 5;
				BufferBuilder bufferBuilder = (isTextDecl ? new BufferBuilder() : stringBuilder);
				int num = 0;
				Encoding encoding = null;
				while (true)
				{
					int length = bufferBuilder.Length;
					int num2 = EatWhitespaces((num == 0) ? null : bufferBuilder);
					if (ps.chars[ps.charPos] == '?')
					{
						bufferBuilder.Length = length;
						if (ps.chars[ps.charPos + 1] == '>')
						{
							break;
						}
						if (ps.charPos + 1 == ps.charsUsed)
						{
							goto IL_07c4;
						}
						ThrowUnexpectedToken("'>'");
					}
					if (num2 == 0 && num != 0)
					{
						ThrowUnexpectedToken("?>");
					}
					int num3 = ParseName();
					NodeData nodeData = null;
					char c = ps.chars[ps.charPos];
					if (c != 'e')
					{
						if (c != 's')
						{
							if (c != 'v' || !XmlConvert.StrEqual(ps.chars, ps.charPos, num3 - ps.charPos, "version") || num != 0)
							{
								goto IL_03bb;
							}
							if (!isTextDecl)
							{
								nodeData = AddAttributeNoChecks("version", 0);
							}
						}
						else
						{
							if (!XmlConvert.StrEqual(ps.chars, ps.charPos, num3 - ps.charPos, "standalone") || (num != 1 && num != 2) || isTextDecl)
							{
								goto IL_03bb;
							}
							if (!isTextDecl)
							{
								nodeData = AddAttributeNoChecks("standalone", 0);
							}
							num = 2;
						}
					}
					else
					{
						if (!XmlConvert.StrEqual(ps.chars, ps.charPos, num3 - ps.charPos, "encoding") || (num != 1 && (!isTextDecl || num != 0)))
						{
							goto IL_03bb;
						}
						if (!isTextDecl)
						{
							nodeData = AddAttributeNoChecks("encoding", 0);
						}
						num = 1;
					}
					goto IL_03d0;
					IL_03d0:
					if (!isTextDecl)
					{
						nodeData.SetLineInfo(ps.LineNo, ps.LinePos);
					}
					bufferBuilder.Append(ps.chars, ps.charPos, num3 - ps.charPos);
					ps.charPos = num3;
					if (ps.chars[ps.charPos] != '=')
					{
						EatWhitespaces(bufferBuilder);
						if (ps.chars[ps.charPos] != '=')
						{
							ThrowUnexpectedToken("=");
						}
					}
					bufferBuilder.Append('=');
					ps.charPos++;
					char c2 = ps.chars[ps.charPos];
					if (c2 != '"' && c2 != '\'')
					{
						EatWhitespaces(bufferBuilder);
						c2 = ps.chars[ps.charPos];
						if (c2 != '"' && c2 != '\'')
						{
							ThrowUnexpectedToken("\"", "'");
						}
					}
					bufferBuilder.Append(c2);
					ps.charPos++;
					if (!isTextDecl)
					{
						nodeData.quoteChar = c2;
						nodeData.SetLineInfo2(ps.LineNo, ps.LinePos);
					}
					int i = ps.charPos;
					char[] chars;
					while (true)
					{
						for (chars = ps.chars; (xmlCharType.charProperties[(int)chars[i]] & 0x80u) != 0; i++)
						{
						}
						if (ps.chars[i] == c2)
						{
							break;
						}
						if (i == ps.charsUsed)
						{
							if (ReadData() != 0)
							{
								continue;
							}
							goto IL_07a2;
						}
						goto IL_07af;
					}
					switch (num)
					{
					case 0:
						if (XmlConvert.StrEqual(ps.chars, ps.charPos, i - ps.charPos, "1.0"))
						{
							if (!isTextDecl)
							{
								nodeData.SetValue(ps.chars, ps.charPos, i - ps.charPos);
							}
							num = 1;
						}
						else
						{
							string arg = new string(ps.chars, ps.charPos, i - ps.charPos);
							Throw("Xml_InvalidVersionNumber", arg);
						}
						break;
					case 1:
					{
						string text = new string(ps.chars, ps.charPos, i - ps.charPos);
						encoding = CheckEncoding(text);
						if (!isTextDecl)
						{
							nodeData.SetValue(text);
						}
						num = 2;
						break;
					}
					case 2:
						if (XmlConvert.StrEqual(ps.chars, ps.charPos, i - ps.charPos, "yes"))
						{
							standalone = true;
						}
						else if (XmlConvert.StrEqual(ps.chars, ps.charPos, i - ps.charPos, "no"))
						{
							standalone = false;
						}
						else
						{
							Throw("Xml_InvalidXmlDecl", ps.LineNo, ps.LinePos - 1);
						}
						if (!isTextDecl)
						{
							nodeData.SetValue(ps.chars, ps.charPos, i - ps.charPos);
						}
						num = 3;
						break;
					}
					bufferBuilder.Append(chars, ps.charPos, i - ps.charPos);
					bufferBuilder.Append(c2);
					ps.charPos = i + 1;
					continue;
					IL_07c4:
					if (ps.isEof || ReadData() == 0)
					{
						Throw("Xml_UnexpectedEOF1");
					}
					continue;
					IL_07af:
					Throw(isTextDecl ? "Xml_InvalidTextDecl" : "Xml_InvalidXmlDecl");
					goto IL_07c4;
					IL_07a2:
					Throw("Xml_UnclosedQuote");
					goto IL_07c4;
					IL_03bb:
					Throw(isTextDecl ? "Xml_InvalidTextDecl" : "Xml_InvalidXmlDecl");
					goto IL_03d0;
				}
				if (num == 0)
				{
					Throw(isTextDecl ? "Xml_InvalidTextDecl" : "Xml_InvalidXmlDecl");
				}
				ps.charPos += 2;
				if (!isTextDecl)
				{
					curNode.SetValue(bufferBuilder.ToString());
					bufferBuilder.Length = 0;
					nextParsingFunction = parsingFunction;
					parsingFunction = ParsingFunction.ResetAttributesRootLevel;
				}
				if (encoding == null)
				{
					if (isTextDecl)
					{
						Throw("Xml_InvalidTextDecl");
					}
					if (afterResetState)
					{
						int codePage = ps.encoding.CodePage;
						if (codePage != Encoding.UTF8.CodePage && codePage != Encoding.Unicode.CodePage && codePage != Encoding.BigEndianUnicode.CodePage && !(ps.encoding is Ucs4Encoding))
						{
							Throw("Xml_EncodingSwitchAfterResetState", (ps.encoding.GetByteCount("A") == 1) ? "UTF-8" : "UTF-16");
						}
					}
					if (ps.decoder is SafeAsciiDecoder)
					{
						SwitchEncodingToUTF8();
					}
				}
				else
				{
					SwitchEncoding(encoding);
				}
				ps.appendMode = false;
				return true;
			}
			while (ReadData() != 0);
			if (!isTextDecl)
			{
				parsingFunction = nextParsingFunction;
			}
			if (afterResetState)
			{
				int codePage2 = ps.encoding.CodePage;
				if (codePage2 != Encoding.UTF8.CodePage && codePage2 != Encoding.Unicode.CodePage && codePage2 != Encoding.BigEndianUnicode.CodePage && !(ps.encoding is Ucs4Encoding))
				{
					Throw("Xml_EncodingSwitchAfterResetState", (ps.encoding.GetByteCount("A") == 1) ? "UTF-8" : "UTF-16");
				}
			}
			if (ps.decoder is SafeAsciiDecoder)
			{
				SwitchEncodingToUTF8();
			}
			ps.appendMode = false;
			return false;
		}

		private bool ParseDocumentContent()
		{
			while (true)
			{
				bool flag = false;
				int charPos = ps.charPos;
				char[] chars = ps.chars;
				if (chars[charPos] == '<')
				{
					flag = true;
					if (ps.charsUsed - charPos >= 4)
					{
						charPos++;
						switch (chars[charPos])
						{
						case '?':
							ps.charPos = charPos + 1;
							if (!ParsePI())
							{
								continue;
							}
							return true;
						case '!':
							charPos++;
							if (ps.charsUsed - charPos < 2)
							{
								break;
							}
							if (chars[charPos] == '-')
							{
								if (chars[charPos + 1] == '-')
								{
									ps.charPos = charPos + 2;
									if (!ParseComment())
									{
										continue;
									}
									return true;
								}
								ThrowUnexpectedToken(charPos + 1, "-");
							}
							else if (chars[charPos] == '[')
							{
								if (fragmentType != XmlNodeType.Document)
								{
									charPos++;
									if (ps.charsUsed - charPos < 6)
									{
										break;
									}
									if (XmlConvert.StrEqual(chars, charPos, 6, "CDATA["))
									{
										ps.charPos = charPos + 6;
										ParseCData();
										if (fragmentType == XmlNodeType.None)
										{
											fragmentType = XmlNodeType.Element;
										}
										return true;
									}
									ThrowUnexpectedToken(charPos, "CDATA[");
								}
								else
								{
									Throw(ps.charPos, "Xml_InvalidRootData");
								}
							}
							else
							{
								if (fragmentType == XmlNodeType.Document || fragmentType == XmlNodeType.None)
								{
									fragmentType = XmlNodeType.Document;
									ps.charPos = charPos;
									ParseDoctypeDecl();
									return true;
								}
								if (ParseUnexpectedToken(charPos) == "DOCTYPE")
								{
									Throw("Xml_BadDTDLocation");
								}
								else
								{
									ThrowUnexpectedToken(charPos, "<!--", "<[CDATA[");
								}
							}
							break;
						case '/':
							Throw(charPos + 1, "Xml_UnexpectedEndTag");
							break;
						default:
							if (rootElementParsed)
							{
								if (fragmentType == XmlNodeType.Document)
								{
									Throw(charPos, "Xml_MultipleRoots");
								}
								if (fragmentType == XmlNodeType.None)
								{
									fragmentType = XmlNodeType.Element;
								}
							}
							ps.charPos = charPos;
							rootElementParsed = true;
							ParseElement();
							return true;
						}
					}
				}
				else if (chars[charPos] == '&')
				{
					if (fragmentType != XmlNodeType.Document)
					{
						if (fragmentType == XmlNodeType.None)
						{
							fragmentType = XmlNodeType.Element;
						}
						int charRefEndPos;
						switch (HandleEntityReference(isInAttributeValue: false, EntityExpandType.OnlyGeneral, out charRefEndPos))
						{
						case EntityType.Unexpanded:
							if (parsingFunction == ParsingFunction.EntityReference)
							{
								parsingFunction = nextParsingFunction;
							}
							ParseEntityReference();
							return true;
						case EntityType.CharacterDec:
						case EntityType.CharacterHex:
						case EntityType.CharacterNamed:
							if (ParseText())
							{
								return true;
							}
							break;
						default:
							chars = ps.chars;
							charPos = ps.charPos;
							break;
						}
						continue;
					}
					Throw(charPos, "Xml_InvalidRootData");
				}
				else if (charPos != ps.charsUsed && (!v1Compat || chars[charPos] != 0))
				{
					if (fragmentType == XmlNodeType.Document)
					{
						if (ParseRootLevelWhitespace())
						{
							return true;
						}
					}
					else if (ParseText())
					{
						if (fragmentType == XmlNodeType.None && curNode.type == XmlNodeType.Text)
						{
							fragmentType = XmlNodeType.Element;
						}
						return true;
					}
					chars = ps.chars;
					charPos = ps.charPos;
					continue;
				}
				if (ReadData() != 0)
				{
					charPos = ps.charPos;
					charPos = ps.charPos;
					chars = ps.chars;
					continue;
				}
				if (flag)
				{
					Throw("Xml_InvalidRootData");
				}
				if (!InEntity)
				{
					break;
				}
				if (HandleEntityEnd(checkEntityNesting: true))
				{
					SetupEndEntityNodeInContent();
					return true;
				}
			}
			if (!rootElementParsed && fragmentType == XmlNodeType.Document)
			{
				ThrowWithoutLineInfo("Xml_MissingRoot");
			}
			if (fragmentType == XmlNodeType.None)
			{
				fragmentType = ((!rootElementParsed) ? XmlNodeType.Element : XmlNodeType.Document);
			}
			OnEof();
			return false;
		}

		private bool ParseElementContent()
		{
			while (true)
			{
				int charPos = ps.charPos;
				char[] chars = ps.chars;
				switch (chars[charPos])
				{
				case '<':
					switch (chars[charPos + 1])
					{
					case '?':
						ps.charPos = charPos + 2;
						if (!ParsePI())
						{
							continue;
						}
						return true;
					case '!':
						charPos += 2;
						if (ps.charsUsed - charPos < 2)
						{
							break;
						}
						if (chars[charPos] == '-')
						{
							if (chars[charPos + 1] == '-')
							{
								ps.charPos = charPos + 2;
								if (!ParseComment())
								{
									continue;
								}
								return true;
							}
							ThrowUnexpectedToken(charPos + 1, "-");
						}
						else if (chars[charPos] == '[')
						{
							charPos++;
							if (ps.charsUsed - charPos >= 6)
							{
								if (XmlConvert.StrEqual(chars, charPos, 6, "CDATA["))
								{
									ps.charPos = charPos + 6;
									ParseCData();
									return true;
								}
								ThrowUnexpectedToken(charPos, "CDATA[");
							}
						}
						else if (ParseUnexpectedToken(charPos) == "DOCTYPE")
						{
							Throw("Xml_BadDTDLocation");
						}
						else
						{
							ThrowUnexpectedToken(charPos, "<!--", "<[CDATA[");
						}
						break;
					case '/':
						ps.charPos = charPos + 2;
						ParseEndElement();
						return true;
					default:
						if (charPos + 1 != ps.charsUsed)
						{
							ps.charPos = charPos + 1;
							ParseElement();
							return true;
						}
						break;
					}
					break;
				case '&':
					if (!ParseText())
					{
						continue;
					}
					return true;
				default:
					if (charPos != ps.charsUsed)
					{
						if (!ParseText())
						{
							continue;
						}
						return true;
					}
					break;
				}
				if (ReadData() != 0)
				{
					continue;
				}
				if (ps.charsUsed - ps.charPos != 0)
				{
					ThrowUnclosedElements();
				}
				if (!InEntity)
				{
					if (index == 0 && fragmentType != XmlNodeType.Document)
					{
						OnEof();
						return false;
					}
					ThrowUnclosedElements();
				}
				if (HandleEntityEnd(checkEntityNesting: true))
				{
					break;
				}
			}
			SetupEndEntityNodeInContent();
			return true;
		}

		private void ThrowUnclosedElements()
		{
			if (index == 0 && curNode.type != XmlNodeType.Element)
			{
				Throw(ps.charsUsed, "Xml_UnexpectedEOF1");
				return;
			}
			int num = ((parsingFunction == ParsingFunction.InIncrementalRead) ? index : (index - 1));
			stringBuilder.Length = 0;
			while (num >= 0)
			{
				NodeData nodeData = nodes[num];
				if (nodeData.type == XmlNodeType.Element)
				{
					stringBuilder.Append(nodeData.GetNameWPrefix(nameTable));
					if (num > 0)
					{
						stringBuilder.Append(", ");
					}
					else
					{
						stringBuilder.Append(".");
					}
				}
				num--;
			}
			Throw(ps.charsUsed, "Xml_UnexpectedEOFInElementContent", stringBuilder.ToString());
		}

		private unsafe void ParseElement()
		{
			int num = ps.charPos;
			char[] chars = ps.chars;
			int colonPos = -1;
			curNode.SetLineInfo(ps.LineNo, ps.LinePos);
			while (true)
			{
				if ((xmlCharType.charProperties[(int)chars[num]] & 4u) != 0)
				{
					num++;
					while (true)
					{
						if ((xmlCharType.charProperties[(int)chars[num]] & 8u) != 0)
						{
							num++;
							continue;
						}
						if (chars[num] != ':')
						{
							break;
						}
						if (colonPos == -1)
						{
							goto IL_009b;
						}
						if (!supportNamespaces)
						{
							num++;
							continue;
						}
						goto IL_0080;
					}
					if (num < ps.charsUsed)
					{
						break;
					}
				}
				goto IL_00b1;
				IL_009b:
				colonPos = num;
				num++;
				continue;
				IL_00b1:
				num = ParseQName(out colonPos);
				chars = ps.chars;
				break;
				IL_0080:
				Throw(num, "Xml_BadNameChar", XmlException.BuildCharExceptionStr(':'));
				goto IL_00b1;
			}
			namespaceManager.PushScope();
			if (colonPos == -1 || !supportNamespaces)
			{
				curNode.SetNamedNode(XmlNodeType.Element, nameTable.Add(chars, ps.charPos, num - ps.charPos));
			}
			else
			{
				int charPos = ps.charPos;
				int num2 = colonPos - charPos;
				if (num2 == lastPrefix.Length && XmlConvert.StrEqual(chars, charPos, num2, lastPrefix))
				{
					curNode.SetNamedNode(XmlNodeType.Element, nameTable.Add(chars, colonPos + 1, num - colonPos - 1), lastPrefix, null);
				}
				else
				{
					curNode.SetNamedNode(XmlNodeType.Element, nameTable.Add(chars, colonPos + 1, num - colonPos - 1), nameTable.Add(chars, ps.charPos, num2), null);
					lastPrefix = curNode.prefix;
				}
			}
			char c = chars[num];
			if (((uint)xmlCharType.charProperties[(int)c] & (true ? 1u : 0u)) != 0)
			{
				ps.charPos = num;
				ParseAttributes();
				return;
			}
			switch (c)
			{
			case '>':
				ps.charPos = num + 1;
				parsingFunction = ParsingFunction.MoveToElementContent;
				break;
			case '/':
				if (num + 1 == ps.charsUsed)
				{
					ps.charPos = num;
					if (ReadData() == 0)
					{
						Throw(num, "Xml_UnexpectedEOF", ">");
					}
					num = ps.charPos;
					chars = ps.chars;
				}
				if (chars[num + 1] == '>')
				{
					curNode.IsEmptyElement = true;
					nextParsingFunction = parsingFunction;
					parsingFunction = ParsingFunction.PopEmptyElementContext;
					ps.charPos = num + 2;
				}
				else
				{
					ThrowUnexpectedToken(num, ">");
				}
				break;
			default:
				Throw(num, "Xml_BadNameChar", XmlException.BuildCharExceptionStr(c));
				break;
			}
			if (addDefaultAttributesAndNormalize)
			{
				AddDefaultAttributesAndNormalize();
			}
			ElementNamespaceLookup();
		}

		private void AddDefaultAttributesAndNormalize()
		{
			qName.Init(curNode.localName, curNode.prefix);
			SchemaInfo dtdSchemaInfo = dtdParserProxy.DtdSchemaInfo;
			SchemaElementDecl schemaElementDecl;
			if ((schemaElementDecl = dtdSchemaInfo.GetElementDecl(qName)) == null && (schemaElementDecl = (SchemaElementDecl)dtdSchemaInfo.UndeclaredElementDecls[qName]) == null)
			{
				return;
			}
			if (normalize && schemaElementDecl.HasNonCDataAttribute)
			{
				for (int i = index + 1; i < index + 1 + attrCount; i++)
				{
					NodeData nodeData = nodes[i];
					qName.Init(nodeData.localName, nodeData.prefix);
					SchemaAttDef attDef = schemaElementDecl.GetAttDef(qName);
					if (attDef == null || attDef.SchemaType.Datatype.TokenizedType == XmlTokenizedType.CDATA)
					{
						continue;
					}
					if (DtdValidation && standalone && attDef.IsDeclaredInExternal)
					{
						string stringValue = nodeData.StringValue;
						nodeData.TrimSpacesInValue();
						if (stringValue != nodeData.StringValue)
						{
							SendValidationEvent(XmlSeverityType.Error, "Sch_StandAloneNormalization", nodeData.GetNameWPrefix(nameTable), nodeData.LineNo, nodeData.LinePos);
						}
					}
					else
					{
						nodeData.TrimSpacesInValue();
					}
				}
			}
			SchemaAttDef[] defaultAttDefs = schemaElementDecl.DefaultAttDefs;
			if (defaultAttDefs == null)
			{
				return;
			}
			int num = attrCount;
			NodeData[] array = null;
			if (attrCount >= 250)
			{
				array = new NodeData[attrCount];
				Array.Copy(nodes, index + 1, array, 0, attrCount);
				Array.Sort(array, SchemaAttDefToNodeDataComparer.Instance);
			}
			foreach (SchemaAttDef schemaAttDef in defaultAttDefs)
			{
				if (AddDefaultAttribute(schemaAttDef, definedInDtd: true, array) && DtdValidation && standalone && schemaAttDef.IsDeclaredInExternal)
				{
					SendValidationEvent(XmlSeverityType.Error, "Sch_UnSpecifiedDefaultAttributeInExternalStandalone", schemaAttDef.Name.Name, curNode.LineNo, curNode.LinePos);
				}
			}
			if (num == 0 && attrNeedNamespaceLookup)
			{
				AttributeNamespaceLookup();
				attrNeedNamespaceLookup = false;
			}
		}

		private unsafe void ParseEndElement()
		{
			NodeData nodeData = nodes[index - 1];
			int length = nodeData.prefix.Length;
			int length2 = nodeData.localName.Length;
			while (ps.charsUsed - ps.charPos < length + length2 + 1 && ReadData() != 0)
			{
			}
			char[] chars = ps.chars;
			int num;
			if (nodeData.prefix.Length == 0)
			{
				if (!XmlConvert.StrEqual(chars, ps.charPos, length2, nodeData.localName))
				{
					ThrowTagMismatch(nodeData);
				}
				num = length2;
			}
			else
			{
				int num2 = ps.charPos + length;
				if (!XmlConvert.StrEqual(chars, ps.charPos, length, nodeData.prefix) || chars[num2] != ':' || !XmlConvert.StrEqual(chars, num2 + 1, length2, nodeData.localName))
				{
					ThrowTagMismatch(nodeData);
				}
				num = length2 + length + 1;
			}
			int i;
			while (true)
			{
				i = ps.charPos + num;
				chars = ps.chars;
				if (i != ps.charsUsed)
				{
					if ((xmlCharType.charProperties[(int)chars[i]] & 8u) != 0 || chars[i] == ':')
					{
						ThrowTagMismatch(nodeData);
					}
					for (; ((uint)xmlCharType.charProperties[(int)chars[i]] & (true ? 1u : 0u)) != 0; i++)
					{
					}
					if (chars[i] == '>')
					{
						break;
					}
					if (i != ps.charsUsed)
					{
						ThrowUnexpectedToken(i, ">");
					}
				}
				if (ReadData() == 0)
				{
					ThrowUnclosedElements();
				}
			}
			index--;
			curNode = nodes[index];
			nodeData.SetLineInfo(ps.LineNo, ps.LinePos);
			nodeData.type = XmlNodeType.EndElement;
			ps.charPos = i + 1;
			nextParsingFunction = ((index > 0) ? parsingFunction : ParsingFunction.DocumentContent);
			parsingFunction = ParsingFunction.PopElementContext;
		}

		private void ThrowTagMismatch(NodeData startTag)
		{
			if (startTag.type == XmlNodeType.Element)
			{
				int colonPos;
				int num = ParseQName(out colonPos);
				Throw("Xml_TagMismatch", new string[3]
				{
					startTag.GetNameWPrefix(nameTable),
					startTag.lineInfo.lineNo.ToString(CultureInfo.InvariantCulture),
					new string(ps.chars, ps.charPos, num - ps.charPos)
				});
			}
			else
			{
				Throw("Xml_UnexpectedEndTag");
			}
		}

		private unsafe void ParseAttributes()
		{
			int num = ps.charPos;
			char[] chars = ps.chars;
			NodeData nodeData = null;
			while (true)
			{
				int num2 = 0;
				while (true)
				{
					char c;
					if (((uint)xmlCharType.charProperties[(int)(c = chars[num])] & (true ? 1u : 0u)) != 0)
					{
						switch (c)
						{
						case '\n':
							OnNewLine(num + 1);
							num2++;
							goto IL_0085;
						case '\r':
							if (chars[num + 1] == '\n')
							{
								OnNewLine(num + 2);
								num2++;
								num++;
								goto IL_0085;
							}
							if (num + 1 != ps.charsUsed)
							{
								OnNewLine(num + 1);
								num2++;
								goto IL_0085;
							}
							break;
						default:
							goto IL_0085;
						}
						ps.charPos = num;
					}
					else
					{
						char c2;
						if ((xmlCharType.charProperties[(int)(c2 = chars[num])] & 4u) != 0)
						{
							goto IL_017d;
						}
						if (c2 == '>')
						{
							ps.charPos = num + 1;
							parsingFunction = ParsingFunction.MoveToElementContent;
							goto IL_046f;
						}
						if (c2 == '/')
						{
							if (num + 1 != ps.charsUsed)
							{
								if (chars[num + 1] == '>')
								{
									ps.charPos = num + 2;
									curNode.IsEmptyElement = true;
									nextParsingFunction = parsingFunction;
									parsingFunction = ParsingFunction.PopEmptyElementContext;
									goto IL_046f;
								}
								ThrowUnexpectedToken(num + 1, ">");
								goto IL_017d;
							}
						}
						else if (num != ps.charsUsed)
						{
							if (c2 != ':' || supportNamespaces)
							{
								Throw(num, "Xml_BadStartNameChar", XmlException.BuildCharExceptionStr(c2));
							}
							goto IL_017d;
						}
					}
					ps.lineNo -= num2;
					if (ReadData() != 0)
					{
						num = ps.charPos;
						chars = ps.chars;
					}
					else
					{
						ThrowUnclosedElements();
					}
					break;
					IL_017d:
					if (num == ps.charPos)
					{
						Throw("Xml_ExpectingWhiteSpace", ParseUnexpectedToken());
					}
					ps.charPos = num;
					int linePos = ps.LinePos;
					int colonPos = -1;
					num++;
					while (true)
					{
						char c3;
						if ((xmlCharType.charProperties[(int)(c3 = chars[num])] & 8u) != 0)
						{
							num++;
							continue;
						}
						if (c3 == ':')
						{
							if (colonPos != -1)
							{
								if (supportNamespaces)
								{
									Throw(num, "Xml_BadNameChar", XmlException.BuildCharExceptionStr(':'));
									break;
								}
								num++;
								continue;
							}
							colonPos = num;
							num++;
							if ((xmlCharType.charProperties[(int)chars[num]] & 4u) != 0)
							{
								num++;
								continue;
							}
							num = ParseQName(out colonPos);
							chars = ps.chars;
							break;
						}
						if (num == ps.charsUsed)
						{
							num = ParseQName(out colonPos);
							chars = ps.chars;
						}
						break;
					}
					nodeData = AddAttribute(num, colonPos);
					nodeData.SetLineInfo(ps.LineNo, linePos);
					if (chars[num] != '=')
					{
						ps.charPos = num;
						EatWhitespaces(null);
						num = ps.charPos;
						if (chars[num] != '=')
						{
							ThrowUnexpectedToken("=");
						}
					}
					num++;
					char c4 = chars[num];
					if (c4 != '"' && c4 != '\'')
					{
						ps.charPos = num;
						EatWhitespaces(null);
						num = ps.charPos;
						c4 = chars[num];
						if (c4 != '"' && c4 != '\'')
						{
							ThrowUnexpectedToken("\"", "'");
						}
					}
					num++;
					ps.charPos = num;
					nodeData.quoteChar = c4;
					nodeData.SetLineInfo2(ps.LineNo, ps.LinePos);
					char c5;
					while ((xmlCharType.charProperties[(int)(c5 = chars[num])] & 0x80u) != 0)
					{
						num++;
					}
					if (c5 == c4)
					{
						nodeData.SetValue(chars, ps.charPos, num - ps.charPos);
						num++;
						ps.charPos = num;
					}
					else
					{
						ParseAttributeValueSlow(num, c4, nodeData);
						num = ps.charPos;
						chars = ps.chars;
					}
					if (nodeData.prefix.Length == 0)
					{
						if (Ref.Equal(nodeData.localName, XmlNs))
						{
							OnDefaultNamespaceDecl(nodeData);
						}
					}
					else if (Ref.Equal(nodeData.prefix, XmlNs))
					{
						OnNamespaceDecl(nodeData);
					}
					else if (Ref.Equal(nodeData.prefix, Xml))
					{
						OnXmlReservedAttribute(nodeData);
					}
					break;
					IL_0085:
					num++;
					continue;
					IL_046f:
					if (addDefaultAttributesAndNormalize)
					{
						AddDefaultAttributesAndNormalize();
					}
					ElementNamespaceLookup();
					if (attrNeedNamespaceLookup)
					{
						AttributeNamespaceLookup();
						attrNeedNamespaceLookup = false;
					}
					if (attrDuplWalkCount >= 250)
					{
						AttributeDuplCheck();
					}
					return;
				}
			}
		}

		private void ElementNamespaceLookup()
		{
			if (curNode.prefix.Length == 0)
			{
				curNode.ns = xmlContext.defaultNamespace;
			}
			else
			{
				curNode.ns = LookupNamespace(curNode);
			}
		}

		private void AttributeNamespaceLookup()
		{
			for (int i = index + 1; i < index + attrCount + 1; i++)
			{
				NodeData nodeData = nodes[i];
				if (nodeData.type == XmlNodeType.Attribute && nodeData.prefix.Length > 0)
				{
					nodeData.ns = LookupNamespace(nodeData);
				}
			}
		}

		private void AttributeDuplCheck()
		{
			if (attrCount < 250)
			{
				for (int i = index + 1; i < index + 1 + attrCount; i++)
				{
					NodeData nodeData = nodes[i];
					for (int j = i + 1; j < index + 1 + attrCount; j++)
					{
						if (Ref.Equal(nodeData.localName, nodes[j].localName) && Ref.Equal(nodeData.ns, nodes[j].ns))
						{
							Throw("Xml_DupAttributeName", nodes[j].GetNameWPrefix(nameTable), nodes[j].LineNo, nodes[j].LinePos);
						}
					}
				}
				return;
			}
			if (attrDuplSortingArray == null || attrDuplSortingArray.Length < attrCount)
			{
				attrDuplSortingArray = new NodeData[attrCount];
			}
			Array.Copy(nodes, index + 1, attrDuplSortingArray, 0, attrCount);
			Array.Sort(attrDuplSortingArray, 0, attrCount);
			NodeData nodeData2 = attrDuplSortingArray[0];
			for (int k = 1; k < attrCount; k++)
			{
				NodeData nodeData3 = attrDuplSortingArray[k];
				if (Ref.Equal(nodeData2.localName, nodeData3.localName) && Ref.Equal(nodeData2.ns, nodeData3.ns))
				{
					Throw("Xml_DupAttributeName", nodeData3.GetNameWPrefix(nameTable), nodeData3.LineNo, nodeData3.LinePos);
				}
				nodeData2 = nodeData3;
			}
		}

		private void OnDefaultNamespaceDecl(NodeData attr)
		{
			if (supportNamespaces)
			{
				string text = nameTable.Add(attr.StringValue);
				attr.ns = nameTable.Add("http://www.w3.org/2000/xmlns/");
				if (!curNode.xmlContextPushed)
				{
					PushXmlContext();
				}
				xmlContext.defaultNamespace = text;
				AddNamespace(string.Empty, text, attr);
			}
		}

		private void OnNamespaceDecl(NodeData attr)
		{
			if (supportNamespaces)
			{
				string text = nameTable.Add(attr.StringValue);
				if (text.Length == 0)
				{
					Throw("Xml_BadNamespaceDecl", attr.lineInfo2.lineNo, attr.lineInfo2.linePos - 1);
				}
				AddNamespace(attr.localName, text, attr);
			}
		}

		private void OnXmlReservedAttribute(NodeData attr)
		{
			switch (attr.localName)
			{
			case "space":
				if (!curNode.xmlContextPushed)
				{
					PushXmlContext();
				}
				switch (XmlConvert.TrimString(attr.StringValue))
				{
				case "preserve":
					xmlContext.xmlSpace = XmlSpace.Preserve;
					break;
				case "default":
					xmlContext.xmlSpace = XmlSpace.Default;
					break;
				default:
					Throw("Xml_InvalidXmlSpace", attr.StringValue, attr.lineInfo.lineNo, attr.lineInfo.linePos);
					break;
				}
				break;
			case "lang":
				if (!curNode.xmlContextPushed)
				{
					PushXmlContext();
				}
				xmlContext.xmlLang = attr.StringValue;
				break;
			}
		}

		private unsafe void ParseAttributeValueSlow(int curPos, char quoteChar, NodeData attr)
		{
			int charRefEndPos = curPos;
			char[] chars = ps.chars;
			int entityId = ps.entityId;
			int num = 0;
			LineInfo lineInfo = new LineInfo(ps.lineNo, ps.LinePos);
			NodeData lastChunk = null;
			while (true)
			{
				if ((xmlCharType.charProperties[(int)chars[charRefEndPos]] & 0x80u) != 0)
				{
					charRefEndPos++;
					continue;
				}
				if (charRefEndPos - ps.charPos > 0)
				{
					stringBuilder.Append(chars, ps.charPos, charRefEndPos - ps.charPos);
					ps.charPos = charRefEndPos;
				}
				if (chars[charRefEndPos] == quoteChar && entityId == ps.entityId)
				{
					break;
				}
				switch (chars[charRefEndPos])
				{
				case '\n':
					charRefEndPos++;
					OnNewLine(charRefEndPos);
					if (normalize)
					{
						stringBuilder.Append(' ');
						ps.charPos++;
					}
					continue;
				case '\r':
					if (chars[charRefEndPos + 1] == '\n')
					{
						charRefEndPos += 2;
						if (normalize)
						{
							stringBuilder.Append(ps.eolNormalized ? "  " : " ");
							ps.charPos = charRefEndPos;
						}
					}
					else
					{
						if (charRefEndPos + 1 >= ps.charsUsed && !ps.isEof)
						{
							break;
						}
						charRefEndPos++;
						if (normalize)
						{
							stringBuilder.Append(' ');
							ps.charPos = charRefEndPos;
						}
					}
					OnNewLine(charRefEndPos);
					continue;
				case '\t':
					charRefEndPos++;
					if (normalize)
					{
						stringBuilder.Append(' ');
						ps.charPos++;
					}
					continue;
				case '"':
				case '\'':
				case '>':
					charRefEndPos++;
					continue;
				case '<':
					Throw(charRefEndPos, "Xml_BadAttributeChar", XmlException.BuildCharExceptionStr('<'));
					break;
				case '&':
				{
					if (charRefEndPos - ps.charPos > 0)
					{
						stringBuilder.Append(chars, ps.charPos, charRefEndPos - ps.charPos);
					}
					ps.charPos = charRefEndPos;
					int entityId2 = ps.entityId;
					LineInfo lineInfo2 = new LineInfo(ps.lineNo, ps.LinePos + 1);
					switch (HandleEntityReference(isInAttributeValue: true, EntityExpandType.All, out charRefEndPos))
					{
					case EntityType.Unexpanded:
						if (parsingMode == ParsingMode.Full && ps.entityId == entityId)
						{
							int num3 = stringBuilder.Length - num;
							if (num3 > 0)
							{
								NodeData nodeData3 = new NodeData();
								nodeData3.lineInfo = lineInfo;
								nodeData3.depth = attr.depth + 1;
								nodeData3.SetValueNode(XmlNodeType.Text, stringBuilder.ToString(num, num3));
								AddAttributeChunkToList(attr, nodeData3, ref lastChunk);
							}
							ps.charPos++;
							string text = ParseEntityName();
							NodeData nodeData4 = new NodeData();
							nodeData4.lineInfo = lineInfo2;
							nodeData4.depth = attr.depth + 1;
							nodeData4.SetNamedNode(XmlNodeType.EntityReference, text);
							AddAttributeChunkToList(attr, nodeData4, ref lastChunk);
							stringBuilder.Append('&');
							stringBuilder.Append(text);
							stringBuilder.Append(';');
							num = stringBuilder.Length;
							lineInfo.Set(ps.LineNo, ps.LinePos);
							fullAttrCleanup = true;
						}
						else
						{
							ps.charPos++;
							ParseEntityName();
						}
						charRefEndPos = ps.charPos;
						break;
					case EntityType.ExpandedInAttribute:
						if (parsingMode == ParsingMode.Full && entityId2 == entityId)
						{
							int num2 = stringBuilder.Length - num;
							if (num2 > 0)
							{
								NodeData nodeData = new NodeData();
								nodeData.lineInfo = lineInfo;
								nodeData.depth = attr.depth + 1;
								nodeData.SetValueNode(XmlNodeType.Text, stringBuilder.ToString(num, num2));
								AddAttributeChunkToList(attr, nodeData, ref lastChunk);
							}
							NodeData nodeData2 = new NodeData();
							nodeData2.lineInfo = lineInfo2;
							nodeData2.depth = attr.depth + 1;
							nodeData2.SetNamedNode(XmlNodeType.EntityReference, ps.entity.Name.Name);
							AddAttributeChunkToList(attr, nodeData2, ref lastChunk);
							fullAttrCleanup = true;
						}
						charRefEndPos = ps.charPos;
						break;
					default:
						charRefEndPos = ps.charPos;
						break;
					case EntityType.CharacterDec:
					case EntityType.CharacterHex:
					case EntityType.CharacterNamed:
						break;
					}
					chars = ps.chars;
					continue;
				}
				default:
				{
					if (charRefEndPos == ps.charsUsed)
					{
						break;
					}
					char c = chars[charRefEndPos];
					if (c >= '\ud800' && c <= '\udbff')
					{
						if (charRefEndPos + 1 == ps.charsUsed)
						{
							break;
						}
						charRefEndPos++;
						if (chars[charRefEndPos] >= '\udc00' && chars[charRefEndPos] <= '\udfff')
						{
							charRefEndPos++;
							continue;
						}
					}
					ThrowInvalidChar(charRefEndPos, c);
					break;
				}
				}
				if (ReadData() == 0)
				{
					if (ps.charsUsed - ps.charPos > 0)
					{
						if (ps.chars[ps.charPos] != '\r')
						{
							Throw("Xml_UnexpectedEOF1");
						}
					}
					else
					{
						if (!InEntity)
						{
							if (fragmentType == XmlNodeType.Attribute)
							{
								if (entityId != ps.entityId)
								{
									Throw("Xml_EntityRefNesting");
								}
								break;
							}
							Throw("Xml_UnclosedQuote");
						}
						if (HandleEntityEnd(checkEntityNesting: true))
						{
							Throw("Xml_InternalError");
						}
						if (entityId == ps.entityId)
						{
							num = stringBuilder.Length;
							lineInfo.Set(ps.LineNo, ps.LinePos);
						}
					}
				}
				charRefEndPos = ps.charPos;
				chars = ps.chars;
			}
			if (attr.nextAttrValueChunk != null)
			{
				int num4 = stringBuilder.Length - num;
				if (num4 > 0)
				{
					NodeData nodeData5 = new NodeData();
					nodeData5.lineInfo = lineInfo;
					nodeData5.depth = attr.depth + 1;
					nodeData5.SetValueNode(XmlNodeType.Text, stringBuilder.ToString(num, num4));
					AddAttributeChunkToList(attr, nodeData5, ref lastChunk);
				}
			}
			ps.charPos = charRefEndPos + 1;
			attr.SetValue(stringBuilder.ToString());
			stringBuilder.Length = 0;
		}

		private void AddAttributeChunkToList(NodeData attr, NodeData chunk, ref NodeData lastChunk)
		{
			if (lastChunk == null)
			{
				lastChunk = chunk;
				attr.nextAttrValueChunk = chunk;
			}
			else
			{
				lastChunk.nextAttrValueChunk = chunk;
				lastChunk = chunk;
			}
		}

		private bool ParseText()
		{
			int outOrChars = 0;
			int startPos;
			int endPos;
			if (parsingMode != 0)
			{
				while (!ParseText(out startPos, out endPos, ref outOrChars))
				{
				}
			}
			else
			{
				curNode.SetLineInfo(ps.LineNo, ps.LinePos);
				if (ParseText(out startPos, out endPos, ref outOrChars))
				{
					if (endPos - startPos != 0)
					{
						XmlNodeType textNodeType = GetTextNodeType(outOrChars);
						if (textNodeType != 0)
						{
							curNode.SetValueNode(textNodeType, ps.chars, startPos, endPos - startPos);
							return true;
						}
					}
				}
				else if (v1Compat)
				{
					do
					{
						stringBuilder.Append(ps.chars, startPos, endPos - startPos);
					}
					while (!ParseText(out startPos, out endPos, ref outOrChars));
					stringBuilder.Append(ps.chars, startPos, endPos - startPos);
					XmlNodeType textNodeType2 = GetTextNodeType(outOrChars);
					if (textNodeType2 != 0)
					{
						curNode.SetValueNode(textNodeType2, stringBuilder.ToString());
						stringBuilder.Length = 0;
						return true;
					}
					stringBuilder.Length = 0;
				}
				else
				{
					bool flag = false;
					if (outOrChars > 32)
					{
						curNode.SetValueNode(XmlNodeType.Text, ps.chars, startPos, endPos - startPos);
						nextParsingFunction = parsingFunction;
						parsingFunction = ParsingFunction.PartialTextValue;
						return true;
					}
					stringBuilder.Append(ps.chars, startPos, endPos - startPos);
					do
					{
						flag = ParseText(out startPos, out endPos, ref outOrChars);
						stringBuilder.Append(ps.chars, startPos, endPos - startPos);
					}
					while (!flag && outOrChars <= 32 && stringBuilder.Length < 4096);
					XmlNodeType xmlNodeType = ((stringBuilder.Length < 4096) ? GetTextNodeType(outOrChars) : XmlNodeType.Text);
					if (xmlNodeType != 0)
					{
						curNode.SetValueNode(xmlNodeType, stringBuilder.ToString());
						stringBuilder.Length = 0;
						if (!flag)
						{
							nextParsingFunction = parsingFunction;
							parsingFunction = ParsingFunction.PartialTextValue;
						}
						return true;
					}
					stringBuilder.Length = 0;
					if (!flag)
					{
						while (!ParseText(out startPos, out endPos, ref outOrChars))
						{
						}
					}
				}
			}
			if (parsingFunction == ParsingFunction.ReportEndEntity)
			{
				SetupEndEntityNodeInContent();
				parsingFunction = nextParsingFunction;
				return true;
			}
			if (parsingFunction == ParsingFunction.EntityReference)
			{
				parsingFunction = nextNextParsingFunction;
				ParseEntityReference();
				return true;
			}
			return false;
		}

		private unsafe bool ParseText(out int startPos, out int endPos, ref int outOrChars)
		{
			char[] chars = ps.chars;
			int charRefEndPos = ps.charPos;
			int num = 0;
			int num2 = -1;
			int num3 = outOrChars;
			char c;
			while (true)
			{
				if ((xmlCharType.charProperties[(int)(c = chars[charRefEndPos])] & 0x40u) != 0)
				{
					num3 |= c;
					charRefEndPos++;
					continue;
				}
				switch (c)
				{
				case '\t':
					charRefEndPos++;
					continue;
				case '\n':
					charRefEndPos++;
					OnNewLine(charRefEndPos);
					continue;
				case '\r':
					if (chars[charRefEndPos + 1] == '\n')
					{
						if (!ps.eolNormalized && parsingMode == ParsingMode.Full)
						{
							if (charRefEndPos - ps.charPos > 0)
							{
								if (num == 0)
								{
									num = 1;
									num2 = charRefEndPos;
								}
								else
								{
									ShiftBuffer(num2 + num, num2, charRefEndPos - num2 - num);
									num2 = charRefEndPos - num;
									num++;
								}
							}
							else
							{
								ps.charPos++;
							}
						}
						charRefEndPos += 2;
					}
					else
					{
						if (charRefEndPos + 1 >= ps.charsUsed && !ps.isEof)
						{
							goto IL_036a;
						}
						if (!ps.eolNormalized)
						{
							chars[charRefEndPos] = '\n';
						}
						charRefEndPos++;
					}
					OnNewLine(charRefEndPos);
					continue;
				case '&':
				{
					int num5;
					if ((num5 = ParseCharRefInline(charRefEndPos, out var charCount, out var entityType)) > 0)
					{
						if (num > 0)
						{
							ShiftBuffer(num2 + num, num2, charRefEndPos - num2 - num);
						}
						num2 = charRefEndPos - num;
						num += num5 - charRefEndPos - charCount;
						charRefEndPos = num5;
						if (!xmlCharType.IsWhiteSpace(chars[num5 - charCount]) || (v1Compat && entityType == EntityType.CharacterDec))
						{
							num3 |= 0xFF;
						}
						continue;
					}
					if (charRefEndPos > ps.charPos)
					{
						break;
					}
					switch (HandleEntityReference(isInAttributeValue: false, EntityExpandType.All, out charRefEndPos))
					{
					case EntityType.Unexpanded:
						break;
					case EntityType.CharacterDec:
						if (!v1Compat)
						{
							goto case EntityType.CharacterHex;
						}
						num3 |= 0xFF;
						goto IL_025d;
					case EntityType.CharacterHex:
					case EntityType.CharacterNamed:
						if (!xmlCharType.IsWhiteSpace(ps.chars[charRefEndPos - 1]))
						{
							num3 |= 0xFF;
						}
						goto IL_025d;
					default:
						{
							charRefEndPos = ps.charPos;
							goto IL_025d;
						}
						IL_025d:
						chars = ps.chars;
						continue;
					}
					nextParsingFunction = parsingFunction;
					parsingFunction = ParsingFunction.EntityReference;
					goto IL_0409;
				}
				case ']':
					if (ps.charsUsed - charRefEndPos >= 3 || ps.isEof)
					{
						if (chars[charRefEndPos + 1] == ']' && chars[charRefEndPos + 2] == '>')
						{
							Throw(charRefEndPos, "Xml_CDATAEndInText");
						}
						num3 |= 0x5D;
						charRefEndPos++;
						continue;
					}
					goto IL_036a;
				default:
					if (charRefEndPos != ps.charsUsed)
					{
						char c2 = chars[charRefEndPos];
						if (c2 >= '\ud800' && c2 <= '\udbff')
						{
							if (charRefEndPos + 1 == ps.charsUsed)
							{
								goto IL_036a;
							}
							charRefEndPos++;
							if (chars[charRefEndPos] >= '\udc00' && chars[charRefEndPos] <= '\udfff')
							{
								charRefEndPos++;
								num3 |= c2;
								continue;
							}
						}
						int num4 = charRefEndPos - ps.charPos;
						if (ZeroEndingStream(charRefEndPos))
						{
							chars = ps.chars;
							charRefEndPos = ps.charPos + num4;
							break;
						}
						ThrowInvalidChar(ps.charPos + num4, c2);
					}
					goto IL_036a;
				case '<':
					break;
					IL_03ec:
					charRefEndPos = ps.charPos;
					chars = ps.chars;
					continue;
					IL_0409:
					startPos = (endPos = charRefEndPos);
					return true;
					IL_036a:
					if (charRefEndPos > ps.charPos)
					{
						break;
					}
					if (ReadData() == 0)
					{
						if (ps.charsUsed - ps.charPos <= 0)
						{
							if (InEntity)
							{
								if (!HandleEntityEnd(checkEntityNesting: true))
								{
									goto IL_03ec;
								}
								nextParsingFunction = parsingFunction;
								parsingFunction = ParsingFunction.ReportEndEntity;
							}
							goto IL_0409;
						}
						if (ps.chars[ps.charPos] != '\r')
						{
							Throw("Xml_UnexpectedEOF1");
						}
					}
					goto IL_03ec;
				}
				break;
			}
			if (parsingMode == ParsingMode.Full && num > 0)
			{
				ShiftBuffer(num2 + num, num2, charRefEndPos - num2 - num);
			}
			startPos = ps.charPos;
			endPos = charRefEndPos - num;
			ps.charPos = charRefEndPos;
			outOrChars = num3;
			return c == '<';
		}

		private void FinishPartialValue()
		{
			curNode.CopyTo(readValueOffset, stringBuilder);
			int outOrChars = 0;
			int startPos;
			int endPos;
			while (!ParseText(out startPos, out endPos, ref outOrChars))
			{
				stringBuilder.Append(ps.chars, startPos, endPos - startPos);
			}
			stringBuilder.Append(ps.chars, startPos, endPos - startPos);
			curNode.SetValue(stringBuilder.ToString());
			stringBuilder.Length = 0;
		}

		private void FinishOtherValueIterator()
		{
			switch (parsingFunction)
			{
			case ParsingFunction.InReadValueChunk:
				if (incReadState == IncrementalReadState.ReadValueChunk_OnPartialValue)
				{
					FinishPartialValue();
					incReadState = IncrementalReadState.ReadValueChunk_OnCachedValue;
				}
				else if (readValueOffset > 0)
				{
					curNode.SetValue(curNode.StringValue.Substring(readValueOffset));
					readValueOffset = 0;
				}
				break;
			case ParsingFunction.InReadContentAsBinary:
			case ParsingFunction.InReadElementContentAsBinary:
				switch (incReadState)
				{
				case IncrementalReadState.ReadContentAsBinary_OnPartialValue:
					FinishPartialValue();
					incReadState = IncrementalReadState.ReadContentAsBinary_OnCachedValue;
					break;
				case IncrementalReadState.ReadContentAsBinary_OnCachedValue:
					if (readValueOffset > 0)
					{
						curNode.SetValue(curNode.StringValue.Substring(readValueOffset));
						readValueOffset = 0;
					}
					break;
				case IncrementalReadState.ReadContentAsBinary_End:
					curNode.SetValue(string.Empty);
					break;
				}
				break;
			case ParsingFunction.InReadAttributeValue:
				break;
			}
		}

		private void SkipPartialTextValue()
		{
			int outOrChars = 0;
			parsingFunction = nextParsingFunction;
			int startPos;
			int endPos;
			while (!ParseText(out startPos, out endPos, ref outOrChars))
			{
			}
		}

		private void FinishReadValueChunk()
		{
			readValueOffset = 0;
			if (incReadState == IncrementalReadState.ReadValueChunk_OnPartialValue)
			{
				SkipPartialTextValue();
				return;
			}
			parsingFunction = nextParsingFunction;
			nextParsingFunction = nextNextParsingFunction;
		}

		private void FinishReadContentAsBinary()
		{
			readValueOffset = 0;
			if (incReadState == IncrementalReadState.ReadContentAsBinary_OnPartialValue)
			{
				SkipPartialTextValue();
			}
			else
			{
				parsingFunction = nextParsingFunction;
				nextParsingFunction = nextNextParsingFunction;
			}
			if (incReadState != IncrementalReadState.ReadContentAsBinary_End)
			{
				while (MoveToNextContentNode(moveIfOnContentNode: true))
				{
				}
			}
		}

		private void FinishReadElementContentAsBinary()
		{
			FinishReadContentAsBinary();
			if (curNode.type != XmlNodeType.EndElement)
			{
				Throw("Xml_InvalidNodeType", curNode.type.ToString());
			}
			outerReader.Read();
		}

		private bool ParseRootLevelWhitespace()
		{
			XmlNodeType whitespaceType = GetWhitespaceType();
			if (whitespaceType == XmlNodeType.None)
			{
				EatWhitespaces(null);
				if (ps.chars[ps.charPos] == '<' || ps.charsUsed - ps.charPos == 0 || ZeroEndingStream(ps.charPos))
				{
					return false;
				}
			}
			else
			{
				curNode.SetLineInfo(ps.LineNo, ps.LinePos);
				EatWhitespaces(stringBuilder);
				if (ps.chars[ps.charPos] == '<' || ps.charsUsed - ps.charPos == 0 || ZeroEndingStream(ps.charPos))
				{
					if (stringBuilder.Length > 0)
					{
						curNode.SetValueNode(whitespaceType, stringBuilder.ToString());
						stringBuilder.Length = 0;
						return true;
					}
					return false;
				}
			}
			if (xmlCharType.IsCharData(ps.chars[ps.charPos]))
			{
				Throw("Xml_InvalidRootData");
			}
			else
			{
				ThrowInvalidChar(ps.charPos, ps.chars[ps.charPos]);
			}
			return false;
		}

		private void ParseEntityReference()
		{
			ps.charPos++;
			curNode.SetLineInfo(ps.LineNo, ps.LinePos);
			curNode.SetNamedNode(XmlNodeType.EntityReference, ParseEntityName());
		}

		private EntityType HandleEntityReference(bool isInAttributeValue, EntityExpandType expandType, out int charRefEndPos)
		{
			if (ps.charPos + 1 == ps.charsUsed && ReadData() == 0)
			{
				Throw("Xml_UnexpectedEOF1");
			}
			if (ps.chars[ps.charPos + 1] == '#')
			{
				charRefEndPos = ParseNumericCharRef(expandType != EntityExpandType.OnlyGeneral, null, out var entityType);
				return entityType;
			}
			charRefEndPos = ParseNamedCharRef(expandType != EntityExpandType.OnlyGeneral, null);
			if (charRefEndPos >= 0)
			{
				return EntityType.CharacterNamed;
			}
			if (expandType != EntityExpandType.OnlyCharacter && (entityHandling == EntityHandling.ExpandEntities || (isInAttributeValue && validatingReaderCompatFlag)))
			{
				ps.charPos++;
				int linePos = ps.LinePos;
				int num;
				try
				{
					num = ParseName();
				}
				catch (XmlException)
				{
					Throw("Xml_ErrorParsingEntityName", ps.LineNo, linePos);
					return EntityType.Skipped;
				}
				if (ps.chars[num] != ';')
				{
					ThrowUnexpectedToken(num, ";");
				}
				int linePos2 = ps.LinePos;
				string name = nameTable.Add(ps.chars, ps.charPos, num - ps.charPos);
				ps.charPos = num + 1;
				charRefEndPos = -1;
				EntityType result = HandleGeneralEntityReference(name, isInAttributeValue, pushFakeEntityIfNullResolver: false, linePos2);
				reportedBaseUri = ps.baseUriStr;
				reportedEncoding = ps.encoding;
				return result;
			}
			return EntityType.Unexpanded;
		}

		private EntityType HandleGeneralEntityReference(string name, bool isInAttributeValue, bool pushFakeEntityIfNullResolver, int entityStartLinePos)
		{
			SchemaEntity schemaEntity = null;
			XmlQualifiedName key = new XmlQualifiedName(name);
			if (dtdParserProxy == null && fragmentParserContext != null && fragmentParserContext.HasDtdInfo && !prohibitDtd)
			{
				ParseDtdFromParserContext();
			}
			if (dtdParserProxy == null || (schemaEntity = (SchemaEntity)dtdParserProxy.DtdSchemaInfo.GeneralEntities[key]) == null)
			{
				if (disableUndeclaredEntityCheck)
				{
					schemaEntity = new SchemaEntity(new XmlQualifiedName(name), isParameter: false);
					schemaEntity.Text = string.Empty;
				}
				else
				{
					Throw("Xml_UndeclaredEntity", name, ps.LineNo, entityStartLinePos);
				}
			}
			if (schemaEntity.IsProcessed)
			{
				Throw("Xml_RecursiveGenEntity", name, ps.LineNo, entityStartLinePos);
			}
			if (!schemaEntity.NData.IsEmpty)
			{
				if (disableUndeclaredEntityCheck)
				{
					schemaEntity = new SchemaEntity(new XmlQualifiedName(name), isParameter: false);
					schemaEntity.Text = string.Empty;
				}
				else
				{
					Throw("Xml_UnparsedEntityRef", name, ps.LineNo, entityStartLinePos);
				}
			}
			if (standalone && schemaEntity.DeclaredInExternal)
			{
				Throw("Xml_ExternalEntityInStandAloneDocument", schemaEntity.Name.Name, ps.LineNo, entityStartLinePos);
			}
			if (schemaEntity.IsExternal)
			{
				if (isInAttributeValue)
				{
					Throw("Xml_ExternalEntityInAttValue", name, ps.LineNo, entityStartLinePos);
					return EntityType.Skipped;
				}
				if (parsingMode == ParsingMode.SkipContent)
				{
					return EntityType.Skipped;
				}
				if (IsResolverNull)
				{
					if (pushFakeEntityIfNullResolver)
					{
						PushExternalEntity(schemaEntity, ++nextEntityId);
						curNode.entityId = ps.entityId;
						return EntityType.FakeExpanded;
					}
					return EntityType.Skipped;
				}
				PushExternalEntity(schemaEntity, ++nextEntityId);
				curNode.entityId = ps.entityId;
				if (!isInAttributeValue || !validatingReaderCompatFlag)
				{
					return EntityType.Expanded;
				}
				return EntityType.ExpandedInAttribute;
			}
			if (parsingMode == ParsingMode.SkipContent)
			{
				return EntityType.Skipped;
			}
			int entityId = nextEntityId++;
			PushInternalEntity(schemaEntity, entityId);
			curNode.entityId = entityId;
			if (!isInAttributeValue || !validatingReaderCompatFlag)
			{
				return EntityType.Expanded;
			}
			return EntityType.ExpandedInAttribute;
		}

		private bool HandleEntityEnd(bool checkEntityNesting)
		{
			if (parsingStatesStackTop == -1)
			{
				Throw("Xml_InternalError");
			}
			if (ps.entityResolvedManually)
			{
				index--;
				if (checkEntityNesting && ps.entityId != nodes[index].entityId)
				{
					Throw("Xml_IncompleteEntity");
				}
				lastEntity = ps.entity;
				PopEntity();
				curNode.entityId = ps.entityId;
				return true;
			}
			if (checkEntityNesting && ps.entityId != nodes[index].entityId)
			{
				Throw("Xml_IncompleteEntity");
			}
			PopEntity();
			curNode.entityId = ps.entityId;
			reportedEncoding = ps.encoding;
			reportedBaseUri = ps.baseUriStr;
			return false;
		}

		private void SetupEndEntityNodeInContent()
		{
			reportedEncoding = ps.encoding;
			reportedBaseUri = ps.baseUriStr;
			curNode = nodes[index];
			curNode.SetNamedNode(XmlNodeType.EndEntity, lastEntity.Name.Name);
			curNode.lineInfo.Set(ps.lineNo, ps.LinePos - 1);
			if (index == 0 && parsingFunction == ParsingFunction.ElementContent)
			{
				parsingFunction = ParsingFunction.DocumentContent;
			}
		}

		private void SetupEndEntityNodeInAttribute()
		{
			curNode = nodes[index + attrCount + 1];
			curNode.lineInfo.linePos += curNode.localName.Length;
			curNode.type = XmlNodeType.EndEntity;
		}

		private bool ParsePI()
		{
			return ParsePI(null);
		}

		private bool ParsePI(BufferBuilder piInDtdStringBuilder)
		{
			if (parsingMode == ParsingMode.Full)
			{
				curNode.SetLineInfo(ps.LineNo, ps.LinePos);
			}
			int num = ParseName();
			string text = nameTable.Add(ps.chars, ps.charPos, num - ps.charPos);
			if (string.Compare(text, "xml", StringComparison.OrdinalIgnoreCase) == 0)
			{
				Throw(text.Equals("xml") ? "Xml_XmlDeclNotFirst" : "Xml_InvalidPIName", text);
			}
			ps.charPos = num;
			if (piInDtdStringBuilder == null)
			{
				if (!ignorePIs && parsingMode == ParsingMode.Full)
				{
					curNode.SetNamedNode(XmlNodeType.ProcessingInstruction, text);
				}
			}
			else
			{
				piInDtdStringBuilder.Append(text);
			}
			char c = ps.chars[ps.charPos];
			if (EatWhitespaces(piInDtdStringBuilder) == 0)
			{
				if (ps.charsUsed - ps.charPos < 2)
				{
					ReadData();
				}
				if (c != '?' || ps.chars[ps.charPos + 1] != '>')
				{
					Throw("Xml_BadNameChar", XmlException.BuildCharExceptionStr(c));
				}
			}
			if (ParsePIValue(out var outStartPos, out var outEndPos))
			{
				if (piInDtdStringBuilder == null)
				{
					if (ignorePIs)
					{
						return false;
					}
					if (parsingMode == ParsingMode.Full)
					{
						curNode.SetValue(ps.chars, outStartPos, outEndPos - outStartPos);
					}
				}
				else
				{
					piInDtdStringBuilder.Append(ps.chars, outStartPos, outEndPos - outStartPos);
				}
			}
			else
			{
				BufferBuilder bufferBuilder;
				if (piInDtdStringBuilder == null)
				{
					if (ignorePIs || parsingMode != 0)
					{
						while (!ParsePIValue(out outStartPos, out outEndPos))
						{
						}
						return false;
					}
					bufferBuilder = stringBuilder;
				}
				else
				{
					bufferBuilder = piInDtdStringBuilder;
				}
				do
				{
					bufferBuilder.Append(ps.chars, outStartPos, outEndPos - outStartPos);
				}
				while (!ParsePIValue(out outStartPos, out outEndPos));
				bufferBuilder.Append(ps.chars, outStartPos, outEndPos - outStartPos);
				if (piInDtdStringBuilder == null)
				{
					curNode.SetValue(stringBuilder.ToString());
					stringBuilder.Length = 0;
				}
			}
			return true;
		}

		private unsafe bool ParsePIValue(out int outStartPos, out int outEndPos)
		{
			if (ps.charsUsed - ps.charPos < 2 && ReadData() == 0)
			{
				Throw(ps.charsUsed, "Xml_UnexpectedEOF", "PI");
			}
			int num = ps.charPos;
			char[] chars = ps.chars;
			int num2 = 0;
			int num3 = -1;
			while (true)
			{
				if ((xmlCharType.charProperties[(int)chars[num]] & 0x40u) != 0 && chars[num] != '?')
				{
					num++;
					continue;
				}
				switch (chars[num])
				{
				case '?':
					if (chars[num + 1] == '>')
					{
						if (num2 > 0)
						{
							ShiftBuffer(num3 + num2, num3, num - num3 - num2);
							outEndPos = num - num2;
						}
						else
						{
							outEndPos = num;
						}
						outStartPos = ps.charPos;
						ps.charPos = num + 2;
						return true;
					}
					if (num + 1 != ps.charsUsed)
					{
						num++;
						continue;
					}
					break;
				case '\n':
					num++;
					OnNewLine(num);
					continue;
				case '\r':
					if (chars[num + 1] == '\n')
					{
						if (!ps.eolNormalized && parsingMode == ParsingMode.Full)
						{
							if (num - ps.charPos > 0)
							{
								if (num2 == 0)
								{
									num2 = 1;
									num3 = num;
								}
								else
								{
									ShiftBuffer(num3 + num2, num3, num - num3 - num2);
									num3 = num - num2;
									num2++;
								}
							}
							else
							{
								ps.charPos++;
							}
						}
						num += 2;
					}
					else
					{
						if (num + 1 >= ps.charsUsed && !ps.isEof)
						{
							break;
						}
						if (!ps.eolNormalized)
						{
							chars[num] = '\n';
						}
						num++;
					}
					OnNewLine(num);
					continue;
				case '\t':
				case '&':
				case '<':
				case ']':
					num++;
					continue;
				default:
				{
					if (num == ps.charsUsed)
					{
						break;
					}
					char c = chars[num];
					if (c >= '\ud800' && c <= '\udbff')
					{
						if (num + 1 == ps.charsUsed)
						{
							break;
						}
						num++;
						if (chars[num] >= '\udc00' && chars[num] <= '\udfff')
						{
							num++;
							continue;
						}
					}
					ThrowInvalidChar(num, c);
					continue;
				}
				}
				break;
			}
			if (num2 > 0)
			{
				ShiftBuffer(num3 + num2, num3, num - num3 - num2);
				outEndPos = num - num2;
			}
			else
			{
				outEndPos = num;
			}
			outStartPos = ps.charPos;
			ps.charPos = num;
			return false;
		}

		private bool ParseComment()
		{
			if (ignoreComments)
			{
				ParsingMode parsingMode = this.parsingMode;
				this.parsingMode = ParsingMode.SkipNode;
				ParseCDataOrComment(XmlNodeType.Comment);
				this.parsingMode = parsingMode;
				return false;
			}
			ParseCDataOrComment(XmlNodeType.Comment);
			return true;
		}

		private void ParseCData()
		{
			ParseCDataOrComment(XmlNodeType.CDATA);
		}

		private void ParseCDataOrComment(XmlNodeType type)
		{
			int outStartPos;
			int outEndPos;
			if (parsingMode == ParsingMode.Full)
			{
				curNode.SetLineInfo(ps.LineNo, ps.LinePos);
				if (ParseCDataOrComment(type, out outStartPos, out outEndPos))
				{
					curNode.SetValueNode(type, ps.chars, outStartPos, outEndPos - outStartPos);
					return;
				}
				do
				{
					stringBuilder.Append(ps.chars, outStartPos, outEndPos - outStartPos);
				}
				while (!ParseCDataOrComment(type, out outStartPos, out outEndPos));
				stringBuilder.Append(ps.chars, outStartPos, outEndPos - outStartPos);
				curNode.SetValueNode(type, stringBuilder.ToString());
				stringBuilder.Length = 0;
			}
			else
			{
				while (!ParseCDataOrComment(type, out outStartPos, out outEndPos))
				{
				}
			}
		}

		private unsafe bool ParseCDataOrComment(XmlNodeType type, out int outStartPos, out int outEndPos)
		{
			if (ps.charsUsed - ps.charPos < 3 && ReadData() == 0)
			{
				Throw("Xml_UnexpectedEOF", (type == XmlNodeType.Comment) ? "Comment" : "CDATA");
			}
			int num = ps.charPos;
			char[] chars = ps.chars;
			int num2 = 0;
			int num3 = -1;
			char c = ((type == XmlNodeType.Comment) ? '-' : ']');
			while (true)
			{
				if ((xmlCharType.charProperties[(int)chars[num]] & 0x40u) != 0 && chars[num] != c)
				{
					num++;
					continue;
				}
				if (chars[num] == c)
				{
					if (chars[num + 1] == c)
					{
						if (chars[num + 2] == '>')
						{
							if (num2 > 0)
							{
								ShiftBuffer(num3 + num2, num3, num - num3 - num2);
								outEndPos = num - num2;
							}
							else
							{
								outEndPos = num;
							}
							outStartPos = ps.charPos;
							ps.charPos = num + 3;
							return true;
						}
						if (num + 2 == ps.charsUsed)
						{
							break;
						}
						if (type == XmlNodeType.Comment)
						{
							Throw(num, "Xml_InvalidCommentChars");
						}
					}
					else if (num + 1 == ps.charsUsed)
					{
						break;
					}
					num++;
					continue;
				}
				switch (chars[num])
				{
				case '\n':
					num++;
					OnNewLine(num);
					continue;
				case '\r':
					if (chars[num + 1] == '\n')
					{
						if (!ps.eolNormalized && parsingMode == ParsingMode.Full)
						{
							if (num - ps.charPos > 0)
							{
								if (num2 == 0)
								{
									num2 = 1;
									num3 = num;
								}
								else
								{
									ShiftBuffer(num3 + num2, num3, num - num3 - num2);
									num3 = num - num2;
									num2++;
								}
							}
							else
							{
								ps.charPos++;
							}
						}
						num += 2;
					}
					else
					{
						if (num + 1 >= ps.charsUsed && !ps.isEof)
						{
							break;
						}
						if (!ps.eolNormalized)
						{
							chars[num] = '\n';
						}
						num++;
					}
					OnNewLine(num);
					continue;
				case '\t':
				case '&':
				case '<':
				case ']':
					num++;
					continue;
				default:
				{
					if (num == ps.charsUsed)
					{
						break;
					}
					char c2 = chars[num];
					if (c2 >= '\ud800' && c2 <= '\udbff')
					{
						if (num + 1 == ps.charsUsed)
						{
							break;
						}
						num++;
						if (chars[num] >= '\udc00' && chars[num] <= '\udfff')
						{
							num++;
							continue;
						}
					}
					ThrowInvalidChar(num, c2);
					break;
				}
				}
				break;
			}
			if (num2 > 0)
			{
				ShiftBuffer(num3 + num2, num3, num - num3 - num2);
				outEndPos = num - num2;
			}
			else
			{
				outEndPos = num;
			}
			outStartPos = ps.charPos;
			ps.charPos = num;
			return false;
		}

		private void ParseDoctypeDecl()
		{
			if (prohibitDtd)
			{
				ThrowWithoutLineInfo(v1Compat ? "Xml_DtdIsProhibited" : "Xml_DtdIsProhibitedEx", string.Empty);
			}
			while (ps.charsUsed - ps.charPos < 8)
			{
				if (ReadData() == 0)
				{
					Throw("Xml_UnexpectedEOF", "DOCTYPE");
				}
			}
			if (!XmlConvert.StrEqual(ps.chars, ps.charPos, 7, "DOCTYPE"))
			{
				ThrowUnexpectedToken((!rootElementParsed && dtdParserProxy == null) ? "DOCTYPE" : "<!--");
			}
			if (!xmlCharType.IsWhiteSpace(ps.chars[ps.charPos + 7]))
			{
				Throw("Xml_ExpectingWhiteSpace", ParseUnexpectedToken(ps.charPos + 7));
			}
			if (dtdParserProxy != null)
			{
				Throw(ps.charPos - 2, "Xml_MultipleDTDsProvided");
			}
			if (rootElementParsed)
			{
				Throw(ps.charPos - 2, "Xml_DtdAfterRootElement");
			}
			ps.charPos += 8;
			EatWhitespaces(null);
			curNode.SetLineInfo(ps.LineNo, ps.LinePos);
			dtdParserProxy = new DtdParserProxy(this);
			dtdParserProxy.Parse(saveInternalSubset: true);
			SchemaInfo dtdSchemaInfo = dtdParserProxy.DtdSchemaInfo;
			if ((validatingReaderCompatFlag || !v1Compat) && (dtdSchemaInfo.HasDefaultAttributes || dtdSchemaInfo.HasNonCDataAttributes))
			{
				addDefaultAttributesAndNormalize = true;
				qName = new XmlQualifiedName();
			}
			curNode.SetNamedNode(XmlNodeType.DocumentType, dtdSchemaInfo.DocTypeName.ToString());
			curNode.SetValue(dtdParserProxy.InternalDtdSubset);
			nextParsingFunction = parsingFunction;
			parsingFunction = ParsingFunction.ResetAttributesRootLevel;
		}

		private int EatWhitespaces(BufferBuilder sb)
		{
			int num = ps.charPos;
			int num2 = 0;
			char[] chars = ps.chars;
			while (true)
			{
				switch (chars[num])
				{
				case '\n':
					num++;
					OnNewLine(num);
					continue;
				case '\r':
					if (chars[num + 1] == '\n')
					{
						int num4 = num - ps.charPos;
						if (sb != null && !ps.eolNormalized)
						{
							if (num4 > 0)
							{
								sb.Append(chars, ps.charPos, num4);
								num2 += num4;
							}
							ps.charPos = num + 1;
						}
						num += 2;
					}
					else
					{
						if (num + 1 >= ps.charsUsed && !ps.isEof)
						{
							break;
						}
						if (!ps.eolNormalized)
						{
							chars[num] = '\n';
						}
						num++;
					}
					OnNewLine(num);
					continue;
				case '\t':
				case ' ':
					num++;
					continue;
				default:
					if (num != ps.charsUsed)
					{
						int num3 = num - ps.charPos;
						if (num3 > 0)
						{
							sb?.Append(ps.chars, ps.charPos, num3);
							ps.charPos = num;
							num2 += num3;
						}
						return num2;
					}
					break;
				}
				int num5 = num - ps.charPos;
				if (num5 > 0)
				{
					sb?.Append(ps.chars, ps.charPos, num5);
					ps.charPos = num;
					num2 += num5;
				}
				if (ReadData() == 0)
				{
					if (ps.charsUsed - ps.charPos == 0)
					{
						break;
					}
					if (ps.chars[ps.charPos] != '\r')
					{
						Throw("Xml_UnexpectedEOF1");
					}
				}
				num = ps.charPos;
				chars = ps.chars;
			}
			return num2;
		}

		private int ParseCharRefInline(int startPos, out int charCount, out EntityType entityType)
		{
			if (ps.chars[startPos + 1] == '#')
			{
				return ParseNumericCharRefInline(startPos, expand: true, null, out charCount, out entityType);
			}
			charCount = 1;
			entityType = EntityType.CharacterNamed;
			return ParseNamedCharRefInline(startPos, expand: true, null);
		}

		private int ParseNumericCharRef(bool expand, BufferBuilder internalSubsetBuilder, out EntityType entityType)
		{
			int num;
			int charCount;
			while (true)
			{
				int num2 = (num = ParseNumericCharRefInline(ps.charPos, expand, internalSubsetBuilder, out charCount, out entityType));
				if (num2 != -2)
				{
					break;
				}
				if (ReadData() == 0)
				{
					Throw("Xml_UnexpectedEOF");
				}
			}
			if (expand)
			{
				ps.charPos = num - charCount;
			}
			return num;
		}

		private int ParseNumericCharRefInline(int startPos, bool expand, BufferBuilder internalSubsetBuilder, out int charCount, out EntityType entityType)
		{
			int num = 0;
			string text = null;
			char[] chars = ps.chars;
			int i = startPos + 2;
			charCount = 0;
			if (chars[i] == 'x')
			{
				i++;
				text = "Xml_BadHexEntity";
				while (true)
				{
					char c = chars[i];
					if (c >= '0' && c <= '9')
					{
						num = num * 16 + c - 48;
					}
					else if (c >= 'a' && c <= 'f')
					{
						num = num * 16 + 10 + c - 97;
					}
					else
					{
						if (c < 'A' || c > 'F')
						{
							break;
						}
						num = num * 16 + 10 + c - 65;
					}
					i++;
				}
				entityType = EntityType.CharacterHex;
			}
			else
			{
				if (i >= ps.charsUsed)
				{
					entityType = EntityType.Unexpanded;
					return -2;
				}
				text = "Xml_BadDecimalEntity";
				for (; chars[i] >= '0' && chars[i] <= '9'; i++)
				{
					num = num * 10 + chars[i] - 48;
				}
				entityType = EntityType.CharacterDec;
			}
			if (chars[i] != ';')
			{
				if (i == ps.charsUsed)
				{
					return -2;
				}
				Throw(i, text);
			}
			if (num <= 65535)
			{
				char c2 = (char)num;
				if ((!xmlCharType.IsCharData(c2) || (c2 >= '\udc00' && c2 <= '\udeff')) && ((v1Compat && normalize) || (!v1Compat && checkCharacters)))
				{
					ThrowInvalidChar((ps.chars[ps.charPos + 2] == 'x') ? (ps.charPos + 3) : (ps.charPos + 2), c2);
				}
				if (expand)
				{
					internalSubsetBuilder?.Append(ps.chars, ps.charPos, i - ps.charPos + 1);
					chars[i] = c2;
				}
				charCount = 1;
				return i + 1;
			}
			int num2 = num - 65536;
			int num3 = 56320 + num2 % 1024;
			int num4 = 55296 + num2 / 1024;
			if (normalize)
			{
				char c3 = (char)num4;
				if (c3 >= '\ud800' && c3 <= '\udbff')
				{
					c3 = (char)num3;
					if (c3 >= '\udc00' && c3 <= '\udfff')
					{
						goto IL_0259;
					}
				}
				ThrowInvalidChar((ps.chars[ps.charPos + 2] == 'x') ? (ps.charPos + 3) : (ps.charPos + 2), (char)num);
			}
			goto IL_0259;
			IL_0259:
			if (expand)
			{
				internalSubsetBuilder?.Append(ps.chars, ps.charPos, i - ps.charPos + 1);
				chars[i - 1] = (char)num4;
				chars[i] = (char)num3;
			}
			charCount = 2;
			return i + 1;
		}

		private int ParseNamedCharRef(bool expand, BufferBuilder internalSubsetBuilder)
		{
			do
			{
				int num;
				switch (num = ParseNamedCharRefInline(ps.charPos, expand, internalSubsetBuilder))
				{
				case -1:
					return -1;
				case -2:
					continue;
				}
				if (expand)
				{
					ps.charPos = num - 1;
				}
				return num;
			}
			while (ReadData() != 0);
			return -1;
		}

		private int ParseNamedCharRefInline(int startPos, bool expand, BufferBuilder internalSubsetBuilder)
		{
			int num = startPos + 1;
			char[] chars = ps.chars;
			char c = chars[num];
			char c2;
			if (c <= 'g')
			{
				if (c != 'a')
				{
					if (c != 'g')
					{
						goto IL_0170;
					}
					if (ps.charsUsed - num >= 3)
					{
						if (chars[num + 1] == 't' && chars[num + 2] == ';')
						{
							num += 3;
							c2 = '>';
							goto IL_0175;
						}
						return -1;
					}
				}
				else
				{
					num++;
					if (chars[num] == 'm')
					{
						if (ps.charsUsed - num >= 3)
						{
							if (chars[num + 1] == 'p' && chars[num + 2] == ';')
							{
								num += 3;
								c2 = '&';
								goto IL_0175;
							}
							return -1;
						}
					}
					else if (chars[num] == 'p')
					{
						if (ps.charsUsed - num >= 4)
						{
							if (chars[num + 1] == 'o' && chars[num + 2] == 's' && chars[num + 3] == ';')
							{
								num += 4;
								c2 = '\'';
								goto IL_0175;
							}
							return -1;
						}
					}
					else if (num < ps.charsUsed)
					{
						return -1;
					}
				}
				goto IL_0172;
			}
			if (c != 'l')
			{
				if (c != 'q')
				{
					goto IL_0170;
				}
				if (ps.charsUsed - num < 5)
				{
					goto IL_0172;
				}
				if (chars[num + 1] != 'u' || chars[num + 2] != 'o' || chars[num + 3] != 't' || chars[num + 4] != ';')
				{
					return -1;
				}
				num += 5;
				c2 = '"';
			}
			else
			{
				if (ps.charsUsed - num < 3)
				{
					goto IL_0172;
				}
				if (chars[num + 1] != 't' || chars[num + 2] != ';')
				{
					return -1;
				}
				num += 3;
				c2 = '<';
			}
			goto IL_0175;
			IL_0175:
			if (expand)
			{
				internalSubsetBuilder?.Append(ps.chars, ps.charPos, num - ps.charPos);
				ps.chars[num - 1] = c2;
			}
			return num;
			IL_0172:
			return -2;
			IL_0170:
			return -1;
		}

		private int ParseName()
		{
			int colonPos;
			return ParseQName(isQName: false, 0, out colonPos);
		}

		private int ParseQName(out int colonPos)
		{
			return ParseQName(isQName: true, 0, out colonPos);
		}

		private unsafe int ParseQName(bool isQName, int startOffset, out int colonPos)
		{
			int num = -1;
			int pos = ps.charPos + startOffset;
			while (true)
			{
				char[] chars = ps.chars;
				if ((xmlCharType.charProperties[(int)chars[pos]] & 4) == 0)
				{
					if (pos == ps.charsUsed)
					{
						if (ReadDataInName(ref pos))
						{
							continue;
						}
						Throw(pos, "Xml_UnexpectedEOF", "Name");
					}
					if (chars[pos] != ':' || supportNamespaces)
					{
						Throw(pos, "Xml_BadStartNameChar", XmlException.BuildCharExceptionStr(chars[pos]));
					}
				}
				pos++;
				while (true)
				{
					if ((xmlCharType.charProperties[(int)chars[pos]] & 8u) != 0)
					{
						pos++;
						continue;
					}
					if (chars[pos] == ':')
					{
						break;
					}
					if (pos == ps.charsUsed)
					{
						if (ReadDataInName(ref pos))
						{
							chars = ps.chars;
							continue;
						}
						Throw(pos, "Xml_UnexpectedEOF", "Name");
					}
					colonPos = ((num == -1) ? (-1) : (ps.charPos + num));
					return pos;
				}
				if ((num != -1 || !isQName) && supportNamespaces)
				{
					Throw(pos, "Xml_BadNameChar", XmlException.BuildCharExceptionStr(':'));
				}
				num = pos - ps.charPos;
				pos++;
			}
		}

		private bool ReadDataInName(ref int pos)
		{
			int num = pos - ps.charPos;
			bool result = ReadData() != 0;
			pos = ps.charPos + num;
			return result;
		}

		private string ParseEntityName()
		{
			int num;
			try
			{
				num = ParseName();
			}
			catch (XmlException)
			{
				Throw("Xml_ErrorParsingEntityName");
				return null;
			}
			if (ps.chars[num] != ';')
			{
				Throw("Xml_ErrorParsingEntityName");
			}
			string result = nameTable.Add(ps.chars, ps.charPos, num - ps.charPos);
			ps.charPos = num + 1;
			return result;
		}

		private NodeData AddNode(int nodeIndex, int nodeDepth)
		{
			NodeData nodeData = nodes[nodeIndex];
			if (nodeData != null)
			{
				nodeData.depth = nodeDepth;
				return nodeData;
			}
			return AllocNode(nodeIndex, nodeDepth);
		}

		private NodeData AllocNode(int nodeIndex, int nodeDepth)
		{
			if (nodeIndex >= nodes.Length - 1)
			{
				NodeData[] destinationArray = new NodeData[nodes.Length * 2];
				Array.Copy(nodes, 0, destinationArray, 0, nodes.Length);
				nodes = destinationArray;
			}
			NodeData nodeData = nodes[nodeIndex];
			if (nodeData == null)
			{
				nodeData = new NodeData();
				nodes[nodeIndex] = nodeData;
			}
			nodeData.depth = nodeDepth;
			return nodeData;
		}

		private NodeData AddAttributeNoChecks(string name, int attrDepth)
		{
			NodeData nodeData = AddNode(index + attrCount + 1, attrDepth);
			nodeData.SetNamedNode(XmlNodeType.Attribute, nameTable.Add(name));
			attrCount++;
			return nodeData;
		}

		private NodeData AddAttribute(int endNamePos, int colonPos)
		{
			if (colonPos == -1 || !supportNamespaces)
			{
				string text = nameTable.Add(ps.chars, ps.charPos, endNamePos - ps.charPos);
				return AddAttribute(text, string.Empty, text);
			}
			attrNeedNamespaceLookup = true;
			int charPos = ps.charPos;
			int num = colonPos - charPos;
			if (num != lastPrefix.Length || !XmlConvert.StrEqual(ps.chars, charPos, num, lastPrefix))
			{
				return AddAttribute(prefix: lastPrefix = nameTable.Add(ps.chars, charPos, num), localName: nameTable.Add(ps.chars, colonPos + 1, endNamePos - colonPos - 1), nameWPrefix: null);
			}
			return AddAttribute(nameTable.Add(ps.chars, colonPos + 1, endNamePos - colonPos - 1), lastPrefix, null);
		}

		private NodeData AddAttribute(string localName, string prefix, string nameWPrefix)
		{
			NodeData nodeData = AddNode(index + attrCount + 1, index + 1);
			nodeData.SetNamedNode(XmlNodeType.Attribute, localName, prefix, nameWPrefix);
			int num = 1 << (localName[0] & 0x1F);
			if ((attrHashtable & num) == 0)
			{
				attrHashtable |= num;
			}
			else if (attrDuplWalkCount < 250)
			{
				attrDuplWalkCount++;
				for (int i = index + 1; i < index + attrCount + 1; i++)
				{
					NodeData nodeData2 = nodes[i];
					if (Ref.Equal(nodeData2.localName, nodeData.localName))
					{
						attrDuplWalkCount = 250;
						break;
					}
				}
			}
			attrCount++;
			return nodeData;
		}

		private void PopElementContext()
		{
			namespaceManager.PopScope();
			if (curNode.xmlContextPushed)
			{
				PopXmlContext();
			}
		}

		private void OnNewLine(int pos)
		{
			ps.lineNo++;
			ps.lineStartPos = pos - 1;
		}

		private void OnEof()
		{
			curNode = nodes[0];
			curNode.Clear(XmlNodeType.None);
			curNode.SetLineInfo(ps.LineNo, ps.LinePos);
			parsingFunction = ParsingFunction.Eof;
			readState = ReadState.EndOfFile;
			reportedEncoding = null;
		}

		private string LookupNamespace(NodeData node)
		{
			string text = namespaceManager.LookupNamespace(node.prefix);
			if (text != null)
			{
				return text;
			}
			Throw("Xml_UnknownNs", node.prefix, node.LineNo, node.LinePos);
			return null;
		}

		private void AddNamespace(string prefix, string uri, NodeData attr)
		{
			if (uri == "http://www.w3.org/2000/xmlns/")
			{
				if (Ref.Equal(prefix, XmlNs))
				{
					Throw("Xml_XmlnsPrefix", attr.lineInfo2.lineNo, attr.lineInfo2.linePos);
				}
				else
				{
					Throw("Xml_NamespaceDeclXmlXmlns", prefix, attr.lineInfo2.lineNo, attr.lineInfo2.linePos);
				}
			}
			else if (uri == "http://www.w3.org/XML/1998/namespace" && !Ref.Equal(prefix, Xml) && !v1Compat)
			{
				Throw("Xml_NamespaceDeclXmlXmlns", prefix, attr.lineInfo2.lineNo, attr.lineInfo2.linePos);
			}
			if (uri.Length == 0 && prefix.Length > 0)
			{
				Throw("Xml_BadNamespaceDecl", attr.lineInfo.lineNo, attr.lineInfo.linePos);
			}
			try
			{
				namespaceManager.AddNamespace(prefix, uri);
			}
			catch (ArgumentException e)
			{
				ReThrow(e, attr.lineInfo.lineNo, attr.lineInfo.linePos);
			}
		}

		private void ResetAttributes()
		{
			if (fullAttrCleanup)
			{
				FullAttributeCleanup();
			}
			curAttrIndex = -1;
			attrCount = 0;
			attrHashtable = 0;
			attrDuplWalkCount = 0;
		}

		private void FullAttributeCleanup()
		{
			for (int i = index + 1; i < index + attrCount + 1; i++)
			{
				NodeData nodeData = nodes[i];
				nodeData.nextAttrValueChunk = null;
				nodeData.IsDefaultAttribute = false;
			}
			fullAttrCleanup = false;
		}

		private void PushXmlContext()
		{
			xmlContext = new XmlContext(xmlContext);
			curNode.xmlContextPushed = true;
		}

		private void PopXmlContext()
		{
			xmlContext = xmlContext.previousContext;
			curNode.xmlContextPushed = false;
		}

		private XmlNodeType GetWhitespaceType()
		{
			if (whitespaceHandling != WhitespaceHandling.None)
			{
				if (xmlContext.xmlSpace == XmlSpace.Preserve)
				{
					return XmlNodeType.SignificantWhitespace;
				}
				if (whitespaceHandling == WhitespaceHandling.All)
				{
					return XmlNodeType.Whitespace;
				}
			}
			return XmlNodeType.None;
		}

		private XmlNodeType GetTextNodeType(int orChars)
		{
			if (orChars > 32)
			{
				return XmlNodeType.Text;
			}
			return GetWhitespaceType();
		}

		private bool PushExternalEntity(SchemaEntity entity, int entityId)
		{
			if (!IsResolverNull)
			{
				Uri baseUri = ((entity.BaseURI.Length > 0) ? xmlResolver.ResolveUri(null, entity.BaseURI) : null);
				Uri uri = xmlResolver.ResolveUri(baseUri, entity.Url);
				Stream stream = null;
				try
				{
					stream = OpenStream(uri);
				}
				catch (Exception ex)
				{
					if (v1Compat)
					{
						throw;
					}
					Throw(new XmlException("Xml_ErrorOpeningExternalEntity", new string[2]
					{
						uri.ToString(),
						ex.Message
					}, ex, 0, 0));
				}
				if (stream == null)
				{
					Throw("Xml_CannotResolveEntity", entity.Name.Name);
				}
				PushParsingState();
				if (v1Compat)
				{
					InitStreamInput(uri, stream, null);
				}
				else
				{
					InitStreamInput(uri, stream, null);
				}
				ps.entity = entity;
				ps.entityId = entityId;
				entity.IsProcessed = true;
				int charPos = ps.charPos;
				if (v1Compat)
				{
					EatWhitespaces(null);
				}
				if (!ParseXmlDeclaration(isTextDecl: true))
				{
					ps.charPos = charPos;
				}
				return true;
			}
			Encoding encoding = ps.encoding;
			PushParsingState();
			InitStringInput(entity.Url, encoding, string.Empty);
			ps.entity = entity;
			ps.entityId = entityId;
			RegisterConsumedCharacters(0L, inEntityReference: true);
			return false;
		}

		private void PushInternalEntity(SchemaEntity entity, int entityId)
		{
			Encoding encoding = ps.encoding;
			PushParsingState();
			InitStringInput((entity.DeclaredURI != null) ? entity.DeclaredURI : string.Empty, encoding, entity.Text);
			ps.entity = entity;
			ps.entityId = entityId;
			ps.lineNo = entity.Line;
			ps.lineStartPos = -entity.Pos - 1;
			ps.eolNormalized = true;
			entity.IsProcessed = true;
			RegisterConsumedCharacters(entity.Text.Length, inEntityReference: true);
		}

		private void PopEntity()
		{
			if (ps.entity != null)
			{
				ps.entity.IsProcessed = false;
			}
			if (ps.stream != null)
			{
				ps.stream.Close();
			}
			PopParsingState();
			curNode.entityId = ps.entityId;
		}

		private void PushParsingState()
		{
			if (parsingStatesStack == null)
			{
				parsingStatesStack = new ParsingState[2];
			}
			else if (parsingStatesStackTop + 1 == parsingStatesStack.Length)
			{
				ParsingState[] destinationArray = new ParsingState[parsingStatesStack.Length * 2];
				Array.Copy(parsingStatesStack, 0, destinationArray, 0, parsingStatesStack.Length);
				parsingStatesStack = destinationArray;
			}
			parsingStatesStackTop++;
			ref ParsingState reference = ref parsingStatesStack[parsingStatesStackTop];
			reference = ps;
			ps.Clear();
		}

		private void PopParsingState()
		{
			ps.Close(closeInput: true);
			ps = parsingStatesStack[parsingStatesStackTop--];
		}

		private void InitIncrementalRead(IncrementalReadDecoder decoder)
		{
			ResetAttributes();
			decoder.Reset();
			incReadDecoder = decoder;
			incReadState = IncrementalReadState.Text;
			incReadDepth = 1;
			incReadLeftStartPos = ps.charPos;
			incReadLeftEndPos = ps.charPos;
			incReadLineInfo.Set(ps.LineNo, ps.LinePos);
			parsingFunction = ParsingFunction.InIncrementalRead;
		}

		private int IncrementalRead(Array array, int index, int count)
		{
			if (array == null)
			{
				throw new ArgumentNullException((incReadDecoder is IncrementalReadCharsDecoder) ? "buffer" : "array");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException((incReadDecoder is IncrementalReadCharsDecoder) ? "count" : "len");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException((incReadDecoder is IncrementalReadCharsDecoder) ? "index" : "offset");
			}
			if (array.Length - index < count)
			{
				throw new ArgumentException((incReadDecoder is IncrementalReadCharsDecoder) ? "count" : "len");
			}
			if (count == 0)
			{
				return 0;
			}
			curNode.lineInfo = incReadLineInfo;
			incReadDecoder.SetNextOutputBuffer(array, index, count);
			IncrementalRead();
			return incReadDecoder.DecodedCount;
		}

		private unsafe int IncrementalRead()
		{
			int num = 0;
			int num3;
			while (true)
			{
				int num2 = incReadLeftEndPos - incReadLeftStartPos;
				if (num2 > 0)
				{
					try
					{
						num3 = incReadDecoder.Decode(ps.chars, incReadLeftStartPos, num2);
					}
					catch (XmlException e)
					{
						ReThrow(e, incReadLineInfo.lineNo, incReadLineInfo.linePos);
						return 0;
					}
					if (num3 < num2)
					{
						incReadLeftStartPos += num3;
						incReadLineInfo.linePos += num3;
						return num3;
					}
					incReadLeftStartPos = 0;
					incReadLeftEndPos = 0;
					incReadLineInfo.linePos += num3;
					if (incReadDecoder.IsFull)
					{
						break;
					}
				}
				int outStartPos = 0;
				int outEndPos = 0;
				while (true)
				{
					switch (incReadState)
					{
					case IncrementalReadState.PI:
						if (ParsePIValue(out outStartPos, out outEndPos))
						{
							ps.charPos -= 2;
							incReadState = IncrementalReadState.Text;
						}
						break;
					case IncrementalReadState.Comment:
						if (ParseCDataOrComment(XmlNodeType.Comment, out outStartPos, out outEndPos))
						{
							ps.charPos -= 3;
							incReadState = IncrementalReadState.Text;
						}
						break;
					case IncrementalReadState.CDATA:
						if (ParseCDataOrComment(XmlNodeType.CDATA, out outStartPos, out outEndPos))
						{
							ps.charPos -= 3;
							incReadState = IncrementalReadState.Text;
						}
						break;
					case IncrementalReadState.EndElement:
						parsingFunction = ParsingFunction.PopElementContext;
						nextParsingFunction = ((index <= 0 && fragmentType == XmlNodeType.Document) ? ParsingFunction.DocumentContent : ParsingFunction.ElementContent);
						outerReader.Read();
						incReadState = IncrementalReadState.End;
						goto case IncrementalReadState.End;
					case IncrementalReadState.End:
						return num;
					case IncrementalReadState.ReadData:
						if (ReadData() == 0)
						{
							ThrowUnclosedElements();
						}
						incReadState = IncrementalReadState.Text;
						outStartPos = ps.charPos;
						outEndPos = outStartPos;
						goto default;
					default:
					{
						char[] chars = ps.chars;
						outStartPos = ps.charPos;
						outEndPos = outStartPos;
						while (true)
						{
							incReadLineInfo.Set(ps.LineNo, ps.LinePos);
							if (incReadState == IncrementalReadState.Attributes)
							{
								char c;
								while ((xmlCharType.charProperties[(int)(c = chars[outEndPos])] & 0x80u) != 0 && c != '/')
								{
									outEndPos++;
								}
							}
							else
							{
								char c;
								while ((xmlCharType.charProperties[(int)(c = chars[outEndPos])] & 0x80u) != 0)
								{
									outEndPos++;
								}
							}
							if (chars[outEndPos] == '&' || chars[outEndPos] == '\t')
							{
								outEndPos++;
								continue;
							}
							if (outEndPos - outStartPos > 0)
							{
								break;
							}
							switch (chars[outEndPos])
							{
							case '\n':
								outEndPos++;
								OnNewLine(outEndPos);
								continue;
							case '\r':
								if (chars[outEndPos + 1] == '\n')
								{
									outEndPos += 2;
								}
								else
								{
									if (outEndPos + 1 >= ps.charsUsed)
									{
										goto IL_06c7;
									}
									outEndPos++;
								}
								OnNewLine(outEndPos);
								continue;
							case '<':
								if (incReadState != 0)
								{
									outEndPos++;
									continue;
								}
								if (ps.charsUsed - outEndPos >= 2)
								{
									char c2 = chars[outEndPos + 1];
									if (c2 != '!')
									{
										switch (c2)
										{
										case '?':
											outEndPos += 2;
											incReadState = IncrementalReadState.PI;
											break;
										case '/':
										{
											int colonPos2;
											int num5 = ParseQName(isQName: true, 2, out colonPos2);
											if (XmlConvert.StrEqual(chars, ps.charPos + 2, num5 - ps.charPos - 2, curNode.GetNameWPrefix(nameTable)) && (ps.chars[num5] == '>' || xmlCharType.IsWhiteSpace(ps.chars[num5])))
											{
												if (--incReadDepth > 0)
												{
													outEndPos = num5 + 1;
													continue;
												}
												ps.charPos = num5;
												if (xmlCharType.IsWhiteSpace(ps.chars[num5]))
												{
													EatWhitespaces(null);
												}
												if (ps.chars[ps.charPos] != '>')
												{
													ThrowUnexpectedToken(">");
												}
												goto end_IL_00ba;
											}
											outEndPos = num5;
											continue;
										}
										default:
										{
											int colonPos;
											int num4 = ParseQName(isQName: true, 1, out colonPos);
											if (XmlConvert.StrEqual(ps.chars, ps.charPos + 1, num4 - ps.charPos - 1, curNode.localName) && (ps.chars[num4] == '>' || ps.chars[num4] == '/' || xmlCharType.IsWhiteSpace(ps.chars[num4])))
											{
												incReadDepth++;
												incReadState = IncrementalReadState.Attributes;
												outEndPos = num4;
												break;
											}
											outEndPos = num4;
											outStartPos = ps.charPos;
											chars = ps.chars;
											continue;
										}
										}
										break;
									}
									if (ps.charsUsed - outEndPos >= 4)
									{
										if (chars[outEndPos + 2] == '-' && chars[outEndPos + 3] == '-')
										{
											outEndPos += 4;
											incReadState = IncrementalReadState.Comment;
											break;
										}
										if (ps.charsUsed - outEndPos >= 9)
										{
											if (!XmlConvert.StrEqual(chars, outEndPos + 2, 7, "[CDATA["))
											{
												continue;
											}
											outEndPos += 9;
											incReadState = IncrementalReadState.CDATA;
											break;
										}
									}
								}
								goto IL_06c7;
							case '/':
								if (incReadState == IncrementalReadState.Attributes)
								{
									if (ps.charsUsed - outEndPos < 2)
									{
										goto IL_06c7;
									}
									if (chars[outEndPos + 1] == '>')
									{
										incReadState = IncrementalReadState.Text;
										incReadDepth--;
									}
								}
								outEndPos++;
								continue;
							case '>':
								if (incReadState == IncrementalReadState.Attributes)
								{
									incReadState = IncrementalReadState.Text;
								}
								outEndPos++;
								continue;
							case '"':
							case '\'':
								switch (incReadState)
								{
								case IncrementalReadState.AttributeValue:
									if (chars[outEndPos] == curNode.quoteChar)
									{
										incReadState = IncrementalReadState.Attributes;
									}
									break;
								case IncrementalReadState.Attributes:
									curNode.quoteChar = chars[outEndPos];
									incReadState = IncrementalReadState.AttributeValue;
									break;
								}
								outEndPos++;
								continue;
							default:
								{
									if (outEndPos != ps.charsUsed)
									{
										outEndPos++;
										continue;
									}
									goto IL_06c7;
								}
								IL_06c7:
								incReadState = IncrementalReadState.ReadData;
								break;
							}
							break;
						}
						ps.charPos = outEndPos;
						break;
					}
					}
					int num6 = outEndPos - outStartPos;
					if (num6 > 0)
					{
						int num7;
						try
						{
							num7 = incReadDecoder.Decode(ps.chars, outStartPos, num6);
						}
						catch (XmlException e2)
						{
							ReThrow(e2, incReadLineInfo.lineNo, incReadLineInfo.linePos);
							return 0;
						}
						num += num7;
						if (incReadDecoder.IsFull)
						{
							incReadLeftStartPos = outStartPos + num7;
							incReadLeftEndPos = outEndPos;
							incReadLineInfo.linePos += num7;
							return num;
						}
					}
					continue;
					end_IL_00ba:
					break;
				}
				ps.charPos++;
				incReadState = IncrementalReadState.EndElement;
			}
			return num3;
		}

		private void FinishIncrementalRead()
		{
			incReadDecoder = new IncrementalReadDummyDecoder();
			IncrementalRead();
			incReadDecoder = null;
		}

		private bool ParseFragmentAttribute()
		{
			if (curNode.type == XmlNodeType.None)
			{
				curNode.type = XmlNodeType.Attribute;
				curAttrIndex = 0;
				ParseAttributeValueSlow(ps.charPos, ' ', curNode);
			}
			else
			{
				parsingFunction = ParsingFunction.InReadAttributeValue;
			}
			if (ReadAttributeValue())
			{
				parsingFunction = ParsingFunction.FragmentAttribute;
				return true;
			}
			OnEof();
			return false;
		}

		private unsafe bool ParseAttributeValueChunk()
		{
			char[] chars = ps.chars;
			int charRefEndPos = ps.charPos;
			curNode = AddNode(index + attrCount + 1, index + 2);
			curNode.SetLineInfo(ps.LineNo, ps.LinePos);
			if (emptyEntityInAttributeResolved)
			{
				curNode.SetValueNode(XmlNodeType.Text, string.Empty);
				emptyEntityInAttributeResolved = false;
				return true;
			}
			while (true)
			{
				if ((xmlCharType.charProperties[(int)chars[charRefEndPos]] & 0x80u) != 0)
				{
					charRefEndPos++;
					continue;
				}
				switch (chars[charRefEndPos])
				{
				case '\r':
					charRefEndPos++;
					continue;
				case '\t':
				case '\n':
					if (normalize)
					{
						chars[charRefEndPos] = ' ';
					}
					charRefEndPos++;
					continue;
				case '"':
				case '\'':
				case '>':
					charRefEndPos++;
					continue;
				case '<':
					Throw(charRefEndPos, "Xml_BadAttributeChar", XmlException.BuildCharExceptionStr('<'));
					goto IL_02b3;
				case '&':
					if (charRefEndPos - ps.charPos > 0)
					{
						stringBuilder.Append(chars, ps.charPos, charRefEndPos - ps.charPos);
					}
					ps.charPos = charRefEndPos;
					switch (HandleEntityReference(isInAttributeValue: true, EntityExpandType.OnlyCharacter, out charRefEndPos))
					{
					case EntityType.CharacterDec:
					case EntityType.CharacterHex:
					case EntityType.CharacterNamed:
						chars = ps.chars;
						if (normalize && xmlCharType.IsWhiteSpace(chars[ps.charPos]) && charRefEndPos - ps.charPos == 1)
						{
							chars[ps.charPos] = ' ';
						}
						goto default;
					case EntityType.Unexpanded:
						break;
					default:
						chars = ps.chars;
						continue;
					}
					if (stringBuilder.Length == 0)
					{
						curNode.lineInfo.linePos++;
						ps.charPos++;
						curNode.SetNamedNode(XmlNodeType.EntityReference, ParseEntityName());
						return true;
					}
					break;
				default:
					{
						if (charRefEndPos != ps.charsUsed)
						{
							char c = chars[charRefEndPos];
							if (c >= '\ud800' && c <= '\udbff')
							{
								if (charRefEndPos + 1 == ps.charsUsed)
								{
									goto IL_02b3;
								}
								charRefEndPos++;
								if (chars[charRefEndPos] >= '\udc00' && chars[charRefEndPos] <= '\udfff')
								{
									charRefEndPos++;
									continue;
								}
							}
							ThrowInvalidChar(charRefEndPos, c);
						}
						goto IL_02b3;
					}
					IL_02b3:
					if (charRefEndPos - ps.charPos > 0)
					{
						stringBuilder.Append(chars, ps.charPos, charRefEndPos - ps.charPos);
						ps.charPos = charRefEndPos;
					}
					if (ReadData() == 0)
					{
						if (stringBuilder.Length > 0)
						{
							break;
						}
						if (HandleEntityEnd(checkEntityNesting: false))
						{
							SetupEndEntityNodeInAttribute();
							return true;
						}
					}
					charRefEndPos = ps.charPos;
					chars = ps.chars;
					continue;
				}
				break;
			}
			if (charRefEndPos - ps.charPos > 0)
			{
				stringBuilder.Append(chars, ps.charPos, charRefEndPos - ps.charPos);
				ps.charPos = charRefEndPos;
			}
			curNode.SetValueNode(XmlNodeType.Text, stringBuilder.ToString());
			stringBuilder.Length = 0;
			return true;
		}

		private void ParseXmlDeclarationFragment()
		{
			try
			{
				ParseXmlDeclaration(isTextDecl: false);
			}
			catch (XmlException ex)
			{
				ReThrow(ex, ex.LineNumber, ex.LinePosition - 6);
			}
		}

		private void ThrowUnexpectedToken(int pos, string expectedToken)
		{
			ThrowUnexpectedToken(pos, expectedToken, null);
		}

		private void ThrowUnexpectedToken(string expectedToken1)
		{
			ThrowUnexpectedToken(expectedToken1, null);
		}

		private void ThrowUnexpectedToken(int pos, string expectedToken1, string expectedToken2)
		{
			ps.charPos = pos;
			ThrowUnexpectedToken(expectedToken1, expectedToken2);
		}

		private void ThrowUnexpectedToken(string expectedToken1, string expectedToken2)
		{
			string text = ParseUnexpectedToken();
			if (expectedToken2 != null)
			{
				Throw("Xml_UnexpectedTokens2", new string[3] { text, expectedToken1, expectedToken2 });
			}
			else
			{
				Throw("Xml_UnexpectedTokenEx", new string[2] { text, expectedToken1 });
			}
		}

		private string ParseUnexpectedToken(int pos)
		{
			ps.charPos = pos;
			return ParseUnexpectedToken();
		}

		private string ParseUnexpectedToken()
		{
			if (xmlCharType.IsNCNameChar(ps.chars[ps.charPos]))
			{
				int i;
				for (i = ps.charPos + 1; xmlCharType.IsNCNameChar(ps.chars[i]); i++)
				{
				}
				return new string(ps.chars, ps.charPos, i - ps.charPos);
			}
			return new string(ps.chars, ps.charPos, 1);
		}

		private int GetIndexOfAttributeWithoutPrefix(string name)
		{
			name = nameTable.Get(name);
			if (name == null)
			{
				return -1;
			}
			for (int i = index + 1; i < index + attrCount + 1; i++)
			{
				if (Ref.Equal(nodes[i].localName, name) && nodes[i].prefix.Length == 0)
				{
					return i;
				}
			}
			return -1;
		}

		private int GetIndexOfAttributeWithPrefix(string name)
		{
			name = nameTable.Add(name);
			if (name == null)
			{
				return -1;
			}
			for (int i = index + 1; i < index + attrCount + 1; i++)
			{
				if (Ref.Equal(nodes[i].GetNameWPrefix(nameTable), name))
				{
					return i;
				}
			}
			return -1;
		}

		private Stream OpenStream(Uri uri)
		{
			return (Stream)xmlResolver.GetEntity(uri, null, typeof(Stream));
		}

		private bool ZeroEndingStream(int pos)
		{
			if (v1Compat && pos == ps.charsUsed - 1 && ps.chars[pos] == '\0' && ReadData() == 0 && ps.isStreamEof)
			{
				ps.charsUsed--;
				return true;
			}
			return false;
		}

		private void ParseDtdFromParserContext()
		{
			dtdParserProxy = new DtdParserProxy(fragmentParserContext.BaseURI, fragmentParserContext.DocTypeName, fragmentParserContext.PublicId, fragmentParserContext.SystemId, fragmentParserContext.InternalSubset, this);
			dtdParserProxy.Parse(saveInternalSubset: false);
			SchemaInfo dtdSchemaInfo = dtdParserProxy.DtdSchemaInfo;
			if ((validatingReaderCompatFlag || !v1Compat) && (dtdSchemaInfo.HasDefaultAttributes || dtdSchemaInfo.HasNonCDataAttributes))
			{
				addDefaultAttributesAndNormalize = true;
				qName = new XmlQualifiedName();
			}
		}

		private bool InitReadContentAsBinary()
		{
			if (parsingFunction == ParsingFunction.InReadValueChunk)
			{
				throw new InvalidOperationException(Res.GetString("Xml_MixingReadValueChunkWithBinary"));
			}
			if (parsingFunction == ParsingFunction.InIncrementalRead)
			{
				throw new InvalidOperationException(Res.GetString("Xml_MixingV1StreamingWithV2Binary"));
			}
			if (!XmlReader.IsTextualNode(curNode.type) && !MoveToNextContentNode(moveIfOnContentNode: false))
			{
				return false;
			}
			SetupReadContentAsBinaryState(ParsingFunction.InReadContentAsBinary);
			incReadLineInfo.Set(curNode.LineNo, curNode.LinePos);
			return true;
		}

		private bool InitReadElementContentAsBinary()
		{
			bool isEmptyElement = curNode.IsEmptyElement;
			outerReader.Read();
			if (isEmptyElement)
			{
				return false;
			}
			if (!MoveToNextContentNode(moveIfOnContentNode: false))
			{
				if (curNode.type != XmlNodeType.EndElement)
				{
					Throw("Xml_InvalidNodeType", curNode.type.ToString());
				}
				outerReader.Read();
				return false;
			}
			SetupReadContentAsBinaryState(ParsingFunction.InReadElementContentAsBinary);
			incReadLineInfo.Set(curNode.LineNo, curNode.LinePos);
			return true;
		}

		private bool MoveToNextContentNode(bool moveIfOnContentNode)
		{
			do
			{
				switch (curNode.type)
				{
				case XmlNodeType.Attribute:
					return !moveIfOnContentNode;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					if (!moveIfOnContentNode)
					{
						return true;
					}
					break;
				case XmlNodeType.EntityReference:
					outerReader.ResolveEntity();
					break;
				default:
					return false;
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.Comment:
				case XmlNodeType.EndEntity:
					break;
				}
				moveIfOnContentNode = false;
			}
			while (outerReader.Read());
			return false;
		}

		private void SetupReadContentAsBinaryState(ParsingFunction inReadBinaryFunction)
		{
			if (parsingFunction == ParsingFunction.PartialTextValue)
			{
				incReadState = IncrementalReadState.ReadContentAsBinary_OnPartialValue;
			}
			else
			{
				incReadState = IncrementalReadState.ReadContentAsBinary_OnCachedValue;
				nextNextParsingFunction = nextParsingFunction;
				nextParsingFunction = parsingFunction;
			}
			readValueOffset = 0;
			parsingFunction = inReadBinaryFunction;
		}

		private void SetupFromParserContext(XmlParserContext context, XmlReaderSettings settings)
		{
			XmlNameTable xmlNameTable = settings.NameTable;
			nameTableFromSettings = xmlNameTable != null;
			if (context.NamespaceManager != null)
			{
				if (xmlNameTable != null && xmlNameTable != context.NamespaceManager.NameTable)
				{
					throw new XmlException("Xml_NametableMismatch");
				}
				namespaceManager = context.NamespaceManager;
				xmlContext.defaultNamespace = namespaceManager.LookupNamespace(string.Empty);
				xmlNameTable = namespaceManager.NameTable;
			}
			else if (context.NameTable != null)
			{
				if (xmlNameTable != null && xmlNameTable != context.NameTable)
				{
					throw new XmlException("Xml_NametableMismatch");
				}
				xmlNameTable = context.NameTable;
			}
			else if (xmlNameTable == null)
			{
				xmlNameTable = new NameTable();
			}
			nameTable = xmlNameTable;
			if (namespaceManager == null)
			{
				namespaceManager = new XmlNamespaceManager(xmlNameTable);
			}
			xmlContext.xmlSpace = context.XmlSpace;
			xmlContext.xmlLang = context.XmlLang;
		}

		internal void ChangeCurrentNodeType(XmlNodeType newNodeType)
		{
			curNode.type = newNodeType;
		}

		internal XmlResolver GetResolver()
		{
			if (IsResolverNull)
			{
				return null;
			}
			return xmlResolver;
		}

		internal bool AddDefaultAttribute(SchemaAttDef attrDef, bool definedInDtd)
		{
			return AddDefaultAttribute(attrDef, definedInDtd, null);
		}

		private bool AddDefaultAttribute(SchemaAttDef attrDef, bool definedInDtd, NodeData[] nameSortedNodeData)
		{
			string name = attrDef.Name.Name;
			string text = attrDef.Prefix;
			string text2 = attrDef.Name.Namespace;
			if (definedInDtd)
			{
				if (text.Length > 0)
				{
					attrNeedNamespaceLookup = true;
				}
			}
			else
			{
				text2 = nameTable.Add(text2);
				if (text.Length == 0 && text2.Length > 0)
				{
					text = namespaceManager.LookupPrefix(text2);
					if (text == null)
					{
						text = string.Empty;
					}
				}
			}
			name = nameTable.Add(name);
			text = nameTable.Add(text);
			if (definedInDtd && nameSortedNodeData != null)
			{
				if (Array.BinarySearch(nameSortedNodeData, attrDef, SchemaAttDefToNodeDataComparer.Instance) >= 0)
				{
					return false;
				}
			}
			else
			{
				for (int i = index + 1; i < index + 1 + attrCount; i++)
				{
					if ((object)nodes[i].localName == name && ((object)nodes[i].prefix == text || ((object)nodes[i].ns == text2 && text2 != null)))
					{
						return false;
					}
				}
			}
			if (definedInDtd && DtdValidation && !attrDef.DefaultValueChecked)
			{
				attrDef.CheckDefaultValue(dtdParserProxy.DtdSchemaInfo, dtdParserProxy);
			}
			NodeData nodeData = AddAttribute(name, text, (text.Length > 0) ? null : name);
			if (!definedInDtd)
			{
				nodeData.ns = text2;
			}
			nodeData.SetValue(attrDef.DefaultValueExpanded);
			nodeData.IsDefaultAttribute = true;
			nodeData.schemaType = ((attrDef.SchemaType == null) ? ((object)attrDef.Datatype) : ((object)attrDef.SchemaType));
			nodeData.typedValue = attrDef.DefaultValueTyped;
			nodeData.lineInfo.Set(attrDef.LineNum, attrDef.LinePos);
			nodeData.lineInfo2.Set(attrDef.ValueLineNum, attrDef.ValueLinePos);
			if (nodeData.prefix.Length == 0)
			{
				if (Ref.Equal(nodeData.localName, XmlNs))
				{
					OnDefaultNamespaceDecl(nodeData);
					if (!definedInDtd && nodes[index].prefix.Length == 0)
					{
						nodes[index].ns = xmlContext.defaultNamespace;
					}
				}
			}
			else if (Ref.Equal(nodeData.prefix, XmlNs))
			{
				OnNamespaceDecl(nodeData);
				if (!definedInDtd)
				{
					string localName = nodeData.localName;
					for (int j = index; j < index + attrCount + 1; j++)
					{
						if (nodes[j].prefix.Equals(localName))
						{
							nodes[j].ns = namespaceManager.LookupNamespace(localName);
						}
					}
				}
			}
			else if (attrDef.Reserved != 0)
			{
				OnXmlReservedAttribute(nodeData);
			}
			fullAttrCleanup = true;
			return true;
		}

		private int ReadContentAsBinary(byte[] buffer, int index, int count)
		{
			if (incReadState == IncrementalReadState.ReadContentAsBinary_End)
			{
				return 0;
			}
			incReadDecoder.SetNextOutputBuffer(buffer, index, count);
			ParsingFunction inReadBinaryFunction;
			while (true)
			{
				int num = 0;
				try
				{
					num = curNode.CopyToBinary(incReadDecoder, readValueOffset);
				}
				catch (XmlException e)
				{
					curNode.AdjustLineInfo(readValueOffset, ps.eolNormalized, ref incReadLineInfo);
					ReThrow(e, incReadLineInfo.lineNo, incReadLineInfo.linePos);
				}
				readValueOffset += num;
				if (incReadDecoder.IsFull)
				{
					return incReadDecoder.DecodedCount;
				}
				if (incReadState == IncrementalReadState.ReadContentAsBinary_OnPartialValue)
				{
					curNode.SetValue(string.Empty);
					bool flag = false;
					int startPos = 0;
					int endPos = 0;
					while (!incReadDecoder.IsFull && !flag)
					{
						int outOrChars = 0;
						incReadLineInfo.Set(ps.LineNo, ps.LinePos);
						flag = ParseText(out startPos, out endPos, ref outOrChars);
						try
						{
							num = incReadDecoder.Decode(ps.chars, startPos, endPos - startPos);
						}
						catch (XmlException e2)
						{
							ReThrow(e2, incReadLineInfo.lineNo, incReadLineInfo.linePos);
						}
						startPos += num;
					}
					incReadState = (flag ? IncrementalReadState.ReadContentAsBinary_OnCachedValue : IncrementalReadState.ReadContentAsBinary_OnPartialValue);
					readValueOffset = 0;
					if (incReadDecoder.IsFull)
					{
						curNode.SetValue(ps.chars, startPos, endPos - startPos);
						AdjustLineInfo(ps.chars, startPos - num, startPos, ps.eolNormalized, ref incReadLineInfo);
						curNode.SetLineInfo(incReadLineInfo.lineNo, incReadLineInfo.linePos);
						return incReadDecoder.DecodedCount;
					}
				}
				inReadBinaryFunction = parsingFunction;
				parsingFunction = nextParsingFunction;
				nextParsingFunction = nextNextParsingFunction;
				if (!MoveToNextContentNode(moveIfOnContentNode: true))
				{
					break;
				}
				SetupReadContentAsBinaryState(inReadBinaryFunction);
				incReadLineInfo.Set(curNode.LineNo, curNode.LinePos);
			}
			SetupReadContentAsBinaryState(inReadBinaryFunction);
			incReadState = IncrementalReadState.ReadContentAsBinary_End;
			return incReadDecoder.DecodedCount;
		}

		private int ReadElementContentAsBinary(byte[] buffer, int index, int count)
		{
			if (count == 0)
			{
				return 0;
			}
			int num = ReadContentAsBinary(buffer, index, count);
			if (num > 0)
			{
				return num;
			}
			if (curNode.type != XmlNodeType.EndElement)
			{
				throw new XmlException("Xml_InvalidNodeType", curNode.type.ToString(), this);
			}
			parsingFunction = nextParsingFunction;
			nextParsingFunction = nextNextParsingFunction;
			outerReader.Read();
			return 0;
		}

		private void InitBase64Decoder()
		{
			if (base64Decoder == null)
			{
				base64Decoder = new Base64Decoder();
			}
			else
			{
				base64Decoder.Reset();
			}
			incReadDecoder = base64Decoder;
		}

		private void InitBinHexDecoder()
		{
			if (binHexDecoder == null)
			{
				binHexDecoder = new BinHexDecoder();
			}
			else
			{
				binHexDecoder.Reset();
			}
			incReadDecoder = binHexDecoder;
		}

		private bool UriEqual(Uri uri1, string uri1Str, string uri2Str, XmlResolver resolver)
		{
			if (uri1 == null || resolver == null)
			{
				return uri1Str == uri2Str;
			}
			Uri obj = resolver.ResolveUri(null, uri2Str);
			return uri1.Equals(obj);
		}

		private void RegisterConsumedCharacters(long characters, bool inEntityReference)
		{
			if (maxCharactersInDocument > 0)
			{
				long num = charactersInDocument + characters;
				if (num < charactersInDocument)
				{
					ThrowWithoutLineInfo("XmlSerializeErrorDetails", new string[2] { "MaxCharactersInDocument", "" });
				}
				else
				{
					charactersInDocument = num;
				}
				if (charactersInDocument > maxCharactersInDocument)
				{
					ThrowWithoutLineInfo("XmlSerializeErrorDetails", new string[2] { "MaxCharactersInDocument", "" });
				}
			}
			if (maxCharactersFromEntities > 0 && inEntityReference)
			{
				long num2 = charactersFromEntities + characters;
				if (num2 < charactersFromEntities)
				{
					ThrowWithoutLineInfo("XmlSerializeErrorDetails", new string[2] { "MaxCharactersFromEntities", "" });
				}
				else
				{
					charactersFromEntities = num2;
				}
				if (charactersFromEntities > maxCharactersFromEntities && XmlTextReaderSection.LimitCharactersFromEntities)
				{
					ThrowWithoutLineInfo("XmlSerializeErrorDetails", new string[2] { "MaxCharactersFromEntities", "" });
				}
			}
		}

		internal static void AdjustLineInfo(char[] chars, int startPos, int endPos, bool isNormalized, ref LineInfo lineInfo)
		{
			int num = -1;
			for (int i = startPos; i < endPos; i++)
			{
				switch (chars[i])
				{
				case '\n':
					lineInfo.lineNo++;
					num = i;
					break;
				case '\r':
					if (!isNormalized)
					{
						lineInfo.lineNo++;
						num = i;
						if (i + 1 < endPos && chars[i + 1] == '\n')
						{
							i++;
							num++;
						}
					}
					break;
				}
			}
			if (num >= 0)
			{
				lineInfo.linePos = endPos - num;
			}
		}
	}
	internal interface IDtdParserAdapter
	{
		XmlNameTable NameTable { get; }

		XmlNamespaceManager NamespaceManager { get; }

		bool DtdValidation { get; }

		bool Normalization { get; }

		bool Namespaces { get; }

		bool V1CompatibilityMode { get; }

		Uri BaseUri { get; }

		char[] ParsingBuffer { get; }

		int ParsingBufferLength { get; }

		int CurrentPosition { get; set; }

		int LineNo { get; }

		int LineStartPosition { get; }

		bool IsEof { get; }

		int EntityStackLength { get; }

		bool IsEntityEolNormalized { get; }

		ValidationEventHandler EventHandler { get; set; }

		int ReadData();

		void OnNewLine(int pos);

		void SendValidationEvent(XmlSeverityType severity, XmlSchemaException exception);

		int ParseNumericCharRef(BufferBuilder internalSubsetBuilder);

		int ParseNamedCharRef(bool expand, BufferBuilder internalSubsetBuilder);

		void ParsePI(BufferBuilder sb);

		void ParseComment(BufferBuilder sb);

		bool PushEntity(SchemaEntity entity, int entityId);

		bool PopEntity(out SchemaEntity oldEntity, out int newEntityId);

		bool PushExternalSubset(string systemId, string publicId);

		void PushInternalDtd(string baseUri, string internalDtd);

		void OnSystemId(string systemId, LineInfo keywordLineInfo, LineInfo systemLiteralLineInfo);

		void OnPublicId(string publicId, LineInfo keywordLineInfo, LineInfo publicLiteralLineInfo);

		void Throw(Exception e);
	}
	public enum Formatting
	{
		None,
		Indented
	}
	public class XmlTextWriter : XmlWriter
	{
		private enum NamespaceState
		{
			Uninitialized,
			NotDeclaredButInScope,
			DeclaredButNotWrittenOut,
			DeclaredAndWrittenOut
		}

		private struct TagInfo
		{
			internal string name;

			internal string prefix;

			internal string defaultNs;

			internal NamespaceState defaultNsState;

			internal XmlSpace xmlSpace;

			internal string xmlLang;

			internal int prevNsTop;

			internal int prefixCount;

			internal bool mixed;

			internal void Init(int nsTop)
			{
				name = null;
				defaultNs = string.Empty;
				defaultNsState = NamespaceState.Uninitialized;
				xmlSpace = XmlSpace.None;
				xmlLang = null;
				prevNsTop = nsTop;
				prefixCount = 0;
				mixed = false;
			}
		}

		private struct Namespace
		{
			internal string prefix;

			internal string ns;

			internal bool declared;

			internal int prevNsIndex;

			internal void Set(string prefix, string ns, bool declared)
			{
				this.prefix = prefix;
				this.ns = ns;
				this.declared = declared;
				prevNsIndex = -1;
			}
		}

		private enum SpecialAttr
		{
			None,
			XmlSpace,
			XmlLang,
			XmlNs
		}

		private enum State
		{
			Start,
			Prolog,
			PostDTD,
			Element,
			Attribute,
			Content,
			AttrOnly,
			Epilog,
			Error,
			Closed
		}

		private enum Token
		{
			PI,
			Doctype,
			Comment,
			CData,
			StartElement,
			EndElement,
			LongEndElement,
			StartAttribute,
			EndAttribute,
			Content,
			Base64,
			RawData,
			Whitespace,
			Empty
		}

		private const int NamespaceStackInitialSize = 8;

		private const int MaxNamespacesWalkCount = 16;

		private TextWriter textWriter;

		private XmlTextEncoder xmlEncoder;

		private Encoding encoding;

		private Formatting formatting;

		private bool indented;

		private int indentation;

		private char indentChar;

		private TagInfo[] stack;

		private int top;

		private State[] stateTable;

		private State currentState;

		private Token lastToken;

		private XmlTextWriterBase64Encoder base64Encoder;

		private char quoteChar;

		private char curQuoteChar;

		private bool namespaces;

		private SpecialAttr specialAttr;

		private string prefixForXmlNs;

		private bool flush;

		private Namespace[] nsStack;

		private int nsTop;

		private Dictionary<string, int> nsHashtable;

		private bool useNsHashtable;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		private static string[] stateName = new string[10] { "Start", "Prolog", "PostDTD", "Element", "Attribute", "Content", "AttrOnly", "Epilog", "Error", "Closed" };

		private static string[] tokenName = new string[14]
		{
			"PI", "Doctype", "Comment", "CData", "StartElement", "EndElement", "LongEndElement", "StartAttribute", "EndAttribute", "Content",
			"Base64", "RawData", "Whitespace", "Empty"
		};

		private static readonly State[] stateTableDefault = new State[104]
		{
			State.Prolog,
			State.Prolog,
			State.PostDTD,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Epilog,
			State.PostDTD,
			State.PostDTD,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Prolog,
			State.Prolog,
			State.PostDTD,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Epilog,
			State.Content,
			State.Content,
			State.Error,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Epilog,
			State.Element,
			State.Element,
			State.Element,
			State.Element,
			State.Element,
			State.Element,
			State.Error,
			State.Element,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.AttrOnly,
			State.Error,
			State.Error,
			State.Attribute,
			State.Attribute,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Element,
			State.Error,
			State.Epilog,
			State.Error,
			State.Content,
			State.Content,
			State.Error,
			State.Content,
			State.Attribute,
			State.Content,
			State.Attribute,
			State.Epilog,
			State.Content,
			State.Content,
			State.Error,
			State.Content,
			State.Attribute,
			State.Content,
			State.Attribute,
			State.Epilog,
			State.Prolog,
			State.Prolog,
			State.PostDTD,
			State.Content,
			State.Attribute,
			State.Content,
			State.Attribute,
			State.Epilog,
			State.Prolog,
			State.Prolog,
			State.PostDTD,
			State.Content,
			State.Attribute,
			State.Content,
			State.Attribute,
			State.Epilog
		};

		private static readonly State[] stateTableDocument = new State[104]
		{
			State.Error,
			State.Prolog,
			State.PostDTD,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Epilog,
			State.Error,
			State.PostDTD,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Prolog,
			State.PostDTD,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Epilog,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Element,
			State.Element,
			State.Element,
			State.Element,
			State.Element,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Attribute,
			State.Attribute,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Element,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Attribute,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Attribute,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Prolog,
			State.PostDTD,
			State.Content,
			State.Attribute,
			State.Content,
			State.Error,
			State.Epilog,
			State.Error,
			State.Prolog,
			State.PostDTD,
			State.Content,
			State.Attribute,
			State.Content,
			State.Error,
			State.Epilog
		};

		public Stream BaseStream
		{
			get
			{
				if (textWriter is StreamWriter streamWriter)
				{
					return streamWriter.BaseStream;
				}
				return null;
			}
		}

		public bool Namespaces
		{
			get
			{
				return namespaces;
			}
			set
			{
				if (currentState != 0)
				{
					throw new InvalidOperationException(Res.GetString("Xml_NotInWriteState"));
				}
				namespaces = value;
			}
		}

		public Formatting Formatting
		{
			get
			{
				return formatting;
			}
			set
			{
				formatting = value;
				indented = value == Formatting.Indented;
			}
		}

		public int Indentation
		{
			get
			{
				return indentation;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(Res.GetString("Xml_InvalidIndentation"));
				}
				indentation = value;
			}
		}

		public char IndentChar
		{
			get
			{
				return indentChar;
			}
			set
			{
				indentChar = value;
			}
		}

		public char QuoteChar
		{
			get
			{
				return quoteChar;
			}
			set
			{
				if (value != '"' && value != '\'')
				{
					throw new ArgumentException(Res.GetString("Xml_InvalidQuote"));
				}
				quoteChar = value;
				xmlEncoder.QuoteChar = value;
			}
		}

		public override WriteState WriteState
		{
			get
			{
				switch (currentState)
				{
				case State.Start:
					return WriteState.Start;
				case State.Prolog:
				case State.PostDTD:
					return WriteState.Prolog;
				case State.Element:
					return WriteState.Element;
				case State.Attribute:
				case State.AttrOnly:
					return WriteState.Attribute;
				case State.Content:
				case State.Epilog:
					return WriteState.Content;
				case State.Error:
					return WriteState.Error;
				case State.Closed:
					return WriteState.Closed;
				default:
					return WriteState.Error;
				}
			}
		}

		public override XmlSpace XmlSpace
		{
			get
			{
				for (int num = top; num > 0; num--)
				{
					XmlSpace xmlSpace = stack[num].xmlSpace;
					if (xmlSpace != 0)
					{
						return xmlSpace;
					}
				}
				return XmlSpace.None;
			}
		}

		public override string XmlLang
		{
			get
			{
				for (int num = top; num > 0; num--)
				{
					string xmlLang = stack[num].xmlLang;
					if (xmlLang != null)
					{
						return xmlLang;
					}
				}
				return null;
			}
		}

		internal XmlTextWriter()
		{
			namespaces = true;
			formatting = Formatting.None;
			indentation = 2;
			indentChar = ' ';
			nsStack = new Namespace[8];
			nsTop = -1;
			stack = new TagInfo[10];
			top = 0;
			stack[top].Init(-1);
			quoteChar = '"';
			stateTable = stateTableDefault;
			currentState = State.Start;
			lastToken = Token.Empty;
		}

		public XmlTextWriter(Stream w, Encoding encoding)
			: this()
		{
			this.encoding = encoding;
			if (encoding != null)
			{
				textWriter = new StreamWriter(w, encoding);
			}
			else
			{
				textWriter = new StreamWriter(w);
			}
			xmlEncoder = new XmlTextEncoder(textWriter);
			xmlEncoder.QuoteChar = quoteChar;
		}

		public XmlTextWriter(string filename, Encoding encoding)
			: this(new FileStream(filename, FileMode.Create, FileAccess.Write, FileShare.Read), encoding)
		{
		}

		public XmlTextWriter(TextWriter w)
			: this()
		{
			textWriter = w;
			encoding = w.Encoding;
			xmlEncoder = new XmlTextEncoder(w);
			xmlEncoder.QuoteChar = quoteChar;
		}

		public override void WriteStartDocument()
		{
			StartDocument(-1);
		}

		public override void WriteStartDocument(bool standalone)
		{
			StartDocument(standalone ? 1 : 0);
		}

		public override void WriteEndDocument()
		{
			try
			{
				AutoCompleteAll();
				if (currentState != State.Epilog)
				{
					throw new ArgumentException(Res.GetString("Xml_NoRoot"));
				}
				stateTable = stateTableDefault;
				currentState = State.Start;
				lastToken = Token.Empty;
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			try
			{
				ValidateName(name, NCName: false);
				AutoComplete(Token.Doctype);
				textWriter.Write("<!DOCTYPE ");
				textWriter.Write(name);
				if (pubid != null)
				{
					textWriter.Write(" PUBLIC " + quoteChar);
					textWriter.Write(pubid);
					textWriter.Write(quoteChar + " " + quoteChar);
					textWriter.Write(sysid);
					textWriter.Write(quoteChar);
				}
				else if (sysid != null)
				{
					textWriter.Write(" SYSTEM " + quoteChar);
					textWriter.Write(sysid);
					textWriter.Write(quoteChar);
				}
				if (subset != null)
				{
					textWriter.Write("[");
					textWriter.Write(subset);
					textWriter.Write("]");
				}
				textWriter.Write('>');
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			try
			{
				AutoComplete(Token.StartElement);
				PushStack();
				textWriter.Write('<');
				if (namespaces)
				{
					stack[top].defaultNs = stack[top - 1].defaultNs;
					if (stack[top - 1].defaultNsState != 0)
					{
						stack[top].defaultNsState = NamespaceState.NotDeclaredButInScope;
					}
					stack[top].mixed = stack[top - 1].mixed;
					if (ns == null)
					{
						if (prefix != null && prefix.Length != 0 && LookupNamespace(prefix) == -1)
						{
							throw new ArgumentException(Res.GetString("Xml_UndefPrefix"));
						}
					}
					else if (prefix == null)
					{
						string text = FindPrefix(ns);
						if (text != null)
						{
							prefix = text;
						}
						else
						{
							PushNamespace(null, ns, declared: false);
						}
					}
					else if (prefix.Length == 0)
					{
						PushNamespace(null, ns, declared: false);
					}
					else
					{
						if (ns.Length == 0)
						{
							prefix = null;
						}
						VerifyPrefixXml(prefix, ns);
						PushNamespace(prefix, ns, declared: false);
					}
					stack[top].prefix = null;
					if (prefix != null && prefix.Length != 0)
					{
						stack[top].prefix = prefix;
						textWriter.Write(prefix);
						textWriter.Write(':');
					}
				}
				else if ((ns != null && ns.Length != 0) || (prefix != null && prefix.Length != 0))
				{
					throw new ArgumentException(Res.GetString("Xml_NoNamespaces"));
				}
				stack[top].name = localName;
				textWriter.Write(localName);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteEndElement()
		{
			InternalWriteEndElement(longFormat: false);
		}

		public override void WriteFullEndElement()
		{
			InternalWriteEndElement(longFormat: true);
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			try
			{
				AutoComplete(Token.StartAttribute);
				specialAttr = SpecialAttr.None;
				if (namespaces)
				{
					if (prefix != null && prefix.Length == 0)
					{
						prefix = null;
					}
					if (ns == "http://www.w3.org/2000/xmlns/" && prefix == null && localName != "xmlns")
					{
						prefix = "xmlns";
					}
					if (prefix == "xml")
					{
						if (localName == "lang")
						{
							specialAttr = SpecialAttr.XmlLang;
						}
						else if (localName == "space")
						{
							specialAttr = SpecialAttr.XmlSpace;
						}
					}
					else if (prefix == "xmlns")
					{
						if ("http://www.w3.org/2000/xmlns/" != ns && ns != null)
						{
							throw new ArgumentException(Res.GetString("Xml_XmlnsBelongsToReservedNs"));
						}
						if (localName == null || localName.Length == 0)
						{
							localName = prefix;
							prefix = null;
							prefixForXmlNs = null;
						}
						else
						{
							prefixForXmlNs = localName;
						}
						specialAttr = SpecialAttr.XmlNs;
					}
					else if (prefix == null && localName == "xmlns")
					{
						if ("http://www.w3.org/2000/xmlns/" != ns && ns != null)
						{
							throw new ArgumentException(Res.GetString("Xml_XmlnsBelongsToReservedNs"));
						}
						specialAttr = SpecialAttr.XmlNs;
						prefixForXmlNs = null;
					}
					else if (ns == null)
					{
						if (prefix != null && LookupNamespace(prefix) == -1)
						{
							throw new ArgumentException(Res.GetString("Xml_UndefPrefix"));
						}
					}
					else if (ns.Length == 0)
					{
						prefix = string.Empty;
					}
					else
					{
						VerifyPrefixXml(prefix, ns);
						if (prefix != null && LookupNamespaceInCurrentScope(prefix) != -1)
						{
							prefix = null;
						}
						string text = FindPrefix(ns);
						if (text != null && (prefix == null || prefix == text))
						{
							prefix = text;
						}
						else
						{
							if (prefix == null)
							{
								prefix = GeneratePrefix();
							}
							PushNamespace(prefix, ns, declared: false);
						}
					}
					if (prefix != null && prefix.Length != 0)
					{
						textWriter.Write(prefix);
						textWriter.Write(':');
					}
				}
				else
				{
					if ((ns != null && ns.Length != 0) || (prefix != null && prefix.Length != 0))
					{
						throw new ArgumentException(Res.GetString("Xml_NoNamespaces"));
					}
					if (localName == "xml:lang")
					{
						specialAttr = SpecialAttr.XmlLang;
					}
					else if (localName == "xml:space")
					{
						specialAttr = SpecialAttr.XmlSpace;
					}
				}
				xmlEncoder.StartAttribute(specialAttr != SpecialAttr.None);
				textWriter.Write(localName);
				textWriter.Write('=');
				if (curQuoteChar != quoteChar)
				{
					curQuoteChar = quoteChar;
					xmlEncoder.QuoteChar = quoteChar;
				}
				textWriter.Write(curQuoteChar);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteEndAttribute()
		{
			try
			{
				AutoComplete(Token.EndAttribute);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteCData(string text)
		{
			try
			{
				AutoComplete(Token.CData);
				if (text != null && text.IndexOf("]]>", StringComparison.Ordinal) >= 0)
				{
					throw new ArgumentException(Res.GetString("Xml_InvalidCDataChars"));
				}
				textWriter.Write("<![CDATA[");
				if (text != null)
				{
					xmlEncoder.WriteRawWithSurrogateChecking(text);
				}
				textWriter.Write("]]>");
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteComment(string text)
		{
			try
			{
				if (text != null && (text.IndexOf("--", StringComparison.Ordinal) >= 0 || (text.Length != 0 && text[text.Length - 1] == '-')))
				{
					throw new ArgumentException(Res.GetString("Xml_InvalidCommentChars"));
				}
				AutoComplete(Token.Comment);
				textWriter.Write("<!--");
				if (text != null)
				{
					xmlEncoder.WriteRawWithSurrogateChecking(text);
				}
				textWriter.Write("-->");
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			try
			{
				if (text != null && text.IndexOf("?>", StringComparison.Ordinal) >= 0)
				{
					throw new ArgumentException(Res.GetString("Xml_InvalidPiChars"));
				}
				if (string.Compare(name, "xml", StringComparison.OrdinalIgnoreCase) == 0 && stateTable == stateTableDocument)
				{
					throw new ArgumentException(Res.GetString("Xml_DupXmlDecl"));
				}
				AutoComplete(Token.PI);
				InternalWriteProcessingInstruction(name, text);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteEntityRef(string name)
		{
			try
			{
				ValidateName(name, NCName: false);
				AutoComplete(Token.Content);
				xmlEncoder.WriteEntityRef(name);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteCharEntity(char ch)
		{
			try
			{
				AutoComplete(Token.Content);
				xmlEncoder.WriteCharEntity(ch);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteWhitespace(string ws)
		{
			try
			{
				if (ws == null || ws.Length == 0)
				{
					throw new ArgumentException(Res.GetString("Xml_NonWhitespace"));
				}
				if (!xmlCharType.IsOnlyWhitespace(ws))
				{
					throw new ArgumentException(Res.GetString("Xml_NonWhitespace"));
				}
				AutoComplete(Token.Whitespace);
				xmlEncoder.Write(ws);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteString(string text)
		{
			try
			{
				if (text != null && text.Length != 0)
				{
					AutoComplete(Token.Content);
					xmlEncoder.Write(text);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			try
			{
				AutoComplete(Token.Content);
				xmlEncoder.WriteSurrogateCharEntity(lowChar, highChar);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			try
			{
				AutoComplete(Token.Content);
				xmlEncoder.Write(buffer, index, count);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			try
			{
				AutoComplete(Token.RawData);
				xmlEncoder.WriteRaw(buffer, index, count);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteRaw(string data)
		{
			try
			{
				AutoComplete(Token.RawData);
				xmlEncoder.WriteRawWithSurrogateChecking(data);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteBase64(byte[] buffer, int index, int count)
		{
			try
			{
				if (!flush)
				{
					AutoComplete(Token.Base64);
				}
				flush = true;
				if (base64Encoder == null)
				{
					base64Encoder = new XmlTextWriterBase64Encoder(xmlEncoder);
				}
				base64Encoder.Encode(buffer, index, count);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteBinHex(byte[] buffer, int index, int count)
		{
			try
			{
				AutoComplete(Token.Content);
				BinHexEncoder.Encode(buffer, index, count, this);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void Close()
		{
			try
			{
				AutoCompleteAll();
			}
			catch
			{
			}
			finally
			{
				currentState = State.Closed;
				textWriter.Close();
			}
		}

		public override void Flush()
		{
			textWriter.Flush();
		}

		public override void WriteName(string name)
		{
			try
			{
				AutoComplete(Token.Content);
				InternalWriteName(name, NCName: false);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteQualifiedName(string localName, string ns)
		{
			try
			{
				AutoComplete(Token.Content);
				if (namespaces)
				{
					if (ns != null && ns.Length != 0 && ns != stack[top].defaultNs)
					{
						string text = FindPrefix(ns);
						if (text == null)
						{
							if (currentState != State.Attribute)
							{
								throw new ArgumentException(Res.GetString("Xml_UndefNamespace", ns));
							}
							text = GeneratePrefix();
							PushNamespace(text, ns, declared: false);
						}
						if (text.Length != 0)
						{
							InternalWriteName(text, NCName: true);
							textWriter.Write(':');
						}
					}
				}
				else if (ns != null && ns.Length != 0)
				{
					throw new ArgumentException(Res.GetString("Xml_NoNamespaces"));
				}
				InternalWriteName(localName, NCName: true);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override string LookupPrefix(string ns)
		{
			if (ns == null || ns.Length == 0)
			{
				throw new ArgumentException(Res.GetString("Xml_EmptyName"));
			}
			string text = FindPrefix(ns);
			if (text == null && ns == stack[top].defaultNs)
			{
				text = string.Empty;
			}
			return text;
		}

		public override void WriteNmToken(string name)
		{
			try
			{
				AutoComplete(Token.Content);
				if (name == null || name.Length == 0)
				{
					throw new ArgumentException(Res.GetString("Xml_EmptyName"));
				}
				if (!xmlCharType.IsNmToken(name))
				{
					throw new ArgumentException(Res.GetString("Xml_InvalidNameChars", name));
				}
				textWriter.Write(name);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		private void StartDocument(int standalone)
		{
			try
			{
				if (currentState != 0)
				{
					throw new InvalidOperationException(Res.GetString("Xml_NotTheFirst"));
				}
				stateTable = stateTableDocument;
				currentState = State.Prolog;
				StringBuilder stringBuilder = new StringBuilder(128);
				stringBuilder.Append("version=" + quoteChar + "1.0" + quoteChar);
				if (encoding != null)
				{
					stringBuilder.Append(" encoding=");
					stringBuilder.Append(quoteChar);
					stringBuilder.Append(encoding.WebName);
					stringBuilder.Append(quoteChar);
				}
				if (standalone >= 0)
				{
					stringBuilder.Append(" standalone=");
					stringBuilder.Append(quoteChar);
					stringBuilder.Append((standalone == 0) ? "no" : "yes");
					stringBuilder.Append(quoteChar);
				}
				InternalWriteProcessingInstruction("xml", stringBuilder.ToString());
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		private void AutoComplete(Token token)
		{
			if (currentState == State.Closed)
			{
				throw new InvalidOperationException(Res.GetString("Xml_Closed"));
			}
			if (currentState == State.Error)
			{
				throw new InvalidOperationException(Res.GetString("Xml_WrongToken", tokenName[(int)token], stateName[8]));
			}
			State state = stateTable[(int)((int)token * 8 + currentState)];
			if (state == State.Error)
			{
				throw new InvalidOperationException(Res.GetString("Xml_WrongToken", tokenName[(int)token], stateName[(int)currentState]));
			}
			switch (token)
			{
			case Token.Doctype:
				if (indented && currentState != 0)
				{
					Indent(beforeEndElement: false);
				}
				break;
			case Token.PI:
			case Token.Comment:
			case Token.CData:
			case Token.StartElement:
				if (currentState == State.Attribute)
				{
					WriteEndAttributeQuote();
					WriteEndStartTag(empty: false);
				}
				else if (currentState == State.Element)
				{
					WriteEndStartTag(empty: false);
				}
				if (token == Token.CData)
				{
					stack[top].mixed = true;
				}
				else if (indented && currentState != 0)
				{
					Indent(beforeEndElement: false);
				}
				break;
			case Token.EndElement:
			case Token.LongEndElement:
				if (flush)
				{
					FlushEncoders();
				}
				if (currentState == State.Attribute)
				{
					WriteEndAttributeQuote();
				}
				if (currentState == State.Content)
				{
					token = Token.LongEndElement;
				}
				else
				{
					WriteEndStartTag(token == Token.EndElement);
				}
				if (stateTableDocument == stateTable && top == 1)
				{
					state = State.Epilog;
				}
				break;
			case Token.StartAttribute:
				if (flush)
				{
					FlushEncoders();
				}
				if (currentState == State.Attribute)
				{
					WriteEndAttributeQuote();
					textWriter.Write(' ');
				}
				else if (currentState == State.Element)
				{
					textWriter.Write(' ');
				}
				break;
			case Token.EndAttribute:
				if (flush)
				{
					FlushEncoders();
				}
				WriteEndAttributeQuote();
				break;
			case Token.Content:
			case Token.RawData:
			case Token.Whitespace:
				if (flush)
				{
					FlushEncoders();
				}
				goto case Token.Base64;
			case Token.Base64:
				if (currentState == State.Element && lastToken != Token.Content)
				{
					WriteEndStartTag(empty: false);
				}
				if (state == State.Content)
				{
					stack[top].mixed = true;
				}
				break;
			default:
				throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
			}
			currentState = state;
			lastToken = token;
		}

		private void AutoCompleteAll()
		{
			if (flush)
			{
				FlushEncoders();
			}
			while (top > 0)
			{
				WriteEndElement();
			}
		}

		private void InternalWriteEndElement(bool longFormat)
		{
			try
			{
				if (top <= 0)
				{
					throw new InvalidOperationException(Res.GetString("Xml_NoStartTag"));
				}
				AutoComplete(longFormat ? Token.LongEndElement : Token.EndElement);
				if (lastToken == Token.LongEndElement)
				{
					if (indented)
					{
						Indent(beforeEndElement: true);
					}
					textWriter.Write('<');
					textWriter.Write('/');
					if (namespaces && stack[top].prefix != null)
					{
						textWriter.Write(stack[top].prefix);
						textWriter.Write(':');
					}
					textWriter.Write(stack[top].name);
					textWriter.Write('>');
				}
				int prevNsTop = stack[top].prevNsTop;
				if (useNsHashtable && prevNsTop < nsTop)
				{
					PopNamespaces(prevNsTop + 1, nsTop);
				}
				nsTop = prevNsTop;
				top--;
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		private void WriteEndStartTag(bool empty)
		{
			xmlEncoder.StartAttribute(cacheAttrValue: false);
			for (int num = nsTop; num > stack[top].prevNsTop; num--)
			{
				if (!nsStack[num].declared)
				{
					textWriter.Write(" xmlns");
					textWriter.Write(':');
					textWriter.Write(nsStack[num].prefix);
					textWriter.Write('=');
					textWriter.Write(quoteChar);
					xmlEncoder.Write(nsStack[num].ns);
					textWriter.Write(quoteChar);
				}
			}
			if (stack[top].defaultNs != stack[top - 1].defaultNs && stack[top].defaultNsState == NamespaceState.DeclaredButNotWrittenOut)
			{
				textWriter.Write(" xmlns");
				textWriter.Write('=');
				textWriter.Write(quoteChar);
				xmlEncoder.Write(stack[top].defaultNs);
				textWriter.Write(quoteChar);
				stack[top].defaultNsState = NamespaceState.DeclaredAndWrittenOut;
			}
			xmlEncoder.EndAttribute();
			if (empty)
			{
				textWriter.Write(" /");
			}
			textWriter.Write('>');
		}

		private void WriteEndAttributeQuote()
		{
			if (specialAttr != 0)
			{
				HandleSpecialAttribute();
			}
			xmlEncoder.EndAttribute();
			textWriter.Write(curQuoteChar);
		}

		private void Indent(bool beforeEndElement)
		{
			if (top == 0)
			{
				textWriter.WriteLine();
			}
			else if (!stack[top].mixed)
			{
				textWriter.WriteLine();
				int num = (beforeEndElement ? (top - 1) : top);
				for (num *= indentation; num > 0; num--)
				{
					textWriter.Write(indentChar);
				}
			}
		}

		private void PushNamespace(string prefix, string ns, bool declared)
		{
			if ("http://www.w3.org/2000/xmlns/" == ns)
			{
				throw new ArgumentException(Res.GetString("Xml_CanNotBindToReservedNamespace"));
			}
			if (prefix == null)
			{
				switch (stack[top].defaultNsState)
				{
				default:
					return;
				case NamespaceState.Uninitialized:
				case NamespaceState.NotDeclaredButInScope:
					stack[top].defaultNs = ns;
					break;
				case NamespaceState.DeclaredButNotWrittenOut:
					break;
				}
				stack[top].defaultNsState = (declared ? NamespaceState.DeclaredAndWrittenOut : NamespaceState.DeclaredButNotWrittenOut);
				return;
			}
			if (prefix.Length != 0 && ns.Length == 0)
			{
				throw new ArgumentException(Res.GetString("Xml_PrefixForEmptyNs"));
			}
			int num = LookupNamespace(prefix);
			if (num != -1 && nsStack[num].ns == ns)
			{
				if (declared)
				{
					nsStack[num].declared = true;
				}
				return;
			}
			if (declared && num != -1 && num > stack[top].prevNsTop)
			{
				nsStack[num].declared = true;
			}
			AddNamespace(prefix, ns, declared);
		}

		private void AddNamespace(string prefix, string ns, bool declared)
		{
			int num = ++nsTop;
			if (num == nsStack.Length)
			{
				Namespace[] destinationArray = new Namespace[num * 2];
				Array.Copy(nsStack, destinationArray, num);
				nsStack = destinationArray;
			}
			nsStack[num].Set(prefix, ns, declared);
			if (useNsHashtable)
			{
				AddToNamespaceHashtable(num);
			}
			else if (num == 16)
			{
				nsHashtable = new Dictionary<string, int>(new SecureStringHasher());
				for (int i = 0; i <= num; i++)
				{
					AddToNamespaceHashtable(i);
				}
				useNsHashtable = true;
			}
		}

		private void AddToNamespaceHashtable(int namespaceIndex)
		{
			string prefix = nsStack[namespaceIndex].prefix;
			if (nsHashtable.TryGetValue(prefix, out var value))
			{
				nsStack[namespaceIndex].prevNsIndex = value;
			}
			nsHashtable[prefix] = namespaceIndex;
		}

		private void PopNamespaces(int indexFrom, int indexTo)
		{
			for (int num = indexTo; num >= indexFrom; num--)
			{
				if (nsStack[num].prevNsIndex == -1)
				{
					nsHashtable.Remove(nsStack[num].prefix);
				}
				else
				{
					nsHashtable[nsStack[num].prefix] = nsStack[num].prevNsIndex;
				}
			}
		}

		private string GeneratePrefix()
		{
			return string.Concat(str3: (stack[top].prefixCount++ + 1).ToString("d", CultureInfo.InvariantCulture), str0: "d", str1: top.ToString("d", CultureInfo.InvariantCulture), str2: "p");
		}

		private void InternalWriteProcessingInstruction(string name, string text)
		{
			textWriter.Write("<?");
			ValidateName(name, NCName: false);
			textWriter.Write(name);
			textWriter.Write(' ');
			if (text != null)
			{
				xmlEncoder.WriteRawWithSurrogateChecking(text);
			}
			textWriter.Write("?>");
		}

		private int LookupNamespace(string prefix)
		{
			if (useNsHashtable)
			{
				if (nsHashtable.TryGetValue(prefix, out var value))
				{
					return value;
				}
			}
			else
			{
				for (int num = nsTop; num >= 0; num--)
				{
					if (nsStack[num].prefix == prefix)
					{
						return num;
					}
				}
			}
			return -1;
		}

		private int LookupNamespaceInCurrentScope(string prefix)
		{
			if (useNsHashtable)
			{
				if (nsHashtable.TryGetValue(prefix, out var value) && value > stack[top].prevNsTop)
				{
					return value;
				}
			}
			else
			{
				for (int num = nsTop; num > stack[top].prevNsTop; num--)
				{
					if (nsStack[num].prefix == prefix)
					{
						return num;
					}
				}
			}
			return -1;
		}

		private string FindPrefix(string ns)
		{
			for (int num = nsTop; num >= 0; num--)
			{
				if (nsStack[num].ns == ns && LookupNamespace(nsStack[num].prefix) == num)
				{
					return nsStack[num].prefix;
				}
			}
			return null;
		}

		private void InternalWriteName(string name, bool NCName)
		{
			ValidateName(name, NCName);
			textWriter.Write(name);
		}

		private unsafe void ValidateName(string name, bool NCName)
		{
			if (name == null || name.Length == 0)
			{
				throw new ArgumentException(Res.GetString("Xml_EmptyName"));
			}
			int length = name.Length;
			int i = 0;
			int num = -1;
			if (namespaces)
			{
				if ((xmlCharType.charProperties[(int)name[i]] & 4u) != 0)
				{
					while (true)
					{
						for (i++; i < length && (xmlCharType.charProperties[(int)name[i]] & 8u) != 0; i++)
						{
						}
						if (i == length)
						{
							return;
						}
						if (name[i] != ':' || NCName || num != -1 || i + 1 >= length)
						{
							break;
						}
						num = i;
					}
				}
			}
			else if ((xmlCharType.charProperties[(int)name[0]] & 4u) != 0 || name[0] == ':')
			{
				for (i++; i < length && ((xmlCharType.charProperties[(int)name[i]] & 8u) != 0 || name[i] == ':'); i++)
				{
				}
				if (i == length)
				{
					return;
				}
			}
			throw new ArgumentException(Res.GetString("Xml_InvalidNameChars", name));
		}

		private void HandleSpecialAttribute()
		{
			string attributeValue = xmlEncoder.AttributeValue;
			switch (specialAttr)
			{
			case SpecialAttr.XmlLang:
				stack[top].xmlLang = attributeValue;
				break;
			case SpecialAttr.XmlSpace:
				attributeValue = XmlConvert.TrimString(attributeValue);
				if (attributeValue == "default")
				{
					stack[top].xmlSpace = XmlSpace.Default;
					break;
				}
				if (attributeValue == "preserve")
				{
					stack[top].xmlSpace = XmlSpace.Preserve;
					break;
				}
				throw new ArgumentException(Res.GetString("Xml_InvalidXmlSpace", attributeValue));
			case SpecialAttr.XmlNs:
				VerifyPrefixXml(prefixForXmlNs, attributeValue);
				PushNamespace(prefixForXmlNs, attributeValue, declared: true);
				break;
			}
		}

		private void VerifyPrefixXml(string prefix, string ns)
		{
			if (prefix != null && prefix.Length == 3 && (prefix[0] == 'x' || prefix[0] == 'X') && (prefix[1] == 'm' || prefix[1] == 'M') && (prefix[2] == 'l' || prefix[2] == 'L') && "http://www.w3.org/XML/1998/namespace" != ns)
			{
				throw new ArgumentException(Res.GetString("Xml_InvalidPrefix"));
			}
		}

		private void PushStack()
		{
			if (top == stack.Length - 1)
			{
				TagInfo[] destinationArray = new TagInfo[stack.Length + 10];
				if (top > 0)
				{
					Array.Copy(stack, destinationArray, top + 1);
				}
				stack = destinationArray;
			}
			top++;
			stack[top].Init(nsTop);
		}

		private void FlushEncoders()
		{
			if (base64Encoder != null)
			{
				base64Encoder.Flush();
			}
			flush = false;
		}
	}
	internal class XmlUtf8RawTextWriterIndent : XmlUtf8RawTextWriter
	{
		protected int indentLevel;

		protected bool newLineOnAttributes;

		protected string indentChars;

		protected bool mixedContent;

		private BitStack mixedContentStack;

		protected ConformanceLevel conformanceLevel;

		public override XmlWriterSettings Settings
		{
			get
			{
				XmlWriterSettings settings = base.Settings;
				settings.ReadOnly = false;
				settings.Indent = true;
				settings.IndentChars = indentChars;
				settings.NewLineOnAttributes = newLineOnAttributes;
				settings.ReadOnly = true;
				return settings;
			}
		}

		public XmlUtf8RawTextWriterIndent(Stream stream, Encoding encoding, XmlWriterSettings settings, bool closeOutput)
			: base(stream, encoding, settings, closeOutput)
		{
			Init(settings);
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			if (!mixedContent && textPos != bufPos)
			{
				WriteIndent();
			}
			base.WriteDocType(name, pubid, sysid, subset);
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			if (!mixedContent && textPos != bufPos)
			{
				WriteIndent();
			}
			indentLevel++;
			mixedContentStack.PushBit(mixedContent);
			base.WriteStartElement(prefix, localName, ns);
		}

		internal override void StartElementContent()
		{
			if (indentLevel == 1 && conformanceLevel == ConformanceLevel.Document)
			{
				mixedContent = false;
			}
			else
			{
				mixedContent = mixedContentStack.PeekBit();
			}
			base.StartElementContent();
		}

		internal override void OnRootElement(ConformanceLevel currentConformanceLevel)
		{
			conformanceLevel = currentConformanceLevel;
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			indentLevel--;
			if (!mixedContent && contentPos != bufPos && textPos != bufPos)
			{
				WriteIndent();
			}
			mixedContent = mixedContentStack.PopBit();
			base.WriteEndElement(prefix, localName, ns);
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			indentLevel--;
			if (!mixedContent && contentPos != bufPos && textPos != bufPos)
			{
				WriteIndent();
			}
			mixedContent = mixedContentStack.PopBit();
			base.WriteFullEndElement(prefix, localName, ns);
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (newLineOnAttributes)
			{
				WriteIndent();
			}
			base.WriteStartAttribute(prefix, localName, ns);
		}

		public override void WriteCData(string text)
		{
			mixedContent = true;
			base.WriteCData(text);
		}

		public override void WriteComment(string text)
		{
			if (!mixedContent && textPos != bufPos)
			{
				WriteIndent();
			}
			base.WriteComment(text);
		}

		public override void WriteProcessingInstruction(string target, string text)
		{
			if (!mixedContent && textPos != bufPos)
			{
				WriteIndent();
			}
			base.WriteProcessingInstruction(target, text);
		}

		public override void WriteEntityRef(string name)
		{
			mixedContent = true;
			base.WriteEntityRef(name);
		}

		public override void WriteCharEntity(char ch)
		{
			mixedContent = true;
			base.WriteCharEntity(ch);
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			mixedContent = true;
			base.WriteSurrogateCharEntity(lowChar, highChar);
		}

		public override void WriteWhitespace(string ws)
		{
			mixedContent = true;
			base.WriteWhitespace(ws);
		}

		public override void WriteString(string text)
		{
			mixedContent = true;
			base.WriteString(text);
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			mixedContent = true;
			base.WriteChars(buffer, index, count);
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			mixedContent = true;
			base.WriteRaw(buffer, index, count);
		}

		public override void WriteRaw(string data)
		{
			mixedContent = true;
			base.WriteRaw(data);
		}

		public override void WriteBase64(byte[] buffer, int index, int count)
		{
			mixedContent = true;
			base.WriteBase64(buffer, index, count);
		}

		private void Init(XmlWriterSettings settings)
		{
			indentLevel = 0;
			indentChars = settings.IndentChars;
			newLineOnAttributes = settings.NewLineOnAttributes;
			mixedContentStack = new BitStack();
			if (!checkCharacters)
			{
				return;
			}
			if (newLineOnAttributes)
			{
				ValidateContentChars(indentChars, "IndentChars", allowOnlyWhitespace: true);
				ValidateContentChars(newLineChars, "NewLineChars", allowOnlyWhitespace: true);
				return;
			}
			ValidateContentChars(indentChars, "IndentChars", allowOnlyWhitespace: false);
			if (newLineHandling != 0)
			{
				ValidateContentChars(newLineChars, "NewLineChars", allowOnlyWhitespace: false);
			}
		}

		private void WriteIndent()
		{
			RawText(newLineChars);
			for (int num = indentLevel; num > 0; num--)
			{
				RawText(indentChars);
			}
		}
	}
	[Obsolete("Use XmlReader created by XmlReader.Create() method using appropriate XmlReaderSettings instead. http://go.microsoft.com/fwlink/?linkid=14202")]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public class XmlValidatingReader : XmlReader, IXmlLineInfo, IXmlNamespaceResolver
	{
		private XmlValidatingReaderImpl impl;

		public override XmlReaderSettings Settings => null;

		public override XmlNodeType NodeType => impl.NodeType;

		public override string Name => impl.Name;

		public override string LocalName => impl.LocalName;

		public override string NamespaceURI => impl.NamespaceURI;

		public override string Prefix => impl.Prefix;

		public override bool HasValue => impl.HasValue;

		public override string Value => impl.Value;

		public override int Depth => impl.Depth;

		public override string BaseURI => impl.BaseURI;

		public override bool IsEmptyElement => impl.IsEmptyElement;

		public override bool IsDefault => impl.IsDefault;

		public override char QuoteChar => impl.QuoteChar;

		public override XmlSpace XmlSpace => impl.XmlSpace;

		public override string XmlLang => impl.XmlLang;

		public override int AttributeCount => impl.AttributeCount;

		public override bool EOF => impl.EOF;

		public override ReadState ReadState => impl.ReadState;

		public override XmlNameTable NameTable => impl.NameTable;

		public override bool CanResolveEntity => true;

		public override bool CanReadBinaryContent => true;

		public int LineNumber => impl.LineNumber;

		public int LinePosition => impl.LinePosition;

		public object SchemaType => impl.SchemaType;

		public XmlReader Reader => impl.Reader;

		public ValidationType ValidationType
		{
			get
			{
				return impl.ValidationType;
			}
			set
			{
				impl.ValidationType = value;
			}
		}

		public XmlSchemaCollection Schemas => impl.Schemas;

		public EntityHandling EntityHandling
		{
			get
			{
				return impl.EntityHandling;
			}
			set
			{
				impl.EntityHandling = value;
			}
		}

		public XmlResolver XmlResolver
		{
			set
			{
				impl.XmlResolver = value;
			}
		}

		public bool Namespaces
		{
			get
			{
				return impl.Namespaces;
			}
			set
			{
				impl.Namespaces = value;
			}
		}

		public Encoding Encoding => impl.Encoding;

		internal XmlValidatingReaderImpl Impl => impl;

		public event ValidationEventHandler ValidationEventHandler
		{
			add
			{
				impl.ValidationEventHandler += value;
			}
			remove
			{
				impl.ValidationEventHandler -= value;
			}
		}

		public XmlValidatingReader(XmlReader reader)
		{
			impl = new XmlValidatingReaderImpl(reader);
			impl.OuterReader = this;
		}

		public XmlValidatingReader(string xmlFragment, XmlNodeType fragType, XmlParserContext context)
		{
			impl = new XmlValidatingReaderImpl(xmlFragment, fragType, context);
			impl.OuterReader = this;
		}

		public XmlValidatingReader(Stream xmlFragment, XmlNodeType fragType, XmlParserContext context)
		{
			impl = new XmlValidatingReaderImpl(xmlFragment, fragType, context);
			impl.OuterReader = this;
		}

		public override string GetAttribute(string name)
		{
			return impl.GetAttribute(name);
		}

		public override string GetAttribute(string localName, string namespaceURI)
		{
			return impl.GetAttribute(localName, namespaceURI);
		}

		public override string GetAttribute(int i)
		{
			return impl.GetAttribute(i);
		}

		public override bool MoveToAttribute(string name)
		{
			return impl.MoveToAttribute(name);
		}

		public override bool MoveToAttribute(string localName, string namespaceURI)
		{
			return impl.MoveToAttribute(localName, namespaceURI);
		}

		public override void MoveToAttribute(int i)
		{
			impl.MoveToAttribute(i);
		}

		public override bool MoveToFirstAttribute()
		{
			return impl.MoveToFirstAttribute();
		}

		public override bool MoveToNextAttribute()
		{
			return impl.MoveToNextAttribute();
		}

		public override bool MoveToElement()
		{
			return impl.MoveToElement();
		}

		public override bool ReadAttributeValue()
		{
			return impl.ReadAttributeValue();
		}

		public override bool Read()
		{
			return impl.Read();
		}

		public override void Close()
		{
			impl.Close();
		}

		public override string LookupNamespace(string prefix)
		{
			string text = impl.LookupNamespace(prefix);
			if (text != null && text.Length == 0)
			{
				text = null;
			}
			return text;
		}

		public override void ResolveEntity()
		{
			impl.ResolveEntity();
		}

		public override int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			return impl.ReadContentAsBase64(buffer, index, count);
		}

		public override int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			return impl.ReadElementContentAsBase64(buffer, index, count);
		}

		public override int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			return impl.ReadContentAsBinHex(buffer, index, count);
		}

		public override int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			return impl.ReadElementContentAsBinHex(buffer, index, count);
		}

		public override string ReadString()
		{
			impl.MoveOffEntityReference();
			return base.ReadString();
		}

		public bool HasLineInfo()
		{
			return true;
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return impl.GetNamespacesInScope(scope);
		}

		string IXmlNamespaceResolver.LookupNamespace(string prefix)
		{
			return impl.LookupNamespace(prefix);
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			return impl.LookupPrefix(namespaceName);
		}

		public object ReadTypedValue()
		{
			return impl.ReadTypedValue();
		}
	}
	internal sealed class XmlValidatingReaderImpl : XmlReader, IXmlLineInfo, IXmlNamespaceResolver
	{
		private enum ParsingFunction
		{
			Read,
			Init,
			ParseDtdFromContext,
			ResolveEntityInternally,
			InReadBinaryContent,
			ReaderClosed,
			Error,
			None
		}

		private XmlReader coreReader;

		private XmlTextReaderImpl coreReaderImpl;

		private IXmlNamespaceResolver coreReaderNSResolver;

		private ValidationType validationType;

		private BaseValidator validator;

		private XmlSchemaCollection schemaCollection;

		private bool processIdentityConstraints;

		private ParsingFunction parsingFunction = ParsingFunction.Init;

		private ValidationEventHandler internalEventHandler;

		private ValidationEventHandler eventHandler;

		private XmlParserContext parserContext;

		private ReadContentAsBinaryHelper readBinaryHelper;

		private XmlReader outerReader;

		public override XmlReaderSettings Settings
		{
			get
			{
				XmlReaderSettings xmlReaderSettings = ((!coreReaderImpl.V1Compat) ? coreReader.Settings : null);
				xmlReaderSettings = ((xmlReaderSettings == null) ? new XmlReaderSettings() : xmlReaderSettings.Clone());
				xmlReaderSettings.ValidationType = ValidationType.DTD;
				if (!processIdentityConstraints)
				{
					xmlReaderSettings.ValidationFlags &= ~XmlSchemaValidationFlags.ProcessIdentityConstraints;
				}
				xmlReaderSettings.ReadOnly = true;
				return xmlReaderSettings;
			}
		}

		public override XmlNodeType NodeType => coreReader.NodeType;

		public override string Name => coreReader.Name;

		public override string LocalName => coreReader.LocalName;

		public override string NamespaceURI => coreReader.NamespaceURI;

		public override string Prefix => coreReader.Prefix;

		public override bool HasValue => coreReader.HasValue;

		public override string Value => coreReader.Value;

		public override int Depth => coreReader.Depth;

		public override string BaseURI => coreReader.BaseURI;

		public override bool IsEmptyElement => coreReader.IsEmptyElement;

		public override bool IsDefault => coreReader.IsDefault;

		public override char QuoteChar => coreReader.QuoteChar;

		public override XmlSpace XmlSpace => coreReader.XmlSpace;

		public override string XmlLang => coreReader.XmlLang;

		public override ReadState ReadState
		{
			get
			{
				if (parsingFunction != ParsingFunction.Init)
				{
					return coreReader.ReadState;
				}
				return ReadState.Initial;
			}
		}

		public override bool EOF => coreReader.EOF;

		public override XmlNameTable NameTable => coreReader.NameTable;

		internal Encoding Encoding => coreReaderImpl.Encoding;

		public override int AttributeCount => coreReader.AttributeCount;

		public override bool CanReadBinaryContent => true;

		public override bool CanResolveEntity => true;

		internal XmlReader OuterReader
		{
			get
			{
				return outerReader;
			}
			set
			{
				outerReader = value;
			}
		}

		public int LineNumber => ((IXmlLineInfo)coreReader).LineNumber;

		public int LinePosition => ((IXmlLineInfo)coreReader).LinePosition;

		internal object SchemaType
		{
			get
			{
				if (validationType != 0)
				{
					if (coreReaderImpl.InternalSchemaType is XmlSchemaType xmlSchemaType && xmlSchemaType.QualifiedName.Namespace == "http://www.w3.org/2001/XMLSchema")
					{
						return xmlSchemaType.Datatype;
					}
					return coreReaderImpl.InternalSchemaType;
				}
				return null;
			}
		}

		internal XmlReader Reader => coreReader;

		internal XmlTextReaderImpl ReaderImpl => coreReaderImpl;

		internal ValidationType ValidationType
		{
			get
			{
				return validationType;
			}
			set
			{
				if (ReadState != 0)
				{
					throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
				}
				validationType = value;
				SetupValidation(value);
			}
		}

		internal XmlSchemaCollection Schemas => schemaCollection;

		internal EntityHandling EntityHandling
		{
			get
			{
				return coreReaderImpl.EntityHandling;
			}
			set
			{
				coreReaderImpl.EntityHandling = value;
			}
		}

		internal XmlResolver XmlResolver
		{
			set
			{
				coreReaderImpl.XmlResolver = value;
				validator.XmlResolver = value;
				schemaCollection.XmlResolver = value;
			}
		}

		internal bool Namespaces
		{
			get
			{
				return coreReaderImpl.Namespaces;
			}
			set
			{
				coreReaderImpl.Namespaces = value;
			}
		}

		internal BaseValidator Validator
		{
			get
			{
				return validator;
			}
			set
			{
				validator = value;
			}
		}

		internal override XmlNamespaceManager NamespaceManager => coreReaderImpl.NamespaceManager;

		internal bool StandAlone => coreReaderImpl.StandAlone;

		internal object SchemaTypeObject
		{
			set
			{
				coreReaderImpl.InternalSchemaType = value;
			}
		}

		internal object TypedValueObject
		{
			get
			{
				return coreReaderImpl.InternalTypedValue;
			}
			set
			{
				coreReaderImpl.InternalTypedValue = value;
			}
		}

		internal bool Normalization => coreReaderImpl.Normalization;

		internal event ValidationEventHandler ValidationEventHandler
		{
			add
			{
				eventHandler = (ValidationEventHandler)Delegate.Remove(eventHandler, internalEventHandler);
				eventHandler = (ValidationEventHandler)Delegate.Combine(eventHandler, value);
				if (eventHandler == null)
				{
					eventHandler = internalEventHandler;
				}
				UpdateHandlers();
			}
			remove
			{
				eventHandler = (ValidationEventHandler)Delegate.Remove(eventHandler, value);
				if (eventHandler == null)
				{
					eventHandler = internalEventHandler;
				}
				UpdateHandlers();
			}
		}

		internal XmlValidatingReaderImpl(XmlReader reader)
		{
			outerReader = this;
			coreReader = reader;
			coreReaderNSResolver = reader as IXmlNamespaceResolver;
			coreReaderImpl = reader as XmlTextReaderImpl;
			if (coreReaderImpl == null && reader is XmlTextReader xmlTextReader)
			{
				coreReaderImpl = xmlTextReader.Impl;
			}
			if (coreReaderImpl == null)
			{
				throw new ArgumentException(Res.GetString("Arg_ExpectingXmlTextReader"), "reader");
			}
			coreReaderImpl.EntityHandling = EntityHandling.ExpandEntities;
			coreReaderImpl.XmlValidatingReaderCompatibilityMode = true;
			processIdentityConstraints = true;
			schemaCollection = new XmlSchemaCollection(coreReader.NameTable);
			schemaCollection.XmlResolver = GetResolver();
			internalEventHandler = InternalValidationCallback;
			eventHandler = internalEventHandler;
			coreReaderImpl.ValidationEventHandler = internalEventHandler;
			validationType = ValidationType.Auto;
			SetupValidation(ValidationType.Auto);
		}

		internal XmlValidatingReaderImpl(string xmlFragment, XmlNodeType fragType, XmlParserContext context)
			: this(new XmlTextReader(xmlFragment, fragType, context))
		{
			if (coreReader.BaseURI.Length > 0)
			{
				validator.BaseUri = GetResolver().ResolveUri(null, coreReader.BaseURI);
			}
			if (context != null)
			{
				parsingFunction = ParsingFunction.ParseDtdFromContext;
				parserContext = context;
			}
		}

		internal XmlValidatingReaderImpl(Stream xmlFragment, XmlNodeType fragType, XmlParserContext context)
			: this(new XmlTextReader(xmlFragment, fragType, context))
		{
			if (coreReader.BaseURI.Length > 0)
			{
				validator.BaseUri = GetResolver().ResolveUri(null, coreReader.BaseURI);
			}
			if (context != null)
			{
				parsingFunction = ParsingFunction.ParseDtdFromContext;
				parserContext = context;
			}
		}

		internal XmlValidatingReaderImpl(XmlReader reader, ValidationEventHandler settingsEventHandler, bool processIdentityConstraints)
		{
			outerReader = this;
			coreReader = reader;
			coreReaderImpl = reader as XmlTextReaderImpl;
			if (coreReaderImpl == null && reader is XmlTextReader xmlTextReader)
			{
				coreReaderImpl = xmlTextReader.Impl;
			}
			if (coreReaderImpl == null)
			{
				throw new ArgumentException(Res.GetString("Arg_ExpectingXmlTextReader"), "reader");
			}
			coreReaderImpl.XmlValidatingReaderCompatibilityMode = true;
			coreReaderNSResolver = reader as IXmlNamespaceResolver;
			this.processIdentityConstraints = processIdentityConstraints;
			schemaCollection = new XmlSchemaCollection(coreReader.NameTable);
			schemaCollection.XmlResolver = GetResolver();
			if (settingsEventHandler == null)
			{
				internalEventHandler = InternalValidationCallback;
				eventHandler = internalEventHandler;
				coreReaderImpl.ValidationEventHandler = internalEventHandler;
			}
			else
			{
				eventHandler = settingsEventHandler;
				coreReaderImpl.ValidationEventHandler = settingsEventHandler;
			}
			validationType = ValidationType.DTD;
			SetupValidation(ValidationType.DTD);
		}

		public override string GetAttribute(string name)
		{
			return coreReader.GetAttribute(name);
		}

		public override string GetAttribute(string localName, string namespaceURI)
		{
			return coreReader.GetAttribute(localName, namespaceURI);
		}

		public override string GetAttribute(int i)
		{
			return coreReader.GetAttribute(i);
		}

		public override bool MoveToAttribute(string name)
		{
			if (!coreReader.MoveToAttribute(name))
			{
				return false;
			}
			parsingFunction = ParsingFunction.Read;
			return true;
		}

		public override bool MoveToAttribute(string localName, string namespaceURI)
		{
			if (!coreReader.MoveToAttribute(localName, namespaceURI))
			{
				return false;
			}
			parsingFunction = ParsingFunction.Read;
			return true;
		}

		public override void MoveToAttribute(int i)
		{
			coreReader.MoveToAttribute(i);
			parsingFunction = ParsingFunction.Read;
		}

		public override bool MoveToFirstAttribute()
		{
			if (!coreReader.MoveToFirstAttribute())
			{
				return false;
			}
			parsingFunction = ParsingFunction.Read;
			return true;
		}

		public override bool MoveToNextAttribute()
		{
			if (!coreReader.MoveToNextAttribute())
			{
				return false;
			}
			parsingFunction = ParsingFunction.Read;
			return true;
		}

		public override bool MoveToElement()
		{
			if (!coreReader.MoveToElement())
			{
				return false;
			}
			parsingFunction = ParsingFunction.Read;
			return true;
		}

		public override bool Read()
		{
			switch (parsingFunction)
			{
			case ParsingFunction.Read:
				if (coreReader.Read())
				{
					ProcessCoreReaderEvent();
					return true;
				}
				validator.CompleteValidation();
				return false;
			case ParsingFunction.ParseDtdFromContext:
				parsingFunction = ParsingFunction.Read;
				ParseDtdFromParserContext();
				goto case ParsingFunction.Read;
			case ParsingFunction.ReaderClosed:
			case ParsingFunction.Error:
				return false;
			case ParsingFunction.Init:
				parsingFunction = ParsingFunction.Read;
				if (coreReader.ReadState == ReadState.Interactive)
				{
					ProcessCoreReaderEvent();
					return true;
				}
				goto case ParsingFunction.Read;
			case ParsingFunction.ResolveEntityInternally:
				parsingFunction = ParsingFunction.Read;
				ResolveEntityInternally();
				goto case ParsingFunction.Read;
			case ParsingFunction.InReadBinaryContent:
				parsingFunction = ParsingFunction.Read;
				readBinaryHelper.Finish();
				goto case ParsingFunction.Read;
			default:
				return false;
			}
		}

		public override void Close()
		{
			coreReader.Close();
			parsingFunction = ParsingFunction.ReaderClosed;
		}

		public override string LookupNamespace(string prefix)
		{
			return coreReaderImpl.LookupNamespace(prefix);
		}

		public override bool ReadAttributeValue()
		{
			if (parsingFunction == ParsingFunction.InReadBinaryContent)
			{
				parsingFunction = ParsingFunction.Read;
				readBinaryHelper.Finish();
			}
			if (!coreReader.ReadAttributeValue())
			{
				return false;
			}
			parsingFunction = ParsingFunction.Read;
			return true;
		}

		public override int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (parsingFunction != ParsingFunction.InReadBinaryContent)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, outerReader);
			}
			parsingFunction = ParsingFunction.Read;
			int result = readBinaryHelper.ReadContentAsBase64(buffer, index, count);
			parsingFunction = ParsingFunction.InReadBinaryContent;
			return result;
		}

		public override int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (parsingFunction != ParsingFunction.InReadBinaryContent)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, outerReader);
			}
			parsingFunction = ParsingFunction.Read;
			int result = readBinaryHelper.ReadContentAsBinHex(buffer, index, count);
			parsingFunction = ParsingFunction.InReadBinaryContent;
			return result;
		}

		public override int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (parsingFunction != ParsingFunction.InReadBinaryContent)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, outerReader);
			}
			parsingFunction = ParsingFunction.Read;
			int result = readBinaryHelper.ReadElementContentAsBase64(buffer, index, count);
			parsingFunction = ParsingFunction.InReadBinaryContent;
			return result;
		}

		public override int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (parsingFunction != ParsingFunction.InReadBinaryContent)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, outerReader);
			}
			parsingFunction = ParsingFunction.Read;
			int result = readBinaryHelper.ReadElementContentAsBinHex(buffer, index, count);
			parsingFunction = ParsingFunction.InReadBinaryContent;
			return result;
		}

		public override void ResolveEntity()
		{
			if (parsingFunction == ParsingFunction.ResolveEntityInternally)
			{
				parsingFunction = ParsingFunction.Read;
			}
			coreReader.ResolveEntity();
		}

		internal void MoveOffEntityReference()
		{
			if (outerReader.NodeType == XmlNodeType.EntityReference && parsingFunction != ParsingFunction.ResolveEntityInternally && !outerReader.Read())
			{
				throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
			}
		}

		public override string ReadString()
		{
			MoveOffEntityReference();
			return base.ReadString();
		}

		public bool HasLineInfo()
		{
			return true;
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return GetNamespacesInScope(scope);
		}

		string IXmlNamespaceResolver.LookupNamespace(string prefix)
		{
			return LookupNamespace(prefix);
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			return LookupPrefix(namespaceName);
		}

		internal IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return coreReaderNSResolver.GetNamespacesInScope(scope);
		}

		internal string LookupPrefix(string namespaceName)
		{
			return coreReaderNSResolver.LookupPrefix(namespaceName);
		}

		public object ReadTypedValue()
		{
			if (validationType == ValidationType.None)
			{
				return null;
			}
			switch (outerReader.NodeType)
			{
			case XmlNodeType.Attribute:
				return coreReaderImpl.InternalTypedValue;
			case XmlNodeType.Element:
			{
				if (SchemaType == null)
				{
					return null;
				}
				XmlSchemaDatatype xmlSchemaDatatype = ((SchemaType is XmlSchemaDatatype) ? ((XmlSchemaDatatype)SchemaType) : ((XmlSchemaType)SchemaType).Datatype);
				if (xmlSchemaDatatype != null)
				{
					if (!outerReader.IsEmptyElement)
					{
						XmlNodeType nodeType;
						do
						{
							if (!outerReader.Read())
							{
								throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
							}
							nodeType = outerReader.NodeType;
						}
						while (nodeType == XmlNodeType.CDATA || nodeType == XmlNodeType.Text || nodeType == XmlNodeType.Whitespace || nodeType == XmlNodeType.SignificantWhitespace || nodeType == XmlNodeType.Comment || nodeType == XmlNodeType.ProcessingInstruction);
						if (outerReader.NodeType != XmlNodeType.EndElement)
						{
							throw new XmlException("Xml_InvalidNodeType", outerReader.NodeType.ToString());
						}
					}
					return coreReaderImpl.InternalTypedValue;
				}
				return null;
			}
			case XmlNodeType.EndElement:
				return null;
			default:
				if (coreReaderImpl.V1Compat)
				{
					return null;
				}
				return Value;
			}
		}

		private void ParseDtdFromParserContext()
		{
			if (parserContext.DocTypeName != null && parserContext.DocTypeName.Length != 0)
			{
				coreReaderImpl.DtdSchemaInfo = DtdParser.Parse(coreReaderImpl, parserContext.BaseURI, parserContext.DocTypeName, parserContext.PublicId, parserContext.SystemId, parserContext.InternalSubset);
				ValidateDtd();
			}
		}

		private void ValidateDtd()
		{
			SchemaInfo dtdSchemaInfo = coreReaderImpl.DtdSchemaInfo;
			if (dtdSchemaInfo != null)
			{
				switch (validationType)
				{
				default:
					return;
				case ValidationType.Auto:
					SetupValidation(ValidationType.DTD);
					break;
				case ValidationType.None:
				case ValidationType.DTD:
					break;
				}
				validator.SchemaInfo = dtdSchemaInfo;
			}
		}

		private void ResolveEntityInternally()
		{
			int depth = coreReader.Depth;
			outerReader.ResolveEntity();
			while (outerReader.Read() && coreReader.Depth > depth)
			{
			}
		}

		private void UpdateHandlers()
		{
			validator.EventHandler = eventHandler;
			coreReaderImpl.ValidationEventHandler = ((validationType != 0) ? eventHandler : null);
		}

		private void SetupValidation(ValidationType valType)
		{
			validator = BaseValidator.CreateInstance(valType, this, schemaCollection, eventHandler, processIdentityConstraints);
			XmlResolver resolver = GetResolver();
			validator.XmlResolver = resolver;
			if (outerReader.BaseURI.Length > 0)
			{
				validator.BaseUri = ((resolver == null) ? new Uri(outerReader.BaseURI, UriKind.RelativeOrAbsolute) : resolver.ResolveUri(null, outerReader.BaseURI));
			}
			UpdateHandlers();
		}

		private XmlResolver GetResolver()
		{
			return coreReaderImpl.GetResolver();
		}

		private void InternalValidationCallback(object sender, ValidationEventArgs e)
		{
			if (validationType != 0 && e.Severity == XmlSeverityType.Error)
			{
				throw e.Exception;
			}
		}

		private void ProcessCoreReaderEvent()
		{
			switch (coreReader.NodeType)
			{
			case XmlNodeType.Whitespace:
				if ((coreReader.Depth > 0 || coreReaderImpl.FragmentType != XmlNodeType.Document) && validator.PreserveWhitespace)
				{
					coreReaderImpl.ChangeCurrentNodeType(XmlNodeType.SignificantWhitespace);
				}
				break;
			case XmlNodeType.DocumentType:
				ValidateDtd();
				return;
			case XmlNodeType.EntityReference:
				parsingFunction = ParsingFunction.ResolveEntityInternally;
				break;
			}
			coreReaderImpl.InternalSchemaType = null;
			coreReaderImpl.InternalTypedValue = null;
			validator.Validate();
		}

		internal void Close(bool closeStream)
		{
			coreReaderImpl.Close(closeStream);
			parsingFunction = ParsingFunction.ReaderClosed;
		}

		internal bool AddDefaultAttribute(SchemaAttDef attdef)
		{
			return coreReaderImpl.AddDefaultAttribute(attdef, definedInDtd: false);
		}

		internal SchemaInfo GetSchemaInfo()
		{
			return validator.SchemaInfo;
		}
	}
	internal class XmlWellFormedWriter : XmlWriter
	{
		private class NamespaceResolverProxy : IXmlNamespaceResolver
		{
			private XmlWellFormedWriter wfWriter;

			internal NamespaceResolverProxy(XmlWellFormedWriter wfWriter)
			{
				this.wfWriter = wfWriter;
			}

			IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
			{
				throw new NotImplementedException();
			}

			string IXmlNamespaceResolver.LookupNamespace(string prefix)
			{
				return wfWriter.LookupNamespace(prefix);
			}

			string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
			{
				return wfWriter.LookupPrefix(namespaceName);
			}
		}

		private struct ElementScope
		{
			internal int prevNSTop;

			internal string prefix;

			internal string localName;

			internal string namespaceUri;

			internal XmlSpace xmlSpace;

			internal string xmlLang;

			internal void Set(string prefix, string localName, string namespaceUri, int prevNSTop)
			{
				this.prevNSTop = prevNSTop;
				this.prefix = prefix;
				this.namespaceUri = namespaceUri;
				this.localName = localName;
				xmlSpace = (XmlSpace)(-1);
				xmlLang = null;
			}

			internal void WriteEndElement(XmlRawWriter rawWriter)
			{
				rawWriter.WriteEndElement(prefix, localName, namespaceUri);
			}

			internal void WriteFullEndElement(XmlRawWriter rawWriter)
			{
				rawWriter.WriteFullEndElement(prefix, localName, namespaceUri);
			}
		}

		private enum NamespaceKind
		{
			Written,
			NeedToWrite,
			Implied,
			Special
		}

		private struct Namespace
		{
			internal string prefix;

			internal string namespaceUri;

			internal NamespaceKind kind;

			internal int prevNsIndex;

			internal void Set(string prefix, string namespaceUri, NamespaceKind kind)
			{
				this.prefix = prefix;
				this.namespaceUri = namespaceUri;
				this.kind = kind;
				prevNsIndex = -1;
			}

			internal void WriteDecl(XmlWriter writer, XmlRawWriter rawWriter)
			{
				if (rawWriter != null)
				{
					rawWriter.WriteNamespaceDeclaration(prefix, namespaceUri);
					return;
				}
				if (prefix.Length == 0)
				{
					writer.WriteStartAttribute(string.Empty, "xmlns", "http://www.w3.org/2000/xmlns/");
				}
				else
				{
					writer.WriteStartAttribute("xmlns", prefix, "http://www.w3.org/2000/xmlns/");
				}
				writer.WriteString(namespaceUri);
				writer.WriteEndAttribute();
			}
		}

		private struct AttrName
		{
			internal string prefix;

			internal string namespaceUri;

			internal string localName;

			internal int prev;

			internal void Set(string prefix, string localName, string namespaceUri)
			{
				this.prefix = prefix;
				this.namespaceUri = namespaceUri;
				this.localName = localName;
				prev = 0;
			}

			internal bool IsDuplicate(string prefix, string localName, string namespaceUri)
			{
				if (this.localName == localName)
				{
					if (!(this.prefix == prefix))
					{
						return this.namespaceUri == namespaceUri;
					}
					return true;
				}
				return false;
			}
		}

		private enum State
		{
			Start = 0,
			TopLevel = 1,
			Document = 2,
			Element = 3,
			Content = 4,
			B64Content = 5,
			B64Attribute = 6,
			AfterRootEle = 7,
			Attribute = 8,
			SpecialAttr = 9,
			EndDocument = 10,
			RootLevelAttr = 11,
			RootLevelSpecAttr = 12,
			RootLevelB64Attr = 13,
			AfterRootLevelAttr = 14,
			Closed = 15,
			Error = 16,
			StartContent = 101,
			StartContentEle = 102,
			StartContentB64 = 103,
			StartDoc = 104,
			StartDocEle = 106,
			EndAttrSEle = 107,
			EndAttrEEle = 108,
			EndAttrSCont = 109,
			EndAttrSAttr = 111,
			PostB64Cont = 112,
			PostB64Attr = 113,
			PostB64RootAttr = 114,
			StartFragEle = 115,
			StartFragCont = 116,
			StartFragB64 = 117,
			StartRootLevelAttr = 118
		}

		private enum Token
		{
			StartDocument,
			EndDocument,
			PI,
			Comment,
			Dtd,
			StartElement,
			EndElement,
			StartAttribute,
			EndAttribute,
			Text,
			CData,
			AtomicValue,
			Base64,
			RawData,
			Whitespace
		}

		private enum SpecialAttribute
		{
			No,
			DefaultXmlns,
			PrefixedXmlns,
			XmlSpace,
			XmlLang
		}

		private const int ElementStackInitialSize = 8;

		private const int NamespaceStackInitialSize = 8;

		private const int AttributeArrayInitialSize = 8;

		private const int MaxAttrDuplWalkCount = 14;

		private const int MaxNamespacesWalkCount = 16;

		private XmlWriter writer;

		private XmlRawWriter rawWriter;

		private IXmlNamespaceResolver predefinedNamespaces;

		private Namespace[] nsStack;

		private int nsTop;

		private Dictionary<string, int> nsHashtable;

		private bool useNsHashtable;

		private ElementScope[] elemScopeStack;

		private int elemTop;

		private AttrName[] attrStack;

		private int attrCount;

		private Dictionary<string, int> attrHashTable;

		private SpecialAttribute specAttr;

		private StringBuilder attrValue;

		private string curDeclPrefix;

		private State[] stateTable;

		private State currentState;

		private bool checkCharacters;

		private ConformanceLevel conformanceLevel;

		private bool dtdWritten;

		private bool xmlDeclFollows;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		private SecureStringHasher hasher;

		internal static readonly string[] stateName = new string[17]
		{
			"Start", "TopLevel", "Document", "Element Start Tag", "Element Content", "Element Content", "Attribute", "EndRootElement", "Attribute", "Special Attribute",
			"End Document", "Root Level Attribute Value", "Root Level Special Attribute Value", "Root Level Base64 Attribute Value", "After Root Level Attribute", "Closed", "Error"
		};

		internal static readonly string[] tokenName = new string[15]
		{
			"StartDocument", "EndDocument", "PI", "Comment", "DTD", "StartElement", "EndElement", "StartAttribute", "EndAttribute", "Text",
			"CDATA", "Atomic value", "Base64", "RawData", "Whitespace"
		};

		private static WriteState[] state2WriteState = new WriteState[17]
		{
			WriteState.Start,
			WriteState.Prolog,
			WriteState.Prolog,
			WriteState.Element,
			WriteState.Content,
			WriteState.Content,
			WriteState.Attribute,
			WriteState.Content,
			WriteState.Attribute,
			WriteState.Attribute,
			WriteState.Content,
			WriteState.Attribute,
			WriteState.Attribute,
			WriteState.Attribute,
			WriteState.Attribute,
			WriteState.Closed,
			WriteState.Error
		};

		private static readonly State[] StateTableDocument = new State[240]
		{
			State.Document,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.PostB64Cont,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.PostB64Cont,
			State.Error,
			State.EndDocument,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartDoc,
			State.TopLevel,
			State.Document,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.AfterRootEle,
			State.EndAttrSCont,
			State.EndAttrSCont,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartDoc,
			State.TopLevel,
			State.Document,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.AfterRootEle,
			State.EndAttrSCont,
			State.EndAttrSCont,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartDoc,
			State.TopLevel,
			State.Document,
			State.Error,
			State.Error,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartDocEle,
			State.Element,
			State.Element,
			State.StartContentEle,
			State.Element,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.EndAttrSEle,
			State.EndAttrSEle,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.EndAttrEEle,
			State.EndAttrEEle,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Attribute,
			State.Error,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.EndAttrSAttr,
			State.EndAttrSAttr,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.Element,
			State.Element,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.Attribute,
			State.SpecialAttr,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.EndAttrSCont,
			State.EndAttrSCont,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.Attribute,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartContentB64,
			State.B64Content,
			State.B64Content,
			State.B64Attribute,
			State.Error,
			State.B64Attribute,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartDoc,
			State.Error,
			State.Document,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.AfterRootEle,
			State.Attribute,
			State.SpecialAttr,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartDoc,
			State.TopLevel,
			State.Document,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.AfterRootEle,
			State.Attribute,
			State.SpecialAttr,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error
		};

		private static readonly State[] StateTableAuto = new State[240]
		{
			State.Document,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.PostB64Cont,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.PostB64Cont,
			State.Error,
			State.EndDocument,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.TopLevel,
			State.TopLevel,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.AfterRootEle,
			State.EndAttrSCont,
			State.EndAttrSCont,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.TopLevel,
			State.TopLevel,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.AfterRootEle,
			State.EndAttrSCont,
			State.EndAttrSCont,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartDoc,
			State.TopLevel,
			State.Error,
			State.Error,
			State.Error,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartFragEle,
			State.Element,
			State.Error,
			State.StartContentEle,
			State.Element,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Element,
			State.EndAttrSEle,
			State.EndAttrSEle,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.EndAttrEEle,
			State.EndAttrEEle,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.RootLevelAttr,
			State.Error,
			State.Error,
			State.Attribute,
			State.Error,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.EndAttrSAttr,
			State.EndAttrSAttr,
			State.Error,
			State.StartRootLevelAttr,
			State.StartRootLevelAttr,
			State.PostB64RootAttr,
			State.RootLevelAttr,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Error,
			State.Element,
			State.Element,
			State.Error,
			State.AfterRootLevelAttr,
			State.AfterRootLevelAttr,
			State.PostB64RootAttr,
			State.Error,
			State.Error,
			State.StartFragCont,
			State.StartFragCont,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Content,
			State.Attribute,
			State.SpecialAttr,
			State.Error,
			State.RootLevelAttr,
			State.RootLevelSpecAttr,
			State.PostB64RootAttr,
			State.Error,
			State.Error,
			State.StartFragCont,
			State.StartFragCont,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Content,
			State.EndAttrSCont,
			State.EndAttrSCont,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.StartFragCont,
			State.StartFragCont,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Content,
			State.Attribute,
			State.Error,
			State.Error,
			State.RootLevelAttr,
			State.Error,
			State.PostB64RootAttr,
			State.Error,
			State.Error,
			State.StartFragB64,
			State.StartFragB64,
			State.Error,
			State.StartContentB64,
			State.B64Content,
			State.B64Content,
			State.B64Attribute,
			State.B64Content,
			State.B64Attribute,
			State.Error,
			State.Error,
			State.RootLevelB64Attr,
			State.Error,
			State.RootLevelB64Attr,
			State.Error,
			State.Error,
			State.StartFragCont,
			State.TopLevel,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.Content,
			State.Attribute,
			State.SpecialAttr,
			State.Error,
			State.RootLevelAttr,
			State.RootLevelSpecAttr,
			State.PostB64RootAttr,
			State.AfterRootLevelAttr,
			State.Error,
			State.TopLevel,
			State.TopLevel,
			State.Error,
			State.StartContent,
			State.Content,
			State.PostB64Cont,
			State.PostB64Attr,
			State.AfterRootEle,
			State.Attribute,
			State.SpecialAttr,
			State.Error,
			State.RootLevelAttr,
			State.RootLevelSpecAttr,
			State.PostB64RootAttr,
			State.AfterRootLevelAttr,
			State.Error
		};

		public override WriteState WriteState
		{
			get
			{
				if (currentState <= State.Error)
				{
					return state2WriteState[(int)currentState];
				}
				return WriteState.Error;
			}
		}

		public override XmlWriterSettings Settings
		{
			get
			{
				XmlWriterSettings settings = writer.Settings;
				settings.ReadOnly = false;
				settings.ConformanceLevel = conformanceLevel;
				settings.ReadOnly = true;
				return settings;
			}
		}

		public override XmlSpace XmlSpace
		{
			get
			{
				int num = elemTop;
				while (num >= 0 && elemScopeStack[num].xmlSpace == (XmlSpace)(-1))
				{
					num--;
				}
				return elemScopeStack[num].xmlSpace;
			}
		}

		public override string XmlLang
		{
			get
			{
				int num = elemTop;
				while (num > 0 && elemScopeStack[num].xmlLang == null)
				{
					num--;
				}
				return elemScopeStack[num].xmlLang;
			}
		}

		internal XmlWriter InnerWriter => writer;

		private bool SaveAttrValue => specAttr != SpecialAttribute.No;

		private bool IsClosedOrErrorState => currentState >= State.Closed;

		internal XmlRawWriter RawWriter => rawWriter;

		internal XmlWellFormedWriter(XmlWriter writer, XmlWriterSettings settings)
		{
			this.writer = writer;
			rawWriter = writer as XmlRawWriter;
			predefinedNamespaces = writer as IXmlNamespaceResolver;
			if (rawWriter != null)
			{
				rawWriter.NamespaceResolver = new NamespaceResolverProxy(this);
			}
			checkCharacters = settings.CheckCharacters;
			conformanceLevel = settings.ConformanceLevel;
			stateTable = ((conformanceLevel == ConformanceLevel.Document) ? StateTableDocument : StateTableAuto);
			currentState = State.Start;
			nsStack = new Namespace[8];
			nsStack[0].Set("xmlns", "http://www.w3.org/2000/xmlns/", NamespaceKind.Special);
			nsStack[1].Set("xml", "http://www.w3.org/XML/1998/namespace", NamespaceKind.Special);
			if (predefinedNamespaces == null)
			{
				nsStack[2].Set(string.Empty, string.Empty, NamespaceKind.Implied);
			}
			else
			{
				string text = predefinedNamespaces.LookupNamespace(string.Empty);
				nsStack[2].Set(string.Empty, (text == null) ? string.Empty : text, NamespaceKind.Implied);
			}
			nsTop = 2;
			elemScopeStack = new ElementScope[8];
			elemScopeStack[0].Set(string.Empty, string.Empty, string.Empty, nsTop);
			elemScopeStack[0].xmlSpace = XmlSpace.None;
			elemScopeStack[0].xmlLang = null;
			elemTop = 0;
			attrStack = new AttrName[8];
			attrValue = new StringBuilder();
			hasher = new SecureStringHasher();
		}

		public override void WriteStartDocument()
		{
			WriteStartDocumentImpl(XmlStandalone.Omit);
		}

		public override void WriteStartDocument(bool standalone)
		{
			WriteStartDocumentImpl(standalone ? XmlStandalone.Yes : XmlStandalone.No);
		}

		public override void WriteEndDocument()
		{
			try
			{
				while (elemTop > 0)
				{
					WriteEndElement();
				}
				State state = currentState;
				AdvanceState(Token.EndDocument);
				if (state != State.AfterRootEle)
				{
					throw new ArgumentException(Res.GetString("Xml_NoRoot"));
				}
				if (rawWriter == null)
				{
					writer.WriteEndDocument();
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			try
			{
				if (name == null || name.Length == 0)
				{
					throw new ArgumentException(Res.GetString("Xml_EmptyName"));
				}
				XmlConvert.VerifyQName(name);
				if (conformanceLevel == ConformanceLevel.Fragment)
				{
					throw new InvalidOperationException(Res.GetString("Xml_DtdNotAllowedInFragment"));
				}
				AdvanceState(Token.Dtd);
				if (dtdWritten)
				{
					currentState = State.Error;
					throw new InvalidOperationException(Res.GetString("Xml_DtdAlreadyWritten"));
				}
				if (conformanceLevel == ConformanceLevel.Auto)
				{
					conformanceLevel = ConformanceLevel.Document;
					stateTable = StateTableDocument;
				}
				if (checkCharacters)
				{
					int index;
					if (pubid != null && (index = xmlCharType.IsPublicId(pubid)) >= 0)
					{
						throw new ArgumentException(Res.GetString("Xml_InvalidCharacter", XmlException.BuildCharExceptionStr(pubid[index])), "pubid");
					}
					if (sysid != null && (index = xmlCharType.IsOnlyCharData(sysid)) >= 0)
					{
						throw new ArgumentException(Res.GetString("Xml_InvalidCharacter", XmlException.BuildCharExceptionStr(sysid[index])), "sysid");
					}
					if (subset != null && (index = xmlCharType.IsOnlyCharData(subset)) >= 0)
					{
						throw new ArgumentException(Res.GetString("Xml_InvalidCharacter", XmlException.BuildCharExceptionStr(subset[index])), "subset");
					}
				}
				writer.WriteDocType(name, pubid, sysid, subset);
				dtdWritten = true;
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			try
			{
				if (localName == null || localName.Length == 0)
				{
					throw new ArgumentException(Res.GetString("Xml_EmptyLocalName"));
				}
				CheckNCName(localName);
				AdvanceState(Token.StartElement);
				if (prefix == null)
				{
					if (ns != null)
					{
						prefix = LookupPrefix(ns);
					}
					if (prefix == null)
					{
						prefix = string.Empty;
					}
				}
				else if (prefix.Length > 0)
				{
					CheckNCName(prefix);
					if (ns == null)
					{
						ns = LookupNamespace(prefix);
					}
					if (ns == null || (ns != null && ns.Length == 0))
					{
						throw new ArgumentException(Res.GetString("Xml_PrefixForEmptyNs"));
					}
				}
				if (ns == null)
				{
					ns = LookupNamespace(prefix);
					if (ns == null)
					{
						ns = string.Empty;
					}
				}
				if (elemTop == 0 && rawWriter != null)
				{
					rawWriter.OnRootElement(conformanceLevel);
				}
				writer.WriteStartElement(prefix, localName, ns);
				int num = ++elemTop;
				if (num == elemScopeStack.Length)
				{
					ElementScope[] destinationArray = new ElementScope[num * 2];
					Array.Copy(elemScopeStack, destinationArray, num);
					elemScopeStack = destinationArray;
				}
				elemScopeStack[num].Set(prefix, localName, ns, nsTop);
				PushNamespace(prefix, ns, explicitlyDefined: false);
				if (attrCount >= 14)
				{
					attrHashTable.Clear();
				}
				attrCount = 0;
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteEndElement()
		{
			try
			{
				AdvanceState(Token.EndElement);
				int num = elemTop;
				if (num == 0)
				{
					throw new XmlException("Xml_NoStartTag", string.Empty);
				}
				if (rawWriter != null)
				{
					elemScopeStack[num].WriteEndElement(rawWriter);
				}
				else
				{
					writer.WriteEndElement();
				}
				int prevNSTop = elemScopeStack[num].prevNSTop;
				if (useNsHashtable && prevNSTop < nsTop)
				{
					PopNamespaces(prevNSTop + 1, nsTop);
				}
				nsTop = prevNSTop;
				if ((elemTop = num - 1) == 0)
				{
					if (conformanceLevel == ConformanceLevel.Document)
					{
						currentState = State.AfterRootEle;
					}
					else
					{
						currentState = State.TopLevel;
					}
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteFullEndElement()
		{
			try
			{
				AdvanceState(Token.EndElement);
				int num = elemTop;
				if (num == 0)
				{
					throw new XmlException("Xml_NoStartTag", string.Empty);
				}
				if (rawWriter != null)
				{
					elemScopeStack[num].WriteFullEndElement(rawWriter);
				}
				else
				{
					writer.WriteFullEndElement();
				}
				int prevNSTop = elemScopeStack[num].prevNSTop;
				if (useNsHashtable && prevNSTop < nsTop)
				{
					PopNamespaces(prevNSTop + 1, nsTop);
				}
				nsTop = prevNSTop;
				if ((elemTop = num - 1) == 0)
				{
					if (conformanceLevel == ConformanceLevel.Document)
					{
						currentState = State.AfterRootEle;
					}
					else
					{
						currentState = State.TopLevel;
					}
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteStartAttribute(string prefix, string localName, string namespaceName)
		{
			try
			{
				if (localName == null || localName.Length == 0)
				{
					if (!(prefix == "xmlns"))
					{
						throw new ArgumentException(Res.GetString("Xml_EmptyLocalName"));
					}
					localName = "xmlns";
					prefix = string.Empty;
				}
				CheckNCName(localName);
				AdvanceState(Token.StartAttribute);
				if (prefix == null)
				{
					if (namespaceName != null && (!(localName == "xmlns") || !(namespaceName == "http://www.w3.org/2000/xmlns/")))
					{
						prefix = LookupPrefix(namespaceName);
					}
					if (prefix == null)
					{
						prefix = string.Empty;
					}
				}
				if (namespaceName == null)
				{
					if (prefix != null && prefix.Length > 0)
					{
						namespaceName = LookupNamespace(prefix);
					}
					if (namespaceName == null)
					{
						namespaceName = string.Empty;
					}
				}
				if (prefix.Length == 0)
				{
					if (localName[0] != 'x' || !(localName == "xmlns"))
					{
						if (namespaceName.Length > 0)
						{
							prefix = LookupPrefix(namespaceName);
							if (prefix == null || prefix.Length == 0)
							{
								prefix = GeneratePrefix();
							}
						}
						goto IL_0219;
					}
					if (namespaceName.Length > 0 && namespaceName != "http://www.w3.org/2000/xmlns/")
					{
						throw new ArgumentException(Res.GetString("Xml_XmlnsPrefix"));
					}
					curDeclPrefix = string.Empty;
					SetSpecialAttribute(SpecialAttribute.DefaultXmlns);
				}
				else
				{
					if (prefix[0] != 'x')
					{
						goto IL_01e5;
					}
					if (prefix == "xmlns")
					{
						if (namespaceName.Length > 0 && namespaceName != "http://www.w3.org/2000/xmlns/")
						{
							throw new ArgumentException(Res.GetString("Xml_XmlnsPrefix"));
						}
						curDeclPrefix = localName;
						SetSpecialAttribute(SpecialAttribute.PrefixedXmlns);
					}
					else
					{
						if (!(prefix == "xml"))
						{
							goto IL_01e5;
						}
						if (namespaceName.Length > 0 && namespaceName != "http://www.w3.org/XML/1998/namespace")
						{
							throw new ArgumentException(Res.GetString("Xml_XmlPrefix"));
						}
						switch (localName)
						{
						case "space":
							break;
						case "lang":
							goto IL_01dc;
						default:
							goto IL_01e5;
						}
						SetSpecialAttribute(SpecialAttribute.XmlSpace);
					}
				}
				goto IL_0238;
				IL_0219:
				if (prefix.Length != 0)
				{
					PushNamespace(prefix, namespaceName, explicitlyDefined: false);
				}
				writer.WriteStartAttribute(prefix, localName, namespaceName);
				goto IL_0238;
				IL_01dc:
				SetSpecialAttribute(SpecialAttribute.XmlLang);
				goto IL_0238;
				IL_0238:
				AddAttribute(prefix, localName, namespaceName);
				return;
				IL_01e5:
				CheckNCName(prefix);
				if (namespaceName.Length == 0)
				{
					prefix = string.Empty;
				}
				else
				{
					string text = LookupLocalNamespace(prefix);
					if (text != null && text != namespaceName)
					{
						prefix = GeneratePrefix();
					}
				}
				goto IL_0219;
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteEndAttribute()
		{
			try
			{
				AdvanceState(Token.EndAttribute);
				if (specAttr != 0)
				{
					string text;
					if (attrValue != null)
					{
						text = attrValue.ToString();
						attrValue.Length = 0;
					}
					else
					{
						text = string.Empty;
					}
					switch (specAttr)
					{
					case SpecialAttribute.DefaultXmlns:
						PushNamespace(string.Empty, text, explicitlyDefined: true);
						if (rawWriter != null)
						{
							rawWriter.WriteNamespaceDeclaration(string.Empty, text);
						}
						else
						{
							writer.WriteAttributeString(string.Empty, "xmlns", "http://www.w3.org/2000/xmlns/", text);
						}
						curDeclPrefix = null;
						break;
					case SpecialAttribute.PrefixedXmlns:
						if (text.Length == 0)
						{
							throw new ArgumentException(Res.GetString("Xml_PrefixForEmptyNs"));
						}
						if (text == "http://www.w3.org/2000/xmlns/" || (text == "http://www.w3.org/XML/1998/namespace" && curDeclPrefix != "xml"))
						{
							throw new ArgumentException(Res.GetString("Xml_CanNotBindToReservedNamespace"));
						}
						PushNamespace(curDeclPrefix, text, explicitlyDefined: true);
						if (rawWriter != null)
						{
							rawWriter.WriteNamespaceDeclaration(curDeclPrefix, text);
						}
						else
						{
							writer.WriteAttributeString("xmlns", curDeclPrefix, "http://www.w3.org/2000/xmlns/", text);
						}
						curDeclPrefix = null;
						break;
					case SpecialAttribute.XmlSpace:
						text = XmlConvert.TrimString(text);
						if (text == "default")
						{
							elemScopeStack[elemTop].xmlSpace = XmlSpace.Default;
						}
						else
						{
							if (!(text == "preserve"))
							{
								throw new ArgumentException(Res.GetString("Xml_InvalidXmlSpace", text));
							}
							elemScopeStack[elemTop].xmlSpace = XmlSpace.Preserve;
						}
						writer.WriteAttributeString("xml", "space", "http://www.w3.org/XML/1998/namespace", text);
						break;
					case SpecialAttribute.XmlLang:
						elemScopeStack[elemTop].xmlLang = text;
						writer.WriteAttributeString("xml", "lang", "http://www.w3.org/XML/1998/namespace", text);
						break;
					}
					specAttr = SpecialAttribute.No;
				}
				else
				{
					writer.WriteEndAttribute();
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteCData(string text)
		{
			try
			{
				if (text == null)
				{
					text = string.Empty;
				}
				AdvanceState(Token.CData);
				writer.WriteCData(text);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteComment(string text)
		{
			try
			{
				if (text == null)
				{
					text = string.Empty;
				}
				AdvanceState(Token.Comment);
				writer.WriteComment(text);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			try
			{
				if (name == null || name.Length == 0)
				{
					throw new ArgumentException(Res.GetString("Xml_EmptyName"));
				}
				CheckNCName(name);
				if (text == null)
				{
					text = string.Empty;
				}
				if (name.Length == 3 && string.Compare(name, "xml", StringComparison.OrdinalIgnoreCase) == 0)
				{
					if (currentState != 0)
					{
						throw new ArgumentException(Res.GetString((conformanceLevel == ConformanceLevel.Document) ? "Xml_DupXmlDecl" : "Xml_CannotWriteXmlDecl"));
					}
					xmlDeclFollows = true;
					AdvanceState(Token.PI);
					if (rawWriter != null)
					{
						rawWriter.WriteXmlDeclaration(text);
					}
					else
					{
						writer.WriteProcessingInstruction(name, text);
					}
				}
				else
				{
					AdvanceState(Token.PI);
					writer.WriteProcessingInstruction(name, text);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteEntityRef(string name)
		{
			try
			{
				if (name == null || name.Length == 0)
				{
					throw new ArgumentException(Res.GetString("Xml_EmptyName"));
				}
				CheckNCName(name);
				AdvanceState(Token.Text);
				if (SaveAttrValue)
				{
					attrValue.Append('&');
					attrValue.Append(name);
					attrValue.Append(';');
				}
				else
				{
					writer.WriteEntityRef(name);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteCharEntity(char ch)
		{
			try
			{
				if (char.IsSurrogate(ch))
				{
					throw new ArgumentException(Res.GetString("Xml_InvalidSurrogateMissingLowChar"));
				}
				AdvanceState(Token.Text);
				if (SaveAttrValue)
				{
					attrValue.Append(ch);
				}
				else
				{
					writer.WriteCharEntity(ch);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			try
			{
				if (!char.IsSurrogatePair(highChar, lowChar))
				{
					throw XmlConvert.CreateInvalidSurrogatePairException(lowChar, highChar);
				}
				AdvanceState(Token.Text);
				if (SaveAttrValue)
				{
					attrValue.Append(highChar);
					attrValue.Append(lowChar);
				}
				else
				{
					writer.WriteSurrogateCharEntity(lowChar, highChar);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteWhitespace(string ws)
		{
			try
			{
				if (ws == null)
				{
					ws = string.Empty;
				}
				if (!XmlCharType.Instance.IsOnlyWhitespace(ws))
				{
					throw new ArgumentException(Res.GetString("Xml_NonWhitespace"));
				}
				AdvanceState(Token.Whitespace);
				if (SaveAttrValue)
				{
					attrValue.Append(ws);
				}
				else
				{
					writer.WriteWhitespace(ws);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteString(string text)
		{
			try
			{
				if (text != null)
				{
					AdvanceState(Token.Text);
					if (SaveAttrValue)
					{
						attrValue.Append(text);
					}
					else
					{
						writer.WriteString(text);
					}
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			try
			{
				if (buffer == null)
				{
					throw new ArgumentNullException("buffer");
				}
				if (index < 0)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				if (count < 0)
				{
					throw new ArgumentOutOfRangeException("count");
				}
				if (count > buffer.Length - index)
				{
					throw new ArgumentOutOfRangeException("count");
				}
				AdvanceState(Token.Text);
				if (SaveAttrValue)
				{
					attrValue.Append(buffer, index, count);
				}
				else
				{
					writer.WriteChars(buffer, index, count);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			try
			{
				if (buffer == null)
				{
					throw new ArgumentNullException("buffer");
				}
				if (index < 0)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				if (count < 0)
				{
					throw new ArgumentOutOfRangeException("count");
				}
				if (count > buffer.Length - index)
				{
					throw new ArgumentOutOfRangeException("count");
				}
				AdvanceState(Token.RawData);
				if (SaveAttrValue)
				{
					attrValue.Append(buffer, index, count);
				}
				else
				{
					writer.WriteRaw(buffer, index, count);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteRaw(string data)
		{
			try
			{
				if (data != null)
				{
					AdvanceState(Token.RawData);
					if (SaveAttrValue)
					{
						attrValue.Append(data);
					}
					else
					{
						writer.WriteRaw(data);
					}
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteBase64(byte[] buffer, int index, int count)
		{
			try
			{
				if (buffer == null)
				{
					throw new ArgumentNullException("buffer");
				}
				if (index < 0)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				if (count < 0)
				{
					throw new ArgumentOutOfRangeException("count");
				}
				if (count > buffer.Length - index)
				{
					throw new ArgumentOutOfRangeException("count");
				}
				AdvanceState(Token.Base64);
				writer.WriteBase64(buffer, index, count);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void Close()
		{
			if (currentState != State.Closed)
			{
				while (currentState != State.Error && elemTop > 0)
				{
					WriteEndElement();
				}
				writer.Flush();
				if (rawWriter != null)
				{
					rawWriter.Close(WriteState);
				}
				else
				{
					writer.Close();
				}
				currentState = State.Closed;
			}
		}

		public override void Flush()
		{
			try
			{
				writer.Flush();
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override string LookupPrefix(string ns)
		{
			try
			{
				if (ns == null)
				{
					throw new ArgumentNullException("ns");
				}
				for (int num = nsTop; num >= 0; num--)
				{
					if (nsStack[num].namespaceUri == ns)
					{
						string prefix = nsStack[num].prefix;
						for (num++; num <= nsTop; num++)
						{
							if (nsStack[num].prefix == prefix)
							{
								return null;
							}
						}
						return prefix;
					}
				}
				return (predefinedNamespaces != null) ? predefinedNamespaces.LookupPrefix(ns) : null;
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteQualifiedName(string localName, string ns)
		{
			try
			{
				if (localName == null || localName.Length == 0)
				{
					throw new ArgumentException(Res.GetString("Xml_EmptyLocalName"));
				}
				CheckNCName(localName);
				AdvanceState(Token.Text);
				string text = string.Empty;
				if (ns != null && ns.Length != 0)
				{
					text = LookupPrefix(ns);
					if (text == null)
					{
						if (currentState != State.Attribute)
						{
							throw new ArgumentException(Res.GetString("Xml_UndefNamespace", ns));
						}
						text = GeneratePrefix();
						PushNamespace(text, ns, explicitlyDefined: false);
					}
				}
				if (SaveAttrValue || rawWriter == null)
				{
					if (text.Length != 0)
					{
						WriteString(text);
						WriteString(":");
					}
					WriteString(localName);
				}
				else
				{
					rawWriter.WriteQualifiedName(text, localName, ns);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteValue(bool value)
		{
			try
			{
				AdvanceState(Token.AtomicValue);
				writer.WriteValue(value);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteValue(DateTime value)
		{
			try
			{
				AdvanceState(Token.AtomicValue);
				writer.WriteValue(value);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteValue(double value)
		{
			try
			{
				AdvanceState(Token.AtomicValue);
				writer.WriteValue(value);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteValue(float value)
		{
			try
			{
				AdvanceState(Token.AtomicValue);
				writer.WriteValue(value);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteValue(decimal value)
		{
			try
			{
				AdvanceState(Token.AtomicValue);
				writer.WriteValue(value);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteValue(int value)
		{
			try
			{
				AdvanceState(Token.AtomicValue);
				writer.WriteValue(value);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteValue(long value)
		{
			try
			{
				AdvanceState(Token.AtomicValue);
				writer.WriteValue(value);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteValue(string value)
		{
			try
			{
				if (SaveAttrValue)
				{
					AdvanceState(Token.Text);
					attrValue.Append(value);
				}
				else
				{
					AdvanceState(Token.AtomicValue);
					writer.WriteValue(value);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteValue(object value)
		{
			try
			{
				if (SaveAttrValue && value is string)
				{
					AdvanceState(Token.Text);
					attrValue.Append(value);
				}
				else
				{
					AdvanceState(Token.AtomicValue);
					writer.WriteValue(value);
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		public override void WriteBinHex(byte[] buffer, int index, int count)
		{
			if (IsClosedOrErrorState)
			{
				throw new InvalidOperationException(Res.GetString("Xml_ClosedOrError"));
			}
			try
			{
				AdvanceState(Token.Text);
				base.WriteBinHex(buffer, index, count);
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		private void SetSpecialAttribute(SpecialAttribute special)
		{
			specAttr = special;
			if (State.Attribute == currentState)
			{
				currentState = State.SpecialAttr;
			}
			else if (State.RootLevelAttr == currentState)
			{
				currentState = State.RootLevelSpecAttr;
			}
		}

		private void WriteStartDocumentImpl(XmlStandalone standalone)
		{
			try
			{
				AdvanceState(Token.StartDocument);
				if (conformanceLevel == ConformanceLevel.Auto)
				{
					conformanceLevel = ConformanceLevel.Document;
					stateTable = StateTableDocument;
				}
				else if (conformanceLevel == ConformanceLevel.Fragment)
				{
					throw new InvalidOperationException(Res.GetString("Xml_CannotStartDocumentOnFragment"));
				}
				if (rawWriter != null)
				{
					if (!xmlDeclFollows)
					{
						rawWriter.WriteXmlDeclaration(standalone);
					}
				}
				else
				{
					writer.WriteStartDocument();
				}
			}
			catch
			{
				currentState = State.Error;
				throw;
			}
		}

		private void StartFragment()
		{
			conformanceLevel = ConformanceLevel.Fragment;
		}

		private void PushNamespace(string prefix, string ns, bool explicitlyDefined)
		{
			int num = LookupNamespaceIndex(prefix);
			NamespaceKind kind;
			if (num != -1)
			{
				if (num > elemScopeStack[elemTop].prevNSTop)
				{
					if (nsStack[num].namespaceUri != ns)
					{
						throw new XmlException("Xml_RedefinePrefix", new string[3]
						{
							prefix,
							nsStack[num].namespaceUri,
							ns
						});
					}
					if (explicitlyDefined)
					{
						if (nsStack[num].kind == NamespaceKind.Written)
						{
							throw DupAttrException((prefix.Length == 0) ? string.Empty : "xmlns", (prefix.Length == 0) ? "xmlns" : prefix);
						}
						nsStack[num].kind = NamespaceKind.Written;
					}
					return;
				}
				if (!explicitlyDefined)
				{
					if (nsStack[num].kind == NamespaceKind.Special)
					{
						if (!(prefix == "xml"))
						{
							throw new ArgumentException(Res.GetString("Xml_XmlnsPrefix"));
						}
						if (ns != nsStack[num].namespaceUri)
						{
							throw new ArgumentException(Res.GetString("Xml_XmlPrefix"));
						}
						kind = NamespaceKind.Implied;
					}
					else
					{
						kind = ((!(nsStack[num].namespaceUri == ns)) ? NamespaceKind.NeedToWrite : NamespaceKind.Implied);
					}
					goto IL_0231;
				}
			}
			if ((ns == "http://www.w3.org/XML/1998/namespace" && prefix != "xml") || (ns == "http://www.w3.org/2000/xmlns/" && prefix != "xmlns"))
			{
				throw new ArgumentException(Res.GetString("Xml_NamespaceDeclXmlXmlns", prefix));
			}
			if (!explicitlyDefined)
			{
				if (predefinedNamespaces == null)
				{
					kind = NamespaceKind.NeedToWrite;
				}
				else
				{
					string text = predefinedNamespaces.LookupNamespace(prefix);
					kind = ((!(text == ns)) ? NamespaceKind.NeedToWrite : NamespaceKind.Implied);
				}
			}
			else
			{
				if (prefix.Length > 0 && prefix[0] == 'x')
				{
					if (prefix == "xml")
					{
						if (ns != "http://www.w3.org/XML/1998/namespace")
						{
							throw new ArgumentException(Res.GetString("Xml_XmlPrefix"));
						}
					}
					else if (prefix == "xmlns")
					{
						throw new ArgumentException(Res.GetString("Xml_XmlnsPrefix"));
					}
				}
				kind = NamespaceKind.Written;
			}
			goto IL_0231;
			IL_0231:
			int num2 = ++nsTop;
			if (num2 == nsStack.Length)
			{
				Namespace[] destinationArray = new Namespace[num2 * 2];
				Array.Copy(nsStack, destinationArray, num2);
				nsStack = destinationArray;
			}
			nsStack[num2].Set(prefix, ns, kind);
			if (useNsHashtable)
			{
				AddToNamespaceHashtable(nsTop);
			}
			else if (nsTop == 16)
			{
				nsHashtable = new Dictionary<string, int>(hasher);
				for (int i = 0; i <= nsTop; i++)
				{
					AddToNamespaceHashtable(i);
				}
				useNsHashtable = true;
			}
		}

		private void AddToNamespaceHashtable(int namespaceIndex)
		{
			string prefix = nsStack[namespaceIndex].prefix;
			if (nsHashtable.TryGetValue(prefix, out var value))
			{
				nsStack[namespaceIndex].prevNsIndex = value;
			}
			nsHashtable[prefix] = namespaceIndex;
		}

		private int LookupNamespaceIndex(string prefix)
		{
			if (useNsHashtable)
			{
				if (nsHashtable.TryGetValue(prefix, out var value))
				{
					return value;
				}
			}
			else
			{
				for (int num = nsTop; num >= 0; num--)
				{
					if (nsStack[num].prefix == prefix)
					{
						return num;
					}
				}
			}
			return -1;
		}

		private void PopNamespaces(int indexFrom, int indexTo)
		{
			for (int num = indexTo; num >= indexFrom; num--)
			{
				if (nsStack[num].prevNsIndex == -1)
				{
					nsHashtable.Remove(nsStack[num].prefix);
				}
				else
				{
					nsHashtable[nsStack[num].prefix] = nsStack[num].prevNsIndex;
				}
			}
		}

		private static XmlException DupAttrException(string prefix, string localName)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (prefix.Length > 0)
			{
				stringBuilder.Append(prefix);
				stringBuilder.Append(':');
			}
			stringBuilder.Append(localName);
			return new XmlException("Xml_DupAttributeName", stringBuilder.ToString());
		}

		private void AdvanceState(Token token)
		{
			if (currentState >= State.Closed)
			{
				if (currentState == State.Closed || currentState == State.Error)
				{
					throw new InvalidOperationException(Res.GetString("Xml_ClosedOrError"));
				}
				throw new InvalidOperationException(Res.GetString("Xml_WrongToken", tokenName[(int)token], GetStateName(currentState)));
			}
			State state;
			while (true)
			{
				state = stateTable[(int)(((int)token << 4) + currentState)];
				if (state < State.Error)
				{
					break;
				}
				switch (state)
				{
				case State.Error:
					ThrowInvalidStateTransition(token, currentState);
					break;
				case State.StartContent:
					StartElementContent();
					state = State.Content;
					break;
				case State.StartContentEle:
					StartElementContent();
					state = State.Element;
					break;
				case State.StartContentB64:
					StartElementContent();
					state = State.B64Content;
					break;
				case State.StartDoc:
					WriteStartDocument();
					state = State.Document;
					break;
				case State.StartDocEle:
					WriteStartDocument();
					state = State.Element;
					break;
				case State.EndAttrSEle:
					WriteEndAttribute();
					StartElementContent();
					state = State.Element;
					break;
				case State.EndAttrEEle:
					WriteEndAttribute();
					StartElementContent();
					state = State.Content;
					break;
				case State.EndAttrSCont:
					WriteEndAttribute();
					StartElementContent();
					state = State.Content;
					break;
				case State.EndAttrSAttr:
					WriteEndAttribute();
					state = State.Attribute;
					break;
				case State.PostB64Cont:
					if (rawWriter != null)
					{
						rawWriter.WriteEndBase64();
					}
					currentState = State.Content;
					continue;
				case State.PostB64Attr:
					if (rawWriter != null)
					{
						rawWriter.WriteEndBase64();
					}
					currentState = State.Attribute;
					continue;
				case State.PostB64RootAttr:
					if (rawWriter != null)
					{
						rawWriter.WriteEndBase64();
					}
					currentState = State.RootLevelAttr;
					continue;
				case State.StartFragEle:
					StartFragment();
					state = State.Element;
					break;
				case State.StartFragCont:
					StartFragment();
					state = State.Content;
					break;
				case State.StartFragB64:
					StartFragment();
					state = State.B64Content;
					break;
				case State.StartRootLevelAttr:
					WriteEndAttribute();
					state = State.RootLevelAttr;
					break;
				}
				break;
			}
			currentState = state;
		}

		private void StartElementContent()
		{
			int prevNSTop = elemScopeStack[elemTop].prevNSTop;
			for (int num = nsTop; num > prevNSTop; num--)
			{
				if (nsStack[num].kind == NamespaceKind.NeedToWrite)
				{
					nsStack[num].WriteDecl(writer, rawWriter);
				}
			}
			if (rawWriter != null)
			{
				rawWriter.StartElementContent();
			}
		}

		private static string GetStateName(State state)
		{
			if (state >= State.Error)
			{
				return "Error";
			}
			return stateName[(int)state];
		}

		internal string LookupNamespace(string prefix)
		{
			for (int num = nsTop; num >= 0; num--)
			{
				if (nsStack[num].prefix == prefix)
				{
					return nsStack[num].namespaceUri;
				}
			}
			if (predefinedNamespaces == null)
			{
				return null;
			}
			return predefinedNamespaces.LookupNamespace(prefix);
		}

		private string LookupLocalNamespace(string prefix)
		{
			for (int num = nsTop; num > elemScopeStack[elemTop].prevNSTop; num--)
			{
				if (nsStack[num].prefix == prefix)
				{
					return nsStack[num].namespaceUri;
				}
			}
			return null;
		}

		private string GeneratePrefix()
		{
			string text = "p" + (nsTop - 2).ToString("d", CultureInfo.InvariantCulture);
			if (LookupNamespace(text) == null)
			{
				return text;
			}
			int num = 0;
			string text2;
			do
			{
				text2 = text + num.ToString(CultureInfo.InvariantCulture);
				num++;
			}
			while (LookupNamespace(text2) != null);
			return text2;
		}

		private unsafe void CheckNCName(string ncname)
		{
			if ((xmlCharType.charProperties[(int)ncname[0]] & 4u) != 0)
			{
				int i = 1;
				for (int length = ncname.Length; i < length; i++)
				{
					if ((xmlCharType.charProperties[(int)ncname[i]] & 8) == 0)
					{
						throw InvalidCharsException(ncname, ncname[i]);
					}
				}
				return;
			}
			throw InvalidCharsException(ncname, ncname[0]);
		}

		private static Exception InvalidCharsException(string name, char badChar)
		{
			string[] array = new string[3]
			{
				name,
				badChar.ToString(CultureInfo.InvariantCulture),
				null
			};
			int num = badChar;
			array[2] = num.ToString("X2", CultureInfo.InvariantCulture);
			return new ArgumentException(Res.GetString("Xml_InvalidNameCharsDetail", array));
		}

		private void ThrowInvalidStateTransition(Token token, State currentState)
		{
			string @string = Res.GetString("Xml_WrongToken", tokenName[(int)token], GetStateName(currentState));
			if ((currentState == State.Start || currentState == State.AfterRootEle) && conformanceLevel == ConformanceLevel.Document)
			{
				throw new InvalidOperationException(@string + ' ' + Res.GetString("Xml_ConformanceLevelFragment"));
			}
			throw new InvalidOperationException(@string);
		}

		private void AddAttribute(string prefix, string localName, string namespaceName)
		{
			int num = attrCount++;
			if (num == attrStack.Length)
			{
				AttrName[] destinationArray = new AttrName[num * 2];
				Array.Copy(attrStack, destinationArray, num);
				attrStack = destinationArray;
			}
			attrStack[num].Set(prefix, localName, namespaceName);
			if (attrCount < 14)
			{
				for (int i = 0; i < num; i++)
				{
					if (attrStack[i].IsDuplicate(prefix, localName, namespaceName))
					{
						throw DupAttrException(prefix, localName);
					}
				}
				return;
			}
			if (attrCount == 14)
			{
				if (attrHashTable == null)
				{
					attrHashTable = new Dictionary<string, int>(hasher);
				}
				for (int j = 0; j < num; j++)
				{
					AddToAttrHashTable(j);
				}
			}
			AddToAttrHashTable(num);
			int prev;
			for (prev = attrStack[num].prev; prev > 0; prev = attrStack[prev].prev)
			{
				prev--;
				if (attrStack[prev].IsDuplicate(prefix, localName, namespaceName))
				{
					throw DupAttrException(prefix, localName);
				}
			}
		}

		private void AddToAttrHashTable(int attributeIndex)
		{
			string localName = attrStack[attributeIndex].localName;
			int count = attrHashTable.Count;
			attrHashTable[localName] = 0;
			if (count == attrHashTable.Count)
			{
				int num = attributeIndex - 1;
				while (num >= 0 && !(attrStack[num].localName == localName))
				{
					num--;
				}
				attrStack[attributeIndex].prev = num + 1;
			}
		}
	}
	public enum WriteState
	{
		Start,
		Prolog,
		Element,
		Attribute,
		Content,
		Closed,
		Error
	}
	public enum XmlOutputMethod
	{
		Xml,
		Html,
		Text,
		AutoDetect
	}
	internal enum XmlStandalone
	{
		Omit,
		Yes,
		No
	}
	internal enum TriState
	{
		Unknown = -1,
		False,
		True
	}
	public sealed class XmlWriterSettings
	{
		private Encoding encoding;

		private bool omitXmlDecl;

		private NewLineHandling newLineHandling;

		private string newLineChars;

		private TriState indent;

		private string indentChars;

		private bool newLineOnAttributes;

		private bool closeOutput;

		private ConformanceLevel conformanceLevel;

		private bool checkCharacters;

		private XmlOutputMethod outputMethod;

		private List<XmlQualifiedName> cdataSections = new List<XmlQualifiedName>();

		private bool doNotEscapeUriAttributes;

		private bool mergeCDataSections;

		private string mediaType;

		private string docTypeSystem;

		private string docTypePublic;

		private XmlStandalone standalone;

		private bool autoXmlDecl;

		private bool isReadOnly;

		public Encoding Encoding
		{
			get
			{
				return encoding;
			}
			set
			{
				CheckReadOnly("Encoding");
				encoding = value;
			}
		}

		public bool OmitXmlDeclaration
		{
			get
			{
				return omitXmlDecl;
			}
			set
			{
				CheckReadOnly("OmitXmlDeclaration");
				omitXmlDecl = value;
			}
		}

		public NewLineHandling NewLineHandling
		{
			get
			{
				return newLineHandling;
			}
			set
			{
				CheckReadOnly("NewLineHandling");
				if ((uint)value > 2u)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				newLineHandling = value;
			}
		}

		public string NewLineChars
		{
			get
			{
				return newLineChars;
			}
			set
			{
				CheckReadOnly("NewLineChars");
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				newLineChars = value;
			}
		}

		public bool Indent
		{
			get
			{
				return indent == TriState.True;
			}
			set
			{
				CheckReadOnly("Indent");
				indent = (value ? TriState.True : TriState.False);
			}
		}

		public string IndentChars
		{
			get
			{
				return indentChars;
			}
			set
			{
				CheckReadOnly("IndentChars");
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				indentChars = value;
			}
		}

		public bool NewLineOnAttributes
		{
			get
			{
				return newLineOnAttributes;
			}
			set
			{
				CheckReadOnly("NewLineOnAttributes");
				newLineOnAttributes = value;
			}
		}

		public bool CloseOutput
		{
			get
			{
				return closeOutput;
			}
			set
			{
				CheckReadOnly("CloseOutput");
				closeOutput = value;
			}
		}

		public ConformanceLevel ConformanceLevel
		{
			get
			{
				return conformanceLevel;
			}
			set
			{
				CheckReadOnly("ConformanceLevel");
				if ((uint)value > 2u)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				conformanceLevel = value;
			}
		}

		public bool CheckCharacters
		{
			get
			{
				return checkCharacters;
			}
			set
			{
				CheckReadOnly("CheckCharacters");
				checkCharacters = value;
			}
		}

		internal bool ReadOnly
		{
			get
			{
				return isReadOnly;
			}
			set
			{
				isReadOnly = value;
			}
		}

		public XmlOutputMethod OutputMethod
		{
			get
			{
				return outputMethod;
			}
			internal set
			{
				outputMethod = value;
			}
		}

		internal List<XmlQualifiedName> CDataSectionElements => cdataSections;

		public bool DoNotEscapeUriAttributes
		{
			get
			{
				return doNotEscapeUriAttributes;
			}
			set
			{
				CheckReadOnly("DoNotEscapeUriAttributes");
				doNotEscapeUriAttributes = value;
			}
		}

		internal bool MergeCDataSections
		{
			get
			{
				return mergeCDataSections;
			}
			set
			{
				CheckReadOnly("MergeCDataSections");
				mergeCDataSections = value;
			}
		}

		internal string MediaType
		{
			get
			{
				return mediaType;
			}
			set
			{
				CheckReadOnly("MediaType");
				mediaType = value;
			}
		}

		internal string DocTypeSystem
		{
			get
			{
				return docTypeSystem;
			}
			set
			{
				CheckReadOnly("DocTypeSystem");
				docTypeSystem = value;
			}
		}

		internal string DocTypePublic
		{
			get
			{
				return docTypePublic;
			}
			set
			{
				CheckReadOnly("DocTypePublic");
				docTypePublic = value;
			}
		}

		internal XmlStandalone Standalone
		{
			get
			{
				return standalone;
			}
			set
			{
				CheckReadOnly("Standalone");
				standalone = value;
			}
		}

		internal bool AutoXmlDeclaration
		{
			get
			{
				return autoXmlDecl;
			}
			set
			{
				CheckReadOnly("AutoXmlDeclaration");
				autoXmlDecl = value;
			}
		}

		internal TriState InternalIndent => indent;

		internal bool IsQuerySpecific
		{
			get
			{
				if (cdataSections.Count == 0 && docTypePublic == null && docTypeSystem == null)
				{
					return standalone == XmlStandalone.Yes;
				}
				return true;
			}
		}

		public XmlWriterSettings()
		{
			Reset();
		}

		public void Reset()
		{
			encoding = Encoding.UTF8;
			omitXmlDecl = false;
			newLineHandling = NewLineHandling.Replace;
			newLineChars = "\r\n";
			indent = TriState.Unknown;
			indentChars = "  ";
			newLineOnAttributes = false;
			closeOutput = false;
			conformanceLevel = ConformanceLevel.Document;
			checkCharacters = true;
			outputMethod = XmlOutputMethod.Xml;
			cdataSections.Clear();
			mergeCDataSections = false;
			mediaType = null;
			docTypeSystem = null;
			docTypePublic = null;
			standalone = XmlStandalone.Omit;
			isReadOnly = false;
		}

		public XmlWriterSettings Clone()
		{
			XmlWriterSettings xmlWriterSettings = MemberwiseClone() as XmlWriterSettings;
			xmlWriterSettings.cdataSections = new List<XmlQualifiedName>(cdataSections);
			xmlWriterSettings.isReadOnly = false;
			return xmlWriterSettings;
		}

		private void CheckReadOnly(string propertyName)
		{
			if (isReadOnly)
			{
				throw new XmlException("Xml_ReadOnlyProperty", "XmlWriterSettings." + propertyName);
			}
		}

		internal void GetObjectData(XmlQueryDataWriter writer)
		{
			writer.Write(encoding.CodePage);
			writer.Write(omitXmlDecl);
			writer.Write((sbyte)newLineHandling);
			writer.WriteStringQ(newLineChars);
			writer.Write((sbyte)indent);
			writer.WriteStringQ(indentChars);
			writer.Write(newLineOnAttributes);
			writer.Write(closeOutput);
			writer.Write((sbyte)conformanceLevel);
			writer.Write(checkCharacters);
			writer.Write((sbyte)outputMethod);
			writer.Write(cdataSections.Count);
			foreach (XmlQualifiedName cdataSection in cdataSections)
			{
				writer.Write(cdataSection.Name);
				writer.Write(cdataSection.Namespace);
			}
			writer.Write(mergeCDataSections);
			writer.WriteStringQ(mediaType);
			writer.WriteStringQ(docTypeSystem);
			writer.WriteStringQ(docTypePublic);
			writer.Write((sbyte)standalone);
			writer.Write(autoXmlDecl);
			writer.Write(isReadOnly);
		}

		internal XmlWriterSettings(XmlQueryDataReader reader)
		{
			encoding = Encoding.GetEncoding(reader.ReadInt32());
			omitXmlDecl = reader.ReadBoolean();
			newLineHandling = (NewLineHandling)reader.ReadSByte(0, 2);
			newLineChars = reader.ReadStringQ();
			indent = (TriState)reader.ReadSByte(-1, 1);
			indentChars = reader.ReadStringQ();
			newLineOnAttributes = reader.ReadBoolean();
			closeOutput = reader.ReadBoolean();
			conformanceLevel = (ConformanceLevel)reader.ReadSByte(0, 2);
			checkCharacters = reader.ReadBoolean();
			outputMethod = (XmlOutputMethod)reader.ReadSByte(0, 3);
			int num = reader.ReadInt32();
			cdataSections = new List<XmlQualifiedName>(num);
			for (int i = 0; i < num; i++)
			{
				cdataSections.Add(new XmlQualifiedName(reader.ReadString(), reader.ReadString()));
			}
			mergeCDataSections = reader.ReadBoolean();
			mediaType = reader.ReadStringQ();
			docTypeSystem = reader.ReadStringQ();
			docTypePublic = reader.ReadStringQ();
			Standalone = (XmlStandalone)reader.ReadSByte(0, 2);
			autoXmlDecl = reader.ReadBoolean();
			isReadOnly = reader.ReadBoolean();
		}
	}
	internal delegate void CachingEventHandler(XsdCachingReader cachingReader);
	internal class AttributePSVIInfo
	{
		internal string localName;

		internal string namespaceUri;

		internal object typedAttributeValue;

		internal XmlSchemaInfo attributeSchemaInfo;

		internal AttributePSVIInfo()
		{
			attributeSchemaInfo = new XmlSchemaInfo();
		}

		internal void Reset()
		{
			typedAttributeValue = null;
			localName = string.Empty;
			namespaceUri = string.Empty;
			attributeSchemaInfo.Clear();
		}
	}
}
namespace System.Xml.Schema
{
	public interface IXmlSchemaInfo
	{
		XmlSchemaValidity Validity { get; }

		bool IsDefault { get; }

		bool IsNil { get; }

		XmlSchemaSimpleType MemberType { get; }

		XmlSchemaType SchemaType { get; }

		XmlSchemaElement SchemaElement { get; }

		XmlSchemaAttribute SchemaAttribute { get; }
	}
}
namespace System.Xml
{
	internal class XsdValidatingReader : XmlReader, IXmlSchemaInfo, IXmlLineInfo, IXmlNamespaceResolver
	{
		private enum ValidatingReaderState
		{
			None = 0,
			Init = 1,
			Read = 2,
			OnDefaultAttribute = -1,
			OnReadAttributeValue = -2,
			OnAttribute = 3,
			ClearAttributes = 4,
			ParseInlineSchema = 5,
			ReadAhead = 6,
			OnReadBinaryContent = 7,
			ReaderClosed = 8,
			EOF = 9,
			Error = 10
		}

		private const int InitialAttributeCount = 8;

		private XmlReader coreReader;

		private IXmlNamespaceResolver coreReaderNSResolver;

		private IXmlNamespaceResolver thisNSResolver;

		private XmlSchemaValidator validator;

		private XmlResolver xmlResolver;

		private ValidationEventHandler validationEvent;

		private ValidatingReaderState validationState;

		private XmlValueGetter valueGetter;

		private XmlNamespaceManager nsManager;

		private bool manageNamespaces;

		private bool processInlineSchema;

		private bool replayCache;

		private ValidatingReaderNodeData cachedNode;

		private AttributePSVIInfo attributePSVI;

		private int attributeCount;

		private int coreReaderAttributeCount;

		private int currentAttrIndex;

		private AttributePSVIInfo[] attributePSVINodes;

		private ArrayList defaultAttributes;

		private Parser inlineSchemaParser;

		private object atomicValue;

		private XmlSchemaInfo xmlSchemaInfo;

		private string originalAtomicValueString;

		private XmlNameTable coreReaderNameTable;

		private XsdCachingReader cachingReader;

		private ValidatingReaderNodeData textNode;

		private string NsXmlNs;

		private string NsXs;

		private string NsXsi;

		private string XsiType;

		private string XsiNil;

		private string XsdSchema;

		private string XsiSchemaLocation;

		private string XsiNoNamespaceSchemaLocation;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		private IXmlLineInfo lineInfo;

		private ReadContentAsBinaryHelper readBinaryHelper;

		private ValidatingReaderState savedState;

		private static Type TypeOfString;

		public override XmlReaderSettings Settings
		{
			get
			{
				XmlReaderSettings xmlReaderSettings = coreReader.Settings;
				if (xmlReaderSettings != null)
				{
					xmlReaderSettings = xmlReaderSettings.Clone();
				}
				if (xmlReaderSettings == null)
				{
					xmlReaderSettings = new XmlReaderSettings();
				}
				xmlReaderSettings.Schemas = validator.SchemaSet;
				xmlReaderSettings.ValidationType = ValidationType.Schema;
				xmlReaderSettings.ValidationFlags = validator.ValidationFlags;
				xmlReaderSettings.ReadOnly = true;
				return xmlReaderSettings;
			}
		}

		public override XmlNodeType NodeType
		{
			get
			{
				if (validationState < ValidatingReaderState.None)
				{
					return cachedNode.NodeType;
				}
				return coreReader.NodeType;
			}
		}

		public override string Name
		{
			get
			{
				if (validationState == ValidatingReaderState.OnDefaultAttribute)
				{
					string defaultAttributePrefix = validator.GetDefaultAttributePrefix(cachedNode.Namespace);
					if (defaultAttributePrefix != null && defaultAttributePrefix.Length != 0)
					{
						return string.Concat(defaultAttributePrefix + ":" + cachedNode.LocalName);
					}
					return cachedNode.LocalName;
				}
				return coreReader.Name;
			}
		}

		public override string LocalName
		{
			get
			{
				if (validationState < ValidatingReaderState.None)
				{
					return cachedNode.LocalName;
				}
				return coreReader.LocalName;
			}
		}

		public override string NamespaceURI
		{
			get
			{
				if (validationState < ValidatingReaderState.None)
				{
					return cachedNode.Namespace;
				}
				return coreReader.NamespaceURI;
			}
		}

		public override string Prefix
		{
			get
			{
				if (validationState < ValidatingReaderState.None)
				{
					return cachedNode.Prefix;
				}
				return coreReader.Prefix;
			}
		}

		public override bool HasValue
		{
			get
			{
				if (validationState < ValidatingReaderState.None)
				{
					return true;
				}
				return coreReader.HasValue;
			}
		}

		public override string Value
		{
			get
			{
				if (validationState < ValidatingReaderState.None)
				{
					return cachedNode.RawValue;
				}
				return coreReader.Value;
			}
		}

		public override int Depth
		{
			get
			{
				if (validationState < ValidatingReaderState.None)
				{
					return cachedNode.Depth;
				}
				return coreReader.Depth;
			}
		}

		public override string BaseURI => coreReader.BaseURI;

		public override bool IsEmptyElement => coreReader.IsEmptyElement;

		public override bool IsDefault
		{
			get
			{
				if (validationState == ValidatingReaderState.OnDefaultAttribute)
				{
					return true;
				}
				return coreReader.IsDefault;
			}
		}

		public override char QuoteChar => coreReader.QuoteChar;

		public override XmlSpace XmlSpace => coreReader.XmlSpace;

		public override string XmlLang => coreReader.XmlLang;

		public override IXmlSchemaInfo SchemaInfo => this;

		public override Type ValueType
		{
			get
			{
				switch (NodeType)
				{
				case XmlNodeType.Element:
				case XmlNodeType.EndElement:
					if (xmlSchemaInfo.ContentType == XmlSchemaContentType.TextOnly)
					{
						return xmlSchemaInfo.SchemaType.Datatype.ValueType;
					}
					break;
				case XmlNodeType.Attribute:
					if (attributePSVI != null && AttributeSchemaInfo.ContentType == XmlSchemaContentType.TextOnly)
					{
						return AttributeSchemaInfo.SchemaType.Datatype.ValueType;
					}
					break;
				}
				return TypeOfString;
			}
		}

		public override int AttributeCount => attributeCount;

		public override bool EOF => coreReader.EOF;

		public override ReadState ReadState
		{
			get
			{
				if (validationState != ValidatingReaderState.Init)
				{
					return coreReader.ReadState;
				}
				return ReadState.Initial;
			}
		}

		public override XmlNameTable NameTable => coreReaderNameTable;

		public override bool CanReadBinaryContent => true;

		bool IXmlSchemaInfo.IsDefault
		{
			get
			{
				switch (NodeType)
				{
				case XmlNodeType.Element:
					if (!coreReader.IsEmptyElement)
					{
						GetIsDefault();
					}
					return xmlSchemaInfo.IsDefault;
				case XmlNodeType.EndElement:
					return xmlSchemaInfo.IsDefault;
				case XmlNodeType.Attribute:
					if (attributePSVI != null)
					{
						return AttributeSchemaInfo.IsDefault;
					}
					break;
				}
				return false;
			}
		}

		bool IXmlSchemaInfo.IsNil
		{
			get
			{
				XmlNodeType nodeType = NodeType;
				if (nodeType == XmlNodeType.Element || nodeType == XmlNodeType.EndElement)
				{
					return xmlSchemaInfo.IsNil;
				}
				return false;
			}
		}

		XmlSchemaValidity IXmlSchemaInfo.Validity
		{
			get
			{
				switch (NodeType)
				{
				case XmlNodeType.Element:
					if (coreReader.IsEmptyElement)
					{
						return xmlSchemaInfo.Validity;
					}
					if (xmlSchemaInfo.Validity == XmlSchemaValidity.Valid)
					{
						return XmlSchemaValidity.NotKnown;
					}
					return xmlSchemaInfo.Validity;
				case XmlNodeType.EndElement:
					return xmlSchemaInfo.Validity;
				case XmlNodeType.Attribute:
					if (attributePSVI != null)
					{
						return AttributeSchemaInfo.Validity;
					}
					break;
				}
				return XmlSchemaValidity.NotKnown;
			}
		}

		XmlSchemaSimpleType IXmlSchemaInfo.MemberType
		{
			get
			{
				switch (NodeType)
				{
				case XmlNodeType.Element:
					if (!coreReader.IsEmptyElement)
					{
						GetMemberType();
					}
					return xmlSchemaInfo.MemberType;
				case XmlNodeType.EndElement:
					return xmlSchemaInfo.MemberType;
				case XmlNodeType.Attribute:
					if (attributePSVI != null)
					{
						return AttributeSchemaInfo.MemberType;
					}
					return null;
				default:
					return null;
				}
			}
		}

		XmlSchemaType IXmlSchemaInfo.SchemaType
		{
			get
			{
				switch (NodeType)
				{
				case XmlNodeType.Element:
				case XmlNodeType.EndElement:
					return xmlSchemaInfo.SchemaType;
				case XmlNodeType.Attribute:
					if (attributePSVI != null)
					{
						return AttributeSchemaInfo.SchemaType;
					}
					return null;
				default:
					return null;
				}
			}
		}

		XmlSchemaElement IXmlSchemaInfo.SchemaElement
		{
			get
			{
				if (NodeType == XmlNodeType.Element || NodeType == XmlNodeType.EndElement)
				{
					return xmlSchemaInfo.SchemaElement;
				}
				return null;
			}
		}

		XmlSchemaAttribute IXmlSchemaInfo.SchemaAttribute
		{
			get
			{
				if (NodeType == XmlNodeType.Attribute && attributePSVI != null)
				{
					return AttributeSchemaInfo.SchemaAttribute;
				}
				return null;
			}
		}

		public int LineNumber
		{
			get
			{
				if (lineInfo != null)
				{
					return lineInfo.LineNumber;
				}
				return 0;
			}
		}

		public int LinePosition
		{
			get
			{
				if (lineInfo != null)
				{
					return lineInfo.LinePosition;
				}
				return 0;
			}
		}

		private XmlSchemaType ElementXmlType => xmlSchemaInfo.XmlType;

		private XmlSchemaType AttributeXmlType
		{
			get
			{
				if (attributePSVI != null)
				{
					return AttributeSchemaInfo.XmlType;
				}
				return null;
			}
		}

		private XmlSchemaInfo AttributeSchemaInfo => attributePSVI.attributeSchemaInfo;

		internal XsdValidatingReader(XmlReader reader, XmlResolver xmlResolver, XmlReaderSettings readerSettings, XmlSchemaObject partialValidationType)
		{
			coreReader = reader;
			coreReaderNSResolver = reader as IXmlNamespaceResolver;
			lineInfo = reader as IXmlLineInfo;
			coreReaderNameTable = coreReader.NameTable;
			if (coreReaderNSResolver == null)
			{
				nsManager = new XmlNamespaceManager(coreReaderNameTable);
				manageNamespaces = true;
			}
			thisNSResolver = this;
			this.xmlResolver = xmlResolver;
			processInlineSchema = (readerSettings.ValidationFlags & XmlSchemaValidationFlags.ProcessInlineSchema) != 0;
			Init();
			SetupValidator(readerSettings, reader, partialValidationType);
			validationEvent = readerSettings.GetEventHandler();
		}

		internal XsdValidatingReader(XmlReader reader, XmlResolver xmlResolver, XmlReaderSettings readerSettings)
			: this(reader, xmlResolver, readerSettings, null)
		{
		}

		private void Init()
		{
			validationState = ValidatingReaderState.Init;
			defaultAttributes = new ArrayList();
			currentAttrIndex = -1;
			attributePSVINodes = new AttributePSVIInfo[8];
			valueGetter = GetStringValue;
			TypeOfString = typeof(string);
			xmlSchemaInfo = new XmlSchemaInfo();
			NsXmlNs = coreReaderNameTable.Add("http://www.w3.org/2000/xmlns/");
			NsXs = coreReaderNameTable.Add("http://www.w3.org/2001/XMLSchema");
			NsXsi = coreReaderNameTable.Add("http://www.w3.org/2001/XMLSchema-instance");
			XsiType = coreReaderNameTable.Add("type");
			XsiNil = coreReaderNameTable.Add("nil");
			XsiSchemaLocation = coreReaderNameTable.Add("schemaLocation");
			XsiNoNamespaceSchemaLocation = coreReaderNameTable.Add("noNamespaceSchemaLocation");
			XsdSchema = coreReaderNameTable.Add("schema");
		}

		private void SetupValidator(XmlReaderSettings readerSettings, XmlReader reader, XmlSchemaObject partialValidationType)
		{
			validator = new XmlSchemaValidator(coreReaderNameTable, readerSettings.Schemas, thisNSResolver, readerSettings.ValidationFlags);
			validator.XmlResolver = xmlResolver;
			validator.SourceUri = XmlConvert.ToUri(reader.BaseURI);
			validator.ValidationEventSender = this;
			validator.ValidationEventHandler += readerSettings.GetEventHandler();
			validator.LineInfoProvider = lineInfo;
			if (validator.ProcessSchemaHints)
			{
				validator.SchemaSet.ReaderSettings.ProhibitDtd = readerSettings.ProhibitDtd;
			}
			validator.SetDtdSchemaInfo(XmlReader.GetDtdSchemaInfo(reader));
			if (partialValidationType != null)
			{
				validator.Initialize(partialValidationType);
			}
			else
			{
				validator.Initialize();
			}
		}

		public override object ReadContentAsObject()
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException("ReadContentAsObject");
			}
			return InternalReadContentAsObject(unwrapTypedValue: true);
		}

		public override bool ReadContentAsBoolean()
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException("ReadContentAsBoolean");
			}
			object value = InternalReadContentAsObject();
			XmlSchemaType xmlSchemaType = ((NodeType == XmlNodeType.Attribute) ? AttributeXmlType : ElementXmlType);
			try
			{
				return xmlSchemaType?.ValueConverter.ToBoolean(value) ?? XmlUntypedConverter.Untyped.ToBoolean(value);
			}
			catch (InvalidCastException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Boolean", innerException, this);
			}
			catch (FormatException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Boolean", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Boolean", innerException3, this);
			}
		}

		public override DateTime ReadContentAsDateTime()
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException("ReadContentAsDateTime");
			}
			object value = InternalReadContentAsObject();
			XmlSchemaType xmlSchemaType = ((NodeType == XmlNodeType.Attribute) ? AttributeXmlType : ElementXmlType);
			try
			{
				return xmlSchemaType?.ValueConverter.ToDateTime(value) ?? XmlUntypedConverter.Untyped.ToDateTime(value);
			}
			catch (InvalidCastException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "DateTime", innerException, this);
			}
			catch (FormatException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "DateTime", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "DateTime", innerException3, this);
			}
		}

		public override double ReadContentAsDouble()
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException("ReadContentAsDouble");
			}
			object value = InternalReadContentAsObject();
			XmlSchemaType xmlSchemaType = ((NodeType == XmlNodeType.Attribute) ? AttributeXmlType : ElementXmlType);
			try
			{
				return xmlSchemaType?.ValueConverter.ToDouble(value) ?? XmlUntypedConverter.Untyped.ToDouble(value);
			}
			catch (InvalidCastException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Double", innerException, this);
			}
			catch (FormatException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Double", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Double", innerException3, this);
			}
		}

		public override float ReadContentAsFloat()
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException("ReadContentAsFloat");
			}
			object value = InternalReadContentAsObject();
			XmlSchemaType xmlSchemaType = ((NodeType == XmlNodeType.Attribute) ? AttributeXmlType : ElementXmlType);
			try
			{
				return xmlSchemaType?.ValueConverter.ToSingle(value) ?? XmlUntypedConverter.Untyped.ToSingle(value);
			}
			catch (InvalidCastException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Float", innerException, this);
			}
			catch (FormatException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Float", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Float", innerException3, this);
			}
		}

		public override decimal ReadContentAsDecimal()
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException("ReadContentAsDecimal");
			}
			object value = InternalReadContentAsObject();
			XmlSchemaType xmlSchemaType = ((NodeType == XmlNodeType.Attribute) ? AttributeXmlType : ElementXmlType);
			try
			{
				return xmlSchemaType?.ValueConverter.ToDecimal(value) ?? XmlUntypedConverter.Untyped.ToDecimal(value);
			}
			catch (InvalidCastException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Decimal", innerException, this);
			}
			catch (FormatException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Decimal", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Decimal", innerException3, this);
			}
		}

		public override int ReadContentAsInt()
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException("ReadContentAsInt");
			}
			object value = InternalReadContentAsObject();
			XmlSchemaType xmlSchemaType = ((NodeType == XmlNodeType.Attribute) ? AttributeXmlType : ElementXmlType);
			try
			{
				return xmlSchemaType?.ValueConverter.ToInt32(value) ?? XmlUntypedConverter.Untyped.ToInt32(value);
			}
			catch (InvalidCastException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Int", innerException, this);
			}
			catch (FormatException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Int", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Int", innerException3, this);
			}
		}

		public override long ReadContentAsLong()
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException("ReadContentAsLong");
			}
			object value = InternalReadContentAsObject();
			XmlSchemaType xmlSchemaType = ((NodeType == XmlNodeType.Attribute) ? AttributeXmlType : ElementXmlType);
			try
			{
				return xmlSchemaType?.ValueConverter.ToInt64(value) ?? XmlUntypedConverter.Untyped.ToInt64(value);
			}
			catch (InvalidCastException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Long", innerException, this);
			}
			catch (FormatException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Long", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Long", innerException3, this);
			}
		}

		public override string ReadContentAsString()
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException("ReadContentAsString");
			}
			object obj = InternalReadContentAsObject();
			XmlSchemaType xmlSchemaType = ((NodeType == XmlNodeType.Attribute) ? AttributeXmlType : ElementXmlType);
			try
			{
				if (xmlSchemaType != null)
				{
					return xmlSchemaType.ValueConverter.ToString(obj);
				}
				return obj as string;
			}
			catch (InvalidCastException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "String", innerException, this);
			}
			catch (FormatException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "String", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "String", innerException3, this);
			}
		}

		public override object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver)
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException("ReadContentAs");
			}
			string originalStringValue;
			object value = InternalReadContentAsObject(unwrapTypedValue: false, out originalStringValue);
			XmlSchemaType xmlSchemaType = ((NodeType == XmlNodeType.Attribute) ? AttributeXmlType : ElementXmlType);
			try
			{
				if (xmlSchemaType != null)
				{
					if (returnType == typeof(DateTimeOffset) && xmlSchemaType.Datatype is Datatype_dateTimeBase)
					{
						value = originalStringValue;
					}
					return xmlSchemaType.ValueConverter.ChangeType(value, returnType);
				}
				return XmlUntypedConverter.Untyped.ChangeType(value, returnType, namespaceResolver);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException, this);
			}
			catch (InvalidCastException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException3, this);
			}
		}

		public override object ReadElementContentAsObject()
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException("ReadElementContentAsObject");
			}
			XmlSchemaType xmlType;
			return InternalReadElementContentAsObject(out xmlType, unwrapTypedValue: true);
		}

		public override bool ReadElementContentAsBoolean()
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException("ReadElementContentAsBoolean");
			}
			XmlSchemaType xmlType;
			object value = InternalReadElementContentAsObject(out xmlType);
			try
			{
				return xmlType?.ValueConverter.ToBoolean(value) ?? XmlUntypedConverter.Untyped.ToBoolean(value);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Boolean", innerException, this);
			}
			catch (InvalidCastException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Boolean", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Boolean", innerException3, this);
			}
		}

		public override DateTime ReadElementContentAsDateTime()
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException("ReadElementContentAsDateTime");
			}
			XmlSchemaType xmlType;
			object value = InternalReadElementContentAsObject(out xmlType);
			try
			{
				return xmlType?.ValueConverter.ToDateTime(value) ?? XmlUntypedConverter.Untyped.ToDateTime(value);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "DateTime", innerException, this);
			}
			catch (InvalidCastException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "DateTime", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "DateTime", innerException3, this);
			}
		}

		public override double ReadElementContentAsDouble()
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException("ReadElementContentAsDouble");
			}
			XmlSchemaType xmlType;
			object value = InternalReadElementContentAsObject(out xmlType);
			try
			{
				return xmlType?.ValueConverter.ToDouble(value) ?? XmlUntypedConverter.Untyped.ToDouble(value);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Double", innerException, this);
			}
			catch (InvalidCastException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Double", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Double", innerException3, this);
			}
		}

		public override float ReadElementContentAsFloat()
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException("ReadElementContentAsFloat");
			}
			XmlSchemaType xmlType;
			object value = InternalReadElementContentAsObject(out xmlType);
			try
			{
				return xmlType?.ValueConverter.ToSingle(value) ?? XmlUntypedConverter.Untyped.ToSingle(value);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Float", innerException, this);
			}
			catch (InvalidCastException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Float", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Float", innerException3, this);
			}
		}

		public override decimal ReadElementContentAsDecimal()
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException("ReadElementContentAsDecimal");
			}
			XmlSchemaType xmlType;
			object value = InternalReadElementContentAsObject(out xmlType);
			try
			{
				return xmlType?.ValueConverter.ToDecimal(value) ?? XmlUntypedConverter.Untyped.ToDecimal(value);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Decimal", innerException, this);
			}
			catch (InvalidCastException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Decimal", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Decimal", innerException3, this);
			}
		}

		public override int ReadElementContentAsInt()
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException("ReadElementContentAsInt");
			}
			XmlSchemaType xmlType;
			object value = InternalReadElementContentAsObject(out xmlType);
			try
			{
				return xmlType?.ValueConverter.ToInt32(value) ?? XmlUntypedConverter.Untyped.ToInt32(value);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Int", innerException, this);
			}
			catch (InvalidCastException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Int", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Int", innerException3, this);
			}
		}

		public override long ReadElementContentAsLong()
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException("ReadElementContentAsLong");
			}
			XmlSchemaType xmlType;
			object value = InternalReadElementContentAsObject(out xmlType);
			try
			{
				return xmlType?.ValueConverter.ToInt64(value) ?? XmlUntypedConverter.Untyped.ToInt64(value);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Long", innerException, this);
			}
			catch (InvalidCastException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Long", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "Long", innerException3, this);
			}
		}

		public override string ReadElementContentAsString()
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException("ReadElementContentAsString");
			}
			XmlSchemaType xmlType;
			object obj = InternalReadElementContentAsObject(out xmlType);
			try
			{
				if (xmlType != null)
				{
					return xmlType.ValueConverter.ToString(obj);
				}
				return obj as string;
			}
			catch (InvalidCastException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "String", innerException, this);
			}
			catch (FormatException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "String", innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", "String", innerException3, this);
			}
		}

		public override object ReadElementContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver)
		{
			if (NodeType != XmlNodeType.Element)
			{
				throw CreateReadElementContentAsException("ReadElementContentAs");
			}
			XmlSchemaType xmlType;
			string originalString;
			object value = InternalReadElementContentAsObject(out xmlType, unwrapTypedValue: false, out originalString);
			try
			{
				if (xmlType != null)
				{
					if (returnType == typeof(DateTimeOffset) && xmlType.Datatype is Datatype_dateTimeBase)
					{
						value = originalString;
					}
					return xmlType.ValueConverter.ChangeType(value, returnType, namespaceResolver);
				}
				return XmlUntypedConverter.Untyped.ChangeType(value, returnType, namespaceResolver);
			}
			catch (FormatException innerException)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException, this);
			}
			catch (InvalidCastException innerException2)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException2, this);
			}
			catch (OverflowException innerException3)
			{
				throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException3, this);
			}
		}

		public override string GetAttribute(string name)
		{
			string text = coreReader.GetAttribute(name);
			if (text == null && attributeCount > 0)
			{
				ValidatingReaderNodeData defaultAttribute = GetDefaultAttribute(name, updatePosition: false);
				if (defaultAttribute != null)
				{
					text = defaultAttribute.RawValue;
				}
			}
			return text;
		}

		public override string GetAttribute(string name, string namespaceURI)
		{
			string attribute = coreReader.GetAttribute(name, namespaceURI);
			if (attribute == null && attributeCount > 0)
			{
				namespaceURI = ((namespaceURI == null) ? string.Empty : coreReaderNameTable.Get(namespaceURI));
				name = coreReaderNameTable.Get(name);
				if (name == null || namespaceURI == null)
				{
					return null;
				}
				ValidatingReaderNodeData defaultAttribute = GetDefaultAttribute(name, namespaceURI, updatePosition: false);
				if (defaultAttribute != null)
				{
					return defaultAttribute.RawValue;
				}
			}
			return attribute;
		}

		public override string GetAttribute(int i)
		{
			if (attributeCount == 0)
			{
				return null;
			}
			if (i < coreReaderAttributeCount)
			{
				return coreReader.GetAttribute(i);
			}
			int index = i - coreReaderAttributeCount;
			ValidatingReaderNodeData validatingReaderNodeData = (ValidatingReaderNodeData)defaultAttributes[index];
			return validatingReaderNodeData.RawValue;
		}

		public override bool MoveToAttribute(string name)
		{
			if (coreReader.MoveToAttribute(name))
			{
				validationState = ValidatingReaderState.OnAttribute;
				attributePSVI = GetAttributePSVI(name);
				goto IL_0057;
			}
			if (attributeCount > 0)
			{
				ValidatingReaderNodeData defaultAttribute = GetDefaultAttribute(name, updatePosition: true);
				if (defaultAttribute != null)
				{
					validationState = ValidatingReaderState.OnDefaultAttribute;
					attributePSVI = defaultAttribute.AttInfo;
					cachedNode = defaultAttribute;
					goto IL_0057;
				}
			}
			return false;
			IL_0057:
			if (validationState == ValidatingReaderState.OnReadBinaryContent)
			{
				readBinaryHelper.Finish();
				validationState = savedState;
			}
			return true;
		}

		public override bool MoveToAttribute(string name, string ns)
		{
			name = coreReaderNameTable.Get(name);
			ns = ((ns != null) ? coreReaderNameTable.Get(ns) : string.Empty);
			if (name == null || ns == null)
			{
				return false;
			}
			if (coreReader.MoveToAttribute(name, ns))
			{
				validationState = ValidatingReaderState.OnAttribute;
				if (inlineSchemaParser == null)
				{
					attributePSVI = GetAttributePSVI(name, ns);
				}
				else
				{
					attributePSVI = null;
				}
			}
			else
			{
				ValidatingReaderNodeData defaultAttribute = GetDefaultAttribute(name, ns, updatePosition: true);
				if (defaultAttribute == null)
				{
					return false;
				}
				attributePSVI = defaultAttribute.AttInfo;
				cachedNode = defaultAttribute;
				validationState = ValidatingReaderState.OnDefaultAttribute;
			}
			if (validationState == ValidatingReaderState.OnReadBinaryContent)
			{
				readBinaryHelper.Finish();
				validationState = savedState;
			}
			return true;
		}

		public override void MoveToAttribute(int i)
		{
			if (i < 0 || i >= attributeCount)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			if (i < coreReaderAttributeCount)
			{
				coreReader.MoveToAttribute(i);
				if (inlineSchemaParser == null)
				{
					attributePSVI = attributePSVINodes[i];
				}
				else
				{
					attributePSVI = null;
				}
				validationState = ValidatingReaderState.OnAttribute;
			}
			else
			{
				int index = i - coreReaderAttributeCount;
				cachedNode = (ValidatingReaderNodeData)defaultAttributes[index];
				attributePSVI = cachedNode.AttInfo;
				validationState = ValidatingReaderState.OnDefaultAttribute;
			}
			if (validationState == ValidatingReaderState.OnReadBinaryContent)
			{
				readBinaryHelper.Finish();
				validationState = savedState;
			}
		}

		public override bool MoveToFirstAttribute()
		{
			if (coreReader.MoveToFirstAttribute())
			{
				currentAttrIndex = 0;
				if (inlineSchemaParser == null)
				{
					attributePSVI = attributePSVINodes[0];
				}
				else
				{
					attributePSVI = null;
				}
				validationState = ValidatingReaderState.OnAttribute;
			}
			else
			{
				if (defaultAttributes.Count <= 0)
				{
					return false;
				}
				cachedNode = (ValidatingReaderNodeData)defaultAttributes[0];
				attributePSVI = cachedNode.AttInfo;
				currentAttrIndex = 0;
				validationState = ValidatingReaderState.OnDefaultAttribute;
			}
			if (validationState == ValidatingReaderState.OnReadBinaryContent)
			{
				readBinaryHelper.Finish();
				validationState = savedState;
			}
			return true;
		}

		public override bool MoveToNextAttribute()
		{
			if (currentAttrIndex + 1 < coreReaderAttributeCount)
			{
				coreReader.MoveToNextAttribute();
				currentAttrIndex++;
				if (inlineSchemaParser == null)
				{
					attributePSVI = attributePSVINodes[currentAttrIndex];
				}
				else
				{
					attributePSVI = null;
				}
				validationState = ValidatingReaderState.OnAttribute;
			}
			else
			{
				if (currentAttrIndex + 1 >= attributeCount)
				{
					return false;
				}
				int index = ++currentAttrIndex - coreReaderAttributeCount;
				cachedNode = (ValidatingReaderNodeData)defaultAttributes[index];
				attributePSVI = cachedNode.AttInfo;
				validationState = ValidatingReaderState.OnDefaultAttribute;
			}
			if (validationState == ValidatingReaderState.OnReadBinaryContent)
			{
				readBinaryHelper.Finish();
				validationState = savedState;
			}
			return true;
		}

		public override bool MoveToElement()
		{
			if (coreReader.MoveToElement() || validationState < ValidatingReaderState.None)
			{
				currentAttrIndex = -1;
				validationState = ValidatingReaderState.ClearAttributes;
				return true;
			}
			return false;
		}

		public override bool Read()
		{
			switch (validationState)
			{
			case ValidatingReaderState.Read:
				if (coreReader.Read())
				{
					ProcessReaderEvent();
					return true;
				}
				validator.EndValidation();
				if (coreReader.EOF)
				{
					validationState = ValidatingReaderState.EOF;
				}
				return false;
			case ValidatingReaderState.ParseInlineSchema:
				ProcessInlineSchema();
				return true;
			case ValidatingReaderState.OnReadAttributeValue:
			case ValidatingReaderState.OnDefaultAttribute:
			case ValidatingReaderState.OnAttribute:
			case ValidatingReaderState.ClearAttributes:
				ClearAttributesInfo();
				if (inlineSchemaParser != null)
				{
					validationState = ValidatingReaderState.ParseInlineSchema;
					goto case ValidatingReaderState.ParseInlineSchema;
				}
				validationState = ValidatingReaderState.Read;
				goto case ValidatingReaderState.Read;
			case ValidatingReaderState.ReadAhead:
				ClearAttributesInfo();
				ProcessReaderEvent();
				validationState = ValidatingReaderState.Read;
				return true;
			case ValidatingReaderState.OnReadBinaryContent:
				validationState = savedState;
				readBinaryHelper.Finish();
				return Read();
			case ValidatingReaderState.Init:
				validationState = ValidatingReaderState.Read;
				if (coreReader.ReadState == ReadState.Interactive)
				{
					ProcessReaderEvent();
					return true;
				}
				goto case ValidatingReaderState.Read;
			case ValidatingReaderState.ReaderClosed:
			case ValidatingReaderState.EOF:
				return false;
			default:
				return false;
			}
		}

		public override void Close()
		{
			coreReader.Close();
			validationState = ValidatingReaderState.ReaderClosed;
		}

		public override void Skip()
		{
			_ = Depth;
			switch (NodeType)
			{
			case XmlNodeType.Element:
				if (!coreReader.IsEmptyElement)
				{
					bool flag = true;
					if ((xmlSchemaInfo.IsUnionType || xmlSchemaInfo.IsDefault) && coreReader is XsdCachingReader)
					{
						flag = false;
					}
					coreReader.Skip();
					validationState = ValidatingReaderState.ReadAhead;
					if (flag)
					{
						validator.SkipToEndElement(xmlSchemaInfo);
					}
				}
				break;
			case XmlNodeType.Attribute:
				MoveToElement();
				goto case XmlNodeType.Element;
			}
			Read();
		}

		public override string LookupNamespace(string prefix)
		{
			return thisNSResolver.LookupNamespace(prefix);
		}

		public override void ResolveEntity()
		{
			throw new InvalidOperationException();
		}

		public override bool ReadAttributeValue()
		{
			if (validationState == ValidatingReaderState.OnReadBinaryContent)
			{
				readBinaryHelper.Finish();
				validationState = savedState;
			}
			if (NodeType == XmlNodeType.Attribute)
			{
				if (validationState == ValidatingReaderState.OnDefaultAttribute)
				{
					cachedNode = CreateDummyTextNode(cachedNode.RawValue, cachedNode.Depth + 1);
					validationState = ValidatingReaderState.OnReadAttributeValue;
					return true;
				}
				return coreReader.ReadAttributeValue();
			}
			return false;
		}

		public override int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (validationState != ValidatingReaderState.OnReadBinaryContent)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
				savedState = validationState;
			}
			validationState = savedState;
			int result = readBinaryHelper.ReadContentAsBase64(buffer, index, count);
			savedState = validationState;
			validationState = ValidatingReaderState.OnReadBinaryContent;
			return result;
		}

		public override int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (validationState != ValidatingReaderState.OnReadBinaryContent)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
				savedState = validationState;
			}
			validationState = savedState;
			int result = readBinaryHelper.ReadContentAsBinHex(buffer, index, count);
			savedState = validationState;
			validationState = ValidatingReaderState.OnReadBinaryContent;
			return result;
		}

		public override int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (validationState != ValidatingReaderState.OnReadBinaryContent)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
				savedState = validationState;
			}
			validationState = savedState;
			int result = readBinaryHelper.ReadElementContentAsBase64(buffer, index, count);
			savedState = validationState;
			validationState = ValidatingReaderState.OnReadBinaryContent;
			return result;
		}

		public override int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (validationState != ValidatingReaderState.OnReadBinaryContent)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
				savedState = validationState;
			}
			validationState = savedState;
			int result = readBinaryHelper.ReadElementContentAsBinHex(buffer, index, count);
			savedState = validationState;
			validationState = ValidatingReaderState.OnReadBinaryContent;
			return result;
		}

		public bool HasLineInfo()
		{
			return true;
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			if (coreReaderNSResolver != null)
			{
				return coreReaderNSResolver.GetNamespacesInScope(scope);
			}
			return nsManager.GetNamespacesInScope(scope);
		}

		string IXmlNamespaceResolver.LookupNamespace(string prefix)
		{
			if (coreReaderNSResolver != null)
			{
				return coreReaderNSResolver.LookupNamespace(prefix);
			}
			return nsManager.LookupNamespace(prefix);
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			if (coreReaderNSResolver != null)
			{
				return coreReaderNSResolver.LookupPrefix(namespaceName);
			}
			return nsManager.LookupPrefix(namespaceName);
		}

		private object GetStringValue()
		{
			return coreReader.Value;
		}

		private void ProcessReaderEvent()
		{
			if (!replayCache)
			{
				switch (coreReader.NodeType)
				{
				case XmlNodeType.Element:
					ProcessElementEvent();
					break;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					validator.ValidateWhitespace(GetStringValue);
					break;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
					validator.ValidateText(GetStringValue);
					break;
				case XmlNodeType.EndElement:
					ProcessEndElementEvent();
					break;
				case XmlNodeType.EntityReference:
					throw new InvalidOperationException();
				case XmlNodeType.DocumentType:
					validator.SetDtdSchemaInfo(XmlReader.GetDtdSchemaInfo(coreReader));
					break;
				case XmlNodeType.Attribute:
				case XmlNodeType.Entity:
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.Comment:
				case XmlNodeType.Document:
				case XmlNodeType.DocumentFragment:
				case XmlNodeType.Notation:
					break;
				}
			}
		}

		private void ProcessElementEvent()
		{
			if (processInlineSchema && IsXSDRoot(coreReader.LocalName, coreReader.NamespaceURI) && coreReader.Depth > 0)
			{
				xmlSchemaInfo.Clear();
				attributeCount = (coreReaderAttributeCount = coreReader.AttributeCount);
				if (!coreReader.IsEmptyElement)
				{
					inlineSchemaParser = new Parser(SchemaType.XSD, coreReaderNameTable, validator.SchemaSet.GetSchemaNames(coreReaderNameTable), validationEvent);
					inlineSchemaParser.StartParsing(coreReader, null);
					inlineSchemaParser.ParseReaderNode();
					validationState = ValidatingReaderState.ParseInlineSchema;
				}
				else
				{
					validationState = ValidatingReaderState.ClearAttributes;
				}
				return;
			}
			atomicValue = null;
			originalAtomicValueString = null;
			xmlSchemaInfo.Clear();
			if (manageNamespaces)
			{
				nsManager.PushScope();
			}
			string xsiSchemaLocation = null;
			string xsiNoNamespaceSchemaLocation = null;
			string xsiNil = null;
			string xsiType = null;
			if (coreReader.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = coreReader.NamespaceURI;
					string localName = coreReader.LocalName;
					if (Ref.Equal(namespaceURI, NsXsi))
					{
						if (Ref.Equal(localName, XsiSchemaLocation))
						{
							xsiSchemaLocation = coreReader.Value;
						}
						else if (Ref.Equal(localName, XsiNoNamespaceSchemaLocation))
						{
							xsiNoNamespaceSchemaLocation = coreReader.Value;
						}
						else if (Ref.Equal(localName, XsiType))
						{
							xsiType = coreReader.Value;
						}
						else if (Ref.Equal(localName, XsiNil))
						{
							xsiNil = coreReader.Value;
						}
					}
					if (manageNamespaces && Ref.Equal(coreReader.NamespaceURI, NsXmlNs))
					{
						nsManager.AddNamespace((coreReader.Prefix.Length == 0) ? string.Empty : coreReader.LocalName, coreReader.Value);
					}
				}
				while (coreReader.MoveToNextAttribute());
				coreReader.MoveToElement();
			}
			validator.ValidateElement(coreReader.LocalName, coreReader.NamespaceURI, xmlSchemaInfo, xsiType, xsiNil, xsiSchemaLocation, xsiNoNamespaceSchemaLocation);
			ValidateAttributes();
			validator.ValidateEndOfAttributes(xmlSchemaInfo);
			if (coreReader.IsEmptyElement)
			{
				ProcessEndElementEvent();
			}
			validationState = ValidatingReaderState.ClearAttributes;
		}

		private void ProcessEndElementEvent()
		{
			atomicValue = validator.ValidateEndElement(xmlSchemaInfo);
			originalAtomicValueString = GetOriginalAtomicValueStringOfElement();
			if (xmlSchemaInfo.IsDefault)
			{
				int depth = coreReader.Depth;
				coreReader = GetCachingReader();
				cachingReader.RecordTextNode(xmlSchemaInfo.XmlType.ValueConverter.ToString(atomicValue), originalAtomicValueString, depth + 1, 0, 0);
				cachingReader.RecordEndElementNode();
				cachingReader.SetToReplayMode();
				replayCache = true;
			}
			else if (manageNamespaces)
			{
				nsManager.PopScope();
			}
		}

		private void ValidateAttributes()
		{
			attributeCount = (coreReaderAttributeCount = coreReader.AttributeCount);
			int num = 0;
			bool flag = false;
			if (coreReader.MoveToFirstAttribute())
			{
				do
				{
					string localName = coreReader.LocalName;
					string namespaceURI = coreReader.NamespaceURI;
					AttributePSVIInfo attributePSVIInfo = AddAttributePSVI(num);
					attributePSVIInfo.localName = localName;
					attributePSVIInfo.namespaceUri = namespaceURI;
					if ((object)namespaceURI == NsXmlNs)
					{
						num++;
						continue;
					}
					attributePSVIInfo.typedAttributeValue = validator.ValidateAttribute(localName, namespaceURI, valueGetter, attributePSVIInfo.attributeSchemaInfo);
					if (!flag)
					{
						flag = attributePSVIInfo.attributeSchemaInfo.Validity == XmlSchemaValidity.Invalid;
					}
					num++;
				}
				while (coreReader.MoveToNextAttribute());
			}
			coreReader.MoveToElement();
			if (flag)
			{
				xmlSchemaInfo.Validity = XmlSchemaValidity.Invalid;
			}
			validator.GetUnspecifiedDefaultAttributes(defaultAttributes, createNodeData: true);
			attributeCount += defaultAttributes.Count;
		}

		private void ClearAttributesInfo()
		{
			attributeCount = 0;
			coreReaderAttributeCount = 0;
			currentAttrIndex = -1;
			defaultAttributes.Clear();
			attributePSVI = null;
		}

		private AttributePSVIInfo GetAttributePSVI(string name)
		{
			if (inlineSchemaParser != null)
			{
				return null;
			}
			ValidateNames.SplitQName(name, out var prefix, out var lname);
			prefix = coreReaderNameTable.Add(prefix);
			lname = coreReaderNameTable.Add(lname);
			string ns = ((prefix.Length != 0) ? thisNSResolver.LookupNamespace(prefix) : string.Empty);
			return GetAttributePSVI(lname, ns);
		}

		private AttributePSVIInfo GetAttributePSVI(string localName, string ns)
		{
			AttributePSVIInfo attributePSVIInfo = null;
			for (int i = 0; i < coreReaderAttributeCount; i++)
			{
				attributePSVIInfo = attributePSVINodes[i];
				if (attributePSVIInfo != null && Ref.Equal(localName, attributePSVIInfo.localName) && Ref.Equal(ns, attributePSVIInfo.namespaceUri))
				{
					currentAttrIndex = i;
					return attributePSVIInfo;
				}
			}
			return null;
		}

		private ValidatingReaderNodeData GetDefaultAttribute(string name, bool updatePosition)
		{
			ValidateNames.SplitQName(name, out var prefix, out var lname);
			prefix = coreReaderNameTable.Add(prefix);
			lname = coreReaderNameTable.Add(lname);
			string ns = ((prefix.Length != 0) ? thisNSResolver.LookupNamespace(prefix) : string.Empty);
			return GetDefaultAttribute(lname, ns, updatePosition);
		}

		private ValidatingReaderNodeData GetDefaultAttribute(string attrLocalName, string ns, bool updatePosition)
		{
			ValidatingReaderNodeData validatingReaderNodeData = null;
			for (int i = 0; i < defaultAttributes.Count; i++)
			{
				validatingReaderNodeData = (ValidatingReaderNodeData)defaultAttributes[i];
				if (Ref.Equal(validatingReaderNodeData.LocalName, attrLocalName) && Ref.Equal(validatingReaderNodeData.Namespace, ns))
				{
					if (updatePosition)
					{
						currentAttrIndex = coreReader.AttributeCount + i;
					}
					return validatingReaderNodeData;
				}
			}
			return null;
		}

		private AttributePSVIInfo AddAttributePSVI(int attIndex)
		{
			AttributePSVIInfo attributePSVIInfo = attributePSVINodes[attIndex];
			if (attributePSVIInfo != null)
			{
				attributePSVIInfo.Reset();
				return attributePSVIInfo;
			}
			if (attIndex >= attributePSVINodes.Length - 1)
			{
				AttributePSVIInfo[] destinationArray = new AttributePSVIInfo[attributePSVINodes.Length * 2];
				Array.Copy(attributePSVINodes, 0, destinationArray, 0, attributePSVINodes.Length);
				attributePSVINodes = destinationArray;
			}
			attributePSVIInfo = attributePSVINodes[attIndex];
			if (attributePSVIInfo == null)
			{
				attributePSVIInfo = new AttributePSVIInfo();
				attributePSVINodes[attIndex] = attributePSVIInfo;
			}
			return attributePSVIInfo;
		}

		private bool IsXSDRoot(string localName, string ns)
		{
			if (Ref.Equal(ns, NsXs))
			{
				return Ref.Equal(localName, XsdSchema);
			}
			return false;
		}

		private void ProcessInlineSchema()
		{
			if (coreReader.Read())
			{
				if (coreReader.NodeType == XmlNodeType.Element)
				{
					attributeCount = (coreReaderAttributeCount = coreReader.AttributeCount);
				}
				else
				{
					ClearAttributesInfo();
				}
				if (!inlineSchemaParser.ParseReaderNode())
				{
					inlineSchemaParser.FinishParsing();
					XmlSchema xmlSchema = inlineSchemaParser.XmlSchema;
					validator.AddSchema(xmlSchema);
					inlineSchemaParser = null;
					validationState = ValidatingReaderState.Read;
				}
			}
		}

		private object InternalReadContentAsObject()
		{
			return InternalReadContentAsObject(unwrapTypedValue: false);
		}

		private object InternalReadContentAsObject(bool unwrapTypedValue)
		{
			string originalStringValue;
			return InternalReadContentAsObject(unwrapTypedValue, out originalStringValue);
		}

		private object InternalReadContentAsObject(bool unwrapTypedValue, out string originalStringValue)
		{
			switch (NodeType)
			{
			case XmlNodeType.Attribute:
				originalStringValue = Value;
				if (attributePSVI != null && attributePSVI.typedAttributeValue != null)
				{
					if (validationState == ValidatingReaderState.OnDefaultAttribute)
					{
						XmlSchemaAttribute schemaAttribute = attributePSVI.attributeSchemaInfo.SchemaAttribute;
						originalStringValue = ((schemaAttribute.DefaultValue != null) ? schemaAttribute.DefaultValue : schemaAttribute.FixedValue);
					}
					return ReturnBoxedValue(attributePSVI.typedAttributeValue, AttributeSchemaInfo.XmlType, unwrapTypedValue);
				}
				return Value;
			case XmlNodeType.EndElement:
				if (atomicValue != null)
				{
					originalStringValue = originalAtomicValueString;
					return atomicValue;
				}
				originalStringValue = string.Empty;
				return string.Empty;
			default:
				if (validator.CurrentContentType == XmlSchemaContentType.TextOnly)
				{
					object result = ReturnBoxedValue(ReadTillEndElement(), xmlSchemaInfo.XmlType, unwrapTypedValue);
					originalStringValue = originalAtomicValueString;
					return result;
				}
				if (coreReader is XsdCachingReader xsdCachingReader)
				{
					originalStringValue = xsdCachingReader.ReadOriginalContentAsString();
				}
				else
				{
					originalStringValue = InternalReadContentAsString();
				}
				return originalStringValue;
			}
		}

		private object InternalReadElementContentAsObject(out XmlSchemaType xmlType)
		{
			return InternalReadElementContentAsObject(out xmlType, unwrapTypedValue: false);
		}

		private object InternalReadElementContentAsObject(out XmlSchemaType xmlType, bool unwrapTypedValue)
		{
			string originalString;
			return InternalReadElementContentAsObject(out xmlType, unwrapTypedValue, out originalString);
		}

		private object InternalReadElementContentAsObject(out XmlSchemaType xmlType, bool unwrapTypedValue, out string originalString)
		{
			object obj = null;
			xmlType = null;
			if (IsEmptyElement)
			{
				obj = ((xmlSchemaInfo.ContentType != 0) ? atomicValue : ReturnBoxedValue(atomicValue, xmlSchemaInfo.XmlType, unwrapTypedValue));
				originalString = originalAtomicValueString;
				xmlType = ElementXmlType;
				Read();
				return obj;
			}
			Read();
			if (NodeType == XmlNodeType.EndElement)
			{
				if (xmlSchemaInfo.IsDefault)
				{
					obj = ((xmlSchemaInfo.ContentType != 0) ? atomicValue : ReturnBoxedValue(atomicValue, xmlSchemaInfo.XmlType, unwrapTypedValue));
					originalString = originalAtomicValueString;
				}
				else
				{
					obj = string.Empty;
					originalString = string.Empty;
				}
			}
			else
			{
				if (NodeType == XmlNodeType.Element)
				{
					throw new XmlException("Xml_MixedReadElementContentAs", string.Empty, this);
				}
				obj = InternalReadContentAsObject(unwrapTypedValue, out originalString);
				if (NodeType != XmlNodeType.EndElement)
				{
					throw new XmlException("Xml_MixedReadElementContentAs", string.Empty, this);
				}
			}
			xmlType = ElementXmlType;
			Read();
			return obj;
		}

		private object ReadTillEndElement()
		{
			if (atomicValue == null)
			{
				while (coreReader.Read())
				{
					if (replayCache)
					{
						continue;
					}
					switch (coreReader.NodeType)
					{
					case XmlNodeType.Element:
						ProcessReaderEvent();
						break;
					case XmlNodeType.Text:
					case XmlNodeType.CDATA:
						validator.ValidateText(GetStringValue);
						continue;
					case XmlNodeType.Whitespace:
					case XmlNodeType.SignificantWhitespace:
						validator.ValidateWhitespace(GetStringValue);
						continue;
					case XmlNodeType.EndElement:
						atomicValue = validator.ValidateEndElement(xmlSchemaInfo);
						originalAtomicValueString = GetOriginalAtomicValueStringOfElement();
						if (manageNamespaces)
						{
							nsManager.PopScope();
						}
						break;
					default:
						continue;
					}
					break;
				}
			}
			else
			{
				if (atomicValue == this)
				{
					atomicValue = null;
				}
				SwitchReader();
			}
			return atomicValue;
		}

		private void SwitchReader()
		{
			if (coreReader is XsdCachingReader xsdCachingReader)
			{
				coreReader = xsdCachingReader.GetCoreReader();
			}
			replayCache = false;
		}

		private void ReadAheadForMemberType()
		{
			while (coreReader.Read())
			{
				switch (coreReader.NodeType)
				{
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
					validator.ValidateText(GetStringValue);
					break;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					validator.ValidateWhitespace(GetStringValue);
					break;
				case XmlNodeType.EndElement:
					atomicValue = validator.ValidateEndElement(xmlSchemaInfo);
					originalAtomicValueString = GetOriginalAtomicValueStringOfElement();
					if (atomicValue == null)
					{
						atomicValue = this;
					}
					else if (xmlSchemaInfo.IsDefault)
					{
						cachingReader.SwitchTextNodeAndEndElement(xmlSchemaInfo.XmlType.ValueConverter.ToString(atomicValue), originalAtomicValueString);
					}
					return;
				}
			}
		}

		private void GetIsDefault()
		{
			XsdCachingReader xsdCachingReader = coreReader as XsdCachingReader;
			if (xsdCachingReader != null || !xmlSchemaInfo.HasDefaultValue)
			{
				return;
			}
			coreReader = GetCachingReader();
			if (xmlSchemaInfo.IsUnionType && !xmlSchemaInfo.IsNil)
			{
				ReadAheadForMemberType();
			}
			else if (coreReader.Read())
			{
				switch (coreReader.NodeType)
				{
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
					validator.ValidateText(GetStringValue);
					break;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					validator.ValidateWhitespace(GetStringValue);
					break;
				case XmlNodeType.EndElement:
					atomicValue = validator.ValidateEndElement(xmlSchemaInfo);
					originalAtomicValueString = GetOriginalAtomicValueStringOfElement();
					if (xmlSchemaInfo.IsDefault)
					{
						cachingReader.SwitchTextNodeAndEndElement(xmlSchemaInfo.XmlType.ValueConverter.ToString(atomicValue), originalAtomicValueString);
					}
					break;
				}
			}
			cachingReader.SetToReplayMode();
			replayCache = true;
		}

		private void GetMemberType()
		{
			if (xmlSchemaInfo.MemberType == null && atomicValue != this)
			{
				XsdCachingReader xsdCachingReader = coreReader as XsdCachingReader;
				if (xsdCachingReader == null && xmlSchemaInfo.IsUnionType && !xmlSchemaInfo.IsNil)
				{
					coreReader = GetCachingReader();
					ReadAheadForMemberType();
					cachingReader.SetToReplayMode();
					replayCache = true;
				}
			}
		}

		private object ReturnBoxedValue(object typedValue, XmlSchemaType xmlType, bool unWrap)
		{
			if (typedValue != null)
			{
				if (unWrap && xmlType.Datatype.Variety == XmlSchemaDatatypeVariety.List)
				{
					Datatype_List datatype_List = xmlType.Datatype as Datatype_List;
					if (datatype_List.ItemType.Variety == XmlSchemaDatatypeVariety.Union)
					{
						typedValue = xmlType.ValueConverter.ChangeType(typedValue, xmlType.Datatype.ValueType, thisNSResolver);
					}
				}
				return typedValue;
			}
			typedValue = validator.GetConcatenatedValue();
			return typedValue;
		}

		private XsdCachingReader GetCachingReader()
		{
			if (cachingReader == null)
			{
				cachingReader = new XsdCachingReader(coreReader, lineInfo, CachingCallBack);
			}
			else
			{
				cachingReader.Reset(coreReader);
			}
			lineInfo = cachingReader;
			return cachingReader;
		}

		internal ValidatingReaderNodeData CreateDummyTextNode(string attributeValue, int depth)
		{
			if (textNode == null)
			{
				textNode = new ValidatingReaderNodeData(XmlNodeType.Text);
			}
			textNode.Depth = depth;
			textNode.RawValue = attributeValue;
			return textNode;
		}

		internal void CachingCallBack(XsdCachingReader cachingReader)
		{
			coreReader = cachingReader.GetCoreReader();
			lineInfo = cachingReader.GetLineInfo();
			replayCache = false;
		}

		private string GetOriginalAtomicValueStringOfElement()
		{
			if (xmlSchemaInfo.IsDefault)
			{
				XmlSchemaElement schemaElement = xmlSchemaInfo.SchemaElement;
				if (schemaElement != null)
				{
					if (schemaElement.DefaultValue == null)
					{
						return schemaElement.FixedValue;
					}
					return schemaElement.DefaultValue;
				}
				return string.Empty;
			}
			return validator.GetConcatenatedValue();
		}
	}
	internal class XsdCachingReader : XmlReader, IXmlLineInfo
	{
		private enum CachingReaderState
		{
			None,
			Init,
			Record,
			Replay,
			ReaderClosed,
			Error
		}

		private const int InitialAttributeCount = 8;

		private const int InitialContentCount = 4;

		private XmlReader coreReader;

		private XmlNameTable coreReaderNameTable;

		private ValidatingReaderNodeData[] contentEvents;

		private ValidatingReaderNodeData[] attributeEvents;

		private ValidatingReaderNodeData cachedNode;

		private CachingReaderState cacheState;

		private int contentIndex;

		private int attributeCount;

		private bool returnOriginalStringValues;

		private CachingEventHandler cacheHandler;

		private int currentAttrIndex;

		private int currentContentIndex;

		private bool readAhead;

		private IXmlLineInfo lineInfo;

		private ValidatingReaderNodeData textNode;

		public override XmlReaderSettings Settings => coreReader.Settings;

		public override XmlNodeType NodeType => cachedNode.NodeType;

		public override string Name => cachedNode.GetAtomizedNameWPrefix(coreReaderNameTable);

		public override string LocalName => cachedNode.LocalName;

		public override string NamespaceURI => cachedNode.Namespace;

		public override string Prefix => cachedNode.Prefix;

		public override bool HasValue => XmlReader.HasValueInternal(cachedNode.NodeType);

		public override string Value
		{
			get
			{
				if (!returnOriginalStringValues)
				{
					return cachedNode.RawValue;
				}
				return cachedNode.OriginalStringValue;
			}
		}

		public override int Depth => cachedNode.Depth;

		public override string BaseURI => coreReader.BaseURI;

		public override bool IsEmptyElement => false;

		public override bool IsDefault => false;

		public override char QuoteChar => coreReader.QuoteChar;

		public override XmlSpace XmlSpace => coreReader.XmlSpace;

		public override string XmlLang => coreReader.XmlLang;

		public override int AttributeCount => attributeCount;

		public override string this[int i] => GetAttribute(i);

		public override string this[string name] => GetAttribute(name);

		public override string this[string name, string namespaceURI] => GetAttribute(name, namespaceURI);

		public override bool EOF
		{
			get
			{
				if (cacheState == CachingReaderState.ReaderClosed)
				{
					return coreReader.EOF;
				}
				return false;
			}
		}

		public override ReadState ReadState => coreReader.ReadState;

		public override XmlNameTable NameTable => coreReaderNameTable;

		int IXmlLineInfo.LineNumber => cachedNode.LineNumber;

		int IXmlLineInfo.LinePosition => cachedNode.LinePosition;

		internal XsdCachingReader(XmlReader reader, IXmlLineInfo lineInfo, CachingEventHandler handlerMethod)
		{
			coreReader = reader;
			this.lineInfo = lineInfo;
			cacheHandler = handlerMethod;
			attributeEvents = new ValidatingReaderNodeData[8];
			contentEvents = new ValidatingReaderNodeData[4];
			Init();
		}

		private void Init()
		{
			coreReaderNameTable = coreReader.NameTable;
			cacheState = CachingReaderState.Init;
			contentIndex = 0;
			currentAttrIndex = -1;
			currentContentIndex = -1;
			attributeCount = 0;
			cachedNode = null;
			readAhead = false;
			if (coreReader.NodeType == XmlNodeType.Element)
			{
				ValidatingReaderNodeData validatingReaderNodeData = AddContent(coreReader.NodeType);
				validatingReaderNodeData.SetItemData(coreReader.LocalName, coreReader.Prefix, coreReader.NamespaceURI, coreReader.Depth);
				validatingReaderNodeData.SetLineInfo(lineInfo);
				RecordAttributes();
			}
		}

		internal void Reset(XmlReader reader)
		{
			coreReader = reader;
			Init();
		}

		public override string GetAttribute(string name)
		{
			int num = ((name.IndexOf(':') != -1) ? GetAttributeIndexWithPrefix(name) : GetAttributeIndexWithoutPrefix(name));
			if (num < 0)
			{
				return null;
			}
			return attributeEvents[num].RawValue;
		}

		public override string GetAttribute(string name, string namespaceURI)
		{
			namespaceURI = ((namespaceURI == null) ? string.Empty : coreReaderNameTable.Get(namespaceURI));
			name = coreReaderNameTable.Get(name);
			for (int i = 0; i < attributeCount; i++)
			{
				ValidatingReaderNodeData validatingReaderNodeData = attributeEvents[i];
				if (Ref.Equal(validatingReaderNodeData.LocalName, name) && Ref.Equal(validatingReaderNodeData.Namespace, namespaceURI))
				{
					return validatingReaderNodeData.RawValue;
				}
			}
			return null;
		}

		public override string GetAttribute(int i)
		{
			if (i < 0 || i >= attributeCount)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			return attributeEvents[i].RawValue;
		}

		public override bool MoveToAttribute(string name)
		{
			int num = ((name.IndexOf(':') != -1) ? GetAttributeIndexWithPrefix(name) : GetAttributeIndexWithoutPrefix(name));
			if (num >= 0)
			{
				currentAttrIndex = num;
				cachedNode = attributeEvents[num];
				return true;
			}
			return false;
		}

		public override bool MoveToAttribute(string name, string ns)
		{
			ns = ((ns == null) ? string.Empty : coreReaderNameTable.Get(ns));
			name = coreReaderNameTable.Get(name);
			for (int i = 0; i < attributeCount; i++)
			{
				ValidatingReaderNodeData validatingReaderNodeData = attributeEvents[i];
				if (Ref.Equal(validatingReaderNodeData.LocalName, name) && Ref.Equal(validatingReaderNodeData.Namespace, ns))
				{
					currentAttrIndex = i;
					cachedNode = attributeEvents[i];
					return true;
				}
			}
			return false;
		}

		public override void MoveToAttribute(int i)
		{
			if (i < 0 || i >= attributeCount)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			currentAttrIndex = i;
			cachedNode = attributeEvents[i];
		}

		public override bool MoveToFirstAttribute()
		{
			if (attributeCount == 0)
			{
				return false;
			}
			currentAttrIndex = 0;
			cachedNode = attributeEvents[0];
			return true;
		}

		public override bool MoveToNextAttribute()
		{
			if (currentAttrIndex + 1 < attributeCount)
			{
				cachedNode = attributeEvents[++currentAttrIndex];
				return true;
			}
			return false;
		}

		public override bool MoveToElement()
		{
			if (cacheState != CachingReaderState.Replay || cachedNode.NodeType != XmlNodeType.Attribute)
			{
				return false;
			}
			currentContentIndex = 0;
			currentAttrIndex = -1;
			Read();
			return true;
		}

		public override bool Read()
		{
			switch (cacheState)
			{
			case CachingReaderState.Init:
				cacheState = CachingReaderState.Record;
				goto case CachingReaderState.Record;
			case CachingReaderState.Record:
			{
				ValidatingReaderNodeData validatingReaderNodeData = null;
				if (coreReader.Read())
				{
					switch (coreReader.NodeType)
					{
					case XmlNodeType.Element:
						cacheState = CachingReaderState.ReaderClosed;
						return false;
					case XmlNodeType.EndElement:
						validatingReaderNodeData = AddContent(coreReader.NodeType);
						validatingReaderNodeData.SetItemData(coreReader.LocalName, coreReader.Prefix, coreReader.NamespaceURI, coreReader.Depth);
						validatingReaderNodeData.SetLineInfo(lineInfo);
						break;
					case XmlNodeType.Text:
					case XmlNodeType.CDATA:
					case XmlNodeType.ProcessingInstruction:
					case XmlNodeType.Comment:
					case XmlNodeType.Whitespace:
					case XmlNodeType.SignificantWhitespace:
						validatingReaderNodeData = AddContent(coreReader.NodeType);
						validatingReaderNodeData.SetItemData(coreReader.Value);
						validatingReaderNodeData.SetLineInfo(lineInfo);
						validatingReaderNodeData.Depth = coreReader.Depth;
						break;
					}
					cachedNode = validatingReaderNodeData;
					return true;
				}
				cacheState = CachingReaderState.ReaderClosed;
				return false;
			}
			case CachingReaderState.Replay:
				if (currentContentIndex >= contentIndex)
				{
					cacheState = CachingReaderState.ReaderClosed;
					cacheHandler(this);
					if (coreReader.NodeType != XmlNodeType.Element || readAhead)
					{
						return coreReader.Read();
					}
					return true;
				}
				cachedNode = contentEvents[currentContentIndex];
				if (currentContentIndex > 0)
				{
					ClearAttributesInfo();
				}
				currentContentIndex++;
				return true;
			default:
				return false;
			}
		}

		internal ValidatingReaderNodeData RecordTextNode(string textValue, string originalStringValue, int depth, int lineNo, int linePos)
		{
			ValidatingReaderNodeData validatingReaderNodeData = AddContent(XmlNodeType.Text);
			validatingReaderNodeData.SetItemData(textValue, originalStringValue);
			validatingReaderNodeData.SetLineInfo(lineNo, linePos);
			validatingReaderNodeData.Depth = depth;
			return validatingReaderNodeData;
		}

		internal void SwitchTextNodeAndEndElement(string textValue, string originalStringValue)
		{
			ValidatingReaderNodeData validatingReaderNodeData = RecordTextNode(textValue, originalStringValue, coreReader.Depth + 1, 0, 0);
			int num = contentIndex - 2;
			ValidatingReaderNodeData validatingReaderNodeData2 = contentEvents[num];
			contentEvents[num] = validatingReaderNodeData;
			contentEvents[contentIndex - 1] = validatingReaderNodeData2;
		}

		internal void RecordEndElementNode()
		{
			ValidatingReaderNodeData validatingReaderNodeData = AddContent(XmlNodeType.EndElement);
			validatingReaderNodeData.SetItemData(coreReader.LocalName, coreReader.Prefix, coreReader.NamespaceURI, coreReader.Depth);
			validatingReaderNodeData.SetLineInfo(coreReader as IXmlLineInfo);
			if (coreReader.IsEmptyElement)
			{
				readAhead = true;
			}
		}

		internal string ReadOriginalContentAsString()
		{
			returnOriginalStringValues = true;
			string result = InternalReadContentAsString();
			returnOriginalStringValues = false;
			return result;
		}

		public override void Close()
		{
			coreReader.Close();
			cacheState = CachingReaderState.ReaderClosed;
		}

		public override void Skip()
		{
			switch (cachedNode.NodeType)
			{
			case XmlNodeType.Element:
				if (coreReader.NodeType != XmlNodeType.EndElement && !readAhead)
				{
					int num = coreReader.Depth - 1;
					while (coreReader.Read() && coreReader.Depth > num)
					{
					}
				}
				coreReader.Read();
				cacheState = CachingReaderState.ReaderClosed;
				cacheHandler(this);
				break;
			case XmlNodeType.Attribute:
				MoveToElement();
				goto case XmlNodeType.Element;
			default:
				Read();
				break;
			}
		}

		public override string LookupNamespace(string prefix)
		{
			return coreReader.LookupNamespace(prefix);
		}

		public override void ResolveEntity()
		{
			throw new InvalidOperationException();
		}

		public override bool ReadAttributeValue()
		{
			if (cachedNode.NodeType != XmlNodeType.Attribute)
			{
				return false;
			}
			cachedNode = CreateDummyTextNode(cachedNode.RawValue, cachedNode.Depth + 1);
			return true;
		}

		bool IXmlLineInfo.HasLineInfo()
		{
			return true;
		}

		internal void SetToReplayMode()
		{
			cacheState = CachingReaderState.Replay;
			currentContentIndex = 0;
			currentAttrIndex = -1;
			Read();
		}

		internal XmlReader GetCoreReader()
		{
			return coreReader;
		}

		internal IXmlLineInfo GetLineInfo()
		{
			return lineInfo;
		}

		private void ClearAttributesInfo()
		{
			attributeCount = 0;
			currentAttrIndex = -1;
		}

		private ValidatingReaderNodeData AddAttribute(int attIndex)
		{
			ValidatingReaderNodeData validatingReaderNodeData = attributeEvents[attIndex];
			if (validatingReaderNodeData != null)
			{
				validatingReaderNodeData.Clear(XmlNodeType.Attribute);
				return validatingReaderNodeData;
			}
			if (attIndex >= attributeEvents.Length - 1)
			{
				ValidatingReaderNodeData[] destinationArray = new ValidatingReaderNodeData[attributeEvents.Length * 2];
				Array.Copy(attributeEvents, 0, destinationArray, 0, attributeEvents.Length);
				attributeEvents = destinationArray;
			}
			validatingReaderNodeData = attributeEvents[attIndex];
			if (validatingReaderNodeData == null)
			{
				validatingReaderNodeData = new ValidatingReaderNodeData(XmlNodeType.Attribute);
				attributeEvents[attIndex] = validatingReaderNodeData;
			}
			return validatingReaderNodeData;
		}

		private ValidatingReaderNodeData AddContent(XmlNodeType nodeType)
		{
			ValidatingReaderNodeData validatingReaderNodeData = contentEvents[contentIndex];
			if (validatingReaderNodeData != null)
			{
				validatingReaderNodeData.Clear(nodeType);
				contentIndex++;
				return validatingReaderNodeData;
			}
			if (contentIndex >= contentEvents.Length - 1)
			{
				ValidatingReaderNodeData[] destinationArray = new ValidatingReaderNodeData[contentEvents.Length * 2];
				Array.Copy(contentEvents, 0, destinationArray, 0, contentEvents.Length);
				contentEvents = destinationArray;
			}
			validatingReaderNodeData = contentEvents[contentIndex];
			if (validatingReaderNodeData == null)
			{
				validatingReaderNodeData = new ValidatingReaderNodeData(nodeType);
				contentEvents[contentIndex] = validatingReaderNodeData;
			}
			contentIndex++;
			return validatingReaderNodeData;
		}

		private void RecordAttributes()
		{
			attributeCount = coreReader.AttributeCount;
			if (coreReader.MoveToFirstAttribute())
			{
				int num = 0;
				do
				{
					ValidatingReaderNodeData validatingReaderNodeData = AddAttribute(num);
					validatingReaderNodeData.SetItemData(coreReader.LocalName, coreReader.Prefix, coreReader.NamespaceURI, coreReader.Depth);
					validatingReaderNodeData.SetLineInfo(lineInfo);
					validatingReaderNodeData.RawValue = coreReader.Value;
					num++;
				}
				while (coreReader.MoveToNextAttribute());
				coreReader.MoveToElement();
			}
		}

		private int GetAttributeIndexWithoutPrefix(string name)
		{
			name = coreReaderNameTable.Get(name);
			if (name == null)
			{
				return -1;
			}
			for (int i = 0; i < attributeCount; i++)
			{
				ValidatingReaderNodeData validatingReaderNodeData = attributeEvents[i];
				if (Ref.Equal(validatingReaderNodeData.LocalName, name) && validatingReaderNodeData.Prefix.Length == 0)
				{
					return i;
				}
			}
			return -1;
		}

		private int GetAttributeIndexWithPrefix(string name)
		{
			name = coreReaderNameTable.Get(name);
			if (name == null)
			{
				return -1;
			}
			for (int i = 0; i < attributeCount; i++)
			{
				ValidatingReaderNodeData validatingReaderNodeData = attributeEvents[i];
				if (Ref.Equal(validatingReaderNodeData.GetAtomizedNameWPrefix(coreReaderNameTable), name))
				{
					return i;
				}
			}
			return -1;
		}

		private ValidatingReaderNodeData CreateDummyTextNode(string attributeValue, int depth)
		{
			if (textNode == null)
			{
				textNode = new ValidatingReaderNodeData(XmlNodeType.Text);
			}
			textNode.Depth = depth;
			textNode.RawValue = attributeValue;
			return textNode;
		}
	}
	internal enum DocumentXmlWriterType
	{
		InsertSiblingAfter,
		InsertSiblingBefore,
		PrependChild,
		AppendChild,
		AppendAttribute,
		ReplaceToFollowingSibling
	}
	internal sealed class DocumentXmlWriter : XmlRawWriter, IXmlNamespaceResolver
	{
		private enum State
		{
			Error,
			Attribute,
			Prolog,
			Fragment,
			Content,
			Last
		}

		private enum Method
		{
			WriteXmlDeclaration,
			WriteStartDocument,
			WriteEndDocument,
			WriteDocType,
			WriteStartElement,
			WriteEndElement,
			WriteFullEndElement,
			WriteStartAttribute,
			WriteEndAttribute,
			WriteNamespaceDeclaration,
			WriteCData,
			WriteComment,
			WriteProcessingInstruction,
			WriteEntityRef,
			WriteWhitespace,
			WriteString
		}

		private DocumentXmlWriterType type;

		private XmlNode start;

		private XmlDocument document;

		private XmlNamespaceManager namespaceManager;

		private State state;

		private XmlNode write;

		private List<XmlNode> fragment;

		private XmlWriterSettings settings;

		private DocumentXPathNavigator navigator;

		private XmlNode end;

		private static State[] changeState = new State[80]
		{
			State.Error,
			State.Error,
			State.Prolog,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Prolog,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Error,
			State.Content,
			State.Error,
			State.Error,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Error,
			State.Content,
			State.Error,
			State.Error,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.Prolog,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.Prolog,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.Prolog,
			State.Content,
			State.Content,
			State.Error,
			State.Error,
			State.Error,
			State.Content,
			State.Content
		};

		public XmlNamespaceManager NamespaceManager
		{
			set
			{
				namespaceManager = value;
			}
		}

		public override XmlWriterSettings Settings => settings;

		public DocumentXPathNavigator Navigator
		{
			set
			{
				navigator = value;
			}
		}

		public XmlNode EndNode
		{
			set
			{
				end = value;
			}
		}

		public DocumentXmlWriter(DocumentXmlWriterType type, XmlNode start, XmlDocument document)
		{
			this.type = type;
			this.start = start;
			this.document = document;
			state = StartState();
			fragment = new List<XmlNode>();
			settings = new XmlWriterSettings();
			settings.ReadOnly = false;
			settings.CheckCharacters = false;
			settings.CloseOutput = false;
			settings.ConformanceLevel = ((state != State.Prolog) ? ConformanceLevel.Fragment : ConformanceLevel.Document);
			settings.ReadOnly = true;
		}

		internal void SetSettings(XmlWriterSettings value)
		{
			settings = value;
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
			VerifyState(Method.WriteXmlDeclaration);
			if (standalone != 0)
			{
				XmlNode node = document.CreateXmlDeclaration("1.0", string.Empty, (standalone == XmlStandalone.Yes) ? "yes" : "no");
				AddChild(node, write);
			}
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
			VerifyState(Method.WriteXmlDeclaration);
			XmlLoader.ParseXmlDeclarationValue(xmldecl, out var version, out var encoding, out var standalone);
			XmlNode node = document.CreateXmlDeclaration(version, encoding, standalone);
			AddChild(node, write);
		}

		public override void WriteStartDocument()
		{
			VerifyState(Method.WriteStartDocument);
		}

		public override void WriteStartDocument(bool standalone)
		{
			VerifyState(Method.WriteStartDocument);
		}

		public override void WriteEndDocument()
		{
			VerifyState(Method.WriteEndDocument);
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			VerifyState(Method.WriteDocType);
			XmlNode node = document.CreateDocumentType(name, pubid, sysid, subset);
			AddChild(node, write);
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			VerifyState(Method.WriteStartElement);
			XmlNode node = document.CreateElement(prefix, localName, ns);
			AddChild(node, write);
			write = node;
		}

		public override void WriteEndElement()
		{
			VerifyState(Method.WriteEndElement);
			if (write == null)
			{
				throw new InvalidOperationException();
			}
			write = write.ParentNode;
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			WriteEndElement();
		}

		public override void WriteFullEndElement()
		{
			VerifyState(Method.WriteFullEndElement);
			if (!(write is XmlElement xmlElement))
			{
				throw new InvalidOperationException();
			}
			xmlElement.IsEmpty = false;
			write = xmlElement.ParentNode;
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			WriteFullEndElement();
		}

		internal override void StartElementContent()
		{
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			VerifyState(Method.WriteStartAttribute);
			XmlAttribute attr = document.CreateAttribute(prefix, localName, ns);
			AddAttribute(attr, write);
			write = attr;
		}

		public override void WriteEndAttribute()
		{
			VerifyState(Method.WriteEndAttribute);
			if (!(write is XmlAttribute xmlAttribute))
			{
				throw new InvalidOperationException();
			}
			if (!xmlAttribute.HasChildNodes)
			{
				XmlNode node = document.CreateTextNode(string.Empty);
				AddChild(node, xmlAttribute);
			}
			write = xmlAttribute.OwnerElement;
		}

		internal override void WriteNamespaceDeclaration(string prefix, string ns)
		{
			VerifyState(Method.WriteNamespaceDeclaration);
			XmlAttribute xmlAttribute = ((prefix.Length != 0) ? document.CreateAttribute(document.strXmlns, prefix, document.strReservedXmlns) : document.CreateAttribute(prefix, document.strXmlns, document.strReservedXmlns));
			AddAttribute(xmlAttribute, write);
			XmlNode node = document.CreateTextNode(ns);
			AddChild(node, xmlAttribute);
		}

		public override void WriteCData(string text)
		{
			VerifyState(Method.WriteCData);
			XmlConvert.VerifyCharData(text, ExceptionType.ArgumentException);
			XmlNode node = document.CreateCDataSection(text);
			AddChild(node, write);
		}

		public override void WriteComment(string text)
		{
			VerifyState(Method.WriteComment);
			XmlConvert.VerifyCharData(text, ExceptionType.ArgumentException);
			XmlNode node = document.CreateComment(text);
			AddChild(node, write);
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			VerifyState(Method.WriteProcessingInstruction);
			XmlConvert.VerifyCharData(text, ExceptionType.ArgumentException);
			XmlNode node = document.CreateProcessingInstruction(name, text);
			AddChild(node, write);
		}

		public override void WriteEntityRef(string name)
		{
			VerifyState(Method.WriteEntityRef);
			XmlNode node = document.CreateEntityReference(name);
			AddChild(node, write);
		}

		public override void WriteCharEntity(char ch)
		{
			WriteString(new string(ch, 1));
		}

		public override void WriteWhitespace(string text)
		{
			VerifyState(Method.WriteWhitespace);
			XmlConvert.VerifyCharData(text, ExceptionType.ArgumentException);
			if (document.PreserveWhitespace)
			{
				XmlNode node = document.CreateWhitespace(text);
				AddChild(node, write);
			}
		}

		public override void WriteString(string text)
		{
			VerifyState(Method.WriteString);
			XmlConvert.VerifyCharData(text, ExceptionType.ArgumentException);
			XmlNode node = document.CreateTextNode(text);
			AddChild(node, write);
		}

		public override void WriteSurrogateCharEntity(char lowCh, char highCh)
		{
			WriteString(new string(new char[2] { highCh, lowCh }));
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			WriteString(new string(buffer, index, count));
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			WriteString(new string(buffer, index, count));
		}

		public override void WriteRaw(string data)
		{
			WriteString(data);
		}

		public override void Close()
		{
		}

		internal override void Close(WriteState currentState)
		{
			if (currentState == WriteState.Error)
			{
				return;
			}
			try
			{
				switch (type)
				{
				case DocumentXmlWriterType.InsertSiblingAfter:
				{
					XmlNode parentNode = start.ParentNode;
					if (parentNode == null)
					{
						throw new InvalidOperationException(Res.GetString("Xpn_MissingParent"));
					}
					for (int num2 = fragment.Count - 1; num2 >= 0; num2--)
					{
						parentNode.InsertAfter(fragment[num2], start);
					}
					break;
				}
				case DocumentXmlWriterType.InsertSiblingBefore:
				{
					XmlNode parentNode = start.ParentNode;
					if (parentNode == null)
					{
						throw new InvalidOperationException(Res.GetString("Xpn_MissingParent"));
					}
					for (int j = 0; j < fragment.Count; j++)
					{
						parentNode.InsertBefore(fragment[j], start);
					}
					break;
				}
				case DocumentXmlWriterType.PrependChild:
				{
					for (int num = fragment.Count - 1; num >= 0; num--)
					{
						start.PrependChild(fragment[num]);
					}
					break;
				}
				case DocumentXmlWriterType.AppendChild:
				{
					for (int i = 0; i < fragment.Count; i++)
					{
						start.AppendChild(fragment[i]);
					}
					break;
				}
				case DocumentXmlWriterType.AppendAttribute:
					CloseWithAppendAttribute();
					break;
				case DocumentXmlWriterType.ReplaceToFollowingSibling:
					if (fragment.Count == 0)
					{
						throw new InvalidOperationException(Res.GetString("Xpn_NoContent"));
					}
					CloseWithReplaceToFollowingSibling();
					break;
				}
			}
			finally
			{
				fragment.Clear();
			}
		}

		private void CloseWithAppendAttribute()
		{
			XmlElement xmlElement = start as XmlElement;
			XmlAttributeCollection attributes = xmlElement.Attributes;
			for (int i = 0; i < fragment.Count; i++)
			{
				XmlAttribute xmlAttribute = fragment[i] as XmlAttribute;
				int num = attributes.FindNodeOffsetNS(xmlAttribute);
				if (num != -1 && ((XmlAttribute)attributes.Nodes[num]).Specified)
				{
					throw new XmlException("Xml_DupAttributeName", (xmlAttribute.Prefix.Length == 0) ? xmlAttribute.LocalName : (xmlAttribute.Prefix + ":" + xmlAttribute.LocalName));
				}
			}
			for (int j = 0; j < fragment.Count; j++)
			{
				XmlAttribute node = fragment[j] as XmlAttribute;
				attributes.Append(node);
			}
		}

		private void CloseWithReplaceToFollowingSibling()
		{
			XmlNode parentNode = start.ParentNode;
			if (parentNode == null)
			{
				throw new InvalidOperationException(Res.GetString("Xpn_MissingParent"));
			}
			if (start != end)
			{
				if (!DocumentXPathNavigator.IsFollowingSibling(start, end))
				{
					throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
				}
				if (start.IsReadOnly)
				{
					throw new InvalidOperationException(Res.GetString("Xdom_Node_Modify_ReadOnly"));
				}
				DocumentXPathNavigator.DeleteToFollowingSibling(start.NextSibling, end);
			}
			XmlNode xmlNode = fragment[0];
			parentNode.ReplaceChild(xmlNode, start);
			for (int num = fragment.Count - 1; num >= 1; num--)
			{
				parentNode.InsertAfter(fragment[num], xmlNode);
			}
			navigator.ResetPosition(xmlNode);
		}

		public override void Flush()
		{
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return namespaceManager.GetNamespacesInScope(scope);
		}

		string IXmlNamespaceResolver.LookupNamespace(string prefix)
		{
			return namespaceManager.LookupNamespace(prefix);
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			return namespaceManager.LookupPrefix(namespaceName);
		}

		private void AddAttribute(XmlAttribute attr, XmlNode parent)
		{
			if (parent == null)
			{
				fragment.Add(attr);
				return;
			}
			if (!(parent is XmlElement xmlElement))
			{
				throw new InvalidOperationException();
			}
			xmlElement.Attributes.Append(attr);
		}

		private void AddChild(XmlNode node, XmlNode parent)
		{
			if (parent == null)
			{
				fragment.Add(node);
			}
			else
			{
				parent.AppendChild(node);
			}
		}

		private State StartState()
		{
			XmlNodeType xmlNodeType = XmlNodeType.None;
			switch (type)
			{
			case DocumentXmlWriterType.InsertSiblingAfter:
			case DocumentXmlWriterType.InsertSiblingBefore:
			{
				XmlNode parentNode = start.ParentNode;
				if (parentNode != null)
				{
					xmlNodeType = parentNode.NodeType;
				}
				switch (xmlNodeType)
				{
				case XmlNodeType.Document:
					return State.Prolog;
				case XmlNodeType.DocumentFragment:
					return State.Fragment;
				}
				break;
			}
			case DocumentXmlWriterType.PrependChild:
			case DocumentXmlWriterType.AppendChild:
				switch (start.NodeType)
				{
				case XmlNodeType.Document:
					return State.Prolog;
				case XmlNodeType.DocumentFragment:
					return State.Fragment;
				}
				break;
			case DocumentXmlWriterType.AppendAttribute:
				return State.Attribute;
			}
			return State.Content;
		}

		private void VerifyState(Method method)
		{
			state = changeState[(int)((int)method * 5 + state)];
			if (state == State.Error)
			{
				throw new InvalidOperationException(Res.GetString("Xml_ClosedOrError"));
			}
		}
	}
}
namespace System.Xml.XPath
{
	public abstract class XPathItem
	{
		public abstract bool IsNode { get; }

		public abstract XmlSchemaType XmlType { get; }

		public abstract string Value { get; }

		public abstract object TypedValue { get; }

		public abstract Type ValueType { get; }

		public abstract bool ValueAsBoolean { get; }

		public abstract DateTime ValueAsDateTime { get; }

		public abstract double ValueAsDouble { get; }

		public abstract int ValueAsInt { get; }

		public abstract long ValueAsLong { get; }

		public virtual object ValueAs(Type returnType)
		{
			return ValueAs(returnType, null);
		}

		public abstract object ValueAs(Type returnType, IXmlNamespaceResolver nsResolver);
	}
	public interface IXPathNavigable
	{
		XPathNavigator CreateNavigator();
	}
	[DebuggerDisplay("{debuggerDisplayProxy}")]
	public abstract class XPathNavigator : XPathItem, ICloneable, IXPathNavigable, IXmlNamespaceResolver
	{
		private class CheckValidityHelper
		{
			private bool isValid;

			private ValidationEventHandler nextEventHandler;

			private XPathNavigatorReader reader;

			internal bool IsValid => isValid;

			internal CheckValidityHelper(ValidationEventHandler nextEventHandler, XPathNavigatorReader reader)
			{
				isValid = true;
				this.nextEventHandler = nextEventHandler;
				this.reader = reader;
			}

			internal void ValidationCallback(object sender, ValidationEventArgs args)
			{
				if (args.Severity == XmlSeverityType.Error)
				{
					isValid = false;
				}
				XmlSchemaValidationException ex = args.Exception as XmlSchemaValidationException;
				if (ex != null && reader != null)
				{
					ex.SetSourceObject(reader.UnderlyingObject);
				}
				if (nextEventHandler != null)
				{
					nextEventHandler(sender, args);
				}
				else if (ex != null && args.Severity == XmlSeverityType.Error)
				{
					throw ex;
				}
			}
		}

		[DebuggerDisplay("{ToString()}")]
		internal struct DebuggerDisplayProxy
		{
			private XPathNavigator nav;

			public DebuggerDisplayProxy(XPathNavigator nav)
			{
				this.nav = nav;
			}

			public override string ToString()
			{
				string text = nav.NodeType.ToString();
				switch (nav.NodeType)
				{
				case XPathNodeType.Element:
				{
					object obj4 = text;
					text = string.Concat(obj4, ", Name=\"", nav.Name, '"');
					break;
				}
				case XPathNodeType.Attribute:
				case XPathNodeType.Namespace:
				case XPathNodeType.ProcessingInstruction:
				{
					object obj2 = text;
					text = string.Concat(obj2, ", Name=\"", nav.Name, '"');
					object obj3 = text;
					text = string.Concat(obj3, ", Value=\"", XmlConvert.EscapeValueForDebuggerDisplay(nav.Value), '"');
					break;
				}
				case XPathNodeType.Text:
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.Comment:
				{
					object obj = text;
					text = string.Concat(obj, ", Value=\"", XmlConvert.EscapeValueForDebuggerDisplay(nav.Value), '"');
					break;
				}
				}
				return text;
			}
		}

		internal const int AllMask = int.MaxValue;

		internal const int NoAttrNmspMask = 2147483635;

		internal const int TextMask = 112;

		internal static readonly XPathNavigatorKeyComparer comparer = new XPathNavigatorKeyComparer();

		internal static readonly char[] NodeTypeLetter = new char[10] { 'R', 'E', 'A', 'N', 'T', 'S', 'W', 'P', 'C', 'X' };

		internal static readonly char[] UniqueIdTbl = new char[32]
		{
			'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
			'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
			'U', 'V', 'W', 'X', 'Y', 'Z', '1', '2', '3', '4',
			'5', '6'
		};

		internal static readonly int[] ContentKindMasks = new int[10] { 1, 2, 0, 0, 112, 32, 64, 128, 256, 2147483635 };

		public sealed override bool IsNode => true;

		public override XmlSchemaType XmlType
		{
			get
			{
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null && schemaInfo.Validity == XmlSchemaValidity.Valid)
				{
					XmlSchemaType memberType = schemaInfo.MemberType;
					if (memberType != null)
					{
						return memberType;
					}
					return schemaInfo.SchemaType;
				}
				return null;
			}
		}

		public override object TypedValue
		{
			get
			{
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null)
				{
					if (schemaInfo.Validity == XmlSchemaValidity.Valid)
					{
						XmlSchemaType xmlSchemaType = schemaInfo.MemberType;
						if (xmlSchemaType == null)
						{
							xmlSchemaType = schemaInfo.SchemaType;
						}
						if (xmlSchemaType != null)
						{
							XmlSchemaDatatype datatype = xmlSchemaType.Datatype;
							if (datatype != null)
							{
								return xmlSchemaType.ValueConverter.ChangeType(Value, datatype.ValueType, this);
							}
						}
					}
					else
					{
						XmlSchemaType xmlSchemaType = schemaInfo.SchemaType;
						if (xmlSchemaType != null)
						{
							XmlSchemaDatatype datatype = xmlSchemaType.Datatype;
							if (datatype != null)
							{
								return xmlSchemaType.ValueConverter.ChangeType(datatype.ParseValue(Value, NameTable, this), datatype.ValueType, this);
							}
						}
					}
				}
				return Value;
			}
		}

		public override Type ValueType
		{
			get
			{
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null)
				{
					if (schemaInfo.Validity == XmlSchemaValidity.Valid)
					{
						XmlSchemaType xmlSchemaType = schemaInfo.MemberType;
						if (xmlSchemaType == null)
						{
							xmlSchemaType = schemaInfo.SchemaType;
						}
						if (xmlSchemaType != null)
						{
							XmlSchemaDatatype datatype = xmlSchemaType.Datatype;
							if (datatype != null)
							{
								return datatype.ValueType;
							}
						}
					}
					else
					{
						XmlSchemaType xmlSchemaType = schemaInfo.SchemaType;
						if (xmlSchemaType != null)
						{
							XmlSchemaDatatype datatype = xmlSchemaType.Datatype;
							if (datatype != null)
							{
								return datatype.ValueType;
							}
						}
					}
				}
				return typeof(string);
			}
		}

		public override bool ValueAsBoolean
		{
			get
			{
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null)
				{
					if (schemaInfo.Validity == XmlSchemaValidity.Valid)
					{
						XmlSchemaType xmlSchemaType = schemaInfo.MemberType;
						if (xmlSchemaType == null)
						{
							xmlSchemaType = schemaInfo.SchemaType;
						}
						if (xmlSchemaType != null)
						{
							return xmlSchemaType.ValueConverter.ToBoolean(Value);
						}
					}
					else
					{
						XmlSchemaType xmlSchemaType = schemaInfo.SchemaType;
						if (xmlSchemaType != null)
						{
							XmlSchemaDatatype datatype = xmlSchemaType.Datatype;
							if (datatype != null)
							{
								return xmlSchemaType.ValueConverter.ToBoolean(datatype.ParseValue(Value, NameTable, this));
							}
						}
					}
				}
				return XmlUntypedConverter.Untyped.ToBoolean(Value);
			}
		}

		public override DateTime ValueAsDateTime
		{
			get
			{
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null)
				{
					if (schemaInfo.Validity == XmlSchemaValidity.Valid)
					{
						XmlSchemaType xmlSchemaType = schemaInfo.MemberType;
						if (xmlSchemaType == null)
						{
							xmlSchemaType = schemaInfo.SchemaType;
						}
						if (xmlSchemaType != null)
						{
							return xmlSchemaType.ValueConverter.ToDateTime(Value);
						}
					}
					else
					{
						XmlSchemaType xmlSchemaType = schemaInfo.SchemaType;
						if (xmlSchemaType != null)
						{
							XmlSchemaDatatype datatype = xmlSchemaType.Datatype;
							if (datatype != null)
							{
								return xmlSchemaType.ValueConverter.ToDateTime(datatype.ParseValue(Value, NameTable, this));
							}
						}
					}
				}
				return XmlUntypedConverter.Untyped.ToDateTime(Value);
			}
		}

		public override double ValueAsDouble
		{
			get
			{
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null)
				{
					if (schemaInfo.Validity == XmlSchemaValidity.Valid)
					{
						XmlSchemaType xmlSchemaType = schemaInfo.MemberType;
						if (xmlSchemaType == null)
						{
							xmlSchemaType = schemaInfo.SchemaType;
						}
						if (xmlSchemaType != null)
						{
							return xmlSchemaType.ValueConverter.ToDouble(Value);
						}
					}
					else
					{
						XmlSchemaType xmlSchemaType = schemaInfo.SchemaType;
						if (xmlSchemaType != null)
						{
							XmlSchemaDatatype datatype = xmlSchemaType.Datatype;
							if (datatype != null)
							{
								return xmlSchemaType.ValueConverter.ToDouble(datatype.ParseValue(Value, NameTable, this));
							}
						}
					}
				}
				return XmlUntypedConverter.Untyped.ToDouble(Value);
			}
		}

		public override int ValueAsInt
		{
			get
			{
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null)
				{
					if (schemaInfo.Validity == XmlSchemaValidity.Valid)
					{
						XmlSchemaType xmlSchemaType = schemaInfo.MemberType;
						if (xmlSchemaType == null)
						{
							xmlSchemaType = schemaInfo.SchemaType;
						}
						if (xmlSchemaType != null)
						{
							return xmlSchemaType.ValueConverter.ToInt32(Value);
						}
					}
					else
					{
						XmlSchemaType xmlSchemaType = schemaInfo.SchemaType;
						if (xmlSchemaType != null)
						{
							XmlSchemaDatatype datatype = xmlSchemaType.Datatype;
							if (datatype != null)
							{
								return xmlSchemaType.ValueConverter.ToInt32(datatype.ParseValue(Value, NameTable, this));
							}
						}
					}
				}
				return XmlUntypedConverter.Untyped.ToInt32(Value);
			}
		}

		public override long ValueAsLong
		{
			get
			{
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null)
				{
					if (schemaInfo.Validity == XmlSchemaValidity.Valid)
					{
						XmlSchemaType xmlSchemaType = schemaInfo.MemberType;
						if (xmlSchemaType == null)
						{
							xmlSchemaType = schemaInfo.SchemaType;
						}
						if (xmlSchemaType != null)
						{
							return xmlSchemaType.ValueConverter.ToInt64(Value);
						}
					}
					else
					{
						XmlSchemaType xmlSchemaType = schemaInfo.SchemaType;
						if (xmlSchemaType != null)
						{
							XmlSchemaDatatype datatype = xmlSchemaType.Datatype;
							if (datatype != null)
							{
								return xmlSchemaType.ValueConverter.ToInt64(datatype.ParseValue(Value, NameTable, this));
							}
						}
					}
				}
				return XmlUntypedConverter.Untyped.ToInt64(Value);
			}
		}

		public abstract XmlNameTable NameTable { get; }

		public static IEqualityComparer NavigatorComparer => comparer;

		public abstract XPathNodeType NodeType { get; }

		public abstract string LocalName { get; }

		public abstract string Name { get; }

		public abstract string NamespaceURI { get; }

		public abstract string Prefix { get; }

		public abstract string BaseURI { get; }

		public abstract bool IsEmptyElement { get; }

		public virtual string XmlLang
		{
			get
			{
				XPathNavigator xPathNavigator = Clone();
				do
				{
					if (xPathNavigator.MoveToAttribute("lang", "http://www.w3.org/XML/1998/namespace"))
					{
						return xPathNavigator.Value;
					}
				}
				while (xPathNavigator.MoveToParent());
				return string.Empty;
			}
		}

		public virtual object UnderlyingObject => null;

		public virtual bool HasAttributes
		{
			get
			{
				if (!MoveToFirstAttribute())
				{
					return false;
				}
				MoveToParent();
				return true;
			}
		}

		public virtual bool HasChildren
		{
			get
			{
				if (MoveToFirstChild())
				{
					MoveToParent();
					return true;
				}
				return false;
			}
		}

		public virtual IXmlSchemaInfo SchemaInfo => this as IXmlSchemaInfo;

		public virtual bool CanEdit => false;

		public virtual string OuterXml
		{
			get
			{
				if (NodeType == XPathNodeType.Attribute)
				{
					return Name + "=\"" + Value + "\"";
				}
				if (NodeType == XPathNodeType.Namespace)
				{
					if (LocalName.Length == 0)
					{
						return "xmlns=\"" + Value + "\"";
					}
					return "xmlns:" + LocalName + "=\"" + Value + "\"";
				}
				StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
				XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
				xmlWriterSettings.Indent = true;
				xmlWriterSettings.OmitXmlDeclaration = true;
				xmlWriterSettings.ConformanceLevel = ConformanceLevel.Auto;
				XmlWriter xmlWriter = XmlWriter.Create(stringWriter, xmlWriterSettings);
				try
				{
					xmlWriter.WriteNode(this, defattr: true);
				}
				finally
				{
					xmlWriter.Close();
				}
				return stringWriter.ToString();
			}
			set
			{
				ReplaceSelf(value);
			}
		}

		public virtual string InnerXml
		{
			get
			{
				switch (NodeType)
				{
				case XPathNodeType.Root:
				case XPathNodeType.Element:
				{
					StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
					XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
					xmlWriterSettings.Indent = true;
					xmlWriterSettings.OmitXmlDeclaration = true;
					xmlWriterSettings.ConformanceLevel = ConformanceLevel.Auto;
					XmlWriter xmlWriter = XmlWriter.Create(stringWriter, xmlWriterSettings);
					try
					{
						if (MoveToFirstChild())
						{
							do
							{
								xmlWriter.WriteNode(this, defattr: true);
							}
							while (MoveToNext());
							MoveToParent();
						}
					}
					finally
					{
						xmlWriter.Close();
					}
					return stringWriter.ToString();
				}
				case XPathNodeType.Attribute:
				case XPathNodeType.Namespace:
					return Value;
				default:
					return string.Empty;
				}
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				switch (NodeType)
				{
				case XPathNodeType.Root:
				case XPathNodeType.Element:
				{
					XPathNavigator xPathNavigator = CreateNavigator();
					while (xPathNavigator.MoveToFirstChild())
					{
						xPathNavigator.DeleteSelf();
					}
					if (value.Length != 0)
					{
						xPathNavigator.AppendChild(value);
					}
					break;
				}
				case XPathNodeType.Attribute:
					SetValue(value);
					break;
				default:
					throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
				}
			}
		}

		internal uint IndexInParent
		{
			get
			{
				XPathNavigator xPathNavigator = Clone();
				uint num = 0u;
				switch (NodeType)
				{
				case XPathNodeType.Attribute:
					while (xPathNavigator.MoveToNextAttribute())
					{
						num++;
					}
					break;
				case XPathNodeType.Namespace:
					while (xPathNavigator.MoveToNextNamespace())
					{
						num++;
					}
					break;
				default:
					while (xPathNavigator.MoveToNext())
					{
						num++;
					}
					break;
				}
				return num;
			}
		}

		internal virtual string UniqueId
		{
			get
			{
				XPathNavigator xPathNavigator = Clone();
				BufferBuilder bufferBuilder = new BufferBuilder();
				bufferBuilder.Append(NodeTypeLetter[(int)NodeType]);
				while (true)
				{
					uint num = xPathNavigator.IndexInParent;
					if (!xPathNavigator.MoveToParent())
					{
						break;
					}
					if (num <= 31)
					{
						bufferBuilder.Append(UniqueIdTbl[num]);
						continue;
					}
					bufferBuilder.Append('0');
					do
					{
						bufferBuilder.Append(UniqueIdTbl[num & 0x1F]);
						num >>= 5;
					}
					while (num != 0);
					bufferBuilder.Append('0');
				}
				return bufferBuilder.ToString();
			}
		}

		private object debuggerDisplayProxy => new DebuggerDisplayProxy(this);

		public override string ToString()
		{
			return Value;
		}

		public virtual void SetValue(string value)
		{
			throw new NotSupportedException();
		}

		public virtual void SetTypedValue(object typedValue)
		{
			if (typedValue == null)
			{
				throw new ArgumentNullException("typedValue");
			}
			switch (NodeType)
			{
			default:
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			case XPathNodeType.Element:
			case XPathNodeType.Attribute:
			{
				string text = null;
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null)
				{
					XmlSchemaType schemaType = schemaInfo.SchemaType;
					if (schemaType != null)
					{
						text = schemaType.ValueConverter.ToString(typedValue, this);
						schemaType.Datatype?.ParseValue(text, NameTable, this);
					}
				}
				if (text == null)
				{
					text = XmlUntypedConverter.Untyped.ToString(typedValue, this);
				}
				SetValue(text);
				break;
			}
			}
		}

		public override object ValueAs(Type returnType, IXmlNamespaceResolver nsResolver)
		{
			if (nsResolver == null)
			{
				nsResolver = this;
			}
			IXmlSchemaInfo schemaInfo = SchemaInfo;
			if (schemaInfo != null)
			{
				if (schemaInfo.Validity == XmlSchemaValidity.Valid)
				{
					XmlSchemaType xmlSchemaType = schemaInfo.MemberType;
					if (xmlSchemaType == null)
					{
						xmlSchemaType = schemaInfo.SchemaType;
					}
					if (xmlSchemaType != null)
					{
						return xmlSchemaType.ValueConverter.ChangeType(Value, returnType, nsResolver);
					}
				}
				else
				{
					XmlSchemaType xmlSchemaType = schemaInfo.SchemaType;
					if (xmlSchemaType != null)
					{
						XmlSchemaDatatype datatype = xmlSchemaType.Datatype;
						if (datatype != null)
						{
							return xmlSchemaType.ValueConverter.ChangeType(datatype.ParseValue(Value, NameTable, nsResolver), returnType, nsResolver);
						}
					}
				}
			}
			return XmlUntypedConverter.Untyped.ChangeType(Value, returnType, nsResolver);
		}

		object ICloneable.Clone()
		{
			return Clone();
		}

		public virtual XPathNavigator CreateNavigator()
		{
			return Clone();
		}

		public virtual string LookupNamespace(string prefix)
		{
			if (prefix == null)
			{
				return null;
			}
			if (NodeType != XPathNodeType.Element)
			{
				XPathNavigator xPathNavigator = Clone();
				if (xPathNavigator.MoveToParent())
				{
					return xPathNavigator.LookupNamespace(prefix);
				}
			}
			else if (MoveToNamespace(prefix))
			{
				string value = Value;
				MoveToParent();
				return value;
			}
			if (prefix.Length == 0)
			{
				return string.Empty;
			}
			if (prefix == "xml")
			{
				return "http://www.w3.org/XML/1998/namespace";
			}
			if (prefix == "xmlns")
			{
				return "http://www.w3.org/2000/xmlns/";
			}
			return null;
		}

		public virtual string LookupPrefix(string namespaceURI)
		{
			if (namespaceURI == null)
			{
				return null;
			}
			XPathNavigator xPathNavigator = Clone();
			if (NodeType != XPathNodeType.Element)
			{
				if (xPathNavigator.MoveToParent())
				{
					return xPathNavigator.LookupPrefix(namespaceURI);
				}
			}
			else if (xPathNavigator.MoveToFirstNamespace(XPathNamespaceScope.All))
			{
				do
				{
					if (namespaceURI == xPathNavigator.Value)
					{
						return xPathNavigator.LocalName;
					}
				}
				while (xPathNavigator.MoveToNextNamespace(XPathNamespaceScope.All));
			}
			if (namespaceURI == LookupNamespace(string.Empty))
			{
				return string.Empty;
			}
			if (namespaceURI == "http://www.w3.org/XML/1998/namespace")
			{
				return "xml";
			}
			if (namespaceURI == "http://www.w3.org/2000/xmlns/")
			{
				return "xmlns";
			}
			return null;
		}

		public virtual IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope)
		{
			XPathNodeType nodeType = NodeType;
			if ((nodeType != XPathNodeType.Element && scope != XmlNamespaceScope.Local) || nodeType == XPathNodeType.Attribute || nodeType == XPathNodeType.Namespace)
			{
				XPathNavigator xPathNavigator = Clone();
				if (xPathNavigator.MoveToParent())
				{
					return xPathNavigator.GetNamespacesInScope(scope);
				}
			}
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			if (scope == XmlNamespaceScope.All)
			{
				dictionary["xml"] = "http://www.w3.org/XML/1998/namespace";
			}
			if (MoveToFirstNamespace((XPathNamespaceScope)scope))
			{
				do
				{
					string localName = LocalName;
					string value = Value;
					if (localName.Length != 0 || value.Length != 0 || scope == XmlNamespaceScope.Local)
					{
						dictionary[localName] = value;
					}
				}
				while (MoveToNextNamespace((XPathNamespaceScope)scope));
				MoveToParent();
			}
			return dictionary;
		}

		public abstract XPathNavigator Clone();

		public virtual XmlReader ReadSubtree()
		{
			switch (NodeType)
			{
			default:
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			case XPathNodeType.Root:
			case XPathNodeType.Element:
				return CreateReader();
			}
		}

		public virtual void WriteSubtree(XmlWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			writer.WriteNode(this, defattr: true);
		}

		public virtual string GetAttribute(string localName, string namespaceURI)
		{
			if (!MoveToAttribute(localName, namespaceURI))
			{
				return "";
			}
			string value = Value;
			MoveToParent();
			return value;
		}

		public virtual bool MoveToAttribute(string localName, string namespaceURI)
		{
			if (MoveToFirstAttribute())
			{
				do
				{
					if (localName == LocalName && namespaceURI == NamespaceURI)
					{
						return true;
					}
				}
				while (MoveToNextAttribute());
				MoveToParent();
			}
			return false;
		}

		public abstract bool MoveToFirstAttribute();

		public abstract bool MoveToNextAttribute();

		public virtual string GetNamespace(string name)
		{
			if (!MoveToNamespace(name))
			{
				if (name == "xml")
				{
					return "http://www.w3.org/XML/1998/namespace";
				}
				if (name == "xmlns")
				{
					return "http://www.w3.org/2000/xmlns/";
				}
				return string.Empty;
			}
			string value = Value;
			MoveToParent();
			return value;
		}

		public virtual bool MoveToNamespace(string name)
		{
			if (MoveToFirstNamespace(XPathNamespaceScope.All))
			{
				do
				{
					if (name == LocalName)
					{
						return true;
					}
				}
				while (MoveToNextNamespace(XPathNamespaceScope.All));
				MoveToParent();
			}
			return false;
		}

		public abstract bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope);

		public abstract bool MoveToNextNamespace(XPathNamespaceScope namespaceScope);

		public bool MoveToFirstNamespace()
		{
			return MoveToFirstNamespace(XPathNamespaceScope.All);
		}

		public bool MoveToNextNamespace()
		{
			return MoveToNextNamespace(XPathNamespaceScope.All);
		}

		public abstract bool MoveToNext();

		public abstract bool MoveToPrevious();

		public virtual bool MoveToFirst()
		{
			switch (NodeType)
			{
			case XPathNodeType.Attribute:
			case XPathNodeType.Namespace:
				return false;
			default:
				if (!MoveToParent())
				{
					return false;
				}
				return MoveToFirstChild();
			}
		}

		public abstract bool MoveToFirstChild();

		public abstract bool MoveToParent();

		public virtual void MoveToRoot()
		{
			while (MoveToParent())
			{
			}
		}

		public abstract bool MoveTo(XPathNavigator other);

		public abstract bool MoveToId(string id);

		public virtual bool MoveToChild(string localName, string namespaceURI)
		{
			if (MoveToFirstChild())
			{
				do
				{
					if (NodeType == XPathNodeType.Element && localName == LocalName && namespaceURI == NamespaceURI)
					{
						return true;
					}
				}
				while (MoveToNext());
				MoveToParent();
			}
			return false;
		}

		public virtual bool MoveToChild(XPathNodeType type)
		{
			if (MoveToFirstChild())
			{
				int contentKindMask = GetContentKindMask(type);
				do
				{
					if (((1 << (int)NodeType) & contentKindMask) != 0)
					{
						return true;
					}
				}
				while (MoveToNext());
				MoveToParent();
			}
			return false;
		}

		public virtual bool MoveToFollowing(string localName, string namespaceURI)
		{
			return MoveToFollowing(localName, namespaceURI, null);
		}

		public virtual bool MoveToFollowing(string localName, string namespaceURI, XPathNavigator end)
		{
			XPathNavigator other = Clone();
			if (end != null)
			{
				switch (end.NodeType)
				{
				case XPathNodeType.Attribute:
				case XPathNodeType.Namespace:
					end = end.Clone();
					end.MoveToNonDescendant();
					break;
				}
			}
			switch (NodeType)
			{
			case XPathNodeType.Attribute:
			case XPathNodeType.Namespace:
				if (!MoveToParent())
				{
					return false;
				}
				break;
			}
			do
			{
				if (!MoveToFirstChild())
				{
					while (!MoveToNext())
					{
						if (!MoveToParent())
						{
							MoveTo(other);
							return false;
						}
					}
				}
				if (end != null && IsSamePosition(end))
				{
					MoveTo(other);
					return false;
				}
			}
			while (NodeType != XPathNodeType.Element || localName != LocalName || namespaceURI != NamespaceURI);
			return true;
		}

		public virtual bool MoveToFollowing(XPathNodeType type)
		{
			return MoveToFollowing(type, null);
		}

		public virtual bool MoveToFollowing(XPathNodeType type, XPathNavigator end)
		{
			XPathNavigator other = Clone();
			int contentKindMask = GetContentKindMask(type);
			if (end != null)
			{
				switch (end.NodeType)
				{
				case XPathNodeType.Attribute:
				case XPathNodeType.Namespace:
					end = end.Clone();
					end.MoveToNonDescendant();
					break;
				}
			}
			switch (NodeType)
			{
			case XPathNodeType.Attribute:
			case XPathNodeType.Namespace:
				if (!MoveToParent())
				{
					return false;
				}
				break;
			}
			do
			{
				if (!MoveToFirstChild())
				{
					while (!MoveToNext())
					{
						if (!MoveToParent())
						{
							MoveTo(other);
							return false;
						}
					}
				}
				if (end != null && IsSamePosition(end))
				{
					MoveTo(other);
					return false;
				}
			}
			while (((1 << (int)NodeType) & contentKindMask) == 0);
			return true;
		}

		public virtual bool MoveToNext(string localName, string namespaceURI)
		{
			XPathNavigator other = Clone();
			while (MoveToNext())
			{
				if (NodeType == XPathNodeType.Element && localName == LocalName && namespaceURI == NamespaceURI)
				{
					return true;
				}
			}
			MoveTo(other);
			return false;
		}

		public virtual bool MoveToNext(XPathNodeType type)
		{
			XPathNavigator other = Clone();
			int contentKindMask = GetContentKindMask(type);
			while (MoveToNext())
			{
				if (((1 << (int)NodeType) & contentKindMask) != 0)
				{
					return true;
				}
			}
			MoveTo(other);
			return false;
		}

		public abstract bool IsSamePosition(XPathNavigator other);

		public virtual bool IsDescendant(XPathNavigator nav)
		{
			if (nav != null)
			{
				nav = nav.Clone();
				while (nav.MoveToParent())
				{
					if (nav.IsSamePosition(this))
					{
						return true;
					}
				}
			}
			return false;
		}

		public virtual XmlNodeOrder ComparePosition(XPathNavigator nav)
		{
			if (nav == null)
			{
				return XmlNodeOrder.Unknown;
			}
			if (IsSamePosition(nav))
			{
				return XmlNodeOrder.Same;
			}
			XPathNavigator xPathNavigator = Clone();
			XPathNavigator xPathNavigator2 = nav.Clone();
			int num = GetDepth(xPathNavigator.Clone());
			int num2 = GetDepth(xPathNavigator2.Clone());
			if (num > num2)
			{
				while (num > num2)
				{
					xPathNavigator.MoveToParent();
					num--;
				}
				if (xPathNavigator.IsSamePosition(xPathNavigator2))
				{
					return XmlNodeOrder.After;
				}
			}
			if (num2 > num)
			{
				while (num2 > num)
				{
					xPathNavigator2.MoveToParent();
					num2--;
				}
				if (xPathNavigator.IsSamePosition(xPathNavigator2))
				{
					return XmlNodeOrder.Before;
				}
			}
			XPathNavigator xPathNavigator3 = xPathNavigator.Clone();
			XPathNavigator xPathNavigator4 = xPathNavigator2.Clone();
			while (true)
			{
				if (!xPathNavigator3.MoveToParent() || !xPathNavigator4.MoveToParent())
				{
					return XmlNodeOrder.Unknown;
				}
				if (xPathNavigator3.IsSamePosition(xPathNavigator4))
				{
					break;
				}
				xPathNavigator.MoveToParent();
				xPathNavigator2.MoveToParent();
			}
			_ = xPathNavigator.GetType().ToString() != "Microsoft.VisualStudio.Modeling.StoreNavigator";
			return CompareSiblings(xPathNavigator, xPathNavigator2);
		}

		public virtual bool CheckValidity(XmlSchemaSet schemas, ValidationEventHandler validationEventHandler)
		{
			XmlSchemaType xmlSchemaType = null;
			XmlSchemaElement xmlSchemaElement = null;
			XmlSchemaAttribute xmlSchemaAttribute = null;
			switch (NodeType)
			{
			case XPathNodeType.Root:
				if (schemas == null)
				{
					throw new InvalidOperationException(Res.GetString("XPathDocument_MissingSchemas"));
				}
				xmlSchemaType = null;
				break;
			case XPathNodeType.Element:
			{
				if (schemas == null)
				{
					throw new InvalidOperationException(Res.GetString("XPathDocument_MissingSchemas"));
				}
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null)
				{
					xmlSchemaType = schemaInfo.SchemaType;
					xmlSchemaElement = schemaInfo.SchemaElement;
				}
				if (xmlSchemaType == null && xmlSchemaElement == null)
				{
					throw new InvalidOperationException(Res.GetString("XPathDocument_NotEnoughSchemaInfo", null));
				}
				break;
			}
			case XPathNodeType.Attribute:
			{
				if (schemas == null)
				{
					throw new InvalidOperationException(Res.GetString("XPathDocument_MissingSchemas"));
				}
				IXmlSchemaInfo schemaInfo = SchemaInfo;
				if (schemaInfo != null)
				{
					xmlSchemaType = schemaInfo.SchemaType;
					xmlSchemaAttribute = schemaInfo.SchemaAttribute;
				}
				if (xmlSchemaType == null && xmlSchemaAttribute == null)
				{
					throw new InvalidOperationException(Res.GetString("XPathDocument_NotEnoughSchemaInfo", null));
				}
				break;
			}
			default:
				throw new InvalidOperationException(Res.GetString("XPathDocument_ValidateInvalidNodeType", null));
			}
			XmlReader xmlReader = CreateReader();
			CheckValidityHelper checkValidityHelper = new CheckValidityHelper(validationEventHandler, xmlReader as XPathNavigatorReader);
			validationEventHandler = checkValidityHelper.ValidationCallback;
			XmlReader validatingReader = GetValidatingReader(xmlReader, schemas, validationEventHandler, xmlSchemaType, xmlSchemaElement, xmlSchemaAttribute);
			while (validatingReader.Read())
			{
			}
			return checkValidityHelper.IsValid;
		}

		private XmlReader GetValidatingReader(XmlReader reader, XmlSchemaSet schemas, ValidationEventHandler validationEvent, XmlSchemaType schemaType, XmlSchemaElement schemaElement, XmlSchemaAttribute schemaAttribute)
		{
			if (schemaAttribute != null)
			{
				return schemaAttribute.Validate(reader, null, schemas, validationEvent);
			}
			if (schemaElement != null)
			{
				return schemaElement.Validate(reader, null, schemas, validationEvent);
			}
			if (schemaType != null)
			{
				return schemaType.Validate(reader, null, schemas, validationEvent);
			}
			XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
			xmlReaderSettings.ConformanceLevel = ConformanceLevel.Auto;
			xmlReaderSettings.ValidationType = ValidationType.Schema;
			xmlReaderSettings.Schemas = schemas;
			xmlReaderSettings.ValidationEventHandler += validationEvent;
			return XmlReader.Create(reader, xmlReaderSettings);
		}

		public virtual XPathExpression Compile(string xpath)
		{
			return XPathExpression.Compile(xpath);
		}

		public virtual XPathNavigator SelectSingleNode(string xpath)
		{
			return SelectSingleNode(XPathExpression.Compile(xpath));
		}

		public virtual XPathNavigator SelectSingleNode(string xpath, IXmlNamespaceResolver resolver)
		{
			return SelectSingleNode(XPathExpression.Compile(xpath, resolver));
		}

		public virtual XPathNavigator SelectSingleNode(XPathExpression expression)
		{
			XPathNodeIterator xPathNodeIterator = Select(expression);
			if (xPathNodeIterator.MoveNext())
			{
				return xPathNodeIterator.Current;
			}
			return null;
		}

		public virtual XPathNodeIterator Select(string xpath)
		{
			return Select(XPathExpression.Compile(xpath));
		}

		public virtual XPathNodeIterator Select(string xpath, IXmlNamespaceResolver resolver)
		{
			return Select(XPathExpression.Compile(xpath, resolver));
		}

		public virtual XPathNodeIterator Select(XPathExpression expr)
		{
			if (!(Evaluate(expr) is XPathNodeIterator result))
			{
				throw XPathException.Create("Xp_NodeSetExpected");
			}
			return result;
		}

		public virtual object Evaluate(string xpath)
		{
			return Evaluate(XPathExpression.Compile(xpath), null);
		}

		public virtual object Evaluate(string xpath, IXmlNamespaceResolver resolver)
		{
			return Evaluate(XPathExpression.Compile(xpath, resolver));
		}

		public virtual object Evaluate(XPathExpression expr)
		{
			return Evaluate(expr, null);
		}

		public virtual object Evaluate(XPathExpression expr, XPathNodeIterator context)
		{
			if (!(expr is CompiledXpathExpr compiledXpathExpr))
			{
				throw XPathException.Create("Xp_BadQueryObject");
			}
			Query query = Query.Clone(compiledXpathExpr.QueryTree);
			query.Reset();
			if (context == null)
			{
				context = new XPathSingletonIterator(Clone(), moved: true);
			}
			object obj = query.Evaluate(context);
			if (obj is XPathNodeIterator)
			{
				return new XPathSelectionIterator(context.Current, query);
			}
			return obj;
		}

		public virtual bool Matches(XPathExpression expr)
		{
			if (!(expr is CompiledXpathExpr compiledXpathExpr))
			{
				throw XPathException.Create("Xp_BadQueryObject");
			}
			Query query = Query.Clone(compiledXpathExpr.QueryTree);
			try
			{
				return query.MatchNode(this) != null;
			}
			catch (XPathException)
			{
				throw XPathException.Create("Xp_InvalidPattern", compiledXpathExpr.Expression);
			}
		}

		public virtual bool Matches(string xpath)
		{
			return Matches(CompileMatchPattern(xpath));
		}

		public virtual XPathNodeIterator SelectChildren(XPathNodeType type)
		{
			return new XPathChildIterator(Clone(), type);
		}

		public virtual XPathNodeIterator SelectChildren(string name, string namespaceURI)
		{
			return new XPathChildIterator(Clone(), name, namespaceURI);
		}

		public virtual XPathNodeIterator SelectAncestors(XPathNodeType type, bool matchSelf)
		{
			return new XPathAncestorIterator(Clone(), type, matchSelf);
		}

		public virtual XPathNodeIterator SelectAncestors(string name, string namespaceURI, bool matchSelf)
		{
			return new XPathAncestorIterator(Clone(), name, namespaceURI, matchSelf);
		}

		public virtual XPathNodeIterator SelectDescendants(XPathNodeType type, bool matchSelf)
		{
			return new XPathDescendantIterator(Clone(), type, matchSelf);
		}

		public virtual XPathNodeIterator SelectDescendants(string name, string namespaceURI, bool matchSelf)
		{
			return new XPathDescendantIterator(Clone(), name, namespaceURI, matchSelf);
		}

		public virtual XmlWriter PrependChild()
		{
			throw new NotSupportedException();
		}

		public virtual XmlWriter AppendChild()
		{
			throw new NotSupportedException();
		}

		public virtual XmlWriter InsertAfter()
		{
			throw new NotSupportedException();
		}

		public virtual XmlWriter InsertBefore()
		{
			throw new NotSupportedException();
		}

		public virtual XmlWriter CreateAttributes()
		{
			throw new NotSupportedException();
		}

		public virtual XmlWriter ReplaceRange(XPathNavigator lastSiblingToReplace)
		{
			throw new NotSupportedException();
		}

		public virtual void ReplaceSelf(string newNode)
		{
			XmlReader newNode2 = CreateContextReader(newNode, fromCurrentNode: false);
			ReplaceSelf(newNode2);
		}

		public virtual void ReplaceSelf(XmlReader newNode)
		{
			if (newNode == null)
			{
				throw new ArgumentNullException("newNode");
			}
			XPathNodeType nodeType = NodeType;
			if (nodeType == XPathNodeType.Root || nodeType == XPathNodeType.Attribute || nodeType == XPathNodeType.Namespace)
			{
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			}
			XmlWriter xmlWriter = ReplaceRange(this);
			BuildSubtree(newNode, xmlWriter);
			xmlWriter.Close();
		}

		public virtual void ReplaceSelf(XPathNavigator newNode)
		{
			if (newNode == null)
			{
				throw new ArgumentNullException("newNode");
			}
			XmlReader newNode2 = newNode.CreateReader();
			ReplaceSelf(newNode2);
		}

		public virtual void AppendChild(string newChild)
		{
			XmlReader newChild2 = CreateContextReader(newChild, fromCurrentNode: true);
			AppendChild(newChild2);
		}

		public virtual void AppendChild(XmlReader newChild)
		{
			if (newChild == null)
			{
				throw new ArgumentNullException("newChild");
			}
			XmlWriter xmlWriter = AppendChild();
			BuildSubtree(newChild, xmlWriter);
			xmlWriter.Close();
		}

		public virtual void AppendChild(XPathNavigator newChild)
		{
			if (newChild == null)
			{
				throw new ArgumentNullException("newChild");
			}
			if (!IsValidChildType(newChild.NodeType))
			{
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			}
			XmlReader newChild2 = newChild.CreateReader();
			AppendChild(newChild2);
		}

		public virtual void PrependChild(string newChild)
		{
			XmlReader newChild2 = CreateContextReader(newChild, fromCurrentNode: true);
			PrependChild(newChild2);
		}

		public virtual void PrependChild(XmlReader newChild)
		{
			if (newChild == null)
			{
				throw new ArgumentNullException("newChild");
			}
			XmlWriter xmlWriter = PrependChild();
			BuildSubtree(newChild, xmlWriter);
			xmlWriter.Close();
		}

		public virtual void PrependChild(XPathNavigator newChild)
		{
			if (newChild == null)
			{
				throw new ArgumentNullException("newChild");
			}
			if (!IsValidChildType(newChild.NodeType))
			{
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			}
			XmlReader newChild2 = newChild.CreateReader();
			PrependChild(newChild2);
		}

		public virtual void InsertBefore(string newSibling)
		{
			XmlReader newSibling2 = CreateContextReader(newSibling, fromCurrentNode: false);
			InsertBefore(newSibling2);
		}

		public virtual void InsertBefore(XmlReader newSibling)
		{
			if (newSibling == null)
			{
				throw new ArgumentNullException("newSibling");
			}
			XmlWriter xmlWriter = InsertBefore();
			BuildSubtree(newSibling, xmlWriter);
			xmlWriter.Close();
		}

		public virtual void InsertBefore(XPathNavigator newSibling)
		{
			if (newSibling == null)
			{
				throw new ArgumentNullException("newSibling");
			}
			if (!IsValidSiblingType(newSibling.NodeType))
			{
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			}
			XmlReader newSibling2 = newSibling.CreateReader();
			InsertBefore(newSibling2);
		}

		public virtual void InsertAfter(string newSibling)
		{
			XmlReader newSibling2 = CreateContextReader(newSibling, fromCurrentNode: false);
			InsertAfter(newSibling2);
		}

		public virtual void InsertAfter(XmlReader newSibling)
		{
			if (newSibling == null)
			{
				throw new ArgumentNullException("newSibling");
			}
			XmlWriter xmlWriter = InsertAfter();
			BuildSubtree(newSibling, xmlWriter);
			xmlWriter.Close();
		}

		public virtual void InsertAfter(XPathNavigator newSibling)
		{
			if (newSibling == null)
			{
				throw new ArgumentNullException("newSibling");
			}
			if (!IsValidSiblingType(newSibling.NodeType))
			{
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			}
			XmlReader newSibling2 = newSibling.CreateReader();
			InsertAfter(newSibling2);
		}

		public virtual void DeleteRange(XPathNavigator lastSiblingToDelete)
		{
			throw new NotSupportedException();
		}

		public virtual void DeleteSelf()
		{
			DeleteRange(this);
		}

		public virtual void PrependChildElement(string prefix, string localName, string namespaceURI, string value)
		{
			XmlWriter xmlWriter = PrependChild();
			xmlWriter.WriteStartElement(prefix, localName, namespaceURI);
			if (value != null)
			{
				xmlWriter.WriteString(value);
			}
			xmlWriter.WriteEndElement();
			xmlWriter.Close();
		}

		public virtual void AppendChildElement(string prefix, string localName, string namespaceURI, string value)
		{
			XmlWriter xmlWriter = AppendChild();
			xmlWriter.WriteStartElement(prefix, localName, namespaceURI);
			if (value != null)
			{
				xmlWriter.WriteString(value);
			}
			xmlWriter.WriteEndElement();
			xmlWriter.Close();
		}

		public virtual void InsertElementBefore(string prefix, string localName, string namespaceURI, string value)
		{
			XmlWriter xmlWriter = InsertBefore();
			xmlWriter.WriteStartElement(prefix, localName, namespaceURI);
			if (value != null)
			{
				xmlWriter.WriteString(value);
			}
			xmlWriter.WriteEndElement();
			xmlWriter.Close();
		}

		public virtual void InsertElementAfter(string prefix, string localName, string namespaceURI, string value)
		{
			XmlWriter xmlWriter = InsertAfter();
			xmlWriter.WriteStartElement(prefix, localName, namespaceURI);
			if (value != null)
			{
				xmlWriter.WriteString(value);
			}
			xmlWriter.WriteEndElement();
			xmlWriter.Close();
		}

		public virtual void CreateAttribute(string prefix, string localName, string namespaceURI, string value)
		{
			XmlWriter xmlWriter = CreateAttributes();
			xmlWriter.WriteStartAttribute(prefix, localName, namespaceURI);
			if (value != null)
			{
				xmlWriter.WriteString(value);
			}
			xmlWriter.WriteEndAttribute();
			xmlWriter.Close();
		}

		internal bool MoveToPrevious(string localName, string namespaceURI)
		{
			XPathNavigator other = Clone();
			localName = ((localName != null) ? NameTable.Get(localName) : null);
			while (MoveToPrevious())
			{
				if (NodeType == XPathNodeType.Element && (object)localName == LocalName && namespaceURI == NamespaceURI)
				{
					return true;
				}
			}
			MoveTo(other);
			return false;
		}

		internal bool MoveToPrevious(XPathNodeType type)
		{
			XPathNavigator other = Clone();
			int contentKindMask = GetContentKindMask(type);
			while (MoveToPrevious())
			{
				if (((1 << (int)NodeType) & contentKindMask) != 0)
				{
					return true;
				}
			}
			MoveTo(other);
			return false;
		}

		internal bool MoveToNonDescendant()
		{
			if (NodeType == XPathNodeType.Root)
			{
				return false;
			}
			if (MoveToNext())
			{
				return true;
			}
			XPathNavigator xPathNavigator = Clone();
			if (!MoveToParent())
			{
				return false;
			}
			switch (xPathNavigator.NodeType)
			{
			case XPathNodeType.Attribute:
			case XPathNodeType.Namespace:
				if (MoveToFirstChild())
				{
					return true;
				}
				break;
			}
			while (!MoveToNext())
			{
				if (!MoveToParent())
				{
					MoveTo(xPathNavigator);
					return false;
				}
			}
			return true;
		}

		private static XPathExpression CompileMatchPattern(string xpath)
		{
			bool needContext;
			Query query = new QueryBuilder().BuildPatternQuery(xpath, out needContext);
			return new CompiledXpathExpr(query, xpath, needContext);
		}

		private static int GetDepth(XPathNavigator nav)
		{
			int num = 0;
			while (nav.MoveToParent())
			{
				num++;
			}
			return num;
		}

		private XmlNodeOrder CompareSiblings(XPathNavigator n1, XPathNavigator n2)
		{
			int num = 0;
			switch (n1.NodeType)
			{
			case XPathNodeType.Attribute:
				num++;
				break;
			default:
				num += 2;
				break;
			case XPathNodeType.Namespace:
				break;
			}
			switch (n2.NodeType)
			{
			case XPathNodeType.Namespace:
				if (num != 0)
				{
					break;
				}
				while (n1.MoveToNextNamespace())
				{
					if (n1.IsSamePosition(n2))
					{
						return XmlNodeOrder.Before;
					}
				}
				break;
			case XPathNodeType.Attribute:
				num--;
				if (num != 0)
				{
					break;
				}
				while (n1.MoveToNextAttribute())
				{
					if (n1.IsSamePosition(n2))
					{
						return XmlNodeOrder.Before;
					}
				}
				break;
			default:
				num -= 2;
				if (num != 0)
				{
					break;
				}
				while (n1.MoveToNext())
				{
					if (n1.IsSamePosition(n2))
					{
						return XmlNodeOrder.Before;
					}
				}
				break;
			}
			if (num >= 0)
			{
				return XmlNodeOrder.After;
			}
			return XmlNodeOrder.Before;
		}

		internal static XmlNamespaceManager GetNamespaces(IXmlNamespaceResolver resolver)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(new NameTable());
			IDictionary<string, string> namespacesInScope = resolver.GetNamespacesInScope(XmlNamespaceScope.All);
			foreach (KeyValuePair<string, string> item in namespacesInScope)
			{
				if (item.Key != "xmlns")
				{
					xmlNamespaceManager.AddNamespace(item.Key, item.Value);
				}
			}
			return xmlNamespaceManager;
		}

		internal static int GetContentKindMask(XPathNodeType type)
		{
			return ContentKindMasks[(int)type];
		}

		internal static int GetKindMask(XPathNodeType type)
		{
			return type switch
			{
				XPathNodeType.All => int.MaxValue, 
				XPathNodeType.Text => 112, 
				_ => 1 << (int)type, 
			};
		}

		internal static bool IsText(XPathNodeType type)
		{
			return ((1 << (int)type) & 0x70) != 0;
		}

		private bool IsValidChildType(XPathNodeType type)
		{
			switch (NodeType)
			{
			case XPathNodeType.Root:
				switch (type)
				{
				case XPathNodeType.Element:
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					return true;
				}
				break;
			case XPathNodeType.Element:
				switch (type)
				{
				case XPathNodeType.Element:
				case XPathNodeType.Text:
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					return true;
				}
				break;
			}
			return false;
		}

		private bool IsValidSiblingType(XPathNodeType type)
		{
			switch (NodeType)
			{
			case XPathNodeType.Element:
			case XPathNodeType.Text:
			case XPathNodeType.SignificantWhitespace:
			case XPathNodeType.Whitespace:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
				switch (type)
				{
				case XPathNodeType.Element:
				case XPathNodeType.Text:
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					return true;
				}
				break;
			}
			return false;
		}

		private XmlReader CreateReader()
		{
			return XPathNavigatorReader.Create(this);
		}

		private XmlReader CreateContextReader(string xml, bool fromCurrentNode)
		{
			if (xml == null)
			{
				throw new ArgumentNullException("xml");
			}
			XPathNavigator xPathNavigator = CreateNavigator();
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(NameTable);
			if (!fromCurrentNode)
			{
				xPathNavigator.MoveToParent();
			}
			if (xPathNavigator.MoveToFirstNamespace(XPathNamespaceScope.All))
			{
				do
				{
					xmlNamespaceManager.AddNamespace(xPathNavigator.LocalName, xPathNavigator.Value);
				}
				while (xPathNavigator.MoveToNextNamespace(XPathNamespaceScope.All));
			}
			XmlParserContext context = new XmlParserContext(NameTable, xmlNamespaceManager, null, XmlSpace.Default);
			XmlTextReader xmlTextReader = new XmlTextReader(xml, XmlNodeType.Element, context);
			xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
			return xmlTextReader;
		}

		internal void BuildSubtree(XmlReader reader, XmlWriter writer)
		{
			string text = "http://www.w3.org/2000/xmlns/";
			ReadState readState = reader.ReadState;
			if (readState != 0 && readState != ReadState.Interactive)
			{
				throw new ArgumentException(Res.GetString("Xml_InvalidOperation"), "reader");
			}
			int num = 0;
			if (readState == ReadState.Initial)
			{
				if (!reader.Read())
				{
					return;
				}
				num++;
			}
			do
			{
				switch (reader.NodeType)
				{
				case XmlNodeType.Element:
				{
					writer.WriteStartElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
					bool isEmptyElement = reader.IsEmptyElement;
					while (reader.MoveToNextAttribute())
					{
						if ((object)reader.NamespaceURI == text)
						{
							if (reader.Prefix.Length == 0)
							{
								writer.WriteAttributeString("", "xmlns", text, reader.Value);
							}
							else
							{
								writer.WriteAttributeString("xmlns", reader.LocalName, text, reader.Value);
							}
						}
						else
						{
							writer.WriteStartAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI);
							writer.WriteString(reader.Value);
							writer.WriteEndAttribute();
						}
					}
					reader.MoveToElement();
					if (isEmptyElement)
					{
						writer.WriteEndElement();
					}
					else
					{
						num++;
					}
					break;
				}
				case XmlNodeType.EndElement:
					writer.WriteFullEndElement();
					num--;
					break;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
					writer.WriteString(reader.Value);
					break;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					writer.WriteString(reader.Value);
					break;
				case XmlNodeType.Comment:
					writer.WriteComment(reader.Value);
					break;
				case XmlNodeType.ProcessingInstruction:
					writer.WriteProcessingInstruction(reader.LocalName, reader.Value);
					break;
				case XmlNodeType.EntityReference:
					reader.ResolveEntity();
					break;
				case XmlNodeType.Attribute:
					if ((object)reader.NamespaceURI == text)
					{
						if (reader.Prefix.Length == 0)
						{
							writer.WriteAttributeString("", "xmlns", text, reader.Value);
						}
						else
						{
							writer.WriteAttributeString("xmlns", reader.LocalName, text, reader.Value);
						}
					}
					else
					{
						writer.WriteStartAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI);
						writer.WriteString(reader.Value);
						writer.WriteEndAttribute();
					}
					break;
				}
			}
			while (reader.Read() && num > 0);
		}
	}
}
namespace System.Xml
{
	internal sealed class DocumentXPathNavigator : XPathNavigator, IHasXmlNode
	{
		private XmlDocument document;

		private XmlNode source;

		private int attributeIndex;

		private XmlElement namespaceParent;

		public override XmlNameTable NameTable => document.NameTable;

		public override XPathNodeType NodeType
		{
			get
			{
				CalibrateText();
				return source.XPNodeType;
			}
		}

		public override string LocalName => source.XPLocalName;

		public override string NamespaceURI
		{
			get
			{
				if (source is XmlAttribute xmlAttribute && xmlAttribute.IsNamespace)
				{
					return string.Empty;
				}
				return source.NamespaceURI;
			}
		}

		public override string Name
		{
			get
			{
				switch (source.NodeType)
				{
				case XmlNodeType.Element:
				case XmlNodeType.ProcessingInstruction:
					return source.Name;
				case XmlNodeType.Attribute:
					if (((XmlAttribute)source).IsNamespace)
					{
						string localName = source.LocalName;
						if (object.Equals(localName, document.strXmlns))
						{
							return string.Empty;
						}
						return localName;
					}
					return source.Name;
				default:
					return string.Empty;
				}
			}
		}

		public override string Prefix
		{
			get
			{
				if (source is XmlAttribute xmlAttribute && xmlAttribute.IsNamespace)
				{
					return string.Empty;
				}
				return source.Prefix;
			}
		}

		public override string Value
		{
			get
			{
				switch (source.NodeType)
				{
				case XmlNodeType.Element:
				case XmlNodeType.DocumentFragment:
					return source.InnerText;
				case XmlNodeType.Document:
					return ValueDocument;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					return ValueText;
				default:
					return source.Value;
				}
			}
		}

		private string ValueDocument
		{
			get
			{
				XmlElement documentElement = document.DocumentElement;
				if (documentElement != null)
				{
					return documentElement.InnerText;
				}
				return string.Empty;
			}
		}

		private string ValueText
		{
			get
			{
				CalibrateText();
				string text = source.Value;
				XmlNode xmlNode = NextSibling(source);
				if (xmlNode != null && xmlNode.IsText)
				{
					StringBuilder stringBuilder = new StringBuilder(text);
					do
					{
						stringBuilder.Append(xmlNode.Value);
						xmlNode = NextSibling(xmlNode);
					}
					while (xmlNode != null && xmlNode.IsText);
					text = stringBuilder.ToString();
				}
				return text;
			}
		}

		public override string BaseURI => source.BaseURI;

		public override bool IsEmptyElement
		{
			get
			{
				if (source is XmlElement xmlElement)
				{
					return xmlElement.IsEmpty;
				}
				return false;
			}
		}

		public override string XmlLang => source.XmlLang;

		public override object UnderlyingObject
		{
			get
			{
				CalibrateText();
				return source;
			}
		}

		public override bool HasAttributes
		{
			get
			{
				if (source is XmlElement xmlElement && xmlElement.HasAttributes)
				{
					XmlAttributeCollection attributes = xmlElement.Attributes;
					for (int i = 0; i < attributes.Count; i++)
					{
						XmlAttribute xmlAttribute = attributes[i];
						if (!xmlAttribute.IsNamespace)
						{
							return true;
						}
					}
				}
				return false;
			}
		}

		public override bool HasChildren
		{
			get
			{
				switch (source.NodeType)
				{
				case XmlNodeType.Element:
				{
					XmlNode xmlNode = FirstChild(source);
					if (xmlNode == null)
					{
						return false;
					}
					return true;
				}
				case XmlNodeType.Document:
				case XmlNodeType.DocumentFragment:
				{
					XmlNode xmlNode = FirstChild(source);
					if (xmlNode == null)
					{
						return false;
					}
					while (!IsValidChild(source, xmlNode))
					{
						xmlNode = NextSibling(xmlNode);
						if (xmlNode == null)
						{
							return false;
						}
					}
					return true;
				}
				default:
					return false;
				}
			}
		}

		public override IXmlSchemaInfo SchemaInfo => source.SchemaInfo;

		public override bool CanEdit => true;

		public DocumentXPathNavigator(XmlDocument document, XmlNode node)
		{
			this.document = document;
			ResetPosition(node);
		}

		public DocumentXPathNavigator(DocumentXPathNavigator other)
		{
			document = other.document;
			source = other.source;
			attributeIndex = other.attributeIndex;
			namespaceParent = other.namespaceParent;
		}

		public override XPathNavigator Clone()
		{
			return new DocumentXPathNavigator(this);
		}

		public override void SetValue(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			XmlNode xmlNode = source;
			switch (xmlNode.NodeType)
			{
			case XmlNodeType.Attribute:
				if (!((XmlAttribute)xmlNode).IsNamespace)
				{
					xmlNode.InnerText = value;
					return;
				}
				break;
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
			{
				CalibrateText();
				xmlNode = source;
				XmlNode xmlNode2 = TextEnd(xmlNode);
				if (xmlNode != xmlNode2)
				{
					if (xmlNode.IsReadOnly)
					{
						throw new InvalidOperationException(Res.GetString("Xdom_Node_Modify_ReadOnly"));
					}
					DeleteToFollowingSibling(xmlNode.NextSibling, xmlNode2);
				}
				goto case XmlNodeType.Element;
			}
			case XmlNodeType.Element:
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Comment:
				xmlNode.InnerText = value;
				return;
			}
			throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
		}

		public override string GetAttribute(string localName, string namespaceURI)
		{
			return source.GetXPAttribute(localName, namespaceURI);
		}

		public override bool MoveToAttribute(string localName, string namespaceURI)
		{
			if (source is XmlElement xmlElement && xmlElement.HasAttributes)
			{
				XmlAttributeCollection attributes = xmlElement.Attributes;
				for (int i = 0; i < attributes.Count; i++)
				{
					XmlAttribute xmlAttribute = attributes[i];
					if (xmlAttribute.LocalName == localName && xmlAttribute.NamespaceURI == namespaceURI)
					{
						if (!xmlAttribute.IsNamespace)
						{
							source = xmlAttribute;
							attributeIndex = i;
							return true;
						}
						return false;
					}
				}
			}
			return false;
		}

		public override bool MoveToFirstAttribute()
		{
			if (source is XmlElement xmlElement && xmlElement.HasAttributes)
			{
				XmlAttributeCollection attributes = xmlElement.Attributes;
				for (int i = 0; i < attributes.Count; i++)
				{
					XmlAttribute xmlAttribute = attributes[i];
					if (!xmlAttribute.IsNamespace)
					{
						source = xmlAttribute;
						attributeIndex = i;
						return true;
					}
				}
			}
			return false;
		}

		public override bool MoveToNextAttribute()
		{
			if (!(source is XmlAttribute xmlAttribute) || xmlAttribute.IsNamespace)
			{
				return false;
			}
			if (!CheckAttributePosition(xmlAttribute, out var attributes, attributeIndex) && !ResetAttributePosition(xmlAttribute, attributes, out attributeIndex))
			{
				return false;
			}
			for (int i = attributeIndex + 1; i < attributes.Count; i++)
			{
				XmlAttribute xmlAttribute2 = attributes[i];
				if (!xmlAttribute2.IsNamespace)
				{
					source = xmlAttribute2;
					attributeIndex = i;
					return true;
				}
			}
			return false;
		}

		public override string GetNamespace(string name)
		{
			XmlNode xmlNode = source;
			while (xmlNode != null && xmlNode.NodeType != XmlNodeType.Element)
			{
				xmlNode = ((!(xmlNode is XmlAttribute xmlAttribute)) ? xmlNode.ParentNode : xmlAttribute.OwnerElement);
			}
			XmlElement xmlElement = xmlNode as XmlElement;
			if (xmlElement != null)
			{
				string localName = ((name == null || name.Length == 0) ? document.strXmlns : name);
				string strReservedXmlns = document.strReservedXmlns;
				do
				{
					XmlAttribute attributeNode = xmlElement.GetAttributeNode(localName, strReservedXmlns);
					if (attributeNode != null)
					{
						return attributeNode.Value;
					}
					xmlElement = xmlElement.ParentNode as XmlElement;
				}
				while (xmlElement != null);
			}
			if (name == document.strXml)
			{
				return document.strReservedXml;
			}
			if (name == document.strXmlns)
			{
				return document.strReservedXmlns;
			}
			return string.Empty;
		}

		public override bool MoveToNamespace(string name)
		{
			if (name == document.strXmlns)
			{
				return false;
			}
			XmlElement xmlElement = source as XmlElement;
			if (xmlElement != null)
			{
				string localName = ((name == null || name.Length == 0) ? document.strXmlns : name);
				string strReservedXmlns = document.strReservedXmlns;
				do
				{
					XmlAttribute attributeNode = xmlElement.GetAttributeNode(localName, strReservedXmlns);
					if (attributeNode != null)
					{
						namespaceParent = (XmlElement)source;
						source = attributeNode;
						return true;
					}
					xmlElement = xmlElement.ParentNode as XmlElement;
				}
				while (xmlElement != null);
				if (name == document.strXml)
				{
					namespaceParent = (XmlElement)source;
					source = document.NamespaceXml;
					return true;
				}
			}
			return false;
		}

		public override bool MoveToFirstNamespace(XPathNamespaceScope scope)
		{
			if (!(source is XmlElement xmlElement))
			{
				return false;
			}
			int index = int.MaxValue;
			switch (scope)
			{
			case XPathNamespaceScope.Local:
			{
				if (!xmlElement.HasAttributes)
				{
					return false;
				}
				XmlAttributeCollection attributes = xmlElement.Attributes;
				if (!MoveToFirstNamespaceLocal(attributes, ref index))
				{
					return false;
				}
				source = attributes[index];
				attributeIndex = index;
				namespaceParent = xmlElement;
				break;
			}
			case XPathNamespaceScope.ExcludeXml:
			{
				XmlAttributeCollection attributes = xmlElement.Attributes;
				if (!MoveToFirstNamespaceGlobal(ref attributes, ref index))
				{
					return false;
				}
				XmlAttribute xmlAttribute = attributes[index];
				while (object.Equals(xmlAttribute.LocalName, document.strXml))
				{
					if (!MoveToNextNamespaceGlobal(ref attributes, ref index))
					{
						return false;
					}
					xmlAttribute = attributes[index];
				}
				source = xmlAttribute;
				attributeIndex = index;
				namespaceParent = xmlElement;
				break;
			}
			case XPathNamespaceScope.All:
			{
				XmlAttributeCollection attributes = xmlElement.Attributes;
				if (!MoveToFirstNamespaceGlobal(ref attributes, ref index))
				{
					source = document.NamespaceXml;
				}
				else
				{
					source = attributes[index];
					attributeIndex = index;
				}
				namespaceParent = xmlElement;
				break;
			}
			default:
				return false;
			}
			return true;
		}

		private static bool MoveToFirstNamespaceLocal(XmlAttributeCollection attributes, ref int index)
		{
			for (int num = attributes.Count - 1; num >= 0; num--)
			{
				XmlAttribute xmlAttribute = attributes[num];
				if (xmlAttribute.IsNamespace)
				{
					index = num;
					return true;
				}
			}
			return false;
		}

		private static bool MoveToFirstNamespaceGlobal(ref XmlAttributeCollection attributes, ref int index)
		{
			if (MoveToFirstNamespaceLocal(attributes, ref index))
			{
				return true;
			}
			for (XmlElement xmlElement = attributes.parent.ParentNode as XmlElement; xmlElement != null; xmlElement = xmlElement.ParentNode as XmlElement)
			{
				if (xmlElement.HasAttributes)
				{
					attributes = xmlElement.Attributes;
					if (MoveToFirstNamespaceLocal(attributes, ref index))
					{
						return true;
					}
				}
			}
			return false;
		}

		public override bool MoveToNextNamespace(XPathNamespaceScope scope)
		{
			if (!(source is XmlAttribute xmlAttribute) || !xmlAttribute.IsNamespace)
			{
				return false;
			}
			int index = attributeIndex;
			if (!CheckAttributePosition(xmlAttribute, out var attributes, index) && !ResetAttributePosition(xmlAttribute, attributes, out index))
			{
				return false;
			}
			switch (scope)
			{
			case XPathNamespaceScope.Local:
				if (xmlAttribute.OwnerElement != namespaceParent)
				{
					return false;
				}
				if (!MoveToNextNamespaceLocal(attributes, ref index))
				{
					return false;
				}
				source = attributes[index];
				attributeIndex = index;
				break;
			case XPathNamespaceScope.ExcludeXml:
			{
				XmlAttribute xmlAttribute2;
				string localName;
				do
				{
					if (!MoveToNextNamespaceGlobal(ref attributes, ref index))
					{
						return false;
					}
					xmlAttribute2 = attributes[index];
					localName = xmlAttribute2.LocalName;
				}
				while (PathHasDuplicateNamespace(xmlAttribute2.OwnerElement, namespaceParent, localName) || object.Equals(localName, document.strXml));
				source = xmlAttribute2;
				attributeIndex = index;
				break;
			}
			case XPathNamespaceScope.All:
			{
				XmlAttribute xmlAttribute2;
				do
				{
					if (!MoveToNextNamespaceGlobal(ref attributes, ref index))
					{
						if (PathHasDuplicateNamespace(null, namespaceParent, document.strXml))
						{
							return false;
						}
						source = document.NamespaceXml;
						return true;
					}
					xmlAttribute2 = attributes[index];
				}
				while (PathHasDuplicateNamespace(xmlAttribute2.OwnerElement, namespaceParent, xmlAttribute2.LocalName));
				source = xmlAttribute2;
				attributeIndex = index;
				break;
			}
			default:
				return false;
			}
			return true;
		}

		private static bool MoveToNextNamespaceLocal(XmlAttributeCollection attributes, ref int index)
		{
			for (int num = index - 1; num >= 0; num--)
			{
				XmlAttribute xmlAttribute = attributes[num];
				if (xmlAttribute.IsNamespace)
				{
					index = num;
					return true;
				}
			}
			return false;
		}

		private static bool MoveToNextNamespaceGlobal(ref XmlAttributeCollection attributes, ref int index)
		{
			if (MoveToNextNamespaceLocal(attributes, ref index))
			{
				return true;
			}
			for (XmlElement xmlElement = attributes.parent.ParentNode as XmlElement; xmlElement != null; xmlElement = xmlElement.ParentNode as XmlElement)
			{
				if (xmlElement.HasAttributes)
				{
					attributes = xmlElement.Attributes;
					if (MoveToFirstNamespaceLocal(attributes, ref index))
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool PathHasDuplicateNamespace(XmlElement top, XmlElement bottom, string localName)
		{
			string strReservedXmlns = document.strReservedXmlns;
			while (bottom != null && bottom != top)
			{
				XmlAttribute attributeNode = bottom.GetAttributeNode(localName, strReservedXmlns);
				if (attributeNode != null)
				{
					return true;
				}
				bottom = bottom.ParentNode as XmlElement;
			}
			return false;
		}

		public override bool MoveToNext()
		{
			XmlNode xmlNode = NextSibling(source);
			if (xmlNode == null)
			{
				return false;
			}
			if (xmlNode.IsText && source.IsText)
			{
				xmlNode = NextSibling(TextEnd(xmlNode));
				if (xmlNode == null)
				{
					return false;
				}
			}
			XmlNode parent = ParentNode(xmlNode);
			while (!IsValidChild(parent, xmlNode))
			{
				xmlNode = NextSibling(xmlNode);
				if (xmlNode == null)
				{
					return false;
				}
			}
			source = xmlNode;
			return true;
		}

		public override bool MoveToPrevious()
		{
			XmlNode xmlNode = PreviousSibling(source);
			if (xmlNode == null)
			{
				return false;
			}
			if (xmlNode.IsText)
			{
				if (source.IsText)
				{
					xmlNode = PreviousSibling(TextStart(xmlNode));
					if (xmlNode == null)
					{
						return false;
					}
				}
				else
				{
					xmlNode = TextStart(xmlNode);
				}
			}
			XmlNode parent = ParentNode(xmlNode);
			while (!IsValidChild(parent, xmlNode))
			{
				xmlNode = PreviousSibling(xmlNode);
				if (xmlNode == null)
				{
					return false;
				}
			}
			source = xmlNode;
			return true;
		}

		public override bool MoveToFirst()
		{
			if (source.NodeType == XmlNodeType.Attribute)
			{
				return false;
			}
			XmlNode xmlNode = ParentNode(source);
			if (xmlNode == null)
			{
				return false;
			}
			XmlNode xmlNode2 = FirstChild(xmlNode);
			while (!IsValidChild(xmlNode, xmlNode2))
			{
				xmlNode2 = NextSibling(xmlNode2);
				if (xmlNode2 == null)
				{
					return false;
				}
			}
			source = xmlNode2;
			return true;
		}

		public override bool MoveToFirstChild()
		{
			XmlNode xmlNode;
			switch (source.NodeType)
			{
			case XmlNodeType.Element:
				xmlNode = FirstChild(source);
				if (xmlNode == null)
				{
					return false;
				}
				break;
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
				xmlNode = FirstChild(source);
				if (xmlNode == null)
				{
					return false;
				}
				while (!IsValidChild(source, xmlNode))
				{
					xmlNode = NextSibling(xmlNode);
					if (xmlNode == null)
					{
						return false;
					}
				}
				break;
			default:
				return false;
			}
			source = xmlNode;
			return true;
		}

		public override bool MoveToParent()
		{
			XmlNode xmlNode = ParentNode(source);
			if (xmlNode != null)
			{
				source = xmlNode;
				return true;
			}
			if (source is XmlAttribute xmlAttribute)
			{
				xmlNode = (xmlAttribute.IsNamespace ? namespaceParent : xmlAttribute.OwnerElement);
				if (xmlNode != null)
				{
					source = xmlNode;
					namespaceParent = null;
					return true;
				}
			}
			return false;
		}

		public override void MoveToRoot()
		{
			while (true)
			{
				XmlNode xmlNode = source.ParentNode;
				if (xmlNode == null)
				{
					if (!(source is XmlAttribute xmlAttribute))
					{
						break;
					}
					xmlNode = (xmlAttribute.IsNamespace ? namespaceParent : xmlAttribute.OwnerElement);
					if (xmlNode == null)
					{
						break;
					}
				}
				source = xmlNode;
			}
			namespaceParent = null;
		}

		public override bool MoveTo(XPathNavigator other)
		{
			if (other is DocumentXPathNavigator documentXPathNavigator && document == documentXPathNavigator.document)
			{
				source = documentXPathNavigator.source;
				attributeIndex = documentXPathNavigator.attributeIndex;
				namespaceParent = documentXPathNavigator.namespaceParent;
				return true;
			}
			return false;
		}

		public override bool MoveToId(string id)
		{
			XmlElement elementById = document.GetElementById(id);
			if (elementById != null)
			{
				source = elementById;
				namespaceParent = null;
				return true;
			}
			return false;
		}

		public override bool MoveToChild(string localName, string namespaceUri)
		{
			if (source.NodeType == XmlNodeType.Attribute)
			{
				return false;
			}
			XmlNode xmlNode = FirstChild(source);
			if (xmlNode != null)
			{
				do
				{
					if (xmlNode.NodeType == XmlNodeType.Element && xmlNode.LocalName == localName && xmlNode.NamespaceURI == namespaceUri)
					{
						source = xmlNode;
						return true;
					}
					xmlNode = NextSibling(xmlNode);
				}
				while (xmlNode != null);
			}
			return false;
		}

		public override bool MoveToChild(XPathNodeType type)
		{
			if (source.NodeType == XmlNodeType.Attribute)
			{
				return false;
			}
			XmlNode xmlNode = FirstChild(source);
			if (xmlNode != null)
			{
				int contentKindMask = XPathNavigator.GetContentKindMask(type);
				if (contentKindMask == 0)
				{
					return false;
				}
				do
				{
					if (((1 << (int)xmlNode.XPNodeType) & contentKindMask) != 0)
					{
						source = xmlNode;
						return true;
					}
					xmlNode = NextSibling(xmlNode);
				}
				while (xmlNode != null);
			}
			return false;
		}

		public override bool MoveToFollowing(string localName, string namespaceUri, XPathNavigator end)
		{
			XmlNode xmlNode = null;
			DocumentXPathNavigator documentXPathNavigator = end as DocumentXPathNavigator;
			if (documentXPathNavigator != null)
			{
				if (document != documentXPathNavigator.document)
				{
					return false;
				}
				XmlNodeType nodeType = documentXPathNavigator.source.NodeType;
				if (nodeType == XmlNodeType.Attribute)
				{
					documentXPathNavigator = (DocumentXPathNavigator)documentXPathNavigator.Clone();
					if (!documentXPathNavigator.MoveToNonDescendant())
					{
						return false;
					}
				}
				xmlNode = documentXPathNavigator.source;
			}
			XmlNode xmlNode2 = source;
			if (xmlNode2.NodeType == XmlNodeType.Attribute)
			{
				xmlNode2 = ((XmlAttribute)xmlNode2).OwnerElement;
				if (xmlNode2 == null)
				{
					return false;
				}
			}
			do
			{
				XmlNode firstChild = xmlNode2.FirstChild;
				if (firstChild != null)
				{
					xmlNode2 = firstChild;
				}
				else
				{
					XmlNode nextSibling;
					while (true)
					{
						nextSibling = xmlNode2.NextSibling;
						if (nextSibling != null)
						{
							break;
						}
						XmlNode parentNode = xmlNode2.ParentNode;
						if (parentNode != null)
						{
							xmlNode2 = parentNode;
							continue;
						}
						return false;
					}
					xmlNode2 = nextSibling;
				}
				if (xmlNode2 == xmlNode)
				{
					return false;
				}
			}
			while (xmlNode2.NodeType != XmlNodeType.Element || xmlNode2.LocalName != localName || xmlNode2.NamespaceURI != namespaceUri);
			source = xmlNode2;
			return true;
		}

		public override bool MoveToFollowing(XPathNodeType type, XPathNavigator end)
		{
			XmlNode xmlNode = null;
			DocumentXPathNavigator documentXPathNavigator = end as DocumentXPathNavigator;
			if (documentXPathNavigator != null)
			{
				if (document != documentXPathNavigator.document)
				{
					return false;
				}
				XmlNodeType nodeType = documentXPathNavigator.source.NodeType;
				if (nodeType == XmlNodeType.Attribute)
				{
					documentXPathNavigator = (DocumentXPathNavigator)documentXPathNavigator.Clone();
					if (!documentXPathNavigator.MoveToNonDescendant())
					{
						return false;
					}
				}
				xmlNode = documentXPathNavigator.source;
			}
			int contentKindMask = XPathNavigator.GetContentKindMask(type);
			if (contentKindMask == 0)
			{
				return false;
			}
			XmlNode xmlNode2 = source;
			switch (xmlNode2.NodeType)
			{
			case XmlNodeType.Attribute:
				xmlNode2 = ((XmlAttribute)xmlNode2).OwnerElement;
				if (xmlNode2 == null)
				{
					return false;
				}
				break;
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				xmlNode2 = TextEnd(xmlNode2);
				break;
			}
			do
			{
				XmlNode firstChild = xmlNode2.FirstChild;
				if (firstChild != null)
				{
					xmlNode2 = firstChild;
				}
				else
				{
					XmlNode nextSibling;
					while (true)
					{
						nextSibling = xmlNode2.NextSibling;
						if (nextSibling != null)
						{
							break;
						}
						XmlNode parentNode = xmlNode2.ParentNode;
						if (parentNode != null)
						{
							xmlNode2 = parentNode;
							continue;
						}
						return false;
					}
					xmlNode2 = nextSibling;
				}
				if (xmlNode2 == xmlNode)
				{
					return false;
				}
			}
			while (((1 << (int)xmlNode2.XPNodeType) & contentKindMask) == 0);
			source = xmlNode2;
			return true;
		}

		public override bool MoveToNext(string localName, string namespaceUri)
		{
			XmlNode xmlNode = NextSibling(source);
			if (xmlNode == null)
			{
				return false;
			}
			do
			{
				if (xmlNode.NodeType == XmlNodeType.Element && xmlNode.LocalName == localName && xmlNode.NamespaceURI == namespaceUri)
				{
					source = xmlNode;
					return true;
				}
				xmlNode = NextSibling(xmlNode);
			}
			while (xmlNode != null);
			return false;
		}

		public override bool MoveToNext(XPathNodeType type)
		{
			XmlNode xmlNode = NextSibling(source);
			if (xmlNode == null)
			{
				return false;
			}
			if (xmlNode.IsText && source.IsText)
			{
				xmlNode = NextSibling(TextEnd(xmlNode));
				if (xmlNode == null)
				{
					return false;
				}
			}
			int contentKindMask = XPathNavigator.GetContentKindMask(type);
			if (contentKindMask == 0)
			{
				return false;
			}
			do
			{
				if (((1 << (int)xmlNode.XPNodeType) & contentKindMask) != 0)
				{
					source = xmlNode;
					return true;
				}
				xmlNode = NextSibling(xmlNode);
			}
			while (xmlNode != null);
			return false;
		}

		public override bool IsSamePosition(XPathNavigator other)
		{
			if (other is DocumentXPathNavigator documentXPathNavigator)
			{
				CalibrateText();
				documentXPathNavigator.CalibrateText();
				if (source == documentXPathNavigator.source)
				{
					return namespaceParent == documentXPathNavigator.namespaceParent;
				}
				return false;
			}
			return false;
		}

		public override bool IsDescendant(XPathNavigator other)
		{
			if (other is DocumentXPathNavigator documentXPathNavigator)
			{
				return IsDescendant(source, documentXPathNavigator.source);
			}
			return false;
		}

		public override bool CheckValidity(XmlSchemaSet schemas, ValidationEventHandler validationEventHandler)
		{
			XmlDocument xmlDocument;
			if (source.NodeType == XmlNodeType.Document)
			{
				xmlDocument = (XmlDocument)source;
			}
			else
			{
				xmlDocument = source.OwnerDocument;
				if (schemas != null)
				{
					throw new ArgumentException(Res.GetString("XPathDocument_SchemaSetNotAllowed", null));
				}
			}
			if (schemas == null && xmlDocument != null)
			{
				schemas = xmlDocument.Schemas;
			}
			if (schemas == null || schemas.Count == 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlDocument_NoSchemaInfo"));
			}
			DocumentSchemaValidator documentSchemaValidator = new DocumentSchemaValidator(xmlDocument, schemas, validationEventHandler);
			documentSchemaValidator.PsviAugmentation = false;
			return documentSchemaValidator.Validate(source);
		}

		private static XmlNode OwnerNode(XmlNode node)
		{
			XmlNode parentNode = node.ParentNode;
			if (parentNode != null)
			{
				return parentNode;
			}
			if (node is XmlAttribute xmlAttribute)
			{
				return xmlAttribute.OwnerElement;
			}
			return null;
		}

		private static int GetDepth(XmlNode node)
		{
			int num = 0;
			for (XmlNode xmlNode = OwnerNode(node); xmlNode != null; xmlNode = OwnerNode(xmlNode))
			{
				num++;
			}
			return num;
		}

		private XmlNodeOrder Compare(XmlNode node1, XmlNode node2)
		{
			if (node1.XPNodeType == XPathNodeType.Attribute)
			{
				if (node2.XPNodeType == XPathNodeType.Attribute)
				{
					XmlElement ownerElement = ((XmlAttribute)node1).OwnerElement;
					if (ownerElement.HasAttributes)
					{
						XmlAttributeCollection attributes = ownerElement.Attributes;
						for (int i = 0; i < attributes.Count; i++)
						{
							XmlAttribute xmlAttribute = attributes[i];
							if (xmlAttribute == node1)
							{
								return XmlNodeOrder.Before;
							}
							if (xmlAttribute == node2)
							{
								return XmlNodeOrder.After;
							}
						}
					}
					return XmlNodeOrder.Unknown;
				}
				return XmlNodeOrder.Before;
			}
			if (node2.XPNodeType == XPathNodeType.Attribute)
			{
				return XmlNodeOrder.After;
			}
			XmlNode nextSibling = node1.NextSibling;
			while (nextSibling != null && nextSibling != node2)
			{
				nextSibling = nextSibling.NextSibling;
			}
			if (nextSibling == null)
			{
				return XmlNodeOrder.After;
			}
			return XmlNodeOrder.Before;
		}

		public override XmlNodeOrder ComparePosition(XPathNavigator other)
		{
			if (!(other is DocumentXPathNavigator documentXPathNavigator))
			{
				return XmlNodeOrder.Unknown;
			}
			CalibrateText();
			documentXPathNavigator.CalibrateText();
			if (source == documentXPathNavigator.source && namespaceParent == documentXPathNavigator.namespaceParent)
			{
				return XmlNodeOrder.Same;
			}
			if (namespaceParent != null || documentXPathNavigator.namespaceParent != null)
			{
				return base.ComparePosition(other);
			}
			XmlNode xmlNode = source;
			XmlNode xmlNode2 = documentXPathNavigator.source;
			XmlNode xmlNode3 = OwnerNode(xmlNode);
			XmlNode xmlNode4 = OwnerNode(xmlNode2);
			if (xmlNode3 == xmlNode4)
			{
				if (xmlNode3 == null)
				{
					return XmlNodeOrder.Unknown;
				}
				return Compare(xmlNode, xmlNode2);
			}
			int num = GetDepth(xmlNode);
			int num2 = GetDepth(xmlNode2);
			if (num2 > num)
			{
				while (xmlNode2 != null && num2 > num)
				{
					xmlNode2 = OwnerNode(xmlNode2);
					num2--;
				}
				if (xmlNode == xmlNode2)
				{
					return XmlNodeOrder.Before;
				}
				xmlNode4 = OwnerNode(xmlNode2);
			}
			else if (num > num2)
			{
				while (xmlNode != null && num > num2)
				{
					xmlNode = OwnerNode(xmlNode);
					num--;
				}
				if (xmlNode == xmlNode2)
				{
					return XmlNodeOrder.After;
				}
				xmlNode3 = OwnerNode(xmlNode);
			}
			while (xmlNode3 != null && xmlNode4 != null)
			{
				if (xmlNode3 == xmlNode4)
				{
					return Compare(xmlNode, xmlNode2);
				}
				xmlNode = xmlNode3;
				xmlNode2 = xmlNode4;
				xmlNode3 = OwnerNode(xmlNode);
				xmlNode4 = OwnerNode(xmlNode2);
			}
			return XmlNodeOrder.Unknown;
		}

		XmlNode IHasXmlNode.GetNode()
		{
			return source;
		}

		public override XPathNodeIterator SelectDescendants(string localName, string namespaceURI, bool matchSelf)
		{
			string text = document.NameTable.Get(namespaceURI);
			if (text == null || source.NodeType == XmlNodeType.Attribute)
			{
				return new DocumentXPathNodeIterator_Empty(this);
			}
			string text2 = document.NameTable.Get(localName);
			if (text2 == null)
			{
				return new DocumentXPathNodeIterator_Empty(this);
			}
			if (text2.Length == 0)
			{
				if (matchSelf)
				{
					return new DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName(this, text);
				}
				return new DocumentXPathNodeIterator_ElemChildren_NoLocalName(this, text);
			}
			if (matchSelf)
			{
				return new DocumentXPathNodeIterator_ElemChildren_AndSelf(this, text2, text);
			}
			return new DocumentXPathNodeIterator_ElemChildren(this, text2, text);
		}

		public override XPathNodeIterator SelectDescendants(XPathNodeType nt, bool includeSelf)
		{
			if (nt == XPathNodeType.Element)
			{
				XmlNodeType nodeType = source.NodeType;
				if (nodeType != XmlNodeType.Document && nodeType != XmlNodeType.Element)
				{
					return new DocumentXPathNodeIterator_Empty(this);
				}
				if (includeSelf)
				{
					return new DocumentXPathNodeIterator_AllElemChildren_AndSelf(this);
				}
				return new DocumentXPathNodeIterator_AllElemChildren(this);
			}
			return base.SelectDescendants(nt, includeSelf);
		}

		public override XmlWriter PrependChild()
		{
			switch (source.NodeType)
			{
			default:
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			case XmlNodeType.Element:
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
			{
				DocumentXmlWriter documentXmlWriter = new DocumentXmlWriter(DocumentXmlWriterType.PrependChild, source, document);
				documentXmlWriter.NamespaceManager = GetNamespaceManager(source, document);
				return new XmlWellFormedWriter(documentXmlWriter, documentXmlWriter.Settings);
			}
			}
		}

		public override XmlWriter AppendChild()
		{
			switch (source.NodeType)
			{
			default:
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			case XmlNodeType.Element:
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
			{
				DocumentXmlWriter documentXmlWriter = new DocumentXmlWriter(DocumentXmlWriterType.AppendChild, source, document);
				documentXmlWriter.NamespaceManager = GetNamespaceManager(source, document);
				return new XmlWellFormedWriter(documentXmlWriter, documentXmlWriter.Settings);
			}
			}
		}

		public override XmlWriter InsertAfter()
		{
			XmlNode xmlNode = source;
			switch (xmlNode.NodeType)
			{
			case XmlNodeType.Attribute:
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				xmlNode = TextEnd(xmlNode);
				break;
			}
			DocumentXmlWriter documentXmlWriter = new DocumentXmlWriter(DocumentXmlWriterType.InsertSiblingAfter, xmlNode, document);
			documentXmlWriter.NamespaceManager = GetNamespaceManager(xmlNode.ParentNode, document);
			return new XmlWellFormedWriter(documentXmlWriter, documentXmlWriter.Settings);
		}

		public override XmlWriter InsertBefore()
		{
			switch (source.NodeType)
			{
			case XmlNodeType.Attribute:
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				CalibrateText();
				break;
			}
			DocumentXmlWriter documentXmlWriter = new DocumentXmlWriter(DocumentXmlWriterType.InsertSiblingBefore, source, document);
			documentXmlWriter.NamespaceManager = GetNamespaceManager(source.ParentNode, document);
			return new XmlWellFormedWriter(documentXmlWriter, documentXmlWriter.Settings);
		}

		public override XmlWriter CreateAttributes()
		{
			if (source.NodeType != XmlNodeType.Element)
			{
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			}
			DocumentXmlWriter documentXmlWriter = new DocumentXmlWriter(DocumentXmlWriterType.AppendAttribute, source, document);
			documentXmlWriter.NamespaceManager = GetNamespaceManager(source, document);
			return new XmlWellFormedWriter(documentXmlWriter, documentXmlWriter.Settings);
		}

		public override XmlWriter ReplaceRange(XPathNavigator lastSiblingToReplace)
		{
			if (!(lastSiblingToReplace is DocumentXPathNavigator documentXPathNavigator))
			{
				if (lastSiblingToReplace == null)
				{
					throw new ArgumentNullException("lastSiblingToReplace");
				}
				throw new NotSupportedException();
			}
			CalibrateText();
			documentXPathNavigator.CalibrateText();
			XmlNode xmlNode = source;
			XmlNode xmlNode2 = documentXPathNavigator.source;
			if (xmlNode == xmlNode2)
			{
				switch (xmlNode.NodeType)
				{
				case XmlNodeType.Attribute:
				case XmlNodeType.Document:
				case XmlNodeType.DocumentFragment:
					throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					xmlNode2 = documentXPathNavigator.TextEnd(xmlNode2);
					break;
				}
			}
			else
			{
				if (xmlNode2.IsText)
				{
					xmlNode2 = documentXPathNavigator.TextEnd(xmlNode2);
				}
				if (!IsFollowingSibling(xmlNode, xmlNode2))
				{
					throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
				}
			}
			DocumentXmlWriter documentXmlWriter = new DocumentXmlWriter(DocumentXmlWriterType.ReplaceToFollowingSibling, xmlNode, document);
			documentXmlWriter.NamespaceManager = GetNamespaceManager(xmlNode.ParentNode, document);
			documentXmlWriter.Navigator = this;
			documentXmlWriter.EndNode = xmlNode2;
			return new XmlWellFormedWriter(documentXmlWriter, documentXmlWriter.Settings);
		}

		public override void DeleteRange(XPathNavigator lastSiblingToDelete)
		{
			if (!(lastSiblingToDelete is DocumentXPathNavigator documentXPathNavigator))
			{
				if (lastSiblingToDelete == null)
				{
					throw new ArgumentNullException("lastSiblingToDelete");
				}
				throw new NotSupportedException();
			}
			CalibrateText();
			documentXPathNavigator.CalibrateText();
			XmlNode xmlNode = source;
			XmlNode xmlNode2 = documentXPathNavigator.source;
			if (xmlNode == xmlNode2)
			{
				switch (xmlNode.NodeType)
				{
				case XmlNodeType.Attribute:
				{
					XmlAttribute xmlAttribute = (XmlAttribute)xmlNode;
					if (!xmlAttribute.IsNamespace)
					{
						XmlNode xmlNode3 = OwnerNode(xmlAttribute);
						DeleteAttribute(xmlAttribute, attributeIndex);
						if (xmlNode3 != null)
						{
							ResetPosition(xmlNode3);
						}
						break;
					}
					goto default;
				}
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					xmlNode2 = documentXPathNavigator.TextEnd(xmlNode2);
					goto case XmlNodeType.Element;
				case XmlNodeType.Element:
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.Comment:
				{
					XmlNode xmlNode3 = OwnerNode(xmlNode);
					DeleteToFollowingSibling(xmlNode, xmlNode2);
					if (xmlNode3 != null)
					{
						ResetPosition(xmlNode3);
					}
					break;
				}
				default:
					throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
				}
			}
			else
			{
				if (xmlNode2.IsText)
				{
					xmlNode2 = documentXPathNavigator.TextEnd(xmlNode2);
				}
				if (!IsFollowingSibling(xmlNode, xmlNode2))
				{
					throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
				}
				XmlNode xmlNode4 = OwnerNode(xmlNode);
				DeleteToFollowingSibling(xmlNode, xmlNode2);
				if (xmlNode4 != null)
				{
					ResetPosition(xmlNode4);
				}
			}
		}

		public override void DeleteSelf()
		{
			XmlNode xmlNode = source;
			XmlNode end = xmlNode;
			switch (xmlNode.NodeType)
			{
			case XmlNodeType.Attribute:
			{
				XmlAttribute xmlAttribute = (XmlAttribute)xmlNode;
				if (!xmlAttribute.IsNamespace)
				{
					XmlNode xmlNode2 = OwnerNode(xmlAttribute);
					DeleteAttribute(xmlAttribute, attributeIndex);
					if (xmlNode2 != null)
					{
						ResetPosition(xmlNode2);
					}
					break;
				}
				goto default;
			}
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				CalibrateText();
				xmlNode = source;
				end = TextEnd(xmlNode);
				goto case XmlNodeType.Element;
			case XmlNodeType.Element:
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Comment:
			{
				XmlNode xmlNode2 = OwnerNode(xmlNode);
				DeleteToFollowingSibling(xmlNode, end);
				if (xmlNode2 != null)
				{
					ResetPosition(xmlNode2);
				}
				break;
			}
			default:
				throw new InvalidOperationException(Res.GetString("Xpn_BadPosition"));
			}
		}

		private static void DeleteAttribute(XmlAttribute attribute, int index)
		{
			if (!CheckAttributePosition(attribute, out var attributes, index) && !ResetAttributePosition(attribute, attributes, out index))
			{
				throw new InvalidOperationException(Res.GetString("Xpn_MissingParent"));
			}
			if (attribute.IsReadOnly)
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Modify_ReadOnly"));
			}
			attributes.RemoveAt(index);
		}

		internal static void DeleteToFollowingSibling(XmlNode node, XmlNode end)
		{
			XmlNode parentNode = node.ParentNode;
			if (parentNode == null)
			{
				throw new InvalidOperationException(Res.GetString("Xpn_MissingParent"));
			}
			if (node.IsReadOnly || end.IsReadOnly)
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Modify_ReadOnly"));
			}
			while (node != end)
			{
				XmlNode oldChild = node;
				node = node.NextSibling;
				parentNode.RemoveChild(oldChild);
			}
			parentNode.RemoveChild(node);
		}

		private static XmlNamespaceManager GetNamespaceManager(XmlNode node, XmlDocument document)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(document.NameTable);
			List<XmlElement> list = new List<XmlElement>();
			while (node != null)
			{
				if (node is XmlElement xmlElement && xmlElement.HasAttributes)
				{
					list.Add(xmlElement);
				}
				node = node.ParentNode;
			}
			for (int num = list.Count - 1; num >= 0; num--)
			{
				xmlNamespaceManager.PushScope();
				XmlAttributeCollection attributes = list[num].Attributes;
				for (int i = 0; i < attributes.Count; i++)
				{
					XmlAttribute xmlAttribute = attributes[i];
					if (xmlAttribute.IsNamespace)
					{
						string prefix = ((xmlAttribute.Prefix.Length == 0) ? string.Empty : xmlAttribute.LocalName);
						xmlNamespaceManager.AddNamespace(prefix, xmlAttribute.Value);
					}
				}
			}
			return xmlNamespaceManager;
		}

		internal void ResetPosition(XmlNode node)
		{
			source = node;
			if (!(node is XmlAttribute xmlAttribute))
			{
				return;
			}
			XmlElement ownerElement = xmlAttribute.OwnerElement;
			if (ownerElement != null)
			{
				ResetAttributePosition(xmlAttribute, ownerElement.Attributes, out attributeIndex);
				if (xmlAttribute.IsNamespace)
				{
					namespaceParent = ownerElement;
				}
			}
		}

		private static bool ResetAttributePosition(XmlAttribute attribute, XmlAttributeCollection attributes, out int index)
		{
			if (attributes != null)
			{
				for (int i = 0; i < attributes.Count; i++)
				{
					if (attribute == attributes[i])
					{
						index = i;
						return true;
					}
				}
			}
			index = 0;
			return false;
		}

		private static bool CheckAttributePosition(XmlAttribute attribute, out XmlAttributeCollection attributes, int index)
		{
			XmlElement ownerElement = attribute.OwnerElement;
			if (ownerElement != null)
			{
				attributes = ownerElement.Attributes;
				if (index >= 0 && index < attributes.Count && attribute == attributes[index])
				{
					return true;
				}
			}
			else
			{
				attributes = null;
			}
			return false;
		}

		private void CalibrateText()
		{
			for (XmlNode xmlNode = PreviousText(source); xmlNode != null; xmlNode = PreviousText(xmlNode))
			{
				ResetPosition(xmlNode);
			}
		}

		private XmlNode ParentNode(XmlNode node)
		{
			XmlNode parentNode = node.ParentNode;
			if (!document.HasEntityReferences)
			{
				return parentNode;
			}
			return ParentNodeTail(parentNode);
		}

		private XmlNode ParentNodeTail(XmlNode parent)
		{
			while (parent != null && parent.NodeType == XmlNodeType.EntityReference)
			{
				parent = parent.ParentNode;
			}
			return parent;
		}

		private XmlNode FirstChild(XmlNode node)
		{
			XmlNode firstChild = node.FirstChild;
			if (!document.HasEntityReferences)
			{
				return firstChild;
			}
			return FirstChildTail(firstChild);
		}

		private XmlNode FirstChildTail(XmlNode child)
		{
			while (child != null && child.NodeType == XmlNodeType.EntityReference)
			{
				child = child.FirstChild;
			}
			return child;
		}

		private XmlNode NextSibling(XmlNode node)
		{
			XmlNode nextSibling = node.NextSibling;
			if (!document.HasEntityReferences)
			{
				return nextSibling;
			}
			return NextSiblingTail(node, nextSibling);
		}

		private XmlNode NextSiblingTail(XmlNode node, XmlNode sibling)
		{
			while (sibling == null)
			{
				node = node.ParentNode;
				if (node == null || node.NodeType != XmlNodeType.EntityReference)
				{
					return null;
				}
				sibling = node.NextSibling;
			}
			while (sibling != null && sibling.NodeType == XmlNodeType.EntityReference)
			{
				sibling = sibling.FirstChild;
			}
			return sibling;
		}

		private XmlNode PreviousSibling(XmlNode node)
		{
			XmlNode previousSibling = node.PreviousSibling;
			if (!document.HasEntityReferences)
			{
				return previousSibling;
			}
			return PreviousSiblingTail(node, previousSibling);
		}

		private XmlNode PreviousSiblingTail(XmlNode node, XmlNode sibling)
		{
			while (sibling == null)
			{
				node = node.ParentNode;
				if (node == null || node.NodeType != XmlNodeType.EntityReference)
				{
					return null;
				}
				sibling = node.PreviousSibling;
			}
			while (sibling != null && sibling.NodeType == XmlNodeType.EntityReference)
			{
				sibling = sibling.LastChild;
			}
			return sibling;
		}

		private XmlNode PreviousText(XmlNode node)
		{
			XmlNode previousText = node.PreviousText;
			if (!document.HasEntityReferences)
			{
				return previousText;
			}
			return PreviousTextTail(node, previousText);
		}

		private XmlNode PreviousTextTail(XmlNode node, XmlNode text)
		{
			if (text != null)
			{
				return text;
			}
			if (!node.IsText)
			{
				return null;
			}
			XmlNode xmlNode;
			for (xmlNode = node.PreviousSibling; xmlNode == null; xmlNode = node.PreviousSibling)
			{
				node = node.ParentNode;
				if (node == null || node.NodeType != XmlNodeType.EntityReference)
				{
					return null;
				}
			}
			while (xmlNode != null)
			{
				switch (xmlNode.NodeType)
				{
				case XmlNodeType.EntityReference:
					break;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					return xmlNode;
				default:
					return null;
				}
				xmlNode = xmlNode.LastChild;
			}
			return null;
		}

		internal static bool IsFollowingSibling(XmlNode left, XmlNode right)
		{
			while (true)
			{
				left = left.NextSibling;
				if (left == null)
				{
					break;
				}
				if (left == right)
				{
					return true;
				}
			}
			return false;
		}

		private static bool IsDescendant(XmlNode top, XmlNode bottom)
		{
			while (true)
			{
				XmlNode xmlNode = bottom.ParentNode;
				if (xmlNode == null)
				{
					if (!(bottom is XmlAttribute xmlAttribute))
					{
						break;
					}
					xmlNode = xmlAttribute.OwnerElement;
					if (xmlNode == null)
					{
						break;
					}
				}
				bottom = xmlNode;
				if (top == bottom)
				{
					return true;
				}
			}
			return false;
		}

		private static bool IsValidChild(XmlNode parent, XmlNode child)
		{
			switch (parent.NodeType)
			{
			case XmlNodeType.Element:
				return true;
			case XmlNodeType.DocumentFragment:
				switch (child.NodeType)
				{
				case XmlNodeType.Element:
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.Comment:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					return true;
				}
				break;
			case XmlNodeType.Document:
				switch (child.NodeType)
				{
				case XmlNodeType.Element:
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.Comment:
					return true;
				}
				break;
			}
			return false;
		}

		private XmlNode TextStart(XmlNode node)
		{
			XmlNode result;
			do
			{
				result = node;
				node = PreviousSibling(node);
			}
			while (node != null && node.IsText);
			return result;
		}

		private XmlNode TextEnd(XmlNode node)
		{
			XmlNode result;
			do
			{
				result = node;
				node = NextSibling(node);
			}
			while (node != null && node.IsText);
			return result;
		}
	}
}
namespace System.Xml.XPath
{
	[DebuggerDisplay("Position={CurrentPosition}, Current={debuggerDisplayProxy}")]
	public abstract class XPathNodeIterator : ICloneable, IEnumerable
	{
		private class Enumerator : IEnumerator
		{
			private XPathNodeIterator original;

			private XPathNodeIterator current;

			private bool iterationStarted;

			public virtual object Current
			{
				get
				{
					if (iterationStarted)
					{
						if (current == null)
						{
							throw new InvalidOperationException(Res.GetString("Sch_EnumFinished", string.Empty));
						}
						return current.Current.Clone();
					}
					throw new InvalidOperationException(Res.GetString("Sch_EnumNotStarted", string.Empty));
				}
			}

			public Enumerator(XPathNodeIterator original)
			{
				this.original = original.Clone();
			}

			public virtual bool MoveNext()
			{
				if (!iterationStarted)
				{
					current = original.Clone();
					iterationStarted = true;
				}
				if (current == null || !current.MoveNext())
				{
					current = null;
					return false;
				}
				return true;
			}

			public virtual void Reset()
			{
				iterationStarted = false;
			}
		}

		internal int count = -1;

		public abstract XPathNavigator Current { get; }

		public abstract int CurrentPosition { get; }

		public virtual int Count
		{
			get
			{
				if (count == -1)
				{
					XPathNodeIterator xPathNodeIterator = Clone();
					while (xPathNodeIterator.MoveNext())
					{
					}
					count = xPathNodeIterator.CurrentPosition;
				}
				return count;
			}
		}

		private object debuggerDisplayProxy
		{
			get
			{
				if (Current != null)
				{
					return new XPathNavigator.DebuggerDisplayProxy(Current);
				}
				return null;
			}
		}

		object ICloneable.Clone()
		{
			return Clone();
		}

		public abstract XPathNodeIterator Clone();

		public abstract bool MoveNext();

		public virtual IEnumerator GetEnumerator()
		{
			return new Enumerator(this);
		}
	}
}
namespace System.Xml
{
	internal sealed class DocumentXPathNodeIterator_Empty : XPathNodeIterator
	{
		private XPathNavigator nav;

		public override XPathNavigator Current => nav;

		public override int CurrentPosition => 0;

		public override int Count => 0;

		internal DocumentXPathNodeIterator_Empty(DocumentXPathNavigator nav)
		{
			this.nav = nav.Clone();
		}

		internal DocumentXPathNodeIterator_Empty(DocumentXPathNodeIterator_Empty other)
		{
			nav = other.nav.Clone();
		}

		public override XPathNodeIterator Clone()
		{
			return new DocumentXPathNodeIterator_Empty(this);
		}

		public override bool MoveNext()
		{
			return false;
		}
	}
	internal abstract class DocumentXPathNodeIterator_ElemDescendants : XPathNodeIterator
	{
		private DocumentXPathNavigator nav;

		private int level;

		private int position;

		public override XPathNavigator Current => nav;

		public override int CurrentPosition => position;

		internal DocumentXPathNodeIterator_ElemDescendants(DocumentXPathNavigator nav)
		{
			this.nav = (DocumentXPathNavigator)nav.Clone();
			level = 0;
			position = 0;
		}

		internal DocumentXPathNodeIterator_ElemDescendants(DocumentXPathNodeIterator_ElemDescendants other)
		{
			nav = (DocumentXPathNavigator)other.nav.Clone();
			level = other.level;
			position = other.position;
		}

		protected abstract bool Match(XmlNode node);

		protected void SetPosition(int pos)
		{
			position = pos;
		}

		public override bool MoveNext()
		{
			XmlNode xmlNode;
			do
			{
				if (nav.MoveToFirstChild())
				{
					level++;
				}
				else
				{
					if (level == 0)
					{
						return false;
					}
					while (!nav.MoveToNext())
					{
						level--;
						if (level == 0)
						{
							return false;
						}
						if (!nav.MoveToParent())
						{
							return false;
						}
					}
				}
				xmlNode = (XmlNode)nav.UnderlyingObject;
			}
			while (xmlNode.NodeType != XmlNodeType.Element || !Match(xmlNode));
			position++;
			return true;
		}
	}
	internal class DocumentXPathNodeIterator_AllElemChildren : DocumentXPathNodeIterator_ElemDescendants
	{
		internal DocumentXPathNodeIterator_AllElemChildren(DocumentXPathNavigator nav)
			: base(nav)
		{
		}

		internal DocumentXPathNodeIterator_AllElemChildren(DocumentXPathNodeIterator_AllElemChildren other)
			: base(other)
		{
		}

		public override XPathNodeIterator Clone()
		{
			return new DocumentXPathNodeIterator_AllElemChildren(this);
		}

		protected override bool Match(XmlNode node)
		{
			return node.NodeType == XmlNodeType.Element;
		}
	}
	internal sealed class DocumentXPathNodeIterator_AllElemChildren_AndSelf : DocumentXPathNodeIterator_AllElemChildren
	{
		internal DocumentXPathNodeIterator_AllElemChildren_AndSelf(DocumentXPathNavigator nav)
			: base(nav)
		{
		}

		internal DocumentXPathNodeIterator_AllElemChildren_AndSelf(DocumentXPathNodeIterator_AllElemChildren_AndSelf other)
			: base(other)
		{
		}

		public override XPathNodeIterator Clone()
		{
			return new DocumentXPathNodeIterator_AllElemChildren_AndSelf(this);
		}

		public override bool MoveNext()
		{
			if (CurrentPosition == 0)
			{
				DocumentXPathNavigator documentXPathNavigator = (DocumentXPathNavigator)Current;
				XmlNode xmlNode = (XmlNode)documentXPathNavigator.UnderlyingObject;
				if (xmlNode.NodeType == XmlNodeType.Element && Match(xmlNode))
				{
					SetPosition(1);
					return true;
				}
			}
			return base.MoveNext();
		}
	}
	internal class DocumentXPathNodeIterator_ElemChildren_NoLocalName : DocumentXPathNodeIterator_ElemDescendants
	{
		private string nsAtom;

		internal DocumentXPathNodeIterator_ElemChildren_NoLocalName(DocumentXPathNavigator nav, string nsAtom)
			: base(nav)
		{
			this.nsAtom = nsAtom;
		}

		internal DocumentXPathNodeIterator_ElemChildren_NoLocalName(DocumentXPathNodeIterator_ElemChildren_NoLocalName other)
			: base(other)
		{
			nsAtom = other.nsAtom;
		}

		public override XPathNodeIterator Clone()
		{
			return new DocumentXPathNodeIterator_ElemChildren_NoLocalName(this);
		}

		protected override bool Match(XmlNode node)
		{
			return Ref.Equal(node.NamespaceURI, nsAtom);
		}
	}
	internal sealed class DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName : DocumentXPathNodeIterator_ElemChildren_NoLocalName
	{
		internal DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName(DocumentXPathNavigator nav, string nsAtom)
			: base(nav, nsAtom)
		{
		}

		internal DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName(DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName other)
			: base(other)
		{
		}

		public override XPathNodeIterator Clone()
		{
			return new DocumentXPathNodeIterator_ElemChildren_AndSelf_NoLocalName(this);
		}

		public override bool MoveNext()
		{
			if (CurrentPosition == 0)
			{
				DocumentXPathNavigator documentXPathNavigator = (DocumentXPathNavigator)Current;
				XmlNode xmlNode = (XmlNode)documentXPathNavigator.UnderlyingObject;
				if (xmlNode.NodeType == XmlNodeType.Element && Match(xmlNode))
				{
					SetPosition(1);
					return true;
				}
			}
			return base.MoveNext();
		}
	}
	internal class DocumentXPathNodeIterator_ElemChildren : DocumentXPathNodeIterator_ElemDescendants
	{
		protected string localNameAtom;

		protected string nsAtom;

		internal DocumentXPathNodeIterator_ElemChildren(DocumentXPathNavigator nav, string localNameAtom, string nsAtom)
			: base(nav)
		{
			this.localNameAtom = localNameAtom;
			this.nsAtom = nsAtom;
		}

		internal DocumentXPathNodeIterator_ElemChildren(DocumentXPathNodeIterator_ElemChildren other)
			: base(other)
		{
			localNameAtom = other.localNameAtom;
			nsAtom = other.nsAtom;
		}

		public override XPathNodeIterator Clone()
		{
			return new DocumentXPathNodeIterator_ElemChildren(this);
		}

		protected override bool Match(XmlNode node)
		{
			if (Ref.Equal(node.LocalName, localNameAtom))
			{
				return Ref.Equal(node.NamespaceURI, nsAtom);
			}
			return false;
		}
	}
	internal sealed class DocumentXPathNodeIterator_ElemChildren_AndSelf : DocumentXPathNodeIterator_ElemChildren
	{
		internal DocumentXPathNodeIterator_ElemChildren_AndSelf(DocumentXPathNavigator nav, string localNameAtom, string nsAtom)
			: base(nav, localNameAtom, nsAtom)
		{
		}

		internal DocumentXPathNodeIterator_ElemChildren_AndSelf(DocumentXPathNodeIterator_ElemChildren_AndSelf other)
			: base(other)
		{
		}

		public override XPathNodeIterator Clone()
		{
			return new DocumentXPathNodeIterator_ElemChildren_AndSelf(this);
		}

		public override bool MoveNext()
		{
			if (CurrentPosition == 0)
			{
				DocumentXPathNavigator documentXPathNavigator = (DocumentXPathNavigator)Current;
				XmlNode xmlNode = (XmlNode)documentXPathNavigator.UnderlyingObject;
				if (xmlNode.NodeType == XmlNodeType.Element && Match(xmlNode))
				{
					SetPosition(1);
					return true;
				}
			}
			return base.MoveNext();
		}
	}
	internal class DomNameTable
	{
		private const int InitialSize = 64;

		private XmlName[] entries;

		private int count;

		private int mask;

		private XmlDocument ownerDocument;

		private XmlNameTable nameTable;

		public DomNameTable(XmlDocument document)
		{
			ownerDocument = document;
			nameTable = document.NameTable;
			entries = new XmlName[64];
			mask = 63;
		}

		public XmlName GetName(string prefix, string localName, string ns, IXmlSchemaInfo schemaInfo)
		{
			if (prefix == null)
			{
				prefix = string.Empty;
			}
			if (ns == null)
			{
				ns = string.Empty;
			}
			int hashCode = XmlName.GetHashCode(localName);
			for (XmlName xmlName = entries[hashCode & mask]; xmlName != null; xmlName = xmlName.next)
			{
				if (xmlName.HashCode == hashCode && ((object)xmlName.LocalName == localName || xmlName.LocalName.Equals(localName)) && ((object)xmlName.Prefix == prefix || xmlName.Prefix.Equals(prefix)) && ((object)xmlName.NamespaceURI == ns || xmlName.NamespaceURI.Equals(ns)) && xmlName.Equals(schemaInfo))
				{
					return xmlName;
				}
			}
			return null;
		}

		public XmlName AddName(string prefix, string localName, string ns, IXmlSchemaInfo schemaInfo)
		{
			if (prefix == null)
			{
				prefix = string.Empty;
			}
			if (ns == null)
			{
				ns = string.Empty;
			}
			int hashCode = XmlName.GetHashCode(localName);
			for (XmlName xmlName = entries[hashCode & mask]; xmlName != null; xmlName = xmlName.next)
			{
				if (xmlName.HashCode == hashCode && ((object)xmlName.LocalName == localName || xmlName.LocalName.Equals(localName)) && ((object)xmlName.Prefix == prefix || xmlName.Prefix.Equals(prefix)) && ((object)xmlName.NamespaceURI == ns || xmlName.NamespaceURI.Equals(ns)) && xmlName.Equals(schemaInfo))
				{
					return xmlName;
				}
			}
			prefix = nameTable.Add(prefix);
			localName = nameTable.Add(localName);
			ns = nameTable.Add(ns);
			int num = hashCode & mask;
			XmlName xmlName2 = XmlName.Create(prefix, localName, ns, hashCode, ownerDocument, entries[num], schemaInfo);
			entries[num] = xmlName2;
			if (count++ == mask)
			{
				Grow();
			}
			return xmlName2;
		}

		private void Grow()
		{
			int num = mask * 2 + 1;
			XmlName[] array = entries;
			XmlName[] array2 = new XmlName[num + 1];
			for (int i = 0; i < array.Length; i++)
			{
				XmlName xmlName = array[i];
				while (xmlName != null)
				{
					int num2 = xmlName.HashCode & num;
					XmlName next = xmlName.next;
					xmlName.next = array2[num2];
					array2[num2] = xmlName;
					xmlName = next;
				}
			}
			entries = array2;
			mask = num;
		}
	}
	[DebuggerDisplay("{debuggerDisplayProxy}")]
	public abstract class XmlNode : ICloneable, IEnumerable, IXPathNavigable
	{
		internal XmlNode parentNode;

		public abstract string Name { get; }

		public virtual string Value
		{
			get
			{
				return null;
			}
			set
			{
				throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, Res.GetString("Xdom_Node_SetVal"), NodeType.ToString()));
			}
		}

		public abstract XmlNodeType NodeType { get; }

		public virtual XmlNode ParentNode
		{
			get
			{
				if (parentNode.NodeType != XmlNodeType.Document)
				{
					return parentNode;
				}
				if (parentNode.FirstChild is XmlLinkedNode xmlLinkedNode)
				{
					XmlLinkedNode xmlLinkedNode2 = xmlLinkedNode;
					do
					{
						if (xmlLinkedNode2 == this)
						{
							return parentNode;
						}
						xmlLinkedNode2 = xmlLinkedNode2.next;
					}
					while (xmlLinkedNode2 != null && xmlLinkedNode2 != xmlLinkedNode);
				}
				return null;
			}
		}

		public virtual XmlNodeList ChildNodes => new XmlChildNodes(this);

		public virtual XmlNode PreviousSibling => null;

		public virtual XmlNode NextSibling => null;

		public virtual XmlAttributeCollection Attributes => null;

		public virtual XmlDocument OwnerDocument
		{
			get
			{
				if (parentNode.NodeType == XmlNodeType.Document)
				{
					return (XmlDocument)parentNode;
				}
				return parentNode.OwnerDocument;
			}
		}

		public virtual XmlNode FirstChild => LastNode?.next;

		public virtual XmlNode LastChild => LastNode;

		internal virtual bool IsContainer => false;

		internal virtual XmlLinkedNode LastNode
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual bool HasChildNodes => LastNode != null;

		public virtual string NamespaceURI => string.Empty;

		public virtual string Prefix
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public abstract string LocalName { get; }

		public virtual bool IsReadOnly
		{
			get
			{
				_ = OwnerDocument;
				return HasReadOnlyParent(this);
			}
		}

		public virtual string InnerText
		{
			get
			{
				XmlNode firstChild = FirstChild;
				if (firstChild == null)
				{
					return string.Empty;
				}
				if (firstChild.NextSibling == null)
				{
					switch (firstChild.NodeType)
					{
					case XmlNodeType.Text:
					case XmlNodeType.CDATA:
					case XmlNodeType.Whitespace:
					case XmlNodeType.SignificantWhitespace:
						return firstChild.Value;
					}
				}
				StringBuilder stringBuilder = new StringBuilder();
				AppendChildText(stringBuilder);
				return stringBuilder.ToString();
			}
			set
			{
				XmlNode firstChild = FirstChild;
				if (firstChild != null && firstChild.NextSibling == null && firstChild.NodeType == XmlNodeType.Text)
				{
					firstChild.Value = value;
					return;
				}
				RemoveAll();
				AppendChild(OwnerDocument.CreateTextNode(value));
			}
		}

		public virtual string OuterXml
		{
			get
			{
				StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
				XmlDOMTextWriter xmlDOMTextWriter = new XmlDOMTextWriter(stringWriter);
				try
				{
					WriteTo(xmlDOMTextWriter);
				}
				finally
				{
					xmlDOMTextWriter.Close();
				}
				return stringWriter.ToString();
			}
		}

		public virtual string InnerXml
		{
			get
			{
				StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
				XmlDOMTextWriter xmlDOMTextWriter = new XmlDOMTextWriter(stringWriter);
				try
				{
					WriteContentTo(xmlDOMTextWriter);
				}
				finally
				{
					xmlDOMTextWriter.Close();
				}
				return stringWriter.ToString();
			}
			set
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Set_InnerXml"));
			}
		}

		public virtual IXmlSchemaInfo SchemaInfo => XmlDocument.NotKnownSchemaInfo;

		public virtual string BaseURI
		{
			get
			{
				for (XmlNode xmlNode = ParentNode; xmlNode != null; xmlNode = xmlNode.ParentNode)
				{
					switch (xmlNode.NodeType)
					{
					case XmlNodeType.EntityReference:
						return ((XmlEntityReference)xmlNode).ChildBaseURI;
					case XmlNodeType.Attribute:
					case XmlNodeType.Entity:
					case XmlNodeType.Document:
						return xmlNode.BaseURI;
					}
				}
				return string.Empty;
			}
		}

		internal XmlDocument Document
		{
			get
			{
				if (NodeType == XmlNodeType.Document)
				{
					return (XmlDocument)this;
				}
				return OwnerDocument;
			}
		}

		public virtual XmlElement this[string name]
		{
			get
			{
				for (XmlNode xmlNode = FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
				{
					if (xmlNode.NodeType == XmlNodeType.Element && xmlNode.Name == name)
					{
						return (XmlElement)xmlNode;
					}
				}
				return null;
			}
		}

		public virtual XmlElement this[string localname, string ns]
		{
			get
			{
				for (XmlNode xmlNode = FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
				{
					if (xmlNode.NodeType == XmlNodeType.Element && xmlNode.LocalName == localname && xmlNode.NamespaceURI == ns)
					{
						return (XmlElement)xmlNode;
					}
				}
				return null;
			}
		}

		internal virtual XmlSpace XmlSpace
		{
			get
			{
				XmlNode xmlNode = this;
				XmlElement xmlElement = null;
				do
				{
					if (xmlNode is XmlElement xmlElement2 && xmlElement2.HasAttribute("xml:space"))
					{
						string attribute = xmlElement2.GetAttribute("xml:space");
						if (string.Compare(attribute, "default", StringComparison.OrdinalIgnoreCase) == 0)
						{
							return XmlSpace.Default;
						}
						if (string.Compare(attribute, "preserve", StringComparison.OrdinalIgnoreCase) == 0)
						{
							return XmlSpace.Preserve;
						}
					}
					xmlNode = xmlNode.ParentNode;
				}
				while (xmlNode != null);
				return XmlSpace.None;
			}
		}

		internal virtual string XmlLang
		{
			get
			{
				XmlNode xmlNode = this;
				XmlElement xmlElement = null;
				do
				{
					if (xmlNode is XmlElement xmlElement2 && xmlElement2.HasAttribute("xml:lang"))
					{
						return xmlElement2.GetAttribute("xml:lang");
					}
					xmlNode = xmlNode.ParentNode;
				}
				while (xmlNode != null);
				return string.Empty;
			}
		}

		internal virtual XPathNodeType XPNodeType => (XPathNodeType)(-1);

		internal virtual string XPLocalName => string.Empty;

		internal virtual bool IsText => false;

		internal virtual XmlNode PreviousText => null;

		private object debuggerDisplayProxy => new DebuggerDisplayXmlNodeProxy(this);

		internal XmlNode()
		{
		}

		internal XmlNode(XmlDocument doc)
		{
			if (doc == null)
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Null_Doc"));
			}
			parentNode = doc;
		}

		public virtual XPathNavigator CreateNavigator()
		{
			if (this is XmlDocument xmlDocument)
			{
				return xmlDocument.CreateNavigator(this);
			}
			XmlDocument ownerDocument = OwnerDocument;
			return ownerDocument.CreateNavigator(this);
		}

		public XmlNode SelectSingleNode(string xpath)
		{
			XmlNodeList xmlNodeList = SelectNodes(xpath);
			if (xmlNodeList != null && xmlNodeList.Count > 0)
			{
				return xmlNodeList[0];
			}
			return null;
		}

		public XmlNode SelectSingleNode(string xpath, XmlNamespaceManager nsmgr)
		{
			XPathNavigator xPathNavigator = CreateNavigator();
			if (xPathNavigator == null)
			{
				return null;
			}
			XPathExpression xPathExpression = xPathNavigator.Compile(xpath);
			xPathExpression.SetContext(nsmgr);
			XmlNodeList xmlNodeList = new XPathNodeList(xPathNavigator.Select(xPathExpression));
			if (xmlNodeList.Count > 0)
			{
				return xmlNodeList[0];
			}
			return null;
		}

		public XmlNodeList SelectNodes(string xpath)
		{
			XPathNavigator xPathNavigator = CreateNavigator();
			if (xPathNavigator == null)
			{
				return null;
			}
			return new XPathNodeList(xPathNavigator.Select(xpath));
		}

		public XmlNodeList SelectNodes(string xpath, XmlNamespaceManager nsmgr)
		{
			XPathNavigator xPathNavigator = CreateNavigator();
			if (xPathNavigator == null)
			{
				return null;
			}
			XPathExpression xPathExpression = xPathNavigator.Compile(xpath);
			xPathExpression.SetContext(nsmgr);
			return new XPathNodeList(xPathNavigator.Select(xPathExpression));
		}

		internal bool AncestorNode(XmlNode node)
		{
			XmlNode xmlNode = ParentNode;
			while (xmlNode != null && xmlNode != this)
			{
				if (xmlNode == node)
				{
					return true;
				}
				xmlNode = xmlNode.ParentNode;
			}
			return false;
		}

		internal bool IsConnected()
		{
			XmlNode xmlNode = ParentNode;
			while (xmlNode != null && xmlNode.NodeType != XmlNodeType.Document)
			{
				xmlNode = xmlNode.ParentNode;
			}
			return xmlNode != null;
		}

		public virtual XmlNode InsertBefore(XmlNode newChild, XmlNode refChild)
		{
			if (this == newChild || AncestorNode(newChild))
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Insert_Child"));
			}
			if (refChild == null)
			{
				return AppendChild(newChild);
			}
			if (!IsContainer)
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_Contain"));
			}
			if (refChild.ParentNode != this)
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Insert_Path"));
			}
			if (newChild == refChild)
			{
				return newChild;
			}
			XmlDocument ownerDocument = newChild.OwnerDocument;
			XmlDocument ownerDocument2 = OwnerDocument;
			if (ownerDocument != null && ownerDocument != ownerDocument2 && ownerDocument != this)
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Insert_Context"));
			}
			if (!CanInsertBefore(newChild, refChild))
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_Location"));
			}
			if (newChild.ParentNode != null)
			{
				newChild.ParentNode.RemoveChild(newChild);
			}
			if (newChild.NodeType == XmlNodeType.DocumentFragment)
			{
				XmlNode firstChild = newChild.FirstChild;
				XmlNode xmlNode = firstChild;
				if (xmlNode != null)
				{
					newChild.RemoveChild(xmlNode);
					InsertBefore(xmlNode, refChild);
					InsertAfter(newChild, xmlNode);
				}
				return firstChild;
			}
			if (!(newChild is XmlLinkedNode) || !IsValidChildType(newChild.NodeType))
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_TypeConflict"));
			}
			XmlLinkedNode xmlLinkedNode = (XmlLinkedNode)newChild;
			XmlLinkedNode xmlLinkedNode2 = (XmlLinkedNode)refChild;
			string value = newChild.Value;
			XmlNodeChangedEventArgs eventArgs = GetEventArgs(newChild, newChild.ParentNode, this, value, value, XmlNodeChangedAction.Insert);
			if (eventArgs != null)
			{
				BeforeEvent(eventArgs);
			}
			if (xmlLinkedNode2 == FirstChild)
			{
				xmlLinkedNode.next = xmlLinkedNode2;
				LastNode.next = xmlLinkedNode;
				xmlLinkedNode.SetParent(this);
				if (xmlLinkedNode.IsText && xmlLinkedNode2.IsText)
				{
					NestTextNodes(xmlLinkedNode, xmlLinkedNode2);
				}
			}
			else
			{
				XmlLinkedNode xmlLinkedNode3 = (XmlLinkedNode)xmlLinkedNode2.PreviousSibling;
				xmlLinkedNode.next = xmlLinkedNode2;
				xmlLinkedNode3.next = xmlLinkedNode;
				xmlLinkedNode.SetParent(this);
				if (xmlLinkedNode3.IsText)
				{
					if (xmlLinkedNode.IsText)
					{
						NestTextNodes(xmlLinkedNode3, xmlLinkedNode);
						if (xmlLinkedNode2.IsText)
						{
							NestTextNodes(xmlLinkedNode, xmlLinkedNode2);
						}
					}
					else if (xmlLinkedNode2.IsText)
					{
						UnnestTextNodes(xmlLinkedNode3, xmlLinkedNode2);
					}
				}
				else if (xmlLinkedNode.IsText && xmlLinkedNode2.IsText)
				{
					NestTextNodes(xmlLinkedNode, xmlLinkedNode2);
				}
			}
			if (eventArgs != null)
			{
				AfterEvent(eventArgs);
			}
			return xmlLinkedNode;
		}

		public virtual XmlNode InsertAfter(XmlNode newChild, XmlNode refChild)
		{
			if (this == newChild || AncestorNode(newChild))
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Insert_Child"));
			}
			if (refChild == null)
			{
				return PrependChild(newChild);
			}
			if (!IsContainer)
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_Contain"));
			}
			if (refChild.ParentNode != this)
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Insert_Path"));
			}
			if (newChild == refChild)
			{
				return newChild;
			}
			XmlDocument ownerDocument = newChild.OwnerDocument;
			XmlDocument ownerDocument2 = OwnerDocument;
			if (ownerDocument != null && ownerDocument != ownerDocument2 && ownerDocument != this)
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Insert_Context"));
			}
			if (!CanInsertAfter(newChild, refChild))
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_Location"));
			}
			if (newChild.ParentNode != null)
			{
				newChild.ParentNode.RemoveChild(newChild);
			}
			if (newChild.NodeType == XmlNodeType.DocumentFragment)
			{
				XmlNode refChild2 = refChild;
				XmlNode firstChild = newChild.FirstChild;
				XmlNode xmlNode = firstChild;
				while (xmlNode != null)
				{
					XmlNode nextSibling = xmlNode.NextSibling;
					newChild.RemoveChild(xmlNode);
					InsertAfter(xmlNode, refChild2);
					refChild2 = xmlNode;
					xmlNode = nextSibling;
				}
				return firstChild;
			}
			if (!(newChild is XmlLinkedNode) || !IsValidChildType(newChild.NodeType))
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_TypeConflict"));
			}
			XmlLinkedNode xmlLinkedNode = (XmlLinkedNode)newChild;
			XmlLinkedNode xmlLinkedNode2 = (XmlLinkedNode)refChild;
			string value = newChild.Value;
			XmlNodeChangedEventArgs eventArgs = GetEventArgs(newChild, newChild.ParentNode, this, value, value, XmlNodeChangedAction.Insert);
			if (eventArgs != null)
			{
				BeforeEvent(eventArgs);
			}
			if (xmlLinkedNode2 == LastNode)
			{
				xmlLinkedNode.next = xmlLinkedNode2.next;
				xmlLinkedNode2.next = xmlLinkedNode;
				LastNode = xmlLinkedNode;
				xmlLinkedNode.SetParent(this);
				if (xmlLinkedNode2.IsText && xmlLinkedNode.IsText)
				{
					NestTextNodes(xmlLinkedNode2, xmlLinkedNode);
				}
			}
			else
			{
				XmlLinkedNode xmlLinkedNode3 = (xmlLinkedNode.next = xmlLinkedNode2.next);
				xmlLinkedNode2.next = xmlLinkedNode;
				xmlLinkedNode.SetParent(this);
				if (xmlLinkedNode2.IsText)
				{
					if (xmlLinkedNode.IsText)
					{
						NestTextNodes(xmlLinkedNode2, xmlLinkedNode);
						if (xmlLinkedNode3.IsText)
						{
							NestTextNodes(xmlLinkedNode, xmlLinkedNode3);
						}
					}
					else if (xmlLinkedNode3.IsText)
					{
						UnnestTextNodes(xmlLinkedNode2, xmlLinkedNode3);
					}
				}
				else if (xmlLinkedNode.IsText && xmlLinkedNode3.IsText)
				{
					NestTextNodes(xmlLinkedNode, xmlLinkedNode3);
				}
			}
			if (eventArgs != null)
			{
				AfterEvent(eventArgs);
			}
			return xmlLinkedNode;
		}

		public virtual XmlNode ReplaceChild(XmlNode newChild, XmlNode oldChild)
		{
			XmlNode nextSibling = oldChild.NextSibling;
			RemoveChild(oldChild);
			InsertBefore(newChild, nextSibling);
			return oldChild;
		}

		public virtual XmlNode RemoveChild(XmlNode oldChild)
		{
			if (!IsContainer)
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Remove_Contain"));
			}
			if (oldChild.ParentNode != this)
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Remove_Child"));
			}
			XmlLinkedNode xmlLinkedNode = (XmlLinkedNode)oldChild;
			string value = xmlLinkedNode.Value;
			XmlNodeChangedEventArgs eventArgs = GetEventArgs(xmlLinkedNode, this, null, value, value, XmlNodeChangedAction.Remove);
			if (eventArgs != null)
			{
				BeforeEvent(eventArgs);
			}
			XmlLinkedNode lastNode = LastNode;
			if (xmlLinkedNode == FirstChild)
			{
				if (xmlLinkedNode == lastNode)
				{
					LastNode = null;
					xmlLinkedNode.next = null;
					xmlLinkedNode.SetParent(null);
				}
				else
				{
					XmlLinkedNode next = xmlLinkedNode.next;
					if (next.IsText && xmlLinkedNode.IsText)
					{
						UnnestTextNodes(xmlLinkedNode, next);
					}
					lastNode.next = next;
					xmlLinkedNode.next = null;
					xmlLinkedNode.SetParent(null);
				}
			}
			else if (xmlLinkedNode == lastNode)
			{
				XmlLinkedNode xmlLinkedNode2 = (XmlLinkedNode)xmlLinkedNode.PreviousSibling;
				xmlLinkedNode2.next = xmlLinkedNode.next;
				LastNode = xmlLinkedNode2;
				xmlLinkedNode.next = null;
				xmlLinkedNode.SetParent(null);
			}
			else
			{
				XmlLinkedNode xmlLinkedNode3 = (XmlLinkedNode)xmlLinkedNode.PreviousSibling;
				XmlLinkedNode next2 = xmlLinkedNode.next;
				if (next2.IsText)
				{
					if (xmlLinkedNode3.IsText)
					{
						NestTextNodes(xmlLinkedNode3, next2);
					}
					else if (xmlLinkedNode.IsText)
					{
						UnnestTextNodes(xmlLinkedNode, next2);
					}
				}
				xmlLinkedNode3.next = next2;
				xmlLinkedNode.next = null;
				xmlLinkedNode.SetParent(null);
			}
			if (eventArgs != null)
			{
				AfterEvent(eventArgs);
			}
			return oldChild;
		}

		public virtual XmlNode PrependChild(XmlNode newChild)
		{
			return InsertBefore(newChild, FirstChild);
		}

		public virtual XmlNode AppendChild(XmlNode newChild)
		{
			XmlDocument xmlDocument = OwnerDocument;
			if (xmlDocument == null)
			{
				xmlDocument = this as XmlDocument;
			}
			if (!IsContainer)
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_Contain"));
			}
			if (this == newChild || AncestorNode(newChild))
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Insert_Child"));
			}
			if (newChild.ParentNode != null)
			{
				newChild.ParentNode.RemoveChild(newChild);
			}
			XmlDocument ownerDocument = newChild.OwnerDocument;
			if (ownerDocument != null && ownerDocument != xmlDocument && ownerDocument != this)
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Insert_Context"));
			}
			if (newChild.NodeType == XmlNodeType.DocumentFragment)
			{
				XmlNode firstChild = newChild.FirstChild;
				XmlNode xmlNode = firstChild;
				while (xmlNode != null)
				{
					XmlNode nextSibling = xmlNode.NextSibling;
					newChild.RemoveChild(xmlNode);
					AppendChild(xmlNode);
					xmlNode = nextSibling;
				}
				return firstChild;
			}
			if (!(newChild is XmlLinkedNode) || !IsValidChildType(newChild.NodeType))
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_TypeConflict"));
			}
			if (!CanInsertAfter(newChild, LastChild))
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_Location"));
			}
			string value = newChild.Value;
			XmlNodeChangedEventArgs eventArgs = GetEventArgs(newChild, newChild.ParentNode, this, value, value, XmlNodeChangedAction.Insert);
			if (eventArgs != null)
			{
				BeforeEvent(eventArgs);
			}
			XmlLinkedNode lastNode = LastNode;
			XmlLinkedNode xmlLinkedNode = (XmlLinkedNode)newChild;
			if (lastNode == null)
			{
				xmlLinkedNode.next = xmlLinkedNode;
				LastNode = xmlLinkedNode;
				xmlLinkedNode.SetParent(this);
			}
			else
			{
				xmlLinkedNode.next = lastNode.next;
				lastNode.next = xmlLinkedNode;
				LastNode = xmlLinkedNode;
				xmlLinkedNode.SetParent(this);
				if (lastNode.IsText && xmlLinkedNode.IsText)
				{
					NestTextNodes(lastNode, xmlLinkedNode);
				}
			}
			if (eventArgs != null)
			{
				AfterEvent(eventArgs);
			}
			return xmlLinkedNode;
		}

		internal virtual XmlNode AppendChildForLoad(XmlNode newChild, XmlDocument doc)
		{
			XmlNodeChangedEventArgs insertEventArgsForLoad = doc.GetInsertEventArgsForLoad(newChild, this);
			if (insertEventArgsForLoad != null)
			{
				doc.BeforeEvent(insertEventArgsForLoad);
			}
			XmlLinkedNode lastNode = LastNode;
			XmlLinkedNode xmlLinkedNode = (XmlLinkedNode)newChild;
			if (lastNode == null)
			{
				xmlLinkedNode.next = xmlLinkedNode;
				LastNode = xmlLinkedNode;
				xmlLinkedNode.SetParentForLoad(this);
			}
			else
			{
				xmlLinkedNode.next = lastNode.next;
				lastNode.next = xmlLinkedNode;
				LastNode = xmlLinkedNode;
				if (lastNode.IsText && xmlLinkedNode.IsText)
				{
					NestTextNodes(lastNode, xmlLinkedNode);
				}
				else
				{
					xmlLinkedNode.SetParentForLoad(this);
				}
			}
			if (insertEventArgsForLoad != null)
			{
				doc.AfterEvent(insertEventArgsForLoad);
			}
			return xmlLinkedNode;
		}

		internal virtual bool IsValidChildType(XmlNodeType type)
		{
			return false;
		}

		internal virtual bool CanInsertBefore(XmlNode newChild, XmlNode refChild)
		{
			return true;
		}

		internal virtual bool CanInsertAfter(XmlNode newChild, XmlNode refChild)
		{
			return true;
		}

		public abstract XmlNode CloneNode(bool deep);

		internal virtual void CopyChildren(XmlDocument doc, XmlNode container, bool deep)
		{
			for (XmlNode xmlNode = container.FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
			{
				AppendChildForLoad(xmlNode.CloneNode(deep), doc);
			}
		}

		public virtual void Normalize()
		{
			XmlNode xmlNode = null;
			StringBuilder stringBuilder = new StringBuilder();
			XmlNode nextSibling;
			for (XmlNode xmlNode2 = FirstChild; xmlNode2 != null; xmlNode2 = nextSibling)
			{
				nextSibling = xmlNode2.NextSibling;
				switch (xmlNode2.NodeType)
				{
				case XmlNodeType.Text:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
				{
					stringBuilder.Append(xmlNode2.Value);
					XmlNode xmlNode3 = NormalizeWinner(xmlNode, xmlNode2);
					if (xmlNode3 == xmlNode)
					{
						RemoveChild(xmlNode2);
						continue;
					}
					if (xmlNode != null)
					{
						RemoveChild(xmlNode);
					}
					xmlNode = xmlNode2;
					continue;
				}
				case XmlNodeType.Element:
					xmlNode2.Normalize();
					break;
				}
				if (xmlNode != null)
				{
					xmlNode.Value = stringBuilder.ToString();
					xmlNode = null;
				}
				stringBuilder.Remove(0, stringBuilder.Length);
			}
			if (xmlNode != null && stringBuilder.Length > 0)
			{
				xmlNode.Value = stringBuilder.ToString();
			}
		}

		private XmlNode NormalizeWinner(XmlNode firstNode, XmlNode secondNode)
		{
			if (firstNode == null)
			{
				return secondNode;
			}
			if (firstNode.NodeType == XmlNodeType.Text)
			{
				return firstNode;
			}
			if (secondNode.NodeType == XmlNodeType.Text)
			{
				return secondNode;
			}
			if (firstNode.NodeType == XmlNodeType.SignificantWhitespace)
			{
				return firstNode;
			}
			if (secondNode.NodeType == XmlNodeType.SignificantWhitespace)
			{
				return secondNode;
			}
			if (firstNode.NodeType == XmlNodeType.Whitespace)
			{
				return firstNode;
			}
			if (secondNode.NodeType == XmlNodeType.Whitespace)
			{
				return secondNode;
			}
			return null;
		}

		public virtual bool Supports(string feature, string version)
		{
			if (string.Compare("XML", feature, StringComparison.OrdinalIgnoreCase) == 0)
			{
				switch (version)
				{
				case null:
				case "1.0":
				case "2.0":
					return true;
				}
			}
			return false;
		}

		internal static bool HasReadOnlyParent(XmlNode n)
		{
			while (n != null)
			{
				switch (n.NodeType)
				{
				case XmlNodeType.EntityReference:
				case XmlNodeType.Entity:
					return true;
				case XmlNodeType.Attribute:
					n = ((XmlAttribute)n).OwnerElement;
					break;
				default:
					n = n.ParentNode;
					break;
				}
			}
			return false;
		}

		public virtual XmlNode Clone()
		{
			return CloneNode(deep: true);
		}

		object ICloneable.Clone()
		{
			return CloneNode(deep: true);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new XmlChildEnumerator(this);
		}

		public IEnumerator GetEnumerator()
		{
			return new XmlChildEnumerator(this);
		}

		private void AppendChildText(StringBuilder builder)
		{
			for (XmlNode xmlNode = FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
			{
				if (xmlNode.FirstChild == null)
				{
					if (xmlNode.NodeType == XmlNodeType.Text || xmlNode.NodeType == XmlNodeType.CDATA || xmlNode.NodeType == XmlNodeType.Whitespace || xmlNode.NodeType == XmlNodeType.SignificantWhitespace)
					{
						builder.Append(xmlNode.InnerText);
					}
				}
				else
				{
					xmlNode.AppendChildText(builder);
				}
			}
		}

		public abstract void WriteTo(XmlWriter w);

		public abstract void WriteContentTo(XmlWriter w);

		public virtual void RemoveAll()
		{
			XmlNode xmlNode = FirstChild;
			XmlNode xmlNode2 = null;
			while (xmlNode != null)
			{
				xmlNode2 = xmlNode.NextSibling;
				RemoveChild(xmlNode);
				xmlNode = xmlNode2;
			}
		}

		public virtual string GetNamespaceOfPrefix(string prefix)
		{
			string namespaceOfPrefixStrict = GetNamespaceOfPrefixStrict(prefix);
			if (namespaceOfPrefixStrict == null)
			{
				return string.Empty;
			}
			return namespaceOfPrefixStrict;
		}

		internal string GetNamespaceOfPrefixStrict(string prefix)
		{
			XmlDocument document = Document;
			if (document != null)
			{
				prefix = document.NameTable.Get(prefix);
				if (prefix == null)
				{
					return null;
				}
				XmlNode xmlNode = this;
				while (xmlNode != null)
				{
					if (xmlNode.NodeType == XmlNodeType.Element)
					{
						XmlElement xmlElement = (XmlElement)xmlNode;
						if (xmlElement.HasAttributes)
						{
							XmlAttributeCollection attributes = xmlElement.Attributes;
							if (prefix.Length == 0)
							{
								for (int i = 0; i < attributes.Count; i++)
								{
									XmlAttribute xmlAttribute = attributes[i];
									if (xmlAttribute.Prefix.Length == 0 && Ref.Equal(xmlAttribute.LocalName, document.strXmlns))
									{
										return xmlAttribute.Value;
									}
								}
							}
							else
							{
								for (int j = 0; j < attributes.Count; j++)
								{
									XmlAttribute xmlAttribute2 = attributes[j];
									if (Ref.Equal(xmlAttribute2.Prefix, document.strXmlns))
									{
										if (Ref.Equal(xmlAttribute2.LocalName, prefix))
										{
											return xmlAttribute2.Value;
										}
									}
									else if (Ref.Equal(xmlAttribute2.Prefix, prefix))
									{
										return xmlAttribute2.NamespaceURI;
									}
								}
							}
						}
						if (Ref.Equal(xmlNode.Prefix, prefix))
						{
							return xmlNode.NamespaceURI;
						}
						xmlNode = xmlNode.ParentNode;
					}
					else
					{
						xmlNode = ((xmlNode.NodeType != XmlNodeType.Attribute) ? xmlNode.ParentNode : ((XmlAttribute)xmlNode).OwnerElement);
					}
				}
				if (Ref.Equal(document.strXml, prefix))
				{
					return document.strReservedXml;
				}
				if (Ref.Equal(document.strXmlns, prefix))
				{
					return document.strReservedXmlns;
				}
			}
			return null;
		}

		public virtual string GetPrefixOfNamespace(string namespaceURI)
		{
			string prefixOfNamespaceStrict = GetPrefixOfNamespaceStrict(namespaceURI);
			if (prefixOfNamespaceStrict == null)
			{
				return string.Empty;
			}
			return prefixOfNamespaceStrict;
		}

		internal string GetPrefixOfNamespaceStrict(string namespaceURI)
		{
			XmlDocument document = Document;
			if (document != null)
			{
				namespaceURI = document.NameTable.Add(namespaceURI);
				XmlNode xmlNode = this;
				while (xmlNode != null)
				{
					if (xmlNode.NodeType == XmlNodeType.Element)
					{
						XmlElement xmlElement = (XmlElement)xmlNode;
						if (xmlElement.HasAttributes)
						{
							XmlAttributeCollection attributes = xmlElement.Attributes;
							for (int i = 0; i < attributes.Count; i++)
							{
								XmlAttribute xmlAttribute = attributes[i];
								if (xmlAttribute.Prefix.Length == 0)
								{
									if (Ref.Equal(xmlAttribute.LocalName, document.strXmlns) && xmlAttribute.Value == namespaceURI)
									{
										return string.Empty;
									}
								}
								else if (Ref.Equal(xmlAttribute.Prefix, document.strXmlns))
								{
									if (xmlAttribute.Value == namespaceURI)
									{
										return xmlAttribute.LocalName;
									}
								}
								else if (Ref.Equal(xmlAttribute.NamespaceURI, namespaceURI))
								{
									return xmlAttribute.Prefix;
								}
							}
						}
						if (Ref.Equal(xmlNode.NamespaceURI, namespaceURI))
						{
							return xmlNode.Prefix;
						}
						xmlNode = xmlNode.ParentNode;
					}
					else
					{
						xmlNode = ((xmlNode.NodeType != XmlNodeType.Attribute) ? xmlNode.ParentNode : ((XmlAttribute)xmlNode).OwnerElement);
					}
				}
				if (object.Equals(document.strReservedXml, namespaceURI))
				{
					return document.strXml;
				}
				if (object.Equals(document.strReservedXmlns, namespaceURI))
				{
					return document.strXmlns;
				}
			}
			return null;
		}

		internal virtual void SetParent(XmlNode node)
		{
			if (node == null)
			{
				parentNode = OwnerDocument;
			}
			else
			{
				parentNode = node;
			}
		}

		internal virtual void SetParentForLoad(XmlNode node)
		{
			parentNode = node;
		}

		internal static void SplitName(string name, out string prefix, out string localName)
		{
			int num = name.IndexOf(':');
			if (-1 == num || num == 0 || name.Length - 1 == num)
			{
				prefix = string.Empty;
				localName = name;
			}
			else
			{
				prefix = name.Substring(0, num);
				localName = name.Substring(num + 1);
			}
		}

		internal virtual XmlNode FindChild(XmlNodeType type)
		{
			for (XmlNode xmlNode = FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
			{
				if (xmlNode.NodeType == type)
				{
					return xmlNode;
				}
			}
			return null;
		}

		internal virtual XmlNodeChangedEventArgs GetEventArgs(XmlNode node, XmlNode oldParent, XmlNode newParent, string oldValue, string newValue, XmlNodeChangedAction action)
		{
			XmlDocument ownerDocument = OwnerDocument;
			if (ownerDocument != null)
			{
				if (!ownerDocument.IsLoading && ((newParent != null && newParent.IsReadOnly) || (oldParent != null && oldParent.IsReadOnly)))
				{
					throw new InvalidOperationException(Res.GetString("Xdom_Node_Modify_ReadOnly"));
				}
				return ownerDocument.GetEventArgs(node, oldParent, newParent, oldValue, newValue, action);
			}
			return null;
		}

		internal virtual void BeforeEvent(XmlNodeChangedEventArgs args)
		{
			if (args != null)
			{
				OwnerDocument.BeforeEvent(args);
			}
		}

		internal virtual void AfterEvent(XmlNodeChangedEventArgs args)
		{
			if (args != null)
			{
				OwnerDocument.AfterEvent(args);
			}
		}

		internal virtual string GetXPAttribute(string localName, string namespaceURI)
		{
			return string.Empty;
		}

		internal static void NestTextNodes(XmlNode prevNode, XmlNode nextNode)
		{
			nextNode.parentNode = prevNode;
		}

		internal static void UnnestTextNodes(XmlNode prevNode, XmlNode nextNode)
		{
			nextNode.parentNode = prevNode.ParentNode;
		}
	}
	public class XmlAttribute : XmlNode
	{
		private XmlName name;

		private XmlLinkedNode lastChild;

		internal int LocalNameHash => name.HashCode;

		internal XmlName XmlName
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public override XmlNode ParentNode => null;

		public override string Name => name.Name;

		public override string LocalName => name.LocalName;

		public override string NamespaceURI => name.NamespaceURI;

		public override string Prefix
		{
			get
			{
				return name.Prefix;
			}
			set
			{
				name = name.OwnerDocument.AddAttrXmlName(value, LocalName, NamespaceURI, SchemaInfo);
			}
		}

		public override XmlNodeType NodeType => XmlNodeType.Attribute;

		public override XmlDocument OwnerDocument => name.OwnerDocument;

		public override string Value
		{
			get
			{
				return InnerText;
			}
			set
			{
				InnerText = value;
			}
		}

		public override IXmlSchemaInfo SchemaInfo => name;

		public override string InnerText
		{
			set
			{
				if (PrepareOwnerElementInElementIdAttrMap())
				{
					string innerText = base.InnerText;
					base.InnerText = value;
					ResetOwnerElementInElementIdAttrMap(innerText);
				}
				else
				{
					base.InnerText = value;
				}
			}
		}

		internal override bool IsContainer => true;

		internal override XmlLinkedNode LastNode
		{
			get
			{
				return lastChild;
			}
			set
			{
				lastChild = value;
			}
		}

		public virtual bool Specified => true;

		public virtual XmlElement OwnerElement => parentNode as XmlElement;

		public override string InnerXml
		{
			set
			{
				RemoveAll();
				XmlLoader xmlLoader = new XmlLoader();
				xmlLoader.LoadInnerXmlAttribute(this, value);
			}
		}

		public override string BaseURI
		{
			get
			{
				if (OwnerElement != null)
				{
					return OwnerElement.BaseURI;
				}
				return string.Empty;
			}
		}

		internal override XmlSpace XmlSpace
		{
			get
			{
				if (OwnerElement != null)
				{
					return OwnerElement.XmlSpace;
				}
				return XmlSpace.None;
			}
		}

		internal override string XmlLang
		{
			get
			{
				if (OwnerElement != null)
				{
					return OwnerElement.XmlLang;
				}
				return string.Empty;
			}
		}

		internal override XPathNodeType XPNodeType
		{
			get
			{
				if (IsNamespace)
				{
					return XPathNodeType.Namespace;
				}
				return XPathNodeType.Attribute;
			}
		}

		internal override string XPLocalName
		{
			get
			{
				string localName = name.LocalName;
				if (localName == OwnerDocument.strXmlns)
				{
					return string.Empty;
				}
				return localName;
			}
		}

		internal bool IsNamespace => Ref.Equal(name.NamespaceURI, name.OwnerDocument.strReservedXmlns);

		internal XmlAttribute(XmlName name, XmlDocument doc)
			: base(doc)
		{
			parentNode = null;
			if (!doc.IsLoading)
			{
				XmlDocument.CheckName(name.Prefix);
				XmlDocument.CheckName(name.LocalName);
			}
			if (name.LocalName.Length == 0)
			{
				throw new ArgumentException(Res.GetString("Xdom_Attr_Name"));
			}
			this.name = name;
		}

		protected internal XmlAttribute(string prefix, string localName, string namespaceURI, XmlDocument doc)
			: this(doc.AddAttrXmlName(prefix, localName, namespaceURI, null), doc)
		{
		}

		public override XmlNode CloneNode(bool deep)
		{
			XmlDocument ownerDocument = OwnerDocument;
			XmlAttribute xmlAttribute = ownerDocument.CreateAttribute(Prefix, LocalName, NamespaceURI);
			xmlAttribute.CopyChildren(ownerDocument, this, deep: true);
			return xmlAttribute;
		}

		internal bool PrepareOwnerElementInElementIdAttrMap()
		{
			XmlDocument ownerDocument = OwnerDocument;
			if (ownerDocument.DtdSchemaInfo != null)
			{
				XmlElement ownerElement = OwnerElement;
				if (ownerElement != null)
				{
					return ownerElement.Attributes.PrepareParentInElementIdAttrMap(Prefix, LocalName);
				}
			}
			return false;
		}

		internal void ResetOwnerElementInElementIdAttrMap(string oldInnerText)
		{
			OwnerElement?.Attributes.ResetParentInElementIdAttrMap(oldInnerText, InnerText);
		}

		internal override XmlNode AppendChildForLoad(XmlNode newChild, XmlDocument doc)
		{
			XmlNodeChangedEventArgs insertEventArgsForLoad = doc.GetInsertEventArgsForLoad(newChild, this);
			if (insertEventArgsForLoad != null)
			{
				doc.BeforeEvent(insertEventArgsForLoad);
			}
			XmlLinkedNode xmlLinkedNode = (XmlLinkedNode)newChild;
			if (lastChild == null)
			{
				xmlLinkedNode.next = xmlLinkedNode;
				lastChild = xmlLinkedNode;
				xmlLinkedNode.SetParentForLoad(this);
			}
			else
			{
				XmlLinkedNode xmlLinkedNode2 = lastChild;
				xmlLinkedNode.next = xmlLinkedNode2.next;
				xmlLinkedNode2.next = xmlLinkedNode;
				lastChild = xmlLinkedNode;
				if (xmlLinkedNode2.IsText && xmlLinkedNode.IsText)
				{
					XmlNode.NestTextNodes(xmlLinkedNode2, xmlLinkedNode);
				}
				else
				{
					xmlLinkedNode.SetParentForLoad(this);
				}
			}
			if (insertEventArgsForLoad != null)
			{
				doc.AfterEvent(insertEventArgsForLoad);
			}
			return xmlLinkedNode;
		}

		internal override bool IsValidChildType(XmlNodeType type)
		{
			if (type != XmlNodeType.Text)
			{
				return type == XmlNodeType.EntityReference;
			}
			return true;
		}

		public override XmlNode InsertBefore(XmlNode newChild, XmlNode refChild)
		{
			XmlNode result;
			if (PrepareOwnerElementInElementIdAttrMap())
			{
				string innerText = InnerText;
				result = base.InsertBefore(newChild, refChild);
				ResetOwnerElementInElementIdAttrMap(innerText);
			}
			else
			{
				result = base.InsertBefore(newChild, refChild);
			}
			return result;
		}

		public override XmlNode InsertAfter(XmlNode newChild, XmlNode refChild)
		{
			XmlNode result;
			if (PrepareOwnerElementInElementIdAttrMap())
			{
				string innerText = InnerText;
				result = base.InsertAfter(newChild, refChild);
				ResetOwnerElementInElementIdAttrMap(innerText);
			}
			else
			{
				result = base.InsertAfter(newChild, refChild);
			}
			return result;
		}

		public override XmlNode ReplaceChild(XmlNode newChild, XmlNode oldChild)
		{
			XmlNode result;
			if (PrepareOwnerElementInElementIdAttrMap())
			{
				string innerText = InnerText;
				result = base.ReplaceChild(newChild, oldChild);
				ResetOwnerElementInElementIdAttrMap(innerText);
			}
			else
			{
				result = base.ReplaceChild(newChild, oldChild);
			}
			return result;
		}

		public override XmlNode RemoveChild(XmlNode oldChild)
		{
			XmlNode result;
			if (PrepareOwnerElementInElementIdAttrMap())
			{
				string innerText = InnerText;
				result = base.RemoveChild(oldChild);
				ResetOwnerElementInElementIdAttrMap(innerText);
			}
			else
			{
				result = base.RemoveChild(oldChild);
			}
			return result;
		}

		public override XmlNode PrependChild(XmlNode newChild)
		{
			XmlNode result;
			if (PrepareOwnerElementInElementIdAttrMap())
			{
				string innerText = InnerText;
				result = base.PrependChild(newChild);
				ResetOwnerElementInElementIdAttrMap(innerText);
			}
			else
			{
				result = base.PrependChild(newChild);
			}
			return result;
		}

		public override XmlNode AppendChild(XmlNode newChild)
		{
			XmlNode result;
			if (PrepareOwnerElementInElementIdAttrMap())
			{
				string innerText = InnerText;
				result = base.AppendChild(newChild);
				ResetOwnerElementInElementIdAttrMap(innerText);
			}
			else
			{
				result = base.AppendChild(newChild);
			}
			return result;
		}

		public override void WriteTo(XmlWriter w)
		{
			w.WriteStartAttribute(Prefix, LocalName, NamespaceURI);
			WriteContentTo(w);
			w.WriteEndAttribute();
		}

		public override void WriteContentTo(XmlWriter w)
		{
			for (XmlNode xmlNode = FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
			{
				xmlNode.WriteTo(w);
			}
		}

		internal override void SetParent(XmlNode node)
		{
			parentNode = node;
		}
	}
	public class XmlNamedNodeMap : IEnumerable
	{
		internal XmlNode parent;

		internal ArrayList nodes;

		public virtual int Count
		{
			get
			{
				if (nodes != null)
				{
					return nodes.Count;
				}
				return 0;
			}
		}

		internal ArrayList Nodes
		{
			get
			{
				if (nodes == null)
				{
					nodes = new ArrayList();
				}
				return nodes;
			}
		}

		internal XmlNamedNodeMap(XmlNode parent)
		{
			this.parent = parent;
			nodes = null;
		}

		public virtual XmlNode GetNamedItem(string name)
		{
			int num = FindNodeOffset(name);
			if (num >= 0)
			{
				return (XmlNode)Nodes[num];
			}
			return null;
		}

		public virtual XmlNode SetNamedItem(XmlNode node)
		{
			if (node == null)
			{
				return null;
			}
			int num = FindNodeOffset(node.LocalName, node.NamespaceURI);
			if (num == -1)
			{
				AddNode(node);
				return null;
			}
			return ReplaceNodeAt(num, node);
		}

		public virtual XmlNode RemoveNamedItem(string name)
		{
			int num = FindNodeOffset(name);
			if (num >= 0)
			{
				return RemoveNodeAt(num);
			}
			return null;
		}

		public virtual XmlNode Item(int index)
		{
			if (index < 0 || index >= Nodes.Count)
			{
				return null;
			}
			try
			{
				return (XmlNode)Nodes[index];
			}
			catch (ArgumentOutOfRangeException)
			{
				throw new IndexOutOfRangeException(Res.GetString("Xdom_IndexOutOfRange"));
			}
		}

		public virtual XmlNode GetNamedItem(string localName, string namespaceURI)
		{
			int num = FindNodeOffset(localName, namespaceURI);
			if (num >= 0)
			{
				return (XmlNode)Nodes[num];
			}
			return null;
		}

		public virtual XmlNode RemoveNamedItem(string localName, string namespaceURI)
		{
			int num = FindNodeOffset(localName, namespaceURI);
			if (num >= 0)
			{
				return RemoveNodeAt(num);
			}
			return null;
		}

		public virtual IEnumerator GetEnumerator()
		{
			if (nodes == null)
			{
				return XmlDocument.EmptyEnumerator;
			}
			return Nodes.GetEnumerator();
		}

		internal int FindNodeOffset(string name)
		{
			int count = Count;
			for (int i = 0; i < count; i++)
			{
				XmlNode xmlNode = (XmlNode)Nodes[i];
				if (name == xmlNode.Name)
				{
					return i;
				}
			}
			return -1;
		}

		internal int FindNodeOffset(string localName, string namespaceURI)
		{
			int count = Count;
			for (int i = 0; i < count; i++)
			{
				XmlNode xmlNode = (XmlNode)Nodes[i];
				if (xmlNode.LocalName == localName && xmlNode.NamespaceURI == namespaceURI)
				{
					return i;
				}
			}
			return -1;
		}

		internal virtual XmlNode AddNode(XmlNode node)
		{
			XmlNode oldParent = ((node.NodeType != XmlNodeType.Attribute) ? node.ParentNode : ((XmlAttribute)node).OwnerElement);
			string value = node.Value;
			XmlNodeChangedEventArgs eventArgs = parent.GetEventArgs(node, oldParent, parent, value, value, XmlNodeChangedAction.Insert);
			if (eventArgs != null)
			{
				parent.BeforeEvent(eventArgs);
			}
			Nodes.Add(node);
			node.SetParent(parent);
			if (eventArgs != null)
			{
				parent.AfterEvent(eventArgs);
			}
			return node;
		}

		internal virtual XmlNode AddNodeForLoad(XmlNode node, XmlDocument doc)
		{
			XmlNodeChangedEventArgs insertEventArgsForLoad = doc.GetInsertEventArgsForLoad(node, parent);
			if (insertEventArgsForLoad != null)
			{
				doc.BeforeEvent(insertEventArgsForLoad);
			}
			Nodes.Add(node);
			node.SetParent(parent);
			if (insertEventArgsForLoad != null)
			{
				doc.AfterEvent(insertEventArgsForLoad);
			}
			return node;
		}

		internal virtual XmlNode RemoveNodeAt(int i)
		{
			XmlNode xmlNode = (XmlNode)Nodes[i];
			string value = xmlNode.Value;
			XmlNodeChangedEventArgs eventArgs = parent.GetEventArgs(xmlNode, parent, null, value, value, XmlNodeChangedAction.Remove);
			if (eventArgs != null)
			{
				parent.BeforeEvent(eventArgs);
			}
			Nodes.RemoveAt(i);
			xmlNode.SetParent(null);
			if (eventArgs != null)
			{
				parent.AfterEvent(eventArgs);
			}
			return xmlNode;
		}

		internal XmlNode ReplaceNodeAt(int i, XmlNode node)
		{
			XmlNode result = RemoveNodeAt(i);
			InsertNodeAt(i, node);
			return result;
		}

		internal virtual XmlNode InsertNodeAt(int i, XmlNode node)
		{
			XmlNode oldParent = ((node.NodeType != XmlNodeType.Attribute) ? node.ParentNode : ((XmlAttribute)node).OwnerElement);
			string value = node.Value;
			XmlNodeChangedEventArgs eventArgs = parent.GetEventArgs(node, oldParent, parent, value, value, XmlNodeChangedAction.Insert);
			if (eventArgs != null)
			{
				parent.BeforeEvent(eventArgs);
			}
			Nodes.Insert(i, node);
			node.SetParent(parent);
			if (eventArgs != null)
			{
				parent.AfterEvent(eventArgs);
			}
			return node;
		}
	}
	public sealed class XmlAttributeCollection : XmlNamedNodeMap, ICollection, IEnumerable
	{
		[IndexerName("ItemOf")]
		public XmlAttribute this[int i]
		{
			get
			{
				try
				{
					return (XmlAttribute)base.Nodes[i];
				}
				catch (ArgumentOutOfRangeException)
				{
					throw new IndexOutOfRangeException(Res.GetString("Xdom_IndexOutOfRange"));
				}
			}
		}

		[IndexerName("ItemOf")]
		public XmlAttribute this[string name]
		{
			get
			{
				ArrayList arrayList = base.Nodes;
				int hashCode = XmlName.GetHashCode(name);
				for (int i = 0; i < arrayList.Count; i++)
				{
					XmlAttribute xmlAttribute = (XmlAttribute)arrayList[i];
					if (hashCode == xmlAttribute.LocalNameHash && name == xmlAttribute.Name)
					{
						return xmlAttribute;
					}
				}
				return null;
			}
		}

		[IndexerName("ItemOf")]
		public XmlAttribute this[string localName, string namespaceURI]
		{
			get
			{
				ArrayList arrayList = base.Nodes;
				int hashCode = XmlName.GetHashCode(localName);
				for (int i = 0; i < arrayList.Count; i++)
				{
					XmlAttribute xmlAttribute = (XmlAttribute)arrayList[i];
					if (hashCode == xmlAttribute.LocalNameHash && localName == xmlAttribute.LocalName && namespaceURI == xmlAttribute.NamespaceURI)
					{
						return xmlAttribute;
					}
				}
				return null;
			}
		}

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot => this;

		int ICollection.Count => base.Count;

		internal XmlAttributeCollection(XmlNode parent)
			: base(parent)
		{
		}

		internal int FindNodeOffset(XmlAttribute node)
		{
			ArrayList arrayList = base.Nodes;
			for (int i = 0; i < arrayList.Count; i++)
			{
				XmlAttribute xmlAttribute = (XmlAttribute)arrayList[i];
				if (xmlAttribute.LocalNameHash == node.LocalNameHash && xmlAttribute.Name == node.Name && xmlAttribute.NamespaceURI == node.NamespaceURI)
				{
					return i;
				}
			}
			return -1;
		}

		internal int FindNodeOffsetNS(XmlAttribute node)
		{
			ArrayList arrayList = base.Nodes;
			for (int i = 0; i < arrayList.Count; i++)
			{
				XmlAttribute xmlAttribute = (XmlAttribute)arrayList[i];
				if (xmlAttribute.LocalNameHash == node.LocalNameHash && xmlAttribute.LocalName == node.LocalName && xmlAttribute.NamespaceURI == node.NamespaceURI)
				{
					return i;
				}
			}
			return -1;
		}

		public override XmlNode SetNamedItem(XmlNode node)
		{
			if (node != null && !(node is XmlAttribute))
			{
				throw new ArgumentException(Res.GetString("Xdom_AttrCol_Object"));
			}
			int num = FindNodeOffset(node.LocalName, node.NamespaceURI);
			if (num == -1)
			{
				return InternalAppendAttribute((XmlAttribute)node);
			}
			XmlNode result = base.RemoveNodeAt(num);
			InsertNodeAt(num, node);
			return result;
		}

		public XmlAttribute Prepend(XmlAttribute node)
		{
			if (node.OwnerDocument != null && node.OwnerDocument != parent.OwnerDocument)
			{
				throw new ArgumentException(Res.GetString("Xdom_NamedNode_Context"));
			}
			if (node.OwnerElement != null)
			{
				Detach(node);
			}
			RemoveDuplicateAttribute(node);
			InsertNodeAt(0, node);
			return node;
		}

		public XmlAttribute Append(XmlAttribute node)
		{
			XmlDocument ownerDocument = node.OwnerDocument;
			if (ownerDocument == null || !ownerDocument.IsLoading)
			{
				if (ownerDocument != null && ownerDocument != parent.OwnerDocument)
				{
					throw new ArgumentException(Res.GetString("Xdom_NamedNode_Context"));
				}
				if (node.OwnerElement != null)
				{
					Detach(node);
				}
				AddNode(node);
			}
			else
			{
				base.AddNodeForLoad(node, ownerDocument);
				InsertParentIntoElementIdAttrMap(node);
			}
			return node;
		}

		public XmlAttribute InsertBefore(XmlAttribute newNode, XmlAttribute refNode)
		{
			if (newNode == refNode)
			{
				return newNode;
			}
			if (refNode == null)
			{
				return Append(newNode);
			}
			if (refNode.OwnerElement != parent)
			{
				throw new ArgumentException(Res.GetString("Xdom_AttrCol_Insert"));
			}
			if (newNode.OwnerDocument != null && newNode.OwnerDocument != parent.OwnerDocument)
			{
				throw new ArgumentException(Res.GetString("Xdom_NamedNode_Context"));
			}
			if (newNode.OwnerElement != null)
			{
				Detach(newNode);
			}
			int num = FindNodeOffset(refNode.LocalName, refNode.NamespaceURI);
			int num2 = RemoveDuplicateAttribute(newNode);
			if (num2 >= 0 && num2 < num)
			{
				num--;
			}
			InsertNodeAt(num, newNode);
			return newNode;
		}

		public XmlAttribute InsertAfter(XmlAttribute newNode, XmlAttribute refNode)
		{
			if (newNode == refNode)
			{
				return newNode;
			}
			if (refNode == null)
			{
				return Prepend(newNode);
			}
			if (refNode.OwnerElement != parent)
			{
				throw new ArgumentException(Res.GetString("Xdom_AttrCol_Insert"));
			}
			if (newNode.OwnerDocument != null && newNode.OwnerDocument != parent.OwnerDocument)
			{
				throw new ArgumentException(Res.GetString("Xdom_NamedNode_Context"));
			}
			if (newNode.OwnerElement != null)
			{
				Detach(newNode);
			}
			int num = FindNodeOffset(refNode.LocalName, refNode.NamespaceURI);
			int num2 = RemoveDuplicateAttribute(newNode);
			if (num2 >= 0 && num2 < num)
			{
				num--;
			}
			InsertNodeAt(num + 1, newNode);
			return newNode;
		}

		public XmlAttribute Remove(XmlAttribute node)
		{
			if (nodes != null)
			{
				int count = nodes.Count;
				for (int i = 0; i < count; i++)
				{
					if (nodes[i] == node)
					{
						RemoveNodeAt(i);
						return node;
					}
				}
			}
			return null;
		}

		public XmlAttribute RemoveAt(int i)
		{
			if (i < 0 || i >= Count || nodes == null)
			{
				return null;
			}
			return (XmlAttribute)RemoveNodeAt(i);
		}

		public void RemoveAll()
		{
			int num = Count;
			while (num > 0)
			{
				num--;
				RemoveAt(num);
			}
		}

		void ICollection.CopyTo(Array array, int index)
		{
			int num = 0;
			int count = base.Nodes.Count;
			while (num < count)
			{
				array.SetValue(nodes[num], index);
				num++;
				index++;
			}
		}

		public void CopyTo(XmlAttribute[] array, int index)
		{
			int num = 0;
			int count = Count;
			while (num < count)
			{
				array[index] = (XmlAttribute)((XmlNode)nodes[num]).CloneNode(deep: true);
				num++;
				index++;
			}
		}

		internal override XmlNode AddNode(XmlNode node)
		{
			RemoveDuplicateAttribute((XmlAttribute)node);
			XmlNode result = base.AddNode(node);
			InsertParentIntoElementIdAttrMap((XmlAttribute)node);
			return result;
		}

		internal override XmlNode InsertNodeAt(int i, XmlNode node)
		{
			XmlNode result = base.InsertNodeAt(i, node);
			InsertParentIntoElementIdAttrMap((XmlAttribute)node);
			return result;
		}

		internal override XmlNode RemoveNodeAt(int i)
		{
			XmlNode xmlNode = base.RemoveNodeAt(i);
			RemoveParentFromElementIdAttrMap((XmlAttribute)xmlNode);
			XmlAttribute defaultAttribute = parent.OwnerDocument.GetDefaultAttribute((XmlElement)parent, xmlNode.Prefix, xmlNode.LocalName, xmlNode.NamespaceURI);
			if (defaultAttribute != null)
			{
				InsertNodeAt(i, defaultAttribute);
			}
			return xmlNode;
		}

		internal void Detach(XmlAttribute attr)
		{
			attr.OwnerElement.Attributes.Remove(attr);
		}

		internal void InsertParentIntoElementIdAttrMap(XmlAttribute attr)
		{
			if (parent is XmlElement xmlElement && parent.OwnerDocument != null)
			{
				XmlName iDInfoByElement = parent.OwnerDocument.GetIDInfoByElement(xmlElement.XmlName);
				if (iDInfoByElement != null && iDInfoByElement.Prefix == attr.XmlName.Prefix && iDInfoByElement.LocalName == attr.XmlName.LocalName)
				{
					parent.OwnerDocument.AddElementWithId(attr.Value, xmlElement);
				}
			}
		}

		internal void RemoveParentFromElementIdAttrMap(XmlAttribute attr)
		{
			if (parent is XmlElement xmlElement && parent.OwnerDocument != null)
			{
				XmlName iDInfoByElement = parent.OwnerDocument.GetIDInfoByElement(xmlElement.XmlName);
				if (iDInfoByElement != null && iDInfoByElement.Prefix == attr.XmlName.Prefix && iDInfoByElement.LocalName == attr.XmlName.LocalName)
				{
					parent.OwnerDocument.RemoveElementWithId(attr.Value, xmlElement);
				}
			}
		}

		internal int RemoveDuplicateAttribute(XmlAttribute attr)
		{
			int num = FindNodeOffset(attr.LocalName, attr.NamespaceURI);
			if (num != -1)
			{
				XmlAttribute attr2 = (XmlAttribute)base.Nodes[num];
				base.RemoveNodeAt(num);
				RemoveParentFromElementIdAttrMap(attr2);
			}
			return num;
		}

		internal bool PrepareParentInElementIdAttrMap(string attrPrefix, string attrLocalName)
		{
			XmlElement xmlElement = parent as XmlElement;
			XmlDocument ownerDocument = parent.OwnerDocument;
			XmlName iDInfoByElement = ownerDocument.GetIDInfoByElement(xmlElement.XmlName);
			if (iDInfoByElement != null && iDInfoByElement.Prefix == attrPrefix && iDInfoByElement.LocalName == attrLocalName)
			{
				return true;
			}
			return false;
		}

		internal void ResetParentInElementIdAttrMap(string oldVal, string newVal)
		{
			XmlElement elem = parent as XmlElement;
			XmlDocument ownerDocument = parent.OwnerDocument;
			ownerDocument.RemoveElementWithId(oldVal, elem);
			ownerDocument.AddElementWithId(newVal, elem);
		}

		internal XmlAttribute InternalAppendAttribute(XmlAttribute node)
		{
			XmlNode xmlNode = base.AddNode(node);
			InsertParentIntoElementIdAttrMap(node);
			return (XmlAttribute)xmlNode;
		}
	}
	public abstract class XmlLinkedNode : XmlNode
	{
		internal XmlLinkedNode next;

		public override XmlNode PreviousSibling
		{
			get
			{
				XmlNode xmlNode = ParentNode;
				if (xmlNode != null)
				{
					XmlNode xmlNode2 = xmlNode.FirstChild;
					while (xmlNode2 != null)
					{
						XmlNode nextSibling = xmlNode2.NextSibling;
						if (nextSibling == this)
						{
							break;
						}
						xmlNode2 = nextSibling;
					}
					return xmlNode2;
				}
				return null;
			}
		}

		public override XmlNode NextSibling
		{
			get
			{
				XmlNode xmlNode = ParentNode;
				if (xmlNode != null && next != xmlNode.FirstChild)
				{
					return next;
				}
				return null;
			}
		}

		internal XmlLinkedNode()
		{
			next = null;
		}

		internal XmlLinkedNode(XmlDocument doc)
			: base(doc)
		{
			next = null;
		}
	}
	public abstract class XmlCharacterData : XmlLinkedNode
	{
		private string data;

		public override string Value
		{
			get
			{
				return Data;
			}
			set
			{
				Data = value;
			}
		}

		public override string InnerText
		{
			get
			{
				return Value;
			}
			set
			{
				Value = value;
			}
		}

		public virtual string Data
		{
			get
			{
				if (data != null)
				{
					return data;
				}
				return string.Empty;
			}
			set
			{
				XmlNode xmlNode = ParentNode;
				XmlNodeChangedEventArgs eventArgs = GetEventArgs(this, xmlNode, xmlNode, data, value, XmlNodeChangedAction.Change);
				if (eventArgs != null)
				{
					BeforeEvent(eventArgs);
				}
				data = value;
				if (eventArgs != null)
				{
					AfterEvent(eventArgs);
				}
			}
		}

		public virtual int Length
		{
			get
			{
				if (data != null)
				{
					return data.Length;
				}
				return 0;
			}
		}

		protected internal XmlCharacterData(string data, XmlDocument doc)
			: base(doc)
		{
			this.data = data;
		}

		public virtual string Substring(int offset, int count)
		{
			int num = ((data != null) ? data.Length : 0);
			if (num > 0)
			{
				if (num < offset + count)
				{
					count = num - offset;
				}
				return data.Substring(offset, count);
			}
			return string.Empty;
		}

		public virtual void AppendData(string strData)
		{
			XmlNode xmlNode = ParentNode;
			int num = ((data != null) ? data.Length : 0);
			if (strData != null)
			{
				num += strData.Length;
			}
			string newValue = new StringBuilder(num).Append(data).Append(strData).ToString();
			XmlNodeChangedEventArgs eventArgs = GetEventArgs(this, xmlNode, xmlNode, data, newValue, XmlNodeChangedAction.Change);
			if (eventArgs != null)
			{
				BeforeEvent(eventArgs);
			}
			data = newValue;
			if (eventArgs != null)
			{
				AfterEvent(eventArgs);
			}
		}

		public virtual void InsertData(int offset, string strData)
		{
			XmlNode xmlNode = ParentNode;
			int num = ((data != null) ? data.Length : 0);
			if (strData != null)
			{
				num += strData.Length;
			}
			string newValue = new StringBuilder(num).Append(data).Insert(offset, strData).ToString();
			XmlNodeChangedEventArgs eventArgs = GetEventArgs(this, xmlNode, xmlNode, data, newValue, XmlNodeChangedAction.Change);
			if (eventArgs != null)
			{
				BeforeEvent(eventArgs);
			}
			data = newValue;
			if (eventArgs != null)
			{
				AfterEvent(eventArgs);
			}
		}

		public virtual void DeleteData(int offset, int count)
		{
			int num = ((data != null) ? data.Length : 0);
			if (num > 0 && num < offset + count)
			{
				count = Math.Max(num - offset, 0);
			}
			string newValue = new StringBuilder(data).Remove(offset, count).ToString();
			XmlNode xmlNode = ParentNode;
			XmlNodeChangedEventArgs eventArgs = GetEventArgs(this, xmlNode, xmlNode, data, newValue, XmlNodeChangedAction.Change);
			if (eventArgs != null)
			{
				BeforeEvent(eventArgs);
			}
			data = newValue;
			if (eventArgs != null)
			{
				AfterEvent(eventArgs);
			}
		}

		public virtual void ReplaceData(int offset, int count, string strData)
		{
			int num = ((data != null) ? data.Length : 0);
			if (num > 0 && num < offset + count)
			{
				count = Math.Max(num - offset, 0);
			}
			StringBuilder stringBuilder = new StringBuilder(data).Remove(offset, count);
			string newValue = stringBuilder.Insert(offset, strData).ToString();
			XmlNode xmlNode = ParentNode;
			XmlNodeChangedEventArgs eventArgs = GetEventArgs(this, xmlNode, xmlNode, data, newValue, XmlNodeChangedAction.Change);
			if (eventArgs != null)
			{
				BeforeEvent(eventArgs);
			}
			data = newValue;
			if (eventArgs != null)
			{
				AfterEvent(eventArgs);
			}
		}

		internal bool CheckOnData(string data)
		{
			return XmlCharType.Instance.IsOnlyWhitespace(data);
		}

		internal bool DecideXPNodeTypeForTextNodes(XmlNode node, ref XPathNodeType xnt)
		{
			while (node != null)
			{
				switch (node.NodeType)
				{
				case XmlNodeType.SignificantWhitespace:
					xnt = XPathNodeType.SignificantWhitespace;
					break;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
					xnt = XPathNodeType.Text;
					return false;
				case XmlNodeType.EntityReference:
					if (!DecideXPNodeTypeForTextNodes(node.FirstChild, ref xnt))
					{
						return false;
					}
					break;
				default:
					return false;
				case XmlNodeType.Whitespace:
					break;
				}
				node = node.NextSibling;
			}
			return true;
		}
	}
	public class XmlCDataSection : XmlCharacterData
	{
		public override string Name => OwnerDocument.strCDataSectionName;

		public override string LocalName => OwnerDocument.strCDataSectionName;

		public override XmlNodeType NodeType => XmlNodeType.CDATA;

		public override XmlNode ParentNode
		{
			get
			{
				switch (parentNode.NodeType)
				{
				case XmlNodeType.Document:
					return null;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
				{
					XmlNode xmlNode = parentNode.parentNode;
					while (xmlNode.IsText)
					{
						xmlNode = xmlNode.parentNode;
					}
					return xmlNode;
				}
				default:
					return parentNode;
				}
			}
		}

		internal override XPathNodeType XPNodeType => XPathNodeType.Text;

		internal override bool IsText => true;

		internal override XmlNode PreviousText
		{
			get
			{
				if (parentNode.IsText)
				{
					return parentNode;
				}
				return null;
			}
		}

		protected internal XmlCDataSection(string data, XmlDocument doc)
			: base(data, doc)
		{
		}

		public override XmlNode CloneNode(bool deep)
		{
			return OwnerDocument.CreateCDataSection(Data);
		}

		public override void WriteTo(XmlWriter w)
		{
			w.WriteCData(Data);
		}

		public override void WriteContentTo(XmlWriter w)
		{
		}
	}
	internal sealed class XmlChildEnumerator : IEnumerator
	{
		internal XmlNode container;

		internal XmlNode child;

		internal bool isFirst;

		object IEnumerator.Current => Current;

		internal XmlNode Current
		{
			get
			{
				if (isFirst || child == null)
				{
					throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
				}
				return child;
			}
		}

		internal XmlChildEnumerator(XmlNode container)
		{
			this.container = container;
			child = container.FirstChild;
			isFirst = true;
		}

		bool IEnumerator.MoveNext()
		{
			return MoveNext();
		}

		internal bool MoveNext()
		{
			if (isFirst)
			{
				child = container.FirstChild;
				isFirst = false;
			}
			else if (child != null)
			{
				child = child.NextSibling;
			}
			return child != null;
		}

		void IEnumerator.Reset()
		{
			isFirst = true;
			child = container.FirstChild;
		}
	}
	public abstract class XmlNodeList : IEnumerable
	{
		public abstract int Count { get; }

		[IndexerName("ItemOf")]
		public virtual XmlNode this[int i] => Item(i);

		public abstract XmlNode Item(int index);

		public abstract IEnumerator GetEnumerator();
	}
	internal class XmlChildNodes : XmlNodeList
	{
		private XmlNode container;

		public override int Count
		{
			get
			{
				int num = 0;
				for (XmlNode xmlNode = container.FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
				{
					num++;
				}
				return num;
			}
		}

		public XmlChildNodes(XmlNode container)
		{
			this.container = container;
		}

		public override XmlNode Item(int i)
		{
			if (i < 0)
			{
				return null;
			}
			XmlNode xmlNode = container.FirstChild;
			while (xmlNode != null)
			{
				if (i == 0)
				{
					return xmlNode;
				}
				xmlNode = xmlNode.NextSibling;
				i--;
			}
			return null;
		}

		public override IEnumerator GetEnumerator()
		{
			if (container.FirstChild == null)
			{
				return XmlDocument.EmptyEnumerator;
			}
			return new XmlChildEnumerator(container);
		}
	}
	public class XmlComment : XmlCharacterData
	{
		public override string Name => OwnerDocument.strCommentName;

		public override string LocalName => OwnerDocument.strCommentName;

		public override XmlNodeType NodeType => XmlNodeType.Comment;

		internal override XPathNodeType XPNodeType => XPathNodeType.Comment;

		protected internal XmlComment(string comment, XmlDocument doc)
			: base(comment, doc)
		{
		}

		public override XmlNode CloneNode(bool deep)
		{
			return OwnerDocument.CreateComment(Data);
		}

		public override void WriteTo(XmlWriter w)
		{
			w.WriteComment(Data);
		}

		public override void WriteContentTo(XmlWriter w)
		{
		}
	}
	public class XmlDeclaration : XmlLinkedNode
	{
		private const string YES = "yes";

		private const string NO = "no";

		private const string VERNUM = "1.0";

		private string encoding;

		private string standalone;

		public string Version => "1.0";

		public string Encoding
		{
			get
			{
				return encoding;
			}
			set
			{
				encoding = ((value == null) ? string.Empty : value);
			}
		}

		public string Standalone
		{
			get
			{
				return standalone;
			}
			set
			{
				if (value == null)
				{
					standalone = string.Empty;
					return;
				}
				if (value.Length == 0 || value == "yes" || value == "no")
				{
					standalone = value;
					return;
				}
				throw new ArgumentException(Res.GetString("Xdom_standalone", value));
			}
		}

		public override string Value
		{
			get
			{
				return InnerText;
			}
			set
			{
				InnerText = value;
			}
		}

		public override string InnerText
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder("version=\"" + Version + "\"");
				if (Encoding.Length > 0)
				{
					stringBuilder.Append(" encoding=\"");
					stringBuilder.Append(Encoding);
					stringBuilder.Append("\"");
				}
				if (Standalone.Length > 0)
				{
					stringBuilder.Append(" standalone=\"");
					stringBuilder.Append(Standalone);
					stringBuilder.Append("\"");
				}
				return stringBuilder.ToString();
			}
			set
			{
				string version = null;
				string text = null;
				string text2 = null;
				string text3 = Encoding;
				string text4 = Standalone;
				XmlLoader.ParseXmlDeclarationValue(value, out version, out text, out text2);
				try
				{
					if (version != null && version != "1.0")
					{
						throw new ArgumentException(Res.GetString("Xdom_Version"));
					}
					if (text != null)
					{
						Encoding = text;
					}
					if (text2 != null)
					{
						Standalone = text2;
					}
				}
				catch
				{
					Encoding = text3;
					Standalone = text4;
					throw;
				}
			}
		}

		public override string Name => "xml";

		public override string LocalName => Name;

		public override XmlNodeType NodeType => XmlNodeType.XmlDeclaration;

		protected internal XmlDeclaration(string version, string encoding, string standalone, XmlDocument doc)
			: base(doc)
		{
			if (version != "1.0")
			{
				throw new ArgumentException(Res.GetString("Xdom_Version"));
			}
			if (standalone != null && standalone.Length > 0 && standalone != "yes" && standalone != "no")
			{
				throw new ArgumentException(Res.GetString("Xdom_standalone", standalone));
			}
			Encoding = encoding;
			Standalone = standalone;
		}

		public override XmlNode CloneNode(bool deep)
		{
			return OwnerDocument.CreateXmlDeclaration(Version, Encoding, Standalone);
		}

		public override void WriteTo(XmlWriter w)
		{
			w.WriteProcessingInstruction(Name, InnerText);
		}

		public override void WriteContentTo(XmlWriter w)
		{
		}
	}
	public class XmlDocument : XmlNode
	{
		private XmlImplementation implementation;

		private DomNameTable domNameTable;

		private XmlLinkedNode lastChild;

		private XmlNamedNodeMap entities;

		private Hashtable htElementIdMap;

		private Hashtable htElementIDAttrDecl;

		private SchemaInfo schemaInfo;

		private XmlSchemaSet schemas;

		private bool reportValidity;

		private bool actualLoadingStatus;

		private XmlNodeChangedEventHandler onNodeInsertingDelegate;

		private XmlNodeChangedEventHandler onNodeInsertedDelegate;

		private XmlNodeChangedEventHandler onNodeRemovingDelegate;

		private XmlNodeChangedEventHandler onNodeRemovedDelegate;

		private XmlNodeChangedEventHandler onNodeChangingDelegate;

		private XmlNodeChangedEventHandler onNodeChangedDelegate;

		internal bool fEntRefNodesPresent;

		internal bool fCDataNodesPresent;

		private bool preserveWhitespace;

		private bool isLoading;

		internal string strDocumentName;

		internal string strDocumentFragmentName;

		internal string strCommentName;

		internal string strTextName;

		internal string strCDataSectionName;

		internal string strEntityName;

		internal string strID;

		internal string strXmlns;

		internal string strXml;

		internal string strSpace;

		internal string strLang;

		internal string strEmpty;

		internal string strNonSignificantWhitespaceName;

		internal string strSignificantWhitespaceName;

		internal string strReservedXmlns;

		internal string strReservedXml;

		internal string baseURI;

		private XmlResolver resolver;

		internal bool bSetResolver;

		internal object objLock;

		private XmlAttribute namespaceXml;

		internal static EmptyEnumerator EmptyEnumerator = new EmptyEnumerator();

		internal static IXmlSchemaInfo NotKnownSchemaInfo = new XmlSchemaInfo(XmlSchemaValidity.NotKnown);

		internal static IXmlSchemaInfo ValidSchemaInfo = new XmlSchemaInfo(XmlSchemaValidity.Valid);

		internal static IXmlSchemaInfo InvalidSchemaInfo = new XmlSchemaInfo(XmlSchemaValidity.Invalid);

		internal SchemaInfo DtdSchemaInfo
		{
			get
			{
				return schemaInfo;
			}
			set
			{
				schemaInfo = value;
			}
		}

		public override XmlNodeType NodeType => XmlNodeType.Document;

		public override XmlNode ParentNode => null;

		public virtual XmlDocumentType DocumentType => (XmlDocumentType)FindChild(XmlNodeType.DocumentType);

		internal virtual XmlDeclaration Declaration
		{
			get
			{
				if (HasChildNodes)
				{
					return FirstChild as XmlDeclaration;
				}
				return null;
			}
		}

		public XmlImplementation Implementation => implementation;

		public override string Name => strDocumentName;

		public override string LocalName => strDocumentName;

		public XmlElement DocumentElement => (XmlElement)FindChild(XmlNodeType.Element);

		internal override bool IsContainer => true;

		internal override XmlLinkedNode LastNode
		{
			get
			{
				return lastChild;
			}
			set
			{
				lastChild = value;
			}
		}

		public override XmlDocument OwnerDocument => null;

		public XmlSchemaSet Schemas
		{
			get
			{
				if (schemas == null)
				{
					schemas = new XmlSchemaSet(NameTable);
				}
				return schemas;
			}
			set
			{
				schemas = value;
			}
		}

		internal bool CanReportValidity => reportValidity;

		internal bool HasSetResolver => bSetResolver;

		public virtual XmlResolver XmlResolver
		{
			set
			{
				if (value != null)
				{
					try
					{
						new NamedPermissionSet("FullTrust").Demand();
					}
					catch (SecurityException inner)
					{
						throw new SecurityException(Res.GetString("Xml_UntrustedCodeSettingResolver"), inner);
					}
				}
				resolver = value;
				if (!bSetResolver)
				{
					bSetResolver = true;
				}
				XmlDocumentType documentType = DocumentType;
				if (documentType != null)
				{
					documentType.DtdSchemaInfo = null;
				}
			}
		}

		public XmlNameTable NameTable => implementation.NameTable;

		public bool PreserveWhitespace
		{
			get
			{
				return preserveWhitespace;
			}
			set
			{
				preserveWhitespace = value;
			}
		}

		public override bool IsReadOnly => false;

		internal XmlNamedNodeMap Entities
		{
			get
			{
				if (entities == null)
				{
					entities = new XmlNamedNodeMap(this);
				}
				return entities;
			}
			set
			{
				entities = value;
			}
		}

		internal bool IsLoading
		{
			get
			{
				return isLoading;
			}
			set
			{
				isLoading = value;
			}
		}

		internal bool ActualLoadingStatus
		{
			get
			{
				return actualLoadingStatus;
			}
			set
			{
				actualLoadingStatus = value;
			}
		}

		internal Encoding TextEncoding
		{
			get
			{
				if (Declaration != null)
				{
					string encoding = Declaration.Encoding;
					if (encoding.Length > 0)
					{
						return System.Text.Encoding.GetEncoding(encoding);
					}
				}
				return null;
			}
		}

		public override string InnerXml
		{
			get
			{
				return base.InnerXml;
			}
			set
			{
				LoadXml(value);
			}
		}

		internal string Version => Declaration?.Version;

		internal string Encoding => Declaration?.Encoding;

		internal string Standalone => Declaration?.Standalone;

		public override IXmlSchemaInfo SchemaInfo
		{
			get
			{
				if (reportValidity)
				{
					XmlElement documentElement = DocumentElement;
					if (documentElement != null)
					{
						switch (documentElement.SchemaInfo.Validity)
						{
						case XmlSchemaValidity.Valid:
							return ValidSchemaInfo;
						case XmlSchemaValidity.Invalid:
							return InvalidSchemaInfo;
						}
					}
				}
				return NotKnownSchemaInfo;
			}
		}

		public override string BaseURI => baseURI;

		internal override XPathNodeType XPNodeType => XPathNodeType.Root;

		internal bool HasEntityReferences => fEntRefNodesPresent;

		internal XmlAttribute NamespaceXml
		{
			get
			{
				if (namespaceXml == null)
				{
					namespaceXml = new XmlAttribute(AddAttrXmlName(strXmlns, strXml, strReservedXmlns, null), this);
					namespaceXml.Value = strReservedXml;
				}
				return namespaceXml;
			}
		}

		public event XmlNodeChangedEventHandler NodeInserting
		{
			add
			{
				onNodeInsertingDelegate = (XmlNodeChangedEventHandler)Delegate.Combine(onNodeInsertingDelegate, value);
			}
			remove
			{
				onNodeInsertingDelegate = (XmlNodeChangedEventHandler)Delegate.Remove(onNodeInsertingDelegate, value);
			}
		}

		public event XmlNodeChangedEventHandler NodeInserted
		{
			add
			{
				onNodeInsertedDelegate = (XmlNodeChangedEventHandler)Delegate.Combine(onNodeInsertedDelegate, value);
			}
			remove
			{
				onNodeInsertedDelegate = (XmlNodeChangedEventHandler)Delegate.Remove(onNodeInsertedDelegate, value);
			}
		}

		public event XmlNodeChangedEventHandler NodeRemoving
		{
			add
			{
				onNodeRemovingDelegate = (XmlNodeChangedEventHandler)Delegate.Combine(onNodeRemovingDelegate, value);
			}
			remove
			{
				onNodeRemovingDelegate = (XmlNodeChangedEventHandler)Delegate.Remove(onNodeRemovingDelegate, value);
			}
		}

		public event XmlNodeChangedEventHandler NodeRemoved
		{
			add
			{
				onNodeRemovedDelegate = (XmlNodeChangedEventHandler)Delegate.Combine(onNodeRemovedDelegate, value);
			}
			remove
			{
				onNodeRemovedDelegate = (XmlNodeChangedEventHandler)Delegate.Remove(onNodeRemovedDelegate, value);
			}
		}

		public event XmlNodeChangedEventHandler NodeChanging
		{
			add
			{
				onNodeChangingDelegate = (XmlNodeChangedEventHandler)Delegate.Combine(onNodeChangingDelegate, value);
			}
			remove
			{
				onNodeChangingDelegate = (XmlNodeChangedEventHandler)Delegate.Remove(onNodeChangingDelegate, value);
			}
		}

		public event XmlNodeChangedEventHandler NodeChanged
		{
			add
			{
				onNodeChangedDelegate = (XmlNodeChangedEventHandler)Delegate.Combine(onNodeChangedDelegate, value);
			}
			remove
			{
				onNodeChangedDelegate = (XmlNodeChangedEventHandler)Delegate.Remove(onNodeChangedDelegate, value);
			}
		}

		public XmlDocument()
			: this(new XmlImplementation())
		{
		}

		public XmlDocument(XmlNameTable nt)
			: this(new XmlImplementation(nt))
		{
		}

		protected internal XmlDocument(XmlImplementation imp)
		{
			implementation = imp;
			domNameTable = new DomNameTable(this);
			XmlNameTable nameTable = NameTable;
			nameTable.Add(string.Empty);
			strDocumentName = nameTable.Add("#document");
			strDocumentFragmentName = nameTable.Add("#document-fragment");
			strCommentName = nameTable.Add("#comment");
			strTextName = nameTable.Add("#text");
			strCDataSectionName = nameTable.Add("#cdata-section");
			strEntityName = nameTable.Add("#entity");
			strID = nameTable.Add("id");
			strNonSignificantWhitespaceName = nameTable.Add("#whitespace");
			strSignificantWhitespaceName = nameTable.Add("#significant-whitespace");
			strXmlns = nameTable.Add("xmlns");
			strXml = nameTable.Add("xml");
			strSpace = nameTable.Add("space");
			strLang = nameTable.Add("lang");
			strReservedXmlns = nameTable.Add("http://www.w3.org/2000/xmlns/");
			strReservedXml = nameTable.Add("http://www.w3.org/XML/1998/namespace");
			strEmpty = nameTable.Add(string.Empty);
			baseURI = string.Empty;
			objLock = new object();
		}

		internal static void CheckName(string name)
		{
			XmlCharType instance = XmlCharType.Instance;
			for (int i = 0; i < name.Length; i++)
			{
				if (!instance.IsNCNameChar(name[i]))
				{
					throw new XmlException("Xml_BadNameChar", XmlException.BuildCharExceptionStr(name[i]));
				}
			}
		}

		internal XmlName AddXmlName(string prefix, string localName, string namespaceURI, IXmlSchemaInfo schemaInfo)
		{
			return domNameTable.AddName(prefix, localName, namespaceURI, schemaInfo);
		}

		internal XmlName GetXmlName(string prefix, string localName, string namespaceURI, IXmlSchemaInfo schemaInfo)
		{
			return domNameTable.GetName(prefix, localName, namespaceURI, schemaInfo);
		}

		internal XmlName AddAttrXmlName(string prefix, string localName, string namespaceURI, IXmlSchemaInfo schemaInfo)
		{
			XmlName xmlName = AddXmlName(prefix, localName, namespaceURI, schemaInfo);
			if (!IsLoading)
			{
				object prefix2 = xmlName.Prefix;
				object namespaceURI2 = xmlName.NamespaceURI;
				object localName2 = xmlName.LocalName;
				if ((prefix2 == strXmlns || (prefix2 == strEmpty && localName2 == strXmlns)) ^ (namespaceURI2 == strReservedXmlns))
				{
					throw new ArgumentException(Res.GetString("Xdom_Attr_Reserved_XmlNS", namespaceURI));
				}
			}
			return xmlName;
		}

		internal bool AddIdInfo(XmlName eleName, XmlName attrName)
		{
			if (htElementIDAttrDecl == null || htElementIDAttrDecl[eleName] == null)
			{
				if (htElementIDAttrDecl == null)
				{
					htElementIDAttrDecl = new Hashtable();
				}
				htElementIDAttrDecl.Add(eleName, attrName);
				return true;
			}
			return false;
		}

		private XmlName GetIDInfoByElement_(XmlName eleName)
		{
			XmlName xmlName = GetXmlName(eleName.Prefix, eleName.LocalName, string.Empty, null);
			if (xmlName != null)
			{
				return (XmlName)htElementIDAttrDecl[xmlName];
			}
			return null;
		}

		internal XmlName GetIDInfoByElement(XmlName eleName)
		{
			if (htElementIDAttrDecl == null)
			{
				return null;
			}
			return GetIDInfoByElement_(eleName);
		}

		private WeakReference GetElement(ArrayList elementList, XmlElement elem)
		{
			ArrayList arrayList = new ArrayList();
			foreach (WeakReference element in elementList)
			{
				if (!element.IsAlive)
				{
					arrayList.Add(element);
				}
				else if ((XmlElement)element.Target == elem)
				{
					return element;
				}
			}
			foreach (WeakReference item in arrayList)
			{
				elementList.Remove(item);
			}
			return null;
		}

		internal void AddElementWithId(string id, XmlElement elem)
		{
			if (htElementIdMap == null || !htElementIdMap.Contains(id))
			{
				if (htElementIdMap == null)
				{
					htElementIdMap = new Hashtable();
				}
				ArrayList arrayList = new ArrayList();
				arrayList.Add(new WeakReference(elem));
				htElementIdMap.Add(id, arrayList);
			}
			else
			{
				ArrayList arrayList2 = (ArrayList)htElementIdMap[id];
				if (GetElement(arrayList2, elem) == null)
				{
					arrayList2.Add(new WeakReference(elem));
				}
			}
		}

		internal void RemoveElementWithId(string id, XmlElement elem)
		{
			if (htElementIdMap == null || !htElementIdMap.Contains(id))
			{
				return;
			}
			ArrayList arrayList = (ArrayList)htElementIdMap[id];
			WeakReference element = GetElement(arrayList, elem);
			if (element != null)
			{
				arrayList.Remove(element);
				if (arrayList.Count == 0)
				{
					htElementIdMap.Remove(id);
				}
			}
		}

		public override XmlNode CloneNode(bool deep)
		{
			XmlDocument xmlDocument = Implementation.CreateDocument();
			xmlDocument.SetBaseURI(baseURI);
			if (deep)
			{
				xmlDocument.ImportChildren(this, xmlDocument, deep);
			}
			return xmlDocument;
		}

		internal XmlResolver GetResolver()
		{
			return resolver;
		}

		internal override bool IsValidChildType(XmlNodeType type)
		{
			switch (type)
			{
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Comment:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				return true;
			case XmlNodeType.DocumentType:
				if (DocumentType != null)
				{
					throw new InvalidOperationException(Res.GetString("Xdom_DualDocumentTypeNode"));
				}
				return true;
			case XmlNodeType.Element:
				if (DocumentElement != null)
				{
					throw new InvalidOperationException(Res.GetString("Xdom_DualDocumentElementNode"));
				}
				return true;
			case XmlNodeType.XmlDeclaration:
				if (Declaration != null)
				{
					throw new InvalidOperationException(Res.GetString("Xdom_DualDeclarationNode"));
				}
				return true;
			default:
				return false;
			}
		}

		private bool HasNodeTypeInPrevSiblings(XmlNodeType nt, XmlNode refNode)
		{
			if (refNode == null)
			{
				return false;
			}
			XmlNode xmlNode = null;
			if (refNode.ParentNode != null)
			{
				xmlNode = refNode.ParentNode.FirstChild;
			}
			while (xmlNode != null)
			{
				if (xmlNode.NodeType == nt)
				{
					return true;
				}
				if (xmlNode == refNode)
				{
					break;
				}
				xmlNode = xmlNode.NextSibling;
			}
			return false;
		}

		private bool HasNodeTypeInNextSiblings(XmlNodeType nt, XmlNode refNode)
		{
			for (XmlNode xmlNode = refNode; xmlNode != null; xmlNode = xmlNode.NextSibling)
			{
				if (xmlNode.NodeType == nt)
				{
					return true;
				}
			}
			return false;
		}

		internal override bool CanInsertBefore(XmlNode newChild, XmlNode refChild)
		{
			if (refChild == null)
			{
				refChild = FirstChild;
			}
			if (refChild == null)
			{
				return true;
			}
			switch (newChild.NodeType)
			{
			case XmlNodeType.XmlDeclaration:
				return refChild == FirstChild;
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Comment:
				return refChild.NodeType != XmlNodeType.XmlDeclaration;
			case XmlNodeType.DocumentType:
				if (refChild.NodeType != XmlNodeType.XmlDeclaration)
				{
					return !HasNodeTypeInPrevSiblings(XmlNodeType.Element, refChild.PreviousSibling);
				}
				break;
			case XmlNodeType.Element:
				if (refChild.NodeType != XmlNodeType.XmlDeclaration)
				{
					return !HasNodeTypeInNextSiblings(XmlNodeType.DocumentType, refChild);
				}
				break;
			}
			return false;
		}

		internal override bool CanInsertAfter(XmlNode newChild, XmlNode refChild)
		{
			if (refChild == null)
			{
				refChild = LastChild;
			}
			if (refChild == null)
			{
				return true;
			}
			switch (newChild.NodeType)
			{
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Comment:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				return true;
			case XmlNodeType.DocumentType:
				return !HasNodeTypeInPrevSiblings(XmlNodeType.Element, refChild);
			case XmlNodeType.Element:
				return !HasNodeTypeInNextSiblings(XmlNodeType.DocumentType, refChild.NextSibling);
			default:
				return false;
			}
		}

		public XmlAttribute CreateAttribute(string name)
		{
			string prefix = string.Empty;
			string localName = string.Empty;
			string namespaceURI = string.Empty;
			XmlNode.SplitName(name, out prefix, out localName);
			SetDefaultNamespace(prefix, localName, ref namespaceURI);
			return CreateAttribute(prefix, localName, namespaceURI);
		}

		internal void SetDefaultNamespace(string prefix, string localName, ref string namespaceURI)
		{
			if (prefix == strXmlns || (prefix.Length == 0 && localName == strXmlns))
			{
				namespaceURI = strReservedXmlns;
			}
			else if (prefix == strXml)
			{
				namespaceURI = strReservedXml;
			}
		}

		public virtual XmlCDataSection CreateCDataSection(string data)
		{
			fCDataNodesPresent = true;
			return new XmlCDataSection(data, this);
		}

		public virtual XmlComment CreateComment(string data)
		{
			return new XmlComment(data, this);
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		public virtual XmlDocumentType CreateDocumentType(string name, string publicId, string systemId, string internalSubset)
		{
			return new XmlDocumentType(name, publicId, systemId, internalSubset, this);
		}

		public virtual XmlDocumentFragment CreateDocumentFragment()
		{
			return new XmlDocumentFragment(this);
		}

		public XmlElement CreateElement(string name)
		{
			string prefix = string.Empty;
			string localName = string.Empty;
			XmlNode.SplitName(name, out prefix, out localName);
			return CreateElement(prefix, localName, string.Empty);
		}

		internal void AddDefaultAttributes(XmlElement elem)
		{
			SchemaInfo dtdSchemaInfo = DtdSchemaInfo;
			SchemaElementDecl schemaElementDecl = GetSchemaElementDecl(elem);
			if (schemaElementDecl == null || schemaElementDecl.AttDefs == null)
			{
				return;
			}
			IDictionaryEnumerator enumerator = schemaElementDecl.AttDefs.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SchemaAttDef schemaAttDef = (SchemaAttDef)enumerator.Value;
				if (schemaAttDef.Presence == SchemaDeclBase.Use.Default || schemaAttDef.Presence == SchemaDeclBase.Use.Fixed)
				{
					string empty = string.Empty;
					string name = schemaAttDef.Name.Name;
					string attrNamespaceURI = string.Empty;
					if (dtdSchemaInfo.SchemaType == SchemaType.DTD)
					{
						empty = schemaAttDef.Name.Namespace;
					}
					else
					{
						empty = schemaAttDef.Prefix;
						attrNamespaceURI = schemaAttDef.Name.Namespace;
					}
					XmlAttribute attributeNode = PrepareDefaultAttribute(schemaAttDef, empty, name, attrNamespaceURI);
					elem.SetAttributeNode(attributeNode);
				}
			}
		}

		private SchemaElementDecl GetSchemaElementDecl(XmlElement elem)
		{
			SchemaInfo dtdSchemaInfo = DtdSchemaInfo;
			if (dtdSchemaInfo != null)
			{
				XmlQualifiedName key = new XmlQualifiedName(elem.LocalName, (dtdSchemaInfo.SchemaType == SchemaType.DTD) ? elem.Prefix : elem.NamespaceURI);
				return (SchemaElementDecl)dtdSchemaInfo.ElementDecls[key];
			}
			return null;
		}

		private XmlAttribute PrepareDefaultAttribute(SchemaAttDef attdef, string attrPrefix, string attrLocalname, string attrNamespaceURI)
		{
			SetDefaultNamespace(attrPrefix, attrLocalname, ref attrNamespaceURI);
			XmlAttribute xmlAttribute = CreateDefaultAttribute(attrPrefix, attrLocalname, attrNamespaceURI);
			xmlAttribute.InnerXml = attdef.DefaultValueRaw;
			if (xmlAttribute is XmlUnspecifiedAttribute xmlUnspecifiedAttribute)
			{
				xmlUnspecifiedAttribute.SetSpecified(f: false);
			}
			return xmlAttribute;
		}

		public virtual XmlEntityReference CreateEntityReference(string name)
		{
			return new XmlEntityReference(name, this);
		}

		public virtual XmlProcessingInstruction CreateProcessingInstruction(string target, string data)
		{
			return new XmlProcessingInstruction(target, data, this);
		}

		public virtual XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone)
		{
			return new XmlDeclaration(version, encoding, standalone, this);
		}

		public virtual XmlText CreateTextNode(string text)
		{
			return new XmlText(text, this);
		}

		public virtual XmlSignificantWhitespace CreateSignificantWhitespace(string text)
		{
			return new XmlSignificantWhitespace(text, this);
		}

		public override XPathNavigator CreateNavigator()
		{
			return CreateNavigator(this);
		}

		protected internal virtual XPathNavigator CreateNavigator(XmlNode node)
		{
			switch (node.NodeType)
			{
			case XmlNodeType.EntityReference:
			case XmlNodeType.Entity:
			case XmlNodeType.DocumentType:
			case XmlNodeType.Notation:
			case XmlNodeType.XmlDeclaration:
				return null;
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.SignificantWhitespace:
			{
				XmlNode xmlNode = node.ParentNode;
				if (xmlNode != null)
				{
					do
					{
						switch (xmlNode.NodeType)
						{
						case XmlNodeType.Attribute:
							return null;
						case XmlNodeType.EntityReference:
							goto IL_006c;
						}
						break;
						IL_006c:
						xmlNode = xmlNode.ParentNode;
					}
					while (xmlNode != null);
				}
				node = NormalizeText(node);
				break;
			}
			case XmlNodeType.Whitespace:
			{
				XmlNode xmlNode = node.ParentNode;
				if (xmlNode != null)
				{
					do
					{
						switch (xmlNode.NodeType)
						{
						case XmlNodeType.Attribute:
						case XmlNodeType.Document:
							return null;
						case XmlNodeType.EntityReference:
							goto IL_00a1;
						}
						break;
						IL_00a1:
						xmlNode = xmlNode.ParentNode;
					}
					while (xmlNode != null);
				}
				node = NormalizeText(node);
				break;
			}
			}
			return new DocumentXPathNavigator(this, node);
		}

		internal static bool IsTextNode(XmlNodeType nt)
		{
			switch (nt)
			{
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				return true;
			default:
				return false;
			}
		}

		private XmlNode NormalizeText(XmlNode n)
		{
			XmlNode xmlNode = null;
			while (IsTextNode(n.NodeType))
			{
				xmlNode = n;
				n = n.PreviousSibling;
				if (n == null)
				{
					XmlNode xmlNode2 = xmlNode;
					while (xmlNode2.ParentNode != null && xmlNode2.ParentNode.NodeType == XmlNodeType.EntityReference)
					{
						if (xmlNode2.ParentNode.PreviousSibling != null)
						{
							n = xmlNode2.ParentNode.PreviousSibling;
							break;
						}
						xmlNode2 = xmlNode2.ParentNode;
						if (xmlNode2 == null)
						{
							break;
						}
					}
				}
				if (n == null)
				{
					break;
				}
				while (n.NodeType == XmlNodeType.EntityReference)
				{
					n = n.LastChild;
				}
			}
			return xmlNode;
		}

		public virtual XmlWhitespace CreateWhitespace(string text)
		{
			return new XmlWhitespace(text, this);
		}

		public virtual XmlNodeList GetElementsByTagName(string name)
		{
			return new XmlElementList(this, name);
		}

		public XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI)
		{
			string prefix = string.Empty;
			string localName = string.Empty;
			XmlNode.SplitName(qualifiedName, out prefix, out localName);
			return CreateAttribute(prefix, localName, namespaceURI);
		}

		public XmlElement CreateElement(string qualifiedName, string namespaceURI)
		{
			string prefix = string.Empty;
			string localName = string.Empty;
			XmlNode.SplitName(qualifiedName, out prefix, out localName);
			return CreateElement(prefix, localName, namespaceURI);
		}

		public virtual XmlNodeList GetElementsByTagName(string localName, string namespaceURI)
		{
			return new XmlElementList(this, localName, namespaceURI);
		}

		public virtual XmlElement GetElementById(string elementId)
		{
			if (htElementIdMap != null)
			{
				ArrayList arrayList = (ArrayList)htElementIdMap[elementId];
				if (arrayList != null)
				{
					foreach (WeakReference item in arrayList)
					{
						XmlElement xmlElement = (XmlElement)item.Target;
						if (xmlElement != null && xmlElement.IsConnected())
						{
							return xmlElement;
						}
					}
				}
			}
			return null;
		}

		public virtual XmlNode ImportNode(XmlNode node, bool deep)
		{
			return ImportNodeInternal(node, deep);
		}

		private XmlNode ImportNodeInternal(XmlNode node, bool deep)
		{
			XmlNode xmlNode = null;
			if (node == null)
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Import_NullNode"));
			}
			switch (node.NodeType)
			{
			case XmlNodeType.Element:
				xmlNode = CreateElement(node.Prefix, node.LocalName, node.NamespaceURI);
				ImportAttributes(node, xmlNode);
				if (deep)
				{
					ImportChildren(node, xmlNode, deep);
				}
				break;
			case XmlNodeType.Attribute:
				xmlNode = CreateAttribute(node.Prefix, node.LocalName, node.NamespaceURI);
				ImportChildren(node, xmlNode, deep: true);
				break;
			case XmlNodeType.Text:
				xmlNode = CreateTextNode(node.Value);
				break;
			case XmlNodeType.Comment:
				xmlNode = CreateComment(node.Value);
				break;
			case XmlNodeType.ProcessingInstruction:
				xmlNode = CreateProcessingInstruction(node.Name, node.Value);
				break;
			case XmlNodeType.XmlDeclaration:
			{
				XmlDeclaration xmlDeclaration = (XmlDeclaration)node;
				xmlNode = CreateXmlDeclaration(xmlDeclaration.Version, xmlDeclaration.Encoding, xmlDeclaration.Standalone);
				break;
			}
			case XmlNodeType.CDATA:
				xmlNode = CreateCDataSection(node.Value);
				break;
			case XmlNodeType.DocumentType:
			{
				XmlDocumentType xmlDocumentType = (XmlDocumentType)node;
				xmlNode = CreateDocumentType(xmlDocumentType.Name, xmlDocumentType.PublicId, xmlDocumentType.SystemId, xmlDocumentType.InternalSubset);
				break;
			}
			case XmlNodeType.DocumentFragment:
				xmlNode = CreateDocumentFragment();
				if (deep)
				{
					ImportChildren(node, xmlNode, deep);
				}
				break;
			case XmlNodeType.EntityReference:
				xmlNode = CreateEntityReference(node.Name);
				break;
			case XmlNodeType.Whitespace:
				xmlNode = CreateWhitespace(node.Value);
				break;
			case XmlNodeType.SignificantWhitespace:
				xmlNode = CreateSignificantWhitespace(node.Value);
				break;
			default:
				throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, Res.GetString("Xdom_Import"), node.NodeType.ToString()));
			}
			return xmlNode;
		}

		private void ImportAttributes(XmlNode fromElem, XmlNode toElem)
		{
			int count = fromElem.Attributes.Count;
			for (int i = 0; i < count; i++)
			{
				if (fromElem.Attributes[i].Specified)
				{
					toElem.Attributes.SetNamedItem(ImportNodeInternal(fromElem.Attributes[i], deep: true));
				}
			}
		}

		private void ImportChildren(XmlNode fromNode, XmlNode toNode, bool deep)
		{
			for (XmlNode xmlNode = fromNode.FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
			{
				toNode.AppendChild(ImportNodeInternal(xmlNode, deep));
			}
		}

		public virtual XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI)
		{
			return new XmlAttribute(AddAttrXmlName(prefix, localName, namespaceURI, null), this);
		}

		protected internal virtual XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI)
		{
			return new XmlUnspecifiedAttribute(prefix, localName, namespaceURI, this);
		}

		public virtual XmlElement CreateElement(string prefix, string localName, string namespaceURI)
		{
			XmlElement xmlElement = new XmlElement(AddXmlName(prefix, localName, namespaceURI, null), empty: true, this);
			if (!IsLoading)
			{
				AddDefaultAttributes(xmlElement);
			}
			return xmlElement;
		}

		public virtual XmlNode CreateNode(XmlNodeType type, string prefix, string name, string namespaceURI)
		{
			switch (type)
			{
			case XmlNodeType.Element:
				if (prefix != null)
				{
					return CreateElement(prefix, name, namespaceURI);
				}
				return CreateElement(name, namespaceURI);
			case XmlNodeType.Attribute:
				if (prefix != null)
				{
					return CreateAttribute(prefix, name, namespaceURI);
				}
				return CreateAttribute(name, namespaceURI);
			case XmlNodeType.Text:
				return CreateTextNode(string.Empty);
			case XmlNodeType.CDATA:
				return CreateCDataSection(string.Empty);
			case XmlNodeType.EntityReference:
				return CreateEntityReference(name);
			case XmlNodeType.ProcessingInstruction:
				return CreateProcessingInstruction(name, string.Empty);
			case XmlNodeType.XmlDeclaration:
				return CreateXmlDeclaration("1.0", null, null);
			case XmlNodeType.Comment:
				return CreateComment(string.Empty);
			case XmlNodeType.DocumentFragment:
				return CreateDocumentFragment();
			case XmlNodeType.DocumentType:
				return CreateDocumentType(name, string.Empty, string.Empty, string.Empty);
			case XmlNodeType.Document:
				return new XmlDocument();
			case XmlNodeType.SignificantWhitespace:
				return CreateSignificantWhitespace(string.Empty);
			case XmlNodeType.Whitespace:
				return CreateWhitespace(string.Empty);
			default:
				throw new ArgumentException(Res.GetString("Arg_CannotCreateNode", type));
			}
		}

		public virtual XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI)
		{
			return CreateNode(ConvertToNodeType(nodeTypeString), name, namespaceURI);
		}

		public virtual XmlNode CreateNode(XmlNodeType type, string name, string namespaceURI)
		{
			return CreateNode(type, null, name, namespaceURI);
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		public virtual XmlNode ReadNode(XmlReader reader)
		{
			XmlNode xmlNode = null;
			try
			{
				IsLoading = true;
				XmlLoader xmlLoader = new XmlLoader();
				return xmlLoader.ReadCurrentNode(this, reader);
			}
			finally
			{
				IsLoading = false;
			}
		}

		internal XmlNodeType ConvertToNodeType(string nodeTypeString)
		{
			return nodeTypeString switch
			{
				"element" => XmlNodeType.Element, 
				"attribute" => XmlNodeType.Attribute, 
				"text" => XmlNodeType.Text, 
				"cdatasection" => XmlNodeType.CDATA, 
				"entityreference" => XmlNodeType.EntityReference, 
				"entity" => XmlNodeType.Entity, 
				"processinginstruction" => XmlNodeType.ProcessingInstruction, 
				"comment" => XmlNodeType.Comment, 
				"document" => XmlNodeType.Document, 
				"documenttype" => XmlNodeType.DocumentType, 
				"documentfragment" => XmlNodeType.DocumentFragment, 
				"notation" => XmlNodeType.Notation, 
				"significantwhitespace" => XmlNodeType.SignificantWhitespace, 
				"whitespace" => XmlNodeType.Whitespace, 
				_ => throw new ArgumentException(Res.GetString("Xdom_Invalid_NT_String", nodeTypeString)), 
			};
		}

		private XmlTextReader SetupReader(XmlTextReader tr)
		{
			tr.XmlValidatingReaderCompatibilityMode = true;
			tr.EntityHandling = EntityHandling.ExpandCharEntities;
			if (HasSetResolver)
			{
				tr.XmlResolver = GetResolver();
			}
			return tr;
		}

		public virtual void Load(string filename)
		{
			XmlTextReader xmlTextReader = SetupReader(new XmlTextReader(filename, NameTable));
			try
			{
				Load(xmlTextReader);
			}
			finally
			{
				xmlTextReader.Close();
			}
		}

		public virtual void Load(Stream inStream)
		{
			XmlTextReader xmlTextReader = SetupReader(new XmlTextReader(inStream, NameTable));
			try
			{
				Load(xmlTextReader);
			}
			finally
			{
				xmlTextReader.Impl.Close(closeInput: false);
			}
		}

		public virtual void Load(TextReader txtReader)
		{
			XmlTextReader xmlTextReader = SetupReader(new XmlTextReader(txtReader, NameTable));
			try
			{
				Load(xmlTextReader);
			}
			finally
			{
				xmlTextReader.Impl.Close(closeInput: false);
			}
		}

		public virtual void Load(XmlReader reader)
		{
			try
			{
				IsLoading = true;
				actualLoadingStatus = true;
				RemoveAll();
				fEntRefNodesPresent = false;
				fCDataNodesPresent = false;
				reportValidity = true;
				XmlLoader xmlLoader = new XmlLoader();
				xmlLoader.Load(this, reader, preserveWhitespace);
			}
			finally
			{
				IsLoading = false;
				actualLoadingStatus = false;
				reportValidity = true;
			}
		}

		public virtual void LoadXml(string xml)
		{
			XmlTextReader xmlTextReader = SetupReader(new XmlTextReader(new StringReader(xml), NameTable));
			try
			{
				Load(xmlTextReader);
			}
			finally
			{
				xmlTextReader.Close();
			}
		}

		public virtual void Save(string filename)
		{
			if (DocumentElement == null)
			{
				throw new XmlException("Xml_InvalidXmlDocument", Res.GetString("Xdom_NoRootEle"));
			}
			XmlDOMTextWriter xmlDOMTextWriter = new XmlDOMTextWriter(filename, TextEncoding);
			try
			{
				if (!preserveWhitespace)
				{
					xmlDOMTextWriter.Formatting = Formatting.Indented;
				}
				WriteTo(xmlDOMTextWriter);
			}
			finally
			{
				xmlDOMTextWriter.Flush();
				xmlDOMTextWriter.Close();
			}
		}

		public virtual void Save(Stream outStream)
		{
			XmlDOMTextWriter xmlDOMTextWriter = new XmlDOMTextWriter(outStream, TextEncoding);
			if (!preserveWhitespace)
			{
				xmlDOMTextWriter.Formatting = Formatting.Indented;
			}
			WriteTo(xmlDOMTextWriter);
			xmlDOMTextWriter.Flush();
		}

		public virtual void Save(TextWriter writer)
		{
			XmlDOMTextWriter xmlDOMTextWriter = new XmlDOMTextWriter(writer);
			if (!preserveWhitespace)
			{
				xmlDOMTextWriter.Formatting = Formatting.Indented;
			}
			Save(xmlDOMTextWriter);
		}

		public virtual void Save(XmlWriter w)
		{
			XmlNode xmlNode = FirstChild;
			if (xmlNode == null)
			{
				return;
			}
			if (w.WriteState == WriteState.Start)
			{
				if (xmlNode is XmlDeclaration)
				{
					if (Standalone.Length == 0)
					{
						w.WriteStartDocument();
					}
					else if (Standalone == "yes")
					{
						w.WriteStartDocument(standalone: true);
					}
					else if (Standalone == "no")
					{
						w.WriteStartDocument(standalone: false);
					}
					xmlNode = xmlNode.NextSibling;
				}
				else
				{
					w.WriteStartDocument();
				}
			}
			while (xmlNode != null)
			{
				xmlNode.WriteTo(w);
				xmlNode = xmlNode.NextSibling;
			}
			w.Flush();
		}

		public override void WriteTo(XmlWriter w)
		{
			WriteContentTo(w);
		}

		public override void WriteContentTo(XmlWriter xw)
		{
			IEnumerator enumerator = GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					XmlNode xmlNode = (XmlNode)enumerator.Current;
					xmlNode.WriteTo(xw);
				}
			}
			finally
			{
				IDisposable disposable = enumerator as IDisposable;
				if (disposable != null)
				{
					disposable.Dispose();
				}
			}
		}

		public void Validate(ValidationEventHandler validationEventHandler)
		{
			Validate(validationEventHandler, this);
		}

		public void Validate(ValidationEventHandler validationEventHandler, XmlNode nodeToValidate)
		{
			if (schemas == null || schemas.Count == 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlDocument_NoSchemaInfo"));
			}
			XmlDocument document = nodeToValidate.Document;
			if (document != this)
			{
				throw new ArgumentException(Res.GetString("XmlDocument_NodeNotFromDocument", "nodeToValidate"));
			}
			if (nodeToValidate == this)
			{
				reportValidity = false;
			}
			DocumentSchemaValidator documentSchemaValidator = new DocumentSchemaValidator(this, schemas, validationEventHandler);
			documentSchemaValidator.Validate(nodeToValidate);
			if (nodeToValidate == this)
			{
				reportValidity = true;
			}
		}

		internal override XmlNodeChangedEventArgs GetEventArgs(XmlNode node, XmlNode oldParent, XmlNode newParent, string oldValue, string newValue, XmlNodeChangedAction action)
		{
			reportValidity = false;
			switch (action)
			{
			case XmlNodeChangedAction.Insert:
				if (onNodeInsertingDelegate == null && onNodeInsertedDelegate == null)
				{
					return null;
				}
				break;
			case XmlNodeChangedAction.Remove:
				if (onNodeRemovingDelegate == null && onNodeRemovedDelegate == null)
				{
					return null;
				}
				break;
			case XmlNodeChangedAction.Change:
				if (onNodeChangingDelegate == null && onNodeChangedDelegate == null)
				{
					return null;
				}
				break;
			}
			return new XmlNodeChangedEventArgs(node, oldParent, newParent, oldValue, newValue, action);
		}

		internal XmlNodeChangedEventArgs GetInsertEventArgsForLoad(XmlNode node, XmlNode newParent)
		{
			if (onNodeInsertingDelegate == null && onNodeInsertedDelegate == null)
			{
				return null;
			}
			string value = node.Value;
			return new XmlNodeChangedEventArgs(node, null, newParent, value, value, XmlNodeChangedAction.Insert);
		}

		internal override void BeforeEvent(XmlNodeChangedEventArgs args)
		{
			if (args == null)
			{
				return;
			}
			switch (args.Action)
			{
			case XmlNodeChangedAction.Insert:
				if (onNodeInsertingDelegate != null)
				{
					onNodeInsertingDelegate(this, args);
				}
				break;
			case XmlNodeChangedAction.Remove:
				if (onNodeRemovingDelegate != null)
				{
					onNodeRemovingDelegate(this, args);
				}
				break;
			case XmlNodeChangedAction.Change:
				if (onNodeChangingDelegate != null)
				{
					onNodeChangingDelegate(this, args);
				}
				break;
			}
		}

		internal override void AfterEvent(XmlNodeChangedEventArgs args)
		{
			if (args == null)
			{
				return;
			}
			switch (args.Action)
			{
			case XmlNodeChangedAction.Insert:
				if (onNodeInsertedDelegate != null)
				{
					onNodeInsertedDelegate(this, args);
				}
				break;
			case XmlNodeChangedAction.Remove:
				if (onNodeRemovedDelegate != null)
				{
					onNodeRemovedDelegate(this, args);
				}
				break;
			case XmlNodeChangedAction.Change:
				if (onNodeChangedDelegate != null)
				{
					onNodeChangedDelegate(this, args);
				}
				break;
			}
		}

		internal XmlAttribute GetDefaultAttribute(XmlElement elem, string attrPrefix, string attrLocalname, string attrNamespaceURI)
		{
			SchemaInfo dtdSchemaInfo = DtdSchemaInfo;
			SchemaElementDecl schemaElementDecl = GetSchemaElementDecl(elem);
			if (schemaElementDecl != null && schemaElementDecl.AttDefs != null)
			{
				IDictionaryEnumerator enumerator = schemaElementDecl.AttDefs.GetEnumerator();
				while (enumerator.MoveNext())
				{
					SchemaAttDef schemaAttDef = (SchemaAttDef)enumerator.Value;
					if ((schemaAttDef.Presence == SchemaDeclBase.Use.Default || schemaAttDef.Presence == SchemaDeclBase.Use.Fixed) && schemaAttDef.Name.Name == attrLocalname && ((dtdSchemaInfo.SchemaType == SchemaType.DTD && schemaAttDef.Name.Namespace == attrPrefix) || (dtdSchemaInfo.SchemaType != SchemaType.DTD && schemaAttDef.Name.Namespace == attrNamespaceURI)))
					{
						return PrepareDefaultAttribute(schemaAttDef, attrPrefix, attrLocalname, attrNamespaceURI);
					}
				}
			}
			return null;
		}

		internal XmlEntity GetEntityNode(string name)
		{
			if (DocumentType != null)
			{
				XmlNamedNodeMap xmlNamedNodeMap = DocumentType.Entities;
				if (xmlNamedNodeMap != null)
				{
					return (XmlEntity)xmlNamedNodeMap.GetNamedItem(name);
				}
			}
			return null;
		}

		internal void SetBaseURI(string inBaseURI)
		{
			baseURI = inBaseURI;
		}

		internal override XmlNode AppendChildForLoad(XmlNode newChild, XmlDocument doc)
		{
			if (!IsValidChildType(newChild.NodeType))
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_TypeConflict"));
			}
			if (!CanInsertAfter(newChild, LastChild))
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Node_Insert_Location"));
			}
			XmlNodeChangedEventArgs insertEventArgsForLoad = GetInsertEventArgsForLoad(newChild, this);
			if (insertEventArgsForLoad != null)
			{
				BeforeEvent(insertEventArgsForLoad);
			}
			XmlLinkedNode xmlLinkedNode = (XmlLinkedNode)newChild;
			if (lastChild == null)
			{
				xmlLinkedNode.next = xmlLinkedNode;
			}
			else
			{
				xmlLinkedNode.next = lastChild.next;
				lastChild.next = xmlLinkedNode;
			}
			lastChild = xmlLinkedNode;
			xmlLinkedNode.SetParentForLoad(this);
			if (insertEventArgsForLoad != null)
			{
				AfterEvent(insertEventArgsForLoad);
			}
			return xmlLinkedNode;
		}
	}
	public class XmlDocumentFragment : XmlNode
	{
		private XmlLinkedNode lastChild;

		public override string Name => OwnerDocument.strDocumentFragmentName;

		public override string LocalName => OwnerDocument.strDocumentFragmentName;

		public override XmlNodeType NodeType => XmlNodeType.DocumentFragment;

		public override XmlNode ParentNode => null;

		public override XmlDocument OwnerDocument => (XmlDocument)parentNode;

		public override string InnerXml
		{
			get
			{
				return base.InnerXml;
			}
			set
			{
				RemoveAll();
				XmlLoader xmlLoader = new XmlLoader();
				xmlLoader.ParsePartialContent(this, value, XmlNodeType.Element);
			}
		}

		internal override bool IsContainer => true;

		internal override XmlLinkedNode LastNode
		{
			get
			{
				return lastChild;
			}
			set
			{
				lastChild = value;
			}
		}

		internal override XPathNodeType XPNodeType => XPathNodeType.Root;

		protected internal XmlDocumentFragment(XmlDocument ownerDocument)
		{
			if (ownerDocument == null)
			{
				throw new ArgumentException(Res.GetString("Xdom_Node_Null_Doc"));
			}
			parentNode = ownerDocument;
		}

		public override XmlNode CloneNode(bool deep)
		{
			XmlDocument ownerDocument = OwnerDocument;
			XmlDocumentFragment xmlDocumentFragment = ownerDocument.CreateDocumentFragment();
			if (deep)
			{
				xmlDocumentFragment.CopyChildren(ownerDocument, this, deep);
			}
			return xmlDocumentFragment;
		}

		internal override bool IsValidChildType(XmlNodeType type)
		{
			switch (type)
			{
			case XmlNodeType.Element:
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.EntityReference:
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Comment:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				return true;
			case XmlNodeType.XmlDeclaration:
			{
				XmlNode firstChild = FirstChild;
				if (firstChild == null || firstChild.NodeType != XmlNodeType.XmlDeclaration)
				{
					return true;
				}
				return false;
			}
			default:
				return false;
			}
		}

		internal override bool CanInsertAfter(XmlNode newChild, XmlNode refChild)
		{
			if (newChild.NodeType == XmlNodeType.XmlDeclaration)
			{
				if (refChild == null)
				{
					return LastNode == null;
				}
				return false;
			}
			return true;
		}

		internal override bool CanInsertBefore(XmlNode newChild, XmlNode refChild)
		{
			if (newChild.NodeType == XmlNodeType.XmlDeclaration)
			{
				if (refChild != null)
				{
					return refChild == FirstChild;
				}
				return true;
			}
			return true;
		}

		public override void WriteTo(XmlWriter w)
		{
			WriteContentTo(w);
		}

		public override void WriteContentTo(XmlWriter w)
		{
			IEnumerator enumerator = GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					XmlNode xmlNode = (XmlNode)enumerator.Current;
					xmlNode.WriteTo(w);
				}
			}
			finally
			{
				IDisposable disposable = enumerator as IDisposable;
				if (disposable != null)
				{
					disposable.Dispose();
				}
			}
		}
	}
	public class XmlDocumentType : XmlLinkedNode
	{
		private string name;

		private string publicId;

		private string systemId;

		private string internalSubset;

		private bool namespaces;

		private XmlNamedNodeMap entities;

		private XmlNamedNodeMap notations;

		private SchemaInfo schemaInfo;

		public override string Name => name;

		public override string LocalName => name;

		public override XmlNodeType NodeType => XmlNodeType.DocumentType;

		public override bool IsReadOnly => true;

		public XmlNamedNodeMap Entities
		{
			get
			{
				if (entities == null)
				{
					entities = new XmlNamedNodeMap(this);
				}
				return entities;
			}
		}

		public XmlNamedNodeMap Notations
		{
			get
			{
				if (notations == null)
				{
					notations = new XmlNamedNodeMap(this);
				}
				return notations;
			}
		}

		public string PublicId => publicId;

		public string SystemId => systemId;

		public string InternalSubset => internalSubset;

		internal bool ParseWithNamespaces
		{
			get
			{
				return namespaces;
			}
			set
			{
				namespaces = value;
			}
		}

		internal SchemaInfo DtdSchemaInfo
		{
			get
			{
				return schemaInfo;
			}
			set
			{
				schemaInfo = value;
			}
		}

		protected internal XmlDocumentType(string name, string publicId, string systemId, string internalSubset, XmlDocument doc)
			: base(doc)
		{
			this.name = name;
			this.publicId = publicId;
			this.systemId = systemId;
			namespaces = true;
			this.internalSubset = internalSubset;
			if (!doc.IsLoading)
			{
				doc.IsLoading = true;
				XmlLoader xmlLoader = new XmlLoader();
				xmlLoader.ParseDocumentType(this);
				doc.IsLoading = false;
			}
		}

		public override XmlNode CloneNode(bool deep)
		{
			return OwnerDocument.CreateDocumentType(name, publicId, systemId, internalSubset);
		}

		public override void WriteTo(XmlWriter w)
		{
			w.WriteDocType(name, publicId, systemId, internalSubset);
		}

		public override void WriteContentTo(XmlWriter w)
		{
		}
	}
	internal sealed class DocumentSchemaValidator : IXmlNamespaceResolver
	{
		private XmlSchemaValidator validator;

		private XmlSchemaSet schemas;

		private XmlNamespaceManager nsManager;

		private XmlNameTable nameTable;

		private ArrayList defaultAttributes;

		private XmlValueGetter nodeValueGetter;

		private XmlSchemaInfo attributeSchemaInfo;

		private XmlSchemaInfo schemaInfo;

		private ValidationEventHandler eventHandler;

		private ValidationEventHandler internalEventHandler;

		private XmlNode startNode;

		private XmlNode currentNode;

		private XmlDocument document;

		private XmlNode[] nodeSequenceToValidate;

		private bool isPartialTreeValid;

		private bool psviAugmentation;

		private bool isValid;

		private string NsXmlNs;

		private string NsXsi;

		private string XsiType;

		private string XsiNil;

		public bool PsviAugmentation
		{
			get
			{
				return psviAugmentation;
			}
			set
			{
				psviAugmentation = value;
			}
		}

		private IXmlNamespaceResolver NamespaceResolver
		{
			get
			{
				if (startNode == document)
				{
					return nsManager;
				}
				return this;
			}
		}

		public DocumentSchemaValidator(XmlDocument ownerDocument, XmlSchemaSet schemas, ValidationEventHandler eventHandler)
		{
			this.schemas = schemas;
			this.eventHandler = eventHandler;
			document = ownerDocument;
			internalEventHandler = InternalValidationCallBack;
			nameTable = document.NameTable;
			nsManager = new XmlNamespaceManager(nameTable);
			nodeValueGetter = GetNodeValue;
			psviAugmentation = true;
			NsXmlNs = nameTable.Add("http://www.w3.org/2000/xmlns/");
			NsXsi = nameTable.Add("http://www.w3.org/2001/XMLSchema-instance");
			XsiType = nameTable.Add("type");
			XsiNil = nameTable.Add("nil");
		}

		public bool Validate(XmlNode nodeToValidate)
		{
			XmlSchemaObject xmlSchemaObject = null;
			XmlSchemaValidationFlags xmlSchemaValidationFlags = XmlSchemaValidationFlags.AllowXmlAttributes;
			startNode = nodeToValidate;
			switch (nodeToValidate.NodeType)
			{
			case XmlNodeType.Document:
				xmlSchemaValidationFlags |= XmlSchemaValidationFlags.ProcessIdentityConstraints;
				break;
			case XmlNodeType.Element:
			{
				IXmlSchemaInfo xmlSchemaInfo = nodeToValidate.SchemaInfo;
				XmlSchemaElement schemaElement = xmlSchemaInfo.SchemaElement;
				if (schemaElement != null)
				{
					xmlSchemaObject = (schemaElement.RefName.IsEmpty ? schemaElement : schemas.GlobalElements[schemaElement.QualifiedName]);
					break;
				}
				xmlSchemaObject = xmlSchemaInfo.SchemaType;
				if (xmlSchemaObject != null)
				{
					break;
				}
				if (nodeToValidate.ParentNode.NodeType == XmlNodeType.Document)
				{
					nodeToValidate = nodeToValidate.ParentNode;
					break;
				}
				xmlSchemaObject = FindSchemaInfo(nodeToValidate as XmlElement);
				if (xmlSchemaObject != null)
				{
					break;
				}
				throw new XmlSchemaValidationException("XmlDocument_NoNodeSchemaInfo", null, nodeToValidate);
			}
			case XmlNodeType.Attribute:
				if (nodeToValidate.XPNodeType != XPathNodeType.Namespace)
				{
					xmlSchemaObject = nodeToValidate.SchemaInfo.SchemaAttribute;
					if (xmlSchemaObject == null)
					{
						xmlSchemaObject = FindSchemaInfo(nodeToValidate as XmlAttribute);
						if (xmlSchemaObject == null)
						{
							throw new XmlSchemaValidationException("XmlDocument_NoNodeSchemaInfo", null, nodeToValidate);
						}
					}
					break;
				}
				goto default;
			default:
				throw new InvalidOperationException(Res.GetString("XmlDocument_ValidateInvalidNodeType", null));
			case XmlNodeType.DocumentFragment:
				break;
			}
			isValid = true;
			CreateValidator(xmlSchemaObject, xmlSchemaValidationFlags);
			if (psviAugmentation)
			{
				if (schemaInfo == null)
				{
					schemaInfo = new XmlSchemaInfo();
				}
				attributeSchemaInfo = new XmlSchemaInfo();
			}
			ValidateNode(nodeToValidate);
			validator.EndValidation();
			return isValid;
		}

		public IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope)
		{
			IDictionary<string, string> namespacesInScope = nsManager.GetNamespacesInScope(scope);
			if (scope != XmlNamespaceScope.Local)
			{
				XmlNode xmlNode = startNode;
				while (xmlNode != null)
				{
					switch (xmlNode.NodeType)
					{
					case XmlNodeType.Element:
					{
						XmlElement xmlElement = (XmlElement)xmlNode;
						if (xmlElement.HasAttributes)
						{
							XmlAttributeCollection attributes = xmlElement.Attributes;
							for (int i = 0; i < attributes.Count; i++)
							{
								XmlAttribute xmlAttribute = attributes[i];
								if (!Ref.Equal(xmlAttribute.NamespaceURI, document.strReservedXmlns))
								{
									continue;
								}
								if (xmlAttribute.Prefix.Length == 0)
								{
									if (!namespacesInScope.ContainsKey(string.Empty))
									{
										namespacesInScope.Add(string.Empty, xmlAttribute.Value);
									}
								}
								else if (!namespacesInScope.ContainsKey(xmlAttribute.LocalName))
								{
									namespacesInScope.Add(xmlAttribute.LocalName, xmlAttribute.Value);
								}
							}
						}
						xmlNode = xmlNode.ParentNode;
						break;
					}
					case XmlNodeType.Attribute:
						xmlNode = ((XmlAttribute)xmlNode).OwnerElement;
						break;
					default:
						xmlNode = xmlNode.ParentNode;
						break;
					}
				}
			}
			return namespacesInScope;
		}

		public string LookupNamespace(string prefix)
		{
			string text = nsManager.LookupNamespace(prefix);
			if (text == null)
			{
				text = startNode.GetNamespaceOfPrefixStrict(prefix);
			}
			return text;
		}

		public string LookupPrefix(string namespaceName)
		{
			string text = nsManager.LookupPrefix(namespaceName);
			if (text == null)
			{
				text = startNode.GetPrefixOfNamespaceStrict(namespaceName);
			}
			return text;
		}

		private void CreateValidator(XmlSchemaObject partialValidationType, XmlSchemaValidationFlags validationFlags)
		{
			validator = new XmlSchemaValidator(nameTable, schemas, NamespaceResolver, validationFlags);
			validator.SourceUri = XmlConvert.ToUri(document.BaseURI);
			validator.XmlResolver = null;
			validator.ValidationEventHandler += internalEventHandler;
			validator.ValidationEventSender = this;
			if (partialValidationType != null)
			{
				validator.Initialize(partialValidationType);
			}
			else
			{
				validator.Initialize();
			}
		}

		private void ValidateNode(XmlNode node)
		{
			currentNode = node;
			switch (currentNode.NodeType)
			{
			case XmlNodeType.Document:
			{
				XmlElement documentElement = ((XmlDocument)node).DocumentElement;
				if (documentElement == null)
				{
					throw new InvalidOperationException(Res.GetString("Xml_InvalidXmlDocument", Res.GetString("Xdom_NoRootEle")));
				}
				ValidateNode(documentElement);
				break;
			}
			case XmlNodeType.EntityReference:
			case XmlNodeType.DocumentFragment:
			{
				for (XmlNode xmlNode = node.FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
				{
					ValidateNode(xmlNode);
				}
				break;
			}
			case XmlNodeType.Element:
				ValidateElement();
				break;
			case XmlNodeType.Attribute:
			{
				XmlAttribute xmlAttribute = currentNode as XmlAttribute;
				validator.ValidateAttribute(xmlAttribute.LocalName, xmlAttribute.NamespaceURI, nodeValueGetter, attributeSchemaInfo);
				if (psviAugmentation)
				{
					xmlAttribute.XmlName = document.AddAttrXmlName(xmlAttribute.Prefix, xmlAttribute.LocalName, xmlAttribute.NamespaceURI, attributeSchemaInfo);
				}
				break;
			}
			case XmlNodeType.Text:
				validator.ValidateText(nodeValueGetter);
				break;
			case XmlNodeType.CDATA:
				validator.ValidateText(nodeValueGetter);
				break;
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				validator.ValidateWhitespace(nodeValueGetter);
				break;
			default:
				throw new InvalidOperationException(Res.GetString("Xml_UnexpectedNodeType", currentNode.NodeType.ToString()));
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Comment:
				break;
			}
		}

		private void ValidateElement()
		{
			nsManager.PushScope();
			XmlElement xmlElement = currentNode as XmlElement;
			XmlAttributeCollection attributes = xmlElement.Attributes;
			XmlAttribute xmlAttribute = null;
			string xsiNil = null;
			string xsiType = null;
			for (int i = 0; i < attributes.Count; i++)
			{
				xmlAttribute = attributes[i];
				string namespaceURI = xmlAttribute.NamespaceURI;
				string localName = xmlAttribute.LocalName;
				if (Ref.Equal(namespaceURI, NsXsi))
				{
					if (Ref.Equal(localName, XsiType))
					{
						xsiType = xmlAttribute.Value;
					}
					else if (Ref.Equal(localName, XsiNil))
					{
						xsiNil = xmlAttribute.Value;
					}
				}
				else if (Ref.Equal(namespaceURI, NsXmlNs))
				{
					nsManager.AddNamespace((xmlAttribute.Prefix.Length == 0) ? string.Empty : xmlAttribute.LocalName, xmlAttribute.Value);
				}
			}
			validator.ValidateElement(xmlElement.LocalName, xmlElement.NamespaceURI, schemaInfo, xsiType, xsiNil, null, null);
			ValidateAttributes(xmlElement);
			validator.ValidateEndOfAttributes(schemaInfo);
			for (XmlNode xmlNode = xmlElement.FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
			{
				ValidateNode(xmlNode);
			}
			currentNode = xmlElement;
			validator.ValidateEndElement(schemaInfo);
			if (psviAugmentation)
			{
				xmlElement.XmlName = document.AddXmlName(xmlElement.Prefix, xmlElement.LocalName, xmlElement.NamespaceURI, schemaInfo);
				if (schemaInfo.IsDefault)
				{
					XmlText newChild = document.CreateTextNode(schemaInfo.SchemaElement.ElementDecl.DefaultValueRaw);
					xmlElement.AppendChild(newChild);
				}
			}
			nsManager.PopScope();
		}

		private void ValidateAttributes(XmlElement elementNode)
		{
			XmlAttributeCollection attributes = elementNode.Attributes;
			XmlAttribute xmlAttribute = null;
			for (int i = 0; i < attributes.Count; i++)
			{
				xmlAttribute = (XmlAttribute)(currentNode = attributes[i]);
				if (!Ref.Equal(xmlAttribute.NamespaceURI, NsXmlNs))
				{
					validator.ValidateAttribute(xmlAttribute.LocalName, xmlAttribute.NamespaceURI, nodeValueGetter, attributeSchemaInfo);
					if (psviAugmentation)
					{
						xmlAttribute.XmlName = document.AddAttrXmlName(xmlAttribute.Prefix, xmlAttribute.LocalName, xmlAttribute.NamespaceURI, attributeSchemaInfo);
					}
				}
			}
			if (!psviAugmentation)
			{
				return;
			}
			if (defaultAttributes == null)
			{
				defaultAttributes = new ArrayList();
			}
			else
			{
				defaultAttributes.Clear();
			}
			validator.GetUnspecifiedDefaultAttributes(defaultAttributes);
			XmlSchemaAttribute xmlSchemaAttribute = null;
			xmlAttribute = null;
			for (int j = 0; j < defaultAttributes.Count; j++)
			{
				xmlSchemaAttribute = defaultAttributes[j] as XmlSchemaAttribute;
				XmlQualifiedName qualifiedName = xmlSchemaAttribute.QualifiedName;
				xmlAttribute = document.CreateDefaultAttribute(GetDefaultPrefix(qualifiedName.Namespace), qualifiedName.Name, qualifiedName.Namespace);
				SetDefaultAttributeSchemaInfo(xmlSchemaAttribute);
				xmlAttribute.XmlName = document.AddAttrXmlName(xmlAttribute.Prefix, xmlAttribute.LocalName, xmlAttribute.NamespaceURI, attributeSchemaInfo);
				xmlAttribute.AppendChild(document.CreateTextNode(xmlSchemaAttribute.AttDef.DefaultValueRaw));
				attributes.Append(xmlAttribute);
				if (xmlAttribute is XmlUnspecifiedAttribute xmlUnspecifiedAttribute)
				{
					xmlUnspecifiedAttribute.SetSpecified(f: false);
				}
			}
		}

		private void SetDefaultAttributeSchemaInfo(XmlSchemaAttribute schemaAttribute)
		{
			attributeSchemaInfo.Clear();
			attributeSchemaInfo.IsDefault = true;
			attributeSchemaInfo.IsNil = false;
			attributeSchemaInfo.SchemaType = schemaAttribute.AttributeSchemaType;
			attributeSchemaInfo.SchemaAttribute = schemaAttribute;
			SchemaAttDef attDef = schemaAttribute.AttDef;
			if (attDef.Datatype.Variety == XmlSchemaDatatypeVariety.Union)
			{
				XsdSimpleValue xsdSimpleValue = attDef.DefaultValueTyped as XsdSimpleValue;
				attributeSchemaInfo.MemberType = xsdSimpleValue.XmlType;
			}
			attributeSchemaInfo.Validity = XmlSchemaValidity.Valid;
		}

		private string GetDefaultPrefix(string attributeNS)
		{
			IDictionary<string, string> namespacesInScope = NamespaceResolver.GetNamespacesInScope(XmlNamespaceScope.All);
			string text = null;
			attributeNS = nameTable.Add(attributeNS);
			foreach (KeyValuePair<string, string> item in namespacesInScope)
			{
				string objA = nameTable.Add(item.Value);
				if (object.ReferenceEquals(objA, attributeNS))
				{
					text = item.Key;
					if (text.Length != 0)
					{
						return text;
					}
				}
			}
			return text;
		}

		private object GetNodeValue()
		{
			return currentNode.Value;
		}

		private XmlSchemaObject FindSchemaInfo(XmlElement elementToValidate)
		{
			isPartialTreeValid = true;
			IXmlSchemaInfo xmlSchemaInfo = null;
			int num = 0;
			XmlNode parentNode = elementToValidate.ParentNode;
			do
			{
				xmlSchemaInfo = parentNode.SchemaInfo;
				if (xmlSchemaInfo.SchemaElement != null || xmlSchemaInfo.SchemaType != null)
				{
					break;
				}
				CheckNodeSequenceCapacity(num);
				nodeSequenceToValidate[num++] = parentNode;
				parentNode = parentNode.ParentNode;
			}
			while (parentNode != null);
			if (parentNode == null)
			{
				num--;
				nodeSequenceToValidate[num] = null;
				return GetTypeFromAncestors(elementToValidate, null, num);
			}
			if (nodeSequenceToValidate == null)
			{
				if (!(xmlSchemaInfo.SchemaType is XmlSchemaComplexType xmlSchemaComplexType))
				{
					return null;
				}
				if (!xmlSchemaComplexType.HasWildCard && !xmlSchemaComplexType.HasDuplicateDecls)
				{
					return GetTypeFromParent(elementToValidate, xmlSchemaComplexType);
				}
				CheckNodeSequenceCapacity(num);
				nodeSequenceToValidate[num++] = parentNode;
			}
			else
			{
				CheckNodeSequenceCapacity(num);
				nodeSequenceToValidate[num++] = parentNode;
			}
			XmlSchemaObject xmlSchemaObject = xmlSchemaInfo.SchemaElement;
			if (xmlSchemaObject == null)
			{
				xmlSchemaObject = xmlSchemaInfo.SchemaType;
			}
			return GetTypeFromAncestors(elementToValidate, xmlSchemaObject, num);
		}

		private XmlSchemaElement GetTypeFromParent(XmlElement elementToValidate, XmlSchemaComplexType parentSchemaType)
		{
			return parentSchemaType.LocalElements[new XmlQualifiedName(elementToValidate.LocalName, elementToValidate.NamespaceURI)] as XmlSchemaElement;
		}

		private void CheckNodeSequenceCapacity(int currentIndex)
		{
			if (nodeSequenceToValidate == null)
			{
				nodeSequenceToValidate = new XmlNode[4];
			}
			else if (currentIndex >= nodeSequenceToValidate.Length - 1)
			{
				XmlNode[] destinationArray = new XmlNode[nodeSequenceToValidate.Length * 2];
				Array.Copy(nodeSequenceToValidate, 0, destinationArray, 0, nodeSequenceToValidate.Length);
				nodeSequenceToValidate = destinationArray;
			}
		}

		private XmlSchemaAttribute FindSchemaInfo(XmlAttribute attributeToValidate)
		{
			XmlElement ownerElement = attributeToValidate.OwnerElement;
			XmlSchemaObject schemaObject = FindSchemaInfo(ownerElement);
			XmlSchemaComplexType complexType = GetComplexType(schemaObject);
			if (complexType == null)
			{
				return null;
			}
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(attributeToValidate.LocalName, attributeToValidate.NamespaceURI);
			XmlSchemaAttribute xmlSchemaAttribute = complexType.AttributeUses[xmlQualifiedName] as XmlSchemaAttribute;
			if (xmlSchemaAttribute == null)
			{
				XmlSchemaAnyAttribute attributeWildcard = complexType.AttributeWildcard;
				if (attributeWildcard != null && attributeWildcard.NamespaceList.Allows(xmlQualifiedName))
				{
					xmlSchemaAttribute = schemas.GlobalAttributes[xmlQualifiedName] as XmlSchemaAttribute;
				}
			}
			return xmlSchemaAttribute;
		}

		private XmlSchemaObject GetTypeFromAncestors(XmlElement elementToValidate, XmlSchemaObject ancestorType, int ancestorsCount)
		{
			validator = CreateTypeFinderValidator(ancestorType);
			schemaInfo = new XmlSchemaInfo();
			int num = ancestorsCount - 1;
			bool flag = AncestorTypeHasWildcard(ancestorType);
			for (int num2 = num; num2 >= 0; num2--)
			{
				XmlNode xmlNode = nodeSequenceToValidate[num2];
				XmlElement xmlElement = xmlNode as XmlElement;
				ValidateSingleElement(xmlElement, skipToEnd: false, schemaInfo);
				if (!flag)
				{
					xmlElement.XmlName = document.AddXmlName(xmlElement.Prefix, xmlElement.LocalName, xmlElement.NamespaceURI, schemaInfo);
					flag = AncestorTypeHasWildcard(schemaInfo.SchemaElement);
				}
				validator.ValidateEndOfAttributes(null);
				if (num2 > 0)
				{
					ValidateChildrenTillNextAncestor(xmlNode, nodeSequenceToValidate[num2 - 1]);
				}
				else
				{
					ValidateChildrenTillNextAncestor(xmlNode, elementToValidate);
				}
			}
			ValidateSingleElement(elementToValidate, skipToEnd: false, schemaInfo);
			XmlSchemaObject xmlSchemaObject = null;
			xmlSchemaObject = ((schemaInfo.SchemaElement == null) ? ((XmlSchemaAnnotated)schemaInfo.SchemaType) : ((XmlSchemaAnnotated)schemaInfo.SchemaElement));
			if (xmlSchemaObject == null)
			{
				if (validator.CurrentProcessContents == XmlSchemaContentProcessing.Skip)
				{
					if (isPartialTreeValid)
					{
						return XmlSchemaComplexType.AnyTypeSkip;
					}
				}
				else if (validator.CurrentProcessContents == XmlSchemaContentProcessing.Lax)
				{
					return XmlSchemaComplexType.AnyType;
				}
			}
			return xmlSchemaObject;
		}

		private bool AncestorTypeHasWildcard(XmlSchemaObject ancestorType)
		{
			XmlSchemaComplexType complexType = GetComplexType(ancestorType);
			if (ancestorType != null)
			{
				return complexType.HasWildCard;
			}
			return false;
		}

		private XmlSchemaComplexType GetComplexType(XmlSchemaObject schemaObject)
		{
			if (schemaObject == null)
			{
				return null;
			}
			XmlSchemaElement xmlSchemaElement = schemaObject as XmlSchemaElement;
			XmlSchemaComplexType xmlSchemaComplexType = null;
			if (xmlSchemaElement != null)
			{
				return xmlSchemaElement.ElementSchemaType as XmlSchemaComplexType;
			}
			return schemaObject as XmlSchemaComplexType;
		}

		private void ValidateSingleElement(XmlElement elementNode, bool skipToEnd, XmlSchemaInfo newSchemaInfo)
		{
			nsManager.PushScope();
			XmlAttributeCollection attributes = elementNode.Attributes;
			XmlAttribute xmlAttribute = null;
			string xsiNil = null;
			string xsiType = null;
			for (int i = 0; i < attributes.Count; i++)
			{
				xmlAttribute = attributes[i];
				string namespaceURI = xmlAttribute.NamespaceURI;
				string localName = xmlAttribute.LocalName;
				if (Ref.Equal(namespaceURI, NsXsi))
				{
					if (Ref.Equal(localName, XsiType))
					{
						xsiType = xmlAttribute.Value;
					}
					else if (Ref.Equal(localName, XsiNil))
					{
						xsiNil = xmlAttribute.Value;
					}
				}
				else if (Ref.Equal(namespaceURI, NsXmlNs))
				{
					nsManager.AddNamespace((xmlAttribute.Prefix.Length == 0) ? string.Empty : xmlAttribute.LocalName, xmlAttribute.Value);
				}
			}
			validator.ValidateElement(elementNode.LocalName, elementNode.NamespaceURI, newSchemaInfo, xsiType, xsiNil, null, null);
			if (skipToEnd)
			{
				validator.ValidateEndOfAttributes(newSchemaInfo);
				validator.SkipToEndElement(newSchemaInfo);
				nsManager.PopScope();
			}
		}

		private void ValidateChildrenTillNextAncestor(XmlNode parentNode, XmlNode childToStopAt)
		{
			XmlNode xmlNode = parentNode.FirstChild;
			while (xmlNode != null && xmlNode != childToStopAt)
			{
				switch (xmlNode.NodeType)
				{
				case XmlNodeType.EntityReference:
					ValidateChildrenTillNextAncestor(xmlNode, childToStopAt);
					break;
				case XmlNodeType.Element:
					ValidateSingleElement(xmlNode as XmlElement, skipToEnd: true, null);
					break;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
					validator.ValidateText(xmlNode.Value);
					break;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					validator.ValidateWhitespace(xmlNode.Value);
					break;
				default:
					throw new InvalidOperationException(Res.GetString("Xml_UnexpectedNodeType", currentNode.NodeType.ToString()));
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.Comment:
					break;
				}
				xmlNode = xmlNode.NextSibling;
			}
		}

		private XmlSchemaValidator CreateTypeFinderValidator(XmlSchemaObject partialValidationType)
		{
			XmlSchemaValidator xmlSchemaValidator = new XmlSchemaValidator(document.NameTable, document.Schemas, nsManager, XmlSchemaValidationFlags.None);
			xmlSchemaValidator.ValidationEventHandler += TypeFinderCallBack;
			if (partialValidationType != null)
			{
				xmlSchemaValidator.Initialize(partialValidationType);
			}
			else
			{
				xmlSchemaValidator.Initialize();
			}
			return xmlSchemaValidator;
		}

		private void TypeFinderCallBack(object sender, ValidationEventArgs arg)
		{
			if (arg.Severity == XmlSeverityType.Error)
			{
				isPartialTreeValid = false;
			}
		}

		private void InternalValidationCallBack(object sender, ValidationEventArgs arg)
		{
			if (arg.Severity == XmlSeverityType.Error)
			{
				isValid = false;
			}
			XmlSchemaValidationException ex = arg.Exception as XmlSchemaValidationException;
			ex.SetSourceObject(currentNode);
			if (eventHandler != null)
			{
				eventHandler(sender, arg);
			}
			else if (arg.Severity == XmlSeverityType.Error)
			{
				throw ex;
			}
		}
	}
	internal class XmlDOMTextWriter : XmlTextWriter
	{
		public XmlDOMTextWriter(Stream w, Encoding encoding)
			: base(w, encoding)
		{
		}

		public XmlDOMTextWriter(string filename, Encoding encoding)
			: base(filename, encoding)
		{
		}

		public XmlDOMTextWriter(TextWriter w)
			: base(w)
		{
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			if (ns.Length == 0 && prefix.Length != 0)
			{
				prefix = "";
			}
			base.WriteStartElement(prefix, localName, ns);
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (ns.Length == 0 && prefix.Length != 0)
			{
				prefix = "";
			}
			base.WriteStartAttribute(prefix, localName, ns);
		}
	}
	public class XmlElement : XmlLinkedNode
	{
		private XmlName name;

		private XmlAttributeCollection attributes;

		private XmlLinkedNode lastChild;

		internal XmlName XmlName
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public override string Name => name.Name;

		public override string LocalName => name.LocalName;

		public override string NamespaceURI => name.NamespaceURI;

		public override string Prefix
		{
			get
			{
				return name.Prefix;
			}
			set
			{
				name = name.OwnerDocument.AddXmlName(value, LocalName, NamespaceURI, SchemaInfo);
			}
		}

		public override XmlNodeType NodeType => XmlNodeType.Element;

		public override XmlNode ParentNode => parentNode;

		public override XmlDocument OwnerDocument => name.OwnerDocument;

		internal override bool IsContainer => true;

		public bool IsEmpty
		{
			get
			{
				return lastChild == this;
			}
			set
			{
				if (value)
				{
					if (lastChild != this)
					{
						RemoveAllChildren();
						lastChild = this;
					}
				}
				else if (lastChild == this)
				{
					lastChild = null;
				}
			}
		}

		internal override XmlLinkedNode LastNode
		{
			get
			{
				if (lastChild != this)
				{
					return lastChild;
				}
				return null;
			}
			set
			{
				lastChild = value;
			}
		}

		public override XmlAttributeCollection Attributes
		{
			get
			{
				if (attributes == null)
				{
					lock (OwnerDocument.objLock)
					{
						if (attributes == null)
						{
							attributes = new XmlAttributeCollection(this);
						}
					}
				}
				return attributes;
			}
		}

		public virtual bool HasAttributes
		{
			get
			{
				if (attributes == null)
				{
					return false;
				}
				return attributes.Count > 0;
			}
		}

		public override IXmlSchemaInfo SchemaInfo => name;

		public override string InnerXml
		{
			get
			{
				return base.InnerXml;
			}
			set
			{
				RemoveAllChildren();
				XmlLoader xmlLoader = new XmlLoader();
				xmlLoader.LoadInnerXmlElement(this, value);
			}
		}

		public override string InnerText
		{
			get
			{
				return base.InnerText;
			}
			set
			{
				XmlLinkedNode lastNode = LastNode;
				if (lastNode != null && lastNode.NodeType == XmlNodeType.Text && lastNode.next == lastNode)
				{
					lastNode.Value = value;
					return;
				}
				RemoveAllChildren();
				AppendChild(OwnerDocument.CreateTextNode(value));
			}
		}

		public override XmlNode NextSibling
		{
			get
			{
				if (parentNode != null && parentNode.LastNode != this)
				{
					return next;
				}
				return null;
			}
		}

		internal override XPathNodeType XPNodeType => XPathNodeType.Element;

		internal override string XPLocalName => LocalName;

		internal XmlElement(XmlName name, bool empty, XmlDocument doc)
			: base(doc)
		{
			parentNode = null;
			if (!doc.IsLoading)
			{
				XmlDocument.CheckName(name.Prefix);
				XmlDocument.CheckName(name.LocalName);
			}
			if (name.LocalName.Length == 0)
			{
				throw new ArgumentException(Res.GetString("Xdom_Empty_LocalName"));
			}
			if (name.Prefix.Length >= 3 && !doc.IsLoading && string.Compare(name.Prefix, 0, "xml", 0, 3, StringComparison.OrdinalIgnoreCase) == 0)
			{
				throw new ArgumentException(Res.GetString("Xdom_Ele_Prefix"));
			}
			this.name = name;
			if (empty)
			{
				lastChild = this;
			}
		}

		protected internal XmlElement(string prefix, string localName, string namespaceURI, XmlDocument doc)
			: this(doc.AddXmlName(prefix, localName, namespaceURI, null), empty: true, doc)
		{
		}

		public override XmlNode CloneNode(bool deep)
		{
			XmlDocument ownerDocument = OwnerDocument;
			bool isLoading = ownerDocument.IsLoading;
			ownerDocument.IsLoading = true;
			XmlElement xmlElement = ownerDocument.CreateElement(Prefix, LocalName, NamespaceURI);
			ownerDocument.IsLoading = isLoading;
			if (xmlElement.IsEmpty != IsEmpty)
			{
				xmlElement.IsEmpty = IsEmpty;
			}
			if (HasAttributes)
			{
				foreach (XmlAttribute attribute in Attributes)
				{
					XmlAttribute xmlAttribute2 = (XmlAttribute)attribute.CloneNode(deep: true);
					if (attribute is XmlUnspecifiedAttribute && !attribute.Specified)
					{
						((XmlUnspecifiedAttribute)xmlAttribute2).SetSpecified(f: false);
					}
					xmlElement.Attributes.InternalAppendAttribute(xmlAttribute2);
				}
			}
			if (deep)
			{
				xmlElement.CopyChildren(ownerDocument, this, deep);
			}
			return xmlElement;
		}

		internal override XmlNode AppendChildForLoad(XmlNode newChild, XmlDocument doc)
		{
			XmlNodeChangedEventArgs insertEventArgsForLoad = doc.GetInsertEventArgsForLoad(newChild, this);
			if (insertEventArgsForLoad != null)
			{
				doc.BeforeEvent(insertEventArgsForLoad);
			}
			XmlLinkedNode xmlLinkedNode = (XmlLinkedNode)newChild;
			if (lastChild == null || lastChild == this)
			{
				xmlLinkedNode.next = xmlLinkedNode;
				lastChild = xmlLinkedNode;
				xmlLinkedNode.SetParentForLoad(this);
			}
			else
			{
				XmlLinkedNode xmlLinkedNode2 = lastChild;
				xmlLinkedNode.next = xmlLinkedNode2.next;
				xmlLinkedNode2.next = xmlLinkedNode;
				lastChild = xmlLinkedNode;
				if (xmlLinkedNode2.IsText && xmlLinkedNode.IsText)
				{
					XmlNode.NestTextNodes(xmlLinkedNode2, xmlLinkedNode);
				}
				else
				{
					xmlLinkedNode.SetParentForLoad(this);
				}
			}
			if (insertEventArgsForLoad != null)
			{
				doc.AfterEvent(insertEventArgsForLoad);
			}
			return xmlLinkedNode;
		}

		internal override bool IsValidChildType(XmlNodeType type)
		{
			switch (type)
			{
			case XmlNodeType.Element:
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.EntityReference:
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Comment:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				return true;
			default:
				return false;
			}
		}

		public virtual string GetAttribute(string name)
		{
			XmlAttribute attributeNode = GetAttributeNode(name);
			if (attributeNode != null)
			{
				return attributeNode.Value;
			}
			return string.Empty;
		}

		public virtual void SetAttribute(string name, string value)
		{
			XmlAttribute attributeNode = GetAttributeNode(name);
			if (attributeNode == null)
			{
				attributeNode = OwnerDocument.CreateAttribute(name);
				attributeNode.Value = value;
				Attributes.InternalAppendAttribute(attributeNode);
			}
			else
			{
				attributeNode.Value = value;
			}
		}

		public virtual void RemoveAttribute(string name)
		{
			if (HasAttributes)
			{
				Attributes.RemoveNamedItem(name);
			}
		}

		public virtual XmlAttribute GetAttributeNode(string name)
		{
			if (HasAttributes)
			{
				return Attributes[name];
			}
			return null;
		}

		public virtual XmlAttribute SetAttributeNode(XmlAttribute newAttr)
		{
			if (newAttr.OwnerElement != null)
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Attr_InUse"));
			}
			return (XmlAttribute)Attributes.SetNamedItem(newAttr);
		}

		public virtual XmlAttribute RemoveAttributeNode(XmlAttribute oldAttr)
		{
			if (HasAttributes)
			{
				return Attributes.Remove(oldAttr);
			}
			return null;
		}

		public virtual XmlNodeList GetElementsByTagName(string name)
		{
			return new XmlElementList(this, name);
		}

		public virtual string GetAttribute(string localName, string namespaceURI)
		{
			XmlAttribute attributeNode = GetAttributeNode(localName, namespaceURI);
			if (attributeNode != null)
			{
				return attributeNode.Value;
			}
			return string.Empty;
		}

		public virtual string SetAttribute(string localName, string namespaceURI, string value)
		{
			XmlAttribute attributeNode = GetAttributeNode(localName, namespaceURI);
			if (attributeNode == null)
			{
				attributeNode = OwnerDocument.CreateAttribute(string.Empty, localName, namespaceURI);
				attributeNode.Value = value;
				Attributes.InternalAppendAttribute(attributeNode);
			}
			else
			{
				attributeNode.Value = value;
			}
			return value;
		}

		public virtual void RemoveAttribute(string localName, string namespaceURI)
		{
			RemoveAttributeNode(localName, namespaceURI);
		}

		public virtual XmlAttribute GetAttributeNode(string localName, string namespaceURI)
		{
			if (HasAttributes)
			{
				return Attributes[localName, namespaceURI];
			}
			return null;
		}

		public virtual XmlAttribute SetAttributeNode(string localName, string namespaceURI)
		{
			XmlAttribute xmlAttribute = GetAttributeNode(localName, namespaceURI);
			if (xmlAttribute == null)
			{
				xmlAttribute = OwnerDocument.CreateAttribute(string.Empty, localName, namespaceURI);
				Attributes.InternalAppendAttribute(xmlAttribute);
			}
			return xmlAttribute;
		}

		public virtual XmlAttribute RemoveAttributeNode(string localName, string namespaceURI)
		{
			if (HasAttributes)
			{
				XmlAttribute attributeNode = GetAttributeNode(localName, namespaceURI);
				Attributes.Remove(attributeNode);
				return attributeNode;
			}
			return null;
		}

		public virtual XmlNodeList GetElementsByTagName(string localName, string namespaceURI)
		{
			return new XmlElementList(this, localName, namespaceURI);
		}

		public virtual bool HasAttribute(string name)
		{
			return GetAttributeNode(name) != null;
		}

		public virtual bool HasAttribute(string localName, string namespaceURI)
		{
			return GetAttributeNode(localName, namespaceURI) != null;
		}

		public override void WriteTo(XmlWriter w)
		{
			if (GetType() == typeof(XmlElement))
			{
				WriteElementTo(w, this);
				return;
			}
			WriteStartElement(w);
			if (IsEmpty)
			{
				w.WriteEndElement();
				return;
			}
			WriteContentTo(w);
			w.WriteFullEndElement();
		}

		private static void WriteElementTo(XmlWriter writer, XmlElement e)
		{
			XmlNode xmlNode = e;
			XmlNode xmlNode2 = e;
			while (true)
			{
				e = xmlNode2 as XmlElement;
				if (e != null && e.GetType() == typeof(XmlElement))
				{
					e.WriteStartElement(writer);
					if (e.IsEmpty)
					{
						writer.WriteEndElement();
					}
					else
					{
						if (e.lastChild != null)
						{
							xmlNode2 = e.FirstChild;
							continue;
						}
						writer.WriteFullEndElement();
					}
				}
				else
				{
					xmlNode2.WriteTo(writer);
				}
				while (xmlNode2 != xmlNode && xmlNode2 == xmlNode2.ParentNode.LastChild)
				{
					xmlNode2 = xmlNode2.ParentNode;
					writer.WriteFullEndElement();
				}
				if (xmlNode2 == xmlNode)
				{
					break;
				}
				xmlNode2 = xmlNode2.NextSibling;
			}
		}

		private void WriteStartElement(XmlWriter w)
		{
			w.WriteStartElement(Prefix, LocalName, NamespaceURI);
			if (HasAttributes)
			{
				XmlAttributeCollection xmlAttributeCollection = Attributes;
				for (int i = 0; i < xmlAttributeCollection.Count; i++)
				{
					XmlAttribute xmlAttribute = xmlAttributeCollection[i];
					xmlAttribute.WriteTo(w);
				}
			}
		}

		public override void WriteContentTo(XmlWriter w)
		{
			for (XmlNode xmlNode = FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
			{
				xmlNode.WriteTo(w);
			}
		}

		public virtual XmlNode RemoveAttributeAt(int i)
		{
			if (HasAttributes)
			{
				return attributes.RemoveAt(i);
			}
			return null;
		}

		public virtual void RemoveAllAttributes()
		{
			if (HasAttributes)
			{
				attributes.RemoveAll();
			}
		}

		public override void RemoveAll()
		{
			base.RemoveAll();
			RemoveAllAttributes();
		}

		internal void RemoveAllChildren()
		{
			base.RemoveAll();
		}

		internal override void SetParent(XmlNode node)
		{
			parentNode = node;
		}

		internal override string GetXPAttribute(string localName, string ns)
		{
			if (ns == OwnerDocument.strReservedXmlns)
			{
				return null;
			}
			XmlAttribute attributeNode = GetAttributeNode(localName, ns);
			if (attributeNode != null)
			{
				return attributeNode.Value;
			}
			return string.Empty;
		}
	}
	internal class XmlElementList : XmlNodeList
	{
		private string asterisk;

		private int changeCount;

		private string name;

		private string localName;

		private string namespaceURI;

		private XmlNode rootNode;

		private int curInd;

		private XmlNode curElem;

		private bool empty;

		private bool atomized;

		private int matchCount;

		internal int ChangeCount => changeCount;

		public override int Count
		{
			get
			{
				if (empty)
				{
					return 0;
				}
				if (matchCount < 0)
				{
					int num = 0;
					int num2 = changeCount;
					XmlNode matchingNode = rootNode;
					while ((matchingNode = GetMatchingNode(matchingNode, bNext: true)) != null)
					{
						num++;
					}
					if (num2 != changeCount)
					{
						return num;
					}
					matchCount = num;
				}
				return matchCount;
			}
		}

		private XmlElementList(XmlNode parent)
		{
			rootNode = parent;
			curInd = -1;
			curElem = rootNode;
			changeCount = 0;
			empty = false;
			atomized = true;
			matchCount = -1;
			new XmlElementListListener(parent.Document, this);
		}

		internal void ConcurrencyCheck(XmlNodeChangedEventArgs args)
		{
			if (!atomized)
			{
				XmlNameTable nameTable = rootNode.Document.NameTable;
				localName = nameTable.Add(localName);
				namespaceURI = nameTable.Add(namespaceURI);
				atomized = true;
			}
			if (IsMatch(args.Node))
			{
				changeCount++;
				curInd = -1;
				curElem = rootNode;
				if (args.Action == XmlNodeChangedAction.Insert)
				{
					empty = false;
				}
			}
			matchCount = -1;
		}

		internal XmlElementList(XmlNode parent, string name)
			: this(parent)
		{
			XmlNameTable nameTable = parent.Document.NameTable;
			asterisk = nameTable.Add("*");
			this.name = nameTable.Add(name);
			localName = null;
			namespaceURI = null;
		}

		internal XmlElementList(XmlNode parent, string localName, string namespaceURI)
			: this(parent)
		{
			XmlNameTable nameTable = parent.Document.NameTable;
			asterisk = nameTable.Add("*");
			this.localName = nameTable.Get(localName);
			this.namespaceURI = nameTable.Get(namespaceURI);
			if (this.localName == null || this.namespaceURI == null)
			{
				empty = true;
				atomized = false;
				this.localName = localName;
				this.namespaceURI = namespaceURI;
			}
			name = null;
		}

		private XmlNode NextElemInPreOrder(XmlNode curNode)
		{
			XmlNode xmlNode = curNode.FirstChild;
			if (xmlNode == null)
			{
				xmlNode = curNode;
				while (xmlNode != null && xmlNode != rootNode && xmlNode.NextSibling == null)
				{
					xmlNode = xmlNode.ParentNode;
				}
				if (xmlNode != null && xmlNode != rootNode)
				{
					xmlNode = xmlNode.NextSibling;
				}
			}
			if (xmlNode == rootNode)
			{
				xmlNode = null;
			}
			return xmlNode;
		}

		private XmlNode PrevElemInPreOrder(XmlNode curNode)
		{
			XmlNode xmlNode = curNode.PreviousSibling;
			while (xmlNode != null && xmlNode.LastChild != null)
			{
				xmlNode = xmlNode.LastChild;
			}
			if (xmlNode == null)
			{
				xmlNode = curNode.ParentNode;
			}
			if (xmlNode == rootNode)
			{
				xmlNode = null;
			}
			return xmlNode;
		}

		private bool IsMatch(XmlNode curNode)
		{
			if (curNode.NodeType == XmlNodeType.Element)
			{
				if (name != null)
				{
					if (Ref.Equal(name, asterisk) || Ref.Equal(curNode.Name, name))
					{
						return true;
					}
				}
				else if ((Ref.Equal(localName, asterisk) || Ref.Equal(curNode.LocalName, localName)) && (Ref.Equal(namespaceURI, asterisk) || curNode.NamespaceURI == namespaceURI))
				{
					return true;
				}
			}
			return false;
		}

		private XmlNode GetMatchingNode(XmlNode n, bool bNext)
		{
			XmlNode xmlNode = n;
			do
			{
				xmlNode = ((!bNext) ? PrevElemInPreOrder(xmlNode) : NextElemInPreOrder(xmlNode));
			}
			while (xmlNode != null && !IsMatch(xmlNode));
			return xmlNode;
		}

		private XmlNode GetNthMatchingNode(XmlNode n, bool bNext, int nCount)
		{
			XmlNode xmlNode = n;
			for (int i = 0; i < nCount; i++)
			{
				xmlNode = GetMatchingNode(xmlNode, bNext);
				if (xmlNode == null)
				{
					return null;
				}
			}
			return xmlNode;
		}

		public XmlNode GetNextNode(XmlNode n)
		{
			if (empty)
			{
				return null;
			}
			XmlNode n2 = ((n == null) ? rootNode : n);
			return GetMatchingNode(n2, bNext: true);
		}

		public override XmlNode Item(int index)
		{
			if (rootNode == null || index < 0)
			{
				return null;
			}
			if (empty)
			{
				return null;
			}
			if (curInd == index)
			{
				return curElem;
			}
			int num = index - curInd;
			bool bNext = num > 0;
			if (num < 0)
			{
				num = -num;
			}
			XmlNode nthMatchingNode;
			if ((nthMatchingNode = GetNthMatchingNode(curElem, bNext, num)) != null)
			{
				curInd = index;
				curElem = nthMatchingNode;
				return curElem;
			}
			return null;
		}

		public override IEnumerator GetEnumerator()
		{
			if (empty)
			{
				return new XmlEmptyElementListEnumerator(this);
			}
			return new XmlElementListEnumerator(this);
		}
	}
	internal class XmlElementListEnumerator : IEnumerator
	{
		private XmlElementList list;

		private XmlNode curElem;

		private int changeCount;

		public object Current => curElem;

		public XmlElementListEnumerator(XmlElementList list)
		{
			this.list = list;
			curElem = null;
			changeCount = list.ChangeCount;
		}

		public bool MoveNext()
		{
			if (list.ChangeCount != changeCount)
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Enum_ElementList"));
			}
			curElem = list.GetNextNode(curElem);
			return curElem != null;
		}

		public void Reset()
		{
			curElem = null;
			changeCount = list.ChangeCount;
		}
	}
	internal class XmlEmptyElementListEnumerator : IEnumerator
	{
		public object Current => null;

		public XmlEmptyElementListEnumerator(XmlElementList list)
		{
		}

		public bool MoveNext()
		{
			return false;
		}

		public void Reset()
		{
		}
	}
	internal class XmlElementListListener
	{
		private WeakReference elemList;

		private XmlDocument doc;

		private XmlNodeChangedEventHandler nodeChangeHandler;

		internal XmlElementListListener(XmlDocument doc, XmlElementList elemList)
		{
			this.doc = doc;
			this.elemList = new WeakReference(elemList);
			nodeChangeHandler = OnListChanged;
			doc.NodeInserted += nodeChangeHandler;
			doc.NodeRemoved += nodeChangeHandler;
		}

		private void OnListChanged(object sender, XmlNodeChangedEventArgs args)
		{
			XmlElementList xmlElementList = (XmlElementList)elemList.Target;
			if (xmlElementList != null)
			{
				xmlElementList.ConcurrencyCheck(args);
				return;
			}
			doc.NodeInserted -= nodeChangeHandler;
			doc.NodeRemoved -= nodeChangeHandler;
		}
	}
	public class XmlEntity : XmlNode
	{
		private string publicId;

		private string systemId;

		private string notationName;

		private string name;

		private string unparsedReplacementStr;

		private string baseURI;

		private XmlLinkedNode lastChild;

		private bool childrenFoliating;

		public override bool IsReadOnly => true;

		public override string Name => name;

		public override string LocalName => name;

		public override string InnerText
		{
			get
			{
				return base.InnerText;
			}
			set
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Ent_Innertext"));
			}
		}

		internal override bool IsContainer => true;

		internal override XmlLinkedNode LastNode
		{
			get
			{
				if (lastChild == null && !childrenFoliating)
				{
					childrenFoliating = true;
					XmlLoader xmlLoader = new XmlLoader();
					xmlLoader.ExpandEntity(this);
				}
				return lastChild;
			}
			set
			{
				lastChild = value;
			}
		}

		public override XmlNodeType NodeType => XmlNodeType.Entity;

		public string PublicId => publicId;

		public string SystemId => systemId;

		public string NotationName => notationName;

		public override string OuterXml => string.Empty;

		public override string InnerXml
		{
			get
			{
				return string.Empty;
			}
			set
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Set_InnerXml"));
			}
		}

		public override string BaseURI => baseURI;

		internal XmlEntity(string name, string strdata, string publicId, string systemId, string notationName, XmlDocument doc)
			: base(doc)
		{
			this.name = doc.NameTable.Add(name);
			this.publicId = publicId;
			this.systemId = systemId;
			this.notationName = notationName;
			unparsedReplacementStr = strdata;
			childrenFoliating = false;
		}

		public override XmlNode CloneNode(bool deep)
		{
			throw new InvalidOperationException(Res.GetString("Xdom_Node_Cloning"));
		}

		internal override bool IsValidChildType(XmlNodeType type)
		{
			if (type != XmlNodeType.Text && type != XmlNodeType.Element && type != XmlNodeType.ProcessingInstruction && type != XmlNodeType.Comment && type != XmlNodeType.CDATA && type != XmlNodeType.Whitespace && type != XmlNodeType.SignificantWhitespace)
			{
				return type == XmlNodeType.EntityReference;
			}
			return true;
		}

		public override void WriteTo(XmlWriter w)
		{
		}

		public override void WriteContentTo(XmlWriter w)
		{
		}

		internal void SetBaseURI(string inBaseURI)
		{
			baseURI = inBaseURI;
		}
	}
	public class XmlEntityReference : XmlLinkedNode
	{
		private string name;

		private XmlLinkedNode lastChild;

		public override string Name => name;

		public override string LocalName => name;

		public override string Value
		{
			get
			{
				return null;
			}
			set
			{
				throw new InvalidOperationException(Res.GetString("Xdom_EntRef_SetVal"));
			}
		}

		public override XmlNodeType NodeType => XmlNodeType.EntityReference;

		public override bool IsReadOnly => true;

		internal override bool IsContainer => true;

		internal override XmlLinkedNode LastNode
		{
			get
			{
				return lastChild;
			}
			set
			{
				lastChild = value;
			}
		}

		public override string BaseURI => OwnerDocument.BaseURI;

		internal string ChildBaseURI
		{
			get
			{
				XmlEntity entityNode = OwnerDocument.GetEntityNode(name);
				if (entityNode != null)
				{
					if (entityNode.SystemId != null && entityNode.SystemId.Length > 0)
					{
						return ConstructBaseURI(entityNode.BaseURI, entityNode.SystemId);
					}
					return entityNode.BaseURI;
				}
				return string.Empty;
			}
		}

		protected internal XmlEntityReference(string name, XmlDocument doc)
			: base(doc)
		{
			if (!doc.IsLoading && name.Length > 0 && name[0] == '#')
			{
				throw new ArgumentException(Res.GetString("Xdom_InvalidCharacter_EntityReference"));
			}
			this.name = doc.NameTable.Add(name);
			doc.fEntRefNodesPresent = true;
		}

		public override XmlNode CloneNode(bool deep)
		{
			return OwnerDocument.CreateEntityReference(name);
		}

		internal override void SetParent(XmlNode node)
		{
			base.SetParent(node);
			if (LastNode == null && node != null && node != OwnerDocument)
			{
				XmlLoader xmlLoader = new XmlLoader();
				xmlLoader.ExpandEntityReference(this);
			}
		}

		internal override void SetParentForLoad(XmlNode node)
		{
			SetParent(node);
		}

		internal override bool IsValidChildType(XmlNodeType type)
		{
			switch (type)
			{
			case XmlNodeType.Element:
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.EntityReference:
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Comment:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				return true;
			default:
				return false;
			}
		}

		public override void WriteTo(XmlWriter w)
		{
			w.WriteEntityRef(name);
		}

		public override void WriteContentTo(XmlWriter w)
		{
			IEnumerator enumerator = GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					XmlNode xmlNode = (XmlNode)enumerator.Current;
					xmlNode.WriteTo(w);
				}
			}
			finally
			{
				IDisposable disposable = enumerator as IDisposable;
				if (disposable != null)
				{
					disposable.Dispose();
				}
			}
		}

		private string ConstructBaseURI(string baseURI, string systemId)
		{
			if (baseURI == null)
			{
				return systemId;
			}
			int num = baseURI.LastIndexOf('/') + 1;
			string text = baseURI;
			if (num > 0 && num < baseURI.Length)
			{
				text = baseURI.Substring(0, num);
			}
			else if (num == 0)
			{
				text += "\\";
			}
			return text + systemId.Replace('\\', '/');
		}
	}
	public enum XmlNodeChangedAction
	{
		Insert,
		Remove,
		Change
	}
	public class XmlImplementation
	{
		private XmlNameTable nameTable;

		internal XmlNameTable NameTable => nameTable;

		public XmlImplementation()
			: this(new NameTable())
		{
		}

		public XmlImplementation(XmlNameTable nt)
		{
			nameTable = nt;
		}

		public bool HasFeature(string strFeature, string strVersion)
		{
			if (string.Compare("XML", strFeature, StringComparison.OrdinalIgnoreCase) == 0)
			{
				switch (strVersion)
				{
				case null:
				case "1.0":
				case "2.0":
					return true;
				}
			}
			return false;
		}

		public virtual XmlDocument CreateDocument()
		{
			return new XmlDocument(this);
		}
	}
	internal class XmlLoader
	{
		private XmlDocument doc;

		private XmlReader reader;

		private bool preserveWhitespace;

		internal void Load(XmlDocument doc, XmlReader reader, bool preserveWhitespace)
		{
			this.doc = doc;
			if (reader.GetType() == typeof(XmlTextReader))
			{
				this.reader = ((XmlTextReader)reader).Impl;
			}
			else
			{
				this.reader = reader;
			}
			this.preserveWhitespace = preserveWhitespace;
			if (doc == null)
			{
				throw new ArgumentException(Res.GetString("Xdom_Load_NoDocument"));
			}
			if (reader == null)
			{
				throw new ArgumentException(Res.GetString("Xdom_Load_NoReader"));
			}
			doc.SetBaseURI(reader.BaseURI);
			if (reader.Settings != null && reader.Settings.ValidationType == ValidationType.Schema)
			{
				doc.Schemas = reader.Settings.Schemas;
			}
			if (this.reader.ReadState == ReadState.Interactive || this.reader.Read())
			{
				LoadDocSequence(doc);
			}
		}

		private void LoadDocSequence(XmlDocument parentDoc)
		{
			XmlNode xmlNode = null;
			while ((xmlNode = LoadNode(skipOverWhitespace: true)) != null)
			{
				parentDoc.AppendChildForLoad(xmlNode, parentDoc);
				if (!reader.Read())
				{
					break;
				}
			}
		}

		internal XmlNode ReadCurrentNode(XmlDocument doc, XmlReader reader)
		{
			this.doc = doc;
			this.reader = reader;
			preserveWhitespace = true;
			if (doc == null)
			{
				throw new ArgumentException(Res.GetString("Xdom_Load_NoDocument"));
			}
			if (reader == null)
			{
				throw new ArgumentException(Res.GetString("Xdom_Load_NoReader"));
			}
			if (reader.ReadState == ReadState.Initial)
			{
				reader.Read();
			}
			if (reader.ReadState == ReadState.Interactive)
			{
				XmlNode xmlNode = LoadNode(skipOverWhitespace: true);
				if (xmlNode.NodeType != XmlNodeType.Attribute)
				{
					reader.Read();
				}
				return xmlNode;
			}
			return null;
		}

		private XmlNode LoadNode(bool skipOverWhitespace)
		{
			XmlReader xmlReader = reader;
			XmlNode xmlNode = null;
			do
			{
				XmlNode xmlNode2 = null;
				switch (xmlReader.NodeType)
				{
				case XmlNodeType.Element:
				{
					bool isEmptyElement = xmlReader.IsEmptyElement;
					XmlElement xmlElement2 = doc.CreateElement(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI);
					xmlElement2.IsEmpty = isEmptyElement;
					if (xmlReader.MoveToFirstAttribute())
					{
						XmlAttributeCollection attributes = xmlElement2.Attributes;
						do
						{
							XmlAttribute node = LoadAttributeNode();
							attributes.Append(node);
						}
						while (xmlReader.MoveToNextAttribute());
						xmlReader.MoveToElement();
					}
					if (!isEmptyElement)
					{
						xmlNode?.AppendChildForLoad(xmlElement2, doc);
						xmlNode = xmlElement2;
						continue;
					}
					IXmlSchemaInfo schemaInfo = xmlReader.SchemaInfo;
					if (schemaInfo != null)
					{
						xmlElement2.XmlName = doc.AddXmlName(xmlElement2.Prefix, xmlElement2.LocalName, xmlElement2.NamespaceURI, schemaInfo);
					}
					xmlNode2 = xmlElement2;
					break;
				}
				case XmlNodeType.EndElement:
				{
					if (xmlNode == null)
					{
						return null;
					}
					IXmlSchemaInfo schemaInfo = xmlReader.SchemaInfo;
					if (schemaInfo != null && xmlNode is XmlElement xmlElement)
					{
						xmlElement.XmlName = doc.AddXmlName(xmlElement.Prefix, xmlElement.LocalName, xmlElement.NamespaceURI, schemaInfo);
					}
					if (xmlNode.ParentNode == null)
					{
						return xmlNode;
					}
					xmlNode = xmlNode.ParentNode;
					continue;
				}
				case XmlNodeType.EntityReference:
					xmlNode2 = LoadEntityReferenceNode(direct: false);
					break;
				case XmlNodeType.EndEntity:
					return null;
				case XmlNodeType.Attribute:
					xmlNode2 = LoadAttributeNode();
					break;
				case XmlNodeType.Text:
					xmlNode2 = doc.CreateTextNode(xmlReader.Value);
					break;
				case XmlNodeType.SignificantWhitespace:
					xmlNode2 = doc.CreateSignificantWhitespace(xmlReader.Value);
					break;
				case XmlNodeType.Whitespace:
					if (preserveWhitespace)
					{
						xmlNode2 = doc.CreateWhitespace(xmlReader.Value);
						break;
					}
					if (xmlNode == null && !skipOverWhitespace)
					{
						return null;
					}
					continue;
				case XmlNodeType.CDATA:
					xmlNode2 = doc.CreateCDataSection(xmlReader.Value);
					break;
				case XmlNodeType.XmlDeclaration:
					xmlNode2 = LoadDeclarationNode();
					break;
				case XmlNodeType.ProcessingInstruction:
					xmlNode2 = doc.CreateProcessingInstruction(xmlReader.Name, xmlReader.Value);
					break;
				case XmlNodeType.Comment:
					xmlNode2 = doc.CreateComment(xmlReader.Value);
					break;
				case XmlNodeType.DocumentType:
					xmlNode2 = LoadDocumentTypeNode();
					break;
				default:
					throw UnexpectedNodeType(xmlReader.NodeType);
				}
				if (xmlNode != null)
				{
					xmlNode.AppendChildForLoad(xmlNode2, doc);
					continue;
				}
				return xmlNode2;
			}
			while (xmlReader.Read());
			if (xmlNode != null)
			{
				while (xmlNode.ParentNode != null)
				{
					xmlNode = xmlNode.ParentNode;
				}
			}
			return xmlNode;
		}

		private XmlAttribute LoadAttributeNode()
		{
			XmlReader xmlReader = reader;
			if (xmlReader.IsDefault)
			{
				return LoadDefaultAttribute();
			}
			XmlAttribute xmlAttribute = doc.CreateAttribute(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI);
			IXmlSchemaInfo schemaInfo = xmlReader.SchemaInfo;
			if (schemaInfo != null)
			{
				xmlAttribute.XmlName = doc.AddAttrXmlName(xmlAttribute.Prefix, xmlAttribute.LocalName, xmlAttribute.NamespaceURI, schemaInfo);
			}
			while (xmlReader.ReadAttributeValue())
			{
				XmlNode xmlNode;
				switch (xmlReader.NodeType)
				{
				case XmlNodeType.Text:
					xmlNode = doc.CreateTextNode(xmlReader.Value);
					break;
				case XmlNodeType.EntityReference:
					xmlNode = doc.CreateEntityReference(xmlReader.LocalName);
					if (xmlReader.CanResolveEntity)
					{
						xmlReader.ResolveEntity();
						LoadAttributeValue(xmlNode, direct: false);
						if (xmlNode.FirstChild == null)
						{
							xmlNode.AppendChildForLoad(doc.CreateTextNode(""), doc);
						}
					}
					break;
				default:
					throw UnexpectedNodeType(xmlReader.NodeType);
				}
				xmlAttribute.AppendChildForLoad(xmlNode, doc);
			}
			return xmlAttribute;
		}

		private XmlAttribute LoadDefaultAttribute()
		{
			XmlReader xmlReader = reader;
			XmlAttribute xmlAttribute = doc.CreateDefaultAttribute(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI);
			IXmlSchemaInfo schemaInfo = xmlReader.SchemaInfo;
			if (schemaInfo != null)
			{
				xmlAttribute.XmlName = doc.AddAttrXmlName(xmlAttribute.Prefix, xmlAttribute.LocalName, xmlAttribute.NamespaceURI, schemaInfo);
			}
			LoadAttributeValue(xmlAttribute, direct: false);
			if (xmlAttribute is XmlUnspecifiedAttribute xmlUnspecifiedAttribute)
			{
				xmlUnspecifiedAttribute.SetSpecified(f: false);
			}
			return xmlAttribute;
		}

		private void LoadAttributeValue(XmlNode parent, bool direct)
		{
			XmlReader xmlReader = reader;
			while (xmlReader.ReadAttributeValue())
			{
				XmlNode xmlNode;
				switch (xmlReader.NodeType)
				{
				case XmlNodeType.Text:
					xmlNode = (direct ? new XmlText(xmlReader.Value, doc) : doc.CreateTextNode(xmlReader.Value));
					break;
				case XmlNodeType.EndEntity:
					return;
				case XmlNodeType.EntityReference:
					xmlNode = (direct ? new XmlEntityReference(reader.LocalName, doc) : doc.CreateEntityReference(reader.LocalName));
					if (xmlReader.CanResolveEntity)
					{
						xmlReader.ResolveEntity();
						LoadAttributeValue(xmlNode, direct);
						if (xmlNode.FirstChild == null)
						{
							xmlNode.AppendChildForLoad(direct ? new XmlText("") : doc.CreateTextNode(""), doc);
						}
					}
					break;
				default:
					throw UnexpectedNodeType(xmlReader.NodeType);
				}
				parent.AppendChildForLoad(xmlNode, doc);
			}
		}

		private XmlEntityReference LoadEntityReferenceNode(bool direct)
		{
			XmlEntityReference xmlEntityReference = (direct ? new XmlEntityReference(reader.Name, doc) : doc.CreateEntityReference(reader.Name));
			if (reader.CanResolveEntity)
			{
				reader.ResolveEntity();
				while (reader.Read() && reader.NodeType != XmlNodeType.EndEntity)
				{
					XmlNode xmlNode = (direct ? LoadNodeDirect() : LoadNode(skipOverWhitespace: false));
					if (xmlNode != null)
					{
						xmlEntityReference.AppendChildForLoad(xmlNode, doc);
					}
				}
				if (xmlEntityReference.LastChild == null)
				{
					xmlEntityReference.AppendChildForLoad(doc.CreateTextNode(""), doc);
				}
			}
			return xmlEntityReference;
		}

		private XmlDeclaration LoadDeclarationNode()
		{
			string version = null;
			string encoding = null;
			string standalone = null;
			while (reader.MoveToNextAttribute())
			{
				switch (reader.Name)
				{
				case "version":
					version = reader.Value;
					break;
				case "encoding":
					encoding = reader.Value;
					break;
				case "standalone":
					standalone = reader.Value;
					break;
				}
			}
			if (version == null)
			{
				ParseXmlDeclarationValue(reader.Value, out version, out encoding, out standalone);
			}
			return doc.CreateXmlDeclaration(version, encoding, standalone);
		}

		private XmlDocumentType LoadDocumentTypeNode()
		{
			string publicId = null;
			string systemId = null;
			string value = reader.Value;
			string localName = reader.LocalName;
			while (reader.MoveToNextAttribute())
			{
				switch (reader.Name)
				{
				case "PUBLIC":
					publicId = reader.Value;
					break;
				case "SYSTEM":
					systemId = reader.Value;
					break;
				}
			}
			XmlDocumentType xmlDocumentType = doc.CreateDocumentType(localName, publicId, systemId, value);
			SchemaInfo dtdSchemaInfo = XmlReader.GetDtdSchemaInfo(reader);
			if (dtdSchemaInfo != null)
			{
				LoadDocumentType(dtdSchemaInfo, xmlDocumentType);
			}
			else
			{
				ParseDocumentType(xmlDocumentType);
			}
			return xmlDocumentType;
		}

		private XmlNode LoadNodeDirect()
		{
			XmlReader xmlReader = reader;
			XmlNode xmlNode = null;
			do
			{
				XmlNode xmlNode2 = null;
				switch (xmlReader.NodeType)
				{
				case XmlNodeType.Element:
				{
					bool isEmptyElement = reader.IsEmptyElement;
					XmlElement xmlElement = new XmlElement(reader.Prefix, reader.LocalName, reader.NamespaceURI, doc);
					xmlElement.IsEmpty = isEmptyElement;
					if (reader.MoveToFirstAttribute())
					{
						XmlAttributeCollection attributes = xmlElement.Attributes;
						do
						{
							XmlAttribute node = LoadAttributeNodeDirect();
							attributes.Append(node);
						}
						while (xmlReader.MoveToNextAttribute());
					}
					if (!isEmptyElement)
					{
						xmlNode.AppendChildForLoad(xmlElement, doc);
						xmlNode = xmlElement;
						continue;
					}
					xmlNode2 = xmlElement;
					break;
				}
				case XmlNodeType.EndElement:
					if (xmlNode.ParentNode == null)
					{
						return xmlNode;
					}
					xmlNode = xmlNode.ParentNode;
					continue;
				case XmlNodeType.EntityReference:
					xmlNode2 = LoadEntityReferenceNode(direct: true);
					break;
				case XmlNodeType.Attribute:
					xmlNode2 = LoadAttributeNodeDirect();
					break;
				case XmlNodeType.SignificantWhitespace:
					xmlNode2 = new XmlSignificantWhitespace(reader.Value, doc);
					break;
				case XmlNodeType.Whitespace:
					if (preserveWhitespace)
					{
						xmlNode2 = new XmlWhitespace(reader.Value, doc);
						break;
					}
					continue;
				case XmlNodeType.Text:
					xmlNode2 = new XmlText(reader.Value, doc);
					break;
				case XmlNodeType.CDATA:
					xmlNode2 = new XmlCDataSection(reader.Value, doc);
					break;
				case XmlNodeType.ProcessingInstruction:
					xmlNode2 = new XmlProcessingInstruction(reader.Name, reader.Value, doc);
					break;
				case XmlNodeType.Comment:
					xmlNode2 = new XmlComment(reader.Value, doc);
					break;
				default:
					throw UnexpectedNodeType(reader.NodeType);
				case XmlNodeType.EndEntity:
					continue;
				}
				if (xmlNode != null)
				{
					xmlNode.AppendChildForLoad(xmlNode2, doc);
					continue;
				}
				return xmlNode2;
			}
			while (xmlReader.Read());
			return null;
		}

		private XmlAttribute LoadAttributeNodeDirect()
		{
			XmlReader xmlReader = reader;
			if (xmlReader.IsDefault)
			{
				XmlUnspecifiedAttribute xmlUnspecifiedAttribute = new XmlUnspecifiedAttribute(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI, doc);
				LoadAttributeValue(xmlUnspecifiedAttribute, direct: true);
				xmlUnspecifiedAttribute.SetSpecified(f: false);
				return xmlUnspecifiedAttribute;
			}
			XmlAttribute xmlAttribute = new XmlAttribute(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI, doc);
			LoadAttributeValue(xmlAttribute, direct: true);
			return xmlAttribute;
		}

		internal void ParseDocumentType(XmlDocumentType dtNode)
		{
			XmlDocument ownerDocument = dtNode.OwnerDocument;
			if (ownerDocument.HasSetResolver)
			{
				ParseDocumentType(dtNode, bUseResolver: true, ownerDocument.GetResolver());
			}
			else
			{
				ParseDocumentType(dtNode, bUseResolver: false, null);
			}
		}

		private void ParseDocumentType(XmlDocumentType dtNode, bool bUseResolver, XmlResolver resolver)
		{
			doc = dtNode.OwnerDocument;
			XmlNameTable nameTable = doc.NameTable;
			XmlNamespaceManager nsManager = new XmlNamespaceManager(nameTable);
			SchemaInfo schInfo = DtdParser.Parse(nameTable, nsManager, dtNode.ParseWithNamespaces, doc.BaseURI, dtNode.Name, dtNode.PublicId, dtNode.SystemId, dtNode.InternalSubset, bUseResolver, resolver);
			LoadDocumentType(schInfo, dtNode);
		}

		private void LoadDocumentType(SchemaInfo schInfo, XmlDocumentType dtNode)
		{
			dtNode.DtdSchemaInfo = schInfo;
			if (schInfo == null)
			{
				return;
			}
			doc.DtdSchemaInfo = schInfo;
			if (schInfo.Notations != null)
			{
				foreach (SchemaNotation value in schInfo.Notations.Values)
				{
					dtNode.Notations.SetNamedItem(new XmlNotation(value.Name.Name, value.Pubid, value.SystemLiteral, doc));
				}
			}
			if (schInfo.GeneralEntities != null)
			{
				foreach (SchemaEntity value2 in schInfo.GeneralEntities.Values)
				{
					XmlEntity xmlEntity = new XmlEntity(value2.Name.Name, value2.Text, value2.Pubid, value2.Url, value2.NData.IsEmpty ? null : value2.NData.Name, doc);
					xmlEntity.SetBaseURI(value2.DeclaredURI);
					dtNode.Entities.SetNamedItem(xmlEntity);
				}
			}
			if (schInfo.ParameterEntities != null)
			{
				foreach (SchemaEntity value3 in schInfo.ParameterEntities.Values)
				{
					XmlEntity xmlEntity2 = new XmlEntity(value3.Name.Name, value3.Text, value3.Pubid, value3.Url, value3.NData.IsEmpty ? null : value3.NData.Name, doc);
					xmlEntity2.SetBaseURI(value3.DeclaredURI);
					dtNode.Entities.SetNamedItem(xmlEntity2);
				}
			}
			doc.Entities = dtNode.Entities;
			IDictionaryEnumerator enumerator4 = schInfo.ElementDecls.GetEnumerator();
			if (enumerator4 == null)
			{
				return;
			}
			enumerator4.Reset();
			while (enumerator4.MoveNext())
			{
				SchemaElementDecl schemaElementDecl = (SchemaElementDecl)enumerator4.Value;
				if (schemaElementDecl.AttDefs == null)
				{
					continue;
				}
				IDictionaryEnumerator enumerator5 = schemaElementDecl.AttDefs.GetEnumerator();
				while (enumerator5.MoveNext())
				{
					SchemaAttDef schemaAttDef = (SchemaAttDef)enumerator5.Value;
					if (schemaAttDef.Datatype.TokenizedType == XmlTokenizedType.ID)
					{
						doc.AddIdInfo(doc.AddXmlName(schemaElementDecl.Prefix, schemaElementDecl.Name.Name, string.Empty, null), doc.AddAttrXmlName(schemaAttDef.Prefix, schemaAttDef.Name.Name, string.Empty, null));
						break;
					}
				}
			}
		}

		private XmlParserContext GetContext(XmlNode node)
		{
			string text = null;
			XmlSpace xmlSpace = XmlSpace.None;
			XmlDocumentType documentType = doc.DocumentType;
			string baseURI = doc.BaseURI;
			Hashtable hashtable = new Hashtable();
			XmlNameTable nameTable = doc.NameTable;
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(nameTable);
			bool flag = false;
			while (node != null && node != doc)
			{
				if (node is XmlElement && ((XmlElement)node).HasAttributes)
				{
					xmlNamespaceManager.PushScope();
					foreach (XmlAttribute attribute in ((XmlElement)node).Attributes)
					{
						if (attribute.Prefix == doc.strXmlns && !hashtable.Contains(attribute.LocalName))
						{
							hashtable.Add(attribute.LocalName, attribute.LocalName);
							xmlNamespaceManager.AddNamespace(attribute.LocalName, attribute.Value);
						}
						else if (!flag && attribute.Prefix.Length == 0 && attribute.LocalName == doc.strXmlns)
						{
							xmlNamespaceManager.AddNamespace(string.Empty, attribute.Value);
							flag = true;
						}
						else if (xmlSpace == XmlSpace.None && attribute.Prefix == doc.strXml && attribute.LocalName == doc.strSpace)
						{
							if (attribute.Value == "default")
							{
								xmlSpace = XmlSpace.Default;
							}
							else if (attribute.Value == "preserve")
							{
								xmlSpace = XmlSpace.Preserve;
							}
						}
						else if (text == null && attribute.Prefix == doc.strXml && attribute.LocalName == doc.strLang)
						{
							text = attribute.Value;
						}
					}
				}
				node = node.ParentNode;
			}
			return new XmlParserContext(nameTable, xmlNamespaceManager, documentType?.Name, documentType?.PublicId, documentType?.SystemId, documentType?.InternalSubset, baseURI, text, xmlSpace);
		}

		internal XmlNamespaceManager ParsePartialContent(XmlNode parentNode, string innerxmltext, XmlNodeType nt)
		{
			doc = parentNode.OwnerDocument;
			XmlParserContext context = GetContext(parentNode);
			reader = CreateInnerXmlReader(innerxmltext, nt, context, doc);
			try
			{
				preserveWhitespace = true;
				bool isLoading = doc.IsLoading;
				doc.IsLoading = true;
				if (nt == XmlNodeType.Entity)
				{
					XmlNode xmlNode = null;
					while (reader.Read() && (xmlNode = LoadNodeDirect()) != null)
					{
						parentNode.AppendChildForLoad(xmlNode, doc);
					}
				}
				else
				{
					XmlNode xmlNode2 = null;
					while (reader.Read() && (xmlNode2 = LoadNode(skipOverWhitespace: true)) != null)
					{
						parentNode.AppendChildForLoad(xmlNode2, doc);
					}
				}
				doc.IsLoading = isLoading;
			}
			finally
			{
				reader.Close();
			}
			return context.NamespaceManager;
		}

		internal void LoadInnerXmlElement(XmlElement node, string innerxmltext)
		{
			XmlNamespaceManager mgr = ParsePartialContent(node, innerxmltext, XmlNodeType.Element);
			if (node.ChildNodes.Count > 0)
			{
				RemoveDuplicateNamespace(node, mgr, fCheckElemAttrs: false);
			}
		}

		internal void LoadInnerXmlAttribute(XmlAttribute node, string innerxmltext)
		{
			ParsePartialContent(node, innerxmltext, XmlNodeType.Attribute);
		}

		private void RemoveDuplicateNamespace(XmlElement elem, XmlNamespaceManager mgr, bool fCheckElemAttrs)
		{
			mgr.PushScope();
			XmlAttributeCollection attributes = elem.Attributes;
			int count = attributes.Count;
			if (fCheckElemAttrs && count > 0)
			{
				for (int num = count - 1; num >= 0; num--)
				{
					XmlAttribute xmlAttribute = attributes[num];
					if (xmlAttribute.Prefix == doc.strXmlns)
					{
						string text = mgr.LookupNamespace(xmlAttribute.LocalName);
						if (text != null)
						{
							if (xmlAttribute.Value == text)
							{
								elem.Attributes.RemoveNodeAt(num);
							}
						}
						else
						{
							mgr.AddNamespace(xmlAttribute.LocalName, xmlAttribute.Value);
						}
					}
					else if (xmlAttribute.Prefix.Length == 0 && xmlAttribute.LocalName == doc.strXmlns)
					{
						string defaultNamespace = mgr.DefaultNamespace;
						if (defaultNamespace != null)
						{
							if (xmlAttribute.Value == defaultNamespace)
							{
								elem.Attributes.RemoveNodeAt(num);
							}
						}
						else
						{
							mgr.AddNamespace(xmlAttribute.LocalName, xmlAttribute.Value);
						}
					}
				}
			}
			for (XmlNode xmlNode = elem.FirstChild; xmlNode != null; xmlNode = xmlNode.NextSibling)
			{
				if (xmlNode is XmlElement elem2)
				{
					RemoveDuplicateNamespace(elem2, mgr, fCheckElemAttrs: true);
				}
			}
			mgr.PopScope();
		}

		private string EntitizeName(string name)
		{
			return "&" + name + ";";
		}

		internal void ExpandEntity(XmlEntity ent)
		{
			ParsePartialContent(ent, EntitizeName(ent.Name), XmlNodeType.Entity);
		}

		internal void ExpandEntityReference(XmlEntityReference eref)
		{
			doc = eref.OwnerDocument;
			bool isLoading = doc.IsLoading;
			doc.IsLoading = true;
			switch (eref.Name)
			{
			case "lt":
				eref.AppendChildForLoad(doc.CreateTextNode("<"), doc);
				doc.IsLoading = isLoading;
				return;
			case "gt":
				eref.AppendChildForLoad(doc.CreateTextNode(">"), doc);
				doc.IsLoading = isLoading;
				return;
			case "amp":
				eref.AppendChildForLoad(doc.CreateTextNode("&"), doc);
				doc.IsLoading = isLoading;
				return;
			case "apos":
				eref.AppendChildForLoad(doc.CreateTextNode("'"), doc);
				doc.IsLoading = isLoading;
				return;
			case "quot":
				eref.AppendChildForLoad(doc.CreateTextNode("\""), doc);
				doc.IsLoading = isLoading;
				return;
			}
			XmlNamedNodeMap entities = doc.Entities;
			foreach (XmlEntity item in entities)
			{
				if (Ref.Equal(item.Name, eref.Name))
				{
					ParsePartialContent(eref, EntitizeName(eref.Name), XmlNodeType.EntityReference);
					return;
				}
			}
			if (!doc.ActualLoadingStatus)
			{
				eref.AppendChildForLoad(doc.CreateTextNode(""), doc);
				doc.IsLoading = isLoading;
				return;
			}
			doc.IsLoading = isLoading;
			throw new XmlException("Xml_UndeclaredParEntity", eref.Name);
		}

		private XmlReader CreateInnerXmlReader(string xmlFragment, XmlNodeType nt, XmlParserContext context, XmlDocument doc)
		{
			XmlNodeType xmlNodeType = nt;
			if (xmlNodeType == XmlNodeType.Entity || xmlNodeType == XmlNodeType.EntityReference)
			{
				xmlNodeType = XmlNodeType.Element;
			}
			XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl(xmlFragment, xmlNodeType, context);
			xmlTextReaderImpl.XmlValidatingReaderCompatibilityMode = true;
			if (doc.HasSetResolver)
			{
				xmlTextReaderImpl.XmlResolver = doc.GetResolver();
			}
			if (!doc.ActualLoadingStatus)
			{
				xmlTextReaderImpl.DisableUndeclaredEntityCheck = true;
			}
			XmlDocumentType documentType = doc.DocumentType;
			if (documentType != null)
			{
				xmlTextReaderImpl.Namespaces = documentType.ParseWithNamespaces;
				if (documentType.DtdSchemaInfo == null)
				{
					SchemaInfo schemaInfo3 = (xmlTextReaderImpl.DtdSchemaInfo = (documentType.DtdSchemaInfo = DtdParser.Parse(xmlTextReaderImpl, context.BaseURI, context.DocTypeName, context.PublicId, context.SystemId, context.InternalSubset)));
				}
				else
				{
					xmlTextReaderImpl.DtdSchemaInfo = documentType.DtdSchemaInfo;
				}
			}
			if (nt == XmlNodeType.Entity || nt == XmlNodeType.EntityReference)
			{
				xmlTextReaderImpl.Read();
				xmlTextReaderImpl.ResolveEntity();
			}
			return xmlTextReaderImpl;
		}

		internal static void ParseXmlDeclarationValue(string strValue, out string version, out string encoding, out string standalone)
		{
			version = null;
			encoding = null;
			standalone = null;
			XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl(strValue, (XmlParserContext)null);
			try
			{
				xmlTextReaderImpl.Read();
				if (xmlTextReaderImpl.MoveToAttribute("version"))
				{
					version = xmlTextReaderImpl.Value;
				}
				if (xmlTextReaderImpl.MoveToAttribute("encoding"))
				{
					encoding = xmlTextReaderImpl.Value;
				}
				if (xmlTextReaderImpl.MoveToAttribute("standalone"))
				{
					standalone = xmlTextReaderImpl.Value;
				}
			}
			finally
			{
				xmlTextReaderImpl.Close();
			}
		}

		internal static Exception UnexpectedNodeType(XmlNodeType nodetype)
		{
			return new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, Res.GetString("Xml_UnexpectedNodeType"), nodetype.ToString()));
		}
	}
	internal class XmlName : IXmlSchemaInfo
	{
		private string prefix;

		private string localName;

		private string ns;

		private string name;

		private int hashCode;

		internal XmlDocument ownerDoc;

		internal XmlName next;

		public string LocalName => localName;

		public string NamespaceURI => ns;

		public string Prefix => prefix;

		public int HashCode => hashCode;

		public XmlDocument OwnerDocument => ownerDoc;

		public string Name
		{
			get
			{
				if (name == null)
				{
					if (prefix.Length > 0)
					{
						if (localName.Length > 0)
						{
							string array = prefix + ":" + localName;
							lock (ownerDoc.NameTable)
							{
								if (name == null)
								{
									name = ownerDoc.NameTable.Add(array);
								}
							}
						}
						else
						{
							name = prefix;
						}
					}
					else
					{
						name = localName;
					}
				}
				return name;
			}
		}

		public virtual XmlSchemaValidity Validity => XmlSchemaValidity.NotKnown;

		public virtual bool IsDefault => false;

		public virtual bool IsNil => false;

		public virtual XmlSchemaSimpleType MemberType => null;

		public virtual XmlSchemaType SchemaType => null;

		public virtual XmlSchemaElement SchemaElement => null;

		public virtual XmlSchemaAttribute SchemaAttribute => null;

		public static XmlName Create(string prefix, string localName, string ns, int hashCode, XmlDocument ownerDoc, XmlName next, IXmlSchemaInfo schemaInfo)
		{
			if (schemaInfo == null)
			{
				return new XmlName(prefix, localName, ns, hashCode, ownerDoc, next);
			}
			return new XmlNameEx(prefix, localName, ns, hashCode, ownerDoc, next, schemaInfo);
		}

		internal XmlName(string prefix, string localName, string ns, int hashCode, XmlDocument ownerDoc, XmlName next)
		{
			this.prefix = prefix;
			this.localName = localName;
			this.ns = ns;
			name = null;
			this.hashCode = hashCode;
			this.ownerDoc = ownerDoc;
			this.next = next;
		}

		public virtual bool Equals(IXmlSchemaInfo schemaInfo)
		{
			return schemaInfo == null;
		}

		public static int GetHashCode(string name)
		{
			int num = 0;
			if (name != null)
			{
				for (int num2 = name.Length - 1; num2 >= 0; num2--)
				{
					char c = name[num2];
					if (c == ':')
					{
						break;
					}
					num += (num << 7) ^ c;
				}
				num -= num >> 17;
				num -= num >> 11;
				num -= num >> 5;
			}
			return num;
		}
	}
	internal sealed class XmlNameEx : XmlName
	{
		private const byte ValidityMask = 3;

		private const byte IsDefaultBit = 4;

		private const byte IsNilBit = 8;

		private byte flags;

		private XmlSchemaSimpleType memberType;

		private XmlSchemaType schemaType;

		private object decl;

		public override XmlSchemaValidity Validity
		{
			get
			{
				if (!ownerDoc.CanReportValidity)
				{
					return XmlSchemaValidity.NotKnown;
				}
				return (XmlSchemaValidity)(flags & 3);
			}
		}

		public override bool IsDefault => (flags & 4) != 0;

		public override bool IsNil => (flags & 8) != 0;

		public override XmlSchemaSimpleType MemberType => memberType;

		public override XmlSchemaType SchemaType => schemaType;

		public override XmlSchemaElement SchemaElement => decl as XmlSchemaElement;

		public override XmlSchemaAttribute SchemaAttribute => decl as XmlSchemaAttribute;

		internal XmlNameEx(string prefix, string localName, string ns, int hashCode, XmlDocument ownerDoc, XmlName next, IXmlSchemaInfo schemaInfo)
			: base(prefix, localName, ns, hashCode, ownerDoc, next)
		{
			SetValidity(schemaInfo.Validity);
			SetIsDefault(schemaInfo.IsDefault);
			SetIsNil(schemaInfo.IsNil);
			memberType = schemaInfo.MemberType;
			schemaType = schemaInfo.SchemaType;
			decl = ((schemaInfo.SchemaElement != null) ? ((XmlSchemaAnnotated)schemaInfo.SchemaElement) : ((XmlSchemaAnnotated)schemaInfo.SchemaAttribute));
		}

		public void SetValidity(XmlSchemaValidity value)
		{
			flags = (byte)((flags & 0xFFFFFFFCu) | (byte)value);
		}

		public void SetIsDefault(bool value)
		{
			if (value)
			{
				flags |= 4;
			}
			else
			{
				flags = (byte)(flags & 0xFFFFFFFBu);
			}
		}

		public void SetIsNil(bool value)
		{
			if (value)
			{
				flags |= 8;
			}
			else
			{
				flags = (byte)(flags & 0xFFFFFFF7u);
			}
		}

		public override bool Equals(IXmlSchemaInfo schemaInfo)
		{
			if (schemaInfo != null && schemaInfo.Validity == (XmlSchemaValidity)(flags & 3) && schemaInfo.IsDefault == ((flags & 4) != 0) && schemaInfo.IsNil == ((flags & 8) != 0) && schemaInfo.MemberType == memberType && schemaInfo.SchemaType == schemaType && schemaInfo.SchemaElement == decl as XmlSchemaElement && schemaInfo.SchemaAttribute == decl as XmlSchemaAttribute)
			{
				return true;
			}
			return false;
		}
	}
	[DebuggerDisplay("{ToString()}")]
	internal struct DebuggerDisplayXmlNodeProxy
	{
		private XmlNode node;

		public DebuggerDisplayXmlNodeProxy(XmlNode node)
		{
			this.node = node;
		}

		public override string ToString()
		{
			XmlNodeType nodeType = node.NodeType;
			string text = nodeType.ToString();
			switch (nodeType)
			{
			case XmlNodeType.Element:
			case XmlNodeType.EntityReference:
				text = text + ", Name=\"" + node.Name + "\"";
				break;
			case XmlNodeType.Attribute:
			case XmlNodeType.ProcessingInstruction:
			{
				string text3 = text;
				text = text3 + ", Name=\"" + node.Name + "\", Value=\"" + XmlConvert.EscapeValueForDebuggerDisplay(node.Value) + "\"";
				break;
			}
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.Comment:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
			case XmlNodeType.XmlDeclaration:
				text = text + ", Value=\"" + XmlConvert.EscapeValueForDebuggerDisplay(node.Value) + "\"";
				break;
			case XmlNodeType.DocumentType:
			{
				XmlDocumentType xmlDocumentType = (XmlDocumentType)node;
				string text2 = text;
				text = text2 + ", Name=\"" + xmlDocumentType.Name + "\", SYSTEM=\"" + xmlDocumentType.SystemId + "\", PUBLIC=\"" + xmlDocumentType.PublicId + "\", Value=\"" + XmlConvert.EscapeValueForDebuggerDisplay(xmlDocumentType.InternalSubset) + "\"";
				break;
			}
			}
			return text;
		}
	}
	public class XmlNodeChangedEventArgs : EventArgs
	{
		private XmlNodeChangedAction action;

		private XmlNode node;

		private XmlNode oldParent;

		private XmlNode newParent;

		private string oldValue;

		private string newValue;

		public XmlNodeChangedAction Action => action;

		public XmlNode Node => node;

		public XmlNode OldParent => oldParent;

		public XmlNode NewParent => newParent;

		public string OldValue => oldValue;

		public string NewValue => newValue;

		public XmlNodeChangedEventArgs(XmlNode node, XmlNode oldParent, XmlNode newParent, string oldValue, string newValue, XmlNodeChangedAction action)
		{
			this.node = node;
			this.oldParent = oldParent;
			this.newParent = newParent;
			this.action = action;
			this.oldValue = oldValue;
			this.newValue = newValue;
		}
	}
	public delegate void XmlNodeChangedEventHandler(object sender, XmlNodeChangedEventArgs e);
	internal class XmlNodeReaderNavigator
	{
		internal struct VirtualAttribute
		{
			internal string name;

			internal string value;

			internal VirtualAttribute(string name, string value)
			{
				this.name = name;
				this.value = value;
			}
		}

		private const string strPublicID = "PUBLIC";

		private const string strSystemID = "SYSTEM";

		private const string strVersion = "version";

		private const string strStandalone = "standalone";

		private const string strEncoding = "encoding";

		private XmlNode curNode;

		private XmlNode elemNode;

		private XmlNode logNode;

		private int attrIndex;

		private int logAttrIndex;

		private XmlNameTable nameTable;

		private XmlDocument doc;

		private int nAttrInd;

		private int nDeclarationAttrCount;

		private int nDocTypeAttrCount;

		private int nLogLevel;

		private int nLogAttrInd;

		private bool bLogOnAttrVal;

		private bool bCreatedOnAttribute;

		internal VirtualAttribute[] decNodeAttributes = new VirtualAttribute[3]
		{
			new VirtualAttribute(null, null),
			new VirtualAttribute(null, null),
			new VirtualAttribute(null, null)
		};

		internal VirtualAttribute[] docTypeNodeAttributes = new VirtualAttribute[2]
		{
			new VirtualAttribute(null, null),
			new VirtualAttribute(null, null)
		};

		private bool bOnAttrVal;

		public XmlNodeType NodeType
		{
			get
			{
				XmlNodeType nodeType = curNode.NodeType;
				if (nAttrInd != -1)
				{
					if (bOnAttrVal)
					{
						return XmlNodeType.Text;
					}
					return XmlNodeType.Attribute;
				}
				return nodeType;
			}
		}

		public string NamespaceURI => curNode.NamespaceURI;

		public string Name
		{
			get
			{
				if (nAttrInd != -1)
				{
					if (bOnAttrVal)
					{
						return string.Empty;
					}
					if (curNode.NodeType == XmlNodeType.XmlDeclaration)
					{
						return decNodeAttributes[nAttrInd].name;
					}
					return docTypeNodeAttributes[nAttrInd].name;
				}
				if (IsLocalNameEmpty(curNode.NodeType))
				{
					return string.Empty;
				}
				return curNode.Name;
			}
		}

		public string LocalName
		{
			get
			{
				if (nAttrInd != -1)
				{
					return Name;
				}
				if (IsLocalNameEmpty(curNode.NodeType))
				{
					return string.Empty;
				}
				return curNode.LocalName;
			}
		}

		internal bool IsOnAttrVal => bOnAttrVal;

		internal XmlNode OwnerElementNode
		{
			get
			{
				if (bCreatedOnAttribute)
				{
					return null;
				}
				return elemNode;
			}
		}

		internal bool CreatedOnAttribute => bCreatedOnAttribute;

		public string Prefix => curNode.Prefix;

		public bool HasValue
		{
			get
			{
				if (nAttrInd != -1)
				{
					return true;
				}
				if (curNode.Value != null || curNode.NodeType == XmlNodeType.DocumentType)
				{
					return true;
				}
				return false;
			}
		}

		public string Value
		{
			get
			{
				string text = null;
				XmlNodeType nodeType = curNode.NodeType;
				if (nAttrInd != -1)
				{
					if (curNode.NodeType == XmlNodeType.XmlDeclaration)
					{
						return decNodeAttributes[nAttrInd].value;
					}
					return docTypeNodeAttributes[nAttrInd].value;
				}
				switch (nodeType)
				{
				case XmlNodeType.DocumentType:
					text = ((XmlDocumentType)curNode).InternalSubset;
					break;
				case XmlNodeType.XmlDeclaration:
				{
					StringBuilder stringBuilder = new StringBuilder(string.Empty);
					if (nDeclarationAttrCount == -1)
					{
						InitDecAttr();
					}
					for (int i = 0; i < nDeclarationAttrCount; i++)
					{
						stringBuilder.Append(decNodeAttributes[i].name + "=\"" + decNodeAttributes[i].value + "\"");
						if (i != nDeclarationAttrCount - 1)
						{
							stringBuilder.Append(" ");
						}
					}
					text = stringBuilder.ToString();
					break;
				}
				default:
					text = curNode.Value;
					break;
				}
				if (text != null)
				{
					return text;
				}
				return string.Empty;
			}
		}

		public string BaseURI => curNode.BaseURI;

		public XmlSpace XmlSpace => curNode.XmlSpace;

		public string XmlLang => curNode.XmlLang;

		public bool IsEmptyElement
		{
			get
			{
				if (curNode.NodeType == XmlNodeType.Element)
				{
					return ((XmlElement)curNode).IsEmpty;
				}
				return false;
			}
		}

		public bool IsDefault
		{
			get
			{
				if (curNode.NodeType == XmlNodeType.Attribute)
				{
					return !((XmlAttribute)curNode).Specified;
				}
				return false;
			}
		}

		public IXmlSchemaInfo SchemaInfo => curNode.SchemaInfo;

		public XmlNameTable NameTable => nameTable;

		public int AttributeCount
		{
			get
			{
				if (bCreatedOnAttribute)
				{
					return 0;
				}
				XmlNodeType nodeType = curNode.NodeType;
				switch (nodeType)
				{
				case XmlNodeType.Element:
					return ((XmlElement)curNode).Attributes.Count;
				default:
					if (!bOnAttrVal || nodeType == XmlNodeType.XmlDeclaration || nodeType == XmlNodeType.DocumentType)
					{
						break;
					}
					goto case XmlNodeType.Attribute;
				case XmlNodeType.Attribute:
					return elemNode.Attributes.Count;
				}
				switch (nodeType)
				{
				case XmlNodeType.XmlDeclaration:
					if (nDeclarationAttrCount != -1)
					{
						return nDeclarationAttrCount;
					}
					InitDecAttr();
					return nDeclarationAttrCount;
				case XmlNodeType.DocumentType:
					if (nDocTypeAttrCount != -1)
					{
						return nDocTypeAttrCount;
					}
					InitDocTypeAttr();
					return nDocTypeAttrCount;
				default:
					return 0;
				}
			}
		}

		private bool IsOnDeclOrDocType
		{
			get
			{
				XmlNodeType nodeType = curNode.NodeType;
				if (nodeType != XmlNodeType.XmlDeclaration)
				{
					return nodeType == XmlNodeType.DocumentType;
				}
				return true;
			}
		}

		public XmlNodeReaderNavigator(XmlNode node)
		{
			curNode = node;
			logNode = node;
			XmlNodeType nodeType = curNode.NodeType;
			if (nodeType == XmlNodeType.Attribute)
			{
				elemNode = null;
				attrIndex = -1;
				bCreatedOnAttribute = true;
			}
			else
			{
				elemNode = node;
				attrIndex = -1;
				bCreatedOnAttribute = false;
			}
			if (nodeType == XmlNodeType.Document)
			{
				doc = (XmlDocument)curNode;
			}
			else
			{
				doc = node.OwnerDocument;
			}
			nameTable = doc.NameTable;
			nAttrInd = -1;
			nDeclarationAttrCount = -1;
			nDocTypeAttrCount = -1;
			bOnAttrVal = false;
			bLogOnAttrVal = false;
		}

		private bool IsLocalNameEmpty(XmlNodeType nt)
		{
			switch (nt)
			{
			case XmlNodeType.None:
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.Comment:
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
			case XmlNodeType.EndElement:
			case XmlNodeType.EndEntity:
				return true;
			case XmlNodeType.Element:
			case XmlNodeType.Attribute:
			case XmlNodeType.EntityReference:
			case XmlNodeType.Entity:
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.DocumentType:
			case XmlNodeType.Notation:
			case XmlNodeType.XmlDeclaration:
				return false;
			default:
				return true;
			}
		}

		private void CheckIndexCondition(int attributeIndex)
		{
			if (attributeIndex < 0 || attributeIndex >= AttributeCount)
			{
				throw new ArgumentOutOfRangeException("attributeIndex");
			}
		}

		private void InitDecAttr()
		{
			int num = 0;
			string version = doc.Version;
			if (version != null && version.Length != 0)
			{
				decNodeAttributes[num].name = "version";
				decNodeAttributes[num].value = version;
				num++;
			}
			version = doc.Encoding;
			if (version != null && version.Length != 0)
			{
				decNodeAttributes[num].name = "encoding";
				decNodeAttributes[num].value = version;
				num++;
			}
			version = doc.Standalone;
			if (version != null && version.Length != 0)
			{
				decNodeAttributes[num].name = "standalone";
				decNodeAttributes[num].value = version;
				num++;
			}
			nDeclarationAttrCount = num;
		}

		public string GetDeclarationAttr(XmlDeclaration decl, string name)
		{
			return name switch
			{
				"version" => decl.Version, 
				"encoding" => decl.Encoding, 
				"standalone" => decl.Standalone, 
				_ => null, 
			};
		}

		public string GetDeclarationAttr(int i)
		{
			if (nDeclarationAttrCount == -1)
			{
				InitDecAttr();
			}
			return decNodeAttributes[i].value;
		}

		public int GetDecAttrInd(string name)
		{
			if (nDeclarationAttrCount == -1)
			{
				InitDecAttr();
			}
			for (int i = 0; i < nDeclarationAttrCount; i++)
			{
				if (decNodeAttributes[i].name == name)
				{
					return i;
				}
			}
			return -1;
		}

		private void InitDocTypeAttr()
		{
			int num = 0;
			XmlDocumentType documentType = doc.DocumentType;
			if (documentType == null)
			{
				nDocTypeAttrCount = 0;
				return;
			}
			string publicId = documentType.PublicId;
			if (publicId != null)
			{
				docTypeNodeAttributes[num].name = "PUBLIC";
				docTypeNodeAttributes[num].value = publicId;
				num++;
			}
			publicId = documentType.SystemId;
			if (publicId != null)
			{
				docTypeNodeAttributes[num].name = "SYSTEM";
				docTypeNodeAttributes[num].value = publicId;
				num++;
			}
			nDocTypeAttrCount = num;
		}

		public string GetDocumentTypeAttr(XmlDocumentType docType, string name)
		{
			if (name == "PUBLIC")
			{
				return docType.PublicId;
			}
			if (name == "SYSTEM")
			{
				return docType.SystemId;
			}
			return null;
		}

		public string GetDocumentTypeAttr(int i)
		{
			if (nDocTypeAttrCount == -1)
			{
				InitDocTypeAttr();
			}
			return docTypeNodeAttributes[i].value;
		}

		public int GetDocTypeAttrInd(string name)
		{
			if (nDocTypeAttrCount == -1)
			{
				InitDocTypeAttr();
			}
			for (int i = 0; i < nDocTypeAttrCount; i++)
			{
				if (docTypeNodeAttributes[i].name == name)
				{
					return i;
				}
			}
			return -1;
		}

		private string GetAttributeFromElement(XmlElement elem, string name)
		{
			return elem.GetAttributeNode(name)?.Value;
		}

		public string GetAttribute(string name)
		{
			if (bCreatedOnAttribute)
			{
				return null;
			}
			return curNode.NodeType switch
			{
				XmlNodeType.Element => GetAttributeFromElement((XmlElement)curNode, name), 
				XmlNodeType.Attribute => GetAttributeFromElement((XmlElement)elemNode, name), 
				XmlNodeType.XmlDeclaration => GetDeclarationAttr((XmlDeclaration)curNode, name), 
				XmlNodeType.DocumentType => GetDocumentTypeAttr((XmlDocumentType)curNode, name), 
				_ => null, 
			};
		}

		private string GetAttributeFromElement(XmlElement elem, string name, string ns)
		{
			return elem.GetAttributeNode(name, ns)?.Value;
		}

		public string GetAttribute(string name, string ns)
		{
			if (bCreatedOnAttribute)
			{
				return null;
			}
			switch (curNode.NodeType)
			{
			case XmlNodeType.Element:
				return GetAttributeFromElement((XmlElement)curNode, name, ns);
			case XmlNodeType.Attribute:
				return GetAttributeFromElement((XmlElement)elemNode, name, ns);
			case XmlNodeType.XmlDeclaration:
				if (ns.Length != 0)
				{
					return null;
				}
				return GetDeclarationAttr((XmlDeclaration)curNode, name);
			case XmlNodeType.DocumentType:
				if (ns.Length != 0)
				{
					return null;
				}
				return GetDocumentTypeAttr((XmlDocumentType)curNode, name);
			default:
				return null;
			}
		}

		public string GetAttribute(int attributeIndex)
		{
			if (bCreatedOnAttribute)
			{
				return null;
			}
			switch (curNode.NodeType)
			{
			case XmlNodeType.Element:
				CheckIndexCondition(attributeIndex);
				return ((XmlElement)curNode).Attributes[attributeIndex].Value;
			case XmlNodeType.Attribute:
				CheckIndexCondition(attributeIndex);
				return ((XmlElement)elemNode).Attributes[attributeIndex].Value;
			case XmlNodeType.XmlDeclaration:
				CheckIndexCondition(attributeIndex);
				return GetDeclarationAttr(attributeIndex);
			case XmlNodeType.DocumentType:
				CheckIndexCondition(attributeIndex);
				return GetDocumentTypeAttr(attributeIndex);
			default:
				throw new ArgumentOutOfRangeException("attributeIndex");
			}
		}

		public void LogMove(int level)
		{
			logNode = curNode;
			nLogLevel = level;
			nLogAttrInd = nAttrInd;
			logAttrIndex = attrIndex;
			bLogOnAttrVal = bOnAttrVal;
		}

		public void RollBackMove(ref int level)
		{
			curNode = logNode;
			level = nLogLevel;
			nAttrInd = nLogAttrInd;
			attrIndex = logAttrIndex;
			bOnAttrVal = bLogOnAttrVal;
		}

		public void ResetToAttribute(ref int level)
		{
			if (bCreatedOnAttribute || !bOnAttrVal)
			{
				return;
			}
			if (IsOnDeclOrDocType)
			{
				level -= 2;
			}
			else
			{
				while (curNode.NodeType != XmlNodeType.Attribute && (curNode = curNode.ParentNode) != null)
				{
					level--;
				}
			}
			bOnAttrVal = false;
		}

		public void ResetMove(ref int level, ref XmlNodeType nt)
		{
			LogMove(level);
			if (bCreatedOnAttribute)
			{
				return;
			}
			if (nAttrInd != -1)
			{
				if (bOnAttrVal)
				{
					level--;
					bOnAttrVal = false;
				}
				nLogAttrInd = nAttrInd;
				level--;
				nAttrInd = -1;
				nt = curNode.NodeType;
				return;
			}
			if (bOnAttrVal && curNode.NodeType != XmlNodeType.Attribute)
			{
				ResetToAttribute(ref level);
			}
			if (curNode.NodeType == XmlNodeType.Attribute)
			{
				curNode = ((XmlAttribute)curNode).OwnerElement;
				attrIndex = -1;
				level--;
				nt = XmlNodeType.Element;
			}
			if (curNode.NodeType == XmlNodeType.Element)
			{
				elemNode = curNode;
			}
		}

		public bool MoveToAttribute(string name)
		{
			return MoveToAttribute(name, string.Empty);
		}

		private bool MoveToAttributeFromElement(XmlElement elem, string name, string ns)
		{
			XmlAttribute xmlAttribute = null;
			xmlAttribute = ((ns.Length != 0) ? elem.GetAttributeNode(name, ns) : elem.GetAttributeNode(name));
			if (xmlAttribute != null)
			{
				bOnAttrVal = false;
				elemNode = elem;
				curNode = xmlAttribute;
				attrIndex = elem.Attributes.FindNodeOffsetNS(xmlAttribute);
				if (attrIndex != -1)
				{
					return true;
				}
			}
			return false;
		}

		public bool MoveToAttribute(string name, string namespaceURI)
		{
			if (bCreatedOnAttribute)
			{
				return false;
			}
			XmlNodeType nodeType = curNode.NodeType;
			if (nodeType == XmlNodeType.Element)
			{
				return MoveToAttributeFromElement((XmlElement)curNode, name, namespaceURI);
			}
			if (nodeType == XmlNodeType.Attribute)
			{
				return MoveToAttributeFromElement((XmlElement)elemNode, name, namespaceURI);
			}
			if (nodeType == XmlNodeType.XmlDeclaration && namespaceURI.Length == 0)
			{
				if ((nAttrInd = GetDecAttrInd(name)) != -1)
				{
					bOnAttrVal = false;
					return true;
				}
			}
			else if (nodeType == XmlNodeType.DocumentType && namespaceURI.Length == 0 && (nAttrInd = GetDocTypeAttrInd(name)) != -1)
			{
				bOnAttrVal = false;
				return true;
			}
			return false;
		}

		public void MoveToAttribute(int attributeIndex)
		{
			if (bCreatedOnAttribute)
			{
				return;
			}
			XmlAttribute xmlAttribute = null;
			switch (curNode.NodeType)
			{
			case XmlNodeType.Element:
				CheckIndexCondition(attributeIndex);
				xmlAttribute = ((XmlElement)curNode).Attributes[attributeIndex];
				if (xmlAttribute != null)
				{
					elemNode = curNode;
					curNode = xmlAttribute;
					attrIndex = attributeIndex;
				}
				break;
			case XmlNodeType.Attribute:
				CheckIndexCondition(attributeIndex);
				xmlAttribute = ((XmlElement)elemNode).Attributes[attributeIndex];
				if (xmlAttribute != null)
				{
					curNode = xmlAttribute;
					attrIndex = attributeIndex;
				}
				break;
			case XmlNodeType.DocumentType:
			case XmlNodeType.XmlDeclaration:
				CheckIndexCondition(attributeIndex);
				nAttrInd = attributeIndex;
				break;
			}
		}

		public bool MoveToNextAttribute(ref int level)
		{
			if (bCreatedOnAttribute)
			{
				return false;
			}
			switch (curNode.NodeType)
			{
			case XmlNodeType.Attribute:
				if (attrIndex >= elemNode.Attributes.Count - 1)
				{
					return false;
				}
				curNode = elemNode.Attributes[++attrIndex];
				return true;
			case XmlNodeType.Element:
				if (curNode.Attributes.Count > 0)
				{
					level++;
					elemNode = curNode;
					curNode = curNode.Attributes[0];
					attrIndex = 0;
					return true;
				}
				break;
			case XmlNodeType.XmlDeclaration:
				if (nDeclarationAttrCount == -1)
				{
					InitDecAttr();
				}
				nAttrInd++;
				if (nAttrInd < nDeclarationAttrCount)
				{
					if (nAttrInd == 0)
					{
						level++;
					}
					bOnAttrVal = false;
					return true;
				}
				nAttrInd--;
				break;
			case XmlNodeType.DocumentType:
				if (nDocTypeAttrCount == -1)
				{
					InitDocTypeAttr();
				}
				nAttrInd++;
				if (nAttrInd < nDocTypeAttrCount)
				{
					if (nAttrInd == 0)
					{
						level++;
					}
					bOnAttrVal = false;
					return true;
				}
				nAttrInd--;
				break;
			}
			return false;
		}

		public bool MoveToParent()
		{
			XmlNode parentNode = curNode.ParentNode;
			if (parentNode != null)
			{
				curNode = parentNode;
				if (!bOnAttrVal)
				{
					attrIndex = 0;
				}
				return true;
			}
			return false;
		}

		public bool MoveToFirstChild()
		{
			XmlNode firstChild = curNode.FirstChild;
			if (firstChild != null)
			{
				curNode = firstChild;
				if (!bOnAttrVal)
				{
					attrIndex = -1;
				}
				return true;
			}
			return false;
		}

		private bool MoveToNextSibling(XmlNode node)
		{
			XmlNode nextSibling = node.NextSibling;
			if (nextSibling != null)
			{
				curNode = nextSibling;
				if (!bOnAttrVal)
				{
					attrIndex = -1;
				}
				return true;
			}
			return false;
		}

		public bool MoveToNext()
		{
			if (curNode.NodeType != XmlNodeType.Attribute)
			{
				return MoveToNextSibling(curNode);
			}
			return MoveToNextSibling(elemNode);
		}

		public bool MoveToElement()
		{
			if (bCreatedOnAttribute)
			{
				return false;
			}
			switch (curNode.NodeType)
			{
			case XmlNodeType.Attribute:
				if (elemNode != null)
				{
					curNode = elemNode;
					attrIndex = -1;
					return true;
				}
				break;
			case XmlNodeType.DocumentType:
			case XmlNodeType.XmlDeclaration:
				if (nAttrInd != -1)
				{
					nAttrInd = -1;
					return true;
				}
				break;
			}
			return false;
		}

		public string LookupNamespace(string prefix)
		{
			if (bCreatedOnAttribute)
			{
				return null;
			}
			if (prefix == "xmlns")
			{
				return nameTable.Add("http://www.w3.org/2000/xmlns/");
			}
			if (prefix == "xml")
			{
				return nameTable.Add("http://www.w3.org/XML/1998/namespace");
			}
			if (prefix == null)
			{
				prefix = string.Empty;
			}
			string name = ((prefix.Length != 0) ? ("xmlns:" + prefix) : "xmlns");
			XmlNode xmlNode = curNode;
			while (xmlNode != null)
			{
				if (xmlNode.NodeType == XmlNodeType.Element)
				{
					XmlElement xmlElement = (XmlElement)xmlNode;
					if (xmlElement.HasAttributes)
					{
						XmlAttribute attributeNode = xmlElement.GetAttributeNode(name);
						if (attributeNode != null)
						{
							return attributeNode.Value;
						}
					}
				}
				else if (xmlNode.NodeType == XmlNodeType.Attribute)
				{
					xmlNode = ((XmlAttribute)xmlNode).OwnerElement;
					continue;
				}
				xmlNode = xmlNode.ParentNode;
			}
			if (prefix.Length == 0)
			{
				return string.Empty;
			}
			return null;
		}

		internal string DefaultLookupNamespace(string prefix)
		{
			if (!bCreatedOnAttribute)
			{
				if (prefix == "xmlns")
				{
					return nameTable.Add("http://www.w3.org/2000/xmlns/");
				}
				if (prefix == "xml")
				{
					return nameTable.Add("http://www.w3.org/XML/1998/namespace");
				}
				if (prefix == string.Empty)
				{
					return nameTable.Add(string.Empty);
				}
			}
			return null;
		}

		internal string LookupPrefix(string namespaceName)
		{
			if (bCreatedOnAttribute || namespaceName == null)
			{
				return null;
			}
			if (namespaceName == "http://www.w3.org/2000/xmlns/")
			{
				return nameTable.Add("xmlns");
			}
			if (namespaceName == "http://www.w3.org/XML/1998/namespace")
			{
				return nameTable.Add("xml");
			}
			if (namespaceName == string.Empty)
			{
				return string.Empty;
			}
			XmlNode xmlNode = curNode;
			while (xmlNode != null)
			{
				if (xmlNode.NodeType == XmlNodeType.Element)
				{
					XmlElement xmlElement = (XmlElement)xmlNode;
					if (xmlElement.HasAttributes)
					{
						XmlAttributeCollection attributes = xmlElement.Attributes;
						for (int i = 0; i < attributes.Count; i++)
						{
							XmlAttribute xmlAttribute = attributes[i];
							if (!(xmlAttribute.Value == namespaceName))
							{
								continue;
							}
							if (xmlAttribute.Prefix.Length == 0 && xmlAttribute.LocalName == "xmlns")
							{
								if (LookupNamespace(string.Empty) == namespaceName)
								{
									return string.Empty;
								}
							}
							else if (xmlAttribute.Prefix == "xmlns")
							{
								string localName = xmlAttribute.LocalName;
								if (LookupNamespace(localName) == namespaceName)
								{
									return nameTable.Add(localName);
								}
							}
						}
					}
				}
				else if (xmlNode.NodeType == XmlNodeType.Attribute)
				{
					xmlNode = ((XmlAttribute)xmlNode).OwnerElement;
					continue;
				}
				xmlNode = xmlNode.ParentNode;
			}
			return null;
		}

		internal IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			if (bCreatedOnAttribute)
			{
				return dictionary;
			}
			XmlNode xmlNode = curNode;
			while (xmlNode != null)
			{
				if (xmlNode.NodeType == XmlNodeType.Element)
				{
					XmlElement xmlElement = (XmlElement)xmlNode;
					if (xmlElement.HasAttributes)
					{
						XmlAttributeCollection attributes = xmlElement.Attributes;
						for (int i = 0; i < attributes.Count; i++)
						{
							XmlAttribute xmlAttribute = attributes[i];
							if (xmlAttribute.LocalName == "xmlns" && xmlAttribute.Prefix.Length == 0)
							{
								if (!dictionary.ContainsKey(string.Empty))
								{
									dictionary.Add(nameTable.Add(string.Empty), nameTable.Add(xmlAttribute.Value));
								}
							}
							else if (xmlAttribute.Prefix == "xmlns")
							{
								string localName = xmlAttribute.LocalName;
								if (!dictionary.ContainsKey(localName))
								{
									dictionary.Add(nameTable.Add(localName), nameTable.Add(xmlAttribute.Value));
								}
							}
						}
					}
					if (scope == XmlNamespaceScope.Local)
					{
						break;
					}
				}
				else if (xmlNode.NodeType == XmlNodeType.Attribute)
				{
					xmlNode = ((XmlAttribute)xmlNode).OwnerElement;
					continue;
				}
				xmlNode = xmlNode.ParentNode;
			}
			if (scope != XmlNamespaceScope.Local)
			{
				if (dictionary.ContainsKey(string.Empty) && dictionary[string.Empty] == string.Empty)
				{
					dictionary.Remove(string.Empty);
				}
				if (scope == XmlNamespaceScope.All)
				{
					dictionary.Add(nameTable.Add("xml"), nameTable.Add("http://www.w3.org/XML/1998/namespace"));
				}
			}
			return dictionary;
		}

		public bool ReadAttributeValue(ref int level, ref bool bResolveEntity, ref XmlNodeType nt)
		{
			if (nAttrInd != -1)
			{
				if (!bOnAttrVal)
				{
					bOnAttrVal = true;
					level++;
					nt = XmlNodeType.Text;
					return true;
				}
				return false;
			}
			if (curNode.NodeType == XmlNodeType.Attribute)
			{
				XmlNode firstChild = curNode.FirstChild;
				if (firstChild != null)
				{
					curNode = firstChild;
					nt = curNode.NodeType;
					level++;
					bOnAttrVal = true;
					return true;
				}
			}
			else if (bOnAttrVal)
			{
				XmlNode xmlNode = null;
				if (curNode.NodeType == XmlNodeType.EntityReference && bResolveEntity)
				{
					curNode = curNode.FirstChild;
					nt = curNode.NodeType;
					level++;
					bResolveEntity = false;
					return true;
				}
				xmlNode = curNode.NextSibling;
				if (xmlNode == null)
				{
					XmlNode parentNode = curNode.ParentNode;
					if (parentNode != null && parentNode.NodeType == XmlNodeType.EntityReference)
					{
						curNode = parentNode;
						nt = XmlNodeType.EndEntity;
						level--;
						return true;
					}
				}
				if (xmlNode != null)
				{
					curNode = xmlNode;
					nt = curNode.NodeType;
					return true;
				}
				return false;
			}
			return false;
		}
	}
	public class XmlNodeReader : XmlReader, IXmlNamespaceResolver
	{
		private XmlNodeReaderNavigator readerNav;

		private XmlNodeType nodeType;

		private int curDepth;

		private ReadState readState;

		private bool fEOF;

		private bool bResolveEntity;

		private bool bStartFromDocument;

		private bool bInReadBinary;

		private ReadContentAsBinaryHelper readBinaryHelper;

		public override XmlNodeType NodeType
		{
			get
			{
				if (!IsInReadingStates())
				{
					return XmlNodeType.None;
				}
				return nodeType;
			}
		}

		public override string Name
		{
			get
			{
				if (!IsInReadingStates())
				{
					return string.Empty;
				}
				return readerNav.Name;
			}
		}

		public override string LocalName
		{
			get
			{
				if (!IsInReadingStates())
				{
					return string.Empty;
				}
				return readerNav.LocalName;
			}
		}

		public override string NamespaceURI
		{
			get
			{
				if (!IsInReadingStates())
				{
					return string.Empty;
				}
				return readerNav.NamespaceURI;
			}
		}

		public override string Prefix
		{
			get
			{
				if (!IsInReadingStates())
				{
					return string.Empty;
				}
				return readerNav.Prefix;
			}
		}

		public override bool HasValue
		{
			get
			{
				if (!IsInReadingStates())
				{
					return false;
				}
				return readerNav.HasValue;
			}
		}

		public override string Value
		{
			get
			{
				if (!IsInReadingStates())
				{
					return string.Empty;
				}
				return readerNav.Value;
			}
		}

		public override int Depth => curDepth;

		public override string BaseURI => readerNav.BaseURI;

		public override bool CanResolveEntity => true;

		public override bool IsEmptyElement
		{
			get
			{
				if (!IsInReadingStates())
				{
					return false;
				}
				return readerNav.IsEmptyElement;
			}
		}

		public override bool IsDefault
		{
			get
			{
				if (!IsInReadingStates())
				{
					return false;
				}
				return readerNav.IsDefault;
			}
		}

		public override XmlSpace XmlSpace
		{
			get
			{
				if (!IsInReadingStates())
				{
					return XmlSpace.None;
				}
				return readerNav.XmlSpace;
			}
		}

		public override string XmlLang
		{
			get
			{
				if (!IsInReadingStates())
				{
					return string.Empty;
				}
				return readerNav.XmlLang;
			}
		}

		public override IXmlSchemaInfo SchemaInfo
		{
			get
			{
				if (!IsInReadingStates())
				{
					return null;
				}
				return readerNav.SchemaInfo;
			}
		}

		public override int AttributeCount
		{
			get
			{
				if (!IsInReadingStates() || nodeType == XmlNodeType.EndElement)
				{
					return 0;
				}
				return readerNav.AttributeCount;
			}
		}

		public override bool EOF
		{
			get
			{
				if (readState != ReadState.Closed)
				{
					return fEOF;
				}
				return false;
			}
		}

		public override ReadState ReadState => readState;

		public override bool HasAttributes => AttributeCount > 0;

		public override XmlNameTable NameTable => readerNav.NameTable;

		public override bool CanReadBinaryContent => true;

		public XmlNodeReader(XmlNode node)
		{
			Init(node);
		}

		private void Init(XmlNode node)
		{
			readerNav = new XmlNodeReaderNavigator(node);
			curDepth = 0;
			readState = ReadState.Initial;
			fEOF = false;
			nodeType = XmlNodeType.None;
			bResolveEntity = false;
			bStartFromDocument = false;
		}

		internal bool IsInReadingStates()
		{
			return readState == ReadState.Interactive;
		}

		public override string GetAttribute(string name)
		{
			if (!IsInReadingStates())
			{
				return null;
			}
			return readerNav.GetAttribute(name);
		}

		public override string GetAttribute(string name, string namespaceURI)
		{
			if (!IsInReadingStates())
			{
				return null;
			}
			string ns = ((namespaceURI == null) ? string.Empty : namespaceURI);
			return readerNav.GetAttribute(name, ns);
		}

		public override string GetAttribute(int attributeIndex)
		{
			if (!IsInReadingStates())
			{
				throw new ArgumentOutOfRangeException("attributeIndex");
			}
			return readerNav.GetAttribute(attributeIndex);
		}

		public override bool MoveToAttribute(string name)
		{
			if (!IsInReadingStates())
			{
				return false;
			}
			readerNav.ResetMove(ref curDepth, ref nodeType);
			if (readerNav.MoveToAttribute(name))
			{
				curDepth++;
				nodeType = readerNav.NodeType;
				if (bInReadBinary)
				{
					FinishReadBinary();
				}
				return true;
			}
			readerNav.RollBackMove(ref curDepth);
			return false;
		}

		public override bool MoveToAttribute(string name, string namespaceURI)
		{
			if (!IsInReadingStates())
			{
				return false;
			}
			readerNav.ResetMove(ref curDepth, ref nodeType);
			string namespaceURI2 = ((namespaceURI == null) ? string.Empty : namespaceURI);
			if (readerNav.MoveToAttribute(name, namespaceURI2))
			{
				curDepth++;
				nodeType = readerNav.NodeType;
				if (bInReadBinary)
				{
					FinishReadBinary();
				}
				return true;
			}
			readerNav.RollBackMove(ref curDepth);
			return false;
		}

		public override void MoveToAttribute(int attributeIndex)
		{
			if (!IsInReadingStates())
			{
				throw new ArgumentOutOfRangeException("attributeIndex");
			}
			readerNav.ResetMove(ref curDepth, ref nodeType);
			try
			{
				if (AttributeCount <= 0)
				{
					throw new ArgumentOutOfRangeException("attributeIndex");
				}
				readerNav.MoveToAttribute(attributeIndex);
				if (bInReadBinary)
				{
					FinishReadBinary();
				}
			}
			catch
			{
				readerNav.RollBackMove(ref curDepth);
				throw;
			}
			curDepth++;
			nodeType = readerNav.NodeType;
		}

		public override bool MoveToFirstAttribute()
		{
			if (!IsInReadingStates())
			{
				return false;
			}
			readerNav.ResetMove(ref curDepth, ref nodeType);
			if (AttributeCount > 0)
			{
				readerNav.MoveToAttribute(0);
				curDepth++;
				nodeType = readerNav.NodeType;
				if (bInReadBinary)
				{
					FinishReadBinary();
				}
				return true;
			}
			readerNav.RollBackMove(ref curDepth);
			return false;
		}

		public override bool MoveToNextAttribute()
		{
			if (!IsInReadingStates() || nodeType == XmlNodeType.EndElement)
			{
				return false;
			}
			readerNav.LogMove(curDepth);
			readerNav.ResetToAttribute(ref curDepth);
			if (readerNav.MoveToNextAttribute(ref curDepth))
			{
				nodeType = readerNav.NodeType;
				if (bInReadBinary)
				{
					FinishReadBinary();
				}
				return true;
			}
			readerNav.RollBackMove(ref curDepth);
			return false;
		}

		public override bool MoveToElement()
		{
			if (!IsInReadingStates())
			{
				return false;
			}
			readerNav.LogMove(curDepth);
			readerNav.ResetToAttribute(ref curDepth);
			if (readerNav.MoveToElement())
			{
				curDepth--;
				nodeType = readerNav.NodeType;
				if (bInReadBinary)
				{
					FinishReadBinary();
				}
				return true;
			}
			readerNav.RollBackMove(ref curDepth);
			return false;
		}

		public override bool Read()
		{
			return Read(fSkipChildren: false);
		}

		private bool Read(bool fSkipChildren)
		{
			if (fEOF)
			{
				return false;
			}
			if (readState == ReadState.Initial)
			{
				if (readerNav.NodeType == XmlNodeType.Document || readerNav.NodeType == XmlNodeType.DocumentFragment)
				{
					bStartFromDocument = true;
					if (!ReadNextNode(fSkipChildren))
					{
						readState = ReadState.Error;
						return false;
					}
				}
				ReSetReadingMarks();
				readState = ReadState.Interactive;
				nodeType = readerNav.NodeType;
				curDepth = 0;
				return true;
			}
			if (bInReadBinary)
			{
				FinishReadBinary();
			}
			bool flag = false;
			if (readerNav.CreatedOnAttribute)
			{
				return false;
			}
			ReSetReadingMarks();
			if (ReadNextNode(fSkipChildren))
			{
				return true;
			}
			if (readState == ReadState.Initial || readState == ReadState.Interactive)
			{
				readState = ReadState.Error;
			}
			if (readState == ReadState.EndOfFile)
			{
				nodeType = XmlNodeType.None;
			}
			return false;
		}

		private bool ReadNextNode(bool fSkipChildren)
		{
			if (readState != ReadState.Interactive && readState != 0)
			{
				nodeType = XmlNodeType.None;
				return false;
			}
			bool flag = !fSkipChildren;
			XmlNodeType xmlNodeType = readerNav.NodeType;
			if (flag && nodeType != XmlNodeType.EndElement && nodeType != XmlNodeType.EndEntity && (xmlNodeType == XmlNodeType.Element || (xmlNodeType == XmlNodeType.EntityReference && bResolveEntity) || ((readerNav.NodeType == XmlNodeType.Document || readerNav.NodeType == XmlNodeType.DocumentFragment) && readState == ReadState.Initial)))
			{
				if (readerNav.MoveToFirstChild())
				{
					nodeType = readerNav.NodeType;
					curDepth++;
					if (bResolveEntity)
					{
						bResolveEntity = false;
					}
					return true;
				}
				if (readerNav.NodeType == XmlNodeType.Element && !readerNav.IsEmptyElement)
				{
					nodeType = XmlNodeType.EndElement;
					return true;
				}
				return ReadForward(fSkipChildren);
			}
			if (readerNav.NodeType == XmlNodeType.EntityReference && bResolveEntity)
			{
				readerNav.MoveToFirstChild();
				nodeType = readerNav.NodeType;
				curDepth++;
				bResolveEntity = false;
				return true;
			}
			return ReadForward(fSkipChildren);
		}

		private void SetEndOfFile()
		{
			fEOF = true;
			readState = ReadState.EndOfFile;
			nodeType = XmlNodeType.None;
		}

		private bool ReadAtZeroLevel(bool fSkipChildren)
		{
			if (!fSkipChildren && nodeType != XmlNodeType.EndElement && readerNav.NodeType == XmlNodeType.Element && !readerNav.IsEmptyElement)
			{
				nodeType = XmlNodeType.EndElement;
				return true;
			}
			SetEndOfFile();
			return false;
		}

		private bool ReadForward(bool fSkipChildren)
		{
			if (readState == ReadState.Error)
			{
				return false;
			}
			if (!bStartFromDocument && curDepth == 0)
			{
				return ReadAtZeroLevel(fSkipChildren);
			}
			if (readerNav.MoveToNext())
			{
				nodeType = readerNav.NodeType;
				return true;
			}
			if (curDepth == 0)
			{
				return ReadAtZeroLevel(fSkipChildren);
			}
			if (readerNav.MoveToParent())
			{
				if (readerNav.NodeType == XmlNodeType.Element)
				{
					curDepth--;
					nodeType = XmlNodeType.EndElement;
					return true;
				}
				if (readerNav.NodeType == XmlNodeType.EntityReference)
				{
					curDepth--;
					nodeType = XmlNodeType.EndEntity;
					return true;
				}
				return true;
			}
			return false;
		}

		private void ReSetReadingMarks()
		{
			readerNav.ResetMove(ref curDepth, ref nodeType);
		}

		public override void Close()
		{
			readState = ReadState.Closed;
		}

		public override void Skip()
		{
			Read(fSkipChildren: true);
		}

		public override string ReadString()
		{
			if (NodeType == XmlNodeType.EntityReference && bResolveEntity && !Read())
			{
				throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
			}
			return base.ReadString();
		}

		public override string LookupNamespace(string prefix)
		{
			if (!IsInReadingStates())
			{
				return null;
			}
			string text = readerNav.LookupNamespace(prefix);
			if (text != null && text.Length == 0)
			{
				return null;
			}
			return text;
		}

		public override void ResolveEntity()
		{
			if (!IsInReadingStates() || nodeType != XmlNodeType.EntityReference)
			{
				throw new InvalidOperationException(Res.GetString("Xnr_ResolveEntity"));
			}
			bResolveEntity = true;
		}

		public override bool ReadAttributeValue()
		{
			if (!IsInReadingStates())
			{
				return false;
			}
			if (readerNav.ReadAttributeValue(ref curDepth, ref bResolveEntity, ref nodeType))
			{
				bInReadBinary = false;
				return true;
			}
			return false;
		}

		public override int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			if (readState != ReadState.Interactive)
			{
				return 0;
			}
			if (!bInReadBinary)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
			}
			bInReadBinary = false;
			int result = readBinaryHelper.ReadContentAsBase64(buffer, index, count);
			bInReadBinary = true;
			return result;
		}

		public override int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (readState != ReadState.Interactive)
			{
				return 0;
			}
			if (!bInReadBinary)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
			}
			bInReadBinary = false;
			int result = readBinaryHelper.ReadContentAsBinHex(buffer, index, count);
			bInReadBinary = true;
			return result;
		}

		public override int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			if (readState != ReadState.Interactive)
			{
				return 0;
			}
			if (!bInReadBinary)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
			}
			bInReadBinary = false;
			int result = readBinaryHelper.ReadElementContentAsBase64(buffer, index, count);
			bInReadBinary = true;
			return result;
		}

		public override int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (readState != ReadState.Interactive)
			{
				return 0;
			}
			if (!bInReadBinary)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
			}
			bInReadBinary = false;
			int result = readBinaryHelper.ReadElementContentAsBinHex(buffer, index, count);
			bInReadBinary = true;
			return result;
		}

		private void FinishReadBinary()
		{
			bInReadBinary = false;
			readBinaryHelper.Finish();
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return readerNav.GetNamespacesInScope(scope);
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			return readerNav.LookupPrefix(namespaceName);
		}

		string IXmlNamespaceResolver.LookupNamespace(string prefix)
		{
			if (!IsInReadingStates())
			{
				return readerNav.DefaultLookupNamespace(prefix);
			}
			string text = readerNav.LookupNamespace(prefix);
			if (text != null)
			{
				text = readerNav.NameTable.Add(text);
			}
			return text;
		}
	}
	public class XmlNotation : XmlNode
	{
		private string publicId;

		private string systemId;

		private string name;

		public override string Name => name;

		public override string LocalName => name;

		public override XmlNodeType NodeType => XmlNodeType.Notation;

		public override bool IsReadOnly => true;

		public string PublicId => publicId;

		public string SystemId => systemId;

		public override string OuterXml => string.Empty;

		public override string InnerXml
		{
			get
			{
				return string.Empty;
			}
			set
			{
				throw new InvalidOperationException(Res.GetString("Xdom_Set_InnerXml"));
			}
		}

		internal XmlNotation(string name, string publicId, string systemId, XmlDocument doc)
			: base(doc)
		{
			this.name = doc.NameTable.Add(name);
			this.publicId = publicId;
			this.systemId = systemId;
		}

		public override XmlNode CloneNode(bool deep)
		{
			throw new InvalidOperationException(Res.GetString("Xdom_Node_Cloning"));
		}

		public override void WriteTo(XmlWriter w)
		{
		}

		public override void WriteContentTo(XmlWriter w)
		{
		}
	}
	public class XmlProcessingInstruction : XmlLinkedNode
	{
		private string target;

		private string data;

		public override string Name
		{
			get
			{
				if (target != null)
				{
					return target;
				}
				return string.Empty;
			}
		}

		public override string LocalName => Name;

		public override string Value
		{
			get
			{
				return data;
			}
			set
			{
				Data = value;
			}
		}

		public string Target => target;

		public string Data
		{
			get
			{
				return data;
			}
			set
			{
				XmlNode xmlNode = ParentNode;
				XmlNodeChangedEventArgs eventArgs = GetEventArgs(this, xmlNode, xmlNode, data, value, XmlNodeChangedAction.Change);
				if (eventArgs != null)
				{
					BeforeEvent(eventArgs);
				}
				data = value;
				if (eventArgs != null)
				{
					AfterEvent(eventArgs);
				}
			}
		}

		public override string InnerText
		{
			get
			{
				return data;
			}
			set
			{
				Data = value;
			}
		}

		public override XmlNodeType NodeType => XmlNodeType.ProcessingInstruction;

		internal override string XPLocalName => Name;

		internal override XPathNodeType XPNodeType => XPathNodeType.ProcessingInstruction;

		protected internal XmlProcessingInstruction(string target, string data, XmlDocument doc)
			: base(doc)
		{
			this.target = target;
			this.data = data;
		}

		public override XmlNode CloneNode(bool deep)
		{
			return OwnerDocument.CreateProcessingInstruction(target, data);
		}

		public override void WriteTo(XmlWriter w)
		{
			w.WriteProcessingInstruction(target, data);
		}

		public override void WriteContentTo(XmlWriter w)
		{
		}
	}
	public class XmlSignificantWhitespace : XmlCharacterData
	{
		public override string Name => OwnerDocument.strSignificantWhitespaceName;

		public override string LocalName => OwnerDocument.strSignificantWhitespaceName;

		public override XmlNodeType NodeType => XmlNodeType.SignificantWhitespace;

		public override XmlNode ParentNode
		{
			get
			{
				switch (parentNode.NodeType)
				{
				case XmlNodeType.Document:
					return base.ParentNode;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
				{
					XmlNode xmlNode = parentNode.parentNode;
					while (xmlNode.IsText)
					{
						xmlNode = xmlNode.parentNode;
					}
					return xmlNode;
				}
				default:
					return parentNode;
				}
			}
		}

		public override string Value
		{
			get
			{
				return Data;
			}
			set
			{
				if (CheckOnData(value))
				{
					Data = value;
					return;
				}
				throw new ArgumentException(Res.GetString("Xdom_WS_Char"));
			}
		}

		internal override XPathNodeType XPNodeType
		{
			get
			{
				XPathNodeType xnt = XPathNodeType.SignificantWhitespace;
				DecideXPNodeTypeForTextNodes(this, ref xnt);
				return xnt;
			}
		}

		internal override bool IsText => true;

		internal override XmlNode PreviousText
		{
			get
			{
				if (parentNode.IsText)
				{
					return parentNode;
				}
				return null;
			}
		}

		protected internal XmlSignificantWhitespace(string strData, XmlDocument doc)
			: base(strData, doc)
		{
			if (!doc.IsLoading && !CheckOnData(strData))
			{
				throw new ArgumentException(Res.GetString("Xdom_WS_Char"));
			}
		}

		public override XmlNode CloneNode(bool deep)
		{
			return OwnerDocument.CreateSignificantWhitespace(Data);
		}

		public override void WriteTo(XmlWriter w)
		{
			w.WriteString(Data);
		}

		public override void WriteContentTo(XmlWriter w)
		{
		}
	}
	public class XmlText : XmlCharacterData
	{
		public override string Name => OwnerDocument.strTextName;

		public override string LocalName => OwnerDocument.strTextName;

		public override XmlNodeType NodeType => XmlNodeType.Text;

		public override XmlNode ParentNode
		{
			get
			{
				switch (parentNode.NodeType)
				{
				case XmlNodeType.Document:
					return null;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
				{
					XmlNode xmlNode = parentNode.parentNode;
					while (xmlNode.IsText)
					{
						xmlNode = xmlNode.parentNode;
					}
					return xmlNode;
				}
				default:
					return parentNode;
				}
			}
		}

		public override string Value
		{
			get
			{
				return Data;
			}
			set
			{
				Data = value;
				XmlNode xmlNode = parentNode;
				if (xmlNode != null && xmlNode.NodeType == XmlNodeType.Attribute && xmlNode is XmlUnspecifiedAttribute xmlUnspecifiedAttribute && !xmlUnspecifiedAttribute.Specified)
				{
					xmlUnspecifiedAttribute.SetSpecified(f: true);
				}
			}
		}

		internal override XPathNodeType XPNodeType => XPathNodeType.Text;

		internal override bool IsText => true;

		internal override XmlNode PreviousText
		{
			get
			{
				if (parentNode.IsText)
				{
					return parentNode;
				}
				return null;
			}
		}

		internal XmlText(string strData)
			: this(strData, null)
		{
		}

		protected internal XmlText(string strData, XmlDocument doc)
			: base(strData, doc)
		{
		}

		public override XmlNode CloneNode(bool deep)
		{
			return OwnerDocument.CreateTextNode(Data);
		}

		public virtual XmlText SplitText(int offset)
		{
			XmlNode xmlNode = ParentNode;
			int length = Length;
			if (offset > length)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (xmlNode == null)
			{
				throw new InvalidOperationException(Res.GetString("Xdom_TextNode_SplitText"));
			}
			int count = length - offset;
			string text = Substring(offset, count);
			DeleteData(offset, count);
			XmlText xmlText = OwnerDocument.CreateTextNode(text);
			xmlNode.InsertAfter(xmlText, this);
			return xmlText;
		}

		public override void WriteTo(XmlWriter w)
		{
			w.WriteString(Data);
		}

		public override void WriteContentTo(XmlWriter w)
		{
		}
	}
	internal class XmlUnspecifiedAttribute : XmlAttribute
	{
		private bool fSpecified;

		public override bool Specified => fSpecified;

		public override string InnerText
		{
			set
			{
				base.InnerText = value;
				fSpecified = true;
			}
		}

		protected internal XmlUnspecifiedAttribute(string prefix, string localName, string namespaceURI, XmlDocument doc)
			: base(prefix, localName, namespaceURI, doc)
		{
		}

		public override XmlNode CloneNode(bool deep)
		{
			XmlDocument ownerDocument = OwnerDocument;
			XmlUnspecifiedAttribute xmlUnspecifiedAttribute = (XmlUnspecifiedAttribute)ownerDocument.CreateDefaultAttribute(Prefix, LocalName, NamespaceURI);
			xmlUnspecifiedAttribute.CopyChildren(ownerDocument, this, deep: true);
			xmlUnspecifiedAttribute.fSpecified = true;
			return xmlUnspecifiedAttribute;
		}

		public override XmlNode InsertBefore(XmlNode newChild, XmlNode refChild)
		{
			XmlNode result = base.InsertBefore(newChild, refChild);
			fSpecified = true;
			return result;
		}

		public override XmlNode InsertAfter(XmlNode newChild, XmlNode refChild)
		{
			XmlNode result = base.InsertAfter(newChild, refChild);
			fSpecified = true;
			return result;
		}

		public override XmlNode ReplaceChild(XmlNode newChild, XmlNode oldChild)
		{
			XmlNode result = base.ReplaceChild(newChild, oldChild);
			fSpecified = true;
			return result;
		}

		public override XmlNode RemoveChild(XmlNode oldChild)
		{
			XmlNode result = base.RemoveChild(oldChild);
			fSpecified = true;
			return result;
		}

		public override XmlNode AppendChild(XmlNode newChild)
		{
			XmlNode result = base.AppendChild(newChild);
			fSpecified = true;
			return result;
		}

		public override void WriteTo(XmlWriter w)
		{
			if (fSpecified)
			{
				base.WriteTo(w);
			}
		}

		internal void SetSpecified(bool f)
		{
			fSpecified = f;
		}
	}
	public class XmlWhitespace : XmlCharacterData
	{
		public override string Name => OwnerDocument.strNonSignificantWhitespaceName;

		public override string LocalName => OwnerDocument.strNonSignificantWhitespaceName;

		public override XmlNodeType NodeType => XmlNodeType.Whitespace;

		public override XmlNode ParentNode
		{
			get
			{
				switch (parentNode.NodeType)
				{
				case XmlNodeType.Document:
					return base.ParentNode;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
				{
					XmlNode xmlNode = parentNode.parentNode;
					while (xmlNode.IsText)
					{
						xmlNode = xmlNode.parentNode;
					}
					return xmlNode;
				}
				default:
					return parentNode;
				}
			}
		}

		public override string Value
		{
			get
			{
				return Data;
			}
			set
			{
				if (CheckOnData(value))
				{
					Data = value;
					return;
				}
				throw new ArgumentException(Res.GetString("Xdom_WS_Char"));
			}
		}

		internal override XPathNodeType XPNodeType
		{
			get
			{
				XPathNodeType xnt = XPathNodeType.Whitespace;
				DecideXPNodeTypeForTextNodes(this, ref xnt);
				return xnt;
			}
		}

		internal override bool IsText => true;

		internal override XmlNode PreviousText
		{
			get
			{
				if (parentNode.IsText)
				{
					return parentNode;
				}
				return null;
			}
		}

		protected internal XmlWhitespace(string strData, XmlDocument doc)
			: base(strData, doc)
		{
			if (!doc.IsLoading && !CheckOnData(strData))
			{
				throw new ArgumentException(Res.GetString("Xdom_WS_Char"));
			}
		}

		public override XmlNode CloneNode(bool deep)
		{
			return OwnerDocument.CreateWhitespace(Data);
		}

		public override void WriteTo(XmlWriter w)
		{
			w.WriteWhitespace(Data);
		}

		public override void WriteContentTo(XmlWriter w)
		{
		}
	}
	internal class XPathNodeList : XmlNodeList
	{
		private List<XmlNode> list;

		private XPathNodeIterator nodeIterator;

		private bool done;

		private static readonly object[] nullparams = new object[0];

		public override int Count
		{
			get
			{
				if (!done)
				{
					ReadUntil(int.MaxValue);
				}
				return list.Count;
			}
		}

		public XPathNodeList(XPathNodeIterator nodeIterator)
		{
			this.nodeIterator = nodeIterator;
			list = new List<XmlNode>();
			done = false;
		}

		private XmlNode GetNode(XPathNavigator n)
		{
			IHasXmlNode hasXmlNode = (IHasXmlNode)n;
			return hasXmlNode.GetNode();
		}

		internal int ReadUntil(int index)
		{
			int num = list.Count;
			while (!done && num <= index)
			{
				if (nodeIterator.MoveNext())
				{
					XmlNode node = GetNode(nodeIterator.Current);
					if (node != null)
					{
						list.Add(node);
						num++;
					}
					continue;
				}
				done = true;
				break;
			}
			return num;
		}

		public override XmlNode Item(int index)
		{
			if (list.Count <= index)
			{
				ReadUntil(index);
			}
			if (index < 0 || list.Count <= index)
			{
				return null;
			}
			return list[index];
		}

		public override IEnumerator GetEnumerator()
		{
			return new XmlNodeListEnumerator(this);
		}
	}
	internal class XmlNodeListEnumerator : IEnumerator
	{
		private XPathNodeList list;

		private int index;

		private bool valid;

		public object Current
		{
			get
			{
				if (valid)
				{
					return list[index];
				}
				return null;
			}
		}

		public XmlNodeListEnumerator(XPathNodeList list)
		{
			this.list = list;
			index = -1;
			valid = false;
		}

		public void Reset()
		{
			index = -1;
		}

		public bool MoveNext()
		{
			index++;
			int num = list.ReadUntil(index + 1);
			if (num - 1 < index)
			{
				return false;
			}
			valid = list[index] != null;
			return valid;
		}
	}
	internal enum BinXmlToken
	{
		Error = 0,
		NotImpl = -2,
		EOF = -1,
		XmlDecl = 254,
		Encoding = 253,
		DocType = 252,
		System = 251,
		Public = 250,
		Subset = 249,
		Element = 248,
		EndElem = 247,
		Attr = 246,
		EndAttrs = 245,
		PI = 244,
		Comment = 243,
		CData = 242,
		EndCData = 241,
		Name = 240,
		QName = 239,
		XmlText = 237,
		Nest = 236,
		EndNest = 235,
		Extn = 234,
		NmFlush = 233,
		SQL_BIT = 6,
		SQL_TINYINT = 7,
		SQL_SMALLINT = 1,
		SQL_INT = 2,
		SQL_BIGINT = 8,
		SQL_REAL = 3,
		SQL_FLOAT = 4,
		SQL_MONEY = 5,
		SQL_SMALLMONEY = 20,
		SQL_DATETIME = 18,
		SQL_SMALLDATETIME = 19,
		SQL_DECIMAL = 10,
		SQL_NUMERIC = 11,
		SQL_UUID = 9,
		SQL_VARBINARY = 15,
		SQL_BINARY = 12,
		SQL_IMAGE = 23,
		SQL_CHAR = 13,
		SQL_VARCHAR = 16,
		SQL_TEXT = 22,
		SQL_NVARCHAR = 17,
		SQL_NCHAR = 14,
		SQL_NTEXT = 24,
		SQL_UDT = 27,
		XSD_KATMAI_DATE = 127,
		XSD_KATMAI_DATETIME = 126,
		XSD_KATMAI_TIME = 125,
		XSD_KATMAI_DATEOFFSET = 124,
		XSD_KATMAI_DATETIMEOFFSET = 123,
		XSD_KATMAI_TIMEOFFSET = 122,
		XSD_BOOLEAN = 134,
		XSD_TIME = 129,
		XSD_DATETIME = 130,
		XSD_DATE = 131,
		XSD_BINHEX = 132,
		XSD_BASE64 = 133,
		XSD_DECIMAL = 135,
		XSD_BYTE = 136,
		XSD_UNSIGNEDSHORT = 137,
		XSD_UNSIGNEDINT = 138,
		XSD_UNSIGNEDLONG = 139,
		XSD_QNAME = 140
	}
	internal struct BinXmlSqlDecimal
	{
		internal byte m_bLen;

		internal byte m_bPrec;

		internal byte m_bScale;

		internal byte m_bSign;

		internal uint m_data1;

		internal uint m_data2;

		internal uint m_data3;

		internal uint m_data4;

		private static readonly byte NUMERIC_MAX_PRECISION = 38;

		private static readonly byte MaxPrecision = NUMERIC_MAX_PRECISION;

		private static readonly byte MaxScale = NUMERIC_MAX_PRECISION;

		private static readonly int x_cNumeMax = 4;

		private static readonly long x_lInt32Base = 4294967296L;

		private static readonly ulong x_ulInt32Base = 4294967296uL;

		private static readonly ulong x_ulInt32BaseForMod = x_ulInt32Base - 1;

		internal static readonly ulong x_llMax = 9223372036854775807uL;

		private static readonly double DUINT_BASE = x_lInt32Base;

		private static readonly double DUINT_BASE2 = DUINT_BASE * DUINT_BASE;

		private static readonly double DUINT_BASE3 = DUINT_BASE2 * DUINT_BASE;

		private static readonly uint[] x_rgulShiftBase = new uint[9] { 10u, 100u, 1000u, 10000u, 100000u, 1000000u, 10000000u, 100000000u, 1000000000u };

		private static readonly byte[] rgCLenFromPrec = new byte[38]
		{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
			2, 2, 2, 2, 2, 2, 2, 2, 2, 3,
			3, 3, 3, 3, 3, 3, 3, 3, 4, 4,
			4, 4, 4, 4, 4, 4, 4, 4
		};

		public bool IsPositive => m_bSign == 0;

		public BinXmlSqlDecimal(byte[] data, int offset, bool trim)
		{
			switch (data[offset])
			{
			case 7:
				m_bLen = 1;
				break;
			case 11:
				m_bLen = 2;
				break;
			case 15:
				m_bLen = 3;
				break;
			case 19:
				m_bLen = 4;
				break;
			default:
				throw new XmlException("XmlBinary_InvalidSqlDecimal", (string[])null);
			}
			m_bPrec = data[offset + 1];
			m_bScale = data[offset + 2];
			m_bSign = (byte)((data[offset + 3] == 0) ? 1 : 0);
			m_data1 = UIntFromByteArray(data, offset + 4);
			m_data2 = ((m_bLen > 1) ? UIntFromByteArray(data, offset + 8) : 0u);
			m_data3 = ((m_bLen > 2) ? UIntFromByteArray(data, offset + 12) : 0u);
			m_data4 = ((m_bLen > 3) ? UIntFromByteArray(data, offset + 16) : 0u);
			if (m_bLen == 4 && m_data4 == 0)
			{
				m_bLen = 3;
			}
			if (m_bLen == 3 && m_data3 == 0)
			{
				m_bLen = 2;
			}
			if (m_bLen == 2 && m_data2 == 0)
			{
				m_bLen = 1;
			}
			if (trim)
			{
				TrimTrailingZeros();
			}
		}

		public void Write(Stream strm)
		{
			strm.WriteByte((byte)(m_bLen * 4 + 3));
			strm.WriteByte(m_bPrec);
			strm.WriteByte(m_bScale);
			strm.WriteByte((byte)((m_bSign == 0) ? 1 : 0));
			WriteUI4(m_data1, strm);
			if (m_bLen <= 1)
			{
				return;
			}
			WriteUI4(m_data2, strm);
			if (m_bLen > 2)
			{
				WriteUI4(m_data3, strm);
				if (m_bLen > 3)
				{
					WriteUI4(m_data4, strm);
				}
			}
		}

		private void WriteUI4(uint val, Stream strm)
		{
			strm.WriteByte((byte)(val & 0xFFu));
			strm.WriteByte((byte)((val >> 8) & 0xFFu));
			strm.WriteByte((byte)((val >> 16) & 0xFFu));
			strm.WriteByte((byte)((val >> 24) & 0xFFu));
		}

		private static uint UIntFromByteArray(byte[] data, int offset)
		{
			int num = data[offset];
			num |= data[offset + 1] << 8;
			num |= data[offset + 2] << 16;
			return (uint)(num | (data[offset + 3] << 24));
		}

		private bool FZero()
		{
			if (m_data1 == 0)
			{
				return m_bLen <= 1;
			}
			return false;
		}

		private void StoreFromWorkingArray(uint[] rguiData)
		{
			m_data1 = rguiData[0];
			m_data2 = rguiData[1];
			m_data3 = rguiData[2];
			m_data4 = rguiData[3];
		}

		private bool FGt10_38(uint[] rglData)
		{
			if ((long)rglData[3] >= 1262177448L)
			{
				if ((long)rglData[3] <= 1262177448L && (long)rglData[2] <= 1518781562L)
				{
					if ((ulong)rglData[2] == 1518781562)
					{
						return (long)rglData[1] >= 160047680L;
					}
					return false;
				}
				return true;
			}
			return false;
		}

		private static void MpDiv1(uint[] rgulU, ref int ciulU, uint iulD, out uint iulR)
		{
			uint num = 0u;
			ulong num2 = iulD;
			int num3 = ciulU;
			while (num3 > 0)
			{
				num3--;
				ulong num4 = ((ulong)num << 32) + rgulU[num3];
				rgulU[num3] = (uint)(num4 / num2);
				num = (uint)(num4 - rgulU[num3] * num2);
			}
			iulR = num;
			MpNormalize(rgulU, ref ciulU);
		}

		private static void MpNormalize(uint[] rgulU, ref int ciulU)
		{
			while (ciulU > 1 && rgulU[ciulU - 1] == 0)
			{
				ciulU--;
			}
		}

		internal void AdjustScale(int digits, bool fRound)
		{
			bool flag = false;
			int num = digits;
			if (num + m_bScale < 0)
			{
				throw new XmlException("SqlTypes_ArithTruncation", (string)null);
			}
			if (num + m_bScale > NUMERIC_MAX_PRECISION)
			{
				throw new XmlException("SqlTypes_ArithOverflow", (string)null);
			}
			byte bScale = (byte)(num + m_bScale);
			byte bPrec = (byte)Math.Min(NUMERIC_MAX_PRECISION, Math.Max(1, num + m_bPrec));
			if (num > 0)
			{
				m_bScale = bScale;
				m_bPrec = bPrec;
				while (num > 0)
				{
					uint uiMultiplier;
					if (num >= 9)
					{
						uiMultiplier = x_rgulShiftBase[8];
						num -= 9;
					}
					else
					{
						uiMultiplier = x_rgulShiftBase[num - 1];
						num = 0;
					}
					MultByULong(uiMultiplier);
				}
			}
			else if (num < 0)
			{
				uint uiMultiplier;
				uint num2;
				do
				{
					if (num <= -9)
					{
						uiMultiplier = x_rgulShiftBase[8];
						num += 9;
					}
					else
					{
						uiMultiplier = x_rgulShiftBase[-num - 1];
						num = 0;
					}
					num2 = DivByULong(uiMultiplier);
				}
				while (num < 0);
				flag = num2 >= uiMultiplier / 2u;
				m_bScale = bScale;
				m_bPrec = bPrec;
			}
			if (flag && fRound)
			{
				AddULong(1u);
			}
			else if (FZero())
			{
				m_bSign = 0;
			}
		}

		private void AddULong(uint ulAdd)
		{
			ulong num = ulAdd;
			int bLen = m_bLen;
			uint[] array = new uint[4] { m_data1, m_data2, m_data3, m_data4 };
			int num2 = 0;
			do
			{
				num += array[num2];
				array[num2] = (uint)num;
				num >>= 32;
				if (0 == num)
				{
					StoreFromWorkingArray(array);
					return;
				}
				num2++;
			}
			while (num2 < bLen);
			if (num2 == x_cNumeMax)
			{
				throw new XmlException("SqlTypes_ArithOverflow", (string)null);
			}
			array[num2] = (uint)num;
			m_bLen++;
			if (FGt10_38(array))
			{
				throw new XmlException("SqlTypes_ArithOverflow", (string)null);
			}
			StoreFromWorkingArray(array);
		}

		private void MultByULong(uint uiMultiplier)
		{
			int bLen = m_bLen;
			ulong num = 0uL;
			ulong num2 = 0uL;
			uint[] array = new uint[4] { m_data1, m_data2, m_data3, m_data4 };
			for (int i = 0; i < bLen; i++)
			{
				ulong num3 = array[i];
				num2 = num3 * uiMultiplier;
				num += num2;
				num2 = ((num >= num2) ? 0 : x_ulInt32Base);
				array[i] = (uint)num;
				num = (num >> 32) + num2;
			}
			if (num != 0)
			{
				if (bLen == x_cNumeMax)
				{
					throw new XmlException("SqlTypes_ArithOverflow", (string)null);
				}
				array[bLen] = (uint)num;
				m_bLen++;
			}
			if (FGt10_38(array))
			{
				throw new XmlException("SqlTypes_ArithOverflow", (string)null);
			}
			StoreFromWorkingArray(array);
		}

		internal uint DivByULong(uint iDivisor)
		{
			ulong num = iDivisor;
			ulong num2 = 0uL;
			uint num3 = 0u;
			bool flag = true;
			if (num == 0)
			{
				throw new XmlException("SqlTypes_DivideByZero", (string)null);
			}
			uint[] array = new uint[4] { m_data1, m_data2, m_data3, m_data4 };
			for (int num4 = m_bLen; num4 > 0; num4--)
			{
				num2 = (num2 << 32) + array[num4 - 1];
				num3 = (array[num4 - 1] = (uint)(num2 / num));
				num2 %= num;
				flag = flag && num3 == 0;
				if (flag)
				{
					m_bLen--;
				}
			}
			StoreFromWorkingArray(array);
			if (flag)
			{
				m_bLen = 1;
			}
			return (uint)num2;
		}

		private static byte CLenFromPrec(byte bPrec)
		{
			return rgCLenFromPrec[bPrec - 1];
		}

		private static char ChFromDigit(uint uiDigit)
		{
			return (char)(uiDigit + 48);
		}

		public decimal ToDecimal()
		{
			if (m_data4 != 0 || m_bScale > 28)
			{
				throw new XmlException("SqlTypes_ArithOverflow", (string)null);
			}
			return new decimal((int)m_data1, (int)m_data2, (int)m_data3, !IsPositive, m_bScale);
		}

		private void TrimTrailingZeros()
		{
			uint[] array = new uint[4] { m_data1, m_data2, m_data3, m_data4 };
			int ciulU = m_bLen;
			if (ciulU == 1 && array[0] == 0)
			{
				m_bScale = 0;
				return;
			}
			while (m_bScale > 0 && (ciulU > 1 || array[0] != 0))
			{
				MpDiv1(array, ref ciulU, 10u, out var iulR);
				if (iulR != 0)
				{
					break;
				}
				m_data1 = array[0];
				m_data2 = array[1];
				m_data3 = array[2];
				m_data4 = array[3];
				m_bScale--;
			}
			if (m_bLen == 4 && m_data4 == 0)
			{
				m_bLen = 3;
			}
			if (m_bLen == 3 && m_data3 == 0)
			{
				m_bLen = 2;
			}
			if (m_bLen == 2 && m_data2 == 0)
			{
				m_bLen = 1;
			}
		}

		public override string ToString()
		{
			uint[] array = new uint[4] { m_data1, m_data2, m_data3, m_data4 };
			int ciulU = m_bLen;
			char[] array2 = new char[NUMERIC_MAX_PRECISION + 1];
			int num = 0;
			while (ciulU > 1 || array[0] != 0)
			{
				MpDiv1(array, ref ciulU, 10u, out var iulR);
				array2[num++] = ChFromDigit(iulR);
			}
			while (num <= m_bScale)
			{
				array2[num++] = ChFromDigit(0u);
			}
			bool isPositive = IsPositive;
			int num2 = (isPositive ? num : (num + 1));
			if (m_bScale > 0)
			{
				num2++;
			}
			char[] array3 = new char[num2];
			int num3 = 0;
			if (!isPositive)
			{
				array3[num3++] = '-';
			}
			while (num > 0)
			{
				if (num-- == m_bScale)
				{
					array3[num3++] = '.';
				}
				array3[num3++] = array2[num];
			}
			return new string(array3);
		}

		[Conditional("DEBUG")]
		private void AssertValid()
		{
			uint[] array = new uint[4] { m_data1, m_data2, m_data3, m_data4 };
			_ = array[m_bLen - 1];
			for (int i = m_bLen; i < x_cNumeMax; i++)
			{
			}
		}
	}
	internal struct BinXmlSqlMoney
	{
		private long data;

		public BinXmlSqlMoney(int v)
		{
			data = v;
		}

		public BinXmlSqlMoney(long v)
		{
			data = v;
		}

		public decimal ToDecimal()
		{
			bool isNegative;
			ulong num;
			if (data < 0)
			{
				isNegative = true;
				num = (ulong)(-data);
			}
			else
			{
				isNegative = false;
				num = (ulong)data;
			}
			return new decimal((int)num, (int)(num >> 32), 0, isNegative, 4);
		}

		public override string ToString()
		{
			return ToDecimal().ToString("#0.00##", CultureInfo.InvariantCulture);
		}
	}
	internal abstract class BinXmlDateTime
	{
		private const int MaxFractionDigits = 7;

		internal static int[] KatmaiTimeScaleMultiplicator = new int[8] { 10000000, 1000000, 100000, 10000, 1000, 100, 10, 1 };

		private static readonly double SQLTicksPerMillisecond = 0.3;

		public static readonly int SQLTicksPerSecond = 300;

		public static readonly int SQLTicksPerMinute = SQLTicksPerSecond * 60;

		public static readonly int SQLTicksPerHour = SQLTicksPerMinute * 60;

		private static readonly int SQLTicksPerDay = SQLTicksPerHour * 24;

		private static void Write2Dig(StringBuilder sb, int val)
		{
			sb.Append((char)(48 + val / 10));
			sb.Append((char)(48 + val % 10));
		}

		private static void Write4DigNeg(StringBuilder sb, int val)
		{
			if (val < 0)
			{
				val = -val;
				sb.Append('-');
			}
			Write2Dig(sb, val / 100);
			Write2Dig(sb, val % 100);
		}

		private static void Write3Dec(StringBuilder sb, int val)
		{
			int num = val % 10;
			val /= 10;
			int num2 = val % 10;
			val /= 10;
			int num3 = val;
			sb.Append('.');
			sb.Append((char)(48 + num3));
			sb.Append((char)(48 + num2));
			sb.Append((char)(48 + num));
		}

		private static void WriteDate(StringBuilder sb, int yr, int mnth, int day)
		{
			Write4DigNeg(sb, yr);
			sb.Append('-');
			Write2Dig(sb, mnth);
			sb.Append('-');
			Write2Dig(sb, day);
		}

		private static void WriteTime(StringBuilder sb, int hr, int min, int sec, int ms)
		{
			Write2Dig(sb, hr);
			sb.Append(':');
			Write2Dig(sb, min);
			sb.Append(':');
			Write2Dig(sb, sec);
			if (ms != 0)
			{
				Write3Dec(sb, ms);
			}
		}

		private static void WriteTimeFullPrecision(StringBuilder sb, int hr, int min, int sec, int fraction)
		{
			Write2Dig(sb, hr);
			sb.Append(':');
			Write2Dig(sb, min);
			sb.Append(':');
			Write2Dig(sb, sec);
			if (fraction != 0)
			{
				int num = 7;
				while (fraction % 10 == 0)
				{
					num--;
					fraction /= 10;
				}
				char[] array = new char[num];
				while (num > 0)
				{
					num--;
					array[num] = (char)(fraction % 10 + 48);
					fraction /= 10;
				}
				sb.Append('.');
				sb.Append(array);
			}
		}

		private static void WriteTimeZone(StringBuilder sb, TimeSpan zone)
		{
			bool negTimeZone = true;
			if (zone.Ticks < 0)
			{
				negTimeZone = false;
				zone = zone.Negate();
			}
			WriteTimeZone(sb, negTimeZone, zone.Hours, zone.Minutes);
		}

		private static void WriteTimeZone(StringBuilder sb, bool negTimeZone, int hr, int min)
		{
			if (hr == 0 && min == 0)
			{
				sb.Append('Z');
				return;
			}
			sb.Append(negTimeZone ? '+' : '-');
			Write2Dig(sb, hr);
			sb.Append(':');
			Write2Dig(sb, min);
		}

		private static void BreakDownXsdDateTime(long val, out int yr, out int mnth, out int day, out int hr, out int min, out int sec, out int ms)
		{
			if (val >= 0)
			{
				long num = val / 4;
				ms = (int)(num % 1000);
				num /= 1000;
				sec = (int)(num % 60);
				num /= 60;
				min = (int)(num % 60);
				num /= 60;
				hr = (int)(num % 24);
				num /= 24;
				day = (int)(num % 31) + 1;
				num /= 31;
				mnth = (int)(num % 12) + 1;
				num /= 12;
				yr = (int)(num - 9999);
				if (yr >= -9999 && yr <= 9999)
				{
					return;
				}
			}
			throw new XmlException("SqlTypes_ArithOverflow", (string)null);
		}

		private static void BreakDownXsdDate(long val, out int yr, out int mnth, out int day, out bool negTimeZone, out int hr, out int min)
		{
			if (val >= 0)
			{
				val /= 4;
				int num = (int)(val % 1740) - 840;
				long num2 = val / 1740;
				if (negTimeZone = num < 0)
				{
					num = -num;
				}
				min = num % 60;
				hr = num / 60;
				day = (int)(num2 % 31) + 1;
				num2 /= 31;
				mnth = (int)(num2 % 12) + 1;
				yr = (int)(num2 / 12) - 9999;
				if (yr >= -9999 && yr <= 9999)
				{
					return;
				}
			}
			throw new XmlException("SqlTypes_ArithOverflow", (string)null);
		}

		private static void BreakDownXsdTime(long val, out int hr, out int min, out int sec, out int ms)
		{
			if (val >= 0)
			{
				val /= 4;
				ms = (int)(val % 1000);
				val /= 1000;
				sec = (int)(val % 60);
				val /= 60;
				min = (int)(val % 60);
				hr = (int)(val / 60);
				if (0 <= hr && hr <= 23)
				{
					return;
				}
			}
			throw new XmlException("SqlTypes_ArithOverflow", (string)null);
		}

		public static string XsdDateTimeToString(long val)
		{
			BreakDownXsdDateTime(val, out var yr, out var mnth, out var day, out var hr, out var min, out var sec, out var ms);
			StringBuilder stringBuilder = new StringBuilder(20);
			WriteDate(stringBuilder, yr, mnth, day);
			stringBuilder.Append('T');
			WriteTime(stringBuilder, hr, min, sec, ms);
			stringBuilder.Append('Z');
			return stringBuilder.ToString();
		}

		public static DateTime XsdDateTimeToDateTime(long val)
		{
			BreakDownXsdDateTime(val, out var yr, out var mnth, out var day, out var hr, out var min, out var sec, out var ms);
			return new DateTime(yr, mnth, day, hr, min, sec, ms, DateTimeKind.Utc);
		}

		public static string XsdDateToString(long val)
		{
			BreakDownXsdDate(val, out var yr, out var mnth, out var day, out var negTimeZone, out var hr, out var min);
			StringBuilder stringBuilder = new StringBuilder(20);
			WriteDate(stringBuilder, yr, mnth, day);
			WriteTimeZone(stringBuilder, negTimeZone, hr, min);
			return stringBuilder.ToString();
		}

		public static DateTime XsdDateToDateTime(long val)
		{
			BreakDownXsdDate(val, out var yr, out var mnth, out var day, out var negTimeZone, out var hr, out var min);
			DateTime dateTime = new DateTime(yr, mnth, day, 0, 0, 0, DateTimeKind.Utc);
			int num = ((!negTimeZone) ? 1 : (-1)) * (hr * 60 + min);
			return TimeZone.CurrentTimeZone.ToLocalTime(dateTime.AddMinutes(num));
		}

		public static string XsdTimeToString(long val)
		{
			BreakDownXsdTime(val, out var hr, out var min, out var sec, out var ms);
			StringBuilder stringBuilder = new StringBuilder(16);
			WriteTime(stringBuilder, hr, min, sec, ms);
			stringBuilder.Append('Z');
			return stringBuilder.ToString();
		}

		public static DateTime XsdTimeToDateTime(long val)
		{
			BreakDownXsdTime(val, out var hr, out var min, out var sec, out var ms);
			return new DateTime(1, 1, 1, hr, min, sec, ms, DateTimeKind.Utc);
		}

		public static string SqlDateTimeToString(int dateticks, uint timeticks)
		{
			DateTime dateTime = SqlDateTimeToDateTime(dateticks, timeticks);
			string text = ((dateTime.Millisecond != 0) ? "yyyy/MM/dd\\THH:mm:ss.ffff" : "yyyy/MM/dd\\THH:mm:ss");
			return dateTime.ToString(text, CultureInfo.InvariantCulture);
		}

		public static DateTime SqlDateTimeToDateTime(int dateticks, uint timeticks)
		{
			DateTime dateTime = new DateTime(1900, 1, 1);
			long num = (long)((double)timeticks / SQLTicksPerMillisecond + 0.5);
			return dateTime.Add(new TimeSpan(dateticks * 864000000000L + num * 10000));
		}

		public static string SqlSmallDateTimeToString(short dateticks, ushort timeticks)
		{
			return SqlSmallDateTimeToDateTime(dateticks, timeticks).ToString("yyyy/MM/dd\\THH:mm:ss", CultureInfo.InvariantCulture);
		}

		public static DateTime SqlSmallDateTimeToDateTime(short dateticks, ushort timeticks)
		{
			return SqlDateTimeToDateTime(dateticks, (uint)(timeticks * SQLTicksPerMinute));
		}

		public static DateTime XsdKatmaiDateToDateTime(byte[] data, int offset)
		{
			long katmaiDateTicks = GetKatmaiDateTicks(data, ref offset);
			return new DateTime(katmaiDateTicks);
		}

		public static DateTime XsdKatmaiDateTimeToDateTime(byte[] data, int offset)
		{
			long katmaiTimeTicks = GetKatmaiTimeTicks(data, ref offset);
			long katmaiDateTicks = GetKatmaiDateTicks(data, ref offset);
			return new DateTime(katmaiDateTicks + katmaiTimeTicks);
		}

		public static DateTime XsdKatmaiTimeToDateTime(byte[] data, int offset)
		{
			return XsdKatmaiDateTimeToDateTime(data, offset);
		}

		public static DateTime XsdKatmaiDateOffsetToDateTime(byte[] data, int offset)
		{
			return XsdKatmaiDateOffsetToDateTimeOffset(data, offset).LocalDateTime;
		}

		public static DateTime XsdKatmaiDateTimeOffsetToDateTime(byte[] data, int offset)
		{
			return XsdKatmaiDateTimeOffsetToDateTimeOffset(data, offset).LocalDateTime;
		}

		public static DateTime XsdKatmaiTimeOffsetToDateTime(byte[] data, int offset)
		{
			return XsdKatmaiTimeOffsetToDateTimeOffset(data, offset).LocalDateTime;
		}

		public static DateTimeOffset XsdKatmaiDateToDateTimeOffset(byte[] data, int offset)
		{
			return XsdKatmaiDateToDateTime(data, offset);
		}

		public static DateTimeOffset XsdKatmaiDateTimeToDateTimeOffset(byte[] data, int offset)
		{
			return XsdKatmaiDateTimeToDateTime(data, offset);
		}

		public static DateTimeOffset XsdKatmaiTimeToDateTimeOffset(byte[] data, int offset)
		{
			return XsdKatmaiTimeToDateTime(data, offset);
		}

		public static DateTimeOffset XsdKatmaiDateOffsetToDateTimeOffset(byte[] data, int offset)
		{
			return XsdKatmaiDateTimeOffsetToDateTimeOffset(data, offset);
		}

		public static DateTimeOffset XsdKatmaiDateTimeOffsetToDateTimeOffset(byte[] data, int offset)
		{
			long katmaiTimeTicks = GetKatmaiTimeTicks(data, ref offset);
			long katmaiDateTicks = GetKatmaiDateTicks(data, ref offset);
			long katmaiTimeZoneTicks = GetKatmaiTimeZoneTicks(data, offset);
			return new DateTimeOffset(katmaiDateTicks + katmaiTimeTicks + katmaiTimeZoneTicks, new TimeSpan(katmaiTimeZoneTicks));
		}

		public static DateTimeOffset XsdKatmaiTimeOffsetToDateTimeOffset(byte[] data, int offset)
		{
			return XsdKatmaiDateTimeOffsetToDateTimeOffset(data, offset);
		}

		public static string XsdKatmaiDateToString(byte[] data, int offset)
		{
			DateTime dateTime = XsdKatmaiDateToDateTime(data, offset);
			StringBuilder stringBuilder = new StringBuilder(10);
			WriteDate(stringBuilder, dateTime.Year, dateTime.Month, dateTime.Day);
			return stringBuilder.ToString();
		}

		public static string XsdKatmaiDateTimeToString(byte[] data, int offset)
		{
			DateTime dt = XsdKatmaiDateTimeToDateTime(data, offset);
			StringBuilder stringBuilder = new StringBuilder(33);
			WriteDate(stringBuilder, dt.Year, dt.Month, dt.Day);
			stringBuilder.Append('T');
			WriteTimeFullPrecision(stringBuilder, dt.Hour, dt.Minute, dt.Second, GetFractions(dt));
			return stringBuilder.ToString();
		}

		public static string XsdKatmaiTimeToString(byte[] data, int offset)
		{
			DateTime dt = XsdKatmaiTimeToDateTime(data, offset);
			StringBuilder stringBuilder = new StringBuilder(16);
			WriteTimeFullPrecision(stringBuilder, dt.Hour, dt.Minute, dt.Second, GetFractions(dt));
			return stringBuilder.ToString();
		}

		public static string XsdKatmaiDateOffsetToString(byte[] data, int offset)
		{
			DateTimeOffset dateTimeOffset = XsdKatmaiDateOffsetToDateTimeOffset(data, offset);
			StringBuilder stringBuilder = new StringBuilder(16);
			WriteDate(stringBuilder, dateTimeOffset.Year, dateTimeOffset.Month, dateTimeOffset.Day);
			WriteTimeZone(stringBuilder, dateTimeOffset.Offset);
			return stringBuilder.ToString();
		}

		public static string XsdKatmaiDateTimeOffsetToString(byte[] data, int offset)
		{
			DateTimeOffset dt = XsdKatmaiDateTimeOffsetToDateTimeOffset(data, offset);
			StringBuilder stringBuilder = new StringBuilder(39);
			WriteDate(stringBuilder, dt.Year, dt.Month, dt.Day);
			stringBuilder.Append('T');
			WriteTimeFullPrecision(stringBuilder, dt.Hour, dt.Minute, dt.Second, GetFractions(dt));
			WriteTimeZone(stringBuilder, dt.Offset);
			return stringBuilder.ToString();
		}

		public static string XsdKatmaiTimeOffsetToString(byte[] data, int offset)
		{
			DateTimeOffset dt = XsdKatmaiTimeOffsetToDateTimeOffset(data, offset);
			StringBuilder stringBuilder = new StringBuilder(22);
			WriteTimeFullPrecision(stringBuilder, dt.Hour, dt.Minute, dt.Second, GetFractions(dt));
			WriteTimeZone(stringBuilder, dt.Offset);
			return stringBuilder.ToString();
		}

		private static long GetKatmaiDateTicks(byte[] data, ref int pos)
		{
			int num = pos;
			pos = num + 3;
			return (data[num] | (data[num + 1] << 8) | (data[num + 2] << 16)) * 864000000000L;
		}

		private static long GetKatmaiTimeTicks(byte[] data, ref int pos)
		{
			int num = pos;
			byte b = data[num];
			num++;
			long num2;
			if (b <= 2)
			{
				num2 = data[num] | (data[num + 1] << 8) | (data[num + 2] << 16);
				pos = num + 3;
			}
			else if (b <= 4)
			{
				num2 = data[num] | (data[num + 1] << 8) | (data[num + 2] << 16);
				num2 |= (long)((ulong)data[num + 3] << 24);
				pos = num + 4;
			}
			else
			{
				if (b > 7)
				{
					throw new XmlException("SqlTypes_ArithOverflow", (string)null);
				}
				num2 = data[num] | (data[num + 1] << 8) | (data[num + 2] << 16);
				num2 |= (long)(((ulong)data[num + 3] << 24) | ((ulong)data[num + 4] << 32));
				pos = num + 5;
			}
			return num2 * KatmaiTimeScaleMultiplicator[b];
		}

		private static long GetKatmaiTimeZoneTicks(byte[] data, int pos)
		{
			return (long)(short)(data[pos] | (data[pos + 1] << 8)) * 600000000L;
		}

		private static int GetFractions(DateTime dt)
		{
			return (int)(dt.Ticks - new DateTime(dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second).Ticks);
		}

		private static int GetFractions(DateTimeOffset dt)
		{
			return (int)(dt.Ticks - new DateTime(dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second).Ticks);
		}
	}
	internal sealed class XmlSqlBinaryReader : XmlReader, IXmlNamespaceResolver
	{
		private enum ScanState
		{
			Doc,
			XmlText,
			Attr,
			AttrVal,
			AttrValPseudoValue,
			Init,
			Error,
			EOF,
			Closed
		}

		internal struct QName
		{
			public string prefix;

			public string localname;

			public string namespaceUri;

			public QName(string prefix, string lname, string nsUri)
			{
				this.prefix = prefix;
				localname = lname;
				namespaceUri = nsUri;
			}

			public void Set(string prefix, string lname, string nsUri)
			{
				this.prefix = prefix;
				localname = lname;
				namespaceUri = nsUri;
			}

			public void Clear()
			{
				prefix = (localname = (namespaceUri = string.Empty));
			}

			public bool MatchNs(string lname, string nsUri)
			{
				if (lname == localname)
				{
					return nsUri == namespaceUri;
				}
				return false;
			}

			public bool MatchPrefix(string prefix, string lname)
			{
				if (lname == localname)
				{
					return prefix == this.prefix;
				}
				return false;
			}

			public void CheckPrefixNS(string prefix, string namespaceUri)
			{
				if (this.prefix == prefix && this.namespaceUri != namespaceUri)
				{
					throw new XmlException("XmlBinary_NoRemapPrefix", new string[3] { prefix, this.namespaceUri, namespaceUri });
				}
			}

			public override int GetHashCode()
			{
				return prefix.GetHashCode() ^ localname.GetHashCode();
			}

			public int GetNSHashCode(SecureStringHasher hasher)
			{
				return hasher.GetHashCode(namespaceUri) ^ hasher.GetHashCode(localname);
			}

			public override bool Equals(object other)
			{
				if (other is QName qName)
				{
					return this == qName;
				}
				return false;
			}

			public override string ToString()
			{
				if (prefix.Length == 0)
				{
					return localname;
				}
				return prefix + ":" + localname;
			}

			public static bool operator ==(QName a, QName b)
			{
				if (a.prefix == b.prefix && a.localname == b.localname)
				{
					return a.namespaceUri == b.namespaceUri;
				}
				return false;
			}

			public static bool operator !=(QName a, QName b)
			{
				return !(a == b);
			}
		}

		private struct ElemInfo
		{
			public QName name;

			public string xmlLang;

			public XmlSpace xmlSpace;

			public bool xmlspacePreserve;

			public NamespaceDecl nsdecls;

			public void Set(QName name, bool xmlspacePreserve)
			{
				this.name = name;
				xmlLang = null;
				xmlSpace = XmlSpace.None;
				this.xmlspacePreserve = xmlspacePreserve;
			}

			public NamespaceDecl Clear()
			{
				NamespaceDecl result = nsdecls;
				nsdecls = null;
				return result;
			}
		}

		private struct AttrInfo
		{
			public QName name;

			public string val;

			public int contentPos;

			public int hashCode;

			public int prevHash;

			public void Set(QName n, string v)
			{
				name = n;
				val = v;
				contentPos = 0;
				hashCode = 0;
				prevHash = 0;
			}

			public void Set(QName n, int pos)
			{
				name = n;
				val = null;
				contentPos = pos;
				hashCode = 0;
				prevHash = 0;
			}

			public void GetLocalnameAndNamespaceUri(out string localname, out string namespaceUri)
			{
				localname = name.localname;
				namespaceUri = name.namespaceUri;
			}

			public int GetLocalnameAndNamespaceUriAndHash(SecureStringHasher hasher, out string localname, out string namespaceUri)
			{
				localname = name.localname;
				namespaceUri = name.namespaceUri;
				return hashCode = name.GetNSHashCode(hasher);
			}

			public bool MatchNS(string localname, string namespaceUri)
			{
				return name.MatchNs(localname, namespaceUri);
			}

			public bool MatchHashNS(int hash, string localname, string namespaceUri)
			{
				if (hashCode == hash)
				{
					return name.MatchNs(localname, namespaceUri);
				}
				return false;
			}

			public void AdjustPosition(int adj)
			{
				if (contentPos != 0)
				{
					contentPos += adj;
				}
			}
		}

		private class NamespaceDecl
		{
			public string prefix;

			public string uri;

			public NamespaceDecl scopeLink;

			public NamespaceDecl prevLink;

			public int scope;

			public bool implied;

			public NamespaceDecl(string prefix, string nsuri, NamespaceDecl nextInScope, NamespaceDecl prevDecl, int scope, bool implied)
			{
				this.prefix = prefix;
				uri = nsuri;
				scopeLink = nextInScope;
				prevLink = prevDecl;
				this.scope = scope;
				this.implied = implied;
			}
		}

		private struct SymbolTables
		{
			public string[] symtable;

			public int symCount;

			public QName[] qnametable;

			public int qnameCount;

			public void Init()
			{
				symtable = new string[64];
				qnametable = new QName[16];
				symtable[0] = string.Empty;
				symCount = 1;
				qnameCount = 1;
			}
		}

		private class NestedBinXml
		{
			public SymbolTables symbolTables;

			public int docState;

			public NestedBinXml next;

			public NestedBinXml(SymbolTables symbolTables, int docState, NestedBinXml next)
			{
				this.symbolTables = symbolTables;
				this.docState = docState;
				this.next = next;
			}
		}

		internal static readonly Type TypeOfObject = typeof(object);

		internal static readonly Type TypeOfString = typeof(string);

		private static Type[] TokenTypeMap = null;

		private static byte[] XsdKatmaiTimeScaleToValueLengthMap = new byte[8] { 3, 3, 3, 4, 4, 5, 5, 5 };

		private static ReadState[] ScanState2ReadState = new ReadState[9]
		{
			ReadState.Interactive,
			ReadState.Interactive,
			ReadState.Interactive,
			ReadState.Interactive,
			ReadState.Interactive,
			ReadState.Initial,
			ReadState.Error,
			ReadState.EndOfFile,
			ReadState.Closed
		};

		private Stream inStrm;

		private byte[] data;

		private int pos;

		private int mark;

		private int end;

		private long offset;

		private bool eof;

		private bool sniffed;

		private bool isEmpty;

		private int docState;

		private SymbolTables symbolTables;

		private XmlNameTable xnt;

		private bool xntFromSettings;

		private string xml;

		private string xmlns;

		private string nsxmlns;

		private string baseUri;

		private ScanState state;

		private XmlNodeType nodetype;

		private BinXmlToken token;

		private int attrIndex;

		private QName qnameOther;

		private QName qnameElement;

		private XmlNodeType parentNodeType;

		private ElemInfo[] elementStack;

		private int elemDepth;

		private AttrInfo[] attributes;

		private int[] attrHashTbl;

		private int attrCount;

		private int posAfterAttrs;

		private bool xmlspacePreserve;

		private int tokLen;

		private int tokDataPos;

		private bool hasTypedValue;

		private Type valueType;

		private string stringValue;

		private Dictionary<string, NamespaceDecl> namespaces;

		private NestedBinXml prevNameInfo;

		private XmlReader textXmlReader;

		private bool closeInput;

		private bool checkCharacters;

		private bool ignoreWhitespace;

		private bool ignorePIs;

		private bool ignoreComments;

		private bool prohibitDtd;

		private SecureStringHasher hasher;

		private XmlCharType xmlCharType;

		private Encoding unicode;

		private byte version;

		public override XmlReaderSettings Settings
		{
			get
			{
				XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
				if (xntFromSettings)
				{
					xmlReaderSettings.NameTable = xnt;
				}
				switch (docState)
				{
				case 0:
					xmlReaderSettings.ConformanceLevel = ConformanceLevel.Auto;
					break;
				case 9:
					xmlReaderSettings.ConformanceLevel = ConformanceLevel.Fragment;
					break;
				default:
					xmlReaderSettings.ConformanceLevel = ConformanceLevel.Document;
					break;
				}
				xmlReaderSettings.CheckCharacters = checkCharacters;
				xmlReaderSettings.IgnoreWhitespace = ignoreWhitespace;
				xmlReaderSettings.IgnoreProcessingInstructions = ignorePIs;
				xmlReaderSettings.IgnoreComments = ignoreComments;
				xmlReaderSettings.ProhibitDtd = prohibitDtd;
				xmlReaderSettings.CloseInput = closeInput;
				xmlReaderSettings.ReadOnly = true;
				return xmlReaderSettings;
			}
		}

		public override XmlNodeType NodeType => nodetype;

		public override string LocalName => qnameOther.localname;

		public override string NamespaceURI => qnameOther.namespaceUri;

		public override string Prefix => qnameOther.prefix;

		public override bool HasValue
		{
			get
			{
				if (ScanState.XmlText == state)
				{
					return textXmlReader.HasValue;
				}
				return XmlReader.HasValueInternal(nodetype);
			}
		}

		public override string Value
		{
			get
			{
				if (stringValue != null)
				{
					return stringValue;
				}
				switch (state)
				{
				case ScanState.Doc:
					switch (nodetype)
					{
					case XmlNodeType.ProcessingInstruction:
					case XmlNodeType.Comment:
					case XmlNodeType.DocumentType:
						return stringValue = GetString(tokDataPos, tokLen);
					case XmlNodeType.CDATA:
						return stringValue = CDATAValue();
					case XmlNodeType.XmlDeclaration:
						return stringValue = XmlDeclValue();
					case XmlNodeType.Text:
					case XmlNodeType.Whitespace:
					case XmlNodeType.SignificantWhitespace:
						return stringValue = ValueAsString(token);
					}
					break;
				case ScanState.XmlText:
					return textXmlReader.Value;
				case ScanState.Attr:
				case ScanState.AttrValPseudoValue:
					return stringValue = GetAttributeText(attrIndex - 1);
				case ScanState.AttrVal:
					return stringValue = ValueAsString(token);
				}
				return string.Empty;
			}
		}

		public override int Depth
		{
			get
			{
				int num = 0;
				switch (state)
				{
				case ScanState.Doc:
					if (nodetype == XmlNodeType.Element || nodetype == XmlNodeType.EndElement)
					{
						num = -1;
					}
					break;
				case ScanState.XmlText:
					num = textXmlReader.Depth;
					break;
				case ScanState.AttrVal:
				case ScanState.AttrValPseudoValue:
					num = 1;
					break;
				default:
					return 0;
				case ScanState.Attr:
					break;
				}
				return elemDepth + num;
			}
		}

		public override string BaseURI => baseUri;

		public override bool IsEmptyElement
		{
			get
			{
				switch (state)
				{
				case ScanState.Doc:
				case ScanState.XmlText:
					return isEmpty;
				default:
					return false;
				}
			}
		}

		public override XmlSpace XmlSpace
		{
			get
			{
				if (ScanState.XmlText != state)
				{
					for (int num = elemDepth; num >= 0; num--)
					{
						XmlSpace xmlSpace = elementStack[num].xmlSpace;
						if (xmlSpace != 0)
						{
							return xmlSpace;
						}
					}
					return XmlSpace.None;
				}
				return textXmlReader.XmlSpace;
			}
		}

		public override string XmlLang
		{
			get
			{
				if (ScanState.XmlText != state)
				{
					for (int num = elemDepth; num >= 0; num--)
					{
						string xmlLang = elementStack[num].xmlLang;
						if (xmlLang != null)
						{
							return xmlLang;
						}
					}
					return string.Empty;
				}
				return textXmlReader.XmlLang;
			}
		}

		public override Type ValueType => valueType;

		public override int AttributeCount
		{
			get
			{
				switch (state)
				{
				case ScanState.Doc:
				case ScanState.Attr:
				case ScanState.AttrVal:
				case ScanState.AttrValPseudoValue:
					return attrCount;
				case ScanState.XmlText:
					return textXmlReader.AttributeCount;
				default:
					return 0;
				}
			}
		}

		public override bool EOF => state == ScanState.EOF;

		public override XmlNameTable NameTable => xnt;

		public override ReadState ReadState => ScanState2ReadState[(int)state];

		public XmlSqlBinaryReader(Stream stream, byte[] data, int len, string baseUri, bool closeInput, XmlReaderSettings settings)
		{
			unicode = Encoding.Unicode;
			xmlCharType = XmlCharType.Instance;
			xnt = settings.NameTable;
			if (xnt == null)
			{
				xnt = new NameTable();
				xntFromSettings = false;
			}
			else
			{
				xntFromSettings = true;
			}
			xml = xnt.Add("xml");
			xmlns = xnt.Add("xmlns");
			nsxmlns = xnt.Add("http://www.w3.org/2000/xmlns/");
			this.baseUri = baseUri;
			state = ScanState.Init;
			nodetype = XmlNodeType.None;
			token = BinXmlToken.Error;
			elementStack = new ElemInfo[16];
			attributes = new AttrInfo[8];
			attrHashTbl = new int[8];
			symbolTables.Init();
			qnameOther.Clear();
			qnameElement.Clear();
			xmlspacePreserve = false;
			hasher = new SecureStringHasher();
			namespaces = new Dictionary<string, NamespaceDecl>(hasher);
			AddInitNamespace(string.Empty, string.Empty);
			AddInitNamespace(xml, xnt.Add("http://www.w3.org/XML/1998/namespace"));
			AddInitNamespace(xmlns, nsxmlns);
			valueType = TypeOfString;
			inStrm = stream;
			if (data != null)
			{
				this.data = data;
				end = len;
				pos = 2;
				sniffed = true;
			}
			else
			{
				this.data = new byte[4096];
				end = stream.Read(this.data, 0, 4096);
				pos = 0;
				sniffed = false;
			}
			mark = -1;
			eof = 0 == end;
			offset = 0L;
			this.closeInput = closeInput;
			switch (settings.ConformanceLevel)
			{
			case ConformanceLevel.Auto:
				docState = 0;
				break;
			case ConformanceLevel.Fragment:
				docState = 9;
				break;
			case ConformanceLevel.Document:
				docState = 1;
				break;
			}
			checkCharacters = settings.CheckCharacters;
			prohibitDtd = settings.ProhibitDtd;
			ignoreWhitespace = settings.IgnoreWhitespace;
			ignorePIs = settings.IgnoreProcessingInstructions;
			ignoreComments = settings.IgnoreComments;
			if (TokenTypeMap == null)
			{
				GenerateTokenTypeMap();
			}
		}

		public override string GetAttribute(string name, string ns)
		{
			if (ScanState.XmlText == state)
			{
				return textXmlReader.GetAttribute(name, ns);
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (ns == null)
			{
				ns = string.Empty;
			}
			int num = LocateAttribute(name, ns);
			if (-1 == num)
			{
				return null;
			}
			return GetAttribute(num);
		}

		public override string GetAttribute(string name)
		{
			if (ScanState.XmlText == state)
			{
				return textXmlReader.GetAttribute(name);
			}
			int num = LocateAttribute(name);
			if (-1 == num)
			{
				return null;
			}
			return GetAttribute(num);
		}

		public override string GetAttribute(int i)
		{
			if (ScanState.XmlText == state)
			{
				return textXmlReader.GetAttribute(i);
			}
			if (i < 0 || i >= attrCount)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			return GetAttributeText(i);
		}

		public override bool MoveToAttribute(string name, string ns)
		{
			if (ScanState.XmlText == state)
			{
				return UpdateFromTextReader(textXmlReader.MoveToAttribute(name, ns));
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (ns == null)
			{
				ns = string.Empty;
			}
			int num = LocateAttribute(name, ns);
			if (-1 != num && state < ScanState.Init)
			{
				PositionOnAttribute(num + 1);
				return true;
			}
			return false;
		}

		public override bool MoveToAttribute(string name)
		{
			if (ScanState.XmlText == state)
			{
				return UpdateFromTextReader(textXmlReader.MoveToAttribute(name));
			}
			int num = LocateAttribute(name);
			if (-1 != num && state < ScanState.Init)
			{
				PositionOnAttribute(num + 1);
				return true;
			}
			return false;
		}

		public override void MoveToAttribute(int i)
		{
			if (ScanState.XmlText == state)
			{
				textXmlReader.MoveToAttribute(i);
				UpdateFromTextReader(needUpdate: true);
				return;
			}
			if (i < 0 || i >= attrCount)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			PositionOnAttribute(i + 1);
		}

		public override bool MoveToFirstAttribute()
		{
			if (ScanState.XmlText == state)
			{
				return UpdateFromTextReader(textXmlReader.MoveToFirstAttribute());
			}
			if (attrCount == 0)
			{
				return false;
			}
			PositionOnAttribute(1);
			return true;
		}

		public override bool MoveToNextAttribute()
		{
			switch (state)
			{
			case ScanState.Doc:
			case ScanState.Attr:
			case ScanState.AttrVal:
			case ScanState.AttrValPseudoValue:
				if (attrIndex >= attrCount)
				{
					return false;
				}
				PositionOnAttribute(++attrIndex);
				return true;
			case ScanState.XmlText:
				return UpdateFromTextReader(textXmlReader.MoveToNextAttribute());
			default:
				return false;
			}
		}

		public override bool MoveToElement()
		{
			switch (state)
			{
			case ScanState.Attr:
			case ScanState.AttrVal:
			case ScanState.AttrValPseudoValue:
				attrIndex = 0;
				qnameOther = qnameElement;
				if (XmlNodeType.Element == parentNodeType)
				{
					token = BinXmlToken.Element;
				}
				else if (XmlNodeType.XmlDeclaration == parentNodeType)
				{
					token = BinXmlToken.XmlDecl;
				}
				else if (XmlNodeType.DocumentType == parentNodeType)
				{
					token = BinXmlToken.DocType;
				}
				nodetype = parentNodeType;
				state = ScanState.Doc;
				pos = posAfterAttrs;
				stringValue = null;
				return true;
			case ScanState.XmlText:
				return UpdateFromTextReader(textXmlReader.MoveToElement());
			default:
				return false;
			}
		}

		public override bool ReadAttributeValue()
		{
			stringValue = null;
			switch (state)
			{
			case ScanState.Attr:
				if (attributes[attrIndex - 1].val == null)
				{
					pos = attributes[attrIndex - 1].contentPos;
					BinXmlToken binXmlToken = RescanNextToken();
					if (BinXmlToken.Attr == binXmlToken || BinXmlToken.EndAttrs == binXmlToken)
					{
						return false;
					}
					token = binXmlToken;
					ReScanOverValue(binXmlToken);
					valueType = GetValueType(binXmlToken);
					state = ScanState.AttrVal;
				}
				else
				{
					token = BinXmlToken.Error;
					valueType = TypeOfString;
					state = ScanState.AttrValPseudoValue;
				}
				qnameOther.Clear();
				nodetype = XmlNodeType.Text;
				return true;
			case ScanState.AttrVal:
				return false;
			case ScanState.XmlText:
				return UpdateFromTextReader(textXmlReader.ReadAttributeValue());
			default:
				return false;
			}
		}

		public override void Close()
		{
			state = ScanState.Closed;
			nodetype = XmlNodeType.None;
			token = BinXmlToken.Error;
			stringValue = null;
			if (textXmlReader != null)
			{
				textXmlReader.Close();
				textXmlReader = null;
			}
			if (inStrm != null && closeInput)
			{
				inStrm.Close();
			}
			inStrm = null;
			pos = (end = 0);
		}

		public override string LookupNamespace(string prefix)
		{
			if (ScanState.XmlText == state)
			{
				return textXmlReader.LookupNamespace(prefix);
			}
			if (prefix != null && namespaces.TryGetValue(prefix, out var value))
			{
				return value.uri;
			}
			return null;
		}

		public override void ResolveEntity()
		{
			throw new NotSupportedException();
		}

		public override bool Read()
		{
			try
			{
				switch (state)
				{
				case ScanState.Init:
					return ReadInit(skipXmlDecl: false);
				case ScanState.Doc:
					return ReadDoc();
				case ScanState.XmlText:
					if (textXmlReader.Read())
					{
						return UpdateFromTextReader(needUpdate: true);
					}
					state = ScanState.Doc;
					nodetype = XmlNodeType.None;
					isEmpty = false;
					goto case ScanState.Doc;
				case ScanState.Attr:
				case ScanState.AttrVal:
				case ScanState.AttrValPseudoValue:
					MoveToElement();
					goto case ScanState.Doc;
				default:
					return false;
				}
			}
			catch (OverflowException ex)
			{
				state = ScanState.Error;
				throw new XmlException(ex.Message, ex);
			}
			catch
			{
				state = ScanState.Error;
				throw;
			}
		}

		private bool SetupContentAsXXX(string name)
		{
			if (!XmlReader.CanReadContentAs(NodeType))
			{
				throw CreateReadContentAsException(name);
			}
			switch (state)
			{
			case ScanState.Doc:
				if (NodeType == XmlNodeType.EndElement)
				{
					return true;
				}
				if (NodeType == XmlNodeType.ProcessingInstruction || NodeType == XmlNodeType.Comment)
				{
					while (Read() && (NodeType == XmlNodeType.ProcessingInstruction || NodeType == XmlNodeType.Comment))
					{
					}
					if (NodeType == XmlNodeType.EndElement)
					{
						return true;
					}
				}
				if (hasTypedValue)
				{
					return true;
				}
				break;
			case ScanState.Attr:
			{
				pos = attributes[attrIndex - 1].contentPos;
				BinXmlToken binXmlToken = RescanNextToken();
				if (BinXmlToken.Attr != binXmlToken && BinXmlToken.EndAttrs != binXmlToken)
				{
					token = binXmlToken;
					ReScanOverValue(binXmlToken);
					return true;
				}
				break;
			}
			case ScanState.AttrVal:
				return true;
			}
			return false;
		}

		private int FinishContentAsXXX(int origPos)
		{
			if (state == ScanState.Doc)
			{
				if (NodeType != XmlNodeType.Element && NodeType != XmlNodeType.EndElement)
				{
					while (Read())
					{
						switch (NodeType)
						{
						case XmlNodeType.ProcessingInstruction:
						case XmlNodeType.Comment:
							continue;
						default:
							throw ThrowNotSupported("XmlBinary_ListsOfValuesNotSupported");
						case XmlNodeType.Element:
						case XmlNodeType.EndElement:
							break;
						}
						break;
					}
				}
				return pos;
			}
			return origPos;
		}

		public override bool ReadContentAsBoolean()
		{
			int origPos = pos;
			bool flag = false;
			try
			{
				if (SetupContentAsXXX("ReadContentAsBoolean"))
				{
					try
					{
						switch (token)
						{
						case BinXmlToken.XSD_BOOLEAN:
							flag = 0 != data[tokDataPos];
							goto IL_0185;
						case BinXmlToken.SQL_SMALLINT:
						case BinXmlToken.SQL_INT:
						case BinXmlToken.SQL_REAL:
						case BinXmlToken.SQL_FLOAT:
						case BinXmlToken.SQL_MONEY:
						case BinXmlToken.SQL_BIT:
						case BinXmlToken.SQL_TINYINT:
						case BinXmlToken.SQL_BIGINT:
						case BinXmlToken.SQL_UUID:
						case BinXmlToken.SQL_DECIMAL:
						case BinXmlToken.SQL_NUMERIC:
						case BinXmlToken.SQL_BINARY:
						case BinXmlToken.SQL_VARBINARY:
						case BinXmlToken.SQL_DATETIME:
						case BinXmlToken.SQL_SMALLDATETIME:
						case BinXmlToken.SQL_SMALLMONEY:
						case BinXmlToken.SQL_IMAGE:
						case BinXmlToken.SQL_UDT:
						case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATEOFFSET:
						case BinXmlToken.XSD_KATMAI_TIME:
						case BinXmlToken.XSD_KATMAI_DATETIME:
						case BinXmlToken.XSD_KATMAI_DATE:
						case BinXmlToken.XSD_TIME:
						case BinXmlToken.XSD_DATETIME:
						case BinXmlToken.XSD_DATE:
						case BinXmlToken.XSD_BINHEX:
						case BinXmlToken.XSD_BASE64:
						case BinXmlToken.XSD_DECIMAL:
						case BinXmlToken.XSD_BYTE:
						case BinXmlToken.XSD_UNSIGNEDSHORT:
						case BinXmlToken.XSD_UNSIGNEDINT:
						case BinXmlToken.XSD_UNSIGNEDLONG:
						case BinXmlToken.XSD_QNAME:
							throw new InvalidCastException(Res.GetString("XmlBinary_CastNotSupported", token, "Boolean"));
						case BinXmlToken.EndElem:
						case BinXmlToken.Element:
							return XmlConvert.ToBoolean(string.Empty);
						}
					}
					catch (InvalidCastException innerException)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Boolean", innerException, null);
					}
					catch (FormatException innerException2)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Boolean", innerException2, null);
					}
				}
				goto end_IL_0009;
				IL_0185:
				origPos = FinishContentAsXXX(origPos);
				return flag;
				end_IL_0009:;
			}
			finally
			{
				pos = origPos;
			}
			return base.ReadContentAsBoolean();
		}

		public override DateTime ReadContentAsDateTime()
		{
			int origPos = pos;
			try
			{
				DateTime result;
				if (SetupContentAsXXX("ReadContentAsDateTime"))
				{
					try
					{
						switch (token)
						{
						case BinXmlToken.SQL_DATETIME:
						case BinXmlToken.SQL_SMALLDATETIME:
						case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATEOFFSET:
						case BinXmlToken.XSD_KATMAI_TIME:
						case BinXmlToken.XSD_KATMAI_DATETIME:
						case BinXmlToken.XSD_KATMAI_DATE:
						case BinXmlToken.XSD_TIME:
						case BinXmlToken.XSD_DATETIME:
						case BinXmlToken.XSD_DATE:
							result = ValueAsDateTime();
							goto IL_018c;
						case BinXmlToken.SQL_SMALLINT:
						case BinXmlToken.SQL_INT:
						case BinXmlToken.SQL_REAL:
						case BinXmlToken.SQL_FLOAT:
						case BinXmlToken.SQL_MONEY:
						case BinXmlToken.SQL_BIT:
						case BinXmlToken.SQL_TINYINT:
						case BinXmlToken.SQL_BIGINT:
						case BinXmlToken.SQL_UUID:
						case BinXmlToken.SQL_DECIMAL:
						case BinXmlToken.SQL_NUMERIC:
						case BinXmlToken.SQL_BINARY:
						case BinXmlToken.SQL_VARBINARY:
						case BinXmlToken.SQL_SMALLMONEY:
						case BinXmlToken.SQL_IMAGE:
						case BinXmlToken.SQL_UDT:
						case BinXmlToken.XSD_BINHEX:
						case BinXmlToken.XSD_BASE64:
						case BinXmlToken.XSD_BOOLEAN:
						case BinXmlToken.XSD_DECIMAL:
						case BinXmlToken.XSD_BYTE:
						case BinXmlToken.XSD_UNSIGNEDSHORT:
						case BinXmlToken.XSD_UNSIGNEDINT:
						case BinXmlToken.XSD_UNSIGNEDLONG:
						case BinXmlToken.XSD_QNAME:
							throw new InvalidCastException(Res.GetString("XmlBinary_CastNotSupported", token, "DateTime"));
						case BinXmlToken.EndElem:
						case BinXmlToken.Element:
							return XmlConvert.ToDateTime(string.Empty, XmlDateTimeSerializationMode.RoundtripKind);
						}
					}
					catch (InvalidCastException innerException)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "DateTime", innerException, null);
					}
					catch (FormatException innerException2)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "DateTime", innerException2, null);
					}
					catch (OverflowException innerException3)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "DateTime", innerException3, null);
					}
				}
				goto end_IL_0007;
				IL_018c:
				origPos = FinishContentAsXXX(origPos);
				return result;
				end_IL_0007:;
			}
			finally
			{
				pos = origPos;
			}
			return base.ReadContentAsDateTime();
		}

		public override double ReadContentAsDouble()
		{
			int origPos = pos;
			try
			{
				double result;
				if (SetupContentAsXXX("ReadContentAsDouble"))
				{
					try
					{
						switch (token)
						{
						case BinXmlToken.SQL_REAL:
						case BinXmlToken.SQL_FLOAT:
							result = ValueAsDouble();
							goto IL_018b;
						case BinXmlToken.SQL_SMALLINT:
						case BinXmlToken.SQL_INT:
						case BinXmlToken.SQL_MONEY:
						case BinXmlToken.SQL_BIT:
						case BinXmlToken.SQL_TINYINT:
						case BinXmlToken.SQL_BIGINT:
						case BinXmlToken.SQL_UUID:
						case BinXmlToken.SQL_DECIMAL:
						case BinXmlToken.SQL_NUMERIC:
						case BinXmlToken.SQL_BINARY:
						case BinXmlToken.SQL_VARBINARY:
						case BinXmlToken.SQL_DATETIME:
						case BinXmlToken.SQL_SMALLDATETIME:
						case BinXmlToken.SQL_SMALLMONEY:
						case BinXmlToken.SQL_IMAGE:
						case BinXmlToken.SQL_UDT:
						case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATEOFFSET:
						case BinXmlToken.XSD_KATMAI_TIME:
						case BinXmlToken.XSD_KATMAI_DATETIME:
						case BinXmlToken.XSD_KATMAI_DATE:
						case BinXmlToken.XSD_TIME:
						case BinXmlToken.XSD_DATETIME:
						case BinXmlToken.XSD_DATE:
						case BinXmlToken.XSD_BINHEX:
						case BinXmlToken.XSD_BASE64:
						case BinXmlToken.XSD_BOOLEAN:
						case BinXmlToken.XSD_DECIMAL:
						case BinXmlToken.XSD_BYTE:
						case BinXmlToken.XSD_UNSIGNEDSHORT:
						case BinXmlToken.XSD_UNSIGNEDINT:
						case BinXmlToken.XSD_UNSIGNEDLONG:
						case BinXmlToken.XSD_QNAME:
							throw new InvalidCastException(Res.GetString("XmlBinary_CastNotSupported", token, "Double"));
						case BinXmlToken.EndElem:
						case BinXmlToken.Element:
							return XmlConvert.ToDouble(string.Empty);
						}
					}
					catch (InvalidCastException innerException)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Double", innerException, null);
					}
					catch (FormatException innerException2)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Double", innerException2, null);
					}
					catch (OverflowException innerException3)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Double", innerException3, null);
					}
				}
				goto end_IL_0007;
				IL_018b:
				origPos = FinishContentAsXXX(origPos);
				return result;
				end_IL_0007:;
			}
			finally
			{
				pos = origPos;
			}
			return base.ReadContentAsDouble();
		}

		public override float ReadContentAsFloat()
		{
			int origPos = pos;
			try
			{
				float result;
				if (SetupContentAsXXX("ReadContentAsFloat"))
				{
					try
					{
						switch (token)
						{
						case BinXmlToken.SQL_REAL:
						case BinXmlToken.SQL_FLOAT:
							result = (float)ValueAsDouble();
							goto IL_018c;
						case BinXmlToken.SQL_SMALLINT:
						case BinXmlToken.SQL_INT:
						case BinXmlToken.SQL_MONEY:
						case BinXmlToken.SQL_BIT:
						case BinXmlToken.SQL_TINYINT:
						case BinXmlToken.SQL_BIGINT:
						case BinXmlToken.SQL_UUID:
						case BinXmlToken.SQL_DECIMAL:
						case BinXmlToken.SQL_NUMERIC:
						case BinXmlToken.SQL_BINARY:
						case BinXmlToken.SQL_VARBINARY:
						case BinXmlToken.SQL_DATETIME:
						case BinXmlToken.SQL_SMALLDATETIME:
						case BinXmlToken.SQL_SMALLMONEY:
						case BinXmlToken.SQL_IMAGE:
						case BinXmlToken.SQL_UDT:
						case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATEOFFSET:
						case BinXmlToken.XSD_KATMAI_TIME:
						case BinXmlToken.XSD_KATMAI_DATETIME:
						case BinXmlToken.XSD_KATMAI_DATE:
						case BinXmlToken.XSD_TIME:
						case BinXmlToken.XSD_DATETIME:
						case BinXmlToken.XSD_DATE:
						case BinXmlToken.XSD_BINHEX:
						case BinXmlToken.XSD_BASE64:
						case BinXmlToken.XSD_BOOLEAN:
						case BinXmlToken.XSD_DECIMAL:
						case BinXmlToken.XSD_BYTE:
						case BinXmlToken.XSD_UNSIGNEDSHORT:
						case BinXmlToken.XSD_UNSIGNEDINT:
						case BinXmlToken.XSD_UNSIGNEDLONG:
						case BinXmlToken.XSD_QNAME:
							throw new InvalidCastException(Res.GetString("XmlBinary_CastNotSupported", token, "Float"));
						case BinXmlToken.EndElem:
						case BinXmlToken.Element:
							return XmlConvert.ToSingle(string.Empty);
						}
					}
					catch (InvalidCastException innerException)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Float", innerException, null);
					}
					catch (FormatException innerException2)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Float", innerException2, null);
					}
					catch (OverflowException innerException3)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Float", innerException3, null);
					}
				}
				goto end_IL_0007;
				IL_018c:
				origPos = FinishContentAsXXX(origPos);
				return result;
				end_IL_0007:;
			}
			finally
			{
				pos = origPos;
			}
			return base.ReadContentAsFloat();
		}

		public override decimal ReadContentAsDecimal()
		{
			int origPos = pos;
			try
			{
				decimal result;
				if (SetupContentAsXXX("ReadContentAsDecimal"))
				{
					try
					{
						switch (token)
						{
						case BinXmlToken.SQL_SMALLINT:
						case BinXmlToken.SQL_INT:
						case BinXmlToken.SQL_MONEY:
						case BinXmlToken.SQL_BIT:
						case BinXmlToken.SQL_TINYINT:
						case BinXmlToken.SQL_BIGINT:
						case BinXmlToken.SQL_DECIMAL:
						case BinXmlToken.SQL_NUMERIC:
						case BinXmlToken.SQL_SMALLMONEY:
						case BinXmlToken.XSD_DECIMAL:
						case BinXmlToken.XSD_BYTE:
						case BinXmlToken.XSD_UNSIGNEDSHORT:
						case BinXmlToken.XSD_UNSIGNEDINT:
						case BinXmlToken.XSD_UNSIGNEDLONG:
							result = ValueAsDecimal();
							goto IL_018b;
						case BinXmlToken.SQL_REAL:
						case BinXmlToken.SQL_FLOAT:
						case BinXmlToken.SQL_UUID:
						case BinXmlToken.SQL_BINARY:
						case BinXmlToken.SQL_VARBINARY:
						case BinXmlToken.SQL_DATETIME:
						case BinXmlToken.SQL_SMALLDATETIME:
						case BinXmlToken.SQL_IMAGE:
						case BinXmlToken.SQL_UDT:
						case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATEOFFSET:
						case BinXmlToken.XSD_KATMAI_TIME:
						case BinXmlToken.XSD_KATMAI_DATETIME:
						case BinXmlToken.XSD_KATMAI_DATE:
						case BinXmlToken.XSD_TIME:
						case BinXmlToken.XSD_DATETIME:
						case BinXmlToken.XSD_DATE:
						case BinXmlToken.XSD_BINHEX:
						case BinXmlToken.XSD_BASE64:
						case BinXmlToken.XSD_BOOLEAN:
						case BinXmlToken.XSD_QNAME:
							throw new InvalidCastException(Res.GetString("XmlBinary_CastNotSupported", token, "Decimal"));
						case BinXmlToken.EndElem:
						case BinXmlToken.Element:
							return XmlConvert.ToDecimal(string.Empty);
						}
					}
					catch (InvalidCastException innerException)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Decimal", innerException, null);
					}
					catch (FormatException innerException2)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Decimal", innerException2, null);
					}
					catch (OverflowException innerException3)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Decimal", innerException3, null);
					}
				}
				goto end_IL_0007;
				IL_018b:
				origPos = FinishContentAsXXX(origPos);
				return result;
				end_IL_0007:;
			}
			finally
			{
				pos = origPos;
			}
			return base.ReadContentAsDecimal();
		}

		public override int ReadContentAsInt()
		{
			int origPos = pos;
			try
			{
				int result;
				if (SetupContentAsXXX("ReadContentAsInt"))
				{
					try
					{
						switch (token)
						{
						case BinXmlToken.SQL_SMALLINT:
						case BinXmlToken.SQL_INT:
						case BinXmlToken.SQL_MONEY:
						case BinXmlToken.SQL_BIT:
						case BinXmlToken.SQL_TINYINT:
						case BinXmlToken.SQL_BIGINT:
						case BinXmlToken.SQL_DECIMAL:
						case BinXmlToken.SQL_NUMERIC:
						case BinXmlToken.SQL_SMALLMONEY:
						case BinXmlToken.XSD_DECIMAL:
						case BinXmlToken.XSD_BYTE:
						case BinXmlToken.XSD_UNSIGNEDSHORT:
						case BinXmlToken.XSD_UNSIGNEDINT:
						case BinXmlToken.XSD_UNSIGNEDLONG:
							result = checked((int)ValueAsLong());
							goto IL_018c;
						case BinXmlToken.SQL_REAL:
						case BinXmlToken.SQL_FLOAT:
						case BinXmlToken.SQL_UUID:
						case BinXmlToken.SQL_BINARY:
						case BinXmlToken.SQL_VARBINARY:
						case BinXmlToken.SQL_DATETIME:
						case BinXmlToken.SQL_SMALLDATETIME:
						case BinXmlToken.SQL_IMAGE:
						case BinXmlToken.SQL_UDT:
						case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATEOFFSET:
						case BinXmlToken.XSD_KATMAI_TIME:
						case BinXmlToken.XSD_KATMAI_DATETIME:
						case BinXmlToken.XSD_KATMAI_DATE:
						case BinXmlToken.XSD_TIME:
						case BinXmlToken.XSD_DATETIME:
						case BinXmlToken.XSD_DATE:
						case BinXmlToken.XSD_BINHEX:
						case BinXmlToken.XSD_BASE64:
						case BinXmlToken.XSD_BOOLEAN:
						case BinXmlToken.XSD_QNAME:
							throw new InvalidCastException(Res.GetString("XmlBinary_CastNotSupported", token, "Int32"));
						case BinXmlToken.EndElem:
						case BinXmlToken.Element:
							return XmlConvert.ToInt32(string.Empty);
						}
					}
					catch (InvalidCastException innerException)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Int32", innerException, null);
					}
					catch (FormatException innerException2)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Int32", innerException2, null);
					}
					catch (OverflowException innerException3)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Int32", innerException3, null);
					}
				}
				goto end_IL_0007;
				IL_018c:
				origPos = FinishContentAsXXX(origPos);
				return result;
				end_IL_0007:;
			}
			finally
			{
				pos = origPos;
			}
			return base.ReadContentAsInt();
		}

		public override long ReadContentAsLong()
		{
			int origPos = pos;
			try
			{
				long result;
				if (SetupContentAsXXX("ReadContentAsLong"))
				{
					try
					{
						switch (token)
						{
						case BinXmlToken.SQL_SMALLINT:
						case BinXmlToken.SQL_INT:
						case BinXmlToken.SQL_MONEY:
						case BinXmlToken.SQL_BIT:
						case BinXmlToken.SQL_TINYINT:
						case BinXmlToken.SQL_BIGINT:
						case BinXmlToken.SQL_DECIMAL:
						case BinXmlToken.SQL_NUMERIC:
						case BinXmlToken.SQL_SMALLMONEY:
						case BinXmlToken.XSD_DECIMAL:
						case BinXmlToken.XSD_BYTE:
						case BinXmlToken.XSD_UNSIGNEDSHORT:
						case BinXmlToken.XSD_UNSIGNEDINT:
						case BinXmlToken.XSD_UNSIGNEDLONG:
							result = ValueAsLong();
							goto IL_018b;
						case BinXmlToken.SQL_REAL:
						case BinXmlToken.SQL_FLOAT:
						case BinXmlToken.SQL_UUID:
						case BinXmlToken.SQL_BINARY:
						case BinXmlToken.SQL_VARBINARY:
						case BinXmlToken.SQL_DATETIME:
						case BinXmlToken.SQL_SMALLDATETIME:
						case BinXmlToken.SQL_IMAGE:
						case BinXmlToken.SQL_UDT:
						case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
						case BinXmlToken.XSD_KATMAI_DATEOFFSET:
						case BinXmlToken.XSD_KATMAI_TIME:
						case BinXmlToken.XSD_KATMAI_DATETIME:
						case BinXmlToken.XSD_KATMAI_DATE:
						case BinXmlToken.XSD_TIME:
						case BinXmlToken.XSD_DATETIME:
						case BinXmlToken.XSD_DATE:
						case BinXmlToken.XSD_BINHEX:
						case BinXmlToken.XSD_BASE64:
						case BinXmlToken.XSD_BOOLEAN:
						case BinXmlToken.XSD_QNAME:
							throw new InvalidCastException(Res.GetString("XmlBinary_CastNotSupported", token, "Int64"));
						case BinXmlToken.EndElem:
						case BinXmlToken.Element:
							return XmlConvert.ToInt64(string.Empty);
						}
					}
					catch (InvalidCastException innerException)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Int64", innerException, null);
					}
					catch (FormatException innerException2)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Int64", innerException2, null);
					}
					catch (OverflowException innerException3)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Int64", innerException3, null);
					}
				}
				goto end_IL_0007;
				IL_018b:
				origPos = FinishContentAsXXX(origPos);
				return result;
				end_IL_0007:;
			}
			finally
			{
				pos = origPos;
			}
			return base.ReadContentAsLong();
		}

		public override object ReadContentAsObject()
		{
			int origPos = pos;
			try
			{
				if (SetupContentAsXXX("ReadContentAsObject"))
				{
					object result;
					try
					{
						result = ((NodeType != XmlNodeType.Element && NodeType != XmlNodeType.EndElement) ? ValueAsObject(token, returnInternalTypes: false) : string.Empty);
					}
					catch (InvalidCastException innerException)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Object", innerException, null);
					}
					catch (FormatException innerException2)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Object", innerException2, null);
					}
					catch (OverflowException innerException3)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", "Object", innerException3, null);
					}
					origPos = FinishContentAsXXX(origPos);
					return result;
				}
			}
			finally
			{
				pos = origPos;
			}
			return base.ReadContentAsObject();
		}

		public override object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver)
		{
			int origPos = pos;
			try
			{
				if (SetupContentAsXXX("ReadContentAs"))
				{
					object result;
					try
					{
						result = ((NodeType != XmlNodeType.Element && NodeType != XmlNodeType.EndElement) ? ((returnType != ValueType && returnType != typeof(object)) ? ValueAs(token, returnType, namespaceResolver) : ValueAsObject(token, returnInternalTypes: false)) : string.Empty);
					}
					catch (InvalidCastException innerException)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException, null);
					}
					catch (FormatException innerException2)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException2, null);
					}
					catch (OverflowException innerException3)
					{
						throw new XmlException("Xml_ReadContentAsFormatException", returnType.ToString(), innerException3, null);
					}
					origPos = FinishContentAsXXX(origPos);
					return result;
				}
			}
			finally
			{
				pos = origPos;
			}
			return base.ReadContentAs(returnType, namespaceResolver);
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			if (ScanState.XmlText == state)
			{
				IXmlNamespaceResolver xmlNamespaceResolver = (IXmlNamespaceResolver)textXmlReader;
				return xmlNamespaceResolver.GetNamespacesInScope(scope);
			}
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			if (XmlNamespaceScope.Local == scope)
			{
				if (elemDepth > 0)
				{
					for (NamespaceDecl namespaceDecl = elementStack[elemDepth].nsdecls; namespaceDecl != null; namespaceDecl = namespaceDecl.scopeLink)
					{
						dictionary.Add(namespaceDecl.prefix, namespaceDecl.uri);
					}
				}
				return dictionary;
			}
			foreach (NamespaceDecl value in namespaces.Values)
			{
				if ((value.scope != -1 || (scope == XmlNamespaceScope.All && "xml" == value.prefix)) && (value.prefix.Length > 0 || value.uri.Length > 0))
				{
					dictionary.Add(value.prefix, value.uri);
				}
			}
			return dictionary;
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			if (ScanState.XmlText == state)
			{
				IXmlNamespaceResolver xmlNamespaceResolver = (IXmlNamespaceResolver)textXmlReader;
				return xmlNamespaceResolver.LookupPrefix(namespaceName);
			}
			if (namespaceName == null)
			{
				return null;
			}
			namespaceName = xnt.Get(namespaceName);
			if (namespaceName == null)
			{
				return null;
			}
			for (int num = elemDepth; num >= 0; num--)
			{
				for (NamespaceDecl namespaceDecl = elementStack[num].nsdecls; namespaceDecl != null; namespaceDecl = namespaceDecl.scopeLink)
				{
					if ((object)namespaceDecl.uri == namespaceName)
					{
						return namespaceDecl.prefix;
					}
				}
			}
			return null;
		}

		private void VerifyVersion(int requiredVersion, BinXmlToken token)
		{
			if (version < requiredVersion)
			{
				throw ThrowUnexpectedToken(token);
			}
		}

		private void AddInitNamespace(string prefix, string uri)
		{
			NamespaceDecl namespaceDecl = new NamespaceDecl(prefix, uri, elementStack[0].nsdecls, null, -1, implied: true);
			elementStack[0].nsdecls = namespaceDecl;
			namespaces.Add(prefix, namespaceDecl);
		}

		private void AddName()
		{
			string array = ParseText();
			int num = symbolTables.symCount++;
			string[] array2 = symbolTables.symtable;
			if (num == array2.Length)
			{
				string[] array3 = new string[checked(num * 2)];
				Array.Copy(array2, 0, array3, 0, num);
				array2 = (symbolTables.symtable = array3);
			}
			array2[num] = xnt.Add(array);
		}

		private void AddQName()
		{
			int num = ReadNameRef();
			int num2 = ReadNameRef();
			int num3 = ReadNameRef();
			int num4 = symbolTables.qnameCount++;
			QName[] array = symbolTables.qnametable;
			if (num4 == array.Length)
			{
				QName[] array2 = new QName[checked(num4 * 2)];
				Array.Copy(array, 0, array2, 0, num4);
				array = (symbolTables.qnametable = array2);
			}
			string[] symtable = symbolTables.symtable;
			string text = symtable[num2];
			string lname;
			string nsUri;
			if (num3 == 0)
			{
				if (num2 == 0 && num == 0)
				{
					return;
				}
				if (!text.StartsWith("xmlns", StringComparison.Ordinal))
				{
					goto IL_0108;
				}
				if (5 < text.Length)
				{
					if (6 == text.Length || ':' != text[5])
					{
						goto IL_0108;
					}
					lname = xnt.Add(text.Substring(6));
					text = xmlns;
				}
				else
				{
					lname = text;
					text = string.Empty;
				}
				nsUri = nsxmlns;
			}
			else
			{
				lname = symtable[num3];
				nsUri = symtable[num];
			}
			array[num4].Set(text, lname, nsUri);
			return;
			IL_0108:
			throw new XmlException("Xml_BadNamespaceDecl", (string[])null);
		}

		private void NameFlush()
		{
			symbolTables.symCount = (symbolTables.qnameCount = 1);
			Array.Clear(symbolTables.symtable, 1, symbolTables.symtable.Length - 1);
			Array.Clear(symbolTables.qnametable, 0, symbolTables.qnametable.Length);
		}

		private void SkipExtn()
		{
			int num = ParseMB32();
			checked
			{
				pos += num;
				Fill(-1);
			}
		}

		private int ReadQNameRef()
		{
			int num = ParseMB32();
			if (num < 0 || num >= symbolTables.qnameCount)
			{
				throw new XmlException("XmlBin_InvalidQNameID", string.Empty);
			}
			return num;
		}

		private int ReadNameRef()
		{
			int num = ParseMB32();
			if (num < 0 || num >= symbolTables.symCount)
			{
				throw new XmlException("XmlBin_InvalidQNameID", string.Empty);
			}
			return num;
		}

		private bool FillAllowEOF()
		{
			if (eof)
			{
				return false;
			}
			byte[] array = data;
			int num = pos;
			int num2 = mark;
			int num3 = end;
			if (num2 == -1)
			{
				num2 = num;
			}
			if (num2 >= 0 && num2 < num3)
			{
				int num4 = num3 - num2;
				if (num4 > 7 * (array.Length / 8))
				{
					byte[] destinationArray = new byte[checked(array.Length * 2)];
					Array.Copy(array, num2, destinationArray, 0, num4);
					array = (data = destinationArray);
				}
				else
				{
					Array.Copy(array, num2, array, 0, num4);
				}
				num -= num2;
				num3 -= num2;
				tokDataPos -= num2;
				for (int i = 0; i < attrCount; i++)
				{
					attributes[i].AdjustPosition(-num2);
				}
				pos = num;
				mark = 0;
				offset += num2;
			}
			else
			{
				pos -= num3;
				offset += num3;
				tokDataPos -= num3;
				num3 = 0;
			}
			int count = array.Length - num3;
			int num5 = inStrm.Read(array, num3, count);
			end = num3 + num5;
			eof = num5 <= 0;
			return num5 > 0;
		}

		private void Fill_(int require)
		{
			while (FillAllowEOF() && pos + require >= end)
			{
			}
			if (pos + require >= end)
			{
				throw ThrowXmlException("Xml_UnexpectedEOF1");
			}
		}

		private void Fill(int require)
		{
			if (pos + require >= end)
			{
				Fill_(require);
			}
		}

		private byte ReadByte()
		{
			Fill(0);
			return data[pos++];
		}

		private ushort ReadUShort()
		{
			Fill(1);
			int num = pos;
			byte[] array = data;
			ushort result = (ushort)(array[num] + (array[num + 1] << 8));
			pos += 2;
			return result;
		}

		private int ParseMB32()
		{
			byte b = ReadByte();
			if (b > 127)
			{
				return ParseMB32_(b);
			}
			return b;
		}

		private int ParseMB32_(byte b)
		{
			uint num = b & 0x7Fu;
			b = ReadByte();
			uint num2 = b & 0x7Fu;
			num += num2 << 7;
			if (b > 127)
			{
				b = ReadByte();
				num2 = b & 0x7Fu;
				num += num2 << 14;
				if (b > 127)
				{
					b = ReadByte();
					num2 = b & 0x7Fu;
					num += num2 << 21;
					if (b > 127)
					{
						b = ReadByte();
						num2 = b & 7u;
						if (b > 7)
						{
							throw ThrowXmlException("XmlBinary_ValueTooBig");
						}
						num += num2 << 28;
					}
				}
			}
			return (int)num;
		}

		private int ParseMB32(int pos)
		{
			byte[] array = data;
			byte b = array[pos++];
			uint num = b & 0x7Fu;
			if (b > 127)
			{
				b = array[pos++];
				uint num2 = b & 0x7Fu;
				num += num2 << 7;
				if (b > 127)
				{
					b = array[pos++];
					num2 = b & 0x7Fu;
					num += num2 << 14;
					if (b > 127)
					{
						b = array[pos++];
						num2 = b & 0x7Fu;
						num += num2 << 21;
						if (b > 127)
						{
							b = array[pos++];
							num2 = b & 7u;
							if (b > 7)
							{
								throw ThrowXmlException("XmlBinary_ValueTooBig");
							}
							num += num2 << 28;
						}
					}
				}
			}
			return (int)num;
		}

		private int ParseMB64()
		{
			byte b = ReadByte();
			if (b > 127)
			{
				return ParseMB32_(b);
			}
			return b;
		}

		private BinXmlToken PeekToken()
		{
			while (pos >= end && FillAllowEOF())
			{
			}
			if (pos >= end)
			{
				return BinXmlToken.EOF;
			}
			return (BinXmlToken)data[pos];
		}

		private BinXmlToken ReadToken()
		{
			while (pos >= end && FillAllowEOF())
			{
			}
			if (pos >= end)
			{
				return BinXmlToken.EOF;
			}
			return (BinXmlToken)data[pos++];
		}

		private BinXmlToken NextToken2(BinXmlToken token)
		{
			while (true)
			{
				switch (token)
				{
				case BinXmlToken.Name:
					AddName();
					break;
				case BinXmlToken.QName:
					AddQName();
					break;
				case BinXmlToken.NmFlush:
					NameFlush();
					break;
				case BinXmlToken.Extn:
					SkipExtn();
					break;
				default:
					return token;
				}
				token = ReadToken();
			}
		}

		private BinXmlToken NextToken1()
		{
			int num = pos;
			BinXmlToken binXmlToken;
			if (num >= end)
			{
				binXmlToken = ReadToken();
			}
			else
			{
				binXmlToken = (BinXmlToken)data[num];
				pos = num + 1;
			}
			if (binXmlToken >= BinXmlToken.NmFlush && binXmlToken <= BinXmlToken.Name)
			{
				return NextToken2(binXmlToken);
			}
			return binXmlToken;
		}

		private BinXmlToken NextToken()
		{
			int num = pos;
			if (num < end)
			{
				BinXmlToken binXmlToken = (BinXmlToken)data[num];
				if (binXmlToken < BinXmlToken.NmFlush || binXmlToken > BinXmlToken.Name)
				{
					pos = num + 1;
					return binXmlToken;
				}
			}
			return NextToken1();
		}

		private BinXmlToken PeekNextToken()
		{
			BinXmlToken binXmlToken = NextToken();
			if (BinXmlToken.EOF != binXmlToken)
			{
				pos--;
			}
			return binXmlToken;
		}

		private BinXmlToken RescanNextToken()
		{
			checked
			{
				while (true)
				{
					BinXmlToken binXmlToken = ReadToken();
					switch (binXmlToken)
					{
					case BinXmlToken.NmFlush:
						break;
					case BinXmlToken.Name:
					{
						int num2 = ParseMB32();
						pos += 2 * num2;
						break;
					}
					case BinXmlToken.QName:
						ParseMB32();
						ParseMB32();
						ParseMB32();
						break;
					case BinXmlToken.Extn:
					{
						int num = ParseMB32();
						pos += num;
						break;
					}
					default:
						return binXmlToken;
					}
				}
			}
		}

		private string ParseText()
		{
			int num = mark;
			try
			{
				if (num < 0)
				{
					mark = pos;
				}
				int start;
				int cch = ScanText(out start);
				return GetString(start, cch);
			}
			finally
			{
				if (num < 0)
				{
					mark = -1;
				}
			}
		}

		private int ScanText(out int start)
		{
			int num = ParseMB32();
			int num2 = mark;
			int num3 = pos;
			checked
			{
				pos += num * 2;
				if (pos > end)
				{
					Fill(-1);
				}
			}
			start = num3 - (num2 - mark);
			return num;
		}

		private string GetString(int pos, int cch)
		{
			checked
			{
				if (pos + cch * 2 > end)
				{
					throw new XmlException("Xml_UnexpectedEOF1", (string[])null);
				}
				if (cch == 0)
				{
					return string.Empty;
				}
				if ((pos & 1) == 0)
				{
					return GetStringAligned(data, pos, cch);
				}
				return unicode.GetString(data, pos, cch * 2);
			}
		}

		private unsafe string GetStringAligned(byte[] data, int offset, int cch)
		{
			fixed (byte* ptr = data)
			{
				char* value = (char*)(ptr + offset);
				return new string(value, 0, cch);
			}
		}

		private string GetAttributeText(int i)
		{
			string val = attributes[i].val;
			if (val != null)
			{
				return val;
			}
			int num = pos;
			try
			{
				pos = attributes[i].contentPos;
				BinXmlToken binXmlToken = RescanNextToken();
				if (BinXmlToken.Attr == binXmlToken || BinXmlToken.EndAttrs == binXmlToken)
				{
					return "";
				}
				token = binXmlToken;
				ReScanOverValue(binXmlToken);
				return ValueAsString(binXmlToken);
			}
			finally
			{
				pos = num;
			}
		}

		private int LocateAttribute(string name, string ns)
		{
			for (int i = 0; i < attrCount; i++)
			{
				if (attributes[i].name.MatchNs(name, ns))
				{
					return i;
				}
			}
			return -1;
		}

		private int LocateAttribute(string name)
		{
			ValidateNames.SplitQName(name, out var prefix, out var lname);
			for (int i = 0; i < attrCount; i++)
			{
				if (attributes[i].name.MatchPrefix(prefix, lname))
				{
					return i;
				}
			}
			return -1;
		}

		private void PositionOnAttribute(int i)
		{
			attrIndex = i;
			qnameOther = attributes[i - 1].name;
			if (state == ScanState.Doc)
			{
				parentNodeType = nodetype;
			}
			token = BinXmlToken.Attr;
			nodetype = XmlNodeType.Attribute;
			state = ScanState.Attr;
			valueType = TypeOfObject;
			stringValue = null;
		}

		private void GrowElements()
		{
			int num = elementStack.Length * 2;
			ElemInfo[] destinationArray = new ElemInfo[num];
			Array.Copy(elementStack, 0, destinationArray, 0, elementStack.Length);
			elementStack = destinationArray;
		}

		private void GrowAttributes()
		{
			int num = attributes.Length * 2;
			AttrInfo[] destinationArray = new AttrInfo[num];
			Array.Copy(attributes, 0, destinationArray, 0, attrCount);
			attributes = destinationArray;
		}

		private void ClearAttributes()
		{
			if (attrCount != 0)
			{
				attrCount = 0;
			}
		}

		private void PushNamespace(string prefix, string ns, bool implied)
		{
			if (prefix == "xml")
			{
				return;
			}
			int num = elemDepth;
			namespaces.TryGetValue(prefix, out var value);
			if (value != null)
			{
				if (value.uri == ns)
				{
					if (!implied && value.implied && value.scope == num)
					{
						value.implied = false;
					}
					return;
				}
				qnameElement.CheckPrefixNS(prefix, ns);
				if (prefix.Length != 0)
				{
					for (int i = 0; i < attrCount; i++)
					{
						if (attributes[i].name.prefix.Length != 0)
						{
							attributes[i].name.CheckPrefixNS(prefix, ns);
						}
					}
				}
			}
			NamespaceDecl namespaceDecl = new NamespaceDecl(prefix, ns, elementStack[num].nsdecls, value, num, implied);
			elementStack[num].nsdecls = namespaceDecl;
			namespaces[prefix] = namespaceDecl;
		}

		private void PopNamespaces(NamespaceDecl firstInScopeChain)
		{
			NamespaceDecl namespaceDecl = firstInScopeChain;
			while (namespaceDecl != null)
			{
				if (namespaceDecl.prevLink == null)
				{
					namespaces.Remove(namespaceDecl.prefix);
				}
				else
				{
					namespaces[namespaceDecl.prefix] = namespaceDecl.prevLink;
				}
				NamespaceDecl scopeLink = namespaceDecl.scopeLink;
				namespaceDecl.prevLink = null;
				namespaceDecl.scopeLink = null;
				namespaceDecl = scopeLink;
			}
		}

		private void GenerateImpliedXmlnsAttrs()
		{
			for (NamespaceDecl namespaceDecl = elementStack[elemDepth].nsdecls; namespaceDecl != null; namespaceDecl = namespaceDecl.scopeLink)
			{
				if (namespaceDecl.implied)
				{
					if (attrCount == attributes.Length)
					{
						GrowAttributes();
					}
					QName n = ((namespaceDecl.prefix.Length != 0) ? new QName(xmlns, xnt.Add(namespaceDecl.prefix), nsxmlns) : new QName(string.Empty, xmlns, nsxmlns));
					attributes[attrCount].Set(n, namespaceDecl.uri);
					attrCount++;
				}
			}
		}

		private bool ReadInit(bool skipXmlDecl)
		{
			string text = null;
			if (!sniffed)
			{
				ushort num = ReadUShort();
				if (num != 65503)
				{
					text = "XmlBinary_InvalidSignature";
					goto IL_01f5;
				}
			}
			version = ReadByte();
			if (version != 1 && version != 2)
			{
				text = "XmlBinary_InvalidProtocolVersion";
			}
			else if (1200 != ReadUShort())
			{
				text = "XmlBinary_UnsupportedCodePage";
			}
			else
			{
				state = ScanState.Doc;
				if (BinXmlToken.XmlDecl != PeekToken())
				{
					goto IL_01ee;
				}
				pos++;
				attributes[0].Set(new QName(string.Empty, xnt.Add("version"), string.Empty), ParseText());
				attrCount = 1;
				if (BinXmlToken.Encoding == PeekToken())
				{
					pos++;
					attributes[1].Set(new QName(string.Empty, xnt.Add("encoding"), string.Empty), ParseText());
					attrCount++;
				}
				byte b = ReadByte();
				switch (b)
				{
				case 1:
				case 2:
					attributes[attrCount].Set(new QName(string.Empty, xnt.Add("standalone"), string.Empty), (b == 1) ? "yes" : "no");
					attrCount++;
					goto case 0;
				case 0:
					if (!skipXmlDecl)
					{
						QName qName = new QName(string.Empty, xnt.Add("xml"), string.Empty);
						qnameOther = (qnameElement = qName);
						nodetype = XmlNodeType.XmlDeclaration;
						posAfterAttrs = pos;
						return true;
					}
					goto IL_01ee;
				}
				text = "XmlBinary_InvalidStandalone";
			}
			goto IL_01f5;
			IL_01ee:
			return ReadDoc();
			IL_01f5:
			state = ScanState.Error;
			throw new XmlException(text, (string[])null);
		}

		private void ScanAttributes()
		{
			int num = -1;
			int num2 = -1;
			mark = pos;
			string text = null;
			bool flag = false;
			BinXmlToken binXmlToken;
			while (BinXmlToken.EndAttrs != (binXmlToken = NextToken()))
			{
				if (BinXmlToken.Attr == binXmlToken)
				{
					if (text != null)
					{
						PushNamespace(text, string.Empty, implied: false);
						text = null;
					}
					if (attrCount == attributes.Length)
					{
						GrowAttributes();
					}
					QName n = symbolTables.qnametable[ReadQNameRef()];
					attributes[attrCount].Set(n, pos);
					if (n.prefix == "xml")
					{
						if (n.localname == "lang")
						{
							num2 = attrCount;
						}
						else if (n.localname == "space")
						{
							num = attrCount;
						}
					}
					else if (object.Equals(n.namespaceUri, nsxmlns))
					{
						text = n.localname;
						if (text == "xmlns")
						{
							text = string.Empty;
						}
					}
					else if (n.prefix.Length != 0)
					{
						if (n.namespaceUri.Length == 0)
						{
							throw new XmlException("Xml_PrefixForEmptyNs", string.Empty);
						}
						PushNamespace(n.prefix, n.namespaceUri, implied: true);
					}
					else if (n.namespaceUri.Length != 0)
					{
						throw ThrowXmlException("XmlBinary_AttrWithNsNoPrefix", n.localname, n.namespaceUri);
					}
					attrCount++;
					flag = false;
				}
				else
				{
					ScanOverValue(binXmlToken, attr: true, checkChars: true);
					if (flag)
					{
						throw ThrowNotSupported("XmlBinary_ListsOfValuesNotSupported");
					}
					string text2 = stringValue;
					if (text2 != null)
					{
						attributes[attrCount - 1].val = text2;
						stringValue = null;
					}
					if (text != null)
					{
						string ns = xnt.Add(ValueAsString(binXmlToken));
						PushNamespace(text, ns, implied: false);
						text = null;
					}
					flag = true;
				}
			}
			if (num != -1)
			{
				string attributeText = GetAttributeText(num);
				XmlSpace xmlSpace = XmlSpace.None;
				if (attributeText == "preserve")
				{
					xmlSpace = XmlSpace.Preserve;
				}
				else if (attributeText == "default")
				{
					xmlSpace = XmlSpace.Default;
				}
				elementStack[elemDepth].xmlSpace = xmlSpace;
				xmlspacePreserve = XmlSpace.Preserve == xmlSpace;
			}
			if (num2 != -1)
			{
				elementStack[elemDepth].xmlLang = GetAttributeText(num2);
			}
			if (attrCount < 200)
			{
				SimpleCheckForDuplicateAttributes();
			}
			else
			{
				HashCheckForDuplicateAttributes();
			}
		}

		private void SimpleCheckForDuplicateAttributes()
		{
			for (int i = 0; i < attrCount; i++)
			{
				attributes[i].GetLocalnameAndNamespaceUri(out var localname, out var namespaceUri);
				for (int j = i + 1; j < attrCount; j++)
				{
					if (attributes[j].MatchNS(localname, namespaceUri))
					{
						throw new XmlException("Xml_DupAttributeName", attributes[i].name.ToString());
					}
				}
			}
		}

		private void HashCheckForDuplicateAttributes()
		{
			int num;
			for (num = 256; num < attrCount; num = checked(num * 2))
			{
			}
			if (attrHashTbl.Length < num)
			{
				attrHashTbl = new int[num];
			}
			for (int i = 0; i < attrCount; i++)
			{
				string localname;
				string namespaceUri;
				int localnameAndNamespaceUriAndHash = attributes[i].GetLocalnameAndNamespaceUriAndHash(hasher, out localname, out namespaceUri);
				int num2 = localnameAndNamespaceUriAndHash & (num - 1);
				int num3 = attrHashTbl[num2];
				attrHashTbl[num2] = i + 1;
				attributes[i].prevHash = num3;
				while (num3 != 0)
				{
					num3--;
					if (attributes[num3].MatchHashNS(localnameAndNamespaceUriAndHash, localname, namespaceUri))
					{
						throw new XmlException("Xml_DupAttributeName", attributes[i].name.ToString());
					}
					num3 = attributes[num3].prevHash;
				}
			}
			Array.Clear(attrHashTbl, 0, num);
		}

		private string XmlDeclValue()
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < attrCount; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append(' ');
				}
				stringBuilder.Append(attributes[i].name.localname);
				stringBuilder.Append("=\"");
				stringBuilder.Append(attributes[i].val);
				stringBuilder.Append('"');
			}
			return stringBuilder.ToString();
		}

		private string CDATAValue()
		{
			string text = GetString(tokDataPos, tokLen);
			StringBuilder stringBuilder = null;
			while (PeekToken() == BinXmlToken.CData)
			{
				pos++;
				if (stringBuilder == null)
				{
					stringBuilder = new StringBuilder(text.Length + text.Length / 2);
					stringBuilder.Append(text);
				}
				stringBuilder.Append(ParseText());
			}
			if (stringBuilder != null)
			{
				text = stringBuilder.ToString();
			}
			stringValue = text;
			return text;
		}

		private void FinishCDATA()
		{
			while (true)
			{
				switch (PeekToken())
				{
				case BinXmlToken.CData:
					break;
				case BinXmlToken.EndCData:
					pos++;
					return;
				default:
					throw new XmlException("XmlBin_MissingEndCDATA");
				}
				pos++;
				ScanText(out var _);
			}
		}

		private void FinishEndElement()
		{
			NamespaceDecl firstInScopeChain = elementStack[elemDepth].Clear();
			PopNamespaces(firstInScopeChain);
			elemDepth--;
		}

		private bool ReadDoc()
		{
			switch (nodetype)
			{
			case XmlNodeType.CDATA:
				FinishCDATA();
				break;
			case XmlNodeType.EndElement:
				FinishEndElement();
				break;
			case XmlNodeType.Element:
				if (isEmpty)
				{
					FinishEndElement();
					isEmpty = false;
				}
				break;
			}
			while (true)
			{
				nodetype = XmlNodeType.None;
				mark = -1;
				if (qnameOther.localname.Length != 0)
				{
					qnameOther.Clear();
				}
				ClearAttributes();
				attrCount = 0;
				valueType = TypeOfString;
				stringValue = null;
				hasTypedValue = false;
				token = NextToken();
				switch (token)
				{
				case BinXmlToken.EOF:
					if (elemDepth > 0)
					{
						throw new XmlException("Xml_UnexpectedEOF1", (string[])null);
					}
					state = ScanState.EOF;
					return false;
				case BinXmlToken.Element:
					ImplReadElement();
					break;
				case BinXmlToken.EndElem:
					ImplReadEndElement();
					break;
				case BinXmlToken.DocType:
					ImplReadDoctype();
					if (prevNameInfo != null)
					{
						continue;
					}
					break;
				case BinXmlToken.PI:
					ImplReadPI();
					if (ignorePIs)
					{
						continue;
					}
					break;
				case BinXmlToken.Comment:
					ImplReadComment();
					if (ignoreComments)
					{
						continue;
					}
					break;
				case BinXmlToken.CData:
					ImplReadCDATA();
					break;
				case BinXmlToken.Nest:
					ImplReadNest();
					sniffed = false;
					return ReadInit(skipXmlDecl: true);
				case BinXmlToken.EndNest:
					if (prevNameInfo != null)
					{
						ImplReadEndNest();
						return ReadDoc();
					}
					goto default;
				case BinXmlToken.XmlText:
					ImplReadXmlText();
					break;
				case BinXmlToken.SQL_SMALLINT:
				case BinXmlToken.SQL_INT:
				case BinXmlToken.SQL_REAL:
				case BinXmlToken.SQL_FLOAT:
				case BinXmlToken.SQL_MONEY:
				case BinXmlToken.SQL_BIT:
				case BinXmlToken.SQL_TINYINT:
				case BinXmlToken.SQL_BIGINT:
				case BinXmlToken.SQL_UUID:
				case BinXmlToken.SQL_DECIMAL:
				case BinXmlToken.SQL_NUMERIC:
				case BinXmlToken.SQL_BINARY:
				case BinXmlToken.SQL_CHAR:
				case BinXmlToken.SQL_NCHAR:
				case BinXmlToken.SQL_VARBINARY:
				case BinXmlToken.SQL_VARCHAR:
				case BinXmlToken.SQL_NVARCHAR:
				case BinXmlToken.SQL_DATETIME:
				case BinXmlToken.SQL_SMALLDATETIME:
				case BinXmlToken.SQL_SMALLMONEY:
				case BinXmlToken.SQL_TEXT:
				case BinXmlToken.SQL_IMAGE:
				case BinXmlToken.SQL_NTEXT:
				case BinXmlToken.SQL_UDT:
				case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
				case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
				case BinXmlToken.XSD_KATMAI_DATEOFFSET:
				case BinXmlToken.XSD_KATMAI_TIME:
				case BinXmlToken.XSD_KATMAI_DATETIME:
				case BinXmlToken.XSD_KATMAI_DATE:
				case BinXmlToken.XSD_TIME:
				case BinXmlToken.XSD_DATETIME:
				case BinXmlToken.XSD_DATE:
				case BinXmlToken.XSD_BINHEX:
				case BinXmlToken.XSD_BASE64:
				case BinXmlToken.XSD_BOOLEAN:
				case BinXmlToken.XSD_DECIMAL:
				case BinXmlToken.XSD_BYTE:
				case BinXmlToken.XSD_UNSIGNEDSHORT:
				case BinXmlToken.XSD_UNSIGNEDINT:
				case BinXmlToken.XSD_UNSIGNEDLONG:
				case BinXmlToken.XSD_QNAME:
					ImplReadData(token);
					if (XmlNodeType.Text == nodetype)
					{
						CheckAllowContent();
					}
					else if (ignoreWhitespace && !xmlspacePreserve)
					{
						continue;
					}
					return true;
				default:
					throw ThrowUnexpectedToken(token);
				}
				break;
			}
			return true;
		}

		private void ImplReadData(BinXmlToken tokenType)
		{
			mark = pos;
			switch (tokenType)
			{
			case BinXmlToken.SQL_CHAR:
			case BinXmlToken.SQL_NCHAR:
			case BinXmlToken.SQL_VARCHAR:
			case BinXmlToken.SQL_NVARCHAR:
			case BinXmlToken.SQL_TEXT:
			case BinXmlToken.SQL_NTEXT:
				valueType = TypeOfString;
				hasTypedValue = false;
				break;
			default:
				valueType = GetValueType(token);
				hasTypedValue = true;
				break;
			}
			nodetype = ScanOverValue(token, attr: false, checkChars: true);
			switch (PeekNextToken())
			{
			case BinXmlToken.SQL_SMALLINT:
			case BinXmlToken.SQL_INT:
			case BinXmlToken.SQL_REAL:
			case BinXmlToken.SQL_FLOAT:
			case BinXmlToken.SQL_MONEY:
			case BinXmlToken.SQL_BIT:
			case BinXmlToken.SQL_TINYINT:
			case BinXmlToken.SQL_BIGINT:
			case BinXmlToken.SQL_UUID:
			case BinXmlToken.SQL_DECIMAL:
			case BinXmlToken.SQL_NUMERIC:
			case BinXmlToken.SQL_BINARY:
			case BinXmlToken.SQL_CHAR:
			case BinXmlToken.SQL_NCHAR:
			case BinXmlToken.SQL_VARBINARY:
			case BinXmlToken.SQL_VARCHAR:
			case BinXmlToken.SQL_NVARCHAR:
			case BinXmlToken.SQL_DATETIME:
			case BinXmlToken.SQL_SMALLDATETIME:
			case BinXmlToken.SQL_SMALLMONEY:
			case BinXmlToken.SQL_TEXT:
			case BinXmlToken.SQL_IMAGE:
			case BinXmlToken.SQL_NTEXT:
			case BinXmlToken.SQL_UDT:
			case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
			case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
			case BinXmlToken.XSD_KATMAI_DATEOFFSET:
			case BinXmlToken.XSD_KATMAI_TIME:
			case BinXmlToken.XSD_KATMAI_DATETIME:
			case BinXmlToken.XSD_KATMAI_DATE:
			case BinXmlToken.XSD_TIME:
			case BinXmlToken.XSD_DATETIME:
			case BinXmlToken.XSD_DATE:
			case BinXmlToken.XSD_BINHEX:
			case BinXmlToken.XSD_BASE64:
			case BinXmlToken.XSD_BOOLEAN:
			case BinXmlToken.XSD_DECIMAL:
			case BinXmlToken.XSD_BYTE:
			case BinXmlToken.XSD_UNSIGNEDSHORT:
			case BinXmlToken.XSD_UNSIGNEDINT:
			case BinXmlToken.XSD_UNSIGNEDLONG:
			case BinXmlToken.XSD_QNAME:
				throw ThrowNotSupported("XmlBinary_ListsOfValuesNotSupported");
			}
		}

		private void ImplReadElement()
		{
			if (3 != docState || 9 != docState)
			{
				switch (docState)
				{
				case 0:
					docState = 9;
					break;
				case 1:
				case 2:
					docState = 3;
					break;
				case -1:
					throw ThrowUnexpectedToken(token);
				}
			}
			elemDepth++;
			if (elemDepth == elementStack.Length)
			{
				GrowElements();
			}
			QName name = symbolTables.qnametable[ReadQNameRef()];
			qnameOther = (qnameElement = name);
			elementStack[elemDepth].Set(name, xmlspacePreserve);
			PushNamespace(name.prefix, name.namespaceUri, implied: true);
			BinXmlToken binXmlToken = PeekNextToken();
			if (BinXmlToken.Attr == binXmlToken)
			{
				ScanAttributes();
				binXmlToken = PeekNextToken();
			}
			GenerateImpliedXmlnsAttrs();
			if (BinXmlToken.EndElem == binXmlToken)
			{
				NextToken();
				isEmpty = true;
			}
			else if (BinXmlToken.SQL_NVARCHAR == binXmlToken)
			{
				if (mark < 0)
				{
					mark = pos;
				}
				pos++;
				if (ReadByte() == 0)
				{
					if (247 != ReadByte())
					{
						pos -= 3;
					}
					else
					{
						pos--;
					}
				}
				else
				{
					pos -= 2;
				}
			}
			nodetype = XmlNodeType.Element;
			valueType = TypeOfObject;
			posAfterAttrs = pos;
		}

		private void ImplReadEndElement()
		{
			if (elemDepth == 0)
			{
				throw ThrowXmlException("Xml_UnexpectedEndTag");
			}
			int num = elemDepth;
			if (1 == num && 3 == docState)
			{
				docState = -1;
			}
			qnameOther = elementStack[num].name;
			xmlspacePreserve = elementStack[num].xmlspacePreserve;
			nodetype = XmlNodeType.EndElement;
		}

		private void ImplReadDoctype()
		{
			if (prohibitDtd)
			{
				throw ThrowXmlException("Xml_DtdIsProhibited");
			}
			switch (docState)
			{
			case 9:
				throw ThrowXmlException("Xml_DtdNotAllowedInFragment");
			default:
				throw ThrowXmlException("Xml_BadDTDLocation");
			case 0:
			case 1:
				docState = 2;
				qnameOther.localname = ParseText();
				if (BinXmlToken.System == PeekToken())
				{
					pos++;
					attributes[attrCount++].Set(new QName(string.Empty, xnt.Add("SYSTEM"), string.Empty), ParseText());
				}
				if (BinXmlToken.Public == PeekToken())
				{
					pos++;
					attributes[attrCount++].Set(new QName(string.Empty, xnt.Add("PUBLIC"), string.Empty), ParseText());
				}
				if (BinXmlToken.Subset == PeekToken())
				{
					pos++;
					mark = pos;
					tokLen = ScanText(out tokDataPos);
				}
				else
				{
					tokLen = (tokDataPos = 0);
				}
				nodetype = XmlNodeType.DocumentType;
				posAfterAttrs = pos;
				break;
			}
		}

		private void ImplReadPI()
		{
			qnameOther.localname = symbolTables.symtable[ReadNameRef()];
			mark = pos;
			tokLen = ScanText(out tokDataPos);
			nodetype = XmlNodeType.ProcessingInstruction;
		}

		private void ImplReadComment()
		{
			nodetype = XmlNodeType.Comment;
			mark = pos;
			tokLen = ScanText(out tokDataPos);
		}

		private void ImplReadCDATA()
		{
			CheckAllowContent();
			nodetype = XmlNodeType.CDATA;
			mark = pos;
			tokLen = ScanText(out tokDataPos);
		}

		private void ImplReadNest()
		{
			CheckAllowContent();
			prevNameInfo = new NestedBinXml(symbolTables, docState, prevNameInfo);
			symbolTables.Init();
			docState = 0;
		}

		private void ImplReadEndNest()
		{
			NestedBinXml nestedBinXml = prevNameInfo;
			symbolTables = nestedBinXml.symbolTables;
			docState = nestedBinXml.docState;
			prevNameInfo = nestedBinXml.next;
		}

		private void ImplReadXmlText()
		{
			CheckAllowContent();
			string xmlFragment = ParseText();
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(xnt);
			foreach (NamespaceDecl value in namespaces.Values)
			{
				if (value.scope > 0)
				{
					xmlNamespaceManager.AddNamespace(value.prefix, value.uri);
				}
			}
			XmlReaderSettings settings = Settings;
			settings.ReadOnly = false;
			settings.NameTable = xnt;
			settings.ProhibitDtd = true;
			if (elemDepth != 0)
			{
				settings.ConformanceLevel = ConformanceLevel.Fragment;
			}
			settings.ReadOnly = true;
			XmlParserContext context = new XmlParserContext(xnt, xmlNamespaceManager, XmlLang, XmlSpace);
			textXmlReader = new XmlTextReaderImpl(xmlFragment, context, settings);
			if (!textXmlReader.Read() || (textXmlReader.NodeType == XmlNodeType.XmlDeclaration && !textXmlReader.Read()))
			{
				state = ScanState.Doc;
				ReadDoc();
			}
			else
			{
				state = ScanState.XmlText;
				UpdateFromTextReader();
			}
		}

		private void UpdateFromTextReader()
		{
			XmlReader xmlReader = textXmlReader;
			nodetype = xmlReader.NodeType;
			qnameOther.prefix = xmlReader.Prefix;
			qnameOther.localname = xmlReader.LocalName;
			qnameOther.namespaceUri = xmlReader.NamespaceURI;
			valueType = xmlReader.ValueType;
			isEmpty = xmlReader.IsEmptyElement;
		}

		private bool UpdateFromTextReader(bool needUpdate)
		{
			if (needUpdate)
			{
				UpdateFromTextReader();
			}
			return needUpdate;
		}

		private void CheckAllowContent()
		{
			switch (docState)
			{
			case 0:
				docState = 9;
				break;
			default:
				throw ThrowXmlException("Xml_InvalidRootData");
			case 3:
			case 9:
				break;
			}
		}

		private void GenerateTokenTypeMap()
		{
			Type[] array = new Type[256];
			array[134] = typeof(bool);
			array[7] = typeof(byte);
			array[136] = typeof(sbyte);
			array[1] = typeof(short);
			array[137] = typeof(ushort);
			array[138] = typeof(uint);
			array[3] = typeof(float);
			array[4] = typeof(double);
			array[8] = typeof(long);
			array[139] = typeof(ulong);
			array[140] = typeof(XmlQualifiedName);
			array[2] = (array[6] = typeof(int));
			array[135] = (array[11] = (array[10] = (array[5] = (array[20] = typeof(decimal)))));
			array[125] = (array[126] = (array[127] = (array[131] = (array[130] = (array[129] = (array[18] = (array[19] = typeof(DateTime))))))));
			array[122] = (array[123] = (array[124] = typeof(DateTimeOffset)));
			array[133] = (array[132] = (array[27] = (array[23] = (array[12] = (array[15] = typeof(byte[]))))));
			array[13] = TypeOfString;
			array[16] = TypeOfString;
			array[22] = TypeOfString;
			array[14] = TypeOfString;
			array[17] = TypeOfString;
			array[24] = TypeOfString;
			array[9] = TypeOfString;
			if (TokenTypeMap == null)
			{
				TokenTypeMap = array;
			}
		}

		private Type GetValueType(BinXmlToken token)
		{
			Type type = TokenTypeMap[(int)token];
			if (type == null)
			{
				throw ThrowUnexpectedToken(token);
			}
			return type;
		}

		private void ReScanOverValue(BinXmlToken token)
		{
			ScanOverValue(token, attr: true, checkChars: false);
		}

		private XmlNodeType ScanOverValue(BinXmlToken token, bool attr, bool checkChars)
		{
			checked
			{
				if (token == BinXmlToken.SQL_NVARCHAR)
				{
					if (mark < 0)
					{
						mark = pos;
					}
					tokLen = ParseMB32();
					tokDataPos = pos;
					pos += tokLen * 2;
					Fill(-1);
					if (checkChars && checkCharacters)
					{
						return CheckText(attr);
					}
					if (!attr)
					{
						return CheckTextIsWS();
					}
					return XmlNodeType.Text;
				}
				return ScanOverAnyValue(token, attr, checkChars);
			}
		}

		private XmlNodeType ScanOverAnyValue(BinXmlToken token, bool attr, bool checkChars)
		{
			if (mark < 0)
			{
				mark = pos;
			}
			checked
			{
				switch (token)
				{
				case BinXmlToken.SQL_BIT:
				case BinXmlToken.SQL_TINYINT:
				case BinXmlToken.XSD_BOOLEAN:
				case BinXmlToken.XSD_BYTE:
					tokDataPos = pos;
					tokLen = 1;
					pos++;
					break;
				case BinXmlToken.SQL_SMALLINT:
				case BinXmlToken.XSD_UNSIGNEDSHORT:
					tokDataPos = pos;
					tokLen = 2;
					pos += 2;
					break;
				case BinXmlToken.SQL_INT:
				case BinXmlToken.SQL_REAL:
				case BinXmlToken.SQL_SMALLDATETIME:
				case BinXmlToken.SQL_SMALLMONEY:
				case BinXmlToken.XSD_UNSIGNEDINT:
					tokDataPos = pos;
					tokLen = 4;
					pos += 4;
					break;
				case BinXmlToken.SQL_FLOAT:
				case BinXmlToken.SQL_MONEY:
				case BinXmlToken.SQL_BIGINT:
				case BinXmlToken.SQL_DATETIME:
				case BinXmlToken.XSD_TIME:
				case BinXmlToken.XSD_DATETIME:
				case BinXmlToken.XSD_DATE:
				case BinXmlToken.XSD_UNSIGNEDLONG:
					tokDataPos = pos;
					tokLen = 8;
					pos += 8;
					break;
				case BinXmlToken.SQL_UUID:
					tokDataPos = pos;
					tokLen = 16;
					pos += 16;
					break;
				case BinXmlToken.SQL_DECIMAL:
				case BinXmlToken.SQL_NUMERIC:
				case BinXmlToken.XSD_DECIMAL:
					tokDataPos = pos;
					tokLen = ParseMB64();
					pos += tokLen;
					break;
				case BinXmlToken.SQL_BINARY:
				case BinXmlToken.SQL_VARBINARY:
				case BinXmlToken.SQL_IMAGE:
				case BinXmlToken.SQL_UDT:
				case BinXmlToken.XSD_BINHEX:
				case BinXmlToken.XSD_BASE64:
					tokLen = ParseMB64();
					tokDataPos = pos;
					pos += tokLen;
					break;
				case BinXmlToken.SQL_CHAR:
				case BinXmlToken.SQL_VARCHAR:
				case BinXmlToken.SQL_TEXT:
					tokLen = ParseMB64();
					tokDataPos = pos;
					pos += tokLen;
					if (checkChars && checkCharacters)
					{
						Fill(-1);
						string text = ValueAsString(token);
						XmlConvert.VerifyCharData(text, ExceptionType.XmlException);
						stringValue = text;
					}
					break;
				case BinXmlToken.SQL_NCHAR:
				case BinXmlToken.SQL_NVARCHAR:
				case BinXmlToken.SQL_NTEXT:
					return ScanOverValue(BinXmlToken.SQL_NVARCHAR, attr, checkChars);
				case BinXmlToken.XSD_QNAME:
					tokDataPos = pos;
					ParseMB32();
					break;
				case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
				case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
				case BinXmlToken.XSD_KATMAI_DATEOFFSET:
				case BinXmlToken.XSD_KATMAI_TIME:
				case BinXmlToken.XSD_KATMAI_DATETIME:
				case BinXmlToken.XSD_KATMAI_DATE:
					VerifyVersion(2, token);
					tokDataPos = pos;
					tokLen = GetXsdKatmaiTokenLength(token);
					pos += tokLen;
					break;
				default:
					throw ThrowUnexpectedToken(token);
				}
				Fill(-1);
				return XmlNodeType.Text;
			}
		}

		private unsafe XmlNodeType CheckText(bool attr)
		{
			XmlCharType xmlCharType = this.xmlCharType;
			fixed (byte* ptr = data)
			{
				int num = pos;
				int num2 = tokDataPos;
				if (!attr)
				{
					while (true)
					{
						int num3 = num2 + 2;
						if (num3 > num)
						{
							return xmlspacePreserve ? XmlNodeType.SignificantWhitespace : XmlNodeType.Whitespace;
						}
						if (ptr[num2 + 1] != 0 || (xmlCharType.charProperties[(int)ptr[num2]] & 1) == 0)
						{
							break;
						}
						num2 = num3;
					}
				}
				char c;
				char c2;
				while (true)
				{
					int num4 = num2 + 2;
					if (num4 > num)
					{
						return XmlNodeType.Text;
					}
					c = (char)(ptr[num2] | (ptr[num2 + 1] << 8));
					if ((xmlCharType.charProperties[(int)c] & 0x10u) != 0)
					{
						num2 = num4;
						continue;
					}
					if (c < '\ud800' || c > '\udbff')
					{
						throw XmlConvert.CreateInvalidCharException(c, ExceptionType.XmlException);
					}
					if (num2 + 4 > num)
					{
						throw ThrowXmlException("Xml_InvalidSurrogateMissingLowChar");
					}
					c2 = (char)(ptr[num2 + 2] | (ptr[num2 + 3] << 8));
					if (c2 < '\udc00' || c2 > '\udfff')
					{
						break;
					}
					num2 += 4;
				}
				throw XmlConvert.CreateInvalidSurrogatePairException(c, c2);
			}
		}

		private XmlNodeType CheckTextIsWS()
		{
			byte[] array = data;
			int num = tokDataPos;
			while (true)
			{
				if (num < pos)
				{
					if (array[num + 1] == 0)
					{
						switch (array[num])
						{
						case 9:
						case 10:
						case 13:
						case 32:
							goto IL_003d;
						}
					}
					break;
				}
				if (xmlspacePreserve)
				{
					return XmlNodeType.SignificantWhitespace;
				}
				return XmlNodeType.Whitespace;
				IL_003d:
				num += 2;
			}
			return XmlNodeType.Text;
		}

		private void CheckValueTokenBounds()
		{
			if (end - tokDataPos < tokLen)
			{
				throw ThrowXmlException("Xml_UnexpectedEOF1");
			}
		}

		private int GetXsdKatmaiTokenLength(BinXmlToken token)
		{
			switch (token)
			{
			case BinXmlToken.XSD_KATMAI_DATE:
				return 3;
			case BinXmlToken.XSD_KATMAI_TIME:
			case BinXmlToken.XSD_KATMAI_DATETIME:
			{
				Fill(0);
				byte scale = data[pos];
				return 4 + XsdKatmaiTimeScaleToValueLength(scale);
			}
			case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
			case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
			case BinXmlToken.XSD_KATMAI_DATEOFFSET:
			{
				Fill(0);
				byte scale = data[pos];
				return 6 + XsdKatmaiTimeScaleToValueLength(scale);
			}
			default:
				throw ThrowUnexpectedToken(this.token);
			}
		}

		private int XsdKatmaiTimeScaleToValueLength(byte scale)
		{
			if (scale > 7)
			{
				throw new XmlException("SqlTypes_ArithOverflow", (string)null);
			}
			return XsdKatmaiTimeScaleToValueLengthMap[scale];
		}

		private long ValueAsLong()
		{
			CheckValueTokenBounds();
			switch (token)
			{
			case BinXmlToken.SQL_BIT:
			case BinXmlToken.SQL_TINYINT:
			{
				byte b2 = data[tokDataPos];
				return b2;
			}
			case BinXmlToken.XSD_BYTE:
			{
				sbyte b = (sbyte)data[tokDataPos];
				return b;
			}
			case BinXmlToken.SQL_SMALLINT:
				return GetInt16(tokDataPos);
			case BinXmlToken.SQL_INT:
				return GetInt32(tokDataPos);
			case BinXmlToken.SQL_BIGINT:
				return GetInt64(tokDataPos);
			case BinXmlToken.XSD_UNSIGNEDSHORT:
				return GetUInt16(tokDataPos);
			case BinXmlToken.XSD_UNSIGNEDINT:
				return GetUInt32(tokDataPos);
			case BinXmlToken.XSD_UNSIGNEDLONG:
			{
				ulong uInt = GetUInt64(tokDataPos);
				return checked((long)uInt);
			}
			case BinXmlToken.SQL_REAL:
			case BinXmlToken.SQL_FLOAT:
			{
				double num2 = ValueAsDouble();
				return (long)num2;
			}
			case BinXmlToken.SQL_MONEY:
			case BinXmlToken.SQL_DECIMAL:
			case BinXmlToken.SQL_NUMERIC:
			case BinXmlToken.SQL_SMALLMONEY:
			case BinXmlToken.XSD_DECIMAL:
			{
				decimal num = ValueAsDecimal();
				return (long)num;
			}
			default:
				throw ThrowUnexpectedToken(token);
			}
		}

		private ulong ValueAsULong()
		{
			if (BinXmlToken.XSD_UNSIGNEDLONG == token)
			{
				CheckValueTokenBounds();
				return GetUInt64(tokDataPos);
			}
			throw ThrowUnexpectedToken(token);
		}

		private decimal ValueAsDecimal()
		{
			CheckValueTokenBounds();
			switch (token)
			{
			case BinXmlToken.SQL_SMALLINT:
			case BinXmlToken.SQL_INT:
			case BinXmlToken.SQL_BIT:
			case BinXmlToken.SQL_TINYINT:
			case BinXmlToken.SQL_BIGINT:
			case BinXmlToken.XSD_BYTE:
			case BinXmlToken.XSD_UNSIGNEDSHORT:
			case BinXmlToken.XSD_UNSIGNEDINT:
				return new decimal(ValueAsLong());
			case BinXmlToken.XSD_UNSIGNEDLONG:
				return new decimal(ValueAsULong());
			case BinXmlToken.SQL_REAL:
				return new decimal(GetSingle(tokDataPos));
			case BinXmlToken.SQL_FLOAT:
				return new decimal(GetDouble(tokDataPos));
			case BinXmlToken.SQL_SMALLMONEY:
				return new BinXmlSqlMoney(GetInt32(tokDataPos)).ToDecimal();
			case BinXmlToken.SQL_MONEY:
				return new BinXmlSqlMoney(GetInt64(tokDataPos)).ToDecimal();
			case BinXmlToken.SQL_DECIMAL:
			case BinXmlToken.SQL_NUMERIC:
			case BinXmlToken.XSD_DECIMAL:
				return new BinXmlSqlDecimal(data, tokDataPos, token == BinXmlToken.XSD_DECIMAL).ToDecimal();
			default:
				throw ThrowUnexpectedToken(token);
			}
		}

		private double ValueAsDouble()
		{
			CheckValueTokenBounds();
			switch (token)
			{
			case BinXmlToken.SQL_SMALLINT:
			case BinXmlToken.SQL_INT:
			case BinXmlToken.SQL_BIT:
			case BinXmlToken.SQL_TINYINT:
			case BinXmlToken.SQL_BIGINT:
			case BinXmlToken.XSD_BYTE:
			case BinXmlToken.XSD_UNSIGNEDSHORT:
			case BinXmlToken.XSD_UNSIGNEDINT:
				return ValueAsLong();
			case BinXmlToken.XSD_UNSIGNEDLONG:
				return ValueAsULong();
			case BinXmlToken.SQL_REAL:
				return GetSingle(tokDataPos);
			case BinXmlToken.SQL_FLOAT:
				return GetDouble(tokDataPos);
			case BinXmlToken.SQL_MONEY:
			case BinXmlToken.SQL_DECIMAL:
			case BinXmlToken.SQL_NUMERIC:
			case BinXmlToken.SQL_SMALLMONEY:
			case BinXmlToken.XSD_DECIMAL:
				return (double)ValueAsDecimal();
			default:
				throw ThrowUnexpectedToken(token);
			}
		}

		private DateTime ValueAsDateTime()
		{
			CheckValueTokenBounds();
			switch (token)
			{
			case BinXmlToken.SQL_DATETIME:
			{
				int num2 = tokDataPos;
				int int5 = GetInt32(num2);
				uint uInt2 = GetUInt32(num2 + 4);
				return BinXmlDateTime.SqlDateTimeToDateTime(int5, uInt2);
			}
			case BinXmlToken.SQL_SMALLDATETIME:
			{
				int num = tokDataPos;
				short int4 = GetInt16(num);
				ushort uInt = GetUInt16(num + 2);
				return BinXmlDateTime.SqlSmallDateTimeToDateTime(int4, uInt);
			}
			case BinXmlToken.XSD_TIME:
			{
				long int3 = GetInt64(tokDataPos);
				return BinXmlDateTime.XsdTimeToDateTime(int3);
			}
			case BinXmlToken.XSD_DATE:
			{
				long int2 = GetInt64(tokDataPos);
				return BinXmlDateTime.XsdDateToDateTime(int2);
			}
			case BinXmlToken.XSD_DATETIME:
			{
				long @int = GetInt64(tokDataPos);
				return BinXmlDateTime.XsdDateTimeToDateTime(@int);
			}
			case BinXmlToken.XSD_KATMAI_DATE:
				return BinXmlDateTime.XsdKatmaiDateToDateTime(data, tokDataPos);
			case BinXmlToken.XSD_KATMAI_DATETIME:
				return BinXmlDateTime.XsdKatmaiDateTimeToDateTime(data, tokDataPos);
			case BinXmlToken.XSD_KATMAI_TIME:
				return BinXmlDateTime.XsdKatmaiTimeToDateTime(data, tokDataPos);
			case BinXmlToken.XSD_KATMAI_DATEOFFSET:
				return BinXmlDateTime.XsdKatmaiDateOffsetToDateTime(data, tokDataPos);
			case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
				return BinXmlDateTime.XsdKatmaiDateTimeOffsetToDateTime(data, tokDataPos);
			case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
				return BinXmlDateTime.XsdKatmaiTimeOffsetToDateTime(data, tokDataPos);
			default:
				throw ThrowUnexpectedToken(token);
			}
		}

		private DateTimeOffset ValueAsDateTimeOffset()
		{
			CheckValueTokenBounds();
			return token switch
			{
				BinXmlToken.XSD_KATMAI_DATEOFFSET => BinXmlDateTime.XsdKatmaiDateOffsetToDateTimeOffset(data, tokDataPos), 
				BinXmlToken.XSD_KATMAI_DATETIMEOFFSET => BinXmlDateTime.XsdKatmaiDateTimeOffsetToDateTimeOffset(data, tokDataPos), 
				BinXmlToken.XSD_KATMAI_TIMEOFFSET => BinXmlDateTime.XsdKatmaiTimeOffsetToDateTimeOffset(data, tokDataPos), 
				_ => throw ThrowUnexpectedToken(token), 
			};
		}

		private string ValueAsDateTimeString()
		{
			CheckValueTokenBounds();
			switch (token)
			{
			case BinXmlToken.SQL_DATETIME:
			{
				int num2 = tokDataPos;
				int int5 = GetInt32(num2);
				uint uInt2 = GetUInt32(num2 + 4);
				return BinXmlDateTime.SqlDateTimeToString(int5, uInt2);
			}
			case BinXmlToken.SQL_SMALLDATETIME:
			{
				int num = tokDataPos;
				short int4 = GetInt16(num);
				ushort uInt = GetUInt16(num + 2);
				return BinXmlDateTime.SqlSmallDateTimeToString(int4, uInt);
			}
			case BinXmlToken.XSD_TIME:
			{
				long int3 = GetInt64(tokDataPos);
				return BinXmlDateTime.XsdTimeToString(int3);
			}
			case BinXmlToken.XSD_DATE:
			{
				long int2 = GetInt64(tokDataPos);
				return BinXmlDateTime.XsdDateToString(int2);
			}
			case BinXmlToken.XSD_DATETIME:
			{
				long @int = GetInt64(tokDataPos);
				return BinXmlDateTime.XsdDateTimeToString(@int);
			}
			case BinXmlToken.XSD_KATMAI_DATE:
				return BinXmlDateTime.XsdKatmaiDateToString(data, tokDataPos);
			case BinXmlToken.XSD_KATMAI_DATETIME:
				return BinXmlDateTime.XsdKatmaiDateTimeToString(data, tokDataPos);
			case BinXmlToken.XSD_KATMAI_TIME:
				return BinXmlDateTime.XsdKatmaiTimeToString(data, tokDataPos);
			case BinXmlToken.XSD_KATMAI_DATEOFFSET:
				return BinXmlDateTime.XsdKatmaiDateOffsetToString(data, tokDataPos);
			case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
				return BinXmlDateTime.XsdKatmaiDateTimeOffsetToString(data, tokDataPos);
			case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
				return BinXmlDateTime.XsdKatmaiTimeOffsetToString(data, tokDataPos);
			default:
				throw ThrowUnexpectedToken(token);
			}
		}

		private string ValueAsString(BinXmlToken token)
		{
			try
			{
				CheckValueTokenBounds();
				switch (token)
				{
				case BinXmlToken.SQL_NCHAR:
				case BinXmlToken.SQL_NVARCHAR:
				case BinXmlToken.SQL_NTEXT:
					return GetString(tokDataPos, tokLen);
				case BinXmlToken.XSD_BOOLEAN:
					if (data[tokDataPos] == 0)
					{
						return "false";
					}
					return "true";
				case BinXmlToken.SQL_SMALLINT:
				case BinXmlToken.SQL_INT:
				case BinXmlToken.SQL_BIT:
				case BinXmlToken.SQL_TINYINT:
				case BinXmlToken.SQL_BIGINT:
				case BinXmlToken.XSD_BYTE:
				case BinXmlToken.XSD_UNSIGNEDSHORT:
				case BinXmlToken.XSD_UNSIGNEDINT:
					return ValueAsLong().ToString(CultureInfo.InvariantCulture);
				case BinXmlToken.XSD_UNSIGNEDLONG:
					return ValueAsULong().ToString(CultureInfo.InvariantCulture);
				case BinXmlToken.SQL_REAL:
					return XmlConvert.ToString(GetSingle(tokDataPos));
				case BinXmlToken.SQL_FLOAT:
					return XmlConvert.ToString(GetDouble(tokDataPos));
				case BinXmlToken.SQL_UUID:
				{
					int num3 = tokDataPos;
					int int2 = GetInt32(num3);
					short int3 = GetInt16(num3 + 4);
					short int4 = GetInt16(num3 + 6);
					return new Guid(int2, int3, int4, data[num3 + 8], data[num3 + 9], data[num3 + 10], data[num3 + 11], data[num3 + 12], data[num3 + 13], data[num3 + 14], data[num3 + 15]).ToString();
				}
				case BinXmlToken.SQL_SMALLMONEY:
					return new BinXmlSqlMoney(GetInt32(tokDataPos)).ToString();
				case BinXmlToken.SQL_MONEY:
					return new BinXmlSqlMoney(GetInt64(tokDataPos)).ToString();
				case BinXmlToken.SQL_DECIMAL:
				case BinXmlToken.SQL_NUMERIC:
				case BinXmlToken.XSD_DECIMAL:
					return new BinXmlSqlDecimal(data, tokDataPos, token == BinXmlToken.XSD_DECIMAL).ToString();
				case BinXmlToken.SQL_CHAR:
				case BinXmlToken.SQL_VARCHAR:
				case BinXmlToken.SQL_TEXT:
				{
					int num2 = tokDataPos;
					int @int = GetInt32(num2);
					Encoding encoding = Encoding.GetEncoding(@int);
					return encoding.GetString(data, num2 + 4, tokLen - 4);
				}
				case BinXmlToken.SQL_BINARY:
				case BinXmlToken.SQL_VARBINARY:
				case BinXmlToken.SQL_IMAGE:
				case BinXmlToken.SQL_UDT:
				case BinXmlToken.XSD_BASE64:
					return Convert.ToBase64String(data, tokDataPos, tokLen);
				case BinXmlToken.XSD_BINHEX:
					return BinHexEncoder.Encode(data, tokDataPos, tokLen);
				case BinXmlToken.SQL_DATETIME:
				case BinXmlToken.SQL_SMALLDATETIME:
				case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
				case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
				case BinXmlToken.XSD_KATMAI_DATEOFFSET:
				case BinXmlToken.XSD_KATMAI_TIME:
				case BinXmlToken.XSD_KATMAI_DATETIME:
				case BinXmlToken.XSD_KATMAI_DATE:
				case BinXmlToken.XSD_TIME:
				case BinXmlToken.XSD_DATETIME:
				case BinXmlToken.XSD_DATE:
					return ValueAsDateTimeString();
				case BinXmlToken.XSD_QNAME:
				{
					int num = ParseMB32(tokDataPos);
					if (num < 0 || num >= symbolTables.qnameCount)
					{
						throw new XmlException("XmlBin_InvalidQNameID", string.Empty);
					}
					QName qName = symbolTables.qnametable[num];
					if (qName.prefix.Length == 0)
					{
						return qName.localname;
					}
					return qName.prefix + ":" + qName.localname;
				}
				default:
					throw ThrowUnexpectedToken(this.token);
				}
			}
			catch
			{
				state = ScanState.Error;
				throw;
			}
		}

		private object ValueAsObject(BinXmlToken token, bool returnInternalTypes)
		{
			CheckValueTokenBounds();
			switch (token)
			{
			case BinXmlToken.SQL_NCHAR:
			case BinXmlToken.SQL_NVARCHAR:
			case BinXmlToken.SQL_NTEXT:
				return GetString(tokDataPos, tokLen);
			case BinXmlToken.XSD_BOOLEAN:
				return 0 != data[tokDataPos];
			case BinXmlToken.SQL_BIT:
				return (int)data[tokDataPos];
			case BinXmlToken.SQL_TINYINT:
				return data[tokDataPos];
			case BinXmlToken.SQL_SMALLINT:
				return GetInt16(tokDataPos);
			case BinXmlToken.SQL_INT:
				return GetInt32(tokDataPos);
			case BinXmlToken.SQL_BIGINT:
				return GetInt64(tokDataPos);
			case BinXmlToken.XSD_BYTE:
			{
				sbyte b = (sbyte)data[tokDataPos];
				return b;
			}
			case BinXmlToken.XSD_UNSIGNEDSHORT:
				return GetUInt16(tokDataPos);
			case BinXmlToken.XSD_UNSIGNEDINT:
				return GetUInt32(tokDataPos);
			case BinXmlToken.XSD_UNSIGNEDLONG:
				return GetUInt64(tokDataPos);
			case BinXmlToken.SQL_REAL:
				return GetSingle(tokDataPos);
			case BinXmlToken.SQL_FLOAT:
				return GetDouble(tokDataPos);
			case BinXmlToken.SQL_UUID:
			{
				int num3 = tokDataPos;
				int int2 = GetInt32(num3);
				short int3 = GetInt16(num3 + 4);
				short int4 = GetInt16(num3 + 6);
				return new Guid(int2, int3, int4, data[num3 + 8], data[num3 + 9], data[num3 + 10], data[num3 + 11], data[num3 + 12], data[num3 + 13], data[num3 + 14], data[num3 + 15]).ToString();
			}
			case BinXmlToken.SQL_SMALLMONEY:
			{
				BinXmlSqlMoney binXmlSqlMoney2 = new BinXmlSqlMoney(GetInt32(tokDataPos));
				if (returnInternalTypes)
				{
					return binXmlSqlMoney2;
				}
				return binXmlSqlMoney2.ToDecimal();
			}
			case BinXmlToken.SQL_MONEY:
			{
				BinXmlSqlMoney binXmlSqlMoney = new BinXmlSqlMoney(GetInt64(tokDataPos));
				if (returnInternalTypes)
				{
					return binXmlSqlMoney;
				}
				return binXmlSqlMoney.ToDecimal();
			}
			case BinXmlToken.SQL_DECIMAL:
			case BinXmlToken.SQL_NUMERIC:
			case BinXmlToken.XSD_DECIMAL:
			{
				BinXmlSqlDecimal binXmlSqlDecimal = new BinXmlSqlDecimal(data, tokDataPos, token == BinXmlToken.XSD_DECIMAL);
				if (returnInternalTypes)
				{
					return binXmlSqlDecimal;
				}
				return binXmlSqlDecimal.ToDecimal();
			}
			case BinXmlToken.SQL_CHAR:
			case BinXmlToken.SQL_VARCHAR:
			case BinXmlToken.SQL_TEXT:
			{
				int num2 = tokDataPos;
				int @int = GetInt32(num2);
				Encoding encoding = Encoding.GetEncoding(@int);
				return encoding.GetString(data, num2 + 4, tokLen - 4);
			}
			case BinXmlToken.SQL_BINARY:
			case BinXmlToken.SQL_VARBINARY:
			case BinXmlToken.SQL_IMAGE:
			case BinXmlToken.SQL_UDT:
			case BinXmlToken.XSD_BINHEX:
			case BinXmlToken.XSD_BASE64:
			{
				byte[] array = new byte[tokLen];
				Array.Copy(data, tokDataPos, array, 0, tokLen);
				return array;
			}
			case BinXmlToken.SQL_DATETIME:
			case BinXmlToken.SQL_SMALLDATETIME:
			case BinXmlToken.XSD_KATMAI_TIME:
			case BinXmlToken.XSD_KATMAI_DATETIME:
			case BinXmlToken.XSD_KATMAI_DATE:
			case BinXmlToken.XSD_TIME:
			case BinXmlToken.XSD_DATETIME:
			case BinXmlToken.XSD_DATE:
				return ValueAsDateTime();
			case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
			case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
			case BinXmlToken.XSD_KATMAI_DATEOFFSET:
				return ValueAsDateTimeOffset();
			case BinXmlToken.XSD_QNAME:
			{
				int num = ParseMB32(tokDataPos);
				if (num < 0 || num >= symbolTables.qnameCount)
				{
					throw new XmlException("XmlBin_InvalidQNameID", string.Empty);
				}
				QName qName = symbolTables.qnametable[num];
				return new XmlQualifiedName(qName.localname, qName.namespaceUri);
			}
			default:
				throw ThrowUnexpectedToken(this.token);
			}
		}

		private XmlValueConverter GetValueConverter(XmlTypeCode typeCode)
		{
			XmlSchemaSimpleType simpleTypeFromTypeCode = DatatypeImplementation.GetSimpleTypeFromTypeCode(typeCode);
			return simpleTypeFromTypeCode.ValueConverter;
		}

		private object ValueAs(BinXmlToken token, Type returnType, IXmlNamespaceResolver namespaceResolver)
		{
			CheckValueTokenBounds();
			switch (token)
			{
			case BinXmlToken.SQL_NCHAR:
			case BinXmlToken.SQL_NVARCHAR:
			case BinXmlToken.SQL_NTEXT:
				return GetValueConverter(XmlTypeCode.String).ChangeType(GetString(tokDataPos, tokLen), returnType, namespaceResolver);
			case BinXmlToken.XSD_BOOLEAN:
				return GetValueConverter(XmlTypeCode.Boolean).ChangeType(0 != data[tokDataPos], returnType, namespaceResolver);
			case BinXmlToken.SQL_BIT:
				return GetValueConverter(XmlTypeCode.NonNegativeInteger).ChangeType((int)data[tokDataPos], returnType, namespaceResolver);
			case BinXmlToken.SQL_TINYINT:
				return GetValueConverter(XmlTypeCode.UnsignedByte).ChangeType(data[tokDataPos], returnType, namespaceResolver);
			case BinXmlToken.SQL_SMALLINT:
			{
				int @int = GetInt16(tokDataPos);
				return GetValueConverter(XmlTypeCode.Short).ChangeType(@int, returnType, namespaceResolver);
			}
			case BinXmlToken.SQL_INT:
			{
				int int2 = GetInt32(tokDataPos);
				return GetValueConverter(XmlTypeCode.Int).ChangeType(int2, returnType, namespaceResolver);
			}
			case BinXmlToken.SQL_BIGINT:
			{
				long int4 = GetInt64(tokDataPos);
				return GetValueConverter(XmlTypeCode.Long).ChangeType(int4, returnType, namespaceResolver);
			}
			case BinXmlToken.XSD_BYTE:
				return GetValueConverter(XmlTypeCode.Byte).ChangeType((int)(sbyte)data[tokDataPos], returnType, namespaceResolver);
			case BinXmlToken.XSD_UNSIGNEDSHORT:
			{
				int uInt = GetUInt16(tokDataPos);
				return GetValueConverter(XmlTypeCode.UnsignedShort).ChangeType(uInt, returnType, namespaceResolver);
			}
			case BinXmlToken.XSD_UNSIGNEDINT:
			{
				long num4 = GetUInt32(tokDataPos);
				return GetValueConverter(XmlTypeCode.UnsignedInt).ChangeType(num4, returnType, namespaceResolver);
			}
			case BinXmlToken.XSD_UNSIGNEDLONG:
			{
				decimal num3 = GetUInt64(tokDataPos);
				return GetValueConverter(XmlTypeCode.UnsignedLong).ChangeType(num3, returnType, namespaceResolver);
			}
			case BinXmlToken.SQL_REAL:
			{
				float single = GetSingle(tokDataPos);
				return GetValueConverter(XmlTypeCode.Float).ChangeType(single, returnType, namespaceResolver);
			}
			case BinXmlToken.SQL_FLOAT:
			{
				double @double = GetDouble(tokDataPos);
				return GetValueConverter(XmlTypeCode.Double).ChangeType(@double, returnType, namespaceResolver);
			}
			case BinXmlToken.SQL_UUID:
				return GetValueConverter(XmlTypeCode.String).ChangeType(ValueAsString(token), returnType, namespaceResolver);
			case BinXmlToken.SQL_SMALLMONEY:
				return GetValueConverter(XmlTypeCode.Decimal).ChangeType(new BinXmlSqlMoney(GetInt32(tokDataPos)).ToDecimal(), returnType, namespaceResolver);
			case BinXmlToken.SQL_MONEY:
				return GetValueConverter(XmlTypeCode.Decimal).ChangeType(new BinXmlSqlMoney(GetInt64(tokDataPos)).ToDecimal(), returnType, namespaceResolver);
			case BinXmlToken.SQL_DECIMAL:
			case BinXmlToken.SQL_NUMERIC:
			case BinXmlToken.XSD_DECIMAL:
				return GetValueConverter(XmlTypeCode.Decimal).ChangeType(new BinXmlSqlDecimal(data, tokDataPos, token == BinXmlToken.XSD_DECIMAL).ToDecimal(), returnType, namespaceResolver);
			case BinXmlToken.SQL_CHAR:
			case BinXmlToken.SQL_VARCHAR:
			case BinXmlToken.SQL_TEXT:
			{
				int num2 = tokDataPos;
				int int3 = GetInt32(num2);
				Encoding encoding = Encoding.GetEncoding(int3);
				return GetValueConverter(XmlTypeCode.UntypedAtomic).ChangeType(encoding.GetString(data, num2 + 4, tokLen - 4), returnType, namespaceResolver);
			}
			case BinXmlToken.SQL_BINARY:
			case BinXmlToken.SQL_VARBINARY:
			case BinXmlToken.SQL_IMAGE:
			case BinXmlToken.SQL_UDT:
			case BinXmlToken.XSD_BINHEX:
			case BinXmlToken.XSD_BASE64:
			{
				byte[] array = new byte[tokLen];
				Array.Copy(data, tokDataPos, array, 0, tokLen);
				return GetValueConverter((token == BinXmlToken.XSD_BINHEX) ? XmlTypeCode.HexBinary : XmlTypeCode.Base64Binary).ChangeType(array, returnType, namespaceResolver);
			}
			case BinXmlToken.SQL_DATETIME:
			case BinXmlToken.SQL_SMALLDATETIME:
			case BinXmlToken.XSD_KATMAI_TIME:
			case BinXmlToken.XSD_KATMAI_DATETIME:
			case BinXmlToken.XSD_KATMAI_DATE:
			case BinXmlToken.XSD_DATETIME:
				return GetValueConverter(XmlTypeCode.DateTime).ChangeType(ValueAsDateTime(), returnType, namespaceResolver);
			case BinXmlToken.XSD_KATMAI_TIMEOFFSET:
			case BinXmlToken.XSD_KATMAI_DATETIMEOFFSET:
			case BinXmlToken.XSD_KATMAI_DATEOFFSET:
				return GetValueConverter(XmlTypeCode.DateTime).ChangeType(ValueAsDateTimeOffset(), returnType, namespaceResolver);
			case BinXmlToken.XSD_TIME:
				return GetValueConverter(XmlTypeCode.Time).ChangeType(ValueAsDateTime(), returnType, namespaceResolver);
			case BinXmlToken.XSD_DATE:
				return GetValueConverter(XmlTypeCode.Date).ChangeType(ValueAsDateTime(), returnType, namespaceResolver);
			case BinXmlToken.XSD_QNAME:
			{
				int num = ParseMB32(tokDataPos);
				if (num < 0 || num >= symbolTables.qnameCount)
				{
					throw new XmlException("XmlBin_InvalidQNameID", string.Empty);
				}
				QName qName = symbolTables.qnametable[num];
				return GetValueConverter(XmlTypeCode.QName).ChangeType(new XmlQualifiedName(qName.localname, qName.namespaceUri), returnType, namespaceResolver);
			}
			default:
				throw ThrowUnexpectedToken(this.token);
			}
		}

		private short GetInt16(int pos)
		{
			byte[] array = data;
			return (short)(array[pos] | (array[pos + 1] << 8));
		}

		private ushort GetUInt16(int pos)
		{
			byte[] array = data;
			return (ushort)(array[pos] | (array[pos + 1] << 8));
		}

		private int GetInt32(int pos)
		{
			byte[] array = data;
			return array[pos] | (array[pos + 1] << 8) | (array[pos + 2] << 16) | (array[pos + 3] << 24);
		}

		private uint GetUInt32(int pos)
		{
			byte[] array = data;
			return (uint)(array[pos] | (array[pos + 1] << 8) | (array[pos + 2] << 16) | (array[pos + 3] << 24));
		}

		private long GetInt64(int pos)
		{
			byte[] array = data;
			uint num = (uint)(array[pos] | (array[pos + 1] << 8) | (array[pos + 2] << 16) | (array[pos + 3] << 24));
			uint num2 = (uint)(array[pos + 4] | (array[pos + 5] << 8) | (array[pos + 6] << 16) | (array[pos + 7] << 24));
			return (long)(((ulong)num2 << 32) | num);
		}

		private ulong GetUInt64(int pos)
		{
			byte[] array = data;
			uint num = (uint)(array[pos] | (array[pos + 1] << 8) | (array[pos + 2] << 16) | (array[pos + 3] << 24));
			uint num2 = (uint)(array[pos + 4] | (array[pos + 5] << 8) | (array[pos + 6] << 16) | (array[pos + 7] << 24));
			return ((ulong)num2 << 32) | num;
		}

		private unsafe float GetSingle(int offset)
		{
			byte[] array = data;
			uint num = (uint)(array[offset] | (array[offset + 1] << 8) | (array[offset + 2] << 16) | (array[offset + 3] << 24));
			return *(float*)(&num);
		}

		private unsafe double GetDouble(int offset)
		{
			uint num = (uint)(data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24));
			uint num2 = (uint)(data[offset + 4] | (data[offset + 5] << 8) | (data[offset + 6] << 16) | (data[offset + 7] << 24));
			ulong num3 = ((ulong)num2 << 32) | num;
			return *(double*)(&num3);
		}

		private Exception ThrowUnexpectedToken(BinXmlToken token)
		{
			return ThrowXmlException("XmlBinary_UnexpectedToken");
		}

		private Exception ThrowXmlException(string res)
		{
			state = ScanState.Error;
			return new XmlException(res, (string[])null);
		}

		private Exception ThrowXmlException(string res, string arg1, string arg2)
		{
			state = ScanState.Error;
			return new XmlException(res, new string[2] { arg1, arg2 });
		}

		private Exception ThrowNotSupported(string res)
		{
			state = ScanState.Error;
			return new NotSupportedException(Res.GetString(res));
		}
	}
}
namespace MS.Internal.Xml.Cache
{
	internal enum TextBlockType
	{
		None = 0,
		Text = 4,
		SignificantWhitespace = 5,
		Whitespace = 6
	}
	internal sealed class XPathDocumentBuilder : XmlRawWriter
	{
		private struct NodePageFactory
		{
			private XPathNode[] page;

			private XPathNodePageInfo pageInfo;

			private int pageSize;

			public XPathNode[] NextNodePage => page;

			public int NextNodeIndex => pageInfo.NodeCount;

			public void Init(int initialPageSize)
			{
				pageSize = initialPageSize;
				page = new XPathNode[pageSize];
				pageInfo = new XPathNodePageInfo(null, 1);
				page[0].Create(pageInfo);
			}

			public void AllocateSlot(out XPathNode[] page, out int idx)
			{
				page = this.page;
				idx = pageInfo.NodeCount;
				if (++pageInfo.NodeCount >= this.page.Length)
				{
					if (pageSize < 65536)
					{
						pageSize *= 2;
					}
					this.page = new XPathNode[pageSize];
					pageInfo.NextPage = this.page;
					pageInfo = new XPathNodePageInfo(page, pageInfo.PageNumber + 1);
					this.page[0].Create(pageInfo);
				}
			}
		}

		private struct TextBlockBuilder
		{
			private IXmlLineInfo lineInfo;

			private TextBlockType textType;

			private string text;

			private int lineNum;

			private int linePos;

			public TextBlockType TextType => textType;

			public bool HasText => textType != TextBlockType.None;

			public int LineNumber => lineNum;

			public int LinePosition => linePos;

			public void Initialize(IXmlLineInfo lineInfo)
			{
				this.lineInfo = lineInfo;
				textType = TextBlockType.None;
			}

			public void WriteTextBlock(string text, TextBlockType textType)
			{
				if (text.Length == 0)
				{
					return;
				}
				if (this.textType == TextBlockType.None)
				{
					this.text = text;
					this.textType = textType;
					if (lineInfo != null)
					{
						lineNum = lineInfo.LineNumber;
						linePos = lineInfo.LinePosition;
					}
				}
				else
				{
					this.text += text;
					if (textType < this.textType)
					{
						this.textType = textType;
					}
				}
			}

			public string ReadText()
			{
				if (textType == TextBlockType.None)
				{
					return string.Empty;
				}
				textType = TextBlockType.None;
				return text;
			}
		}

		private const int ElementIndexSize = 64;

		private NodePageFactory nodePageFact;

		private NodePageFactory nmspPageFact;

		private TextBlockBuilder textBldr;

		private Stack<XPathNodeRef> stkNmsp;

		private XPathNodeInfoTable infoTable;

		private XPathDocument doc;

		private IXmlLineInfo lineInfo;

		private XmlNameTable nameTable;

		private bool atomizeNames;

		private XPathNode[] pageNmsp;

		private int idxNmsp;

		private XPathNode[] pageParent;

		private int idxParent;

		private XPathNode[] pageSibling;

		private int idxSibling;

		private int lineNumBase;

		private int linePosBase;

		private XmlQualifiedName idAttrName;

		private Hashtable elemIdMap;

		private XPathNodeRef[] elemNameIndex;

		public XPathDocumentBuilder(XPathDocument doc, IXmlLineInfo lineInfo, string baseUri, XPathDocument.LoadFlags flags)
		{
			nodePageFact.Init(256);
			nmspPageFact.Init(16);
			stkNmsp = new Stack<XPathNodeRef>();
			Initialize(doc, lineInfo, baseUri, flags);
		}

		public void Initialize(XPathDocument doc, IXmlLineInfo lineInfo, string baseUri, XPathDocument.LoadFlags flags)
		{
			this.doc = doc;
			nameTable = doc.NameTable;
			atomizeNames = (flags & XPathDocument.LoadFlags.AtomizeNames) != 0;
			idxParent = (idxSibling = 0);
			elemNameIndex = new XPathNodeRef[64];
			textBldr.Initialize(lineInfo);
			this.lineInfo = lineInfo;
			lineNumBase = 0;
			linePosBase = 0;
			infoTable = new XPathNodeInfoTable();
			XPathNode[] page;
			int idxText = NewNode(out page, XPathNodeType.Text, string.Empty, string.Empty, string.Empty, string.Empty);
			this.doc.SetCollapsedTextNode(page, idxText);
			idxNmsp = NewNamespaceNode(out pageNmsp, nameTable.Add("xml"), nameTable.Add("http://www.w3.org/XML/1998/namespace"), null, 0);
			this.doc.SetXmlNamespaceNode(pageNmsp, idxNmsp);
			if ((flags & XPathDocument.LoadFlags.Fragment) == 0)
			{
				idxParent = NewNode(out pageParent, XPathNodeType.Root, string.Empty, string.Empty, string.Empty, baseUri);
				this.doc.SetRootNode(pageParent, idxParent);
			}
			else
			{
				this.doc.SetRootNode(nodePageFact.NextNodePage, nodePageFact.NextNodeIndex);
			}
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			WriteStartElement(prefix, localName, ns, string.Empty);
		}

		public void WriteStartElement(string prefix, string localName, string ns, string baseUri)
		{
			if (atomizeNames)
			{
				prefix = nameTable.Add(prefix);
				localName = nameTable.Add(localName);
				ns = nameTable.Add(ns);
			}
			AddSibling(XPathNodeType.Element, localName, ns, prefix, baseUri);
			pageParent = pageSibling;
			idxParent = idxSibling;
			idxSibling = 0;
			int num = pageParent[idxParent].LocalNameHashCode & 0x3F;
			ref XPathNodeRef reference = ref elemNameIndex[num];
			reference = LinkSimilarElements(elemNameIndex[num].Page, elemNameIndex[num].Index, pageParent, idxParent);
			if (elemIdMap != null)
			{
				idAttrName = (XmlQualifiedName)elemIdMap[new XmlQualifiedName(localName, prefix)];
			}
		}

		public override void WriteEndElement()
		{
			WriteEndElement(allowShortcutTag: true);
		}

		public override void WriteFullEndElement()
		{
			WriteEndElement(allowShortcutTag: false);
		}

		internal override void WriteEndElement(string prefix, string localName, string namespaceName)
		{
			WriteEndElement(allowShortcutTag: true);
		}

		internal override void WriteFullEndElement(string prefix, string localName, string namespaceName)
		{
			WriteEndElement(allowShortcutTag: false);
		}

		public void WriteEndElement(bool allowShortcutTag)
		{
			if (!pageParent[idxParent].HasContentChild)
			{
				switch (textBldr.TextType)
				{
				case TextBlockType.Text:
					if (lineInfo == null)
					{
						goto IL_00b1;
					}
					if (textBldr.LineNumber == pageParent[idxParent].LineNumber)
					{
						int num = textBldr.LinePosition - pageParent[idxParent].LinePosition;
						if (num >= 0 && num <= 255)
						{
							pageParent[idxParent].SetCollapsedLineInfoOffset(num);
							goto IL_00b1;
						}
					}
					goto case TextBlockType.SignificantWhitespace;
				case TextBlockType.SignificantWhitespace:
				case TextBlockType.Whitespace:
					CachedTextNode();
					pageParent[idxParent].SetValue(pageSibling[idxSibling].Value);
					break;
				default:
					{
						pageParent[idxParent].SetEmptyValue(allowShortcutTag);
						break;
					}
					IL_00b1:
					pageParent[idxParent].SetCollapsedValue(textBldr.ReadText());
					break;
				}
			}
			else if (textBldr.HasText)
			{
				CachedTextNode();
			}
			if (pageParent[idxParent].HasNamespaceDecls)
			{
				doc.AddNamespace(pageParent, idxParent, pageNmsp, idxNmsp);
				XPathNodeRef xPathNodeRef = stkNmsp.Pop();
				pageNmsp = xPathNodeRef.Page;
				idxNmsp = xPathNodeRef.Index;
			}
			pageSibling = pageParent;
			idxSibling = idxParent;
			idxParent = pageParent[idxParent].GetParent(out pageParent);
		}

		public override void WriteStartAttribute(string prefix, string localName, string namespaceName)
		{
			if (atomizeNames)
			{
				prefix = nameTable.Add(prefix);
				localName = nameTable.Add(localName);
				namespaceName = nameTable.Add(namespaceName);
			}
			AddSibling(XPathNodeType.Attribute, localName, namespaceName, prefix, string.Empty);
		}

		public override void WriteEndAttribute()
		{
			pageSibling[idxSibling].SetValue(textBldr.ReadText());
			if (idAttrName != null && pageSibling[idxSibling].LocalName == idAttrName.Name && pageSibling[idxSibling].Prefix == idAttrName.Namespace)
			{
				doc.AddIdElement(pageSibling[idxSibling].Value, pageParent, idxParent);
			}
		}

		public override void WriteCData(string text)
		{
			WriteString(text, TextBlockType.Text);
		}

		public override void WriteComment(string text)
		{
			AddSibling(XPathNodeType.Comment, string.Empty, string.Empty, string.Empty, string.Empty);
			pageSibling[idxSibling].SetValue(text);
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			WriteProcessingInstruction(name, text, string.Empty);
		}

		public void WriteProcessingInstruction(string name, string text, string baseUri)
		{
			if (atomizeNames)
			{
				name = nameTable.Add(name);
			}
			AddSibling(XPathNodeType.ProcessingInstruction, name, string.Empty, string.Empty, baseUri);
			pageSibling[idxSibling].SetValue(text);
		}

		public override void WriteWhitespace(string ws)
		{
			WriteString(ws, TextBlockType.Whitespace);
		}

		public override void WriteString(string text)
		{
			WriteString(text, TextBlockType.Text);
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			WriteString(new string(buffer, index, count), TextBlockType.Text);
		}

		public override void WriteRaw(string data)
		{
			WriteString(data, TextBlockType.Text);
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			WriteString(new string(buffer, index, count), TextBlockType.Text);
		}

		public void WriteString(string text, TextBlockType textType)
		{
			textBldr.WriteTextBlock(text, textType);
		}

		public override void WriteEntityRef(string name)
		{
			throw new NotImplementedException();
		}

		public override void WriteCharEntity(char ch)
		{
			char[] value = new char[1] { ch };
			WriteString(new string(value), TextBlockType.Text);
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			char[] value = new char[2] { highChar, lowChar };
			WriteString(new string(value), TextBlockType.Text);
		}

		public override void Close()
		{
			if (textBldr.HasText)
			{
				CachedTextNode();
			}
			XPathNode[] pageRoot;
			int rootNode = doc.GetRootNode(out pageRoot);
			if (rootNode == nodePageFact.NextNodeIndex && pageRoot == nodePageFact.NextNodePage)
			{
				AddSibling(XPathNodeType.Text, string.Empty, string.Empty, string.Empty, string.Empty);
				pageSibling[idxSibling].SetValue(string.Empty);
			}
		}

		public override void Flush()
		{
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
		}

		internal override void StartElementContent()
		{
		}

		internal override void WriteNamespaceDeclaration(string prefix, string namespaceName)
		{
			if (atomizeNames)
			{
				prefix = nameTable.Add(prefix);
			}
			namespaceName = nameTable.Add(namespaceName);
			XPathNode[] pageNode = pageNmsp;
			int sibling = idxNmsp;
			while (sibling != 0 && (object)pageNode[sibling].LocalName != prefix)
			{
				sibling = pageNode[sibling].GetSibling(out pageNode);
			}
			XPathNode[] page;
			int num = NewNamespaceNode(out page, prefix, namespaceName, pageParent, idxParent);
			if (sibling != 0)
			{
				XPathNode[] pageNode2 = pageNmsp;
				int sibling2 = idxNmsp;
				XPathNode[] array = page;
				int num2 = num;
				while (sibling2 != sibling || pageNode2 != pageNode)
				{
					int parent = pageNode2[sibling2].GetParent(out var pageNode3);
					parent = NewNamespaceNode(out pageNode3, pageNode2[sibling2].LocalName, pageNode2[sibling2].Value, pageNode3, parent);
					array[num2].SetSibling(infoTable, pageNode3, parent);
					array = pageNode3;
					num2 = parent;
					sibling2 = pageNode2[sibling2].GetSibling(out pageNode2);
				}
				sibling = pageNode[sibling].GetSibling(out pageNode);
				if (sibling != 0)
				{
					array[num2].SetSibling(infoTable, pageNode, sibling);
				}
			}
			else if (idxParent != 0)
			{
				page[num].SetSibling(infoTable, pageNmsp, idxNmsp);
			}
			else
			{
				doc.SetRootNode(page, num);
			}
			if (idxParent != 0)
			{
				if (!pageParent[idxParent].HasNamespaceDecls)
				{
					stkNmsp.Push(new XPathNodeRef(pageNmsp, idxNmsp));
					pageParent[idxParent].HasNamespaceDecls = true;
				}
				pageNmsp = page;
				idxNmsp = num;
			}
		}

		public void CreateIdTables(SchemaInfo schInfo)
		{
			foreach (SchemaElementDecl value in schInfo.ElementDecls.Values)
			{
				if (value.AttDefs == null)
				{
					continue;
				}
				foreach (SchemaAttDef value2 in value.AttDefs.Values)
				{
					if (value2.Datatype.TokenizedType == XmlTokenizedType.ID)
					{
						if (elemIdMap == null)
						{
							elemIdMap = new Hashtable();
						}
						elemIdMap.Add(value.Name, value2.Name);
						break;
					}
				}
			}
		}

		private XPathNodeRef LinkSimilarElements(XPathNode[] pagePrev, int idxPrev, XPathNode[] pageNext, int idxNext)
		{
			pagePrev?[idxPrev].SetSimilarElement(infoTable, pageNext, idxNext);
			return new XPathNodeRef(pageNext, idxNext);
		}

		private int NewNamespaceNode(out XPathNode[] page, string prefix, string namespaceUri, XPathNode[] pageElem, int idxElem)
		{
			nmspPageFact.AllocateSlot(out var page2, out var idx);
			ComputeLineInfo(isTextNode: false, out var lineNumOffset, out var linePosOffset);
			XPathNodeInfoAtom info = infoTable.Create(prefix, string.Empty, string.Empty, string.Empty, pageElem, page2, null, doc, lineNumBase, linePosBase);
			page2[idx].Create(info, XPathNodeType.Namespace, idxElem);
			page2[idx].SetValue(namespaceUri);
			page2[idx].SetLineInfoOffsets(lineNumOffset, linePosOffset);
			page = page2;
			return idx;
		}

		private int NewNode(out XPathNode[] page, XPathNodeType xptyp, string localName, string namespaceUri, string prefix, string baseUri)
		{
			nodePageFact.AllocateSlot(out var page2, out var idx);
			ComputeLineInfo(XPathNavigator.IsText(xptyp), out var lineNumOffset, out var linePosOffset);
			XPathNodeInfoAtom info = infoTable.Create(localName, namespaceUri, prefix, baseUri, pageParent, page2, page2, doc, lineNumBase, linePosBase);
			page2[idx].Create(info, xptyp, idxParent);
			page2[idx].SetLineInfoOffsets(lineNumOffset, linePosOffset);
			page = page2;
			return idx;
		}

		private void ComputeLineInfo(bool isTextNode, out int lineNumOffset, out int linePosOffset)
		{
			if (lineInfo == null)
			{
				lineNumOffset = 0;
				linePosOffset = 0;
				return;
			}
			int lineNumber;
			int linePosition;
			if (isTextNode)
			{
				lineNumber = textBldr.LineNumber;
				linePosition = textBldr.LinePosition;
			}
			else
			{
				lineNumber = lineInfo.LineNumber;
				linePosition = lineInfo.LinePosition;
			}
			lineNumOffset = lineNumber - lineNumBase;
			if (lineNumOffset < 0 || lineNumOffset > 16383)
			{
				lineNumBase = lineNumber;
				lineNumOffset = 0;
			}
			linePosOffset = linePosition - linePosBase;
			if (linePosOffset < 0 || linePosOffset > 65535)
			{
				linePosBase = linePosition;
				linePosOffset = 0;
			}
		}

		private void AddSibling(XPathNodeType xptyp, string localName, string namespaceUri, string prefix, string baseUri)
		{
			if (textBldr.HasText)
			{
				CachedTextNode();
			}
			XPathNode[] page;
			int num = NewNode(out page, xptyp, localName, namespaceUri, prefix, baseUri);
			if (idxParent != 0)
			{
				pageParent[idxParent].SetParentProperties(xptyp);
				if (idxSibling != 0)
				{
					pageSibling[idxSibling].SetSibling(infoTable, page, num);
				}
			}
			pageSibling = page;
			idxSibling = num;
		}

		private void CachedTextNode()
		{
			TextBlockType textType = textBldr.TextType;
			string value = textBldr.ReadText();
			AddSibling((XPathNodeType)textType, string.Empty, string.Empty, string.Empty, string.Empty);
			pageSibling[idxSibling].SetValue(value);
		}
	}
	internal abstract class XPathDocumentBaseIterator : XPathNodeIterator
	{
		protected XPathDocumentNavigator ctxt;

		protected int pos;

		public override XPathNavigator Current => ctxt;

		public override int CurrentPosition => pos;

		protected XPathDocumentBaseIterator(XPathDocumentNavigator ctxt)
		{
			this.ctxt = new XPathDocumentNavigator(ctxt);
		}

		protected XPathDocumentBaseIterator(XPathDocumentBaseIterator iter)
		{
			ctxt = new XPathDocumentNavigator(iter.ctxt);
			pos = iter.pos;
		}
	}
	internal class XPathDocumentElementChildIterator : XPathDocumentBaseIterator
	{
		private string localName;

		private string namespaceUri;

		public XPathDocumentElementChildIterator(XPathDocumentNavigator parent, string name, string namespaceURI)
			: base(parent)
		{
			if (namespaceURI == null)
			{
				throw new ArgumentNullException("namespaceURI");
			}
			localName = parent.NameTable.Get(name);
			namespaceUri = namespaceURI;
		}

		public XPathDocumentElementChildIterator(XPathDocumentElementChildIterator iter)
			: base(iter)
		{
			localName = iter.localName;
			namespaceUri = iter.namespaceUri;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathDocumentElementChildIterator(this);
		}

		public override bool MoveNext()
		{
			if (pos == 0)
			{
				if (!ctxt.MoveToChild(localName, namespaceUri))
				{
					return false;
				}
			}
			else if (!ctxt.MoveToNext(localName, namespaceUri))
			{
				return false;
			}
			pos++;
			return true;
		}
	}
	internal class XPathDocumentKindChildIterator : XPathDocumentBaseIterator
	{
		private XPathNodeType typ;

		public XPathDocumentKindChildIterator(XPathDocumentNavigator parent, XPathNodeType typ)
			: base(parent)
		{
			this.typ = typ;
		}

		public XPathDocumentKindChildIterator(XPathDocumentKindChildIterator iter)
			: base(iter)
		{
			typ = iter.typ;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathDocumentKindChildIterator(this);
		}

		public override bool MoveNext()
		{
			if (pos == 0)
			{
				if (!ctxt.MoveToChild(typ))
				{
					return false;
				}
			}
			else if (!ctxt.MoveToNext(typ))
			{
				return false;
			}
			pos++;
			return true;
		}
	}
	internal class XPathDocumentElementDescendantIterator : XPathDocumentBaseIterator
	{
		private XPathDocumentNavigator end;

		private string localName;

		private string namespaceUri;

		private bool matchSelf;

		public XPathDocumentElementDescendantIterator(XPathDocumentNavigator root, string name, string namespaceURI, bool matchSelf)
			: base(root)
		{
			if (namespaceURI == null)
			{
				throw new ArgumentNullException("namespaceURI");
			}
			localName = root.NameTable.Get(name);
			namespaceUri = namespaceURI;
			this.matchSelf = matchSelf;
			if (root.NodeType != 0)
			{
				end = new XPathDocumentNavigator(root);
				end.MoveToNonDescendant();
			}
		}

		public XPathDocumentElementDescendantIterator(XPathDocumentElementDescendantIterator iter)
			: base(iter)
		{
			end = iter.end;
			localName = iter.localName;
			namespaceUri = iter.namespaceUri;
			matchSelf = iter.matchSelf;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathDocumentElementDescendantIterator(this);
		}

		public override bool MoveNext()
		{
			if (matchSelf)
			{
				matchSelf = false;
				if (ctxt.IsElementMatch(localName, namespaceUri))
				{
					pos++;
					return true;
				}
			}
			if (!ctxt.MoveToFollowing(localName, namespaceUri, end))
			{
				return false;
			}
			pos++;
			return true;
		}
	}
	internal class XPathDocumentKindDescendantIterator : XPathDocumentBaseIterator
	{
		private XPathDocumentNavigator end;

		private XPathNodeType typ;

		private bool matchSelf;

		public XPathDocumentKindDescendantIterator(XPathDocumentNavigator root, XPathNodeType typ, bool matchSelf)
			: base(root)
		{
			this.typ = typ;
			this.matchSelf = matchSelf;
			if (root.NodeType != 0)
			{
				end = new XPathDocumentNavigator(root);
				end.MoveToNonDescendant();
			}
		}

		public XPathDocumentKindDescendantIterator(XPathDocumentKindDescendantIterator iter)
			: base(iter)
		{
			end = iter.end;
			typ = iter.typ;
			matchSelf = iter.matchSelf;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathDocumentKindDescendantIterator(this);
		}

		public override bool MoveNext()
		{
			if (matchSelf)
			{
				matchSelf = false;
				if (ctxt.IsKindMatch(typ))
				{
					pos++;
					return true;
				}
			}
			if (!ctxt.MoveToFollowing(typ, end))
			{
				return false;
			}
			pos++;
			return true;
		}
	}
	internal sealed class XPathDocumentNavigator : XPathNavigator, IXmlLineInfo
	{
		private XPathNode[] pageCurrent;

		private XPathNode[] pageParent;

		private int idxCurrent;

		private int idxParent;

		private string atomizedLocalName;

		public override string Value
		{
			get
			{
				string value = pageCurrent[idxCurrent].Value;
				if (value != null)
				{
					return value;
				}
				if (idxParent != 0)
				{
					return pageParent[idxParent].Value;
				}
				string text = string.Empty;
				StringBuilder stringBuilder = null;
				XPathNode[] pageNode;
				XPathNode[] array = (pageNode = pageCurrent);
				int idxNode;
				int num = (idxNode = idxCurrent);
				if (!XPathNodeHelper.GetNonDescendant(ref pageNode, ref idxNode))
				{
					pageNode = null;
					idxNode = 0;
				}
				while (XPathNodeHelper.GetTextFollowing(ref array, ref num, pageNode, idxNode))
				{
					if (text.Length == 0)
					{
						text = array[num].Value;
						continue;
					}
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder();
						stringBuilder.Append(text);
					}
					stringBuilder.Append(array[num].Value);
				}
				if (stringBuilder == null)
				{
					return text;
				}
				return stringBuilder.ToString();
			}
		}

		public override XPathNodeType NodeType => pageCurrent[idxCurrent].NodeType;

		public override string LocalName => pageCurrent[idxCurrent].LocalName;

		public override string NamespaceURI => pageCurrent[idxCurrent].NamespaceUri;

		public override string Name => pageCurrent[idxCurrent].Name;

		public override string Prefix => pageCurrent[idxCurrent].Prefix;

		public override string BaseURI
		{
			get
			{
				XPathNode[] pageNode;
				int parent;
				if (idxParent != 0)
				{
					pageNode = pageParent;
					parent = idxParent;
				}
				else
				{
					pageNode = pageCurrent;
					parent = idxCurrent;
				}
				do
				{
					switch (pageNode[parent].NodeType)
					{
					case XPathNodeType.Root:
					case XPathNodeType.Element:
					case XPathNodeType.ProcessingInstruction:
						return pageNode[parent].BaseUri;
					}
					parent = pageNode[parent].GetParent(out pageNode);
				}
				while (parent != 0);
				return string.Empty;
			}
		}

		public override bool IsEmptyElement => pageCurrent[idxCurrent].AllowShortcutTag;

		public override XmlNameTable NameTable => pageCurrent[idxCurrent].Document.NameTable;

		public override bool HasAttributes => pageCurrent[idxCurrent].HasAttribute;

		public override bool HasChildren => pageCurrent[idxCurrent].HasContentChild;

		internal override string UniqueId
		{
			get
			{
				char[] array = new char[16];
				int length = 0;
				array[length++] = XPathNavigator.NodeTypeLetter[(int)pageCurrent[idxCurrent].NodeType];
				int num;
				if (idxParent != 0)
				{
					num = (pageParent[0].PageInfo.PageNumber - 1 << 16) | (idxParent - 1);
					do
					{
						array[length++] = XPathNavigator.UniqueIdTbl[num & 0x1F];
						num >>= 5;
					}
					while (num != 0);
					array[length++] = '0';
				}
				num = (pageCurrent[0].PageInfo.PageNumber - 1 << 16) | (idxCurrent - 1);
				do
				{
					array[length++] = XPathNavigator.UniqueIdTbl[num & 0x1F];
					num >>= 5;
				}
				while (num != 0);
				return new string(array, 0, length);
			}
		}

		public int LineNumber
		{
			get
			{
				if (idxParent != 0 && NodeType == XPathNodeType.Text)
				{
					return pageParent[idxParent].LineNumber;
				}
				return pageCurrent[idxCurrent].LineNumber;
			}
		}

		public int LinePosition
		{
			get
			{
				if (idxParent != 0 && NodeType == XPathNodeType.Text)
				{
					return pageParent[idxParent].CollapsedLinePosition;
				}
				return pageCurrent[idxCurrent].LinePosition;
			}
		}

		public XPathDocumentNavigator(XPathNode[] pageCurrent, int idxCurrent, XPathNode[] pageParent, int idxParent)
		{
			this.pageCurrent = pageCurrent;
			this.pageParent = pageParent;
			this.idxCurrent = idxCurrent;
			this.idxParent = idxParent;
		}

		public XPathDocumentNavigator(XPathDocumentNavigator nav)
			: this(nav.pageCurrent, nav.idxCurrent, nav.pageParent, nav.idxParent)
		{
			atomizedLocalName = nav.atomizedLocalName;
		}

		public override XPathNavigator Clone()
		{
			return new XPathDocumentNavigator(pageCurrent, idxCurrent, pageParent, idxParent);
		}

		public override bool MoveToFirstAttribute()
		{
			XPathNode[] array = pageCurrent;
			int num = idxCurrent;
			if (XPathNodeHelper.GetFirstAttribute(ref pageCurrent, ref idxCurrent))
			{
				pageParent = array;
				idxParent = num;
				return true;
			}
			return false;
		}

		public override bool MoveToNextAttribute()
		{
			return XPathNodeHelper.GetNextAttribute(ref pageCurrent, ref idxCurrent);
		}

		public override bool MoveToAttribute(string localName, string namespaceURI)
		{
			XPathNode[] array = pageCurrent;
			int num = idxCurrent;
			if ((object)localName != atomizedLocalName)
			{
				atomizedLocalName = ((localName != null) ? NameTable.Get(localName) : null);
			}
			if (XPathNodeHelper.GetAttribute(ref pageCurrent, ref idxCurrent, atomizedLocalName, namespaceURI))
			{
				pageParent = array;
				idxParent = num;
				return true;
			}
			return false;
		}

		public override bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope)
		{
			XPathNode[] pageNmsp;
			for (int num = ((namespaceScope != XPathNamespaceScope.Local) ? XPathNodeHelper.GetInScopeNamespaces(pageCurrent, idxCurrent, out pageNmsp) : XPathNodeHelper.GetLocalNamespaces(pageCurrent, idxCurrent, out pageNmsp)); num != 0; num = pageNmsp[num].GetSibling(out pageNmsp))
			{
				if (namespaceScope != XPathNamespaceScope.ExcludeXml || !pageNmsp[num].IsXmlNamespaceNode)
				{
					pageParent = pageCurrent;
					idxParent = idxCurrent;
					pageCurrent = pageNmsp;
					idxCurrent = num;
					return true;
				}
			}
			return false;
		}

		public override bool MoveToNextNamespace(XPathNamespaceScope scope)
		{
			XPathNode[] pageNode = pageCurrent;
			int sibling = idxCurrent;
			if (pageNode[sibling].NodeType != XPathNodeType.Namespace)
			{
				return false;
			}
			do
			{
				sibling = pageNode[sibling].GetSibling(out pageNode);
				if (sibling == 0)
				{
					return false;
				}
				switch (scope)
				{
				case XPathNamespaceScope.Local:
				{
					XPathNode[] pageNode2;
					int parent = pageNode[sibling].GetParent(out pageNode2);
					if (parent != idxParent || pageNode2 != pageParent)
					{
						return false;
					}
					break;
				}
				case XPathNamespaceScope.ExcludeXml:
					continue;
				}
				break;
			}
			while (pageNode[sibling].IsXmlNamespaceNode);
			pageCurrent = pageNode;
			idxCurrent = sibling;
			return true;
		}

		public override bool MoveToNext()
		{
			return XPathNodeHelper.GetContentSibling(ref pageCurrent, ref idxCurrent);
		}

		public override bool MoveToPrevious()
		{
			if (idxParent != 0)
			{
				return false;
			}
			return XPathNodeHelper.GetPreviousContentSibling(ref pageCurrent, ref idxCurrent);
		}

		public override bool MoveToFirstChild()
		{
			if (pageCurrent[idxCurrent].HasCollapsedText)
			{
				pageParent = pageCurrent;
				idxParent = idxCurrent;
				idxCurrent = pageCurrent[idxCurrent].Document.GetCollapsedTextNode(out pageCurrent);
				return true;
			}
			return XPathNodeHelper.GetContentChild(ref pageCurrent, ref idxCurrent);
		}

		public override bool MoveToParent()
		{
			if (idxParent != 0)
			{
				pageCurrent = pageParent;
				idxCurrent = idxParent;
				pageParent = null;
				idxParent = 0;
				return true;
			}
			return XPathNodeHelper.GetParent(ref pageCurrent, ref idxCurrent);
		}

		public override bool MoveTo(XPathNavigator other)
		{
			if (other is XPathDocumentNavigator xPathDocumentNavigator)
			{
				pageCurrent = xPathDocumentNavigator.pageCurrent;
				idxCurrent = xPathDocumentNavigator.idxCurrent;
				pageParent = xPathDocumentNavigator.pageParent;
				idxParent = xPathDocumentNavigator.idxParent;
				return true;
			}
			return false;
		}

		public override bool MoveToId(string id)
		{
			XPathNode[] pageElem;
			int num = pageCurrent[idxCurrent].Document.LookupIdElement(id, out pageElem);
			if (num != 0)
			{
				pageCurrent = pageElem;
				idxCurrent = num;
				pageParent = null;
				idxParent = 0;
				return true;
			}
			return false;
		}

		public override bool IsSamePosition(XPathNavigator other)
		{
			if (other is XPathDocumentNavigator xPathDocumentNavigator)
			{
				if (idxCurrent == xPathDocumentNavigator.idxCurrent && pageCurrent == xPathDocumentNavigator.pageCurrent && idxParent == xPathDocumentNavigator.idxParent)
				{
					return pageParent == xPathDocumentNavigator.pageParent;
				}
				return false;
			}
			return false;
		}

		public override void MoveToRoot()
		{
			if (idxParent != 0)
			{
				pageParent = null;
				idxParent = 0;
			}
			idxCurrent = pageCurrent[idxCurrent].GetRoot(out pageCurrent);
		}

		public override bool MoveToChild(string localName, string namespaceURI)
		{
			if ((object)localName != atomizedLocalName)
			{
				atomizedLocalName = ((localName != null) ? NameTable.Get(localName) : null);
			}
			return XPathNodeHelper.GetElementChild(ref pageCurrent, ref idxCurrent, atomizedLocalName, namespaceURI);
		}

		public override bool MoveToNext(string localName, string namespaceURI)
		{
			if ((object)localName != atomizedLocalName)
			{
				atomizedLocalName = ((localName != null) ? NameTable.Get(localName) : null);
			}
			return XPathNodeHelper.GetElementSibling(ref pageCurrent, ref idxCurrent, atomizedLocalName, namespaceURI);
		}

		public override bool MoveToChild(XPathNodeType type)
		{
			if (pageCurrent[idxCurrent].HasCollapsedText)
			{
				if (type != XPathNodeType.Text && type != XPathNodeType.All)
				{
					return false;
				}
				pageParent = pageCurrent;
				idxParent = idxCurrent;
				idxCurrent = pageCurrent[idxCurrent].Document.GetCollapsedTextNode(out pageCurrent);
				return true;
			}
			return XPathNodeHelper.GetContentChild(ref pageCurrent, ref idxCurrent, type);
		}

		public override bool MoveToNext(XPathNodeType type)
		{
			return XPathNodeHelper.GetContentSibling(ref pageCurrent, ref idxCurrent, type);
		}

		public override bool MoveToFollowing(string localName, string namespaceURI, XPathNavigator end)
		{
			if ((object)localName != atomizedLocalName)
			{
				atomizedLocalName = ((localName != null) ? NameTable.Get(localName) : null);
			}
			XPathNode[] pageEnd;
			int followingEnd = GetFollowingEnd(end as XPathDocumentNavigator, useParentOfVirtual: false, out pageEnd);
			if (idxParent != 0)
			{
				if (!XPathNodeHelper.GetElementFollowing(ref pageParent, ref idxParent, pageEnd, followingEnd, atomizedLocalName, namespaceURI))
				{
					return false;
				}
				pageCurrent = pageParent;
				idxCurrent = idxParent;
				pageParent = null;
				idxParent = 0;
				return true;
			}
			return XPathNodeHelper.GetElementFollowing(ref pageCurrent, ref idxCurrent, pageEnd, followingEnd, atomizedLocalName, namespaceURI);
		}

		public override bool MoveToFollowing(XPathNodeType type, XPathNavigator end)
		{
			XPathDocumentNavigator xPathDocumentNavigator = end as XPathDocumentNavigator;
			XPathNode[] pageEnd;
			int followingEnd;
			if (type == XPathNodeType.Text || type == XPathNodeType.All)
			{
				if (pageCurrent[idxCurrent].HasCollapsedText)
				{
					if (xPathDocumentNavigator != null && idxCurrent == xPathDocumentNavigator.idxParent && pageCurrent == xPathDocumentNavigator.pageParent)
					{
						return false;
					}
					pageParent = pageCurrent;
					idxParent = idxCurrent;
					idxCurrent = pageCurrent[idxCurrent].Document.GetCollapsedTextNode(out pageCurrent);
					return true;
				}
				if (type == XPathNodeType.Text)
				{
					followingEnd = GetFollowingEnd(xPathDocumentNavigator, useParentOfVirtual: true, out pageEnd);
					XPathNode[] array;
					int num;
					if (idxParent != 0)
					{
						array = pageParent;
						num = idxParent;
					}
					else
					{
						array = pageCurrent;
						num = idxCurrent;
					}
					if (xPathDocumentNavigator != null && xPathDocumentNavigator.idxParent != 0 && num == followingEnd && array == pageEnd)
					{
						return false;
					}
					if (!XPathNodeHelper.GetTextFollowing(ref array, ref num, pageEnd, followingEnd))
					{
						return false;
					}
					if (array[num].NodeType == XPathNodeType.Element)
					{
						idxCurrent = array[num].Document.GetCollapsedTextNode(out pageCurrent);
						pageParent = array;
						idxParent = num;
					}
					else
					{
						pageCurrent = array;
						idxCurrent = num;
						pageParent = null;
						idxParent = 0;
					}
					return true;
				}
			}
			followingEnd = GetFollowingEnd(xPathDocumentNavigator, useParentOfVirtual: false, out pageEnd);
			if (idxParent != 0)
			{
				if (!XPathNodeHelper.GetContentFollowing(ref pageParent, ref idxParent, pageEnd, followingEnd, type))
				{
					return false;
				}
				pageCurrent = pageParent;
				idxCurrent = idxParent;
				pageParent = null;
				idxParent = 0;
				return true;
			}
			return XPathNodeHelper.GetContentFollowing(ref pageCurrent, ref idxCurrent, pageEnd, followingEnd, type);
		}

		public override XPathNodeIterator SelectChildren(XPathNodeType type)
		{
			return new XPathDocumentKindChildIterator(this, type);
		}

		public override XPathNodeIterator SelectChildren(string name, string namespaceURI)
		{
			if (name == null || name.Length == 0)
			{
				return base.SelectChildren(name, namespaceURI);
			}
			return new XPathDocumentElementChildIterator(this, name, namespaceURI);
		}

		public override XPathNodeIterator SelectDescendants(XPathNodeType type, bool matchSelf)
		{
			return new XPathDocumentKindDescendantIterator(this, type, matchSelf);
		}

		public override XPathNodeIterator SelectDescendants(string name, string namespaceURI, bool matchSelf)
		{
			if (name == null || name.Length == 0)
			{
				return base.SelectDescendants(name, namespaceURI, matchSelf);
			}
			return new XPathDocumentElementDescendantIterator(this, name, namespaceURI, matchSelf);
		}

		public override XmlNodeOrder ComparePosition(XPathNavigator other)
		{
			if (other is XPathDocumentNavigator xPathDocumentNavigator)
			{
				XPathDocument document = pageCurrent[idxCurrent].Document;
				XPathDocument document2 = xPathDocumentNavigator.pageCurrent[xPathDocumentNavigator.idxCurrent].Document;
				if (document == document2)
				{
					int num = GetPrimaryLocation();
					int num2 = xPathDocumentNavigator.GetPrimaryLocation();
					if (num == num2)
					{
						num = GetSecondaryLocation();
						num2 = xPathDocumentNavigator.GetSecondaryLocation();
						if (num == num2)
						{
							return XmlNodeOrder.Same;
						}
					}
					if (num >= num2)
					{
						return XmlNodeOrder.After;
					}
					return XmlNodeOrder.Before;
				}
			}
			return XmlNodeOrder.Unknown;
		}

		public override bool IsDescendant(XPathNavigator other)
		{
			if (other is XPathDocumentNavigator xPathDocumentNavigator)
			{
				XPathNode[] pageNode;
				int parent;
				if (xPathDocumentNavigator.idxParent != 0)
				{
					pageNode = xPathDocumentNavigator.pageParent;
					parent = xPathDocumentNavigator.idxParent;
				}
				else
				{
					parent = xPathDocumentNavigator.pageCurrent[xPathDocumentNavigator.idxCurrent].GetParent(out pageNode);
				}
				while (parent != 0)
				{
					if (parent == idxCurrent && pageNode == pageCurrent)
					{
						return true;
					}
					parent = pageNode[parent].GetParent(out pageNode);
				}
			}
			return false;
		}

		private int GetPrimaryLocation()
		{
			if (idxParent == 0)
			{
				return XPathNodeHelper.GetLocation(pageCurrent, idxCurrent);
			}
			return XPathNodeHelper.GetLocation(pageParent, idxParent);
		}

		private int GetSecondaryLocation()
		{
			if (idxParent == 0)
			{
				return int.MinValue;
			}
			return pageCurrent[idxCurrent].NodeType switch
			{
				XPathNodeType.Namespace => -2147483647 + XPathNodeHelper.GetLocation(pageCurrent, idxCurrent), 
				XPathNodeType.Attribute => XPathNodeHelper.GetLocation(pageCurrent, idxCurrent), 
				_ => int.MaxValue, 
			};
		}

		public bool HasLineInfo()
		{
			return pageCurrent[idxCurrent].Document.HasLineInfo;
		}

		public int GetPositionHashCode()
		{
			return idxCurrent ^ idxParent;
		}

		public bool IsElementMatch(string localName, string namespaceURI)
		{
			if ((object)localName != atomizedLocalName)
			{
				atomizedLocalName = ((localName != null) ? NameTable.Get(localName) : null);
			}
			if (idxParent != 0)
			{
				return false;
			}
			return pageCurrent[idxCurrent].ElementMatch(atomizedLocalName, namespaceURI);
		}

		public bool IsContentKindMatch(XPathNodeType typ)
		{
			return ((1 << (int)pageCurrent[idxCurrent].NodeType) & XPathNavigator.GetContentKindMask(typ)) != 0;
		}

		public bool IsKindMatch(XPathNodeType typ)
		{
			return ((1 << (int)pageCurrent[idxCurrent].NodeType) & XPathNavigator.GetKindMask(typ)) != 0;
		}

		private int GetFollowingEnd(XPathDocumentNavigator end, bool useParentOfVirtual, out XPathNode[] pageEnd)
		{
			if (end != null && pageCurrent[idxCurrent].Document == end.pageCurrent[end.idxCurrent].Document)
			{
				if (end.idxParent == 0)
				{
					pageEnd = end.pageCurrent;
					return end.idxCurrent;
				}
				pageEnd = end.pageParent;
				if (!useParentOfVirtual)
				{
					return end.idxParent + 1;
				}
				return end.idxParent;
			}
			pageEnd = null;
			return 0;
		}
	}
	internal struct XPathNode
	{
		private const uint NodeTypeMask = 15u;

		private const uint HasAttributeBit = 16u;

		private const uint HasContentChildBit = 32u;

		private const uint HasElementChildBit = 64u;

		private const uint HasCollapsedTextBit = 128u;

		private const uint AllowShortcutTagBit = 256u;

		private const uint HasNmspDeclsBit = 512u;

		private const uint LineNumberMask = 16776192u;

		private const int LineNumberShift = 10;

		private const int CollapsedPositionShift = 24;

		public const int MaxLineNumberOffset = 16383;

		public const int MaxLinePositionOffset = 65535;

		public const int MaxCollapsedPositionOffset = 255;

		private XPathNodeInfoAtom info;

		private ushort idxSibling;

		private ushort idxParent;

		private ushort idxSimilar;

		private ushort posOffset;

		private uint props;

		private string value;

		public XPathNodeType NodeType => (XPathNodeType)((int)props & 0xF);

		public string Prefix => info.Prefix;

		public string LocalName => info.LocalName;

		public string Name
		{
			get
			{
				if (Prefix.Length == 0)
				{
					return LocalName;
				}
				return Prefix + ":" + LocalName;
			}
		}

		public string NamespaceUri => info.NamespaceUri;

		public XPathDocument Document => info.Document;

		public string BaseUri => info.BaseUri;

		public int LineNumber => info.LineNumberBase + (int)((props & 0xFFFC00) >> 10);

		public int LinePosition => info.LinePositionBase + posOffset;

		public int CollapsedLinePosition => LinePosition + (int)(props >> 24);

		public XPathNodePageInfo PageInfo => info.PageInfo;

		public bool IsXmlNamespaceNode
		{
			get
			{
				string localName = info.LocalName;
				if (NodeType == XPathNodeType.Namespace && localName.Length == 3)
				{
					return localName == "xml";
				}
				return false;
			}
		}

		public bool HasSibling => idxSibling != 0;

		public bool HasCollapsedText => (props & 0x80) != 0;

		public bool HasAttribute => (props & 0x10) != 0;

		public bool HasContentChild => (props & 0x20) != 0;

		public bool HasElementChild => (props & 0x40) != 0;

		public bool IsAttrNmsp
		{
			get
			{
				XPathNodeType nodeType = NodeType;
				if (nodeType != XPathNodeType.Attribute)
				{
					return nodeType == XPathNodeType.Namespace;
				}
				return true;
			}
		}

		public bool IsText => XPathNavigator.IsText(NodeType);

		public bool HasNamespaceDecls
		{
			get
			{
				return (props & 0x200) != 0;
			}
			set
			{
				if (value)
				{
					props |= 512u;
				}
				else
				{
					props &= 255u;
				}
			}
		}

		public bool AllowShortcutTag => (props & 0x100) != 0;

		public int LocalNameHashCode => info.LocalNameHashCode;

		public string Value => value;

		public int GetRoot(out XPathNode[] pageNode)
		{
			return info.Document.GetRootNode(out pageNode);
		}

		public int GetParent(out XPathNode[] pageNode)
		{
			pageNode = info.ParentPage;
			return idxParent;
		}

		public int GetSibling(out XPathNode[] pageNode)
		{
			pageNode = info.SiblingPage;
			return idxSibling;
		}

		public int GetSimilarElement(out XPathNode[] pageNode)
		{
			pageNode = info.SimilarElementPage;
			return idxSimilar;
		}

		public bool NameMatch(string localName, string namespaceName)
		{
			if ((object)info.LocalName == localName)
			{
				return info.NamespaceUri == namespaceName;
			}
			return false;
		}

		public bool ElementMatch(string localName, string namespaceName)
		{
			if (NodeType == XPathNodeType.Element && (object)info.LocalName == localName)
			{
				return info.NamespaceUri == namespaceName;
			}
			return false;
		}

		public void Create(XPathNodePageInfo pageInfo)
		{
			info = new XPathNodeInfoAtom(pageInfo);
		}

		public void Create(XPathNodeInfoAtom info, XPathNodeType xptyp, int idxParent)
		{
			this.info = info;
			props = (uint)xptyp;
			this.idxParent = (ushort)idxParent;
		}

		public void SetLineInfoOffsets(int lineNumOffset, int linePosOffset)
		{
			props |= (uint)(lineNumOffset << 10);
			posOffset = (ushort)linePosOffset;
		}

		public void SetCollapsedLineInfoOffset(int posOffset)
		{
			props |= (uint)(posOffset << 24);
		}

		public void SetValue(string value)
		{
			this.value = value;
		}

		public void SetEmptyValue(bool allowShortcutTag)
		{
			value = string.Empty;
			if (allowShortcutTag)
			{
				props |= 256u;
			}
		}

		public void SetCollapsedValue(string value)
		{
			this.value = value;
			props |= 160u;
		}

		public void SetParentProperties(XPathNodeType xptyp)
		{
			if (xptyp == XPathNodeType.Attribute)
			{
				props |= 16u;
				return;
			}
			props |= 32u;
			if (xptyp == XPathNodeType.Element)
			{
				props |= 64u;
			}
		}

		public void SetSibling(XPathNodeInfoTable infoTable, XPathNode[] pageSibling, int idxSibling)
		{
			this.idxSibling = (ushort)idxSibling;
			if (pageSibling != info.SiblingPage)
			{
				info = infoTable.Create(info.LocalName, info.NamespaceUri, info.Prefix, info.BaseUri, info.ParentPage, pageSibling, info.SimilarElementPage, info.Document, info.LineNumberBase, info.LinePositionBase);
			}
		}

		public void SetSimilarElement(XPathNodeInfoTable infoTable, XPathNode[] pageSimilar, int idxSimilar)
		{
			this.idxSimilar = (ushort)idxSimilar;
			if (pageSimilar != info.SimilarElementPage)
			{
				info = infoTable.Create(info.LocalName, info.NamespaceUri, info.Prefix, info.BaseUri, info.ParentPage, info.SiblingPage, pageSimilar, info.Document, info.LineNumberBase, info.LinePositionBase);
			}
		}
	}
	internal struct XPathNodeRef
	{
		private XPathNode[] page;

		private int idx;

		public static XPathNodeRef Null => default(XPathNodeRef);

		public bool IsNull => page == null;

		public XPathNode[] Page => page;

		public int Index => idx;

		public XPathNodeRef(XPathNode[] page, int idx)
		{
			this.page = page;
			this.idx = idx;
		}

		public override int GetHashCode()
		{
			return XPathNodeHelper.GetLocation(page, idx);
		}
	}
	internal abstract class XPathNodeHelper
	{
		public static int GetLocalNamespaces(XPathNode[] pageElem, int idxElem, out XPathNode[] pageNmsp)
		{
			if (pageElem[idxElem].HasNamespaceDecls)
			{
				return pageElem[idxElem].Document.LookupNamespaces(pageElem, idxElem, out pageNmsp);
			}
			pageNmsp = null;
			return 0;
		}

		public static int GetInScopeNamespaces(XPathNode[] pageElem, int idxElem, out XPathNode[] pageNmsp)
		{
			if (pageElem[idxElem].NodeType == XPathNodeType.Element)
			{
				XPathDocument document = pageElem[idxElem].Document;
				while (!pageElem[idxElem].HasNamespaceDecls)
				{
					idxElem = pageElem[idxElem].GetParent(out pageElem);
					if (idxElem == 0)
					{
						return document.GetXmlNamespaceNode(out pageNmsp);
					}
				}
				return document.LookupNamespaces(pageElem, idxElem, out pageNmsp);
			}
			pageNmsp = null;
			return 0;
		}

		public static bool GetFirstAttribute(ref XPathNode[] pageNode, ref int idxNode)
		{
			if (pageNode[idxNode].HasAttribute)
			{
				GetChild(ref pageNode, ref idxNode);
				return true;
			}
			return false;
		}

		public static bool GetNextAttribute(ref XPathNode[] pageNode, ref int idxNode)
		{
			XPathNode[] pageNode2;
			int sibling = pageNode[idxNode].GetSibling(out pageNode2);
			if (sibling != 0 && pageNode2[sibling].NodeType == XPathNodeType.Attribute)
			{
				pageNode = pageNode2;
				idxNode = sibling;
				return true;
			}
			return false;
		}

		public static bool GetContentChild(ref XPathNode[] pageNode, ref int idxNode)
		{
			XPathNode[] pageNode2 = pageNode;
			int idxNode2 = idxNode;
			if (pageNode2[idxNode2].HasContentChild)
			{
				GetChild(ref pageNode2, ref idxNode2);
				while (pageNode2[idxNode2].NodeType == XPathNodeType.Attribute)
				{
					idxNode2 = pageNode2[idxNode2].GetSibling(out pageNode2);
				}
				pageNode = pageNode2;
				idxNode = idxNode2;
				return true;
			}
			return false;
		}

		public static bool GetContentSibling(ref XPathNode[] pageNode, ref int idxNode)
		{
			XPathNode[] pageNode2 = pageNode;
			int num = idxNode;
			if (!pageNode2[num].IsAttrNmsp)
			{
				num = pageNode2[num].GetSibling(out pageNode2);
				if (num != 0)
				{
					pageNode = pageNode2;
					idxNode = num;
					return true;
				}
			}
			return false;
		}

		public static bool GetParent(ref XPathNode[] pageNode, ref int idxNode)
		{
			XPathNode[] pageNode2 = pageNode;
			int num = idxNode;
			num = pageNode2[num].GetParent(out pageNode2);
			if (num != 0)
			{
				pageNode = pageNode2;
				idxNode = num;
				return true;
			}
			return false;
		}

		public static int GetLocation(XPathNode[] pageNode, int idxNode)
		{
			return (pageNode[0].PageInfo.PageNumber << 16) | idxNode;
		}

		public static bool GetElementChild(ref XPathNode[] pageNode, ref int idxNode, string localName, string namespaceName)
		{
			XPathNode[] pageNode2 = pageNode;
			int idxNode2 = idxNode;
			if (pageNode2[idxNode2].HasElementChild)
			{
				GetChild(ref pageNode2, ref idxNode2);
				do
				{
					if (pageNode2[idxNode2].ElementMatch(localName, namespaceName))
					{
						pageNode = pageNode2;
						idxNode = idxNode2;
						return true;
					}
					idxNode2 = pageNode2[idxNode2].GetSibling(out pageNode2);
				}
				while (idxNode2 != 0);
			}
			return false;
		}

		public static bool GetElementSibling(ref XPathNode[] pageNode, ref int idxNode, string localName, string namespaceName)
		{
			XPathNode[] pageNode2 = pageNode;
			int num = idxNode;
			if (pageNode2[num].NodeType != XPathNodeType.Attribute)
			{
				while (true)
				{
					num = pageNode2[num].GetSibling(out pageNode2);
					if (num == 0)
					{
						break;
					}
					if (pageNode2[num].ElementMatch(localName, namespaceName))
					{
						pageNode = pageNode2;
						idxNode = num;
						return true;
					}
				}
			}
			return false;
		}

		public static bool GetContentChild(ref XPathNode[] pageNode, ref int idxNode, XPathNodeType typ)
		{
			XPathNode[] pageNode2 = pageNode;
			int idxNode2 = idxNode;
			if (pageNode2[idxNode2].HasContentChild)
			{
				int contentKindMask = XPathNavigator.GetContentKindMask(typ);
				GetChild(ref pageNode2, ref idxNode2);
				do
				{
					if (((1 << (int)pageNode2[idxNode2].NodeType) & contentKindMask) != 0)
					{
						if (typ == XPathNodeType.Attribute)
						{
							return false;
						}
						pageNode = pageNode2;
						idxNode = idxNode2;
						return true;
					}
					idxNode2 = pageNode2[idxNode2].GetSibling(out pageNode2);
				}
				while (idxNode2 != 0);
			}
			return false;
		}

		public static bool GetContentSibling(ref XPathNode[] pageNode, ref int idxNode, XPathNodeType typ)
		{
			XPathNode[] pageNode2 = pageNode;
			int num = idxNode;
			int contentKindMask = XPathNavigator.GetContentKindMask(typ);
			if (pageNode2[num].NodeType != XPathNodeType.Attribute)
			{
				while (true)
				{
					num = pageNode2[num].GetSibling(out pageNode2);
					if (num == 0)
					{
						break;
					}
					if (((1 << (int)pageNode2[num].NodeType) & contentKindMask) != 0)
					{
						pageNode = pageNode2;
						idxNode = num;
						return true;
					}
				}
			}
			return false;
		}

		public static bool GetPreviousContentSibling(ref XPathNode[] pageNode, ref int idxNode)
		{
			XPathNode[] pageNode2 = pageNode;
			int num = idxNode;
			num = pageNode2[num].GetParent(out pageNode2);
			if (num != 0)
			{
				int num2 = idxNode - 1;
				XPathNode[] array;
				if (num2 == 0)
				{
					array = pageNode[0].PageInfo.PreviousPage;
					num2 = array.Length - 1;
				}
				else
				{
					array = pageNode;
				}
				if (num == num2 && pageNode2 == array)
				{
					return false;
				}
				XPathNode[] pageNode3 = array;
				int num3 = num2;
				do
				{
					array = pageNode3;
					num2 = num3;
					num3 = pageNode3[num3].GetParent(out pageNode3);
				}
				while (num3 != num || pageNode3 != pageNode2);
				if (array[num2].NodeType != XPathNodeType.Attribute)
				{
					pageNode = array;
					idxNode = num2;
					return true;
				}
			}
			return false;
		}

		public static bool GetPreviousElementSibling(ref XPathNode[] pageNode, ref int idxNode, string localName, string namespaceName)
		{
			XPathNode[] pageNode2 = pageNode;
			int idxNode2 = idxNode;
			if (pageNode2[idxNode2].NodeType != XPathNodeType.Attribute)
			{
				while (GetPreviousContentSibling(ref pageNode2, ref idxNode2))
				{
					if (pageNode2[idxNode2].ElementMatch(localName, namespaceName))
					{
						pageNode = pageNode2;
						idxNode = idxNode2;
						return true;
					}
				}
			}
			return false;
		}

		public static bool GetPreviousContentSibling(ref XPathNode[] pageNode, ref int idxNode, XPathNodeType typ)
		{
			XPathNode[] pageNode2 = pageNode;
			int idxNode2 = idxNode;
			int contentKindMask = XPathNavigator.GetContentKindMask(typ);
			while (GetPreviousContentSibling(ref pageNode2, ref idxNode2))
			{
				if (((1 << (int)pageNode2[idxNode2].NodeType) & contentKindMask) != 0)
				{
					pageNode = pageNode2;
					idxNode = idxNode2;
					return true;
				}
			}
			return false;
		}

		public static bool GetAttribute(ref XPathNode[] pageNode, ref int idxNode, string localName, string namespaceName)
		{
			XPathNode[] pageNode2 = pageNode;
			int idxNode2 = idxNode;
			if (pageNode2[idxNode2].HasAttribute)
			{
				GetChild(ref pageNode2, ref idxNode2);
				do
				{
					if (pageNode2[idxNode2].NameMatch(localName, namespaceName))
					{
						pageNode = pageNode2;
						idxNode = idxNode2;
						return true;
					}
					idxNode2 = pageNode2[idxNode2].GetSibling(out pageNode2);
				}
				while (idxNode2 != 0 && pageNode2[idxNode2].NodeType == XPathNodeType.Attribute);
			}
			return false;
		}

		public static bool GetFollowing(ref XPathNode[] pageNode, ref int idxNode)
		{
			XPathNode[] array = pageNode;
			int num = idxNode;
			do
			{
				if (++num < array[0].PageInfo.NodeCount)
				{
					pageNode = array;
					idxNode = num;
					return true;
				}
				array = array[0].PageInfo.NextPage;
				num = 0;
			}
			while (array != null);
			return false;
		}

		public static bool GetElementFollowing(ref XPathNode[] pageCurrent, ref int idxCurrent, XPathNode[] pageEnd, int idxEnd, string localName, string namespaceName)
		{
			XPathNode[] pageNode = pageCurrent;
			int i = idxCurrent;
			if (pageNode[i].NodeType == XPathNodeType.Element && (object)pageNode[i].LocalName == localName)
			{
				int num = 0;
				if (pageEnd != null)
				{
					num = pageEnd[0].PageInfo.PageNumber;
					int pageNumber = pageNode[0].PageInfo.PageNumber;
					if (pageNumber > num || (pageNumber == num && i >= idxEnd))
					{
						pageEnd = null;
					}
				}
				while (true)
				{
					i = pageNode[i].GetSimilarElement(out pageNode);
					if (i != 0)
					{
						if (pageEnd != null)
						{
							int pageNumber = pageNode[0].PageInfo.PageNumber;
							if (pageNumber > num || (pageNumber == num && i >= idxEnd))
							{
								goto IL_00bd;
							}
						}
						if ((object)pageNode[i].LocalName == localName && pageNode[i].NamespaceUri == namespaceName)
						{
							break;
						}
						continue;
					}
					goto IL_00bd;
					IL_00bd:
					return false;
				}
			}
			else
			{
				i++;
				while (true)
				{
					if (pageNode == pageEnd && i <= idxEnd)
					{
						for (; i != idxEnd; i++)
						{
							if (pageNode[i].ElementMatch(localName, namespaceName))
							{
								goto end_IL_00c3;
							}
						}
					}
					else
					{
						for (; i < pageNode[0].PageInfo.NodeCount; i++)
						{
							if (pageNode[i].ElementMatch(localName, namespaceName))
							{
								goto end_IL_00c3;
							}
						}
						pageNode = pageNode[0].PageInfo.NextPage;
						i = 1;
						if (pageNode != null)
						{
							continue;
						}
					}
					return false;
					continue;
					end_IL_00c3:
					break;
				}
			}
			pageCurrent = pageNode;
			idxCurrent = i;
			return true;
		}

		public static bool GetContentFollowing(ref XPathNode[] pageCurrent, ref int idxCurrent, XPathNode[] pageEnd, int idxEnd, XPathNodeType typ)
		{
			XPathNode[] array = pageCurrent;
			int num = idxCurrent;
			int contentKindMask = XPathNavigator.GetContentKindMask(typ);
			num++;
			while (true)
			{
				if (array == pageEnd && num <= idxEnd)
				{
					for (; num != idxEnd; num++)
					{
						if (((1 << (int)array[num].NodeType) & contentKindMask) != 0)
						{
							goto end_IL_0012;
						}
					}
				}
				else
				{
					for (; num < array[0].PageInfo.NodeCount; num++)
					{
						if (((1 << (int)array[num].NodeType) & contentKindMask) != 0)
						{
							goto end_IL_0012;
						}
					}
					array = array[0].PageInfo.NextPage;
					num = 1;
					if (array != null)
					{
						continue;
					}
				}
				return false;
				continue;
				end_IL_0012:
				break;
			}
			pageCurrent = array;
			idxCurrent = num;
			return true;
		}

		public static bool GetTextFollowing(ref XPathNode[] pageCurrent, ref int idxCurrent, XPathNode[] pageEnd, int idxEnd)
		{
			XPathNode[] array = pageCurrent;
			int num = idxCurrent;
			num++;
			while (true)
			{
				if (array == pageEnd && num <= idxEnd)
				{
					for (; num != idxEnd; num++)
					{
						if (array[num].IsText || (array[num].NodeType == XPathNodeType.Element && array[num].HasCollapsedText))
						{
							goto end_IL_000a;
						}
					}
				}
				else
				{
					for (; num < array[0].PageInfo.NodeCount; num++)
					{
						if (array[num].IsText || (array[num].NodeType == XPathNodeType.Element && array[num].HasCollapsedText))
						{
							goto end_IL_000a;
						}
					}
					array = array[0].PageInfo.NextPage;
					num = 1;
					if (array != null)
					{
						continue;
					}
				}
				return false;
				continue;
				end_IL_000a:
				break;
			}
			pageCurrent = array;
			idxCurrent = num;
			return true;
		}

		public static bool GetNonDescendant(ref XPathNode[] pageNode, ref int idxNode)
		{
			XPathNode[] pageNode2 = pageNode;
			int num = idxNode;
			do
			{
				if (pageNode2[num].HasSibling)
				{
					pageNode = pageNode2;
					idxNode = pageNode2[num].GetSibling(out pageNode);
					return true;
				}
				num = pageNode2[num].GetParent(out pageNode2);
			}
			while (num != 0);
			return false;
		}

		private static void GetChild(ref XPathNode[] pageNode, ref int idxNode)
		{
			if (++idxNode >= pageNode.Length)
			{
				pageNode = pageNode[0].PageInfo.NextPage;
				idxNode = 1;
			}
		}
	}
	internal sealed class XPathNodePageInfo
	{
		private int pageNum;

		private int nodeCount;

		private XPathNode[] pagePrev;

		private XPathNode[] pageNext;

		public int PageNumber => pageNum;

		public int NodeCount
		{
			get
			{
				return nodeCount;
			}
			set
			{
				nodeCount = value;
			}
		}

		public XPathNode[] PreviousPage => pagePrev;

		public XPathNode[] NextPage
		{
			get
			{
				return pageNext;
			}
			set
			{
				pageNext = value;
			}
		}

		public XPathNodePageInfo(XPathNode[] pagePrev, int pageNum)
		{
			this.pagePrev = pagePrev;
			this.pageNum = pageNum;
			nodeCount = 1;
		}
	}
	internal sealed class XPathNodeInfoAtom
	{
		private string localName;

		private string namespaceUri;

		private string prefix;

		private string baseUri;

		private XPathNode[] pageParent;

		private XPathNode[] pageSibling;

		private XPathNode[] pageSimilar;

		private XPathDocument doc;

		private int lineNumBase;

		private int linePosBase;

		private int hashCode;

		private int localNameHash;

		private XPathNodeInfoAtom next;

		private XPathNodePageInfo pageInfo;

		public XPathNodePageInfo PageInfo => pageInfo;

		public string LocalName => localName;

		public string NamespaceUri => namespaceUri;

		public string Prefix => prefix;

		public string BaseUri => baseUri;

		public XPathNode[] SiblingPage => pageSibling;

		public XPathNode[] SimilarElementPage => pageSimilar;

		public XPathNode[] ParentPage => pageParent;

		public XPathDocument Document => doc;

		public int LineNumberBase => lineNumBase;

		public int LinePositionBase => linePosBase;

		public int LocalNameHashCode => localNameHash;

		public XPathNodeInfoAtom Next
		{
			get
			{
				return next;
			}
			set
			{
				next = value;
			}
		}

		public XPathNodeInfoAtom(XPathNodePageInfo pageInfo)
		{
			this.pageInfo = pageInfo;
		}

		public XPathNodeInfoAtom(string localName, string namespaceUri, string prefix, string baseUri, XPathNode[] pageParent, XPathNode[] pageSibling, XPathNode[] pageSimilar, XPathDocument doc, int lineNumBase, int linePosBase)
		{
			Init(localName, namespaceUri, prefix, baseUri, pageParent, pageSibling, pageSimilar, doc, lineNumBase, linePosBase);
		}

		public void Init(string localName, string namespaceUri, string prefix, string baseUri, XPathNode[] pageParent, XPathNode[] pageSibling, XPathNode[] pageSimilar, XPathDocument doc, int lineNumBase, int linePosBase)
		{
			this.localName = localName;
			this.namespaceUri = namespaceUri;
			this.prefix = prefix;
			this.baseUri = baseUri;
			this.pageParent = pageParent;
			this.pageSibling = pageSibling;
			this.pageSimilar = pageSimilar;
			this.doc = doc;
			this.lineNumBase = lineNumBase;
			this.linePosBase = linePosBase;
			next = null;
			pageInfo = null;
			hashCode = 0;
			localNameHash = 0;
			for (int i = 0; i < this.localName.Length; i++)
			{
				localNameHash += (localNameHash << 7) ^ this.localName[i];
			}
		}

		public override int GetHashCode()
		{
			if (hashCode == 0)
			{
				int num = localNameHash;
				if (pageSibling != null)
				{
					num += (num << 7) ^ pageSibling[0].PageInfo.PageNumber;
				}
				if (pageParent != null)
				{
					num += (num << 7) ^ pageParent[0].PageInfo.PageNumber;
				}
				if (pageSimilar != null)
				{
					num += (num << 7) ^ pageSimilar[0].PageInfo.PageNumber;
				}
				hashCode = ((num == 0) ? 1 : num);
			}
			return hashCode;
		}

		public override bool Equals(object other)
		{
			XPathNodeInfoAtom xPathNodeInfoAtom = other as XPathNodeInfoAtom;
			if (GetHashCode() == xPathNodeInfoAtom.GetHashCode() && (object)localName == xPathNodeInfoAtom.localName && pageSibling == xPathNodeInfoAtom.pageSibling && (object)namespaceUri == xPathNodeInfoAtom.namespaceUri && pageParent == xPathNodeInfoAtom.pageParent && pageSimilar == xPathNodeInfoAtom.pageSimilar && (object)prefix == xPathNodeInfoAtom.prefix && (object)baseUri == xPathNodeInfoAtom.baseUri && lineNumBase == xPathNodeInfoAtom.lineNumBase && linePosBase == xPathNodeInfoAtom.linePosBase)
			{
				return true;
			}
			return false;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("hash=");
			stringBuilder.Append(GetHashCode());
			stringBuilder.Append(", ");
			if (localName.Length != 0)
			{
				stringBuilder.Append('{');
				stringBuilder.Append(namespaceUri);
				stringBuilder.Append('}');
				if (prefix.Length != 0)
				{
					stringBuilder.Append(prefix);
					stringBuilder.Append(':');
				}
				stringBuilder.Append(localName);
				stringBuilder.Append(", ");
			}
			if (pageParent != null)
			{
				stringBuilder.Append("parent=");
				stringBuilder.Append(pageParent[0].PageInfo.PageNumber);
				stringBuilder.Append(", ");
			}
			if (pageSibling != null)
			{
				stringBuilder.Append("sibling=");
				stringBuilder.Append(pageSibling[0].PageInfo.PageNumber);
				stringBuilder.Append(", ");
			}
			if (pageSimilar != null)
			{
				stringBuilder.Append("similar=");
				stringBuilder.Append(pageSimilar[0].PageInfo.PageNumber);
				stringBuilder.Append(", ");
			}
			stringBuilder.Append("lineNum=");
			stringBuilder.Append(lineNumBase);
			stringBuilder.Append(", ");
			stringBuilder.Append("linePos=");
			stringBuilder.Append(linePosBase);
			return stringBuilder.ToString();
		}
	}
	internal sealed class XPathNodeInfoTable
	{
		private const int DefaultTableSize = 32;

		private XPathNodeInfoAtom[] hashTable;

		private int sizeTable;

		private XPathNodeInfoAtom infoCached;

		public XPathNodeInfoTable()
		{
			hashTable = new XPathNodeInfoAtom[32];
			sizeTable = 0;
		}

		public XPathNodeInfoAtom Create(string localName, string namespaceUri, string prefix, string baseUri, XPathNode[] pageParent, XPathNode[] pageSibling, XPathNode[] pageSimilar, XPathDocument doc, int lineNumBase, int linePosBase)
		{
			XPathNodeInfoAtom xPathNodeInfoAtom;
			if (infoCached == null)
			{
				xPathNodeInfoAtom = new XPathNodeInfoAtom(localName, namespaceUri, prefix, baseUri, pageParent, pageSibling, pageSimilar, doc, lineNumBase, linePosBase);
			}
			else
			{
				xPathNodeInfoAtom = infoCached;
				infoCached = xPathNodeInfoAtom.Next;
				xPathNodeInfoAtom.Init(localName, namespaceUri, prefix, baseUri, pageParent, pageSibling, pageSimilar, doc, lineNumBase, linePosBase);
			}
			return Atomize(xPathNodeInfoAtom);
		}

		private XPathNodeInfoAtom Atomize(XPathNodeInfoAtom info)
		{
			for (XPathNodeInfoAtom xPathNodeInfoAtom = hashTable[info.GetHashCode() & (hashTable.Length - 1)]; xPathNodeInfoAtom != null; xPathNodeInfoAtom = xPathNodeInfoAtom.Next)
			{
				if (info.Equals(xPathNodeInfoAtom))
				{
					info.Next = infoCached;
					infoCached = info;
					return xPathNodeInfoAtom;
				}
			}
			if (sizeTable >= hashTable.Length)
			{
				XPathNodeInfoAtom[] array = hashTable;
				hashTable = new XPathNodeInfoAtom[array.Length * 2];
				for (int i = 0; i < array.Length; i++)
				{
					XPathNodeInfoAtom xPathNodeInfoAtom = array[i];
					while (xPathNodeInfoAtom != null)
					{
						XPathNodeInfoAtom next = xPathNodeInfoAtom.Next;
						AddInfo(xPathNodeInfoAtom);
						xPathNodeInfoAtom = next;
					}
				}
			}
			AddInfo(info);
			return info;
		}

		private void AddInfo(XPathNodeInfoAtom info)
		{
			int num = info.GetHashCode() & (hashTable.Length - 1);
			info.Next = hashTable[num];
			hashTable[num] = info;
			sizeTable++;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < hashTable.Length; i++)
			{
				stringBuilder.AppendFormat("{0,4}: ", i);
				for (XPathNodeInfoAtom xPathNodeInfoAtom = hashTable[i]; xPathNodeInfoAtom != null; xPathNodeInfoAtom = xPathNodeInfoAtom.Next)
				{
					if (xPathNodeInfoAtom != hashTable[i])
					{
						stringBuilder.Append("\n      ");
					}
					stringBuilder.Append(xPathNodeInfoAtom);
				}
				stringBuilder.Append('\n');
			}
			return stringBuilder.ToString();
		}
	}
}
namespace System.Xml.XPath
{
	public class XPathDocument : IXPathNavigable
	{
		internal enum LoadFlags
		{
			None,
			AtomizeNames,
			Fragment
		}

		private XPathNode[] pageText;

		private XPathNode[] pageRoot;

		private XPathNode[] pageXmlNmsp;

		private int idxText;

		private int idxRoot;

		private int idxXmlNmsp;

		private XmlNameTable nameTable;

		private bool hasLineInfo;

		private Dictionary<XPathNodeRef, XPathNodeRef> mapNmsp;

		private Dictionary<string, XPathNodeRef> idValueMap;

		internal XmlNameTable NameTable => nameTable;

		internal bool HasLineInfo => hasLineInfo;

		internal XPathDocument()
		{
			nameTable = new NameTable();
		}

		internal XPathDocument(XmlNameTable nameTable)
		{
			if (nameTable == null)
			{
				throw new ArgumentNullException("nameTable");
			}
			this.nameTable = nameTable;
		}

		public XPathDocument(XmlReader reader)
			: this(reader, XmlSpace.Default)
		{
		}

		public XPathDocument(XmlReader reader, XmlSpace space)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			LoadFromReader(reader, space);
		}

		public XPathDocument(TextReader textReader)
		{
			XmlTextReaderImpl xmlTextReaderImpl = SetupReader(new XmlTextReaderImpl(string.Empty, textReader));
			try
			{
				LoadFromReader(xmlTextReaderImpl, XmlSpace.Default);
			}
			finally
			{
				xmlTextReaderImpl.Close();
			}
		}

		public XPathDocument(Stream stream)
		{
			XmlTextReaderImpl xmlTextReaderImpl = SetupReader(new XmlTextReaderImpl(string.Empty, stream));
			try
			{
				LoadFromReader(xmlTextReaderImpl, XmlSpace.Default);
			}
			finally
			{
				xmlTextReaderImpl.Close();
			}
		}

		public XPathDocument(string uri)
			: this(uri, XmlSpace.Default)
		{
		}

		public XPathDocument(string uri, XmlSpace space)
		{
			XmlTextReaderImpl xmlTextReaderImpl = SetupReader(new XmlTextReaderImpl(uri));
			try
			{
				LoadFromReader(xmlTextReaderImpl, space);
			}
			finally
			{
				xmlTextReaderImpl.Close();
			}
		}

		internal XmlRawWriter LoadFromWriter(LoadFlags flags, string baseUri)
		{
			return new XPathDocumentBuilder(this, null, baseUri, flags);
		}

		internal void LoadFromReader(XmlReader reader, XmlSpace space)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			IXmlLineInfo xmlLineInfo = reader as IXmlLineInfo;
			if (xmlLineInfo == null || !xmlLineInfo.HasLineInfo())
			{
				xmlLineInfo = null;
			}
			hasLineInfo = xmlLineInfo != null;
			nameTable = reader.NameTable;
			XPathDocumentBuilder xPathDocumentBuilder = new XPathDocumentBuilder(this, xmlLineInfo, reader.BaseURI, LoadFlags.None);
			try
			{
				bool flag = reader.ReadState == ReadState.Initial;
				int depth = reader.Depth;
				string text = nameTable.Get("http://www.w3.org/2000/xmlns/");
				if (flag && !reader.Read())
				{
					return;
				}
				while (flag || reader.Depth >= depth)
				{
					switch (reader.NodeType)
					{
					case XmlNodeType.Element:
					{
						bool isEmptyElement = reader.IsEmptyElement;
						xPathDocumentBuilder.WriteStartElement(reader.Prefix, reader.LocalName, reader.NamespaceURI, reader.BaseURI);
						while (reader.MoveToNextAttribute())
						{
							string namespaceURI = reader.NamespaceURI;
							if ((object)namespaceURI == text)
							{
								if (reader.Prefix.Length == 0)
								{
									xPathDocumentBuilder.WriteNamespaceDeclaration(string.Empty, reader.Value);
								}
								else
								{
									xPathDocumentBuilder.WriteNamespaceDeclaration(reader.LocalName, reader.Value);
								}
							}
							else
							{
								xPathDocumentBuilder.WriteStartAttribute(reader.Prefix, reader.LocalName, namespaceURI);
								xPathDocumentBuilder.WriteString(reader.Value, TextBlockType.Text);
								xPathDocumentBuilder.WriteEndAttribute();
							}
						}
						if (isEmptyElement)
						{
							xPathDocumentBuilder.WriteEndElement(allowShortcutTag: true);
						}
						break;
					}
					case XmlNodeType.EndElement:
						xPathDocumentBuilder.WriteEndElement(allowShortcutTag: false);
						break;
					case XmlNodeType.Text:
					case XmlNodeType.CDATA:
						xPathDocumentBuilder.WriteString(reader.Value, TextBlockType.Text);
						break;
					case XmlNodeType.SignificantWhitespace:
						if (reader.XmlSpace == XmlSpace.Preserve)
						{
							xPathDocumentBuilder.WriteString(reader.Value, TextBlockType.SignificantWhitespace);
							break;
						}
						goto case XmlNodeType.Whitespace;
					case XmlNodeType.Whitespace:
						if (space == XmlSpace.Preserve && (!flag || reader.Depth != 0))
						{
							xPathDocumentBuilder.WriteString(reader.Value, TextBlockType.Whitespace);
						}
						break;
					case XmlNodeType.Comment:
						xPathDocumentBuilder.WriteComment(reader.Value);
						break;
					case XmlNodeType.ProcessingInstruction:
						xPathDocumentBuilder.WriteProcessingInstruction(reader.LocalName, reader.Value, reader.BaseURI);
						break;
					case XmlNodeType.EntityReference:
						reader.ResolveEntity();
						break;
					case XmlNodeType.DocumentType:
					{
						SchemaInfo dtdSchemaInfo = XmlReader.GetDtdSchemaInfo(reader);
						if (dtdSchemaInfo != null)
						{
							xPathDocumentBuilder.CreateIdTables(dtdSchemaInfo);
						}
						break;
					}
					}
					if (!reader.Read())
					{
						break;
					}
				}
			}
			finally
			{
				xPathDocumentBuilder.Close();
			}
		}

		public XPathNavigator CreateNavigator()
		{
			return new XPathDocumentNavigator(pageRoot, idxRoot, null, 0);
		}

		internal int GetCollapsedTextNode(out XPathNode[] pageText)
		{
			pageText = this.pageText;
			return idxText;
		}

		internal void SetCollapsedTextNode(XPathNode[] pageText, int idxText)
		{
			this.pageText = pageText;
			this.idxText = idxText;
		}

		internal int GetRootNode(out XPathNode[] pageRoot)
		{
			pageRoot = this.pageRoot;
			return idxRoot;
		}

		internal void SetRootNode(XPathNode[] pageRoot, int idxRoot)
		{
			this.pageRoot = pageRoot;
			this.idxRoot = idxRoot;
		}

		internal int GetXmlNamespaceNode(out XPathNode[] pageXmlNmsp)
		{
			pageXmlNmsp = this.pageXmlNmsp;
			return idxXmlNmsp;
		}

		internal void SetXmlNamespaceNode(XPathNode[] pageXmlNmsp, int idxXmlNmsp)
		{
			this.pageXmlNmsp = pageXmlNmsp;
			this.idxXmlNmsp = idxXmlNmsp;
		}

		internal void AddNamespace(XPathNode[] pageElem, int idxElem, XPathNode[] pageNmsp, int idxNmsp)
		{
			if (mapNmsp == null)
			{
				mapNmsp = new Dictionary<XPathNodeRef, XPathNodeRef>();
			}
			mapNmsp.Add(new XPathNodeRef(pageElem, idxElem), new XPathNodeRef(pageNmsp, idxNmsp));
		}

		internal int LookupNamespaces(XPathNode[] pageElem, int idxElem, out XPathNode[] pageNmsp)
		{
			XPathNodeRef key = new XPathNodeRef(pageElem, idxElem);
			if (mapNmsp == null || !mapNmsp.ContainsKey(key))
			{
				pageNmsp = null;
				return 0;
			}
			key = mapNmsp[key];
			pageNmsp = key.Page;
			return key.Index;
		}

		internal void AddIdElement(string id, XPathNode[] pageElem, int idxElem)
		{
			if (idValueMap == null)
			{
				idValueMap = new Dictionary<string, XPathNodeRef>();
			}
			if (!idValueMap.ContainsKey(id))
			{
				idValueMap.Add(id, new XPathNodeRef(pageElem, idxElem));
			}
		}

		internal int LookupIdElement(string id, out XPathNode[] pageElem)
		{
			if (idValueMap == null || !idValueMap.ContainsKey(id))
			{
				pageElem = null;
				return 0;
			}
			XPathNodeRef xPathNodeRef = idValueMap[id];
			pageElem = xPathNodeRef.Page;
			return xPathNodeRef.Index;
		}

		private XmlTextReaderImpl SetupReader(XmlTextReaderImpl reader)
		{
			reader.EntityHandling = EntityHandling.ExpandEntities;
			reader.XmlValidatingReaderCompatibilityMode = true;
			return reader;
		}
	}
	[Serializable]
	public class XPathException : SystemException
	{
		private string res;

		private string[] args;

		private string message;

		public override string Message
		{
			get
			{
				if (message != null)
				{
					return message;
				}
				return base.Message;
			}
		}

		protected XPathException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			res = (string)info.GetValue("res", typeof(string));
			args = (string[])info.GetValue("args", typeof(string[]));
			string text = null;
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				if (current.Name == "version")
				{
					text = (string)current.Value;
				}
			}
			if (text == null)
			{
				message = CreateMessage(res, args);
			}
			else
			{
				message = null;
			}
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("res", res);
			info.AddValue("args", args);
			info.AddValue("version", "2.0");
		}

		public XPathException()
			: this(string.Empty, (Exception)null)
		{
		}

		public XPathException(string message)
			: this(message, (Exception)null)
		{
		}

		public XPathException(string message, Exception innerException)
			: this("Xml_UserException", new string[1] { message }, innerException)
		{
		}

		internal static XPathException Create(string res)
		{
			return new XPathException(res, (string[])null);
		}

		internal static XPathException Create(string res, string arg)
		{
			return new XPathException(res, new string[1] { arg });
		}

		internal static XPathException Create(string res, string arg, string arg2)
		{
			return new XPathException(res, new string[2] { arg, arg2 });
		}

		internal static XPathException Create(string res, string arg, Exception innerException)
		{
			return new XPathException(res, new string[1] { arg }, innerException);
		}

		private XPathException(string res, string[] args)
			: this(res, args, null)
		{
		}

		private XPathException(string res, string[] args, Exception inner)
			: base(CreateMessage(res, args), inner)
		{
			base.HResult = -2146231997;
			this.res = res;
			this.args = args;
		}

		private static string CreateMessage(string res, string[] args)
		{
			try
			{
				string text = Res.GetString(res, args);
				if (text == null)
				{
					text = "UNKNOWN(" + res + ")";
				}
				return text;
			}
			catch (MissingManifestResourceException)
			{
				return "UNKNOWN(" + res + ")";
			}
		}
	}
	public enum XmlSortOrder
	{
		Ascending = 1,
		Descending
	}
	public enum XmlCaseOrder
	{
		None,
		UpperFirst,
		LowerFirst
	}
	public enum XmlDataType
	{
		Text = 1,
		Number
	}
	public enum XPathResultType
	{
		Number = 0,
		String = 1,
		Boolean = 2,
		NodeSet = 3,
		Navigator = 1,
		Any = 5,
		Error = 6
	}
	public abstract class XPathExpression
	{
		public abstract string Expression { get; }

		public abstract XPathResultType ReturnType { get; }

		internal XPathExpression()
		{
		}

		public abstract void AddSort(object expr, IComparer comparer);

		public abstract void AddSort(object expr, XmlSortOrder order, XmlCaseOrder caseOrder, string lang, XmlDataType dataType);

		public abstract XPathExpression Clone();

		public abstract void SetContext(XmlNamespaceManager nsManager);

		public abstract void SetContext(IXmlNamespaceResolver nsResolver);

		public static XPathExpression Compile(string xpath)
		{
			return Compile(xpath, null);
		}

		public static XPathExpression Compile(string xpath, IXmlNamespaceResolver nsResolver)
		{
			bool needContext;
			Query query = new QueryBuilder().Build(xpath, out needContext);
			CompiledXpathExpr compiledXpathExpr = new CompiledXpathExpr(query, xpath, needContext);
			if (nsResolver != null)
			{
				XmlNamespaceManager namespaces = XPathNavigator.GetNamespaces(nsResolver);
				compiledXpathExpr.SetContext(namespaces);
			}
			return compiledXpathExpr;
		}

		private void PrintQuery(XmlWriter w)
		{
			((CompiledXpathExpr)this).QueryTree.PrintQuery(w);
		}
	}
	public enum XPathNamespaceScope
	{
		All,
		ExcludeXml,
		Local
	}
	internal class XPathNavigatorKeyComparer : IEqualityComparer
	{
		bool IEqualityComparer.Equals(object obj1, object obj2)
		{
			XPathNavigator xPathNavigator = obj1 as XPathNavigator;
			XPathNavigator xPathNavigator2 = obj2 as XPathNavigator;
			if (xPathNavigator != null && xPathNavigator2 != null && xPathNavigator.IsSamePosition(xPathNavigator2))
			{
				return true;
			}
			return false;
		}

		int IEqualityComparer.GetHashCode(object obj)
		{
			if (obj == null)
			{
				throw new ArgumentNullException("obj");
			}
			if (obj is XPathDocumentNavigator xPathDocumentNavigator)
			{
				return xPathDocumentNavigator.GetPositionHashCode();
			}
			if (obj is XPathNavigator xPathNavigator)
			{
				object underlyingObject = xPathNavigator.UnderlyingObject;
				if (underlyingObject != null)
				{
					return underlyingObject.GetHashCode();
				}
				int nodeType = (int)xPathNavigator.NodeType;
				nodeType ^= xPathNavigator.LocalName.GetHashCode();
				nodeType ^= xPathNavigator.Prefix.GetHashCode();
				return nodeType ^ xPathNavigator.NamespaceURI.GetHashCode();
			}
			return obj.GetHashCode();
		}
	}
	internal class XPathNavigatorReader : XmlReader, IXmlNamespaceResolver
	{
		private enum State
		{
			Initial,
			Content,
			EndElement,
			Attribute,
			AttrVal,
			InReadBinary,
			EOF,
			Closed,
			Error
		}

		internal const string space = "space";

		private XPathNavigator nav;

		private XPathNavigator navToRead;

		private int depth;

		private State state;

		private XmlNodeType nodeType;

		private int attrCount;

		private bool readEntireDocument;

		protected IXmlLineInfo lineInfo;

		protected IXmlSchemaInfo schemaInfo;

		private ReadContentAsBinaryHelper readBinaryHelper;

		private State savedState;

		internal static XmlNodeType[] convertFromXPathNodeType = new XmlNodeType[10]
		{
			XmlNodeType.Document,
			XmlNodeType.Element,
			XmlNodeType.Attribute,
			XmlNodeType.Attribute,
			XmlNodeType.Text,
			XmlNodeType.SignificantWhitespace,
			XmlNodeType.Whitespace,
			XmlNodeType.ProcessingInstruction,
			XmlNodeType.Comment,
			XmlNodeType.None
		};

		internal object UnderlyingObject => nav.UnderlyingObject;

		protected bool IsReading
		{
			get
			{
				if (state > State.Initial)
				{
					return state < State.EOF;
				}
				return false;
			}
		}

		internal override XmlNamespaceManager NamespaceManager => XPathNavigator.GetNamespaces(this);

		public override XmlNameTable NameTable => navToRead.NameTable;

		public override XmlReaderSettings Settings
		{
			get
			{
				XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
				xmlReaderSettings.NameTable = NameTable;
				xmlReaderSettings.ConformanceLevel = ConformanceLevel.Fragment;
				xmlReaderSettings.CheckCharacters = false;
				xmlReaderSettings.ReadOnly = true;
				return xmlReaderSettings;
			}
		}

		public override IXmlSchemaInfo SchemaInfo
		{
			get
			{
				if (nodeType == XmlNodeType.Text)
				{
					return null;
				}
				return nav.SchemaInfo;
			}
		}

		public override Type ValueType => nav.ValueType;

		public override XmlNodeType NodeType => nodeType;

		public override string NamespaceURI
		{
			get
			{
				if (nav.NodeType == XPathNodeType.Namespace)
				{
					return NameTable.Add("http://www.w3.org/2000/xmlns/");
				}
				if (NodeType == XmlNodeType.Text)
				{
					return string.Empty;
				}
				return nav.NamespaceURI;
			}
		}

		public override string LocalName
		{
			get
			{
				if (nav.NodeType == XPathNodeType.Namespace && nav.LocalName.Length == 0)
				{
					return NameTable.Add("xmlns");
				}
				if (NodeType == XmlNodeType.Text)
				{
					return string.Empty;
				}
				return nav.LocalName;
			}
		}

		public override string Prefix
		{
			get
			{
				if (nav.NodeType == XPathNodeType.Namespace && nav.LocalName.Length != 0)
				{
					return NameTable.Add("xmlns");
				}
				if (NodeType == XmlNodeType.Text)
				{
					return string.Empty;
				}
				return nav.Prefix;
			}
		}

		public override string BaseURI
		{
			get
			{
				if (state == State.Initial)
				{
					return navToRead.BaseURI;
				}
				return nav.BaseURI;
			}
		}

		public override bool IsEmptyElement => nav.IsEmptyElement;

		public override XmlSpace XmlSpace
		{
			get
			{
				string empty = string.Empty;
				XPathNavigator xPathNavigator = nav.Clone();
				do
				{
					if (xPathNavigator.MoveToAttribute("space", "http://www.w3.org/XML/1998/namespace"))
					{
						empty = xPathNavigator.Value;
						if (empty == "default")
						{
							return XmlSpace.Default;
						}
						if (empty == "preserve")
						{
							return XmlSpace.Preserve;
						}
					}
				}
				while (xPathNavigator.MoveToParent());
				return XmlSpace.None;
			}
		}

		public override string XmlLang => nav.XmlLang;

		public override bool HasValue
		{
			get
			{
				if (nodeType != XmlNodeType.Element && nodeType != XmlNodeType.Document && nodeType != XmlNodeType.EndElement && nodeType != 0)
				{
					return true;
				}
				return false;
			}
		}

		public override string Value
		{
			get
			{
				if (nodeType != XmlNodeType.Element && nodeType != XmlNodeType.Document && nodeType != XmlNodeType.EndElement && nodeType != 0)
				{
					return nav.Value;
				}
				return string.Empty;
			}
		}

		public override int AttributeCount
		{
			get
			{
				if (attrCount < 0)
				{
					XPathNavigator elemNav = GetElemNav();
					int num = 0;
					if (elemNav != null)
					{
						if (elemNav.MoveToFirstNamespace(XPathNamespaceScope.Local))
						{
							do
							{
								num++;
							}
							while (elemNav.MoveToNextNamespace(XPathNamespaceScope.Local));
							elemNav.MoveToParent();
						}
						if (elemNav.MoveToFirstAttribute())
						{
							do
							{
								num++;
							}
							while (elemNav.MoveToNextAttribute());
						}
					}
					attrCount = num;
				}
				return attrCount;
			}
		}

		public override bool EOF => state == State.EOF;

		public override ReadState ReadState
		{
			get
			{
				switch (state)
				{
				case State.Initial:
					return ReadState.Initial;
				case State.Content:
				case State.EndElement:
				case State.Attribute:
				case State.AttrVal:
				case State.InReadBinary:
					return ReadState.Interactive;
				case State.EOF:
					return ReadState.EndOfFile;
				case State.Closed:
					return ReadState.Closed;
				default:
					return ReadState.Error;
				}
			}
		}

		public override bool CanReadBinaryContent => true;

		public override int Depth => depth;

		internal static XmlNodeType ToXmlNodeType(XPathNodeType typ)
		{
			return convertFromXPathNodeType[(int)typ];
		}

		public static XPathNavigatorReader Create(XPathNavigator navToRead)
		{
			XPathNavigator xPathNavigator = navToRead.Clone();
			IXmlLineInfo xli = xPathNavigator as IXmlLineInfo;
			IXmlSchemaInfo xmlSchemaInfo = xPathNavigator as IXmlSchemaInfo;
			if (xmlSchemaInfo == null)
			{
				return new XPathNavigatorReader(xPathNavigator, xli, xmlSchemaInfo);
			}
			return new XPathNavigatorReaderWithSI(xPathNavigator, xli, xmlSchemaInfo);
		}

		protected XPathNavigatorReader(XPathNavigator navToRead, IXmlLineInfo xli, IXmlSchemaInfo xsi)
		{
			this.navToRead = navToRead;
			lineInfo = xli;
			schemaInfo = xsi;
			nav = XmlEmptyNavigator.Singleton;
			state = State.Initial;
			depth = 0;
			nodeType = ToXmlNodeType(nav.NodeType);
		}

		IDictionary<string, string> IXmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope scope)
		{
			return nav.GetNamespacesInScope(scope);
		}

		string IXmlNamespaceResolver.LookupNamespace(string prefix)
		{
			return nav.LookupNamespace(prefix);
		}

		string IXmlNamespaceResolver.LookupPrefix(string namespaceName)
		{
			return nav.LookupPrefix(namespaceName);
		}

		private XPathNavigator GetElemNav()
		{
			switch (state)
			{
			case State.Content:
				return nav.Clone();
			case State.Attribute:
			case State.AttrVal:
			{
				XPathNavigator xPathNavigator = nav.Clone();
				if (xPathNavigator.MoveToParent())
				{
					return xPathNavigator;
				}
				break;
			}
			case State.InReadBinary:
			{
				state = savedState;
				XPathNavigator elemNav = GetElemNav();
				state = State.InReadBinary;
				return elemNav;
			}
			}
			return null;
		}

		private XPathNavigator GetElemNav(out int depth)
		{
			XPathNavigator xPathNavigator = null;
			switch (state)
			{
			case State.Content:
				if (nodeType == XmlNodeType.Element)
				{
					xPathNavigator = nav.Clone();
				}
				depth = this.depth;
				break;
			case State.Attribute:
				xPathNavigator = nav.Clone();
				xPathNavigator.MoveToParent();
				depth = this.depth - 1;
				break;
			case State.AttrVal:
				xPathNavigator = nav.Clone();
				xPathNavigator.MoveToParent();
				depth = this.depth - 2;
				break;
			case State.InReadBinary:
				state = savedState;
				xPathNavigator = GetElemNav(out depth);
				state = State.InReadBinary;
				break;
			default:
				depth = this.depth;
				break;
			}
			return xPathNavigator;
		}

		private void MoveToAttr(XPathNavigator nav, int depth)
		{
			this.nav.MoveTo(nav);
			this.depth = depth;
			nodeType = XmlNodeType.Attribute;
			state = State.Attribute;
		}

		public override string GetAttribute(string name)
		{
			XPathNavigator xPathNavigator = nav;
			switch (xPathNavigator.NodeType)
			{
			case XPathNodeType.Attribute:
				xPathNavigator = xPathNavigator.Clone();
				if (!xPathNavigator.MoveToParent())
				{
					return null;
				}
				break;
			default:
				return null;
			case XPathNodeType.Element:
				break;
			}
			ValidateNames.SplitQName(name, out var prefix, out var lname);
			if (prefix.Length == 0)
			{
				if (lname == "xmlns")
				{
					return xPathNavigator.GetNamespace(string.Empty);
				}
				if (xPathNavigator == nav)
				{
					xPathNavigator = xPathNavigator.Clone();
				}
				if (xPathNavigator.MoveToAttribute(lname, string.Empty))
				{
					return xPathNavigator.Value;
				}
			}
			else
			{
				if (prefix == "xmlns")
				{
					return xPathNavigator.GetNamespace(lname);
				}
				if (xPathNavigator == nav)
				{
					xPathNavigator = xPathNavigator.Clone();
				}
				if (xPathNavigator.MoveToFirstAttribute())
				{
					do
					{
						if (xPathNavigator.LocalName == lname && xPathNavigator.Prefix == prefix)
						{
							return xPathNavigator.Value;
						}
					}
					while (xPathNavigator.MoveToNextAttribute());
				}
			}
			return null;
		}

		public override string GetAttribute(string localName, string namespaceURI)
		{
			if (localName == null)
			{
				throw new ArgumentNullException("localName");
			}
			XPathNavigator xPathNavigator = nav;
			switch (xPathNavigator.NodeType)
			{
			case XPathNodeType.Attribute:
				xPathNavigator = xPathNavigator.Clone();
				if (!xPathNavigator.MoveToParent())
				{
					return null;
				}
				break;
			default:
				return null;
			case XPathNodeType.Element:
				break;
			}
			if (namespaceURI == "http://www.w3.org/2000/xmlns/")
			{
				if (localName == "xmlns")
				{
					localName = string.Empty;
				}
				return xPathNavigator.GetNamespace(localName);
			}
			if (namespaceURI == null)
			{
				namespaceURI = string.Empty;
			}
			if (xPathNavigator == nav)
			{
				xPathNavigator = xPathNavigator.Clone();
			}
			if (xPathNavigator.MoveToAttribute(localName, namespaceURI))
			{
				return xPathNavigator.Value;
			}
			return null;
		}

		private static string GetNamespaceByIndex(XPathNavigator nav, int index, out int count)
		{
			string value = nav.Value;
			string result = null;
			if (nav.MoveToNextNamespace(XPathNamespaceScope.Local))
			{
				result = GetNamespaceByIndex(nav, index, out count);
			}
			else
			{
				count = 0;
			}
			if (count == index)
			{
				result = value;
			}
			count++;
			return result;
		}

		public override string GetAttribute(int index)
		{
			if (index >= 0)
			{
				XPathNavigator elemNav = GetElemNav();
				if (elemNav != null)
				{
					if (elemNav.MoveToFirstNamespace(XPathNamespaceScope.Local))
					{
						int count;
						string namespaceByIndex = GetNamespaceByIndex(elemNav, index, out count);
						if (namespaceByIndex != null)
						{
							return namespaceByIndex;
						}
						index -= count;
						elemNav.MoveToParent();
					}
					if (elemNav.MoveToFirstAttribute())
					{
						do
						{
							if (index == 0)
							{
								return elemNav.Value;
							}
							index--;
						}
						while (elemNav.MoveToNextAttribute());
					}
				}
			}
			throw new ArgumentOutOfRangeException("index");
		}

		public override bool MoveToAttribute(string localName, string namespaceName)
		{
			if (localName == null)
			{
				throw new ArgumentNullException("localName");
			}
			int num = depth;
			XPathNavigator elemNav = GetElemNav(out num);
			if (elemNav != null)
			{
				if (namespaceName == "http://www.w3.org/2000/xmlns/")
				{
					if (localName == "xmlns")
					{
						localName = string.Empty;
					}
					if (!elemNav.MoveToFirstNamespace(XPathNamespaceScope.Local))
					{
						goto IL_0078;
					}
					while (!(elemNav.LocalName == localName))
					{
						if (elemNav.MoveToNextNamespace(XPathNamespaceScope.Local))
						{
							continue;
						}
						goto IL_0078;
					}
				}
				else
				{
					if (namespaceName == null)
					{
						namespaceName = string.Empty;
					}
					if (!elemNav.MoveToAttribute(localName, namespaceName))
					{
						goto IL_0078;
					}
				}
				if (state == State.InReadBinary)
				{
					readBinaryHelper.Finish();
					state = savedState;
				}
				MoveToAttr(elemNav, num + 1);
				return true;
			}
			goto IL_0078;
			IL_0078:
			return false;
		}

		public override bool MoveToFirstAttribute()
		{
			int num;
			XPathNavigator elemNav = GetElemNav(out num);
			if (elemNav != null)
			{
				if (elemNav.MoveToFirstNamespace(XPathNamespaceScope.Local))
				{
					while (elemNav.MoveToNextNamespace(XPathNamespaceScope.Local))
					{
					}
				}
				else if (!elemNav.MoveToFirstAttribute())
				{
					goto IL_0028;
				}
				if (state == State.InReadBinary)
				{
					readBinaryHelper.Finish();
					state = savedState;
				}
				MoveToAttr(elemNav, num + 1);
				return true;
			}
			goto IL_0028;
			IL_0028:
			return false;
		}

		public override bool MoveToNextAttribute()
		{
			switch (state)
			{
			case State.Content:
				return MoveToFirstAttribute();
			case State.Attribute:
			{
				if (XPathNodeType.Attribute == nav.NodeType)
				{
					return nav.MoveToNextAttribute();
				}
				XPathNavigator xPathNavigator = nav.Clone();
				if (!xPathNavigator.MoveToParent())
				{
					return false;
				}
				if (!xPathNavigator.MoveToFirstNamespace(XPathNamespaceScope.Local))
				{
					return false;
				}
				if (xPathNavigator.IsSamePosition(nav))
				{
					xPathNavigator.MoveToParent();
					if (!xPathNavigator.MoveToFirstAttribute())
					{
						return false;
					}
					nav.MoveTo(xPathNavigator);
					return true;
				}
				XPathNavigator xPathNavigator2 = xPathNavigator.Clone();
				while (true)
				{
					if (!xPathNavigator.MoveToNextNamespace(XPathNamespaceScope.Local))
					{
						return false;
					}
					if (xPathNavigator.IsSamePosition(nav))
					{
						break;
					}
					xPathNavigator2.MoveTo(xPathNavigator);
				}
				nav.MoveTo(xPathNavigator2);
				return true;
			}
			case State.AttrVal:
				depth--;
				state = State.Attribute;
				if (!MoveToNextAttribute())
				{
					depth++;
					state = State.AttrVal;
					return false;
				}
				nodeType = XmlNodeType.Attribute;
				return true;
			case State.InReadBinary:
				state = savedState;
				if (!MoveToNextAttribute())
				{
					state = State.InReadBinary;
					return false;
				}
				readBinaryHelper.Finish();
				return true;
			default:
				return false;
			}
		}

		public override bool MoveToAttribute(string name)
		{
			int num;
			XPathNavigator elemNav = GetElemNav(out num);
			if (elemNav == null)
			{
				return false;
			}
			ValidateNames.SplitQName(name, out var prefix, out var lname);
			bool flag = false;
			if ((flag = prefix.Length == 0 && lname == "xmlns") || prefix == "xmlns")
			{
				if (flag)
				{
					lname = string.Empty;
				}
				if (!elemNav.MoveToFirstNamespace(XPathNamespaceScope.Local))
				{
					goto IL_00b3;
				}
				while (!(elemNav.LocalName == lname))
				{
					if (elemNav.MoveToNextNamespace(XPathNamespaceScope.Local))
					{
						continue;
					}
					goto IL_00b3;
				}
			}
			else if (prefix.Length == 0)
			{
				if (!elemNav.MoveToAttribute(lname, string.Empty))
				{
					goto IL_00b3;
				}
			}
			else
			{
				if (!elemNav.MoveToFirstAttribute())
				{
					goto IL_00b3;
				}
				while (!(elemNav.LocalName == lname) || !(elemNav.Prefix == prefix))
				{
					if (elemNav.MoveToNextAttribute())
					{
						continue;
					}
					goto IL_00b3;
				}
			}
			if (state == State.InReadBinary)
			{
				readBinaryHelper.Finish();
				state = savedState;
			}
			MoveToAttr(elemNav, num + 1);
			return true;
			IL_00b3:
			return false;
		}

		public override bool MoveToElement()
		{
			switch (state)
			{
			case State.Attribute:
			case State.AttrVal:
				if (!nav.MoveToParent())
				{
					return false;
				}
				depth--;
				if (state == State.AttrVal)
				{
					depth--;
				}
				state = State.Content;
				nodeType = XmlNodeType.Element;
				return true;
			case State.InReadBinary:
				state = savedState;
				if (!MoveToElement())
				{
					state = State.InReadBinary;
					return false;
				}
				readBinaryHelper.Finish();
				break;
			}
			return false;
		}

		public override void ResolveEntity()
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		public override bool ReadAttributeValue()
		{
			if (state == State.InReadBinary)
			{
				readBinaryHelper.Finish();
				state = savedState;
			}
			if (state == State.Attribute)
			{
				state = State.AttrVal;
				nodeType = XmlNodeType.Text;
				depth++;
				return true;
			}
			return false;
		}

		public override int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (state != State.InReadBinary)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
				savedState = state;
			}
			state = savedState;
			int result = readBinaryHelper.ReadContentAsBase64(buffer, index, count);
			savedState = state;
			state = State.InReadBinary;
			return result;
		}

		public override int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (state != State.InReadBinary)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
				savedState = state;
			}
			state = savedState;
			int result = readBinaryHelper.ReadContentAsBinHex(buffer, index, count);
			savedState = state;
			state = State.InReadBinary;
			return result;
		}

		public override int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (state != State.InReadBinary)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
				savedState = state;
			}
			state = savedState;
			int result = readBinaryHelper.ReadElementContentAsBase64(buffer, index, count);
			savedState = state;
			state = State.InReadBinary;
			return result;
		}

		public override int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			if (ReadState != ReadState.Interactive)
			{
				return 0;
			}
			if (state != State.InReadBinary)
			{
				readBinaryHelper = ReadContentAsBinaryHelper.CreateOrReset(readBinaryHelper, this);
				savedState = state;
			}
			state = savedState;
			int result = readBinaryHelper.ReadElementContentAsBinHex(buffer, index, count);
			savedState = state;
			state = State.InReadBinary;
			return result;
		}

		public override string LookupNamespace(string prefix)
		{
			return nav.LookupNamespace(prefix);
		}

		public override bool Read()
		{
			attrCount = -1;
			switch (state)
			{
			case State.EOF:
			case State.Closed:
			case State.Error:
				return false;
			case State.Initial:
				nav = navToRead;
				state = State.Content;
				if (nav.NodeType == XPathNodeType.Root)
				{
					if (!nav.MoveToFirstChild())
					{
						SetEOF();
						return false;
					}
					readEntireDocument = true;
				}
				else if (XPathNodeType.Attribute == nav.NodeType)
				{
					state = State.Attribute;
				}
				nodeType = ToXmlNodeType(nav.NodeType);
				break;
			case State.Content:
				if (nav.MoveToFirstChild())
				{
					nodeType = ToXmlNodeType(nav.NodeType);
					depth++;
					state = State.Content;
					break;
				}
				if (nodeType == XmlNodeType.Element && !nav.IsEmptyElement)
				{
					nodeType = XmlNodeType.EndElement;
					state = State.EndElement;
					break;
				}
				goto case State.EndElement;
			case State.EndElement:
				if (depth == 0 && !readEntireDocument)
				{
					SetEOF();
					return false;
				}
				if (nav.MoveToNext())
				{
					nodeType = ToXmlNodeType(nav.NodeType);
					state = State.Content;
					break;
				}
				if (depth > 0 && nav.MoveToParent())
				{
					nodeType = XmlNodeType.EndElement;
					state = State.EndElement;
					depth--;
					break;
				}
				SetEOF();
				return false;
			case State.Attribute:
			case State.AttrVal:
				if (!nav.MoveToParent())
				{
					SetEOF();
					return false;
				}
				nodeType = ToXmlNodeType(nav.NodeType);
				depth--;
				if (state == State.AttrVal)
				{
					depth--;
				}
				goto case State.Content;
			case State.InReadBinary:
				state = savedState;
				readBinaryHelper.Finish();
				return Read();
			}
			return true;
		}

		public override void Close()
		{
			nav = XmlEmptyNavigator.Singleton;
			nodeType = XmlNodeType.None;
			state = State.Closed;
			depth = 0;
		}

		private void SetEOF()
		{
			nav = XmlEmptyNavigator.Singleton;
			nodeType = XmlNodeType.None;
			state = State.EOF;
			depth = 0;
		}
	}
	internal class XPathNavigatorReaderWithSI : XPathNavigatorReader, IXmlSchemaInfo
	{
		public virtual XmlSchemaValidity Validity
		{
			get
			{
				if (!base.IsReading)
				{
					return XmlSchemaValidity.NotKnown;
				}
				return schemaInfo.Validity;
			}
		}

		public override bool IsDefault
		{
			get
			{
				if (!base.IsReading)
				{
					return false;
				}
				return schemaInfo.IsDefault;
			}
		}

		public virtual bool IsNil
		{
			get
			{
				if (!base.IsReading)
				{
					return false;
				}
				return schemaInfo.IsNil;
			}
		}

		public virtual XmlSchemaSimpleType MemberType
		{
			get
			{
				if (!base.IsReading)
				{
					return null;
				}
				return schemaInfo.MemberType;
			}
		}

		public virtual XmlSchemaType SchemaType
		{
			get
			{
				if (!base.IsReading)
				{
					return null;
				}
				return schemaInfo.SchemaType;
			}
		}

		public virtual XmlSchemaElement SchemaElement
		{
			get
			{
				if (!base.IsReading)
				{
					return null;
				}
				return schemaInfo.SchemaElement;
			}
		}

		public virtual XmlSchemaAttribute SchemaAttribute
		{
			get
			{
				if (!base.IsReading)
				{
					return null;
				}
				return schemaInfo.SchemaAttribute;
			}
		}

		internal XPathNavigatorReaderWithSI(XPathNavigator navToRead, IXmlLineInfo xli, IXmlSchemaInfo xsi)
			: base(navToRead, xli, xsi)
		{
		}
	}
	internal class XmlEmptyNavigator : XPathNavigator
	{
		private static XmlEmptyNavigator singleton;

		public static XmlEmptyNavigator Singleton
		{
			get
			{
				if (singleton == null)
				{
					singleton = new XmlEmptyNavigator();
				}
				return singleton;
			}
		}

		public override XPathNodeType NodeType => XPathNodeType.All;

		public override string NamespaceURI => string.Empty;

		public override string LocalName => string.Empty;

		public override string Name => string.Empty;

		public override string Prefix => string.Empty;

		public override string BaseURI => string.Empty;

		public override string Value => string.Empty;

		public override bool IsEmptyElement => false;

		public override string XmlLang => string.Empty;

		public override bool HasAttributes => false;

		public override bool HasChildren => false;

		public override XmlNameTable NameTable => new NameTable();

		private XmlEmptyNavigator()
		{
		}

		public override bool MoveToFirstChild()
		{
			return false;
		}

		public override void MoveToRoot()
		{
		}

		public override bool MoveToNext()
		{
			return false;
		}

		public override bool MoveToPrevious()
		{
			return false;
		}

		public override bool MoveToFirst()
		{
			return false;
		}

		public override bool MoveToFirstAttribute()
		{
			return false;
		}

		public override bool MoveToNextAttribute()
		{
			return false;
		}

		public override bool MoveToId(string id)
		{
			return false;
		}

		public override string GetAttribute(string localName, string namespaceName)
		{
			return null;
		}

		public override bool MoveToAttribute(string localName, string namespaceName)
		{
			return false;
		}

		public override string GetNamespace(string name)
		{
			return null;
		}

		public override bool MoveToNamespace(string prefix)
		{
			return false;
		}

		public override bool MoveToFirstNamespace(XPathNamespaceScope scope)
		{
			return false;
		}

		public override bool MoveToNextNamespace(XPathNamespaceScope scope)
		{
			return false;
		}

		public override bool MoveToParent()
		{
			return false;
		}

		public override bool MoveTo(XPathNavigator other)
		{
			return this == other;
		}

		public override XmlNodeOrder ComparePosition(XPathNavigator other)
		{
			if (this != other)
			{
				return XmlNodeOrder.Unknown;
			}
			return XmlNodeOrder.Same;
		}

		public override bool IsSamePosition(XPathNavigator other)
		{
			return this == other;
		}

		public override XPathNavigator Clone()
		{
			return this;
		}
	}
	public enum XPathNodeType
	{
		Root,
		Element,
		Attribute,
		Namespace,
		Text,
		SignificantWhitespace,
		Whitespace,
		ProcessingInstruction,
		Comment,
		All
	}
}
namespace MS.Internal.Xml.XPath
{
	internal abstract class ResetableIterator : XPathNodeIterator
	{
		public abstract override int CurrentPosition { get; }

		public ResetableIterator()
		{
			count = -1;
		}

		protected ResetableIterator(ResetableIterator other)
		{
			count = other.count;
		}

		protected void ResetCount()
		{
			count = -1;
		}

		public abstract void Reset();

		public virtual bool MoveToPosition(int pos)
		{
			Reset();
			for (int i = CurrentPosition; i < pos; i++)
			{
				if (!MoveNext())
				{
					return false;
				}
			}
			return true;
		}
	}
	[DebuggerDisplay("{ToString()}")]
	internal abstract class Query : ResetableIterator
	{
		public const XPathResultType XPathResultType_Navigator = (XPathResultType)4;

		public override int Count
		{
			get
			{
				if (count == -1)
				{
					Query query = (Query)Clone();
					query.Reset();
					count = 0;
					while (query.MoveNext())
					{
						count++;
					}
				}
				return count;
			}
		}

		public virtual double XsltDefaultPriority => 0.5;

		public abstract XPathResultType StaticType { get; }

		public virtual QueryProps Properties => QueryProps.Merge;

		public Query()
		{
		}

		protected Query(Query other)
			: base(other)
		{
		}

		public override bool MoveNext()
		{
			return Advance() != null;
		}

		public virtual void SetXsltContext(XsltContext context)
		{
		}

		public abstract object Evaluate(XPathNodeIterator nodeIterator);

		public abstract XPathNavigator Advance();

		public virtual XPathNavigator MatchNode(XPathNavigator current)
		{
			throw XPathException.Create("Xp_InvalidPattern");
		}

		public static Query Clone(Query input)
		{
			if (input != null)
			{
				return (Query)input.Clone();
			}
			return null;
		}

		protected static XPathNodeIterator Clone(XPathNodeIterator input)
		{
			return input?.Clone();
		}

		protected static XPathNavigator Clone(XPathNavigator input)
		{
			return input?.Clone();
		}

		public bool Insert(List<XPathNavigator> buffer, XPathNavigator nav)
		{
			int num = 0;
			int num2 = buffer.Count;
			if (num2 != 0)
			{
				switch (CompareNodes(buffer[num2 - 1], nav))
				{
				case XmlNodeOrder.Same:
					return false;
				case XmlNodeOrder.Before:
					buffer.Add(nav.Clone());
					return true;
				}
				num2--;
			}
			while (num < num2)
			{
				int median = GetMedian(num, num2);
				switch (CompareNodes(buffer[median], nav))
				{
				case XmlNodeOrder.Same:
					return false;
				case XmlNodeOrder.Before:
					num = median + 1;
					break;
				default:
					num2 = median;
					break;
				}
			}
			buffer.Insert(num, nav.Clone());
			return true;
		}

		private static int GetMedian(int l, int r)
		{
			return (int)((uint)(l + r) >> 1);
		}

		public static XmlNodeOrder CompareNodes(XPathNavigator l, XPathNavigator r)
		{
			XmlNodeOrder xmlNodeOrder = l.ComparePosition(r);
			if (xmlNodeOrder == XmlNodeOrder.Unknown)
			{
				XPathNavigator xPathNavigator = l.Clone();
				xPathNavigator.MoveToRoot();
				string baseURI = xPathNavigator.BaseURI;
				if (!xPathNavigator.MoveTo(r))
				{
					xPathNavigator = r.Clone();
				}
				xPathNavigator.MoveToRoot();
				string baseURI2 = xPathNavigator.BaseURI;
				int num = string.CompareOrdinal(baseURI, baseURI2);
				xmlNodeOrder = ((num >= 0) ? ((num > 0) ? XmlNodeOrder.After : XmlNodeOrder.Unknown) : XmlNodeOrder.Before);
			}
			return xmlNodeOrder;
		}

		[Conditional("DEBUG")]
		private void AssertDOD(List<XPathNavigator> buffer, XPathNavigator nav, int pos)
		{
			if (!(nav.GetType().ToString() == "Microsoft.VisualStudio.Modeling.StoreNavigator") && !(nav.GetType().ToString() == "System.Xml.DataDocumentXPathNavigator"))
			{
				if (0 < pos)
				{
					CompareNodes(buffer[pos - 1], nav);
				}
				if (pos < buffer.Count)
				{
					CompareNodes(nav, buffer[pos]);
				}
			}
		}

		[Conditional("DEBUG")]
		public static void AssertQuery(Query query)
		{
			if (query is FunctionQuery)
			{
				return;
			}
			query = Clone(query);
			XPathNavigator xPathNavigator = null;
			_ = query.Clone().Count;
			int num = 0;
			XPathNavigator xPathNavigator2;
			while ((xPathNavigator2 = query.Advance()) != null && !(xPathNavigator2.GetType().ToString() == "Microsoft.VisualStudio.Modeling.StoreNavigator") && !(xPathNavigator2.GetType().ToString() == "System.Xml.DataDocumentXPathNavigator"))
			{
				if (xPathNavigator != null && (xPathNavigator.NodeType != XPathNodeType.Namespace || xPathNavigator2.NodeType != XPathNodeType.Namespace))
				{
					CompareNodes(xPathNavigator, xPathNavigator2);
				}
				xPathNavigator = xPathNavigator2.Clone();
				num++;
			}
		}

		protected XPathResultType GetXPathType(object value)
		{
			if (value is XPathNodeIterator)
			{
				return XPathResultType.NodeSet;
			}
			if (value is string)
			{
				return XPathResultType.String;
			}
			if (value is double)
			{
				return XPathResultType.Number;
			}
			if (value is bool)
			{
				return XPathResultType.Boolean;
			}
			return (XPathResultType)4;
		}

		public virtual void PrintQuery(XmlWriter w)
		{
			w.WriteElementString(GetType().Name, string.Empty);
		}
	}
	internal class ContextQuery : Query
	{
		protected XPathNavigator contextNode;

		public override XPathNavigator Current => contextNode;

		public override XPathResultType StaticType => XPathResultType.NodeSet;

		public override int CurrentPosition => count;

		public override int Count => 1;

		public override QueryProps Properties => (QueryProps)23;

		public ContextQuery()
		{
			count = 0;
		}

		protected ContextQuery(ContextQuery other)
			: base(other)
		{
			contextNode = other.contextNode;
		}

		public override void Reset()
		{
			count = 0;
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			contextNode = context.Current;
			count = 0;
			return this;
		}

		public override XPathNavigator Advance()
		{
			if (count == 0)
			{
				count = 1;
				return contextNode;
			}
			return null;
		}

		public override XPathNavigator MatchNode(XPathNavigator current)
		{
			return current;
		}

		public override XPathNodeIterator Clone()
		{
			return new ContextQuery(this);
		}
	}
	internal sealed class AbsoluteQuery : ContextQuery
	{
		public AbsoluteQuery()
		{
		}

		private AbsoluteQuery(AbsoluteQuery other)
			: base(other)
		{
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			contextNode = context.Current.Clone();
			contextNode.MoveToRoot();
			count = 0;
			return this;
		}

		public override XPathNavigator MatchNode(XPathNavigator context)
		{
			if (context != null && context.NodeType == XPathNodeType.Root)
			{
				return context;
			}
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return new AbsoluteQuery(this);
		}
	}
	internal abstract class AstNode
	{
		public enum AstType
		{
			Axis,
			Operator,
			Filter,
			ConstantOperand,
			Function,
			Group,
			Root,
			Variable,
			Error
		}

		public abstract AstType Type { get; }

		public abstract XPathResultType ReturnType { get; }
	}
	internal abstract class BaseAxisQuery : Query
	{
		internal Query qyInput;

		private bool nameTest;

		private string name;

		private string prefix;

		private string nsUri;

		private XPathNodeType typeTest;

		protected XPathNavigator currentNode;

		protected int position;

		protected string Name => name;

		protected string Prefix => prefix;

		protected string Namespace => nsUri;

		protected bool NameTest => nameTest;

		protected XPathNodeType TypeTest => typeTest;

		public override int CurrentPosition => position;

		public override XPathNavigator Current => currentNode;

		public override double XsltDefaultPriority
		{
			get
			{
				if (qyInput.GetType() != typeof(ContextQuery))
				{
					return 0.5;
				}
				if (name.Length != 0)
				{
					return 0.0;
				}
				if (prefix.Length != 0)
				{
					return -0.25;
				}
				return -0.5;
			}
		}

		public override XPathResultType StaticType => XPathResultType.NodeSet;

		protected BaseAxisQuery(Query qyInput)
		{
			name = string.Empty;
			prefix = string.Empty;
			nsUri = string.Empty;
			this.qyInput = qyInput;
		}

		protected BaseAxisQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest)
		{
			this.qyInput = qyInput;
			this.name = name;
			this.prefix = prefix;
			this.typeTest = typeTest;
			nameTest = prefix.Length != 0 || name.Length != 0;
			nsUri = string.Empty;
		}

		protected BaseAxisQuery(BaseAxisQuery other)
			: base(other)
		{
			qyInput = Query.Clone(other.qyInput);
			name = other.name;
			prefix = other.prefix;
			nsUri = other.nsUri;
			typeTest = other.typeTest;
			nameTest = other.nameTest;
			position = other.position;
			currentNode = other.currentNode;
		}

		public override void Reset()
		{
			position = 0;
			currentNode = null;
			qyInput.Reset();
		}

		public override void SetXsltContext(XsltContext context)
		{
			nsUri = context.LookupNamespace(prefix);
			qyInput.SetXsltContext(context);
		}

		public virtual bool matches(XPathNavigator e)
		{
			if (TypeTest == e.NodeType || TypeTest == XPathNodeType.All || (TypeTest == XPathNodeType.Text && (e.NodeType == XPathNodeType.Whitespace || e.NodeType == XPathNodeType.SignificantWhitespace)))
			{
				if (!NameTest)
				{
					return true;
				}
				if ((name.Equals(e.LocalName) || name.Length == 0) && nsUri.Equals(e.NamespaceURI))
				{
					return true;
				}
			}
			return false;
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			ResetCount();
			Reset();
			qyInput.Evaluate(nodeIterator);
			return this;
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			if (NameTest)
			{
				w.WriteAttributeString("name", (Prefix.Length != 0) ? (Prefix + ':' + Name) : Name);
			}
			if (TypeTest != XPathNodeType.Element)
			{
				w.WriteAttributeString("nodeType", TypeTest.ToString());
			}
			qyInput.PrintQuery(w);
			w.WriteEndElement();
		}
	}
	internal sealed class AttributeQuery : BaseAxisQuery
	{
		private bool onAttribute;

		public AttributeQuery(Query qyParent, string Name, string Prefix, XPathNodeType Type)
			: base(qyParent, Name, Prefix, Type)
		{
		}

		private AttributeQuery(AttributeQuery other)
			: base(other)
		{
			onAttribute = other.onAttribute;
		}

		public override void Reset()
		{
			onAttribute = false;
			base.Reset();
		}

		public override XPathNavigator Advance()
		{
			do
			{
				if (!onAttribute)
				{
					currentNode = qyInput.Advance();
					if (currentNode == null)
					{
						return null;
					}
					position = 0;
					currentNode = currentNode.Clone();
					onAttribute = currentNode.MoveToFirstAttribute();
				}
				else
				{
					onAttribute = currentNode.MoveToNextAttribute();
				}
			}
			while (!onAttribute || !matches(currentNode));
			position++;
			return currentNode;
		}

		public override XPathNavigator MatchNode(XPathNavigator context)
		{
			if (context != null && context.NodeType == XPathNodeType.Attribute && matches(context))
			{
				XPathNavigator xPathNavigator = context.Clone();
				if (xPathNavigator.MoveToParent())
				{
					return qyInput.MatchNode(xPathNavigator);
				}
			}
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return new AttributeQuery(this);
		}
	}
	internal class Axis : AstNode
	{
		public enum AxisType
		{
			Ancestor,
			AncestorOrSelf,
			Attribute,
			Child,
			Descendant,
			DescendantOrSelf,
			Following,
			FollowingSibling,
			Namespace,
			Parent,
			Preceding,
			PrecedingSibling,
			Self,
			None
		}

		private AxisType axisType;

		private AstNode input;

		private string prefix;

		private string name;

		private XPathNodeType nodeType;

		protected bool abbrAxis;

		private string urn = string.Empty;

		public override AstType Type => AstType.Axis;

		public override XPathResultType ReturnType => XPathResultType.NodeSet;

		public AstNode Input
		{
			get
			{
				return input;
			}
			set
			{
				input = value;
			}
		}

		public string Prefix => prefix;

		public string Name => name;

		public XPathNodeType NodeType => nodeType;

		public AxisType TypeOfAxis => axisType;

		public bool AbbrAxis => abbrAxis;

		public string Urn
		{
			get
			{
				return urn;
			}
			set
			{
				urn = value;
			}
		}

		public Axis(AxisType axisType, AstNode input, string prefix, string name, XPathNodeType nodetype)
		{
			this.axisType = axisType;
			this.input = input;
			this.prefix = prefix;
			this.name = name;
			nodeType = nodetype;
		}

		public Axis(AxisType axisType, AstNode input)
			: this(axisType, input, string.Empty, string.Empty, XPathNodeType.All)
		{
			abbrAxis = true;
		}
	}
	internal abstract class ValueQuery : Query
	{
		public sealed override XPathNavigator Current
		{
			get
			{
				throw XPathException.Create("Xp_NodeSetExpected");
			}
		}

		public sealed override int CurrentPosition
		{
			get
			{
				throw XPathException.Create("Xp_NodeSetExpected");
			}
		}

		public sealed override int Count
		{
			get
			{
				throw XPathException.Create("Xp_NodeSetExpected");
			}
		}

		public ValueQuery()
		{
		}

		protected ValueQuery(ValueQuery other)
			: base(other)
		{
		}

		public sealed override void Reset()
		{
		}

		public sealed override XPathNavigator Advance()
		{
			throw XPathException.Create("Xp_NodeSetExpected");
		}
	}
	internal sealed class BooleanExpr : ValueQuery
	{
		private Query opnd1;

		private Query opnd2;

		private bool isOr;

		public override XPathResultType StaticType => XPathResultType.Boolean;

		public BooleanExpr(Operator.Op op, Query opnd1, Query opnd2)
		{
			if (opnd1.StaticType != XPathResultType.Boolean)
			{
				opnd1 = new BooleanFunctions(Function.FunctionType.FuncBoolean, opnd1);
			}
			if (opnd2.StaticType != XPathResultType.Boolean)
			{
				opnd2 = new BooleanFunctions(Function.FunctionType.FuncBoolean, opnd2);
			}
			this.opnd1 = opnd1;
			this.opnd2 = opnd2;
			isOr = op == Operator.Op.OR;
		}

		private BooleanExpr(BooleanExpr other)
			: base(other)
		{
			opnd1 = Query.Clone(other.opnd1);
			opnd2 = Query.Clone(other.opnd2);
			isOr = other.isOr;
		}

		public override void SetXsltContext(XsltContext context)
		{
			opnd1.SetXsltContext(context);
			opnd2.SetXsltContext(context);
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			object obj = opnd1.Evaluate(nodeIterator);
			if ((bool)obj == isOr)
			{
				return obj;
			}
			return opnd2.Evaluate(nodeIterator);
		}

		public override XPathNodeIterator Clone()
		{
			return new BooleanExpr(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			w.WriteAttributeString("op", (isOr ? Operator.Op.OR : Operator.Op.AND).ToString());
			opnd1.PrintQuery(w);
			opnd2.PrintQuery(w);
			w.WriteEndElement();
		}
	}
	internal sealed class BooleanFunctions : ValueQuery
	{
		private Query arg;

		private Function.FunctionType funcType;

		public override XPathResultType StaticType => XPathResultType.Boolean;

		public BooleanFunctions(Function.FunctionType funcType, Query arg)
		{
			this.arg = arg;
			this.funcType = funcType;
		}

		private BooleanFunctions(BooleanFunctions other)
			: base(other)
		{
			arg = Query.Clone(other.arg);
			funcType = other.funcType;
		}

		public override void SetXsltContext(XsltContext context)
		{
			if (arg != null)
			{
				arg.SetXsltContext(context);
			}
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			return funcType switch
			{
				Function.FunctionType.FuncBoolean => toBoolean(nodeIterator), 
				Function.FunctionType.FuncNot => Not(nodeIterator), 
				Function.FunctionType.FuncTrue => true, 
				Function.FunctionType.FuncFalse => false, 
				Function.FunctionType.FuncLang => Lang(nodeIterator), 
				_ => false, 
			};
		}

		internal static bool toBoolean(double number)
		{
			if (number != 0.0)
			{
				return !double.IsNaN(number);
			}
			return false;
		}

		internal static bool toBoolean(string str)
		{
			return str.Length > 0;
		}

		internal bool toBoolean(XPathNodeIterator nodeIterator)
		{
			object obj = arg.Evaluate(nodeIterator);
			if (obj is XPathNodeIterator)
			{
				return arg.Advance() != null;
			}
			if (obj is string)
			{
				return toBoolean((string)obj);
			}
			if (obj is double)
			{
				return toBoolean((double)obj);
			}
			if (obj is bool)
			{
				return (bool)obj;
			}
			return true;
		}

		private bool Not(XPathNodeIterator nodeIterator)
		{
			return !(bool)arg.Evaluate(nodeIterator);
		}

		private bool Lang(XPathNodeIterator nodeIterator)
		{
			string text = arg.Evaluate(nodeIterator).ToString();
			string xmlLang = nodeIterator.Current.XmlLang;
			if (xmlLang.StartsWith(text, StringComparison.OrdinalIgnoreCase))
			{
				if (xmlLang.Length != text.Length)
				{
					return xmlLang[text.Length] == '-';
				}
				return true;
			}
			return false;
		}

		public override XPathNodeIterator Clone()
		{
			return new BooleanFunctions(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			w.WriteAttributeString("name", funcType.ToString());
			if (arg != null)
			{
				arg.PrintQuery(w);
			}
			w.WriteEndElement();
		}
	}
	internal abstract class CacheAxisQuery : BaseAxisQuery
	{
		protected List<XPathNavigator> outputBuffer;

		public override XPathNavigator Current
		{
			get
			{
				if (count == 0)
				{
					return null;
				}
				return outputBuffer[count - 1];
			}
		}

		public override int CurrentPosition => count;

		public override int Count => outputBuffer.Count;

		public override QueryProps Properties => (QueryProps)23;

		public CacheAxisQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest)
			: base(qyInput, name, prefix, typeTest)
		{
			outputBuffer = new List<XPathNavigator>();
			count = 0;
		}

		protected CacheAxisQuery(CacheAxisQuery other)
			: base(other)
		{
			outputBuffer = new List<XPathNavigator>(other.outputBuffer);
			count = other.count;
		}

		public override void Reset()
		{
			count = 0;
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			base.Evaluate(context);
			outputBuffer.Clear();
			return this;
		}

		public override XPathNavigator Advance()
		{
			if (count < outputBuffer.Count)
			{
				return outputBuffer[count++];
			}
			return null;
		}
	}
	internal class ChildrenQuery : BaseAxisQuery
	{
		private XPathNodeIterator iterator = XPathEmptyIterator.Instance;

		public ChildrenQuery(Query qyInput, string name, string prefix, XPathNodeType type)
			: base(qyInput, name, prefix, type)
		{
		}

		protected ChildrenQuery(ChildrenQuery other)
			: base(other)
		{
			iterator = Query.Clone(other.iterator);
		}

		public override void Reset()
		{
			iterator = XPathEmptyIterator.Instance;
			base.Reset();
		}

		public override XPathNavigator Advance()
		{
			while (!iterator.MoveNext())
			{
				XPathNavigator xPathNavigator = qyInput.Advance();
				if (xPathNavigator == null)
				{
					return null;
				}
				if (base.NameTest)
				{
					if (base.TypeTest == XPathNodeType.ProcessingInstruction)
					{
						iterator = new IteratorFilter(xPathNavigator.SelectChildren(base.TypeTest), base.Name);
					}
					else
					{
						iterator = xPathNavigator.SelectChildren(base.Name, base.Namespace);
					}
				}
				else
				{
					iterator = xPathNavigator.SelectChildren(base.TypeTest);
				}
				position = 0;
			}
			position++;
			currentNode = iterator.Current;
			return currentNode;
		}

		public sealed override XPathNavigator MatchNode(XPathNavigator context)
		{
			if (context != null && matches(context))
			{
				XPathNavigator xPathNavigator = context.Clone();
				if (xPathNavigator.NodeType != XPathNodeType.Attribute && xPathNavigator.MoveToParent())
				{
					return qyInput.MatchNode(xPathNavigator);
				}
				return null;
			}
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return new ChildrenQuery(this);
		}
	}
	internal sealed class CacheChildrenQuery : ChildrenQuery
	{
		private XPathNavigator nextInput;

		private ClonableStack<XPathNavigator> elementStk;

		private ClonableStack<int> positionStk;

		private bool needInput;

		public CacheChildrenQuery(Query qyInput, string name, string prefix, XPathNodeType type)
			: base(qyInput, name, prefix, type)
		{
			elementStk = new ClonableStack<XPathNavigator>();
			positionStk = new ClonableStack<int>();
			needInput = true;
		}

		private CacheChildrenQuery(CacheChildrenQuery other)
			: base(other)
		{
			nextInput = Query.Clone(other.nextInput);
			elementStk = other.elementStk.Clone();
			positionStk = other.positionStk.Clone();
			needInput = other.needInput;
		}

		public override void Reset()
		{
			nextInput = null;
			elementStk.Clear();
			positionStk.Clear();
			needInput = true;
			base.Reset();
		}

		public override XPathNavigator Advance()
		{
			do
			{
				IL_0000:
				if (needInput)
				{
					if (elementStk.Count == 0)
					{
						currentNode = GetNextInput();
						if (currentNode == null)
						{
							return null;
						}
						if (!currentNode.MoveToFirstChild())
						{
							goto IL_0000;
						}
						position = 0;
					}
					else
					{
						currentNode = elementStk.Pop();
						position = positionStk.Pop();
						if (!DecideNextNode())
						{
							goto IL_0000;
						}
					}
					needInput = false;
				}
				else if (!currentNode.MoveToNext() || !DecideNextNode())
				{
					needInput = true;
					goto IL_0000;
				}
			}
			while (!matches(currentNode));
			position++;
			return currentNode;
		}

		private bool DecideNextNode()
		{
			nextInput = GetNextInput();
			if (nextInput != null && Query.CompareNodes(currentNode, nextInput) == XmlNodeOrder.After)
			{
				elementStk.Push(currentNode);
				positionStk.Push(position);
				currentNode = nextInput;
				nextInput = null;
				if (!currentNode.MoveToFirstChild())
				{
					return false;
				}
				position = 0;
			}
			return true;
		}

		private XPathNavigator GetNextInput()
		{
			XPathNavigator xPathNavigator;
			if (nextInput != null)
			{
				xPathNavigator = nextInput;
				nextInput = null;
			}
			else
			{
				xPathNavigator = qyInput.Advance();
				if (xPathNavigator != null)
				{
					xPathNavigator = xPathNavigator.Clone();
				}
			}
			return xPathNavigator;
		}

		public override XPathNodeIterator Clone()
		{
			return new CacheChildrenQuery(this);
		}
	}
	internal abstract class CacheOutputQuery : Query
	{
		internal Query input;

		protected List<XPathNavigator> outputBuffer;

		public override XPathNavigator Current
		{
			get
			{
				if (count == 0)
				{
					return null;
				}
				return outputBuffer[count - 1];
			}
		}

		public override XPathResultType StaticType => XPathResultType.NodeSet;

		public override int CurrentPosition => count;

		public override int Count => outputBuffer.Count;

		public override QueryProps Properties => (QueryProps)23;

		public CacheOutputQuery(Query input)
		{
			this.input = input;
			outputBuffer = new List<XPathNavigator>();
			count = 0;
		}

		protected CacheOutputQuery(CacheOutputQuery other)
			: base(other)
		{
			input = Query.Clone(other.input);
			outputBuffer = new List<XPathNavigator>(other.outputBuffer);
			count = other.count;
		}

		public override void Reset()
		{
			count = 0;
		}

		public override void SetXsltContext(XsltContext context)
		{
			input.SetXsltContext(context);
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			outputBuffer.Clear();
			count = 0;
			return input.Evaluate(context);
		}

		public override XPathNavigator Advance()
		{
			if (count < outputBuffer.Count)
			{
				return outputBuffer[count++];
			}
			return null;
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			input.PrintQuery(w);
			w.WriteEndElement();
		}
	}
	internal sealed class ClonableStack<T> : List<T>
	{
		public ClonableStack()
		{
		}

		public ClonableStack(int capacity)
			: base(capacity)
		{
		}

		private ClonableStack(IEnumerable<T> collection)
			: base(collection)
		{
		}

		public void Push(T value)
		{
			Add(value);
		}

		public T Pop()
		{
			int index = base.Count - 1;
			T result = base[index];
			RemoveAt(index);
			return result;
		}

		public T Peek()
		{
			return base[base.Count - 1];
		}

		public ClonableStack<T> Clone()
		{
			return new ClonableStack<T>(this);
		}
	}
	internal class CompiledXpathExpr : XPathExpression
	{
		private class UndefinedXsltContext : XsltContext
		{
			private XmlNamespaceManager nsManager;

			public override string DefaultNamespace => string.Empty;

			public override bool Whitespace => false;

			public UndefinedXsltContext(XmlNamespaceManager nsManager)
				: base(dummy: false)
			{
				this.nsManager = nsManager;
			}

			public override string LookupNamespace(string prefix)
			{
				if (prefix.Length == 0)
				{
					return string.Empty;
				}
				string text = nsManager.LookupNamespace(prefix);
				if (text == null)
				{
					throw XPathException.Create("XmlUndefinedAlias", prefix);
				}
				return text;
			}

			public override IXsltContextVariable ResolveVariable(string prefix, string name)
			{
				throw XPathException.Create("Xp_UndefinedXsltContext");
			}

			public override IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] ArgTypes)
			{
				throw XPathException.Create("Xp_UndefinedXsltContext");
			}

			public override bool PreserveWhitespace(XPathNavigator node)
			{
				return false;
			}

			public override int CompareDocument(string baseUri, string nextbaseUri)
			{
				return string.CompareOrdinal(baseUri, nextbaseUri);
			}
		}

		private Query query;

		private string expr;

		private bool needContext;

		internal Query QueryTree
		{
			get
			{
				if (needContext)
				{
					throw XPathException.Create("Xp_NoContext");
				}
				return query;
			}
		}

		public override string Expression => expr;

		public override XPathResultType ReturnType => query.StaticType;

		internal CompiledXpathExpr(Query query, string expression, bool needContext)
		{
			this.query = query;
			expr = expression;
			this.needContext = needContext;
		}

		public virtual void CheckErrors()
		{
		}

		public override void AddSort(object expr, IComparer comparer)
		{
			Query evalQuery;
			if (expr is string)
			{
				evalQuery = new QueryBuilder().Build((string)expr, out needContext);
			}
			else
			{
				if (!(expr is CompiledXpathExpr))
				{
					throw XPathException.Create("Xp_BadQueryObject");
				}
				evalQuery = ((CompiledXpathExpr)expr).QueryTree;
			}
			SortQuery sortQuery = query as SortQuery;
			if (sortQuery == null)
			{
				sortQuery = (SortQuery)(query = new SortQuery(query));
			}
			sortQuery.AddSort(evalQuery, comparer);
		}

		public override void AddSort(object expr, XmlSortOrder order, XmlCaseOrder caseOrder, string lang, XmlDataType dataType)
		{
			AddSort(expr, new XPathComparerHelper(order, caseOrder, lang, dataType));
		}

		public override XPathExpression Clone()
		{
			return new CompiledXpathExpr(Query.Clone(query), expr, needContext);
		}

		public override void SetContext(XmlNamespaceManager nsManager)
		{
			XsltContext xsltContext = nsManager as XsltContext;
			if (xsltContext == null)
			{
				if (nsManager == null)
				{
					nsManager = new XmlNamespaceManager(new System.Xml.NameTable());
				}
				xsltContext = new UndefinedXsltContext(nsManager);
			}
			query.SetXsltContext(xsltContext);
			needContext = false;
		}

		public override void SetContext(IXmlNamespaceResolver nsResolver)
		{
			XmlNamespaceManager xmlNamespaceManager = nsResolver as XmlNamespaceManager;
			if (xmlNamespaceManager == null && nsResolver != null)
			{
				xmlNamespaceManager = new XmlNamespaceManager(new System.Xml.NameTable());
			}
			SetContext(xmlNamespaceManager);
		}
	}
}
namespace System.Xml.Xsl
{
	public abstract class XsltContext : XmlNamespaceManager
	{
		public abstract bool Whitespace { get; }

		protected XsltContext(NameTable table)
			: base(table)
		{
		}

		protected XsltContext()
			: base(new NameTable())
		{
		}

		internal XsltContext(bool dummy)
		{
		}

		public abstract IXsltContextVariable ResolveVariable(string prefix, string name);

		public abstract IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] ArgTypes);

		public abstract bool PreserveWhitespace(XPathNavigator node);

		public abstract int CompareDocument(string baseUri, string nextbaseUri);
	}
}
namespace MS.Internal.Xml.XPath
{
	internal sealed class XPathComparerHelper : IComparer
	{
		private XmlSortOrder order;

		private XmlCaseOrder caseOrder;

		private CultureInfo cinfo;

		private XmlDataType dataType;

		public XPathComparerHelper(XmlSortOrder order, XmlCaseOrder caseOrder, string lang, XmlDataType dataType)
		{
			if (lang == null)
			{
				cinfo = Thread.CurrentThread.CurrentCulture;
			}
			else
			{
				try
				{
					cinfo = new CultureInfo(lang);
				}
				catch (ArgumentException)
				{
					throw;
				}
			}
			if (order == XmlSortOrder.Descending)
			{
				switch (caseOrder)
				{
				case XmlCaseOrder.LowerFirst:
					caseOrder = XmlCaseOrder.UpperFirst;
					break;
				case XmlCaseOrder.UpperFirst:
					caseOrder = XmlCaseOrder.LowerFirst;
					break;
				}
			}
			this.order = order;
			this.caseOrder = caseOrder;
			this.dataType = dataType;
		}

		public int Compare(object x, object y)
		{
			int num = ((order == XmlSortOrder.Ascending) ? 1 : (-1));
			switch (dataType)
			{
			case XmlDataType.Text:
			{
				string strA = Convert.ToString(x, cinfo);
				string strB = Convert.ToString(y, cinfo);
				int num4 = string.Compare(strA, strB, (caseOrder != 0) ? true : false, cinfo);
				if (num4 != 0 || caseOrder == XmlCaseOrder.None)
				{
					return num * num4;
				}
				int num5 = ((caseOrder == XmlCaseOrder.LowerFirst) ? 1 : (-1));
				num4 = string.Compare(strA, strB, ignoreCase: false, cinfo);
				return num5 * num4;
			}
			case XmlDataType.Number:
			{
				double num2 = XmlConvert.ToXPathDouble(x);
				double num3 = XmlConvert.ToXPathDouble(y);
				if (num2 > num3)
				{
					return num;
				}
				if (num2 < num3)
				{
					return -1 * num;
				}
				if (num2 == num3)
				{
					return 0;
				}
				if (double.IsNaN(num2))
				{
					if (double.IsNaN(num3))
					{
						return 0;
					}
					return -1 * num;
				}
				return num;
			}
			default:
				throw new InvalidOperationException(System.Xml.Res.GetString("Xml_InvalidOperation"));
			}
		}
	}
	internal abstract class DescendantBaseQuery : BaseAxisQuery
	{
		protected bool matchSelf;

		protected bool abbrAxis;

		public DescendantBaseQuery(Query qyParent, string Name, string Prefix, XPathNodeType Type, bool matchSelf, bool abbrAxis)
			: base(qyParent, Name, Prefix, Type)
		{
			this.matchSelf = matchSelf;
			this.abbrAxis = abbrAxis;
		}

		public DescendantBaseQuery(DescendantBaseQuery other)
			: base(other)
		{
			matchSelf = other.matchSelf;
			abbrAxis = other.abbrAxis;
		}

		public override XPathNavigator MatchNode(XPathNavigator context)
		{
			if (context != null)
			{
				if (!abbrAxis)
				{
					throw XPathException.Create("Xp_InvalidPattern");
				}
				XPathNavigator xPathNavigator = null;
				if (matches(context))
				{
					if (matchSelf && (xPathNavigator = qyInput.MatchNode(context)) != null)
					{
						return xPathNavigator;
					}
					XPathNavigator xPathNavigator2 = context.Clone();
					while (xPathNavigator2.MoveToParent())
					{
						if ((xPathNavigator = qyInput.MatchNode(xPathNavigator2)) != null)
						{
							return xPathNavigator;
						}
					}
				}
			}
			return null;
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			if (matchSelf)
			{
				w.WriteAttributeString("self", "yes");
			}
			if (base.NameTest)
			{
				w.WriteAttributeString("name", (base.Prefix.Length != 0) ? (base.Prefix + ':' + base.Name) : base.Name);
			}
			if (base.TypeTest != XPathNodeType.Element)
			{
				w.WriteAttributeString("nodeType", base.TypeTest.ToString());
			}
			qyInput.PrintQuery(w);
			w.WriteEndElement();
		}
	}
	internal class DescendantQuery : DescendantBaseQuery
	{
		private XPathNodeIterator nodeIterator;

		internal DescendantQuery(Query qyParent, string Name, string Prefix, XPathNodeType Type, bool matchSelf, bool abbrAxis)
			: base(qyParent, Name, Prefix, Type, matchSelf, abbrAxis)
		{
		}

		public DescendantQuery(DescendantQuery other)
			: base(other)
		{
			nodeIterator = Query.Clone(other.nodeIterator);
		}

		public override void Reset()
		{
			nodeIterator = null;
			base.Reset();
		}

		public override XPathNavigator Advance()
		{
			while (true)
			{
				if (nodeIterator == null)
				{
					position = 0;
					XPathNavigator xPathNavigator = qyInput.Advance();
					if (xPathNavigator == null)
					{
						return null;
					}
					if (base.NameTest)
					{
						if (base.TypeTest == XPathNodeType.ProcessingInstruction)
						{
							nodeIterator = new IteratorFilter(xPathNavigator.SelectDescendants(base.TypeTest, matchSelf), base.Name);
						}
						else
						{
							nodeIterator = xPathNavigator.SelectDescendants(base.Name, base.Namespace, matchSelf);
						}
					}
					else
					{
						nodeIterator = xPathNavigator.SelectDescendants(base.TypeTest, matchSelf);
					}
				}
				if (nodeIterator.MoveNext())
				{
					break;
				}
				nodeIterator = null;
			}
			position++;
			currentNode = nodeIterator.Current;
			return currentNode;
		}

		public override XPathNodeIterator Clone()
		{
			return new DescendantQuery(this);
		}
	}
	internal sealed class DescendantOverDescendantQuery : DescendantBaseQuery
	{
		private int level;

		public DescendantOverDescendantQuery(Query qyParent, bool matchSelf, string name, string prefix, XPathNodeType typeTest, bool abbrAxis)
			: base(qyParent, name, prefix, typeTest, matchSelf, abbrAxis)
		{
		}

		private DescendantOverDescendantQuery(DescendantOverDescendantQuery other)
			: base(other)
		{
			level = other.level;
		}

		public override void Reset()
		{
			level = 0;
			base.Reset();
		}

		public override XPathNavigator Advance()
		{
			while (true)
			{
				if (level == 0)
				{
					currentNode = qyInput.Advance();
					position = 0;
					if (currentNode == null)
					{
						return null;
					}
					if (matchSelf && matches(currentNode))
					{
						break;
					}
					currentNode = currentNode.Clone();
					if (!MoveToFirstChild())
					{
						continue;
					}
				}
				else if (!MoveUpUntillNext())
				{
					continue;
				}
				do
				{
					if (matches(currentNode))
					{
						position++;
						return currentNode;
					}
				}
				while (MoveToFirstChild());
			}
			position = 1;
			return currentNode;
		}

		private bool MoveToFirstChild()
		{
			if (currentNode.MoveToFirstChild())
			{
				level++;
				return true;
			}
			return false;
		}

		private bool MoveUpUntillNext()
		{
			while (!currentNode.MoveToNext())
			{
				level--;
				if (level == 0)
				{
					return false;
				}
				currentNode.MoveToParent();
			}
			return true;
		}

		public override XPathNodeIterator Clone()
		{
			return new DescendantOverDescendantQuery(this);
		}
	}
	internal sealed class DocumentOrderQuery : CacheOutputQuery
	{
		public DocumentOrderQuery(Query qyParent)
			: base(qyParent)
		{
		}

		private DocumentOrderQuery(DocumentOrderQuery other)
			: base(other)
		{
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			base.Evaluate(context);
			XPathNavigator nav;
			while ((nav = input.Advance()) != null)
			{
				Insert(outputBuffer, nav);
			}
			return this;
		}

		public override XPathNavigator MatchNode(XPathNavigator context)
		{
			return input.MatchNode(context);
		}

		public override XPathNodeIterator Clone()
		{
			return new DocumentOrderQuery(this);
		}
	}
	internal sealed class EmptyQuery : Query
	{
		public override int CurrentPosition => 0;

		public override int Count => 0;

		public override QueryProps Properties => (QueryProps)23;

		public override XPathResultType StaticType => XPathResultType.NodeSet;

		public override XPathNavigator Current => null;

		public override XPathNavigator Advance()
		{
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return this;
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			return this;
		}

		public override void Reset()
		{
		}
	}
	internal abstract class ExtensionQuery : Query
	{
		protected string prefix;

		protected string name;

		protected XsltContext xsltContext;

		private ResetableIterator queryIterator;

		public override XPathNavigator Current
		{
			get
			{
				if (queryIterator == null)
				{
					throw XPathException.Create("Xp_NodeSetExpected");
				}
				if (queryIterator.CurrentPosition == 0)
				{
					Advance();
				}
				return queryIterator.Current;
			}
		}

		public override int CurrentPosition
		{
			get
			{
				if (queryIterator != null)
				{
					return queryIterator.CurrentPosition;
				}
				return 0;
			}
		}

		protected string QName
		{
			get
			{
				if (prefix.Length == 0)
				{
					return name;
				}
				return prefix + ":" + name;
			}
		}

		public override int Count
		{
			get
			{
				if (queryIterator != null)
				{
					return queryIterator.Count;
				}
				return 1;
			}
		}

		public override XPathResultType StaticType => XPathResultType.Any;

		public ExtensionQuery(string prefix, string name)
		{
			this.prefix = prefix;
			this.name = name;
		}

		protected ExtensionQuery(ExtensionQuery other)
			: base(other)
		{
			prefix = other.prefix;
			name = other.name;
			xsltContext = other.xsltContext;
			queryIterator = (ResetableIterator)Query.Clone(other.queryIterator);
		}

		public override void Reset()
		{
			if (queryIterator != null)
			{
				queryIterator.Reset();
			}
		}

		public override XPathNavigator Advance()
		{
			if (queryIterator == null)
			{
				throw XPathException.Create("Xp_NodeSetExpected");
			}
			if (queryIterator.MoveNext())
			{
				return queryIterator.Current;
			}
			return null;
		}

		protected object ProcessResult(object value)
		{
			if (value is string)
			{
				return value;
			}
			if (value is double)
			{
				return value;
			}
			if (value is bool)
			{
				return value;
			}
			if (value is XPathNavigator)
			{
				return value;
			}
			if (value is int)
			{
				return (double)(int)value;
			}
			if (value == null)
			{
				queryIterator = XPathEmptyIterator.Instance;
				return this;
			}
			if (value is ResetableIterator resetableIterator)
			{
				queryIterator = (ResetableIterator)resetableIterator.Clone();
				return this;
			}
			if (value is XPathNodeIterator nodeIterator)
			{
				queryIterator = new XPathArrayIterator(nodeIterator);
				return this;
			}
			if (value is IXPathNavigable iXPathNavigable)
			{
				return iXPathNavigable.CreateNavigator();
			}
			if (value is short)
			{
				return (double)(short)value;
			}
			if (value is long)
			{
				return (double)(long)value;
			}
			if (value is uint)
			{
				return (double)(uint)value;
			}
			if (value is ushort)
			{
				return (double)(int)(ushort)value;
			}
			if (value is ulong)
			{
				return (double)(ulong)value;
			}
			if (value is float)
			{
				return (double)(float)value;
			}
			if (value is decimal)
			{
				return (double)(decimal)value;
			}
			return value.ToString();
		}
	}
	internal sealed class FunctionQuery : ExtensionQuery
	{
		private IList<Query> args;

		private IXsltContextFunction function;

		public override XPathResultType StaticType
		{
			get
			{
				XPathResultType xPathResultType = ((function != null) ? function.ReturnType : XPathResultType.Any);
				if (xPathResultType == XPathResultType.Error)
				{
					xPathResultType = XPathResultType.Any;
				}
				return xPathResultType;
			}
		}

		public FunctionQuery(string prefix, string name, List<Query> args)
			: base(prefix, name)
		{
			this.args = args;
		}

		private FunctionQuery(FunctionQuery other)
			: base(other)
		{
			function = other.function;
			Query[] array = new Query[other.args.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Query.Clone(other.args[i]);
			}
			args = array;
			args = array;
		}

		public override void SetXsltContext(XsltContext context)
		{
			if (context == null)
			{
				throw XPathException.Create("Xp_NoContext");
			}
			if (xsltContext == context)
			{
				return;
			}
			xsltContext = context;
			foreach (Query arg in args)
			{
				arg.SetXsltContext(context);
			}
			XPathResultType[] array = new XPathResultType[args.Count];
			for (int i = 0; i < args.Count; i++)
			{
				array[i] = args[i].StaticType;
			}
			function = xsltContext.ResolveFunction(prefix, name, array);
			if (function == null)
			{
				throw XPathException.Create("Xp_UndefFunc", base.QName);
			}
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			if (xsltContext == null)
			{
				throw XPathException.Create("Xp_NoContext");
			}
			object[] array = new object[args.Count];
			for (int i = 0; i < args.Count; i++)
			{
				array[i] = args[i].Evaluate(nodeIterator);
				if (array[i] is XPathNodeIterator)
				{
					array[i] = new XPathSelectionIterator(nodeIterator.Current, args[i]);
				}
			}
			try
			{
				return ProcessResult(function.Invoke(xsltContext, array, nodeIterator.Current));
			}
			catch (Exception innerException)
			{
				throw XPathException.Create("Xp_FunctionFailed", base.QName, innerException);
			}
		}

		public override XPathNavigator MatchNode(XPathNavigator navigator)
		{
			if (name != "key" && prefix.Length != 0)
			{
				throw XPathException.Create("Xp_InvalidPattern");
			}
			Evaluate(new XPathSingletonIterator(navigator, moved: true));
			XPathNavigator xPathNavigator = null;
			while ((xPathNavigator = Advance()) != null)
			{
				if (xPathNavigator.IsSamePosition(navigator))
				{
					return xPathNavigator;
				}
			}
			return xPathNavigator;
		}

		public override XPathNodeIterator Clone()
		{
			return new FunctionQuery(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			w.WriteAttributeString("name", (prefix.Length != 0) ? (prefix + ':' + name) : name);
			foreach (Query arg in args)
			{
				arg.PrintQuery(w);
			}
			w.WriteEndElement();
		}
	}
	internal class Filter : AstNode
	{
		private AstNode input;

		private AstNode condition;

		public override AstType Type => AstType.Filter;

		public override XPathResultType ReturnType => XPathResultType.NodeSet;

		public AstNode Input => input;

		public AstNode Condition => condition;

		public Filter(AstNode input, AstNode condition)
		{
			this.input = input;
			this.condition = condition;
		}
	}
	internal sealed class FilterQuery : BaseAxisQuery
	{
		private Query cond;

		private bool noPosition;

		public Query Condition => cond;

		public override QueryProps Properties => QueryProps.Position | (qyInput.Properties & (QueryProps)24);

		public FilterQuery(Query qyParent, Query cond, bool noPosition)
			: base(qyParent)
		{
			this.cond = cond;
			this.noPosition = noPosition;
		}

		private FilterQuery(FilterQuery other)
			: base(other)
		{
			cond = Query.Clone(other.cond);
			noPosition = other.noPosition;
		}

		public override void Reset()
		{
			cond.Reset();
			base.Reset();
		}

		public override void SetXsltContext(XsltContext input)
		{
			base.SetXsltContext(input);
			cond.SetXsltContext(input);
			if (cond.StaticType != 0 && cond.StaticType != XPathResultType.Any && noPosition && qyInput is ReversePositionQuery reversePositionQuery)
			{
				qyInput = reversePositionQuery.input;
			}
		}

		public override XPathNavigator Advance()
		{
			while ((currentNode = qyInput.Advance()) != null)
			{
				if (EvaluatePredicate())
				{
					position++;
					return currentNode;
				}
			}
			return null;
		}

		internal bool EvaluatePredicate()
		{
			object obj = cond.Evaluate(qyInput);
			if (obj is XPathNodeIterator)
			{
				return cond.Advance() != null;
			}
			if (obj is string)
			{
				return ((string)obj).Length != 0;
			}
			if (obj is double)
			{
				return (double)obj == (double)qyInput.CurrentPosition;
			}
			if (obj is bool)
			{
				return (bool)obj;
			}
			return true;
		}

		public override XPathNavigator MatchNode(XPathNavigator current)
		{
			if (current == null)
			{
				return null;
			}
			XPathNavigator xPathNavigator = qyInput.MatchNode(current);
			if (xPathNavigator != null)
			{
				switch (cond.StaticType)
				{
				case XPathResultType.Number:
				{
					if (!(cond is OperandQuery operandQuery))
					{
						break;
					}
					double num = (double)operandQuery.val;
					if (qyInput is ChildrenQuery childrenQuery)
					{
						XPathNavigator xPathNavigator2 = current.Clone();
						xPathNavigator2.MoveToParent();
						int num2 = 0;
						xPathNavigator2.MoveToFirstChild();
						do
						{
							if (!childrenQuery.matches(xPathNavigator2))
							{
								continue;
							}
							num2++;
							if (current.IsSamePosition(xPathNavigator2))
							{
								if (num != (double)num2)
								{
									return null;
								}
								return xPathNavigator;
							}
						}
						while (xPathNavigator2.MoveToNext());
						return null;
					}
					if (!(qyInput is AttributeQuery attributeQuery))
					{
						break;
					}
					XPathNavigator xPathNavigator3 = current.Clone();
					xPathNavigator3.MoveToParent();
					int num3 = 0;
					xPathNavigator3.MoveToFirstAttribute();
					do
					{
						if (!attributeQuery.matches(xPathNavigator3))
						{
							continue;
						}
						num3++;
						if (current.IsSamePosition(xPathNavigator3))
						{
							if (num != (double)num3)
							{
								return null;
							}
							return xPathNavigator;
						}
					}
					while (xPathNavigator3.MoveToNextAttribute());
					return null;
				}
				case XPathResultType.NodeSet:
					cond.Evaluate(new XPathSingletonIterator(current, moved: true));
					if (cond.Advance() == null)
					{
						return null;
					}
					return xPathNavigator;
				case XPathResultType.Boolean:
					if (noPosition)
					{
						if (!(bool)cond.Evaluate(new XPathSingletonIterator(current, moved: true)))
						{
							return null;
						}
						return xPathNavigator;
					}
					break;
				case XPathResultType.String:
					if (noPosition)
					{
						if (((string)cond.Evaluate(new XPathSingletonIterator(current, moved: true))).Length == 0)
						{
							return null;
						}
						return xPathNavigator;
					}
					break;
				case (XPathResultType)4:
					return xPathNavigator;
				default:
					return null;
				}
				Evaluate(new XPathSingletonIterator(xPathNavigator, moved: true));
				XPathNavigator xPathNavigator4;
				while ((xPathNavigator4 = Advance()) != null)
				{
					if (xPathNavigator4.IsSamePosition(current))
					{
						return xPathNavigator;
					}
				}
			}
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return new FilterQuery(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			if (!noPosition)
			{
				w.WriteAttributeString("position", "yes");
			}
			qyInput.PrintQuery(w);
			cond.PrintQuery(w);
			w.WriteEndElement();
		}
	}
	internal sealed class FollowingQuery : BaseAxisQuery
	{
		private XPathNavigator input;

		private XPathNodeIterator iterator;

		public FollowingQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest)
			: base(qyInput, name, prefix, typeTest)
		{
		}

		private FollowingQuery(FollowingQuery other)
			: base(other)
		{
			input = Query.Clone(other.input);
			iterator = Query.Clone(other.iterator);
		}

		public override void Reset()
		{
			iterator = null;
			base.Reset();
		}

		public override XPathNavigator Advance()
		{
			if (iterator == null)
			{
				input = qyInput.Advance();
				if (input == null)
				{
					return null;
				}
				XPathNavigator xPathNavigator;
				do
				{
					xPathNavigator = input.Clone();
					input = qyInput.Advance();
				}
				while (xPathNavigator.IsDescendant(input));
				input = xPathNavigator;
				iterator = XPathEmptyIterator.Instance;
			}
			while (!iterator.MoveNext())
			{
				bool matchSelf;
				if (input.NodeType == XPathNodeType.Attribute || input.NodeType == XPathNodeType.Namespace)
				{
					input.MoveToParent();
					matchSelf = false;
				}
				else
				{
					while (!input.MoveToNext())
					{
						if (!input.MoveToParent())
						{
							return null;
						}
					}
					matchSelf = true;
				}
				if (base.NameTest)
				{
					iterator = input.SelectDescendants(base.Name, base.Namespace, matchSelf);
				}
				else
				{
					iterator = input.SelectDescendants(base.TypeTest, matchSelf);
				}
			}
			position++;
			currentNode = iterator.Current;
			return currentNode;
		}

		public override XPathNodeIterator Clone()
		{
			return new FollowingQuery(this);
		}
	}
	internal sealed class FollSiblingQuery : BaseAxisQuery
	{
		private ClonableStack<XPathNavigator> elementStk;

		private List<XPathNavigator> parentStk;

		private XPathNavigator nextInput;

		public FollSiblingQuery(Query qyInput, string name, string prefix, XPathNodeType type)
			: base(qyInput, name, prefix, type)
		{
			elementStk = new ClonableStack<XPathNavigator>();
			parentStk = new List<XPathNavigator>();
		}

		private FollSiblingQuery(FollSiblingQuery other)
			: base(other)
		{
			elementStk = other.elementStk.Clone();
			parentStk = new List<XPathNavigator>(other.parentStk);
			nextInput = Query.Clone(other.nextInput);
		}

		public override void Reset()
		{
			elementStk.Clear();
			parentStk.Clear();
			nextInput = null;
			base.Reset();
		}

		private bool Visited(XPathNavigator nav)
		{
			XPathNavigator xPathNavigator = nav.Clone();
			xPathNavigator.MoveToParent();
			for (int i = 0; i < parentStk.Count; i++)
			{
				if (xPathNavigator.IsSamePosition(parentStk[i]))
				{
					return true;
				}
			}
			parentStk.Add(xPathNavigator);
			return false;
		}

		private XPathNavigator FetchInput()
		{
			XPathNavigator xPathNavigator;
			do
			{
				xPathNavigator = qyInput.Advance();
				if (xPathNavigator == null)
				{
					return null;
				}
			}
			while (Visited(xPathNavigator));
			return xPathNavigator.Clone();
		}

		public override XPathNavigator Advance()
		{
			while (true)
			{
				if (currentNode == null)
				{
					if (nextInput == null)
					{
						nextInput = FetchInput();
					}
					if (elementStk.Count == 0)
					{
						if (nextInput == null)
						{
							break;
						}
						currentNode = nextInput;
						nextInput = FetchInput();
					}
					else
					{
						currentNode = elementStk.Pop();
					}
				}
				while (currentNode.IsDescendant(nextInput))
				{
					elementStk.Push(currentNode);
					currentNode = nextInput;
					nextInput = qyInput.Advance();
					if (nextInput != null)
					{
						nextInput = nextInput.Clone();
					}
				}
				while (currentNode.MoveToNext())
				{
					if (matches(currentNode))
					{
						position++;
						return currentNode;
					}
				}
				currentNode = null;
			}
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return new FollSiblingQuery(this);
		}
	}
	internal class ForwardPositionQuery : CacheOutputQuery
	{
		public ForwardPositionQuery(Query input)
			: base(input)
		{
		}

		protected ForwardPositionQuery(ForwardPositionQuery other)
			: base(other)
		{
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			base.Evaluate(context);
			XPathNavigator xPathNavigator;
			while ((xPathNavigator = input.Advance()) != null)
			{
				outputBuffer.Add(xPathNavigator.Clone());
			}
			return this;
		}

		public override XPathNavigator MatchNode(XPathNavigator context)
		{
			return input.MatchNode(context);
		}

		public override XPathNodeIterator Clone()
		{
			return new ForwardPositionQuery(this);
		}
	}
	internal class Function : AstNode
	{
		public enum FunctionType
		{
			FuncLast,
			FuncPosition,
			FuncCount,
			FuncID,
			FuncLocalName,
			FuncNameSpaceUri,
			FuncName,
			FuncString,
			FuncBoolean,
			FuncNumber,
			FuncTrue,
			FuncFalse,
			FuncNot,
			FuncConcat,
			FuncStartsWith,
			FuncContains,
			FuncSubstringBefore,
			FuncSubstringAfter,
			FuncSubstring,
			FuncStringLength,
			FuncNormalize,
			FuncTranslate,
			FuncLang,
			FuncSum,
			FuncFloor,
			FuncCeiling,
			FuncRound,
			FuncUserDefined
		}

		private FunctionType functionType;

		private ArrayList argumentList;

		private string name;

		private string prefix;

		internal static XPathResultType[] ReturnTypes = new XPathResultType[28]
		{
			XPathResultType.Number,
			XPathResultType.Number,
			XPathResultType.Number,
			XPathResultType.NodeSet,
			XPathResultType.String,
			XPathResultType.String,
			XPathResultType.String,
			XPathResultType.String,
			XPathResultType.Boolean,
			XPathResultType.Number,
			XPathResultType.Boolean,
			XPathResultType.Boolean,
			XPathResultType.Boolean,
			XPathResultType.String,
			XPathResultType.Boolean,
			XPathResultType.Boolean,
			XPathResultType.String,
			XPathResultType.String,
			XPathResultType.String,
			XPathResultType.Number,
			XPathResultType.String,
			XPathResultType.String,
			XPathResultType.Boolean,
			XPathResultType.Number,
			XPathResultType.Number,
			XPathResultType.Number,
			XPathResultType.Number,
			XPathResultType.Any
		};

		public override AstType Type => AstType.Function;

		public override XPathResultType ReturnType => ReturnTypes[(int)functionType];

		public FunctionType TypeOfFunction => functionType;

		public ArrayList ArgumentList => argumentList;

		public string Prefix => prefix;

		public string Name => name;

		public Function(FunctionType ftype, ArrayList argumentList)
		{
			functionType = ftype;
			this.argumentList = new ArrayList(argumentList);
		}

		public Function(string prefix, string name, ArrayList argumentList)
		{
			functionType = FunctionType.FuncUserDefined;
			this.prefix = prefix;
			this.name = name;
			this.argumentList = new ArrayList(argumentList);
		}

		public Function(FunctionType ftype)
		{
			functionType = ftype;
		}

		public Function(FunctionType ftype, AstNode arg)
		{
			functionType = ftype;
			argumentList = new ArrayList();
			argumentList.Add(arg);
		}
	}
	internal class Group : AstNode
	{
		private AstNode groupNode;

		public override AstType Type => AstType.Group;

		public override XPathResultType ReturnType => XPathResultType.NodeSet;

		public AstNode GroupNode => groupNode;

		public Group(AstNode groupNode)
		{
			this.groupNode = groupNode;
		}
	}
	internal sealed class GroupQuery : BaseAxisQuery
	{
		public override XPathResultType StaticType => qyInput.StaticType;

		public override QueryProps Properties => QueryProps.Position;

		public GroupQuery(Query qy)
			: base(qy)
		{
		}

		private GroupQuery(GroupQuery other)
			: base(other)
		{
		}

		public override XPathNavigator Advance()
		{
			currentNode = qyInput.Advance();
			if (currentNode != null)
			{
				position++;
			}
			return currentNode;
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			return qyInput.Evaluate(nodeIterator);
		}

		public override XPathNodeIterator Clone()
		{
			return new GroupQuery(this);
		}
	}
	internal sealed class IDQuery : CacheOutputQuery
	{
		public IDQuery(Query arg)
			: base(arg)
		{
		}

		private IDQuery(IDQuery other)
			: base(other)
		{
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			object obj = base.Evaluate(context);
			XPathNavigator contextNode = context.Current.Clone();
			switch (GetXPathType(obj))
			{
			case XPathResultType.NodeSet:
			{
				XPathNavigator xPathNavigator;
				while ((xPathNavigator = input.Advance()) != null)
				{
					ProcessIds(contextNode, xPathNavigator.Value);
				}
				break;
			}
			case XPathResultType.String:
				ProcessIds(contextNode, (string)obj);
				break;
			case XPathResultType.Number:
				ProcessIds(contextNode, StringFunctions.toString((double)obj));
				break;
			case XPathResultType.Boolean:
				ProcessIds(contextNode, StringFunctions.toString((bool)obj));
				break;
			case (XPathResultType)4:
				ProcessIds(contextNode, ((XPathNavigator)obj).Value);
				break;
			}
			return this;
		}

		private void ProcessIds(XPathNavigator contextNode, string val)
		{
			string[] array = XmlConvert.SplitString(val);
			for (int i = 0; i < array.Length; i++)
			{
				if (contextNode.MoveToId(array[i]))
				{
					Insert(outputBuffer, contextNode);
				}
			}
		}

		public override XPathNavigator MatchNode(XPathNavigator context)
		{
			Evaluate(new XPathSingletonIterator(context, moved: true));
			XPathNavigator xPathNavigator;
			while ((xPathNavigator = Advance()) != null)
			{
				if (xPathNavigator.IsSamePosition(context))
				{
					return context;
				}
			}
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return new IDQuery(this);
		}
	}
	internal class IteratorFilter : XPathNodeIterator
	{
		private XPathNodeIterator innerIterator;

		private string name;

		private int position;

		public override XPathNavigator Current => innerIterator.Current;

		public override int CurrentPosition => position;

		internal IteratorFilter(XPathNodeIterator innerIterator, string name)
		{
			this.innerIterator = innerIterator;
			this.name = name;
		}

		private IteratorFilter(IteratorFilter it)
		{
			innerIterator = it.innerIterator.Clone();
			name = it.name;
			position = it.position;
		}

		public override XPathNodeIterator Clone()
		{
			return new IteratorFilter(this);
		}

		public override bool MoveNext()
		{
			while (innerIterator.MoveNext())
			{
				if (innerIterator.Current.LocalName == name)
				{
					position++;
					return true;
				}
			}
			return false;
		}
	}
	internal enum QueryProps
	{
		None = 0,
		Position = 1,
		Count = 2,
		Cached = 4,
		Reverse = 8,
		Merge = 0x10
	}
	internal sealed class LogicalExpr : ValueQuery
	{
		private delegate bool cmpXslt(Operator.Op op, object val1, object val2);

		private struct NodeSet
		{
			private Query opnd;

			private XPathNavigator current;

			public string Value => current.Value;

			public NodeSet(object opnd)
			{
				this.opnd = (Query)opnd;
				current = null;
			}

			public bool MoveNext()
			{
				current = opnd.Advance();
				return current != null;
			}

			public void Reset()
			{
				opnd.Reset();
			}
		}

		private Operator.Op op;

		private Query opnd1;

		private Query opnd2;

		private Operator.Op[] invertOp = new Operator.Op[6]
		{
			Operator.Op.GT,
			Operator.Op.LT,
			Operator.Op.GE,
			Operator.Op.LE,
			Operator.Op.EQ,
			Operator.Op.NE
		};

		private static readonly cmpXslt[][] CompXsltE = new cmpXslt[5][]
		{
			new cmpXslt[5] { cmpNumberNumber, null, null, null, null },
			new cmpXslt[5] { cmpStringNumber, cmpStringStringE, null, null, null },
			new cmpXslt[5] { cmpBoolNumberE, cmpBoolStringE, cmpBoolBoolE, null, null },
			new cmpXslt[5] { cmpQueryNumber, cmpQueryStringE, cmpQueryBoolE, cmpQueryQueryE, null },
			new cmpXslt[5] { cmpRtfNumber, cmpRtfStringE, cmpRtfBoolE, cmpRtfQueryE, cmpRtfRtfE }
		};

		private static readonly cmpXslt[][] CompXsltO = new cmpXslt[5][]
		{
			new cmpXslt[5] { cmpNumberNumber, null, null, null, null },
			new cmpXslt[5] { cmpStringNumber, cmpStringStringO, null, null, null },
			new cmpXslt[5] { cmpBoolNumberO, cmpBoolStringO, cmpBoolBoolO, null, null },
			new cmpXslt[5] { cmpQueryNumber, cmpQueryStringO, cmpQueryBoolO, cmpQueryQueryO, null },
			new cmpXslt[5] { cmpRtfNumber, cmpRtfStringO, cmpRtfBoolO, cmpRtfQueryO, cmpRtfRtfO }
		};

		public override XPathResultType StaticType => XPathResultType.Boolean;

		public LogicalExpr(Operator.Op op, Query opnd1, Query opnd2)
		{
			this.op = op;
			this.opnd1 = opnd1;
			this.opnd2 = opnd2;
		}

		private LogicalExpr(LogicalExpr other)
			: base(other)
		{
			op = other.op;
			opnd1 = Query.Clone(other.opnd1);
			opnd2 = Query.Clone(other.opnd2);
		}

		public override void SetXsltContext(XsltContext context)
		{
			opnd1.SetXsltContext(context);
			opnd2.SetXsltContext(context);
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			Operator.Op op = this.op;
			object obj = opnd1.Evaluate(nodeIterator);
			object obj2 = opnd2.Evaluate(nodeIterator);
			int num = (int)GetXPathType(obj);
			int num2 = (int)GetXPathType(obj2);
			if (num < num2)
			{
				op = invertOp[(int)op];
				object obj3 = obj;
				obj = obj2;
				obj2 = obj3;
				int num3 = num;
				num = num2;
				num2 = num3;
			}
			if (op == Operator.Op.EQ || op == Operator.Op.NE)
			{
				return CompXsltE[num][num2](op, obj, obj2);
			}
			return CompXsltO[num][num2](op, obj, obj2);
		}

		private static bool cmpQueryQueryE(Operator.Op op, object val1, object val2)
		{
			bool flag = op == Operator.Op.EQ;
			NodeSet nodeSet = new NodeSet(val1);
			NodeSet nodeSet2 = new NodeSet(val2);
			while (true)
			{
				if (!nodeSet.MoveNext())
				{
					return false;
				}
				if (!nodeSet2.MoveNext())
				{
					break;
				}
				string value = nodeSet.Value;
				do
				{
					if (value == nodeSet2.Value == flag)
					{
						return true;
					}
				}
				while (nodeSet2.MoveNext());
				nodeSet2.Reset();
			}
			return false;
		}

		private static bool cmpQueryQueryO(Operator.Op op, object val1, object val2)
		{
			NodeSet nodeSet = new NodeSet(val1);
			NodeSet nodeSet2 = new NodeSet(val2);
			while (true)
			{
				if (!nodeSet.MoveNext())
				{
					return false;
				}
				if (!nodeSet2.MoveNext())
				{
					break;
				}
				double n = NumberFunctions.Number(nodeSet.Value);
				do
				{
					if (cmpNumberNumber(op, n, NumberFunctions.Number(nodeSet2.Value)))
					{
						return true;
					}
				}
				while (nodeSet2.MoveNext());
				nodeSet2.Reset();
			}
			return false;
		}

		private static bool cmpQueryNumber(Operator.Op op, object val1, object val2)
		{
			NodeSet nodeSet = new NodeSet(val1);
			double n = (double)val2;
			while (nodeSet.MoveNext())
			{
				if (cmpNumberNumber(op, NumberFunctions.Number(nodeSet.Value), n))
				{
					return true;
				}
			}
			return false;
		}

		private static bool cmpQueryStringE(Operator.Op op, object val1, object val2)
		{
			NodeSet nodeSet = new NodeSet(val1);
			string n = (string)val2;
			while (nodeSet.MoveNext())
			{
				if (cmpStringStringE(op, nodeSet.Value, n))
				{
					return true;
				}
			}
			return false;
		}

		private static bool cmpQueryStringO(Operator.Op op, object val1, object val2)
		{
			NodeSet nodeSet = new NodeSet(val1);
			double n = NumberFunctions.Number((string)val2);
			while (nodeSet.MoveNext())
			{
				if (cmpNumberNumberO(op, NumberFunctions.Number(nodeSet.Value), n))
				{
					return true;
				}
			}
			return false;
		}

		private static bool cmpRtfQueryE(Operator.Op op, object val1, object val2)
		{
			string n = Rtf(val1);
			NodeSet nodeSet = new NodeSet(val2);
			while (nodeSet.MoveNext())
			{
				if (cmpStringStringE(op, n, nodeSet.Value))
				{
					return true;
				}
			}
			return false;
		}

		private static bool cmpRtfQueryO(Operator.Op op, object val1, object val2)
		{
			double n = NumberFunctions.Number(Rtf(val1));
			NodeSet nodeSet = new NodeSet(val2);
			while (nodeSet.MoveNext())
			{
				if (cmpNumberNumberO(op, n, NumberFunctions.Number(nodeSet.Value)))
				{
					return true;
				}
			}
			return false;
		}

		private static bool cmpQueryBoolE(Operator.Op op, object val1, object val2)
		{
			bool n = new NodeSet(val1).MoveNext();
			bool n2 = (bool)val2;
			return cmpBoolBoolE(op, n, n2);
		}

		private static bool cmpQueryBoolO(Operator.Op op, object val1, object val2)
		{
			double n = (new NodeSet(val1).MoveNext() ? 1.0 : 0.0);
			double n2 = NumberFunctions.Number((bool)val2);
			return cmpNumberNumberO(op, n, n2);
		}

		private static bool cmpBoolBoolE(Operator.Op op, bool n1, bool n2)
		{
			return op == Operator.Op.EQ == (n1 == n2);
		}

		private static bool cmpBoolBoolE(Operator.Op op, object val1, object val2)
		{
			bool n = (bool)val1;
			bool n2 = (bool)val2;
			return cmpBoolBoolE(op, n, n2);
		}

		private static bool cmpBoolBoolO(Operator.Op op, object val1, object val2)
		{
			double n = NumberFunctions.Number((bool)val1);
			double n2 = NumberFunctions.Number((bool)val2);
			return cmpNumberNumberO(op, n, n2);
		}

		private static bool cmpBoolNumberE(Operator.Op op, object val1, object val2)
		{
			bool n = (bool)val1;
			bool n2 = BooleanFunctions.toBoolean((double)val2);
			return cmpBoolBoolE(op, n, n2);
		}

		private static bool cmpBoolNumberO(Operator.Op op, object val1, object val2)
		{
			double n = NumberFunctions.Number((bool)val1);
			double n2 = (double)val2;
			return cmpNumberNumberO(op, n, n2);
		}

		private static bool cmpBoolStringE(Operator.Op op, object val1, object val2)
		{
			bool n = (bool)val1;
			bool n2 = BooleanFunctions.toBoolean((string)val2);
			return cmpBoolBoolE(op, n, n2);
		}

		private static bool cmpRtfBoolE(Operator.Op op, object val1, object val2)
		{
			bool n = BooleanFunctions.toBoolean(Rtf(val1));
			bool n2 = (bool)val2;
			return cmpBoolBoolE(op, n, n2);
		}

		private static bool cmpBoolStringO(Operator.Op op, object val1, object val2)
		{
			return cmpNumberNumberO(op, NumberFunctions.Number((bool)val1), NumberFunctions.Number((string)val2));
		}

		private static bool cmpRtfBoolO(Operator.Op op, object val1, object val2)
		{
			return cmpNumberNumberO(op, NumberFunctions.Number(Rtf(val1)), NumberFunctions.Number((bool)val2));
		}

		private static bool cmpNumberNumber(Operator.Op op, double n1, double n2)
		{
			return op switch
			{
				Operator.Op.LT => n1 < n2, 
				Operator.Op.GT => n1 > n2, 
				Operator.Op.LE => n1 <= n2, 
				Operator.Op.GE => n1 >= n2, 
				Operator.Op.EQ => n1 == n2, 
				Operator.Op.NE => n1 != n2, 
				_ => false, 
			};
		}

		private static bool cmpNumberNumberO(Operator.Op op, double n1, double n2)
		{
			return op switch
			{
				Operator.Op.LT => n1 < n2, 
				Operator.Op.GT => n1 > n2, 
				Operator.Op.LE => n1 <= n2, 
				Operator.Op.GE => n1 >= n2, 
				_ => false, 
			};
		}

		private static bool cmpNumberNumber(Operator.Op op, object val1, object val2)
		{
			double n = (double)val1;
			double n2 = (double)val2;
			return cmpNumberNumber(op, n, n2);
		}

		private static bool cmpStringNumber(Operator.Op op, object val1, object val2)
		{
			double n = (double)val2;
			double n2 = NumberFunctions.Number((string)val1);
			return cmpNumberNumber(op, n2, n);
		}

		private static bool cmpRtfNumber(Operator.Op op, object val1, object val2)
		{
			double n = (double)val2;
			double n2 = NumberFunctions.Number(Rtf(val1));
			return cmpNumberNumber(op, n2, n);
		}

		private static bool cmpStringStringE(Operator.Op op, string n1, string n2)
		{
			return op == Operator.Op.EQ == (n1 == n2);
		}

		private static bool cmpStringStringE(Operator.Op op, object val1, object val2)
		{
			string n = (string)val1;
			string n2 = (string)val2;
			return cmpStringStringE(op, n, n2);
		}

		private static bool cmpRtfStringE(Operator.Op op, object val1, object val2)
		{
			string n = Rtf(val1);
			string n2 = (string)val2;
			return cmpStringStringE(op, n, n2);
		}

		private static bool cmpRtfRtfE(Operator.Op op, object val1, object val2)
		{
			string n = Rtf(val1);
			string n2 = Rtf(val2);
			return cmpStringStringE(op, n, n2);
		}

		private static bool cmpStringStringO(Operator.Op op, object val1, object val2)
		{
			double n = NumberFunctions.Number((string)val1);
			double n2 = NumberFunctions.Number((string)val2);
			return cmpNumberNumberO(op, n, n2);
		}

		private static bool cmpRtfStringO(Operator.Op op, object val1, object val2)
		{
			double n = NumberFunctions.Number(Rtf(val1));
			double n2 = NumberFunctions.Number((string)val2);
			return cmpNumberNumberO(op, n, n2);
		}

		private static bool cmpRtfRtfO(Operator.Op op, object val1, object val2)
		{
			double n = NumberFunctions.Number(Rtf(val1));
			double n2 = NumberFunctions.Number(Rtf(val2));
			return cmpNumberNumberO(op, n, n2);
		}

		public override XPathNodeIterator Clone()
		{
			return new LogicalExpr(this);
		}

		private static string Rtf(object o)
		{
			return ((XPathNavigator)o).Value;
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			w.WriteAttributeString("op", op.ToString());
			opnd1.PrintQuery(w);
			opnd2.PrintQuery(w);
			w.WriteEndElement();
		}
	}
	internal sealed class MergeFilterQuery : CacheOutputQuery
	{
		private Query child;

		public MergeFilterQuery(Query input, Query child)
			: base(input)
		{
			this.child = child;
		}

		private MergeFilterQuery(MergeFilterQuery other)
			: base(other)
		{
			child = Query.Clone(other.child);
		}

		public override void SetXsltContext(XsltContext xsltContext)
		{
			base.SetXsltContext(xsltContext);
			child.SetXsltContext(xsltContext);
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			base.Evaluate(nodeIterator);
			while (input.Advance() != null)
			{
				child.Evaluate(input);
				XPathNavigator nav;
				while ((nav = child.Advance()) != null)
				{
					Insert(outputBuffer, nav);
				}
			}
			return this;
		}

		public override XPathNavigator MatchNode(XPathNavigator current)
		{
			XPathNavigator xPathNavigator = child.MatchNode(current);
			if (xPathNavigator == null)
			{
				return null;
			}
			xPathNavigator = input.MatchNode(xPathNavigator);
			if (xPathNavigator == null)
			{
				return null;
			}
			Evaluate(new XPathSingletonIterator(xPathNavigator.Clone(), moved: true));
			for (XPathNavigator xPathNavigator2 = Advance(); xPathNavigator2 != null; xPathNavigator2 = Advance())
			{
				if (xPathNavigator2.IsSamePosition(current))
				{
					return xPathNavigator;
				}
			}
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return new MergeFilterQuery(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			input.PrintQuery(w);
			child.PrintQuery(w);
			w.WriteEndElement();
		}
	}
	internal sealed class NamespaceQuery : BaseAxisQuery
	{
		private bool onNamespace;

		public NamespaceQuery(Query qyParent, string Name, string Prefix, XPathNodeType Type)
			: base(qyParent, Name, Prefix, Type)
		{
		}

		private NamespaceQuery(NamespaceQuery other)
			: base(other)
		{
			onNamespace = other.onNamespace;
		}

		public override void Reset()
		{
			onNamespace = false;
			base.Reset();
		}

		public override XPathNavigator Advance()
		{
			do
			{
				if (!onNamespace)
				{
					currentNode = qyInput.Advance();
					if (currentNode == null)
					{
						return null;
					}
					position = 0;
					currentNode = currentNode.Clone();
					onNamespace = currentNode.MoveToFirstNamespace();
				}
				else
				{
					onNamespace = currentNode.MoveToNextNamespace();
				}
			}
			while (!onNamespace || !matches(currentNode));
			position++;
			return currentNode;
		}

		public override bool matches(XPathNavigator e)
		{
			if (e.Value.Length == 0)
			{
				return false;
			}
			if (base.NameTest)
			{
				return base.Name.Equals(e.LocalName);
			}
			return true;
		}

		public override XPathNodeIterator Clone()
		{
			return new NamespaceQuery(this);
		}
	}
	internal sealed class NodeFunctions : ValueQuery
	{
		private Query arg;

		private Function.FunctionType funcType;

		private XsltContext xsltContext;

		public override XPathResultType StaticType => Function.ReturnTypes[(int)funcType];

		public NodeFunctions(Function.FunctionType funcType, Query arg)
		{
			this.funcType = funcType;
			this.arg = arg;
		}

		public override void SetXsltContext(XsltContext context)
		{
			xsltContext = (context.Whitespace ? context : null);
			if (arg != null)
			{
				arg.SetXsltContext(context);
			}
		}

		private XPathNavigator EvaluateArg(XPathNodeIterator context)
		{
			if (arg == null)
			{
				return context.Current;
			}
			arg.Evaluate(context);
			return arg.Advance();
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			switch (funcType)
			{
			case Function.FunctionType.FuncPosition:
				return (double)context.CurrentPosition;
			case Function.FunctionType.FuncLast:
				return (double)context.Count;
			case Function.FunctionType.FuncNameSpaceUri:
			{
				XPathNavigator xPathNavigator2 = EvaluateArg(context);
				if (xPathNavigator2 != null)
				{
					return xPathNavigator2.NamespaceURI;
				}
				break;
			}
			case Function.FunctionType.FuncLocalName:
			{
				XPathNavigator xPathNavigator2 = EvaluateArg(context);
				if (xPathNavigator2 != null)
				{
					return xPathNavigator2.LocalName;
				}
				break;
			}
			case Function.FunctionType.FuncName:
			{
				XPathNavigator xPathNavigator2 = EvaluateArg(context);
				if (xPathNavigator2 != null)
				{
					return xPathNavigator2.Name;
				}
				break;
			}
			case Function.FunctionType.FuncCount:
			{
				arg.Evaluate(context);
				int num = 0;
				if (xsltContext != null)
				{
					XPathNavigator xPathNavigator;
					while ((xPathNavigator = arg.Advance()) != null)
					{
						if (xPathNavigator.NodeType != XPathNodeType.Whitespace || xsltContext.PreserveWhitespace(xPathNavigator))
						{
							num++;
						}
					}
				}
				else
				{
					while (arg.Advance() != null)
					{
						num++;
					}
				}
				return (double)num;
			}
			}
			return string.Empty;
		}

		public override XPathNodeIterator Clone()
		{
			NodeFunctions nodeFunctions = new NodeFunctions(funcType, Query.Clone(arg));
			nodeFunctions.xsltContext = xsltContext;
			return nodeFunctions;
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			w.WriteAttributeString("name", funcType.ToString());
			if (arg != null)
			{
				arg.PrintQuery(w);
			}
			w.WriteEndElement();
		}
	}
	internal sealed class NumberFunctions : ValueQuery
	{
		private Query arg;

		private Function.FunctionType ftype;

		public override XPathResultType StaticType => XPathResultType.Number;

		public NumberFunctions(Function.FunctionType ftype, Query arg)
		{
			this.arg = arg;
			this.ftype = ftype;
		}

		private NumberFunctions(NumberFunctions other)
			: base(other)
		{
			arg = Query.Clone(other.arg);
			ftype = other.ftype;
		}

		public override void SetXsltContext(XsltContext context)
		{
			if (arg != null)
			{
				arg.SetXsltContext(context);
			}
		}

		internal static double Number(bool arg)
		{
			if (!arg)
			{
				return 0.0;
			}
			return 1.0;
		}

		internal static double Number(string arg)
		{
			return XmlConvert.ToXPathDouble(arg);
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			return ftype switch
			{
				Function.FunctionType.FuncNumber => Number(nodeIterator), 
				Function.FunctionType.FuncSum => Sum(nodeIterator), 
				Function.FunctionType.FuncFloor => Floor(nodeIterator), 
				Function.FunctionType.FuncCeiling => Ceiling(nodeIterator), 
				Function.FunctionType.FuncRound => Round(nodeIterator), 
				_ => null, 
			};
		}

		private double Number(XPathNodeIterator nodeIterator)
		{
			if (arg == null)
			{
				return XmlConvert.ToXPathDouble(nodeIterator.Current.Value);
			}
			object obj = arg.Evaluate(nodeIterator);
			switch (GetXPathType(obj))
			{
			case XPathResultType.NodeSet:
			{
				XPathNavigator xPathNavigator = arg.Advance();
				if (xPathNavigator != null)
				{
					return Number(xPathNavigator.Value);
				}
				break;
			}
			case XPathResultType.String:
				return Number((string)obj);
			case XPathResultType.Boolean:
				return Number((bool)obj);
			case XPathResultType.Number:
				return (double)obj;
			case (XPathResultType)4:
				return Number(((XPathNavigator)obj).Value);
			}
			return double.NaN;
		}

		private double Sum(XPathNodeIterator nodeIterator)
		{
			double num = 0.0;
			arg.Evaluate(nodeIterator);
			XPathNavigator xPathNavigator;
			while ((xPathNavigator = arg.Advance()) != null)
			{
				num += Number(xPathNavigator.Value);
			}
			return num;
		}

		private double Floor(XPathNodeIterator nodeIterator)
		{
			return Math.Floor((double)arg.Evaluate(nodeIterator));
		}

		private double Ceiling(XPathNodeIterator nodeIterator)
		{
			return Math.Ceiling((double)arg.Evaluate(nodeIterator));
		}

		private double Round(XPathNodeIterator nodeIterator)
		{
			double value = XmlConvert.ToXPathDouble(arg.Evaluate(nodeIterator));
			return XmlConvert.XPathRound(value);
		}

		public override XPathNodeIterator Clone()
		{
			return new NumberFunctions(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			w.WriteAttributeString("name", ftype.ToString());
			if (arg != null)
			{
				arg.PrintQuery(w);
			}
			w.WriteEndElement();
		}
	}
	internal sealed class NumericExpr : ValueQuery
	{
		private Operator.Op op;

		private Query opnd1;

		private Query opnd2;

		public override XPathResultType StaticType => XPathResultType.Number;

		public NumericExpr(Operator.Op op, Query opnd1, Query opnd2)
		{
			if (opnd1.StaticType != 0)
			{
				opnd1 = new NumberFunctions(Function.FunctionType.FuncNumber, opnd1);
			}
			if (opnd2.StaticType != 0)
			{
				opnd2 = new NumberFunctions(Function.FunctionType.FuncNumber, opnd2);
			}
			this.op = op;
			this.opnd1 = opnd1;
			this.opnd2 = opnd2;
		}

		private NumericExpr(NumericExpr other)
			: base(other)
		{
			op = other.op;
			opnd1 = Query.Clone(other.opnd1);
			opnd2 = Query.Clone(other.opnd2);
		}

		public override void SetXsltContext(XsltContext context)
		{
			opnd1.SetXsltContext(context);
			opnd2.SetXsltContext(context);
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			return GetValue(op, XmlConvert.ToXPathDouble(opnd1.Evaluate(nodeIterator)), XmlConvert.ToXPathDouble(opnd2.Evaluate(nodeIterator)));
		}

		private static double GetValue(Operator.Op op, double n1, double n2)
		{
			return op switch
			{
				Operator.Op.PLUS => n1 + n2, 
				Operator.Op.MINUS => n1 - n2, 
				Operator.Op.MOD => n1 % n2, 
				Operator.Op.DIV => n1 / n2, 
				Operator.Op.MUL => n1 * n2, 
				_ => 0.0, 
			};
		}

		public override XPathNodeIterator Clone()
		{
			return new NumericExpr(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			w.WriteAttributeString("op", op.ToString());
			opnd1.PrintQuery(w);
			opnd2.PrintQuery(w);
			w.WriteEndElement();
		}
	}
	internal class Operand : AstNode
	{
		private XPathResultType type;

		private object val;

		public override AstType Type => AstType.ConstantOperand;

		public override XPathResultType ReturnType => type;

		public object OperandValue => val;

		public Operand(string val)
		{
			type = XPathResultType.String;
			this.val = val;
		}

		public Operand(double val)
		{
			type = XPathResultType.Number;
			this.val = val;
		}

		public Operand(bool val)
		{
			type = XPathResultType.Boolean;
			this.val = val;
		}
	}
	internal sealed class OperandQuery : ValueQuery
	{
		internal object val;

		public override XPathResultType StaticType => GetXPathType(val);

		public OperandQuery(object val)
		{
			this.val = val;
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			return val;
		}

		public override XPathNodeIterator Clone()
		{
			return this;
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			w.WriteAttributeString("value", Convert.ToString(val, CultureInfo.InvariantCulture));
			w.WriteEndElement();
		}
	}
	internal class Operator : AstNode
	{
		public enum Op
		{
			LT,
			GT,
			LE,
			GE,
			EQ,
			NE,
			OR,
			AND,
			PLUS,
			MINUS,
			MUL,
			MOD,
			DIV,
			UNION,
			INVALID
		}

		private Op opType;

		private AstNode opnd1;

		private AstNode opnd2;

		public override AstType Type => AstType.Operator;

		public override XPathResultType ReturnType
		{
			get
			{
				if (opType < Op.PLUS)
				{
					return XPathResultType.Boolean;
				}
				if (opType < Op.UNION)
				{
					return XPathResultType.Number;
				}
				return XPathResultType.NodeSet;
			}
		}

		public Op OperatorType => opType;

		public AstNode Operand1 => opnd1;

		public AstNode Operand2 => opnd2;

		public Operator(Op op, AstNode opnd1, AstNode opnd2)
		{
			opType = op;
			this.opnd1 = opnd1;
			this.opnd2 = opnd2;
		}
	}
	internal sealed class ParentQuery : CacheAxisQuery
	{
		public ParentQuery(Query qyInput, string Name, string Prefix, XPathNodeType Type)
			: base(qyInput, Name, Prefix, Type)
		{
		}

		private ParentQuery(ParentQuery other)
			: base(other)
		{
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			base.Evaluate(context);
			XPathNavigator xPathNavigator;
			while ((xPathNavigator = qyInput.Advance()) != null)
			{
				xPathNavigator = xPathNavigator.Clone();
				if (xPathNavigator.MoveToParent() && matches(xPathNavigator))
				{
					Insert(outputBuffer, xPathNavigator);
				}
			}
			return this;
		}

		public override XPathNodeIterator Clone()
		{
			return new ParentQuery(this);
		}
	}
	internal sealed class PrecedingQuery : BaseAxisQuery
	{
		private XPathNodeIterator workIterator;

		private ClonableStack<XPathNavigator> ancestorStk;

		public override QueryProps Properties => base.Properties | QueryProps.Reverse;

		public PrecedingQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest)
			: base(qyInput, name, prefix, typeTest)
		{
			ancestorStk = new ClonableStack<XPathNavigator>();
		}

		private PrecedingQuery(PrecedingQuery other)
			: base(other)
		{
			workIterator = Query.Clone(other.workIterator);
			ancestorStk = other.ancestorStk.Clone();
		}

		public override void Reset()
		{
			workIterator = null;
			ancestorStk.Clear();
			base.Reset();
		}

		public override XPathNavigator Advance()
		{
			if (workIterator == null)
			{
				XPathNavigator xPathNavigator = qyInput.Advance();
				if (xPathNavigator == null)
				{
					return null;
				}
				XPathNavigator xPathNavigator2 = xPathNavigator.Clone();
				do
				{
					xPathNavigator2.MoveTo(xPathNavigator);
				}
				while ((xPathNavigator = qyInput.Advance()) != null);
				if (xPathNavigator2.NodeType == XPathNodeType.Attribute || xPathNavigator2.NodeType == XPathNodeType.Namespace)
				{
					xPathNavigator2.MoveToParent();
				}
				do
				{
					ancestorStk.Push(xPathNavigator2.Clone());
				}
				while (xPathNavigator2.MoveToParent());
				workIterator = xPathNavigator2.SelectDescendants(XPathNodeType.All, matchSelf: true);
			}
			while (workIterator.MoveNext())
			{
				currentNode = workIterator.Current;
				if (currentNode.IsSamePosition(ancestorStk.Peek()))
				{
					ancestorStk.Pop();
					if (ancestorStk.Count == 0)
					{
						currentNode = null;
						workIterator = null;
						return null;
					}
				}
				else if (matches(currentNode))
				{
					position++;
					return currentNode;
				}
			}
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return new PrecedingQuery(this);
		}
	}
	internal class PreSiblingQuery : CacheAxisQuery
	{
		public override QueryProps Properties => base.Properties | QueryProps.Reverse;

		public PreSiblingQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest)
			: base(qyInput, name, prefix, typeTest)
		{
		}

		protected PreSiblingQuery(PreSiblingQuery other)
			: base(other)
		{
		}

		private bool NotVisited(XPathNavigator nav, List<XPathNavigator> parentStk)
		{
			XPathNavigator xPathNavigator = nav.Clone();
			xPathNavigator.MoveToParent();
			for (int i = 0; i < parentStk.Count; i++)
			{
				if (xPathNavigator.IsSamePosition(parentStk[i]))
				{
					return false;
				}
			}
			parentStk.Add(xPathNavigator);
			return true;
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			base.Evaluate(context);
			List<XPathNavigator> parentStk = new List<XPathNavigator>();
			Stack<XPathNavigator> stack = new Stack<XPathNavigator>();
			while ((currentNode = qyInput.Advance()) != null)
			{
				stack.Push(currentNode.Clone());
			}
			while (stack.Count != 0)
			{
				XPathNavigator xPathNavigator = stack.Pop();
				if (xPathNavigator.NodeType == XPathNodeType.Attribute || xPathNavigator.NodeType == XPathNodeType.Namespace || !NotVisited(xPathNavigator, parentStk))
				{
					continue;
				}
				XPathNavigator xPathNavigator2 = xPathNavigator.Clone();
				if (!xPathNavigator2.MoveToParent())
				{
					continue;
				}
				xPathNavigator2.MoveToFirstChild();
				while (!xPathNavigator2.IsSamePosition(xPathNavigator))
				{
					if (matches(xPathNavigator2))
					{
						Insert(outputBuffer, xPathNavigator2);
					}
					if (!xPathNavigator2.MoveToNext())
					{
						break;
					}
				}
			}
			return this;
		}

		public override XPathNodeIterator Clone()
		{
			return new PreSiblingQuery(this);
		}
	}
	internal sealed class QueryBuilder
	{
		private enum Flags
		{
			None = 0,
			SmartDesc = 1,
			PosFilter = 2,
			Filter = 4
		}

		private enum Props
		{
			None = 0,
			PosFilter = 1,
			HasPosition = 2,
			HasLast = 4,
			NonFlat = 8
		}

		private string query;

		private bool allowVar;

		private bool allowKey;

		private bool allowCurrent;

		private bool needContext;

		private BaseAxisQuery firstInput;

		private void Reset()
		{
			needContext = false;
		}

		private Query ProcessAxis(Axis root, Flags flags, out Props props)
		{
			Query query = null;
			if (root.Prefix.Length > 0)
			{
				needContext = true;
			}
			firstInput = null;
			Query query2;
			if (root.Input != null)
			{
				Flags flags2 = Flags.None;
				if ((flags & Flags.PosFilter) == 0)
				{
					if (root.Input is Axis axis && root.TypeOfAxis == Axis.AxisType.Child && axis.TypeOfAxis == Axis.AxisType.DescendantOrSelf && axis.NodeType == XPathNodeType.All)
					{
						Query qyParent;
						if (axis.Input != null)
						{
							qyParent = ProcessNode(axis.Input, Flags.SmartDesc, out props);
						}
						else
						{
							qyParent = new ContextQuery();
							props = Props.None;
						}
						query = new DescendantQuery(qyParent, root.Name, root.Prefix, root.NodeType, matchSelf: false, axis.AbbrAxis);
						if ((props & Props.NonFlat) != 0)
						{
							query = new DocumentOrderQuery(query);
						}
						props |= Props.NonFlat;
						return query;
					}
					if (root.TypeOfAxis == Axis.AxisType.Descendant || root.TypeOfAxis == Axis.AxisType.DescendantOrSelf)
					{
						flags2 |= Flags.SmartDesc;
					}
				}
				query2 = ProcessNode(root.Input, flags2, out props);
			}
			else
			{
				query2 = new ContextQuery();
				props = Props.None;
			}
			switch (root.TypeOfAxis)
			{
			case Axis.AxisType.Ancestor:
				query = new XPathAncestorQuery(query2, root.Name, root.Prefix, root.NodeType, matchSelf: false);
				props |= Props.NonFlat;
				break;
			case Axis.AxisType.AncestorOrSelf:
				query = new XPathAncestorQuery(query2, root.Name, root.Prefix, root.NodeType, matchSelf: true);
				props |= Props.NonFlat;
				break;
			case Axis.AxisType.Child:
				query = (((props & Props.NonFlat) == 0) ? new ChildrenQuery(query2, root.Name, root.Prefix, root.NodeType) : new CacheChildrenQuery(query2, root.Name, root.Prefix, root.NodeType));
				break;
			case Axis.AxisType.Parent:
				query = new ParentQuery(query2, root.Name, root.Prefix, root.NodeType);
				break;
			case Axis.AxisType.Descendant:
				if ((flags & Flags.SmartDesc) != 0)
				{
					query = new DescendantOverDescendantQuery(query2, matchSelf: false, root.Name, root.Prefix, root.NodeType, abbrAxis: false);
				}
				else
				{
					query = new DescendantQuery(query2, root.Name, root.Prefix, root.NodeType, matchSelf: false, abbrAxis: false);
					if ((props & Props.NonFlat) != 0)
					{
						query = new DocumentOrderQuery(query);
					}
				}
				props |= Props.NonFlat;
				break;
			case Axis.AxisType.DescendantOrSelf:
				if ((flags & Flags.SmartDesc) != 0)
				{
					query = new DescendantOverDescendantQuery(query2, matchSelf: true, root.Name, root.Prefix, root.NodeType, root.AbbrAxis);
				}
				else
				{
					query = new DescendantQuery(query2, root.Name, root.Prefix, root.NodeType, matchSelf: true, root.AbbrAxis);
					if ((props & Props.NonFlat) != 0)
					{
						query = new DocumentOrderQuery(query);
					}
				}
				props |= Props.NonFlat;
				break;
			case Axis.AxisType.Preceding:
				query = new PrecedingQuery(query2, root.Name, root.Prefix, root.NodeType);
				props |= Props.NonFlat;
				break;
			case Axis.AxisType.Following:
				query = new FollowingQuery(query2, root.Name, root.Prefix, root.NodeType);
				props |= Props.NonFlat;
				break;
			case Axis.AxisType.FollowingSibling:
				query = new FollSiblingQuery(query2, root.Name, root.Prefix, root.NodeType);
				if ((props & Props.NonFlat) != 0)
				{
					query = new DocumentOrderQuery(query);
				}
				break;
			case Axis.AxisType.PrecedingSibling:
				query = new PreSiblingQuery(query2, root.Name, root.Prefix, root.NodeType);
				break;
			case Axis.AxisType.Attribute:
				query = new AttributeQuery(query2, root.Name, root.Prefix, root.NodeType);
				break;
			case Axis.AxisType.Self:
				query = new XPathSelfQuery(query2, root.Name, root.Prefix, root.NodeType);
				break;
			case Axis.AxisType.Namespace:
				query = (((root.NodeType != XPathNodeType.All && root.NodeType != XPathNodeType.Element && root.NodeType != XPathNodeType.Attribute) || root.Prefix.Length != 0) ? ((Query)new EmptyQuery()) : ((Query)new NamespaceQuery(query2, root.Name, root.Prefix, root.NodeType)));
				break;
			default:
				throw XPathException.Create("Xp_NotSupported", this.query);
			}
			return query;
		}

		private bool CanBeNumber(Query q)
		{
			if (q.StaticType != XPathResultType.Any)
			{
				return q.StaticType == XPathResultType.Number;
			}
			return true;
		}

		private Query ProcessFilter(Filter root, Flags flags, out Props props)
		{
			bool flag = (flags & Flags.Filter) == 0;
			Props props2;
			Query query = ProcessNode(root.Condition, Flags.None, out props2);
			if (CanBeNumber(query) || (props2 & (Props)6) != 0)
			{
				props2 |= Props.HasPosition;
				flags |= Flags.PosFilter;
			}
			flags &= (Flags)(-2);
			Query query2 = ProcessNode(root.Input, flags | Flags.Filter, out props);
			if (root.Input.Type != AstNode.AstType.Filter)
			{
				props &= (Props)(-2);
			}
			if ((props2 & Props.HasPosition) != 0)
			{
				props |= Props.PosFilter;
			}
			if (query2 is FilterQuery filterQuery && (props2 & Props.HasPosition) == 0 && filterQuery.Condition.StaticType != XPathResultType.Any)
			{
				Query query3 = filterQuery.Condition;
				if (query3.StaticType == XPathResultType.Number)
				{
					query3 = new LogicalExpr(Operator.Op.EQ, new NodeFunctions(Function.FunctionType.FuncPosition, null), query3);
				}
				query = new BooleanExpr(Operator.Op.AND, query3, query);
				query2 = filterQuery.qyInput;
			}
			if ((props & Props.PosFilter) != 0 && query2 is DocumentOrderQuery)
			{
				query2 = ((DocumentOrderQuery)query2).input;
			}
			if (firstInput == null)
			{
				firstInput = query2 as BaseAxisQuery;
			}
			bool flag2 = (query2.Properties & QueryProps.Merge) != 0;
			bool flag3 = (query2.Properties & QueryProps.Reverse) != 0;
			if ((props2 & Props.HasPosition) != 0)
			{
				if (flag3)
				{
					query2 = new ReversePositionQuery(query2);
				}
				else if ((props2 & Props.HasLast) != 0)
				{
					query2 = new ForwardPositionQuery(query2);
				}
			}
			if (flag && firstInput != null)
			{
				if (flag2 && (props & Props.PosFilter) != 0)
				{
					query2 = new FilterQuery(query2, query, noPosition: false);
					Query qyInput = firstInput.qyInput;
					if (!(qyInput is ContextQuery))
					{
						firstInput.qyInput = new ContextQuery();
						firstInput = null;
						return new MergeFilterQuery(qyInput, query2);
					}
					firstInput = null;
					return query2;
				}
				firstInput = null;
			}
			return new FilterQuery(query2, query, (props2 & Props.HasPosition) == 0);
		}

		private Query ProcessOperator(Operator root, out Props props)
		{
			Props props2;
			Query query = ProcessNode(root.Operand1, Flags.None, out props2);
			Props props3;
			Query query2 = ProcessNode(root.Operand2, Flags.None, out props3);
			props = props2 | props3;
			switch (root.OperatorType)
			{
			case Operator.Op.PLUS:
			case Operator.Op.MINUS:
			case Operator.Op.MUL:
			case Operator.Op.MOD:
			case Operator.Op.DIV:
				return new NumericExpr(root.OperatorType, query, query2);
			case Operator.Op.LT:
			case Operator.Op.GT:
			case Operator.Op.LE:
			case Operator.Op.GE:
			case Operator.Op.EQ:
			case Operator.Op.NE:
				return new LogicalExpr(root.OperatorType, query, query2);
			case Operator.Op.OR:
			case Operator.Op.AND:
				return new BooleanExpr(root.OperatorType, query, query2);
			case Operator.Op.UNION:
				props |= Props.NonFlat;
				return new UnionExpr(query, query2);
			default:
				return null;
			}
		}

		private Query ProcessVariable(Variable root)
		{
			needContext = true;
			if (!allowVar)
			{
				throw XPathException.Create("Xp_InvalidKeyPattern", query);
			}
			return new VariableQuery(root.Localname, root.Prefix);
		}

		private Query ProcessFunction(Function root, out Props props)
		{
			props = Props.None;
			Query query = null;
			switch (root.TypeOfFunction)
			{
			case Function.FunctionType.FuncLast:
				query = new NodeFunctions(root.TypeOfFunction, null);
				props |= Props.HasLast;
				return query;
			case Function.FunctionType.FuncPosition:
				query = new NodeFunctions(root.TypeOfFunction, null);
				props |= Props.HasPosition;
				return query;
			case Function.FunctionType.FuncCount:
				return new NodeFunctions(Function.FunctionType.FuncCount, ProcessNode((AstNode)root.ArgumentList[0], Flags.None, out props));
			case Function.FunctionType.FuncID:
				query = new IDQuery(ProcessNode((AstNode)root.ArgumentList[0], Flags.None, out props));
				props |= Props.NonFlat;
				return query;
			case Function.FunctionType.FuncLocalName:
			case Function.FunctionType.FuncNameSpaceUri:
			case Function.FunctionType.FuncName:
				if (root.ArgumentList != null && root.ArgumentList.Count > 0)
				{
					return new NodeFunctions(root.TypeOfFunction, ProcessNode((AstNode)root.ArgumentList[0], Flags.None, out props));
				}
				return new NodeFunctions(root.TypeOfFunction, null);
			case Function.FunctionType.FuncString:
			case Function.FunctionType.FuncConcat:
			case Function.FunctionType.FuncStartsWith:
			case Function.FunctionType.FuncContains:
			case Function.FunctionType.FuncSubstringBefore:
			case Function.FunctionType.FuncSubstringAfter:
			case Function.FunctionType.FuncSubstring:
			case Function.FunctionType.FuncStringLength:
			case Function.FunctionType.FuncNormalize:
			case Function.FunctionType.FuncTranslate:
				return new StringFunctions(root.TypeOfFunction, ProcessArguments(root.ArgumentList, out props));
			case Function.FunctionType.FuncNumber:
			case Function.FunctionType.FuncSum:
			case Function.FunctionType.FuncFloor:
			case Function.FunctionType.FuncCeiling:
			case Function.FunctionType.FuncRound:
				if (root.ArgumentList != null && root.ArgumentList.Count > 0)
				{
					return new NumberFunctions(root.TypeOfFunction, ProcessNode((AstNode)root.ArgumentList[0], Flags.None, out props));
				}
				return new NumberFunctions(Function.FunctionType.FuncNumber, null);
			case Function.FunctionType.FuncTrue:
			case Function.FunctionType.FuncFalse:
				return new BooleanFunctions(root.TypeOfFunction, null);
			case Function.FunctionType.FuncBoolean:
			case Function.FunctionType.FuncNot:
			case Function.FunctionType.FuncLang:
				return new BooleanFunctions(root.TypeOfFunction, ProcessNode((AstNode)root.ArgumentList[0], Flags.None, out props));
			case Function.FunctionType.FuncUserDefined:
				needContext = true;
				if (!allowCurrent && root.Name == "current" && root.Prefix.Length == 0)
				{
					throw XPathException.Create("Xp_CurrentNotAllowed");
				}
				if (!allowKey && root.Name == "key" && root.Prefix.Length == 0)
				{
					throw XPathException.Create("Xp_InvalidKeyPattern", this.query);
				}
				query = new FunctionQuery(root.Prefix, root.Name, ProcessArguments(root.ArgumentList, out props));
				props |= Props.NonFlat;
				return query;
			default:
				throw XPathException.Create("Xp_NotSupported", this.query);
			}
		}

		private List<Query> ProcessArguments(ArrayList args, out Props props)
		{
			int num = args?.Count ?? 0;
			List<Query> list = new List<Query>(num);
			props = Props.None;
			for (int i = 0; i < num; i++)
			{
				list.Add(ProcessNode((AstNode)args[i], Flags.None, out var props2));
				props |= props2;
			}
			return list;
		}

		private Query ProcessNode(AstNode root, Flags flags, out Props props)
		{
			Query result = null;
			props = Props.None;
			switch (root.Type)
			{
			case AstNode.AstType.Axis:
				result = ProcessAxis((Axis)root, flags, out props);
				break;
			case AstNode.AstType.Operator:
				result = ProcessOperator((Operator)root, out props);
				break;
			case AstNode.AstType.Filter:
				result = ProcessFilter((Filter)root, flags, out props);
				break;
			case AstNode.AstType.ConstantOperand:
				result = new OperandQuery(((Operand)root).OperandValue);
				break;
			case AstNode.AstType.Variable:
				result = ProcessVariable((Variable)root);
				break;
			case AstNode.AstType.Function:
				result = ProcessFunction((Function)root, out props);
				break;
			case AstNode.AstType.Group:
				result = new GroupQuery(ProcessNode(((Group)root).GroupNode, Flags.None, out props));
				break;
			case AstNode.AstType.Root:
				result = new AbsoluteQuery();
				break;
			}
			return result;
		}

		private Query Build(AstNode root, string query)
		{
			Reset();
			this.query = query;
			Props props;
			return ProcessNode(root, Flags.None, out props);
		}

		internal Query Build(string query, bool allowVar, bool allowKey)
		{
			this.allowVar = allowVar;
			this.allowKey = allowKey;
			allowCurrent = true;
			return Build(XPathParser.ParseXPathExpresion(query), query);
		}

		internal Query Build(string query, out bool needContext)
		{
			Query result = Build(query, allowVar: true, allowKey: true);
			needContext = this.needContext;
			return result;
		}

		internal Query BuildPatternQuery(string query, bool allowVar, bool allowKey)
		{
			this.allowVar = allowVar;
			this.allowKey = allowKey;
			allowCurrent = false;
			return Build(XPathParser.ParseXPathPattern(query), query);
		}

		internal Query BuildPatternQuery(string query, out bool needContext)
		{
			Query result = BuildPatternQuery(query, allowVar: true, allowKey: true);
			needContext = this.needContext;
			return result;
		}
	}
	internal sealed class UnionExpr : Query
	{
		internal Query qy1;

		internal Query qy2;

		private bool advance1;

		private bool advance2;

		private XPathNavigator currentNode;

		private XPathNavigator nextNode;

		public override XPathResultType StaticType => XPathResultType.NodeSet;

		public override XPathNavigator Current => currentNode;

		public override int CurrentPosition
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public UnionExpr(Query query1, Query query2)
		{
			qy1 = query1;
			qy2 = query2;
			advance1 = true;
			advance2 = true;
		}

		private UnionExpr(UnionExpr other)
			: base(other)
		{
			qy1 = Query.Clone(other.qy1);
			qy2 = Query.Clone(other.qy2);
			advance1 = other.advance1;
			advance2 = other.advance2;
			currentNode = Query.Clone(other.currentNode);
			nextNode = Query.Clone(other.nextNode);
		}

		public override void Reset()
		{
			qy1.Reset();
			qy2.Reset();
			advance1 = true;
			advance2 = true;
			nextNode = null;
		}

		public override void SetXsltContext(XsltContext xsltContext)
		{
			qy1.SetXsltContext(xsltContext);
			qy2.SetXsltContext(xsltContext);
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			qy1.Evaluate(context);
			qy2.Evaluate(context);
			advance1 = true;
			advance2 = true;
			nextNode = null;
			ResetCount();
			return this;
		}

		private XPathNavigator ProcessSamePosition(XPathNavigator result)
		{
			currentNode = result;
			advance1 = (advance2 = true);
			return result;
		}

		private XPathNavigator ProcessBeforePosition(XPathNavigator res1, XPathNavigator res2)
		{
			nextNode = res2;
			advance2 = false;
			advance1 = true;
			currentNode = res1;
			return res1;
		}

		private XPathNavigator ProcessAfterPosition(XPathNavigator res1, XPathNavigator res2)
		{
			nextNode = res1;
			advance1 = false;
			advance2 = true;
			currentNode = res2;
			return res2;
		}

		public override XPathNavigator Advance()
		{
			XmlNodeOrder xmlNodeOrder = XmlNodeOrder.Before;
			XPathNavigator xPathNavigator = ((!advance1) ? nextNode : qy1.Advance());
			XPathNavigator xPathNavigator2 = ((!advance2) ? nextNode : qy2.Advance());
			if (xPathNavigator == null || xPathNavigator2 == null)
			{
				if (xPathNavigator2 == null)
				{
					advance1 = true;
					advance2 = false;
					currentNode = xPathNavigator;
					nextNode = null;
					return xPathNavigator;
				}
				advance1 = false;
				advance2 = true;
				currentNode = xPathNavigator2;
				nextNode = null;
				return xPathNavigator2;
			}
			return Query.CompareNodes(xPathNavigator, xPathNavigator2) switch
			{
				XmlNodeOrder.Before => ProcessBeforePosition(xPathNavigator, xPathNavigator2), 
				XmlNodeOrder.After => ProcessAfterPosition(xPathNavigator, xPathNavigator2), 
				_ => ProcessSamePosition(xPathNavigator), 
			};
		}

		public override XPathNavigator MatchNode(XPathNavigator xsltContext)
		{
			if (xsltContext != null)
			{
				XPathNavigator xPathNavigator = qy1.MatchNode(xsltContext);
				if (xPathNavigator != null)
				{
					return xPathNavigator;
				}
				return qy2.MatchNode(xsltContext);
			}
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return new UnionExpr(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			if (qy1 != null)
			{
				qy1.PrintQuery(w);
			}
			if (qy2 != null)
			{
				qy2.PrintQuery(w);
			}
			w.WriteEndElement();
		}
	}
	internal sealed class ReversePositionQuery : ForwardPositionQuery
	{
		public override int CurrentPosition => outputBuffer.Count - count + 1;

		public override QueryProps Properties => base.Properties | QueryProps.Reverse;

		public ReversePositionQuery(Query input)
			: base(input)
		{
		}

		private ReversePositionQuery(ReversePositionQuery other)
			: base(other)
		{
		}

		public override XPathNodeIterator Clone()
		{
			return new ReversePositionQuery(this);
		}
	}
	internal class Root : AstNode
	{
		public override AstType Type => AstType.Root;

		public override XPathResultType ReturnType => XPathResultType.NodeSet;
	}
	internal sealed class SortQuery : Query
	{
		private List<SortKey> results;

		private XPathSortComparer comparer;

		private Query qyInput;

		public override XPathNavigator Current
		{
			get
			{
				if (count == 0)
				{
					return null;
				}
				return results[count - 1].Node;
			}
		}

		public override XPathResultType StaticType => XPathResultType.NodeSet;

		public override int CurrentPosition => count;

		public override int Count => results.Count;

		public override QueryProps Properties => (QueryProps)7;

		public SortQuery(Query qyInput)
		{
			results = new List<SortKey>();
			comparer = new XPathSortComparer();
			this.qyInput = qyInput;
			count = 0;
		}

		private SortQuery(SortQuery other)
			: base(other)
		{
			results = new List<SortKey>(other.results);
			comparer = other.comparer.Clone();
			qyInput = Query.Clone(other.qyInput);
			count = 0;
		}

		public override void Reset()
		{
			count = 0;
		}

		public override void SetXsltContext(XsltContext xsltContext)
		{
			qyInput.SetXsltContext(xsltContext);
			if (qyInput.StaticType != XPathResultType.NodeSet && qyInput.StaticType != XPathResultType.Any)
			{
				throw XPathException.Create("Xp_NodeSetExpected");
			}
		}

		private void BuildResultsList()
		{
			int numSorts = comparer.NumSorts;
			XPathNavigator xPathNavigator;
			while ((xPathNavigator = qyInput.Advance()) != null)
			{
				SortKey sortKey = new SortKey(numSorts, results.Count, xPathNavigator.Clone());
				for (int i = 0; i < numSorts; i++)
				{
					sortKey[i] = comparer.Expression(i).Evaluate(qyInput);
				}
				results.Add(sortKey);
			}
			results.Sort(comparer);
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			qyInput.Evaluate(context);
			results.Clear();
			BuildResultsList();
			count = 0;
			return this;
		}

		public override XPathNavigator Advance()
		{
			if (count < results.Count)
			{
				return results[count++].Node;
			}
			return null;
		}

		internal void AddSort(Query evalQuery, IComparer comparer)
		{
			this.comparer.AddSort(evalQuery, comparer);
		}

		public override XPathNodeIterator Clone()
		{
			return new SortQuery(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			qyInput.PrintQuery(w);
			w.WriteElementString("XPathSortComparer", "... PrintTree() not implemented ...");
			w.WriteEndElement();
		}
	}
	internal sealed class SortKey
	{
		private int numKeys;

		private object[] keys;

		private int originalPosition;

		private XPathNavigator node;

		public object this[int index]
		{
			get
			{
				return keys[index];
			}
			set
			{
				keys[index] = value;
			}
		}

		public int NumKeys => numKeys;

		public int OriginalPosition => originalPosition;

		public XPathNavigator Node => node;

		public SortKey(int numKeys, int originalPosition, XPathNavigator node)
		{
			this.numKeys = numKeys;
			keys = new object[numKeys];
			this.originalPosition = originalPosition;
			this.node = node;
		}
	}
	internal sealed class XPathSortComparer : IComparer<SortKey>
	{
		private const int minSize = 3;

		private Query[] expressions;

		private IComparer[] comparers;

		private int numSorts;

		public int NumSorts => numSorts;

		public XPathSortComparer(int size)
		{
			if (size <= 0)
			{
				size = 3;
			}
			expressions = new Query[size];
			comparers = new IComparer[size];
		}

		public XPathSortComparer()
			: this(3)
		{
		}

		public void AddSort(Query evalQuery, IComparer comparer)
		{
			if (numSorts == expressions.Length)
			{
				Query[] array = new Query[numSorts * 2];
				IComparer[] array2 = new IComparer[numSorts * 2];
				for (int i = 0; i < numSorts; i++)
				{
					array[i] = expressions[i];
					array2[i] = comparers[i];
				}
				expressions = array;
				comparers = array2;
			}
			if (evalQuery.StaticType == XPathResultType.NodeSet || evalQuery.StaticType == XPathResultType.Any)
			{
				evalQuery = new StringFunctions(Function.FunctionType.FuncString, new Query[1] { evalQuery });
			}
			expressions[numSorts] = evalQuery;
			comparers[numSorts] = comparer;
			numSorts++;
		}

		public Query Expression(int i)
		{
			return expressions[i];
		}

		int IComparer<SortKey>.Compare(SortKey x, SortKey y)
		{
			int num = 0;
			for (int i = 0; i < x.NumKeys; i++)
			{
				num = comparers[i].Compare(x[i], y[i]);
				if (num != 0)
				{
					return num;
				}
			}
			return x.OriginalPosition - y.OriginalPosition;
		}

		internal XPathSortComparer Clone()
		{
			XPathSortComparer xPathSortComparer = new XPathSortComparer(numSorts);
			for (int i = 0; i < numSorts; i++)
			{
				xPathSortComparer.comparers[i] = comparers[i];
				xPathSortComparer.expressions[i] = (Query)expressions[i].Clone();
			}
			xPathSortComparer.numSorts = numSorts;
			return xPathSortComparer;
		}
	}
	internal sealed class StringFunctions : ValueQuery
	{
		private Function.FunctionType funcType;

		private IList<Query> argList;

		private static readonly CompareInfo compareInfo = CultureInfo.InvariantCulture.CompareInfo;

		public override XPathResultType StaticType
		{
			get
			{
				if (funcType == Function.FunctionType.FuncStringLength)
				{
					return XPathResultType.Number;
				}
				if (funcType == Function.FunctionType.FuncStartsWith || funcType == Function.FunctionType.FuncContains)
				{
					return XPathResultType.Boolean;
				}
				return XPathResultType.String;
			}
		}

		public StringFunctions(Function.FunctionType funcType, IList<Query> argList)
		{
			this.funcType = funcType;
			this.argList = argList;
		}

		private StringFunctions(StringFunctions other)
			: base(other)
		{
			funcType = other.funcType;
			Query[] array = new Query[other.argList.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Query.Clone(other.argList[i]);
			}
			argList = array;
		}

		public override void SetXsltContext(XsltContext context)
		{
			for (int i = 0; i < argList.Count; i++)
			{
				argList[i].SetXsltContext(context);
			}
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			return funcType switch
			{
				Function.FunctionType.FuncString => toString(nodeIterator), 
				Function.FunctionType.FuncConcat => Concat(nodeIterator), 
				Function.FunctionType.FuncStartsWith => StartsWith(nodeIterator), 
				Function.FunctionType.FuncContains => Contains(nodeIterator), 
				Function.FunctionType.FuncSubstringBefore => SubstringBefore(nodeIterator), 
				Function.FunctionType.FuncSubstringAfter => SubstringAfter(nodeIterator), 
				Function.FunctionType.FuncSubstring => Substring(nodeIterator), 
				Function.FunctionType.FuncStringLength => StringLength(nodeIterator), 
				Function.FunctionType.FuncNormalize => Normalize(nodeIterator), 
				Function.FunctionType.FuncTranslate => Translate(nodeIterator), 
				_ => string.Empty, 
			};
		}

		internal static string toString(double num)
		{
			return num.ToString("R", NumberFormatInfo.InvariantInfo);
		}

		internal static string toString(bool b)
		{
			if (!b)
			{
				return "false";
			}
			return "true";
		}

		private string toString(XPathNodeIterator nodeIterator)
		{
			if (argList.Count > 0)
			{
				object obj = argList[0].Evaluate(nodeIterator);
				switch (GetXPathType(obj))
				{
				case XPathResultType.NodeSet:
				{
					XPathNavigator xPathNavigator = argList[0].Advance();
					if (xPathNavigator == null)
					{
						return string.Empty;
					}
					return xPathNavigator.Value;
				}
				case XPathResultType.String:
					return (string)obj;
				case XPathResultType.Boolean:
					if (!(bool)obj)
					{
						return "false";
					}
					return "true";
				case (XPathResultType)4:
					return ((XPathNavigator)obj).Value;
				default:
					return toString((double)obj);
				}
			}
			return nodeIterator.Current.Value;
		}

		private string Concat(XPathNodeIterator nodeIterator)
		{
			int num = 0;
			StringBuilder stringBuilder = new StringBuilder();
			while (num < argList.Count)
			{
				stringBuilder.Append(argList[num++].Evaluate(nodeIterator).ToString());
			}
			return stringBuilder.ToString();
		}

		private bool StartsWith(XPathNodeIterator nodeIterator)
		{
			string text = argList[0].Evaluate(nodeIterator).ToString();
			string text2 = argList[1].Evaluate(nodeIterator).ToString();
			if (text.Length >= text2.Length)
			{
				return string.CompareOrdinal(text, 0, text2, 0, text2.Length) == 0;
			}
			return false;
		}

		private bool Contains(XPathNodeIterator nodeIterator)
		{
			string source = argList[0].Evaluate(nodeIterator).ToString();
			string value = argList[1].Evaluate(nodeIterator).ToString();
			return compareInfo.IndexOf(source, value, CompareOptions.Ordinal) >= 0;
		}

		private string SubstringBefore(XPathNodeIterator nodeIterator)
		{
			string text = argList[0].Evaluate(nodeIterator).ToString();
			string text2 = argList[1].Evaluate(nodeIterator).ToString();
			if (text2.Length == 0)
			{
				return text2;
			}
			int num = compareInfo.IndexOf(text, text2, CompareOptions.Ordinal);
			if (num >= 1)
			{
				return text.Substring(0, num);
			}
			return string.Empty;
		}

		private string SubstringAfter(XPathNodeIterator nodeIterator)
		{
			string text = argList[0].Evaluate(nodeIterator).ToString();
			string text2 = argList[1].Evaluate(nodeIterator).ToString();
			if (text2.Length == 0)
			{
				return text;
			}
			int num = compareInfo.IndexOf(text, text2, CompareOptions.Ordinal);
			if (num >= 0)
			{
				return text.Substring(num + text2.Length);
			}
			return string.Empty;
		}

		private string Substring(XPathNodeIterator nodeIterator)
		{
			string text = argList[0].Evaluate(nodeIterator).ToString();
			double num = XmlConvert.XPathRound(XmlConvert.ToXPathDouble(argList[1].Evaluate(nodeIterator))) - 1.0;
			if (double.IsNaN(num) || (double)text.Length <= num)
			{
				return string.Empty;
			}
			if (argList.Count == 3)
			{
				double num2 = XmlConvert.XPathRound(XmlConvert.ToXPathDouble(argList[2].Evaluate(nodeIterator)));
				if (double.IsNaN(num2))
				{
					return string.Empty;
				}
				if (num < 0.0 || num2 < 0.0)
				{
					num2 = num + num2;
					if (!(num2 > 0.0))
					{
						return string.Empty;
					}
					num = 0.0;
				}
				double num3 = (double)text.Length - num;
				if (num2 > num3)
				{
					num2 = num3;
				}
				return text.Substring((int)num, (int)num2);
			}
			if (num < 0.0)
			{
				num = 0.0;
			}
			return text.Substring((int)num);
		}

		private double StringLength(XPathNodeIterator nodeIterator)
		{
			if (argList.Count > 0)
			{
				return argList[0].Evaluate(nodeIterator).ToString().Length;
			}
			return nodeIterator.Current.Value.Length;
		}

		private string Normalize(XPathNodeIterator nodeIterator)
		{
			string value = ((argList.Count <= 0) ? nodeIterator.Current.Value : argList[0].Evaluate(nodeIterator).ToString());
			value = XmlConvert.TrimString(value);
			int i = 0;
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			XmlCharType instance = XmlCharType.Instance;
			for (; i < value.Length; i++)
			{
				if (!instance.IsWhiteSpace(value[i]))
				{
					flag = true;
					stringBuilder.Append(value[i]);
				}
				else if (flag)
				{
					flag = false;
					stringBuilder.Append(' ');
				}
			}
			return stringBuilder.ToString();
		}

		private string Translate(XPathNodeIterator nodeIterator)
		{
			string text = argList[0].Evaluate(nodeIterator).ToString();
			string text2 = argList[1].Evaluate(nodeIterator).ToString();
			string text3 = argList[2].Evaluate(nodeIterator).ToString();
			int i = 0;
			StringBuilder stringBuilder = new StringBuilder();
			for (; i < text.Length; i++)
			{
				int num = text2.IndexOf(text[i]);
				if (num != -1)
				{
					if (num < text3.Length)
					{
						stringBuilder.Append(text3[num]);
					}
				}
				else
				{
					stringBuilder.Append(text[i]);
				}
			}
			return stringBuilder.ToString();
		}

		public override XPathNodeIterator Clone()
		{
			return new StringFunctions(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			w.WriteAttributeString("name", funcType.ToString());
			foreach (Query arg in argList)
			{
				arg.PrintQuery(w);
			}
			w.WriteEndElement();
		}
	}
	internal class Variable : AstNode
	{
		private string localname;

		private string prefix;

		public override AstType Type => AstType.Variable;

		public override XPathResultType ReturnType => XPathResultType.Any;

		public string Localname => localname;

		public string Prefix => prefix;

		public Variable(string name, string prefix)
		{
			localname = name;
			this.prefix = prefix;
		}
	}
	internal sealed class VariableQuery : ExtensionQuery
	{
		private IXsltContextVariable variable;

		public override XPathResultType StaticType
		{
			get
			{
				if (variable != null)
				{
					return GetXPathType(Evaluate(null));
				}
				XPathResultType xPathResultType = ((variable != null) ? variable.VariableType : XPathResultType.Any);
				if (xPathResultType == XPathResultType.Error)
				{
					xPathResultType = XPathResultType.Any;
				}
				return xPathResultType;
			}
		}

		public VariableQuery(string name, string prefix)
			: base(prefix, name)
		{
		}

		private VariableQuery(VariableQuery other)
			: base(other)
		{
			variable = other.variable;
		}

		public override void SetXsltContext(XsltContext context)
		{
			if (context == null)
			{
				throw XPathException.Create("Xp_NoContext");
			}
			if (xsltContext != context)
			{
				xsltContext = context;
				variable = xsltContext.ResolveVariable(prefix, name);
				if (variable == null)
				{
					throw XPathException.Create("Xp_UndefVar", base.QName);
				}
			}
		}

		public override object Evaluate(XPathNodeIterator nodeIterator)
		{
			if (xsltContext == null)
			{
				throw XPathException.Create("Xp_NoContext");
			}
			return ProcessResult(variable.Evaluate(xsltContext));
		}

		public override XPathNodeIterator Clone()
		{
			return new VariableQuery(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			w.WriteAttributeString("name", (prefix.Length != 0) ? (prefix + ':' + name) : name);
			w.WriteEndElement();
		}
	}
	internal abstract class XPathAxisIterator : XPathNodeIterator
	{
		internal XPathNavigator nav;

		internal XPathNodeType type;

		internal string name;

		internal string uri;

		internal int position;

		internal bool matchSelf;

		internal bool first = true;

		public override XPathNavigator Current => nav;

		public override int CurrentPosition => position;

		protected virtual bool Matches
		{
			get
			{
				if (name == null)
				{
					if (type != nav.NodeType && type != XPathNodeType.All)
					{
						if (type == XPathNodeType.Text)
						{
							if (nav.NodeType != XPathNodeType.Whitespace)
							{
								return nav.NodeType == XPathNodeType.SignificantWhitespace;
							}
							return true;
						}
						return false;
					}
					return true;
				}
				if (nav.NodeType == XPathNodeType.Element && (name.Length == 0 || name == nav.LocalName))
				{
					return uri == nav.NamespaceURI;
				}
				return false;
			}
		}

		public XPathAxisIterator(XPathNavigator nav, bool matchSelf)
		{
			this.nav = nav;
			this.matchSelf = matchSelf;
		}

		public XPathAxisIterator(XPathNavigator nav, XPathNodeType type, bool matchSelf)
			: this(nav, matchSelf)
		{
			this.type = type;
		}

		public XPathAxisIterator(XPathNavigator nav, string name, string namespaceURI, bool matchSelf)
			: this(nav, matchSelf)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (namespaceURI == null)
			{
				throw new ArgumentNullException("namespaceURI");
			}
			this.name = name;
			uri = namespaceURI;
		}

		public XPathAxisIterator(XPathAxisIterator it)
		{
			nav = it.nav.Clone();
			type = it.type;
			name = it.name;
			uri = it.uri;
			position = it.position;
			matchSelf = it.matchSelf;
			first = it.first;
		}
	}
	internal class XPathAncestorIterator : XPathAxisIterator
	{
		public XPathAncestorIterator(XPathNavigator nav, XPathNodeType type, bool matchSelf)
			: base(nav, type, matchSelf)
		{
		}

		public XPathAncestorIterator(XPathNavigator nav, string name, string namespaceURI, bool matchSelf)
			: base(nav, name, namespaceURI, matchSelf)
		{
		}

		public XPathAncestorIterator(XPathAncestorIterator other)
			: base(other)
		{
		}

		public override bool MoveNext()
		{
			if (first)
			{
				first = false;
				if (matchSelf && Matches)
				{
					position = 1;
					return true;
				}
			}
			while (nav.MoveToParent())
			{
				if (Matches)
				{
					position++;
					return true;
				}
			}
			return false;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathAncestorIterator(this);
		}
	}
	internal sealed class XPathAncestorQuery : CacheAxisQuery
	{
		private bool matchSelf;

		public override int CurrentPosition => outputBuffer.Count - count + 1;

		public override QueryProps Properties => base.Properties | QueryProps.Reverse;

		public XPathAncestorQuery(Query qyInput, string name, string prefix, XPathNodeType typeTest, bool matchSelf)
			: base(qyInput, name, prefix, typeTest)
		{
			this.matchSelf = matchSelf;
		}

		private XPathAncestorQuery(XPathAncestorQuery other)
			: base(other)
		{
			matchSelf = other.matchSelf;
		}

		public override object Evaluate(XPathNodeIterator context)
		{
			base.Evaluate(context);
			XPathNavigator xPathNavigator = null;
			XPathNavigator xPathNavigator2;
			while ((xPathNavigator2 = qyInput.Advance()) != null)
			{
				if (!matchSelf || !matches(xPathNavigator2) || Insert(outputBuffer, xPathNavigator2))
				{
					if (xPathNavigator == null || !xPathNavigator.MoveTo(xPathNavigator2))
					{
						xPathNavigator = xPathNavigator2.Clone();
					}
					while (xPathNavigator.MoveToParent() && (!matches(xPathNavigator) || Insert(outputBuffer, xPathNavigator)))
					{
					}
				}
			}
			return this;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathAncestorQuery(this);
		}

		public override void PrintQuery(XmlWriter w)
		{
			w.WriteStartElement(GetType().Name);
			if (matchSelf)
			{
				w.WriteAttributeString("self", "yes");
			}
			if (base.NameTest)
			{
				w.WriteAttributeString("name", (base.Prefix.Length != 0) ? (base.Prefix + ':' + base.Name) : base.Name);
			}
			if (base.TypeTest != XPathNodeType.Element)
			{
				w.WriteAttributeString("nodeType", base.TypeTest.ToString());
			}
			qyInput.PrintQuery(w);
			w.WriteEndElement();
		}
	}
	[DebuggerDisplay("Position={CurrentPosition}, Current={debuggerDisplayProxy, nq}")]
	internal class XPathArrayIterator : ResetableIterator
	{
		protected IList list;

		protected int index;

		public IList AsList => list;

		public override XPathNavigator Current
		{
			get
			{
				if (index < 1)
				{
					throw new InvalidOperationException(System.Xml.Res.GetString("Sch_EnumNotStarted", string.Empty));
				}
				return (XPathNavigator)list[index - 1];
			}
		}

		public override int CurrentPosition => index;

		public override int Count => list.Count;

		private object debuggerDisplayProxy
		{
			get
			{
				if (index >= 1)
				{
					return new XPathNavigator.DebuggerDisplayProxy(Current);
				}
				return null;
			}
		}

		public XPathArrayIterator(IList list)
		{
			this.list = list;
		}

		public XPathArrayIterator(XPathArrayIterator it)
		{
			list = it.list;
			index = it.index;
		}

		public XPathArrayIterator(XPathNodeIterator nodeIterator)
		{
			list = new ArrayList();
			while (nodeIterator.MoveNext())
			{
				list.Add(nodeIterator.Current.Clone());
			}
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathArrayIterator(this);
		}

		public override bool MoveNext()
		{
			if (index == list.Count)
			{
				return false;
			}
			index++;
			return true;
		}

		public override void Reset()
		{
			index = 0;
		}

		public override IEnumerator GetEnumerator()
		{
			return list.GetEnumerator();
		}
	}
	internal class XPathChildIterator : XPathAxisIterator
	{
		public XPathChildIterator(XPathNavigator nav, XPathNodeType type)
			: base(nav, type, matchSelf: false)
		{
		}

		public XPathChildIterator(XPathNavigator nav, string name, string namespaceURI)
			: base(nav, name, namespaceURI, matchSelf: false)
		{
		}

		public XPathChildIterator(XPathChildIterator it)
			: base(it)
		{
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathChildIterator(this);
		}

		public override bool MoveNext()
		{
			while (first ? nav.MoveToFirstChild() : nav.MoveToNext())
			{
				first = false;
				if (Matches)
				{
					position++;
					return true;
				}
			}
			return false;
		}
	}
	internal class XPathDescendantIterator : XPathAxisIterator
	{
		private int level;

		public XPathDescendantIterator(XPathNavigator nav, XPathNodeType type, bool matchSelf)
			: base(nav, type, matchSelf)
		{
		}

		public XPathDescendantIterator(XPathNavigator nav, string name, string namespaceURI, bool matchSelf)
			: base(nav, name, namespaceURI, matchSelf)
		{
		}

		public XPathDescendantIterator(XPathDescendantIterator it)
			: base(it)
		{
			level = it.level;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathDescendantIterator(this);
		}

		public override bool MoveNext()
		{
			if (first)
			{
				first = false;
				if (matchSelf && Matches)
				{
					position = 1;
					return true;
				}
			}
			do
			{
				if (nav.MoveToFirstChild())
				{
					level++;
					continue;
				}
				while (true)
				{
					if (level == 0)
					{
						return false;
					}
					if (nav.MoveToNext())
					{
						break;
					}
					nav.MoveToParent();
					level--;
				}
			}
			while (!Matches);
			position++;
			return true;
		}
	}
	internal sealed class XPathEmptyIterator : ResetableIterator
	{
		public static XPathEmptyIterator Instance = new XPathEmptyIterator();

		public override XPathNavigator Current => null;

		public override int CurrentPosition => 0;

		public override int Count => 0;

		private XPathEmptyIterator()
		{
		}

		public override XPathNodeIterator Clone()
		{
			return this;
		}

		public override bool MoveNext()
		{
			return false;
		}

		public override void Reset()
		{
		}
	}
	internal class XPathMultyIterator : ResetableIterator
	{
		protected ResetableIterator[] arr;

		protected int firstNotEmpty;

		protected int position;

		public override XPathNavigator Current => arr[firstNotEmpty].Current;

		public override int CurrentPosition => position;

		public XPathMultyIterator(ArrayList inputArray)
		{
			arr = new ResetableIterator[inputArray.Count];
			for (int i = 0; i < arr.Length; i++)
			{
				arr[i] = new XPathArrayIterator((ArrayList)inputArray[i]);
			}
			Init();
		}

		private void Init()
		{
			for (int i = 0; i < arr.Length; i++)
			{
				Advance(i);
			}
			int num = arr.Length - 2;
			while (firstNotEmpty <= num)
			{
				if (SiftItem(num))
				{
					num--;
				}
			}
		}

		private bool Advance(int pos)
		{
			if (!arr[pos].MoveNext())
			{
				if (firstNotEmpty != pos)
				{
					ResetableIterator resetableIterator = arr[pos];
					Array.Copy(arr, firstNotEmpty, arr, firstNotEmpty + 1, pos - firstNotEmpty);
					arr[firstNotEmpty] = resetableIterator;
				}
				firstNotEmpty++;
				return false;
			}
			return true;
		}

		private bool SiftItem(int item)
		{
			ResetableIterator resetableIterator = arr[item];
			while (item + 1 < arr.Length)
			{
				switch (Query.CompareNodes(resetableIterator.Current, arr[item + 1].Current))
				{
				case XmlNodeOrder.After:
					arr[item] = arr[item + 1];
					item++;
					continue;
				default:
					arr[item] = resetableIterator;
					if (!Advance(item))
					{
						return false;
					}
					resetableIterator = arr[item];
					continue;
				case XmlNodeOrder.Before:
					break;
				}
				break;
			}
			arr[item] = resetableIterator;
			return true;
		}

		public override void Reset()
		{
			firstNotEmpty = 0;
			position = 0;
			for (int i = 0; i < arr.Length; i++)
			{
				arr[i].Reset();
			}
			Init();
		}

		public XPathMultyIterator(XPathMultyIterator it)
		{
			arr = (ResetableIterator[])it.arr.Clone();
			firstNotEmpty = it.firstNotEmpty;
			position = it.position;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathMultyIterator(this);
		}

		public override bool MoveNext()
		{
			if (firstNotEmpty >= arr.Length)
			{
				return false;
			}
			if (position != 0)
			{
				if (Advance(firstNotEmpty))
				{
					SiftItem(firstNotEmpty);
				}
				if (firstNotEmpty >= arr.Length)
				{
					return false;
				}
			}
			position++;
			return true;
		}
	}
	internal class XPathParser
	{
		private class ParamInfo
		{
			private Function.FunctionType ftype;

			private int minargs;

			private int maxargs;

			private XPathResultType[] argTypes;

			public Function.FunctionType FType => ftype;

			public int Minargs => minargs;

			public int Maxargs => maxargs;

			public XPathResultType[] ArgTypes => argTypes;

			internal ParamInfo(Function.FunctionType ftype, int minargs, int maxargs, XPathResultType[] argTypes)
			{
				this.ftype = ftype;
				this.minargs = minargs;
				this.maxargs = maxargs;
				this.argTypes = argTypes;
			}
		}

		private XPathScanner scanner;

		private static readonly XPathResultType[] temparray1 = new XPathResultType[0];

		private static readonly XPathResultType[] temparray2 = new XPathResultType[1] { XPathResultType.NodeSet };

		private static readonly XPathResultType[] temparray3 = new XPathResultType[1] { XPathResultType.Any };

		private static readonly XPathResultType[] temparray4 = new XPathResultType[1] { XPathResultType.String };

		private static readonly XPathResultType[] temparray5 = new XPathResultType[2]
		{
			XPathResultType.String,
			XPathResultType.String
		};

		private static readonly XPathResultType[] temparray6 = new XPathResultType[3]
		{
			XPathResultType.String,
			XPathResultType.Number,
			XPathResultType.Number
		};

		private static readonly XPathResultType[] temparray7 = new XPathResultType[3]
		{
			XPathResultType.String,
			XPathResultType.String,
			XPathResultType.String
		};

		private static readonly XPathResultType[] temparray8 = new XPathResultType[1] { XPathResultType.Boolean };

		private static readonly XPathResultType[] temparray9;

		private static Hashtable functionTable;

		private static Hashtable AxesTable;

		private XPathParser(XPathScanner scanner)
		{
			this.scanner = scanner;
		}

		public static AstNode ParseXPathExpresion(string xpathExpresion)
		{
			XPathScanner xPathScanner = new XPathScanner(xpathExpresion);
			XPathParser xPathParser = new XPathParser(xPathScanner);
			AstNode result = xPathParser.ParseExpresion(null);
			if (xPathScanner.Kind != XPathScanner.LexKind.Eof)
			{
				throw XPathException.Create("Xp_InvalidToken", xPathScanner.SourceText);
			}
			return result;
		}

		public static AstNode ParseXPathPattern(string xpathPattern)
		{
			XPathScanner xPathScanner = new XPathScanner(xpathPattern);
			XPathParser xPathParser = new XPathParser(xPathScanner);
			AstNode result = xPathParser.ParsePattern(null);
			if (xPathScanner.Kind != XPathScanner.LexKind.Eof)
			{
				throw XPathException.Create("Xp_InvalidToken", xPathScanner.SourceText);
			}
			return result;
		}

		private AstNode ParseExpresion(AstNode qyInput)
		{
			return ParseOrExpr(qyInput);
		}

		private AstNode ParseOrExpr(AstNode qyInput)
		{
			AstNode astNode = ParseAndExpr(qyInput);
			while (TestOp("or"))
			{
				NextLex();
				astNode = new Operator(Operator.Op.OR, astNode, ParseAndExpr(qyInput));
			}
			return astNode;
		}

		private AstNode ParseAndExpr(AstNode qyInput)
		{
			AstNode astNode = ParseEqualityExpr(qyInput);
			while (TestOp("and"))
			{
				NextLex();
				astNode = new Operator(Operator.Op.AND, astNode, ParseEqualityExpr(qyInput));
			}
			return astNode;
		}

		private AstNode ParseEqualityExpr(AstNode qyInput)
		{
			AstNode astNode = ParseRelationalExpr(qyInput);
			while (true)
			{
				Operator.Op op = ((scanner.Kind == XPathScanner.LexKind.Eq) ? Operator.Op.EQ : ((scanner.Kind == XPathScanner.LexKind.Ne) ? Operator.Op.NE : Operator.Op.INVALID));
				if (op == Operator.Op.INVALID)
				{
					break;
				}
				NextLex();
				astNode = new Operator(op, astNode, ParseRelationalExpr(qyInput));
			}
			return astNode;
		}

		private AstNode ParseRelationalExpr(AstNode qyInput)
		{
			AstNode astNode = ParseAdditiveExpr(qyInput);
			while (true)
			{
				Operator.Op op = ((scanner.Kind != XPathScanner.LexKind.Lt) ? ((scanner.Kind == XPathScanner.LexKind.Le) ? Operator.Op.LE : ((scanner.Kind == XPathScanner.LexKind.Gt) ? Operator.Op.GT : ((scanner.Kind == XPathScanner.LexKind.Ge) ? Operator.Op.GE : Operator.Op.INVALID))) : Operator.Op.LT);
				if (op == Operator.Op.INVALID)
				{
					break;
				}
				NextLex();
				astNode = new Operator(op, astNode, ParseAdditiveExpr(qyInput));
			}
			return astNode;
		}

		private AstNode ParseAdditiveExpr(AstNode qyInput)
		{
			AstNode astNode = ParseMultiplicativeExpr(qyInput);
			while (true)
			{
				Operator.Op op = ((scanner.Kind == XPathScanner.LexKind.Plus) ? Operator.Op.PLUS : ((scanner.Kind == XPathScanner.LexKind.Minus) ? Operator.Op.MINUS : Operator.Op.INVALID));
				if (op == Operator.Op.INVALID)
				{
					break;
				}
				NextLex();
				astNode = new Operator(op, astNode, ParseMultiplicativeExpr(qyInput));
			}
			return astNode;
		}

		private AstNode ParseMultiplicativeExpr(AstNode qyInput)
		{
			AstNode astNode = ParseUnaryExpr(qyInput);
			while (true)
			{
				Operator.Op op = ((scanner.Kind == XPathScanner.LexKind.Star) ? Operator.Op.MUL : (TestOp("div") ? Operator.Op.DIV : (TestOp("mod") ? Operator.Op.MOD : Operator.Op.INVALID)));
				if (op == Operator.Op.INVALID)
				{
					break;
				}
				NextLex();
				astNode = new Operator(op, astNode, ParseUnaryExpr(qyInput));
			}
			return astNode;
		}

		private AstNode ParseUnaryExpr(AstNode qyInput)
		{
			if (scanner.Kind == XPathScanner.LexKind.Minus)
			{
				NextLex();
				return new Operator(Operator.Op.MUL, ParseUnaryExpr(qyInput), new Operand(-1.0));
			}
			return ParseUnionExpr(qyInput);
		}

		private AstNode ParseUnionExpr(AstNode qyInput)
		{
			AstNode astNode = ParsePathExpr(qyInput);
			while (scanner.Kind == XPathScanner.LexKind.Union)
			{
				NextLex();
				AstNode astNode2 = ParsePathExpr(qyInput);
				CheckNodeSet(astNode.ReturnType);
				CheckNodeSet(astNode2.ReturnType);
				astNode = new Operator(Operator.Op.UNION, astNode, astNode2);
			}
			return astNode;
		}

		private static bool IsNodeType(XPathScanner scaner)
		{
			if (scaner.Prefix.Length == 0)
			{
				if (!(scaner.Name == "node") && !(scaner.Name == "text") && !(scaner.Name == "processing-instruction"))
				{
					return scaner.Name == "comment";
				}
				return true;
			}
			return false;
		}

		private AstNode ParsePathExpr(AstNode qyInput)
		{
			AstNode astNode;
			if (IsPrimaryExpr(scanner))
			{
				astNode = ParseFilterExpr(qyInput);
				if (scanner.Kind == XPathScanner.LexKind.Slash)
				{
					NextLex();
					astNode = ParseRelativeLocationPath(astNode);
				}
				else if (scanner.Kind == XPathScanner.LexKind.SlashSlash)
				{
					NextLex();
					astNode = ParseRelativeLocationPath(new Axis(Axis.AxisType.DescendantOrSelf, astNode));
				}
			}
			else
			{
				astNode = ParseLocationPath(null);
			}
			return astNode;
		}

		private AstNode ParseFilterExpr(AstNode qyInput)
		{
			AstNode astNode = ParsePrimaryExpr(qyInput);
			while (scanner.Kind == XPathScanner.LexKind.LBracket)
			{
				astNode = new Filter(astNode, ParsePredicate(astNode));
			}
			return astNode;
		}

		private AstNode ParsePredicate(AstNode qyInput)
		{
			CheckNodeSet(qyInput.ReturnType);
			PassToken(XPathScanner.LexKind.LBracket);
			AstNode result = ParseExpresion(qyInput);
			PassToken(XPathScanner.LexKind.RBracket);
			return result;
		}

		private AstNode ParseLocationPath(AstNode qyInput)
		{
			if (scanner.Kind == XPathScanner.LexKind.Slash)
			{
				NextLex();
				AstNode astNode = new Root();
				if (IsStep(scanner.Kind))
				{
					astNode = ParseRelativeLocationPath(astNode);
				}
				return astNode;
			}
			if (scanner.Kind == XPathScanner.LexKind.SlashSlash)
			{
				NextLex();
				return ParseRelativeLocationPath(new Axis(Axis.AxisType.DescendantOrSelf, new Root()));
			}
			return ParseRelativeLocationPath(qyInput);
		}

		private AstNode ParseRelativeLocationPath(AstNode qyInput)
		{
			AstNode astNode = ParseStep(qyInput);
			if (XPathScanner.LexKind.SlashSlash == scanner.Kind)
			{
				NextLex();
				astNode = ParseRelativeLocationPath(new Axis(Axis.AxisType.DescendantOrSelf, astNode));
			}
			else if (XPathScanner.LexKind.Slash == scanner.Kind)
			{
				NextLex();
				astNode = ParseRelativeLocationPath(astNode);
			}
			return astNode;
		}

		private static bool IsStep(XPathScanner.LexKind lexKind)
		{
			if (lexKind != XPathScanner.LexKind.Dot && lexKind != XPathScanner.LexKind.DotDot && lexKind != XPathScanner.LexKind.At && lexKind != XPathScanner.LexKind.Axe && lexKind != XPathScanner.LexKind.Star)
			{
				return lexKind == XPathScanner.LexKind.Name;
			}
			return true;
		}

		private AstNode ParseStep(AstNode qyInput)
		{
			AstNode astNode;
			if (XPathScanner.LexKind.Dot == scanner.Kind)
			{
				NextLex();
				astNode = new Axis(Axis.AxisType.Self, qyInput);
			}
			else if (XPathScanner.LexKind.DotDot == scanner.Kind)
			{
				NextLex();
				astNode = new Axis(Axis.AxisType.Parent, qyInput);
			}
			else
			{
				Axis.AxisType axisType = Axis.AxisType.Child;
				switch (scanner.Kind)
				{
				case XPathScanner.LexKind.At:
					axisType = Axis.AxisType.Attribute;
					NextLex();
					break;
				case XPathScanner.LexKind.Axe:
					axisType = GetAxis(scanner);
					NextLex();
					break;
				}
				XPathNodeType nodeType = ((axisType != Axis.AxisType.Attribute) ? XPathNodeType.Element : XPathNodeType.Attribute);
				astNode = ParseNodeTest(qyInput, axisType, nodeType);
				while (XPathScanner.LexKind.LBracket == scanner.Kind)
				{
					astNode = new Filter(astNode, ParsePredicate(astNode));
				}
			}
			return astNode;
		}

		private AstNode ParseNodeTest(AstNode qyInput, Axis.AxisType axisType, XPathNodeType nodeType)
		{
			string prefix;
			string text;
			switch (scanner.Kind)
			{
			case XPathScanner.LexKind.Name:
				if (scanner.CanBeFunction && IsNodeType(scanner))
				{
					prefix = string.Empty;
					text = string.Empty;
					nodeType = ((scanner.Name == "comment") ? XPathNodeType.Comment : ((scanner.Name == "text") ? XPathNodeType.Text : ((scanner.Name == "node") ? XPathNodeType.All : ((scanner.Name == "processing-instruction") ? XPathNodeType.ProcessingInstruction : XPathNodeType.Root))));
					NextLex();
					PassToken(XPathScanner.LexKind.LParens);
					if (nodeType == XPathNodeType.ProcessingInstruction && scanner.Kind != XPathScanner.LexKind.RParens)
					{
						CheckToken(XPathScanner.LexKind.String);
						text = scanner.StringValue;
						NextLex();
					}
					PassToken(XPathScanner.LexKind.RParens);
				}
				else
				{
					prefix = scanner.Prefix;
					text = scanner.Name;
					NextLex();
					if (text == "*")
					{
						text = string.Empty;
					}
				}
				break;
			case XPathScanner.LexKind.Star:
				prefix = string.Empty;
				text = string.Empty;
				NextLex();
				break;
			default:
				throw XPathException.Create("Xp_NodeSetExpected", scanner.SourceText);
			}
			return new Axis(axisType, qyInput, prefix, text, nodeType);
		}

		private static bool IsPrimaryExpr(XPathScanner scanner)
		{
			if (scanner.Kind != XPathScanner.LexKind.String && scanner.Kind != XPathScanner.LexKind.Number && scanner.Kind != XPathScanner.LexKind.Dollar && scanner.Kind != XPathScanner.LexKind.LParens)
			{
				if (scanner.Kind == XPathScanner.LexKind.Name && scanner.CanBeFunction)
				{
					return !IsNodeType(scanner);
				}
				return false;
			}
			return true;
		}

		private AstNode ParsePrimaryExpr(AstNode qyInput)
		{
			AstNode astNode = null;
			switch (scanner.Kind)
			{
			case XPathScanner.LexKind.String:
				astNode = new Operand(scanner.StringValue);
				NextLex();
				break;
			case XPathScanner.LexKind.Number:
				astNode = new Operand(scanner.NumberValue);
				NextLex();
				break;
			case XPathScanner.LexKind.Dollar:
				NextLex();
				CheckToken(XPathScanner.LexKind.Name);
				astNode = new Variable(scanner.Name, scanner.Prefix);
				NextLex();
				break;
			case XPathScanner.LexKind.LParens:
				NextLex();
				astNode = ParseExpresion(qyInput);
				if (astNode.Type != AstNode.AstType.ConstantOperand)
				{
					astNode = new Group(astNode);
				}
				PassToken(XPathScanner.LexKind.RParens);
				break;
			case XPathScanner.LexKind.Name:
				if (scanner.CanBeFunction && !IsNodeType(scanner))
				{
					astNode = ParseMethod(null);
				}
				break;
			}
			return astNode;
		}

		private AstNode ParseMethod(AstNode qyInput)
		{
			ArrayList arrayList = new ArrayList();
			string name = scanner.Name;
			string prefix = scanner.Prefix;
			PassToken(XPathScanner.LexKind.Name);
			PassToken(XPathScanner.LexKind.LParens);
			if (scanner.Kind != XPathScanner.LexKind.RParens)
			{
				while (true)
				{
					arrayList.Add(ParseExpresion(qyInput));
					if (scanner.Kind == XPathScanner.LexKind.RParens)
					{
						break;
					}
					PassToken(XPathScanner.LexKind.Comma);
				}
			}
			PassToken(XPathScanner.LexKind.RParens);
			if (prefix.Length == 0)
			{
				ParamInfo paramInfo = (ParamInfo)functionTable[name];
				if (paramInfo != null)
				{
					int num = arrayList.Count;
					if (num < paramInfo.Minargs)
					{
						throw XPathException.Create("Xp_InvalidNumArgs", name, scanner.SourceText);
					}
					if (paramInfo.FType == Function.FunctionType.FuncConcat)
					{
						for (int i = 0; i < num; i++)
						{
							AstNode astNode = (AstNode)arrayList[i];
							if (astNode.ReturnType != XPathResultType.String)
							{
								astNode = new Function(Function.FunctionType.FuncString, astNode);
							}
							arrayList[i] = astNode;
						}
					}
					else
					{
						if (paramInfo.Maxargs < num)
						{
							throw XPathException.Create("Xp_InvalidNumArgs", name, scanner.SourceText);
						}
						if (paramInfo.ArgTypes.Length < num)
						{
							num = paramInfo.ArgTypes.Length;
						}
						for (int j = 0; j < num; j++)
						{
							AstNode astNode2 = (AstNode)arrayList[j];
							if (paramInfo.ArgTypes[j] == XPathResultType.Any || paramInfo.ArgTypes[j] == astNode2.ReturnType)
							{
								continue;
							}
							switch (paramInfo.ArgTypes[j])
							{
							case XPathResultType.NodeSet:
								if (!(astNode2 is Variable) && (!(astNode2 is Function) || astNode2.ReturnType != XPathResultType.Any))
								{
									throw XPathException.Create("Xp_InvalidArgumentType", name, scanner.SourceText);
								}
								break;
							case XPathResultType.String:
								astNode2 = new Function(Function.FunctionType.FuncString, astNode2);
								break;
							case XPathResultType.Number:
								astNode2 = new Function(Function.FunctionType.FuncNumber, astNode2);
								break;
							case XPathResultType.Boolean:
								astNode2 = new Function(Function.FunctionType.FuncBoolean, astNode2);
								break;
							}
							arrayList[j] = astNode2;
						}
					}
					return new Function(paramInfo.FType, arrayList);
				}
			}
			return new Function(prefix, name, arrayList);
		}

		private AstNode ParsePattern(AstNode qyInput)
		{
			AstNode astNode = ParseLocationPathPattern(qyInput);
			while (scanner.Kind == XPathScanner.LexKind.Union)
			{
				NextLex();
				astNode = new Operator(Operator.Op.UNION, astNode, ParseLocationPathPattern(qyInput));
			}
			return astNode;
		}

		private AstNode ParseLocationPathPattern(AstNode qyInput)
		{
			AstNode astNode = null;
			switch (scanner.Kind)
			{
			case XPathScanner.LexKind.Slash:
				NextLex();
				astNode = new Root();
				if (scanner.Kind == XPathScanner.LexKind.Eof || scanner.Kind == XPathScanner.LexKind.Union)
				{
					return astNode;
				}
				break;
			case XPathScanner.LexKind.SlashSlash:
				NextLex();
				astNode = new Axis(Axis.AxisType.DescendantOrSelf, new Root());
				break;
			case XPathScanner.LexKind.Name:
				if (!scanner.CanBeFunction)
				{
					break;
				}
				astNode = ParseIdKeyPattern(qyInput);
				if (astNode != null)
				{
					switch (scanner.Kind)
					{
					case XPathScanner.LexKind.Slash:
						NextLex();
						break;
					case XPathScanner.LexKind.SlashSlash:
						NextLex();
						astNode = new Axis(Axis.AxisType.DescendantOrSelf, astNode);
						break;
					default:
						return astNode;
					}
				}
				break;
			}
			return ParseRelativePathPattern(astNode);
		}

		private AstNode ParseIdKeyPattern(AstNode qyInput)
		{
			ArrayList arrayList = new ArrayList();
			if (scanner.Prefix.Length == 0)
			{
				if (scanner.Name == "id")
				{
					ParamInfo paramInfo = (ParamInfo)functionTable["id"];
					NextLex();
					PassToken(XPathScanner.LexKind.LParens);
					CheckToken(XPathScanner.LexKind.String);
					arrayList.Add(new Operand(scanner.StringValue));
					NextLex();
					PassToken(XPathScanner.LexKind.RParens);
					return new Function(paramInfo.FType, arrayList);
				}
				if (scanner.Name == "key")
				{
					NextLex();
					PassToken(XPathScanner.LexKind.LParens);
					CheckToken(XPathScanner.LexKind.String);
					arrayList.Add(new Operand(scanner.StringValue));
					NextLex();
					PassToken(XPathScanner.LexKind.Comma);
					CheckToken(XPathScanner.LexKind.String);
					arrayList.Add(new Operand(scanner.StringValue));
					NextLex();
					PassToken(XPathScanner.LexKind.RParens);
					return new Function("", "key", arrayList);
				}
			}
			return null;
		}

		private AstNode ParseRelativePathPattern(AstNode qyInput)
		{
			AstNode astNode = ParseStepPattern(qyInput);
			if (XPathScanner.LexKind.SlashSlash == scanner.Kind)
			{
				NextLex();
				astNode = ParseRelativePathPattern(new Axis(Axis.AxisType.DescendantOrSelf, astNode));
			}
			else if (XPathScanner.LexKind.Slash == scanner.Kind)
			{
				NextLex();
				astNode = ParseRelativePathPattern(astNode);
			}
			return astNode;
		}

		private AstNode ParseStepPattern(AstNode qyInput)
		{
			Axis.AxisType axisType = Axis.AxisType.Child;
			switch (scanner.Kind)
			{
			case XPathScanner.LexKind.At:
				axisType = Axis.AxisType.Attribute;
				NextLex();
				break;
			case XPathScanner.LexKind.Axe:
				axisType = GetAxis(scanner);
				if (axisType != Axis.AxisType.Child && axisType != Axis.AxisType.Attribute)
				{
					throw XPathException.Create("Xp_InvalidToken", scanner.SourceText);
				}
				NextLex();
				break;
			}
			XPathNodeType nodeType = ((axisType != Axis.AxisType.Attribute) ? XPathNodeType.Element : XPathNodeType.Attribute);
			AstNode astNode = ParseNodeTest(qyInput, axisType, nodeType);
			while (XPathScanner.LexKind.LBracket == scanner.Kind)
			{
				astNode = new Filter(astNode, ParsePredicate(astNode));
			}
			return astNode;
		}

		private void CheckToken(XPathScanner.LexKind t)
		{
			if (scanner.Kind != t)
			{
				throw XPathException.Create("Xp_InvalidToken", scanner.SourceText);
			}
		}

		private void PassToken(XPathScanner.LexKind t)
		{
			CheckToken(t);
			NextLex();
		}

		private void NextLex()
		{
			scanner.NextLex();
		}

		private bool TestOp(string op)
		{
			if (scanner.Kind == XPathScanner.LexKind.Name && scanner.Prefix.Length == 0)
			{
				return scanner.Name.Equals(op);
			}
			return false;
		}

		private void CheckNodeSet(XPathResultType t)
		{
			if (t != XPathResultType.NodeSet && t != XPathResultType.Any)
			{
				throw XPathException.Create("Xp_NodeSetExpected", scanner.SourceText);
			}
		}

		private static Hashtable CreateFunctionTable()
		{
			Hashtable hashtable = new Hashtable(36);
			hashtable.Add("last", new ParamInfo(Function.FunctionType.FuncLast, 0, 0, temparray1));
			hashtable.Add("position", new ParamInfo(Function.FunctionType.FuncPosition, 0, 0, temparray1));
			hashtable.Add("name", new ParamInfo(Function.FunctionType.FuncName, 0, 1, temparray2));
			hashtable.Add("namespace-uri", new ParamInfo(Function.FunctionType.FuncNameSpaceUri, 0, 1, temparray2));
			hashtable.Add("local-name", new ParamInfo(Function.FunctionType.FuncLocalName, 0, 1, temparray2));
			hashtable.Add("count", new ParamInfo(Function.FunctionType.FuncCount, 1, 1, temparray2));
			hashtable.Add("id", new ParamInfo(Function.FunctionType.FuncID, 1, 1, temparray3));
			hashtable.Add("string", new ParamInfo(Function.FunctionType.FuncString, 0, 1, temparray3));
			hashtable.Add("concat", new ParamInfo(Function.FunctionType.FuncConcat, 2, 100, temparray4));
			hashtable.Add("starts-with", new ParamInfo(Function.FunctionType.FuncStartsWith, 2, 2, temparray5));
			hashtable.Add("contains", new ParamInfo(Function.FunctionType.FuncContains, 2, 2, temparray5));
			hashtable.Add("substring-before", new ParamInfo(Function.FunctionType.FuncSubstringBefore, 2, 2, temparray5));
			hashtable.Add("substring-after", new ParamInfo(Function.FunctionType.FuncSubstringAfter, 2, 2, temparray5));
			hashtable.Add("substring", new ParamInfo(Function.FunctionType.FuncSubstring, 2, 3, temparray6));
			hashtable.Add("string-length", new ParamInfo(Function.FunctionType.FuncStringLength, 0, 1, temparray4));
			hashtable.Add("normalize-space", new ParamInfo(Function.FunctionType.FuncNormalize, 0, 1, temparray4));
			hashtable.Add("translate", new ParamInfo(Function.FunctionType.FuncTranslate, 3, 3, temparray7));
			hashtable.Add("boolean", new ParamInfo(Function.FunctionType.FuncBoolean, 1, 1, temparray3));
			hashtable.Add("not", new ParamInfo(Function.FunctionType.FuncNot, 1, 1, temparray8));
			hashtable.Add("true", new ParamInfo(Function.FunctionType.FuncTrue, 0, 0, temparray8));
			hashtable.Add("false", new ParamInfo(Function.FunctionType.FuncFalse, 0, 0, temparray8));
			hashtable.Add("lang", new ParamInfo(Function.FunctionType.FuncLang, 1, 1, temparray4));
			hashtable.Add("number", new ParamInfo(Function.FunctionType.FuncNumber, 0, 1, temparray3));
			hashtable.Add("sum", new ParamInfo(Function.FunctionType.FuncSum, 1, 1, temparray2));
			hashtable.Add("floor", new ParamInfo(Function.FunctionType.FuncFloor, 1, 1, temparray9));
			hashtable.Add("ceiling", new ParamInfo(Function.FunctionType.FuncCeiling, 1, 1, temparray9));
			hashtable.Add("round", new ParamInfo(Function.FunctionType.FuncRound, 1, 1, temparray9));
			return hashtable;
		}

		private static Hashtable CreateAxesTable()
		{
			Hashtable hashtable = new Hashtable(13);
			hashtable.Add("ancestor", Axis.AxisType.Ancestor);
			hashtable.Add("ancestor-or-self", Axis.AxisType.AncestorOrSelf);
			hashtable.Add("attribute", Axis.AxisType.Attribute);
			hashtable.Add("child", Axis.AxisType.Child);
			hashtable.Add("descendant", Axis.AxisType.Descendant);
			hashtable.Add("descendant-or-self", Axis.AxisType.DescendantOrSelf);
			hashtable.Add("following", Axis.AxisType.Following);
			hashtable.Add("following-sibling", Axis.AxisType.FollowingSibling);
			hashtable.Add("namespace", Axis.AxisType.Namespace);
			hashtable.Add("parent", Axis.AxisType.Parent);
			hashtable.Add("preceding", Axis.AxisType.Preceding);
			hashtable.Add("preceding-sibling", Axis.AxisType.PrecedingSibling);
			hashtable.Add("self", Axis.AxisType.Self);
			return hashtable;
		}

		private Axis.AxisType GetAxis(XPathScanner scaner)
		{
			object obj = AxesTable[scaner.Name];
			if (obj == null)
			{
				throw XPathException.Create("Xp_InvalidToken", scanner.SourceText);
			}
			return (Axis.AxisType)obj;
		}

		static XPathParser()
		{
			XPathResultType[] array = (temparray9 = new XPathResultType[1]);
			functionTable = CreateFunctionTable();
			AxesTable = CreateAxesTable();
		}
	}
	internal sealed class XPathScanner
	{
		public enum LexKind
		{
			Comma = 44,
			Slash = 47,
			At = 64,
			Dot = 46,
			LParens = 40,
			RParens = 41,
			LBracket = 91,
			RBracket = 93,
			Star = 42,
			Plus = 43,
			Minus = 45,
			Eq = 61,
			Lt = 60,
			Gt = 62,
			Bang = 33,
			Dollar = 36,
			Apos = 39,
			Quote = 34,
			Union = 124,
			Ne = 78,
			Le = 76,
			Ge = 71,
			And = 65,
			Or = 79,
			DotDot = 68,
			SlashSlash = 83,
			Name = 110,
			String = 115,
			Number = 100,
			Axe = 97,
			Eof = 69
		}

		private string xpathExpr;

		private int xpathExprIndex;

		private LexKind kind;

		private char currentChar;

		private string name;

		private string prefix;

		private string stringValue;

		private double numberValue = double.NaN;

		private bool canBeFunction;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		public string SourceText => xpathExpr;

		private char CurerntChar => currentChar;

		public LexKind Kind => kind;

		public string Name => name;

		public string Prefix => prefix;

		public string StringValue => stringValue;

		public double NumberValue => numberValue;

		public bool CanBeFunction => canBeFunction;

		public XPathScanner(string xpathExpr)
		{
			if (xpathExpr == null)
			{
				throw XPathException.Create("Xp_ExprExpected", string.Empty);
			}
			this.xpathExpr = xpathExpr;
			NextChar();
			NextLex();
		}

		private bool NextChar()
		{
			if (xpathExprIndex < xpathExpr.Length)
			{
				currentChar = xpathExpr[xpathExprIndex++];
				return true;
			}
			currentChar = '\0';
			return false;
		}

		private void SkipSpace()
		{
			while (xmlCharType.IsWhiteSpace(CurerntChar) && NextChar())
			{
			}
		}

		public bool NextLex()
		{
			SkipSpace();
			switch (CurerntChar)
			{
			case '\0':
				kind = LexKind.Eof;
				return false;
			case '#':
			case '$':
			case '(':
			case ')':
			case '*':
			case '+':
			case ',':
			case '-':
			case '=':
			case '@':
			case '[':
			case ']':
			case '|':
				kind = (LexKind)Convert.ToInt32(CurerntChar, CultureInfo.InvariantCulture);
				NextChar();
				break;
			case '<':
				kind = LexKind.Lt;
				NextChar();
				if (CurerntChar == '=')
				{
					kind = LexKind.Le;
					NextChar();
				}
				break;
			case '>':
				kind = LexKind.Gt;
				NextChar();
				if (CurerntChar == '=')
				{
					kind = LexKind.Ge;
					NextChar();
				}
				break;
			case '!':
				kind = LexKind.Bang;
				NextChar();
				if (CurerntChar == '=')
				{
					kind = LexKind.Ne;
					NextChar();
				}
				break;
			case '.':
				kind = LexKind.Dot;
				NextChar();
				if (CurerntChar == '.')
				{
					kind = LexKind.DotDot;
					NextChar();
				}
				else if (xmlCharType.IsDigit(CurerntChar))
				{
					kind = LexKind.Number;
					numberValue = ScanFraction();
				}
				break;
			case '/':
				kind = LexKind.Slash;
				NextChar();
				if (CurerntChar == '/')
				{
					kind = LexKind.SlashSlash;
					NextChar();
				}
				break;
			case '"':
			case '\'':
				kind = LexKind.String;
				stringValue = ScanString();
				break;
			default:
				if (xmlCharType.IsDigit(CurerntChar))
				{
					kind = LexKind.Number;
					numberValue = ScanNumber();
					break;
				}
				if (xmlCharType.IsStartNCNameChar(CurerntChar))
				{
					kind = LexKind.Name;
					name = ScanName();
					prefix = string.Empty;
					if (CurerntChar == ':')
					{
						NextChar();
						if (CurerntChar == ':')
						{
							NextChar();
							kind = LexKind.Axe;
						}
						else
						{
							prefix = name;
							if (CurerntChar == '*')
							{
								NextChar();
								name = "*";
							}
							else
							{
								if (!xmlCharType.IsStartNCNameChar(CurerntChar))
								{
									throw XPathException.Create("Xp_InvalidName", SourceText);
								}
								name = ScanName();
							}
						}
					}
					else
					{
						SkipSpace();
						if (CurerntChar == ':')
						{
							NextChar();
							if (CurerntChar != ':')
							{
								throw XPathException.Create("Xp_InvalidName", SourceText);
							}
							NextChar();
							kind = LexKind.Axe;
						}
					}
					SkipSpace();
					canBeFunction = CurerntChar == '(';
					break;
				}
				throw XPathException.Create("Xp_InvalidToken", SourceText);
			}
			return true;
		}

		private double ScanNumber()
		{
			int startIndex = xpathExprIndex - 1;
			int num = 0;
			while (xmlCharType.IsDigit(CurerntChar))
			{
				NextChar();
				num++;
			}
			if (CurerntChar == '.')
			{
				NextChar();
				num++;
				while (xmlCharType.IsDigit(CurerntChar))
				{
					NextChar();
					num++;
				}
			}
			return XmlConvert.ToXPathDouble(xpathExpr.Substring(startIndex, num));
		}

		private double ScanFraction()
		{
			int startIndex = xpathExprIndex - 2;
			int num = 1;
			while (xmlCharType.IsDigit(CurerntChar))
			{
				NextChar();
				num++;
			}
			return XmlConvert.ToXPathDouble(xpathExpr.Substring(startIndex, num));
		}

		private string ScanString()
		{
			char curerntChar = CurerntChar;
			NextChar();
			int startIndex = xpathExprIndex - 1;
			int num = 0;
			while (CurerntChar != curerntChar)
			{
				if (!NextChar())
				{
					throw XPathException.Create("Xp_UnclosedString");
				}
				num++;
			}
			NextChar();
			return xpathExpr.Substring(startIndex, num);
		}

		private string ScanName()
		{
			int startIndex = xpathExprIndex - 1;
			int num = 0;
			while (xmlCharType.IsNCNameChar(CurerntChar))
			{
				NextChar();
				num++;
			}
			return xpathExpr.Substring(startIndex, num);
		}
	}
	internal class XPathSelectionIterator : ResetableIterator
	{
		private XPathNavigator nav;

		private Query query;

		private int position;

		public override int Count => query.Count;

		public override XPathNavigator Current => nav;

		public override int CurrentPosition => position;

		internal XPathSelectionIterator(XPathNavigator nav, Query query)
		{
			this.nav = nav.Clone();
			this.query = query;
		}

		protected XPathSelectionIterator(XPathSelectionIterator it)
		{
			nav = it.nav.Clone();
			query = (Query)it.query.Clone();
			position = it.position;
		}

		public override void Reset()
		{
			query.Reset();
		}

		public override bool MoveNext()
		{
			XPathNavigator xPathNavigator = query.Advance();
			if (xPathNavigator != null)
			{
				position++;
				if (!nav.MoveTo(xPathNavigator))
				{
					nav = xPathNavigator.Clone();
				}
				return true;
			}
			return false;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathSelectionIterator(this);
		}
	}
	internal sealed class XPathSelfQuery : BaseAxisQuery
	{
		public XPathSelfQuery(Query qyInput, string Name, string Prefix, XPathNodeType Type)
			: base(qyInput, Name, Prefix, Type)
		{
		}

		private XPathSelfQuery(XPathSelfQuery other)
			: base(other)
		{
		}

		public override XPathNavigator Advance()
		{
			while ((currentNode = qyInput.Advance()) != null)
			{
				if (matches(currentNode))
				{
					position = 1;
					return currentNode;
				}
			}
			return null;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathSelfQuery(this);
		}
	}
	internal class XPathSingletonIterator : ResetableIterator
	{
		private XPathNavigator nav;

		private int position;

		public override XPathNavigator Current => nav;

		public override int CurrentPosition => position;

		public override int Count => 1;

		public XPathSingletonIterator(XPathNavigator nav)
		{
			this.nav = nav;
		}

		public XPathSingletonIterator(XPathNavigator nav, bool moved)
			: this(nav)
		{
			if (moved)
			{
				position = 1;
			}
		}

		public XPathSingletonIterator(XPathSingletonIterator it)
		{
			nav = it.nav.Clone();
			position = it.position;
		}

		public override XPathNodeIterator Clone()
		{
			return new XPathSingletonIterator(this);
		}

		public override bool MoveNext()
		{
			if (position == 0)
			{
				position = 1;
				return true;
			}
			return false;
		}

		public override void Reset()
		{
			position = 0;
		}
	}
}
namespace System.Xml.Xsl
{
	public sealed class XslCompiledTransform
	{
		private const string Version = "2.0.0.0";

		private static readonly PermissionSet MemberAccessPermissionSet;

		private bool enableDebug;

		private CompilerResults compilerResults;

		private XmlWriterSettings outputSettings;

		private QilExpression qil;

		private XmlILCommand command;

		private static ConstructorInfo GeneratedCodeCtor;

		internal CompilerErrorCollection Errors
		{
			get
			{
				if (compilerResults == null)
				{
					return null;
				}
				return compilerResults.Errors;
			}
		}

		public XmlWriterSettings OutputSettings => outputSettings;

		public TempFileCollection TemporaryFiles
		{
			[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
			get
			{
				if (compilerResults == null)
				{
					return null;
				}
				return compilerResults.TempFiles;
			}
		}

		static XslCompiledTransform()
		{
			MemberAccessPermissionSet = new PermissionSet(PermissionState.None);
			MemberAccessPermissionSet.AddPermission(new ReflectionPermission(ReflectionPermissionFlag.MemberAccess));
		}

		public XslCompiledTransform()
		{
		}

		public XslCompiledTransform(bool enableDebug)
		{
			this.enableDebug = enableDebug;
		}

		private void Reset()
		{
			compilerResults = null;
			outputSettings = null;
			qil = null;
			command = null;
		}

		public void Load(XmlReader stylesheet)
		{
			Reset();
			LoadInternal(stylesheet, XsltSettings.Default, XsltConfigSection.CreateDefaultResolver());
		}

		public void Load(XmlReader stylesheet, XsltSettings settings, XmlResolver stylesheetResolver)
		{
			Reset();
			LoadInternal(stylesheet, settings, stylesheetResolver);
		}

		public void Load(IXPathNavigable stylesheet)
		{
			Reset();
			LoadInternal(stylesheet, XsltSettings.Default, XsltConfigSection.CreateDefaultResolver());
		}

		public void Load(IXPathNavigable stylesheet, XsltSettings settings, XmlResolver stylesheetResolver)
		{
			Reset();
			LoadInternal(stylesheet, settings, stylesheetResolver);
		}

		public void Load(string stylesheetUri)
		{
			Reset();
			if (stylesheetUri == null)
			{
				throw new ArgumentNullException("stylesheetUri");
			}
			LoadInternal(stylesheetUri, XsltSettings.Default, XsltConfigSection.CreateDefaultResolver());
		}

		public void Load(string stylesheetUri, XsltSettings settings, XmlResolver stylesheetResolver)
		{
			Reset();
			if (stylesheetUri == null)
			{
				throw new ArgumentNullException("stylesheetUri");
			}
			LoadInternal(stylesheetUri, settings, stylesheetResolver);
		}

		private CompilerResults LoadInternal(object stylesheet, XsltSettings settings, XmlResolver stylesheetResolver)
		{
			if (stylesheet == null)
			{
				throw new ArgumentNullException("stylesheet");
			}
			if (settings == null)
			{
				settings = XsltSettings.Default;
			}
			CompileXsltToQil(stylesheet, settings, stylesheetResolver);
			CompilerError firstError = GetFirstError();
			if (firstError != null)
			{
				throw new XslLoadException(firstError);
			}
			if (!settings.CheckOnly)
			{
				CompileQilToMsil(settings);
			}
			return compilerResults;
		}

		private void CompileXsltToQil(object stylesheet, XsltSettings settings, XmlResolver stylesheetResolver)
		{
			compilerResults = new System.Xml.Xsl.Xslt.Compiler(settings, enableDebug, null).Compile(stylesheet, stylesheetResolver, out qil);
		}

		private CompilerError GetFirstError()
		{
			foreach (CompilerError error in compilerResults.Errors)
			{
				if (!error.IsWarning)
				{
					return error;
				}
			}
			return null;
		}

		private void CompileQilToMsil(XsltSettings settings)
		{
			command = new XmlILGenerator().Generate(qil, null);
			outputSettings = command.StaticData.DefaultWriterSettings;
			qil = null;
		}

		public static CompilerErrorCollection CompileToType(XmlReader stylesheet, XsltSettings settings, XmlResolver stylesheetResolver, bool debug, TypeBuilder typeBuilder, string scriptAssemblyPath)
		{
			if (stylesheet == null)
			{
				throw new ArgumentNullException("stylesheet");
			}
			if (typeBuilder == null)
			{
				throw new ArgumentNullException("typeBuilder");
			}
			if (settings == null)
			{
				settings = XsltSettings.Default;
			}
			if (settings.EnableScript && scriptAssemblyPath == null)
			{
				throw new ArgumentNullException("scriptAssemblyPath");
			}
			if (scriptAssemblyPath != null)
			{
				scriptAssemblyPath = Path.GetFullPath(scriptAssemblyPath);
			}
			QilExpression query;
			CompilerErrorCollection errors = new System.Xml.Xsl.Xslt.Compiler(settings, debug, scriptAssemblyPath).Compile(stylesheet, stylesheetResolver, out query).Errors;
			if (!errors.HasErrors)
			{
				if (GeneratedCodeCtor == null)
				{
					GeneratedCodeCtor = typeof(GeneratedCodeAttribute).GetConstructor(new Type[2]
					{
						typeof(string),
						typeof(string)
					});
				}
				typeBuilder.SetCustomAttribute(new CustomAttributeBuilder(GeneratedCodeCtor, new object[2]
				{
					typeof(XslCompiledTransform).FullName,
					"2.0.0.0"
				}));
				new XmlILGenerator().Generate(query, typeBuilder);
			}
			return errors;
		}

		public void Load(Type compiledStylesheet)
		{
			Reset();
			if (compiledStylesheet == null)
			{
				throw new ArgumentNullException("compiledStylesheet");
			}
			object[] customAttributes = compiledStylesheet.GetCustomAttributes(typeof(GeneratedCodeAttribute), inherit: false);
			GeneratedCodeAttribute generatedCodeAttribute = ((customAttributes.Length > 0) ? ((GeneratedCodeAttribute)customAttributes[0]) : null);
			if (generatedCodeAttribute != null && generatedCodeAttribute.Tool == typeof(XslCompiledTransform).FullName && generatedCodeAttribute.Version == "2.0.0.0")
			{
				FieldInfo field = compiledStylesheet.GetField("staticData", BindingFlags.Static | BindingFlags.NonPublic);
				FieldInfo field2 = compiledStylesheet.GetField("ebTypes", BindingFlags.Static | BindingFlags.NonPublic);
				if (field != null && field2 != null)
				{
					if (XsltConfigSection.EnableMemberAccessForXslCompiledTransform)
					{
						new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Assert();
					}
					object obj = field.GetValue(null);
					if (obj is byte[] array)
					{
						lock (array)
						{
							obj = field.GetValue(null);
							if (obj == array)
							{
								MethodInfo method = compiledStylesheet.GetMethod("Execute", BindingFlags.Static | BindingFlags.NonPublic);
								Delegate @delegate = Delegate.CreateDelegate(typeof(ExecuteDelegate), method);
								obj = new XmlILCommand((ExecuteDelegate)@delegate, new XmlQueryStaticData(array, (Type[])field2.GetValue(null)));
								Thread.MemoryBarrier();
								field.SetValue(null, obj);
							}
						}
					}
					command = obj as XmlILCommand;
				}
			}
			if (command == null)
			{
				throw new ArgumentException(Res.GetString("Xslt_NotCompiledStylesheet", compiledStylesheet.FullName), "compiledStylesheet");
			}
			outputSettings = command.StaticData.DefaultWriterSettings;
		}

		public void Load(MethodInfo executeMethod, byte[] queryData, Type[] earlyBoundTypes)
		{
			Reset();
			if (executeMethod == null)
			{
				throw new ArgumentNullException("executeMethod");
			}
			if (queryData == null)
			{
				throw new ArgumentNullException("queryData");
			}
			if (!XsltConfigSection.EnableMemberAccessForXslCompiledTransform && executeMethod.DeclaringType != null && !executeMethod.DeclaringType.IsVisible)
			{
				new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Demand();
			}
			Delegate @delegate = ((executeMethod is DynamicMethod dynamicMethod) ? dynamicMethod.CreateDelegate(typeof(ExecuteDelegate)) : Delegate.CreateDelegate(typeof(ExecuteDelegate), executeMethod));
			command = new XmlILCommand((ExecuteDelegate)@delegate, new XmlQueryStaticData(queryData, earlyBoundTypes));
			outputSettings = command.StaticData.DefaultWriterSettings;
		}

		public void Transform(IXPathNavigable input, XmlWriter results)
		{
			CheckCommand();
			CheckInput(input);
			command.Execute(input, XsltConfigSection.CreateDefaultResolver(), null, results);
		}

		public void Transform(IXPathNavigable input, XsltArgumentList arguments, XmlWriter results)
		{
			CheckCommand();
			CheckInput(input);
			command.Execute(input, XsltConfigSection.CreateDefaultResolver(), arguments, results);
		}

		public void Transform(IXPathNavigable input, XsltArgumentList arguments, TextWriter results)
		{
			CheckCommand();
			CheckInput(input);
			command.Execute(input, XsltConfigSection.CreateDefaultResolver(), arguments, results);
		}

		public void Transform(IXPathNavigable input, XsltArgumentList arguments, Stream results)
		{
			CheckCommand();
			CheckInput(input);
			command.Execute(input, XsltConfigSection.CreateDefaultResolver(), arguments, results);
		}

		public void Transform(IXPathNavigable input, XsltArgumentList arguments, XmlWriter results, XmlResolver documentResolver)
		{
			CheckInput(input);
			CheckCommand();
			command.Execute(input, documentResolver, arguments, results);
		}

		public void Transform(XmlReader input, XmlWriter results)
		{
			CheckCommand();
			CheckInput(input);
			command.Execute(input, XsltConfigSection.CreateDefaultResolver(), null, results);
		}

		public void Transform(XmlReader input, XsltArgumentList arguments, XmlWriter results)
		{
			CheckCommand();
			CheckInput(input);
			command.Execute(input, XsltConfigSection.CreateDefaultResolver(), arguments, results);
		}

		public void Transform(XmlReader input, XsltArgumentList arguments, TextWriter results)
		{
			CheckCommand();
			CheckInput(input);
			command.Execute(input, XsltConfigSection.CreateDefaultResolver(), arguments, results);
		}

		public void Transform(XmlReader input, XsltArgumentList arguments, Stream results)
		{
			CheckCommand();
			CheckInput(input);
			command.Execute(input, XsltConfigSection.CreateDefaultResolver(), arguments, results);
		}

		public void Transform(XmlReader input, XsltArgumentList arguments, XmlWriter results, XmlResolver documentResolver)
		{
			CheckCommand();
			CheckInput(input);
			command.Execute(input, documentResolver, arguments, results);
		}

		public void Transform(string inputUri, string resultsFile)
		{
			CheckCommand();
			using XmlReader contextDocument = CreateReader(inputUri);
			if (resultsFile == null)
			{
				throw new ArgumentNullException("resultsFile");
			}
			using FileStream results = new FileStream(resultsFile, FileMode.Create, FileAccess.Write);
			command.Execute(contextDocument, XsltConfigSection.CreateDefaultResolver(), null, results);
		}

		public void Transform(string inputUri, XmlWriter results)
		{
			CheckCommand();
			using XmlReader contextDocument = CreateReader(inputUri);
			command.Execute(contextDocument, XsltConfigSection.CreateDefaultResolver(), null, results);
		}

		public void Transform(string inputUri, XsltArgumentList arguments, XmlWriter results)
		{
			CheckCommand();
			using XmlReader contextDocument = CreateReader(inputUri);
			command.Execute(contextDocument, XsltConfigSection.CreateDefaultResolver(), arguments, results);
		}

		public void Transform(string inputUri, XsltArgumentList arguments, TextWriter results)
		{
			CheckCommand();
			using XmlReader contextDocument = CreateReader(inputUri);
			command.Execute(contextDocument, XsltConfigSection.CreateDefaultResolver(), arguments, results);
		}

		public void Transform(string inputUri, XsltArgumentList arguments, Stream results)
		{
			CheckCommand();
			using XmlReader contextDocument = CreateReader(inputUri);
			command.Execute(contextDocument, XsltConfigSection.CreateDefaultResolver(), arguments, results);
		}

		private void CheckCommand()
		{
			if (command == null)
			{
				throw new InvalidOperationException(Res.GetString("Xslt_NoStylesheetLoaded"));
			}
		}

		private void CheckInput(object input)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
		}

		private XmlReader CreateReader(string inputUri)
		{
			if (inputUri == null)
			{
				throw new ArgumentNullException("inputUri");
			}
			return XmlReader.Create(inputUri);
		}

		private QilExpression TestCompile(object stylesheet, XsltSettings settings, XmlResolver stylesheetResolver)
		{
			Reset();
			CompileXsltToQil(stylesheet, settings, stylesheetResolver);
			return qil;
		}

		private void TestGenerate(XsltSettings settings)
		{
			CompileQilToMsil(settings);
		}

		private void Transform(string inputUri, XsltArgumentList arguments, XmlWriter results, XmlResolver documentResolver)
		{
			command.Execute(inputUri, documentResolver, arguments, results);
		}

		internal static void PrintQil(object qil, XmlWriter xw, bool printComments, bool printTypes, bool printLineInfo)
		{
			QilExpression node = (QilExpression)qil;
			QilXmlWriter.Options options = QilXmlWriter.Options.None;
			if (printComments)
			{
				options |= QilXmlWriter.Options.Annotations;
			}
			if (printTypes)
			{
				options |= QilXmlWriter.Options.TypeInfo;
			}
			if (printLineInfo)
			{
				options |= QilXmlWriter.Options.LineInfo;
			}
			QilXmlWriter qilXmlWriter = new QilXmlWriter(xw, options);
			qilXmlWriter.ToXml(node);
			xw.Flush();
		}
	}
	public abstract class XsltMessageEncounteredEventArgs : EventArgs
	{
		public abstract string Message { get; }
	}
	public delegate void XsltMessageEncounteredEventHandler(object sender, XsltMessageEncounteredEventArgs e);
	public class XsltArgumentList
	{
		private Hashtable parameters = new Hashtable();

		private Hashtable extensions = new Hashtable();

		internal XsltMessageEncounteredEventHandler xsltMessageEncountered;

		public event XsltMessageEncounteredEventHandler XsltMessageEncountered
		{
			add
			{
				xsltMessageEncountered = (XsltMessageEncounteredEventHandler)Delegate.Combine(xsltMessageEncountered, value);
			}
			remove
			{
				xsltMessageEncountered = (XsltMessageEncounteredEventHandler)Delegate.Remove(xsltMessageEncountered, value);
			}
		}

		public object GetParam(string name, string namespaceUri)
		{
			return parameters[new XmlQualifiedName(name, namespaceUri)];
		}

		public object GetExtensionObject(string namespaceUri)
		{
			return extensions[namespaceUri];
		}

		public void AddParam(string name, string namespaceUri, object parameter)
		{
			CheckArgumentNull(name, "name");
			CheckArgumentNull(namespaceUri, "namespaceUri");
			CheckArgumentNull(parameter, "parameter");
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(name, namespaceUri);
			xmlQualifiedName.Verify();
			parameters.Add(xmlQualifiedName, parameter);
		}

		public void AddExtensionObject(string namespaceUri, object extension)
		{
			CheckArgumentNull(namespaceUri, "namespaceUri");
			CheckArgumentNull(extension, "extension");
			extensions.Add(namespaceUri, extension);
		}

		public object RemoveParam(string name, string namespaceUri)
		{
			XmlQualifiedName key = new XmlQualifiedName(name, namespaceUri);
			object result = parameters[key];
			parameters.Remove(key);
			return result;
		}

		public object RemoveExtensionObject(string namespaceUri)
		{
			object result = extensions[namespaceUri];
			extensions.Remove(namespaceUri);
			return result;
		}

		public void Clear()
		{
			parameters.Clear();
			extensions.Clear();
			xsltMessageEncountered = null;
		}

		private static void CheckArgumentNull(object param, string paramName)
		{
			if (param == null)
			{
				throw new ArgumentNullException(paramName);
			}
		}
	}
	public interface IXsltContextFunction
	{
		int Minargs { get; }

		int Maxargs { get; }

		XPathResultType ReturnType { get; }

		XPathResultType[] ArgTypes { get; }

		object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext);
	}
	public interface IXsltContextVariable
	{
		bool IsLocal { get; }

		bool IsParam { get; }

		XPathResultType VariableType { get; }

		object Evaluate(XsltContext xsltContext);
	}
	[Serializable]
	public class XsltException : SystemException
	{
		private string res;

		private string[] args;

		private string sourceUri;

		private int lineNumber;

		private int linePosition;

		private string message;

		public virtual string SourceUri => sourceUri;

		public virtual int LineNumber => lineNumber;

		public virtual int LinePosition => linePosition;

		public override string Message
		{
			get
			{
				if (message != null)
				{
					return message;
				}
				return base.Message;
			}
		}

		protected XsltException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			res = (string)info.GetValue("res", typeof(string));
			args = (string[])info.GetValue("args", typeof(string[]));
			sourceUri = (string)info.GetValue("sourceUri", typeof(string));
			lineNumber = (int)info.GetValue("lineNumber", typeof(int));
			linePosition = (int)info.GetValue("linePosition", typeof(int));
			string text = null;
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				if (current.Name == "version")
				{
					text = (string)current.Value;
				}
			}
			if (text == null)
			{
				message = CreateMessage(res, args, sourceUri, lineNumber, linePosition);
			}
			else
			{
				message = null;
			}
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("res", res);
			info.AddValue("args", args);
			info.AddValue("sourceUri", sourceUri);
			info.AddValue("lineNumber", lineNumber);
			info.AddValue("linePosition", linePosition);
			info.AddValue("version", "2.0");
		}

		public XsltException()
			: this(string.Empty, null)
		{
		}

		public XsltException(string message)
			: this(message, null)
		{
		}

		public XsltException(string message, Exception innerException)
			: this("Xml_UserException", new string[1] { message }, null, 0, 0, innerException)
		{
		}

		internal static XsltException Create(string res, params string[] args)
		{
			return new XsltException(res, args, null, 0, 0, null);
		}

		internal static XsltException Create(string res, string[] args, Exception inner)
		{
			return new XsltException(res, args, null, 0, 0, inner);
		}

		internal XsltException(string res, string[] args, string sourceUri, int lineNumber, int linePosition, Exception inner)
			: base(CreateMessage(res, args, sourceUri, lineNumber, linePosition), inner)
		{
			base.HResult = -2146231998;
			this.res = res;
			this.sourceUri = sourceUri;
			this.lineNumber = lineNumber;
			this.linePosition = linePosition;
		}

		private static string CreateMessage(string res, string[] args, string sourceUri, int lineNumber, int linePosition)
		{
			try
			{
				string text = FormatMessage(res, args);
				if (res != "Xslt_CompileError" && lineNumber != 0)
				{
					text = text + " " + FormatMessage("Xml_ErrorFilePosition", sourceUri, lineNumber.ToString(CultureInfo.InvariantCulture), linePosition.ToString(CultureInfo.InvariantCulture));
				}
				return text;
			}
			catch (MissingManifestResourceException)
			{
				return "UNKNOWN(" + res + ")";
			}
		}

		private static string FormatMessage(string key, params string[] args)
		{
			string text = System.Xml.Utils.Res.GetString(key);
			if (text != null && args != null)
			{
				text = string.Format(CultureInfo.InvariantCulture, text, args);
			}
			return text;
		}
	}
	[Serializable]
	public class XsltCompileException : XsltException
	{
		protected XsltCompileException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
		}

		public XsltCompileException()
		{
		}

		public XsltCompileException(string message)
			: base(message)
		{
		}

		public XsltCompileException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public XsltCompileException(Exception inner, string sourceUri, int lineNumber, int linePosition)
			: base((lineNumber != 0) ? "Xslt_CompileError" : "Xslt_CompileError2", new string[3]
			{
				sourceUri,
				lineNumber.ToString(CultureInfo.InvariantCulture),
				linePosition.ToString(CultureInfo.InvariantCulture)
			}, sourceUri, lineNumber, linePosition, inner)
		{
		}
	}
	[Obsolete("This class has been deprecated. Please use System.Xml.Xsl.XslCompiledTransform instead. http://go.microsoft.com/fwlink/?linkid=14202")]
	public sealed class XslTransform
	{
		private class DebuggerAddapter : IXsltDebugger
		{
			private object unknownDebugger;

			private MethodInfo getBltIn;

			private MethodInfo onCompile;

			private MethodInfo onExecute;

			public DebuggerAddapter(object unknownDebugger)
			{
				this.unknownDebugger = unknownDebugger;
				BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
				Type type = unknownDebugger.GetType();
				getBltIn = type.GetMethod("GetBuiltInTemplatesUri", bindingAttr);
				onCompile = type.GetMethod("OnInstructionCompile", bindingAttr);
				onExecute = type.GetMethod("OnInstructionExecute", bindingAttr);
			}

			public string GetBuiltInTemplatesUri()
			{
				if (getBltIn == null)
				{
					return null;
				}
				return (string)getBltIn.Invoke(unknownDebugger, new object[0]);
			}

			public void OnInstructionCompile(XPathNavigator styleSheetNavigator)
			{
				if (onCompile != null)
				{
					onCompile.Invoke(unknownDebugger, new object[1] { styleSheetNavigator });
				}
			}

			public void OnInstructionExecute(IXsltProcessor xsltProcessor)
			{
				if (onExecute != null)
				{
					onExecute.Invoke(unknownDebugger, new object[1] { xsltProcessor });
				}
			}
		}

		private XmlResolver _documentResolver;

		private bool isDocumentResolverSet;

		private System.Xml.Xsl.XsltOld.Stylesheet _CompiledStylesheet;

		private List<TheQuery> _QueryStore;

		private RootAction _RootAction;

		private IXsltDebugger debugger;

		private XmlResolver _DocumentResolver
		{
			get
			{
				if (isDocumentResolverSet)
				{
					return _documentResolver;
				}
				return XsltConfigSection.CreateDefaultResolver();
			}
		}

		public XmlResolver XmlResolver
		{
			set
			{
				_documentResolver = value;
				isDocumentResolverSet = true;
			}
		}

		internal IXsltDebugger Debugger => debugger;

		public XslTransform()
		{
		}

		public void Load(XmlReader stylesheet)
		{
			Load(stylesheet, XsltConfigSection.CreateDefaultResolver());
		}

		public void Load(XmlReader stylesheet, XmlResolver resolver)
		{
			Load(new XPathDocument(stylesheet, XmlSpace.Preserve), resolver);
		}

		public void Load(IXPathNavigable stylesheet)
		{
			Load(stylesheet, XsltConfigSection.CreateDefaultResolver());
		}

		public void Load(IXPathNavigable stylesheet, XmlResolver resolver)
		{
			if (stylesheet == null)
			{
				throw new ArgumentNullException("stylesheet");
			}
			Load(stylesheet.CreateNavigator(), resolver);
		}

		public void Load(XPathNavigator stylesheet)
		{
			if (stylesheet == null)
			{
				throw new ArgumentNullException("stylesheet");
			}
			Load(stylesheet, XsltConfigSection.CreateDefaultResolver());
		}

		public void Load(XPathNavigator stylesheet, XmlResolver resolver)
		{
			if (stylesheet == null)
			{
				throw new ArgumentNullException("stylesheet");
			}
			if (resolver == null)
			{
				resolver = new XmlNullResolver();
			}
			Compile(stylesheet, resolver, null);
		}

		public void Load(string url)
		{
			XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl(url);
			Evidence evidence = XmlSecureResolver.CreateEvidenceForUrl(xmlTextReaderImpl.BaseURI);
			Compile(System.Xml.Xsl.XsltOld.Compiler.LoadDocument(xmlTextReaderImpl).CreateNavigator(), XsltConfigSection.CreateDefaultResolver(), evidence);
		}

		public void Load(string url, XmlResolver resolver)
		{
			XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl(url);
			xmlTextReaderImpl.XmlResolver = resolver;
			Evidence evidence = XmlSecureResolver.CreateEvidenceForUrl(xmlTextReaderImpl.BaseURI);
			if (resolver == null)
			{
				resolver = new XmlNullResolver();
			}
			Compile(System.Xml.Xsl.XsltOld.Compiler.LoadDocument(xmlTextReaderImpl).CreateNavigator(), resolver, evidence);
		}

		public void Load(IXPathNavigable stylesheet, XmlResolver resolver, Evidence evidence)
		{
			if (stylesheet == null)
			{
				throw new ArgumentNullException("stylesheet");
			}
			Load(stylesheet.CreateNavigator(), resolver, evidence);
		}

		public void Load(XmlReader stylesheet, XmlResolver resolver, Evidence evidence)
		{
			if (stylesheet == null)
			{
				throw new ArgumentNullException("stylesheet");
			}
			Load(new XPathDocument(stylesheet, XmlSpace.Preserve), resolver, evidence);
		}

		public void Load(XPathNavigator stylesheet, XmlResolver resolver, Evidence evidence)
		{
			if (stylesheet == null)
			{
				throw new ArgumentNullException("stylesheet");
			}
			if (resolver == null)
			{
				resolver = new XmlNullResolver();
			}
			if (evidence == null)
			{
				evidence = new Evidence();
			}
			else
			{
				new SecurityPermission(SecurityPermissionFlag.ControlEvidence).Demand();
			}
			Compile(stylesheet, resolver, evidence);
		}

		private void CheckCommand()
		{
			if (_CompiledStylesheet == null)
			{
				throw new InvalidOperationException(Res.GetString("Xslt_NoStylesheetLoaded"));
			}
		}

		public XmlReader Transform(XPathNavigator input, XsltArgumentList args, XmlResolver resolver)
		{
			CheckCommand();
			Processor processor = new Processor(input, args, resolver, _CompiledStylesheet, _QueryStore, _RootAction, debugger);
			return processor.StartReader();
		}

		public XmlReader Transform(XPathNavigator input, XsltArgumentList args)
		{
			return Transform(input, args, _DocumentResolver);
		}

		public void Transform(XPathNavigator input, XsltArgumentList args, XmlWriter output, XmlResolver resolver)
		{
			CheckCommand();
			Processor processor = new Processor(input, args, resolver, _CompiledStylesheet, _QueryStore, _RootAction, debugger);
			processor.Execute(output);
		}

		public void Transform(XPathNavigator input, XsltArgumentList args, XmlWriter output)
		{
			Transform(input, args, output, _DocumentResolver);
		}

		public void Transform(XPathNavigator input, XsltArgumentList args, Stream output, XmlResolver resolver)
		{
			CheckCommand();
			Processor processor = new Processor(input, args, resolver, _CompiledStylesheet, _QueryStore, _RootAction, debugger);
			processor.Execute(output);
		}

		public void Transform(XPathNavigator input, XsltArgumentList args, Stream output)
		{
			Transform(input, args, output, _DocumentResolver);
		}

		public void Transform(XPathNavigator input, XsltArgumentList args, TextWriter output, XmlResolver resolver)
		{
			CheckCommand();
			Processor processor = new Processor(input, args, resolver, _CompiledStylesheet, _QueryStore, _RootAction, debugger);
			processor.Execute(output);
		}

		public void Transform(XPathNavigator input, XsltArgumentList args, TextWriter output)
		{
			CheckCommand();
			Processor processor = new Processor(input, args, _DocumentResolver, _CompiledStylesheet, _QueryStore, _RootAction, debugger);
			processor.Execute(output);
		}

		public XmlReader Transform(IXPathNavigable input, XsltArgumentList args, XmlResolver resolver)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			return Transform(input.CreateNavigator(), args, resolver);
		}

		public XmlReader Transform(IXPathNavigable input, XsltArgumentList args)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			return Transform(input.CreateNavigator(), args, _DocumentResolver);
		}

		public void Transform(IXPathNavigable input, XsltArgumentList args, TextWriter output, XmlResolver resolver)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			Transform(input.CreateNavigator(), args, output, resolver);
		}

		public void Transform(IXPathNavigable input, XsltArgumentList args, TextWriter output)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			Transform(input.CreateNavigator(), args, output, _DocumentResolver);
		}

		public void Transform(IXPathNavigable input, XsltArgumentList args, Stream output, XmlResolver resolver)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			Transform(input.CreateNavigator(), args, output, resolver);
		}

		public void Transform(IXPathNavigable input, XsltArgumentList args, Stream output)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			Transform(input.CreateNavigator(), args, output, _DocumentResolver);
		}

		public void Transform(IXPathNavigable input, XsltArgumentList args, XmlWriter output, XmlResolver resolver)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			Transform(input.CreateNavigator(), args, output, resolver);
		}

		public void Transform(IXPathNavigable input, XsltArgumentList args, XmlWriter output)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			Transform(input.CreateNavigator(), args, output, _DocumentResolver);
		}

		public void Transform(string inputfile, string outputfile, XmlResolver resolver)
		{
			FileStream fileStream = null;
			try
			{
				XPathDocument input = new XPathDocument(inputfile);
				fileStream = new FileStream(outputfile, FileMode.Create, FileAccess.ReadWrite);
				Transform(input, null, fileStream, resolver);
			}
			finally
			{
				fileStream?.Close();
			}
		}

		public void Transform(string inputfile, string outputfile)
		{
			Transform(inputfile, outputfile, _DocumentResolver);
		}

		private void Compile(XPathNavigator stylesheet, XmlResolver resolver, Evidence evidence)
		{
			System.Xml.Xsl.XsltOld.Compiler compiler = ((Debugger == null) ? new System.Xml.Xsl.XsltOld.Compiler() : new DbgCompiler(Debugger));
			NavigatorInput input = new NavigatorInput(stylesheet);
			compiler.Compile(input, resolver, evidence);
			_CompiledStylesheet = compiler.CompiledStylesheet;
			_QueryStore = compiler.QueryStore;
			_RootAction = compiler.RootAction;
		}

		internal XslTransform(object debugger)
		{
			if (debugger != null)
			{
				this.debugger = new DebuggerAddapter(debugger);
			}
		}
	}
	public sealed class XsltSettings
	{
		private bool enableDocumentFunction;

		private bool enableScript;

		private bool checkOnly;

		private bool includeDebugInformation;

		private int warningLevel = -1;

		private bool treatWarningsAsErrors;

		private TempFileCollection tempFiles;

		public static XsltSettings Default => new XsltSettings(enableDocumentFunction: false, enableScript: false);

		public static XsltSettings TrustedXslt => new XsltSettings(enableDocumentFunction: true, enableScript: true);

		public bool EnableDocumentFunction
		{
			get
			{
				return enableDocumentFunction;
			}
			set
			{
				enableDocumentFunction = value;
			}
		}

		public bool EnableScript
		{
			get
			{
				return enableScript;
			}
			set
			{
				enableScript = value;
			}
		}

		internal bool CheckOnly
		{
			get
			{
				return checkOnly;
			}
			set
			{
				checkOnly = value;
			}
		}

		internal bool IncludeDebugInformation
		{
			get
			{
				return includeDebugInformation;
			}
			set
			{
				includeDebugInformation = value;
			}
		}

		internal int WarningLevel
		{
			get
			{
				return warningLevel;
			}
			set
			{
				warningLevel = value;
			}
		}

		internal bool TreatWarningsAsErrors
		{
			get
			{
				return treatWarningsAsErrors;
			}
			set
			{
				treatWarningsAsErrors = value;
			}
		}

		internal TempFileCollection TempFiles
		{
			get
			{
				return tempFiles;
			}
			set
			{
				tempFiles = value;
			}
		}

		public XsltSettings()
		{
		}

		public XsltSettings(bool enableDocumentFunction, bool enableScript)
		{
			this.enableDocumentFunction = enableDocumentFunction;
			this.enableScript = enableScript;
		}
	}
}
namespace System.Xml.Schema
{
	internal class AxisElement
	{
		internal DoubleLinkAxis curNode;

		internal int rootDepth;

		internal int curDepth;

		internal bool isMatch;

		internal DoubleLinkAxis CurNode => curNode;

		internal AxisElement(DoubleLinkAxis node, int depth)
		{
			curNode = node;
			rootDepth = (curDepth = depth);
			isMatch = false;
		}

		internal void SetDepth(int depth)
		{
			rootDepth = (curDepth = depth);
		}

		internal void MoveToParent(int depth, ForwardAxis parent)
		{
			if (depth == curDepth - 1)
			{
				if (curNode.Input == parent.RootNode && parent.IsDss)
				{
					curNode = parent.RootNode;
					rootDepth = (curDepth = -1);
				}
				else if (curNode.Input != null)
				{
					curNode = (DoubleLinkAxis)curNode.Input;
					curDepth--;
				}
			}
			else if (depth == curDepth && isMatch)
			{
				isMatch = false;
			}
		}

		internal bool MoveToChild(string name, string URN, int depth, ForwardAxis parent)
		{
			if (Asttree.IsAttribute(curNode))
			{
				return false;
			}
			if (isMatch)
			{
				isMatch = false;
			}
			if (!AxisStack.Equal(curNode.Name, curNode.Urn, name, URN))
			{
				return false;
			}
			if (curDepth == -1)
			{
				SetDepth(depth);
			}
			else if (depth > curDepth)
			{
				return false;
			}
			if (curNode == parent.TopNode)
			{
				isMatch = true;
				return true;
			}
			DoubleLinkAxis ast = (DoubleLinkAxis)curNode.Next;
			if (Asttree.IsAttribute(ast))
			{
				isMatch = true;
				return false;
			}
			curNode = ast;
			curDepth++;
			return false;
		}
	}
	internal class AxisStack
	{
		private ArrayList stack;

		private ForwardAxis subtree;

		private ActiveAxis parent;

		internal ForwardAxis Subtree => subtree;

		internal int Length => stack.Count;

		public AxisStack(ForwardAxis faxis, ActiveAxis parent)
		{
			subtree = faxis;
			stack = new ArrayList();
			this.parent = parent;
			if (!faxis.IsDss)
			{
				Push(1);
			}
		}

		internal void Push(int depth)
		{
			AxisElement value = new AxisElement(subtree.RootNode, depth);
			stack.Add(value);
		}

		internal void Pop()
		{
			stack.RemoveAt(Length - 1);
		}

		internal static bool Equal(string thisname, string thisURN, string name, string URN)
		{
			if (thisURN == null)
			{
				if (URN != null && URN.Length != 0)
				{
					return false;
				}
			}
			else if (thisURN.Length != 0 && thisURN != URN)
			{
				return false;
			}
			if (thisname.Length != 0 && thisname != name)
			{
				return false;
			}
			return true;
		}

		internal void MoveToParent(string name, string URN, int depth)
		{
			if (subtree.IsSelfAxis)
			{
				return;
			}
			foreach (AxisElement item in stack)
			{
				item.MoveToParent(depth, subtree);
			}
			if (subtree.IsDss && Equal(subtree.RootNode.Name, subtree.RootNode.Urn, name, URN))
			{
				Pop();
			}
		}

		internal bool MoveToChild(string name, string URN, int depth)
		{
			bool result = false;
			if (subtree.IsDss && Equal(subtree.RootNode.Name, subtree.RootNode.Urn, name, URN))
			{
				Push(-1);
			}
			foreach (AxisElement item in stack)
			{
				if (item.MoveToChild(name, URN, depth, subtree))
				{
					result = true;
				}
			}
			return result;
		}

		internal bool MoveToAttribute(string name, string URN, int depth)
		{
			if (!subtree.IsAttribute)
			{
				return false;
			}
			if (!Equal(subtree.TopNode.Name, subtree.TopNode.Urn, name, URN))
			{
				return false;
			}
			bool result = false;
			if (subtree.TopNode.Input == null)
			{
				if (!subtree.IsDss)
				{
					return depth == 1;
				}
				return true;
			}
			foreach (AxisElement item in stack)
			{
				if (item.isMatch && item.CurNode == subtree.TopNode.Input)
				{
					result = true;
				}
			}
			return result;
		}
	}
	internal class ActiveAxis
	{
		private int currentDepth;

		private bool isActive;

		private Asttree axisTree;

		private ArrayList axisStack;

		public int CurrentDepth => currentDepth;

		internal void Reactivate()
		{
			isActive = true;
			currentDepth = -1;
		}

		internal ActiveAxis(Asttree axisTree)
		{
			this.axisTree = axisTree;
			currentDepth = -1;
			axisStack = new ArrayList(axisTree.SubtreeArray.Count);
			foreach (ForwardAxis item in axisTree.SubtreeArray)
			{
				AxisStack value = new AxisStack(item, this);
				axisStack.Add(value);
			}
			isActive = true;
		}

		public bool MoveToStartElement(string localname, string URN)
		{
			if (!isActive)
			{
				return false;
			}
			currentDepth++;
			bool result = false;
			foreach (AxisStack item in this.axisStack)
			{
				if (item.Subtree.IsSelfAxis)
				{
					if (item.Subtree.IsDss || CurrentDepth == 0)
					{
						result = true;
					}
				}
				else if (CurrentDepth != 0 && item.MoveToChild(localname, URN, currentDepth))
				{
					result = true;
				}
			}
			return result;
		}

		public virtual bool EndElement(string localname, string URN)
		{
			if (currentDepth == 0)
			{
				isActive = false;
				currentDepth--;
			}
			if (!isActive)
			{
				return false;
			}
			foreach (AxisStack item in this.axisStack)
			{
				item.MoveToParent(localname, URN, currentDepth);
			}
			currentDepth--;
			return false;
		}

		public bool MoveToAttribute(string localname, string URN)
		{
			if (!isActive)
			{
				return false;
			}
			bool result = false;
			foreach (AxisStack item in this.axisStack)
			{
				if (item.MoveToAttribute(localname, URN, currentDepth + 1))
				{
					result = true;
				}
			}
			return result;
		}
	}
	internal class DoubleLinkAxis : Axis
	{
		internal Axis next;

		internal Axis Next
		{
			get
			{
				return next;
			}
			set
			{
				next = value;
			}
		}

		internal DoubleLinkAxis(Axis axis, DoubleLinkAxis inputaxis)
			: base(axis.TypeOfAxis, inputaxis, axis.Prefix, axis.Name, axis.NodeType)
		{
			next = null;
			base.Urn = axis.Urn;
			abbrAxis = axis.AbbrAxis;
			if (inputaxis != null)
			{
				inputaxis.Next = this;
			}
		}

		internal static DoubleLinkAxis ConvertTree(Axis axis)
		{
			if (axis == null)
			{
				return null;
			}
			return new DoubleLinkAxis(axis, ConvertTree((Axis)axis.Input));
		}
	}
	internal class ForwardAxis
	{
		private DoubleLinkAxis topNode;

		private DoubleLinkAxis rootNode;

		private bool isAttribute;

		private bool isDss;

		private bool isSelfAxis;

		internal DoubleLinkAxis RootNode => rootNode;

		internal DoubleLinkAxis TopNode => topNode;

		internal bool IsAttribute => isAttribute;

		internal bool IsDss => isDss;

		internal bool IsSelfAxis => isSelfAxis;

		public ForwardAxis(DoubleLinkAxis axis, bool isdesorself)
		{
			isDss = isdesorself;
			isAttribute = Asttree.IsAttribute(axis);
			topNode = axis;
			rootNode = axis;
			while (rootNode.Input != null)
			{
				rootNode = (DoubleLinkAxis)rootNode.Input;
			}
			isSelfAxis = Asttree.IsSelf(topNode);
		}
	}
	internal class Asttree
	{
		private ArrayList fAxisArray;

		private string xpathexpr;

		private bool isField;

		private XmlNamespaceManager nsmgr;

		internal ArrayList SubtreeArray => fAxisArray;

		public Asttree(string xPath, bool isField, XmlNamespaceManager nsmgr)
		{
			xpathexpr = xPath;
			this.isField = isField;
			this.nsmgr = nsmgr;
			CompileXPath(xPath, isField, nsmgr);
		}

		private static bool IsNameTest(Axis ast)
		{
			if (ast.TypeOfAxis == Axis.AxisType.Child)
			{
				return ast.NodeType == XPathNodeType.Element;
			}
			return false;
		}

		internal static bool IsAttribute(Axis ast)
		{
			if (ast.TypeOfAxis == Axis.AxisType.Attribute)
			{
				return ast.NodeType == XPathNodeType.Attribute;
			}
			return false;
		}

		private static bool IsDescendantOrSelf(Axis ast)
		{
			if (ast.TypeOfAxis == Axis.AxisType.DescendantOrSelf && ast.NodeType == XPathNodeType.All)
			{
				return ast.AbbrAxis;
			}
			return false;
		}

		internal static bool IsSelf(Axis ast)
		{
			if (ast.TypeOfAxis == Axis.AxisType.Self && ast.NodeType == XPathNodeType.All)
			{
				return ast.AbbrAxis;
			}
			return false;
		}

		public void CompileXPath(string xPath, bool isField, XmlNamespaceManager nsmgr)
		{
			if (xPath == null || xPath.Length == 0)
			{
				throw new XmlSchemaException("Sch_EmptyXPath", string.Empty);
			}
			string[] array = xPath.Split('|');
			ArrayList arrayList = new ArrayList(array.Length);
			fAxisArray = new ArrayList(array.Length);
			try
			{
				string[] array2 = array;
				foreach (string xpathExpresion in array2)
				{
					Axis value = (Axis)XPathParser.ParseXPathExpresion(xpathExpresion);
					arrayList.Add(value);
				}
			}
			catch
			{
				throw new XmlSchemaException("Sch_ICXpathError", xPath);
			}
			foreach (Axis item in arrayList)
			{
				Axis axis2;
				if ((axis2 = item) == null)
				{
					throw new XmlSchemaException("Sch_ICXpathError", xPath);
				}
				Axis axis3 = axis2;
				if (IsAttribute(axis2))
				{
					if (!isField)
					{
						throw new XmlSchemaException("Sch_SelectorAttr", xPath);
					}
					SetURN(axis2, nsmgr);
					try
					{
						axis2 = (Axis)axis2.Input;
					}
					catch
					{
						throw new XmlSchemaException("Sch_ICXpathError", xPath);
					}
				}
				while (axis2 != null && (IsNameTest(axis2) || IsSelf(axis2)))
				{
					if (IsSelf(axis2) && item != axis2)
					{
						axis3.Input = axis2.Input;
					}
					else
					{
						axis3 = axis2;
						if (IsNameTest(axis2))
						{
							SetURN(axis2, nsmgr);
						}
					}
					try
					{
						axis2 = (Axis)axis2.Input;
					}
					catch
					{
						throw new XmlSchemaException("Sch_ICXpathError", xPath);
					}
				}
				axis3.Input = null;
				if (axis2 == null)
				{
					if (IsSelf(item) && item.Input != null)
					{
						fAxisArray.Add(new ForwardAxis(DoubleLinkAxis.ConvertTree((Axis)item.Input), isdesorself: false));
					}
					else
					{
						fAxisArray.Add(new ForwardAxis(DoubleLinkAxis.ConvertTree(item), isdesorself: false));
					}
					continue;
				}
				if (!IsDescendantOrSelf(axis2))
				{
					throw new XmlSchemaException("Sch_ICXpathError", xPath);
				}
				try
				{
					axis2 = (Axis)axis2.Input;
				}
				catch
				{
					throw new XmlSchemaException("Sch_ICXpathError", xPath);
				}
				if (axis2 == null || !IsSelf(axis2) || axis2.Input != null)
				{
					throw new XmlSchemaException("Sch_ICXpathError", xPath);
				}
				if (IsSelf(item) && item.Input != null)
				{
					fAxisArray.Add(new ForwardAxis(DoubleLinkAxis.ConvertTree((Axis)item.Input), isdesorself: true));
				}
				else
				{
					fAxisArray.Add(new ForwardAxis(DoubleLinkAxis.ConvertTree(item), isdesorself: true));
				}
			}
		}

		private void SetURN(Axis axis, XmlNamespaceManager nsmgr)
		{
			if (axis.Prefix.Length != 0)
			{
				axis.Urn = nsmgr.LookupNamespace(axis.Prefix);
				if (axis.Urn == null)
				{
					throw new XmlSchemaException("Sch_UnresolvedPrefix", axis.Prefix);
				}
			}
			else if (axis.Name.Length != 0)
			{
				axis.Urn = null;
			}
			else
			{
				axis.Urn = "";
			}
		}
	}
	internal class BaseValidator
	{
		private XmlSchemaCollection schemaCollection;

		private ValidationEventHandler eventHandler;

		private XmlNameTable nameTable;

		private SchemaNames schemaNames;

		private PositionInfo positionInfo;

		private XmlResolver xmlResolver;

		private Uri baseUri;

		protected SchemaInfo schemaInfo;

		protected XmlValidatingReaderImpl reader;

		protected XmlQualifiedName elementName;

		protected ValidationState context;

		protected StringBuilder textValue;

		protected string textString;

		protected bool hasSibling;

		protected bool checkDatatype;

		public XmlValidatingReaderImpl Reader => reader;

		public XmlSchemaCollection SchemaCollection => schemaCollection;

		public XmlNameTable NameTable => nameTable;

		public SchemaNames SchemaNames
		{
			get
			{
				if (schemaNames != null)
				{
					return schemaNames;
				}
				if (schemaCollection != null)
				{
					schemaNames = schemaCollection.GetSchemaNames(nameTable);
				}
				else
				{
					schemaNames = new SchemaNames(nameTable);
				}
				return schemaNames;
			}
		}

		public PositionInfo PositionInfo => positionInfo;

		public XmlResolver XmlResolver
		{
			get
			{
				return xmlResolver;
			}
			set
			{
				xmlResolver = value;
			}
		}

		public Uri BaseUri
		{
			get
			{
				return baseUri;
			}
			set
			{
				baseUri = value;
			}
		}

		public ValidationEventHandler EventHandler
		{
			get
			{
				return eventHandler;
			}
			set
			{
				eventHandler = value;
			}
		}

		public SchemaInfo SchemaInfo
		{
			get
			{
				return schemaInfo;
			}
			set
			{
				schemaInfo = value;
			}
		}

		public virtual bool PreserveWhitespace => false;

		public BaseValidator(BaseValidator other)
		{
			reader = other.reader;
			schemaCollection = other.schemaCollection;
			eventHandler = other.eventHandler;
			nameTable = other.nameTable;
			schemaNames = other.schemaNames;
			positionInfo = other.positionInfo;
			xmlResolver = other.xmlResolver;
			baseUri = other.baseUri;
			elementName = other.elementName;
		}

		public BaseValidator(XmlValidatingReaderImpl reader, XmlSchemaCollection schemaCollection, ValidationEventHandler eventHandler)
		{
			this.reader = reader;
			this.schemaCollection = schemaCollection;
			this.eventHandler = eventHandler;
			nameTable = reader.NameTable;
			positionInfo = PositionInfo.GetPositionInfo(reader);
			elementName = new XmlQualifiedName();
		}

		public virtual void Validate()
		{
		}

		public virtual void CompleteValidation()
		{
		}

		public virtual object FindId(string name)
		{
			return null;
		}

		public void ValidateText()
		{
			if (!context.NeedValidateChildren)
			{
				return;
			}
			if (context.IsNill)
			{
				SendValidationEvent("Sch_ContentInNill", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
				return;
			}
			ContentValidator contentValidator = context.ElementDecl.ContentValidator;
			switch (contentValidator.ContentType)
			{
			case XmlSchemaContentType.ElementOnly:
			{
				ArrayList arrayList = contentValidator.ExpectedElements(context, isRequiredOnly: false);
				if (arrayList == null)
				{
					SendValidationEvent("Sch_InvalidTextInElement", XmlSchemaValidator.BuildElementName(context.LocalName, context.Namespace));
					break;
				}
				SendValidationEvent("Sch_InvalidTextInElementExpecting", new string[2]
				{
					XmlSchemaValidator.BuildElementName(context.LocalName, context.Namespace),
					XmlSchemaValidator.PrintExpectedElements(arrayList, getParticles: false)
				});
				break;
			}
			case XmlSchemaContentType.Empty:
				SendValidationEvent("Sch_InvalidTextInEmpty", string.Empty);
				break;
			}
			if (checkDatatype)
			{
				SaveTextValue(reader.Value);
			}
		}

		public void ValidateWhitespace()
		{
			if (context.NeedValidateChildren)
			{
				XmlSchemaContentType contentType = context.ElementDecl.ContentValidator.ContentType;
				if (context.IsNill)
				{
					SendValidationEvent("Sch_ContentInNill", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
				}
				if (contentType == XmlSchemaContentType.Empty)
				{
					SendValidationEvent("Sch_InvalidWhitespaceInEmpty", string.Empty);
				}
			}
		}

		private void SaveTextValue(string value)
		{
			if (textString.Length == 0)
			{
				textString = value;
				return;
			}
			if (!hasSibling)
			{
				textValue.Append(textString);
				hasSibling = true;
			}
			textValue.Append(value);
		}

		protected void SendValidationEvent(string code)
		{
			SendValidationEvent(code, string.Empty);
		}

		protected void SendValidationEvent(string code, string[] args)
		{
			SendValidationEvent(new XmlSchemaException(code, args, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition));
		}

		protected void SendValidationEvent(string code, string arg)
		{
			SendValidationEvent(new XmlSchemaException(code, arg, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition));
		}

		protected void SendValidationEvent(string code, string arg1, string arg2)
		{
			SendValidationEvent(new XmlSchemaException(code, new string[2] { arg1, arg2 }, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition));
		}

		protected void SendValidationEvent(XmlSchemaException e)
		{
			SendValidationEvent(e, XmlSeverityType.Error);
		}

		protected void SendValidationEvent(string code, string msg, XmlSeverityType severity)
		{
			SendValidationEvent(new XmlSchemaException(code, msg, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition), severity);
		}

		protected void SendValidationEvent(string code, string[] args, XmlSeverityType severity)
		{
			SendValidationEvent(new XmlSchemaException(code, args, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition), severity);
		}

		protected void SendValidationEvent(XmlSchemaException e, XmlSeverityType severity)
		{
			if (eventHandler != null)
			{
				eventHandler(reader, new ValidationEventArgs(e, severity));
			}
			else if (severity == XmlSeverityType.Error)
			{
				throw e;
			}
		}

		protected static void ProcessEntity(SchemaInfo sinfo, string name, object sender, ValidationEventHandler eventhandler, string baseUri, int lineNumber, int linePosition)
		{
			SchemaEntity schemaEntity = (SchemaEntity)sinfo.GeneralEntities[new XmlQualifiedName(name)];
			XmlSchemaException ex = null;
			if (schemaEntity == null)
			{
				ex = new XmlSchemaException("Sch_UndeclaredEntity", name, baseUri, lineNumber, linePosition);
			}
			else if (schemaEntity.NData.IsEmpty)
			{
				ex = new XmlSchemaException("Sch_UnparsedEntityRef", name, baseUri, lineNumber, linePosition);
			}
			if (ex != null)
			{
				if (eventhandler == null)
				{
					throw ex;
				}
				eventhandler(sender, new ValidationEventArgs(ex));
			}
		}

		public static BaseValidator CreateInstance(ValidationType valType, XmlValidatingReaderImpl reader, XmlSchemaCollection schemaCollection, ValidationEventHandler eventHandler, bool processIdentityConstraints)
		{
			return valType switch
			{
				ValidationType.XDR => new XdrValidator(reader, schemaCollection, eventHandler), 
				ValidationType.Schema => new XsdValidator(reader, schemaCollection, eventHandler), 
				ValidationType.DTD => new DtdValidator(reader, eventHandler, processIdentityConstraints), 
				ValidationType.Auto => new AutoValidator(reader, schemaCollection, eventHandler), 
				ValidationType.None => new BaseValidator(reader, schemaCollection, eventHandler), 
				_ => null, 
			};
		}
	}
	internal class AutoValidator : BaseValidator
	{
		private const string x_schema = "x-schema";

		public override bool PreserveWhitespace => false;

		public AutoValidator(XmlValidatingReaderImpl reader, XmlSchemaCollection schemaCollection, ValidationEventHandler eventHandler)
			: base(reader, schemaCollection, eventHandler)
		{
			schemaInfo = new SchemaInfo();
		}

		public override void Validate()
		{
			switch (DetectValidationType())
			{
			case ValidationType.XDR:
				reader.Validator = new XdrValidator(this);
				reader.Validator.Validate();
				break;
			case ValidationType.Schema:
				reader.Validator = new XsdValidator(this);
				reader.Validator.Validate();
				break;
			case ValidationType.Auto:
			case ValidationType.DTD:
				break;
			}
		}

		public override void CompleteValidation()
		{
		}

		public override object FindId(string name)
		{
			return null;
		}

		private ValidationType DetectValidationType()
		{
			if (reader.Schemas != null && reader.Schemas.Count > 0)
			{
				XmlSchemaCollectionEnumerator enumerator = reader.Schemas.GetEnumerator();
				while (enumerator.MoveNext())
				{
					XmlSchemaCollectionNode currentNode = enumerator.CurrentNode;
					SchemaInfo schemaInfo = currentNode.SchemaInfo;
					if (schemaInfo.SchemaType == SchemaType.XSD)
					{
						return ValidationType.Schema;
					}
					if (schemaInfo.SchemaType == SchemaType.XDR)
					{
						return ValidationType.XDR;
					}
				}
			}
			if (reader.NodeType == XmlNodeType.Element)
			{
				switch (base.SchemaNames.SchemaTypeFromRoot(reader.LocalName, reader.NamespaceURI))
				{
				case SchemaType.XSD:
					return ValidationType.Schema;
				case SchemaType.XDR:
					return ValidationType.XDR;
				}
				int attributeCount = reader.AttributeCount;
				for (int i = 0; i < attributeCount; i++)
				{
					reader.MoveToAttribute(i);
					string namespaceURI = reader.NamespaceURI;
					string localName = reader.LocalName;
					if (Ref.Equal(namespaceURI, base.SchemaNames.NsXmlNs))
					{
						if (XdrBuilder.IsXdrSchema(reader.Value))
						{
							reader.MoveToElement();
							return ValidationType.XDR;
						}
						continue;
					}
					if (Ref.Equal(namespaceURI, base.SchemaNames.NsXsi))
					{
						reader.MoveToElement();
						return ValidationType.Schema;
					}
					if (Ref.Equal(namespaceURI, base.SchemaNames.QnDtDt.Namespace) && Ref.Equal(localName, base.SchemaNames.QnDtDt.Name))
					{
						reader.SchemaTypeObject = XmlSchemaDatatype.FromXdrName(reader.Value);
						reader.MoveToElement();
						return ValidationType.XDR;
					}
				}
				if (attributeCount > 0)
				{
					reader.MoveToElement();
				}
			}
			return ValidationType.Auto;
		}
	}
	internal class BaseProcessor
	{
		private XmlNameTable nameTable;

		private SchemaNames schemaNames;

		private ValidationEventHandler eventHandler;

		private XmlSchemaCompilationSettings compilationSettings;

		private int errorCount;

		private string NsXml;

		protected XmlNameTable NameTable => nameTable;

		protected SchemaNames SchemaNames
		{
			get
			{
				if (schemaNames == null)
				{
					schemaNames = new SchemaNames(nameTable);
				}
				return schemaNames;
			}
		}

		protected ValidationEventHandler EventHandler => eventHandler;

		protected XmlSchemaCompilationSettings CompilationSettings => compilationSettings;

		protected bool HasErrors => errorCount != 0;

		public BaseProcessor(XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler eventHandler)
			: this(nameTable, schemaNames, eventHandler, new XmlSchemaCompilationSettings())
		{
		}

		public BaseProcessor(XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler eventHandler, XmlSchemaCompilationSettings compilationSettings)
		{
			this.nameTable = nameTable;
			this.schemaNames = schemaNames;
			this.eventHandler = eventHandler;
			this.compilationSettings = compilationSettings;
			NsXml = nameTable.Add("http://www.w3.org/XML/1998/namespace");
		}

		protected void AddToTable(XmlSchemaObjectTable table, XmlQualifiedName qname, XmlSchemaObject item)
		{
			if (qname.Name.Length == 0)
			{
				return;
			}
			XmlSchemaObject xmlSchemaObject = table[qname];
			if (xmlSchemaObject != null)
			{
				if (xmlSchemaObject == item)
				{
					return;
				}
				string code = "Sch_DupGlobalElement";
				if (item is XmlSchemaAttributeGroup)
				{
					string strA = nameTable.Add(qname.Namespace);
					if (Ref.Equal(strA, NsXml))
					{
						XmlSchema buildInSchema = Preprocessor.GetBuildInSchema();
						XmlSchemaObject xmlSchemaObject2 = buildInSchema.AttributeGroups[qname];
						if (xmlSchemaObject == xmlSchemaObject2)
						{
							table.Insert(qname, item);
							return;
						}
						if (item == xmlSchemaObject2)
						{
							return;
						}
					}
					else if (IsValidAttributeGroupRedefine(xmlSchemaObject, item, table))
					{
						return;
					}
					code = "Sch_DupAttributeGroup";
				}
				else if (item is XmlSchemaAttribute)
				{
					string strA2 = nameTable.Add(qname.Namespace);
					if (Ref.Equal(strA2, NsXml))
					{
						XmlSchema buildInSchema2 = Preprocessor.GetBuildInSchema();
						XmlSchemaObject xmlSchemaObject3 = buildInSchema2.Attributes[qname];
						if (xmlSchemaObject == xmlSchemaObject3)
						{
							table.Insert(qname, item);
							return;
						}
						if (item == xmlSchemaObject3)
						{
							return;
						}
					}
					code = "Sch_DupGlobalAttribute";
				}
				else if (item is XmlSchemaSimpleType)
				{
					if (IsValidTypeRedefine(xmlSchemaObject, item, table))
					{
						return;
					}
					code = "Sch_DupSimpleType";
				}
				else if (item is XmlSchemaComplexType)
				{
					if (IsValidTypeRedefine(xmlSchemaObject, item, table))
					{
						return;
					}
					code = "Sch_DupComplexType";
				}
				else if (item is XmlSchemaGroup)
				{
					if (IsValidGroupRedefine(xmlSchemaObject, item, table))
					{
						return;
					}
					code = "Sch_DupGroup";
				}
				else if (item is XmlSchemaNotation)
				{
					code = "Sch_DupNotation";
				}
				else if (item is XmlSchemaIdentityConstraint)
				{
					code = "Sch_DupIdentityConstraint";
				}
				SendValidationEvent(code, qname.ToString(), item);
			}
			else
			{
				table.Add(qname, item);
			}
		}

		private bool IsValidAttributeGroupRedefine(XmlSchemaObject existingObject, XmlSchemaObject item, XmlSchemaObjectTable table)
		{
			XmlSchemaAttributeGroup xmlSchemaAttributeGroup = item as XmlSchemaAttributeGroup;
			XmlSchemaAttributeGroup xmlSchemaAttributeGroup2 = existingObject as XmlSchemaAttributeGroup;
			if (xmlSchemaAttributeGroup2 == xmlSchemaAttributeGroup.Redefined)
			{
				if (xmlSchemaAttributeGroup2.AttributeUses.Count == 0)
				{
					table.Insert(xmlSchemaAttributeGroup.QualifiedName, xmlSchemaAttributeGroup);
					return true;
				}
			}
			else if (xmlSchemaAttributeGroup2.Redefined == xmlSchemaAttributeGroup)
			{
				return true;
			}
			return false;
		}

		private bool IsValidGroupRedefine(XmlSchemaObject existingObject, XmlSchemaObject item, XmlSchemaObjectTable table)
		{
			XmlSchemaGroup xmlSchemaGroup = item as XmlSchemaGroup;
			XmlSchemaGroup xmlSchemaGroup2 = existingObject as XmlSchemaGroup;
			if (xmlSchemaGroup2 == xmlSchemaGroup.Redefined)
			{
				if (xmlSchemaGroup2.CanonicalParticle == null)
				{
					table.Insert(xmlSchemaGroup.QualifiedName, xmlSchemaGroup);
					return true;
				}
			}
			else if (xmlSchemaGroup2.Redefined == xmlSchemaGroup)
			{
				return true;
			}
			return false;
		}

		private bool IsValidTypeRedefine(XmlSchemaObject existingObject, XmlSchemaObject item, XmlSchemaObjectTable table)
		{
			XmlSchemaType xmlSchemaType = item as XmlSchemaType;
			XmlSchemaType xmlSchemaType2 = existingObject as XmlSchemaType;
			if (xmlSchemaType2 == xmlSchemaType.Redefined)
			{
				if (xmlSchemaType2.ElementDecl == null)
				{
					table.Insert(xmlSchemaType.QualifiedName, xmlSchemaType);
					return true;
				}
			}
			else if (xmlSchemaType2.Redefined == xmlSchemaType)
			{
				return true;
			}
			return false;
		}

		protected void SendValidationEvent(string code, XmlSchemaObject source)
		{
			SendValidationEvent(new XmlSchemaException(code, source), XmlSeverityType.Error);
		}

		protected void SendValidationEvent(string code, string msg, XmlSchemaObject source)
		{
			SendValidationEvent(new XmlSchemaException(code, msg, source), XmlSeverityType.Error);
		}

		protected void SendValidationEvent(string code, string msg1, string msg2, XmlSchemaObject source)
		{
			SendValidationEvent(new XmlSchemaException(code, new string[2] { msg1, msg2 }, source), XmlSeverityType.Error);
		}

		protected void SendValidationEvent(string code, string[] args, Exception innerException, XmlSchemaObject source)
		{
			SendValidationEvent(new XmlSchemaException(code, args, innerException, source.SourceUri, source.LineNumber, source.LinePosition, source), XmlSeverityType.Error);
		}

		protected void SendValidationEvent(string code, string msg1, string msg2, string sourceUri, int lineNumber, int linePosition)
		{
			SendValidationEvent(new XmlSchemaException(code, new string[2] { msg1, msg2 }, sourceUri, lineNumber, linePosition), XmlSeverityType.Error);
		}

		protected void SendValidationEvent(string code, XmlSchemaObject source, XmlSeverityType severity)
		{
			SendValidationEvent(new XmlSchemaException(code, source), severity);
		}

		protected void SendValidationEvent(XmlSchemaException e)
		{
			SendValidationEvent(e, XmlSeverityType.Error);
		}

		protected void SendValidationEvent(string code, string msg, XmlSchemaObject source, XmlSeverityType severity)
		{
			SendValidationEvent(new XmlSchemaException(code, msg, source), severity);
		}

		protected void SendValidationEvent(XmlSchemaException e, XmlSeverityType severity)
		{
			if (severity == XmlSeverityType.Error)
			{
				errorCount++;
			}
			if (eventHandler != null)
			{
				eventHandler(null, new ValidationEventArgs(e, severity));
			}
			else if (severity == XmlSeverityType.Error)
			{
				throw e;
			}
		}

		protected void SendValidationEventNoThrow(XmlSchemaException e, XmlSeverityType severity)
		{
			if (severity == XmlSeverityType.Error)
			{
				errorCount++;
			}
			if (eventHandler != null)
			{
				eventHandler(null, new ValidationEventArgs(e, severity));
			}
		}
	}
	internal sealed class BitSet
	{
		private const int bitSlotShift = 5;

		private const int bitSlotMask = 31;

		private int count;

		private uint[] bits;

		public int Count => count;

		public bool this[int index] => Get(index);

		public bool IsEmpty
		{
			get
			{
				uint num = 0u;
				for (int i = 0; i < bits.Length; i++)
				{
					num |= bits[i];
				}
				return num == 0;
			}
		}

		private BitSet()
		{
		}

		public BitSet(int count)
		{
			this.count = count;
			bits = new uint[Subscript(count + 31)];
		}

		public void Clear()
		{
			int num = bits.Length;
			int num2 = num;
			while (num2-- > 0)
			{
				bits[num2] = 0u;
			}
		}

		public void Clear(int index)
		{
			int num = Subscript(index);
			EnsureLength(num + 1);
			bits[num] &= (uint)(~(1 << index));
		}

		public void Set(int index)
		{
			int num = Subscript(index);
			EnsureLength(num + 1);
			bits[num] |= (uint)(1 << index);
		}

		public bool Get(int index)
		{
			bool result = false;
			if (index < count)
			{
				int num = Subscript(index);
				result = (bits[num] & (1 << (index & 0x1F))) != 0;
			}
			return result;
		}

		public int NextSet(int startFrom)
		{
			int num = startFrom + 1;
			if (num == count)
			{
				return -1;
			}
			int num2 = Subscript(num);
			num &= 0x1F;
			uint num3;
			for (num3 = bits[num2] >> num; num3 == 0; num3 = bits[num2])
			{
				if (++num2 == bits.Length)
				{
					return -1;
				}
				num = 0;
			}
			while ((num3 & 1) == 0)
			{
				num3 >>= 1;
				num++;
			}
			return (num2 << 5) + num;
		}

		public void And(BitSet other)
		{
			if (this != other)
			{
				int num = bits.Length;
				int num2 = other.bits.Length;
				int i = ((num > num2) ? num2 : num);
				int num3 = i;
				while (num3-- > 0)
				{
					bits[num3] &= other.bits[num3];
				}
				for (; i < num; i++)
				{
					bits[i] = 0u;
				}
			}
		}

		public void Or(BitSet other)
		{
			if (this != other)
			{
				int num = other.bits.Length;
				EnsureLength(num);
				int num2 = num;
				while (num2-- > 0)
				{
					bits[num2] |= other.bits[num2];
				}
			}
		}

		public override int GetHashCode()
		{
			int num = 1234;
			int num2 = bits.Length;
			while (--num2 >= 0)
			{
				num ^= (int)bits[num2] * (num2 + 1);
			}
			return num ^ num;
		}

		public override bool Equals(object obj)
		{
			if (obj != null)
			{
				if (this == obj)
				{
					return true;
				}
				BitSet bitSet = (BitSet)obj;
				int num = bits.Length;
				int num2 = bitSet.bits.Length;
				int num3 = ((num > num2) ? num2 : num);
				int num4 = num3;
				while (num4-- > 0)
				{
					if (bits[num4] != bitSet.bits[num4])
					{
						return false;
					}
				}
				if (num > num3)
				{
					int num5 = num;
					while (num5-- > num3)
					{
						if (bits[num5] != 0)
						{
							return false;
						}
					}
				}
				else
				{
					int num6 = num2;
					while (num6-- > num3)
					{
						if (bitSet.bits[num6] != 0)
						{
							return false;
						}
					}
				}
				return true;
			}
			return false;
		}

		public BitSet Clone()
		{
			BitSet bitSet = new BitSet();
			bitSet.count = count;
			bitSet.bits = (uint[])bits.Clone();
			return bitSet;
		}

		public bool Intersects(BitSet other)
		{
			int num = Math.Min(bits.Length, other.bits.Length);
			while (--num >= 0)
			{
				if ((bits[num] & other.bits[num]) != 0)
				{
					return true;
				}
			}
			return false;
		}

		private int Subscript(int bitIndex)
		{
			return bitIndex >> 5;
		}

		private void EnsureLength(int nRequiredLength)
		{
			if (nRequiredLength > bits.Length)
			{
				int num = 2 * bits.Length;
				if (num < nRequiredLength)
				{
					num = nRequiredLength;
				}
				uint[] destinationArray = new uint[num];
				Array.Copy(bits, destinationArray, bits.Length);
				bits = destinationArray;
			}
		}
	}
	internal class ChameleonKey
	{
		internal string targetNS;

		internal Uri chameleonLocation;

		private int hashCode;

		public ChameleonKey(string ns, Uri location)
		{
			targetNS = ns;
			chameleonLocation = location;
		}

		public override int GetHashCode()
		{
			if (hashCode == 0)
			{
				hashCode = targetNS.GetHashCode() + chameleonLocation.GetHashCode();
			}
			return hashCode;
		}

		public override bool Equals(object obj)
		{
			if (object.ReferenceEquals(this, obj))
			{
				return true;
			}
			if (obj is ChameleonKey chameleonKey)
			{
				if (targetNS.Equals(chameleonKey.targetNS))
				{
					return chameleonLocation.Equals(chameleonKey.chameleonLocation);
				}
				return false;
			}
			return false;
		}
	}
	internal class CompiledIdentityConstraint
	{
		public enum ConstraintRole
		{
			Unique,
			Key,
			Keyref
		}

		internal XmlQualifiedName name = XmlQualifiedName.Empty;

		private ConstraintRole role;

		private Asttree selector;

		private Asttree[] fields;

		internal XmlQualifiedName refer = XmlQualifiedName.Empty;

		public static readonly CompiledIdentityConstraint Empty = new CompiledIdentityConstraint();

		public ConstraintRole Role => role;

		public Asttree Selector => selector;

		public Asttree[] Fields => fields;

		private CompiledIdentityConstraint()
		{
		}

		public CompiledIdentityConstraint(XmlSchemaIdentityConstraint constraint, XmlNamespaceManager nsmgr)
		{
			name = constraint.QualifiedName;
			try
			{
				selector = new Asttree(constraint.Selector.XPath, isField: false, nsmgr);
			}
			catch (XmlSchemaException ex)
			{
				ex.SetSource(constraint.Selector);
				throw ex;
			}
			XmlSchemaObjectCollection xmlSchemaObjectCollection = constraint.Fields;
			fields = new Asttree[xmlSchemaObjectCollection.Count];
			for (int i = 0; i < xmlSchemaObjectCollection.Count; i++)
			{
				try
				{
					fields[i] = new Asttree(((XmlSchemaXPath)xmlSchemaObjectCollection[i]).XPath, isField: true, nsmgr);
				}
				catch (XmlSchemaException ex2)
				{
					ex2.SetSource(constraint.Fields[i]);
					throw ex2;
				}
			}
			if (constraint is XmlSchemaUnique)
			{
				role = ConstraintRole.Unique;
				return;
			}
			if (constraint is XmlSchemaKey)
			{
				role = ConstraintRole.Key;
				return;
			}
			role = ConstraintRole.Keyref;
			refer = ((XmlSchemaKeyref)constraint).Refer;
		}
	}
	internal sealed class Compiler : BaseProcessor
	{
		private string restrictionErrorMsg;

		private XmlSchemaObjectTable attributes = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable attributeGroups = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable elements = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable schemaTypes = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable groups = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable notations = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable examplars = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable identityConstraints = new XmlSchemaObjectTable();

		private Stack complexTypeStack = new Stack();

		private Hashtable schemasToCompile = new Hashtable();

		private Hashtable importedSchemas = new Hashtable();

		private XmlSchema schemaForSchema;

		public Compiler(XmlNameTable nameTable, ValidationEventHandler eventHandler, XmlSchema schemaForSchema, XmlSchemaCompilationSettings compilationSettings)
			: base(nameTable, null, eventHandler, compilationSettings)
		{
			this.schemaForSchema = schemaForSchema;
		}

		public bool Execute(XmlSchemaSet schemaSet, SchemaInfo schemaCompiledInfo)
		{
			Compile();
			if (!base.HasErrors)
			{
				Output(schemaCompiledInfo);
				schemaSet.elements = elements;
				schemaSet.attributes = attributes;
				schemaSet.schemaTypes = schemaTypes;
				schemaSet.substitutionGroups = examplars;
			}
			return !base.HasErrors;
		}

		internal void Prepare(XmlSchema schema, bool cleanup)
		{
			if (schemasToCompile[schema] != null)
			{
				return;
			}
			schemasToCompile.Add(schema, schema);
			foreach (XmlSchemaElement value in schema.Elements.Values)
			{
				if (cleanup)
				{
					CleanupElement(value);
				}
				AddToTable(elements, value.QualifiedName, value);
			}
			foreach (XmlSchemaAttribute value2 in schema.Attributes.Values)
			{
				if (cleanup)
				{
					CleanupAttribute(value2);
				}
				AddToTable(attributes, value2.QualifiedName, value2);
			}
			foreach (XmlSchemaGroup value3 in schema.Groups.Values)
			{
				if (cleanup)
				{
					CleanupGroup(value3);
				}
				AddToTable(groups, value3.QualifiedName, value3);
			}
			foreach (XmlSchemaAttributeGroup value4 in schema.AttributeGroups.Values)
			{
				if (cleanup)
				{
					CleanupAttributeGroup(value4);
				}
				AddToTable(attributeGroups, value4.QualifiedName, value4);
			}
			foreach (XmlSchemaType value5 in schema.SchemaTypes.Values)
			{
				if (cleanup)
				{
					if (value5 is XmlSchemaComplexType complexType)
					{
						CleanupComplexType(complexType);
					}
					else
					{
						CleanupSimpleType(value5 as XmlSchemaSimpleType);
					}
				}
				AddToTable(schemaTypes, value5.QualifiedName, value5);
			}
			foreach (XmlSchemaNotation value6 in schema.Notations.Values)
			{
				AddToTable(notations, value6.QualifiedName, value6);
			}
			foreach (XmlSchemaIdentityConstraint value7 in schema.IdentityConstraints.Values)
			{
				AddToTable(identityConstraints, value7.QualifiedName, value7);
			}
		}

		private void UpdateSForSSimpleTypes()
		{
			XmlSchemaSimpleType[] builtInTypes = DatatypeImplementation.GetBuiltInTypes();
			int num = builtInTypes.Length - 3;
			for (int i = 12; i < num; i++)
			{
				XmlSchemaSimpleType xmlSchemaSimpleType = builtInTypes[i];
				schemaForSchema.SchemaTypes.Replace(xmlSchemaSimpleType.QualifiedName, xmlSchemaSimpleType);
				schemaTypes.Replace(xmlSchemaSimpleType.QualifiedName, xmlSchemaSimpleType);
			}
		}

		private void Output(SchemaInfo schemaInfo)
		{
			foreach (XmlSchema value in schemasToCompile.Values)
			{
				string text = value.TargetNamespace;
				if (text == null)
				{
					text = string.Empty;
				}
				schemaInfo.TargetNamespaces[text] = text;
			}
			foreach (XmlSchemaElement value2 in elements.Values)
			{
				schemaInfo.ElementDecls.Add(value2.QualifiedName, value2.ElementDecl);
			}
			foreach (XmlSchemaAttribute value3 in attributes.Values)
			{
				schemaInfo.AttributeDecls.Add(value3.QualifiedName, value3.AttDef);
			}
			foreach (XmlSchemaType value4 in schemaTypes.Values)
			{
				schemaInfo.ElementDeclsByType.Add(value4.QualifiedName, value4.ElementDecl);
			}
			foreach (XmlSchemaNotation value5 in notations.Values)
			{
				SchemaNotation schemaNotation = new SchemaNotation(value5.QualifiedName);
				schemaNotation.SystemLiteral = value5.System;
				schemaNotation.Pubid = value5.Public;
				if (schemaInfo.Notations[schemaNotation.Name.Name] == null)
				{
					schemaInfo.Notations.Add(schemaNotation.Name.Name, schemaNotation);
				}
			}
		}

		internal void ImportAllCompiledSchemas(XmlSchemaSet schemaSet)
		{
			SortedList sortedSchemas = schemaSet.SortedSchemas;
			for (int i = 0; i < sortedSchemas.Count; i++)
			{
				XmlSchema xmlSchema = (XmlSchema)sortedSchemas.GetByIndex(i);
				if (xmlSchema.IsCompiledBySet)
				{
					Prepare(xmlSchema, cleanup: false);
				}
			}
		}

		internal bool Compile()
		{
			schemaTypes.Insert(DatatypeImplementation.QnAnyType, XmlSchemaComplexType.AnyType);
			if (schemaForSchema != null)
			{
				schemaForSchema.SchemaTypes.Replace(DatatypeImplementation.QnAnyType, XmlSchemaComplexType.AnyType);
				UpdateSForSSimpleTypes();
			}
			foreach (XmlSchemaGroup value in groups.Values)
			{
				CompileGroup(value);
			}
			foreach (XmlSchemaAttributeGroup value2 in attributeGroups.Values)
			{
				CompileAttributeGroup(value2);
			}
			foreach (XmlSchemaType value3 in schemaTypes.Values)
			{
				if (value3 is XmlSchemaComplexType complexType)
				{
					CompileComplexType(complexType);
				}
				else
				{
					CompileSimpleType((XmlSchemaSimpleType)value3);
				}
			}
			foreach (XmlSchemaElement value4 in elements.Values)
			{
				if (value4.ElementDecl == null)
				{
					CompileElement(value4);
				}
			}
			foreach (XmlSchemaAttribute value5 in attributes.Values)
			{
				if (value5.AttDef == null)
				{
					CompileAttribute(value5);
				}
			}
			foreach (XmlSchemaIdentityConstraint value6 in identityConstraints.Values)
			{
				if (value6.CompiledConstraint == null)
				{
					CompileIdentityConstraint(value6);
				}
			}
			while (complexTypeStack.Count > 0)
			{
				XmlSchemaComplexType complexType2 = (XmlSchemaComplexType)complexTypeStack.Pop();
				CompileComplexTypeElements(complexType2);
			}
			ProcessSubstitutionGroups();
			foreach (XmlSchemaType value7 in schemaTypes.Values)
			{
				if (value7 is XmlSchemaComplexType complexType3)
				{
					CheckParticleDerivation(complexType3);
				}
			}
			foreach (XmlSchemaElement value8 in elements.Values)
			{
				if (value8.ElementSchemaType is XmlSchemaComplexType complexType4 && value8.SchemaTypeName == XmlQualifiedName.Empty)
				{
					CheckParticleDerivation(complexType4);
				}
			}
			foreach (XmlSchemaGroup value9 in groups.Values)
			{
				XmlSchemaGroup redefined = value9.Redefined;
				if (redefined != null)
				{
					RecursivelyCheckRedefinedGroups(value9, redefined);
				}
			}
			foreach (XmlSchemaAttributeGroup value10 in attributeGroups.Values)
			{
				XmlSchemaAttributeGroup redefined2 = value10.Redefined;
				if (redefined2 != null)
				{
					RecursivelyCheckRedefinedAttributeGroups(value10, redefined2);
				}
			}
			return !base.HasErrors;
		}

		private void CleanupAttribute(XmlSchemaAttribute attribute)
		{
			if (attribute.SchemaType != null)
			{
				CleanupSimpleType(attribute.SchemaType);
			}
			attribute.AttDef = null;
		}

		private void CleanupAttributeGroup(XmlSchemaAttributeGroup attributeGroup)
		{
			CleanupAttributes(attributeGroup.Attributes);
			attributeGroup.AttributeUses.Clear();
			attributeGroup.AttributeWildcard = null;
			if (attributeGroup.Redefined != null)
			{
				CleanupAttributeGroup(attributeGroup.Redefined);
			}
		}

		private void CleanupComplexType(XmlSchemaComplexType complexType)
		{
			if (complexType.QualifiedName == DatatypeImplementation.QnAnyType)
			{
				return;
			}
			if (complexType.ContentModel != null)
			{
				if (complexType.ContentModel is XmlSchemaSimpleContent)
				{
					XmlSchemaSimpleContent xmlSchemaSimpleContent = (XmlSchemaSimpleContent)complexType.ContentModel;
					if (xmlSchemaSimpleContent.Content is XmlSchemaSimpleContentExtension)
					{
						XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = (XmlSchemaSimpleContentExtension)xmlSchemaSimpleContent.Content;
						CleanupAttributes(xmlSchemaSimpleContentExtension.Attributes);
					}
					else
					{
						XmlSchemaSimpleContentRestriction xmlSchemaSimpleContentRestriction = (XmlSchemaSimpleContentRestriction)xmlSchemaSimpleContent.Content;
						CleanupAttributes(xmlSchemaSimpleContentRestriction.Attributes);
					}
				}
				else
				{
					XmlSchemaComplexContent xmlSchemaComplexContent = (XmlSchemaComplexContent)complexType.ContentModel;
					if (xmlSchemaComplexContent.Content is XmlSchemaComplexContentExtension)
					{
						XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension = (XmlSchemaComplexContentExtension)xmlSchemaComplexContent.Content;
						CleanupParticle(xmlSchemaComplexContentExtension.Particle);
						CleanupAttributes(xmlSchemaComplexContentExtension.Attributes);
					}
					else
					{
						XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction = (XmlSchemaComplexContentRestriction)xmlSchemaComplexContent.Content;
						CleanupParticle(xmlSchemaComplexContentRestriction.Particle);
						CleanupAttributes(xmlSchemaComplexContentRestriction.Attributes);
					}
				}
			}
			else
			{
				CleanupParticle(complexType.Particle);
				CleanupAttributes(complexType.Attributes);
			}
			complexType.LocalElements.Clear();
			complexType.AttributeUses.Clear();
			complexType.SetAttributeWildcard(null);
			complexType.SetContentTypeParticle(XmlSchemaParticle.Empty);
			complexType.ElementDecl = null;
			complexType.HasDuplicateDecls = false;
			complexType.HasWildCard = false;
			if (complexType.Redefined != null)
			{
				CleanupComplexType(complexType.Redefined as XmlSchemaComplexType);
			}
		}

		private void CleanupSimpleType(XmlSchemaSimpleType simpleType)
		{
			if (simpleType != XmlSchemaType.GetBuiltInSimpleType(simpleType.TypeCode))
			{
				simpleType.ElementDecl = null;
				if (simpleType.Redefined != null)
				{
					CleanupSimpleType(simpleType.Redefined as XmlSchemaSimpleType);
				}
			}
		}

		private void CleanupElement(XmlSchemaElement element)
		{
			if (element.SchemaType != null)
			{
				if (element.SchemaType is XmlSchemaComplexType complexType)
				{
					CleanupComplexType(complexType);
				}
				else
				{
					CleanupSimpleType((XmlSchemaSimpleType)element.SchemaType);
				}
			}
			foreach (XmlSchemaIdentityConstraint constraint in element.Constraints)
			{
				constraint.CompiledConstraint = null;
			}
			element.ElementDecl = null;
			element.IsLocalTypeDerivationChecked = false;
		}

		private void CleanupAttributes(XmlSchemaObjectCollection attributes)
		{
			foreach (XmlSchemaObject attribute in attributes)
			{
				if (attribute is XmlSchemaAttribute)
				{
					CleanupAttribute((XmlSchemaAttribute)attribute);
				}
			}
		}

		private void CleanupGroup(XmlSchemaGroup group)
		{
			CleanupParticle(group.Particle);
			group.CanonicalParticle = null;
			if (group.Redefined != null)
			{
				CleanupGroup(group.Redefined);
			}
		}

		private void CleanupParticle(XmlSchemaParticle particle)
		{
			if (particle is XmlSchemaElement)
			{
				CleanupElement((XmlSchemaElement)particle);
			}
			else
			{
				if (!(particle is XmlSchemaGroupBase))
				{
					return;
				}
				foreach (XmlSchemaParticle item in ((XmlSchemaGroupBase)particle).Items)
				{
					CleanupParticle(item);
				}
			}
		}

		private void ProcessSubstitutionGroups()
		{
			foreach (XmlSchemaElement value in elements.Values)
			{
				if (value.SubstitutionGroup.IsEmpty)
				{
					continue;
				}
				if (!(elements[value.SubstitutionGroup] is XmlSchemaElement xmlSchemaElement2))
				{
					SendValidationEvent("Sch_NoExamplar", value);
					continue;
				}
				if (!XmlSchemaType.IsDerivedFrom(value.ElementSchemaType, xmlSchemaElement2.ElementSchemaType, xmlSchemaElement2.FinalResolved))
				{
					SendValidationEvent("Sch_InvalidSubstitutionMember", value.QualifiedName.ToString(), xmlSchemaElement2.QualifiedName.ToString(), value);
				}
				if ((xmlSchemaElement2.BlockResolved & XmlSchemaDerivationMethod.Substitution) == 0)
				{
					XmlSchemaSubstitutionGroup xmlSchemaSubstitutionGroup = (XmlSchemaSubstitutionGroup)examplars[value.SubstitutionGroup];
					if (xmlSchemaSubstitutionGroup == null)
					{
						xmlSchemaSubstitutionGroup = new XmlSchemaSubstitutionGroup();
						xmlSchemaSubstitutionGroup.Examplar = value.SubstitutionGroup;
						examplars.Add(value.SubstitutionGroup, xmlSchemaSubstitutionGroup);
					}
					ArrayList members = xmlSchemaSubstitutionGroup.Members;
					if (!members.Contains(value))
					{
						members.Add(value);
					}
				}
			}
			foreach (XmlSchemaSubstitutionGroup value2 in examplars.Values)
			{
				CompileSubstitutionGroup(value2);
			}
		}

		private void CompileSubstitutionGroup(XmlSchemaSubstitutionGroup substitutionGroup)
		{
			if (substitutionGroup.IsProcessing)
			{
				{
					IEnumerator enumerator = substitutionGroup.Members.GetEnumerator();
					try
					{
						if (enumerator.MoveNext())
						{
							XmlSchemaElement source = (XmlSchemaElement)enumerator.Current;
							SendValidationEvent("Sch_SubstitutionCircularRef", source);
							return;
						}
					}
					finally
					{
						IDisposable disposable = enumerator as IDisposable;
						if (disposable != null)
						{
							disposable.Dispose();
						}
					}
				}
			}
			XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)elements[substitutionGroup.Examplar];
			if (substitutionGroup.Members.Contains(xmlSchemaElement))
			{
				return;
			}
			substitutionGroup.IsProcessing = true;
			try
			{
				if (xmlSchemaElement.FinalResolved == XmlSchemaDerivationMethod.All)
				{
					SendValidationEvent("Sch_InvalidExamplar", xmlSchemaElement);
				}
				ArrayList arrayList = null;
				foreach (XmlSchemaElement member in substitutionGroup.Members)
				{
					XmlSchemaSubstitutionGroup xmlSchemaSubstitutionGroup = (XmlSchemaSubstitutionGroup)examplars[member.QualifiedName];
					if (xmlSchemaSubstitutionGroup == null)
					{
						continue;
					}
					CompileSubstitutionGroup(xmlSchemaSubstitutionGroup);
					foreach (XmlSchemaElement member2 in xmlSchemaSubstitutionGroup.Members)
					{
						if (member2 != member)
						{
							if (arrayList == null)
							{
								arrayList = new ArrayList();
							}
							arrayList.Add(member2);
						}
					}
				}
				if (arrayList != null)
				{
					foreach (XmlSchemaElement item in arrayList)
					{
						substitutionGroup.Members.Add(item);
					}
				}
				substitutionGroup.Members.Add(xmlSchemaElement);
			}
			finally
			{
				substitutionGroup.IsProcessing = false;
			}
		}

		private void RecursivelyCheckRedefinedGroups(XmlSchemaGroup redefinedGroup, XmlSchemaGroup baseGroup)
		{
			if (baseGroup.Redefined != null)
			{
				RecursivelyCheckRedefinedGroups(baseGroup, baseGroup.Redefined);
			}
			if (redefinedGroup.SelfReferenceCount == 0)
			{
				if (baseGroup.CanonicalParticle == null)
				{
					baseGroup.CanonicalParticle = CannonicalizeParticle(baseGroup.Particle, root: true);
				}
				if (redefinedGroup.CanonicalParticle == null)
				{
					redefinedGroup.CanonicalParticle = CannonicalizeParticle(redefinedGroup.Particle, root: true);
				}
				CompileParticleElements(redefinedGroup.CanonicalParticle);
				CompileParticleElements(baseGroup.CanonicalParticle);
				CheckParticleDerivation(redefinedGroup.CanonicalParticle, baseGroup.CanonicalParticle);
			}
		}

		private void RecursivelyCheckRedefinedAttributeGroups(XmlSchemaAttributeGroup attributeGroup, XmlSchemaAttributeGroup baseAttributeGroup)
		{
			if (baseAttributeGroup.Redefined != null)
			{
				RecursivelyCheckRedefinedAttributeGroups(baseAttributeGroup, baseAttributeGroup.Redefined);
			}
			if (attributeGroup.SelfReferenceCount == 0)
			{
				CompileAttributeGroup(baseAttributeGroup);
				CompileAttributeGroup(attributeGroup);
				CheckAtrributeGroupRestriction(baseAttributeGroup, attributeGroup);
			}
		}

		private void CompileGroup(XmlSchemaGroup group)
		{
			if (group.IsProcessing)
			{
				SendValidationEvent("Sch_GroupCircularRef", group);
				group.CanonicalParticle = XmlSchemaParticle.Empty;
				return;
			}
			group.IsProcessing = true;
			if (group.CanonicalParticle == null)
			{
				group.CanonicalParticle = CannonicalizeParticle(group.Particle, root: true);
			}
			group.IsProcessing = false;
		}

		private void CompileSimpleType(XmlSchemaSimpleType simpleType)
		{
			if (simpleType.IsProcessing)
			{
				throw new XmlSchemaException("Sch_TypeCircularRef", simpleType);
			}
			if (simpleType.ElementDecl != null)
			{
				return;
			}
			simpleType.IsProcessing = true;
			try
			{
				if (simpleType.Content is XmlSchemaSimpleTypeList)
				{
					XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = (XmlSchemaSimpleTypeList)simpleType.Content;
					simpleType.SetBaseSchemaType(DatatypeImplementation.AnySimpleType);
					XmlSchemaDatatype datatype;
					if (xmlSchemaSimpleTypeList.ItemTypeName.IsEmpty)
					{
						CompileSimpleType(xmlSchemaSimpleTypeList.ItemType);
						xmlSchemaSimpleTypeList.BaseItemType = xmlSchemaSimpleTypeList.ItemType;
						datatype = xmlSchemaSimpleTypeList.ItemType.Datatype;
					}
					else
					{
						XmlSchemaSimpleType simpleType2 = GetSimpleType(xmlSchemaSimpleTypeList.ItemTypeName);
						if (simpleType2 == null)
						{
							throw new XmlSchemaException("Sch_UndeclaredSimpleType", xmlSchemaSimpleTypeList.ItemTypeName.ToString(), xmlSchemaSimpleTypeList);
						}
						if ((simpleType2.FinalResolved & XmlSchemaDerivationMethod.List) != 0)
						{
							SendValidationEvent("Sch_BaseFinalList", simpleType);
						}
						xmlSchemaSimpleTypeList.BaseItemType = simpleType2;
						datatype = simpleType2.Datatype;
					}
					simpleType.SetDatatype(datatype.DeriveByList(simpleType));
					simpleType.SetDerivedBy(XmlSchemaDerivationMethod.List);
				}
				else if (simpleType.Content is XmlSchemaSimpleTypeRestriction)
				{
					XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)simpleType.Content;
					XmlSchemaDatatype datatype2;
					if (xmlSchemaSimpleTypeRestriction.BaseTypeName.IsEmpty)
					{
						CompileSimpleType(xmlSchemaSimpleTypeRestriction.BaseType);
						simpleType.SetBaseSchemaType(xmlSchemaSimpleTypeRestriction.BaseType);
						datatype2 = xmlSchemaSimpleTypeRestriction.BaseType.Datatype;
					}
					else if (simpleType.Redefined != null && xmlSchemaSimpleTypeRestriction.BaseTypeName == simpleType.Redefined.QualifiedName)
					{
						CompileSimpleType((XmlSchemaSimpleType)simpleType.Redefined);
						simpleType.SetBaseSchemaType(simpleType.Redefined.BaseXmlSchemaType);
						datatype2 = simpleType.Redefined.Datatype;
					}
					else
					{
						if (xmlSchemaSimpleTypeRestriction.BaseTypeName.Equals(DatatypeImplementation.QnAnySimpleType))
						{
							XmlSchema parentSchema = Preprocessor.GetParentSchema(simpleType);
							if (parentSchema.TargetNamespace != "http://www.w3.org/2001/XMLSchema")
							{
								throw new XmlSchemaException("Sch_InvalidSimpleTypeRestriction", xmlSchemaSimpleTypeRestriction.BaseTypeName.ToString(), simpleType);
							}
						}
						XmlSchemaSimpleType simpleType3 = GetSimpleType(xmlSchemaSimpleTypeRestriction.BaseTypeName);
						if (simpleType3 == null)
						{
							throw new XmlSchemaException("Sch_UndeclaredSimpleType", xmlSchemaSimpleTypeRestriction.BaseTypeName.ToString(), xmlSchemaSimpleTypeRestriction);
						}
						if ((simpleType3.FinalResolved & XmlSchemaDerivationMethod.Restriction) != 0)
						{
							SendValidationEvent("Sch_BaseFinalRestriction", simpleType);
						}
						simpleType.SetBaseSchemaType(simpleType3);
						datatype2 = simpleType3.Datatype;
					}
					simpleType.SetDatatype(datatype2.DeriveByRestriction(xmlSchemaSimpleTypeRestriction.Facets, base.NameTable, simpleType));
					simpleType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
				}
				else
				{
					XmlSchemaSimpleType[] types = CompileBaseMemberTypes(simpleType);
					simpleType.SetBaseSchemaType(DatatypeImplementation.AnySimpleType);
					simpleType.SetDatatype(XmlSchemaDatatype.DeriveByUnion(types, simpleType));
					simpleType.SetDerivedBy(XmlSchemaDerivationMethod.Union);
				}
			}
			catch (XmlSchemaException ex)
			{
				if (ex.SourceSchemaObject == null)
				{
					ex.SetSource(simpleType);
				}
				SendValidationEvent(ex);
				simpleType.SetDatatype(DatatypeImplementation.AnySimpleType.Datatype);
			}
			finally
			{
				SchemaElementDecl schemaElementDecl = new SchemaElementDecl();
				schemaElementDecl.ContentValidator = ContentValidator.TextOnly;
				schemaElementDecl.SchemaType = simpleType;
				schemaElementDecl.Datatype = simpleType.Datatype;
				simpleType.ElementDecl = schemaElementDecl;
				simpleType.IsProcessing = false;
			}
		}

		private XmlSchemaSimpleType[] CompileBaseMemberTypes(XmlSchemaSimpleType simpleType)
		{
			ArrayList arrayList = new ArrayList();
			XmlSchemaSimpleTypeUnion xmlSchemaSimpleTypeUnion = (XmlSchemaSimpleTypeUnion)simpleType.Content;
			Array memberTypes = xmlSchemaSimpleTypeUnion.MemberTypes;
			if (memberTypes != null)
			{
				foreach (XmlQualifiedName item in memberTypes)
				{
					XmlSchemaSimpleType simpleType2 = GetSimpleType(item);
					if (simpleType2 != null)
					{
						if (simpleType2.Datatype.Variety == XmlSchemaDatatypeVariety.Union)
						{
							CheckUnionType(simpleType2, arrayList, simpleType);
						}
						else
						{
							arrayList.Add(simpleType2);
						}
						if ((simpleType2.FinalResolved & XmlSchemaDerivationMethod.Union) != 0)
						{
							SendValidationEvent("Sch_BaseFinalUnion", simpleType);
						}
						continue;
					}
					throw new XmlSchemaException("Sch_UndeclaredSimpleType", item.ToString(), xmlSchemaSimpleTypeUnion);
				}
			}
			XmlSchemaObjectCollection baseTypes = xmlSchemaSimpleTypeUnion.BaseTypes;
			if (baseTypes != null)
			{
				foreach (XmlSchemaSimpleType item2 in baseTypes)
				{
					CompileSimpleType(item2);
					if (item2.Datatype.Variety == XmlSchemaDatatypeVariety.Union)
					{
						CheckUnionType(item2, arrayList, simpleType);
					}
					else
					{
						arrayList.Add(item2);
					}
				}
			}
			xmlSchemaSimpleTypeUnion.SetBaseMemberTypes(arrayList.ToArray(typeof(XmlSchemaSimpleType)) as XmlSchemaSimpleType[]);
			return xmlSchemaSimpleTypeUnion.BaseMemberTypes;
		}

		private void CheckUnionType(XmlSchemaSimpleType unionMember, ArrayList memberTypeDefinitions, XmlSchemaSimpleType parentType)
		{
			XmlSchemaDatatype datatype = unionMember.Datatype;
			if (unionMember.DerivedBy == XmlSchemaDerivationMethod.Restriction && (datatype.HasLexicalFacets || datatype.HasValueFacets))
			{
				SendValidationEvent("Sch_UnionFromUnion", parentType);
				return;
			}
			Datatype_union datatype_union = unionMember.Datatype as Datatype_union;
			memberTypeDefinitions.AddRange(datatype_union.BaseMemberTypes);
		}

		private void CompileComplexType(XmlSchemaComplexType complexType)
		{
			if (complexType.ElementDecl != null)
			{
				return;
			}
			if (complexType.IsProcessing)
			{
				SendValidationEvent("Sch_TypeCircularRef", complexType);
				return;
			}
			complexType.IsProcessing = true;
			try
			{
				if (complexType.ContentModel != null)
				{
					if (complexType.ContentModel is XmlSchemaSimpleContent)
					{
						XmlSchemaSimpleContent xmlSchemaSimpleContent = (XmlSchemaSimpleContent)complexType.ContentModel;
						complexType.SetContentType(XmlSchemaContentType.TextOnly);
						if (xmlSchemaSimpleContent.Content is XmlSchemaSimpleContentExtension)
						{
							CompileSimpleContentExtension(complexType, (XmlSchemaSimpleContentExtension)xmlSchemaSimpleContent.Content);
						}
						else
						{
							CompileSimpleContentRestriction(complexType, (XmlSchemaSimpleContentRestriction)xmlSchemaSimpleContent.Content);
						}
					}
					else
					{
						XmlSchemaComplexContent xmlSchemaComplexContent = (XmlSchemaComplexContent)complexType.ContentModel;
						if (xmlSchemaComplexContent.Content is XmlSchemaComplexContentExtension)
						{
							CompileComplexContentExtension(complexType, xmlSchemaComplexContent, (XmlSchemaComplexContentExtension)xmlSchemaComplexContent.Content);
						}
						else
						{
							CompileComplexContentRestriction(complexType, xmlSchemaComplexContent, (XmlSchemaComplexContentRestriction)xmlSchemaComplexContent.Content);
						}
					}
				}
				else
				{
					complexType.SetBaseSchemaType(XmlSchemaComplexType.AnyType);
					CompileLocalAttributes(XmlSchemaComplexType.AnyType, complexType, complexType.Attributes, complexType.AnyAttribute, XmlSchemaDerivationMethod.Restriction);
					complexType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
					complexType.SetContentTypeParticle(CompileContentTypeParticle(complexType.Particle));
					complexType.SetContentType(GetSchemaContentType(complexType, null, complexType.ContentTypeParticle));
				}
				if (complexType.ContainsIdAttribute(findAll: true))
				{
					SendValidationEvent("Sch_TwoIdAttrUses", complexType);
				}
				SchemaElementDecl schemaElementDecl = new SchemaElementDecl();
				schemaElementDecl.ContentValidator = CompileComplexContent(complexType);
				schemaElementDecl.SchemaType = complexType;
				schemaElementDecl.IsAbstract = complexType.IsAbstract;
				schemaElementDecl.Datatype = complexType.Datatype;
				schemaElementDecl.Block = complexType.BlockResolved;
				schemaElementDecl.AnyAttribute = complexType.AttributeWildcard;
				foreach (XmlSchemaAttribute value in complexType.AttributeUses.Values)
				{
					if (value.Use == XmlSchemaUse.Prohibited)
					{
						if (schemaElementDecl.ProhibitedAttributes[value.QualifiedName] == null)
						{
							schemaElementDecl.ProhibitedAttributes.Add(value.QualifiedName, value.QualifiedName);
						}
					}
					else if (schemaElementDecl.AttDefs[value.QualifiedName] == null && value.AttDef != null && value.AttDef.Name != XmlQualifiedName.Empty && value.AttDef != SchemaAttDef.Empty)
					{
						schemaElementDecl.AddAttDef(value.AttDef);
					}
				}
				schemaElementDecl.EndAddAttDef();
				complexType.ElementDecl = schemaElementDecl;
			}
			finally
			{
				complexType.IsProcessing = false;
			}
		}

		private void CompileSimpleContentExtension(XmlSchemaComplexType complexType, XmlSchemaSimpleContentExtension simpleExtension)
		{
			XmlSchemaComplexType xmlSchemaComplexType = null;
			if (complexType.Redefined != null && simpleExtension.BaseTypeName == complexType.Redefined.QualifiedName)
			{
				xmlSchemaComplexType = (XmlSchemaComplexType)complexType.Redefined;
				CompileComplexType(xmlSchemaComplexType);
				complexType.SetBaseSchemaType(xmlSchemaComplexType);
				complexType.SetDatatype(xmlSchemaComplexType.Datatype);
			}
			else
			{
				XmlSchemaType anySchemaType = GetAnySchemaType(simpleExtension.BaseTypeName);
				if (anySchemaType == null)
				{
					SendValidationEvent("Sch_UndeclaredType", simpleExtension.BaseTypeName.ToString(), simpleExtension);
				}
				else
				{
					complexType.SetBaseSchemaType(anySchemaType);
					complexType.SetDatatype(anySchemaType.Datatype);
				}
				xmlSchemaComplexType = anySchemaType as XmlSchemaComplexType;
			}
			if (xmlSchemaComplexType != null)
			{
				if ((xmlSchemaComplexType.FinalResolved & XmlSchemaDerivationMethod.Extension) != 0)
				{
					SendValidationEvent("Sch_BaseFinalExtension", complexType);
				}
				if (xmlSchemaComplexType.ContentType != 0)
				{
					SendValidationEvent("Sch_NotSimpleContent", complexType);
				}
			}
			complexType.SetDerivedBy(XmlSchemaDerivationMethod.Extension);
			CompileLocalAttributes(xmlSchemaComplexType, complexType, simpleExtension.Attributes, simpleExtension.AnyAttribute, XmlSchemaDerivationMethod.Extension);
		}

		private void CompileSimpleContentRestriction(XmlSchemaComplexType complexType, XmlSchemaSimpleContentRestriction simpleRestriction)
		{
			XmlSchemaComplexType xmlSchemaComplexType = null;
			XmlSchemaDatatype xmlSchemaDatatype = null;
			if (complexType.Redefined != null && simpleRestriction.BaseTypeName == complexType.Redefined.QualifiedName)
			{
				xmlSchemaComplexType = (XmlSchemaComplexType)complexType.Redefined;
				CompileComplexType(xmlSchemaComplexType);
				xmlSchemaDatatype = xmlSchemaComplexType.Datatype;
			}
			else
			{
				xmlSchemaComplexType = GetComplexType(simpleRestriction.BaseTypeName);
				if (xmlSchemaComplexType == null)
				{
					SendValidationEvent("Sch_UndefBaseRestriction", simpleRestriction.BaseTypeName.ToString(), simpleRestriction);
					return;
				}
				if (xmlSchemaComplexType.ContentType == XmlSchemaContentType.TextOnly)
				{
					if (simpleRestriction.BaseType == null)
					{
						xmlSchemaDatatype = xmlSchemaComplexType.Datatype;
					}
					else
					{
						CompileSimpleType(simpleRestriction.BaseType);
						if (!XmlSchemaType.IsDerivedFromDatatype(simpleRestriction.BaseType.Datatype, xmlSchemaComplexType.Datatype, XmlSchemaDerivationMethod.None))
						{
							SendValidationEvent("Sch_DerivedNotFromBase", simpleRestriction);
						}
						xmlSchemaDatatype = simpleRestriction.BaseType.Datatype;
					}
				}
				else if (xmlSchemaComplexType.ContentType == XmlSchemaContentType.Mixed && xmlSchemaComplexType.ElementDecl.ContentValidator.IsEmptiable)
				{
					if (simpleRestriction.BaseType != null)
					{
						CompileSimpleType(simpleRestriction.BaseType);
						complexType.SetBaseSchemaType(simpleRestriction.BaseType);
						xmlSchemaDatatype = simpleRestriction.BaseType.Datatype;
					}
					else
					{
						SendValidationEvent("Sch_NeedSimpleTypeChild", simpleRestriction);
					}
				}
				else
				{
					SendValidationEvent("Sch_NotSimpleContent", complexType);
				}
			}
			if (xmlSchemaComplexType != null && xmlSchemaComplexType.ElementDecl != null && (xmlSchemaComplexType.FinalResolved & XmlSchemaDerivationMethod.Restriction) != 0)
			{
				SendValidationEvent("Sch_BaseFinalRestriction", complexType);
			}
			if (xmlSchemaComplexType != null)
			{
				complexType.SetBaseSchemaType(xmlSchemaComplexType);
			}
			if (xmlSchemaDatatype != null)
			{
				try
				{
					complexType.SetDatatype(xmlSchemaDatatype.DeriveByRestriction(simpleRestriction.Facets, base.NameTable, complexType));
				}
				catch (XmlSchemaException ex)
				{
					if (ex.SourceSchemaObject == null)
					{
						ex.SetSource(complexType);
					}
					SendValidationEvent(ex);
					complexType.SetDatatype(DatatypeImplementation.AnySimpleType.Datatype);
				}
			}
			complexType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
			CompileLocalAttributes(xmlSchemaComplexType, complexType, simpleRestriction.Attributes, simpleRestriction.AnyAttribute, XmlSchemaDerivationMethod.Restriction);
		}

		private void CompileComplexContentExtension(XmlSchemaComplexType complexType, XmlSchemaComplexContent complexContent, XmlSchemaComplexContentExtension complexExtension)
		{
			XmlSchemaComplexType xmlSchemaComplexType = null;
			if (complexType.Redefined != null && complexExtension.BaseTypeName == complexType.Redefined.QualifiedName)
			{
				xmlSchemaComplexType = (XmlSchemaComplexType)complexType.Redefined;
				CompileComplexType(xmlSchemaComplexType);
			}
			else
			{
				xmlSchemaComplexType = GetComplexType(complexExtension.BaseTypeName);
				if (xmlSchemaComplexType == null)
				{
					SendValidationEvent("Sch_UndefBaseExtension", complexExtension.BaseTypeName.ToString(), complexExtension);
					return;
				}
			}
			if ((xmlSchemaComplexType.FinalResolved & XmlSchemaDerivationMethod.Extension) != 0)
			{
				SendValidationEvent("Sch_BaseFinalExtension", complexType);
			}
			CompileLocalAttributes(xmlSchemaComplexType, complexType, complexExtension.Attributes, complexExtension.AnyAttribute, XmlSchemaDerivationMethod.Extension);
			XmlSchemaParticle contentTypeParticle = xmlSchemaComplexType.ContentTypeParticle;
			XmlSchemaParticle xmlSchemaParticle = CannonicalizeParticle(complexExtension.Particle, root: true);
			if (contentTypeParticle != XmlSchemaParticle.Empty)
			{
				if (xmlSchemaParticle != XmlSchemaParticle.Empty)
				{
					XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
					xmlSchemaSequence.Items.Add(contentTypeParticle);
					xmlSchemaSequence.Items.Add(xmlSchemaParticle);
					complexType.SetContentTypeParticle(CompileContentTypeParticle(xmlSchemaSequence));
				}
				else
				{
					complexType.SetContentTypeParticle(contentTypeParticle);
				}
			}
			else
			{
				complexType.SetContentTypeParticle(xmlSchemaParticle);
			}
			XmlSchemaContentType xmlSchemaContentType = GetSchemaContentType(complexType, complexContent, xmlSchemaParticle);
			if (xmlSchemaContentType == XmlSchemaContentType.Empty)
			{
				xmlSchemaContentType = xmlSchemaComplexType.ContentType;
			}
			complexType.SetContentType(xmlSchemaContentType);
			if (xmlSchemaComplexType.ContentType != XmlSchemaContentType.Empty && complexType.ContentType != xmlSchemaComplexType.ContentType)
			{
				SendValidationEvent("Sch_DifContentType", complexType);
				return;
			}
			complexType.SetBaseSchemaType(xmlSchemaComplexType);
			complexType.SetDerivedBy(XmlSchemaDerivationMethod.Extension);
		}

		private void CompileComplexContentRestriction(XmlSchemaComplexType complexType, XmlSchemaComplexContent complexContent, XmlSchemaComplexContentRestriction complexRestriction)
		{
			XmlSchemaComplexType xmlSchemaComplexType = null;
			if (complexType.Redefined != null && complexRestriction.BaseTypeName == complexType.Redefined.QualifiedName)
			{
				xmlSchemaComplexType = (XmlSchemaComplexType)complexType.Redefined;
				CompileComplexType(xmlSchemaComplexType);
			}
			else
			{
				xmlSchemaComplexType = GetComplexType(complexRestriction.BaseTypeName);
				if (xmlSchemaComplexType == null)
				{
					SendValidationEvent("Sch_UndefBaseRestriction", complexRestriction.BaseTypeName.ToString(), complexRestriction);
					return;
				}
			}
			complexType.SetBaseSchemaType(xmlSchemaComplexType);
			if ((xmlSchemaComplexType.FinalResolved & XmlSchemaDerivationMethod.Restriction) != 0)
			{
				SendValidationEvent("Sch_BaseFinalRestriction", complexType);
			}
			CompileLocalAttributes(xmlSchemaComplexType, complexType, complexRestriction.Attributes, complexRestriction.AnyAttribute, XmlSchemaDerivationMethod.Restriction);
			complexType.SetContentTypeParticle(CompileContentTypeParticle(complexRestriction.Particle));
			XmlSchemaContentType schemaContentType = GetSchemaContentType(complexType, complexContent, complexType.ContentTypeParticle);
			complexType.SetContentType(schemaContentType);
			switch (schemaContentType)
			{
			case XmlSchemaContentType.Empty:
				if (xmlSchemaComplexType.ElementDecl != null && !xmlSchemaComplexType.ElementDecl.ContentValidator.IsEmptiable)
				{
					SendValidationEvent("Sch_InvalidContentRestrictionDetailed", Res.GetString("Sch_InvalidBaseToEmpty"), complexType);
				}
				break;
			case XmlSchemaContentType.Mixed:
				if (xmlSchemaComplexType.ContentType != XmlSchemaContentType.Mixed)
				{
					SendValidationEvent("Sch_InvalidContentRestrictionDetailed", Res.GetString("Sch_InvalidBaseToMixed"), complexType);
				}
				break;
			}
			complexType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
		}

		private void CheckParticleDerivation(XmlSchemaComplexType complexType)
		{
			XmlSchemaComplexType xmlSchemaComplexType = complexType.BaseXmlSchemaType as XmlSchemaComplexType;
			restrictionErrorMsg = null;
			if (xmlSchemaComplexType != null && xmlSchemaComplexType != XmlSchemaComplexType.AnyType && complexType.DerivedBy == XmlSchemaDerivationMethod.Restriction)
			{
				XmlSchemaParticle derivedParticle = CannonicalizePointlessRoot(complexType.ContentTypeParticle);
				XmlSchemaParticle baseParticle = CannonicalizePointlessRoot(xmlSchemaComplexType.ContentTypeParticle);
				if (!IsValidRestriction(derivedParticle, baseParticle))
				{
					if (restrictionErrorMsg != null)
					{
						SendValidationEvent("Sch_InvalidParticleRestrictionDetailed", restrictionErrorMsg, complexType);
					}
					else
					{
						SendValidationEvent("Sch_InvalidParticleRestriction", complexType);
					}
				}
			}
			else
			{
				if (xmlSchemaComplexType != XmlSchemaComplexType.AnyType)
				{
					return;
				}
				foreach (XmlSchemaElement value in complexType.LocalElements.Values)
				{
					if (!value.IsLocalTypeDerivationChecked && value.ElementSchemaType is XmlSchemaComplexType complexType2 && value.SchemaTypeName == XmlQualifiedName.Empty && value.RefName == XmlQualifiedName.Empty)
					{
						value.IsLocalTypeDerivationChecked = true;
						CheckParticleDerivation(complexType2);
					}
				}
			}
		}

		private void CheckParticleDerivation(XmlSchemaParticle derivedParticle, XmlSchemaParticle baseParticle)
		{
			restrictionErrorMsg = null;
			derivedParticle = CannonicalizePointlessRoot(derivedParticle);
			baseParticle = CannonicalizePointlessRoot(baseParticle);
			if (!IsValidRestriction(derivedParticle, baseParticle))
			{
				if (restrictionErrorMsg != null)
				{
					SendValidationEvent("Sch_InvalidParticleRestrictionDetailed", restrictionErrorMsg, derivedParticle);
				}
				else
				{
					SendValidationEvent("Sch_InvalidParticleRestriction", derivedParticle);
				}
			}
		}

		private XmlSchemaParticle CompileContentTypeParticle(XmlSchemaParticle particle)
		{
			XmlSchemaParticle xmlSchemaParticle = CannonicalizeParticle(particle, root: true);
			if (xmlSchemaParticle is XmlSchemaChoice xmlSchemaChoice && xmlSchemaChoice.Items.Count == 0)
			{
				if (xmlSchemaChoice.MinOccurs != 0m)
				{
					SendValidationEvent("Sch_EmptyChoice", xmlSchemaChoice, XmlSeverityType.Warning);
				}
				return XmlSchemaParticle.Empty;
			}
			return xmlSchemaParticle;
		}

		private XmlSchemaParticle CannonicalizeParticle(XmlSchemaParticle particle, bool root)
		{
			if (particle == null || particle.IsEmpty)
			{
				return XmlSchemaParticle.Empty;
			}
			if (particle is XmlSchemaElement)
			{
				return particle;
			}
			if (particle is XmlSchemaGroupRef)
			{
				return CannonicalizeGroupRef((XmlSchemaGroupRef)particle, root);
			}
			if (particle is XmlSchemaAll)
			{
				return CannonicalizeAll((XmlSchemaAll)particle, root);
			}
			if (particle is XmlSchemaChoice)
			{
				return CannonicalizeChoice((XmlSchemaChoice)particle, root);
			}
			if (particle is XmlSchemaSequence)
			{
				return CannonicalizeSequence((XmlSchemaSequence)particle, root);
			}
			return particle;
		}

		private XmlSchemaParticle CannonicalizeElement(XmlSchemaElement element)
		{
			if (!element.RefName.IsEmpty && (element.ElementDecl.Block & XmlSchemaDerivationMethod.Substitution) == 0)
			{
				XmlSchemaSubstitutionGroup xmlSchemaSubstitutionGroup = (XmlSchemaSubstitutionGroup)examplars[element.QualifiedName];
				if (xmlSchemaSubstitutionGroup == null)
				{
					return element;
				}
				XmlSchemaChoice xmlSchemaChoice = new XmlSchemaChoice();
				foreach (XmlSchemaElement member in xmlSchemaSubstitutionGroup.Members)
				{
					xmlSchemaChoice.Items.Add(member);
				}
				xmlSchemaChoice.MinOccurs = element.MinOccurs;
				xmlSchemaChoice.MaxOccurs = element.MaxOccurs;
				CopyPosition(xmlSchemaChoice, element, copyParent: false);
				return xmlSchemaChoice;
			}
			return element;
		}

		private XmlSchemaParticle CannonicalizeGroupRef(XmlSchemaGroupRef groupRef, bool root)
		{
			XmlSchemaGroup xmlSchemaGroup = ((groupRef.Redefined == null) ? ((XmlSchemaGroup)groups[groupRef.RefName]) : groupRef.Redefined);
			if (xmlSchemaGroup == null)
			{
				SendValidationEvent("Sch_UndefGroupRef", groupRef.RefName.ToString(), groupRef);
				return XmlSchemaParticle.Empty;
			}
			if (xmlSchemaGroup.CanonicalParticle == null)
			{
				CompileGroup(xmlSchemaGroup);
			}
			if (xmlSchemaGroup.CanonicalParticle == XmlSchemaParticle.Empty)
			{
				return XmlSchemaParticle.Empty;
			}
			XmlSchemaGroupBase xmlSchemaGroupBase = (XmlSchemaGroupBase)xmlSchemaGroup.CanonicalParticle;
			if (xmlSchemaGroupBase is XmlSchemaAll)
			{
				if (!root)
				{
					SendValidationEvent("Sch_AllRefNotRoot", "", groupRef);
					return XmlSchemaParticle.Empty;
				}
				if (groupRef.MinOccurs > 1m || groupRef.MaxOccurs != 1m)
				{
					SendValidationEvent("Sch_AllRefMinMax", groupRef);
					return XmlSchemaParticle.Empty;
				}
			}
			else if (xmlSchemaGroupBase is XmlSchemaChoice && xmlSchemaGroupBase.Items.Count == 0)
			{
				if (groupRef.MinOccurs != 0m)
				{
					SendValidationEvent("Sch_EmptyChoice", groupRef, XmlSeverityType.Warning);
				}
				return XmlSchemaParticle.Empty;
			}
			XmlSchemaGroupBase xmlSchemaGroupBase2 = ((xmlSchemaGroupBase is XmlSchemaSequence) ? new XmlSchemaSequence() : ((xmlSchemaGroupBase is XmlSchemaChoice) ? ((XmlSchemaGroupBase)new XmlSchemaChoice()) : ((XmlSchemaGroupBase)new XmlSchemaAll())));
			xmlSchemaGroupBase2.MinOccurs = groupRef.MinOccurs;
			xmlSchemaGroupBase2.MaxOccurs = groupRef.MaxOccurs;
			xmlSchemaGroupBase2.LineNumber = groupRef.LineNumber;
			xmlSchemaGroupBase2.LinePosition = groupRef.LinePosition;
			foreach (XmlSchemaParticle item in xmlSchemaGroupBase.Items)
			{
				xmlSchemaGroupBase2.Items.Add(item);
			}
			groupRef.SetParticle(xmlSchemaGroupBase2);
			return xmlSchemaGroupBase2;
		}

		private XmlSchemaParticle CannonicalizeAll(XmlSchemaAll all, bool root)
		{
			if (all.Items.Count > 0)
			{
				XmlSchemaAll xmlSchemaAll = new XmlSchemaAll();
				xmlSchemaAll.MinOccurs = all.MinOccurs;
				xmlSchemaAll.MaxOccurs = all.MaxOccurs;
				CopyPosition(xmlSchemaAll, all, copyParent: true);
				foreach (XmlSchemaElement item in all.Items)
				{
					XmlSchemaParticle xmlSchemaParticle = CannonicalizeParticle(item, root: false);
					if (xmlSchemaParticle != XmlSchemaParticle.Empty)
					{
						xmlSchemaAll.Items.Add(xmlSchemaParticle);
					}
				}
				all = xmlSchemaAll;
			}
			if (all.Items.Count == 0)
			{
				return XmlSchemaParticle.Empty;
			}
			if (!root)
			{
				SendValidationEvent("Sch_NotAllAlone", all);
				return XmlSchemaParticle.Empty;
			}
			return all;
		}

		private XmlSchemaParticle CannonicalizeChoice(XmlSchemaChoice choice, bool root)
		{
			XmlSchemaChoice source = choice;
			if (choice.Items.Count > 0)
			{
				XmlSchemaChoice xmlSchemaChoice = new XmlSchemaChoice();
				xmlSchemaChoice.MinOccurs = choice.MinOccurs;
				xmlSchemaChoice.MaxOccurs = choice.MaxOccurs;
				CopyPosition(xmlSchemaChoice, choice, copyParent: true);
				foreach (XmlSchemaParticle item2 in choice.Items)
				{
					XmlSchemaParticle xmlSchemaParticle = CannonicalizeParticle(item2, root: false);
					if (xmlSchemaParticle == XmlSchemaParticle.Empty)
					{
						continue;
					}
					if (xmlSchemaParticle.MinOccurs == 1m && xmlSchemaParticle.MaxOccurs == 1m && xmlSchemaParticle is XmlSchemaChoice)
					{
						foreach (XmlSchemaParticle item3 in ((XmlSchemaChoice)xmlSchemaParticle).Items)
						{
							xmlSchemaChoice.Items.Add(item3);
						}
					}
					else
					{
						xmlSchemaChoice.Items.Add(xmlSchemaParticle);
					}
				}
				choice = xmlSchemaChoice;
			}
			if (!root && choice.Items.Count == 0)
			{
				if (choice.MinOccurs != 0m)
				{
					SendValidationEvent("Sch_EmptyChoice", source, XmlSeverityType.Warning);
				}
				return XmlSchemaParticle.Empty;
			}
			if (!root && choice.Items.Count == 1 && choice.MinOccurs == 1m && choice.MaxOccurs == 1m)
			{
				return (XmlSchemaParticle)choice.Items[0];
			}
			return choice;
		}

		private XmlSchemaParticle CannonicalizeSequence(XmlSchemaSequence sequence, bool root)
		{
			if (sequence.Items.Count > 0)
			{
				XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
				xmlSchemaSequence.MinOccurs = sequence.MinOccurs;
				xmlSchemaSequence.MaxOccurs = sequence.MaxOccurs;
				CopyPosition(xmlSchemaSequence, sequence, copyParent: true);
				foreach (XmlSchemaParticle item2 in sequence.Items)
				{
					XmlSchemaParticle xmlSchemaParticle = CannonicalizeParticle(item2, root: false);
					if (xmlSchemaParticle == XmlSchemaParticle.Empty)
					{
						continue;
					}
					if (xmlSchemaParticle.MinOccurs == 1m && xmlSchemaParticle.MaxOccurs == 1m && xmlSchemaParticle is XmlSchemaSequence)
					{
						foreach (XmlSchemaParticle item3 in ((XmlSchemaSequence)xmlSchemaParticle).Items)
						{
							xmlSchemaSequence.Items.Add(item3);
						}
					}
					else
					{
						xmlSchemaSequence.Items.Add(xmlSchemaParticle);
					}
				}
				sequence = xmlSchemaSequence;
			}
			if (sequence.Items.Count == 0)
			{
				return XmlSchemaParticle.Empty;
			}
			if (!root && sequence.Items.Count == 1 && sequence.MinOccurs == 1m && sequence.MaxOccurs == 1m)
			{
				return (XmlSchemaParticle)sequence.Items[0];
			}
			return sequence;
		}

		private XmlSchemaParticle CannonicalizePointlessRoot(XmlSchemaParticle particle)
		{
			if (particle == null)
			{
				return null;
			}
			decimal num = 1m;
			if (particle is XmlSchemaSequence xmlSchemaSequence)
			{
				XmlSchemaObjectCollection items = xmlSchemaSequence.Items;
				int count = items.Count;
				if (count == 1 && xmlSchemaSequence.MinOccurs == num && xmlSchemaSequence.MaxOccurs == num)
				{
					return (XmlSchemaParticle)items[0];
				}
			}
			else if (particle is XmlSchemaChoice xmlSchemaChoice)
			{
				XmlSchemaObjectCollection items2 = xmlSchemaChoice.Items;
				switch (items2.Count)
				{
				case 1:
					if (xmlSchemaChoice.MinOccurs == num && xmlSchemaChoice.MaxOccurs == num)
					{
						return (XmlSchemaParticle)items2[0];
					}
					break;
				case 0:
					return XmlSchemaParticle.Empty;
				}
			}
			else if (particle is XmlSchemaAll xmlSchemaAll)
			{
				XmlSchemaObjectCollection items3 = xmlSchemaAll.Items;
				int count2 = items3.Count;
				if (count2 == 1 && xmlSchemaAll.MinOccurs == num && xmlSchemaAll.MaxOccurs == num)
				{
					return (XmlSchemaParticle)items3[0];
				}
			}
			return particle;
		}

		private bool IsValidRestriction(XmlSchemaParticle derivedParticle, XmlSchemaParticle baseParticle)
		{
			if (derivedParticle == baseParticle)
			{
				return true;
			}
			if (derivedParticle == null || derivedParticle == XmlSchemaParticle.Empty)
			{
				return IsParticleEmptiable(baseParticle);
			}
			if (baseParticle == null || baseParticle == XmlSchemaParticle.Empty)
			{
				return false;
			}
			if (derivedParticle is XmlSchemaElement)
			{
				XmlSchemaElement element = (XmlSchemaElement)derivedParticle;
				derivedParticle = CannonicalizeElement(element);
			}
			if (baseParticle is XmlSchemaElement)
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)baseParticle;
				XmlSchemaParticle xmlSchemaParticle = CannonicalizeElement(xmlSchemaElement);
				if (xmlSchemaParticle is XmlSchemaChoice)
				{
					return IsValidRestriction(derivedParticle, xmlSchemaParticle);
				}
				if (derivedParticle is XmlSchemaElement)
				{
					return IsElementFromElement((XmlSchemaElement)derivedParticle, xmlSchemaElement);
				}
				restrictionErrorMsg = Res.GetString("Sch_ForbiddenDerivedParticleForElem");
				return false;
			}
			if (baseParticle is XmlSchemaAny)
			{
				if (derivedParticle is XmlSchemaElement)
				{
					return IsElementFromAny((XmlSchemaElement)derivedParticle, (XmlSchemaAny)baseParticle);
				}
				if (derivedParticle is XmlSchemaAny)
				{
					return IsAnyFromAny((XmlSchemaAny)derivedParticle, (XmlSchemaAny)baseParticle);
				}
				return IsGroupBaseFromAny((XmlSchemaGroupBase)derivedParticle, (XmlSchemaAny)baseParticle);
			}
			if (baseParticle is XmlSchemaAll)
			{
				if (derivedParticle is XmlSchemaElement)
				{
					return IsElementFromGroupBase((XmlSchemaElement)derivedParticle, (XmlSchemaGroupBase)baseParticle);
				}
				if (derivedParticle is XmlSchemaAll)
				{
					if (IsGroupBaseFromGroupBase((XmlSchemaGroupBase)derivedParticle, (XmlSchemaGroupBase)baseParticle, skipEmptableOnly: true))
					{
						return true;
					}
				}
				else if (derivedParticle is XmlSchemaSequence)
				{
					if (IsSequenceFromAll((XmlSchemaSequence)derivedParticle, (XmlSchemaAll)baseParticle))
					{
						return true;
					}
					restrictionErrorMsg = Res.GetString("Sch_SeqFromAll", derivedParticle.LineNumber.ToString(NumberFormatInfo.InvariantInfo), derivedParticle.LinePosition.ToString(NumberFormatInfo.InvariantInfo), baseParticle.LineNumber.ToString(NumberFormatInfo.InvariantInfo), baseParticle.LinePosition.ToString(NumberFormatInfo.InvariantInfo));
				}
				else if (derivedParticle is XmlSchemaChoice || derivedParticle is XmlSchemaAny)
				{
					restrictionErrorMsg = Res.GetString("Sch_ForbiddenDerivedParticleForAll");
				}
				return false;
			}
			if (baseParticle is XmlSchemaChoice)
			{
				if (derivedParticle is XmlSchemaElement)
				{
					return IsElementFromGroupBase((XmlSchemaElement)derivedParticle, (XmlSchemaGroupBase)baseParticle);
				}
				if (derivedParticle is XmlSchemaChoice)
				{
					XmlSchemaChoice xmlSchemaChoice = baseParticle as XmlSchemaChoice;
					XmlSchemaChoice xmlSchemaChoice2 = derivedParticle as XmlSchemaChoice;
					if (xmlSchemaChoice.Parent == null || xmlSchemaChoice2.Parent == null)
					{
						return IsChoiceFromChoiceSubstGroup(xmlSchemaChoice2, xmlSchemaChoice);
					}
					if (IsGroupBaseFromGroupBase(xmlSchemaChoice2, xmlSchemaChoice, skipEmptableOnly: false))
					{
						return true;
					}
				}
				else if (derivedParticle is XmlSchemaSequence)
				{
					if (IsSequenceFromChoice((XmlSchemaSequence)derivedParticle, (XmlSchemaChoice)baseParticle))
					{
						return true;
					}
					restrictionErrorMsg = Res.GetString("Sch_SeqFromChoice", derivedParticle.LineNumber.ToString(NumberFormatInfo.InvariantInfo), derivedParticle.LinePosition.ToString(NumberFormatInfo.InvariantInfo), baseParticle.LineNumber.ToString(NumberFormatInfo.InvariantInfo), baseParticle.LinePosition.ToString(NumberFormatInfo.InvariantInfo));
				}
				else
				{
					restrictionErrorMsg = Res.GetString("Sch_ForbiddenDerivedParticleForChoice");
				}
				return false;
			}
			if (baseParticle is XmlSchemaSequence)
			{
				if (derivedParticle is XmlSchemaElement)
				{
					return IsElementFromGroupBase((XmlSchemaElement)derivedParticle, (XmlSchemaGroupBase)baseParticle);
				}
				if (derivedParticle is XmlSchemaSequence || (derivedParticle is XmlSchemaAll && ((XmlSchemaGroupBase)derivedParticle).Items.Count == 1))
				{
					if (IsGroupBaseFromGroupBase((XmlSchemaGroupBase)derivedParticle, (XmlSchemaGroupBase)baseParticle, skipEmptableOnly: true))
					{
						return true;
					}
				}
				else
				{
					restrictionErrorMsg = Res.GetString("Sch_ForbiddenDerivedParticleForSeq");
				}
				return false;
			}
			return false;
		}

		private bool IsElementFromElement(XmlSchemaElement derivedElement, XmlSchemaElement baseElement)
		{
			if (!(derivedElement.QualifiedName == baseElement.QualifiedName) || (!baseElement.IsNillable && derivedElement.IsNillable) || !IsValidOccurrenceRangeRestriction(derivedElement, baseElement) || (baseElement.FixedValue != null && !IsFixedEqual(baseElement.ElementDecl, derivedElement.ElementDecl)) || (derivedElement.ElementDecl.Block | baseElement.ElementDecl.Block) != derivedElement.ElementDecl.Block || derivedElement.ElementSchemaType == null || baseElement.ElementSchemaType == null || !XmlSchemaType.IsDerivedFrom(derivedElement.ElementSchemaType, baseElement.ElementSchemaType, ~(XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union)))
			{
				restrictionErrorMsg = Res.GetString("Sch_ElementFromElement", derivedElement.QualifiedName, baseElement.QualifiedName);
				return false;
			}
			return true;
		}

		private bool IsElementFromAny(XmlSchemaElement derivedElement, XmlSchemaAny baseAny)
		{
			if (!baseAny.Allows(derivedElement.QualifiedName))
			{
				restrictionErrorMsg = Res.GetString("Sch_ElementFromAnyRule1", derivedElement.QualifiedName.ToString());
				return false;
			}
			if (!IsValidOccurrenceRangeRestriction(derivedElement, baseAny))
			{
				restrictionErrorMsg = Res.GetString("Sch_ElementFromAnyRule2", derivedElement.QualifiedName.ToString());
				return false;
			}
			return true;
		}

		private bool IsAnyFromAny(XmlSchemaAny derivedAny, XmlSchemaAny baseAny)
		{
			if (!IsValidOccurrenceRangeRestriction(derivedAny, baseAny))
			{
				restrictionErrorMsg = Res.GetString("Sch_AnyFromAnyRule1");
				return false;
			}
			if (!NamespaceList.IsSubset(derivedAny.NamespaceList, baseAny.NamespaceList))
			{
				restrictionErrorMsg = Res.GetString("Sch_AnyFromAnyRule2");
				return false;
			}
			if (derivedAny.ProcessContentsCorrect < baseAny.ProcessContentsCorrect)
			{
				restrictionErrorMsg = Res.GetString("Sch_AnyFromAnyRule3");
				return false;
			}
			return true;
		}

		private bool IsGroupBaseFromAny(XmlSchemaGroupBase derivedGroupBase, XmlSchemaAny baseAny)
		{
			CalculateEffectiveTotalRange(derivedGroupBase, out var minOccurs, out var maxOccurs);
			if (!IsValidOccurrenceRangeRestriction(minOccurs, maxOccurs, baseAny.MinOccurs, baseAny.MaxOccurs))
			{
				restrictionErrorMsg = Res.GetString("Sch_GroupBaseFromAny2", derivedGroupBase.LineNumber.ToString(NumberFormatInfo.InvariantInfo), derivedGroupBase.LinePosition.ToString(NumberFormatInfo.InvariantInfo), baseAny.LineNumber.ToString(NumberFormatInfo.InvariantInfo), baseAny.LinePosition.ToString(NumberFormatInfo.InvariantInfo));
				return false;
			}
			string minOccursString = baseAny.MinOccursString;
			baseAny.MinOccurs = 0m;
			foreach (XmlSchemaParticle item in derivedGroupBase.Items)
			{
				if (!IsValidRestriction(item, baseAny))
				{
					restrictionErrorMsg = Res.GetString("Sch_GroupBaseFromAny1");
					baseAny.MinOccursString = minOccursString;
					return false;
				}
			}
			baseAny.MinOccursString = minOccursString;
			return true;
		}

		private bool IsElementFromGroupBase(XmlSchemaElement derivedElement, XmlSchemaGroupBase baseGroupBase)
		{
			if (baseGroupBase is XmlSchemaSequence)
			{
				XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
				xmlSchemaSequence.MinOccurs = 1m;
				xmlSchemaSequence.MaxOccurs = 1m;
				xmlSchemaSequence.Items.Add(derivedElement);
				if (IsGroupBaseFromGroupBase(xmlSchemaSequence, baseGroupBase, skipEmptableOnly: true))
				{
					return true;
				}
				restrictionErrorMsg = Res.GetString("Sch_ElementFromGroupBase1", derivedElement.QualifiedName.ToString(), derivedElement.LineNumber.ToString(NumberFormatInfo.InvariantInfo), derivedElement.LinePosition.ToString(NumberFormatInfo.InvariantInfo), baseGroupBase.LineNumber.ToString(NumberFormatInfo.InvariantInfo), baseGroupBase.LinePosition.ToString(NumberFormatInfo.InvariantInfo));
			}
			else if (baseGroupBase is XmlSchemaChoice)
			{
				XmlSchemaChoice xmlSchemaChoice = new XmlSchemaChoice();
				xmlSchemaChoice.MinOccurs = 1m;
				xmlSchemaChoice.MaxOccurs = 1m;
				xmlSchemaChoice.Items.Add(derivedElement);
				if (IsGroupBaseFromGroupBase(xmlSchemaChoice, baseGroupBase, skipEmptableOnly: false))
				{
					return true;
				}
				restrictionErrorMsg = Res.GetString("Sch_ElementFromGroupBase2", derivedElement.QualifiedName.ToString(), derivedElement.LineNumber.ToString(NumberFormatInfo.InvariantInfo), derivedElement.LinePosition.ToString(NumberFormatInfo.InvariantInfo), baseGroupBase.LineNumber.ToString(NumberFormatInfo.InvariantInfo), baseGroupBase.LinePosition.ToString(NumberFormatInfo.InvariantInfo));
			}
			else if (baseGroupBase is XmlSchemaAll)
			{
				XmlSchemaAll xmlSchemaAll = new XmlSchemaAll();
				xmlSchemaAll.MinOccurs = 1m;
				xmlSchemaAll.MaxOccurs = 1m;
				xmlSchemaAll.Items.Add(derivedElement);
				if (IsGroupBaseFromGroupBase(xmlSchemaAll, baseGroupBase, skipEmptableOnly: true))
				{
					return true;
				}
				restrictionErrorMsg = Res.GetString("Sch_ElementFromGroupBase3", derivedElement.QualifiedName.ToString(), derivedElement.LineNumber.ToString(NumberFormatInfo.InvariantInfo), derivedElement.LinePosition.ToString(NumberFormatInfo.InvariantInfo), baseGroupBase.LineNumber.ToString(NumberFormatInfo.InvariantInfo), baseGroupBase.LinePosition.ToString(NumberFormatInfo.InvariantInfo));
			}
			return false;
		}

		private bool IsChoiceFromChoiceSubstGroup(XmlSchemaChoice derivedChoice, XmlSchemaChoice baseChoice)
		{
			if (!IsValidOccurrenceRangeRestriction(derivedChoice, baseChoice))
			{
				restrictionErrorMsg = Res.GetString("Sch_GroupBaseRestRangeInvalid");
				return false;
			}
			foreach (XmlSchemaParticle item in derivedChoice.Items)
			{
				if (GetMappingParticle(item, baseChoice.Items) < 0)
				{
					return false;
				}
			}
			return true;
		}

		private bool IsGroupBaseFromGroupBase(XmlSchemaGroupBase derivedGroupBase, XmlSchemaGroupBase baseGroupBase, bool skipEmptableOnly)
		{
			if (!IsValidOccurrenceRangeRestriction(derivedGroupBase, baseGroupBase))
			{
				restrictionErrorMsg = Res.GetString("Sch_GroupBaseRestRangeInvalid");
				return false;
			}
			if (derivedGroupBase.Items.Count > baseGroupBase.Items.Count)
			{
				restrictionErrorMsg = Res.GetString("Sch_GroupBaseRestNoMap");
				return false;
			}
			int num = 0;
			foreach (XmlSchemaParticle item in baseGroupBase.Items)
			{
				if (num < derivedGroupBase.Items.Count && IsValidRestriction((XmlSchemaParticle)derivedGroupBase.Items[num], item))
				{
					num++;
				}
				else if (skipEmptableOnly && !IsParticleEmptiable(item))
				{
					if (restrictionErrorMsg == null)
					{
						restrictionErrorMsg = Res.GetString("Sch_GroupBaseRestNotEmptiable");
					}
					return false;
				}
			}
			if (num < derivedGroupBase.Items.Count)
			{
				return false;
			}
			return true;
		}

		private bool IsSequenceFromAll(XmlSchemaSequence derivedSequence, XmlSchemaAll baseAll)
		{
			if (!IsValidOccurrenceRangeRestriction(derivedSequence, baseAll) || derivedSequence.Items.Count > baseAll.Items.Count)
			{
				return false;
			}
			BitSet bitSet = new BitSet(baseAll.Items.Count);
			foreach (XmlSchemaParticle item in derivedSequence.Items)
			{
				int mappingParticle = GetMappingParticle(item, baseAll.Items);
				if (mappingParticle >= 0)
				{
					if (bitSet[mappingParticle])
					{
						return false;
					}
					bitSet.Set(mappingParticle);
					continue;
				}
				return false;
			}
			for (int i = 0; i < baseAll.Items.Count; i++)
			{
				if (!bitSet[i] && !IsParticleEmptiable((XmlSchemaParticle)baseAll.Items[i]))
				{
					return false;
				}
			}
			return true;
		}

		private bool IsSequenceFromChoice(XmlSchemaSequence derivedSequence, XmlSchemaChoice baseChoice)
		{
			decimal minOccurs = derivedSequence.MinOccurs * (decimal)derivedSequence.Items.Count;
			decimal maxOccurs = ((!(derivedSequence.MaxOccurs == decimal.MaxValue)) ? (derivedSequence.MaxOccurs * (decimal)derivedSequence.Items.Count) : decimal.MaxValue);
			if (!IsValidOccurrenceRangeRestriction(minOccurs, maxOccurs, baseChoice.MinOccurs, baseChoice.MaxOccurs) || derivedSequence.Items.Count > baseChoice.Items.Count)
			{
				return false;
			}
			foreach (XmlSchemaParticle item in derivedSequence.Items)
			{
				if (GetMappingParticle(item, baseChoice.Items) < 0)
				{
					return false;
				}
			}
			return true;
		}

		private bool IsValidOccurrenceRangeRestriction(XmlSchemaParticle derivedParticle, XmlSchemaParticle baseParticle)
		{
			return IsValidOccurrenceRangeRestriction(derivedParticle.MinOccurs, derivedParticle.MaxOccurs, baseParticle.MinOccurs, baseParticle.MaxOccurs);
		}

		private bool IsValidOccurrenceRangeRestriction(decimal minOccurs, decimal maxOccurs, decimal baseMinOccurs, decimal baseMaxOccurs)
		{
			if (baseMinOccurs <= minOccurs)
			{
				return maxOccurs <= baseMaxOccurs;
			}
			return false;
		}

		private int GetMappingParticle(XmlSchemaParticle particle, XmlSchemaObjectCollection collection)
		{
			for (int i = 0; i < collection.Count; i++)
			{
				if (IsValidRestriction(particle, (XmlSchemaParticle)collection[i]))
				{
					return i;
				}
			}
			return -1;
		}

		private bool IsParticleEmptiable(XmlSchemaParticle particle)
		{
			CalculateEffectiveTotalRange(particle, out var minOccurs, out var _);
			return minOccurs == 0m;
		}

		private void CalculateEffectiveTotalRange(XmlSchemaParticle particle, out decimal minOccurs, out decimal maxOccurs)
		{
			if (particle is XmlSchemaElement || particle is XmlSchemaAny)
			{
				minOccurs = particle.MinOccurs;
				maxOccurs = particle.MaxOccurs;
				return;
			}
			if (particle is XmlSchemaChoice)
			{
				if (((XmlSchemaChoice)particle).Items.Count == 0)
				{
					minOccurs = (maxOccurs = 0m);
					return;
				}
				minOccurs = decimal.MaxValue;
				maxOccurs = 0m;
				foreach (XmlSchemaParticle item in ((XmlSchemaChoice)particle).Items)
				{
					CalculateEffectiveTotalRange(item, out var minOccurs2, out var maxOccurs2);
					if (minOccurs2 < minOccurs)
					{
						minOccurs = minOccurs2;
					}
					if (maxOccurs2 > maxOccurs)
					{
						maxOccurs = maxOccurs2;
					}
				}
				minOccurs *= particle.MinOccurs;
				if (maxOccurs != decimal.MaxValue)
				{
					if (particle.MaxOccurs == decimal.MaxValue)
					{
						maxOccurs = decimal.MaxValue;
					}
					else
					{
						maxOccurs *= particle.MaxOccurs;
					}
				}
				return;
			}
			XmlSchemaObjectCollection items = ((XmlSchemaGroupBase)particle).Items;
			if (items.Count == 0)
			{
				minOccurs = (maxOccurs = 0m);
				return;
			}
			minOccurs = 0m;
			maxOccurs = 0m;
			foreach (XmlSchemaParticle item2 in items)
			{
				CalculateEffectiveTotalRange(item2, out var minOccurs3, out var maxOccurs3);
				minOccurs += minOccurs3;
				if (maxOccurs != decimal.MaxValue)
				{
					if (maxOccurs3 == decimal.MaxValue)
					{
						maxOccurs = decimal.MaxValue;
					}
					else
					{
						maxOccurs += maxOccurs3;
					}
				}
			}
			minOccurs *= particle.MinOccurs;
			if (maxOccurs != decimal.MaxValue)
			{
				if (particle.MaxOccurs == decimal.MaxValue)
				{
					maxOccurs = decimal.MaxValue;
				}
				else
				{
					maxOccurs *= particle.MaxOccurs;
				}
			}
		}

		private void PushComplexType(XmlSchemaComplexType complexType)
		{
			complexTypeStack.Push(complexType);
		}

		private XmlSchemaContentType GetSchemaContentType(XmlSchemaComplexType complexType, XmlSchemaComplexContent complexContent, XmlSchemaParticle particle)
		{
			if ((complexContent != null && complexContent.IsMixed) || (complexContent == null && complexType.IsMixed))
			{
				return XmlSchemaContentType.Mixed;
			}
			if (particle != null && !particle.IsEmpty)
			{
				return XmlSchemaContentType.ElementOnly;
			}
			return XmlSchemaContentType.Empty;
		}

		private void CompileAttributeGroup(XmlSchemaAttributeGroup attributeGroup)
		{
			if (attributeGroup.IsProcessing)
			{
				SendValidationEvent("Sch_AttributeGroupCircularRef", attributeGroup);
			}
			else
			{
				if (attributeGroup.AttributeUses.Count > 0)
				{
					return;
				}
				attributeGroup.IsProcessing = true;
				XmlSchemaAnyAttribute xmlSchemaAnyAttribute = attributeGroup.AnyAttribute;
				try
				{
					foreach (XmlSchemaObject attribute in attributeGroup.Attributes)
					{
						if (attribute is XmlSchemaAttribute)
						{
							XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)attribute;
							if (xmlSchemaAttribute.Use != XmlSchemaUse.Prohibited)
							{
								CompileAttribute(xmlSchemaAttribute);
								if (attributeGroup.AttributeUses[xmlSchemaAttribute.QualifiedName] == null)
								{
									attributeGroup.AttributeUses.Add(xmlSchemaAttribute.QualifiedName, xmlSchemaAttribute);
								}
								else
								{
									SendValidationEvent("Sch_DupAttributeUse", xmlSchemaAttribute.QualifiedName.ToString(), xmlSchemaAttribute);
								}
							}
							continue;
						}
						XmlSchemaAttributeGroupRef xmlSchemaAttributeGroupRef = (XmlSchemaAttributeGroupRef)attribute;
						XmlSchemaAttributeGroup xmlSchemaAttributeGroup = ((attributeGroup.Redefined == null || !(xmlSchemaAttributeGroupRef.RefName == attributeGroup.Redefined.QualifiedName)) ? ((XmlSchemaAttributeGroup)attributeGroups[xmlSchemaAttributeGroupRef.RefName]) : attributeGroup.Redefined);
						if (xmlSchemaAttributeGroup != null)
						{
							CompileAttributeGroup(xmlSchemaAttributeGroup);
							foreach (XmlSchemaAttribute value in xmlSchemaAttributeGroup.AttributeUses.Values)
							{
								if (attributeGroup.AttributeUses[value.QualifiedName] == null)
								{
									attributeGroup.AttributeUses.Add(value.QualifiedName, value);
								}
								else
								{
									SendValidationEvent("Sch_DupAttributeUse", value.QualifiedName.ToString(), value);
								}
							}
							xmlSchemaAnyAttribute = CompileAnyAttributeIntersection(xmlSchemaAnyAttribute, xmlSchemaAttributeGroup.AttributeWildcard);
						}
						else
						{
							SendValidationEvent("Sch_UndefAttributeGroupRef", xmlSchemaAttributeGroupRef.RefName.ToString(), xmlSchemaAttributeGroupRef);
						}
					}
					attributeGroup.AttributeWildcard = xmlSchemaAnyAttribute;
				}
				finally
				{
					attributeGroup.IsProcessing = false;
				}
			}
		}

		private void CompileLocalAttributes(XmlSchemaComplexType baseType, XmlSchemaComplexType derivedType, XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, XmlSchemaDerivationMethod derivedBy)
		{
			XmlSchemaAnyAttribute xmlSchemaAnyAttribute = baseType?.AttributeWildcard;
			foreach (XmlSchemaObject attribute in attributes)
			{
				if (attribute is XmlSchemaAttribute)
				{
					XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)attribute;
					if (xmlSchemaAttribute.Use != XmlSchemaUse.Prohibited)
					{
						CompileAttribute(xmlSchemaAttribute);
					}
					if (xmlSchemaAttribute.Use != XmlSchemaUse.Prohibited || (xmlSchemaAttribute.Use == XmlSchemaUse.Prohibited && derivedBy == XmlSchemaDerivationMethod.Restriction && baseType != XmlSchemaComplexType.AnyType))
					{
						if (derivedType.AttributeUses[xmlSchemaAttribute.QualifiedName] == null)
						{
							derivedType.AttributeUses.Add(xmlSchemaAttribute.QualifiedName, xmlSchemaAttribute);
						}
						else
						{
							SendValidationEvent("Sch_DupAttributeUse", xmlSchemaAttribute.QualifiedName.ToString(), xmlSchemaAttribute);
						}
					}
					else
					{
						SendValidationEvent("Sch_AttributeIgnored", xmlSchemaAttribute.QualifiedName.ToString(), xmlSchemaAttribute, XmlSeverityType.Warning);
					}
					continue;
				}
				XmlSchemaAttributeGroupRef xmlSchemaAttributeGroupRef = (XmlSchemaAttributeGroupRef)attribute;
				XmlSchemaAttributeGroup xmlSchemaAttributeGroup = (XmlSchemaAttributeGroup)attributeGroups[xmlSchemaAttributeGroupRef.RefName];
				if (xmlSchemaAttributeGroup != null)
				{
					CompileAttributeGroup(xmlSchemaAttributeGroup);
					foreach (XmlSchemaAttribute value in xmlSchemaAttributeGroup.AttributeUses.Values)
					{
						if (value.Use != XmlSchemaUse.Prohibited || (value.Use == XmlSchemaUse.Prohibited && derivedBy == XmlSchemaDerivationMethod.Restriction && baseType != XmlSchemaComplexType.AnyType))
						{
							if (derivedType.AttributeUses[value.QualifiedName] == null)
							{
								derivedType.AttributeUses.Add(value.QualifiedName, value);
							}
							else
							{
								SendValidationEvent("Sch_DupAttributeUse", value.QualifiedName.ToString(), xmlSchemaAttributeGroupRef);
							}
						}
						else
						{
							SendValidationEvent("Sch_AttributeIgnored", value.QualifiedName.ToString(), value, XmlSeverityType.Warning);
						}
					}
					anyAttribute = CompileAnyAttributeIntersection(anyAttribute, xmlSchemaAttributeGroup.AttributeWildcard);
				}
				else
				{
					SendValidationEvent("Sch_UndefAttributeGroupRef", xmlSchemaAttributeGroupRef.RefName.ToString(), xmlSchemaAttributeGroupRef);
				}
			}
			if (baseType != null)
			{
				if (derivedBy == XmlSchemaDerivationMethod.Extension)
				{
					derivedType.SetAttributeWildcard(CompileAnyAttributeUnion(anyAttribute, xmlSchemaAnyAttribute));
					{
						foreach (XmlSchemaAttribute value2 in baseType.AttributeUses.Values)
						{
							XmlSchemaAttribute xmlSchemaAttribute4 = (XmlSchemaAttribute)derivedType.AttributeUses[value2.QualifiedName];
							if (xmlSchemaAttribute4 == null)
							{
								derivedType.AttributeUses.Add(value2.QualifiedName, value2);
							}
							else if (value2.Use != XmlSchemaUse.Prohibited && xmlSchemaAttribute4.AttributeSchemaType != value2.AttributeSchemaType)
							{
								SendValidationEvent("Sch_InvalidAttributeExtension", xmlSchemaAttribute4);
							}
						}
						return;
					}
				}
				if (anyAttribute != null && (xmlSchemaAnyAttribute == null || !XmlSchemaAnyAttribute.IsSubset(anyAttribute, xmlSchemaAnyAttribute) || !IsProcessContentsRestricted(baseType, anyAttribute, xmlSchemaAnyAttribute)))
				{
					SendValidationEvent("Sch_InvalidAnyAttributeRestriction", derivedType);
				}
				else
				{
					derivedType.SetAttributeWildcard(anyAttribute);
				}
				foreach (XmlSchemaAttribute value3 in baseType.AttributeUses.Values)
				{
					XmlSchemaAttribute xmlSchemaAttribute6 = (XmlSchemaAttribute)derivedType.AttributeUses[value3.QualifiedName];
					if (xmlSchemaAttribute6 == null)
					{
						derivedType.AttributeUses.Add(value3.QualifiedName, value3);
					}
					else if (value3.Use == XmlSchemaUse.Prohibited && xmlSchemaAttribute6.Use != XmlSchemaUse.Prohibited)
					{
						SendValidationEvent("Sch_AttributeRestrictionProhibited", xmlSchemaAttribute6);
					}
					else if (value3.Use == XmlSchemaUse.Required && xmlSchemaAttribute6.Use != XmlSchemaUse.Required)
					{
						SendValidationEvent("Sch_AttributeUseInvalid", xmlSchemaAttribute6);
					}
					else if (xmlSchemaAttribute6.Use != XmlSchemaUse.Prohibited)
					{
						if (value3.AttributeSchemaType == null || xmlSchemaAttribute6.AttributeSchemaType == null || !XmlSchemaType.IsDerivedFrom(xmlSchemaAttribute6.AttributeSchemaType, value3.AttributeSchemaType, XmlSchemaDerivationMethod.Empty))
						{
							SendValidationEvent("Sch_AttributeRestrictionInvalid", xmlSchemaAttribute6);
						}
						else if (!IsFixedEqual(value3.AttDef, xmlSchemaAttribute6.AttDef))
						{
							SendValidationEvent("Sch_AttributeFixedInvalid", xmlSchemaAttribute6);
						}
					}
				}
				{
					foreach (XmlSchemaAttribute value4 in derivedType.AttributeUses.Values)
					{
						XmlSchemaAttribute xmlSchemaAttribute8 = (XmlSchemaAttribute)baseType.AttributeUses[value4.QualifiedName];
						if (xmlSchemaAttribute8 == null && (xmlSchemaAnyAttribute == null || !xmlSchemaAnyAttribute.Allows(value4.QualifiedName)))
						{
							SendValidationEvent("Sch_AttributeRestrictionInvalidFromWildcard", value4);
						}
					}
					return;
				}
			}
			derivedType.SetAttributeWildcard(anyAttribute);
		}

		private void CheckAtrributeGroupRestriction(XmlSchemaAttributeGroup baseAttributeGroup, XmlSchemaAttributeGroup derivedAttributeGroup)
		{
			XmlSchemaAnyAttribute attributeWildcard = baseAttributeGroup.AttributeWildcard;
			XmlSchemaAnyAttribute attributeWildcard2 = derivedAttributeGroup.AttributeWildcard;
			if (attributeWildcard2 != null && (attributeWildcard == null || !XmlSchemaAnyAttribute.IsSubset(attributeWildcard2, attributeWildcard) || !IsProcessContentsRestricted(null, attributeWildcard2, attributeWildcard)))
			{
				SendValidationEvent("Sch_InvalidAnyAttributeRestriction", derivedAttributeGroup);
			}
			foreach (XmlSchemaAttribute value in baseAttributeGroup.AttributeUses.Values)
			{
				XmlSchemaAttribute xmlSchemaAttribute2 = (XmlSchemaAttribute)derivedAttributeGroup.AttributeUses[value.QualifiedName];
				if (xmlSchemaAttribute2 != null)
				{
					if (value.Use == XmlSchemaUse.Prohibited && xmlSchemaAttribute2.Use != XmlSchemaUse.Prohibited)
					{
						SendValidationEvent("Sch_AttributeRestrictionProhibited", xmlSchemaAttribute2);
					}
					else if (value.Use == XmlSchemaUse.Required && xmlSchemaAttribute2.Use != XmlSchemaUse.Required)
					{
						SendValidationEvent("Sch_AttributeUseInvalid", xmlSchemaAttribute2);
					}
					else if (xmlSchemaAttribute2.Use != XmlSchemaUse.Prohibited)
					{
						if (value.AttributeSchemaType == null || xmlSchemaAttribute2.AttributeSchemaType == null || !XmlSchemaType.IsDerivedFrom(xmlSchemaAttribute2.AttributeSchemaType, value.AttributeSchemaType, XmlSchemaDerivationMethod.Empty))
						{
							SendValidationEvent("Sch_AttributeRestrictionInvalid", xmlSchemaAttribute2);
						}
						else if (!IsFixedEqual(value.AttDef, xmlSchemaAttribute2.AttDef))
						{
							SendValidationEvent("Sch_AttributeFixedInvalid", xmlSchemaAttribute2);
						}
					}
				}
				else if (value.Use == XmlSchemaUse.Required)
				{
					SendValidationEvent("Sch_NoDerivedAttribute", value.QualifiedName.ToString(), baseAttributeGroup.QualifiedName.ToString(), derivedAttributeGroup);
				}
			}
			foreach (XmlSchemaAttribute value2 in derivedAttributeGroup.AttributeUses.Values)
			{
				XmlSchemaAttribute xmlSchemaAttribute4 = (XmlSchemaAttribute)baseAttributeGroup.AttributeUses[value2.QualifiedName];
				if (xmlSchemaAttribute4 == null && (attributeWildcard == null || !attributeWildcard.Allows(value2.QualifiedName)))
				{
					SendValidationEvent("Sch_AttributeRestrictionInvalidFromWildcard", value2);
				}
			}
		}

		private bool IsProcessContentsRestricted(XmlSchemaComplexType baseType, XmlSchemaAnyAttribute derivedAttributeWildcard, XmlSchemaAnyAttribute baseAttributeWildcard)
		{
			if (baseType == XmlSchemaComplexType.AnyType)
			{
				return true;
			}
			if (derivedAttributeWildcard.ProcessContentsCorrect >= baseAttributeWildcard.ProcessContentsCorrect)
			{
				return true;
			}
			return false;
		}

		private XmlSchemaAnyAttribute CompileAnyAttributeUnion(XmlSchemaAnyAttribute a, XmlSchemaAnyAttribute b)
		{
			if (a == null)
			{
				return b;
			}
			if (b == null)
			{
				return a;
			}
			XmlSchemaAnyAttribute xmlSchemaAnyAttribute = XmlSchemaAnyAttribute.Union(a, b, v1Compat: false);
			if (xmlSchemaAnyAttribute == null)
			{
				SendValidationEvent("Sch_UnexpressibleAnyAttribute", a);
			}
			return xmlSchemaAnyAttribute;
		}

		private XmlSchemaAnyAttribute CompileAnyAttributeIntersection(XmlSchemaAnyAttribute a, XmlSchemaAnyAttribute b)
		{
			if (a == null)
			{
				return b;
			}
			if (b == null)
			{
				return a;
			}
			XmlSchemaAnyAttribute xmlSchemaAnyAttribute = XmlSchemaAnyAttribute.Intersection(a, b, v1Compat: false);
			if (xmlSchemaAnyAttribute == null)
			{
				SendValidationEvent("Sch_UnexpressibleAnyAttribute", a);
			}
			return xmlSchemaAnyAttribute;
		}

		private void CompileAttribute(XmlSchemaAttribute xa)
		{
			if (xa.IsProcessing)
			{
				SendValidationEvent("Sch_AttributeCircularRef", xa);
			}
			else
			{
				if (xa.AttDef != null)
				{
					return;
				}
				xa.IsProcessing = true;
				SchemaAttDef schemaAttDef = null;
				try
				{
					if (!xa.RefName.IsEmpty)
					{
						XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)attributes[xa.RefName];
						if (xmlSchemaAttribute == null)
						{
							throw new XmlSchemaException("Sch_UndeclaredAttribute", xa.RefName.ToString(), xa);
						}
						CompileAttribute(xmlSchemaAttribute);
						if (xmlSchemaAttribute.AttDef == null)
						{
							throw new XmlSchemaException("Sch_RefInvalidAttribute", xa.RefName.ToString(), xa);
						}
						schemaAttDef = xmlSchemaAttribute.AttDef.Clone();
						XmlSchemaDatatype datatype = schemaAttDef.Datatype;
						if (datatype != null)
						{
							if (xmlSchemaAttribute.FixedValue == null && xmlSchemaAttribute.DefaultValue == null)
							{
								SetDefaultFixed(xa, schemaAttDef);
							}
							else if (xmlSchemaAttribute.FixedValue != null)
							{
								if (xa.DefaultValue != null)
								{
									throw new XmlSchemaException("Sch_FixedDefaultInRef", xa.RefName.ToString(), xa);
								}
								if (xa.FixedValue != null)
								{
									object o = datatype.ParseValue(xa.FixedValue, base.NameTable, new SchemaNamespaceManager(xa), createAtomicValue: true);
									if (!datatype.IsEqual(schemaAttDef.DefaultValueTyped, o))
									{
										throw new XmlSchemaException("Sch_FixedInRef", xa.RefName.ToString(), xa);
									}
								}
							}
						}
						xa.SetAttributeType(xmlSchemaAttribute.AttributeSchemaType);
					}
					else
					{
						schemaAttDef = new SchemaAttDef(xa.QualifiedName, xa.Prefix);
						if (xa.SchemaType != null)
						{
							CompileSimpleType(xa.SchemaType);
							xa.SetAttributeType(xa.SchemaType);
							schemaAttDef.SchemaType = xa.SchemaType;
							schemaAttDef.Datatype = xa.SchemaType.Datatype;
						}
						else if (!xa.SchemaTypeName.IsEmpty)
						{
							XmlSchemaSimpleType simpleType = GetSimpleType(xa.SchemaTypeName);
							if (simpleType == null)
							{
								throw new XmlSchemaException("Sch_UndeclaredSimpleType", xa.SchemaTypeName.ToString(), xa);
							}
							xa.SetAttributeType(simpleType);
							schemaAttDef.Datatype = simpleType.Datatype;
							schemaAttDef.SchemaType = simpleType;
						}
						else
						{
							schemaAttDef.SchemaType = DatatypeImplementation.AnySimpleType;
							schemaAttDef.Datatype = DatatypeImplementation.AnySimpleType.Datatype;
							xa.SetAttributeType(DatatypeImplementation.AnySimpleType);
						}
						if (schemaAttDef.Datatype != null)
						{
							schemaAttDef.Datatype.VerifySchemaValid(notations, xa);
						}
						SetDefaultFixed(xa, schemaAttDef);
					}
					schemaAttDef.SchemaAttribute = xa;
					xa.AttDef = schemaAttDef;
				}
				catch (XmlSchemaException ex)
				{
					if (ex.SourceSchemaObject == null)
					{
						ex.SetSource(xa);
					}
					SendValidationEvent(ex);
					xa.AttDef = SchemaAttDef.Empty;
				}
				finally
				{
					xa.IsProcessing = false;
				}
			}
		}

		private void SetDefaultFixed(XmlSchemaAttribute xa, SchemaAttDef decl)
		{
			if (xa.DefaultValue != null || xa.FixedValue != null)
			{
				if (xa.DefaultValue != null)
				{
					decl.Presence = SchemaDeclBase.Use.Default;
					string text2 = (decl.DefaultValueRaw = (decl.DefaultValueExpanded = xa.DefaultValue));
				}
				else
				{
					if (xa.Use == XmlSchemaUse.Required)
					{
						decl.Presence = SchemaDeclBase.Use.RequiredFixed;
					}
					else
					{
						decl.Presence = SchemaDeclBase.Use.Fixed;
					}
					string text4 = (decl.DefaultValueRaw = (decl.DefaultValueExpanded = xa.FixedValue));
				}
				if (decl.Datatype != null)
				{
					if (decl.Datatype.TypeCode == XmlTypeCode.Id)
					{
						SendValidationEvent("Sch_DefaultIdValue", xa);
					}
					else
					{
						decl.DefaultValueTyped = decl.Datatype.ParseValue(decl.DefaultValueRaw, base.NameTable, new SchemaNamespaceManager(xa), createAtomicValue: true);
					}
				}
			}
			else
			{
				switch (xa.Use)
				{
				case XmlSchemaUse.None:
				case XmlSchemaUse.Optional:
					decl.Presence = SchemaDeclBase.Use.Implied;
					break;
				case XmlSchemaUse.Required:
					decl.Presence = SchemaDeclBase.Use.Required;
					break;
				case XmlSchemaUse.Prohibited:
					break;
				}
			}
		}

		private void CompileIdentityConstraint(XmlSchemaIdentityConstraint xi)
		{
			if (xi.IsProcessing)
			{
				xi.CompiledConstraint = CompiledIdentityConstraint.Empty;
				SendValidationEvent("Sch_IdentityConstraintCircularRef", xi);
			}
			else
			{
				if (xi.CompiledConstraint != null)
				{
					return;
				}
				xi.IsProcessing = true;
				CompiledIdentityConstraint compiledIdentityConstraint = null;
				try
				{
					SchemaNamespaceManager nsmgr = new SchemaNamespaceManager(xi);
					compiledIdentityConstraint = new CompiledIdentityConstraint(xi, nsmgr);
					if (xi is XmlSchemaKeyref)
					{
						XmlSchemaIdentityConstraint xmlSchemaIdentityConstraint = (XmlSchemaIdentityConstraint)identityConstraints[((XmlSchemaKeyref)xi).Refer];
						if (xmlSchemaIdentityConstraint == null)
						{
							throw new XmlSchemaException("Sch_UndeclaredIdentityConstraint", ((XmlSchemaKeyref)xi).Refer.ToString(), xi);
						}
						CompileIdentityConstraint(xmlSchemaIdentityConstraint);
						if (xmlSchemaIdentityConstraint.CompiledConstraint == null)
						{
							throw new XmlSchemaException("Sch_RefInvalidIdentityConstraint", ((XmlSchemaKeyref)xi).Refer.ToString(), xi);
						}
						if (xmlSchemaIdentityConstraint.Fields.Count != xi.Fields.Count)
						{
							throw new XmlSchemaException("Sch_RefInvalidCardin", xi.QualifiedName.ToString(), xi);
						}
						if (xmlSchemaIdentityConstraint.CompiledConstraint.Role == CompiledIdentityConstraint.ConstraintRole.Keyref)
						{
							throw new XmlSchemaException("Sch_ReftoKeyref", xi.QualifiedName.ToString(), xi);
						}
					}
					xi.CompiledConstraint = compiledIdentityConstraint;
				}
				catch (XmlSchemaException ex)
				{
					if (ex.SourceSchemaObject == null)
					{
						ex.SetSource(xi);
					}
					SendValidationEvent(ex);
					xi.CompiledConstraint = CompiledIdentityConstraint.Empty;
				}
				finally
				{
					xi.IsProcessing = false;
				}
			}
		}

		private void CompileElement(XmlSchemaElement xe)
		{
			if (xe.IsProcessing)
			{
				SendValidationEvent("Sch_ElementCircularRef", xe);
			}
			else
			{
				if (xe.ElementDecl != null)
				{
					return;
				}
				xe.IsProcessing = true;
				SchemaElementDecl schemaElementDecl = null;
				try
				{
					if (!xe.RefName.IsEmpty)
					{
						XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)elements[xe.RefName];
						if (xmlSchemaElement == null)
						{
							throw new XmlSchemaException("Sch_UndeclaredElement", xe.RefName.ToString(), xe);
						}
						CompileElement(xmlSchemaElement);
						if (xmlSchemaElement.ElementDecl == null)
						{
							throw new XmlSchemaException("Sch_RefInvalidElement", xe.RefName.ToString(), xe);
						}
						xe.SetElementType(xmlSchemaElement.ElementSchemaType);
						schemaElementDecl = xmlSchemaElement.ElementDecl.Clone();
					}
					else
					{
						if (xe.SchemaType != null)
						{
							xe.SetElementType(xe.SchemaType);
						}
						else if (!xe.SchemaTypeName.IsEmpty)
						{
							xe.SetElementType(GetAnySchemaType(xe.SchemaTypeName));
							if (xe.ElementSchemaType == null)
							{
								throw new XmlSchemaException("Sch_UndeclaredType", xe.SchemaTypeName.ToString(), xe);
							}
						}
						else if (!xe.SubstitutionGroup.IsEmpty)
						{
							XmlSchemaElement xmlSchemaElement2 = (XmlSchemaElement)elements[xe.SubstitutionGroup];
							if (xmlSchemaElement2 == null)
							{
								throw new XmlSchemaException("Sch_UndeclaredEquivClass", xe.SubstitutionGroup.Name.ToString(CultureInfo.InvariantCulture), xe);
							}
							if (xmlSchemaElement2.IsProcessing)
							{
								return;
							}
							CompileElement(xmlSchemaElement2);
							if (xmlSchemaElement2.ElementDecl == null)
							{
								xe.SetElementType(XmlSchemaComplexType.AnyType);
								schemaElementDecl = XmlSchemaComplexType.AnyType.ElementDecl.Clone();
							}
							else
							{
								xe.SetElementType(xmlSchemaElement2.ElementSchemaType);
								schemaElementDecl = xmlSchemaElement2.ElementDecl.Clone();
							}
						}
						else
						{
							xe.SetElementType(XmlSchemaComplexType.AnyType);
							schemaElementDecl = XmlSchemaComplexType.AnyType.ElementDecl.Clone();
						}
						if (schemaElementDecl == null)
						{
							if (xe.ElementSchemaType is XmlSchemaComplexType)
							{
								XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)xe.ElementSchemaType;
								CompileComplexType(xmlSchemaComplexType);
								if (xmlSchemaComplexType.ElementDecl != null)
								{
									schemaElementDecl = xmlSchemaComplexType.ElementDecl.Clone();
								}
							}
							else if (xe.ElementSchemaType is XmlSchemaSimpleType)
							{
								XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)xe.ElementSchemaType;
								CompileSimpleType(xmlSchemaSimpleType);
								if (xmlSchemaSimpleType.ElementDecl != null)
								{
									schemaElementDecl = xmlSchemaSimpleType.ElementDecl.Clone();
								}
							}
						}
						schemaElementDecl.Name = xe.QualifiedName;
						schemaElementDecl.IsAbstract = xe.IsAbstract;
						if (xe.ElementSchemaType is XmlSchemaComplexType xmlSchemaComplexType2)
						{
							schemaElementDecl.IsAbstract |= xmlSchemaComplexType2.IsAbstract;
						}
						schemaElementDecl.IsNillable = xe.IsNillable;
						schemaElementDecl.Block |= xe.BlockResolved;
					}
					if (schemaElementDecl.Datatype != null)
					{
						schemaElementDecl.Datatype.VerifySchemaValid(notations, xe);
					}
					if ((xe.DefaultValue != null || xe.FixedValue != null) && schemaElementDecl.ContentValidator != null)
					{
						if (schemaElementDecl.ContentValidator.ContentType != 0 && (schemaElementDecl.ContentValidator.ContentType != XmlSchemaContentType.Mixed || !schemaElementDecl.ContentValidator.IsEmptiable))
						{
							throw new XmlSchemaException("Sch_ElementCannotHaveValue", xe);
						}
						if (xe.DefaultValue != null)
						{
							schemaElementDecl.Presence = SchemaDeclBase.Use.Default;
							schemaElementDecl.DefaultValueRaw = xe.DefaultValue;
						}
						else
						{
							schemaElementDecl.Presence = SchemaDeclBase.Use.Fixed;
							schemaElementDecl.DefaultValueRaw = xe.FixedValue;
						}
						if (schemaElementDecl.Datatype != null)
						{
							if (schemaElementDecl.Datatype.TypeCode == XmlTypeCode.Id)
							{
								SendValidationEvent("Sch_DefaultIdValue", xe);
							}
							else
							{
								schemaElementDecl.DefaultValueTyped = schemaElementDecl.Datatype.ParseValue(schemaElementDecl.DefaultValueRaw, base.NameTable, new SchemaNamespaceManager(xe), createAtomicValue: true);
							}
						}
						else
						{
							schemaElementDecl.DefaultValueTyped = DatatypeImplementation.AnySimpleType.Datatype.ParseValue(schemaElementDecl.DefaultValueRaw, base.NameTable, new SchemaNamespaceManager(xe));
						}
					}
					if (xe.HasConstraints)
					{
						XmlSchemaObjectCollection constraints = xe.Constraints;
						CompiledIdentityConstraint[] array = new CompiledIdentityConstraint[constraints.Count];
						int num = 0;
						foreach (XmlSchemaIdentityConstraint item in constraints)
						{
							CompileIdentityConstraint(item);
							array[num++] = item.CompiledConstraint;
						}
						schemaElementDecl.Constraints = array;
					}
					schemaElementDecl.SchemaElement = xe;
					xe.ElementDecl = schemaElementDecl;
				}
				catch (XmlSchemaException ex)
				{
					if (ex.SourceSchemaObject == null)
					{
						ex.SetSource(xe);
					}
					SendValidationEvent(ex);
					xe.ElementDecl = SchemaElementDecl.Empty;
				}
				finally
				{
					xe.IsProcessing = false;
				}
			}
		}

		private ContentValidator CompileComplexContent(XmlSchemaComplexType complexType)
		{
			if (complexType.ContentType == XmlSchemaContentType.Empty)
			{
				return ContentValidator.Empty;
			}
			if (complexType.ContentType == XmlSchemaContentType.TextOnly)
			{
				return ContentValidator.TextOnly;
			}
			XmlSchemaParticle contentTypeParticle = complexType.ContentTypeParticle;
			if (contentTypeParticle == null || contentTypeParticle == XmlSchemaParticle.Empty)
			{
				if (complexType.ContentType == XmlSchemaContentType.ElementOnly)
				{
					return ContentValidator.Empty;
				}
				return ContentValidator.Mixed;
			}
			PushComplexType(complexType);
			if (contentTypeParticle is XmlSchemaAll)
			{
				XmlSchemaAll xmlSchemaAll = (XmlSchemaAll)contentTypeParticle;
				AllElementsContentValidator allElementsContentValidator = new AllElementsContentValidator(complexType.ContentType, xmlSchemaAll.Items.Count, xmlSchemaAll.MinOccurs == 0m);
				{
					foreach (XmlSchemaElement item in xmlSchemaAll.Items)
					{
						if (!allElementsContentValidator.AddElement(item.QualifiedName, item, item.MinOccurs == 0m))
						{
							SendValidationEvent("Sch_DupElement", item.QualifiedName.ToString(), item);
						}
					}
					return allElementsContentValidator;
				}
			}
			ParticleContentValidator particleContentValidator = new ParticleContentValidator(complexType.ContentType, base.CompilationSettings.EnableUpaCheck);
			try
			{
				particleContentValidator.Start();
				complexType.HasWildCard = BuildParticleContentModel(particleContentValidator, contentTypeParticle);
				return particleContentValidator.Finish(useDFA: true);
			}
			catch (UpaException ex)
			{
				if (ex.Particle1 is XmlSchemaElement)
				{
					if (ex.Particle2 is XmlSchemaElement)
					{
						SendValidationEvent("Sch_NonDeterministic", ((XmlSchemaElement)ex.Particle1).QualifiedName.ToString(), (XmlSchemaElement)ex.Particle2);
					}
					else
					{
						SendValidationEvent("Sch_NonDeterministicAnyEx", ((XmlSchemaAny)ex.Particle2).ResolvedNamespace, ((XmlSchemaElement)ex.Particle1).QualifiedName.ToString(), (XmlSchemaAny)ex.Particle2);
					}
				}
				else if (ex.Particle2 is XmlSchemaElement)
				{
					SendValidationEvent("Sch_NonDeterministicAnyEx", ((XmlSchemaAny)ex.Particle1).ResolvedNamespace, ((XmlSchemaElement)ex.Particle2).QualifiedName.ToString(), (XmlSchemaElement)ex.Particle2);
				}
				else
				{
					SendValidationEvent("Sch_NonDeterministicAnyAny", ((XmlSchemaAny)ex.Particle1).ResolvedNamespace, ((XmlSchemaAny)ex.Particle2).ResolvedNamespace, (XmlSchemaAny)ex.Particle2);
				}
				return XmlSchemaComplexType.AnyTypeContentValidator;
			}
			catch (NotSupportedException)
			{
				SendValidationEvent("Sch_ComplexContentModel", complexType, XmlSeverityType.Warning);
				return XmlSchemaComplexType.AnyTypeContentValidator;
			}
		}

		private bool BuildParticleContentModel(ParticleContentValidator contentValidator, XmlSchemaParticle particle)
		{
			bool result = false;
			if (particle is XmlSchemaElement)
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)particle;
				contentValidator.AddName(xmlSchemaElement.QualifiedName, xmlSchemaElement);
			}
			else if (particle is XmlSchemaAny)
			{
				result = true;
				XmlSchemaAny xmlSchemaAny = (XmlSchemaAny)particle;
				contentValidator.AddNamespaceList(xmlSchemaAny.NamespaceList, xmlSchemaAny);
			}
			else if (particle is XmlSchemaGroupBase)
			{
				XmlSchemaObjectCollection items = ((XmlSchemaGroupBase)particle).Items;
				bool flag = particle is XmlSchemaChoice;
				contentValidator.OpenGroup();
				bool flag2 = true;
				foreach (XmlSchemaParticle item in items)
				{
					if (flag2)
					{
						flag2 = false;
					}
					else if (flag)
					{
						contentValidator.AddChoice();
					}
					else
					{
						contentValidator.AddSequence();
					}
					result = BuildParticleContentModel(contentValidator, item);
				}
				contentValidator.CloseGroup();
			}
			if (!(particle.MinOccurs == 1m) || !(particle.MaxOccurs == 1m))
			{
				if (particle.MinOccurs == 0m && particle.MaxOccurs == 1m)
				{
					contentValidator.AddQMark();
				}
				else if (particle.MinOccurs == 0m && particle.MaxOccurs == decimal.MaxValue)
				{
					contentValidator.AddStar();
				}
				else if (particle.MinOccurs == 1m && particle.MaxOccurs == decimal.MaxValue)
				{
					contentValidator.AddPlus();
				}
				else
				{
					contentValidator.AddLeafRange(particle.MinOccurs, particle.MaxOccurs);
				}
			}
			return result;
		}

		private void CompileParticleElements(XmlSchemaComplexType complexType, XmlSchemaParticle particle)
		{
			if (particle is XmlSchemaElement)
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)particle;
				CompileElement(xmlSchemaElement);
				if (complexType.LocalElements[xmlSchemaElement.QualifiedName] == null)
				{
					complexType.LocalElements.Add(xmlSchemaElement.QualifiedName, xmlSchemaElement);
					return;
				}
				complexType.HasDuplicateDecls = true;
				XmlSchemaElement xmlSchemaElement2 = (XmlSchemaElement)complexType.LocalElements[xmlSchemaElement.QualifiedName];
				if (xmlSchemaElement2.ElementSchemaType != xmlSchemaElement.ElementSchemaType)
				{
					SendValidationEvent("Sch_ElementTypeCollision", particle);
				}
			}
			else
			{
				if (!(particle is XmlSchemaGroupBase))
				{
					return;
				}
				XmlSchemaObjectCollection items = ((XmlSchemaGroupBase)particle).Items;
				foreach (XmlSchemaParticle item in items)
				{
					CompileParticleElements(complexType, item);
				}
			}
		}

		private void CompileParticleElements(XmlSchemaParticle particle)
		{
			if (particle is XmlSchemaElement)
			{
				XmlSchemaElement xe = (XmlSchemaElement)particle;
				CompileElement(xe);
			}
			else
			{
				if (!(particle is XmlSchemaGroupBase))
				{
					return;
				}
				XmlSchemaObjectCollection items = ((XmlSchemaGroupBase)particle).Items;
				foreach (XmlSchemaParticle item in items)
				{
					CompileParticleElements(item);
				}
			}
		}

		private void CompileComplexTypeElements(XmlSchemaComplexType complexType)
		{
			if (complexType.IsProcessing)
			{
				SendValidationEvent("Sch_TypeCircularRef", complexType);
				return;
			}
			complexType.IsProcessing = true;
			try
			{
				if (complexType.ContentTypeParticle != XmlSchemaParticle.Empty)
				{
					CompileParticleElements(complexType, complexType.ContentTypeParticle);
				}
			}
			finally
			{
				complexType.IsProcessing = false;
			}
		}

		private XmlSchemaSimpleType GetSimpleType(XmlQualifiedName name)
		{
			XmlSchemaSimpleType xmlSchemaSimpleType = schemaTypes[name] as XmlSchemaSimpleType;
			if (xmlSchemaSimpleType != null)
			{
				CompileSimpleType(xmlSchemaSimpleType);
			}
			else
			{
				xmlSchemaSimpleType = DatatypeImplementation.GetSimpleTypeFromXsdType(name);
			}
			return xmlSchemaSimpleType;
		}

		private XmlSchemaComplexType GetComplexType(XmlQualifiedName name)
		{
			XmlSchemaComplexType xmlSchemaComplexType = schemaTypes[name] as XmlSchemaComplexType;
			if (xmlSchemaComplexType != null)
			{
				CompileComplexType(xmlSchemaComplexType);
			}
			return xmlSchemaComplexType;
		}

		private XmlSchemaType GetAnySchemaType(XmlQualifiedName name)
		{
			XmlSchemaType xmlSchemaType = (XmlSchemaType)schemaTypes[name];
			if (xmlSchemaType != null)
			{
				if (xmlSchemaType is XmlSchemaComplexType)
				{
					CompileComplexType((XmlSchemaComplexType)xmlSchemaType);
				}
				else
				{
					CompileSimpleType((XmlSchemaSimpleType)xmlSchemaType);
				}
				return xmlSchemaType;
			}
			return DatatypeImplementation.GetSimpleTypeFromXsdType(name);
		}

		private void CopyPosition(XmlSchemaObject to, XmlSchemaObject from, bool copyParent)
		{
			to.SourceUri = from.SourceUri;
			to.LinePosition = from.LinePosition;
			to.LineNumber = from.LineNumber;
			if (copyParent)
			{
				to.Parent = from.Parent;
			}
		}

		private bool IsFixedEqual(SchemaDeclBase baseDecl, SchemaDeclBase derivedDecl)
		{
			if (baseDecl.Presence == SchemaDeclBase.Use.Fixed || baseDecl.Presence == SchemaDeclBase.Use.RequiredFixed)
			{
				object defaultValueTyped = baseDecl.DefaultValueTyped;
				object defaultValueTyped2 = derivedDecl.DefaultValueTyped;
				if (derivedDecl.Presence != SchemaDeclBase.Use.Fixed && derivedDecl.Presence != SchemaDeclBase.Use.RequiredFixed)
				{
					return false;
				}
				XmlSchemaDatatype datatype = baseDecl.Datatype;
				XmlSchemaDatatype datatype2 = derivedDecl.Datatype;
				if (datatype.Variety == XmlSchemaDatatypeVariety.Union)
				{
					if (datatype2.Variety == XmlSchemaDatatypeVariety.Union)
					{
						if (!datatype2.IsEqual(defaultValueTyped, defaultValueTyped2))
						{
							return false;
						}
					}
					else
					{
						XsdSimpleValue xsdSimpleValue = baseDecl.DefaultValueTyped as XsdSimpleValue;
						XmlSchemaDatatype datatype3 = xsdSimpleValue.XmlType.Datatype;
						if (!datatype3.IsComparable(datatype2) || !datatype2.IsEqual(xsdSimpleValue.TypedValue, defaultValueTyped2))
						{
							return false;
						}
					}
				}
				else if (!datatype2.IsEqual(defaultValueTyped, defaultValueTyped2))
				{
					return false;
				}
			}
			return true;
		}
	}
	internal sealed class ConstraintStruct
	{
		internal CompiledIdentityConstraint constraint;

		internal SelectorActiveAxis axisSelector;

		internal ArrayList axisFields;

		internal Hashtable qualifiedTable;

		internal Hashtable keyrefTable;

		private int tableDim;

		internal int TableDim => tableDim;

		internal ConstraintStruct(CompiledIdentityConstraint constraint)
		{
			this.constraint = constraint;
			tableDim = constraint.Fields.Length;
			axisFields = new ArrayList();
			axisSelector = new SelectorActiveAxis(constraint.Selector, this);
			if (this.constraint.Role != CompiledIdentityConstraint.ConstraintRole.Keyref)
			{
				qualifiedTable = new Hashtable();
			}
		}
	}
	internal class LocatedActiveAxis : ActiveAxis
	{
		private int column;

		internal bool isMatched;

		internal KeySequence Ks;

		internal int Column => column;

		internal LocatedActiveAxis(Asttree astfield, KeySequence ks, int column)
			: base(astfield)
		{
			Ks = ks;
			this.column = column;
			isMatched = false;
		}

		internal void Reactivate(KeySequence ks)
		{
			Reactivate();
			Ks = ks;
		}
	}
	internal class SelectorActiveAxis : ActiveAxis
	{
		private ConstraintStruct cs;

		private ArrayList KSs;

		private int KSpointer;

		public bool EmptyStack => KSpointer == 0;

		public int lastDepth
		{
			get
			{
				if (KSpointer != 0)
				{
					return ((KSStruct)KSs[KSpointer - 1]).depth;
				}
				return -1;
			}
		}

		public SelectorActiveAxis(Asttree axisTree, ConstraintStruct cs)
			: base(axisTree)
		{
			KSs = new ArrayList();
			this.cs = cs;
		}

		public override bool EndElement(string localname, string URN)
		{
			base.EndElement(localname, URN);
			if (KSpointer > 0 && base.CurrentDepth == lastDepth)
			{
				return true;
			}
			return false;
		}

		public int PushKS(int errline, int errcol)
		{
			KeySequence ks = new KeySequence(cs.TableDim, errline, errcol);
			KSStruct kSStruct;
			if (KSpointer < KSs.Count)
			{
				kSStruct = (KSStruct)KSs[KSpointer];
				kSStruct.ks = ks;
				for (int i = 0; i < cs.TableDim; i++)
				{
					kSStruct.fields[i].Reactivate(ks);
				}
			}
			else
			{
				kSStruct = new KSStruct(ks, cs.TableDim);
				for (int j = 0; j < cs.TableDim; j++)
				{
					kSStruct.fields[j] = new LocatedActiveAxis(cs.constraint.Fields[j], ks, j);
					cs.axisFields.Add(kSStruct.fields[j]);
				}
				KSs.Add(kSStruct);
			}
			kSStruct.depth = base.CurrentDepth - 1;
			return KSpointer++;
		}

		public KeySequence PopKS()
		{
			return ((KSStruct)KSs[--KSpointer]).ks;
		}
	}
	internal class KSStruct
	{
		public int depth;

		public KeySequence ks;

		public LocatedActiveAxis[] fields;

		public KSStruct(KeySequence ks, int dim)
		{
			this.ks = ks;
			fields = new LocatedActiveAxis[dim];
		}
	}
	internal class TypedObject
	{
		private class DecimalStruct
		{
			private bool isDecimal;

			private decimal[] dvalue;

			public bool IsDecimal
			{
				get
				{
					return isDecimal;
				}
				set
				{
					isDecimal = value;
				}
			}

			public decimal[] Dvalue => dvalue;

			public DecimalStruct()
			{
				dvalue = new decimal[1];
			}

			public DecimalStruct(int dim)
			{
				dvalue = new decimal[dim];
			}
		}

		private DecimalStruct dstruct;

		private object ovalue;

		private string svalue;

		private XmlSchemaDatatype xsdtype;

		private int dim = 1;

		private bool isList;

		public int Dim => dim;

		public bool IsList => isList;

		public bool IsDecimal => dstruct.IsDecimal;

		public decimal[] Dvalue => dstruct.Dvalue;

		public object Value
		{
			get
			{
				return ovalue;
			}
			set
			{
				ovalue = value;
			}
		}

		public XmlSchemaDatatype Type
		{
			get
			{
				return xsdtype;
			}
			set
			{
				xsdtype = value;
			}
		}

		public TypedObject(object obj, string svalue, XmlSchemaDatatype xsdtype)
		{
			ovalue = obj;
			this.svalue = svalue;
			this.xsdtype = xsdtype;
			if (xsdtype.Variety == XmlSchemaDatatypeVariety.List || xsdtype is Datatype_base64Binary || xsdtype is Datatype_hexBinary)
			{
				isList = true;
				dim = ((Array)obj).Length;
			}
		}

		public override string ToString()
		{
			return svalue;
		}

		public void SetDecimal()
		{
			if (dstruct != null)
			{
				return;
			}
			switch (xsdtype.TypeCode)
			{
			case XmlTypeCode.Decimal:
			case XmlTypeCode.Integer:
			case XmlTypeCode.NonPositiveInteger:
			case XmlTypeCode.NegativeInteger:
			case XmlTypeCode.Long:
			case XmlTypeCode.Int:
			case XmlTypeCode.Short:
			case XmlTypeCode.Byte:
			case XmlTypeCode.NonNegativeInteger:
			case XmlTypeCode.UnsignedLong:
			case XmlTypeCode.UnsignedInt:
			case XmlTypeCode.UnsignedShort:
			case XmlTypeCode.UnsignedByte:
			case XmlTypeCode.PositiveInteger:
				if (isList)
				{
					dstruct = new DecimalStruct(dim);
					for (int i = 0; i < dim; i++)
					{
						ref decimal reference = ref dstruct.Dvalue[i];
						reference = Convert.ToDecimal(((Array)ovalue).GetValue(i), NumberFormatInfo.InvariantInfo);
					}
				}
				else
				{
					dstruct = new DecimalStruct();
					ref decimal reference2 = ref dstruct.Dvalue[0];
					reference2 = Convert.ToDecimal(ovalue, NumberFormatInfo.InvariantInfo);
				}
				dstruct.IsDecimal = true;
				break;
			default:
				if (isList)
				{
					dstruct = new DecimalStruct(dim);
				}
				else
				{
					dstruct = new DecimalStruct();
				}
				break;
			}
		}

		private bool ListDValueEquals(TypedObject other)
		{
			for (int i = 0; i < Dim; i++)
			{
				if (Dvalue[i] != other.Dvalue[i])
				{
					return false;
				}
			}
			return true;
		}

		public bool Equals(TypedObject other)
		{
			if (Dim != other.Dim)
			{
				return false;
			}
			if (Type != other.Type)
			{
				if (!Type.IsComparable(other.Type))
				{
					return false;
				}
				other.SetDecimal();
				SetDecimal();
				if (IsDecimal && other.IsDecimal)
				{
					return ListDValueEquals(other);
				}
			}
			if (IsList)
			{
				if (other.IsList)
				{
					return Type.Compare(Value, other.Value) == 0;
				}
				Array array = Value as Array;
				if (array is XmlAtomicValue[] array2)
				{
					if (array2.Length == 1)
					{
						return array2.GetValue(0).Equals(other.Value);
					}
					return false;
				}
				if (array.Length == 1)
				{
					return array.GetValue(0).Equals(other.Value);
				}
				return false;
			}
			if (other.IsList)
			{
				Array array3 = other.Value as Array;
				if (array3 is XmlAtomicValue[] array4)
				{
					if (array4.Length == 1)
					{
						return array4.GetValue(0).Equals(Value);
					}
					return false;
				}
				if (array3.Length == 1)
				{
					return array3.GetValue(0).Equals(Value);
				}
				return false;
			}
			return Value.Equals(other.Value);
		}
	}
	internal class KeySequence
	{
		private TypedObject[] ks;

		private int dim;

		private int hashcode = -1;

		private int posline;

		private int poscol;

		public int PosLine => posline;

		public int PosCol => poscol;

		public object this[int index]
		{
			get
			{
				return ks[index];
			}
			set
			{
				ks[index] = (TypedObject)value;
			}
		}

		internal KeySequence(int dim, int line, int col)
		{
			this.dim = dim;
			ks = new TypedObject[dim];
			posline = line;
			poscol = col;
		}

		public KeySequence(TypedObject[] ks)
		{
			this.ks = ks;
			dim = ks.Length;
			posline = (poscol = 0);
		}

		internal bool IsQualified()
		{
			TypedObject[] array = ks;
			foreach (TypedObject typedObject in array)
			{
				if (typedObject == null || typedObject.Value == null)
				{
					return false;
				}
			}
			return true;
		}

		public override int GetHashCode()
		{
			if (hashcode != -1)
			{
				return hashcode;
			}
			hashcode = 0;
			for (int i = 0; i < ks.Length; i++)
			{
				ks[i].SetDecimal();
				if (ks[i].IsDecimal)
				{
					for (int j = 0; j < ks[i].Dim; j++)
					{
						hashcode += ks[i].Dvalue[j].GetHashCode();
					}
				}
				else if (ks[i].Value is Array array)
				{
					if (array is XmlAtomicValue[] array2)
					{
						for (int k = 0; k < array2.Length; k++)
						{
							hashcode += ((XmlAtomicValue)array2.GetValue(k)).TypedValue.GetHashCode();
						}
					}
					else
					{
						for (int l = 0; l < ((Array)ks[i].Value).Length; l++)
						{
							hashcode += ((Array)ks[i].Value).GetValue(l).GetHashCode();
						}
					}
				}
				else
				{
					hashcode += ks[i].Value.GetHashCode();
				}
			}
			return hashcode;
		}

		public override bool Equals(object other)
		{
			KeySequence keySequence = (KeySequence)other;
			for (int i = 0; i < ks.Length; i++)
			{
				if (!ks[i].Equals(keySequence.ks[i]))
				{
					return false;
				}
			}
			return true;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(ks[0].ToString());
			for (int i = 1; i < ks.Length; i++)
			{
				stringBuilder.Append(" ");
				stringBuilder.Append(ks[i].ToString());
			}
			return stringBuilder.ToString();
		}
	}
	internal class UpaException : Exception
	{
		private object particle1;

		private object particle2;

		public object Particle1 => particle1;

		public object Particle2 => particle2;

		public UpaException(object particle1, object particle2)
		{
			this.particle1 = particle1;
			this.particle2 = particle2;
		}
	}
	internal class SymbolsDictionary
	{
		private int last;

		private Hashtable names;

		private Hashtable wildcards;

		private ArrayList particles;

		private object particleLast;

		private bool isUpaEnforced = true;

		public int Count => last + 1;

		public int CountOfNames => names.Count;

		public bool IsUpaEnforced
		{
			get
			{
				return isUpaEnforced;
			}
			set
			{
				isUpaEnforced = value;
			}
		}

		public int this[XmlQualifiedName name]
		{
			get
			{
				object obj = names[name];
				if (obj != null)
				{
					return (int)obj;
				}
				if (wildcards != null)
				{
					obj = wildcards[name.Namespace];
					if (obj != null)
					{
						return (int)obj;
					}
				}
				return last;
			}
		}

		public SymbolsDictionary()
		{
			names = new Hashtable();
			particles = new ArrayList();
		}

		public int AddName(XmlQualifiedName name, object particle)
		{
			object obj = names[name];
			if (obj != null)
			{
				int num = (int)obj;
				if (particles[num] != particle)
				{
					isUpaEnforced = false;
				}
				return num;
			}
			names.Add(name, last);
			particles.Add(particle);
			return last++;
		}

		public void AddNamespaceList(NamespaceList list, object particle, bool allowLocal)
		{
			switch (list.Type)
			{
			case NamespaceList.ListType.Any:
				particleLast = particle;
				break;
			case NamespaceList.ListType.Other:
				AddWildcard(list.Excluded, null);
				if (!allowLocal)
				{
					AddWildcard(string.Empty, null);
				}
				break;
			case NamespaceList.ListType.Set:
			{
				foreach (string item in list.Enumerate)
				{
					AddWildcard(item, particle);
				}
				break;
			}
			}
		}

		private void AddWildcard(string wildcard, object particle)
		{
			if (wildcards == null)
			{
				wildcards = new Hashtable();
			}
			object obj = wildcards[wildcard];
			if (obj == null)
			{
				wildcards.Add(wildcard, last);
				particles.Add(particle);
				last++;
			}
			else if (particle != null)
			{
				particles[(int)obj] = particle;
			}
		}

		public ICollection GetNamespaceListSymbols(NamespaceList list)
		{
			ArrayList arrayList = new ArrayList();
			foreach (XmlQualifiedName key in names.Keys)
			{
				if (key != XmlQualifiedName.Empty && list.Allows(key))
				{
					arrayList.Add(names[key]);
				}
			}
			if (wildcards != null)
			{
				foreach (string key2 in wildcards.Keys)
				{
					if (list.Allows(key2))
					{
						arrayList.Add(wildcards[key2]);
					}
				}
			}
			if (list.Type == NamespaceList.ListType.Any || list.Type == NamespaceList.ListType.Other)
			{
				arrayList.Add(last);
			}
			return arrayList;
		}

		public bool Exists(XmlQualifiedName name)
		{
			object obj = names[name];
			if (obj != null)
			{
				return true;
			}
			return false;
		}

		public object GetParticle(int symbol)
		{
			if (symbol != last)
			{
				return particles[symbol];
			}
			return particleLast;
		}

		public string NameOf(int symbol)
		{
			foreach (DictionaryEntry name in names)
			{
				if ((int)name.Value == symbol)
				{
					return ((XmlQualifiedName)name.Key).ToString();
				}
			}
			if (wildcards != null)
			{
				foreach (DictionaryEntry wildcard in wildcards)
				{
					if ((int)wildcard.Value == symbol)
					{
						return (string)wildcard.Key + ":*";
					}
				}
			}
			return "##other:*";
		}
	}
	internal struct Position
	{
		public int symbol;

		public object particle;

		public Position(int symbol, object particle)
		{
			this.symbol = symbol;
			this.particle = particle;
		}
	}
	internal class Positions
	{
		private ArrayList positions = new ArrayList();

		public Position this[int pos] => (Position)positions[pos];

		public int Count => positions.Count;

		public int Add(int symbol, object particle)
		{
			return positions.Add(new Position(symbol, particle));
		}
	}
	internal abstract class SyntaxTreeNode
	{
		public abstract bool IsNullable { get; }

		public virtual bool IsRangeNode => false;

		public abstract void ExpandTree(InteriorNode parent, SymbolsDictionary symbols, Positions positions);

		public abstract SyntaxTreeNode Clone(Positions positions);

		public abstract void ConstructPos(BitSet firstpos, BitSet lastpos, BitSet[] followpos);
	}
	internal class LeafNode : SyntaxTreeNode
	{
		private int pos;

		public int Pos
		{
			get
			{
				return pos;
			}
			set
			{
				pos = value;
			}
		}

		public override bool IsNullable => false;

		public LeafNode(int pos)
		{
			this.pos = pos;
		}

		public override void ExpandTree(InteriorNode parent, SymbolsDictionary symbols, Positions positions)
		{
		}

		public override SyntaxTreeNode Clone(Positions positions)
		{
			return new LeafNode(positions.Add(positions[pos].symbol, positions[pos].particle));
		}

		public override void ConstructPos(BitSet firstpos, BitSet lastpos, BitSet[] followpos)
		{
			firstpos.Set(pos);
			lastpos.Set(pos);
		}
	}
	internal class NamespaceListNode : SyntaxTreeNode
	{
		protected NamespaceList namespaceList;

		protected object particle;

		public override bool IsNullable
		{
			get
			{
				throw new InvalidOperationException();
			}
		}

		public NamespaceListNode(NamespaceList namespaceList, object particle)
		{
			this.namespaceList = namespaceList;
			this.particle = particle;
		}

		public override SyntaxTreeNode Clone(Positions positions)
		{
			throw new InvalidOperationException();
		}

		public virtual ICollection GetResolvedSymbols(SymbolsDictionary symbols)
		{
			return symbols.GetNamespaceListSymbols(namespaceList);
		}

		public override void ExpandTree(InteriorNode parent, SymbolsDictionary symbols, Positions positions)
		{
			SyntaxTreeNode syntaxTreeNode = null;
			foreach (int resolvedSymbol in GetResolvedSymbols(symbols))
			{
				if (symbols.GetParticle(resolvedSymbol) != particle)
				{
					symbols.IsUpaEnforced = false;
				}
				LeafNode leafNode = new LeafNode(positions.Add(resolvedSymbol, particle));
				if (syntaxTreeNode == null)
				{
					syntaxTreeNode = leafNode;
					continue;
				}
				InteriorNode interiorNode = new ChoiceNode();
				interiorNode.LeftChild = syntaxTreeNode;
				interiorNode.RightChild = leafNode;
				syntaxTreeNode = interiorNode;
			}
			if (parent.LeftChild == this)
			{
				parent.LeftChild = syntaxTreeNode;
			}
			else
			{
				parent.RightChild = syntaxTreeNode;
			}
		}

		public override void ConstructPos(BitSet firstpos, BitSet lastpos, BitSet[] followpos)
		{
			throw new InvalidOperationException();
		}
	}
	internal abstract class InteriorNode : SyntaxTreeNode
	{
		private SyntaxTreeNode leftChild;

		private SyntaxTreeNode rightChild;

		public SyntaxTreeNode LeftChild
		{
			get
			{
				return leftChild;
			}
			set
			{
				leftChild = value;
			}
		}

		public SyntaxTreeNode RightChild
		{
			get
			{
				return rightChild;
			}
			set
			{
				rightChild = value;
			}
		}

		public override SyntaxTreeNode Clone(Positions positions)
		{
			InteriorNode interiorNode = (InteriorNode)MemberwiseClone();
			interiorNode.LeftChild = leftChild.Clone(positions);
			if (rightChild != null)
			{
				interiorNode.RightChild = rightChild.Clone(positions);
			}
			return interiorNode;
		}

		public override void ExpandTree(InteriorNode parent, SymbolsDictionary symbols, Positions positions)
		{
			leftChild.ExpandTree(this, symbols, positions);
			if (rightChild != null)
			{
				rightChild.ExpandTree(this, symbols, positions);
			}
		}
	}
	internal sealed class SequenceNode : InteriorNode
	{
		public override bool IsNullable
		{
			get
			{
				if (!base.LeftChild.IsNullable || (!base.RightChild.IsNullable && !base.RightChild.IsRangeNode))
				{
					if (base.RightChild.IsRangeNode)
					{
						return ((LeafRangeNode)base.RightChild).Min == 0m;
					}
					return false;
				}
				return true;
			}
		}

		public override void ConstructPos(BitSet firstpos, BitSet lastpos, BitSet[] followpos)
		{
			BitSet bitSet = new BitSet(lastpos.Count);
			base.LeftChild.ConstructPos(firstpos, bitSet, followpos);
			BitSet bitSet2 = new BitSet(firstpos.Count);
			base.RightChild.ConstructPos(bitSet2, lastpos, followpos);
			if (base.LeftChild.IsNullable && !base.RightChild.IsRangeNode)
			{
				firstpos.Or(bitSet2);
			}
			if (base.RightChild.IsNullable)
			{
				lastpos.Or(bitSet);
			}
			for (int num = bitSet.NextSet(-1); num != -1; num = bitSet.NextSet(num))
			{
				followpos[num].Or(bitSet2);
			}
			if (base.RightChild.IsRangeNode)
			{
				((LeafRangeNode)base.RightChild).NextIteration = firstpos.Clone();
			}
		}
	}
	internal sealed class ChoiceNode : InteriorNode
	{
		public override bool IsNullable
		{
			get
			{
				if (!base.LeftChild.IsNullable)
				{
					return base.RightChild.IsNullable;
				}
				return true;
			}
		}

		public override void ConstructPos(BitSet firstpos, BitSet lastpos, BitSet[] followpos)
		{
			base.LeftChild.ConstructPos(firstpos, lastpos, followpos);
			BitSet bitSet = new BitSet(firstpos.Count);
			BitSet bitSet2 = new BitSet(lastpos.Count);
			base.RightChild.ConstructPos(bitSet, bitSet2, followpos);
			firstpos.Or(bitSet);
			lastpos.Or(bitSet2);
		}
	}
	internal sealed class PlusNode : InteriorNode
	{
		public override bool IsNullable => base.LeftChild.IsNullable;

		public override void ConstructPos(BitSet firstpos, BitSet lastpos, BitSet[] followpos)
		{
			base.LeftChild.ConstructPos(firstpos, lastpos, followpos);
			for (int num = lastpos.NextSet(-1); num != -1; num = lastpos.NextSet(num))
			{
				followpos[num].Or(firstpos);
			}
		}
	}
	internal sealed class QmarkNode : InteriorNode
	{
		public override bool IsNullable => true;

		public override void ConstructPos(BitSet firstpos, BitSet lastpos, BitSet[] followpos)
		{
			base.LeftChild.ConstructPos(firstpos, lastpos, followpos);
		}
	}
	internal sealed class StarNode : InteriorNode
	{
		public override bool IsNullable => true;

		public override void ConstructPos(BitSet firstpos, BitSet lastpos, BitSet[] followpos)
		{
			base.LeftChild.ConstructPos(firstpos, lastpos, followpos);
			for (int num = lastpos.NextSet(-1); num != -1; num = lastpos.NextSet(num))
			{
				followpos[num].Or(firstpos);
			}
		}
	}
	internal sealed class LeafRangeNode : LeafNode
	{
		private decimal min;

		private decimal max;

		private BitSet nextIteration;

		public decimal Max => max;

		public decimal Min => min;

		public BitSet NextIteration
		{
			get
			{
				return nextIteration;
			}
			set
			{
				nextIteration = value;
			}
		}

		public override bool IsRangeNode => true;

		public LeafRangeNode(decimal min, decimal max)
			: this(-1, min, max)
		{
		}

		public LeafRangeNode(int pos, decimal min, decimal max)
			: base(pos)
		{
			this.min = min;
			this.max = max;
		}

		public override SyntaxTreeNode Clone(Positions positions)
		{
			return new LeafRangeNode(base.Pos, min, max);
		}
	}
	internal class ContentValidator
	{
		private XmlSchemaContentType contentType;

		private bool isOpen;

		private bool isEmptiable;

		public static readonly ContentValidator Empty = new ContentValidator(XmlSchemaContentType.Empty);

		public static readonly ContentValidator TextOnly = new ContentValidator(XmlSchemaContentType.TextOnly, isOpen: false, isEmptiable: false);

		public static readonly ContentValidator Mixed = new ContentValidator(XmlSchemaContentType.Mixed);

		public static readonly ContentValidator Any = new ContentValidator(XmlSchemaContentType.Mixed, isOpen: true, isEmptiable: true);

		public XmlSchemaContentType ContentType => contentType;

		public bool PreserveWhitespace
		{
			get
			{
				if (contentType != 0)
				{
					return contentType == XmlSchemaContentType.Mixed;
				}
				return true;
			}
		}

		public virtual bool IsEmptiable => isEmptiable;

		public bool IsOpen
		{
			get
			{
				if (contentType == XmlSchemaContentType.TextOnly || contentType == XmlSchemaContentType.Empty)
				{
					return false;
				}
				return isOpen;
			}
			set
			{
				isOpen = value;
			}
		}

		public ContentValidator(XmlSchemaContentType contentType)
		{
			this.contentType = contentType;
			isEmptiable = true;
		}

		protected ContentValidator(XmlSchemaContentType contentType, bool isOpen, bool isEmptiable)
		{
			this.contentType = contentType;
			this.isOpen = isOpen;
			this.isEmptiable = isEmptiable;
		}

		public virtual void InitValidation(ValidationState context)
		{
		}

		public virtual object ValidateElement(XmlQualifiedName name, ValidationState context, out int errorCode)
		{
			if (contentType == XmlSchemaContentType.TextOnly || contentType == XmlSchemaContentType.Empty)
			{
				context.NeedValidateChildren = false;
			}
			errorCode = -1;
			return null;
		}

		public virtual bool CompleteValidation(ValidationState context)
		{
			return true;
		}

		public virtual ArrayList ExpectedElements(ValidationState context, bool isRequiredOnly)
		{
			return null;
		}

		public virtual ArrayList ExpectedParticles(ValidationState context, bool isRequiredOnly)
		{
			return null;
		}
	}
	internal sealed class ParticleContentValidator : ContentValidator
	{
		private SymbolsDictionary symbols;

		private Positions positions;

		private Stack stack;

		private SyntaxTreeNode contentNode;

		private bool isPartial;

		private int minMaxNodesCount;

		private bool enableUpaCheck;

		public ParticleContentValidator(XmlSchemaContentType contentType)
			: this(contentType, enableUpaCheck: true)
		{
		}

		public ParticleContentValidator(XmlSchemaContentType contentType, bool enableUpaCheck)
			: base(contentType)
		{
			this.enableUpaCheck = enableUpaCheck;
		}

		public override void InitValidation(ValidationState context)
		{
			throw new InvalidOperationException();
		}

		public override object ValidateElement(XmlQualifiedName name, ValidationState context, out int errorCode)
		{
			throw new InvalidOperationException();
		}

		public override bool CompleteValidation(ValidationState context)
		{
			throw new InvalidOperationException();
		}

		public void Start()
		{
			symbols = new SymbolsDictionary();
			positions = new Positions();
			stack = new Stack();
		}

		public void OpenGroup()
		{
			stack.Push(null);
		}

		public void CloseGroup()
		{
			SyntaxTreeNode syntaxTreeNode = (SyntaxTreeNode)stack.Pop();
			if (syntaxTreeNode == null)
			{
				return;
			}
			if (stack.Count == 0)
			{
				contentNode = syntaxTreeNode;
				isPartial = false;
				return;
			}
			InteriorNode interiorNode = (InteriorNode)stack.Pop();
			if (interiorNode != null)
			{
				interiorNode.RightChild = syntaxTreeNode;
				syntaxTreeNode = interiorNode;
				isPartial = true;
			}
			else
			{
				isPartial = false;
			}
			stack.Push(syntaxTreeNode);
		}

		public bool Exists(XmlQualifiedName name)
		{
			if (symbols.Exists(name))
			{
				return true;
			}
			return false;
		}

		public void AddName(XmlQualifiedName name, object particle)
		{
			AddLeafNode(new LeafNode(positions.Add(symbols.AddName(name, particle), particle)));
		}

		public void AddNamespaceList(NamespaceList namespaceList, object particle)
		{
			symbols.AddNamespaceList(namespaceList, particle, allowLocal: false);
			AddLeafNode(new NamespaceListNode(namespaceList, particle));
		}

		private void AddLeafNode(SyntaxTreeNode node)
		{
			if (stack.Count > 0)
			{
				InteriorNode interiorNode = (InteriorNode)stack.Pop();
				if (interiorNode != null)
				{
					interiorNode.RightChild = node;
					node = interiorNode;
				}
			}
			stack.Push(node);
			isPartial = true;
		}

		public void AddChoice()
		{
			SyntaxTreeNode leftChild = (SyntaxTreeNode)stack.Pop();
			InteriorNode interiorNode = new ChoiceNode();
			interiorNode.LeftChild = leftChild;
			stack.Push(interiorNode);
		}

		public void AddSequence()
		{
			SyntaxTreeNode leftChild = (SyntaxTreeNode)stack.Pop();
			InteriorNode interiorNode = new SequenceNode();
			interiorNode.LeftChild = leftChild;
			stack.Push(interiorNode);
		}

		public void AddStar()
		{
			Closure(new StarNode());
		}

		public void AddPlus()
		{
			Closure(new PlusNode());
		}

		public void AddQMark()
		{
			Closure(new QmarkNode());
		}

		public void AddLeafRange(decimal min, decimal max)
		{
			LeafRangeNode leafRangeNode = new LeafRangeNode(min, max);
			int num2 = (leafRangeNode.Pos = positions.Add(-2, leafRangeNode));
			InteriorNode interiorNode = new SequenceNode();
			interiorNode.RightChild = leafRangeNode;
			Closure(interiorNode);
			minMaxNodesCount++;
		}

		private void Closure(InteriorNode node)
		{
			if (stack.Count > 0)
			{
				SyntaxTreeNode syntaxTreeNode = (SyntaxTreeNode)stack.Pop();
				InteriorNode interiorNode = syntaxTreeNode as InteriorNode;
				if (isPartial && interiorNode != null)
				{
					node.LeftChild = interiorNode.RightChild;
					interiorNode.RightChild = node;
				}
				else
				{
					node.LeftChild = syntaxTreeNode;
					syntaxTreeNode = node;
				}
				stack.Push(syntaxTreeNode);
			}
			else if (contentNode != null)
			{
				node.LeftChild = contentNode;
				contentNode = node;
			}
		}

		public ContentValidator Finish()
		{
			return Finish(useDFA: true);
		}

		public ContentValidator Finish(bool useDFA)
		{
			if (contentNode == null)
			{
				if (base.ContentType == XmlSchemaContentType.Mixed)
				{
					_ = base.IsOpen;
					if (!base.IsOpen)
					{
						return ContentValidator.TextOnly;
					}
					return ContentValidator.Any;
				}
				return ContentValidator.Empty;
			}
			InteriorNode interiorNode = new SequenceNode();
			interiorNode.LeftChild = contentNode;
			LeafNode leafNode = (LeafNode)(interiorNode.RightChild = new LeafNode(positions.Add(symbols.AddName(XmlQualifiedName.Empty, null), null)));
			contentNode.ExpandTree(interiorNode, symbols, positions);
			_ = symbols.Count;
			int count = positions.Count;
			BitSet bitSet = new BitSet(count);
			BitSet lastpos = new BitSet(count);
			BitSet[] array = new BitSet[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = new BitSet(count);
			}
			interiorNode.ConstructPos(bitSet, lastpos, array);
			if (minMaxNodesCount > 0)
			{
				BitSet posWithRangeTerminals;
				BitSet[] minmaxFollowPos = CalculateTotalFollowposForRangeNodes(bitSet, array, out posWithRangeTerminals);
				if (enableUpaCheck)
				{
					CheckCMUPAWithLeafRangeNodes(GetApplicableMinMaxFollowPos(bitSet, posWithRangeTerminals, minmaxFollowPos));
					for (int j = 0; j < count; j++)
					{
						CheckCMUPAWithLeafRangeNodes(GetApplicableMinMaxFollowPos(array[j], posWithRangeTerminals, minmaxFollowPos));
					}
				}
				return new RangeContentValidator(bitSet, array, symbols, positions, leafNode.Pos, base.ContentType, interiorNode.LeftChild.IsNullable, posWithRangeTerminals, minMaxNodesCount);
			}
			int[][] array2 = null;
			if (!symbols.IsUpaEnforced)
			{
				if (enableUpaCheck)
				{
					CheckUniqueParticleAttribution(bitSet, array);
				}
			}
			else if (useDFA)
			{
				array2 = BuildTransitionTable(bitSet, array, leafNode.Pos);
			}
			if (array2 != null)
			{
				return new DfaContentValidator(array2, symbols, base.ContentType, base.IsOpen, interiorNode.LeftChild.IsNullable);
			}
			return new NfaContentValidator(bitSet, array, symbols, positions, leafNode.Pos, base.ContentType, base.IsOpen, interiorNode.LeftChild.IsNullable);
		}

		private BitSet[] CalculateTotalFollowposForRangeNodes(BitSet firstpos, BitSet[] followpos, out BitSet posWithRangeTerminals)
		{
			int count = positions.Count;
			posWithRangeTerminals = new BitSet(count);
			BitSet[] array = new BitSet[minMaxNodesCount];
			int num = 0;
			for (int num2 = count - 1; num2 >= 0; num2--)
			{
				Position position = positions[num2];
				if (position.symbol == -2)
				{
					LeafRangeNode leafRangeNode = position.particle as LeafRangeNode;
					BitSet bitSet = new BitSet(count);
					bitSet.Clear();
					bitSet.Or(followpos[num2]);
					if (leafRangeNode.Min != leafRangeNode.Max)
					{
						bitSet.Or(leafRangeNode.NextIteration);
					}
					for (int num3 = bitSet.NextSet(-1); num3 != -1; num3 = bitSet.NextSet(num3))
					{
						if (num3 > num2)
						{
							Position position2 = positions[num3];
							if (position2.symbol == -2)
							{
								LeafRangeNode leafRangeNode2 = position2.particle as LeafRangeNode;
								bitSet.Or(array[leafRangeNode2.Pos]);
							}
						}
					}
					array[num] = bitSet;
					leafRangeNode.Pos = num++;
					posWithRangeTerminals.Set(num2);
				}
			}
			return array;
		}

		private void CheckCMUPAWithLeafRangeNodes(BitSet curpos)
		{
			object[] array = new object[symbols.Count];
			for (int num = curpos.NextSet(-1); num != -1; num = curpos.NextSet(num))
			{
				Position position = positions[num];
				int symbol = position.symbol;
				if (symbol >= 0)
				{
					if (array[symbol] != null)
					{
						throw new UpaException(array[symbol], position.particle);
					}
					array[symbol] = position.particle;
				}
			}
		}

		private BitSet GetApplicableMinMaxFollowPos(BitSet curpos, BitSet posWithRangeTerminals, BitSet[] minmaxFollowPos)
		{
			if (curpos.Intersects(posWithRangeTerminals))
			{
				BitSet bitSet = new BitSet(positions.Count);
				bitSet.Or(curpos);
				bitSet.And(posWithRangeTerminals);
				curpos = curpos.Clone();
				for (int num = bitSet.NextSet(-1); num != -1; num = bitSet.NextSet(num))
				{
					LeafRangeNode leafRangeNode = positions[num].particle as LeafRangeNode;
					curpos.Or(minmaxFollowPos[leafRangeNode.Pos]);
				}
			}
			return curpos;
		}

		private void CheckUniqueParticleAttribution(BitSet firstpos, BitSet[] followpos)
		{
			CheckUniqueParticleAttribution(firstpos);
			for (int i = 0; i < positions.Count; i++)
			{
				CheckUniqueParticleAttribution(followpos[i]);
			}
		}

		private void CheckUniqueParticleAttribution(BitSet curpos)
		{
			object[] array = new object[symbols.Count];
			for (int num = curpos.NextSet(-1); num != -1; num = curpos.NextSet(num))
			{
				int symbol = positions[num].symbol;
				if (array[symbol] == null)
				{
					array[symbol] = positions[num].particle;
				}
				else if (array[symbol] != positions[num].particle)
				{
					throw new UpaException(array[symbol], positions[num].particle);
				}
			}
		}

		private int[][] BuildTransitionTable(BitSet firstpos, BitSet[] followpos, int endMarkerPos)
		{
			int count = positions.Count;
			int num = 8192 / count;
			int count2 = symbols.Count;
			ArrayList arrayList = new ArrayList();
			Hashtable hashtable = new Hashtable();
			hashtable.Add(new BitSet(count), -1);
			Queue queue = new Queue();
			int num2 = 0;
			queue.Enqueue(firstpos);
			hashtable.Add(firstpos, 0);
			arrayList.Add(new int[count2 + 1]);
			while (queue.Count > 0)
			{
				BitSet bitSet = (BitSet)queue.Dequeue();
				int[] array = (int[])arrayList[num2];
				if (bitSet[endMarkerPos])
				{
					array[count2] = 1;
				}
				for (int i = 0; i < count2; i++)
				{
					BitSet bitSet2 = new BitSet(count);
					for (int num3 = bitSet.NextSet(-1); num3 != -1; num3 = bitSet.NextSet(num3))
					{
						if (i == positions[num3].symbol)
						{
							bitSet2.Or(followpos[num3]);
						}
					}
					object obj = hashtable[bitSet2];
					if (obj != null)
					{
						array[i] = (int)obj;
						continue;
					}
					int num4 = hashtable.Count - 1;
					if (num4 >= num)
					{
						return null;
					}
					queue.Enqueue(bitSet2);
					hashtable.Add(bitSet2, num4);
					arrayList.Add(new int[count2 + 1]);
					array[i] = num4;
				}
				num2++;
			}
			return (int[][])arrayList.ToArray(typeof(int[]));
		}
	}
	internal sealed class DfaContentValidator : ContentValidator
	{
		private int[][] transitionTable;

		private SymbolsDictionary symbols;

		internal DfaContentValidator(int[][] transitionTable, SymbolsDictionary symbols, XmlSchemaContentType contentType, bool isOpen, bool isEmptiable)
			: base(contentType, isOpen, isEmptiable)
		{
			this.transitionTable = transitionTable;
			this.symbols = symbols;
		}

		public override void InitValidation(ValidationState context)
		{
			context.CurrentState.State = 0;
			context.HasMatched = transitionTable[0][symbols.Count] > 0;
		}

		public override object ValidateElement(XmlQualifiedName name, ValidationState context, out int errorCode)
		{
			int num = symbols[name];
			int num2 = transitionTable[context.CurrentState.State][num];
			errorCode = 0;
			if (num2 != -1)
			{
				context.CurrentState.State = num2;
				context.HasMatched = transitionTable[context.CurrentState.State][symbols.Count] > 0;
				return symbols.GetParticle(num);
			}
			if (base.IsOpen && context.HasMatched)
			{
				return null;
			}
			context.NeedValidateChildren = false;
			errorCode = -1;
			return null;
		}

		public override bool CompleteValidation(ValidationState context)
		{
			if (!context.HasMatched)
			{
				return false;
			}
			return true;
		}

		public override ArrayList ExpectedElements(ValidationState context, bool isRequiredOnly)
		{
			ArrayList arrayList = null;
			int[] array = transitionTable[context.CurrentState.State];
			if (array != null)
			{
				for (int i = 0; i < array.Length - 1; i++)
				{
					if (array[i] == -1)
					{
						continue;
					}
					if (arrayList == null)
					{
						arrayList = new ArrayList();
					}
					XmlSchemaParticle xmlSchemaParticle = (XmlSchemaParticle)symbols.GetParticle(i);
					if (xmlSchemaParticle == null)
					{
						string text = symbols.NameOf(i);
						if (text.Length != 0)
						{
							arrayList.Add(text);
						}
					}
					else
					{
						string nameString = xmlSchemaParticle.NameString;
						if (!arrayList.Contains(nameString))
						{
							arrayList.Add(nameString);
						}
					}
				}
			}
			return arrayList;
		}

		public override ArrayList ExpectedParticles(ValidationState context, bool isRequiredOnly)
		{
			ArrayList arrayList = new ArrayList();
			int[] array = transitionTable[context.CurrentState.State];
			if (array != null)
			{
				for (int i = 0; i < array.Length - 1; i++)
				{
					if (array[i] != -1)
					{
						XmlSchemaParticle xmlSchemaParticle = (XmlSchemaParticle)symbols.GetParticle(i);
						if (xmlSchemaParticle != null && !arrayList.Contains(xmlSchemaParticle))
						{
							arrayList.Add(xmlSchemaParticle);
						}
					}
				}
			}
			return arrayList;
		}
	}
	internal sealed class NfaContentValidator : ContentValidator
	{
		private BitSet firstpos;

		private BitSet[] followpos;

		private SymbolsDictionary symbols;

		private Positions positions;

		private int endMarkerPos;

		internal NfaContentValidator(BitSet firstpos, BitSet[] followpos, SymbolsDictionary symbols, Positions positions, int endMarkerPos, XmlSchemaContentType contentType, bool isOpen, bool isEmptiable)
			: base(contentType, isOpen, isEmptiable)
		{
			this.firstpos = firstpos;
			this.followpos = followpos;
			this.symbols = symbols;
			this.positions = positions;
			this.endMarkerPos = endMarkerPos;
		}

		public override void InitValidation(ValidationState context)
		{
			context.CurPos[0] = firstpos.Clone();
			context.CurPos[1] = new BitSet(firstpos.Count);
			context.CurrentState.CurPosIndex = 0;
		}

		public override object ValidateElement(XmlQualifiedName name, ValidationState context, out int errorCode)
		{
			BitSet bitSet = context.CurPos[context.CurrentState.CurPosIndex];
			int num = (context.CurrentState.CurPosIndex + 1) % 2;
			BitSet bitSet2 = context.CurPos[num];
			bitSet2.Clear();
			int num2 = symbols[name];
			object result = null;
			errorCode = 0;
			for (int num3 = bitSet.NextSet(-1); num3 != -1; num3 = bitSet.NextSet(num3))
			{
				if (num2 == positions[num3].symbol)
				{
					bitSet2.Or(followpos[num3]);
					result = positions[num3].particle;
					break;
				}
			}
			if (!bitSet2.IsEmpty)
			{
				context.CurrentState.CurPosIndex = num;
				return result;
			}
			if (base.IsOpen && bitSet[endMarkerPos])
			{
				return null;
			}
			context.NeedValidateChildren = false;
			errorCode = -1;
			return null;
		}

		public override bool CompleteValidation(ValidationState context)
		{
			if (!context.CurPos[context.CurrentState.CurPosIndex][endMarkerPos])
			{
				return false;
			}
			return true;
		}

		public override ArrayList ExpectedElements(ValidationState context, bool isRequiredOnly)
		{
			ArrayList arrayList = null;
			BitSet bitSet = context.CurPos[context.CurrentState.CurPosIndex];
			for (int num = bitSet.NextSet(-1); num != -1; num = bitSet.NextSet(num))
			{
				if (arrayList == null)
				{
					arrayList = new ArrayList();
				}
				XmlSchemaParticle xmlSchemaParticle = (XmlSchemaParticle)positions[num].particle;
				if (xmlSchemaParticle == null)
				{
					string text = symbols.NameOf(positions[num].symbol);
					if (text.Length != 0)
					{
						arrayList.Add(text);
					}
				}
				else
				{
					string nameString = xmlSchemaParticle.NameString;
					if (!arrayList.Contains(nameString))
					{
						arrayList.Add(nameString);
					}
				}
			}
			return arrayList;
		}

		public override ArrayList ExpectedParticles(ValidationState context, bool isRequiredOnly)
		{
			ArrayList arrayList = new ArrayList();
			BitSet bitSet = context.CurPos[context.CurrentState.CurPosIndex];
			for (int num = bitSet.NextSet(-1); num != -1; num = bitSet.NextSet(num))
			{
				XmlSchemaParticle xmlSchemaParticle = (XmlSchemaParticle)positions[num].particle;
				if (xmlSchemaParticle != null && !arrayList.Contains(xmlSchemaParticle))
				{
					arrayList.Add(xmlSchemaParticle);
				}
			}
			return arrayList;
		}
	}
	internal struct RangePositionInfo
	{
		public BitSet curpos;

		public decimal[] rangeCounters;
	}
	internal sealed class RangeContentValidator : ContentValidator
	{
		private BitSet firstpos;

		private BitSet[] followpos;

		private BitSet positionsWithRangeTerminals;

		private SymbolsDictionary symbols;

		private Positions positions;

		private int minMaxNodesCount;

		private int endMarkerPos;

		internal RangeContentValidator(BitSet firstpos, BitSet[] followpos, SymbolsDictionary symbols, Positions positions, int endMarkerPos, XmlSchemaContentType contentType, bool isEmptiable, BitSet positionsWithRangeTerminals, int minmaxNodesCount)
			: base(contentType, isOpen: false, isEmptiable)
		{
			this.firstpos = firstpos;
			this.followpos = followpos;
			this.symbols = symbols;
			this.positions = positions;
			this.positionsWithRangeTerminals = positionsWithRangeTerminals;
			minMaxNodesCount = minmaxNodesCount;
			this.endMarkerPos = endMarkerPos;
		}

		public override void InitValidation(ValidationState context)
		{
			_ = positions.Count;
			List<RangePositionInfo> list = context.RunningPositions;
			if (list == null)
			{
				list = (context.RunningPositions = new List<RangePositionInfo>());
			}
			else
			{
				list.Clear();
			}
			RangePositionInfo item = default(RangePositionInfo);
			item.curpos = firstpos.Clone();
			item.rangeCounters = new decimal[minMaxNodesCount];
			list.Add(item);
			context.CurrentState.NumberOfRunningPos = 1;
			context.HasMatched = item.curpos.Get(endMarkerPos);
		}

		public override object ValidateElement(XmlQualifiedName name, ValidationState context, out int errorCode)
		{
			errorCode = 0;
			int num = symbols[name];
			bool flag = false;
			List<RangePositionInfo> runningPositions = context.RunningPositions;
			int numberOfRunningPos = context.CurrentState.NumberOfRunningPos;
			int i = 0;
			int num2 = -1;
			int num3 = -1;
			bool flag2 = false;
			for (; i < numberOfRunningPos; i++)
			{
				BitSet curpos = runningPositions[i].curpos;
				for (int num4 = curpos.NextSet(-1); num4 != -1; num4 = curpos.NextSet(num4))
				{
					if (num == positions[num4].symbol)
					{
						num2 = num4;
						if (num3 == -1)
						{
							num3 = i;
						}
						flag2 = true;
						break;
					}
				}
				if (flag2 && positions[num2].particle is XmlSchemaElement)
				{
					break;
				}
			}
			if (i == numberOfRunningPos && num2 != -1)
			{
				i = num3;
			}
			if (i < numberOfRunningPos)
			{
				if (i != 0)
				{
					runningPositions.RemoveRange(0, i);
				}
				numberOfRunningPos -= i;
				i = 0;
				while (i < numberOfRunningPos)
				{
					RangePositionInfo value = runningPositions[i];
					if (value.curpos.Get(num2))
					{
						value.curpos = followpos[num2];
						runningPositions[i] = value;
						i++;
						continue;
					}
					numberOfRunningPos--;
					if (numberOfRunningPos > 0)
					{
						RangePositionInfo value2 = runningPositions[numberOfRunningPos];
						runningPositions[numberOfRunningPos] = runningPositions[i];
						runningPositions[i] = value2;
					}
				}
			}
			else
			{
				numberOfRunningPos = 0;
			}
			if (numberOfRunningPos > 0)
			{
				if (numberOfRunningPos >= 10000)
				{
					context.TooComplex = true;
					numberOfRunningPos /= 2;
				}
				for (i = numberOfRunningPos - 1; i >= 0; i--)
				{
					int index = i;
					BitSet curpos2 = runningPositions[i].curpos;
					flag = flag || curpos2.Get(endMarkerPos);
					while (numberOfRunningPos < 10000 && curpos2.Intersects(positionsWithRangeTerminals))
					{
						BitSet bitSet = curpos2.Clone();
						bitSet.And(positionsWithRangeTerminals);
						int num5 = bitSet.NextSet(-1);
						LeafRangeNode leafRangeNode = positions[num5].particle as LeafRangeNode;
						RangePositionInfo value = runningPositions[index];
						if (numberOfRunningPos + 2 >= runningPositions.Count)
						{
							runningPositions.Add(default(RangePositionInfo));
							runningPositions.Add(default(RangePositionInfo));
						}
						RangePositionInfo value3 = runningPositions[numberOfRunningPos];
						if (value3.rangeCounters == null)
						{
							value3.rangeCounters = new decimal[minMaxNodesCount];
						}
						Array.Copy(value.rangeCounters, 0, value3.rangeCounters, 0, value.rangeCounters.Length);
						decimal num6 = ++value3.rangeCounters[leafRangeNode.Pos];
						if (num6 == leafRangeNode.Max)
						{
							value3.curpos = followpos[num5];
							value3.rangeCounters[leafRangeNode.Pos] = 0m;
							runningPositions[numberOfRunningPos] = value3;
							index = numberOfRunningPos++;
						}
						else
						{
							if (num6 < leafRangeNode.Min)
							{
								value3.curpos = leafRangeNode.NextIteration;
								runningPositions[numberOfRunningPos] = value3;
								numberOfRunningPos++;
								break;
							}
							value3.curpos = leafRangeNode.NextIteration;
							runningPositions[numberOfRunningPos] = value3;
							index = numberOfRunningPos + 1;
							value3 = runningPositions[index];
							if (value3.rangeCounters == null)
							{
								value3.rangeCounters = new decimal[minMaxNodesCount];
							}
							Array.Copy(value.rangeCounters, 0, value3.rangeCounters, 0, value.rangeCounters.Length);
							value3.curpos = followpos[num5];
							value3.rangeCounters[leafRangeNode.Pos] = 0m;
							runningPositions[index] = value3;
							numberOfRunningPos += 2;
						}
						curpos2 = runningPositions[index].curpos;
						flag = flag || curpos2.Get(endMarkerPos);
					}
				}
				context.HasMatched = flag;
				context.CurrentState.NumberOfRunningPos = numberOfRunningPos;
				return positions[num2].particle;
			}
			errorCode = -1;
			context.NeedValidateChildren = false;
			return null;
		}

		public override bool CompleteValidation(ValidationState context)
		{
			return context.HasMatched;
		}

		public override ArrayList ExpectedElements(ValidationState context, bool isRequiredOnly)
		{
			ArrayList arrayList = null;
			if (context.RunningPositions != null)
			{
				List<RangePositionInfo> runningPositions = context.RunningPositions;
				BitSet bitSet = new BitSet(positions.Count);
				for (int num = context.CurrentState.NumberOfRunningPos - 1; num >= 0; num--)
				{
					bitSet.Or(runningPositions[num].curpos);
				}
				for (int num2 = bitSet.NextSet(-1); num2 != -1; num2 = bitSet.NextSet(num2))
				{
					if (arrayList == null)
					{
						arrayList = new ArrayList();
					}
					int symbol = positions[num2].symbol;
					if (symbol >= 0)
					{
						if (!(positions[num2].particle is XmlSchemaParticle xmlSchemaParticle))
						{
							string text = symbols.NameOf(positions[num2].symbol);
							if (text.Length != 0)
							{
								arrayList.Add(text);
							}
						}
						else
						{
							string nameString = xmlSchemaParticle.NameString;
							if (!arrayList.Contains(nameString))
							{
								arrayList.Add(nameString);
							}
						}
					}
				}
			}
			return arrayList;
		}

		public override ArrayList ExpectedParticles(ValidationState context, bool isRequiredOnly)
		{
			ArrayList arrayList = new ArrayList();
			if (context.RunningPositions != null)
			{
				List<RangePositionInfo> runningPositions = context.RunningPositions;
				BitSet bitSet = new BitSet(positions.Count);
				for (int num = context.CurrentState.NumberOfRunningPos - 1; num >= 0; num--)
				{
					bitSet.Or(runningPositions[num].curpos);
				}
				for (int num2 = bitSet.NextSet(-1); num2 != -1; num2 = bitSet.NextSet(num2))
				{
					int symbol = positions[num2].symbol;
					if (symbol >= 0 && positions[num2].particle is XmlSchemaParticle xmlSchemaParticle && !arrayList.Contains(xmlSchemaParticle))
					{
						arrayList.Add(xmlSchemaParticle);
					}
				}
			}
			return arrayList;
		}
	}
	internal sealed class AllElementsContentValidator : ContentValidator
	{
		private Hashtable elements;

		private object[] particles;

		private BitSet isRequired;

		private int countRequired;

		public override bool IsEmptiable
		{
			get
			{
				if (!base.IsEmptiable)
				{
					return countRequired == 0;
				}
				return true;
			}
		}

		public AllElementsContentValidator(XmlSchemaContentType contentType, int size, bool isEmptiable)
			: base(contentType, isOpen: false, isEmptiable)
		{
			elements = new Hashtable(size);
			particles = new object[size];
			isRequired = new BitSet(size);
		}

		public bool AddElement(XmlQualifiedName name, object particle, bool isEmptiable)
		{
			if (elements[name] != null)
			{
				return false;
			}
			int count = elements.Count;
			elements.Add(name, count);
			particles[count] = particle;
			if (!isEmptiable)
			{
				isRequired.Set(count);
				countRequired++;
			}
			return true;
		}

		public override void InitValidation(ValidationState context)
		{
			context.AllElementsSet = new BitSet(elements.Count);
			context.CurrentState.AllElementsRequired = -1;
		}

		public override object ValidateElement(XmlQualifiedName name, ValidationState context, out int errorCode)
		{
			object obj = elements[name];
			errorCode = 0;
			if (obj == null)
			{
				context.NeedValidateChildren = false;
				return null;
			}
			int num = (int)obj;
			if (context.AllElementsSet[num])
			{
				errorCode = -2;
				return null;
			}
			if (context.CurrentState.AllElementsRequired == -1)
			{
				context.CurrentState.AllElementsRequired = 0;
			}
			context.AllElementsSet.Set(num);
			if (isRequired[num])
			{
				context.CurrentState.AllElementsRequired++;
			}
			return particles[num];
		}

		public override bool CompleteValidation(ValidationState context)
		{
			if (context.CurrentState.AllElementsRequired == countRequired || (IsEmptiable && context.CurrentState.AllElementsRequired == -1))
			{
				return true;
			}
			return false;
		}

		public override ArrayList ExpectedElements(ValidationState context, bool isRequiredOnly)
		{
			ArrayList arrayList = null;
			foreach (DictionaryEntry element in elements)
			{
				if (!context.AllElementsSet[(int)element.Value] && (!isRequiredOnly || isRequired[(int)element.Value]))
				{
					if (arrayList == null)
					{
						arrayList = new ArrayList();
					}
					arrayList.Add(element.Key);
				}
			}
			return arrayList;
		}

		public override ArrayList ExpectedParticles(ValidationState context, bool isRequiredOnly)
		{
			ArrayList arrayList = new ArrayList();
			foreach (DictionaryEntry element in elements)
			{
				if (!context.AllElementsSet[(int)element.Value] && (!isRequiredOnly || isRequired[(int)element.Value]))
				{
					arrayList.Add(particles[(int)element.Value]);
				}
			}
			return arrayList;
		}
	}
	public enum XmlSchemaDatatypeVariety
	{
		Atomic,
		List,
		Union
	}
	internal class XsdSimpleValue
	{
		private XmlSchemaSimpleType xmlType;

		private object typedValue;

		public XmlSchemaSimpleType XmlType => xmlType;

		public object TypedValue => typedValue;

		public XsdSimpleValue(XmlSchemaSimpleType st, object value)
		{
			xmlType = st;
			typedValue = value;
		}
	}
	[Flags]
	internal enum RestrictionFlags
	{
		Length = 1,
		MinLength = 2,
		MaxLength = 4,
		Pattern = 8,
		Enumeration = 0x10,
		WhiteSpace = 0x20,
		MaxInclusive = 0x40,
		MaxExclusive = 0x80,
		MinInclusive = 0x100,
		MinExclusive = 0x200,
		TotalDigits = 0x400,
		FractionDigits = 0x800
	}
	internal enum XmlSchemaWhiteSpace
	{
		Preserve,
		Replace,
		Collapse
	}
	internal class RestrictionFacets
	{
		internal int Length;

		internal int MinLength;

		internal int MaxLength;

		internal ArrayList Patterns;

		internal ArrayList Enumeration;

		internal XmlSchemaWhiteSpace WhiteSpace;

		internal object MaxInclusive;

		internal object MaxExclusive;

		internal object MinInclusive;

		internal object MinExclusive;

		internal int TotalDigits;

		internal int FractionDigits;

		internal RestrictionFlags Flags;

		internal RestrictionFlags FixedFlags;
	}
	public abstract class XmlSchemaDatatype
	{
		public abstract Type ValueType { get; }

		public abstract XmlTokenizedType TokenizedType { get; }

		public virtual XmlSchemaDatatypeVariety Variety => XmlSchemaDatatypeVariety.Atomic;

		public virtual XmlTypeCode TypeCode => XmlTypeCode.None;

		internal abstract bool HasLexicalFacets { get; }

		internal abstract bool HasValueFacets { get; }

		internal abstract XmlValueConverter ValueConverter { get; }

		internal abstract RestrictionFacets Restriction { get; set; }

		internal abstract FacetsChecker FacetsChecker { get; }

		internal abstract XmlSchemaWhiteSpace BuiltInWhitespaceFacet { get; }

		internal string TypeCodeString
		{
			get
			{
				string result = string.Empty;
				XmlTypeCode typeCode = TypeCode;
				switch (Variety)
				{
				case XmlSchemaDatatypeVariety.List:
					result = ((typeCode != XmlTypeCode.AnyAtomicType) ? ("List of " + TypeCodeToString(typeCode)) : "List of Union");
					break;
				case XmlSchemaDatatypeVariety.Union:
					result = "Union";
					break;
				case XmlSchemaDatatypeVariety.Atomic:
					result = ((typeCode != XmlTypeCode.AnyAtomicType) ? TypeCodeToString(typeCode) : "anySimpleType");
					break;
				}
				return result;
			}
		}

		public abstract object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr);

		public virtual object ChangeType(object value, Type targetType)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (targetType == null)
			{
				throw new ArgumentNullException("targetType");
			}
			return ValueConverter.ChangeType(value, targetType);
		}

		public virtual object ChangeType(object value, Type targetType, IXmlNamespaceResolver namespaceResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (targetType == null)
			{
				throw new ArgumentNullException("targetType");
			}
			if (namespaceResolver == null)
			{
				throw new ArgumentNullException("namespaceResolver");
			}
			return ValueConverter.ChangeType(value, targetType, namespaceResolver);
		}

		public virtual bool IsDerivedFrom(XmlSchemaDatatype datatype)
		{
			return false;
		}

		internal abstract int Compare(object value1, object value2);

		internal abstract object ParseValue(string s, Type typDest, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr);

		internal abstract object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, bool createAtomicValue);

		internal abstract Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue);

		internal abstract Exception TryParseValue(object value, XmlNameTable nameTable, IXmlNamespaceResolver namespaceResolver, out object typedValue);

		internal abstract XmlSchemaDatatype DeriveByRestriction(XmlSchemaObjectCollection facets, XmlNameTable nameTable, XmlSchemaType schemaType);

		internal abstract XmlSchemaDatatype DeriveByList(XmlSchemaType schemaType);

		internal abstract void VerifySchemaValid(XmlSchemaObjectTable notations, XmlSchemaObject caller);

		internal abstract bool IsEqual(object o1, object o2);

		internal abstract bool IsComparable(XmlSchemaDatatype dtype);

		internal string TypeCodeToString(XmlTypeCode typeCode)
		{
			return typeCode switch
			{
				XmlTypeCode.None => "None", 
				XmlTypeCode.Item => "AnyType", 
				XmlTypeCode.AnyAtomicType => "AnyAtomicType", 
				XmlTypeCode.String => "String", 
				XmlTypeCode.Boolean => "Boolean", 
				XmlTypeCode.Decimal => "Decimal", 
				XmlTypeCode.Float => "Float", 
				XmlTypeCode.Double => "Double", 
				XmlTypeCode.Duration => "Duration", 
				XmlTypeCode.DateTime => "DateTime", 
				XmlTypeCode.Time => "Time", 
				XmlTypeCode.Date => "Date", 
				XmlTypeCode.GYearMonth => "GYearMonth", 
				XmlTypeCode.GYear => "GYear", 
				XmlTypeCode.GMonthDay => "GMonthDay", 
				XmlTypeCode.GDay => "GDay", 
				XmlTypeCode.GMonth => "GMonth", 
				XmlTypeCode.HexBinary => "HexBinary", 
				XmlTypeCode.Base64Binary => "Base64Binary", 
				XmlTypeCode.AnyUri => "AnyUri", 
				XmlTypeCode.QName => "QName", 
				XmlTypeCode.Notation => "Notation", 
				XmlTypeCode.NormalizedString => "NormalizedString", 
				XmlTypeCode.Token => "Token", 
				XmlTypeCode.Language => "Language", 
				XmlTypeCode.NmToken => "NmToken", 
				XmlTypeCode.Name => "Name", 
				XmlTypeCode.NCName => "NCName", 
				XmlTypeCode.Id => "Id", 
				XmlTypeCode.Idref => "Idref", 
				XmlTypeCode.Entity => "Entity", 
				XmlTypeCode.Integer => "Integer", 
				XmlTypeCode.NonPositiveInteger => "NonPositiveInteger", 
				XmlTypeCode.NegativeInteger => "NegativeInteger", 
				XmlTypeCode.Long => "Long", 
				XmlTypeCode.Int => "Int", 
				XmlTypeCode.Short => "Short", 
				XmlTypeCode.Byte => "Byte", 
				XmlTypeCode.NonNegativeInteger => "NonNegativeInteger", 
				XmlTypeCode.UnsignedLong => "UnsignedLong", 
				XmlTypeCode.UnsignedInt => "UnsignedInt", 
				XmlTypeCode.UnsignedShort => "UnsignedShort", 
				XmlTypeCode.UnsignedByte => "UnsignedByte", 
				XmlTypeCode.PositiveInteger => "PositiveInteger", 
				_ => typeCode.ToString(), 
			};
		}

		internal static string ConcatenatedToString(object value)
		{
			Type type = value.GetType();
			string result = string.Empty;
			if (type != typeof(IEnumerable) || type == typeof(string))
			{
				result = ((!(value is IFormattable)) ? value.ToString() : ((IFormattable)value).ToString("", CultureInfo.InvariantCulture));
			}
			else
			{
				StringBuilder stringBuilder = new StringBuilder();
				IEnumerator enumerator = (value as IEnumerable).GetEnumerator();
				if (enumerator.MoveNext())
				{
					stringBuilder.Append("{");
					object current = enumerator.Current;
					if (current is IFormattable)
					{
						stringBuilder.Append(((IFormattable)current).ToString("", CultureInfo.InvariantCulture));
					}
					else
					{
						stringBuilder.Append(current.ToString());
					}
					while (enumerator.MoveNext())
					{
						stringBuilder.Append(" , ");
						current = enumerator.Current;
						if (current is IFormattable)
						{
							stringBuilder.Append(((IFormattable)current).ToString("", CultureInfo.InvariantCulture));
						}
						else
						{
							stringBuilder.Append(current.ToString());
						}
					}
					stringBuilder.Append("}");
					result = stringBuilder.ToString();
				}
			}
			return result;
		}

		internal static XmlSchemaDatatype FromXmlTokenizedType(XmlTokenizedType token)
		{
			return DatatypeImplementation.FromXmlTokenizedType(token);
		}

		internal static XmlSchemaDatatype FromXmlTokenizedTypeXsd(XmlTokenizedType token)
		{
			return DatatypeImplementation.FromXmlTokenizedTypeXsd(token);
		}

		internal static XmlSchemaDatatype FromXdrName(string name)
		{
			return DatatypeImplementation.FromXdrName(name);
		}

		internal static XmlSchemaDatatype DeriveByUnion(XmlSchemaSimpleType[] types, XmlSchemaType schemaType)
		{
			return DatatypeImplementation.DeriveByUnion(types, schemaType);
		}

		internal static string XdrCanonizeUri(string uri, XmlNameTable nameTable, SchemaNames schemaNames)
		{
			int num = 5;
			bool flag = false;
			if (uri.Length > 5 && uri.StartsWith("uuid:", StringComparison.Ordinal))
			{
				flag = true;
			}
			else if (uri.Length > 9 && uri.StartsWith("urn:uuid:", StringComparison.Ordinal))
			{
				flag = true;
				num = 9;
			}
			string text = ((!flag) ? uri : nameTable.Add(uri.Substring(0, num) + uri.Substring(num, uri.Length - num).ToUpper(CultureInfo.InvariantCulture)));
			if (Ref.Equal(schemaNames.NsDataTypeAlias, text) || Ref.Equal(schemaNames.NsDataTypeOld, text))
			{
				text = schemaNames.NsDataType;
			}
			else if (Ref.Equal(schemaNames.NsXdrAlias, text))
			{
				text = schemaNames.NsXdr;
			}
			return text;
		}
	}
	internal abstract class DatatypeImplementation : XmlSchemaDatatype
	{
		private class SchemaDatatypeMap : IComparable
		{
			private string name;

			private DatatypeImplementation type;

			private int parentIndex;

			public string Name => name;

			public int ParentIndex => parentIndex;

			internal SchemaDatatypeMap(string name, DatatypeImplementation type)
			{
				this.name = name;
				this.type = type;
			}

			internal SchemaDatatypeMap(string name, DatatypeImplementation type, int parentIndex)
			{
				this.name = name;
				this.type = type;
				this.parentIndex = parentIndex;
			}

			public static explicit operator DatatypeImplementation(SchemaDatatypeMap sdm)
			{
				return sdm.type;
			}

			public int CompareTo(object obj)
			{
				return string.Compare(name, (string)obj, StringComparison.Ordinal);
			}
		}

		private const int anySimpleTypeIndex = 11;

		private XmlSchemaDatatypeVariety variety;

		private RestrictionFacets restriction;

		private DatatypeImplementation baseType;

		private XmlValueConverter valueConverter;

		private XmlSchemaType parentSchemaType;

		private static Hashtable builtinTypes;

		private static XmlSchemaSimpleType[] enumToTypeCode;

		private static XmlSchemaSimpleType anySimpleType;

		private static XmlSchemaSimpleType anyAtomicType;

		private static XmlSchemaSimpleType untypedAtomicType;

		private static XmlSchemaSimpleType yearMonthDurationType;

		private static XmlSchemaSimpleType dayTimeDurationType;

		private static XmlSchemaSimpleType normalizedStringTypeV1Compat;

		private static XmlSchemaSimpleType tokenTypeV1Compat;

		internal static XmlQualifiedName QnAnySimpleType;

		internal static XmlQualifiedName QnAnyType;

		internal static FacetsChecker stringFacetsChecker;

		internal static FacetsChecker miscFacetsChecker;

		internal static FacetsChecker numeric2FacetsChecker;

		internal static FacetsChecker binaryFacetsChecker;

		internal static FacetsChecker dateTimeFacetsChecker;

		internal static FacetsChecker durationFacetsChecker;

		internal static FacetsChecker listFacetsChecker;

		internal static FacetsChecker qnameFacetsChecker;

		internal static FacetsChecker unionFacetsChecker;

		private static readonly DatatypeImplementation c_anySimpleType;

		private static readonly DatatypeImplementation c_anyURI;

		private static readonly DatatypeImplementation c_base64Binary;

		private static readonly DatatypeImplementation c_boolean;

		private static readonly DatatypeImplementation c_byte;

		private static readonly DatatypeImplementation c_char;

		private static readonly DatatypeImplementation c_date;

		private static readonly DatatypeImplementation c_dateTime;

		private static readonly DatatypeImplementation c_dateTimeNoTz;

		private static readonly DatatypeImplementation c_dateTimeTz;

		private static readonly DatatypeImplementation c_day;

		private static readonly DatatypeImplementation c_decimal;

		private static readonly DatatypeImplementation c_double;

		private static readonly DatatypeImplementation c_doubleXdr;

		private static readonly DatatypeImplementation c_duration;

		private static readonly DatatypeImplementation c_ENTITY;

		private static readonly DatatypeImplementation c_ENTITIES;

		private static readonly DatatypeImplementation c_ENUMERATION;

		private static readonly DatatypeImplementation c_fixed;

		private static readonly DatatypeImplementation c_float;

		private static readonly DatatypeImplementation c_floatXdr;

		private static readonly DatatypeImplementation c_hexBinary;

		private static readonly DatatypeImplementation c_ID;

		private static readonly DatatypeImplementation c_IDREF;

		private static readonly DatatypeImplementation c_IDREFS;

		private static readonly DatatypeImplementation c_int;

		private static readonly DatatypeImplementation c_integer;

		private static readonly DatatypeImplementation c_language;

		private static readonly DatatypeImplementation c_long;

		private static readonly DatatypeImplementation c_month;

		private static readonly DatatypeImplementation c_monthDay;

		private static readonly DatatypeImplementation c_Name;

		private static readonly DatatypeImplementation c_NCName;

		private static readonly DatatypeImplementation c_negativeInteger;

		private static readonly DatatypeImplementation c_NMTOKEN;

		private static readonly DatatypeImplementation c_NMTOKENS;

		private static readonly DatatypeImplementation c_nonNegativeInteger;

		private static readonly DatatypeImplementation c_nonPositiveInteger;

		private static readonly DatatypeImplementation c_normalizedString;

		private static readonly DatatypeImplementation c_NOTATION;

		private static readonly DatatypeImplementation c_positiveInteger;

		private static readonly DatatypeImplementation c_QName;

		private static readonly DatatypeImplementation c_QNameXdr;

		private static readonly DatatypeImplementation c_short;

		private static readonly DatatypeImplementation c_string;

		private static readonly DatatypeImplementation c_time;

		private static readonly DatatypeImplementation c_timeNoTz;

		private static readonly DatatypeImplementation c_timeTz;

		private static readonly DatatypeImplementation c_token;

		private static readonly DatatypeImplementation c_unsignedByte;

		private static readonly DatatypeImplementation c_unsignedInt;

		private static readonly DatatypeImplementation c_unsignedLong;

		private static readonly DatatypeImplementation c_unsignedShort;

		private static readonly DatatypeImplementation c_uuid;

		private static readonly DatatypeImplementation c_year;

		private static readonly DatatypeImplementation c_yearMonth;

		internal static readonly DatatypeImplementation c_normalizedStringV1Compat;

		internal static readonly DatatypeImplementation c_tokenV1Compat;

		private static readonly DatatypeImplementation c_anyAtomicType;

		private static readonly DatatypeImplementation c_dayTimeDuration;

		private static readonly DatatypeImplementation c_untypedAtomicType;

		private static readonly DatatypeImplementation c_yearMonthDuration;

		private static readonly DatatypeImplementation[] c_tokenizedTypes;

		private static readonly DatatypeImplementation[] c_tokenizedTypesXsd;

		private static readonly SchemaDatatypeMap[] c_XdrTypes;

		private static readonly SchemaDatatypeMap[] c_XsdTypes;

		internal static XmlSchemaSimpleType AnySimpleType => anySimpleType;

		internal static XmlSchemaSimpleType AnyAtomicType => anyAtomicType;

		internal static XmlSchemaSimpleType UntypedAtomicType => untypedAtomicType;

		internal static XmlSchemaSimpleType YearMonthDurationType => yearMonthDurationType;

		internal static XmlSchemaSimpleType DayTimeDurationType => dayTimeDurationType;

		internal override FacetsChecker FacetsChecker => miscFacetsChecker;

		internal override XmlValueConverter ValueConverter
		{
			get
			{
				if (valueConverter == null)
				{
					valueConverter = CreateValueConverter(parentSchemaType);
				}
				return valueConverter;
			}
		}

		public override XmlTokenizedType TokenizedType => XmlTokenizedType.None;

		public override Type ValueType => typeof(string);

		public override XmlSchemaDatatypeVariety Variety => variety;

		public override XmlTypeCode TypeCode => XmlTypeCode.None;

		internal override RestrictionFacets Restriction
		{
			get
			{
				return restriction;
			}
			set
			{
				restriction = value;
			}
		}

		internal override bool HasLexicalFacets
		{
			get
			{
				RestrictionFlags restrictionFlags = ((restriction != null) ? restriction.Flags : ((RestrictionFlags)0));
				if (restrictionFlags != 0 && (restrictionFlags & (RestrictionFlags.Pattern | RestrictionFlags.WhiteSpace | RestrictionFlags.TotalDigits | RestrictionFlags.FractionDigits)) != 0)
				{
					return true;
				}
				return false;
			}
		}

		internal override bool HasValueFacets
		{
			get
			{
				RestrictionFlags restrictionFlags = ((restriction != null) ? restriction.Flags : ((RestrictionFlags)0));
				if (restrictionFlags != 0 && (restrictionFlags & (RestrictionFlags.Length | RestrictionFlags.MinLength | RestrictionFlags.MaxLength | RestrictionFlags.Enumeration | RestrictionFlags.MaxInclusive | RestrictionFlags.MaxExclusive | RestrictionFlags.MinInclusive | RestrictionFlags.MinExclusive | RestrictionFlags.TotalDigits | RestrictionFlags.FractionDigits)) != 0)
				{
					return true;
				}
				return false;
			}
		}

		protected DatatypeImplementation Base => baseType;

		internal abstract Type ListValueType { get; }

		internal abstract RestrictionFlags ValidRestrictionFlags { get; }

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Preserve;

		static DatatypeImplementation()
		{
			builtinTypes = new Hashtable();
			enumToTypeCode = new XmlSchemaSimpleType[55];
			QnAnySimpleType = new XmlQualifiedName("anySimpleType", "http://www.w3.org/2001/XMLSchema");
			QnAnyType = new XmlQualifiedName("anyType", "http://www.w3.org/2001/XMLSchema");
			stringFacetsChecker = new StringFacetsChecker();
			miscFacetsChecker = new MiscFacetsChecker();
			numeric2FacetsChecker = new Numeric2FacetsChecker();
			binaryFacetsChecker = new BinaryFacetsChecker();
			dateTimeFacetsChecker = new DateTimeFacetsChecker();
			durationFacetsChecker = new DurationFacetsChecker();
			listFacetsChecker = new ListFacetsChecker();
			qnameFacetsChecker = new QNameFacetsChecker();
			unionFacetsChecker = new UnionFacetsChecker();
			c_anySimpleType = new Datatype_anySimpleType();
			c_anyURI = new Datatype_anyURI();
			c_base64Binary = new Datatype_base64Binary();
			c_boolean = new Datatype_boolean();
			c_byte = new Datatype_byte();
			c_char = new Datatype_char();
			c_date = new Datatype_date();
			c_dateTime = new Datatype_dateTime();
			c_dateTimeNoTz = new Datatype_dateTimeNoTimeZone();
			c_dateTimeTz = new Datatype_dateTimeTimeZone();
			c_day = new Datatype_day();
			c_decimal = new Datatype_decimal();
			c_double = new Datatype_double();
			c_doubleXdr = new Datatype_doubleXdr();
			c_duration = new Datatype_duration();
			c_ENTITY = new Datatype_ENTITY();
			c_ENTITIES = (DatatypeImplementation)c_ENTITY.DeriveByList(1, null);
			c_ENUMERATION = new Datatype_ENUMERATION();
			c_fixed = new Datatype_fixed();
			c_float = new Datatype_float();
			c_floatXdr = new Datatype_floatXdr();
			c_hexBinary = new Datatype_hexBinary();
			c_ID = new Datatype_ID();
			c_IDREF = new Datatype_IDREF();
			c_IDREFS = (DatatypeImplementation)c_IDREF.DeriveByList(1, null);
			c_int = new Datatype_int();
			c_integer = new Datatype_integer();
			c_language = new Datatype_language();
			c_long = new Datatype_long();
			c_month = new Datatype_month();
			c_monthDay = new Datatype_monthDay();
			c_Name = new Datatype_Name();
			c_NCName = new Datatype_NCName();
			c_negativeInteger = new Datatype_negativeInteger();
			c_NMTOKEN = new Datatype_NMTOKEN();
			c_NMTOKENS = (DatatypeImplementation)c_NMTOKEN.DeriveByList(1, null);
			c_nonNegativeInteger = new Datatype_nonNegativeInteger();
			c_nonPositiveInteger = new Datatype_nonPositiveInteger();
			c_normalizedString = new Datatype_normalizedString();
			c_NOTATION = new Datatype_NOTATION();
			c_positiveInteger = new Datatype_positiveInteger();
			c_QName = new Datatype_QName();
			c_QNameXdr = new Datatype_QNameXdr();
			c_short = new Datatype_short();
			c_string = new Datatype_string();
			c_time = new Datatype_time();
			c_timeNoTz = new Datatype_timeNoTimeZone();
			c_timeTz = new Datatype_timeTimeZone();
			c_token = new Datatype_token();
			c_unsignedByte = new Datatype_unsignedByte();
			c_unsignedInt = new Datatype_unsignedInt();
			c_unsignedLong = new Datatype_unsignedLong();
			c_unsignedShort = new Datatype_unsignedShort();
			c_uuid = new Datatype_uuid();
			c_year = new Datatype_year();
			c_yearMonth = new Datatype_yearMonth();
			c_normalizedStringV1Compat = new Datatype_normalizedStringV1Compat();
			c_tokenV1Compat = new Datatype_tokenV1Compat();
			c_anyAtomicType = new Datatype_anyAtomicType();
			c_dayTimeDuration = new Datatype_dayTimeDuration();
			c_untypedAtomicType = new Datatype_untypedAtomicType();
			c_yearMonthDuration = new Datatype_yearMonthDuration();
			c_tokenizedTypes = new DatatypeImplementation[13]
			{
				c_string, c_ID, c_IDREF, c_IDREFS, c_ENTITY, c_ENTITIES, c_NMTOKEN, c_NMTOKENS, c_NOTATION, c_ENUMERATION,
				c_QNameXdr, c_NCName, null
			};
			c_tokenizedTypesXsd = new DatatypeImplementation[13]
			{
				c_string, c_ID, c_IDREF, c_IDREFS, c_ENTITY, c_ENTITIES, c_NMTOKEN, c_NMTOKENS, c_NOTATION, c_ENUMERATION,
				c_QName, c_NCName, null
			};
			c_XdrTypes = new SchemaDatatypeMap[38]
			{
				new SchemaDatatypeMap("bin.base64", c_base64Binary),
				new SchemaDatatypeMap("bin.hex", c_hexBinary),
				new SchemaDatatypeMap("boolean", c_boolean),
				new SchemaDatatypeMap("char", c_char),
				new SchemaDatatypeMap("date", c_date),
				new SchemaDatatypeMap("dateTime", c_dateTimeNoTz),
				new SchemaDatatypeMap("dateTime.tz", c_dateTimeTz),
				new SchemaDatatypeMap("decimal", c_decimal),
				new SchemaDatatypeMap("entities", c_ENTITIES),
				new SchemaDatatypeMap("entity", c_ENTITY),
				new SchemaDatatypeMap("enumeration", c_ENUMERATION),
				new SchemaDatatypeMap("fixed.14.4", c_fixed),
				new SchemaDatatypeMap("float", c_doubleXdr),
				new SchemaDatatypeMap("float.ieee.754.32", c_floatXdr),
				new SchemaDatatypeMap("float.ieee.754.64", c_doubleXdr),
				new SchemaDatatypeMap("i1", c_byte),
				new SchemaDatatypeMap("i2", c_short),
				new SchemaDatatypeMap("i4", c_int),
				new SchemaDatatypeMap("i8", c_long),
				new SchemaDatatypeMap("id", c_ID),
				new SchemaDatatypeMap("idref", c_IDREF),
				new SchemaDatatypeMap("idrefs", c_IDREFS),
				new SchemaDatatypeMap("int", c_int),
				new SchemaDatatypeMap("nmtoken", c_NMTOKEN),
				new SchemaDatatypeMap("nmtokens", c_NMTOKENS),
				new SchemaDatatypeMap("notation", c_NOTATION),
				new SchemaDatatypeMap("number", c_doubleXdr),
				new SchemaDatatypeMap("r4", c_floatXdr),
				new SchemaDatatypeMap("r8", c_doubleXdr),
				new SchemaDatatypeMap("string", c_string),
				new SchemaDatatypeMap("time", c_timeNoTz),
				new SchemaDatatypeMap("time.tz", c_timeTz),
				new SchemaDatatypeMap("ui1", c_unsignedByte),
				new SchemaDatatypeMap("ui2", c_unsignedShort),
				new SchemaDatatypeMap("ui4", c_unsignedInt),
				new SchemaDatatypeMap("ui8", c_unsignedLong),
				new SchemaDatatypeMap("uri", c_anyURI),
				new SchemaDatatypeMap("uuid", c_uuid)
			};
			c_XsdTypes = new SchemaDatatypeMap[45]
			{
				new SchemaDatatypeMap("ENTITIES", c_ENTITIES, 11),
				new SchemaDatatypeMap("ENTITY", c_ENTITY, 11),
				new SchemaDatatypeMap("ID", c_ID, 5),
				new SchemaDatatypeMap("IDREF", c_IDREF, 5),
				new SchemaDatatypeMap("IDREFS", c_IDREFS, 11),
				new SchemaDatatypeMap("NCName", c_NCName, 9),
				new SchemaDatatypeMap("NMTOKEN", c_NMTOKEN, 40),
				new SchemaDatatypeMap("NMTOKENS", c_NMTOKENS, 11),
				new SchemaDatatypeMap("NOTATION", c_NOTATION, 11),
				new SchemaDatatypeMap("Name", c_Name, 40),
				new SchemaDatatypeMap("QName", c_QName, 11),
				new SchemaDatatypeMap("anySimpleType", c_anySimpleType, -1),
				new SchemaDatatypeMap("anyURI", c_anyURI, 11),
				new SchemaDatatypeMap("base64Binary", c_base64Binary, 11),
				new SchemaDatatypeMap("boolean", c_boolean, 11),
				new SchemaDatatypeMap("byte", c_byte, 37),
				new SchemaDatatypeMap("date", c_date, 11),
				new SchemaDatatypeMap("dateTime", c_dateTime, 11),
				new SchemaDatatypeMap("decimal", c_decimal, 11),
				new SchemaDatatypeMap("double", c_double, 11),
				new SchemaDatatypeMap("duration", c_duration, 11),
				new SchemaDatatypeMap("float", c_float, 11),
				new SchemaDatatypeMap("gDay", c_day, 11),
				new SchemaDatatypeMap("gMonth", c_month, 11),
				new SchemaDatatypeMap("gMonthDay", c_monthDay, 11),
				new SchemaDatatypeMap("gYear", c_year, 11),
				new SchemaDatatypeMap("gYearMonth", c_yearMonth, 11),
				new SchemaDatatypeMap("hexBinary", c_hexBinary, 11),
				new SchemaDatatypeMap("int", c_int, 31),
				new SchemaDatatypeMap("integer", c_integer, 18),
				new SchemaDatatypeMap("language", c_language, 40),
				new SchemaDatatypeMap("long", c_long, 29),
				new SchemaDatatypeMap("negativeInteger", c_negativeInteger, 34),
				new SchemaDatatypeMap("nonNegativeInteger", c_nonNegativeInteger, 29),
				new SchemaDatatypeMap("nonPositiveInteger", c_nonPositiveInteger, 29),
				new SchemaDatatypeMap("normalizedString", c_normalizedString, 38),
				new SchemaDatatypeMap("positiveInteger", c_positiveInteger, 33),
				new SchemaDatatypeMap("short", c_short, 28),
				new SchemaDatatypeMap("string", c_string, 11),
				new SchemaDatatypeMap("time", c_time, 11),
				new SchemaDatatypeMap("token", c_token, 35),
				new SchemaDatatypeMap("unsignedByte", c_unsignedByte, 44),
				new SchemaDatatypeMap("unsignedInt", c_unsignedInt, 43),
				new SchemaDatatypeMap("unsignedLong", c_unsignedLong, 33),
				new SchemaDatatypeMap("unsignedShort", c_unsignedShort, 42)
			};
			CreateBuiltinTypes();
		}

		internal new static DatatypeImplementation FromXmlTokenizedType(XmlTokenizedType token)
		{
			return c_tokenizedTypes[(int)token];
		}

		internal new static DatatypeImplementation FromXmlTokenizedTypeXsd(XmlTokenizedType token)
		{
			return c_tokenizedTypesXsd[(int)token];
		}

		internal new static DatatypeImplementation FromXdrName(string name)
		{
			int num = Array.BinarySearch(c_XdrTypes, name, null);
			if (num >= 0)
			{
				return (DatatypeImplementation)c_XdrTypes[num];
			}
			return null;
		}

		private static DatatypeImplementation FromTypeName(string name)
		{
			int num = Array.BinarySearch(c_XsdTypes, name, null);
			if (num >= 0)
			{
				return (DatatypeImplementation)c_XsdTypes[num];
			}
			return null;
		}

		internal static XmlSchemaSimpleType StartBuiltinType(XmlQualifiedName qname, XmlSchemaDatatype dataType)
		{
			XmlSchemaSimpleType xmlSchemaSimpleType = new XmlSchemaSimpleType();
			xmlSchemaSimpleType.SetQualifiedName(qname);
			xmlSchemaSimpleType.SetDatatype(dataType);
			xmlSchemaSimpleType.ElementDecl = new SchemaElementDecl(dataType);
			xmlSchemaSimpleType.ElementDecl.SchemaType = xmlSchemaSimpleType;
			return xmlSchemaSimpleType;
		}

		internal static void FinishBuiltinType(XmlSchemaSimpleType derivedType, XmlSchemaSimpleType baseType)
		{
			derivedType.SetBaseSchemaType(baseType);
			derivedType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
			if (derivedType.Datatype.Variety == XmlSchemaDatatypeVariety.Atomic)
			{
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = new XmlSchemaSimpleTypeRestriction();
				xmlSchemaSimpleTypeRestriction.BaseTypeName = baseType.QualifiedName;
				derivedType.Content = xmlSchemaSimpleTypeRestriction;
			}
			if (derivedType.Datatype.Variety == XmlSchemaDatatypeVariety.List)
			{
				XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = new XmlSchemaSimpleTypeList();
				derivedType.SetDerivedBy(XmlSchemaDerivationMethod.List);
				switch (derivedType.Datatype.TypeCode)
				{
				case XmlTypeCode.NmToken:
				{
					XmlSchemaSimpleType xmlSchemaSimpleType9 = (xmlSchemaSimpleTypeList.ItemType = (xmlSchemaSimpleTypeList.BaseItemType = enumToTypeCode[34]));
					break;
				}
				case XmlTypeCode.Entity:
				{
					XmlSchemaSimpleType xmlSchemaSimpleType6 = (xmlSchemaSimpleTypeList.ItemType = (xmlSchemaSimpleTypeList.BaseItemType = enumToTypeCode[39]));
					break;
				}
				case XmlTypeCode.Idref:
				{
					XmlSchemaSimpleType xmlSchemaSimpleType3 = (xmlSchemaSimpleTypeList.ItemType = (xmlSchemaSimpleTypeList.BaseItemType = enumToTypeCode[38]));
					break;
				}
				}
				derivedType.Content = xmlSchemaSimpleTypeList;
			}
		}

		internal static void CreateBuiltinTypes()
		{
			SchemaDatatypeMap schemaDatatypeMap = c_XsdTypes[11];
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(schemaDatatypeMap.Name, "http://www.w3.org/2001/XMLSchema");
			DatatypeImplementation datatypeImplementation = FromTypeName(xmlQualifiedName.Name);
			anySimpleType = StartBuiltinType(xmlQualifiedName, datatypeImplementation);
			datatypeImplementation.parentSchemaType = anySimpleType;
			builtinTypes.Add(xmlQualifiedName, anySimpleType);
			for (int i = 0; i < c_XsdTypes.Length; i++)
			{
				if (i != 11)
				{
					schemaDatatypeMap = c_XsdTypes[i];
					xmlQualifiedName = new XmlQualifiedName(schemaDatatypeMap.Name, "http://www.w3.org/2001/XMLSchema");
					datatypeImplementation = FromTypeName(xmlQualifiedName.Name);
					XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)(datatypeImplementation.parentSchemaType = StartBuiltinType(xmlQualifiedName, datatypeImplementation));
					builtinTypes.Add(xmlQualifiedName, xmlSchemaSimpleType);
					if (datatypeImplementation.variety == XmlSchemaDatatypeVariety.Atomic)
					{
						enumToTypeCode[(int)datatypeImplementation.TypeCode] = xmlSchemaSimpleType;
					}
				}
			}
			for (int j = 0; j < c_XsdTypes.Length; j++)
			{
				if (j != 11)
				{
					schemaDatatypeMap = c_XsdTypes[j];
					XmlSchemaSimpleType derivedType = (XmlSchemaSimpleType)builtinTypes[new XmlQualifiedName(schemaDatatypeMap.Name, "http://www.w3.org/2001/XMLSchema")];
					if (schemaDatatypeMap.ParentIndex == 11)
					{
						FinishBuiltinType(derivedType, anySimpleType);
						continue;
					}
					XmlSchemaSimpleType xmlSchemaSimpleType2 = (XmlSchemaSimpleType)builtinTypes[new XmlQualifiedName(c_XsdTypes[schemaDatatypeMap.ParentIndex].Name, "http://www.w3.org/2001/XMLSchema")];
					FinishBuiltinType(derivedType, xmlSchemaSimpleType2);
				}
			}
			xmlQualifiedName = new XmlQualifiedName("anyAtomicType", "http://www.w3.org/2003/11/xpath-datatypes");
			anyAtomicType = StartBuiltinType(xmlQualifiedName, c_anyAtomicType);
			c_anyAtomicType.parentSchemaType = anyAtomicType;
			FinishBuiltinType(anyAtomicType, anySimpleType);
			builtinTypes.Add(xmlQualifiedName, anyAtomicType);
			enumToTypeCode[10] = anyAtomicType;
			xmlQualifiedName = new XmlQualifiedName("untypedAtomic", "http://www.w3.org/2003/11/xpath-datatypes");
			untypedAtomicType = StartBuiltinType(xmlQualifiedName, c_untypedAtomicType);
			c_untypedAtomicType.parentSchemaType = untypedAtomicType;
			FinishBuiltinType(untypedAtomicType, anyAtomicType);
			builtinTypes.Add(xmlQualifiedName, untypedAtomicType);
			enumToTypeCode[11] = untypedAtomicType;
			xmlQualifiedName = new XmlQualifiedName("yearMonthDuration", "http://www.w3.org/2003/11/xpath-datatypes");
			yearMonthDurationType = StartBuiltinType(xmlQualifiedName, c_yearMonthDuration);
			c_yearMonthDuration.parentSchemaType = yearMonthDurationType;
			FinishBuiltinType(yearMonthDurationType, enumToTypeCode[17]);
			builtinTypes.Add(xmlQualifiedName, yearMonthDurationType);
			enumToTypeCode[53] = yearMonthDurationType;
			xmlQualifiedName = new XmlQualifiedName("dayTimeDuration", "http://www.w3.org/2003/11/xpath-datatypes");
			dayTimeDurationType = StartBuiltinType(xmlQualifiedName, c_dayTimeDuration);
			c_dayTimeDuration.parentSchemaType = dayTimeDurationType;
			FinishBuiltinType(dayTimeDurationType, enumToTypeCode[17]);
			builtinTypes.Add(xmlQualifiedName, dayTimeDurationType);
			enumToTypeCode[54] = dayTimeDurationType;
		}

		internal static XmlSchemaSimpleType GetSimpleTypeFromTypeCode(XmlTypeCode typeCode)
		{
			return enumToTypeCode[(int)typeCode];
		}

		internal static XmlSchemaSimpleType GetSimpleTypeFromXsdType(XmlQualifiedName qname)
		{
			return (XmlSchemaSimpleType)builtinTypes[qname];
		}

		internal static XmlSchemaSimpleType GetNormalizedStringTypeV1Compat()
		{
			if (normalizedStringTypeV1Compat == null)
			{
				XmlSchemaSimpleType simpleTypeFromTypeCode = GetSimpleTypeFromTypeCode(XmlTypeCode.NormalizedString);
				normalizedStringTypeV1Compat = simpleTypeFromTypeCode.Clone() as XmlSchemaSimpleType;
				normalizedStringTypeV1Compat.SetDatatype(c_normalizedStringV1Compat);
				normalizedStringTypeV1Compat.ElementDecl = new SchemaElementDecl(c_normalizedStringV1Compat);
				normalizedStringTypeV1Compat.ElementDecl.SchemaType = normalizedStringTypeV1Compat;
			}
			return normalizedStringTypeV1Compat;
		}

		internal static XmlSchemaSimpleType GetTokenTypeV1Compat()
		{
			if (tokenTypeV1Compat == null)
			{
				XmlSchemaSimpleType simpleTypeFromTypeCode = GetSimpleTypeFromTypeCode(XmlTypeCode.Token);
				tokenTypeV1Compat = simpleTypeFromTypeCode.Clone() as XmlSchemaSimpleType;
				tokenTypeV1Compat.SetDatatype(c_tokenV1Compat);
				tokenTypeV1Compat.ElementDecl = new SchemaElementDecl(c_tokenV1Compat);
				tokenTypeV1Compat.ElementDecl.SchemaType = tokenTypeV1Compat;
			}
			return tokenTypeV1Compat;
		}

		internal static XmlSchemaSimpleType[] GetBuiltInTypes()
		{
			return enumToTypeCode;
		}

		internal static XmlTypeCode GetPrimitiveTypeCode(XmlTypeCode typeCode)
		{
			XmlSchemaSimpleType xmlSchemaSimpleType = enumToTypeCode[(int)typeCode];
			while (xmlSchemaSimpleType.BaseXmlSchemaType != AnySimpleType)
			{
				xmlSchemaSimpleType = xmlSchemaSimpleType.BaseXmlSchemaType as XmlSchemaSimpleType;
			}
			return xmlSchemaSimpleType.TypeCode;
		}

		internal override XmlSchemaDatatype DeriveByRestriction(XmlSchemaObjectCollection facets, XmlNameTable nameTable, XmlSchemaType schemaType)
		{
			DatatypeImplementation datatypeImplementation = (DatatypeImplementation)MemberwiseClone();
			datatypeImplementation.restriction = FacetsChecker.ConstructRestriction(this, facets, nameTable);
			datatypeImplementation.baseType = this;
			datatypeImplementation.parentSchemaType = schemaType;
			datatypeImplementation.valueConverter = null;
			return datatypeImplementation;
		}

		internal override XmlSchemaDatatype DeriveByList(XmlSchemaType schemaType)
		{
			return DeriveByList(0, schemaType);
		}

		internal XmlSchemaDatatype DeriveByList(int minSize, XmlSchemaType schemaType)
		{
			if (variety == XmlSchemaDatatypeVariety.List)
			{
				throw new XmlSchemaException("Sch_ListFromNonatomic", string.Empty);
			}
			if (variety == XmlSchemaDatatypeVariety.Union && !((Datatype_union)this).HasAtomicMembers())
			{
				throw new XmlSchemaException("Sch_ListFromNonatomic", string.Empty);
			}
			DatatypeImplementation datatypeImplementation = new Datatype_List(this, minSize);
			datatypeImplementation.variety = XmlSchemaDatatypeVariety.List;
			datatypeImplementation.restriction = null;
			datatypeImplementation.baseType = c_anySimpleType;
			datatypeImplementation.parentSchemaType = schemaType;
			return datatypeImplementation;
		}

		internal new static DatatypeImplementation DeriveByUnion(XmlSchemaSimpleType[] types, XmlSchemaType schemaType)
		{
			DatatypeImplementation datatypeImplementation = new Datatype_union(types);
			datatypeImplementation.baseType = c_anySimpleType;
			datatypeImplementation.variety = XmlSchemaDatatypeVariety.Union;
			datatypeImplementation.parentSchemaType = schemaType;
			return datatypeImplementation;
		}

		internal override void VerifySchemaValid(XmlSchemaObjectTable notations, XmlSchemaObject caller)
		{
		}

		public override bool IsDerivedFrom(XmlSchemaDatatype datatype)
		{
			if (datatype == null)
			{
				return false;
			}
			for (DatatypeImplementation datatypeImplementation = this; datatypeImplementation != null; datatypeImplementation = datatypeImplementation.baseType)
			{
				if (datatypeImplementation == datatype)
				{
					return true;
				}
			}
			if (((DatatypeImplementation)datatype).baseType == null)
			{
				Type type = GetType();
				Type type2 = datatype.GetType();
				if (type2 != type)
				{
					return type.IsSubclassOf(type2);
				}
				return true;
			}
			if (datatype.Variety == XmlSchemaDatatypeVariety.Union && !datatype.HasLexicalFacets && !datatype.HasValueFacets && variety != XmlSchemaDatatypeVariety.Union)
			{
				return ((Datatype_union)datatype).IsUnionBaseOf(this);
			}
			if ((variety == XmlSchemaDatatypeVariety.Union || variety == XmlSchemaDatatypeVariety.List) && restriction == null)
			{
				return datatype == anySimpleType.Datatype;
			}
			return false;
		}

		internal override bool IsEqual(object o1, object o2)
		{
			return Compare(o1, o2) == 0;
		}

		internal override bool IsComparable(XmlSchemaDatatype dtype)
		{
			XmlTypeCode typeCode = TypeCode;
			XmlTypeCode typeCode2 = dtype.TypeCode;
			if (typeCode == typeCode2)
			{
				return true;
			}
			if (GetPrimitiveTypeCode(typeCode) == GetPrimitiveTypeCode(typeCode2))
			{
				return true;
			}
			if (IsDerivedFrom(dtype) || dtype.IsDerivedFrom(this))
			{
				return true;
			}
			return false;
		}

		internal virtual XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return null;
		}

		internal override object ParseValue(string s, Type typDest, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr)
		{
			return ValueConverter.ChangeType(ParseValue(s, nameTable, nsmgr), typDest, nsmgr);
		}

		public override object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr)
		{
			object typedValue;
			Exception ex = TryParseValue(s, nameTable, nsmgr, out typedValue);
			if (ex != null)
			{
				throw new XmlSchemaException("Sch_InvalidValueDetailed", new string[3]
				{
					s,
					GetTypeName(),
					ex.Message
				}, ex, null, 0, 0, null);
			}
			if (Variety == XmlSchemaDatatypeVariety.Union)
			{
				XsdSimpleValue xsdSimpleValue = typedValue as XsdSimpleValue;
				return xsdSimpleValue.TypedValue;
			}
			return typedValue;
		}

		internal override object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, bool createAtomicValue)
		{
			if (createAtomicValue)
			{
				object typedValue;
				Exception ex = TryParseValue(s, nameTable, nsmgr, out typedValue);
				if (ex != null)
				{
					throw new XmlSchemaException("Sch_InvalidValueDetailed", new string[3]
					{
						s,
						GetTypeName(),
						ex.Message
					}, ex, null, 0, 0, null);
				}
				return typedValue;
			}
			return ParseValue(s, nameTable, nsmgr);
		}

		internal override Exception TryParseValue(object value, XmlNameTable nameTable, IXmlNamespaceResolver namespaceResolver, out object typedValue)
		{
			Exception ex = null;
			typedValue = null;
			if (value == null)
			{
				return new ArgumentNullException("value");
			}
			if (value is string s)
			{
				return TryParseValue(s, nameTable, namespaceResolver, out typedValue);
			}
			try
			{
				object obj = value;
				if (value.GetType() != ValueType)
				{
					obj = ValueConverter.ChangeType(value, ValueType, namespaceResolver);
				}
				if (HasLexicalFacets)
				{
					string parseString = (string)ValueConverter.ChangeType(value, typeof(string), namespaceResolver);
					ex = FacetsChecker.CheckLexicalFacets(ref parseString, this);
					if (ex != null)
					{
						return ex;
					}
				}
				if (HasValueFacets)
				{
					ex = FacetsChecker.CheckValueFacets(obj, this);
					if (ex != null)
					{
						return ex;
					}
				}
				typedValue = obj;
				return null;
			}
			catch (FormatException result)
			{
				return result;
			}
			catch (InvalidCastException result2)
			{
				return result2;
			}
			catch (OverflowException result3)
			{
				return result3;
			}
			catch (ArgumentException result4)
			{
				return result4;
			}
		}

		internal string GetTypeName()
		{
			XmlSchemaType xmlSchemaType = parentSchemaType;
			if (xmlSchemaType == null || xmlSchemaType.QualifiedName.IsEmpty)
			{
				return base.TypeCodeString;
			}
			return xmlSchemaType.QualifiedName.ToString();
		}

		protected int Compare(byte[] value1, byte[] value2)
		{
			int num = value1.Length;
			if (num != value2.Length)
			{
				return -1;
			}
			for (int i = 0; i < num; i++)
			{
				if (value1[i] != value2[i])
				{
					return -1;
				}
			}
			return 0;
		}
	}
	internal class Datatype_anySimpleType : DatatypeImplementation
	{
		private static readonly Type atomicValueType = typeof(string);

		private static readonly Type listValueType = typeof(string[]);

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.miscFacetsChecker;

		public override Type ValueType => atomicValueType;

		public override XmlTypeCode TypeCode => XmlTypeCode.AnyAtomicType;

		internal override Type ListValueType => listValueType;

		public override XmlTokenizedType TokenizedType => XmlTokenizedType.None;

		internal override RestrictionFlags ValidRestrictionFlags => (RestrictionFlags)0;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlUntypedConverter.Untyped;
		}

		internal override int Compare(object value1, object value2)
		{
			return string.Compare(value1.ToString(), value2.ToString(), StringComparison.Ordinal);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = XmlComplianceUtil.NonCDataNormalize(s);
			return null;
		}
	}
	internal class Datatype_List : Datatype_anySimpleType
	{
		private DatatypeImplementation itemType;

		private int minListSize;

		public override Type ValueType => ListValueType;

		public override XmlTokenizedType TokenizedType => itemType.TokenizedType;

		internal override Type ListValueType => itemType.ListValueType;

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.listFacetsChecker;

		public override XmlTypeCode TypeCode => itemType.TypeCode;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Length | RestrictionFlags.MinLength | RestrictionFlags.MaxLength | RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace;

		internal DatatypeImplementation ItemType => itemType;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			XmlSchemaType xmlSchemaType = null;
			XmlSchemaComplexType xmlSchemaComplexType = schemaType as XmlSchemaComplexType;
			XmlSchemaSimpleType xmlSchemaSimpleType;
			if (xmlSchemaComplexType != null)
			{
				do
				{
					xmlSchemaSimpleType = xmlSchemaComplexType.BaseXmlSchemaType as XmlSchemaSimpleType;
					if (xmlSchemaSimpleType != null)
					{
						break;
					}
					xmlSchemaComplexType = xmlSchemaComplexType.BaseXmlSchemaType as XmlSchemaComplexType;
				}
				while (xmlSchemaComplexType != null && xmlSchemaComplexType != XmlSchemaComplexType.AnyType);
			}
			else
			{
				xmlSchemaSimpleType = schemaType as XmlSchemaSimpleType;
			}
			if (xmlSchemaSimpleType != null)
			{
				do
				{
					if (xmlSchemaSimpleType.Content is XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList)
					{
						xmlSchemaType = xmlSchemaSimpleTypeList.BaseItemType;
						break;
					}
					xmlSchemaSimpleType = xmlSchemaSimpleType.BaseXmlSchemaType as XmlSchemaSimpleType;
				}
				while (xmlSchemaSimpleType != null && xmlSchemaSimpleType != DatatypeImplementation.AnySimpleType);
			}
			if (xmlSchemaType == null)
			{
				xmlSchemaType = DatatypeImplementation.GetSimpleTypeFromTypeCode(schemaType.Datatype.TypeCode);
			}
			return XmlListConverter.Create(xmlSchemaType.ValueConverter);
		}

		internal Datatype_List(DatatypeImplementation type)
			: this(type, 0)
		{
		}

		internal Datatype_List(DatatypeImplementation type, int minListSize)
		{
			itemType = type;
			this.minListSize = minListSize;
		}

		internal override int Compare(object value1, object value2)
		{
			Array array = (Array)value1;
			Array array2 = (Array)value2;
			int length = array.Length;
			if (length != array2.Length)
			{
				return -1;
			}
			if (array is XmlAtomicValue[] array3)
			{
				XmlAtomicValue[] array4 = array2 as XmlAtomicValue[];
				for (int i = 0; i < array3.Length; i++)
				{
					XmlSchemaType xmlType = array3[i].XmlType;
					if (xmlType != array4[i].XmlType || !xmlType.Datatype.IsEqual(array3[i].TypedValue, array4[i].TypedValue))
					{
						return -1;
					}
				}
				return 0;
			}
			for (int j = 0; j < array.Length; j++)
			{
				if (itemType.Compare(array.GetValue(j), array2.GetValue(j)) != 0)
				{
					return -1;
				}
			}
			return 0;
		}

		internal override Exception TryParseValue(object value, XmlNameTable nameTable, IXmlNamespaceResolver namespaceResolver, out object typedValue)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			string text = value as string;
			typedValue = null;
			if (text != null)
			{
				return TryParseValue(text, nameTable, namespaceResolver, out typedValue);
			}
			try
			{
				object obj = ValueConverter.ChangeType(value, ValueType, namespaceResolver);
				Array array = obj as Array;
				bool hasLexicalFacets = itemType.HasLexicalFacets;
				bool hasValueFacets = itemType.HasValueFacets;
				FacetsChecker facetsChecker = itemType.FacetsChecker;
				XmlValueConverter xmlValueConverter = itemType.ValueConverter;
				int num = 0;
				Exception ex;
				while (true)
				{
					if (num < array.Length)
					{
						object value2 = array.GetValue(num);
						if (hasLexicalFacets)
						{
							string parseString = (string)xmlValueConverter.ChangeType(value2, typeof(string), namespaceResolver);
							ex = facetsChecker.CheckLexicalFacets(ref parseString, itemType);
							if (ex != null)
							{
								return ex;
							}
						}
						if (hasValueFacets)
						{
							ex = facetsChecker.CheckValueFacets(value2, itemType);
							if (ex != null)
							{
								break;
							}
						}
						num++;
						continue;
					}
					if (HasLexicalFacets)
					{
						string parseString2 = (string)ValueConverter.ChangeType(obj, typeof(string), namespaceResolver);
						ex = DatatypeImplementation.listFacetsChecker.CheckLexicalFacets(ref parseString2, this);
						if (ex != null)
						{
							return ex;
						}
					}
					if (HasValueFacets)
					{
						ex = DatatypeImplementation.listFacetsChecker.CheckValueFacets(obj, this);
						if (ex != null)
						{
							return ex;
						}
					}
					typedValue = obj;
					return null;
				}
				return ex;
			}
			catch (FormatException result)
			{
				return result;
			}
			catch (InvalidCastException result2)
			{
				return result2;
			}
			catch (OverflowException result3)
			{
				return result3;
			}
			catch (ArgumentException result4)
			{
				return result4;
			}
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = DatatypeImplementation.listFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ArrayList arrayList = new ArrayList();
				object obj;
				if (itemType.Variety == XmlSchemaDatatypeVariety.Union)
				{
					string[] array = XmlConvert.SplitString(s);
					foreach (string s2 in array)
					{
						ex = itemType.TryParseValue(s2, nameTable, nsmgr, out var typedValue2);
						if (ex != null)
						{
							goto IL_0127;
						}
						XsdSimpleValue xsdSimpleValue = (XsdSimpleValue)typedValue2;
						arrayList.Add(new XmlAtomicValue(xsdSimpleValue.XmlType, xsdSimpleValue.TypedValue, nsmgr));
					}
					obj = arrayList.ToArray(typeof(XmlAtomicValue));
				}
				else
				{
					string[] array2 = XmlConvert.SplitString(s);
					foreach (string s3 in array2)
					{
						ex = itemType.TryParseValue(s3, nameTable, nsmgr, out typedValue);
						if (ex != null)
						{
							goto IL_0127;
						}
						arrayList.Add(typedValue);
					}
					obj = arrayList.ToArray(itemType.ValueType);
				}
				if (arrayList.Count < minListSize)
				{
					return new XmlSchemaException("Sch_EmptyAttributeValue", string.Empty);
				}
				ex = DatatypeImplementation.listFacetsChecker.CheckValueFacets(obj, this);
				if (ex == null)
				{
					typedValue = obj;
					return null;
				}
			}
			goto IL_0127;
			IL_0127:
			return ex;
		}
	}
	internal class Datatype_union : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(object);

		private static readonly Type listValueType = typeof(object[]);

		private XmlSchemaSimpleType[] types;

		public override Type ValueType => atomicValueType;

		public override XmlTypeCode TypeCode => XmlTypeCode.AnyAtomicType;

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.unionFacetsChecker;

		internal override Type ListValueType => listValueType;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Pattern | RestrictionFlags.Enumeration;

		internal XmlSchemaSimpleType[] BaseMemberTypes => types;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlUnionConverter.Create(schemaType);
		}

		internal Datatype_union(XmlSchemaSimpleType[] types)
		{
			this.types = types;
		}

		internal override int Compare(object value1, object value2)
		{
			XsdSimpleValue xsdSimpleValue = value1 as XsdSimpleValue;
			XsdSimpleValue xsdSimpleValue2 = value2 as XsdSimpleValue;
			if (xsdSimpleValue == null || xsdSimpleValue2 == null)
			{
				return -1;
			}
			XmlSchemaType xmlType = xsdSimpleValue.XmlType;
			XmlSchemaType xmlType2 = xsdSimpleValue2.XmlType;
			if (xmlType == xmlType2)
			{
				XmlSchemaDatatype datatype = xmlType.Datatype;
				return datatype.Compare(xsdSimpleValue.TypedValue, xsdSimpleValue2.TypedValue);
			}
			return -1;
		}

		internal bool HasAtomicMembers()
		{
			XmlSchemaSimpleType[] array = types;
			foreach (XmlSchemaSimpleType xmlSchemaSimpleType in array)
			{
				if (xmlSchemaSimpleType.Datatype.Variety == XmlSchemaDatatypeVariety.List)
				{
					return false;
				}
			}
			return true;
		}

		internal bool IsUnionBaseOf(DatatypeImplementation derivedType)
		{
			XmlSchemaSimpleType[] array = types;
			foreach (XmlSchemaSimpleType xmlSchemaSimpleType in array)
			{
				if (derivedType.IsDerivedFrom(xmlSchemaSimpleType.Datatype))
				{
					return true;
				}
			}
			return false;
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			XmlSchemaSimpleType xmlSchemaSimpleType = null;
			typedValue = null;
			Exception ex = DatatypeImplementation.unionFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				XmlSchemaSimpleType[] array = types;
				foreach (XmlSchemaSimpleType xmlSchemaSimpleType2 in array)
				{
					ex = xmlSchemaSimpleType2.Datatype.TryParseValue(s, nameTable, nsmgr, out typedValue);
					if (ex == null)
					{
						xmlSchemaSimpleType = xmlSchemaSimpleType2;
						break;
					}
				}
				if (xmlSchemaSimpleType == null)
				{
					ex = new XmlSchemaException("Sch_UnionFailedEx", s);
				}
				else
				{
					typedValue = new XsdSimpleValue(xmlSchemaSimpleType, typedValue);
					ex = DatatypeImplementation.unionFacetsChecker.CheckValueFacets(typedValue, this);
					if (ex == null)
					{
						return null;
					}
				}
			}
			return ex;
		}

		internal override Exception TryParseValue(object value, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			typedValue = null;
			if (value is string s)
			{
				return TryParseValue(s, nameTable, nsmgr, out typedValue);
			}
			object typedValue2 = null;
			XmlSchemaSimpleType st = null;
			XmlSchemaSimpleType[] array = types;
			foreach (XmlSchemaSimpleType xmlSchemaSimpleType in array)
			{
				if (xmlSchemaSimpleType.Datatype.TryParseValue(value, nameTable, nsmgr, out typedValue2) == null)
				{
					st = xmlSchemaSimpleType;
					break;
				}
			}
			if (typedValue2 == null)
			{
				return new XmlSchemaException("Sch_UnionFailedEx", value.ToString());
			}
			try
			{
				if (HasLexicalFacets)
				{
					string parseString = (string)ValueConverter.ChangeType(typedValue2, typeof(string), nsmgr);
					Exception ex = DatatypeImplementation.unionFacetsChecker.CheckLexicalFacets(ref parseString, this);
					if (ex != null)
					{
						return ex;
					}
				}
				typedValue = new XsdSimpleValue(st, typedValue2);
				if (HasValueFacets)
				{
					Exception ex = DatatypeImplementation.unionFacetsChecker.CheckValueFacets(typedValue, this);
					if (ex != null)
					{
						return ex;
					}
				}
				return null;
			}
			catch (FormatException result)
			{
				return result;
			}
			catch (InvalidCastException result2)
			{
				return result2;
			}
			catch (OverflowException result3)
			{
				return result3;
			}
			catch (ArgumentException result4)
			{
				return result4;
			}
		}
	}
	internal class Datatype_anyAtomicType : Datatype_anySimpleType
	{
		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Preserve;

		public override XmlTypeCode TypeCode => XmlTypeCode.AnyAtomicType;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlAnyConverter.AnyAtomic;
		}
	}
	internal class Datatype_untypedAtomicType : Datatype_anyAtomicType
	{
		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Preserve;

		public override XmlTypeCode TypeCode => XmlTypeCode.UntypedAtomic;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlUntypedConverter.Untyped;
		}
	}
	internal class Datatype_string : Datatype_anySimpleType
	{
		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Preserve;

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.stringFacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.String;

		public override XmlTokenizedType TokenizedType => XmlTokenizedType.CDATA;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Length | RestrictionFlags.MinLength | RestrictionFlags.MaxLength | RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlStringConverter.Create(schemaType);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = DatatypeImplementation.stringFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = DatatypeImplementation.stringFacetsChecker.CheckValueFacets(s, this);
				if (ex == null)
				{
					typedValue = s;
					return null;
				}
			}
			return ex;
		}
	}
	internal class Datatype_boolean : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(bool);

		private static readonly Type listValueType = typeof(bool[]);

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.miscFacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.Boolean;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Pattern | RestrictionFlags.WhiteSpace;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlBooleanConverter.Create(schemaType);
		}

		internal override int Compare(object value1, object value2)
		{
			return ((bool)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = DatatypeImplementation.miscFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToBoolean(s, out var result);
				if (ex == null)
				{
					typedValue = result;
					return null;
				}
			}
			return ex;
		}
	}
	internal class Datatype_float : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(float);

		private static readonly Type listValueType = typeof(float[]);

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.numeric2FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.Float;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace | RestrictionFlags.MaxInclusive | RestrictionFlags.MaxExclusive | RestrictionFlags.MinInclusive | RestrictionFlags.MinExclusive;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlNumeric2Converter.Create(schemaType);
		}

		internal override int Compare(object value1, object value2)
		{
			return ((float)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = DatatypeImplementation.numeric2FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToSingle(s, out var result);
				if (ex == null)
				{
					ex = DatatypeImplementation.numeric2FacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_double : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(double);

		private static readonly Type listValueType = typeof(double[]);

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.numeric2FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.Double;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace | RestrictionFlags.MaxInclusive | RestrictionFlags.MaxExclusive | RestrictionFlags.MinInclusive | RestrictionFlags.MinExclusive;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlNumeric2Converter.Create(schemaType);
		}

		internal override int Compare(object value1, object value2)
		{
			return ((double)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = DatatypeImplementation.numeric2FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToDouble(s, out var result);
				if (ex == null)
				{
					ex = DatatypeImplementation.numeric2FacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_decimal : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(decimal);

		private static readonly Type listValueType = typeof(decimal[]);

		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(decimal.MinValue, decimal.MaxValue);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.Decimal;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace | RestrictionFlags.MaxInclusive | RestrictionFlags.MaxExclusive | RestrictionFlags.MinInclusive | RestrictionFlags.MinExclusive | RestrictionFlags.TotalDigits | RestrictionFlags.FractionDigits;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlNumeric10Converter.Create(schemaType);
		}

		internal override int Compare(object value1, object value2)
		{
			return ((decimal)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = numeric10FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToDecimal(s, out var result);
				if (ex == null)
				{
					ex = numeric10FacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_duration : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(TimeSpan);

		private static readonly Type listValueType = typeof(TimeSpan[]);

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.durationFacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.Duration;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace | RestrictionFlags.MaxInclusive | RestrictionFlags.MaxExclusive | RestrictionFlags.MinInclusive | RestrictionFlags.MinExclusive;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlMiscConverter.Create(schemaType);
		}

		internal override int Compare(object value1, object value2)
		{
			return ((TimeSpan)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			if (s == null || s.Length == 0)
			{
				return new XmlSchemaException("Sch_EmptyAttributeValue", string.Empty);
			}
			Exception ex = DatatypeImplementation.durationFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToTimeSpan(s, out var result);
				if (ex == null)
				{
					ex = DatatypeImplementation.durationFacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_yearMonthDuration : Datatype_duration
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.YearMonthDuration;

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			if (s == null || s.Length == 0)
			{
				return new XmlSchemaException("Sch_EmptyAttributeValue", string.Empty);
			}
			Exception ex = DatatypeImplementation.durationFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XsdDuration.TryParse(s, XsdDuration.DurationType.YearMonthDuration, out var result);
				if (ex == null)
				{
					ex = result.TryToTimeSpan(XsdDuration.DurationType.YearMonthDuration, out var result2);
					if (ex == null)
					{
						ex = DatatypeImplementation.durationFacetsChecker.CheckValueFacets(result2, this);
						if (ex == null)
						{
							typedValue = result2;
							return null;
						}
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_dayTimeDuration : Datatype_duration
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.DayTimeDuration;

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			if (s == null || s.Length == 0)
			{
				return new XmlSchemaException("Sch_EmptyAttributeValue", string.Empty);
			}
			Exception ex = DatatypeImplementation.durationFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XsdDuration.TryParse(s, XsdDuration.DurationType.DayTimeDuration, out var result);
				if (ex == null)
				{
					ex = result.TryToTimeSpan(XsdDuration.DurationType.DayTimeDuration, out var result2);
					if (ex == null)
					{
						ex = DatatypeImplementation.durationFacetsChecker.CheckValueFacets(result2, this);
						if (ex == null)
						{
							typedValue = result2;
							return null;
						}
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_dateTimeBase : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(DateTime);

		private static readonly Type listValueType = typeof(DateTime[]);

		private XsdDateTimeFlags dateTimeFlags;

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.dateTimeFacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.DateTime;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace | RestrictionFlags.MaxInclusive | RestrictionFlags.MaxExclusive | RestrictionFlags.MinInclusive | RestrictionFlags.MinExclusive;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlDateTimeConverter.Create(schemaType);
		}

		internal Datatype_dateTimeBase()
		{
		}

		internal Datatype_dateTimeBase(XsdDateTimeFlags dateTimeFlags)
		{
			this.dateTimeFlags = dateTimeFlags;
		}

		internal override int Compare(object value1, object value2)
		{
			DateTime dateTime = (DateTime)value1;
			DateTime value3 = (DateTime)value2;
			if (dateTime.Kind == DateTimeKind.Unspecified || value3.Kind == DateTimeKind.Unspecified)
			{
				return dateTime.CompareTo(value3);
			}
			return dateTime.ToUniversalTime().CompareTo(value3.ToUniversalTime());
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = DatatypeImplementation.dateTimeFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				if (!XsdDateTime.TryParse(s, dateTimeFlags, out var result))
				{
					ex = new FormatException(Res.GetString("XmlConvert_BadFormat", s, "XsdDateTime"));
				}
				else
				{
					DateTime minValue = DateTime.MinValue;
					try
					{
						minValue = result;
					}
					catch (ArgumentException result2)
					{
						return result2;
					}
					ex = DatatypeImplementation.dateTimeFacetsChecker.CheckValueFacets(minValue, this);
					if (ex == null)
					{
						typedValue = minValue;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_dateTimeNoTimeZone : Datatype_dateTimeBase
	{
		internal Datatype_dateTimeNoTimeZone()
			: base(XsdDateTimeFlags.XdrDateTimeNoTz)
		{
		}
	}
	internal class Datatype_dateTimeTimeZone : Datatype_dateTimeBase
	{
		internal Datatype_dateTimeTimeZone()
			: base(XsdDateTimeFlags.XdrDateTime)
		{
		}
	}
	internal class Datatype_dateTime : Datatype_dateTimeBase
	{
		internal Datatype_dateTime()
			: base(XsdDateTimeFlags.DateTime)
		{
		}
	}
	internal class Datatype_timeNoTimeZone : Datatype_dateTimeBase
	{
		internal Datatype_timeNoTimeZone()
			: base(XsdDateTimeFlags.XdrTimeNoTz)
		{
		}
	}
	internal class Datatype_timeTimeZone : Datatype_dateTimeBase
	{
		internal Datatype_timeTimeZone()
			: base(XsdDateTimeFlags.Time)
		{
		}
	}
	internal class Datatype_time : Datatype_dateTimeBase
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.Time;

		internal Datatype_time()
			: base(XsdDateTimeFlags.Time)
		{
		}
	}
	internal class Datatype_date : Datatype_dateTimeBase
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.Date;

		internal Datatype_date()
			: base(XsdDateTimeFlags.Date)
		{
		}
	}
	internal class Datatype_yearMonth : Datatype_dateTimeBase
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.GYearMonth;

		internal Datatype_yearMonth()
			: base(XsdDateTimeFlags.GYearMonth)
		{
		}
	}
	internal class Datatype_year : Datatype_dateTimeBase
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.GYear;

		internal Datatype_year()
			: base(XsdDateTimeFlags.GYear)
		{
		}
	}
	internal class Datatype_monthDay : Datatype_dateTimeBase
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.GMonthDay;

		internal Datatype_monthDay()
			: base(XsdDateTimeFlags.GMonthDay)
		{
		}
	}
	internal class Datatype_day : Datatype_dateTimeBase
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.GDay;

		internal Datatype_day()
			: base(XsdDateTimeFlags.GDay)
		{
		}
	}
	internal class Datatype_month : Datatype_dateTimeBase
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.GMonth;

		internal Datatype_month()
			: base(XsdDateTimeFlags.GMonth)
		{
		}
	}
	internal class Datatype_hexBinary : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(byte[]);

		private static readonly Type listValueType = typeof(byte[][]);

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.binaryFacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.HexBinary;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Length | RestrictionFlags.MinLength | RestrictionFlags.MaxLength | RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlMiscConverter.Create(schemaType);
		}

		internal override int Compare(object value1, object value2)
		{
			return Compare((byte[])value1, (byte[])value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = DatatypeImplementation.binaryFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				byte[] array = null;
				try
				{
					array = XmlConvert.FromBinHexString(s, allowOddCount: false);
				}
				catch (ArgumentException result)
				{
					return result;
				}
				catch (XmlException result2)
				{
					return result2;
				}
				ex = DatatypeImplementation.binaryFacetsChecker.CheckValueFacets(array, this);
				if (ex == null)
				{
					typedValue = array;
					return null;
				}
			}
			return ex;
		}
	}
	internal class Datatype_base64Binary : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(byte[]);

		private static readonly Type listValueType = typeof(byte[][]);

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.binaryFacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.Base64Binary;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Length | RestrictionFlags.MinLength | RestrictionFlags.MaxLength | RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlMiscConverter.Create(schemaType);
		}

		internal override int Compare(object value1, object value2)
		{
			return Compare((byte[])value1, (byte[])value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = DatatypeImplementation.binaryFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				byte[] array = null;
				try
				{
					array = Convert.FromBase64String(s);
				}
				catch (ArgumentException result)
				{
					return result;
				}
				catch (FormatException result2)
				{
					return result2;
				}
				ex = DatatypeImplementation.binaryFacetsChecker.CheckValueFacets(array, this);
				if (ex == null)
				{
					typedValue = array;
					return null;
				}
			}
			return ex;
		}
	}
	internal class Datatype_anyURI : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(Uri);

		private static readonly Type listValueType = typeof(Uri[]);

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.stringFacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.AnyUri;

		public override Type ValueType => atomicValueType;

		internal override bool HasValueFacets => true;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Length | RestrictionFlags.MinLength | RestrictionFlags.MaxLength | RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlMiscConverter.Create(schemaType);
		}

		internal override int Compare(object value1, object value2)
		{
			if (!((Uri)value1).Equals((Uri)value2))
			{
				return -1;
			}
			return 0;
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = DatatypeImplementation.stringFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToUri(s, out var result);
				if (ex == null)
				{
					string originalString = result.OriginalString;
					ex = ((StringFacetsChecker)DatatypeImplementation.stringFacetsChecker).CheckValueFacets(originalString, this, verifyUri: false);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_QName : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(XmlQualifiedName);

		private static readonly Type listValueType = typeof(XmlQualifiedName[]);

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.qnameFacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.QName;

		public override XmlTokenizedType TokenizedType => XmlTokenizedType.QName;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Length | RestrictionFlags.MinLength | RestrictionFlags.MaxLength | RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlMiscConverter.Create(schemaType);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			if (s == null || s.Length == 0)
			{
				return new XmlSchemaException("Sch_EmptyAttributeValue", string.Empty);
			}
			Exception ex = DatatypeImplementation.qnameFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				XmlQualifiedName xmlQualifiedName = null;
				try
				{
					xmlQualifiedName = XmlQualifiedName.Parse(s, nsmgr, out var _);
				}
				catch (ArgumentException result)
				{
					return result;
				}
				catch (XmlException result2)
				{
					return result2;
				}
				ex = DatatypeImplementation.qnameFacetsChecker.CheckValueFacets(xmlQualifiedName, this);
				if (ex == null)
				{
					typedValue = xmlQualifiedName;
					return null;
				}
			}
			return ex;
		}
	}
	internal class Datatype_normalizedString : Datatype_string
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.NormalizedString;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Replace;

		internal override bool HasValueFacets => true;
	}
	internal class Datatype_normalizedStringV1Compat : Datatype_string
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.NormalizedString;

		internal override bool HasValueFacets => true;
	}
	internal class Datatype_token : Datatype_normalizedString
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.Token;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;
	}
	internal class Datatype_tokenV1Compat : Datatype_normalizedStringV1Compat
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.Token;
	}
	internal class Datatype_language : Datatype_token
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.Language;
	}
	internal class Datatype_NMTOKEN : Datatype_token
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.NmToken;

		public override XmlTokenizedType TokenizedType => XmlTokenizedType.NMTOKEN;
	}
	internal class Datatype_Name : Datatype_token
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.Name;
	}
	internal class Datatype_NCName : Datatype_Name
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.NCName;

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = DatatypeImplementation.stringFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = DatatypeImplementation.stringFacetsChecker.CheckValueFacets(s, this);
				if (ex == null)
				{
					nameTable.Add(s);
					typedValue = s;
					return null;
				}
			}
			return ex;
		}
	}
	internal class Datatype_ID : Datatype_NCName
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.Id;

		public override XmlTokenizedType TokenizedType => XmlTokenizedType.ID;
	}
	internal class Datatype_IDREF : Datatype_NCName
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.Idref;

		public override XmlTokenizedType TokenizedType => XmlTokenizedType.IDREF;
	}
	internal class Datatype_ENTITY : Datatype_NCName
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.Entity;

		public override XmlTokenizedType TokenizedType => XmlTokenizedType.ENTITY;
	}
	internal class Datatype_NOTATION : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(XmlQualifiedName);

		private static readonly Type listValueType = typeof(XmlQualifiedName[]);

		internal override FacetsChecker FacetsChecker => DatatypeImplementation.qnameFacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.Notation;

		public override XmlTokenizedType TokenizedType => XmlTokenizedType.NOTATION;

		internal override RestrictionFlags ValidRestrictionFlags => RestrictionFlags.Length | RestrictionFlags.MinLength | RestrictionFlags.MaxLength | RestrictionFlags.Pattern | RestrictionFlags.Enumeration | RestrictionFlags.WhiteSpace;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override XmlSchemaWhiteSpace BuiltInWhitespaceFacet => XmlSchemaWhiteSpace.Collapse;

		internal override XmlValueConverter CreateValueConverter(XmlSchemaType schemaType)
		{
			return XmlMiscConverter.Create(schemaType);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			if (s == null || s.Length == 0)
			{
				return new XmlSchemaException("Sch_EmptyAttributeValue", string.Empty);
			}
			Exception ex = DatatypeImplementation.qnameFacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				XmlQualifiedName xmlQualifiedName = null;
				try
				{
					xmlQualifiedName = XmlQualifiedName.Parse(s, nsmgr, out var _);
				}
				catch (ArgumentException result)
				{
					return result;
				}
				catch (XmlException result2)
				{
					return result2;
				}
				ex = DatatypeImplementation.qnameFacetsChecker.CheckValueFacets(xmlQualifiedName, this);
				if (ex == null)
				{
					typedValue = xmlQualifiedName;
					return null;
				}
			}
			return ex;
		}

		internal override void VerifySchemaValid(XmlSchemaObjectTable notations, XmlSchemaObject caller)
		{
			for (Datatype_NOTATION datatype_NOTATION = this; datatype_NOTATION != null; datatype_NOTATION = (Datatype_NOTATION)datatype_NOTATION.Base)
			{
				if (datatype_NOTATION.Restriction != null && (datatype_NOTATION.Restriction.Flags & RestrictionFlags.Enumeration) != 0)
				{
					foreach (XmlQualifiedName item in datatype_NOTATION.Restriction.Enumeration)
					{
						if (!notations.Contains(item))
						{
							throw new XmlSchemaException("Sch_NotationRequired", caller);
						}
					}
					return;
				}
			}
			throw new XmlSchemaException("Sch_NotationRequired", caller);
		}
	}
	internal class Datatype_integer : Datatype_decimal
	{
		public override XmlTypeCode TypeCode => XmlTypeCode.Integer;

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToInteger(s, out var result);
				if (ex == null)
				{
					ex = FacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_nonPositiveInteger : Datatype_integer
	{
		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(decimal.MinValue, 0m);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.NonPositiveInteger;

		internal override bool HasValueFacets => true;
	}
	internal class Datatype_negativeInteger : Datatype_nonPositiveInteger
	{
		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(decimal.MinValue, -1m);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.NegativeInteger;
	}
	internal class Datatype_long : Datatype_integer
	{
		private static readonly Type atomicValueType = typeof(long);

		private static readonly Type listValueType = typeof(long[]);

		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(new decimal(long.MinValue), new decimal(long.MaxValue));

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		internal override bool HasValueFacets => true;

		public override XmlTypeCode TypeCode => XmlTypeCode.Long;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override int Compare(object value1, object value2)
		{
			return ((long)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = numeric10FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToInt64(s, out var result);
				if (ex == null)
				{
					ex = numeric10FacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_int : Datatype_long
	{
		private static readonly Type atomicValueType = typeof(int);

		private static readonly Type listValueType = typeof(int[]);

		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(-2147483648m, 2147483647m);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.Int;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override int Compare(object value1, object value2)
		{
			return ((int)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = numeric10FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToInt32(s, out var result);
				if (ex == null)
				{
					ex = numeric10FacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_short : Datatype_int
	{
		private static readonly Type atomicValueType = typeof(short);

		private static readonly Type listValueType = typeof(short[]);

		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(-32768m, 32767m);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.Short;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override int Compare(object value1, object value2)
		{
			return ((short)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = numeric10FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToInt16(s, out var result);
				if (ex == null)
				{
					ex = numeric10FacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_byte : Datatype_short
	{
		private static readonly Type atomicValueType = typeof(sbyte);

		private static readonly Type listValueType = typeof(sbyte[]);

		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(-128m, 127m);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.Byte;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override int Compare(object value1, object value2)
		{
			return ((sbyte)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = numeric10FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToSByte(s, out var result);
				if (ex == null)
				{
					ex = numeric10FacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_nonNegativeInteger : Datatype_integer
	{
		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(0m, decimal.MaxValue);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.NonNegativeInteger;

		internal override bool HasValueFacets => true;
	}
	internal class Datatype_unsignedLong : Datatype_nonNegativeInteger
	{
		private static readonly Type atomicValueType = typeof(ulong);

		private static readonly Type listValueType = typeof(ulong[]);

		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(0m, 18446744073709551615m);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.UnsignedLong;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override int Compare(object value1, object value2)
		{
			return ((ulong)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = numeric10FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToUInt64(s, out var result);
				if (ex == null)
				{
					ex = numeric10FacetsChecker.CheckValueFacets((decimal)result, (XmlSchemaDatatype)this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_unsignedInt : Datatype_unsignedLong
	{
		private static readonly Type atomicValueType = typeof(uint);

		private static readonly Type listValueType = typeof(uint[]);

		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(0m, new decimal(4294967295L));

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.UnsignedInt;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override int Compare(object value1, object value2)
		{
			return ((uint)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = numeric10FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToUInt32(s, out var result);
				if (ex == null)
				{
					ex = numeric10FacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_unsignedShort : Datatype_unsignedInt
	{
		private static readonly Type atomicValueType = typeof(ushort);

		private static readonly Type listValueType = typeof(ushort[]);

		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(0m, 65535m);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.UnsignedShort;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override int Compare(object value1, object value2)
		{
			return ((ushort)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = numeric10FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToUInt16(s, out var result);
				if (ex == null)
				{
					ex = numeric10FacetsChecker.CheckValueFacets(result, this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_unsignedByte : Datatype_unsignedShort
	{
		private static readonly Type atomicValueType = typeof(byte);

		private static readonly Type listValueType = typeof(byte[]);

		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(0m, 255m);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.UnsignedByte;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override int Compare(object value1, object value2)
		{
			return ((byte)value1).CompareTo(value2);
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Exception ex = numeric10FacetsChecker.CheckLexicalFacets(ref s, this);
			if (ex == null)
			{
				ex = XmlConvert.TryToByte(s, out var result);
				if (ex == null)
				{
					ex = numeric10FacetsChecker.CheckValueFacets((short)result, (XmlSchemaDatatype)this);
					if (ex == null)
					{
						typedValue = result;
						return null;
					}
				}
			}
			return ex;
		}
	}
	internal class Datatype_positiveInteger : Datatype_nonNegativeInteger
	{
		private static readonly FacetsChecker numeric10FacetsChecker = new Numeric10FacetsChecker(1m, decimal.MaxValue);

		internal override FacetsChecker FacetsChecker => numeric10FacetsChecker;

		public override XmlTypeCode TypeCode => XmlTypeCode.PositiveInteger;
	}
	internal class Datatype_doubleXdr : Datatype_double
	{
		public override object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr)
		{
			double num;
			try
			{
				num = XmlConvert.ToDouble(s);
			}
			catch (Exception innerException)
			{
				throw new XmlSchemaException(Res.GetString("Sch_InvalidValue", s), innerException);
			}
			if (double.IsInfinity(num) || double.IsNaN(num))
			{
				throw new XmlSchemaException("Sch_InvalidValue", s);
			}
			return num;
		}
	}
	internal class Datatype_floatXdr : Datatype_float
	{
		public override object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr)
		{
			float num;
			try
			{
				num = XmlConvert.ToSingle(s);
			}
			catch (Exception innerException)
			{
				throw new XmlSchemaException(Res.GetString("Sch_InvalidValue", s), innerException);
			}
			if (float.IsInfinity(num) || float.IsNaN(num))
			{
				throw new XmlSchemaException("Sch_InvalidValue", s);
			}
			return num;
		}
	}
	internal class Datatype_QNameXdr : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(XmlQualifiedName);

		private static readonly Type listValueType = typeof(XmlQualifiedName[]);

		public override XmlTokenizedType TokenizedType => XmlTokenizedType.QName;

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		public override object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr)
		{
			if (s == null || s.Length == 0)
			{
				throw new XmlSchemaException("Sch_EmptyAttributeValue", string.Empty);
			}
			if (nsmgr == null)
			{
				throw new ArgumentNullException("nsmgr");
			}
			try
			{
				string prefix;
				return XmlQualifiedName.Parse(s.Trim(), nsmgr, out prefix);
			}
			catch (XmlSchemaException ex)
			{
				throw ex;
			}
			catch (Exception innerException)
			{
				throw new XmlSchemaException(Res.GetString("Sch_InvalidValue", s), innerException);
			}
		}
	}
	internal class Datatype_ENUMERATION : Datatype_NMTOKEN
	{
		public override XmlTokenizedType TokenizedType => XmlTokenizedType.ENUMERATION;
	}
	internal class Datatype_char : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(char);

		private static readonly Type listValueType = typeof(char[]);

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override RestrictionFlags ValidRestrictionFlags => (RestrictionFlags)0;

		internal override int Compare(object value1, object value2)
		{
			return ((char)value1).CompareTo(value2);
		}

		public override object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr)
		{
			try
			{
				return XmlConvert.ToChar(s);
			}
			catch (XmlSchemaException ex)
			{
				throw ex;
			}
			catch (Exception innerException)
			{
				throw new XmlSchemaException(Res.GetString("Sch_InvalidValue", s), innerException);
			}
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			char result;
			Exception ex = XmlConvert.TryToChar(s, out result);
			if (ex == null)
			{
				typedValue = result;
				return null;
			}
			return ex;
		}
	}
	internal class Datatype_fixed : Datatype_decimal
	{
		public override object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr)
		{
			Exception ex;
			try
			{
				Numeric10FacetsChecker numeric10FacetsChecker = FacetsChecker as Numeric10FacetsChecker;
				decimal num = XmlConvert.ToDecimal(s);
				ex = numeric10FacetsChecker.CheckTotalAndFractionDigits(num, 18, 4, checkTotal: true, checkFraction: true);
				if (ex == null)
				{
					return num;
				}
			}
			catch (XmlSchemaException ex2)
			{
				throw ex2;
			}
			catch (Exception innerException)
			{
				throw new XmlSchemaException(Res.GetString("Sch_InvalidValue", s), innerException);
			}
			throw ex;
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			decimal result;
			Exception ex = XmlConvert.TryToDecimal(s, out result);
			if (ex == null)
			{
				Numeric10FacetsChecker numeric10FacetsChecker = FacetsChecker as Numeric10FacetsChecker;
				ex = numeric10FacetsChecker.CheckTotalAndFractionDigits(result, 18, 4, checkTotal: true, checkFraction: true);
				if (ex == null)
				{
					typedValue = result;
					return null;
				}
			}
			return ex;
		}
	}
	internal class Datatype_uuid : Datatype_anySimpleType
	{
		private static readonly Type atomicValueType = typeof(Guid);

		private static readonly Type listValueType = typeof(Guid[]);

		public override Type ValueType => atomicValueType;

		internal override Type ListValueType => listValueType;

		internal override RestrictionFlags ValidRestrictionFlags => (RestrictionFlags)0;

		internal override int Compare(object value1, object value2)
		{
			if (!((Guid)value1).Equals(value2))
			{
				return -1;
			}
			return 0;
		}

		public override object ParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr)
		{
			try
			{
				return XmlConvert.ToGuid(s);
			}
			catch (XmlSchemaException ex)
			{
				throw ex;
			}
			catch (Exception innerException)
			{
				throw new XmlSchemaException(Res.GetString("Sch_InvalidValue", s), innerException);
			}
		}

		internal override Exception TryParseValue(string s, XmlNameTable nameTable, IXmlNamespaceResolver nsmgr, out object typedValue)
		{
			typedValue = null;
			Guid result;
			Exception ex = XmlConvert.TryToGuid(s, out result);
			if (ex == null)
			{
				typedValue = result;
				return null;
			}
			return ex;
		}
	}
}
namespace System.Xml
{
	internal class DtdParser
	{
		private enum Token
		{
			CDATA,
			ID,
			IDREF,
			IDREFS,
			ENTITY,
			ENTITIES,
			NMTOKEN,
			NMTOKENS,
			NOTATION,
			None,
			PERef,
			AttlistDecl,
			ElementDecl,
			EntityDecl,
			NotationDecl,
			Comment,
			PI,
			CondSectionStart,
			CondSectionEnd,
			Eof,
			REQUIRED,
			IMPLIED,
			FIXED,
			QName,
			Name,
			Nmtoken,
			Quote,
			LeftParen,
			RightParen,
			GreaterThan,
			Or,
			LeftBracket,
			RightBracket,
			PUBLIC,
			SYSTEM,
			Literal,
			DOCTYPE,
			NData,
			Percent,
			Star,
			QMark,
			Plus,
			PCDATA,
			Comma,
			ANY,
			EMPTY,
			IGNORE,
			INCLUDE
		}

		private enum ScanningFunction
		{
			SubsetContent,
			Name,
			QName,
			Nmtoken,
			Doctype1,
			Doctype2,
			Element1,
			Element2,
			Element3,
			Element4,
			Element5,
			Element6,
			Element7,
			Attlist1,
			Attlist2,
			Attlist3,
			Attlist4,
			Attlist5,
			Attlist6,
			Attlist7,
			Entity1,
			Entity2,
			Entity3,
			Notation1,
			CondSection1,
			CondSection2,
			CondSection3,
			Literal,
			SystemId,
			PublicId1,
			PublicId2,
			ClosingTag,
			ParamEntitySpace,
			None
		}

		private enum LiteralType
		{
			AttributeValue,
			EntityReplText,
			SystemOrPublicID
		}

		private class UndeclaredNotation
		{
			internal string name;

			internal int lineNo;

			internal int linePos;

			internal UndeclaredNotation next;

			internal UndeclaredNotation(string name, int lineNo, int linePos)
			{
				this.name = name;
				this.lineNo = lineNo;
				this.linePos = linePos;
				next = null;
			}
		}

		private class ParseElementOnlyContent_LocalFrame
		{
			public int startParenEntityId;

			public Token parsingSchema;

			public int connectorEntityId;

			public int contentEntityId;

			public ParseElementOnlyContent_LocalFrame(int startParentEntityIdParam)
			{
				startParenEntityId = startParentEntityIdParam;
				parsingSchema = Token.None;
				connectorEntityId = startParentEntityIdParam;
				contentEntityId = -1;
			}
		}

		private const int CondSectionEntityIdsInitialSize = 2;

		private IDtdParserAdapter readerAdapter;

		private XmlNameTable nameTable;

		private SchemaInfo schemaInfo;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		private string systemId = string.Empty;

		private string publicId = string.Empty;

		private bool validate;

		private bool normalize;

		private bool supportNamespaces;

		private bool v1Compat;

		private char[] chars;

		private int charsUsed;

		private int curPos;

		private ScanningFunction scanningFunction;

		private ScanningFunction nextScaningFunction;

		private ScanningFunction savedScanningFunction;

		private bool whitespaceSeen;

		private int tokenStartPos;

		private int colonPos;

		private BufferBuilder internalSubsetValueSb;

		private string internalSubsetValue = string.Empty;

		private int externalEntitiesDepth;

		private int currentEntityId;

		private int nextEntityId = 1;

		private int[] condSectionEntityIds;

		private bool freeFloatingDtd;

		private bool hasFreeFloatingInternalSubset;

		private BufferBuilder stringBuilder;

		private Hashtable undeclaredNotations;

		private int condSectionDepth;

		private LineInfo literalLineInfo = new LineInfo(0, 0);

		private char literalQuoteChar = '"';

		private string documentBaseUri = string.Empty;

		private string externalDtdBaseUri = string.Empty;

		internal string SystemID => systemId;

		internal string PublicID => publicId;

		internal string InternalSubset => internalSubsetValue;

		internal SchemaInfo SchemaInfo => schemaInfo;

		private bool ParsingInternalSubset => externalEntitiesDepth == 0;

		private bool IgnoreEntityReferences => scanningFunction == ScanningFunction.CondSection3;

		private bool SaveInternalSubsetValue
		{
			get
			{
				if (readerAdapter.EntityStackLength == 0)
				{
					return internalSubsetValueSb != null;
				}
				return false;
			}
		}

		private bool ParsingTopLevelMarkup
		{
			get
			{
				if (scanningFunction != 0)
				{
					if (scanningFunction == ScanningFunction.ParamEntitySpace)
					{
						return savedScanningFunction == ScanningFunction.SubsetContent;
					}
					return false;
				}
				return true;
			}
		}

		private int LineNo => readerAdapter.LineNo;

		private int LinePos => curPos - readerAdapter.LineStartPosition;

		private string BaseUriStr
		{
			get
			{
				Uri baseUri = readerAdapter.BaseUri;
				if (!(baseUri != null))
				{
					return string.Empty;
				}
				return baseUri.ToString();
			}
		}

		internal DtdParser(IDtdParserAdapter readerAdapter)
		{
			this.readerAdapter = readerAdapter;
			nameTable = readerAdapter.NameTable;
			validate = readerAdapter.DtdValidation;
			normalize = readerAdapter.Normalization;
			supportNamespaces = readerAdapter.Namespaces;
			v1Compat = readerAdapter.V1CompatibilityMode;
			schemaInfo = new SchemaInfo();
			schemaInfo.SchemaType = SchemaType.DTD;
			stringBuilder = new BufferBuilder();
			Uri baseUri = readerAdapter.BaseUri;
			if (baseUri != null)
			{
				documentBaseUri = baseUri.ToString();
			}
		}

		internal DtdParser(string baseUri, string docTypeName, string publicId, string systemId, string internalSubset, IDtdParserAdapter underlyingReader)
			: this(underlyingReader)
		{
			if (docTypeName == null || docTypeName.Length == 0)
			{
				throw XmlConvert.CreateInvalidNameArgumentException(docTypeName, "docTypeName");
			}
			XmlConvert.VerifyName(docTypeName);
			int num = docTypeName.IndexOf(':');
			if (num == -1)
			{
				schemaInfo.DocTypeName = new XmlQualifiedName(nameTable.Add(docTypeName));
			}
			else
			{
				schemaInfo.DocTypeName = new XmlQualifiedName(nameTable.Add(docTypeName.Substring(0, num)), nameTable.Add(docTypeName.Substring(num + 1)));
			}
			if (systemId != null && systemId.Length > 0)
			{
				int index;
				if ((index = xmlCharType.IsOnlyCharData(systemId)) >= 0)
				{
					ThrowInvalidChar(curPos, systemId[index]);
				}
				this.systemId = systemId;
			}
			if (publicId != null && publicId.Length > 0)
			{
				int index;
				if ((index = xmlCharType.IsPublicId(publicId)) >= 0)
				{
					ThrowInvalidChar(curPos, publicId[index]);
				}
				this.publicId = publicId;
			}
			if (internalSubset != null && internalSubset.Length > 0)
			{
				readerAdapter.PushInternalDtd(baseUri, internalSubset);
				hasFreeFloatingInternalSubset = true;
			}
			Uri baseUri2 = readerAdapter.BaseUri;
			if (baseUri2 != null)
			{
				documentBaseUri = baseUri2.ToString();
			}
			freeFloatingDtd = true;
		}

		internal static SchemaInfo Parse(XmlNameTable nt, XmlNamespaceManager nsManager, bool namespaces, string baseUri, string docTypeName, string publicId, string systemId, string internalSubset, bool useResolver, XmlResolver resolver)
		{
			XmlParserContext context = new XmlParserContext(nt, nsManager, null, null, null, null, baseUri, string.Empty, XmlSpace.None);
			XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl("", XmlNodeType.Element, context);
			xmlTextReaderImpl.Namespaces = namespaces;
			if (useResolver)
			{
				xmlTextReaderImpl.XmlResolver = resolver;
			}
			return Parse(xmlTextReaderImpl, baseUri, docTypeName, publicId, systemId, internalSubset);
		}

		internal static SchemaInfo Parse(XmlTextReaderImpl tr, string baseUri, string docTypeName, string publicId, string systemId, string internalSubset)
		{
			XmlTextReaderImpl.DtdParserProxy dtdParserProxy = new XmlTextReaderImpl.DtdParserProxy(baseUri, docTypeName, publicId, systemId, internalSubset, tr);
			dtdParserProxy.Parse(saveInternalSubset: false);
			return dtdParserProxy.DtdSchemaInfo;
		}

		internal void Parse(bool saveInternalSubset)
		{
			if (freeFloatingDtd)
			{
				ParseFreeFloatingDtd();
			}
			else
			{
				ParseInDocumentDtd(saveInternalSubset);
			}
			schemaInfo.Finish();
			if (!validate || undeclaredNotations == null)
			{
				return;
			}
			foreach (UndeclaredNotation value in undeclaredNotations.Values)
			{
				for (UndeclaredNotation undeclaredNotation2 = value; undeclaredNotation2 != null; undeclaredNotation2 = undeclaredNotation2.next)
				{
					SendValidationEvent(XmlSeverityType.Error, new XmlSchemaException("Sch_UndeclaredNotation", value.name, BaseUriStr, value.lineNo, value.linePos));
				}
			}
		}

		private void ParseInDocumentDtd(bool saveInternalSubset)
		{
			LoadParsingBuffer();
			scanningFunction = ScanningFunction.QName;
			nextScaningFunction = ScanningFunction.Doctype1;
			if (GetToken(needWhiteSpace: false) != Token.QName)
			{
				OnUnexpectedError();
			}
			schemaInfo.DocTypeName = GetNameQualified(canHavePrefix: true);
			Token token = GetToken(needWhiteSpace: false);
			if (token == Token.SYSTEM || token == Token.PUBLIC)
			{
				ParseExternalId(token, Token.DOCTYPE, out publicId, out systemId);
				token = GetToken(needWhiteSpace: false);
			}
			switch (token)
			{
			case Token.LeftBracket:
				if (saveInternalSubset)
				{
					SaveParsingBuffer();
					internalSubsetValueSb = new BufferBuilder();
				}
				ParseInternalSubset();
				break;
			default:
				OnUnexpectedError();
				break;
			case Token.GreaterThan:
				break;
			}
			SaveParsingBuffer();
			if (systemId != null && systemId.Length > 0)
			{
				ParseExternalSubset();
			}
		}

		private void ParseFreeFloatingDtd()
		{
			if (hasFreeFloatingInternalSubset)
			{
				LoadParsingBuffer();
				ParseInternalSubset();
				SaveParsingBuffer();
			}
			if (systemId != null && systemId.Length > 0)
			{
				ParseExternalSubset();
			}
		}

		private void ParseInternalSubset()
		{
			ParseSubset();
		}

		private void ParseExternalSubset()
		{
			if (readerAdapter.PushExternalSubset(systemId, publicId))
			{
				Uri baseUri = readerAdapter.BaseUri;
				if (baseUri != null)
				{
					externalDtdBaseUri = baseUri.ToString();
				}
				externalEntitiesDepth++;
				LoadParsingBuffer();
				ParseSubset();
			}
		}

		private void ParseSubset()
		{
			while (true)
			{
				Token token = GetToken(needWhiteSpace: false);
				int num = currentEntityId;
				switch (token)
				{
				case Token.AttlistDecl:
					ParseAttlistDecl();
					break;
				case Token.ElementDecl:
					ParseElementDecl();
					break;
				case Token.EntityDecl:
					ParseEntityDecl();
					break;
				case Token.NotationDecl:
					ParseNotationDecl();
					break;
				case Token.Comment:
					ParseComment();
					break;
				case Token.PI:
					ParsePI();
					break;
				case Token.CondSectionStart:
					if (ParsingInternalSubset)
					{
						Throw(curPos - 3, "Xml_InvalidConditionalSection");
					}
					ParseCondSection();
					num = currentEntityId;
					break;
				case Token.CondSectionEnd:
					if (condSectionDepth > 0)
					{
						condSectionDepth--;
						if (validate && currentEntityId != condSectionEntityIds[condSectionDepth])
						{
							SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
						}
					}
					else
					{
						Throw(curPos - 3, "Xml_UnexpectedCDataEnd");
					}
					break;
				case Token.RightBracket:
					if (ParsingInternalSubset)
					{
						if (condSectionDepth != 0)
						{
							Throw(curPos, "Xml_UnclosedConditionalSection");
						}
						if (internalSubsetValueSb != null)
						{
							SaveParsingBuffer(curPos - 1);
							internalSubsetValue = internalSubsetValueSb.ToString();
							internalSubsetValueSb = null;
						}
						if (GetToken(needWhiteSpace: false) != Token.GreaterThan)
						{
							ThrowUnexpectedToken(curPos, ">");
						}
					}
					else
					{
						Throw(curPos, "Xml_ExpectDtdMarkup");
					}
					return;
				case Token.Eof:
					if (ParsingInternalSubset && !freeFloatingDtd)
					{
						Throw(curPos, "Xml_IncompleteDtdContent");
					}
					if (condSectionDepth != 0)
					{
						Throw(curPos, "Xml_UnclosedConditionalSection");
					}
					return;
				}
				if (currentEntityId != num)
				{
					if (validate)
					{
						SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
					}
					else if (!v1Compat)
					{
						Throw(curPos, "Sch_ParEntityRefNesting");
					}
				}
			}
		}

		private void ParseAttlistDecl()
		{
			if (GetToken(needWhiteSpace: true) == Token.QName)
			{
				XmlQualifiedName nameQualified = GetNameQualified(canHavePrefix: true);
				SchemaElementDecl schemaElementDecl = (SchemaElementDecl)schemaInfo.ElementDecls[nameQualified];
				if (schemaElementDecl == null)
				{
					schemaElementDecl = (SchemaElementDecl)schemaInfo.UndeclaredElementDecls[nameQualified];
					if (schemaElementDecl == null)
					{
						schemaElementDecl = new SchemaElementDecl(nameQualified, nameQualified.Namespace, SchemaType.DTD);
						schemaInfo.UndeclaredElementDecls.Add(nameQualified, schemaElementDecl);
					}
				}
				SchemaAttDef schemaAttDef = null;
				while (true)
				{
					switch (GetToken(needWhiteSpace: false))
					{
					case Token.QName:
					{
						XmlQualifiedName nameQualified2 = GetNameQualified(canHavePrefix: true);
						schemaAttDef = new SchemaAttDef(nameQualified2, nameQualified2.Namespace);
						schemaAttDef.IsDeclaredInExternal = !ParsingInternalSubset;
						schemaAttDef.LineNum = LineNo;
						schemaAttDef.LinePos = LinePos - (curPos - tokenStartPos);
						ParseAttlistType(schemaAttDef, schemaElementDecl);
						ParseAttlistDefault(schemaAttDef);
						if (schemaAttDef.Prefix.Length > 0 && schemaAttDef.Prefix.Equals("xml"))
						{
							if (schemaAttDef.Name.Name == "space")
							{
								if (v1Compat)
								{
									string text = schemaAttDef.DefaultValueExpanded.Trim();
									if (text.Equals("preserve") || text.Equals("default"))
									{
										schemaAttDef.Reserved = SchemaAttDef.Reserve.XmlSpace;
									}
								}
								else
								{
									schemaAttDef.Reserved = SchemaAttDef.Reserve.XmlSpace;
									if (schemaAttDef.Datatype.TokenizedType != XmlTokenizedType.ENUMERATION)
									{
										Throw("Xml_EnumerationRequired", string.Empty, schemaAttDef.LineNum, schemaAttDef.LinePos);
									}
									if (readerAdapter.EventHandler != null)
									{
										schemaAttDef.CheckXmlSpace(readerAdapter.EventHandler);
									}
								}
							}
							else if (schemaAttDef.Name.Name == "lang")
							{
								schemaAttDef.Reserved = SchemaAttDef.Reserve.XmlLang;
							}
						}
						if (schemaElementDecl.GetAttDef(schemaAttDef.Name) == null)
						{
							schemaElementDecl.AddAttDef(schemaAttDef);
						}
						continue;
					}
					case Token.GreaterThan:
						if (v1Compat && schemaAttDef != null && schemaAttDef.Prefix.Length > 0 && schemaAttDef.Prefix.Equals("xml") && schemaAttDef.Name.Name == "space")
						{
							schemaAttDef.Reserved = SchemaAttDef.Reserve.XmlSpace;
							if (schemaAttDef.Datatype.TokenizedType != XmlTokenizedType.ENUMERATION)
							{
								Throw("Xml_EnumerationRequired", string.Empty, schemaAttDef.LineNum, schemaAttDef.LinePos);
							}
							if (readerAdapter.EventHandler != null)
							{
								schemaAttDef.CheckXmlSpace(readerAdapter.EventHandler);
							}
						}
						return;
					}
					break;
				}
			}
			OnUnexpectedError();
		}

		private void ParseAttlistType(SchemaAttDef attrDef, SchemaElementDecl elementDecl)
		{
			Token token = GetToken(needWhiteSpace: true);
			if (token != 0)
			{
				elementDecl.HasNonCDataAttribute = true;
			}
			if (IsAttributeValueType(token))
			{
				attrDef.Datatype = XmlSchemaDatatype.FromXmlTokenizedType((XmlTokenizedType)token);
				attrDef.SchemaType = XmlSchemaType.GetBuiltInSimpleType(attrDef.Datatype.TypeCode);
				switch (token)
				{
				default:
					return;
				case Token.ID:
					if (validate && elementDecl.IsIdDeclared)
					{
						SchemaAttDef attDef = elementDecl.GetAttDef(attrDef.Name);
						if (attDef == null || attDef.Datatype.TokenizedType != XmlTokenizedType.ID)
						{
							SendValidationEvent(XmlSeverityType.Error, "Sch_IdAttrDeclared", elementDecl.Name.ToString());
						}
					}
					elementDecl.IsIdDeclared = true;
					return;
				case Token.NOTATION:
					break;
				}
				if (validate)
				{
					if (elementDecl.IsNotationDeclared)
					{
						SendValidationEvent(curPos - 8, XmlSeverityType.Error, "Sch_DupNotationAttribute", elementDecl.Name.ToString());
					}
					else
					{
						if (elementDecl.ContentValidator != null && elementDecl.ContentValidator.ContentType == XmlSchemaContentType.Empty)
						{
							SendValidationEvent(curPos - 8, XmlSeverityType.Error, "Sch_NotationAttributeOnEmptyElement", elementDecl.Name.ToString());
						}
						elementDecl.IsNotationDeclared = true;
					}
				}
				if (GetToken(needWhiteSpace: true) == Token.LeftParen && GetToken(needWhiteSpace: false) == Token.Name)
				{
					do
					{
						string nameString = GetNameString();
						if (schemaInfo.Notations[nameString] == null)
						{
							if (undeclaredNotations == null)
							{
								undeclaredNotations = new Hashtable();
							}
							UndeclaredNotation undeclaredNotation = new UndeclaredNotation(nameString, LineNo, LinePos - nameString.Length);
							UndeclaredNotation undeclaredNotation2 = (UndeclaredNotation)undeclaredNotations[nameString];
							if (undeclaredNotation2 != null)
							{
								undeclaredNotation.next = undeclaredNotation2.next;
								undeclaredNotation2.next = undeclaredNotation;
							}
							else
							{
								undeclaredNotations.Add(nameString, undeclaredNotation);
							}
						}
						if (validate && !v1Compat && attrDef.Values != null && attrDef.Values.Contains(nameString))
						{
							SendValidationEvent(XmlSeverityType.Error, new XmlSchemaException("Xml_AttlistDuplNotationValue", nameString, BaseUriStr, LineNo, LinePos));
						}
						attrDef.AddValue(nameString);
						switch (GetToken(needWhiteSpace: false))
						{
						case Token.Or:
							continue;
						case Token.RightParen:
							return;
						}
						break;
					}
					while (GetToken(needWhiteSpace: false) == Token.Name);
				}
			}
			else if (token == Token.LeftParen)
			{
				attrDef.Datatype = XmlSchemaDatatype.FromXmlTokenizedType(XmlTokenizedType.ENUMERATION);
				attrDef.SchemaType = XmlSchemaType.GetBuiltInSimpleType(attrDef.Datatype.TypeCode);
				if (GetToken(needWhiteSpace: false) == Token.Nmtoken)
				{
					attrDef.AddValue(GetNameString());
					while (true)
					{
						string nmtokenString;
						switch (GetToken(needWhiteSpace: false))
						{
						case Token.Or:
							if (GetToken(needWhiteSpace: false) == Token.Nmtoken)
							{
								nmtokenString = GetNmtokenString();
								if (validate && !v1Compat && attrDef.Values != null && attrDef.Values.Contains(nmtokenString))
								{
									SendValidationEvent(XmlSeverityType.Error, new XmlSchemaException("Xml_AttlistDuplEnumValue", nmtokenString, BaseUriStr, LineNo, LinePos));
								}
								goto IL_02f4;
							}
							break;
						case Token.RightParen:
							return;
						}
						break;
						IL_02f4:
						attrDef.AddValue(nmtokenString);
					}
				}
			}
			OnUnexpectedError();
		}

		private void ParseAttlistDefault(SchemaAttDef attrDef)
		{
			switch (GetToken(needWhiteSpace: true))
			{
			case Token.REQUIRED:
				attrDef.Presence = SchemaDeclBase.Use.Required;
				return;
			case Token.IMPLIED:
				attrDef.Presence = SchemaDeclBase.Use.Implied;
				return;
			case Token.FIXED:
				attrDef.Presence = SchemaDeclBase.Use.Fixed;
				if (GetToken(needWhiteSpace: true) != Token.Literal)
				{
					break;
				}
				goto case Token.Literal;
			case Token.Literal:
				if (validate && attrDef.Datatype.TokenizedType == XmlTokenizedType.ID)
				{
					SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_AttListPresence", string.Empty);
				}
				if (attrDef.Datatype.TokenizedType != 0)
				{
					attrDef.DefaultValueExpanded = GetValueWithStrippedSpaces();
				}
				else
				{
					attrDef.DefaultValueExpanded = GetValue();
				}
				attrDef.ValueLineNum = literalLineInfo.lineNo;
				attrDef.ValueLinePos = literalLineInfo.linePos + 1;
				DtdValidator.SetDefaultTypedValue(attrDef, readerAdapter);
				return;
			}
			OnUnexpectedError();
		}

		private void ParseElementDecl()
		{
			if (GetToken(needWhiteSpace: true) == Token.QName)
			{
				SchemaElementDecl schemaElementDecl = null;
				XmlQualifiedName nameQualified = GetNameQualified(canHavePrefix: true);
				schemaElementDecl = (SchemaElementDecl)schemaInfo.ElementDecls[nameQualified];
				if (schemaElementDecl != null)
				{
					if (validate)
					{
						SendValidationEvent(curPos - nameQualified.Name.Length, XmlSeverityType.Error, "Sch_DupElementDecl", GetNameString());
					}
				}
				else
				{
					if ((schemaElementDecl = (SchemaElementDecl)schemaInfo.UndeclaredElementDecls[nameQualified]) != null)
					{
						schemaInfo.UndeclaredElementDecls.Remove(nameQualified);
					}
					else
					{
						schemaElementDecl = new SchemaElementDecl(nameQualified, nameQualified.Namespace, SchemaType.DTD);
					}
					schemaInfo.ElementDecls.Add(nameQualified, schemaElementDecl);
				}
				schemaElementDecl.IsDeclaredInExternal = !ParsingInternalSubset;
				switch (GetToken(needWhiteSpace: true))
				{
				case Token.EMPTY:
					schemaElementDecl.ContentValidator = ContentValidator.Empty;
					goto IL_0175;
				case Token.ANY:
					schemaElementDecl.ContentValidator = ContentValidator.Any;
					goto IL_0175;
				case Token.LeftParen:
					{
						int startParenEntityId = currentEntityId;
						Token token = GetToken(needWhiteSpace: false);
						if (token != Token.None)
						{
							if (token != Token.PCDATA)
							{
								break;
							}
							ParticleContentValidator particleContentValidator = new ParticleContentValidator(XmlSchemaContentType.Mixed);
							particleContentValidator.Start();
							particleContentValidator.OpenGroup();
							ParseElementMixedContent(particleContentValidator, startParenEntityId);
							schemaElementDecl.ContentValidator = particleContentValidator.Finish(useDFA: true);
						}
						else
						{
							ParticleContentValidator particleContentValidator2 = null;
							particleContentValidator2 = new ParticleContentValidator(XmlSchemaContentType.ElementOnly);
							particleContentValidator2.Start();
							particleContentValidator2.OpenGroup();
							ParseElementOnlyContent(particleContentValidator2, startParenEntityId);
							schemaElementDecl.ContentValidator = particleContentValidator2.Finish(useDFA: true);
						}
						goto IL_0175;
					}
					IL_0175:
					if (GetToken(needWhiteSpace: false) != Token.GreaterThan)
					{
						ThrowUnexpectedToken(curPos, ">");
					}
					return;
				}
			}
			OnUnexpectedError();
		}

		private void ParseElementOnlyContent(ParticleContentValidator pcv, int startParenEntityId)
		{
			Stack<ParseElementOnlyContent_LocalFrame> stack = new Stack<ParseElementOnlyContent_LocalFrame>();
			ParseElementOnlyContent_LocalFrame parseElementOnlyContent_LocalFrame = new ParseElementOnlyContent_LocalFrame(startParenEntityId);
			stack.Push(parseElementOnlyContent_LocalFrame);
			while (true)
			{
				switch (GetToken(needWhiteSpace: false))
				{
				case Token.QName:
					pcv.AddName(GetNameQualified(canHavePrefix: true), null);
					if (validate)
					{
						parseElementOnlyContent_LocalFrame.contentEntityId = currentEntityId;
						if (parseElementOnlyContent_LocalFrame.connectorEntityId > parseElementOnlyContent_LocalFrame.contentEntityId)
						{
							SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
						}
					}
					ParseHowMany(pcv);
					goto IL_00f8;
				case Token.LeftParen:
					pcv.OpenGroup();
					if (validate)
					{
						parseElementOnlyContent_LocalFrame.contentEntityId = currentEntityId;
						if (parseElementOnlyContent_LocalFrame.connectorEntityId > parseElementOnlyContent_LocalFrame.contentEntityId)
						{
							SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
						}
					}
					parseElementOnlyContent_LocalFrame = new ParseElementOnlyContent_LocalFrame(currentEntityId);
					stack.Push(parseElementOnlyContent_LocalFrame);
					break;
				case Token.GreaterThan:
					Throw(curPos, "Xml_InvalidContentModel");
					goto IL_024c;
				default:
					goto IL_0246;
					IL_0246:
					OnUnexpectedError();
					goto IL_024c;
					IL_0233:
					Throw(curPos, "Xml_InvalidContentModel");
					goto IL_024c;
					IL_00f8:
					switch (GetToken(needWhiteSpace: false))
					{
					case Token.Comma:
						break;
					case Token.Or:
						goto IL_018a;
					case Token.RightParen:
						goto IL_01f7;
					case Token.GreaterThan:
						goto IL_0233;
					default:
						goto IL_0246;
					}
					if (parseElementOnlyContent_LocalFrame.parsingSchema == Token.Or)
					{
						Throw(curPos, "Xml_InvalidContentModel");
					}
					pcv.AddSequence();
					parseElementOnlyContent_LocalFrame.parsingSchema = Token.Comma;
					if (validate)
					{
						parseElementOnlyContent_LocalFrame.connectorEntityId = currentEntityId;
						if (parseElementOnlyContent_LocalFrame.connectorEntityId > parseElementOnlyContent_LocalFrame.contentEntityId)
						{
							SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
						}
					}
					break;
					IL_024c:
					stack.Pop();
					if (stack.Count > 0)
					{
						parseElementOnlyContent_LocalFrame = stack.Peek();
						goto IL_00f8;
					}
					return;
					IL_018a:
					if (parseElementOnlyContent_LocalFrame.parsingSchema == Token.Comma)
					{
						Throw(curPos, "Xml_InvalidContentModel");
					}
					pcv.AddChoice();
					parseElementOnlyContent_LocalFrame.parsingSchema = Token.Or;
					if (validate)
					{
						parseElementOnlyContent_LocalFrame.connectorEntityId = currentEntityId;
						if (parseElementOnlyContent_LocalFrame.connectorEntityId > parseElementOnlyContent_LocalFrame.contentEntityId)
						{
							SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
						}
					}
					break;
					IL_01f7:
					pcv.CloseGroup();
					if (validate && currentEntityId != parseElementOnlyContent_LocalFrame.startParenEntityId)
					{
						SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
					}
					ParseHowMany(pcv);
					goto IL_024c;
				}
			}
		}

		private void ParseHowMany(ParticleContentValidator pcv)
		{
			switch (GetToken(needWhiteSpace: false))
			{
			case Token.Star:
				pcv.AddStar();
				break;
			case Token.QMark:
				pcv.AddQMark();
				break;
			case Token.Plus:
				pcv.AddPlus();
				break;
			}
		}

		private void ParseElementMixedContent(ParticleContentValidator pcv, int startParenEntityId)
		{
			bool flag = false;
			int num = -1;
			int num2 = currentEntityId;
			while (true)
			{
				switch (GetToken(needWhiteSpace: false))
				{
				case Token.RightParen:
					pcv.CloseGroup();
					if (validate && currentEntityId != startParenEntityId)
					{
						SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
					}
					if (GetToken(needWhiteSpace: false) == Token.Star && flag)
					{
						pcv.AddStar();
					}
					else if (flag)
					{
						ThrowUnexpectedToken(curPos, "*");
					}
					return;
				case Token.Or:
				{
					if (!flag)
					{
						flag = true;
					}
					else
					{
						pcv.AddChoice();
					}
					if (validate)
					{
						num = currentEntityId;
						if (num2 < num)
						{
							SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
						}
					}
					if (GetToken(needWhiteSpace: false) != Token.QName)
					{
						break;
					}
					XmlQualifiedName nameQualified = GetNameQualified(canHavePrefix: true);
					if (pcv.Exists(nameQualified) && validate)
					{
						SendValidationEvent(XmlSeverityType.Error, "Sch_DupElement", nameQualified.ToString());
					}
					pcv.AddName(nameQualified, null);
					if (validate)
					{
						num2 = currentEntityId;
						if (num2 < num)
						{
							SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
						}
					}
					continue;
				}
				}
				OnUnexpectedError();
			}
		}

		private void ParseEntityDecl()
		{
			bool flag = false;
			SchemaEntity schemaEntity = null;
			Token token = GetToken(needWhiteSpace: true);
			if (token == Token.Name)
			{
				goto IL_002c;
			}
			if (token == Token.Percent)
			{
				flag = true;
				if (GetToken(needWhiteSpace: true) == Token.Name)
				{
					goto IL_002c;
				}
			}
			goto IL_024e;
			IL_002c:
			XmlQualifiedName nameQualified = GetNameQualified(canHavePrefix: false);
			schemaEntity = new SchemaEntity(nameQualified, flag);
			schemaEntity.BaseURI = BaseUriStr;
			schemaEntity.DeclaredURI = ((externalDtdBaseUri.Length == 0) ? documentBaseUri : externalDtdBaseUri);
			if (flag)
			{
				if (schemaInfo.ParameterEntities[nameQualified] == null)
				{
					schemaInfo.ParameterEntities.Add(nameQualified, schemaEntity);
				}
			}
			else if (schemaInfo.GeneralEntities[nameQualified] == null)
			{
				schemaInfo.GeneralEntities.Add(nameQualified, schemaEntity);
			}
			schemaEntity.DeclaredInExternal = !ParsingInternalSubset;
			schemaEntity.IsProcessed = true;
			Token token2 = GetToken(needWhiteSpace: true);
			switch (token2)
			{
			case Token.PUBLIC:
			case Token.SYSTEM:
			{
				ParseExternalId(token2, Token.EntityDecl, out var pubid, out var url);
				schemaEntity.IsExternal = true;
				schemaEntity.Url = url;
				schemaEntity.Pubid = pubid;
				if (GetToken(needWhiteSpace: false) == Token.NData)
				{
					if (flag)
					{
						ThrowUnexpectedToken(curPos - 5, ">");
					}
					if (!whitespaceSeen)
					{
						Throw(curPos - 5, "Xml_ExpectingWhiteSpace", "NDATA");
					}
					if (GetToken(needWhiteSpace: true) != Token.Name)
					{
						break;
					}
					schemaEntity.NData = GetNameQualified(canHavePrefix: false);
					string name = schemaEntity.NData.Name;
					if (schemaInfo.Notations[name] == null)
					{
						if (undeclaredNotations == null)
						{
							undeclaredNotations = new Hashtable();
						}
						UndeclaredNotation undeclaredNotation = new UndeclaredNotation(name, LineNo, LinePos - name.Length);
						UndeclaredNotation undeclaredNotation2 = (UndeclaredNotation)undeclaredNotations[name];
						if (undeclaredNotation2 != null)
						{
							undeclaredNotation.next = undeclaredNotation2.next;
							undeclaredNotation2.next = undeclaredNotation;
						}
						else
						{
							undeclaredNotations.Add(name, undeclaredNotation);
						}
					}
				}
				goto IL_023b;
			}
			case Token.Literal:
				{
					schemaEntity.Text = GetValue();
					schemaEntity.Line = literalLineInfo.lineNo;
					schemaEntity.Pos = literalLineInfo.linePos;
					goto IL_023b;
				}
				IL_023b:
				if (GetToken(needWhiteSpace: false) == Token.GreaterThan)
				{
					schemaEntity.IsProcessed = false;
					return;
				}
				break;
			}
			goto IL_024e;
			IL_024e:
			OnUnexpectedError();
		}

		private void ParseNotationDecl()
		{
			if (GetToken(needWhiteSpace: true) != Token.Name)
			{
				OnUnexpectedError();
			}
			SchemaNotation schemaNotation = null;
			XmlQualifiedName nameQualified = GetNameQualified(canHavePrefix: false);
			if (schemaInfo.Notations[nameQualified.Name] == null)
			{
				if (undeclaredNotations != null)
				{
					undeclaredNotations.Remove(nameQualified.Name);
				}
				schemaNotation = new SchemaNotation(nameQualified);
				schemaInfo.Notations.Add(schemaNotation.Name.Name, schemaNotation);
			}
			else if (validate)
			{
				SendValidationEvent(curPos - nameQualified.Name.Length, XmlSeverityType.Error, "Sch_DupNotation", nameQualified.Name);
			}
			Token token = GetToken(needWhiteSpace: true);
			if (token == Token.SYSTEM || token == Token.PUBLIC)
			{
				ParseExternalId(token, Token.NOTATION, out var pubid, out var systemLiteral);
				if (schemaNotation != null)
				{
					schemaNotation.SystemLiteral = systemLiteral;
					schemaNotation.Pubid = pubid;
				}
			}
			else
			{
				OnUnexpectedError();
			}
			if (GetToken(needWhiteSpace: false) != Token.GreaterThan)
			{
				OnUnexpectedError();
			}
		}

		private void ParseComment()
		{
			SaveParsingBuffer();
			try
			{
				if (SaveInternalSubsetValue)
				{
					readerAdapter.ParseComment(internalSubsetValueSb);
					internalSubsetValueSb.Append("-->");
				}
				else
				{
					readerAdapter.ParseComment(null);
				}
			}
			catch (XmlException ex)
			{
				if (!(ex.ResString == "Xml_UnexpectedEOF") || currentEntityId == 0)
				{
					throw;
				}
				SendValidationEvent(XmlSeverityType.Error, "Sch_ParEntityRefNesting", null);
			}
			LoadParsingBuffer();
		}

		private void ParsePI()
		{
			SaveParsingBuffer();
			if (SaveInternalSubsetValue)
			{
				readerAdapter.ParsePI(internalSubsetValueSb);
				internalSubsetValueSb.Append("?>");
			}
			else
			{
				readerAdapter.ParsePI(null);
			}
			LoadParsingBuffer();
		}

		private void ParseCondSection()
		{
			int num = currentEntityId;
			switch (GetToken(needWhiteSpace: false))
			{
			case Token.INCLUDE:
				if (GetToken(needWhiteSpace: false) == Token.RightBracket)
				{
					if (validate && num != currentEntityId)
					{
						SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
					}
					if (validate)
					{
						if (condSectionEntityIds == null)
						{
							condSectionEntityIds = new int[2];
						}
						else if (condSectionEntityIds.Length == condSectionDepth)
						{
							int[] destinationArray = new int[condSectionEntityIds.Length * 2];
							Array.Copy(condSectionEntityIds, 0, destinationArray, 0, condSectionEntityIds.Length);
							condSectionEntityIds = destinationArray;
						}
						condSectionEntityIds[condSectionDepth] = num;
					}
					condSectionDepth++;
					break;
				}
				goto default;
			case Token.IGNORE:
				if (GetToken(needWhiteSpace: false) == Token.RightBracket)
				{
					if (validate && num != currentEntityId)
					{
						SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
					}
					if (GetToken(needWhiteSpace: false) == Token.CondSectionEnd)
					{
						if (validate && num != currentEntityId)
						{
							SendValidationEvent(curPos, XmlSeverityType.Error, "Sch_ParEntityRefNesting", string.Empty);
						}
						break;
					}
				}
				goto default;
			default:
				OnUnexpectedError();
				break;
			}
		}

		private void ParseExternalId(Token idTokenType, Token declType, out string publicId, out string systemId)
		{
			LineInfo keywordLineInfo = new LineInfo(LineNo, LinePos - 6);
			publicId = null;
			systemId = null;
			if (GetToken(needWhiteSpace: true) != Token.Literal)
			{
				ThrowUnexpectedToken(curPos, "\"", "'");
			}
			if (idTokenType == Token.SYSTEM)
			{
				systemId = GetValue();
				if (systemId.IndexOf('#') >= 0)
				{
					Throw(curPos - systemId.Length - 1, "Xml_FragmentId", new string[2]
					{
						systemId.Substring(systemId.IndexOf('#')),
						systemId
					});
				}
				if (declType == Token.DOCTYPE && !freeFloatingDtd)
				{
					literalLineInfo.linePos++;
					readerAdapter.OnSystemId(systemId, keywordLineInfo, literalLineInfo);
				}
				return;
			}
			publicId = GetValue();
			int num;
			if ((num = xmlCharType.IsPublicId(publicId)) >= 0)
			{
				ThrowInvalidChar(curPos - 1 - publicId.Length + num, publicId[num]);
			}
			if (declType == Token.DOCTYPE && !freeFloatingDtd)
			{
				literalLineInfo.linePos++;
				readerAdapter.OnPublicId(publicId, keywordLineInfo, literalLineInfo);
				if (GetToken(needWhiteSpace: false) == Token.Literal)
				{
					if (!whitespaceSeen)
					{
						Throw("Xml_ExpectingWhiteSpace", new string(literalQuoteChar, 1), literalLineInfo.lineNo, literalLineInfo.linePos);
					}
					systemId = GetValue();
					literalLineInfo.linePos++;
					readerAdapter.OnSystemId(systemId, keywordLineInfo, literalLineInfo);
				}
				else
				{
					ThrowUnexpectedToken(curPos, "\"", "'");
				}
			}
			else if (GetToken(needWhiteSpace: false) == Token.Literal)
			{
				if (!whitespaceSeen)
				{
					Throw("Xml_ExpectingWhiteSpace", new string(literalQuoteChar, 1), literalLineInfo.lineNo, literalLineInfo.linePos);
				}
				systemId = GetValue();
			}
			else if (declType != Token.NOTATION)
			{
				ThrowUnexpectedToken(curPos, "\"", "'");
			}
		}

		private Token GetToken(bool needWhiteSpace)
		{
			whitespaceSeen = false;
			while (true)
			{
				switch (chars[curPos])
				{
				case '\0':
					if (curPos != charsUsed)
					{
						ThrowInvalidChar(curPos, chars[curPos]);
					}
					break;
				case '\n':
					whitespaceSeen = true;
					curPos++;
					readerAdapter.OnNewLine(curPos);
					continue;
				case '\r':
					whitespaceSeen = true;
					if (chars[curPos + 1] == '\n')
					{
						if (normalize)
						{
							SaveParsingBuffer();
							readerAdapter.CurrentPosition++;
						}
						curPos += 2;
					}
					else
					{
						if (curPos + 1 >= charsUsed && !readerAdapter.IsEof)
						{
							break;
						}
						chars[curPos] = '\n';
						curPos++;
					}
					readerAdapter.OnNewLine(curPos);
					continue;
				case '\t':
				case ' ':
					whitespaceSeen = true;
					curPos++;
					continue;
				case '%':
					if (charsUsed - curPos < 2)
					{
						break;
					}
					if (!xmlCharType.IsWhiteSpace(chars[curPos + 1]))
					{
						if (IgnoreEntityReferences)
						{
							curPos++;
						}
						else
						{
							HandleEntityReference(paramEntity: true, inLiteral: false, inAttribute: false);
						}
						continue;
					}
					goto default;
				default:
					if (needWhiteSpace && !whitespaceSeen && scanningFunction != ScanningFunction.ParamEntitySpace)
					{
						Throw(curPos, "Xml_ExpectingWhiteSpace", ParseUnexpectedToken(curPos));
					}
					tokenStartPos = curPos;
					while (true)
					{
						switch (scanningFunction)
						{
						case ScanningFunction.Name:
							return ScanNameExpected();
						case ScanningFunction.QName:
							return ScanQNameExpected();
						case ScanningFunction.Nmtoken:
							return ScanNmtokenExpected();
						case ScanningFunction.SubsetContent:
							return ScanSubsetContent();
						case ScanningFunction.Doctype1:
							return ScanDoctype1();
						case ScanningFunction.Doctype2:
							return ScanDoctype2();
						case ScanningFunction.Element1:
							return ScanElement1();
						case ScanningFunction.Element2:
							return ScanElement2();
						case ScanningFunction.Element3:
							return ScanElement3();
						case ScanningFunction.Element4:
							return ScanElement4();
						case ScanningFunction.Element5:
							return ScanElement5();
						case ScanningFunction.Element6:
							return ScanElement6();
						case ScanningFunction.Element7:
							return ScanElement7();
						case ScanningFunction.Attlist1:
							return ScanAttlist1();
						case ScanningFunction.Attlist2:
							return ScanAttlist2();
						case ScanningFunction.Attlist3:
							return ScanAttlist3();
						case ScanningFunction.Attlist4:
							return ScanAttlist4();
						case ScanningFunction.Attlist5:
							return ScanAttlist5();
						case ScanningFunction.Attlist6:
							return ScanAttlist6();
						case ScanningFunction.Attlist7:
							return ScanAttlist7();
						case ScanningFunction.Notation1:
							return ScanNotation1();
						case ScanningFunction.SystemId:
							return ScanSystemId();
						case ScanningFunction.PublicId1:
							return ScanPublicId1();
						case ScanningFunction.PublicId2:
							return ScanPublicId2();
						case ScanningFunction.Entity1:
							return ScanEntity1();
						case ScanningFunction.Entity2:
							return ScanEntity2();
						case ScanningFunction.Entity3:
							return ScanEntity3();
						case ScanningFunction.CondSection1:
							return ScanCondSection1();
						case ScanningFunction.CondSection2:
							return ScanCondSection2();
						case ScanningFunction.CondSection3:
							return ScanCondSection3();
						case ScanningFunction.ClosingTag:
							return ScanClosingTag();
						case ScanningFunction.ParamEntitySpace:
							break;
						default:
							return Token.None;
						}
						whitespaceSeen = true;
						scanningFunction = savedScanningFunction;
					}
				}
				if ((readerAdapter.IsEof || ReadData() == 0) && !HandleEntityEnd(inLiteral: false))
				{
					if (scanningFunction == ScanningFunction.SubsetContent)
					{
						break;
					}
					Throw(curPos, "Xml_IncompleteDtdContent");
				}
			}
			return Token.Eof;
		}

		private Token ScanSubsetContent()
		{
			while (true)
			{
				char c = chars[curPos];
				if (c != '<')
				{
					if (c != ']')
					{
						goto IL_04f3;
					}
					if (charsUsed - curPos >= 2 || readerAdapter.IsEof)
					{
						if (chars[curPos + 1] != ']')
						{
							curPos++;
							scanningFunction = ScanningFunction.ClosingTag;
							return Token.RightBracket;
						}
						if (charsUsed - curPos >= 3 || readerAdapter.IsEof)
						{
							if (chars[curPos + 1] == ']' && chars[curPos + 2] == '>')
							{
								break;
							}
							goto IL_04f3;
						}
					}
				}
				else
				{
					switch (chars[curPos + 1])
					{
					case '!':
						switch (chars[curPos + 2])
						{
						case 'E':
							if (chars[curPos + 3] == 'L')
							{
								if (charsUsed - curPos >= 9)
								{
									if (chars[curPos + 4] != 'E' || chars[curPos + 5] != 'M' || chars[curPos + 6] != 'E' || chars[curPos + 7] != 'N' || chars[curPos + 8] != 'T')
									{
										Throw(curPos, "Xml_ExpectDtdMarkup");
									}
									curPos += 9;
									scanningFunction = ScanningFunction.QName;
									nextScaningFunction = ScanningFunction.Element1;
									return Token.ElementDecl;
								}
							}
							else if (chars[curPos + 3] == 'N')
							{
								if (charsUsed - curPos >= 8)
								{
									if (chars[curPos + 4] != 'T' || chars[curPos + 5] != 'I' || chars[curPos + 6] != 'T' || chars[curPos + 7] != 'Y')
									{
										Throw(curPos, "Xml_ExpectDtdMarkup");
									}
									curPos += 8;
									scanningFunction = ScanningFunction.Entity1;
									return Token.EntityDecl;
								}
							}
							else if (charsUsed - curPos >= 4)
							{
								Throw(curPos, "Xml_ExpectDtdMarkup");
								return Token.None;
							}
							break;
						case 'A':
							if (charsUsed - curPos >= 9)
							{
								if (chars[curPos + 3] != 'T' || chars[curPos + 4] != 'T' || chars[curPos + 5] != 'L' || chars[curPos + 6] != 'I' || chars[curPos + 7] != 'S' || chars[curPos + 8] != 'T')
								{
									Throw(curPos, "Xml_ExpectDtdMarkup");
								}
								curPos += 9;
								scanningFunction = ScanningFunction.QName;
								nextScaningFunction = ScanningFunction.Attlist1;
								return Token.AttlistDecl;
							}
							break;
						case 'N':
							if (charsUsed - curPos >= 10)
							{
								if (chars[curPos + 3] != 'O' || chars[curPos + 4] != 'T' || chars[curPos + 5] != 'A' || chars[curPos + 6] != 'T' || chars[curPos + 7] != 'I' || chars[curPos + 8] != 'O' || chars[curPos + 9] != 'N')
								{
									Throw(curPos, "Xml_ExpectDtdMarkup");
								}
								curPos += 10;
								scanningFunction = ScanningFunction.Name;
								nextScaningFunction = ScanningFunction.Notation1;
								return Token.NotationDecl;
							}
							break;
						case '[':
							curPos += 3;
							scanningFunction = ScanningFunction.CondSection1;
							return Token.CondSectionStart;
						case '-':
							if (chars[curPos + 3] == '-')
							{
								curPos += 4;
								return Token.Comment;
							}
							if (charsUsed - curPos >= 4)
							{
								Throw(curPos, "Xml_ExpectDtdMarkup");
							}
							break;
						default:
							if (charsUsed - curPos >= 3)
							{
								Throw(curPos + 2, "Xml_ExpectDtdMarkup");
							}
							break;
						}
						break;
					case '?':
						curPos += 2;
						return Token.PI;
					default:
						if (charsUsed - curPos >= 2)
						{
							Throw(curPos, "Xml_ExpectDtdMarkup");
							return Token.None;
						}
						break;
					}
				}
				goto IL_0513;
				IL_0513:
				if (ReadData() == 0)
				{
					Throw(charsUsed, "Xml_IncompleteDtdContent");
				}
				continue;
				IL_04f3:
				if (charsUsed - curPos != 0)
				{
					Throw(curPos, "Xml_ExpectDtdMarkup");
				}
				goto IL_0513;
			}
			curPos += 3;
			return Token.CondSectionEnd;
		}

		private Token ScanNameExpected()
		{
			ScanName();
			scanningFunction = nextScaningFunction;
			return Token.Name;
		}

		private Token ScanQNameExpected()
		{
			ScanQName();
			scanningFunction = nextScaningFunction;
			return Token.QName;
		}

		private Token ScanNmtokenExpected()
		{
			ScanNmtoken();
			scanningFunction = nextScaningFunction;
			return Token.Nmtoken;
		}

		private Token ScanDoctype1()
		{
			switch (chars[curPos])
			{
			case 'P':
				if (!EatPublicKeyword())
				{
					Throw(curPos, "Xml_ExpectExternalOrClose");
				}
				nextScaningFunction = ScanningFunction.Doctype2;
				scanningFunction = ScanningFunction.PublicId1;
				return Token.PUBLIC;
			case 'S':
				if (!EatSystemKeyword())
				{
					Throw(curPos, "Xml_ExpectExternalOrClose");
				}
				nextScaningFunction = ScanningFunction.Doctype2;
				scanningFunction = ScanningFunction.SystemId;
				return Token.SYSTEM;
			case '[':
				curPos++;
				scanningFunction = ScanningFunction.SubsetContent;
				return Token.LeftBracket;
			case '>':
				curPos++;
				scanningFunction = ScanningFunction.SubsetContent;
				return Token.GreaterThan;
			default:
				Throw(curPos, "Xml_ExpectExternalOrClose");
				return Token.None;
			}
		}

		private Token ScanDoctype2()
		{
			switch (chars[curPos])
			{
			case '[':
				curPos++;
				scanningFunction = ScanningFunction.SubsetContent;
				return Token.LeftBracket;
			case '>':
				curPos++;
				scanningFunction = ScanningFunction.SubsetContent;
				return Token.GreaterThan;
			default:
				Throw(curPos, "Xml_ExpectSubOrClose");
				return Token.None;
			}
		}

		private Token ScanClosingTag()
		{
			if (chars[curPos] != '>')
			{
				ThrowUnexpectedToken(curPos, ">");
			}
			curPos++;
			scanningFunction = ScanningFunction.SubsetContent;
			return Token.GreaterThan;
		}

		private Token ScanElement1()
		{
			while (true)
			{
				char c = chars[curPos];
				if (c != '(')
				{
					if (c != 'A')
					{
						if (c == 'E')
						{
							if (charsUsed - curPos < 5)
							{
								goto IL_011b;
							}
							if (chars[curPos + 1] == 'M' && chars[curPos + 2] == 'P' && chars[curPos + 3] == 'T' && chars[curPos + 4] == 'Y')
							{
								curPos += 5;
								scanningFunction = ScanningFunction.ClosingTag;
								return Token.EMPTY;
							}
						}
					}
					else
					{
						if (charsUsed - curPos < 3)
						{
							goto IL_011b;
						}
						if (chars[curPos + 1] == 'N' && chars[curPos + 2] == 'Y')
						{
							break;
						}
					}
					Throw(curPos, "Xml_InvalidContentModel");
					goto IL_011b;
				}
				scanningFunction = ScanningFunction.Element2;
				curPos++;
				return Token.LeftParen;
				IL_011b:
				if (ReadData() == 0)
				{
					Throw(curPos, "Xml_IncompleteDtdContent");
				}
			}
			curPos += 3;
			scanningFunction = ScanningFunction.ClosingTag;
			return Token.ANY;
		}

		private Token ScanElement2()
		{
			if (chars[curPos] == '#')
			{
				while (charsUsed - curPos < 7)
				{
					if (ReadData() == 0)
					{
						Throw(curPos, "Xml_IncompleteDtdContent");
					}
				}
				if (chars[curPos + 1] == 'P' && chars[curPos + 2] == 'C' && chars[curPos + 3] == 'D' && chars[curPos + 4] == 'A' && chars[curPos + 5] == 'T' && chars[curPos + 6] == 'A')
				{
					curPos += 7;
					scanningFunction = ScanningFunction.Element6;
					return Token.PCDATA;
				}
				Throw(curPos + 1, "Xml_ExpectPcData");
			}
			scanningFunction = ScanningFunction.Element3;
			return Token.None;
		}

		private Token ScanElement3()
		{
			switch (chars[curPos])
			{
			case '(':
				curPos++;
				return Token.LeftParen;
			case '>':
				curPos++;
				scanningFunction = ScanningFunction.SubsetContent;
				return Token.GreaterThan;
			default:
				ScanQName();
				scanningFunction = ScanningFunction.Element4;
				return Token.QName;
			}
		}

		private Token ScanElement4()
		{
			scanningFunction = ScanningFunction.Element5;
			Token result;
			switch (chars[curPos])
			{
			case '*':
				result = Token.Star;
				break;
			case '?':
				result = Token.QMark;
				break;
			case '+':
				result = Token.Plus;
				break;
			default:
				return Token.None;
			}
			if (whitespaceSeen)
			{
				Throw(curPos, "Xml_ExpectNoWhitespace");
			}
			curPos++;
			return result;
		}

		private Token ScanElement5()
		{
			switch (chars[curPos])
			{
			case ',':
				curPos++;
				scanningFunction = ScanningFunction.Element3;
				return Token.Comma;
			case '|':
				curPos++;
				scanningFunction = ScanningFunction.Element3;
				return Token.Or;
			case ')':
				curPos++;
				scanningFunction = ScanningFunction.Element4;
				return Token.RightParen;
			case '>':
				curPos++;
				scanningFunction = ScanningFunction.SubsetContent;
				return Token.GreaterThan;
			default:
				Throw(curPos, "Xml_ExpectOp");
				return Token.None;
			}
		}

		private Token ScanElement6()
		{
			switch (chars[curPos])
			{
			case ')':
				curPos++;
				scanningFunction = ScanningFunction.Element7;
				return Token.RightParen;
			case '|':
				curPos++;
				nextScaningFunction = ScanningFunction.Element6;
				scanningFunction = ScanningFunction.QName;
				return Token.Or;
			default:
				ThrowUnexpectedToken(curPos, ")", "|");
				return Token.None;
			}
		}

		private Token ScanElement7()
		{
			scanningFunction = ScanningFunction.ClosingTag;
			if (chars[curPos] == '*' && !whitespaceSeen)
			{
				curPos++;
				return Token.Star;
			}
			return Token.None;
		}

		private Token ScanAttlist1()
		{
			char c = chars[curPos];
			if (c == '>')
			{
				curPos++;
				scanningFunction = ScanningFunction.SubsetContent;
				return Token.GreaterThan;
			}
			if (!whitespaceSeen)
			{
				Throw(curPos, "Xml_ExpectingWhiteSpace", ParseUnexpectedToken(curPos));
			}
			ScanQName();
			scanningFunction = ScanningFunction.Attlist2;
			return Token.QName;
		}

		private Token ScanAttlist2()
		{
			while (true)
			{
				switch (chars[curPos])
				{
				case '(':
					curPos++;
					scanningFunction = ScanningFunction.Nmtoken;
					nextScaningFunction = ScanningFunction.Attlist5;
					return Token.LeftParen;
				case 'C':
					if (charsUsed - curPos >= 5)
					{
						if (chars[curPos + 1] != 'D' || chars[curPos + 2] != 'A' || chars[curPos + 3] != 'T' || chars[curPos + 4] != 'A')
						{
							Throw(curPos, "Xml_InvalidAttributeType1");
						}
						curPos += 5;
						scanningFunction = ScanningFunction.Attlist6;
						return Token.CDATA;
					}
					break;
				case 'E':
					if (charsUsed - curPos < 9)
					{
						break;
					}
					scanningFunction = ScanningFunction.Attlist6;
					if (chars[curPos + 1] != 'N' || chars[curPos + 2] != 'T' || chars[curPos + 3] != 'I' || chars[curPos + 4] != 'T')
					{
						Throw(curPos, "Xml_InvalidAttributeType");
					}
					switch (chars[curPos + 5])
					{
					case 'I':
						if (chars[curPos + 6] != 'E' || chars[curPos + 7] != 'S')
						{
							Throw(curPos, "Xml_InvalidAttributeType");
						}
						curPos += 8;
						return Token.ENTITIES;
					case 'Y':
						curPos += 6;
						return Token.ENTITY;
					}
					Throw(curPos, "Xml_InvalidAttributeType");
					break;
				case 'I':
					if (charsUsed - curPos >= 6)
					{
						scanningFunction = ScanningFunction.Attlist6;
						if (chars[curPos + 1] != 'D')
						{
							Throw(curPos, "Xml_InvalidAttributeType");
						}
						if (chars[curPos + 2] != 'R')
						{
							curPos += 2;
							return Token.ID;
						}
						if (chars[curPos + 3] != 'E' || chars[curPos + 4] != 'F')
						{
							Throw(curPos, "Xml_InvalidAttributeType");
						}
						if (chars[curPos + 5] != 'S')
						{
							curPos += 5;
							return Token.IDREF;
						}
						curPos += 6;
						return Token.IDREFS;
					}
					break;
				case 'N':
					if (charsUsed - curPos < 8 && !readerAdapter.IsEof)
					{
						break;
					}
					switch (chars[curPos + 1])
					{
					case 'O':
						if (chars[curPos + 2] != 'T' || chars[curPos + 3] != 'A' || chars[curPos + 4] != 'T' || chars[curPos + 5] != 'I' || chars[curPos + 6] != 'O' || chars[curPos + 7] != 'N')
						{
							Throw(curPos, "Xml_InvalidAttributeType");
						}
						curPos += 8;
						scanningFunction = ScanningFunction.Attlist3;
						return Token.NOTATION;
					case 'M':
						if (chars[curPos + 2] != 'T' || chars[curPos + 3] != 'O' || chars[curPos + 4] != 'K' || chars[curPos + 5] != 'E' || chars[curPos + 6] != 'N')
						{
							Throw(curPos, "Xml_InvalidAttributeType");
						}
						scanningFunction = ScanningFunction.Attlist6;
						if (chars[curPos + 7] == 'S')
						{
							curPos += 8;
							return Token.NMTOKENS;
						}
						curPos += 7;
						return Token.NMTOKEN;
					}
					Throw(curPos, "Xml_InvalidAttributeType");
					break;
				default:
					Throw(curPos, "Xml_InvalidAttributeType");
					break;
				}
				if (ReadData() == 0)
				{
					Throw(curPos, "Xml_IncompleteDtdContent");
				}
			}
		}

		private Token ScanAttlist3()
		{
			if (chars[curPos] == '(')
			{
				curPos++;
				scanningFunction = ScanningFunction.Name;
				nextScaningFunction = ScanningFunction.Attlist4;
				return Token.LeftParen;
			}
			ThrowUnexpectedToken(curPos, "(");
			return Token.None;
		}

		private Token ScanAttlist4()
		{
			switch (chars[curPos])
			{
			case ')':
				curPos++;
				scanningFunction = ScanningFunction.Attlist6;
				return Token.RightParen;
			case '|':
				curPos++;
				scanningFunction = ScanningFunction.Name;
				nextScaningFunction = ScanningFunction.Attlist4;
				return Token.Or;
			default:
				ThrowUnexpectedToken(curPos, ")", "|");
				return Token.None;
			}
		}

		private Token ScanAttlist5()
		{
			switch (chars[curPos])
			{
			case ')':
				curPos++;
				scanningFunction = ScanningFunction.Attlist6;
				return Token.RightParen;
			case '|':
				curPos++;
				scanningFunction = ScanningFunction.Nmtoken;
				nextScaningFunction = ScanningFunction.Attlist5;
				return Token.Or;
			default:
				ThrowUnexpectedToken(curPos, ")", "|");
				return Token.None;
			}
		}

		private Token ScanAttlist6()
		{
			while (true)
			{
				switch (chars[curPos])
				{
				case '"':
				case '\'':
					ScanLiteral(LiteralType.AttributeValue);
					scanningFunction = ScanningFunction.Attlist1;
					return Token.Literal;
				case '#':
					if (charsUsed - curPos < 6)
					{
						break;
					}
					switch (chars[curPos + 1])
					{
					case 'R':
						if (charsUsed - curPos >= 9)
						{
							if (chars[curPos + 2] != 'E' || chars[curPos + 3] != 'Q' || chars[curPos + 4] != 'U' || chars[curPos + 5] != 'I' || chars[curPos + 6] != 'R' || chars[curPos + 7] != 'E' || chars[curPos + 8] != 'D')
							{
								Throw(curPos, "Xml_ExpectAttType");
							}
							curPos += 9;
							scanningFunction = ScanningFunction.Attlist1;
							return Token.REQUIRED;
						}
						break;
					case 'I':
						if (charsUsed - curPos >= 8)
						{
							if (chars[curPos + 2] != 'M' || chars[curPos + 3] != 'P' || chars[curPos + 4] != 'L' || chars[curPos + 5] != 'I' || chars[curPos + 6] != 'E' || chars[curPos + 7] != 'D')
							{
								Throw(curPos, "Xml_ExpectAttType");
							}
							curPos += 8;
							scanningFunction = ScanningFunction.Attlist1;
							return Token.IMPLIED;
						}
						break;
					case 'F':
						if (chars[curPos + 2] != 'I' || chars[curPos + 3] != 'X' || chars[curPos + 4] != 'E' || chars[curPos + 5] != 'D')
						{
							Throw(curPos, "Xml_ExpectAttType");
						}
						curPos += 6;
						scanningFunction = ScanningFunction.Attlist7;
						return Token.FIXED;
					default:
						Throw(curPos, "Xml_ExpectAttType");
						break;
					}
					break;
				default:
					Throw(curPos, "Xml_ExpectAttType");
					break;
				}
				if (ReadData() == 0)
				{
					Throw(curPos, "Xml_IncompleteDtdContent");
				}
			}
		}

		private Token ScanAttlist7()
		{
			char c = chars[curPos];
			if (c == '"' || c == '\'')
			{
				ScanLiteral(LiteralType.AttributeValue);
				scanningFunction = ScanningFunction.Attlist1;
				return Token.Literal;
			}
			ThrowUnexpectedToken(curPos, "\"", "'");
			return Token.None;
		}

		private unsafe Token ScanLiteral(LiteralType literalType)
		{
			char c = chars[curPos];
			char value = ((literalType == LiteralType.AttributeValue) ? ' ' : '\n');
			int num = currentEntityId;
			literalLineInfo.Set(LineNo, LinePos);
			curPos++;
			tokenStartPos = curPos;
			stringBuilder.Length = 0;
			while (true)
			{
				if ((xmlCharType.charProperties[(int)chars[curPos]] & 0x80u) != 0 && chars[curPos] != '%')
				{
					curPos++;
					continue;
				}
				if (chars[curPos] == c && currentEntityId == num)
				{
					break;
				}
				int num2 = curPos - tokenStartPos;
				if (num2 > 0)
				{
					stringBuilder.Append(chars, tokenStartPos, num2);
					tokenStartPos = curPos;
				}
				switch (chars[curPos])
				{
				case '"':
				case '\'':
				case '>':
					curPos++;
					continue;
				case '\n':
					curPos++;
					if (normalize)
					{
						stringBuilder.Append(value);
						tokenStartPos = curPos;
					}
					readerAdapter.OnNewLine(curPos);
					continue;
				case '\r':
					if (chars[curPos + 1] == '\n')
					{
						if (normalize)
						{
							if (literalType == LiteralType.AttributeValue)
							{
								stringBuilder.Append(readerAdapter.IsEntityEolNormalized ? "  " : " ");
							}
							else
							{
								stringBuilder.Append(readerAdapter.IsEntityEolNormalized ? "\r\n" : "\n");
							}
							tokenStartPos = curPos + 2;
							SaveParsingBuffer();
							readerAdapter.CurrentPosition++;
						}
						curPos += 2;
					}
					else
					{
						if (curPos + 1 == charsUsed)
						{
							break;
						}
						curPos++;
						if (normalize)
						{
							stringBuilder.Append(value);
							tokenStartPos = curPos;
						}
					}
					readerAdapter.OnNewLine(curPos);
					continue;
				case '\t':
					if (literalType == LiteralType.AttributeValue && normalize)
					{
						stringBuilder.Append(' ');
						tokenStartPos++;
					}
					curPos++;
					continue;
				case '<':
					if (literalType == LiteralType.AttributeValue)
					{
						Throw(curPos, "Xml_BadAttributeChar", XmlException.BuildCharExceptionStr('<'));
					}
					curPos++;
					continue;
				case '%':
					if (literalType != LiteralType.EntityReplText)
					{
						curPos++;
						continue;
					}
					HandleEntityReference(paramEntity: true, inLiteral: true, literalType == LiteralType.AttributeValue);
					tokenStartPos = curPos;
					continue;
				case '&':
				{
					if (literalType == LiteralType.SystemOrPublicID)
					{
						curPos++;
						continue;
					}
					if (curPos + 1 == charsUsed)
					{
						break;
					}
					if (chars[curPos + 1] == '#')
					{
						SaveParsingBuffer();
						int num3 = readerAdapter.ParseNumericCharRef(SaveInternalSubsetValue ? internalSubsetValueSb : null);
						LoadParsingBuffer();
						stringBuilder.Append(chars, curPos, num3 - curPos);
						readerAdapter.CurrentPosition = num3;
						tokenStartPos = num3;
						curPos = num3;
						continue;
					}
					SaveParsingBuffer();
					if (literalType == LiteralType.AttributeValue)
					{
						int num4 = readerAdapter.ParseNamedCharRef(expand: true, SaveInternalSubsetValue ? internalSubsetValueSb : null);
						LoadParsingBuffer();
						if (num4 >= 0)
						{
							stringBuilder.Append(chars, curPos, num4 - curPos);
							readerAdapter.CurrentPosition = num4;
							tokenStartPos = num4;
							curPos = num4;
						}
						else
						{
							HandleEntityReference(paramEntity: false, inLiteral: true, inAttribute: true);
							tokenStartPos = curPos;
						}
						continue;
					}
					int num5 = readerAdapter.ParseNamedCharRef(expand: false, null);
					LoadParsingBuffer();
					if (num5 >= 0)
					{
						tokenStartPos = curPos;
						curPos = num5;
						continue;
					}
					stringBuilder.Append('&');
					curPos++;
					tokenStartPos = curPos;
					XmlQualifiedName entityName = ScanEntityName();
					VerifyEntityReference(entityName, paramEntity: false, mustBeDeclared: false, inAttribute: false);
					continue;
				}
				default:
				{
					if (curPos == charsUsed)
					{
						break;
					}
					char c2 = chars[curPos];
					if (c2 >= '\ud800' && c2 <= '\udbff')
					{
						if (curPos + 1 == charsUsed)
						{
							break;
						}
						curPos++;
						if (chars[curPos] >= '\udc00' && chars[curPos] <= '\udfff')
						{
							curPos++;
							continue;
						}
					}
					ThrowInvalidChar(curPos, c2);
					return Token.None;
				}
				}
				if ((readerAdapter.IsEof || ReadData() == 0) && (literalType == LiteralType.SystemOrPublicID || !HandleEntityEnd(inLiteral: true)))
				{
					Throw(curPos, "Xml_UnclosedQuote");
				}
				tokenStartPos = curPos;
			}
			if (stringBuilder.Length > 0)
			{
				stringBuilder.Append(chars, tokenStartPos, curPos - tokenStartPos);
			}
			curPos++;
			literalQuoteChar = c;
			return Token.Literal;
		}

		private XmlQualifiedName ScanEntityName()
		{
			try
			{
				ScanName();
			}
			catch (XmlException ex)
			{
				Throw("Xml_ErrorParsingEntityName", string.Empty, ex.LineNumber, ex.LinePosition);
			}
			if (chars[curPos] != ';')
			{
				ThrowUnexpectedToken(curPos, ";");
			}
			XmlQualifiedName nameQualified = GetNameQualified(canHavePrefix: false);
			curPos++;
			return nameQualified;
		}

		private Token ScanNotation1()
		{
			switch (chars[curPos])
			{
			case 'P':
				if (!EatPublicKeyword())
				{
					Throw(curPos, "Xml_ExpectExternalOrClose");
				}
				nextScaningFunction = ScanningFunction.ClosingTag;
				scanningFunction = ScanningFunction.PublicId1;
				return Token.PUBLIC;
			case 'S':
				if (!EatSystemKeyword())
				{
					Throw(curPos, "Xml_ExpectExternalOrClose");
				}
				nextScaningFunction = ScanningFunction.ClosingTag;
				scanningFunction = ScanningFunction.SystemId;
				return Token.SYSTEM;
			default:
				Throw(curPos, "Xml_ExpectExternalOrPublicId");
				return Token.None;
			}
		}

		private Token ScanSystemId()
		{
			if (chars[curPos] != '"' && chars[curPos] != '\'')
			{
				ThrowUnexpectedToken(curPos, "\"", "'");
			}
			ScanLiteral(LiteralType.SystemOrPublicID);
			scanningFunction = nextScaningFunction;
			return Token.Literal;
		}

		private Token ScanEntity1()
		{
			if (chars[curPos] == '%')
			{
				curPos++;
				nextScaningFunction = ScanningFunction.Entity2;
				scanningFunction = ScanningFunction.Name;
				return Token.Percent;
			}
			ScanName();
			scanningFunction = ScanningFunction.Entity2;
			return Token.Name;
		}

		private Token ScanEntity2()
		{
			switch (chars[curPos])
			{
			case 'P':
				if (!EatPublicKeyword())
				{
					Throw(curPos, "Xml_ExpectExternalOrClose");
				}
				nextScaningFunction = ScanningFunction.Entity3;
				scanningFunction = ScanningFunction.PublicId1;
				return Token.PUBLIC;
			case 'S':
				if (!EatSystemKeyword())
				{
					Throw(curPos, "Xml_ExpectExternalOrClose");
				}
				nextScaningFunction = ScanningFunction.Entity3;
				scanningFunction = ScanningFunction.SystemId;
				return Token.SYSTEM;
			case '"':
			case '\'':
				ScanLiteral(LiteralType.EntityReplText);
				scanningFunction = ScanningFunction.ClosingTag;
				return Token.Literal;
			default:
				Throw(curPos, "Xml_ExpectExternalIdOrEntityValue");
				return Token.None;
			}
		}

		private Token ScanEntity3()
		{
			if (chars[curPos] == 'N')
			{
				do
				{
					if (charsUsed - curPos >= 5)
					{
						if (chars[curPos + 1] != 'D' || chars[curPos + 2] != 'A' || chars[curPos + 3] != 'T' || chars[curPos + 4] != 'A')
						{
							break;
						}
						curPos += 5;
						scanningFunction = ScanningFunction.Name;
						nextScaningFunction = ScanningFunction.ClosingTag;
						return Token.NData;
					}
				}
				while (ReadData() != 0);
			}
			scanningFunction = ScanningFunction.ClosingTag;
			return Token.None;
		}

		private Token ScanPublicId1()
		{
			if (chars[curPos] != '"' && chars[curPos] != '\'')
			{
				ThrowUnexpectedToken(curPos, "\"", "'");
			}
			ScanLiteral(LiteralType.SystemOrPublicID);
			scanningFunction = ScanningFunction.PublicId2;
			return Token.Literal;
		}

		private Token ScanPublicId2()
		{
			if (chars[curPos] != '"' && chars[curPos] != '\'')
			{
				scanningFunction = nextScaningFunction;
				return Token.None;
			}
			ScanLiteral(LiteralType.SystemOrPublicID);
			scanningFunction = nextScaningFunction;
			return Token.Literal;
		}

		private Token ScanCondSection1()
		{
			if (chars[curPos] != 'I')
			{
				Throw(curPos, "Xml_ExpectIgnoreOrInclude");
			}
			curPos++;
			while (true)
			{
				if (charsUsed - curPos >= 5)
				{
					char c = chars[curPos];
					if (c == 'G')
					{
						if (chars[curPos + 1] != 'N' || chars[curPos + 2] != 'O' || chars[curPos + 3] != 'R' || chars[curPos + 4] != 'E' || xmlCharType.IsNameChar(chars[curPos + 5]))
						{
							break;
						}
						nextScaningFunction = ScanningFunction.CondSection3;
						scanningFunction = ScanningFunction.CondSection2;
						curPos += 5;
						return Token.IGNORE;
					}
					if (c != 'N')
					{
						break;
					}
					if (charsUsed - curPos >= 6)
					{
						if (chars[curPos + 1] != 'C' || chars[curPos + 2] != 'L' || chars[curPos + 3] != 'U' || chars[curPos + 4] != 'D' || chars[curPos + 5] != 'E' || xmlCharType.IsNameChar(chars[curPos + 6]))
						{
							break;
						}
						nextScaningFunction = ScanningFunction.SubsetContent;
						scanningFunction = ScanningFunction.CondSection2;
						curPos += 6;
						return Token.INCLUDE;
					}
				}
				if (ReadData() == 0)
				{
					Throw(curPos, "Xml_IncompleteDtdContent");
				}
			}
			Throw(curPos - 1, "Xml_ExpectIgnoreOrInclude");
			return Token.None;
		}

		private Token ScanCondSection2()
		{
			if (chars[curPos] != '[')
			{
				ThrowUnexpectedToken(curPos, "[");
			}
			curPos++;
			scanningFunction = nextScaningFunction;
			return Token.RightBracket;
		}

		private unsafe Token ScanCondSection3()
		{
			int num = 0;
			while (true)
			{
				if ((xmlCharType.charProperties[(int)chars[curPos]] & 0x40u) != 0 && chars[curPos] != ']')
				{
					curPos++;
					continue;
				}
				switch (chars[curPos])
				{
				case '\t':
				case '"':
				case '&':
				case '\'':
					curPos++;
					continue;
				case '\n':
					curPos++;
					readerAdapter.OnNewLine(curPos);
					continue;
				case '\r':
					if (chars[curPos + 1] == '\n')
					{
						curPos += 2;
					}
					else
					{
						if (curPos + 1 >= charsUsed && !readerAdapter.IsEof)
						{
							break;
						}
						curPos++;
					}
					readerAdapter.OnNewLine(curPos);
					continue;
				case '<':
					if (charsUsed - curPos >= 3)
					{
						if (chars[curPos + 1] != '!' || chars[curPos + 2] != '[')
						{
							curPos++;
							continue;
						}
						num++;
						curPos += 3;
						continue;
					}
					break;
				case ']':
					if (charsUsed - curPos < 3)
					{
						break;
					}
					if (chars[curPos + 1] != ']' || chars[curPos + 2] != '>')
					{
						curPos++;
						continue;
					}
					if (num > 0)
					{
						num--;
						curPos += 3;
						continue;
					}
					curPos += 3;
					scanningFunction = ScanningFunction.SubsetContent;
					return Token.CondSectionEnd;
				default:
				{
					if (curPos == charsUsed)
					{
						break;
					}
					char c = chars[curPos];
					if (c >= '\ud800' && c <= '\udbff')
					{
						if (curPos + 1 == charsUsed)
						{
							break;
						}
						curPos++;
						if (chars[curPos] >= '\udc00' && chars[curPos] <= '\udfff')
						{
							curPos++;
							continue;
						}
					}
					ThrowInvalidChar(curPos, c);
					return Token.None;
				}
				}
				if (readerAdapter.IsEof || ReadData() == 0)
				{
					if (HandleEntityEnd(inLiteral: false))
					{
						continue;
					}
					Throw(curPos, "Xml_UnclosedConditionalSection");
				}
				tokenStartPos = curPos;
			}
		}

		private void ScanName()
		{
			ScanQName(isQName: false);
		}

		private void ScanQName()
		{
			ScanQName(supportNamespaces);
		}

		private unsafe void ScanQName(bool isQName)
		{
			tokenStartPos = curPos;
			int num = -1;
			while (true)
			{
				if ((xmlCharType.charProperties[(int)chars[curPos]] & 4) == 0 && chars[curPos] != ':')
				{
					if (curPos == charsUsed)
					{
						if (ReadDataInName())
						{
							continue;
						}
						Throw(curPos, "Xml_UnexpectedEOF", "Name");
					}
					else if (chars[curPos] != ':' || supportNamespaces)
					{
						Throw(curPos, "Xml_BadStartNameChar", XmlException.BuildCharExceptionStr(chars[curPos]));
					}
				}
				curPos++;
				while (true)
				{
					if ((xmlCharType.charProperties[(int)chars[curPos]] & 8u) != 0)
					{
						curPos++;
						continue;
					}
					if (chars[curPos] == ':')
					{
						if (isQName)
						{
							break;
						}
						curPos++;
						continue;
					}
					if (charsUsed - curPos == 0)
					{
						if (ReadDataInName())
						{
							continue;
						}
						if (tokenStartPos == curPos)
						{
							Throw(curPos, "Xml_UnexpectedEOF", "Name");
						}
					}
					colonPos = ((num == -1) ? (-1) : (tokenStartPos + num));
					return;
				}
				if (num != -1)
				{
					Throw(curPos, "Xml_BadNameChar", XmlException.BuildCharExceptionStr(':'));
				}
				num = curPos - tokenStartPos;
				curPos++;
			}
		}

		private bool ReadDataInName()
		{
			int num = curPos - tokenStartPos;
			curPos = tokenStartPos;
			bool result = ReadData() != 0;
			tokenStartPos = curPos;
			curPos += num;
			return result;
		}

		private unsafe void ScanNmtoken()
		{
			tokenStartPos = curPos;
			int num;
			while (true)
			{
				if ((xmlCharType.charProperties[(int)chars[curPos]] & 8u) != 0 || chars[curPos] == ':')
				{
					curPos++;
					continue;
				}
				if (chars[curPos] != 0)
				{
					if (curPos - tokenStartPos == 0)
					{
						Throw(curPos, "Xml_BadNameChar", XmlException.BuildCharExceptionStr(chars[curPos]));
					}
					return;
				}
				num = curPos - tokenStartPos;
				curPos = tokenStartPos;
				if (ReadData() == 0)
				{
					if (num > 0)
					{
						break;
					}
					Throw(curPos, "Xml_UnexpectedEOF", "NmToken");
				}
				tokenStartPos = curPos;
				curPos += num;
			}
			tokenStartPos = curPos;
			curPos += num;
		}

		private bool EatPublicKeyword()
		{
			while (charsUsed - curPos < 6)
			{
				if (ReadData() == 0)
				{
					return false;
				}
			}
			if (chars[curPos + 1] != 'U' || chars[curPos + 2] != 'B' || chars[curPos + 3] != 'L' || chars[curPos + 4] != 'I' || chars[curPos + 5] != 'C')
			{
				return false;
			}
			curPos += 6;
			return true;
		}

		private bool EatSystemKeyword()
		{
			while (charsUsed - curPos < 6)
			{
				if (ReadData() == 0)
				{
					return false;
				}
			}
			if (chars[curPos + 1] != 'Y' || chars[curPos + 2] != 'S' || chars[curPos + 3] != 'T' || chars[curPos + 4] != 'E' || chars[curPos + 5] != 'M')
			{
				return false;
			}
			curPos += 6;
			return true;
		}

		private XmlQualifiedName GetNameQualified(bool canHavePrefix)
		{
			if (colonPos == -1)
			{
				return new XmlQualifiedName(nameTable.Add(chars, tokenStartPos, curPos - tokenStartPos));
			}
			if (canHavePrefix)
			{
				return new XmlQualifiedName(nameTable.Add(chars, colonPos + 1, curPos - colonPos - 1), nameTable.Add(chars, tokenStartPos, colonPos - tokenStartPos));
			}
			Throw(tokenStartPos, "Xml_ColonInLocalName", GetNameString());
			return null;
		}

		private string GetNameString()
		{
			return new string(chars, tokenStartPos, curPos - tokenStartPos);
		}

		private string GetNmtokenString()
		{
			return GetNameString();
		}

		private string GetValue()
		{
			if (stringBuilder.Length == 0)
			{
				return new string(chars, tokenStartPos, curPos - tokenStartPos - 1);
			}
			return stringBuilder.ToString();
		}

		private string GetValueWithStrippedSpaces()
		{
			if (stringBuilder.Length == 0)
			{
				int len = curPos - tokenStartPos - 1;
				XmlComplianceUtil.StripSpaces(chars, tokenStartPos, ref len);
				return new string(chars, tokenStartPos, len);
			}
			return XmlComplianceUtil.StripSpaces(stringBuilder.ToString());
		}

		private int ReadData()
		{
			SaveParsingBuffer();
			int result = readerAdapter.ReadData();
			LoadParsingBuffer();
			return result;
		}

		private void LoadParsingBuffer()
		{
			chars = readerAdapter.ParsingBuffer;
			charsUsed = readerAdapter.ParsingBufferLength;
			curPos = readerAdapter.CurrentPosition;
		}

		private void SaveParsingBuffer()
		{
			SaveParsingBuffer(curPos);
		}

		private void SaveParsingBuffer(int internalSubsetValueEndPos)
		{
			if (SaveInternalSubsetValue)
			{
				int currentPosition = readerAdapter.CurrentPosition;
				if (internalSubsetValueEndPos - currentPosition > 0)
				{
					internalSubsetValueSb.Append(chars, currentPosition, internalSubsetValueEndPos - currentPosition);
				}
			}
			readerAdapter.CurrentPosition = curPos;
		}

		private bool HandleEntityReference(bool paramEntity, bool inLiteral, bool inAttribute)
		{
			curPos++;
			return HandleEntityReference(ScanEntityName(), paramEntity, inLiteral, inAttribute);
		}

		private bool HandleEntityReference(XmlQualifiedName entityName, bool paramEntity, bool inLiteral, bool inAttribute)
		{
			SaveParsingBuffer();
			if (paramEntity && ParsingInternalSubset && !ParsingTopLevelMarkup)
			{
				Throw(curPos - entityName.Name.Length - 1, "Xml_InvalidParEntityRef");
			}
			SchemaEntity schemaEntity = VerifyEntityReference(entityName, paramEntity, mustBeDeclared: true, inAttribute);
			if (schemaEntity == null)
			{
				return false;
			}
			if (schemaEntity.IsProcessed)
			{
				Throw(curPos - entityName.Name.Length - 1, paramEntity ? "Xml_RecursiveParEntity" : "Xml_RecursiveGenEntity", entityName.Name);
			}
			int entityId = nextEntityId++;
			if (schemaEntity.IsExternal)
			{
				if (!readerAdapter.PushEntity(schemaEntity, entityId))
				{
					return false;
				}
				externalEntitiesDepth++;
			}
			else
			{
				if (schemaEntity.Text.Length == 0)
				{
					return false;
				}
				if (!readerAdapter.PushEntity(schemaEntity, entityId))
				{
					return false;
				}
			}
			currentEntityId = entityId;
			if (paramEntity && !inLiteral && scanningFunction != ScanningFunction.ParamEntitySpace)
			{
				savedScanningFunction = scanningFunction;
				scanningFunction = ScanningFunction.ParamEntitySpace;
			}
			LoadParsingBuffer();
			return true;
		}

		private bool HandleEntityEnd(bool inLiteral)
		{
			SaveParsingBuffer();
			if (!readerAdapter.PopEntity(out var oldEntity, out currentEntityId))
			{
				return false;
			}
			LoadParsingBuffer();
			if (oldEntity == null)
			{
				if (scanningFunction == ScanningFunction.ParamEntitySpace)
				{
					scanningFunction = savedScanningFunction;
				}
				return false;
			}
			if (oldEntity.IsExternal)
			{
				externalEntitiesDepth--;
			}
			if (!inLiteral && scanningFunction != ScanningFunction.ParamEntitySpace)
			{
				savedScanningFunction = scanningFunction;
				scanningFunction = ScanningFunction.ParamEntitySpace;
			}
			return true;
		}

		private SchemaEntity VerifyEntityReference(XmlQualifiedName entityName, bool paramEntity, bool mustBeDeclared, bool inAttribute)
		{
			SchemaEntity schemaEntity = ((!paramEntity) ? ((SchemaEntity)schemaInfo.GeneralEntities[entityName]) : ((SchemaEntity)schemaInfo.ParameterEntities[entityName]));
			if (schemaEntity == null)
			{
				if (paramEntity)
				{
					if (validate)
					{
						SendValidationEvent(curPos - entityName.Name.Length - 1, XmlSeverityType.Error, "Xml_UndeclaredParEntity", entityName.Name);
					}
				}
				else if (mustBeDeclared)
				{
					if (!ParsingInternalSubset)
					{
						SendValidationEvent(curPos - entityName.Name.Length - 1, XmlSeverityType.Error, "Xml_UndeclaredEntity", entityName.Name);
					}
					else
					{
						Throw(curPos - entityName.Name.Length - 1, "Xml_UndeclaredEntity", entityName.Name);
					}
				}
				return null;
			}
			if (!schemaEntity.NData.IsEmpty)
			{
				Throw(curPos - entityName.Name.Length - 1, "Xml_UnparsedEntityRef", entityName.Name);
			}
			if (inAttribute && schemaEntity.IsExternal)
			{
				Throw(curPos - entityName.Name.Length - 1, "Xml_ExternalEntityInAttValue", entityName.Name);
			}
			return schemaEntity;
		}

		private void SendValidationEvent(int pos, XmlSeverityType severity, string code, string arg)
		{
			SendValidationEvent(severity, new XmlSchemaException(code, arg, BaseUriStr, LineNo, LinePos + (pos - curPos)));
		}

		private void SendValidationEvent(XmlSeverityType severity, string code, string arg)
		{
			SendValidationEvent(severity, new XmlSchemaException(code, arg, BaseUriStr, LineNo, LinePos));
		}

		private void SendValidationEvent(XmlSeverityType severity, XmlSchemaException e)
		{
			readerAdapter.SendValidationEvent(severity, e);
		}

		private bool IsAttributeValueType(Token token)
		{
			if (token >= Token.CDATA)
			{
				return token <= Token.NOTATION;
			}
			return false;
		}

		private void OnUnexpectedError()
		{
			Throw(curPos, "Xml_InternalError");
		}

		private void Throw(int curPos, string res)
		{
			Throw(curPos, res, string.Empty);
		}

		private void Throw(int curPos, string res, string arg)
		{
			this.curPos = curPos;
			Uri baseUri = readerAdapter.BaseUri;
			readerAdapter.Throw(new XmlException(res, arg, LineNo, LinePos, (baseUri == null) ? null : baseUri.ToString()));
		}

		private void Throw(int curPos, string res, string[] args)
		{
			this.curPos = curPos;
			Uri baseUri = readerAdapter.BaseUri;
			readerAdapter.Throw(new XmlException(res, args, LineNo, LinePos, (baseUri == null) ? null : baseUri.ToString()));
		}

		private void Throw(string res, string arg, int lineNo, int linePos)
		{
			Uri baseUri = readerAdapter.BaseUri;
			readerAdapter.Throw(new XmlException(res, arg, lineNo, linePos, (baseUri == null) ? null : baseUri.ToString()));
		}

		private void ThrowInvalidChar(int pos, char invChar)
		{
			Throw(pos, "Xml_InvalidCharacter", XmlException.BuildCharExceptionStr(invChar));
		}

		private void ThrowUnexpectedToken(int pos, string expectedToken)
		{
			ThrowUnexpectedToken(pos, expectedToken, null);
		}

		private void ThrowUnexpectedToken(int pos, string expectedToken1, string expectedToken2)
		{
			string text = ParseUnexpectedToken(pos);
			if (expectedToken2 != null)
			{
				Throw(curPos, "Xml_UnexpectedTokens2", new string[3] { text, expectedToken1, expectedToken2 });
			}
			else
			{
				Throw(curPos, "Xml_UnexpectedTokenEx", new string[2] { text, expectedToken1 });
			}
		}

		private string ParseUnexpectedToken(int startPos)
		{
			if (xmlCharType.IsNCNameChar(chars[startPos]))
			{
				int i;
				for (i = startPos + 1; xmlCharType.IsNCNameChar(chars[i]); i++)
				{
				}
				return new string(chars, startPos, i - startPos);
			}
			return new string(chars, startPos, 1);
		}
	}
}
namespace System.Xml.Schema
{
	internal sealed class DtdValidator : BaseValidator
	{
		private class NamespaceManager : XmlNamespaceManager
		{
			public override string LookupNamespace(string prefix)
			{
				return prefix;
			}
		}

		private const int STACK_INCREMENT = 10;

		private static NamespaceManager namespaceManager = new NamespaceManager();

		private HWStack validationStack;

		private Hashtable attPresence;

		private XmlQualifiedName name = XmlQualifiedName.Empty;

		private Hashtable IDs;

		private IdRefNode idRefListHead;

		private bool processIdentityConstraints;

		public override bool PreserveWhitespace
		{
			get
			{
				if (context.ElementDecl == null)
				{
					return false;
				}
				return context.ElementDecl.ContentValidator.PreserveWhitespace;
			}
		}

		internal DtdValidator(XmlValidatingReaderImpl reader, ValidationEventHandler eventHandler, bool processIdentityConstraints)
			: base(reader, null, eventHandler)
		{
			this.processIdentityConstraints = processIdentityConstraints;
			Init();
		}

		private void Init()
		{
			validationStack = new HWStack(10);
			textValue = new StringBuilder();
			name = XmlQualifiedName.Empty;
			attPresence = new Hashtable();
			schemaInfo = new SchemaInfo();
			checkDatatype = false;
			Push(name);
		}

		public override void Validate()
		{
			if (schemaInfo.SchemaType == SchemaType.DTD)
			{
				switch (reader.NodeType)
				{
				case XmlNodeType.Element:
					ValidateElement();
					if (reader.IsEmptyElement)
					{
						goto case XmlNodeType.EndElement;
					}
					break;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					if (MeetsStandAloneConstraint())
					{
						ValidateWhitespace();
					}
					break;
				case XmlNodeType.ProcessingInstruction:
				case XmlNodeType.Comment:
					ValidatePIComment();
					break;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
					ValidateText();
					break;
				case XmlNodeType.EntityReference:
					if (!GenEntity(new XmlQualifiedName(reader.LocalName, reader.Prefix)))
					{
						ValidateText();
					}
					break;
				case XmlNodeType.EndElement:
					ValidateEndElement();
					break;
				case XmlNodeType.Attribute:
				case XmlNodeType.Entity:
				case XmlNodeType.Document:
				case XmlNodeType.DocumentType:
				case XmlNodeType.DocumentFragment:
				case XmlNodeType.Notation:
					break;
				}
			}
			else if (reader.Depth == 0 && reader.NodeType == XmlNodeType.Element)
			{
				SendValidationEvent("Xml_NoDTDPresent", name.ToString(), XmlSeverityType.Warning);
			}
		}

		private bool MeetsStandAloneConstraint()
		{
			if (reader.StandAlone && context.ElementDecl != null && context.ElementDecl.IsDeclaredInExternal && context.ElementDecl.ContentValidator.ContentType == XmlSchemaContentType.ElementOnly)
			{
				SendValidationEvent("Sch_StandAlone");
				return false;
			}
			return true;
		}

		private void ValidatePIComment()
		{
			if (context.NeedValidateChildren && context.ElementDecl.ContentValidator == ContentValidator.Empty)
			{
				SendValidationEvent("Sch_InvalidPIComment");
			}
		}

		private void ValidateElement()
		{
			elementName.Init(reader.LocalName, reader.Prefix);
			if (reader.Depth == 0 && !schemaInfo.DocTypeName.IsEmpty && !schemaInfo.DocTypeName.Equals(elementName))
			{
				SendValidationEvent("Sch_RootMatchDocType");
			}
			else
			{
				ValidateChildElement();
			}
			ProcessElement();
		}

		private void ValidateChildElement()
		{
			if (context.NeedValidateChildren)
			{
				int errorCode = 0;
				context.ElementDecl.ContentValidator.ValidateElement(elementName, context, out errorCode);
				if (errorCode < 0)
				{
					XmlSchemaValidator.ElementValidationError(elementName, context, base.EventHandler, reader, reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition, getParticles: false);
				}
			}
		}

		private void ValidateStartElement()
		{
			if (context.ElementDecl != null)
			{
				base.Reader.SchemaTypeObject = context.ElementDecl.SchemaType;
				if (base.Reader.IsEmptyElement && context.ElementDecl.DefaultValueTyped != null)
				{
					base.Reader.TypedValueObject = context.ElementDecl.DefaultValueTyped;
					context.IsNill = true;
				}
				if (context.ElementDecl.HasRequiredAttribute)
				{
					attPresence.Clear();
				}
			}
			if (!base.Reader.MoveToFirstAttribute())
			{
				return;
			}
			do
			{
				try
				{
					reader.SchemaTypeObject = null;
					SchemaAttDef attDef = context.ElementDecl.GetAttDef(new XmlQualifiedName(reader.LocalName, reader.Prefix));
					if (attDef != null)
					{
						if (context.ElementDecl != null && context.ElementDecl.HasRequiredAttribute)
						{
							attPresence.Add(attDef.Name, attDef);
						}
						base.Reader.SchemaTypeObject = attDef.SchemaType;
						if (attDef.Datatype != null && !reader.IsDefault)
						{
							CheckValue(base.Reader.Value, attDef);
						}
					}
					else
					{
						SendValidationEvent("Sch_UndeclaredAttribute", reader.Name);
					}
				}
				catch (XmlSchemaException ex)
				{
					ex.SetSource(base.Reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
					SendValidationEvent(ex);
				}
			}
			while (base.Reader.MoveToNextAttribute());
			base.Reader.MoveToElement();
		}

		private void ValidateEndStartElement()
		{
			if (context.ElementDecl.HasRequiredAttribute)
			{
				try
				{
					context.ElementDecl.CheckAttributes(attPresence, base.Reader.StandAlone);
				}
				catch (XmlSchemaException ex)
				{
					ex.SetSource(base.Reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
					SendValidationEvent(ex);
				}
			}
			if (context.ElementDecl.Datatype != null)
			{
				checkDatatype = true;
				hasSibling = false;
				textString = string.Empty;
				textValue.Length = 0;
			}
		}

		private void ProcessElement()
		{
			SchemaElementDecl elementDecl = schemaInfo.GetElementDecl(elementName);
			Push(elementName);
			if (elementDecl != null)
			{
				context.ElementDecl = elementDecl;
				ValidateStartElement();
				ValidateEndStartElement();
				context.NeedValidateChildren = true;
				elementDecl.ContentValidator.InitValidation(context);
			}
			else
			{
				SendValidationEvent("Sch_UndeclaredElement", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
				context.ElementDecl = null;
			}
		}

		public override void CompleteValidation()
		{
			if (schemaInfo.SchemaType == SchemaType.DTD)
			{
				do
				{
					ValidateEndElement();
				}
				while (Pop());
				CheckForwardRefs();
			}
		}

		private void ValidateEndElement()
		{
			if (context.ElementDecl != null)
			{
				if (context.NeedValidateChildren && !context.ElementDecl.ContentValidator.CompleteValidation(context))
				{
					XmlSchemaValidator.CompleteValidationError(context, base.EventHandler, reader, reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition, getParticles: false);
				}
				if (checkDatatype)
				{
					string value = ((!hasSibling) ? textString : textValue.ToString());
					CheckValue(value, null);
					checkDatatype = false;
					textValue.Length = 0;
					textString = string.Empty;
				}
			}
			Pop();
		}

		private void ProcessTokenizedType(XmlTokenizedType ttype, string name)
		{
			switch (ttype)
			{
			case XmlTokenizedType.ID:
				if (processIdentityConstraints)
				{
					if (FindId(name) != null)
					{
						SendValidationEvent("Sch_DupId", name);
					}
					else
					{
						AddID(name, context.LocalName);
					}
				}
				break;
			case XmlTokenizedType.IDREF:
				if (processIdentityConstraints)
				{
					object obj = FindId(name);
					if (obj == null)
					{
						idRefListHead = new IdRefNode(idRefListHead, name, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
					}
				}
				break;
			case XmlTokenizedType.ENTITY:
				BaseValidator.ProcessEntity(schemaInfo, name, this, base.EventHandler, base.Reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
				break;
			case XmlTokenizedType.IDREFS:
				break;
			}
		}

		private void CheckValue(string value, SchemaAttDef attdef)
		{
			try
			{
				reader.TypedValueObject = null;
				bool flag = attdef != null;
				XmlSchemaDatatype xmlSchemaDatatype = (flag ? attdef.Datatype : context.ElementDecl.Datatype);
				if (xmlSchemaDatatype == null)
				{
					return;
				}
				if (xmlSchemaDatatype.TokenizedType != 0)
				{
					value = value.Trim();
				}
				object obj = xmlSchemaDatatype.ParseValue(value, base.NameTable, namespaceManager);
				reader.TypedValueObject = obj;
				XmlTokenizedType tokenizedType = xmlSchemaDatatype.TokenizedType;
				if (tokenizedType == XmlTokenizedType.ENTITY || tokenizedType == XmlTokenizedType.ID || tokenizedType == XmlTokenizedType.IDREF)
				{
					if (xmlSchemaDatatype.Variety == XmlSchemaDatatypeVariety.List)
					{
						string[] array = (string[])obj;
						string[] array2 = array;
						foreach (string text in array2)
						{
							ProcessTokenizedType(xmlSchemaDatatype.TokenizedType, text);
						}
					}
					else
					{
						ProcessTokenizedType(xmlSchemaDatatype.TokenizedType, (string)obj);
					}
				}
				SchemaDeclBase schemaDeclBase = (flag ? ((SchemaDeclBase)attdef) : ((SchemaDeclBase)context.ElementDecl));
				if (schemaDeclBase.Values != null && !schemaDeclBase.CheckEnumeration(obj))
				{
					if (xmlSchemaDatatype.TokenizedType == XmlTokenizedType.NOTATION)
					{
						SendValidationEvent("Sch_NotationValue", obj.ToString());
					}
					else
					{
						SendValidationEvent("Sch_EnumerationValue", obj.ToString());
					}
				}
				if (!schemaDeclBase.CheckValue(obj))
				{
					if (flag)
					{
						SendValidationEvent("Sch_FixedAttributeValue", attdef.Name.ToString());
					}
					else
					{
						SendValidationEvent("Sch_FixedElementValue", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
					}
				}
			}
			catch (XmlSchemaException)
			{
				if (attdef != null)
				{
					SendValidationEvent("Sch_AttributeValueDataType", attdef.Name.ToString());
				}
				else
				{
					SendValidationEvent("Sch_ElementValueDataType", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
				}
			}
		}

		internal void AddID(string name, object node)
		{
			if (IDs == null)
			{
				IDs = new Hashtable();
			}
			IDs.Add(name, node);
		}

		public override object FindId(string name)
		{
			if (IDs != null)
			{
				return IDs[name];
			}
			return null;
		}

		private bool GenEntity(XmlQualifiedName qname)
		{
			string text = qname.Name;
			if (text[0] == '#')
			{
				return false;
			}
			if (SchemaEntity.IsPredefinedEntity(text))
			{
				return false;
			}
			SchemaEntity entity = GetEntity(qname, fParameterEntity: false);
			if (entity == null)
			{
				throw new XmlException("Xml_UndeclaredEntity", text);
			}
			if (!entity.NData.IsEmpty)
			{
				throw new XmlException("Xml_UnparsedEntityRef", text);
			}
			if (reader.StandAlone && entity.DeclaredInExternal)
			{
				SendValidationEvent("Sch_StandAlone");
			}
			return true;
		}

		private SchemaEntity GetEntity(XmlQualifiedName qname, bool fParameterEntity)
		{
			if (fParameterEntity)
			{
				return (SchemaEntity)schemaInfo.ParameterEntities[qname];
			}
			return (SchemaEntity)schemaInfo.GeneralEntities[qname];
		}

		private void CheckForwardRefs()
		{
			IdRefNode idRefNode = idRefListHead;
			while (idRefNode != null)
			{
				if (FindId(idRefNode.Id) == null)
				{
					SendValidationEvent(new XmlSchemaException("Sch_UndeclaredId", idRefNode.Id, reader.BaseURI, idRefNode.LineNo, idRefNode.LinePos));
				}
				IdRefNode next = idRefNode.Next;
				idRefNode.Next = null;
				idRefNode = next;
			}
			idRefListHead = null;
		}

		private void Push(XmlQualifiedName elementName)
		{
			context = (ValidationState)validationStack.Push();
			if (context == null)
			{
				context = new ValidationState();
				validationStack.AddToTop(context);
			}
			context.LocalName = elementName.Name;
			context.Namespace = elementName.Namespace;
			context.HasMatched = false;
			context.IsNill = false;
			context.NeedValidateChildren = false;
		}

		private bool Pop()
		{
			if (validationStack.Length > 1)
			{
				validationStack.Pop();
				context = (ValidationState)validationStack.Peek();
				return true;
			}
			return false;
		}

		public static void SetDefaultTypedValue(SchemaAttDef attdef, IDtdParserAdapter readerAdapter)
		{
			try
			{
				string text = attdef.DefaultValueExpanded;
				XmlSchemaDatatype datatype = attdef.Datatype;
				if (datatype != null)
				{
					if (datatype.TokenizedType != 0)
					{
						text = text.Trim();
					}
					attdef.DefaultValueTyped = datatype.ParseValue(text, readerAdapter.NameTable, readerAdapter.NamespaceManager);
				}
			}
			catch (Exception)
			{
				XmlSchemaException exception = new XmlSchemaException("Sch_AttributeDefaultDataType", attdef.Name.ToString());
				readerAdapter.SendValidationEvent(XmlSeverityType.Error, exception);
			}
		}

		public static void CheckDefaultValue(SchemaAttDef attdef, SchemaInfo sinfo, IDtdParserAdapter readerAdapter)
		{
			try
			{
				XmlSchemaDatatype datatype = attdef.Datatype;
				if (datatype == null)
				{
					return;
				}
				object defaultValueTyped = attdef.DefaultValueTyped;
				switch (datatype.TokenizedType)
				{
				case XmlTokenizedType.ENTITY:
				{
					Uri uri = readerAdapter.BaseUri;
					string text = ((uri == null) ? string.Empty : uri.ToString());
					if (datatype.Variety == XmlSchemaDatatypeVariety.List)
					{
						string[] array = (string[])defaultValueTyped;
						string[] array2 = array;
						foreach (string text2 in array2)
						{
							BaseValidator.ProcessEntity(sinfo, text2, readerAdapter, readerAdapter.EventHandler, text, attdef.ValueLineNum, attdef.ValueLinePos);
						}
					}
					else
					{
						BaseValidator.ProcessEntity(sinfo, (string)defaultValueTyped, readerAdapter, readerAdapter.EventHandler, text, attdef.ValueLineNum, attdef.ValueLinePos);
					}
					break;
				}
				case XmlTokenizedType.ENUMERATION:
					if (!attdef.CheckEnumeration(defaultValueTyped))
					{
						XmlSchemaException exception = new XmlSchemaException("Sch_EnumerationValue", defaultValueTyped.ToString(), readerAdapter.BaseUri.ToString(), attdef.ValueLineNum, attdef.ValueLinePos);
						readerAdapter.SendValidationEvent(XmlSeverityType.Error, exception);
					}
					break;
				}
			}
			catch (Exception)
			{
				XmlSchemaException exception2 = new XmlSchemaException("Sch_AttributeDefaultDataType", attdef.Name.ToString());
				readerAdapter.SendValidationEvent(XmlSeverityType.Error, exception2);
			}
		}
	}
	internal abstract class FacetsChecker
	{
		private struct FacetsCompiler
		{
			private struct Map
			{
				internal char match;

				internal string replacement;

				internal Map(char m, string r)
				{
					match = m;
					replacement = r;
				}
			}

			private DatatypeImplementation datatype;

			private RestrictionFacets derivedRestriction;

			private RestrictionFlags baseFlags;

			private RestrictionFlags baseFixedFlags;

			private RestrictionFlags validRestrictionFlags;

			private XmlSchemaDatatype nonNegativeInt;

			private XmlSchemaDatatype builtInType;

			private XmlTypeCode builtInEnum;

			private bool firstPattern;

			private StringBuilder regStr;

			private XmlSchemaPatternFacet pattern_facet;

			private static readonly Map[] c_map = new Map[8]
			{
				new Map('c', "\\p{_xmlC}"),
				new Map('C', "\\P{_xmlC}"),
				new Map('d', "\\p{_xmlD}"),
				new Map('D', "\\P{_xmlD}"),
				new Map('i', "\\p{_xmlI}"),
				new Map('I', "\\P{_xmlI}"),
				new Map('w', "\\p{_xmlW}"),
				new Map('W', "\\P{_xmlW}")
			};

			public FacetsCompiler(DatatypeImplementation baseDatatype, RestrictionFacets restriction)
			{
				firstPattern = true;
				regStr = null;
				pattern_facet = null;
				datatype = baseDatatype;
				derivedRestriction = restriction;
				baseFlags = ((datatype.Restriction != null) ? datatype.Restriction.Flags : ((RestrictionFlags)0));
				baseFixedFlags = ((datatype.Restriction != null) ? datatype.Restriction.FixedFlags : ((RestrictionFlags)0));
				validRestrictionFlags = datatype.ValidRestrictionFlags;
				nonNegativeInt = DatatypeImplementation.GetSimpleTypeFromTypeCode(XmlTypeCode.NonNegativeInteger).Datatype;
				builtInEnum = ((!(datatype is Datatype_union) && !(datatype is Datatype_List)) ? datatype.TypeCode : XmlTypeCode.None);
				builtInType = ((builtInEnum > XmlTypeCode.None) ? DatatypeImplementation.GetSimpleTypeFromTypeCode(builtInEnum).Datatype : datatype);
			}

			internal void CompileLengthFacet(XmlSchemaFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.Length, "Sch_LengthFacetProhibited");
				CheckDupFlag(facet, RestrictionFlags.Length, "Sch_DupLengthFacet");
				derivedRestriction.Length = XmlBaseConverter.DecimalToInt32((decimal)ParseFacetValue(nonNegativeInt, facet, "Sch_LengthFacetInvalid", null, null));
				if ((baseFixedFlags & RestrictionFlags.Length) != 0 && !datatype.IsEqual(datatype.Restriction.Length, derivedRestriction.Length))
				{
					throw new XmlSchemaException("Sch_FacetBaseFixed", facet);
				}
				if ((baseFlags & RestrictionFlags.Length) != 0 && datatype.Restriction.Length < derivedRestriction.Length)
				{
					throw new XmlSchemaException("Sch_LengthGtBaseLength", facet);
				}
				if (((baseFlags & RestrictionFlags.MinLength) != 0 || (baseFlags & RestrictionFlags.MaxLength) != 0) && (datatype.Restriction.MaxLength < derivedRestriction.Length || datatype.Restriction.MinLength > derivedRestriction.Length))
				{
					throw new XmlSchemaException("Sch_MaxMinLengthBaseLength", facet);
				}
				SetFlag(facet, RestrictionFlags.Length);
			}

			internal void CompileMinLengthFacet(XmlSchemaFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.MinLength, "Sch_MinLengthFacetProhibited");
				CheckDupFlag(facet, RestrictionFlags.MinLength, "Sch_DupMinLengthFacet");
				derivedRestriction.MinLength = XmlBaseConverter.DecimalToInt32((decimal)ParseFacetValue(nonNegativeInt, facet, "Sch_MinLengthFacetInvalid", null, null));
				if ((baseFixedFlags & RestrictionFlags.MinLength) != 0 && !datatype.IsEqual(datatype.Restriction.MinLength, derivedRestriction.MinLength))
				{
					throw new XmlSchemaException("Sch_FacetBaseFixed", facet);
				}
				if ((baseFlags & RestrictionFlags.MinLength) != 0 && datatype.Restriction.MinLength > derivedRestriction.MinLength)
				{
					throw new XmlSchemaException("Sch_MinLengthGtBaseMinLength", facet);
				}
				if ((baseFlags & RestrictionFlags.Length) != 0 && datatype.Restriction.Length < derivedRestriction.MinLength)
				{
					throw new XmlSchemaException("Sch_MaxMinLengthBaseLength", facet);
				}
				SetFlag(facet, RestrictionFlags.MinLength);
			}

			internal void CompileMaxLengthFacet(XmlSchemaFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.MaxLength, "Sch_MaxLengthFacetProhibited");
				CheckDupFlag(facet, RestrictionFlags.MaxLength, "Sch_DupMaxLengthFacet");
				derivedRestriction.MaxLength = XmlBaseConverter.DecimalToInt32((decimal)ParseFacetValue(nonNegativeInt, facet, "Sch_MaxLengthFacetInvalid", null, null));
				if ((baseFixedFlags & RestrictionFlags.MaxLength) != 0 && !datatype.IsEqual(datatype.Restriction.MaxLength, derivedRestriction.MaxLength))
				{
					throw new XmlSchemaException("Sch_FacetBaseFixed", facet);
				}
				if ((baseFlags & RestrictionFlags.MaxLength) != 0 && datatype.Restriction.MaxLength < derivedRestriction.MaxLength)
				{
					throw new XmlSchemaException("Sch_MaxLengthGtBaseMaxLength", facet);
				}
				if ((baseFlags & RestrictionFlags.Length) != 0 && datatype.Restriction.Length > derivedRestriction.MaxLength)
				{
					throw new XmlSchemaException("Sch_MaxMinLengthBaseLength", facet);
				}
				SetFlag(facet, RestrictionFlags.MaxLength);
			}

			internal void CompilePatternFacet(XmlSchemaPatternFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.Pattern, "Sch_PatternFacetProhibited");
				if (firstPattern)
				{
					regStr = new StringBuilder();
					regStr.Append("(");
					regStr.Append(facet.Value);
					pattern_facet = new XmlSchemaPatternFacet();
					pattern_facet = facet;
					firstPattern = false;
				}
				else
				{
					regStr.Append(")|(");
					regStr.Append(facet.Value);
				}
				SetFlag(facet, RestrictionFlags.Pattern);
			}

			internal void CompileEnumerationFacet(XmlSchemaFacet facet, IXmlNamespaceResolver nsmgr, XmlNameTable nameTable)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.Enumeration, "Sch_EnumerationFacetProhibited");
				if (derivedRestriction.Enumeration == null)
				{
					derivedRestriction.Enumeration = new ArrayList();
				}
				derivedRestriction.Enumeration.Add(ParseFacetValue(datatype, facet, "Sch_EnumerationFacetInvalid", nsmgr, nameTable));
				SetFlag(facet, RestrictionFlags.Enumeration);
			}

			internal void CompileWhitespaceFacet(XmlSchemaFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.WhiteSpace, "Sch_WhiteSpaceFacetProhibited");
				CheckDupFlag(facet, RestrictionFlags.WhiteSpace, "Sch_DupWhiteSpaceFacet");
				if (facet.Value == "preserve")
				{
					derivedRestriction.WhiteSpace = XmlSchemaWhiteSpace.Preserve;
				}
				else if (facet.Value == "replace")
				{
					derivedRestriction.WhiteSpace = XmlSchemaWhiteSpace.Replace;
				}
				else
				{
					if (!(facet.Value == "collapse"))
					{
						throw new XmlSchemaException("Sch_InvalidWhiteSpace", facet.Value, facet);
					}
					derivedRestriction.WhiteSpace = XmlSchemaWhiteSpace.Collapse;
				}
				if ((baseFixedFlags & RestrictionFlags.WhiteSpace) != 0 && !datatype.IsEqual(datatype.Restriction.WhiteSpace, derivedRestriction.WhiteSpace))
				{
					throw new XmlSchemaException("Sch_FacetBaseFixed", facet);
				}
				XmlSchemaWhiteSpace xmlSchemaWhiteSpace = (((baseFlags & RestrictionFlags.WhiteSpace) == 0) ? datatype.BuiltInWhitespaceFacet : datatype.Restriction.WhiteSpace);
				if (xmlSchemaWhiteSpace == XmlSchemaWhiteSpace.Collapse && (derivedRestriction.WhiteSpace == XmlSchemaWhiteSpace.Replace || derivedRestriction.WhiteSpace == XmlSchemaWhiteSpace.Preserve))
				{
					throw new XmlSchemaException("Sch_WhiteSpaceRestriction1", facet);
				}
				if (xmlSchemaWhiteSpace == XmlSchemaWhiteSpace.Replace && derivedRestriction.WhiteSpace == XmlSchemaWhiteSpace.Preserve)
				{
					throw new XmlSchemaException("Sch_WhiteSpaceRestriction2", facet);
				}
				SetFlag(facet, RestrictionFlags.WhiteSpace);
			}

			internal void CompileMaxInclusiveFacet(XmlSchemaFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.MaxInclusive, "Sch_MaxInclusiveFacetProhibited");
				CheckDupFlag(facet, RestrictionFlags.MaxInclusive, "Sch_DupMaxInclusiveFacet");
				derivedRestriction.MaxInclusive = ParseFacetValue(builtInType, facet, "Sch_MaxInclusiveFacetInvalid", null, null);
				if ((baseFixedFlags & RestrictionFlags.MaxInclusive) != 0 && !datatype.IsEqual(datatype.Restriction.MaxInclusive, derivedRestriction.MaxInclusive))
				{
					throw new XmlSchemaException("Sch_FacetBaseFixed", facet);
				}
				CheckValue(derivedRestriction.MaxInclusive, facet);
				SetFlag(facet, RestrictionFlags.MaxInclusive);
			}

			internal void CompileMaxExclusiveFacet(XmlSchemaFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.MaxExclusive, "Sch_MaxExclusiveFacetProhibited");
				CheckDupFlag(facet, RestrictionFlags.MaxExclusive, "Sch_DupMaxExclusiveFacet");
				derivedRestriction.MaxExclusive = ParseFacetValue(builtInType, facet, "Sch_MaxExclusiveFacetInvalid", null, null);
				if ((baseFixedFlags & RestrictionFlags.MaxExclusive) != 0 && !datatype.IsEqual(datatype.Restriction.MaxExclusive, derivedRestriction.MaxExclusive))
				{
					throw new XmlSchemaException("Sch_FacetBaseFixed", facet);
				}
				CheckValue(derivedRestriction.MaxExclusive, facet);
				SetFlag(facet, RestrictionFlags.MaxExclusive);
			}

			internal void CompileMinInclusiveFacet(XmlSchemaFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.MinInclusive, "Sch_MinInclusiveFacetProhibited");
				CheckDupFlag(facet, RestrictionFlags.MinInclusive, "Sch_DupMinInclusiveFacet");
				derivedRestriction.MinInclusive = ParseFacetValue(builtInType, facet, "Sch_MinInclusiveFacetInvalid", null, null);
				if ((baseFixedFlags & RestrictionFlags.MinInclusive) != 0 && !datatype.IsEqual(datatype.Restriction.MinInclusive, derivedRestriction.MinInclusive))
				{
					throw new XmlSchemaException("Sch_FacetBaseFixed", facet);
				}
				CheckValue(derivedRestriction.MinInclusive, facet);
				SetFlag(facet, RestrictionFlags.MinInclusive);
			}

			internal void CompileMinExclusiveFacet(XmlSchemaFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.MinExclusive, "Sch_MinExclusiveFacetProhibited");
				CheckDupFlag(facet, RestrictionFlags.MinExclusive, "Sch_DupMinExclusiveFacet");
				derivedRestriction.MinExclusive = ParseFacetValue(builtInType, facet, "Sch_MinExclusiveFacetInvalid", null, null);
				if ((baseFixedFlags & RestrictionFlags.MinExclusive) != 0 && !datatype.IsEqual(datatype.Restriction.MinExclusive, derivedRestriction.MinExclusive))
				{
					throw new XmlSchemaException("Sch_FacetBaseFixed", facet);
				}
				CheckValue(derivedRestriction.MinExclusive, facet);
				SetFlag(facet, RestrictionFlags.MinExclusive);
			}

			internal void CompileTotalDigitsFacet(XmlSchemaFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.TotalDigits, "Sch_TotalDigitsFacetProhibited");
				CheckDupFlag(facet, RestrictionFlags.TotalDigits, "Sch_DupTotalDigitsFacet");
				XmlSchemaDatatype xmlSchemaDatatype = DatatypeImplementation.GetSimpleTypeFromTypeCode(XmlTypeCode.PositiveInteger).Datatype;
				derivedRestriction.TotalDigits = XmlBaseConverter.DecimalToInt32((decimal)ParseFacetValue(xmlSchemaDatatype, facet, "Sch_TotalDigitsFacetInvalid", null, null));
				if ((baseFixedFlags & RestrictionFlags.TotalDigits) != 0 && !datatype.IsEqual(datatype.Restriction.TotalDigits, derivedRestriction.TotalDigits))
				{
					throw new XmlSchemaException("Sch_FacetBaseFixed", facet);
				}
				if ((baseFlags & RestrictionFlags.TotalDigits) != 0 && derivedRestriction.TotalDigits > datatype.Restriction.TotalDigits)
				{
					throw new XmlSchemaException("Sch_TotalDigitsMismatch", string.Empty);
				}
				SetFlag(facet, RestrictionFlags.TotalDigits);
			}

			internal void CompileFractionDigitsFacet(XmlSchemaFacet facet)
			{
				CheckProhibitedFlag(facet, RestrictionFlags.FractionDigits, "Sch_FractionDigitsFacetProhibited");
				CheckDupFlag(facet, RestrictionFlags.FractionDigits, "Sch_DupFractionDigitsFacet");
				derivedRestriction.FractionDigits = XmlBaseConverter.DecimalToInt32((decimal)ParseFacetValue(nonNegativeInt, facet, "Sch_FractionDigitsFacetInvalid", null, null));
				if (derivedRestriction.FractionDigits != 0 && datatype.TypeCode != XmlTypeCode.Decimal)
				{
					throw new XmlSchemaException("Sch_FractionDigitsFacetInvalid", Res.GetString("Sch_FractionDigitsNotOnDecimal"), facet);
				}
				if ((baseFlags & RestrictionFlags.FractionDigits) != 0 && derivedRestriction.FractionDigits > datatype.Restriction.FractionDigits)
				{
					throw new XmlSchemaException("Sch_TotalDigitsMismatch", string.Empty);
				}
				SetFlag(facet, RestrictionFlags.FractionDigits);
			}

			internal void FinishFacetCompile()
			{
				if (firstPattern)
				{
					return;
				}
				if (derivedRestriction.Patterns == null)
				{
					derivedRestriction.Patterns = new ArrayList();
				}
				try
				{
					regStr.Append(")");
					string text = regStr.ToString();
					if (text.IndexOf('|') != -1)
					{
						regStr.Insert(0, "(");
						regStr.Append(")");
					}
					derivedRestriction.Patterns.Add(new Regex(Preprocess(regStr.ToString()), RegexOptions.None));
				}
				catch (Exception ex)
				{
					throw new XmlSchemaException("Sch_PatternFacetInvalid", ex.Message, pattern_facet);
				}
			}

			private void CheckValue(object value, XmlSchemaFacet facet)
			{
				RestrictionFacets restriction = datatype.Restriction;
				switch (facet.FacetType)
				{
				case FacetType.MaxInclusive:
					if ((baseFlags & RestrictionFlags.MaxInclusive) != 0 && datatype.Compare(value, restriction.MaxInclusive) > 0)
					{
						throw new XmlSchemaException("Sch_MaxInclusiveMismatch", string.Empty);
					}
					if ((baseFlags & RestrictionFlags.MaxExclusive) != 0 && datatype.Compare(value, restriction.MaxExclusive) >= 0)
					{
						throw new XmlSchemaException("Sch_MaxIncExlMismatch", string.Empty);
					}
					break;
				case FacetType.MaxExclusive:
					if ((baseFlags & RestrictionFlags.MaxExclusive) != 0 && datatype.Compare(value, restriction.MaxExclusive) > 0)
					{
						throw new XmlSchemaException("Sch_MaxExclusiveMismatch", string.Empty);
					}
					if ((baseFlags & RestrictionFlags.MaxInclusive) != 0 && datatype.Compare(value, restriction.MaxInclusive) > 0)
					{
						throw new XmlSchemaException("Sch_MaxExlIncMismatch", string.Empty);
					}
					break;
				case FacetType.MinInclusive:
					if ((baseFlags & RestrictionFlags.MinInclusive) != 0 && datatype.Compare(value, restriction.MinInclusive) < 0)
					{
						throw new XmlSchemaException("Sch_MinInclusiveMismatch", string.Empty);
					}
					if ((baseFlags & RestrictionFlags.MinExclusive) != 0 && datatype.Compare(value, restriction.MinExclusive) < 0)
					{
						throw new XmlSchemaException("Sch_MinIncExlMismatch", string.Empty);
					}
					if ((baseFlags & RestrictionFlags.MaxExclusive) != 0 && datatype.Compare(value, restriction.MaxExclusive) >= 0)
					{
						throw new XmlSchemaException("Sch_MinIncMaxExlMismatch", string.Empty);
					}
					break;
				case FacetType.MinExclusive:
					if ((baseFlags & RestrictionFlags.MinExclusive) != 0 && datatype.Compare(value, restriction.MinExclusive) < 0)
					{
						throw new XmlSchemaException("Sch_MinExclusiveMismatch", string.Empty);
					}
					if ((baseFlags & RestrictionFlags.MinInclusive) != 0 && datatype.Compare(value, restriction.MinInclusive) < 0)
					{
						throw new XmlSchemaException("Sch_MinExlIncMismatch", string.Empty);
					}
					if ((baseFlags & RestrictionFlags.MaxExclusive) != 0 && datatype.Compare(value, restriction.MaxExclusive) >= 0)
					{
						throw new XmlSchemaException("Sch_MinExlMaxExlMismatch", string.Empty);
					}
					break;
				}
			}

			internal void CompileFacetCombinations()
			{
				_ = datatype.Restriction;
				if ((derivedRestriction.Flags & RestrictionFlags.MaxInclusive) != 0 && (derivedRestriction.Flags & RestrictionFlags.MaxExclusive) != 0)
				{
					throw new XmlSchemaException("Sch_MaxInclusiveExclusive", string.Empty);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MinInclusive) != 0 && (derivedRestriction.Flags & RestrictionFlags.MinExclusive) != 0)
				{
					throw new XmlSchemaException("Sch_MinInclusiveExclusive", string.Empty);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.Length) != 0 && (derivedRestriction.Flags & (RestrictionFlags.MinLength | RestrictionFlags.MaxLength)) != 0)
				{
					throw new XmlSchemaException("Sch_LengthAndMinMax", string.Empty);
				}
				CopyFacetsFromBaseType();
				if ((derivedRestriction.Flags & RestrictionFlags.MinLength) != 0 && (derivedRestriction.Flags & RestrictionFlags.MaxLength) != 0 && derivedRestriction.MinLength > derivedRestriction.MaxLength)
				{
					throw new XmlSchemaException("Sch_MinLengthGtMaxLength", string.Empty);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MinInclusive) != 0 && (derivedRestriction.Flags & RestrictionFlags.MaxInclusive) != 0 && datatype.Compare(derivedRestriction.MinInclusive, derivedRestriction.MaxInclusive) > 0)
				{
					throw new XmlSchemaException("Sch_MinInclusiveGtMaxInclusive", string.Empty);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MinInclusive) != 0 && (derivedRestriction.Flags & RestrictionFlags.MaxExclusive) != 0 && datatype.Compare(derivedRestriction.MinInclusive, derivedRestriction.MaxExclusive) > 0)
				{
					throw new XmlSchemaException("Sch_MinInclusiveGtMaxExclusive", string.Empty);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MinExclusive) != 0 && (derivedRestriction.Flags & RestrictionFlags.MaxExclusive) != 0 && datatype.Compare(derivedRestriction.MinExclusive, derivedRestriction.MaxExclusive) > 0)
				{
					throw new XmlSchemaException("Sch_MinExclusiveGtMaxExclusive", string.Empty);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MinExclusive) != 0 && (derivedRestriction.Flags & RestrictionFlags.MaxInclusive) != 0 && datatype.Compare(derivedRestriction.MinExclusive, derivedRestriction.MaxInclusive) > 0)
				{
					throw new XmlSchemaException("Sch_MinExclusiveGtMaxInclusive", string.Empty);
				}
				if ((derivedRestriction.Flags & (RestrictionFlags.TotalDigits | RestrictionFlags.FractionDigits)) == (RestrictionFlags.TotalDigits | RestrictionFlags.FractionDigits) && derivedRestriction.FractionDigits > derivedRestriction.TotalDigits)
				{
					throw new XmlSchemaException("Sch_FractionDigitsGtTotalDigits", string.Empty);
				}
			}

			private void CopyFacetsFromBaseType()
			{
				RestrictionFacets restriction = datatype.Restriction;
				if ((derivedRestriction.Flags & RestrictionFlags.Length) == 0 && (baseFlags & RestrictionFlags.Length) != 0)
				{
					derivedRestriction.Length = restriction.Length;
					SetFlag(RestrictionFlags.Length);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MinLength) == 0 && (baseFlags & RestrictionFlags.MinLength) != 0)
				{
					derivedRestriction.MinLength = restriction.MinLength;
					SetFlag(RestrictionFlags.MinLength);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MaxLength) == 0 && (baseFlags & RestrictionFlags.MaxLength) != 0)
				{
					derivedRestriction.MaxLength = restriction.MaxLength;
					SetFlag(RestrictionFlags.MaxLength);
				}
				if ((baseFlags & RestrictionFlags.Pattern) != 0)
				{
					if (derivedRestriction.Patterns == null)
					{
						derivedRestriction.Patterns = restriction.Patterns;
					}
					else
					{
						derivedRestriction.Patterns.AddRange(restriction.Patterns);
					}
					SetFlag(RestrictionFlags.Pattern);
				}
				if ((baseFlags & RestrictionFlags.Enumeration) != 0)
				{
					if (derivedRestriction.Enumeration == null)
					{
						derivedRestriction.Enumeration = restriction.Enumeration;
					}
					SetFlag(RestrictionFlags.Enumeration);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.WhiteSpace) == 0 && (baseFlags & RestrictionFlags.WhiteSpace) != 0)
				{
					derivedRestriction.WhiteSpace = restriction.WhiteSpace;
					SetFlag(RestrictionFlags.WhiteSpace);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MaxInclusive) == 0 && (baseFlags & RestrictionFlags.MaxInclusive) != 0)
				{
					derivedRestriction.MaxInclusive = restriction.MaxInclusive;
					SetFlag(RestrictionFlags.MaxInclusive);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MaxExclusive) == 0 && (baseFlags & RestrictionFlags.MaxExclusive) != 0)
				{
					derivedRestriction.MaxExclusive = restriction.MaxExclusive;
					SetFlag(RestrictionFlags.MaxExclusive);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MinInclusive) == 0 && (baseFlags & RestrictionFlags.MinInclusive) != 0)
				{
					derivedRestriction.MinInclusive = restriction.MinInclusive;
					SetFlag(RestrictionFlags.MinInclusive);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.MinExclusive) == 0 && (baseFlags & RestrictionFlags.MinExclusive) != 0)
				{
					derivedRestriction.MinExclusive = restriction.MinExclusive;
					SetFlag(RestrictionFlags.MinExclusive);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.TotalDigits) == 0 && (baseFlags & RestrictionFlags.TotalDigits) != 0)
				{
					derivedRestriction.TotalDigits = restriction.TotalDigits;
					SetFlag(RestrictionFlags.TotalDigits);
				}
				if ((derivedRestriction.Flags & RestrictionFlags.FractionDigits) == 0 && (baseFlags & RestrictionFlags.FractionDigits) != 0)
				{
					derivedRestriction.FractionDigits = restriction.FractionDigits;
					SetFlag(RestrictionFlags.FractionDigits);
				}
			}

			private object ParseFacetValue(XmlSchemaDatatype datatype, XmlSchemaFacet facet, string code, IXmlNamespaceResolver nsmgr, XmlNameTable nameTable)
			{
				object typedValue;
				Exception ex = datatype.TryParseValue(facet.Value, nameTable, nsmgr, out typedValue);
				if (ex == null)
				{
					return typedValue;
				}
				throw new XmlSchemaException(code, new string[1] { ex.Message }, ex, facet.SourceUri, facet.LineNumber, facet.LinePosition, facet);
			}

			private static string Preprocess(string pattern)
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("^");
				char[] array = pattern.ToCharArray();
				int length = pattern.Length;
				int num = 0;
				for (int i = 0; i < length - 2; i++)
				{
					if (array[i] != '\\')
					{
						continue;
					}
					if (array[i + 1] == '\\')
					{
						i++;
						continue;
					}
					char c = array[i + 1];
					for (int j = 0; j < c_map.Length; j++)
					{
						if (c_map[j].match == c)
						{
							if (num < i)
							{
								stringBuilder.Append(array, num, i - num);
							}
							stringBuilder.Append(c_map[j].replacement);
							i++;
							num = i + 1;
							break;
						}
					}
				}
				if (num < length)
				{
					stringBuilder.Append(array, num, length - num);
				}
				stringBuilder.Append("$");
				return stringBuilder.ToString();
			}

			private void CheckProhibitedFlag(XmlSchemaFacet facet, RestrictionFlags flag, string errorCode)
			{
				if ((validRestrictionFlags & flag) == 0)
				{
					throw new XmlSchemaException(errorCode, datatype.TypeCodeString, facet);
				}
			}

			private void CheckDupFlag(XmlSchemaFacet facet, RestrictionFlags flag, string errorCode)
			{
				if ((derivedRestriction.Flags & flag) != 0)
				{
					throw new XmlSchemaException(errorCode, facet);
				}
			}

			private void SetFlag(XmlSchemaFacet facet, RestrictionFlags flag)
			{
				derivedRestriction.Flags |= flag;
				if (facet.IsFixed)
				{
					derivedRestriction.FixedFlags |= flag;
				}
			}

			private void SetFlag(RestrictionFlags flag)
			{
				derivedRestriction.Flags |= flag;
				if ((baseFixedFlags & flag) != 0)
				{
					derivedRestriction.FixedFlags |= flag;
				}
			}
		}

		internal virtual Exception CheckLexicalFacets(ref string parseString, XmlSchemaDatatype datatype)
		{
			CheckWhitespaceFacets(ref parseString, datatype);
			return CheckPatternFacets(datatype.Restriction, parseString);
		}

		internal virtual Exception CheckValueFacets(object value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(decimal value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(long value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(int value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(short value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(byte value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(DateTime value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(double value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(float value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(string value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(byte[] value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(TimeSpan value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal virtual Exception CheckValueFacets(XmlQualifiedName value, XmlSchemaDatatype datatype)
		{
			return null;
		}

		internal void CheckWhitespaceFacets(ref string s, XmlSchemaDatatype datatype)
		{
			RestrictionFacets restriction = datatype.Restriction;
			switch (datatype.Variety)
			{
			case XmlSchemaDatatypeVariety.List:
				s = s.Trim();
				break;
			case XmlSchemaDatatypeVariety.Atomic:
				if (datatype.BuiltInWhitespaceFacet == XmlSchemaWhiteSpace.Collapse)
				{
					s = XmlComplianceUtil.NonCDataNormalize(s);
				}
				else if (datatype.BuiltInWhitespaceFacet == XmlSchemaWhiteSpace.Replace)
				{
					s = XmlComplianceUtil.CDataNormalize(s);
				}
				else if (restriction != null && (restriction.Flags & RestrictionFlags.WhiteSpace) != 0)
				{
					if (restriction.WhiteSpace == XmlSchemaWhiteSpace.Replace)
					{
						s = XmlComplianceUtil.CDataNormalize(s);
					}
					else if (restriction.WhiteSpace == XmlSchemaWhiteSpace.Collapse)
					{
						s = XmlComplianceUtil.NonCDataNormalize(s);
					}
				}
				break;
			}
		}

		internal Exception CheckPatternFacets(RestrictionFacets restriction, string value)
		{
			if (restriction != null && (restriction.Flags & RestrictionFlags.Pattern) != 0)
			{
				foreach (Regex pattern in restriction.Patterns)
				{
					if (!pattern.IsMatch(value))
					{
						return new XmlSchemaException("Sch_PatternConstraintFailed", string.Empty);
					}
				}
			}
			return null;
		}

		internal virtual bool MatchEnumeration(object value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			return false;
		}

		internal virtual RestrictionFacets ConstructRestriction(DatatypeImplementation datatype, XmlSchemaObjectCollection facets, XmlNameTable nameTable)
		{
			RestrictionFacets restrictionFacets = new RestrictionFacets();
			FacetsCompiler facetsCompiler = new FacetsCompiler(datatype, restrictionFacets);
			foreach (XmlSchemaFacet facet in facets)
			{
				if (facet.Value == null)
				{
					throw new XmlSchemaException("Sch_InvalidFacet", facet);
				}
				IXmlNamespaceResolver nsmgr = new SchemaNamespaceManager(facet);
				switch (facet.FacetType)
				{
				case FacetType.Length:
					facetsCompiler.CompileLengthFacet(facet);
					break;
				case FacetType.MinLength:
					facetsCompiler.CompileMinLengthFacet(facet);
					break;
				case FacetType.MaxLength:
					facetsCompiler.CompileMaxLengthFacet(facet);
					break;
				case FacetType.Pattern:
					facetsCompiler.CompilePatternFacet(facet as XmlSchemaPatternFacet);
					break;
				case FacetType.Enumeration:
					facetsCompiler.CompileEnumerationFacet(facet, nsmgr, nameTable);
					break;
				case FacetType.Whitespace:
					facetsCompiler.CompileWhitespaceFacet(facet);
					break;
				case FacetType.MinInclusive:
					facetsCompiler.CompileMinInclusiveFacet(facet);
					break;
				case FacetType.MinExclusive:
					facetsCompiler.CompileMinExclusiveFacet(facet);
					break;
				case FacetType.MaxInclusive:
					facetsCompiler.CompileMaxInclusiveFacet(facet);
					break;
				case FacetType.MaxExclusive:
					facetsCompiler.CompileMaxExclusiveFacet(facet);
					break;
				case FacetType.TotalDigits:
					facetsCompiler.CompileTotalDigitsFacet(facet);
					break;
				case FacetType.FractionDigits:
					facetsCompiler.CompileFractionDigitsFacet(facet);
					break;
				default:
					throw new XmlSchemaException("Sch_UnknownFacet", facet);
				}
			}
			facetsCompiler.FinishFacetCompile();
			facetsCompiler.CompileFacetCombinations();
			return restrictionFacets;
		}

		internal static decimal Power(int x, int y)
		{
			decimal result = 1m;
			decimal num = x;
			if (y > 28)
			{
				return decimal.MaxValue;
			}
			for (int i = 0; i < y; i++)
			{
				result *= num;
			}
			return result;
		}
	}
	internal class Numeric10FacetsChecker : FacetsChecker
	{
		private static readonly char[] signs = new char[2] { '+', '-' };

		private decimal maxValue;

		private decimal minValue;

		internal Numeric10FacetsChecker(decimal minVal, decimal maxVal)
		{
			minValue = minVal;
			maxValue = maxVal;
		}

		internal override Exception CheckValueFacets(object value, XmlSchemaDatatype datatype)
		{
			decimal value2 = datatype.ValueConverter.ToDecimal(value);
			return CheckValueFacets(value2, datatype);
		}

		internal override Exception CheckValueFacets(decimal value, XmlSchemaDatatype datatype)
		{
			RestrictionFacets restriction = datatype.Restriction;
			RestrictionFlags restrictionFlags = restriction?.Flags ?? ((RestrictionFlags)0);
			XmlValueConverter valueConverter = datatype.ValueConverter;
			if (value > maxValue || value < minValue)
			{
				return new OverflowException(Res.GetString("XmlConvert_Overflow", value.ToString(CultureInfo.InvariantCulture), datatype.TypeCodeString));
			}
			if (restrictionFlags != 0)
			{
				if ((restrictionFlags & RestrictionFlags.MaxInclusive) != 0 && value > valueConverter.ToDecimal(restriction.MaxInclusive))
				{
					return new XmlSchemaException("Sch_MaxInclusiveConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MaxExclusive) != 0 && value >= valueConverter.ToDecimal(restriction.MaxExclusive))
				{
					return new XmlSchemaException("Sch_MaxExclusiveConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MinInclusive) != 0 && value < valueConverter.ToDecimal(restriction.MinInclusive))
				{
					return new XmlSchemaException("Sch_MinInclusiveConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MinExclusive) != 0 && value <= valueConverter.ToDecimal(restriction.MinExclusive))
				{
					return new XmlSchemaException("Sch_MinExclusiveConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.Enumeration) != 0 && !MatchEnumeration(value, restriction.Enumeration, valueConverter))
				{
					return new XmlSchemaException("Sch_EnumerationConstraintFailed", string.Empty);
				}
				return CheckTotalAndFractionDigits(value, restriction.TotalDigits, restriction.FractionDigits, (restrictionFlags & RestrictionFlags.TotalDigits) != 0, (restrictionFlags & RestrictionFlags.FractionDigits) != 0);
			}
			return null;
		}

		internal override Exception CheckValueFacets(long value, XmlSchemaDatatype datatype)
		{
			decimal value2 = value;
			return CheckValueFacets(value2, datatype);
		}

		internal override Exception CheckValueFacets(int value, XmlSchemaDatatype datatype)
		{
			decimal value2 = value;
			return CheckValueFacets(value2, datatype);
		}

		internal override Exception CheckValueFacets(short value, XmlSchemaDatatype datatype)
		{
			decimal value2 = value;
			return CheckValueFacets(value2, datatype);
		}

		internal override Exception CheckValueFacets(byte value, XmlSchemaDatatype datatype)
		{
			decimal value2 = value;
			return CheckValueFacets(value2, datatype);
		}

		internal override bool MatchEnumeration(object value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			return MatchEnumeration(datatype.ValueConverter.ToDecimal(value), enumeration, datatype.ValueConverter);
		}

		internal bool MatchEnumeration(decimal value, ArrayList enumeration, XmlValueConverter valueConverter)
		{
			foreach (object item in enumeration)
			{
				if (value == valueConverter.ToDecimal(item))
				{
					return true;
				}
			}
			return false;
		}

		internal Exception CheckTotalAndFractionDigits(decimal value, int totalDigits, int fractionDigits, bool checkTotal, bool checkFraction)
		{
			decimal num = FacetsChecker.Power(10, totalDigits) - 1m;
			int num2 = 0;
			if (value < 0m)
			{
				value = decimal.Negate(value);
			}
			while (decimal.Truncate(value) != value)
			{
				value *= 10m;
				num2++;
			}
			if (checkTotal && (value > num || num2 > totalDigits))
			{
				return new XmlSchemaException("Sch_TotalDigitsConstraintFailed", string.Empty);
			}
			if (checkFraction && num2 > fractionDigits)
			{
				return new XmlSchemaException("Sch_FractionDigitsConstraintFailed", string.Empty);
			}
			return null;
		}
	}
	internal class Numeric2FacetsChecker : FacetsChecker
	{
		internal override Exception CheckValueFacets(object value, XmlSchemaDatatype datatype)
		{
			double value2 = datatype.ValueConverter.ToDouble(value);
			return CheckValueFacets(value2, datatype);
		}

		internal override Exception CheckValueFacets(double value, XmlSchemaDatatype datatype)
		{
			RestrictionFacets restriction = datatype.Restriction;
			RestrictionFlags restrictionFlags = restriction?.Flags ?? ((RestrictionFlags)0);
			XmlValueConverter valueConverter = datatype.ValueConverter;
			if ((restrictionFlags & RestrictionFlags.MaxInclusive) != 0 && value > valueConverter.ToDouble(restriction.MaxInclusive))
			{
				return new XmlSchemaException("Sch_MaxInclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.MaxExclusive) != 0 && value >= valueConverter.ToDouble(restriction.MaxExclusive))
			{
				return new XmlSchemaException("Sch_MaxExclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.MinInclusive) != 0 && value < valueConverter.ToDouble(restriction.MinInclusive))
			{
				return new XmlSchemaException("Sch_MinInclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.MinExclusive) != 0 && value <= valueConverter.ToDouble(restriction.MinExclusive))
			{
				return new XmlSchemaException("Sch_MinExclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.Enumeration) != 0 && !MatchEnumeration(value, restriction.Enumeration, valueConverter))
			{
				return new XmlSchemaException("Sch_EnumerationConstraintFailed", string.Empty);
			}
			return null;
		}

		internal override Exception CheckValueFacets(float value, XmlSchemaDatatype datatype)
		{
			double value2 = value;
			return CheckValueFacets(value2, datatype);
		}

		internal override bool MatchEnumeration(object value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			return MatchEnumeration(datatype.ValueConverter.ToDouble(value), enumeration, datatype.ValueConverter);
		}

		private bool MatchEnumeration(double value, ArrayList enumeration, XmlValueConverter valueConverter)
		{
			foreach (object item in enumeration)
			{
				if (value == valueConverter.ToDouble(item))
				{
					return true;
				}
			}
			return false;
		}
	}
	internal class DurationFacetsChecker : FacetsChecker
	{
		internal override Exception CheckValueFacets(object value, XmlSchemaDatatype datatype)
		{
			TimeSpan value2 = (TimeSpan)datatype.ValueConverter.ChangeType(value, typeof(TimeSpan));
			return CheckValueFacets(value2, datatype);
		}

		internal override Exception CheckValueFacets(TimeSpan value, XmlSchemaDatatype datatype)
		{
			RestrictionFacets restriction = datatype.Restriction;
			RestrictionFlags restrictionFlags = restriction?.Flags ?? ((RestrictionFlags)0);
			if ((restrictionFlags & RestrictionFlags.MaxInclusive) != 0 && TimeSpan.Compare(value, (TimeSpan)restriction.MaxInclusive) > 0)
			{
				return new XmlSchemaException("Sch_MaxInclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.MaxExclusive) != 0 && TimeSpan.Compare(value, (TimeSpan)restriction.MaxExclusive) >= 0)
			{
				return new XmlSchemaException("Sch_MaxExclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.MinInclusive) != 0 && TimeSpan.Compare(value, (TimeSpan)restriction.MinInclusive) < 0)
			{
				return new XmlSchemaException("Sch_MinInclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.MinExclusive) != 0 && TimeSpan.Compare(value, (TimeSpan)restriction.MinExclusive) <= 0)
			{
				return new XmlSchemaException("Sch_MinExclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.Enumeration) != 0 && !MatchEnumeration(value, restriction.Enumeration))
			{
				return new XmlSchemaException("Sch_EnumerationConstraintFailed", string.Empty);
			}
			return null;
		}

		internal override bool MatchEnumeration(object value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			return MatchEnumeration((TimeSpan)value, enumeration);
		}

		private bool MatchEnumeration(TimeSpan value, ArrayList enumeration)
		{
			foreach (TimeSpan item in enumeration)
			{
				if (TimeSpan.Compare(value, item) == 0)
				{
					return true;
				}
			}
			return false;
		}
	}
	internal class DateTimeFacetsChecker : FacetsChecker
	{
		internal override Exception CheckValueFacets(object value, XmlSchemaDatatype datatype)
		{
			DateTime value2 = datatype.ValueConverter.ToDateTime(value);
			return CheckValueFacets(value2, datatype);
		}

		internal override Exception CheckValueFacets(DateTime value, XmlSchemaDatatype datatype)
		{
			RestrictionFacets restriction = datatype.Restriction;
			RestrictionFlags restrictionFlags = restriction?.Flags ?? ((RestrictionFlags)0);
			if ((restrictionFlags & RestrictionFlags.MaxInclusive) != 0 && datatype.Compare(value, (DateTime)restriction.MaxInclusive) > 0)
			{
				return new XmlSchemaException("Sch_MaxInclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.MaxExclusive) != 0 && datatype.Compare(value, (DateTime)restriction.MaxExclusive) >= 0)
			{
				return new XmlSchemaException("Sch_MaxExclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.MinInclusive) != 0 && datatype.Compare(value, (DateTime)restriction.MinInclusive) < 0)
			{
				return new XmlSchemaException("Sch_MinInclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.MinExclusive) != 0 && datatype.Compare(value, (DateTime)restriction.MinExclusive) <= 0)
			{
				return new XmlSchemaException("Sch_MinExclusiveConstraintFailed", string.Empty);
			}
			if ((restrictionFlags & RestrictionFlags.Enumeration) != 0 && !MatchEnumeration(value, restriction.Enumeration, datatype))
			{
				return new XmlSchemaException("Sch_EnumerationConstraintFailed", string.Empty);
			}
			return null;
		}

		internal override bool MatchEnumeration(object value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			return MatchEnumeration(datatype.ValueConverter.ToDateTime(value), enumeration, datatype);
		}

		private bool MatchEnumeration(DateTime value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			foreach (DateTime item in enumeration)
			{
				if (datatype.Compare(value, item) == 0)
				{
					return true;
				}
			}
			return false;
		}
	}
	internal class StringFacetsChecker : FacetsChecker
	{
		private static Regex languagePattern;

		private static Regex LanguagePattern
		{
			get
			{
				if (languagePattern == null)
				{
					Regex value = new Regex("^([a-zA-Z]{1,8})(-[a-zA-Z0-9]{1,8})*$", RegexOptions.None);
					Interlocked.CompareExchange(ref languagePattern, value, null);
				}
				return languagePattern;
			}
		}

		internal override Exception CheckValueFacets(object value, XmlSchemaDatatype datatype)
		{
			string value2 = datatype.ValueConverter.ToString(value);
			return CheckValueFacets(value2, datatype, verifyUri: true);
		}

		internal override Exception CheckValueFacets(string value, XmlSchemaDatatype datatype)
		{
			return CheckValueFacets(value, datatype, verifyUri: true);
		}

		internal Exception CheckValueFacets(string value, XmlSchemaDatatype datatype, bool verifyUri)
		{
			int length = value.Length;
			RestrictionFacets restriction = datatype.Restriction;
			RestrictionFlags restrictionFlags = restriction?.Flags ?? ((RestrictionFlags)0);
			Exception ex = CheckBuiltInFacets(value, datatype.TypeCode, verifyUri);
			if (ex != null)
			{
				return ex;
			}
			if (restrictionFlags != 0)
			{
				if ((restrictionFlags & RestrictionFlags.Length) != 0 && restriction.Length != length)
				{
					return new XmlSchemaException("Sch_LengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MinLength) != 0 && length < restriction.MinLength)
				{
					return new XmlSchemaException("Sch_MinLengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MaxLength) != 0 && restriction.MaxLength < length)
				{
					return new XmlSchemaException("Sch_MaxLengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.Enumeration) != 0 && !MatchEnumeration(value, restriction.Enumeration, datatype))
				{
					return new XmlSchemaException("Sch_EnumerationConstraintFailed", string.Empty);
				}
			}
			return null;
		}

		internal override bool MatchEnumeration(object value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			return MatchEnumeration(datatype.ValueConverter.ToString(value), enumeration, datatype);
		}

		private bool MatchEnumeration(string value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			if (datatype.TypeCode == XmlTypeCode.AnyUri)
			{
				foreach (Uri item in enumeration)
				{
					if (value.Equals(item.OriginalString))
					{
						return true;
					}
				}
			}
			else
			{
				foreach (string item2 in enumeration)
				{
					if (value.Equals(item2))
					{
						return true;
					}
				}
			}
			return false;
		}

		private Exception CheckBuiltInFacets(string s, XmlTypeCode typeCode, bool verifyUri)
		{
			Exception result = null;
			switch (typeCode)
			{
			case XmlTypeCode.AnyUri:
				if (verifyUri)
				{
					result = XmlConvert.TryToUri(s, out var _);
				}
				break;
			case XmlTypeCode.NormalizedString:
				result = XmlConvert.TryVerifyNormalizedString(s);
				break;
			case XmlTypeCode.Token:
				result = XmlConvert.TryVerifyTOKEN(s);
				break;
			case XmlTypeCode.Language:
				if (s == null || s.Length == 0)
				{
					return new XmlSchemaException("Sch_EmptyAttributeValue", string.Empty);
				}
				if (!LanguagePattern.IsMatch(s))
				{
					return new XmlSchemaException("Sch_InvalidLanguageId", string.Empty);
				}
				break;
			case XmlTypeCode.NmToken:
				result = XmlConvert.TryVerifyNMTOKEN(s);
				break;
			case XmlTypeCode.Name:
				result = XmlConvert.TryVerifyName(s);
				break;
			case XmlTypeCode.NCName:
			case XmlTypeCode.Id:
			case XmlTypeCode.Idref:
			case XmlTypeCode.Entity:
				result = XmlConvert.TryVerifyNCName(s);
				break;
			}
			return result;
		}
	}
	internal class QNameFacetsChecker : FacetsChecker
	{
		internal override Exception CheckValueFacets(object value, XmlSchemaDatatype datatype)
		{
			XmlQualifiedName value2 = (XmlQualifiedName)datatype.ValueConverter.ChangeType(value, typeof(XmlQualifiedName));
			return CheckValueFacets(value2, datatype);
		}

		internal override Exception CheckValueFacets(XmlQualifiedName value, XmlSchemaDatatype datatype)
		{
			RestrictionFacets restriction = datatype.Restriction;
			RestrictionFlags restrictionFlags = restriction?.Flags ?? ((RestrictionFlags)0);
			if (restrictionFlags != 0)
			{
				string text = value.ToString();
				int length = text.Length;
				if ((restrictionFlags & RestrictionFlags.Length) != 0 && restriction.Length != length)
				{
					return new XmlSchemaException("Sch_LengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MinLength) != 0 && length < restriction.MinLength)
				{
					return new XmlSchemaException("Sch_MinLengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MaxLength) != 0 && restriction.MaxLength < length)
				{
					return new XmlSchemaException("Sch_MaxLengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.Enumeration) != 0 && !MatchEnumeration(value, restriction.Enumeration))
				{
					return new XmlSchemaException("Sch_EnumerationConstraintFailed", string.Empty);
				}
			}
			return null;
		}

		internal override bool MatchEnumeration(object value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			return MatchEnumeration((XmlQualifiedName)datatype.ValueConverter.ChangeType(value, typeof(XmlQualifiedName)), enumeration);
		}

		private bool MatchEnumeration(XmlQualifiedName value, ArrayList enumeration)
		{
			foreach (XmlQualifiedName item in enumeration)
			{
				if (value.Equals(item))
				{
					return true;
				}
			}
			return false;
		}
	}
	internal class MiscFacetsChecker : FacetsChecker
	{
	}
	internal class BinaryFacetsChecker : FacetsChecker
	{
		internal override Exception CheckValueFacets(object value, XmlSchemaDatatype datatype)
		{
			byte[] value2 = (byte[])value;
			return CheckValueFacets(value2, datatype);
		}

		internal override Exception CheckValueFacets(byte[] value, XmlSchemaDatatype datatype)
		{
			RestrictionFacets restriction = datatype.Restriction;
			int num = value.Length;
			RestrictionFlags restrictionFlags = restriction?.Flags ?? ((RestrictionFlags)0);
			if (restrictionFlags != 0)
			{
				if ((restrictionFlags & RestrictionFlags.Length) != 0 && restriction.Length != num)
				{
					return new XmlSchemaException("Sch_LengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MinLength) != 0 && num < restriction.MinLength)
				{
					return new XmlSchemaException("Sch_MinLengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MaxLength) != 0 && restriction.MaxLength < num)
				{
					return new XmlSchemaException("Sch_MaxLengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.Enumeration) != 0 && !MatchEnumeration(value, restriction.Enumeration, datatype))
				{
					return new XmlSchemaException("Sch_EnumerationConstraintFailed", string.Empty);
				}
			}
			return null;
		}

		internal override bool MatchEnumeration(object value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			return MatchEnumeration((byte[])value, enumeration, datatype);
		}

		private bool MatchEnumeration(byte[] value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			foreach (byte[] item in enumeration)
			{
				if (datatype.Compare(value, item) == 0)
				{
					return true;
				}
			}
			return false;
		}
	}
	internal class ListFacetsChecker : FacetsChecker
	{
		internal override Exception CheckValueFacets(object value, XmlSchemaDatatype datatype)
		{
			Array array = value as Array;
			RestrictionFacets restriction = datatype.Restriction;
			RestrictionFlags restrictionFlags = restriction?.Flags ?? ((RestrictionFlags)0);
			if ((restrictionFlags & (RestrictionFlags.Length | RestrictionFlags.MinLength | RestrictionFlags.MaxLength)) != 0)
			{
				int length = array.Length;
				if ((restrictionFlags & RestrictionFlags.Length) != 0 && restriction.Length != length)
				{
					return new XmlSchemaException("Sch_LengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MinLength) != 0 && length < restriction.MinLength)
				{
					return new XmlSchemaException("Sch_MinLengthConstraintFailed", string.Empty);
				}
				if ((restrictionFlags & RestrictionFlags.MaxLength) != 0 && restriction.MaxLength < length)
				{
					return new XmlSchemaException("Sch_MaxLengthConstraintFailed", string.Empty);
				}
			}
			if ((restrictionFlags & RestrictionFlags.Enumeration) != 0 && !MatchEnumeration(value, restriction.Enumeration, datatype))
			{
				return new XmlSchemaException("Sch_EnumerationConstraintFailed", string.Empty);
			}
			return null;
		}

		internal override bool MatchEnumeration(object value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			foreach (object item in enumeration)
			{
				if (datatype.Compare(value, item) == 0)
				{
					return true;
				}
			}
			return false;
		}
	}
	internal class UnionFacetsChecker : FacetsChecker
	{
		internal override Exception CheckValueFacets(object value, XmlSchemaDatatype datatype)
		{
			RestrictionFacets restriction = datatype.Restriction;
			RestrictionFlags restrictionFlags = restriction?.Flags ?? ((RestrictionFlags)0);
			if ((restrictionFlags & RestrictionFlags.Enumeration) != 0 && !MatchEnumeration(value, restriction.Enumeration, datatype))
			{
				return new XmlSchemaException("Sch_EnumerationConstraintFailed", string.Empty);
			}
			return null;
		}

		internal override bool MatchEnumeration(object value, ArrayList enumeration, XmlSchemaDatatype datatype)
		{
			foreach (object item in enumeration)
			{
				if (datatype.Compare(value, item) == 0)
				{
					return true;
				}
			}
			return false;
		}
	}
	internal class NamespaceList
	{
		public enum ListType
		{
			Any,
			Other,
			Set
		}

		private ListType type;

		private Hashtable set;

		private string targetNamespace;

		public ListType Type => type;

		public string Excluded => targetNamespace;

		public ICollection Enumerate => type switch
		{
			ListType.Set => set.Keys, 
			_ => throw new InvalidOperationException(), 
		};

		public NamespaceList()
		{
		}

		public NamespaceList(string namespaces, string targetNamespace)
		{
			this.targetNamespace = targetNamespace;
			namespaces = namespaces.Trim();
			if (namespaces == "##any" || namespaces.Length == 0)
			{
				type = ListType.Any;
				return;
			}
			if (namespaces == "##other")
			{
				type = ListType.Other;
				return;
			}
			type = ListType.Set;
			set = new Hashtable();
			string[] array = XmlConvert.SplitString(namespaces);
			foreach (string text in array)
			{
				if (text == "##local")
				{
					set[string.Empty] = string.Empty;
					continue;
				}
				if (text == "##targetNamespace")
				{
					set[targetNamespace] = targetNamespace;
					continue;
				}
				XmlConvert.ToUri(text);
				set[text] = text;
			}
		}

		public NamespaceList Clone()
		{
			NamespaceList namespaceList = (NamespaceList)MemberwiseClone();
			if (type == ListType.Set)
			{
				namespaceList.set = (Hashtable)set.Clone();
			}
			return namespaceList;
		}

		public virtual bool Allows(string ns)
		{
			switch (type)
			{
			case ListType.Any:
				return true;
			case ListType.Other:
				if (ns != targetNamespace)
				{
					return ns.Length != 0;
				}
				return false;
			case ListType.Set:
				return set[ns] != null;
			default:
				return false;
			}
		}

		public bool Allows(XmlQualifiedName qname)
		{
			return Allows(qname.Namespace);
		}

		public override string ToString()
		{
			switch (type)
			{
			case ListType.Any:
				return "##any";
			case ListType.Other:
				return "##other";
			case ListType.Set:
			{
				StringBuilder stringBuilder = new StringBuilder();
				bool flag = true;
				foreach (string key in set.Keys)
				{
					if (flag)
					{
						flag = false;
					}
					else
					{
						stringBuilder.Append(" ");
					}
					if (key == targetNamespace)
					{
						stringBuilder.Append("##targetNamespace");
					}
					else if (key.Length == 0)
					{
						stringBuilder.Append("##local");
					}
					else
					{
						stringBuilder.Append(key);
					}
				}
				return stringBuilder.ToString();
			}
			default:
				return string.Empty;
			}
		}

		public static bool IsSubset(NamespaceList sub, NamespaceList super)
		{
			if (super.type == ListType.Any)
			{
				return true;
			}
			if (sub.type == ListType.Other && super.type == ListType.Other)
			{
				return super.targetNamespace == sub.targetNamespace;
			}
			if (sub.type == ListType.Set)
			{
				if (super.type == ListType.Other)
				{
					return !sub.set.Contains(super.targetNamespace);
				}
				foreach (string key in sub.set.Keys)
				{
					if (!super.set.Contains(key))
					{
						return false;
					}
				}
				return true;
			}
			return false;
		}

		public static NamespaceList Union(NamespaceList o1, NamespaceList o2, bool v1Compat)
		{
			NamespaceList result = null;
			if (o1.type == ListType.Any)
			{
				result = new NamespaceList();
			}
			else if (o2.type == ListType.Any)
			{
				result = new NamespaceList();
			}
			else
			{
				if (o1.type == ListType.Set && o2.type == ListType.Set)
				{
					result = o1.Clone();
					{
						foreach (string key in o2.set.Keys)
						{
							result.set[key] = key;
						}
						return result;
					}
				}
				if (o1.type == ListType.Other && o2.type == ListType.Other)
				{
					result = ((!(o1.targetNamespace == o2.targetNamespace)) ? new NamespaceList("##other", string.Empty) : o1.Clone());
				}
				else if (o1.type == ListType.Set && o2.type == ListType.Other)
				{
					result = (v1Compat ? ((!o1.set.Contains(o2.targetNamespace)) ? o2.Clone() : new NamespaceList()) : ((o2.targetNamespace != string.Empty) ? o1.CompareSetToOther(o2) : ((!o1.set.Contains(string.Empty)) ? new NamespaceList("##other", string.Empty) : new NamespaceList())));
				}
				else if (o2.type == ListType.Set && o1.type == ListType.Other)
				{
					result = (v1Compat ? ((!o2.set.Contains(o2.targetNamespace)) ? o1.Clone() : new NamespaceList()) : ((o1.targetNamespace != string.Empty) ? o2.CompareSetToOther(o1) : ((!o2.set.Contains(string.Empty)) ? new NamespaceList("##other", string.Empty) : new NamespaceList())));
				}
			}
			return result;
		}

		private NamespaceList CompareSetToOther(NamespaceList other)
		{
			NamespaceList namespaceList = null;
			if (set.Contains(other.targetNamespace))
			{
				if (set.Contains(string.Empty))
				{
					return new NamespaceList();
				}
				return new NamespaceList("##other", string.Empty);
			}
			if (set.Contains(string.Empty))
			{
				return null;
			}
			return other.Clone();
		}

		public static NamespaceList Intersection(NamespaceList o1, NamespaceList o2, bool v1Compat)
		{
			NamespaceList namespaceList = null;
			if (o1.type == ListType.Any)
			{
				namespaceList = o2.Clone();
			}
			else if (o2.type == ListType.Any)
			{
				namespaceList = o1.Clone();
			}
			else if (o1.type == ListType.Set && o2.type == ListType.Other)
			{
				namespaceList = o1.Clone();
				namespaceList.RemoveNamespace(o2.targetNamespace);
				if (!v1Compat)
				{
					namespaceList.RemoveNamespace(string.Empty);
				}
			}
			else if (o1.type == ListType.Other && o2.type == ListType.Set)
			{
				namespaceList = o2.Clone();
				namespaceList.RemoveNamespace(o1.targetNamespace);
				if (!v1Compat)
				{
					namespaceList.RemoveNamespace(string.Empty);
				}
			}
			else
			{
				if (o1.type == ListType.Set && o2.type == ListType.Set)
				{
					namespaceList = o1.Clone();
					namespaceList = new NamespaceList();
					namespaceList.type = ListType.Set;
					namespaceList.set = new Hashtable();
					{
						foreach (string key in o1.set.Keys)
						{
							if (o2.set.Contains(key))
							{
								namespaceList.set.Add(key, key);
							}
						}
						return namespaceList;
					}
				}
				if (o1.type == ListType.Other && o2.type == ListType.Other)
				{
					if (o1.targetNamespace == o2.targetNamespace)
					{
						return o1.Clone();
					}
					if (!v1Compat)
					{
						if (o1.targetNamespace == string.Empty)
						{
							namespaceList = o2.Clone();
						}
						else if (o2.targetNamespace == string.Empty)
						{
							namespaceList = o1.Clone();
						}
					}
				}
			}
			return namespaceList;
		}

		private void RemoveNamespace(string tns)
		{
			if (set[tns] != null)
			{
				set.Remove(tns);
			}
		}

		public bool IsEmpty()
		{
			if (type == ListType.Set)
			{
				if (set != null)
				{
					return set.Count == 0;
				}
				return true;
			}
			return false;
		}
	}
	internal class NamespaceListV1Compat : NamespaceList
	{
		public NamespaceListV1Compat(string namespaces, string targetNamespace)
			: base(namespaces, targetNamespace)
		{
		}

		public override bool Allows(string ns)
		{
			if (base.Type == ListType.Other)
			{
				return ns != base.Excluded;
			}
			return base.Allows(ns);
		}
	}
	internal sealed class Parser
	{
		private SchemaType schemaType;

		private XmlNameTable nameTable;

		private SchemaNames schemaNames;

		private ValidationEventHandler eventHandler;

		private XmlNamespaceManager namespaceManager;

		private XmlReader reader;

		private PositionInfo positionInfo;

		private bool isProcessNamespaces;

		private int schemaXmlDepth;

		private int markupDepth;

		private SchemaBuilder builder;

		private XmlSchema schema;

		private SchemaInfo xdrSchema;

		private XmlResolver xmlResolver;

		private XmlDocument dummyDocument;

		private bool processMarkup;

		private XmlNode parentNode;

		private XmlNamespaceManager annotationNSManager;

		private string xmlns;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		public XmlSchema XmlSchema => schema;

		internal XmlResolver XmlResolver
		{
			set
			{
				xmlResolver = value;
			}
		}

		public SchemaInfo XdrSchema => xdrSchema;

		public Parser(SchemaType schemaType, XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler eventHandler)
		{
			this.schemaType = schemaType;
			this.nameTable = nameTable;
			this.schemaNames = schemaNames;
			this.eventHandler = eventHandler;
			xmlResolver = XmlReaderSection.CreateDefaultResolver();
			processMarkup = true;
			dummyDocument = new XmlDocument();
		}

		public SchemaType Parse(XmlReader reader, string targetNamespace)
		{
			StartParsing(reader, targetNamespace);
			while (ParseReaderNode() && reader.Read())
			{
			}
			return FinishParsing();
		}

		public void StartParsing(XmlReader reader, string targetNamespace)
		{
			this.reader = reader;
			positionInfo = PositionInfo.GetPositionInfo(reader);
			namespaceManager = reader.NamespaceManager;
			if (namespaceManager == null)
			{
				namespaceManager = new XmlNamespaceManager(nameTable);
				isProcessNamespaces = true;
			}
			else
			{
				isProcessNamespaces = false;
			}
			while (reader.NodeType != XmlNodeType.Element && reader.Read())
			{
			}
			markupDepth = int.MaxValue;
			schemaXmlDepth = reader.Depth;
			SchemaType rootType = schemaNames.SchemaTypeFromRoot(reader.LocalName, reader.NamespaceURI);
			if (!CheckSchemaRoot(rootType, out var code))
			{
				throw new XmlSchemaException(code, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition);
			}
			if (schemaType == SchemaType.XSD)
			{
				schema = new XmlSchema();
				schema.BaseUri = new Uri(reader.BaseURI, UriKind.RelativeOrAbsolute);
				builder = new XsdBuilder(reader, namespaceManager, schema, nameTable, schemaNames, eventHandler);
			}
			else
			{
				xdrSchema = new SchemaInfo();
				xdrSchema.SchemaType = SchemaType.XDR;
				builder = new XdrBuilder(reader, namespaceManager, xdrSchema, targetNamespace, nameTable, schemaNames, eventHandler);
				((XdrBuilder)builder).XmlResolver = xmlResolver;
			}
		}

		private bool CheckSchemaRoot(SchemaType rootType, out string code)
		{
			code = null;
			if (schemaType == SchemaType.None)
			{
				schemaType = rootType;
			}
			switch (rootType)
			{
			case SchemaType.XSD:
				if (schemaType != SchemaType.XSD)
				{
					code = "Sch_MixSchemaTypes";
					return false;
				}
				break;
			case SchemaType.XDR:
				if (schemaType == SchemaType.XSD)
				{
					code = "Sch_XSDSchemaOnly";
					return false;
				}
				if (schemaType != SchemaType.XDR)
				{
					code = "Sch_MixSchemaTypes";
					return false;
				}
				break;
			case SchemaType.None:
			case SchemaType.DTD:
				code = "Sch_SchemaRootExpected";
				if (schemaType == SchemaType.XSD)
				{
					code = "Sch_XSDSchemaRootExpected";
				}
				return false;
			}
			return true;
		}

		public SchemaType FinishParsing()
		{
			return schemaType;
		}

		public bool ParseReaderNode()
		{
			if (reader.Depth > markupDepth)
			{
				if (processMarkup)
				{
					ProcessAppInfoDocMarkup(root: false);
				}
				return true;
			}
			if (reader.NodeType == XmlNodeType.Element)
			{
				if (builder.ProcessElement(reader.Prefix, reader.LocalName, reader.NamespaceURI))
				{
					namespaceManager.PushScope();
					if (reader.MoveToFirstAttribute())
					{
						do
						{
							builder.ProcessAttribute(reader.Prefix, reader.LocalName, reader.NamespaceURI, reader.Value);
							if (Ref.Equal(reader.NamespaceURI, schemaNames.NsXmlNs) && isProcessNamespaces)
							{
								namespaceManager.AddNamespace((reader.Prefix.Length == 0) ? string.Empty : reader.LocalName, reader.Value);
							}
						}
						while (reader.MoveToNextAttribute());
						reader.MoveToElement();
					}
					builder.StartChildren();
					if (reader.IsEmptyElement)
					{
						namespaceManager.PopScope();
						builder.EndChildren();
					}
					else if (!builder.IsContentParsed())
					{
						markupDepth = reader.Depth;
						processMarkup = true;
						if (annotationNSManager == null)
						{
							annotationNSManager = new XmlNamespaceManager(nameTable);
							xmlns = nameTable.Add("xmlns");
						}
						ProcessAppInfoDocMarkup(root: true);
					}
				}
				else if (!reader.IsEmptyElement)
				{
					markupDepth = reader.Depth;
					processMarkup = false;
				}
			}
			else if (reader.NodeType == XmlNodeType.Text)
			{
				if (!xmlCharType.IsOnlyWhitespace(reader.Value))
				{
					builder.ProcessCData(reader.Value);
				}
			}
			else if (reader.NodeType == XmlNodeType.EntityReference || reader.NodeType == XmlNodeType.SignificantWhitespace || reader.NodeType == XmlNodeType.CDATA)
			{
				builder.ProcessCData(reader.Value);
			}
			else if (reader.NodeType == XmlNodeType.EndElement)
			{
				if (reader.Depth == markupDepth)
				{
					if (processMarkup)
					{
						XmlNodeList childNodes = parentNode.ChildNodes;
						XmlNode[] array = new XmlNode[childNodes.Count];
						for (int i = 0; i < childNodes.Count; i++)
						{
							array[i] = childNodes[i];
						}
						builder.ProcessMarkup(array);
						namespaceManager.PopScope();
						builder.EndChildren();
					}
					markupDepth = int.MaxValue;
				}
				else
				{
					namespaceManager.PopScope();
					builder.EndChildren();
				}
				if (reader.Depth == schemaXmlDepth)
				{
					return false;
				}
			}
			return true;
		}

		private void ProcessAppInfoDocMarkup(bool root)
		{
			XmlNode newChild = null;
			switch (reader.NodeType)
			{
			case XmlNodeType.Element:
				annotationNSManager.PushScope();
				newChild = LoadElementNode(root);
				return;
			case XmlNodeType.Text:
				newChild = dummyDocument.CreateTextNode(reader.Value);
				break;
			case XmlNodeType.SignificantWhitespace:
				newChild = dummyDocument.CreateSignificantWhitespace(reader.Value);
				break;
			case XmlNodeType.CDATA:
				newChild = dummyDocument.CreateCDataSection(reader.Value);
				break;
			case XmlNodeType.EntityReference:
				newChild = dummyDocument.CreateEntityReference(reader.Name);
				break;
			case XmlNodeType.Comment:
				newChild = dummyDocument.CreateComment(reader.Value);
				break;
			case XmlNodeType.ProcessingInstruction:
				newChild = dummyDocument.CreateProcessingInstruction(reader.Name, reader.Value);
				break;
			case XmlNodeType.EndElement:
				annotationNSManager.PopScope();
				parentNode = parentNode.ParentNode;
				return;
			case XmlNodeType.Whitespace:
			case XmlNodeType.EndEntity:
				return;
			}
			parentNode.AppendChild(newChild);
		}

		private XmlElement LoadElementNode(bool root)
		{
			XmlReader xmlReader = reader;
			bool isEmptyElement = xmlReader.IsEmptyElement;
			XmlElement xmlElement = dummyDocument.CreateElement(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI);
			xmlElement.IsEmpty = isEmptyElement;
			if (root)
			{
				parentNode = xmlElement;
			}
			else
			{
				XmlAttributeCollection attributes = xmlElement.Attributes;
				if (xmlReader.MoveToFirstAttribute())
				{
					do
					{
						if (Ref.Equal(xmlReader.NamespaceURI, schemaNames.NsXmlNs))
						{
							annotationNSManager.AddNamespace((xmlReader.Prefix.Length == 0) ? string.Empty : reader.LocalName, reader.Value);
						}
						XmlAttribute node = LoadAttributeNode();
						attributes.Append(node);
					}
					while (xmlReader.MoveToNextAttribute());
				}
				xmlReader.MoveToElement();
				string text = annotationNSManager.LookupNamespace(xmlReader.Prefix);
				if (text == null)
				{
					XmlAttribute node2 = CreateXmlNsAttribute(xmlReader.Prefix, namespaceManager.LookupNamespace(xmlReader.Prefix));
					attributes.Append(node2);
				}
				else if (text.Length == 0)
				{
					string text2 = namespaceManager.LookupNamespace(xmlReader.Prefix);
					if (text2 != string.Empty)
					{
						XmlAttribute node3 = CreateXmlNsAttribute(xmlReader.Prefix, text2);
						attributes.Append(node3);
					}
				}
				while (xmlReader.MoveToNextAttribute())
				{
					if (xmlReader.Prefix.Length != 0)
					{
						string text3 = annotationNSManager.LookupNamespace(xmlReader.Prefix);
						if (text3 == null)
						{
							XmlAttribute node4 = CreateXmlNsAttribute(xmlReader.Prefix, namespaceManager.LookupNamespace(xmlReader.Prefix));
							attributes.Append(node4);
						}
					}
				}
				xmlReader.MoveToElement();
				parentNode.AppendChild(xmlElement);
				if (!xmlReader.IsEmptyElement)
				{
					parentNode = xmlElement;
				}
			}
			return xmlElement;
		}

		private XmlAttribute CreateXmlNsAttribute(string prefix, string value)
		{
			XmlAttribute xmlAttribute = ((prefix.Length != 0) ? dummyDocument.CreateAttribute(xmlns, prefix, "http://www.w3.org/2000/xmlns/") : dummyDocument.CreateAttribute(string.Empty, xmlns, "http://www.w3.org/2000/xmlns/"));
			xmlAttribute.AppendChild(dummyDocument.CreateTextNode(value));
			annotationNSManager.AddNamespace(prefix, value);
			return xmlAttribute;
		}

		private XmlAttribute LoadAttributeNode()
		{
			XmlReader xmlReader = reader;
			XmlAttribute xmlAttribute = dummyDocument.CreateAttribute(xmlReader.Prefix, xmlReader.LocalName, xmlReader.NamespaceURI);
			while (xmlReader.ReadAttributeValue())
			{
				switch (xmlReader.NodeType)
				{
				case XmlNodeType.Text:
					xmlAttribute.AppendChild(dummyDocument.CreateTextNode(xmlReader.Value));
					break;
				case XmlNodeType.EntityReference:
					xmlAttribute.AppendChild(LoadEntityReferenceInAttribute());
					break;
				default:
					throw XmlLoader.UnexpectedNodeType(xmlReader.NodeType);
				}
			}
			return xmlAttribute;
		}

		private XmlEntityReference LoadEntityReferenceInAttribute()
		{
			XmlEntityReference xmlEntityReference = dummyDocument.CreateEntityReference(reader.LocalName);
			if (!reader.CanResolveEntity)
			{
				return xmlEntityReference;
			}
			reader.ResolveEntity();
			while (reader.ReadAttributeValue())
			{
				switch (reader.NodeType)
				{
				case XmlNodeType.Text:
					xmlEntityReference.AppendChild(dummyDocument.CreateTextNode(reader.Value));
					break;
				case XmlNodeType.EndEntity:
					if (xmlEntityReference.ChildNodes.Count == 0)
					{
						xmlEntityReference.AppendChild(dummyDocument.CreateTextNode(string.Empty));
					}
					return xmlEntityReference;
				case XmlNodeType.EntityReference:
					xmlEntityReference.AppendChild(LoadEntityReferenceInAttribute());
					break;
				default:
					throw XmlLoader.UnexpectedNodeType(reader.NodeType);
				}
			}
			return xmlEntityReference;
		}
	}
	internal enum Compositor
	{
		Root,
		Include,
		Import,
		Redefine
	}
	internal class RedefineEntry
	{
		internal XmlSchemaRedefine redefine;

		internal XmlSchema schemaToUpdate;

		public RedefineEntry(XmlSchemaRedefine external, XmlSchema schema)
		{
			redefine = external;
			schemaToUpdate = schema;
		}
	}
	internal sealed class Preprocessor : BaseProcessor
	{
		private const XmlSchemaDerivationMethod schemaBlockDefaultAllowed = XmlSchemaDerivationMethod.Substitution | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction;

		private const XmlSchemaDerivationMethod schemaFinalDefaultAllowed = XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union;

		private const XmlSchemaDerivationMethod elementBlockAllowed = XmlSchemaDerivationMethod.Substitution | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction;

		private const XmlSchemaDerivationMethod elementFinalAllowed = XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction;

		private const XmlSchemaDerivationMethod simpleTypeFinalAllowed = XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union;

		private const XmlSchemaDerivationMethod complexTypeBlockAllowed = XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction;

		private const XmlSchemaDerivationMethod complexTypeFinalAllowed = XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction;

		private string Xmlns;

		private string NsXsi;

		private string targetNamespace;

		private XmlSchema rootSchema;

		private XmlSchema currentSchema;

		private XmlSchemaForm elementFormDefault;

		private XmlSchemaForm attributeFormDefault;

		private XmlSchemaDerivationMethod blockDefault;

		private XmlSchemaDerivationMethod finalDefault;

		private Hashtable schemaLocations;

		private Hashtable chameleonSchemas;

		private Hashtable referenceNamespaces;

		private Hashtable processedExternals;

		private SortedList lockList;

		private XmlReaderSettings readerSettings;

		private XmlSchema rootSchemaForRedefine;

		private ArrayList redefinedList;

		private static XmlSchema builtInSchemaForXmlNS;

		private XmlResolver xmlResolver;

		internal XmlResolver XmlResolver
		{
			set
			{
				xmlResolver = value;
			}
		}

		internal XmlReaderSettings ReaderSettings
		{
			get
			{
				if (readerSettings == null)
				{
					readerSettings = new XmlReaderSettings();
					readerSettings.ProhibitDtd = true;
				}
				return readerSettings;
			}
			set
			{
				readerSettings = value;
			}
		}

		internal Hashtable SchemaLocations
		{
			set
			{
				schemaLocations = value;
			}
		}

		internal Hashtable ChameleonSchemas
		{
			set
			{
				chameleonSchemas = value;
			}
		}

		internal XmlSchema RootSchema => rootSchema;

		public Preprocessor(XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler eventHandler)
			: this(nameTable, schemaNames, eventHandler, new XmlSchemaCompilationSettings())
		{
		}

		public Preprocessor(XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler eventHandler, XmlSchemaCompilationSettings compilationSettings)
			: base(nameTable, schemaNames, eventHandler, compilationSettings)
		{
			referenceNamespaces = new Hashtable();
			processedExternals = new Hashtable();
			lockList = new SortedList();
		}

		public bool Execute(XmlSchema schema, string targetNamespace, bool loadExternals)
		{
			rootSchema = schema;
			Xmlns = base.NameTable.Add("xmlns");
			NsXsi = base.NameTable.Add("http://www.w3.org/2001/XMLSchema-instance");
			rootSchema.ImportedSchemas.Clear();
			rootSchema.ImportedNamespaces.Clear();
			if (rootSchema.BaseUri != null && schemaLocations[rootSchema.BaseUri] == null)
			{
				schemaLocations.Add(rootSchema.BaseUri, rootSchema);
			}
			if (rootSchema.TargetNamespace != null)
			{
				if (targetNamespace == null)
				{
					targetNamespace = rootSchema.TargetNamespace;
				}
				else if (targetNamespace != rootSchema.TargetNamespace)
				{
					SendValidationEvent("Sch_MismatchTargetNamespaceEx", targetNamespace, rootSchema.TargetNamespace, rootSchema);
				}
			}
			else if (targetNamespace != null && targetNamespace.Length != 0)
			{
				rootSchema = GetChameleonSchema(targetNamespace, rootSchema);
			}
			if (loadExternals && xmlResolver != null)
			{
				LoadExternals(rootSchema);
			}
			BuildSchemaList(rootSchema);
			int i = 0;
			try
			{
				for (i = 0; i < lockList.Count; i++)
				{
					XmlSchema xmlSchema = (XmlSchema)lockList.GetByIndex(i);
					Monitor.Enter(xmlSchema);
					xmlSchema.IsProcessing = false;
				}
				rootSchemaForRedefine = rootSchema;
				Preprocess(rootSchema, targetNamespace, rootSchema.ImportedSchemas);
				if (redefinedList != null)
				{
					foreach (RedefineEntry redefined in redefinedList)
					{
						PreprocessRedefine(redefined);
					}
				}
			}
			finally
			{
				if (i == lockList.Count)
				{
					i--;
				}
				while (i >= 0)
				{
					XmlSchema xmlSchema = (XmlSchema)lockList.GetByIndex(i);
					xmlSchema.IsProcessing = false;
					if (xmlSchema == GetBuildInSchema())
					{
						Monitor.Exit(xmlSchema);
					}
					else
					{
						xmlSchema.IsCompiledBySet = false;
						xmlSchema.IsPreprocessed = !base.HasErrors;
						Monitor.Exit(xmlSchema);
					}
					i--;
				}
			}
			rootSchema.IsPreprocessed = !base.HasErrors;
			return !base.HasErrors;
		}

		private void Cleanup(XmlSchema schema)
		{
			if (schema != GetBuildInSchema())
			{
				schema.Attributes.Clear();
				schema.AttributeGroups.Clear();
				schema.SchemaTypes.Clear();
				schema.Elements.Clear();
				schema.Groups.Clear();
				schema.Notations.Clear();
				schema.Ids.Clear();
				schema.IdentityConstraints.Clear();
				schema.IsRedefined = false;
				schema.IsCompiledBySet = false;
			}
		}

		private void CleanupRedefine(XmlSchemaExternal include)
		{
			XmlSchemaRedefine xmlSchemaRedefine = include as XmlSchemaRedefine;
			xmlSchemaRedefine.AttributeGroups.Clear();
			xmlSchemaRedefine.Groups.Clear();
			xmlSchemaRedefine.SchemaTypes.Clear();
		}

		private void BuildSchemaList(XmlSchema schema)
		{
			if (lockList.Contains(schema.SchemaId))
			{
				return;
			}
			lockList.Add(schema.SchemaId, schema);
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (include.Schema != null)
				{
					BuildSchemaList(include.Schema);
				}
			}
		}

		private void LoadExternals(XmlSchema schema)
		{
			if (schema.IsProcessing)
			{
				return;
			}
			schema.IsProcessing = true;
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				Uri uri = null;
				XmlSchema schema2 = include.Schema;
				if (schema2 != null)
				{
					uri = schema2.BaseUri;
					if (uri != null && schemaLocations[uri] == null)
					{
						schemaLocations.Add(uri, schema2);
					}
					LoadExternals(schema2);
					continue;
				}
				string schemaLocation = include.SchemaLocation;
				Uri uri2 = null;
				Exception innerException = null;
				if (schemaLocation != null)
				{
					try
					{
						uri2 = ResolveSchemaLocationUri(schema, schemaLocation);
					}
					catch (Exception ex)
					{
						uri2 = null;
						innerException = ex;
					}
				}
				if (include.Compositor == Compositor.Import)
				{
					XmlSchemaImport xmlSchemaImport = include as XmlSchemaImport;
					string text = ((xmlSchemaImport.Namespace != null) ? xmlSchemaImport.Namespace : string.Empty);
					if (!schema.ImportedNamespaces.Contains(text))
					{
						schema.ImportedNamespaces.Add(text);
					}
					if (text == "http://www.w3.org/XML/1998/namespace" && uri2 == null)
					{
						include.Schema = GetBuildInSchema();
						continue;
					}
				}
				if (uri2 == null)
				{
					if (schemaLocation != null)
					{
						SendValidationEvent(new XmlSchemaException("Sch_InvalidIncludeLocation", null, innerException, include.SourceUri, include.LineNumber, include.LinePosition, include), XmlSeverityType.Warning);
					}
				}
				else if (schemaLocations[uri2] == null)
				{
					object obj = null;
					try
					{
						obj = GetSchemaEntity(uri2);
					}
					catch (Exception ex2)
					{
						innerException = ex2;
						obj = null;
					}
					if (obj != null)
					{
						include.BaseUri = uri2;
						Type type = obj.GetType();
						if (typeof(XmlSchema).IsAssignableFrom(type))
						{
							include.Schema = (XmlSchema)obj;
							schemaLocations.Add(uri2, include.Schema);
							LoadExternals(include.Schema);
							continue;
						}
						XmlReader xmlReader = null;
						if (type.IsSubclassOf(typeof(Stream)))
						{
							readerSettings.CloseInput = true;
							readerSettings.XmlResolver = xmlResolver;
							xmlReader = XmlReader.Create((Stream)obj, readerSettings, uri2.ToString());
						}
						else if (type.IsSubclassOf(typeof(XmlReader)))
						{
							xmlReader = (XmlReader)obj;
						}
						else if (type.IsSubclassOf(typeof(TextReader)))
						{
							readerSettings.CloseInput = true;
							readerSettings.XmlResolver = xmlResolver;
							xmlReader = XmlReader.Create((TextReader)obj, readerSettings, uri2.ToString());
						}
						if (xmlReader == null)
						{
							SendValidationEvent("Sch_InvalidIncludeLocation", include, XmlSeverityType.Warning);
							continue;
						}
						try
						{
							Parser parser = new Parser(SchemaType.XSD, base.NameTable, base.SchemaNames, base.EventHandler);
							parser.Parse(xmlReader, null);
							while (xmlReader.Read())
							{
							}
							schema2 = (include.Schema = parser.XmlSchema);
							schemaLocations.Add(uri2, schema2);
							LoadExternals(schema2);
						}
						catch (XmlSchemaException ex3)
						{
							SendValidationEvent("Sch_CannotLoadSchemaLocation", schemaLocation, ex3.Message, ex3.SourceUri, ex3.LineNumber, ex3.LinePosition);
						}
						catch (Exception innerException2)
						{
							SendValidationEvent(new XmlSchemaException("Sch_InvalidIncludeLocation", null, innerException2, include.SourceUri, include.LineNumber, include.LinePosition, include), XmlSeverityType.Warning);
						}
						finally
						{
							xmlReader.Close();
						}
					}
					else
					{
						SendValidationEvent(new XmlSchemaException("Sch_InvalidIncludeLocation", null, innerException, include.SourceUri, include.LineNumber, include.LinePosition, include), XmlSeverityType.Warning);
					}
				}
				else
				{
					include.Schema = (XmlSchema)schemaLocations[uri2];
				}
			}
		}

		internal static XmlSchema GetBuildInSchema()
		{
			if (builtInSchemaForXmlNS == null)
			{
				XmlSchema xmlSchema = new XmlSchema();
				xmlSchema.TargetNamespace = "http://www.w3.org/XML/1998/namespace";
				xmlSchema.Namespaces.Add("xml", "http://www.w3.org/XML/1998/namespace");
				XmlSchemaAttribute xmlSchemaAttribute = new XmlSchemaAttribute();
				xmlSchemaAttribute.Name = "lang";
				xmlSchemaAttribute.SchemaTypeName = new XmlQualifiedName("language", "http://www.w3.org/2001/XMLSchema");
				xmlSchema.Items.Add(xmlSchemaAttribute);
				XmlSchemaAttribute xmlSchemaAttribute2 = new XmlSchemaAttribute();
				xmlSchemaAttribute2.Name = "base";
				xmlSchemaAttribute2.SchemaTypeName = new XmlQualifiedName("anyURI", "http://www.w3.org/2001/XMLSchema");
				xmlSchema.Items.Add(xmlSchemaAttribute2);
				XmlSchemaAttribute xmlSchemaAttribute3 = new XmlSchemaAttribute();
				xmlSchemaAttribute3.Name = "space";
				XmlSchemaSimpleType xmlSchemaSimpleType = new XmlSchemaSimpleType();
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = new XmlSchemaSimpleTypeRestriction();
				xmlSchemaSimpleTypeRestriction.BaseTypeName = new XmlQualifiedName("NCName", "http://www.w3.org/2001/XMLSchema");
				XmlSchemaEnumerationFacet xmlSchemaEnumerationFacet = new XmlSchemaEnumerationFacet();
				xmlSchemaEnumerationFacet.Value = "default";
				xmlSchemaSimpleTypeRestriction.Facets.Add(xmlSchemaEnumerationFacet);
				XmlSchemaEnumerationFacet xmlSchemaEnumerationFacet2 = new XmlSchemaEnumerationFacet();
				xmlSchemaEnumerationFacet2.Value = "preserve";
				xmlSchemaSimpleTypeRestriction.Facets.Add(xmlSchemaEnumerationFacet2);
				xmlSchemaSimpleType.Content = xmlSchemaSimpleTypeRestriction;
				xmlSchemaAttribute3.SchemaType = xmlSchemaSimpleType;
				xmlSchemaAttribute3.DefaultValue = "preserve";
				xmlSchema.Items.Add(xmlSchemaAttribute3);
				XmlSchemaAttributeGroup xmlSchemaAttributeGroup = new XmlSchemaAttributeGroup();
				xmlSchemaAttributeGroup.Name = "specialAttrs";
				XmlSchemaAttribute xmlSchemaAttribute4 = new XmlSchemaAttribute();
				xmlSchemaAttribute4.RefName = new XmlQualifiedName("lang", "http://www.w3.org/XML/1998/namespace");
				xmlSchemaAttributeGroup.Attributes.Add(xmlSchemaAttribute4);
				XmlSchemaAttribute xmlSchemaAttribute5 = new XmlSchemaAttribute();
				xmlSchemaAttribute5.RefName = new XmlQualifiedName("space", "http://www.w3.org/XML/1998/namespace");
				xmlSchemaAttributeGroup.Attributes.Add(xmlSchemaAttribute5);
				XmlSchemaAttribute xmlSchemaAttribute6 = new XmlSchemaAttribute();
				xmlSchemaAttribute6.RefName = new XmlQualifiedName("base", "http://www.w3.org/XML/1998/namespace");
				xmlSchemaAttributeGroup.Attributes.Add(xmlSchemaAttribute6);
				xmlSchema.Items.Add(xmlSchemaAttributeGroup);
				xmlSchema.IsPreprocessed = true;
				xmlSchema.CompileSchemaInSet(new NameTable(), null, null);
				Interlocked.CompareExchange(ref builtInSchemaForXmlNS, xmlSchema, null);
			}
			return builtInSchemaForXmlNS;
		}

		private void BuildRefNamespaces(XmlSchema schema)
		{
			referenceNamespaces.Clear();
			referenceNamespaces.Add("http://www.w3.org/2001/XMLSchema", "http://www.w3.org/2001/XMLSchema");
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (include is XmlSchemaImport)
				{
					XmlSchemaImport xmlSchemaImport = include as XmlSchemaImport;
					string text = xmlSchemaImport.Namespace;
					if (text == null)
					{
						text = string.Empty;
					}
					if (referenceNamespaces[text] == null)
					{
						referenceNamespaces.Add(text, text);
					}
				}
			}
			string empty = schema.TargetNamespace;
			if (empty == null)
			{
				empty = string.Empty;
			}
			if (referenceNamespaces[empty] == null)
			{
				referenceNamespaces.Add(empty, empty);
			}
		}

		private void ParseUri(string uri, string code, XmlSchemaObject sourceSchemaObject)
		{
			try
			{
				XmlConvert.ToUri(uri);
			}
			catch (FormatException innerException)
			{
				SendValidationEvent(code, new string[1] { uri }, innerException, sourceSchemaObject);
			}
		}

		private void Preprocess(XmlSchema schema, string targetNamespace, ArrayList imports)
		{
			XmlSchema xmlSchema = null;
			if (schema.IsProcessing)
			{
				return;
			}
			schema.IsProcessing = true;
			string text = schema.TargetNamespace;
			if (text != null)
			{
				text = (schema.TargetNamespace = base.NameTable.Add(text));
				if (text.Length == 0)
				{
					SendValidationEvent("Sch_InvalidTargetNamespaceAttribute", schema);
				}
				else
				{
					ParseUri(text, "Sch_InvalidNamespace", schema);
				}
			}
			if (schema.Version != null)
			{
				XmlSchemaDatatype datatype = DatatypeImplementation.GetSimpleTypeFromTypeCode(XmlTypeCode.Token).Datatype;
				object typedValue;
				Exception ex = datatype.TryParseValue(schema.Version, null, null, out typedValue);
				if (ex != null)
				{
					SendValidationEvent("Sch_AttributeValueDataTypeDetailed", new string[4] { "version", schema.Version, datatype.TypeCodeString, ex.Message }, ex, schema);
				}
				else
				{
					schema.Version = (string)typedValue;
				}
			}
			Cleanup(schema);
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				XmlSchema xmlSchema2 = include.Schema;
				SetParent(include, schema);
				PreprocessAnnotation(include);
				string schemaLocation = include.SchemaLocation;
				if (schemaLocation != null)
				{
					ParseUri(schemaLocation, "Sch_InvalidSchemaLocation", include);
				}
				else if ((include.Compositor == Compositor.Include || include.Compositor == Compositor.Redefine) && include.Schema == null)
				{
					SendValidationEvent("Sch_MissRequiredAttribute", "schemaLocation", include);
				}
				switch (include.Compositor)
				{
				case Compositor.Import:
				{
					XmlSchemaImport xmlSchemaImport = include as XmlSchemaImport;
					string @namespace = xmlSchemaImport.Namespace;
					if (@namespace == schema.TargetNamespace)
					{
						SendValidationEvent("Sch_ImportTargetNamespace", include);
					}
					if (xmlSchema2 != null)
					{
						if (@namespace != xmlSchema2.TargetNamespace)
						{
							SendValidationEvent("Sch_MismatchTargetNamespaceImport", @namespace, xmlSchema2.TargetNamespace, xmlSchemaImport);
						}
						xmlSchema = rootSchemaForRedefine;
						rootSchemaForRedefine = xmlSchema2;
						Preprocess(xmlSchema2, @namespace, imports);
						rootSchemaForRedefine = xmlSchema;
					}
					else if (@namespace != null)
					{
						if (@namespace.Length == 0)
						{
							SendValidationEvent("Sch_InvalidNamespaceAttribute", @namespace, include);
						}
						else
						{
							ParseUri(@namespace, "Sch_InvalidNamespace", include);
						}
					}
					continue;
				}
				case Compositor.Include:
				{
					XmlSchema schema2 = include.Schema;
					if (schema2 == null)
					{
						continue;
					}
					break;
				}
				case Compositor.Redefine:
					if (xmlSchema2 == null)
					{
						continue;
					}
					CleanupRedefine(include);
					break;
				}
				if (xmlSchema2.TargetNamespace != null)
				{
					if (schema.TargetNamespace != xmlSchema2.TargetNamespace)
					{
						SendValidationEvent("Sch_MismatchTargetNamespaceInclude", xmlSchema2.TargetNamespace, schema.TargetNamespace, include);
					}
				}
				else if (targetNamespace != null && targetNamespace.Length != 0)
				{
					xmlSchema2 = (include.Schema = GetChameleonSchema(targetNamespace, xmlSchema2));
				}
				Preprocess(xmlSchema2, schema.TargetNamespace, imports);
			}
			currentSchema = schema;
			BuildRefNamespaces(schema);
			ValidateIdAttribute(schema);
			this.targetNamespace = ((targetNamespace == null) ? string.Empty : targetNamespace);
			SetSchemaDefaults(schema);
			processedExternals.Clear();
			for (int i = 0; i < schema.Includes.Count; i++)
			{
				XmlSchemaExternal xmlSchemaExternal2 = (XmlSchemaExternal)schema.Includes[i];
				XmlSchema schema3 = xmlSchemaExternal2.Schema;
				if (schema3 != null)
				{
					switch (xmlSchemaExternal2.Compositor)
					{
					case Compositor.Include:
						if (processedExternals[schema3] != null)
						{
							continue;
						}
						processedExternals.Add(schema3, xmlSchemaExternal2);
						CopyIncludedComponents(schema3, schema);
						break;
					case Compositor.Redefine:
						if (redefinedList == null)
						{
							redefinedList = new ArrayList();
						}
						redefinedList.Add(new RedefineEntry(xmlSchemaExternal2 as XmlSchemaRedefine, rootSchemaForRedefine));
						if (processedExternals[schema3] != null)
						{
							continue;
						}
						processedExternals.Add(schema3, xmlSchemaExternal2);
						CopyIncludedComponents(schema3, schema);
						break;
					case Compositor.Import:
						if (schema3 != rootSchema)
						{
							XmlSchemaImport xmlSchemaImport2 = xmlSchemaExternal2 as XmlSchemaImport;
							string text3 = ((xmlSchemaImport2.Namespace != null) ? xmlSchemaImport2.Namespace : string.Empty);
							if (!imports.Contains(schema3))
							{
								imports.Add(schema3);
							}
							if (!rootSchema.ImportedNamespaces.Contains(text3))
							{
								rootSchema.ImportedNamespaces.Add(text3);
							}
						}
						break;
					}
				}
				else if (xmlSchemaExternal2.Compositor == Compositor.Redefine)
				{
					XmlSchemaRedefine xmlSchemaRedefine = xmlSchemaExternal2 as XmlSchemaRedefine;
					if (xmlSchemaRedefine.BaseUri == null)
					{
						foreach (XmlSchemaObject item2 in xmlSchemaRedefine.Items)
						{
							if (!(item2 is XmlSchemaAnnotation))
							{
								SendValidationEvent("Sch_RedefineNoSchema", xmlSchemaRedefine);
								break;
							}
						}
					}
				}
				ValidateIdAttribute(xmlSchemaExternal2);
			}
			ArrayList arrayList = new ArrayList();
			foreach (XmlSchemaObject item3 in schema.Items)
			{
				SetParent(item3, schema);
				if (item3 is XmlSchemaAttribute)
				{
					XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)item3;
					PreprocessAttribute(xmlSchemaAttribute);
					AddToTable(schema.Attributes, xmlSchemaAttribute.QualifiedName, xmlSchemaAttribute);
				}
				else if (item3 is XmlSchemaAttributeGroup)
				{
					XmlSchemaAttributeGroup xmlSchemaAttributeGroup = (XmlSchemaAttributeGroup)item3;
					PreprocessAttributeGroup(xmlSchemaAttributeGroup);
					AddToTable(schema.AttributeGroups, xmlSchemaAttributeGroup.QualifiedName, xmlSchemaAttributeGroup);
				}
				else if (item3 is XmlSchemaComplexType)
				{
					XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)item3;
					PreprocessComplexType(xmlSchemaComplexType, local: false);
					AddToTable(schema.SchemaTypes, xmlSchemaComplexType.QualifiedName, xmlSchemaComplexType);
				}
				else if (item3 is XmlSchemaSimpleType)
				{
					XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)item3;
					PreprocessSimpleType(xmlSchemaSimpleType, local: false);
					AddToTable(schema.SchemaTypes, xmlSchemaSimpleType.QualifiedName, xmlSchemaSimpleType);
				}
				else if (item3 is XmlSchemaElement)
				{
					XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)item3;
					PreprocessElement(xmlSchemaElement);
					AddToTable(schema.Elements, xmlSchemaElement.QualifiedName, xmlSchemaElement);
				}
				else if (item3 is XmlSchemaGroup)
				{
					XmlSchemaGroup xmlSchemaGroup = (XmlSchemaGroup)item3;
					PreprocessGroup(xmlSchemaGroup);
					AddToTable(schema.Groups, xmlSchemaGroup.QualifiedName, xmlSchemaGroup);
				}
				else if (item3 is XmlSchemaNotation)
				{
					XmlSchemaNotation xmlSchemaNotation = (XmlSchemaNotation)item3;
					PreprocessNotation(xmlSchemaNotation);
					AddToTable(schema.Notations, xmlSchemaNotation.QualifiedName, xmlSchemaNotation);
				}
				else if (item3 is XmlSchemaAnnotation)
				{
					PreprocessAnnotation(item3 as XmlSchemaAnnotation);
				}
				else
				{
					SendValidationEvent("Sch_InvalidCollection", item3);
					arrayList.Add(item3);
				}
			}
			foreach (XmlSchemaObject item4 in arrayList)
			{
				schema.Items.Remove(item4);
			}
		}

		private void CopyIncludedComponents(XmlSchema includedSchema, XmlSchema schema)
		{
			foreach (XmlSchemaElement value in includedSchema.Elements.Values)
			{
				AddToTable(schema.Elements, value.QualifiedName, value);
			}
			foreach (XmlSchemaAttribute value2 in includedSchema.Attributes.Values)
			{
				AddToTable(schema.Attributes, value2.QualifiedName, value2);
			}
			foreach (XmlSchemaGroup value3 in includedSchema.Groups.Values)
			{
				AddToTable(schema.Groups, value3.QualifiedName, value3);
			}
			foreach (XmlSchemaAttributeGroup value4 in includedSchema.AttributeGroups.Values)
			{
				AddToTable(schema.AttributeGroups, value4.QualifiedName, value4);
			}
			foreach (XmlSchemaType value5 in includedSchema.SchemaTypes.Values)
			{
				AddToTable(schema.SchemaTypes, value5.QualifiedName, value5);
			}
			foreach (XmlSchemaNotation value6 in includedSchema.Notations.Values)
			{
				AddToTable(schema.Notations, value6.QualifiedName, value6);
			}
		}

		private void PreprocessRedefine(RedefineEntry redefineEntry)
		{
			XmlSchemaRedefine redefine = redefineEntry.redefine;
			XmlSchema schema = redefine.Schema;
			currentSchema = GetParentSchema(redefine);
			SetSchemaDefaults(currentSchema);
			if (schema.IsRedefined)
			{
				SendValidationEvent("Sch_MultipleRedefine", redefine, XmlSeverityType.Warning);
				return;
			}
			schema.IsRedefined = true;
			XmlSchema schemaToUpdate = redefineEntry.schemaToUpdate;
			ArrayList arrayList = new ArrayList();
			GetIncludedSet(schema, arrayList);
			string @namespace = ((schemaToUpdate.TargetNamespace == null) ? string.Empty : schemaToUpdate.TargetNamespace);
			foreach (XmlSchemaObject item in redefine.Items)
			{
				SetParent(item, redefine);
				if (item is XmlSchemaGroup)
				{
					XmlSchemaGroup xmlSchemaGroup = (XmlSchemaGroup)item;
					PreprocessGroup(xmlSchemaGroup);
					xmlSchemaGroup.QualifiedName.SetNamespace(@namespace);
					if (redefine.Groups[xmlSchemaGroup.QualifiedName] != null)
					{
						SendValidationEvent("Sch_GroupDoubleRedefine", xmlSchemaGroup);
						continue;
					}
					AddToTable(redefine.Groups, xmlSchemaGroup.QualifiedName, xmlSchemaGroup);
					XmlSchemaGroup xmlSchemaGroup2 = (XmlSchemaGroup)schemaToUpdate.Groups[xmlSchemaGroup.QualifiedName];
					XmlSchema parentSchema = GetParentSchema(xmlSchemaGroup2);
					if (xmlSchemaGroup2 == null || (parentSchema != schema && !arrayList.Contains(parentSchema)))
					{
						SendValidationEvent("Sch_ComponentRedefineNotFound", "<group>", xmlSchemaGroup.QualifiedName.ToString(), xmlSchemaGroup);
						continue;
					}
					xmlSchemaGroup.Redefined = xmlSchemaGroup2;
					schemaToUpdate.Groups.Insert(xmlSchemaGroup.QualifiedName, xmlSchemaGroup);
					CheckRefinedGroup(xmlSchemaGroup);
				}
				else if (item is XmlSchemaAttributeGroup)
				{
					XmlSchemaAttributeGroup xmlSchemaAttributeGroup = (XmlSchemaAttributeGroup)item;
					PreprocessAttributeGroup(xmlSchemaAttributeGroup);
					xmlSchemaAttributeGroup.QualifiedName.SetNamespace(@namespace);
					if (redefine.AttributeGroups[xmlSchemaAttributeGroup.QualifiedName] != null)
					{
						SendValidationEvent("Sch_AttrGroupDoubleRedefine", xmlSchemaAttributeGroup);
						continue;
					}
					AddToTable(redefine.AttributeGroups, xmlSchemaAttributeGroup.QualifiedName, xmlSchemaAttributeGroup);
					XmlSchemaAttributeGroup xmlSchemaAttributeGroup2 = (XmlSchemaAttributeGroup)schemaToUpdate.AttributeGroups[xmlSchemaAttributeGroup.QualifiedName];
					XmlSchema parentSchema2 = GetParentSchema(xmlSchemaAttributeGroup2);
					if (xmlSchemaAttributeGroup2 == null || (parentSchema2 != schema && !arrayList.Contains(parentSchema2)))
					{
						SendValidationEvent("Sch_ComponentRedefineNotFound", "<attributeGroup>", xmlSchemaAttributeGroup.QualifiedName.ToString(), xmlSchemaAttributeGroup);
						continue;
					}
					xmlSchemaAttributeGroup.Redefined = xmlSchemaAttributeGroup2;
					schemaToUpdate.AttributeGroups.Insert(xmlSchemaAttributeGroup.QualifiedName, xmlSchemaAttributeGroup);
					CheckRefinedAttributeGroup(xmlSchemaAttributeGroup);
				}
				else if (item is XmlSchemaComplexType)
				{
					XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)item;
					PreprocessComplexType(xmlSchemaComplexType, local: false);
					xmlSchemaComplexType.QualifiedName.SetNamespace(@namespace);
					if (redefine.SchemaTypes[xmlSchemaComplexType.QualifiedName] != null)
					{
						SendValidationEvent("Sch_ComplexTypeDoubleRedefine", xmlSchemaComplexType);
						continue;
					}
					AddToTable(redefine.SchemaTypes, xmlSchemaComplexType.QualifiedName, xmlSchemaComplexType);
					XmlSchemaType xmlSchemaType = (XmlSchemaType)schemaToUpdate.SchemaTypes[xmlSchemaComplexType.QualifiedName];
					XmlSchema parentSchema3 = GetParentSchema(xmlSchemaType);
					if (xmlSchemaType == null || (parentSchema3 != schema && !arrayList.Contains(parentSchema3)))
					{
						SendValidationEvent("Sch_ComponentRedefineNotFound", "<complexType>", xmlSchemaComplexType.QualifiedName.ToString(), xmlSchemaComplexType);
					}
					else if (xmlSchemaType is XmlSchemaComplexType)
					{
						xmlSchemaComplexType.Redefined = xmlSchemaType;
						schemaToUpdate.SchemaTypes.Insert(xmlSchemaComplexType.QualifiedName, xmlSchemaComplexType);
						CheckRefinedComplexType(xmlSchemaComplexType);
					}
					else
					{
						SendValidationEvent("Sch_SimpleToComplexTypeRedefine", xmlSchemaComplexType);
					}
				}
				else
				{
					if (!(item is XmlSchemaSimpleType))
					{
						continue;
					}
					XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)item;
					PreprocessSimpleType(xmlSchemaSimpleType, local: false);
					xmlSchemaSimpleType.QualifiedName.SetNamespace(@namespace);
					if (redefine.SchemaTypes[xmlSchemaSimpleType.QualifiedName] != null)
					{
						SendValidationEvent("Sch_SimpleTypeDoubleRedefine", xmlSchemaSimpleType);
						continue;
					}
					AddToTable(redefine.SchemaTypes, xmlSchemaSimpleType.QualifiedName, xmlSchemaSimpleType);
					XmlSchemaType xmlSchemaType2 = (XmlSchemaType)schemaToUpdate.SchemaTypes[xmlSchemaSimpleType.QualifiedName];
					XmlSchema parentSchema4 = GetParentSchema(xmlSchemaType2);
					if (xmlSchemaType2 == null || (parentSchema4 != schema && !arrayList.Contains(parentSchema4)))
					{
						SendValidationEvent("Sch_ComponentRedefineNotFound", "<simpleType>", xmlSchemaSimpleType.QualifiedName.ToString(), xmlSchemaSimpleType);
					}
					else if (xmlSchemaType2 is XmlSchemaSimpleType)
					{
						xmlSchemaSimpleType.Redefined = xmlSchemaType2;
						schemaToUpdate.SchemaTypes.Insert(xmlSchemaSimpleType.QualifiedName, xmlSchemaSimpleType);
						CheckRefinedSimpleType(xmlSchemaSimpleType);
					}
					else
					{
						SendValidationEvent("Sch_ComplexToSimpleTypeRedefine", xmlSchemaSimpleType);
					}
				}
			}
		}

		private void GetIncludedSet(XmlSchema schema, ArrayList includesList)
		{
			if (includesList.Contains(schema))
			{
				return;
			}
			includesList.Add(schema);
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if ((include.Compositor == Compositor.Include || include.Compositor == Compositor.Redefine) && include.Schema != null)
				{
					GetIncludedSet(include.Schema, includesList);
				}
			}
		}

		internal static XmlSchema GetParentSchema(XmlSchemaObject currentSchemaObject)
		{
			XmlSchema xmlSchema = null;
			while (xmlSchema == null && currentSchemaObject != null)
			{
				currentSchemaObject = currentSchemaObject.Parent;
				xmlSchema = currentSchemaObject as XmlSchema;
			}
			return xmlSchema;
		}

		private void SetSchemaDefaults(XmlSchema schema)
		{
			if (schema.BlockDefault == XmlSchemaDerivationMethod.All)
			{
				blockDefault = XmlSchemaDerivationMethod.All;
			}
			else if (schema.BlockDefault == XmlSchemaDerivationMethod.None)
			{
				blockDefault = XmlSchemaDerivationMethod.Empty;
			}
			else
			{
				if (((uint)schema.BlockDefault & 0xFFFFFFF8u) != 0)
				{
					SendValidationEvent("Sch_InvalidBlockDefaultValue", schema);
				}
				blockDefault = schema.BlockDefault & (XmlSchemaDerivationMethod.Substitution | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction);
			}
			if (schema.FinalDefault == XmlSchemaDerivationMethod.All)
			{
				finalDefault = XmlSchemaDerivationMethod.All;
			}
			else if (schema.FinalDefault == XmlSchemaDerivationMethod.None)
			{
				finalDefault = XmlSchemaDerivationMethod.Empty;
			}
			else
			{
				if (((uint)schema.FinalDefault & 0xFFFFFFE1u) != 0)
				{
					SendValidationEvent("Sch_InvalidFinalDefaultValue", schema);
				}
				finalDefault = schema.FinalDefault & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union);
			}
			elementFormDefault = schema.ElementFormDefault;
			if (elementFormDefault == XmlSchemaForm.None)
			{
				elementFormDefault = XmlSchemaForm.Unqualified;
			}
			attributeFormDefault = schema.AttributeFormDefault;
			if (attributeFormDefault == XmlSchemaForm.None)
			{
				attributeFormDefault = XmlSchemaForm.Unqualified;
			}
		}

		private int CountGroupSelfReference(XmlSchemaObjectCollection items, XmlQualifiedName name, XmlSchemaGroup redefined)
		{
			int num = 0;
			foreach (XmlSchemaParticle item in items)
			{
				if (item is XmlSchemaGroupRef)
				{
					XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef)item;
					if (xmlSchemaGroupRef.RefName == name)
					{
						xmlSchemaGroupRef.Redefined = redefined;
						if (xmlSchemaGroupRef.MinOccurs != 1m || xmlSchemaGroupRef.MaxOccurs != 1m)
						{
							SendValidationEvent("Sch_MinMaxGroupRedefine", xmlSchemaGroupRef);
						}
						num++;
					}
				}
				else if (item is XmlSchemaGroupBase)
				{
					num += CountGroupSelfReference(((XmlSchemaGroupBase)item).Items, name, redefined);
				}
				if (num > 1)
				{
					return num;
				}
			}
			return num;
		}

		private void CheckRefinedGroup(XmlSchemaGroup group)
		{
			int num = 0;
			if (group.Particle != null)
			{
				num = CountGroupSelfReference(group.Particle.Items, group.QualifiedName, group.Redefined);
			}
			if (num > 1)
			{
				SendValidationEvent("Sch_MultipleGroupSelfRef", group);
			}
			group.SelfReferenceCount = num;
		}

		private void CheckRefinedAttributeGroup(XmlSchemaAttributeGroup attributeGroup)
		{
			int num = 0;
			foreach (XmlSchemaObject attribute in attributeGroup.Attributes)
			{
				if (attribute is XmlSchemaAttributeGroupRef && ((XmlSchemaAttributeGroupRef)attribute).RefName == attributeGroup.QualifiedName)
				{
					num++;
				}
			}
			if (num > 1)
			{
				SendValidationEvent("Sch_MultipleAttrGroupSelfRef", attributeGroup);
			}
			attributeGroup.SelfReferenceCount = num;
		}

		private void CheckRefinedSimpleType(XmlSchemaSimpleType stype)
		{
			if (stype.Content != null && stype.Content is XmlSchemaSimpleTypeRestriction)
			{
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)stype.Content;
				if (xmlSchemaSimpleTypeRestriction.BaseTypeName == stype.QualifiedName)
				{
					return;
				}
			}
			SendValidationEvent("Sch_InvalidTypeRedefine", stype);
		}

		private void CheckRefinedComplexType(XmlSchemaComplexType ctype)
		{
			if (ctype.ContentModel != null)
			{
				XmlQualifiedName xmlQualifiedName;
				if (ctype.ContentModel is XmlSchemaComplexContent)
				{
					XmlSchemaComplexContent xmlSchemaComplexContent = (XmlSchemaComplexContent)ctype.ContentModel;
					xmlQualifiedName = ((!(xmlSchemaComplexContent.Content is XmlSchemaComplexContentRestriction)) ? ((XmlSchemaComplexContentExtension)xmlSchemaComplexContent.Content).BaseTypeName : ((XmlSchemaComplexContentRestriction)xmlSchemaComplexContent.Content).BaseTypeName);
				}
				else
				{
					XmlSchemaSimpleContent xmlSchemaSimpleContent = (XmlSchemaSimpleContent)ctype.ContentModel;
					xmlQualifiedName = ((!(xmlSchemaSimpleContent.Content is XmlSchemaSimpleContentRestriction)) ? ((XmlSchemaSimpleContentExtension)xmlSchemaSimpleContent.Content).BaseTypeName : ((XmlSchemaSimpleContentRestriction)xmlSchemaSimpleContent.Content).BaseTypeName);
				}
				if (xmlQualifiedName == ctype.QualifiedName)
				{
					return;
				}
			}
			SendValidationEvent("Sch_InvalidTypeRedefine", ctype);
		}

		private void PreprocessAttribute(XmlSchemaAttribute attribute)
		{
			if (attribute.Name != null)
			{
				ValidateNameAttribute(attribute);
				attribute.SetQualifiedName(new XmlQualifiedName(attribute.Name, targetNamespace));
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", attribute);
			}
			if (attribute.Use != 0)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "use", attribute);
			}
			if (attribute.Form != 0)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "form", attribute);
			}
			PreprocessAttributeContent(attribute);
			ValidateIdAttribute(attribute);
		}

		private void PreprocessLocalAttribute(XmlSchemaAttribute attribute)
		{
			if (attribute.Name != null)
			{
				ValidateNameAttribute(attribute);
				PreprocessAttributeContent(attribute);
				attribute.SetQualifiedName(new XmlQualifiedName(attribute.Name, (attribute.Form == XmlSchemaForm.Qualified || (attribute.Form == XmlSchemaForm.None && attributeFormDefault == XmlSchemaForm.Qualified)) ? targetNamespace : null));
			}
			else
			{
				PreprocessAnnotation(attribute);
				if (attribute.RefName.IsEmpty)
				{
					SendValidationEvent("Sch_AttributeNameRef", "???", attribute);
				}
				else
				{
					ValidateQNameAttribute(attribute, "ref", attribute.RefName);
				}
				if (!attribute.SchemaTypeName.IsEmpty || attribute.SchemaType != null || attribute.Form != 0)
				{
					SendValidationEvent("Sch_InvalidAttributeRef", attribute);
				}
				attribute.SetQualifiedName(attribute.RefName);
			}
			ValidateIdAttribute(attribute);
		}

		private void PreprocessAttributeContent(XmlSchemaAttribute attribute)
		{
			PreprocessAnnotation(attribute);
			if (Ref.Equal(currentSchema.TargetNamespace, NsXsi))
			{
				SendValidationEvent("Sch_TargetNamespaceXsi", attribute);
			}
			if (!attribute.RefName.IsEmpty)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "ref", attribute);
			}
			if (attribute.DefaultValue != null && attribute.FixedValue != null)
			{
				SendValidationEvent("Sch_DefaultFixedAttributes", attribute);
			}
			if (attribute.DefaultValue != null && attribute.Use != XmlSchemaUse.Optional && attribute.Use != 0)
			{
				SendValidationEvent("Sch_OptionalDefaultAttribute", attribute);
			}
			if (attribute.Name == Xmlns)
			{
				SendValidationEvent("Sch_XmlNsAttribute", attribute);
			}
			if (attribute.SchemaType != null)
			{
				SetParent(attribute.SchemaType, attribute);
				if (!attribute.SchemaTypeName.IsEmpty)
				{
					SendValidationEvent("Sch_TypeMutualExclusive", attribute);
				}
				PreprocessSimpleType(attribute.SchemaType, local: true);
			}
			if (!attribute.SchemaTypeName.IsEmpty)
			{
				ValidateQNameAttribute(attribute, "type", attribute.SchemaTypeName);
			}
		}

		private void PreprocessAttributeGroup(XmlSchemaAttributeGroup attributeGroup)
		{
			if (attributeGroup.Name != null)
			{
				ValidateNameAttribute(attributeGroup);
				attributeGroup.SetQualifiedName(new XmlQualifiedName(attributeGroup.Name, targetNamespace));
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", attributeGroup);
			}
			PreprocessAttributes(attributeGroup.Attributes, attributeGroup.AnyAttribute, attributeGroup);
			PreprocessAnnotation(attributeGroup);
			ValidateIdAttribute(attributeGroup);
		}

		private void PreprocessElement(XmlSchemaElement element)
		{
			if (element.Name != null)
			{
				ValidateNameAttribute(element);
				element.SetQualifiedName(new XmlQualifiedName(element.Name, targetNamespace));
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", element);
			}
			PreprocessElementContent(element);
			if (element.Final == XmlSchemaDerivationMethod.All)
			{
				element.SetFinalResolved(XmlSchemaDerivationMethod.All);
			}
			else if (element.Final == XmlSchemaDerivationMethod.None)
			{
				if (finalDefault == XmlSchemaDerivationMethod.All)
				{
					element.SetFinalResolved(XmlSchemaDerivationMethod.All);
				}
				else
				{
					element.SetFinalResolved(finalDefault & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
				}
			}
			else
			{
				if (((uint)element.Final & 0xFFFFFFF9u) != 0)
				{
					SendValidationEvent("Sch_InvalidElementFinalValue", element);
				}
				element.SetFinalResolved(element.Final & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
			}
			if (element.Form != 0)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "form", element);
			}
			if (element.MinOccursString != null)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "minOccurs", element);
			}
			if (element.MaxOccursString != null)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "maxOccurs", element);
			}
			if (!element.SubstitutionGroup.IsEmpty)
			{
				ValidateQNameAttribute(element, "type", element.SubstitutionGroup);
			}
			ValidateIdAttribute(element);
		}

		private void PreprocessLocalElement(XmlSchemaElement element)
		{
			if (element.Name != null)
			{
				ValidateNameAttribute(element);
				PreprocessElementContent(element);
				element.SetQualifiedName(new XmlQualifiedName(element.Name, (element.Form == XmlSchemaForm.Qualified || (element.Form == XmlSchemaForm.None && elementFormDefault == XmlSchemaForm.Qualified)) ? targetNamespace : null));
			}
			else
			{
				PreprocessAnnotation(element);
				if (element.RefName.IsEmpty)
				{
					SendValidationEvent("Sch_ElementNameRef", element);
				}
				else
				{
					ValidateQNameAttribute(element, "ref", element.RefName);
				}
				if (!element.SchemaTypeName.IsEmpty || element.HasAbstractAttribute || element.Block != XmlSchemaDerivationMethod.None || element.SchemaType != null || element.HasConstraints || element.DefaultValue != null || element.Form != 0 || element.FixedValue != null || element.HasNillableAttribute)
				{
					SendValidationEvent("Sch_InvalidElementRef", element);
				}
				if (element.DefaultValue != null && element.FixedValue != null)
				{
					SendValidationEvent("Sch_DefaultFixedAttributes", element);
				}
				element.SetQualifiedName(element.RefName);
			}
			if (element.MinOccurs > element.MaxOccurs)
			{
				element.MinOccurs = 0m;
				SendValidationEvent("Sch_MinGtMax", element);
			}
			if (element.HasAbstractAttribute)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "abstract", element);
			}
			if (element.Final != XmlSchemaDerivationMethod.None)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "final", element);
			}
			if (!element.SubstitutionGroup.IsEmpty)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "substitutionGroup", element);
			}
			ValidateIdAttribute(element);
		}

		private void PreprocessElementContent(XmlSchemaElement element)
		{
			PreprocessAnnotation(element);
			if (!element.RefName.IsEmpty)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "ref", element);
			}
			if (element.Block == XmlSchemaDerivationMethod.All)
			{
				element.SetBlockResolved(XmlSchemaDerivationMethod.All);
			}
			else if (element.Block == XmlSchemaDerivationMethod.None)
			{
				if (blockDefault == XmlSchemaDerivationMethod.All)
				{
					element.SetBlockResolved(XmlSchemaDerivationMethod.All);
				}
				else
				{
					element.SetBlockResolved(blockDefault & (XmlSchemaDerivationMethod.Substitution | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
				}
			}
			else
			{
				if (((uint)element.Block & 0xFFFFFFF8u) != 0)
				{
					SendValidationEvent("Sch_InvalidElementBlockValue", element);
				}
				element.SetBlockResolved(element.Block & (XmlSchemaDerivationMethod.Substitution | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
			}
			if (element.SchemaType != null)
			{
				SetParent(element.SchemaType, element);
				if (!element.SchemaTypeName.IsEmpty)
				{
					SendValidationEvent("Sch_TypeMutualExclusive", element);
				}
				if (element.SchemaType is XmlSchemaComplexType)
				{
					PreprocessComplexType((XmlSchemaComplexType)element.SchemaType, local: true);
				}
				else
				{
					PreprocessSimpleType((XmlSchemaSimpleType)element.SchemaType, local: true);
				}
			}
			if (!element.SchemaTypeName.IsEmpty)
			{
				ValidateQNameAttribute(element, "type", element.SchemaTypeName);
			}
			if (element.DefaultValue != null && element.FixedValue != null)
			{
				SendValidationEvent("Sch_DefaultFixedAttributes", element);
			}
			foreach (XmlSchemaIdentityConstraint constraint in element.Constraints)
			{
				SetParent(constraint, element);
				PreprocessIdentityConstraint(constraint);
			}
		}

		private void PreprocessIdentityConstraint(XmlSchemaIdentityConstraint constraint)
		{
			bool flag = true;
			PreprocessAnnotation(constraint);
			if (constraint.Name != null)
			{
				ValidateNameAttribute(constraint);
				constraint.SetQualifiedName(new XmlQualifiedName(constraint.Name, targetNamespace));
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", constraint);
				flag = false;
			}
			if (rootSchema.IdentityConstraints[constraint.QualifiedName] != null)
			{
				SendValidationEvent("Sch_DupIdentityConstraint", constraint.QualifiedName.ToString(), constraint);
				flag = false;
			}
			else
			{
				rootSchema.IdentityConstraints.Add(constraint.QualifiedName, constraint);
			}
			if (constraint.Selector == null)
			{
				SendValidationEvent("Sch_IdConstraintNoSelector", constraint);
				flag = false;
			}
			if (constraint.Fields.Count == 0)
			{
				SendValidationEvent("Sch_IdConstraintNoFields", constraint);
				flag = false;
			}
			if (constraint is XmlSchemaKeyref)
			{
				XmlSchemaKeyref xmlSchemaKeyref = (XmlSchemaKeyref)constraint;
				if (xmlSchemaKeyref.Refer.IsEmpty)
				{
					SendValidationEvent("Sch_IdConstraintNoRefer", constraint);
					flag = false;
				}
				else
				{
					ValidateQNameAttribute(xmlSchemaKeyref, "refer", xmlSchemaKeyref.Refer);
				}
			}
			if (!flag)
			{
				return;
			}
			ValidateIdAttribute(constraint);
			ValidateIdAttribute(constraint.Selector);
			SetParent(constraint.Selector, constraint);
			foreach (XmlSchemaXPath field in constraint.Fields)
			{
				SetParent(field, constraint);
				ValidateIdAttribute(field);
			}
		}

		private void PreprocessSimpleType(XmlSchemaSimpleType simpleType, bool local)
		{
			if (local)
			{
				if (simpleType.Name != null)
				{
					SendValidationEvent("Sch_ForbiddenAttribute", "name", simpleType);
				}
			}
			else
			{
				if (simpleType.Name != null)
				{
					ValidateNameAttribute(simpleType);
					simpleType.SetQualifiedName(new XmlQualifiedName(simpleType.Name, targetNamespace));
				}
				else
				{
					SendValidationEvent("Sch_MissRequiredAttribute", "name", simpleType);
				}
				if (simpleType.Final == XmlSchemaDerivationMethod.All)
				{
					simpleType.SetFinalResolved(XmlSchemaDerivationMethod.All);
				}
				else if (simpleType.Final == XmlSchemaDerivationMethod.None)
				{
					if (finalDefault == XmlSchemaDerivationMethod.All)
					{
						simpleType.SetFinalResolved(XmlSchemaDerivationMethod.All);
					}
					else
					{
						simpleType.SetFinalResolved(finalDefault & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union));
					}
				}
				else
				{
					if (((uint)simpleType.Final & 0xFFFFFFE1u) != 0)
					{
						SendValidationEvent("Sch_InvalidSimpleTypeFinalValue", simpleType);
					}
					simpleType.SetFinalResolved(simpleType.Final & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union));
				}
			}
			if (simpleType.Content == null)
			{
				SendValidationEvent("Sch_NoSimpleTypeContent", simpleType);
			}
			else if (simpleType.Content is XmlSchemaSimpleTypeRestriction)
			{
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)simpleType.Content;
				SetParent(xmlSchemaSimpleTypeRestriction, simpleType);
				foreach (XmlSchemaObject facet in xmlSchemaSimpleTypeRestriction.Facets)
				{
					SetParent(facet, xmlSchemaSimpleTypeRestriction);
				}
				if (xmlSchemaSimpleTypeRestriction.BaseType != null)
				{
					if (!xmlSchemaSimpleTypeRestriction.BaseTypeName.IsEmpty)
					{
						SendValidationEvent("Sch_SimpleTypeRestRefBase", xmlSchemaSimpleTypeRestriction);
					}
					PreprocessSimpleType(xmlSchemaSimpleTypeRestriction.BaseType, local: true);
				}
				else if (xmlSchemaSimpleTypeRestriction.BaseTypeName.IsEmpty)
				{
					SendValidationEvent("Sch_SimpleTypeRestRefBaseNone", xmlSchemaSimpleTypeRestriction);
				}
				else
				{
					ValidateQNameAttribute(xmlSchemaSimpleTypeRestriction, "base", xmlSchemaSimpleTypeRestriction.BaseTypeName);
				}
				PreprocessAnnotation(xmlSchemaSimpleTypeRestriction);
				ValidateIdAttribute(xmlSchemaSimpleTypeRestriction);
			}
			else if (simpleType.Content is XmlSchemaSimpleTypeList)
			{
				XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = (XmlSchemaSimpleTypeList)simpleType.Content;
				SetParent(xmlSchemaSimpleTypeList, simpleType);
				if (xmlSchemaSimpleTypeList.ItemType != null)
				{
					if (!xmlSchemaSimpleTypeList.ItemTypeName.IsEmpty)
					{
						SendValidationEvent("Sch_SimpleTypeListRefBase", xmlSchemaSimpleTypeList);
					}
					SetParent(xmlSchemaSimpleTypeList.ItemType, xmlSchemaSimpleTypeList);
					PreprocessSimpleType(xmlSchemaSimpleTypeList.ItemType, local: true);
				}
				else if (xmlSchemaSimpleTypeList.ItemTypeName.IsEmpty)
				{
					SendValidationEvent("Sch_SimpleTypeListRefBaseNone", xmlSchemaSimpleTypeList);
				}
				else
				{
					ValidateQNameAttribute(xmlSchemaSimpleTypeList, "itemType", xmlSchemaSimpleTypeList.ItemTypeName);
				}
				PreprocessAnnotation(xmlSchemaSimpleTypeList);
				ValidateIdAttribute(xmlSchemaSimpleTypeList);
			}
			else
			{
				XmlSchemaSimpleTypeUnion xmlSchemaSimpleTypeUnion = (XmlSchemaSimpleTypeUnion)simpleType.Content;
				SetParent(xmlSchemaSimpleTypeUnion, simpleType);
				int num = xmlSchemaSimpleTypeUnion.BaseTypes.Count;
				if (xmlSchemaSimpleTypeUnion.MemberTypes != null)
				{
					num += xmlSchemaSimpleTypeUnion.MemberTypes.Length;
					XmlQualifiedName[] memberTypes = xmlSchemaSimpleTypeUnion.MemberTypes;
					foreach (XmlQualifiedName value in memberTypes)
					{
						ValidateQNameAttribute(xmlSchemaSimpleTypeUnion, "memberTypes", value);
					}
				}
				if (num == 0)
				{
					SendValidationEvent("Sch_SimpleTypeUnionNoBase", xmlSchemaSimpleTypeUnion);
				}
				foreach (XmlSchemaSimpleType baseType in xmlSchemaSimpleTypeUnion.BaseTypes)
				{
					SetParent(baseType, xmlSchemaSimpleTypeUnion);
					PreprocessSimpleType(baseType, local: true);
				}
				PreprocessAnnotation(xmlSchemaSimpleTypeUnion);
				ValidateIdAttribute(xmlSchemaSimpleTypeUnion);
			}
			ValidateIdAttribute(simpleType);
		}

		private void PreprocessComplexType(XmlSchemaComplexType complexType, bool local)
		{
			if (local)
			{
				if (complexType.Name != null)
				{
					SendValidationEvent("Sch_ForbiddenAttribute", "name", complexType);
				}
			}
			else
			{
				if (complexType.Name != null)
				{
					ValidateNameAttribute(complexType);
					complexType.SetQualifiedName(new XmlQualifiedName(complexType.Name, targetNamespace));
				}
				else
				{
					SendValidationEvent("Sch_MissRequiredAttribute", "name", complexType);
				}
				if (complexType.Block == XmlSchemaDerivationMethod.All)
				{
					complexType.SetBlockResolved(XmlSchemaDerivationMethod.All);
				}
				else if (complexType.Block == XmlSchemaDerivationMethod.None)
				{
					complexType.SetBlockResolved(blockDefault & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
				}
				else
				{
					if (((uint)complexType.Block & 0xFFFFFFF9u) != 0)
					{
						SendValidationEvent("Sch_InvalidComplexTypeBlockValue", complexType);
					}
					complexType.SetBlockResolved(complexType.Block & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
				}
				if (complexType.Final == XmlSchemaDerivationMethod.All)
				{
					complexType.SetFinalResolved(XmlSchemaDerivationMethod.All);
				}
				else if (complexType.Final == XmlSchemaDerivationMethod.None)
				{
					if (finalDefault == XmlSchemaDerivationMethod.All)
					{
						complexType.SetFinalResolved(XmlSchemaDerivationMethod.All);
					}
					else
					{
						complexType.SetFinalResolved(finalDefault & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
					}
				}
				else
				{
					if (((uint)complexType.Final & 0xFFFFFFF9u) != 0)
					{
						SendValidationEvent("Sch_InvalidComplexTypeFinalValue", complexType);
					}
					complexType.SetFinalResolved(complexType.Final & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
				}
			}
			if (complexType.ContentModel != null)
			{
				SetParent(complexType.ContentModel, complexType);
				PreprocessAnnotation(complexType.ContentModel);
				if (complexType.Particle == null)
				{
					_ = complexType.Attributes;
				}
				if (complexType.ContentModel is XmlSchemaSimpleContent)
				{
					XmlSchemaSimpleContent xmlSchemaSimpleContent = (XmlSchemaSimpleContent)complexType.ContentModel;
					if (xmlSchemaSimpleContent.Content == null)
					{
						if (complexType.QualifiedName == XmlQualifiedName.Empty)
						{
							SendValidationEvent("Sch_NoRestOrExt", complexType);
						}
						else
						{
							SendValidationEvent("Sch_NoRestOrExtQName", complexType.QualifiedName.Name, complexType.QualifiedName.Namespace, complexType);
						}
					}
					else
					{
						SetParent(xmlSchemaSimpleContent.Content, xmlSchemaSimpleContent);
						PreprocessAnnotation(xmlSchemaSimpleContent.Content);
						if (xmlSchemaSimpleContent.Content is XmlSchemaSimpleContentExtension)
						{
							XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = (XmlSchemaSimpleContentExtension)xmlSchemaSimpleContent.Content;
							if (xmlSchemaSimpleContentExtension.BaseTypeName.IsEmpty)
							{
								SendValidationEvent("Sch_MissAttribute", "base", xmlSchemaSimpleContentExtension);
							}
							else
							{
								ValidateQNameAttribute(xmlSchemaSimpleContentExtension, "base", xmlSchemaSimpleContentExtension.BaseTypeName);
							}
							PreprocessAttributes(xmlSchemaSimpleContentExtension.Attributes, xmlSchemaSimpleContentExtension.AnyAttribute, xmlSchemaSimpleContentExtension);
							ValidateIdAttribute(xmlSchemaSimpleContentExtension);
						}
						else
						{
							XmlSchemaSimpleContentRestriction xmlSchemaSimpleContentRestriction = (XmlSchemaSimpleContentRestriction)xmlSchemaSimpleContent.Content;
							if (xmlSchemaSimpleContentRestriction.BaseTypeName.IsEmpty)
							{
								SendValidationEvent("Sch_MissAttribute", "base", xmlSchemaSimpleContentRestriction);
							}
							else
							{
								ValidateQNameAttribute(xmlSchemaSimpleContentRestriction, "base", xmlSchemaSimpleContentRestriction.BaseTypeName);
							}
							if (xmlSchemaSimpleContentRestriction.BaseType != null)
							{
								SetParent(xmlSchemaSimpleContentRestriction.BaseType, xmlSchemaSimpleContentRestriction);
								PreprocessSimpleType(xmlSchemaSimpleContentRestriction.BaseType, local: true);
							}
							PreprocessAttributes(xmlSchemaSimpleContentRestriction.Attributes, xmlSchemaSimpleContentRestriction.AnyAttribute, xmlSchemaSimpleContentRestriction);
							ValidateIdAttribute(xmlSchemaSimpleContentRestriction);
						}
					}
					ValidateIdAttribute(xmlSchemaSimpleContent);
				}
				else
				{
					XmlSchemaComplexContent xmlSchemaComplexContent = (XmlSchemaComplexContent)complexType.ContentModel;
					if (xmlSchemaComplexContent.Content == null)
					{
						if (complexType.QualifiedName == XmlQualifiedName.Empty)
						{
							SendValidationEvent("Sch_NoRestOrExt", complexType);
						}
						else
						{
							SendValidationEvent("Sch_NoRestOrExtQName", complexType.QualifiedName.Name, complexType.QualifiedName.Namespace, complexType);
						}
					}
					else
					{
						if (!xmlSchemaComplexContent.HasMixedAttribute && complexType.IsMixed)
						{
							xmlSchemaComplexContent.IsMixed = true;
						}
						SetParent(xmlSchemaComplexContent.Content, xmlSchemaComplexContent);
						PreprocessAnnotation(xmlSchemaComplexContent.Content);
						if (xmlSchemaComplexContent.Content is XmlSchemaComplexContentExtension)
						{
							XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension = (XmlSchemaComplexContentExtension)xmlSchemaComplexContent.Content;
							if (xmlSchemaComplexContentExtension.BaseTypeName.IsEmpty)
							{
								SendValidationEvent("Sch_MissAttribute", "base", xmlSchemaComplexContentExtension);
							}
							else
							{
								ValidateQNameAttribute(xmlSchemaComplexContentExtension, "base", xmlSchemaComplexContentExtension.BaseTypeName);
							}
							if (xmlSchemaComplexContentExtension.Particle != null)
							{
								SetParent(xmlSchemaComplexContentExtension.Particle, xmlSchemaComplexContentExtension);
								PreprocessParticle(xmlSchemaComplexContentExtension.Particle);
							}
							PreprocessAttributes(xmlSchemaComplexContentExtension.Attributes, xmlSchemaComplexContentExtension.AnyAttribute, xmlSchemaComplexContentExtension);
							ValidateIdAttribute(xmlSchemaComplexContentExtension);
						}
						else
						{
							XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction = (XmlSchemaComplexContentRestriction)xmlSchemaComplexContent.Content;
							if (xmlSchemaComplexContentRestriction.BaseTypeName.IsEmpty)
							{
								SendValidationEvent("Sch_MissAttribute", "base", xmlSchemaComplexContentRestriction);
							}
							else
							{
								ValidateQNameAttribute(xmlSchemaComplexContentRestriction, "base", xmlSchemaComplexContentRestriction.BaseTypeName);
							}
							if (xmlSchemaComplexContentRestriction.Particle != null)
							{
								SetParent(xmlSchemaComplexContentRestriction.Particle, xmlSchemaComplexContentRestriction);
								PreprocessParticle(xmlSchemaComplexContentRestriction.Particle);
							}
							PreprocessAttributes(xmlSchemaComplexContentRestriction.Attributes, xmlSchemaComplexContentRestriction.AnyAttribute, xmlSchemaComplexContentRestriction);
							ValidateIdAttribute(xmlSchemaComplexContentRestriction);
						}
						ValidateIdAttribute(xmlSchemaComplexContent);
					}
				}
			}
			else
			{
				if (complexType.Particle != null)
				{
					SetParent(complexType.Particle, complexType);
					PreprocessParticle(complexType.Particle);
				}
				PreprocessAttributes(complexType.Attributes, complexType.AnyAttribute, complexType);
			}
			ValidateIdAttribute(complexType);
		}

		private void PreprocessGroup(XmlSchemaGroup group)
		{
			if (group.Name != null)
			{
				ValidateNameAttribute(group);
				group.SetQualifiedName(new XmlQualifiedName(group.Name, targetNamespace));
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", group);
			}
			if (group.Particle == null)
			{
				SendValidationEvent("Sch_NoGroupParticle", group);
				return;
			}
			if (group.Particle.MinOccursString != null)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "minOccurs", group.Particle);
			}
			if (group.Particle.MaxOccursString != null)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "maxOccurs", group.Particle);
			}
			PreprocessParticle(group.Particle);
			PreprocessAnnotation(group);
			ValidateIdAttribute(group);
		}

		private void PreprocessNotation(XmlSchemaNotation notation)
		{
			if (notation.Name != null)
			{
				ValidateNameAttribute(notation);
				notation.QualifiedName = new XmlQualifiedName(notation.Name, targetNamespace);
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", notation);
			}
			if (notation.Public == null && notation.System == null)
			{
				SendValidationEvent("Sch_MissingPublicSystemAttribute", notation);
			}
			else
			{
				if (notation.Public != null)
				{
					try
					{
						XmlConvert.VerifyTOKEN(notation.Public);
					}
					catch (XmlException innerException)
					{
						SendValidationEvent("Sch_InvalidPublicAttribute", new string[1] { notation.Public }, innerException, notation);
					}
				}
				if (notation.System != null)
				{
					ParseUri(notation.System, "Sch_InvalidSystemAttribute", notation);
				}
			}
			PreprocessAnnotation(notation);
			ValidateIdAttribute(notation);
		}

		private void PreprocessParticle(XmlSchemaParticle particle)
		{
			if (particle is XmlSchemaAll)
			{
				if (particle.MinOccurs != 0m && particle.MinOccurs != 1m)
				{
					particle.MinOccurs = 1m;
					SendValidationEvent("Sch_InvalidAllMin", particle);
				}
				if (particle.MaxOccurs != 1m)
				{
					particle.MaxOccurs = 1m;
					SendValidationEvent("Sch_InvalidAllMax", particle);
				}
				foreach (XmlSchemaElement item in ((XmlSchemaAll)particle).Items)
				{
					if (item.MaxOccurs != 0m && item.MaxOccurs != 1m)
					{
						item.MaxOccurs = 1m;
						SendValidationEvent("Sch_InvalidAllElementMax", item);
					}
					SetParent(item, particle);
					PreprocessLocalElement(item);
				}
			}
			else
			{
				if (particle.MinOccurs > particle.MaxOccurs)
				{
					particle.MinOccurs = particle.MaxOccurs;
					SendValidationEvent("Sch_MinGtMax", particle);
				}
				if (particle is XmlSchemaChoice)
				{
					foreach (XmlSchemaObject item2 in ((XmlSchemaChoice)particle).Items)
					{
						SetParent(item2, particle);
						if (item2 is XmlSchemaElement)
						{
							PreprocessLocalElement((XmlSchemaElement)item2);
						}
						else
						{
							PreprocessParticle((XmlSchemaParticle)item2);
						}
					}
				}
				else if (particle is XmlSchemaSequence)
				{
					foreach (XmlSchemaObject item3 in ((XmlSchemaSequence)particle).Items)
					{
						SetParent(item3, particle);
						if (item3 is XmlSchemaElement)
						{
							PreprocessLocalElement((XmlSchemaElement)item3);
						}
						else
						{
							PreprocessParticle((XmlSchemaParticle)item3);
						}
					}
				}
				else if (particle is XmlSchemaGroupRef)
				{
					XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef)particle;
					if (xmlSchemaGroupRef.RefName.IsEmpty)
					{
						SendValidationEvent("Sch_MissAttribute", "ref", xmlSchemaGroupRef);
					}
					else
					{
						ValidateQNameAttribute(xmlSchemaGroupRef, "ref", xmlSchemaGroupRef.RefName);
					}
				}
				else if (particle is XmlSchemaAny)
				{
					try
					{
						((XmlSchemaAny)particle).BuildNamespaceList(targetNamespace);
					}
					catch (FormatException ex)
					{
						SendValidationEvent("Sch_InvalidAnyDetailed", new string[1] { ex.Message }, ex, particle);
					}
				}
			}
			PreprocessAnnotation(particle);
			ValidateIdAttribute(particle);
		}

		private void PreprocessAttributes(XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, XmlSchemaObject parent)
		{
			foreach (XmlSchemaAnnotated attribute in attributes)
			{
				SetParent(attribute, parent);
				if (attribute is XmlSchemaAttribute)
				{
					PreprocessLocalAttribute((XmlSchemaAttribute)attribute);
					continue;
				}
				XmlSchemaAttributeGroupRef xmlSchemaAttributeGroupRef = (XmlSchemaAttributeGroupRef)attribute;
				if (xmlSchemaAttributeGroupRef.RefName.IsEmpty)
				{
					SendValidationEvent("Sch_MissAttribute", "ref", xmlSchemaAttributeGroupRef);
				}
				else
				{
					ValidateQNameAttribute(xmlSchemaAttributeGroupRef, "ref", xmlSchemaAttributeGroupRef.RefName);
				}
				PreprocessAnnotation(attribute);
				ValidateIdAttribute(attribute);
			}
			if (anyAttribute != null)
			{
				try
				{
					SetParent(anyAttribute, parent);
					PreprocessAnnotation(anyAttribute);
					anyAttribute.BuildNamespaceList(targetNamespace);
				}
				catch (FormatException ex)
				{
					SendValidationEvent("Sch_InvalidAnyDetailed", new string[1] { ex.Message }, ex, anyAttribute);
				}
				ValidateIdAttribute(anyAttribute);
			}
		}

		private void ValidateIdAttribute(XmlSchemaObject xso)
		{
			if (xso.IdAttribute != null)
			{
				try
				{
					xso.IdAttribute = base.NameTable.Add(XmlConvert.VerifyNCName(xso.IdAttribute));
				}
				catch (XmlException ex)
				{
					SendValidationEvent("Sch_InvalidIdAttribute", new string[1] { ex.Message }, ex, xso);
					return;
				}
				catch (ArgumentNullException)
				{
					SendValidationEvent("Sch_InvalidIdAttribute", Res.GetString("Sch_NullValue"), xso);
					return;
				}
				try
				{
					currentSchema.Ids.Add(xso.IdAttribute, xso);
				}
				catch (ArgumentException)
				{
					SendValidationEvent("Sch_DupIdAttribute", xso);
				}
			}
		}

		private void ValidateNameAttribute(XmlSchemaObject xso)
		{
			string nameAttribute = xso.NameAttribute;
			if (nameAttribute == null || nameAttribute.Length == 0)
			{
				SendValidationEvent("Sch_InvalidNameAttributeEx", null, Res.GetString("Sch_NullValue"), xso);
			}
			nameAttribute = XmlComplianceUtil.NonCDataNormalize(nameAttribute);
			int num = ValidateNames.ParseNCName(nameAttribute, 0);
			if (num != nameAttribute.Length)
			{
				string @string = Res.GetString("Xml_BadNameCharWithPos", XmlException.BuildCharExceptionStr(nameAttribute[num])[0], XmlException.BuildCharExceptionStr(nameAttribute[num])[1], num);
				SendValidationEvent("Sch_InvalidNameAttributeEx", nameAttribute, @string, xso);
			}
			else
			{
				xso.NameAttribute = base.NameTable.Add(nameAttribute);
			}
		}

		private void ValidateQNameAttribute(XmlSchemaObject xso, string attributeName, XmlQualifiedName value)
		{
			try
			{
				value.Verify();
				value.Atomize(base.NameTable);
				if (currentSchema.IsChameleon && value.Namespace.Length == 0)
				{
					value.SetNamespace(currentSchema.TargetNamespace);
				}
				if (referenceNamespaces[value.Namespace] == null)
				{
					SendValidationEvent("Sch_UnrefNS", value.Namespace, xso, XmlSeverityType.Warning);
				}
			}
			catch (FormatException ex)
			{
				SendValidationEvent("Sch_InvalidAttribute", new string[2] { attributeName, ex.Message }, ex, xso);
			}
			catch (XmlException ex2)
			{
				SendValidationEvent("Sch_InvalidAttribute", new string[2] { attributeName, ex2.Message }, ex2, xso);
			}
		}

		private Uri ResolveSchemaLocationUri(XmlSchema enclosingSchema, string location)
		{
			if (location.Length == 0)
			{
				return null;
			}
			return xmlResolver.ResolveUri(enclosingSchema.BaseUri, location);
		}

		private object GetSchemaEntity(Uri ruri)
		{
			return xmlResolver.GetEntity(ruri, null, null);
		}

		private XmlSchema GetChameleonSchema(string targetNamespace, XmlSchema schema)
		{
			ChameleonKey key = new ChameleonKey(targetNamespace, schema.BaseUri);
			XmlSchema xmlSchema = (XmlSchema)chameleonSchemas[key];
			if (xmlSchema == null)
			{
				xmlSchema = schema.DeepClone();
				xmlSchema.IsChameleon = true;
				xmlSchema.TargetNamespace = targetNamespace;
				chameleonSchemas.Add(key, xmlSchema);
				schema.IsProcessing = false;
			}
			return xmlSchema;
		}

		private void SetParent(XmlSchemaObject child, XmlSchemaObject parent)
		{
			child.Parent = parent;
		}

		private void PreprocessAnnotation(XmlSchemaObject schemaObject)
		{
			if (schemaObject is XmlSchemaAnnotated)
			{
				XmlSchemaAnnotated xmlSchemaAnnotated = schemaObject as XmlSchemaAnnotated;
				XmlSchemaAnnotation annotation = xmlSchemaAnnotated.Annotation;
				if (annotation != null)
				{
					PreprocessAnnotation(annotation);
					annotation.Parent = schemaObject;
				}
			}
		}

		private void PreprocessAnnotation(XmlSchemaAnnotation annotation)
		{
			ValidateIdAttribute(annotation);
			foreach (XmlSchemaObject item in annotation.Items)
			{
				item.Parent = annotation;
			}
		}
	}
	internal abstract class SchemaDeclBase
	{
		public enum Use
		{
			Default,
			Required,
			Implied,
			Fixed,
			RequiredFixed
		}

		protected XmlQualifiedName name = XmlQualifiedName.Empty;

		protected string prefix;

		protected ArrayList values;

		protected XmlSchemaType schemaType;

		protected XmlSchemaDatatype datatype;

		protected bool isDeclaredInExternal;

		protected Use presence;

		protected string defaultValueRaw;

		protected object defaultValueTyped;

		protected long maxLength;

		protected long minLength;

		public XmlQualifiedName Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public string Prefix
		{
			get
			{
				if (prefix != null)
				{
					return prefix;
				}
				return string.Empty;
			}
			set
			{
				prefix = value;
			}
		}

		public ArrayList Values
		{
			get
			{
				return values;
			}
			set
			{
				values = value;
			}
		}

		public Use Presence
		{
			get
			{
				return presence;
			}
			set
			{
				presence = value;
			}
		}

		public long MaxLength
		{
			get
			{
				return maxLength;
			}
			set
			{
				maxLength = value;
			}
		}

		public long MinLength
		{
			get
			{
				return minLength;
			}
			set
			{
				minLength = value;
			}
		}

		public bool IsDeclaredInExternal
		{
			get
			{
				return isDeclaredInExternal;
			}
			set
			{
				isDeclaredInExternal = value;
			}
		}

		public XmlSchemaType SchemaType
		{
			get
			{
				return schemaType;
			}
			set
			{
				schemaType = value;
			}
		}

		public XmlSchemaDatatype Datatype
		{
			get
			{
				return datatype;
			}
			set
			{
				datatype = value;
			}
		}

		public string DefaultValueRaw
		{
			get
			{
				if (defaultValueRaw == null)
				{
					return string.Empty;
				}
				return defaultValueRaw;
			}
			set
			{
				defaultValueRaw = value;
			}
		}

		public object DefaultValueTyped
		{
			get
			{
				return defaultValueTyped;
			}
			set
			{
				defaultValueTyped = value;
			}
		}

		protected SchemaDeclBase(XmlQualifiedName name, string prefix)
		{
			this.name = name;
			this.prefix = prefix;
			maxLength = -1L;
			minLength = -1L;
		}

		protected SchemaDeclBase()
		{
		}

		public void AddValue(string value)
		{
			if (values == null)
			{
				values = new ArrayList();
			}
			values.Add(value);
		}

		public bool CheckEnumeration(object pVal)
		{
			if (datatype.TokenizedType == XmlTokenizedType.NOTATION || datatype.TokenizedType == XmlTokenizedType.ENUMERATION)
			{
				return values.Contains(pVal.ToString());
			}
			return true;
		}

		public bool CheckValue(object pVal)
		{
			if (presence == Use.Fixed || presence == Use.RequiredFixed)
			{
				if (defaultValueTyped != null)
				{
					return datatype.IsEqual(pVal, defaultValueTyped);
				}
				return false;
			}
			return true;
		}
	}
	internal sealed class SchemaAttDef : SchemaDeclBase
	{
		public enum Reserve
		{
			None,
			XmlSpace,
			XmlLang
		}

		private Reserve reserved;

		private string defExpanded;

		private bool hasEntityRef;

		private XmlSchemaAttribute schemaAttribute;

		private bool defaultValueChecked;

		private int lineNum;

		private int linePos;

		private int valueLineNum;

		private int valueLinePos;

		public static readonly SchemaAttDef Empty = new SchemaAttDef();

		internal int LinePos
		{
			get
			{
				return linePos;
			}
			set
			{
				linePos = value;
			}
		}

		internal int LineNum
		{
			get
			{
				return lineNum;
			}
			set
			{
				lineNum = value;
			}
		}

		internal int ValueLinePos
		{
			get
			{
				return valueLinePos;
			}
			set
			{
				valueLinePos = value;
			}
		}

		internal int ValueLineNum
		{
			get
			{
				return valueLineNum;
			}
			set
			{
				valueLineNum = value;
			}
		}

		internal bool DefaultValueChecked => defaultValueChecked;

		public string DefaultValueExpanded
		{
			get
			{
				if (defExpanded == null)
				{
					return string.Empty;
				}
				return defExpanded;
			}
			set
			{
				defExpanded = value;
			}
		}

		public Reserve Reserved
		{
			get
			{
				return reserved;
			}
			set
			{
				reserved = value;
			}
		}

		public bool HasEntityRef
		{
			get
			{
				return hasEntityRef;
			}
			set
			{
				hasEntityRef = value;
			}
		}

		public XmlSchemaAttribute SchemaAttribute
		{
			get
			{
				return schemaAttribute;
			}
			set
			{
				schemaAttribute = value;
			}
		}

		public SchemaAttDef(XmlQualifiedName name, string prefix)
			: base(name, prefix)
		{
			reserved = Reserve.None;
		}

		private SchemaAttDef()
		{
		}

		public SchemaAttDef Clone()
		{
			return (SchemaAttDef)MemberwiseClone();
		}

		public void CheckXmlSpace(ValidationEventHandler eventhandler)
		{
			if (datatype.TokenizedType == XmlTokenizedType.ENUMERATION && values != null && values.Count <= 2)
			{
				string text = values[0].ToString();
				if (values.Count == 2)
				{
					string text2 = values[1].ToString();
					if ((text == "default" || text2 == "default") && (text == "preserve" || text2 == "preserve"))
					{
						return;
					}
				}
				else if (text == "default" || text == "preserve")
				{
					return;
				}
			}
			eventhandler(this, new ValidationEventArgs(new XmlSchemaException("Sch_XmlSpace", string.Empty)));
		}

		internal void CheckDefaultValue(SchemaInfo schemaInfo, IDtdParserAdapter readerAdapter)
		{
			DtdValidator.CheckDefaultValue(this, schemaInfo, readerAdapter);
			defaultValueChecked = true;
		}
	}
	internal abstract class SchemaBuilder
	{
		internal abstract bool ProcessElement(string prefix, string name, string ns);

		internal abstract void ProcessAttribute(string prefix, string name, string ns, string value);

		internal abstract bool IsContentParsed();

		internal abstract void ProcessMarkup(XmlNode[] markup);

		internal abstract void ProcessCData(string value);

		internal abstract void StartChildren();

		internal abstract void EndChildren();
	}
	internal sealed class SchemaCollectionCompiler : BaseProcessor
	{
		private bool compileContentModel;

		private XmlSchemaObjectTable examplars = new XmlSchemaObjectTable();

		private Stack complexTypeStack = new Stack();

		private XmlSchema schema;

		public SchemaCollectionCompiler(XmlNameTable nameTable, ValidationEventHandler eventHandler)
			: base(nameTable, null, eventHandler)
		{
		}

		public bool Execute(XmlSchema schema, SchemaInfo schemaInfo, bool compileContentModel)
		{
			this.compileContentModel = compileContentModel;
			this.schema = schema;
			Prepare();
			Cleanup();
			Compile();
			if (!base.HasErrors)
			{
				Output(schemaInfo);
			}
			return !base.HasErrors;
		}

		private void Prepare()
		{
			foreach (XmlSchemaElement value in schema.Elements.Values)
			{
				if (!value.SubstitutionGroup.IsEmpty)
				{
					XmlSchemaSubstitutionGroup xmlSchemaSubstitutionGroup = (XmlSchemaSubstitutionGroup)examplars[value.SubstitutionGroup];
					if (xmlSchemaSubstitutionGroup == null)
					{
						xmlSchemaSubstitutionGroup = new XmlSchemaSubstitutionGroupV1Compat();
						xmlSchemaSubstitutionGroup.Examplar = value.SubstitutionGroup;
						examplars.Add(value.SubstitutionGroup, xmlSchemaSubstitutionGroup);
					}
					ArrayList members = xmlSchemaSubstitutionGroup.Members;
					members.Add(value);
				}
			}
		}

		private void Cleanup()
		{
			foreach (XmlSchemaGroup value in schema.Groups.Values)
			{
				CleanupGroup(value);
			}
			foreach (XmlSchemaAttributeGroup value2 in schema.AttributeGroups.Values)
			{
				CleanupAttributeGroup(value2);
			}
			foreach (XmlSchemaType value3 in schema.SchemaTypes.Values)
			{
				if (value3 is XmlSchemaComplexType)
				{
					CleanupComplexType((XmlSchemaComplexType)value3);
				}
				else
				{
					CleanupSimpleType((XmlSchemaSimpleType)value3);
				}
			}
			foreach (XmlSchemaElement value4 in schema.Elements.Values)
			{
				CleanupElement(value4);
			}
			foreach (XmlSchemaAttribute value5 in schema.Attributes.Values)
			{
				CleanupAttribute(value5);
			}
		}

		internal static void Cleanup(XmlSchema schema)
		{
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (include.Schema != null)
				{
					Cleanup(include.Schema);
				}
				if (!(include is XmlSchemaRedefine))
				{
					continue;
				}
				XmlSchemaRedefine xmlSchemaRedefine = include as XmlSchemaRedefine;
				xmlSchemaRedefine.AttributeGroups.Clear();
				xmlSchemaRedefine.Groups.Clear();
				xmlSchemaRedefine.SchemaTypes.Clear();
				foreach (XmlSchemaObject item in xmlSchemaRedefine.Items)
				{
					if (item is XmlSchemaAttribute)
					{
						CleanupAttribute((XmlSchemaAttribute)item);
					}
					else if (item is XmlSchemaAttributeGroup)
					{
						CleanupAttributeGroup((XmlSchemaAttributeGroup)item);
					}
					else if (item is XmlSchemaComplexType)
					{
						CleanupComplexType((XmlSchemaComplexType)item);
					}
					else if (item is XmlSchemaSimpleType)
					{
						CleanupSimpleType((XmlSchemaSimpleType)item);
					}
					else if (item is XmlSchemaElement)
					{
						CleanupElement((XmlSchemaElement)item);
					}
					else if (item is XmlSchemaGroup)
					{
						CleanupGroup((XmlSchemaGroup)item);
					}
				}
			}
			foreach (XmlSchemaObject item2 in schema.Items)
			{
				if (item2 is XmlSchemaAttribute)
				{
					CleanupAttribute((XmlSchemaAttribute)item2);
				}
				else if (item2 is XmlSchemaAttributeGroup)
				{
					CleanupAttributeGroup((XmlSchemaAttributeGroup)item2);
				}
				else if (item2 is XmlSchemaComplexType)
				{
					CleanupComplexType((XmlSchemaComplexType)item2);
				}
				else if (item2 is XmlSchemaSimpleType)
				{
					CleanupSimpleType((XmlSchemaSimpleType)item2);
				}
				else if (item2 is XmlSchemaElement)
				{
					CleanupElement((XmlSchemaElement)item2);
				}
				else if (item2 is XmlSchemaGroup)
				{
					CleanupGroup((XmlSchemaGroup)item2);
				}
			}
			schema.Attributes.Clear();
			schema.AttributeGroups.Clear();
			schema.SchemaTypes.Clear();
			schema.Elements.Clear();
			schema.Groups.Clear();
			schema.Notations.Clear();
			schema.Ids.Clear();
			schema.IdentityConstraints.Clear();
		}

		private void Compile()
		{
			schema.SchemaTypes.Insert(DatatypeImplementation.QnAnyType, XmlSchemaComplexType.AnyType);
			foreach (XmlSchemaSubstitutionGroupV1Compat value in examplars.Values)
			{
				CompileSubstitutionGroup(value);
			}
			foreach (XmlSchemaGroup value2 in schema.Groups.Values)
			{
				CompileGroup(value2);
			}
			foreach (XmlSchemaAttributeGroup value3 in schema.AttributeGroups.Values)
			{
				CompileAttributeGroup(value3);
			}
			foreach (XmlSchemaType value4 in schema.SchemaTypes.Values)
			{
				if (value4 is XmlSchemaComplexType)
				{
					CompileComplexType((XmlSchemaComplexType)value4);
				}
				else
				{
					CompileSimpleType((XmlSchemaSimpleType)value4);
				}
			}
			foreach (XmlSchemaElement value5 in schema.Elements.Values)
			{
				if (value5.ElementDecl == null)
				{
					CompileElement(value5);
				}
			}
			foreach (XmlSchemaAttribute value6 in schema.Attributes.Values)
			{
				if (value6.AttDef == null)
				{
					CompileAttribute(value6);
				}
			}
			foreach (XmlSchemaIdentityConstraint value7 in schema.IdentityConstraints.Values)
			{
				if (value7.CompiledConstraint == null)
				{
					CompileIdentityConstraint(value7);
				}
			}
			while (complexTypeStack.Count > 0)
			{
				XmlSchemaComplexType complexType = (XmlSchemaComplexType)complexTypeStack.Pop();
				CompileCompexTypeElements(complexType);
			}
			foreach (XmlSchemaType value8 in schema.SchemaTypes.Values)
			{
				if (value8 is XmlSchemaComplexType)
				{
					CheckParticleDerivation((XmlSchemaComplexType)value8);
				}
			}
			foreach (XmlSchemaElement value9 in schema.Elements.Values)
			{
				if (value9.ElementSchemaType is XmlSchemaComplexType && value9.SchemaTypeName == XmlQualifiedName.Empty)
				{
					CheckParticleDerivation((XmlSchemaComplexType)value9.ElementSchemaType);
				}
			}
			foreach (XmlSchemaSubstitutionGroup value10 in examplars.Values)
			{
				CheckSubstitutionGroup(value10);
			}
			schema.SchemaTypes.Remove(DatatypeImplementation.QnAnyType);
		}

		private void Output(SchemaInfo schemaInfo)
		{
			foreach (XmlSchemaElement value in schema.Elements.Values)
			{
				schemaInfo.TargetNamespaces[value.QualifiedName.Namespace] = true;
				schemaInfo.ElementDecls.Add(value.QualifiedName, value.ElementDecl);
			}
			foreach (XmlSchemaAttribute value2 in schema.Attributes.Values)
			{
				schemaInfo.TargetNamespaces[value2.QualifiedName.Namespace] = true;
				schemaInfo.AttributeDecls.Add(value2.QualifiedName, value2.AttDef);
			}
			foreach (XmlSchemaType value3 in schema.SchemaTypes.Values)
			{
				schemaInfo.TargetNamespaces[value3.QualifiedName.Namespace] = true;
				if (!(value3 is XmlSchemaComplexType xmlSchemaComplexType) || (!xmlSchemaComplexType.IsAbstract && value3 != XmlSchemaComplexType.AnyType))
				{
					schemaInfo.ElementDeclsByType.Add(value3.QualifiedName, value3.ElementDecl);
				}
			}
			foreach (XmlSchemaNotation value4 in schema.Notations.Values)
			{
				schemaInfo.TargetNamespaces[value4.QualifiedName.Namespace] = true;
				SchemaNotation schemaNotation = new SchemaNotation(value4.QualifiedName);
				schemaNotation.SystemLiteral = value4.System;
				schemaNotation.Pubid = value4.Public;
				if (schemaInfo.Notations[schemaNotation.Name.Name] == null)
				{
					schemaInfo.Notations.Add(schemaNotation.Name.Name, schemaNotation);
				}
			}
		}

		private static void CleanupAttribute(XmlSchemaAttribute attribute)
		{
			if (attribute.SchemaType != null)
			{
				CleanupSimpleType(attribute.SchemaType);
			}
			attribute.AttDef = null;
		}

		private static void CleanupAttributeGroup(XmlSchemaAttributeGroup attributeGroup)
		{
			CleanupAttributes(attributeGroup.Attributes);
			attributeGroup.AttributeUses.Clear();
			attributeGroup.AttributeWildcard = null;
		}

		private static void CleanupComplexType(XmlSchemaComplexType complexType)
		{
			if (complexType.ContentModel != null)
			{
				if (complexType.ContentModel is XmlSchemaSimpleContent)
				{
					XmlSchemaSimpleContent xmlSchemaSimpleContent = (XmlSchemaSimpleContent)complexType.ContentModel;
					if (xmlSchemaSimpleContent.Content is XmlSchemaSimpleContentExtension)
					{
						XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = (XmlSchemaSimpleContentExtension)xmlSchemaSimpleContent.Content;
						CleanupAttributes(xmlSchemaSimpleContentExtension.Attributes);
					}
					else
					{
						XmlSchemaSimpleContentRestriction xmlSchemaSimpleContentRestriction = (XmlSchemaSimpleContentRestriction)xmlSchemaSimpleContent.Content;
						CleanupAttributes(xmlSchemaSimpleContentRestriction.Attributes);
					}
				}
				else
				{
					XmlSchemaComplexContent xmlSchemaComplexContent = (XmlSchemaComplexContent)complexType.ContentModel;
					if (xmlSchemaComplexContent.Content is XmlSchemaComplexContentExtension)
					{
						XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension = (XmlSchemaComplexContentExtension)xmlSchemaComplexContent.Content;
						CleanupParticle(xmlSchemaComplexContentExtension.Particle);
						CleanupAttributes(xmlSchemaComplexContentExtension.Attributes);
					}
					else
					{
						XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction = (XmlSchemaComplexContentRestriction)xmlSchemaComplexContent.Content;
						CleanupParticle(xmlSchemaComplexContentRestriction.Particle);
						CleanupAttributes(xmlSchemaComplexContentRestriction.Attributes);
					}
				}
			}
			else
			{
				CleanupParticle(complexType.Particle);
				CleanupAttributes(complexType.Attributes);
			}
			complexType.LocalElements.Clear();
			complexType.AttributeUses.Clear();
			complexType.SetAttributeWildcard(null);
			complexType.SetContentTypeParticle(XmlSchemaParticle.Empty);
			complexType.ElementDecl = null;
		}

		private static void CleanupSimpleType(XmlSchemaSimpleType simpleType)
		{
			simpleType.ElementDecl = null;
		}

		private static void CleanupElement(XmlSchemaElement element)
		{
			if (element.SchemaType != null)
			{
				if (element.SchemaType is XmlSchemaComplexType complexType)
				{
					CleanupComplexType(complexType);
				}
				else
				{
					CleanupSimpleType((XmlSchemaSimpleType)element.SchemaType);
				}
			}
			foreach (XmlSchemaIdentityConstraint constraint in element.Constraints)
			{
				constraint.CompiledConstraint = null;
			}
			element.ElementDecl = null;
		}

		private static void CleanupAttributes(XmlSchemaObjectCollection attributes)
		{
			foreach (XmlSchemaObject attribute in attributes)
			{
				if (attribute is XmlSchemaAttribute)
				{
					CleanupAttribute((XmlSchemaAttribute)attribute);
				}
			}
		}

		private static void CleanupGroup(XmlSchemaGroup group)
		{
			CleanupParticle(group.Particle);
			group.CanonicalParticle = null;
		}

		private static void CleanupParticle(XmlSchemaParticle particle)
		{
			if (particle is XmlSchemaElement)
			{
				CleanupElement((XmlSchemaElement)particle);
			}
			else
			{
				if (!(particle is XmlSchemaGroupBase))
				{
					return;
				}
				foreach (XmlSchemaParticle item in ((XmlSchemaGroupBase)particle).Items)
				{
					CleanupParticle(item);
				}
			}
		}

		private void CompileSubstitutionGroup(XmlSchemaSubstitutionGroupV1Compat substitutionGroup)
		{
			if (substitutionGroup.IsProcessing)
			{
				{
					IEnumerator enumerator = substitutionGroup.Members.GetEnumerator();
					try
					{
						if (enumerator.MoveNext())
						{
							XmlSchemaElement source = (XmlSchemaElement)enumerator.Current;
							SendValidationEvent("Sch_SubstitutionCircularRef", source);
							return;
						}
					}
					finally
					{
						IDisposable disposable = enumerator as IDisposable;
						if (disposable != null)
						{
							disposable.Dispose();
						}
					}
				}
			}
			XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)schema.Elements[substitutionGroup.Examplar];
			if (substitutionGroup.Members.Contains(xmlSchemaElement))
			{
				return;
			}
			substitutionGroup.IsProcessing = true;
			if (xmlSchemaElement != null)
			{
				if (xmlSchemaElement.FinalResolved == XmlSchemaDerivationMethod.All)
				{
					SendValidationEvent("Sch_InvalidExamplar", xmlSchemaElement);
				}
				foreach (XmlSchemaElement member in substitutionGroup.Members)
				{
					XmlSchemaSubstitutionGroupV1Compat xmlSchemaSubstitutionGroupV1Compat = (XmlSchemaSubstitutionGroupV1Compat)examplars[member.QualifiedName];
					if (xmlSchemaSubstitutionGroupV1Compat != null)
					{
						CompileSubstitutionGroup(xmlSchemaSubstitutionGroupV1Compat);
						foreach (XmlSchemaElement item in xmlSchemaSubstitutionGroupV1Compat.Choice.Items)
						{
							substitutionGroup.Choice.Items.Add(item);
						}
					}
					else
					{
						substitutionGroup.Choice.Items.Add(member);
					}
				}
				substitutionGroup.Choice.Items.Add(xmlSchemaElement);
				substitutionGroup.Members.Add(xmlSchemaElement);
			}
			else
			{
				{
					IEnumerator enumerator3 = substitutionGroup.Members.GetEnumerator();
					try
					{
						if (enumerator3.MoveNext())
						{
							XmlSchemaElement source2 = (XmlSchemaElement)enumerator3.Current;
							SendValidationEvent("Sch_NoExamplar", source2);
						}
					}
					finally
					{
						IDisposable disposable2 = enumerator3 as IDisposable;
						if (disposable2 != null)
						{
							disposable2.Dispose();
						}
					}
				}
			}
			substitutionGroup.IsProcessing = false;
		}

		private void CheckSubstitutionGroup(XmlSchemaSubstitutionGroup substitutionGroup)
		{
			XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)schema.Elements[substitutionGroup.Examplar];
			if (xmlSchemaElement == null)
			{
				return;
			}
			foreach (XmlSchemaElement member in substitutionGroup.Members)
			{
				if (member != xmlSchemaElement && !XmlSchemaType.IsDerivedFrom(member.ElementSchemaType, xmlSchemaElement.ElementSchemaType, xmlSchemaElement.FinalResolved))
				{
					SendValidationEvent("Sch_InvalidSubstitutionMember", member.QualifiedName.ToString(), xmlSchemaElement.QualifiedName.ToString(), member);
				}
			}
		}

		private void CompileGroup(XmlSchemaGroup group)
		{
			if (group.IsProcessing)
			{
				SendValidationEvent("Sch_GroupCircularRef", group);
				group.CanonicalParticle = XmlSchemaParticle.Empty;
				return;
			}
			group.IsProcessing = true;
			if (group.CanonicalParticle == null)
			{
				group.CanonicalParticle = CannonicalizeParticle(group.Particle, root: true, substitution: true);
			}
			group.IsProcessing = false;
		}

		private void CompileSimpleType(XmlSchemaSimpleType simpleType)
		{
			if (simpleType.IsProcessing)
			{
				throw new XmlSchemaException("Sch_TypeCircularRef", simpleType);
			}
			if (simpleType.ElementDecl != null)
			{
				return;
			}
			simpleType.IsProcessing = true;
			try
			{
				if (simpleType.Content is XmlSchemaSimpleTypeList)
				{
					XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = (XmlSchemaSimpleTypeList)simpleType.Content;
					simpleType.SetBaseSchemaType(DatatypeImplementation.AnySimpleType);
					XmlSchemaDatatype datatype;
					if (xmlSchemaSimpleTypeList.ItemTypeName.IsEmpty)
					{
						CompileSimpleType(xmlSchemaSimpleTypeList.ItemType);
						xmlSchemaSimpleTypeList.BaseItemType = xmlSchemaSimpleTypeList.ItemType;
						datatype = xmlSchemaSimpleTypeList.ItemType.Datatype;
					}
					else
					{
						XmlSchemaSimpleType simpleType2 = GetSimpleType(xmlSchemaSimpleTypeList.ItemTypeName);
						if (simpleType2 == null)
						{
							throw new XmlSchemaException("Sch_UndeclaredSimpleType", xmlSchemaSimpleTypeList.ItemTypeName.ToString(), simpleType);
						}
						if ((simpleType2.FinalResolved & XmlSchemaDerivationMethod.List) != 0)
						{
							SendValidationEvent("Sch_BaseFinalList", simpleType);
						}
						xmlSchemaSimpleTypeList.BaseItemType = simpleType2;
						datatype = simpleType2.Datatype;
					}
					simpleType.SetDatatype(datatype.DeriveByList(simpleType));
					simpleType.SetDerivedBy(XmlSchemaDerivationMethod.List);
				}
				else if (simpleType.Content is XmlSchemaSimpleTypeRestriction)
				{
					XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)simpleType.Content;
					XmlSchemaDatatype datatype2;
					if (xmlSchemaSimpleTypeRestriction.BaseTypeName.IsEmpty)
					{
						CompileSimpleType(xmlSchemaSimpleTypeRestriction.BaseType);
						simpleType.SetBaseSchemaType(xmlSchemaSimpleTypeRestriction.BaseType);
						datatype2 = xmlSchemaSimpleTypeRestriction.BaseType.Datatype;
					}
					else if (simpleType.Redefined != null && xmlSchemaSimpleTypeRestriction.BaseTypeName == simpleType.Redefined.QualifiedName)
					{
						CompileSimpleType((XmlSchemaSimpleType)simpleType.Redefined);
						simpleType.SetBaseSchemaType(simpleType.Redefined.BaseXmlSchemaType);
						datatype2 = simpleType.Redefined.Datatype;
					}
					else
					{
						if (xmlSchemaSimpleTypeRestriction.BaseTypeName.Equals(DatatypeImplementation.QnAnySimpleType))
						{
							throw new XmlSchemaException("Sch_InvalidSimpleTypeRestriction", xmlSchemaSimpleTypeRestriction.BaseTypeName.ToString(), simpleType);
						}
						XmlSchemaSimpleType simpleType3 = GetSimpleType(xmlSchemaSimpleTypeRestriction.BaseTypeName);
						if (simpleType3 == null)
						{
							throw new XmlSchemaException("Sch_UndeclaredSimpleType", xmlSchemaSimpleTypeRestriction.BaseTypeName.ToString(), simpleType);
						}
						if ((simpleType3.FinalResolved & XmlSchemaDerivationMethod.Restriction) != 0)
						{
							SendValidationEvent("Sch_BaseFinalRestriction", simpleType);
						}
						simpleType.SetBaseSchemaType(simpleType3);
						datatype2 = simpleType3.Datatype;
					}
					simpleType.SetDatatype(datatype2.DeriveByRestriction(xmlSchemaSimpleTypeRestriction.Facets, base.NameTable, simpleType));
					simpleType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
				}
				else
				{
					XmlSchemaSimpleType[] types = CompileBaseMemberTypes(simpleType);
					simpleType.SetBaseSchemaType(DatatypeImplementation.AnySimpleType);
					simpleType.SetDatatype(XmlSchemaDatatype.DeriveByUnion(types, simpleType));
					simpleType.SetDerivedBy(XmlSchemaDerivationMethod.Union);
				}
			}
			catch (XmlSchemaException ex)
			{
				if (ex.SourceSchemaObject == null)
				{
					ex.SetSource(simpleType);
				}
				SendValidationEvent(ex);
				simpleType.SetDatatype(DatatypeImplementation.AnySimpleType.Datatype);
			}
			finally
			{
				SchemaElementDecl schemaElementDecl = new SchemaElementDecl();
				schemaElementDecl.ContentValidator = ContentValidator.TextOnly;
				schemaElementDecl.SchemaType = simpleType;
				schemaElementDecl.Datatype = simpleType.Datatype;
				simpleType.ElementDecl = schemaElementDecl;
				simpleType.IsProcessing = false;
			}
		}

		private XmlSchemaSimpleType[] CompileBaseMemberTypes(XmlSchemaSimpleType simpleType)
		{
			ArrayList arrayList = new ArrayList();
			XmlSchemaSimpleTypeUnion xmlSchemaSimpleTypeUnion = (XmlSchemaSimpleTypeUnion)simpleType.Content;
			Array memberTypes = xmlSchemaSimpleTypeUnion.MemberTypes;
			if (memberTypes != null)
			{
				foreach (XmlQualifiedName item in memberTypes)
				{
					XmlSchemaSimpleType simpleType2 = GetSimpleType(item);
					if (simpleType2 != null)
					{
						if (simpleType2.Datatype.Variety == XmlSchemaDatatypeVariety.Union)
						{
							CheckUnionType(simpleType2, arrayList, simpleType);
						}
						else
						{
							arrayList.Add(simpleType2);
						}
						if ((simpleType2.FinalResolved & XmlSchemaDerivationMethod.Union) != 0)
						{
							SendValidationEvent("Sch_BaseFinalUnion", simpleType);
						}
						continue;
					}
					throw new XmlSchemaException("Sch_UndeclaredSimpleType", item.ToString(), simpleType);
				}
			}
			XmlSchemaObjectCollection baseTypes = xmlSchemaSimpleTypeUnion.BaseTypes;
			if (baseTypes != null)
			{
				foreach (XmlSchemaSimpleType item2 in baseTypes)
				{
					CompileSimpleType(item2);
					if (item2.Datatype.Variety == XmlSchemaDatatypeVariety.Union)
					{
						CheckUnionType(item2, arrayList, simpleType);
					}
					else
					{
						arrayList.Add(item2);
					}
				}
			}
			xmlSchemaSimpleTypeUnion.SetBaseMemberTypes(arrayList.ToArray(typeof(XmlSchemaSimpleType)) as XmlSchemaSimpleType[]);
			return xmlSchemaSimpleTypeUnion.BaseMemberTypes;
		}

		private void CheckUnionType(XmlSchemaSimpleType unionMember, ArrayList memberTypeDefinitions, XmlSchemaSimpleType parentType)
		{
			XmlSchemaDatatype datatype = unionMember.Datatype;
			if (unionMember.DerivedBy == XmlSchemaDerivationMethod.Restriction && (datatype.HasLexicalFacets || datatype.HasValueFacets))
			{
				SendValidationEvent("Sch_UnionFromUnion", parentType);
				return;
			}
			Datatype_union datatype_union = unionMember.Datatype as Datatype_union;
			memberTypeDefinitions.AddRange(datatype_union.BaseMemberTypes);
		}

		private void CompileComplexType(XmlSchemaComplexType complexType)
		{
			if (complexType.ElementDecl != null)
			{
				return;
			}
			if (complexType.IsProcessing)
			{
				SendValidationEvent("Sch_TypeCircularRef", complexType);
				return;
			}
			complexType.IsProcessing = true;
			if (complexType.ContentModel != null)
			{
				if (complexType.ContentModel is XmlSchemaSimpleContent)
				{
					XmlSchemaSimpleContent xmlSchemaSimpleContent = (XmlSchemaSimpleContent)complexType.ContentModel;
					complexType.SetContentType(XmlSchemaContentType.TextOnly);
					if (xmlSchemaSimpleContent.Content is XmlSchemaSimpleContentExtension)
					{
						CompileSimpleContentExtension(complexType, (XmlSchemaSimpleContentExtension)xmlSchemaSimpleContent.Content);
					}
					else
					{
						CompileSimpleContentRestriction(complexType, (XmlSchemaSimpleContentRestriction)xmlSchemaSimpleContent.Content);
					}
				}
				else
				{
					XmlSchemaComplexContent xmlSchemaComplexContent = (XmlSchemaComplexContent)complexType.ContentModel;
					if (xmlSchemaComplexContent.Content is XmlSchemaComplexContentExtension)
					{
						CompileComplexContentExtension(complexType, xmlSchemaComplexContent, (XmlSchemaComplexContentExtension)xmlSchemaComplexContent.Content);
					}
					else
					{
						CompileComplexContentRestriction(complexType, xmlSchemaComplexContent, (XmlSchemaComplexContentRestriction)xmlSchemaComplexContent.Content);
					}
				}
			}
			else
			{
				complexType.SetBaseSchemaType(XmlSchemaComplexType.AnyType);
				CompileLocalAttributes(XmlSchemaComplexType.AnyType, complexType, complexType.Attributes, complexType.AnyAttribute, XmlSchemaDerivationMethod.Restriction);
				complexType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
				complexType.SetContentTypeParticle(CompileContentTypeParticle(complexType.Particle, substitution: true));
				complexType.SetContentType(GetSchemaContentType(complexType, null, complexType.ContentTypeParticle));
			}
			bool flag = false;
			foreach (XmlSchemaAttribute value in complexType.AttributeUses.Values)
			{
				if (value.Use == XmlSchemaUse.Prohibited)
				{
					continue;
				}
				XmlSchemaDatatype datatype = value.Datatype;
				if (datatype != null && datatype.TokenizedType == XmlTokenizedType.ID)
				{
					if (flag)
					{
						SendValidationEvent("Sch_TwoIdAttrUses", complexType);
					}
					else
					{
						flag = true;
					}
				}
			}
			SchemaElementDecl schemaElementDecl = new SchemaElementDecl();
			schemaElementDecl.ContentValidator = CompileComplexContent(complexType);
			schemaElementDecl.SchemaType = complexType;
			schemaElementDecl.IsAbstract = complexType.IsAbstract;
			schemaElementDecl.Datatype = complexType.Datatype;
			schemaElementDecl.Block = complexType.BlockResolved;
			schemaElementDecl.AnyAttribute = complexType.AttributeWildcard;
			foreach (XmlSchemaAttribute value2 in complexType.AttributeUses.Values)
			{
				if (value2.Use == XmlSchemaUse.Prohibited)
				{
					if (schemaElementDecl.ProhibitedAttributes[value2.QualifiedName] == null)
					{
						schemaElementDecl.ProhibitedAttributes.Add(value2.QualifiedName, value2.QualifiedName);
					}
				}
				else if (schemaElementDecl.AttDefs[value2.QualifiedName] == null && value2.AttDef != null && value2.AttDef.Name != XmlQualifiedName.Empty && value2.AttDef != SchemaAttDef.Empty)
				{
					schemaElementDecl.AddAttDef(value2.AttDef);
				}
			}
			schemaElementDecl.EndAddAttDef();
			complexType.ElementDecl = schemaElementDecl;
			complexType.IsProcessing = false;
		}

		private void CompileSimpleContentExtension(XmlSchemaComplexType complexType, XmlSchemaSimpleContentExtension simpleExtension)
		{
			XmlSchemaComplexType xmlSchemaComplexType = null;
			if (complexType.Redefined != null && simpleExtension.BaseTypeName == complexType.Redefined.QualifiedName)
			{
				xmlSchemaComplexType = (XmlSchemaComplexType)complexType.Redefined;
				CompileComplexType(xmlSchemaComplexType);
				complexType.SetBaseSchemaType(xmlSchemaComplexType);
				complexType.SetDatatype(xmlSchemaComplexType.Datatype);
			}
			else
			{
				XmlSchemaType anySchemaType = GetAnySchemaType(simpleExtension.BaseTypeName);
				if (anySchemaType == null)
				{
					SendValidationEvent("Sch_UndeclaredType", simpleExtension.BaseTypeName.ToString(), complexType);
				}
				else
				{
					complexType.SetBaseSchemaType(anySchemaType);
					complexType.SetDatatype(anySchemaType.Datatype);
				}
				xmlSchemaComplexType = anySchemaType as XmlSchemaComplexType;
			}
			if (xmlSchemaComplexType != null)
			{
				if ((xmlSchemaComplexType.FinalResolved & XmlSchemaDerivationMethod.Extension) != 0)
				{
					SendValidationEvent("Sch_BaseFinalExtension", complexType);
				}
				if (xmlSchemaComplexType.ContentType != 0)
				{
					SendValidationEvent("Sch_NotSimpleContent", complexType);
				}
			}
			complexType.SetDerivedBy(XmlSchemaDerivationMethod.Extension);
			CompileLocalAttributes(xmlSchemaComplexType, complexType, simpleExtension.Attributes, simpleExtension.AnyAttribute, XmlSchemaDerivationMethod.Extension);
		}

		private void CompileSimpleContentRestriction(XmlSchemaComplexType complexType, XmlSchemaSimpleContentRestriction simpleRestriction)
		{
			XmlSchemaComplexType xmlSchemaComplexType = null;
			XmlSchemaDatatype xmlSchemaDatatype = null;
			if (complexType.Redefined != null && simpleRestriction.BaseTypeName == complexType.Redefined.QualifiedName)
			{
				xmlSchemaComplexType = (XmlSchemaComplexType)complexType.Redefined;
				CompileComplexType(xmlSchemaComplexType);
				xmlSchemaDatatype = xmlSchemaComplexType.Datatype;
			}
			else
			{
				xmlSchemaComplexType = GetComplexType(simpleRestriction.BaseTypeName);
				if (xmlSchemaComplexType == null)
				{
					SendValidationEvent("Sch_UndefBaseRestriction", simpleRestriction.BaseTypeName.ToString(), simpleRestriction);
					return;
				}
				if (xmlSchemaComplexType.ContentType == XmlSchemaContentType.TextOnly)
				{
					if (simpleRestriction.BaseType == null)
					{
						xmlSchemaDatatype = xmlSchemaComplexType.Datatype;
					}
					else
					{
						CompileSimpleType(simpleRestriction.BaseType);
						if (!XmlSchemaType.IsDerivedFromDatatype(simpleRestriction.BaseType.Datatype, xmlSchemaComplexType.Datatype, XmlSchemaDerivationMethod.None))
						{
							SendValidationEvent("Sch_DerivedNotFromBase", simpleRestriction);
						}
						xmlSchemaDatatype = simpleRestriction.BaseType.Datatype;
					}
				}
				else if (xmlSchemaComplexType.ContentType == XmlSchemaContentType.Mixed && xmlSchemaComplexType.ElementDecl.ContentValidator.IsEmptiable)
				{
					if (simpleRestriction.BaseType != null)
					{
						CompileSimpleType(simpleRestriction.BaseType);
						complexType.SetBaseSchemaType(simpleRestriction.BaseType);
						xmlSchemaDatatype = simpleRestriction.BaseType.Datatype;
					}
					else
					{
						SendValidationEvent("Sch_NeedSimpleTypeChild", simpleRestriction);
					}
				}
				else
				{
					SendValidationEvent("Sch_NotSimpleContent", complexType);
				}
			}
			if (xmlSchemaComplexType != null && xmlSchemaComplexType.ElementDecl != null && (xmlSchemaComplexType.FinalResolved & XmlSchemaDerivationMethod.Restriction) != 0)
			{
				SendValidationEvent("Sch_BaseFinalRestriction", complexType);
			}
			if (xmlSchemaComplexType != null)
			{
				complexType.SetBaseSchemaType(xmlSchemaComplexType);
			}
			if (xmlSchemaDatatype != null)
			{
				try
				{
					complexType.SetDatatype(xmlSchemaDatatype.DeriveByRestriction(simpleRestriction.Facets, base.NameTable, complexType));
				}
				catch (XmlSchemaException ex)
				{
					if (ex.SourceSchemaObject == null)
					{
						ex.SetSource(complexType);
					}
					SendValidationEvent(ex);
					complexType.SetDatatype(DatatypeImplementation.AnySimpleType.Datatype);
				}
			}
			complexType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
			CompileLocalAttributes(xmlSchemaComplexType, complexType, simpleRestriction.Attributes, simpleRestriction.AnyAttribute, XmlSchemaDerivationMethod.Restriction);
		}

		private void CompileComplexContentExtension(XmlSchemaComplexType complexType, XmlSchemaComplexContent complexContent, XmlSchemaComplexContentExtension complexExtension)
		{
			XmlSchemaComplexType xmlSchemaComplexType = null;
			if (complexType.Redefined != null && complexExtension.BaseTypeName == complexType.Redefined.QualifiedName)
			{
				xmlSchemaComplexType = (XmlSchemaComplexType)complexType.Redefined;
				CompileComplexType(xmlSchemaComplexType);
			}
			else
			{
				xmlSchemaComplexType = GetComplexType(complexExtension.BaseTypeName);
				if (xmlSchemaComplexType == null)
				{
					SendValidationEvent("Sch_UndefBaseExtension", complexExtension.BaseTypeName.ToString(), complexExtension);
					return;
				}
			}
			if (xmlSchemaComplexType != null && xmlSchemaComplexType.ElementDecl != null && xmlSchemaComplexType.ContentType == XmlSchemaContentType.TextOnly)
			{
				SendValidationEvent("Sch_NotComplexContent", complexType);
				return;
			}
			complexType.SetBaseSchemaType(xmlSchemaComplexType);
			if ((xmlSchemaComplexType.FinalResolved & XmlSchemaDerivationMethod.Extension) != 0)
			{
				SendValidationEvent("Sch_BaseFinalExtension", complexType);
			}
			CompileLocalAttributes(xmlSchemaComplexType, complexType, complexExtension.Attributes, complexExtension.AnyAttribute, XmlSchemaDerivationMethod.Extension);
			XmlSchemaParticle contentTypeParticle = xmlSchemaComplexType.ContentTypeParticle;
			XmlSchemaParticle xmlSchemaParticle = CannonicalizeParticle(complexExtension.Particle, root: true, substitution: true);
			if (contentTypeParticle != XmlSchemaParticle.Empty)
			{
				if (xmlSchemaParticle != XmlSchemaParticle.Empty)
				{
					XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
					xmlSchemaSequence.Items.Add(contentTypeParticle);
					xmlSchemaSequence.Items.Add(xmlSchemaParticle);
					complexType.SetContentTypeParticle(CompileContentTypeParticle(xmlSchemaSequence, substitution: false));
				}
				else
				{
					complexType.SetContentTypeParticle(contentTypeParticle);
				}
				XmlSchemaContentType xmlSchemaContentType = GetSchemaContentType(complexType, complexContent, xmlSchemaParticle);
				if (xmlSchemaContentType == XmlSchemaContentType.Empty)
				{
					xmlSchemaContentType = xmlSchemaComplexType.ContentType;
				}
				complexType.SetContentType(xmlSchemaContentType);
				if (complexType.ContentType != xmlSchemaComplexType.ContentType)
				{
					SendValidationEvent("Sch_DifContentType", complexType);
				}
			}
			else
			{
				complexType.SetContentTypeParticle(xmlSchemaParticle);
				complexType.SetContentType(GetSchemaContentType(complexType, complexContent, complexType.ContentTypeParticle));
			}
			complexType.SetDerivedBy(XmlSchemaDerivationMethod.Extension);
		}

		private void CompileComplexContentRestriction(XmlSchemaComplexType complexType, XmlSchemaComplexContent complexContent, XmlSchemaComplexContentRestriction complexRestriction)
		{
			XmlSchemaComplexType xmlSchemaComplexType = null;
			if (complexType.Redefined != null && complexRestriction.BaseTypeName == complexType.Redefined.QualifiedName)
			{
				xmlSchemaComplexType = (XmlSchemaComplexType)complexType.Redefined;
				CompileComplexType(xmlSchemaComplexType);
			}
			else
			{
				xmlSchemaComplexType = GetComplexType(complexRestriction.BaseTypeName);
				if (xmlSchemaComplexType == null)
				{
					SendValidationEvent("Sch_UndefBaseRestriction", complexRestriction.BaseTypeName.ToString(), complexRestriction);
					return;
				}
			}
			if (xmlSchemaComplexType != null && xmlSchemaComplexType.ElementDecl != null && xmlSchemaComplexType.ContentType == XmlSchemaContentType.TextOnly)
			{
				SendValidationEvent("Sch_NotComplexContent", complexType);
				return;
			}
			complexType.SetBaseSchemaType(xmlSchemaComplexType);
			if ((xmlSchemaComplexType.FinalResolved & XmlSchemaDerivationMethod.Restriction) != 0)
			{
				SendValidationEvent("Sch_BaseFinalRestriction", complexType);
			}
			CompileLocalAttributes(xmlSchemaComplexType, complexType, complexRestriction.Attributes, complexRestriction.AnyAttribute, XmlSchemaDerivationMethod.Restriction);
			complexType.SetContentTypeParticle(CompileContentTypeParticle(complexRestriction.Particle, substitution: true));
			complexType.SetContentType(GetSchemaContentType(complexType, complexContent, complexType.ContentTypeParticle));
			if (complexType.ContentType == XmlSchemaContentType.Empty)
			{
				_ = xmlSchemaComplexType.ElementDecl;
				if (xmlSchemaComplexType.ElementDecl != null && !xmlSchemaComplexType.ElementDecl.ContentValidator.IsEmptiable)
				{
					SendValidationEvent("Sch_InvalidContentRestriction", complexType);
				}
			}
			complexType.SetDerivedBy(XmlSchemaDerivationMethod.Restriction);
		}

		private void CheckParticleDerivation(XmlSchemaComplexType complexType)
		{
			if (complexType.BaseXmlSchemaType is XmlSchemaComplexType xmlSchemaComplexType && xmlSchemaComplexType != XmlSchemaComplexType.AnyType && complexType.DerivedBy == XmlSchemaDerivationMethod.Restriction && !IsValidRestriction(complexType.ContentTypeParticle, xmlSchemaComplexType.ContentTypeParticle))
			{
				SendValidationEvent("Sch_InvalidParticleRestriction", complexType);
			}
		}

		private XmlSchemaParticle CompileContentTypeParticle(XmlSchemaParticle particle, bool substitution)
		{
			XmlSchemaParticle xmlSchemaParticle = CannonicalizeParticle(particle, root: true, substitution);
			if (xmlSchemaParticle is XmlSchemaChoice xmlSchemaChoice && xmlSchemaChoice.Items.Count == 0)
			{
				if (xmlSchemaChoice.MinOccurs != 0m)
				{
					SendValidationEvent("Sch_EmptyChoice", xmlSchemaChoice, XmlSeverityType.Warning);
				}
				return XmlSchemaParticle.Empty;
			}
			return xmlSchemaParticle;
		}

		private XmlSchemaParticle CannonicalizeParticle(XmlSchemaParticle particle, bool root, bool substitution)
		{
			if (particle == null || particle.IsEmpty)
			{
				return XmlSchemaParticle.Empty;
			}
			if (particle is XmlSchemaElement)
			{
				return CannonicalizeElement((XmlSchemaElement)particle, substitution);
			}
			if (particle is XmlSchemaGroupRef)
			{
				return CannonicalizeGroupRef((XmlSchemaGroupRef)particle, root, substitution);
			}
			if (particle is XmlSchemaAll)
			{
				return CannonicalizeAll((XmlSchemaAll)particle, root, substitution);
			}
			if (particle is XmlSchemaChoice)
			{
				return CannonicalizeChoice((XmlSchemaChoice)particle, root, substitution);
			}
			if (particle is XmlSchemaSequence)
			{
				return CannonicalizeSequence((XmlSchemaSequence)particle, root, substitution);
			}
			return particle;
		}

		private XmlSchemaParticle CannonicalizeElement(XmlSchemaElement element, bool substitution)
		{
			if (!element.RefName.IsEmpty && substitution && (element.BlockResolved & XmlSchemaDerivationMethod.Substitution) == 0)
			{
				XmlSchemaSubstitutionGroupV1Compat xmlSchemaSubstitutionGroupV1Compat = (XmlSchemaSubstitutionGroupV1Compat)examplars[element.QualifiedName];
				if (xmlSchemaSubstitutionGroupV1Compat == null)
				{
					return element;
				}
				XmlSchemaChoice xmlSchemaChoice = (XmlSchemaChoice)xmlSchemaSubstitutionGroupV1Compat.Choice.Clone();
				xmlSchemaChoice.MinOccurs = element.MinOccurs;
				xmlSchemaChoice.MaxOccurs = element.MaxOccurs;
				return xmlSchemaChoice;
			}
			return element;
		}

		private XmlSchemaParticle CannonicalizeGroupRef(XmlSchemaGroupRef groupRef, bool root, bool substitution)
		{
			XmlSchemaGroup xmlSchemaGroup = ((groupRef.Redefined == null) ? ((XmlSchemaGroup)schema.Groups[groupRef.RefName]) : groupRef.Redefined);
			if (xmlSchemaGroup == null)
			{
				SendValidationEvent("Sch_UndefGroupRef", groupRef.RefName.ToString(), groupRef);
				return XmlSchemaParticle.Empty;
			}
			if (xmlSchemaGroup.CanonicalParticle == null)
			{
				CompileGroup(xmlSchemaGroup);
			}
			if (xmlSchemaGroup.CanonicalParticle == XmlSchemaParticle.Empty)
			{
				return XmlSchemaParticle.Empty;
			}
			XmlSchemaGroupBase xmlSchemaGroupBase = (XmlSchemaGroupBase)xmlSchemaGroup.CanonicalParticle;
			if (xmlSchemaGroupBase is XmlSchemaAll)
			{
				if (!root)
				{
					SendValidationEvent("Sch_AllRefNotRoot", "", groupRef);
					return XmlSchemaParticle.Empty;
				}
				if (groupRef.MinOccurs != 1m || groupRef.MaxOccurs != 1m)
				{
					SendValidationEvent("Sch_AllRefMinMax", groupRef);
					return XmlSchemaParticle.Empty;
				}
			}
			else if (xmlSchemaGroupBase is XmlSchemaChoice && xmlSchemaGroupBase.Items.Count == 0)
			{
				if (groupRef.MinOccurs != 0m)
				{
					SendValidationEvent("Sch_EmptyChoice", groupRef, XmlSeverityType.Warning);
				}
				return XmlSchemaParticle.Empty;
			}
			XmlSchemaGroupBase xmlSchemaGroupBase2 = ((xmlSchemaGroupBase is XmlSchemaSequence) ? new XmlSchemaSequence() : ((xmlSchemaGroupBase is XmlSchemaChoice) ? ((XmlSchemaGroupBase)new XmlSchemaChoice()) : ((XmlSchemaGroupBase)new XmlSchemaAll())));
			xmlSchemaGroupBase2.MinOccurs = groupRef.MinOccurs;
			xmlSchemaGroupBase2.MaxOccurs = groupRef.MaxOccurs;
			foreach (XmlSchemaParticle item in xmlSchemaGroupBase.Items)
			{
				xmlSchemaGroupBase2.Items.Add(item);
			}
			groupRef.SetParticle(xmlSchemaGroupBase2);
			return xmlSchemaGroupBase2;
		}

		private XmlSchemaParticle CannonicalizeAll(XmlSchemaAll all, bool root, bool substitution)
		{
			if (all.Items.Count > 0)
			{
				XmlSchemaAll xmlSchemaAll = new XmlSchemaAll();
				xmlSchemaAll.MinOccurs = all.MinOccurs;
				xmlSchemaAll.MaxOccurs = all.MaxOccurs;
				xmlSchemaAll.SourceUri = all.SourceUri;
				xmlSchemaAll.LineNumber = all.LineNumber;
				xmlSchemaAll.LinePosition = all.LinePosition;
				foreach (XmlSchemaElement item in all.Items)
				{
					XmlSchemaParticle xmlSchemaParticle = CannonicalizeParticle(item, root: false, substitution);
					if (xmlSchemaParticle != XmlSchemaParticle.Empty)
					{
						xmlSchemaAll.Items.Add(xmlSchemaParticle);
					}
				}
				all = xmlSchemaAll;
			}
			if (all.Items.Count == 0)
			{
				return XmlSchemaParticle.Empty;
			}
			if (root && all.Items.Count == 1)
			{
				XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
				xmlSchemaSequence.MinOccurs = all.MinOccurs;
				xmlSchemaSequence.MaxOccurs = all.MaxOccurs;
				xmlSchemaSequence.Items.Add((XmlSchemaParticle)all.Items[0]);
				return xmlSchemaSequence;
			}
			if (!root && all.Items.Count == 1 && all.MinOccurs == 1m && all.MaxOccurs == 1m)
			{
				return (XmlSchemaParticle)all.Items[0];
			}
			if (!root)
			{
				SendValidationEvent("Sch_NotAllAlone", all);
				return XmlSchemaParticle.Empty;
			}
			return all;
		}

		private XmlSchemaParticle CannonicalizeChoice(XmlSchemaChoice choice, bool root, bool substitution)
		{
			XmlSchemaChoice source = choice;
			if (choice.Items.Count > 0)
			{
				XmlSchemaChoice xmlSchemaChoice = new XmlSchemaChoice();
				xmlSchemaChoice.MinOccurs = choice.MinOccurs;
				xmlSchemaChoice.MaxOccurs = choice.MaxOccurs;
				foreach (XmlSchemaParticle item2 in choice.Items)
				{
					XmlSchemaParticle xmlSchemaParticle = CannonicalizeParticle(item2, root: false, substitution);
					if (xmlSchemaParticle == XmlSchemaParticle.Empty)
					{
						continue;
					}
					if (xmlSchemaParticle.MinOccurs == 1m && xmlSchemaParticle.MaxOccurs == 1m && xmlSchemaParticle is XmlSchemaChoice)
					{
						foreach (XmlSchemaParticle item3 in ((XmlSchemaChoice)xmlSchemaParticle).Items)
						{
							xmlSchemaChoice.Items.Add(item3);
						}
					}
					else
					{
						xmlSchemaChoice.Items.Add(xmlSchemaParticle);
					}
				}
				choice = xmlSchemaChoice;
			}
			if (!root && choice.Items.Count == 0)
			{
				if (choice.MinOccurs != 0m)
				{
					SendValidationEvent("Sch_EmptyChoice", source, XmlSeverityType.Warning);
				}
				return XmlSchemaParticle.Empty;
			}
			if (!root && choice.Items.Count == 1 && choice.MinOccurs == 1m && choice.MaxOccurs == 1m)
			{
				return (XmlSchemaParticle)choice.Items[0];
			}
			return choice;
		}

		private XmlSchemaParticle CannonicalizeSequence(XmlSchemaSequence sequence, bool root, bool substitution)
		{
			if (sequence.Items.Count > 0)
			{
				XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
				xmlSchemaSequence.MinOccurs = sequence.MinOccurs;
				xmlSchemaSequence.MaxOccurs = sequence.MaxOccurs;
				foreach (XmlSchemaParticle item2 in sequence.Items)
				{
					XmlSchemaParticle xmlSchemaParticle = CannonicalizeParticle(item2, root: false, substitution);
					if (xmlSchemaParticle == XmlSchemaParticle.Empty)
					{
						continue;
					}
					if (xmlSchemaParticle.MinOccurs == 1m && xmlSchemaParticle.MaxOccurs == 1m && xmlSchemaParticle is XmlSchemaSequence)
					{
						foreach (XmlSchemaParticle item3 in ((XmlSchemaSequence)xmlSchemaParticle).Items)
						{
							xmlSchemaSequence.Items.Add(item3);
						}
					}
					else
					{
						xmlSchemaSequence.Items.Add(xmlSchemaParticle);
					}
				}
				sequence = xmlSchemaSequence;
			}
			if (sequence.Items.Count == 0)
			{
				return XmlSchemaParticle.Empty;
			}
			if (!root && sequence.Items.Count == 1 && sequence.MinOccurs == 1m && sequence.MaxOccurs == 1m)
			{
				return (XmlSchemaParticle)sequence.Items[0];
			}
			return sequence;
		}

		private bool IsValidRestriction(XmlSchemaParticle derivedParticle, XmlSchemaParticle baseParticle)
		{
			if (derivedParticle == baseParticle)
			{
				return true;
			}
			if (derivedParticle == null || derivedParticle == XmlSchemaParticle.Empty)
			{
				return IsParticleEmptiable(baseParticle);
			}
			if (baseParticle == null || baseParticle == XmlSchemaParticle.Empty)
			{
				return false;
			}
			if (baseParticle is XmlSchemaElement)
			{
				if (derivedParticle is XmlSchemaElement)
				{
					return IsElementFromElement((XmlSchemaElement)derivedParticle, (XmlSchemaElement)baseParticle);
				}
				return false;
			}
			if (baseParticle is XmlSchemaAny)
			{
				if (derivedParticle is XmlSchemaElement)
				{
					return IsElementFromAny((XmlSchemaElement)derivedParticle, (XmlSchemaAny)baseParticle);
				}
				if (derivedParticle is XmlSchemaAny)
				{
					return IsAnyFromAny((XmlSchemaAny)derivedParticle, (XmlSchemaAny)baseParticle);
				}
				return IsGroupBaseFromAny((XmlSchemaGroupBase)derivedParticle, (XmlSchemaAny)baseParticle);
			}
			if (baseParticle is XmlSchemaAll)
			{
				if (derivedParticle is XmlSchemaElement)
				{
					return IsElementFromGroupBase((XmlSchemaElement)derivedParticle, (XmlSchemaGroupBase)baseParticle, skipEmptableOnly: true);
				}
				if (derivedParticle is XmlSchemaAll)
				{
					return IsGroupBaseFromGroupBase((XmlSchemaGroupBase)derivedParticle, (XmlSchemaGroupBase)baseParticle, skipEmptableOnly: true);
				}
				if (derivedParticle is XmlSchemaSequence)
				{
					return IsSequenceFromAll((XmlSchemaSequence)derivedParticle, (XmlSchemaAll)baseParticle);
				}
			}
			else if (baseParticle is XmlSchemaChoice)
			{
				if (derivedParticle is XmlSchemaElement)
				{
					return IsElementFromGroupBase((XmlSchemaElement)derivedParticle, (XmlSchemaGroupBase)baseParticle, skipEmptableOnly: false);
				}
				if (derivedParticle is XmlSchemaChoice)
				{
					return IsGroupBaseFromGroupBase((XmlSchemaGroupBase)derivedParticle, (XmlSchemaGroupBase)baseParticle, skipEmptableOnly: false);
				}
				if (derivedParticle is XmlSchemaSequence)
				{
					return IsSequenceFromChoice((XmlSchemaSequence)derivedParticle, (XmlSchemaChoice)baseParticle);
				}
			}
			else if (baseParticle is XmlSchemaSequence)
			{
				if (derivedParticle is XmlSchemaElement)
				{
					return IsElementFromGroupBase((XmlSchemaElement)derivedParticle, (XmlSchemaGroupBase)baseParticle, skipEmptableOnly: true);
				}
				if (derivedParticle is XmlSchemaSequence)
				{
					return IsGroupBaseFromGroupBase((XmlSchemaGroupBase)derivedParticle, (XmlSchemaGroupBase)baseParticle, skipEmptableOnly: true);
				}
			}
			return false;
		}

		private bool IsElementFromElement(XmlSchemaElement derivedElement, XmlSchemaElement baseElement)
		{
			if (derivedElement.QualifiedName == baseElement.QualifiedName && derivedElement.IsNillable == baseElement.IsNillable && IsValidOccurrenceRangeRestriction(derivedElement, baseElement) && (baseElement.FixedValue == null || baseElement.FixedValue == derivedElement.FixedValue) && (derivedElement.BlockResolved | baseElement.BlockResolved) == derivedElement.BlockResolved && derivedElement.ElementSchemaType != null && baseElement.ElementSchemaType != null)
			{
				return XmlSchemaType.IsDerivedFrom(derivedElement.ElementSchemaType, baseElement.ElementSchemaType, ~XmlSchemaDerivationMethod.Restriction);
			}
			return false;
		}

		private bool IsElementFromAny(XmlSchemaElement derivedElement, XmlSchemaAny baseAny)
		{
			if (baseAny.Allows(derivedElement.QualifiedName))
			{
				return IsValidOccurrenceRangeRestriction(derivedElement, baseAny);
			}
			return false;
		}

		private bool IsAnyFromAny(XmlSchemaAny derivedAny, XmlSchemaAny baseAny)
		{
			if (IsValidOccurrenceRangeRestriction(derivedAny, baseAny))
			{
				return NamespaceList.IsSubset(derivedAny.NamespaceList, baseAny.NamespaceList);
			}
			return false;
		}

		private bool IsGroupBaseFromAny(XmlSchemaGroupBase derivedGroupBase, XmlSchemaAny baseAny)
		{
			CalculateEffectiveTotalRange(derivedGroupBase, out var minOccurs, out var maxOccurs);
			if (!IsValidOccurrenceRangeRestriction(minOccurs, maxOccurs, baseAny.MinOccurs, baseAny.MaxOccurs))
			{
				return false;
			}
			string minOccursString = baseAny.MinOccursString;
			baseAny.MinOccurs = 0m;
			foreach (XmlSchemaParticle item in derivedGroupBase.Items)
			{
				if (!IsValidRestriction(item, baseAny))
				{
					baseAny.MinOccursString = minOccursString;
					return false;
				}
			}
			baseAny.MinOccursString = minOccursString;
			return true;
		}

		private bool IsElementFromGroupBase(XmlSchemaElement derivedElement, XmlSchemaGroupBase baseGroupBase, bool skipEmptableOnly)
		{
			bool flag = false;
			foreach (XmlSchemaParticle item in baseGroupBase.Items)
			{
				if (!flag)
				{
					string minOccursString = item.MinOccursString;
					string maxOccursString = item.MaxOccursString;
					item.MinOccurs *= baseGroupBase.MinOccurs;
					if (item.MaxOccurs != decimal.MaxValue)
					{
						if (baseGroupBase.MaxOccurs == decimal.MaxValue)
						{
							item.MaxOccurs = decimal.MaxValue;
						}
						else
						{
							item.MaxOccurs *= baseGroupBase.MaxOccurs;
						}
					}
					flag = IsValidRestriction(derivedElement, item);
					item.MinOccursString = minOccursString;
					item.MaxOccursString = maxOccursString;
				}
				else if (skipEmptableOnly && !IsParticleEmptiable(item))
				{
					return false;
				}
			}
			return flag;
		}

		private bool IsGroupBaseFromGroupBase(XmlSchemaGroupBase derivedGroupBase, XmlSchemaGroupBase baseGroupBase, bool skipEmptableOnly)
		{
			if (!IsValidOccurrenceRangeRestriction(derivedGroupBase, baseGroupBase) || derivedGroupBase.Items.Count > baseGroupBase.Items.Count)
			{
				return false;
			}
			int num = 0;
			foreach (XmlSchemaParticle item in baseGroupBase.Items)
			{
				if (num < derivedGroupBase.Items.Count && IsValidRestriction((XmlSchemaParticle)derivedGroupBase.Items[num], item))
				{
					num++;
				}
				else if (skipEmptableOnly && !IsParticleEmptiable(item))
				{
					return false;
				}
			}
			if (num < derivedGroupBase.Items.Count)
			{
				return false;
			}
			return true;
		}

		private bool IsSequenceFromAll(XmlSchemaSequence derivedSequence, XmlSchemaAll baseAll)
		{
			if (!IsValidOccurrenceRangeRestriction(derivedSequence, baseAll) || derivedSequence.Items.Count > baseAll.Items.Count)
			{
				return false;
			}
			BitSet bitSet = new BitSet(baseAll.Items.Count);
			foreach (XmlSchemaParticle item in derivedSequence.Items)
			{
				int mappingParticle = GetMappingParticle(item, baseAll.Items);
				if (mappingParticle >= 0)
				{
					if (bitSet[mappingParticle])
					{
						return false;
					}
					bitSet.Set(mappingParticle);
					continue;
				}
				return false;
			}
			for (int i = 0; i < baseAll.Items.Count; i++)
			{
				if (!bitSet[i] && !IsParticleEmptiable((XmlSchemaParticle)baseAll.Items[i]))
				{
					return false;
				}
			}
			return true;
		}

		private bool IsSequenceFromChoice(XmlSchemaSequence derivedSequence, XmlSchemaChoice baseChoice)
		{
			CalculateSequenceRange(derivedSequence, out var minOccurs, out var maxOccurs);
			if (!IsValidOccurrenceRangeRestriction(minOccurs, maxOccurs, baseChoice.MinOccurs, baseChoice.MaxOccurs) || derivedSequence.Items.Count > baseChoice.Items.Count)
			{
				return false;
			}
			foreach (XmlSchemaParticle item in derivedSequence.Items)
			{
				if (GetMappingParticle(item, baseChoice.Items) < 0)
				{
					return false;
				}
			}
			return true;
		}

		private void CalculateSequenceRange(XmlSchemaSequence sequence, out decimal minOccurs, out decimal maxOccurs)
		{
			minOccurs = 0m;
			maxOccurs = 0m;
			foreach (XmlSchemaParticle item in sequence.Items)
			{
				minOccurs += item.MinOccurs;
				if (item.MaxOccurs == decimal.MaxValue)
				{
					maxOccurs = decimal.MaxValue;
				}
				else if (maxOccurs != decimal.MaxValue)
				{
					maxOccurs += item.MaxOccurs;
				}
			}
			minOccurs *= sequence.MinOccurs;
			if (sequence.MaxOccurs == decimal.MaxValue)
			{
				maxOccurs = decimal.MaxValue;
			}
			else if (maxOccurs != decimal.MaxValue)
			{
				maxOccurs *= sequence.MaxOccurs;
			}
		}

		private bool IsValidOccurrenceRangeRestriction(XmlSchemaParticle derivedParticle, XmlSchemaParticle baseParticle)
		{
			return IsValidOccurrenceRangeRestriction(derivedParticle.MinOccurs, derivedParticle.MaxOccurs, baseParticle.MinOccurs, baseParticle.MaxOccurs);
		}

		private bool IsValidOccurrenceRangeRestriction(decimal minOccurs, decimal maxOccurs, decimal baseMinOccurs, decimal baseMaxOccurs)
		{
			if (baseMinOccurs <= minOccurs)
			{
				return maxOccurs <= baseMaxOccurs;
			}
			return false;
		}

		private int GetMappingParticle(XmlSchemaParticle particle, XmlSchemaObjectCollection collection)
		{
			for (int i = 0; i < collection.Count; i++)
			{
				if (IsValidRestriction(particle, (XmlSchemaParticle)collection[i]))
				{
					return i;
				}
			}
			return -1;
		}

		private bool IsParticleEmptiable(XmlSchemaParticle particle)
		{
			CalculateEffectiveTotalRange(particle, out var minOccurs, out var _);
			return minOccurs == 0m;
		}

		private void CalculateEffectiveTotalRange(XmlSchemaParticle particle, out decimal minOccurs, out decimal maxOccurs)
		{
			if (particle is XmlSchemaElement || particle is XmlSchemaAny)
			{
				minOccurs = particle.MinOccurs;
				maxOccurs = particle.MaxOccurs;
				return;
			}
			if (particle is XmlSchemaChoice)
			{
				if (((XmlSchemaChoice)particle).Items.Count == 0)
				{
					minOccurs = (maxOccurs = 0m);
					return;
				}
				minOccurs = decimal.MaxValue;
				maxOccurs = 0m;
				foreach (XmlSchemaParticle item in ((XmlSchemaChoice)particle).Items)
				{
					CalculateEffectiveTotalRange(item, out var minOccurs2, out var maxOccurs2);
					if (minOccurs2 < minOccurs)
					{
						minOccurs = minOccurs2;
					}
					if (maxOccurs2 > maxOccurs)
					{
						maxOccurs = maxOccurs2;
					}
				}
				minOccurs *= particle.MinOccurs;
				if (maxOccurs != decimal.MaxValue)
				{
					if (particle.MaxOccurs == decimal.MaxValue)
					{
						maxOccurs = decimal.MaxValue;
					}
					else
					{
						maxOccurs *= particle.MaxOccurs;
					}
				}
				return;
			}
			XmlSchemaObjectCollection items = ((XmlSchemaGroupBase)particle).Items;
			if (items.Count == 0)
			{
				minOccurs = (maxOccurs = 0m);
				return;
			}
			minOccurs = 0m;
			maxOccurs = 0m;
			foreach (XmlSchemaParticle item2 in items)
			{
				CalculateEffectiveTotalRange(item2, out var minOccurs3, out var maxOccurs3);
				minOccurs += minOccurs3;
				if (maxOccurs != decimal.MaxValue)
				{
					if (maxOccurs3 == decimal.MaxValue)
					{
						maxOccurs = decimal.MaxValue;
					}
					else
					{
						maxOccurs += maxOccurs3;
					}
				}
			}
			minOccurs *= particle.MinOccurs;
			if (maxOccurs != decimal.MaxValue)
			{
				if (particle.MaxOccurs == decimal.MaxValue)
				{
					maxOccurs = decimal.MaxValue;
				}
				else
				{
					maxOccurs *= particle.MaxOccurs;
				}
			}
		}

		private void PushComplexType(XmlSchemaComplexType complexType)
		{
			complexTypeStack.Push(complexType);
		}

		private XmlSchemaContentType GetSchemaContentType(XmlSchemaComplexType complexType, XmlSchemaComplexContent complexContent, XmlSchemaParticle particle)
		{
			if ((complexContent != null && complexContent.IsMixed) || (complexContent == null && complexType.IsMixed))
			{
				return XmlSchemaContentType.Mixed;
			}
			if (particle != null && !particle.IsEmpty)
			{
				return XmlSchemaContentType.ElementOnly;
			}
			return XmlSchemaContentType.Empty;
		}

		private void CompileAttributeGroup(XmlSchemaAttributeGroup attributeGroup)
		{
			if (attributeGroup.IsProcessing)
			{
				SendValidationEvent("Sch_AttributeGroupCircularRef", attributeGroup);
			}
			else
			{
				if (attributeGroup.AttributeUses.Count > 0)
				{
					return;
				}
				attributeGroup.IsProcessing = true;
				XmlSchemaAnyAttribute xmlSchemaAnyAttribute = attributeGroup.AnyAttribute;
				foreach (XmlSchemaObject attribute in attributeGroup.Attributes)
				{
					if (attribute is XmlSchemaAttribute)
					{
						XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)attribute;
						if (xmlSchemaAttribute.Use != XmlSchemaUse.Prohibited)
						{
							CompileAttribute(xmlSchemaAttribute);
						}
						if (attributeGroup.AttributeUses[xmlSchemaAttribute.QualifiedName] == null)
						{
							attributeGroup.AttributeUses.Add(xmlSchemaAttribute.QualifiedName, xmlSchemaAttribute);
						}
						else
						{
							SendValidationEvent("Sch_DupAttributeUse", xmlSchemaAttribute.QualifiedName.ToString(), xmlSchemaAttribute);
						}
						continue;
					}
					XmlSchemaAttributeGroupRef xmlSchemaAttributeGroupRef = (XmlSchemaAttributeGroupRef)attribute;
					XmlSchemaAttributeGroup xmlSchemaAttributeGroup = ((attributeGroup.Redefined == null || !(xmlSchemaAttributeGroupRef.RefName == attributeGroup.Redefined.QualifiedName)) ? ((XmlSchemaAttributeGroup)schema.AttributeGroups[xmlSchemaAttributeGroupRef.RefName]) : attributeGroup.Redefined);
					if (xmlSchemaAttributeGroup != null)
					{
						CompileAttributeGroup(xmlSchemaAttributeGroup);
						foreach (XmlSchemaAttribute value in xmlSchemaAttributeGroup.AttributeUses.Values)
						{
							if (attributeGroup.AttributeUses[value.QualifiedName] == null)
							{
								attributeGroup.AttributeUses.Add(value.QualifiedName, value);
							}
							else
							{
								SendValidationEvent("Sch_DupAttributeUse", value.QualifiedName.ToString(), value);
							}
						}
						xmlSchemaAnyAttribute = CompileAnyAttributeIntersection(xmlSchemaAnyAttribute, xmlSchemaAttributeGroup.AttributeWildcard);
					}
					else
					{
						SendValidationEvent("Sch_UndefAttributeGroupRef", xmlSchemaAttributeGroupRef.RefName.ToString(), xmlSchemaAttributeGroupRef);
					}
				}
				attributeGroup.AttributeWildcard = xmlSchemaAnyAttribute;
				attributeGroup.IsProcessing = false;
			}
		}

		private void CompileLocalAttributes(XmlSchemaComplexType baseType, XmlSchemaComplexType derivedType, XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, XmlSchemaDerivationMethod derivedBy)
		{
			XmlSchemaAnyAttribute xmlSchemaAnyAttribute = baseType?.AttributeWildcard;
			foreach (XmlSchemaObject attribute in attributes)
			{
				if (attribute is XmlSchemaAttribute)
				{
					XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)attribute;
					if (xmlSchemaAttribute.Use != XmlSchemaUse.Prohibited)
					{
						CompileAttribute(xmlSchemaAttribute);
					}
					if (xmlSchemaAttribute.Use != XmlSchemaUse.Prohibited || (xmlSchemaAttribute.Use == XmlSchemaUse.Prohibited && derivedBy == XmlSchemaDerivationMethod.Restriction && baseType != XmlSchemaComplexType.AnyType))
					{
						if (derivedType.AttributeUses[xmlSchemaAttribute.QualifiedName] == null)
						{
							derivedType.AttributeUses.Add(xmlSchemaAttribute.QualifiedName, xmlSchemaAttribute);
						}
						else
						{
							SendValidationEvent("Sch_DupAttributeUse", xmlSchemaAttribute.QualifiedName.ToString(), xmlSchemaAttribute);
						}
					}
					else
					{
						SendValidationEvent("Sch_AttributeIgnored", xmlSchemaAttribute.QualifiedName.ToString(), xmlSchemaAttribute, XmlSeverityType.Warning);
					}
					continue;
				}
				XmlSchemaAttributeGroupRef xmlSchemaAttributeGroupRef = (XmlSchemaAttributeGroupRef)attribute;
				XmlSchemaAttributeGroup xmlSchemaAttributeGroup = (XmlSchemaAttributeGroup)schema.AttributeGroups[xmlSchemaAttributeGroupRef.RefName];
				if (xmlSchemaAttributeGroup != null)
				{
					CompileAttributeGroup(xmlSchemaAttributeGroup);
					foreach (XmlSchemaAttribute value in xmlSchemaAttributeGroup.AttributeUses.Values)
					{
						if (value.Use != XmlSchemaUse.Prohibited || (value.Use == XmlSchemaUse.Prohibited && derivedBy == XmlSchemaDerivationMethod.Restriction && baseType != XmlSchemaComplexType.AnyType))
						{
							if (derivedType.AttributeUses[value.QualifiedName] == null)
							{
								derivedType.AttributeUses.Add(value.QualifiedName, value);
							}
							else
							{
								SendValidationEvent("Sch_DupAttributeUse", value.QualifiedName.ToString(), xmlSchemaAttributeGroupRef);
							}
						}
						else
						{
							SendValidationEvent("Sch_AttributeIgnored", value.QualifiedName.ToString(), value, XmlSeverityType.Warning);
						}
					}
					anyAttribute = CompileAnyAttributeIntersection(anyAttribute, xmlSchemaAttributeGroup.AttributeWildcard);
				}
				else
				{
					SendValidationEvent("Sch_UndefAttributeGroupRef", xmlSchemaAttributeGroupRef.RefName.ToString(), xmlSchemaAttributeGroupRef);
				}
			}
			if (baseType != null)
			{
				if (derivedBy == XmlSchemaDerivationMethod.Extension)
				{
					derivedType.SetAttributeWildcard(CompileAnyAttributeUnion(anyAttribute, xmlSchemaAnyAttribute));
					{
						foreach (XmlSchemaAttribute value2 in baseType.AttributeUses.Values)
						{
							XmlSchemaAttribute xmlSchemaAttribute4 = (XmlSchemaAttribute)derivedType.AttributeUses[value2.QualifiedName];
							if (xmlSchemaAttribute4 != null)
							{
								if (xmlSchemaAttribute4.AttributeSchemaType != value2.AttributeSchemaType || value2.Use == XmlSchemaUse.Prohibited)
								{
									SendValidationEvent("Sch_InvalidAttributeExtension", xmlSchemaAttribute4);
								}
							}
							else
							{
								derivedType.AttributeUses.Add(value2.QualifiedName, value2);
							}
						}
						return;
					}
				}
				if (anyAttribute != null && (xmlSchemaAnyAttribute == null || !XmlSchemaAnyAttribute.IsSubset(anyAttribute, xmlSchemaAnyAttribute)))
				{
					SendValidationEvent("Sch_InvalidAnyAttributeRestriction", derivedType);
				}
				else
				{
					derivedType.SetAttributeWildcard(anyAttribute);
				}
				foreach (XmlSchemaAttribute value3 in baseType.AttributeUses.Values)
				{
					XmlSchemaAttribute xmlSchemaAttribute6 = (XmlSchemaAttribute)derivedType.AttributeUses[value3.QualifiedName];
					if (xmlSchemaAttribute6 == null)
					{
						derivedType.AttributeUses.Add(value3.QualifiedName, value3);
					}
					else if (value3.Use == XmlSchemaUse.Prohibited && xmlSchemaAttribute6.Use != XmlSchemaUse.Prohibited)
					{
						SendValidationEvent("Sch_AttributeRestrictionProhibited", xmlSchemaAttribute6);
					}
					else if (xmlSchemaAttribute6.Use != XmlSchemaUse.Prohibited && (value3.AttributeSchemaType == null || xmlSchemaAttribute6.AttributeSchemaType == null || !XmlSchemaType.IsDerivedFrom(xmlSchemaAttribute6.AttributeSchemaType, value3.AttributeSchemaType, XmlSchemaDerivationMethod.Empty)))
					{
						SendValidationEvent("Sch_AttributeRestrictionInvalid", xmlSchemaAttribute6);
					}
				}
				{
					foreach (XmlSchemaAttribute value4 in derivedType.AttributeUses.Values)
					{
						XmlSchemaAttribute xmlSchemaAttribute8 = (XmlSchemaAttribute)baseType.AttributeUses[value4.QualifiedName];
						if (xmlSchemaAttribute8 == null && (xmlSchemaAnyAttribute == null || !xmlSchemaAnyAttribute.Allows(value4.QualifiedName)))
						{
							SendValidationEvent("Sch_AttributeRestrictionInvalidFromWildcard", value4);
						}
					}
					return;
				}
			}
			derivedType.SetAttributeWildcard(anyAttribute);
		}

		private XmlSchemaAnyAttribute CompileAnyAttributeUnion(XmlSchemaAnyAttribute a, XmlSchemaAnyAttribute b)
		{
			if (a == null)
			{
				return b;
			}
			if (b == null)
			{
				return a;
			}
			XmlSchemaAnyAttribute xmlSchemaAnyAttribute = XmlSchemaAnyAttribute.Union(a, b, v1Compat: true);
			if (xmlSchemaAnyAttribute == null)
			{
				SendValidationEvent("Sch_UnexpressibleAnyAttribute", a);
			}
			return xmlSchemaAnyAttribute;
		}

		private XmlSchemaAnyAttribute CompileAnyAttributeIntersection(XmlSchemaAnyAttribute a, XmlSchemaAnyAttribute b)
		{
			if (a == null)
			{
				return b;
			}
			if (b == null)
			{
				return a;
			}
			XmlSchemaAnyAttribute xmlSchemaAnyAttribute = XmlSchemaAnyAttribute.Intersection(a, b, v1Compat: true);
			if (xmlSchemaAnyAttribute == null)
			{
				SendValidationEvent("Sch_UnexpressibleAnyAttribute", a);
			}
			return xmlSchemaAnyAttribute;
		}

		private void CompileAttribute(XmlSchemaAttribute xa)
		{
			if (xa.IsProcessing)
			{
				SendValidationEvent("Sch_AttributeCircularRef", xa);
			}
			else
			{
				if (xa.AttDef != null)
				{
					return;
				}
				xa.IsProcessing = true;
				SchemaAttDef schemaAttDef = null;
				try
				{
					if (!xa.RefName.IsEmpty)
					{
						XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)schema.Attributes[xa.RefName];
						if (xmlSchemaAttribute == null)
						{
							throw new XmlSchemaException("Sch_UndeclaredAttribute", xa.RefName.ToString(), xa);
						}
						CompileAttribute(xmlSchemaAttribute);
						if (xmlSchemaAttribute.AttDef == null)
						{
							throw new XmlSchemaException("Sch_RefInvalidAttribute", xa.RefName.ToString(), xa);
						}
						schemaAttDef = xmlSchemaAttribute.AttDef.Clone();
						if (schemaAttDef.Datatype != null)
						{
							if (xmlSchemaAttribute.FixedValue != null)
							{
								if (xa.DefaultValue != null)
								{
									throw new XmlSchemaException("Sch_FixedDefaultInRef", xa.RefName.ToString(), xa);
								}
								if (xa.FixedValue != null)
								{
									if (xa.FixedValue != xmlSchemaAttribute.FixedValue)
									{
										throw new XmlSchemaException("Sch_FixedInRef", xa.RefName.ToString(), xa);
									}
								}
								else
								{
									schemaAttDef.Presence = SchemaDeclBase.Use.Fixed;
									string text2 = (schemaAttDef.DefaultValueRaw = (schemaAttDef.DefaultValueExpanded = xmlSchemaAttribute.FixedValue));
									schemaAttDef.DefaultValueTyped = schemaAttDef.Datatype.ParseValue(schemaAttDef.DefaultValueRaw, base.NameTable, new SchemaNamespaceManager(xa), createAtomicValue: true);
								}
							}
							else if (xmlSchemaAttribute.DefaultValue != null && xa.DefaultValue == null && xa.FixedValue == null)
							{
								schemaAttDef.Presence = SchemaDeclBase.Use.Default;
								string text4 = (schemaAttDef.DefaultValueRaw = (schemaAttDef.DefaultValueExpanded = xmlSchemaAttribute.DefaultValue));
								schemaAttDef.DefaultValueTyped = schemaAttDef.Datatype.ParseValue(schemaAttDef.DefaultValueRaw, base.NameTable, new SchemaNamespaceManager(xa), createAtomicValue: true);
							}
						}
						xa.SetAttributeType(xmlSchemaAttribute.AttributeSchemaType);
					}
					else
					{
						schemaAttDef = new SchemaAttDef(xa.QualifiedName, xa.Prefix);
						if (xa.SchemaType != null)
						{
							CompileSimpleType(xa.SchemaType);
							xa.SetAttributeType(xa.SchemaType);
							schemaAttDef.SchemaType = xa.SchemaType;
							schemaAttDef.Datatype = xa.SchemaType.Datatype;
						}
						else if (!xa.SchemaTypeName.IsEmpty)
						{
							XmlSchemaSimpleType simpleType = GetSimpleType(xa.SchemaTypeName);
							if (simpleType == null)
							{
								throw new XmlSchemaException("Sch_UndeclaredSimpleType", xa.SchemaTypeName.ToString(), xa);
							}
							xa.SetAttributeType(simpleType);
							schemaAttDef.Datatype = simpleType.Datatype;
							schemaAttDef.SchemaType = simpleType;
						}
						else
						{
							schemaAttDef.SchemaType = DatatypeImplementation.AnySimpleType;
							schemaAttDef.Datatype = DatatypeImplementation.AnySimpleType.Datatype;
							xa.SetAttributeType(DatatypeImplementation.AnySimpleType);
						}
					}
					if (schemaAttDef.Datatype != null)
					{
						schemaAttDef.Datatype.VerifySchemaValid(schema.Notations, xa);
					}
					if (xa.DefaultValue != null || xa.FixedValue != null)
					{
						if (xa.DefaultValue != null)
						{
							schemaAttDef.Presence = SchemaDeclBase.Use.Default;
							string text6 = (schemaAttDef.DefaultValueRaw = (schemaAttDef.DefaultValueExpanded = xa.DefaultValue));
						}
						else
						{
							schemaAttDef.Presence = SchemaDeclBase.Use.Fixed;
							string text8 = (schemaAttDef.DefaultValueRaw = (schemaAttDef.DefaultValueExpanded = xa.FixedValue));
						}
						if (schemaAttDef.Datatype != null)
						{
							schemaAttDef.DefaultValueTyped = schemaAttDef.Datatype.ParseValue(schemaAttDef.DefaultValueRaw, base.NameTable, new SchemaNamespaceManager(xa), createAtomicValue: true);
						}
					}
					else
					{
						switch (xa.Use)
						{
						case XmlSchemaUse.None:
						case XmlSchemaUse.Optional:
							schemaAttDef.Presence = SchemaDeclBase.Use.Implied;
							break;
						case XmlSchemaUse.Required:
							schemaAttDef.Presence = SchemaDeclBase.Use.Required;
							break;
						}
					}
					schemaAttDef.SchemaAttribute = xa;
					xa.AttDef = schemaAttDef;
				}
				catch (XmlSchemaException ex)
				{
					if (ex.SourceSchemaObject == null)
					{
						ex.SetSource(xa);
					}
					SendValidationEvent(ex);
					xa.AttDef = SchemaAttDef.Empty;
				}
				finally
				{
					xa.IsProcessing = false;
				}
			}
		}

		private void CompileIdentityConstraint(XmlSchemaIdentityConstraint xi)
		{
			if (xi.IsProcessing)
			{
				xi.CompiledConstraint = CompiledIdentityConstraint.Empty;
				SendValidationEvent("Sch_IdentityConstraintCircularRef", xi);
			}
			else
			{
				if (xi.CompiledConstraint != null)
				{
					return;
				}
				xi.IsProcessing = true;
				CompiledIdentityConstraint compiledIdentityConstraint = null;
				try
				{
					SchemaNamespaceManager nsmgr = new SchemaNamespaceManager(xi);
					compiledIdentityConstraint = new CompiledIdentityConstraint(xi, nsmgr);
					if (xi is XmlSchemaKeyref)
					{
						XmlSchemaIdentityConstraint xmlSchemaIdentityConstraint = (XmlSchemaIdentityConstraint)schema.IdentityConstraints[((XmlSchemaKeyref)xi).Refer];
						if (xmlSchemaIdentityConstraint == null)
						{
							throw new XmlSchemaException("Sch_UndeclaredIdentityConstraint", ((XmlSchemaKeyref)xi).Refer.ToString(), xi);
						}
						CompileIdentityConstraint(xmlSchemaIdentityConstraint);
						if (xmlSchemaIdentityConstraint.CompiledConstraint == null)
						{
							throw new XmlSchemaException("Sch_RefInvalidIdentityConstraint", ((XmlSchemaKeyref)xi).Refer.ToString(), xi);
						}
						if (xmlSchemaIdentityConstraint.Fields.Count != xi.Fields.Count)
						{
							throw new XmlSchemaException("Sch_RefInvalidCardin", xi.QualifiedName.ToString(), xi);
						}
						if (xmlSchemaIdentityConstraint.CompiledConstraint.Role == CompiledIdentityConstraint.ConstraintRole.Keyref)
						{
							throw new XmlSchemaException("Sch_ReftoKeyref", xi.QualifiedName.ToString(), xi);
						}
					}
					xi.CompiledConstraint = compiledIdentityConstraint;
				}
				catch (XmlSchemaException ex)
				{
					if (ex.SourceSchemaObject == null)
					{
						ex.SetSource(xi);
					}
					SendValidationEvent(ex);
					xi.CompiledConstraint = CompiledIdentityConstraint.Empty;
				}
				finally
				{
					xi.IsProcessing = false;
				}
			}
		}

		private void CompileElement(XmlSchemaElement xe)
		{
			if (xe.IsProcessing)
			{
				SendValidationEvent("Sch_ElementCircularRef", xe);
			}
			else
			{
				if (xe.ElementDecl != null)
				{
					return;
				}
				xe.IsProcessing = true;
				SchemaElementDecl schemaElementDecl = null;
				try
				{
					if (!xe.RefName.IsEmpty)
					{
						XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)schema.Elements[xe.RefName];
						if (xmlSchemaElement == null)
						{
							throw new XmlSchemaException("Sch_UndeclaredElement", xe.RefName.ToString(), xe);
						}
						CompileElement(xmlSchemaElement);
						if (xmlSchemaElement.ElementDecl == null)
						{
							throw new XmlSchemaException("Sch_RefInvalidElement", xe.RefName.ToString(), xe);
						}
						xe.SetElementType(xmlSchemaElement.ElementSchemaType);
						schemaElementDecl = xmlSchemaElement.ElementDecl.Clone();
					}
					else
					{
						if (xe.SchemaType != null)
						{
							xe.SetElementType(xe.SchemaType);
						}
						else if (!xe.SchemaTypeName.IsEmpty)
						{
							xe.SetElementType(GetAnySchemaType(xe.SchemaTypeName));
							if (xe.ElementSchemaType == null)
							{
								throw new XmlSchemaException("Sch_UndeclaredType", xe.SchemaTypeName.ToString(), xe);
							}
						}
						else if (!xe.SubstitutionGroup.IsEmpty)
						{
							XmlSchemaElement xmlSchemaElement2 = (XmlSchemaElement)schema.Elements[xe.SubstitutionGroup];
							if (xmlSchemaElement2 == null)
							{
								throw new XmlSchemaException("Sch_UndeclaredEquivClass", xe.SubstitutionGroup.Name.ToString(CultureInfo.InvariantCulture), xe);
							}
							if (xmlSchemaElement2.IsProcessing)
							{
								return;
							}
							CompileElement(xmlSchemaElement2);
							if (xmlSchemaElement2.ElementDecl == null)
							{
								xe.SetElementType(XmlSchemaComplexType.AnyType);
								schemaElementDecl = XmlSchemaComplexType.AnyType.ElementDecl.Clone();
							}
							else
							{
								xe.SetElementType(xmlSchemaElement2.ElementSchemaType);
								schemaElementDecl = xmlSchemaElement2.ElementDecl.Clone();
							}
						}
						else
						{
							xe.SetElementType(XmlSchemaComplexType.AnyType);
							schemaElementDecl = XmlSchemaComplexType.AnyType.ElementDecl.Clone();
						}
						if (schemaElementDecl == null)
						{
							if (xe.ElementSchemaType is XmlSchemaComplexType)
							{
								XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)xe.ElementSchemaType;
								CompileComplexType(xmlSchemaComplexType);
								if (xmlSchemaComplexType.ElementDecl != null)
								{
									schemaElementDecl = xmlSchemaComplexType.ElementDecl.Clone();
								}
							}
							else if (xe.ElementSchemaType is XmlSchemaSimpleType)
							{
								XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)xe.ElementSchemaType;
								CompileSimpleType(xmlSchemaSimpleType);
								if (xmlSchemaSimpleType.ElementDecl != null)
								{
									schemaElementDecl = xmlSchemaSimpleType.ElementDecl.Clone();
								}
							}
						}
						schemaElementDecl.Name = xe.QualifiedName;
						schemaElementDecl.IsAbstract = xe.IsAbstract;
						if (xe.ElementSchemaType is XmlSchemaComplexType xmlSchemaComplexType2)
						{
							schemaElementDecl.IsAbstract |= xmlSchemaComplexType2.IsAbstract;
						}
						schemaElementDecl.IsNillable = xe.IsNillable;
						schemaElementDecl.Block |= xe.BlockResolved;
					}
					if (schemaElementDecl.Datatype != null)
					{
						schemaElementDecl.Datatype.VerifySchemaValid(schema.Notations, xe);
					}
					if ((xe.DefaultValue != null || xe.FixedValue != null) && schemaElementDecl.ContentValidator != null)
					{
						if (schemaElementDecl.ContentValidator.ContentType == XmlSchemaContentType.TextOnly)
						{
							if (xe.DefaultValue != null)
							{
								schemaElementDecl.Presence = SchemaDeclBase.Use.Default;
								schemaElementDecl.DefaultValueRaw = xe.DefaultValue;
							}
							else
							{
								schemaElementDecl.Presence = SchemaDeclBase.Use.Fixed;
								schemaElementDecl.DefaultValueRaw = xe.FixedValue;
							}
							if (schemaElementDecl.Datatype != null)
							{
								schemaElementDecl.DefaultValueTyped = schemaElementDecl.Datatype.ParseValue(schemaElementDecl.DefaultValueRaw, base.NameTable, new SchemaNamespaceManager(xe), createAtomicValue: true);
							}
						}
						else if (schemaElementDecl.ContentValidator.ContentType != XmlSchemaContentType.Mixed || !schemaElementDecl.ContentValidator.IsEmptiable)
						{
							throw new XmlSchemaException("Sch_ElementCannotHaveValue", xe);
						}
					}
					if (xe.HasConstraints)
					{
						XmlSchemaObjectCollection constraints = xe.Constraints;
						CompiledIdentityConstraint[] array = new CompiledIdentityConstraint[constraints.Count];
						int num = 0;
						foreach (XmlSchemaIdentityConstraint item in constraints)
						{
							CompileIdentityConstraint(item);
							array[num++] = item.CompiledConstraint;
						}
						schemaElementDecl.Constraints = array;
					}
					schemaElementDecl.SchemaElement = xe;
					xe.ElementDecl = schemaElementDecl;
				}
				catch (XmlSchemaException ex)
				{
					if (ex.SourceSchemaObject == null)
					{
						ex.SetSource(xe);
					}
					SendValidationEvent(ex);
					xe.ElementDecl = SchemaElementDecl.Empty;
				}
				finally
				{
					xe.IsProcessing = false;
				}
			}
		}

		private ContentValidator CompileComplexContent(XmlSchemaComplexType complexType)
		{
			if (complexType.ContentType == XmlSchemaContentType.Empty)
			{
				return ContentValidator.Empty;
			}
			if (complexType.ContentType == XmlSchemaContentType.TextOnly)
			{
				return ContentValidator.TextOnly;
			}
			XmlSchemaParticle contentTypeParticle = complexType.ContentTypeParticle;
			if (contentTypeParticle == null || contentTypeParticle == XmlSchemaParticle.Empty)
			{
				if (complexType.ContentType == XmlSchemaContentType.ElementOnly)
				{
					return ContentValidator.Empty;
				}
				return ContentValidator.Mixed;
			}
			PushComplexType(complexType);
			if (contentTypeParticle is XmlSchemaAll)
			{
				XmlSchemaAll xmlSchemaAll = (XmlSchemaAll)contentTypeParticle;
				AllElementsContentValidator allElementsContentValidator = new AllElementsContentValidator(complexType.ContentType, xmlSchemaAll.Items.Count, xmlSchemaAll.MinOccurs == 0m);
				{
					foreach (XmlSchemaElement item in xmlSchemaAll.Items)
					{
						if (!allElementsContentValidator.AddElement(item.QualifiedName, item, item.MinOccurs == 0m))
						{
							SendValidationEvent("Sch_DupElement", item.QualifiedName.ToString(), item);
						}
					}
					return allElementsContentValidator;
				}
			}
			ParticleContentValidator particleContentValidator = new ParticleContentValidator(complexType.ContentType);
			try
			{
				particleContentValidator.Start();
				BuildParticleContentModel(particleContentValidator, contentTypeParticle);
				return particleContentValidator.Finish(compileContentModel);
			}
			catch (UpaException ex)
			{
				if (ex.Particle1 is XmlSchemaElement)
				{
					if (ex.Particle2 is XmlSchemaElement)
					{
						SendValidationEvent("Sch_NonDeterministic", ((XmlSchemaElement)ex.Particle1).QualifiedName.ToString(), (XmlSchemaElement)ex.Particle2);
					}
					else
					{
						SendValidationEvent("Sch_NonDeterministicAnyEx", ((XmlSchemaAny)ex.Particle2).NamespaceList.ToString(), ((XmlSchemaElement)ex.Particle1).QualifiedName.ToString(), (XmlSchemaAny)ex.Particle2);
					}
				}
				else if (ex.Particle2 is XmlSchemaElement)
				{
					SendValidationEvent("Sch_NonDeterministicAnyEx", ((XmlSchemaAny)ex.Particle1).NamespaceList.ToString(), ((XmlSchemaElement)ex.Particle2).QualifiedName.ToString(), (XmlSchemaAny)ex.Particle1);
				}
				else
				{
					SendValidationEvent("Sch_NonDeterministicAnyAny", ((XmlSchemaAny)ex.Particle1).NamespaceList.ToString(), ((XmlSchemaAny)ex.Particle2).NamespaceList.ToString(), (XmlSchemaAny)ex.Particle1);
				}
				return XmlSchemaComplexType.AnyTypeContentValidator;
			}
			catch (NotSupportedException)
			{
				SendValidationEvent("Sch_ComplexContentModel", complexType, XmlSeverityType.Warning);
				return XmlSchemaComplexType.AnyTypeContentValidator;
			}
		}

		private void BuildParticleContentModel(ParticleContentValidator contentValidator, XmlSchemaParticle particle)
		{
			if (particle is XmlSchemaElement)
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)particle;
				contentValidator.AddName(xmlSchemaElement.QualifiedName, xmlSchemaElement);
			}
			else if (particle is XmlSchemaAny)
			{
				XmlSchemaAny xmlSchemaAny = (XmlSchemaAny)particle;
				contentValidator.AddNamespaceList(xmlSchemaAny.NamespaceList, xmlSchemaAny);
			}
			else if (particle is XmlSchemaGroupBase)
			{
				XmlSchemaObjectCollection items = ((XmlSchemaGroupBase)particle).Items;
				bool flag = particle is XmlSchemaChoice;
				contentValidator.OpenGroup();
				bool flag2 = true;
				foreach (XmlSchemaParticle item in items)
				{
					if (flag2)
					{
						flag2 = false;
					}
					else if (flag)
					{
						contentValidator.AddChoice();
					}
					else
					{
						contentValidator.AddSequence();
					}
					BuildParticleContentModel(contentValidator, item);
				}
				contentValidator.CloseGroup();
			}
			if (!(particle.MinOccurs == 1m) || !(particle.MaxOccurs == 1m))
			{
				if (particle.MinOccurs == 0m && particle.MaxOccurs == 1m)
				{
					contentValidator.AddQMark();
				}
				else if (particle.MinOccurs == 0m && particle.MaxOccurs == decimal.MaxValue)
				{
					contentValidator.AddStar();
				}
				else if (particle.MinOccurs == 1m && particle.MaxOccurs == decimal.MaxValue)
				{
					contentValidator.AddPlus();
				}
				else
				{
					contentValidator.AddLeafRange(particle.MinOccurs, particle.MaxOccurs);
				}
			}
		}

		private void CompileParticleElements(XmlSchemaComplexType complexType, XmlSchemaParticle particle)
		{
			if (particle is XmlSchemaElement)
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)particle;
				CompileElement(xmlSchemaElement);
				if (complexType.LocalElements[xmlSchemaElement.QualifiedName] == null)
				{
					complexType.LocalElements.Add(xmlSchemaElement.QualifiedName, xmlSchemaElement);
					return;
				}
				XmlSchemaElement xmlSchemaElement2 = (XmlSchemaElement)complexType.LocalElements[xmlSchemaElement.QualifiedName];
				if (xmlSchemaElement2.ElementSchemaType != xmlSchemaElement.ElementSchemaType)
				{
					SendValidationEvent("Sch_ElementTypeCollision", particle);
				}
			}
			else
			{
				if (!(particle is XmlSchemaGroupBase))
				{
					return;
				}
				XmlSchemaObjectCollection items = ((XmlSchemaGroupBase)particle).Items;
				foreach (XmlSchemaParticle item in items)
				{
					CompileParticleElements(complexType, item);
				}
			}
		}

		private void CompileCompexTypeElements(XmlSchemaComplexType complexType)
		{
			if (complexType.IsProcessing)
			{
				SendValidationEvent("Sch_TypeCircularRef", complexType);
				return;
			}
			complexType.IsProcessing = true;
			if (complexType.ContentTypeParticle != XmlSchemaParticle.Empty)
			{
				CompileParticleElements(complexType, complexType.ContentTypeParticle);
			}
			complexType.IsProcessing = false;
		}

		private XmlSchemaSimpleType GetSimpleType(XmlQualifiedName name)
		{
			XmlSchemaSimpleType xmlSchemaSimpleType = schema.SchemaTypes[name] as XmlSchemaSimpleType;
			if (xmlSchemaSimpleType != null)
			{
				CompileSimpleType(xmlSchemaSimpleType);
			}
			else
			{
				xmlSchemaSimpleType = DatatypeImplementation.GetSimpleTypeFromXsdType(name);
				if (xmlSchemaSimpleType != null)
				{
					if (xmlSchemaSimpleType.TypeCode == XmlTypeCode.NormalizedString)
					{
						xmlSchemaSimpleType = DatatypeImplementation.GetNormalizedStringTypeV1Compat();
					}
					else if (xmlSchemaSimpleType.TypeCode == XmlTypeCode.Token)
					{
						xmlSchemaSimpleType = DatatypeImplementation.GetTokenTypeV1Compat();
					}
				}
			}
			return xmlSchemaSimpleType;
		}

		private XmlSchemaComplexType GetComplexType(XmlQualifiedName name)
		{
			XmlSchemaComplexType xmlSchemaComplexType = schema.SchemaTypes[name] as XmlSchemaComplexType;
			if (xmlSchemaComplexType != null)
			{
				CompileComplexType(xmlSchemaComplexType);
			}
			return xmlSchemaComplexType;
		}

		private XmlSchemaType GetAnySchemaType(XmlQualifiedName name)
		{
			XmlSchemaType xmlSchemaType = (XmlSchemaType)schema.SchemaTypes[name];
			if (xmlSchemaType != null)
			{
				if (xmlSchemaType is XmlSchemaComplexType)
				{
					CompileComplexType((XmlSchemaComplexType)xmlSchemaType);
				}
				else
				{
					CompileSimpleType((XmlSchemaSimpleType)xmlSchemaType);
				}
				return xmlSchemaType;
			}
			return DatatypeImplementation.GetSimpleTypeFromXsdType(name);
		}
	}
	internal sealed class SchemaCollectionPreprocessor : BaseProcessor
	{
		private enum Compositor
		{
			Root,
			Include,
			Import
		}

		private const XmlSchemaDerivationMethod schemaBlockDefaultAllowed = XmlSchemaDerivationMethod.Substitution | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction;

		private const XmlSchemaDerivationMethod schemaFinalDefaultAllowed = XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union;

		private const XmlSchemaDerivationMethod elementBlockAllowed = XmlSchemaDerivationMethod.Substitution | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction;

		private const XmlSchemaDerivationMethod elementFinalAllowed = XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction;

		private const XmlSchemaDerivationMethod simpleTypeFinalAllowed = XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union;

		private const XmlSchemaDerivationMethod complexTypeBlockAllowed = XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction;

		private const XmlSchemaDerivationMethod complexTypeFinalAllowed = XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction;

		private XmlSchema schema;

		private string targetNamespace;

		private bool buildinIncluded;

		private XmlSchemaForm elementFormDefault;

		private XmlSchemaForm attributeFormDefault;

		private XmlSchemaDerivationMethod blockDefault;

		private XmlSchemaDerivationMethod finalDefault;

		private Hashtable schemaLocations;

		private Hashtable referenceNamespaces;

		private string Xmlns;

		private XmlResolver xmlResolver;

		internal XmlResolver XmlResolver
		{
			set
			{
				xmlResolver = value;
			}
		}

		public SchemaCollectionPreprocessor(XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler eventHandler)
			: base(nameTable, schemaNames, eventHandler)
		{
		}

		public bool Execute(XmlSchema schema, string targetNamespace, bool loadExternals, XmlSchemaCollection xsc)
		{
			this.schema = schema;
			Xmlns = base.NameTable.Add("xmlns");
			Cleanup(schema);
			if (loadExternals && xmlResolver != null)
			{
				schemaLocations = new Hashtable();
				if (schema.BaseUri != null)
				{
					schemaLocations.Add(schema.BaseUri, schema.BaseUri);
				}
				LoadExternals(schema, xsc);
			}
			ValidateIdAttribute(schema);
			Preprocess(schema, targetNamespace, Compositor.Root);
			if (!base.HasErrors)
			{
				schema.IsPreprocessed = true;
				foreach (XmlSchemaExternal include in schema.Includes)
				{
					if (include.Schema != null)
					{
						include.Schema.IsPreprocessed = true;
					}
				}
			}
			return !base.HasErrors;
		}

		private void Cleanup(XmlSchema schema)
		{
			if (schema.IsProcessing)
			{
				return;
			}
			schema.IsProcessing = true;
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (include.Schema != null)
				{
					Cleanup(include.Schema);
				}
				if (include is XmlSchemaRedefine)
				{
					XmlSchemaRedefine xmlSchemaRedefine = include as XmlSchemaRedefine;
					xmlSchemaRedefine.AttributeGroups.Clear();
					xmlSchemaRedefine.Groups.Clear();
					xmlSchemaRedefine.SchemaTypes.Clear();
				}
			}
			schema.Attributes.Clear();
			schema.AttributeGroups.Clear();
			schema.SchemaTypes.Clear();
			schema.Elements.Clear();
			schema.Groups.Clear();
			schema.Notations.Clear();
			schema.Ids.Clear();
			schema.IdentityConstraints.Clear();
			schema.IsProcessing = false;
		}

		private void LoadExternals(XmlSchema schema, XmlSchemaCollection xsc)
		{
			if (schema.IsProcessing)
			{
				return;
			}
			schema.IsProcessing = true;
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				Uri uri = null;
				if (include.Schema != null)
				{
					if (include is XmlSchemaImport && ((XmlSchemaImport)include).Namespace == "http://www.w3.org/XML/1998/namespace")
					{
						buildinIncluded = true;
						continue;
					}
					uri = include.BaseUri;
					if (uri != null && schemaLocations[uri] == null)
					{
						schemaLocations.Add(uri, uri);
					}
					LoadExternals(include.Schema, xsc);
					continue;
				}
				if (xsc != null && include is XmlSchemaImport)
				{
					XmlSchemaImport xmlSchemaImport = (XmlSchemaImport)include;
					string ns = ((xmlSchemaImport.Namespace != null) ? xmlSchemaImport.Namespace : string.Empty);
					include.Schema = xsc[ns];
					if (include.Schema != null)
					{
						include.Schema = include.Schema.Clone();
						if (include.Schema.BaseUri != null && schemaLocations[include.Schema.BaseUri] == null)
						{
							schemaLocations.Add(include.Schema.BaseUri, include.Schema.BaseUri);
						}
						Uri uri2 = null;
						foreach (XmlSchemaExternal include2 in include.Schema.Includes)
						{
							if (!(include2 is XmlSchemaImport))
							{
								continue;
							}
							XmlSchemaImport xmlSchemaImport2 = (XmlSchemaImport)include2;
							uri2 = ((xmlSchemaImport2.BaseUri != null) ? xmlSchemaImport2.BaseUri : ((xmlSchemaImport2.Schema != null && xmlSchemaImport2.Schema.BaseUri != null) ? xmlSchemaImport2.Schema.BaseUri : null));
							if (uri2 != null)
							{
								if (schemaLocations[uri2] != null)
								{
									xmlSchemaImport2.Schema = null;
								}
								else
								{
									schemaLocations.Add(uri2, uri2);
								}
							}
						}
						continue;
					}
				}
				if (include is XmlSchemaImport && ((XmlSchemaImport)include).Namespace == "http://www.w3.org/XML/1998/namespace")
				{
					if (!buildinIncluded)
					{
						buildinIncluded = true;
						include.Schema = Preprocessor.GetBuildInSchema();
					}
					continue;
				}
				string schemaLocation = include.SchemaLocation;
				if (schemaLocation == null)
				{
					continue;
				}
				Uri uri3 = ResolveSchemaLocationUri(schema, schemaLocation);
				if (!(uri3 != null) || schemaLocations[uri3] != null)
				{
					continue;
				}
				Stream schemaEntity = GetSchemaEntity(uri3);
				if (schemaEntity != null)
				{
					include.BaseUri = uri3;
					schemaLocations.Add(uri3, uri3);
					XmlTextReader xmlTextReader = new XmlTextReader(uri3.ToString(), schemaEntity, base.NameTable);
					xmlTextReader.XmlResolver = xmlResolver;
					try
					{
						Parser parser = new Parser(SchemaType.XSD, base.NameTable, base.SchemaNames, base.EventHandler);
						parser.Parse(xmlTextReader, null);
						while (xmlTextReader.Read())
						{
						}
						include.Schema = parser.XmlSchema;
						LoadExternals(include.Schema, xsc);
					}
					catch (XmlSchemaException ex)
					{
						SendValidationEventNoThrow(new XmlSchemaException("Sch_CannotLoadSchema", new string[2] { schemaLocation, ex.Message }, ex.SourceUri, ex.LineNumber, ex.LinePosition), XmlSeverityType.Error);
					}
					catch (Exception)
					{
						SendValidationEvent("Sch_InvalidIncludeLocation", include, XmlSeverityType.Warning);
					}
					finally
					{
						xmlTextReader.Close();
					}
				}
				else
				{
					SendValidationEvent("Sch_InvalidIncludeLocation", include, XmlSeverityType.Warning);
				}
			}
			schema.IsProcessing = false;
		}

		private void BuildRefNamespaces(XmlSchema schema)
		{
			referenceNamespaces = new Hashtable();
			referenceNamespaces.Add("http://www.w3.org/2001/XMLSchema", "http://www.w3.org/2001/XMLSchema");
			referenceNamespaces.Add(string.Empty, string.Empty);
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (include is XmlSchemaImport)
				{
					XmlSchemaImport xmlSchemaImport = include as XmlSchemaImport;
					string @namespace = xmlSchemaImport.Namespace;
					if (@namespace != null && referenceNamespaces[@namespace] == null)
					{
						referenceNamespaces.Add(@namespace, @namespace);
					}
				}
			}
			if (schema.TargetNamespace != null && referenceNamespaces[schema.TargetNamespace] == null)
			{
				referenceNamespaces.Add(schema.TargetNamespace, schema.TargetNamespace);
			}
		}

		private void Preprocess(XmlSchema schema, string targetNamespace, Compositor compositor)
		{
			if (schema.IsProcessing)
			{
				return;
			}
			schema.IsProcessing = true;
			string text = schema.TargetNamespace;
			if (text != null)
			{
				text = (schema.TargetNamespace = base.NameTable.Add(text));
				if (text.Length == 0)
				{
					SendValidationEvent("Sch_InvalidTargetNamespaceAttribute", schema);
				}
				else
				{
					try
					{
						XmlConvert.ToUri(text);
					}
					catch
					{
						SendValidationEvent("Sch_InvalidNamespace", schema.TargetNamespace, schema);
					}
				}
			}
			if (schema.Version != null)
			{
				try
				{
					XmlConvert.VerifyTOKEN(schema.Version);
				}
				catch (Exception)
				{
					SendValidationEvent("Sch_AttributeValueDataType", "version", schema);
				}
			}
			switch (compositor)
			{
			case Compositor.Root:
				if (targetNamespace == null && schema.TargetNamespace != null)
				{
					targetNamespace = schema.TargetNamespace;
				}
				else if (schema.TargetNamespace == null && targetNamespace != null && targetNamespace.Length == 0)
				{
					targetNamespace = null;
				}
				if (targetNamespace != schema.TargetNamespace)
				{
					SendValidationEvent("Sch_MismatchTargetNamespaceEx", targetNamespace, schema.TargetNamespace, schema);
				}
				break;
			case Compositor.Import:
				if (targetNamespace != schema.TargetNamespace)
				{
					SendValidationEvent("Sch_MismatchTargetNamespaceImport", targetNamespace, schema.TargetNamespace, schema);
				}
				break;
			case Compositor.Include:
				if (schema.TargetNamespace != null && targetNamespace != schema.TargetNamespace)
				{
					SendValidationEvent("Sch_MismatchTargetNamespaceInclude", targetNamespace, schema.TargetNamespace, schema);
				}
				break;
			}
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				SetParent(include, schema);
				PreprocessAnnotation(include);
				string schemaLocation = include.SchemaLocation;
				if (schemaLocation != null)
				{
					try
					{
						XmlConvert.ToUri(schemaLocation);
					}
					catch
					{
						SendValidationEvent("Sch_InvalidSchemaLocation", schemaLocation, include);
					}
				}
				else if ((include is XmlSchemaRedefine || include is XmlSchemaInclude) && include.Schema == null)
				{
					SendValidationEvent("Sch_MissRequiredAttribute", "schemaLocation", include);
				}
				if (include.Schema != null)
				{
					if (include is XmlSchemaRedefine)
					{
						Preprocess(include.Schema, schema.TargetNamespace, Compositor.Include);
					}
					else if (include is XmlSchemaImport)
					{
						if (((XmlSchemaImport)include).Namespace == null && schema.TargetNamespace == null)
						{
							SendValidationEvent("Sch_ImportTargetNamespaceNull", include);
						}
						else if (((XmlSchemaImport)include).Namespace == schema.TargetNamespace)
						{
							SendValidationEvent("Sch_ImportTargetNamespace", include);
						}
						Preprocess(include.Schema, ((XmlSchemaImport)include).Namespace, Compositor.Import);
					}
					else
					{
						Preprocess(include.Schema, schema.TargetNamespace, Compositor.Include);
					}
				}
				else
				{
					if (!(include is XmlSchemaImport))
					{
						continue;
					}
					string @namespace = ((XmlSchemaImport)include).Namespace;
					if (@namespace == null)
					{
						continue;
					}
					if (@namespace.Length == 0)
					{
						SendValidationEvent("Sch_InvalidNamespaceAttribute", @namespace, include);
						continue;
					}
					try
					{
						XmlConvert.ToUri(@namespace);
					}
					catch (FormatException)
					{
						SendValidationEvent("Sch_InvalidNamespace", @namespace, include);
					}
				}
			}
			BuildRefNamespaces(schema);
			this.targetNamespace = ((targetNamespace == null) ? string.Empty : targetNamespace);
			if (schema.BlockDefault == XmlSchemaDerivationMethod.All)
			{
				blockDefault = XmlSchemaDerivationMethod.All;
			}
			else if (schema.BlockDefault == XmlSchemaDerivationMethod.None)
			{
				blockDefault = XmlSchemaDerivationMethod.Empty;
			}
			else
			{
				if (((uint)schema.BlockDefault & 0xFFFFFFF8u) != 0)
				{
					SendValidationEvent("Sch_InvalidBlockDefaultValue", schema);
				}
				blockDefault = schema.BlockDefault & (XmlSchemaDerivationMethod.Substitution | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction);
			}
			if (schema.FinalDefault == XmlSchemaDerivationMethod.All)
			{
				finalDefault = XmlSchemaDerivationMethod.All;
			}
			else if (schema.FinalDefault == XmlSchemaDerivationMethod.None)
			{
				finalDefault = XmlSchemaDerivationMethod.Empty;
			}
			else
			{
				if (((uint)schema.FinalDefault & 0xFFFFFFE1u) != 0)
				{
					SendValidationEvent("Sch_InvalidFinalDefaultValue", schema);
				}
				finalDefault = schema.FinalDefault & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union);
			}
			elementFormDefault = schema.ElementFormDefault;
			if (elementFormDefault == XmlSchemaForm.None)
			{
				elementFormDefault = XmlSchemaForm.Unqualified;
			}
			attributeFormDefault = schema.AttributeFormDefault;
			if (attributeFormDefault == XmlSchemaForm.None)
			{
				attributeFormDefault = XmlSchemaForm.Unqualified;
			}
			foreach (XmlSchemaExternal include2 in schema.Includes)
			{
				if (include2 is XmlSchemaRedefine)
				{
					XmlSchemaRedefine xmlSchemaRedefine = (XmlSchemaRedefine)include2;
					if (include2.Schema != null)
					{
						PreprocessRedefine(xmlSchemaRedefine);
					}
					else
					{
						foreach (XmlSchemaObject item2 in xmlSchemaRedefine.Items)
						{
							if (!(item2 is XmlSchemaAnnotation))
							{
								SendValidationEvent("Sch_RedefineNoSchema", xmlSchemaRedefine);
								break;
							}
						}
					}
				}
				XmlSchema xmlSchema = include2.Schema;
				if (xmlSchema != null)
				{
					foreach (XmlSchemaElement value in xmlSchema.Elements.Values)
					{
						AddToTable(schema.Elements, value.QualifiedName, value);
					}
					foreach (XmlSchemaAttribute value2 in xmlSchema.Attributes.Values)
					{
						AddToTable(schema.Attributes, value2.QualifiedName, value2);
					}
					foreach (XmlSchemaGroup value3 in xmlSchema.Groups.Values)
					{
						AddToTable(schema.Groups, value3.QualifiedName, value3);
					}
					foreach (XmlSchemaAttributeGroup value4 in xmlSchema.AttributeGroups.Values)
					{
						AddToTable(schema.AttributeGroups, value4.QualifiedName, value4);
					}
					foreach (XmlSchemaType value5 in xmlSchema.SchemaTypes.Values)
					{
						AddToTable(schema.SchemaTypes, value5.QualifiedName, value5);
					}
					foreach (XmlSchemaNotation value6 in xmlSchema.Notations.Values)
					{
						AddToTable(schema.Notations, value6.QualifiedName, value6);
					}
				}
				ValidateIdAttribute(include2);
			}
			ArrayList arrayList = new ArrayList();
			foreach (XmlSchemaObject item3 in schema.Items)
			{
				SetParent(item3, schema);
				if (item3 is XmlSchemaAttribute)
				{
					XmlSchemaAttribute xmlSchemaAttribute2 = (XmlSchemaAttribute)item3;
					PreprocessAttribute(xmlSchemaAttribute2);
					AddToTable(schema.Attributes, xmlSchemaAttribute2.QualifiedName, xmlSchemaAttribute2);
				}
				else if (item3 is XmlSchemaAttributeGroup)
				{
					XmlSchemaAttributeGroup xmlSchemaAttributeGroup2 = (XmlSchemaAttributeGroup)item3;
					PreprocessAttributeGroup(xmlSchemaAttributeGroup2);
					AddToTable(schema.AttributeGroups, xmlSchemaAttributeGroup2.QualifiedName, xmlSchemaAttributeGroup2);
				}
				else if (item3 is XmlSchemaComplexType)
				{
					XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)item3;
					PreprocessComplexType(xmlSchemaComplexType, local: false);
					AddToTable(schema.SchemaTypes, xmlSchemaComplexType.QualifiedName, xmlSchemaComplexType);
				}
				else if (item3 is XmlSchemaSimpleType)
				{
					XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)item3;
					PreprocessSimpleType(xmlSchemaSimpleType, local: false);
					AddToTable(schema.SchemaTypes, xmlSchemaSimpleType.QualifiedName, xmlSchemaSimpleType);
				}
				else if (item3 is XmlSchemaElement)
				{
					XmlSchemaElement xmlSchemaElement2 = (XmlSchemaElement)item3;
					PreprocessElement(xmlSchemaElement2);
					AddToTable(schema.Elements, xmlSchemaElement2.QualifiedName, xmlSchemaElement2);
				}
				else if (item3 is XmlSchemaGroup)
				{
					XmlSchemaGroup xmlSchemaGroup2 = (XmlSchemaGroup)item3;
					PreprocessGroup(xmlSchemaGroup2);
					AddToTable(schema.Groups, xmlSchemaGroup2.QualifiedName, xmlSchemaGroup2);
				}
				else if (item3 is XmlSchemaNotation)
				{
					XmlSchemaNotation xmlSchemaNotation2 = (XmlSchemaNotation)item3;
					PreprocessNotation(xmlSchemaNotation2);
					AddToTable(schema.Notations, xmlSchemaNotation2.QualifiedName, xmlSchemaNotation2);
				}
				else if (!(item3 is XmlSchemaAnnotation))
				{
					SendValidationEvent("Sch_InvalidCollection", item3);
					arrayList.Add(item3);
				}
			}
			foreach (XmlSchemaObject item4 in arrayList)
			{
				schema.Items.Remove(item4);
			}
			schema.IsProcessing = false;
		}

		private void PreprocessRedefine(XmlSchemaRedefine redefine)
		{
			foreach (XmlSchemaObject item in redefine.Items)
			{
				SetParent(item, redefine);
				if (item is XmlSchemaGroup)
				{
					XmlSchemaGroup xmlSchemaGroup = (XmlSchemaGroup)item;
					PreprocessGroup(xmlSchemaGroup);
					if (redefine.Groups[xmlSchemaGroup.QualifiedName] != null)
					{
						SendValidationEvent("Sch_GroupDoubleRedefine", xmlSchemaGroup);
						continue;
					}
					AddToTable(redefine.Groups, xmlSchemaGroup.QualifiedName, xmlSchemaGroup);
					xmlSchemaGroup.Redefined = (XmlSchemaGroup)redefine.Schema.Groups[xmlSchemaGroup.QualifiedName];
					if (xmlSchemaGroup.Redefined != null)
					{
						CheckRefinedGroup(xmlSchemaGroup);
					}
					else
					{
						SendValidationEvent("Sch_GroupRedefineNotFound", xmlSchemaGroup);
					}
				}
				else if (item is XmlSchemaAttributeGroup)
				{
					XmlSchemaAttributeGroup xmlSchemaAttributeGroup = (XmlSchemaAttributeGroup)item;
					PreprocessAttributeGroup(xmlSchemaAttributeGroup);
					if (redefine.AttributeGroups[xmlSchemaAttributeGroup.QualifiedName] != null)
					{
						SendValidationEvent("Sch_AttrGroupDoubleRedefine", xmlSchemaAttributeGroup);
						continue;
					}
					AddToTable(redefine.AttributeGroups, xmlSchemaAttributeGroup.QualifiedName, xmlSchemaAttributeGroup);
					xmlSchemaAttributeGroup.Redefined = (XmlSchemaAttributeGroup)redefine.Schema.AttributeGroups[xmlSchemaAttributeGroup.QualifiedName];
					if (xmlSchemaAttributeGroup.Redefined != null)
					{
						CheckRefinedAttributeGroup(xmlSchemaAttributeGroup);
					}
					else
					{
						SendValidationEvent("Sch_AttrGroupRedefineNotFound", xmlSchemaAttributeGroup);
					}
				}
				else if (item is XmlSchemaComplexType)
				{
					XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)item;
					PreprocessComplexType(xmlSchemaComplexType, local: false);
					if (redefine.SchemaTypes[xmlSchemaComplexType.QualifiedName] != null)
					{
						SendValidationEvent("Sch_ComplexTypeDoubleRedefine", xmlSchemaComplexType);
						continue;
					}
					AddToTable(redefine.SchemaTypes, xmlSchemaComplexType.QualifiedName, xmlSchemaComplexType);
					XmlSchemaType xmlSchemaType = (XmlSchemaType)redefine.Schema.SchemaTypes[xmlSchemaComplexType.QualifiedName];
					if (xmlSchemaType != null)
					{
						if (xmlSchemaType is XmlSchemaComplexType)
						{
							xmlSchemaComplexType.Redefined = xmlSchemaType;
							CheckRefinedComplexType(xmlSchemaComplexType);
						}
						else
						{
							SendValidationEvent("Sch_SimpleToComplexTypeRedefine", xmlSchemaComplexType);
						}
					}
					else
					{
						SendValidationEvent("Sch_ComplexTypeRedefineNotFound", xmlSchemaComplexType);
					}
				}
				else
				{
					if (!(item is XmlSchemaSimpleType))
					{
						continue;
					}
					XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)item;
					PreprocessSimpleType(xmlSchemaSimpleType, local: false);
					if (redefine.SchemaTypes[xmlSchemaSimpleType.QualifiedName] != null)
					{
						SendValidationEvent("Sch_SimpleTypeDoubleRedefine", xmlSchemaSimpleType);
						continue;
					}
					AddToTable(redefine.SchemaTypes, xmlSchemaSimpleType.QualifiedName, xmlSchemaSimpleType);
					XmlSchemaType xmlSchemaType2 = (XmlSchemaType)redefine.Schema.SchemaTypes[xmlSchemaSimpleType.QualifiedName];
					if (xmlSchemaType2 != null)
					{
						if (xmlSchemaType2 is XmlSchemaSimpleType)
						{
							xmlSchemaSimpleType.Redefined = xmlSchemaType2;
							CheckRefinedSimpleType(xmlSchemaSimpleType);
						}
						else
						{
							SendValidationEvent("Sch_ComplexToSimpleTypeRedefine", xmlSchemaSimpleType);
						}
					}
					else
					{
						SendValidationEvent("Sch_SimpleTypeRedefineNotFound", xmlSchemaSimpleType);
					}
				}
			}
			foreach (DictionaryEntry group in redefine.Groups)
			{
				redefine.Schema.Groups.Insert((XmlQualifiedName)group.Key, (XmlSchemaObject)group.Value);
			}
			foreach (DictionaryEntry attributeGroup in redefine.AttributeGroups)
			{
				redefine.Schema.AttributeGroups.Insert((XmlQualifiedName)attributeGroup.Key, (XmlSchemaObject)attributeGroup.Value);
			}
			foreach (DictionaryEntry schemaType in redefine.SchemaTypes)
			{
				redefine.Schema.SchemaTypes.Insert((XmlQualifiedName)schemaType.Key, (XmlSchemaObject)schemaType.Value);
			}
		}

		private int CountGroupSelfReference(XmlSchemaObjectCollection items, XmlQualifiedName name)
		{
			int num = 0;
			foreach (XmlSchemaParticle item in items)
			{
				if (item is XmlSchemaGroupRef)
				{
					XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef)item;
					if (xmlSchemaGroupRef.RefName == name)
					{
						if (xmlSchemaGroupRef.MinOccurs != 1m || xmlSchemaGroupRef.MaxOccurs != 1m)
						{
							SendValidationEvent("Sch_MinMaxGroupRedefine", xmlSchemaGroupRef);
						}
						num++;
					}
				}
				else if (item is XmlSchemaGroupBase)
				{
					num += CountGroupSelfReference(((XmlSchemaGroupBase)item).Items, name);
				}
				if (num > 1)
				{
					return num;
				}
			}
			return num;
		}

		private void CheckRefinedGroup(XmlSchemaGroup group)
		{
			int num = 0;
			if (group.Particle != null)
			{
				num = CountGroupSelfReference(group.Particle.Items, group.QualifiedName);
			}
			if (num > 1)
			{
				SendValidationEvent("Sch_MultipleGroupSelfRef", group);
			}
		}

		private void CheckRefinedAttributeGroup(XmlSchemaAttributeGroup attributeGroup)
		{
			int num = 0;
			foreach (XmlSchemaObject attribute in attributeGroup.Attributes)
			{
				if (attribute is XmlSchemaAttributeGroupRef && ((XmlSchemaAttributeGroupRef)attribute).RefName == attributeGroup.QualifiedName)
				{
					num++;
				}
			}
			if (num > 1)
			{
				SendValidationEvent("Sch_MultipleAttrGroupSelfRef", attributeGroup);
			}
		}

		private void CheckRefinedSimpleType(XmlSchemaSimpleType stype)
		{
			if (stype.Content != null && stype.Content is XmlSchemaSimpleTypeRestriction)
			{
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)stype.Content;
				if (xmlSchemaSimpleTypeRestriction.BaseTypeName == stype.QualifiedName)
				{
					return;
				}
			}
			SendValidationEvent("Sch_InvalidTypeRedefine", stype);
		}

		private void CheckRefinedComplexType(XmlSchemaComplexType ctype)
		{
			if (ctype.ContentModel != null)
			{
				XmlQualifiedName xmlQualifiedName;
				if (ctype.ContentModel is XmlSchemaComplexContent)
				{
					XmlSchemaComplexContent xmlSchemaComplexContent = (XmlSchemaComplexContent)ctype.ContentModel;
					xmlQualifiedName = ((!(xmlSchemaComplexContent.Content is XmlSchemaComplexContentRestriction)) ? ((XmlSchemaComplexContentExtension)xmlSchemaComplexContent.Content).BaseTypeName : ((XmlSchemaComplexContentRestriction)xmlSchemaComplexContent.Content).BaseTypeName);
				}
				else
				{
					XmlSchemaSimpleContent xmlSchemaSimpleContent = (XmlSchemaSimpleContent)ctype.ContentModel;
					xmlQualifiedName = ((!(xmlSchemaSimpleContent.Content is XmlSchemaSimpleContentRestriction)) ? ((XmlSchemaSimpleContentExtension)xmlSchemaSimpleContent.Content).BaseTypeName : ((XmlSchemaSimpleContentRestriction)xmlSchemaSimpleContent.Content).BaseTypeName);
				}
				if (xmlQualifiedName == ctype.QualifiedName)
				{
					return;
				}
			}
			SendValidationEvent("Sch_InvalidTypeRedefine", ctype);
		}

		private void PreprocessAttribute(XmlSchemaAttribute attribute)
		{
			if (attribute.Name != null)
			{
				ValidateNameAttribute(attribute);
				attribute.SetQualifiedName(new XmlQualifiedName(attribute.Name, targetNamespace));
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", attribute);
			}
			if (attribute.Use != 0)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "use", attribute);
			}
			if (attribute.Form != 0)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "form", attribute);
			}
			PreprocessAttributeContent(attribute);
			ValidateIdAttribute(attribute);
		}

		private void PreprocessLocalAttribute(XmlSchemaAttribute attribute)
		{
			if (attribute.Name != null)
			{
				ValidateNameAttribute(attribute);
				PreprocessAttributeContent(attribute);
				attribute.SetQualifiedName(new XmlQualifiedName(attribute.Name, (attribute.Form == XmlSchemaForm.Qualified || (attribute.Form == XmlSchemaForm.None && attributeFormDefault == XmlSchemaForm.Qualified)) ? targetNamespace : null));
			}
			else
			{
				PreprocessAnnotation(attribute);
				if (attribute.RefName.IsEmpty)
				{
					SendValidationEvent("Sch_AttributeNameRef", "???", attribute);
				}
				else
				{
					ValidateQNameAttribute(attribute, "ref", attribute.RefName);
				}
				if (!attribute.SchemaTypeName.IsEmpty || attribute.SchemaType != null || attribute.Form != 0)
				{
					SendValidationEvent("Sch_InvalidAttributeRef", attribute);
				}
				attribute.SetQualifiedName(attribute.RefName);
			}
			ValidateIdAttribute(attribute);
		}

		private void PreprocessAttributeContent(XmlSchemaAttribute attribute)
		{
			PreprocessAnnotation(attribute);
			if (schema.TargetNamespace == "http://www.w3.org/2001/XMLSchema-instance")
			{
				SendValidationEvent("Sch_TargetNamespaceXsi", attribute);
			}
			if (!attribute.RefName.IsEmpty)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "ref", attribute);
			}
			if (attribute.DefaultValue != null && attribute.FixedValue != null)
			{
				SendValidationEvent("Sch_DefaultFixedAttributes", attribute);
			}
			if (attribute.DefaultValue != null && attribute.Use != XmlSchemaUse.Optional && attribute.Use != 0)
			{
				SendValidationEvent("Sch_OptionalDefaultAttribute", attribute);
			}
			if (attribute.Name == Xmlns)
			{
				SendValidationEvent("Sch_XmlNsAttribute", attribute);
			}
			if (attribute.SchemaType != null)
			{
				SetParent(attribute.SchemaType, attribute);
				if (!attribute.SchemaTypeName.IsEmpty)
				{
					SendValidationEvent("Sch_TypeMutualExclusive", attribute);
				}
				PreprocessSimpleType(attribute.SchemaType, local: true);
			}
			if (!attribute.SchemaTypeName.IsEmpty)
			{
				ValidateQNameAttribute(attribute, "type", attribute.SchemaTypeName);
			}
		}

		private void PreprocessAttributeGroup(XmlSchemaAttributeGroup attributeGroup)
		{
			if (attributeGroup.Name != null)
			{
				ValidateNameAttribute(attributeGroup);
				attributeGroup.SetQualifiedName(new XmlQualifiedName(attributeGroup.Name, targetNamespace));
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", attributeGroup);
			}
			PreprocessAttributes(attributeGroup.Attributes, attributeGroup.AnyAttribute, attributeGroup);
			PreprocessAnnotation(attributeGroup);
			ValidateIdAttribute(attributeGroup);
		}

		private void PreprocessElement(XmlSchemaElement element)
		{
			if (element.Name != null)
			{
				ValidateNameAttribute(element);
				element.SetQualifiedName(new XmlQualifiedName(element.Name, targetNamespace));
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", element);
			}
			PreprocessElementContent(element);
			if (element.Final == XmlSchemaDerivationMethod.All)
			{
				element.SetFinalResolved(XmlSchemaDerivationMethod.All);
			}
			else if (element.Final == XmlSchemaDerivationMethod.None)
			{
				if (finalDefault == XmlSchemaDerivationMethod.All)
				{
					element.SetFinalResolved(XmlSchemaDerivationMethod.All);
				}
				else
				{
					element.SetFinalResolved(finalDefault & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
				}
			}
			else
			{
				if (((uint)element.Final & 0xFFFFFFF9u) != 0)
				{
					SendValidationEvent("Sch_InvalidElementFinalValue", element);
				}
				element.SetFinalResolved(element.Final & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
			}
			if (element.Form != 0)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "form", element);
			}
			if (element.MinOccursString != null)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "minOccurs", element);
			}
			if (element.MaxOccursString != null)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "maxOccurs", element);
			}
			if (!element.SubstitutionGroup.IsEmpty)
			{
				ValidateQNameAttribute(element, "type", element.SubstitutionGroup);
			}
			ValidateIdAttribute(element);
		}

		private void PreprocessLocalElement(XmlSchemaElement element)
		{
			if (element.Name != null)
			{
				ValidateNameAttribute(element);
				PreprocessElementContent(element);
				element.SetQualifiedName(new XmlQualifiedName(element.Name, (element.Form == XmlSchemaForm.Qualified || (element.Form == XmlSchemaForm.None && elementFormDefault == XmlSchemaForm.Qualified)) ? targetNamespace : null));
			}
			else
			{
				PreprocessAnnotation(element);
				if (element.RefName.IsEmpty)
				{
					SendValidationEvent("Sch_ElementNameRef", element);
				}
				else
				{
					ValidateQNameAttribute(element, "ref", element.RefName);
				}
				if (!element.SchemaTypeName.IsEmpty || element.IsAbstract || element.Block != XmlSchemaDerivationMethod.None || element.SchemaType != null || element.HasConstraints || element.DefaultValue != null || element.Form != 0 || element.FixedValue != null || element.HasNillableAttribute)
				{
					SendValidationEvent("Sch_InvalidElementRef", element);
				}
				if (element.DefaultValue != null && element.FixedValue != null)
				{
					SendValidationEvent("Sch_DefaultFixedAttributes", element);
				}
				element.SetQualifiedName(element.RefName);
			}
			if (element.MinOccurs > element.MaxOccurs)
			{
				element.MinOccurs = 0m;
				SendValidationEvent("Sch_MinGtMax", element);
			}
			if (element.IsAbstract)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "abstract", element);
			}
			if (element.Final != XmlSchemaDerivationMethod.None)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "final", element);
			}
			if (!element.SubstitutionGroup.IsEmpty)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "substitutionGroup", element);
			}
			ValidateIdAttribute(element);
		}

		private void PreprocessElementContent(XmlSchemaElement element)
		{
			PreprocessAnnotation(element);
			if (!element.RefName.IsEmpty)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "ref", element);
			}
			if (element.Block == XmlSchemaDerivationMethod.All)
			{
				element.SetBlockResolved(XmlSchemaDerivationMethod.All);
			}
			else if (element.Block == XmlSchemaDerivationMethod.None)
			{
				if (blockDefault == XmlSchemaDerivationMethod.All)
				{
					element.SetBlockResolved(XmlSchemaDerivationMethod.All);
				}
				else
				{
					element.SetBlockResolved(blockDefault & (XmlSchemaDerivationMethod.Substitution | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
				}
			}
			else
			{
				if (((uint)element.Block & 0xFFFFFFF8u) != 0)
				{
					SendValidationEvent("Sch_InvalidElementBlockValue", element);
				}
				element.SetBlockResolved(element.Block & (XmlSchemaDerivationMethod.Substitution | XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
			}
			if (element.SchemaType != null)
			{
				SetParent(element.SchemaType, element);
				if (!element.SchemaTypeName.IsEmpty)
				{
					SendValidationEvent("Sch_TypeMutualExclusive", element);
				}
				if (element.SchemaType is XmlSchemaComplexType)
				{
					PreprocessComplexType((XmlSchemaComplexType)element.SchemaType, local: true);
				}
				else
				{
					PreprocessSimpleType((XmlSchemaSimpleType)element.SchemaType, local: true);
				}
			}
			if (!element.SchemaTypeName.IsEmpty)
			{
				ValidateQNameAttribute(element, "type", element.SchemaTypeName);
			}
			if (element.DefaultValue != null && element.FixedValue != null)
			{
				SendValidationEvent("Sch_DefaultFixedAttributes", element);
			}
			foreach (XmlSchemaIdentityConstraint constraint in element.Constraints)
			{
				SetParent(constraint, element);
				PreprocessIdentityConstraint(constraint);
			}
		}

		private void PreprocessIdentityConstraint(XmlSchemaIdentityConstraint constraint)
		{
			bool flag = true;
			PreprocessAnnotation(constraint);
			if (constraint.Name != null)
			{
				ValidateNameAttribute(constraint);
				constraint.SetQualifiedName(new XmlQualifiedName(constraint.Name, targetNamespace));
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", constraint);
				flag = false;
			}
			if (schema.IdentityConstraints[constraint.QualifiedName] != null)
			{
				SendValidationEvent("Sch_DupIdentityConstraint", constraint.QualifiedName.ToString(), constraint);
				flag = false;
			}
			else
			{
				schema.IdentityConstraints.Add(constraint.QualifiedName, constraint);
			}
			if (constraint.Selector == null)
			{
				SendValidationEvent("Sch_IdConstraintNoSelector", constraint);
				flag = false;
			}
			if (constraint.Fields.Count == 0)
			{
				SendValidationEvent("Sch_IdConstraintNoFields", constraint);
				flag = false;
			}
			if (constraint is XmlSchemaKeyref)
			{
				XmlSchemaKeyref xmlSchemaKeyref = (XmlSchemaKeyref)constraint;
				if (xmlSchemaKeyref.Refer.IsEmpty)
				{
					SendValidationEvent("Sch_IdConstraintNoRefer", constraint);
					flag = false;
				}
				else
				{
					ValidateQNameAttribute(xmlSchemaKeyref, "refer", xmlSchemaKeyref.Refer);
				}
			}
			if (!flag)
			{
				return;
			}
			ValidateIdAttribute(constraint);
			ValidateIdAttribute(constraint.Selector);
			SetParent(constraint.Selector, constraint);
			foreach (XmlSchemaXPath field in constraint.Fields)
			{
				SetParent(field, constraint);
				ValidateIdAttribute(field);
			}
		}

		private void PreprocessSimpleType(XmlSchemaSimpleType simpleType, bool local)
		{
			if (local)
			{
				if (simpleType.Name != null)
				{
					SendValidationEvent("Sch_ForbiddenAttribute", "name", simpleType);
				}
			}
			else
			{
				if (simpleType.Name != null)
				{
					ValidateNameAttribute(simpleType);
					simpleType.SetQualifiedName(new XmlQualifiedName(simpleType.Name, targetNamespace));
				}
				else
				{
					SendValidationEvent("Sch_MissRequiredAttribute", "name", simpleType);
				}
				if (simpleType.Final == XmlSchemaDerivationMethod.All)
				{
					simpleType.SetFinalResolved(XmlSchemaDerivationMethod.All);
				}
				else if (simpleType.Final == XmlSchemaDerivationMethod.None)
				{
					if (finalDefault == XmlSchemaDerivationMethod.All)
					{
						simpleType.SetFinalResolved(XmlSchemaDerivationMethod.All);
					}
					else
					{
						simpleType.SetFinalResolved(finalDefault & (XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union));
					}
				}
				else
				{
					if (((uint)simpleType.Final & 0xFFFFFFE3u) != 0)
					{
						SendValidationEvent("Sch_InvalidSimpleTypeFinalValue", simpleType);
					}
					simpleType.SetFinalResolved(simpleType.Final & (XmlSchemaDerivationMethod.Restriction | XmlSchemaDerivationMethod.List | XmlSchemaDerivationMethod.Union));
				}
			}
			if (simpleType.Content == null)
			{
				SendValidationEvent("Sch_NoSimpleTypeContent", simpleType);
			}
			else if (simpleType.Content is XmlSchemaSimpleTypeRestriction)
			{
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)simpleType.Content;
				SetParent(xmlSchemaSimpleTypeRestriction, simpleType);
				foreach (XmlSchemaObject facet in xmlSchemaSimpleTypeRestriction.Facets)
				{
					SetParent(facet, xmlSchemaSimpleTypeRestriction);
				}
				if (xmlSchemaSimpleTypeRestriction.BaseType != null)
				{
					if (!xmlSchemaSimpleTypeRestriction.BaseTypeName.IsEmpty)
					{
						SendValidationEvent("Sch_SimpleTypeRestRefBase", xmlSchemaSimpleTypeRestriction);
					}
					PreprocessSimpleType(xmlSchemaSimpleTypeRestriction.BaseType, local: true);
				}
				else if (xmlSchemaSimpleTypeRestriction.BaseTypeName.IsEmpty)
				{
					SendValidationEvent("Sch_SimpleTypeRestRefBaseNone", xmlSchemaSimpleTypeRestriction);
				}
				else
				{
					ValidateQNameAttribute(xmlSchemaSimpleTypeRestriction, "base", xmlSchemaSimpleTypeRestriction.BaseTypeName);
				}
				PreprocessAnnotation(xmlSchemaSimpleTypeRestriction);
				ValidateIdAttribute(xmlSchemaSimpleTypeRestriction);
			}
			else if (simpleType.Content is XmlSchemaSimpleTypeList)
			{
				XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = (XmlSchemaSimpleTypeList)simpleType.Content;
				SetParent(xmlSchemaSimpleTypeList, simpleType);
				if (xmlSchemaSimpleTypeList.ItemType != null)
				{
					if (!xmlSchemaSimpleTypeList.ItemTypeName.IsEmpty)
					{
						SendValidationEvent("Sch_SimpleTypeListRefBase", xmlSchemaSimpleTypeList);
					}
					SetParent(xmlSchemaSimpleTypeList.ItemType, xmlSchemaSimpleTypeList);
					PreprocessSimpleType(xmlSchemaSimpleTypeList.ItemType, local: true);
				}
				else if (xmlSchemaSimpleTypeList.ItemTypeName.IsEmpty)
				{
					SendValidationEvent("Sch_SimpleTypeListRefBaseNone", xmlSchemaSimpleTypeList);
				}
				else
				{
					ValidateQNameAttribute(xmlSchemaSimpleTypeList, "itemType", xmlSchemaSimpleTypeList.ItemTypeName);
				}
				PreprocessAnnotation(xmlSchemaSimpleTypeList);
				ValidateIdAttribute(xmlSchemaSimpleTypeList);
			}
			else
			{
				XmlSchemaSimpleTypeUnion xmlSchemaSimpleTypeUnion = (XmlSchemaSimpleTypeUnion)simpleType.Content;
				SetParent(xmlSchemaSimpleTypeUnion, simpleType);
				int num = xmlSchemaSimpleTypeUnion.BaseTypes.Count;
				if (xmlSchemaSimpleTypeUnion.MemberTypes != null)
				{
					num += xmlSchemaSimpleTypeUnion.MemberTypes.Length;
					XmlQualifiedName[] memberTypes = xmlSchemaSimpleTypeUnion.MemberTypes;
					foreach (XmlQualifiedName value in memberTypes)
					{
						ValidateQNameAttribute(xmlSchemaSimpleTypeUnion, "memberTypes", value);
					}
				}
				if (num == 0)
				{
					SendValidationEvent("Sch_SimpleTypeUnionNoBase", xmlSchemaSimpleTypeUnion);
				}
				foreach (XmlSchemaSimpleType baseType in xmlSchemaSimpleTypeUnion.BaseTypes)
				{
					SetParent(baseType, xmlSchemaSimpleTypeUnion);
					PreprocessSimpleType(baseType, local: true);
				}
				PreprocessAnnotation(xmlSchemaSimpleTypeUnion);
				ValidateIdAttribute(xmlSchemaSimpleTypeUnion);
			}
			ValidateIdAttribute(simpleType);
		}

		private void PreprocessComplexType(XmlSchemaComplexType complexType, bool local)
		{
			if (local)
			{
				if (complexType.Name != null)
				{
					SendValidationEvent("Sch_ForbiddenAttribute", "name", complexType);
				}
			}
			else
			{
				if (complexType.Name != null)
				{
					ValidateNameAttribute(complexType);
					complexType.SetQualifiedName(new XmlQualifiedName(complexType.Name, targetNamespace));
				}
				else
				{
					SendValidationEvent("Sch_MissRequiredAttribute", "name", complexType);
				}
				if (complexType.Block == XmlSchemaDerivationMethod.All)
				{
					complexType.SetBlockResolved(XmlSchemaDerivationMethod.All);
				}
				else if (complexType.Block == XmlSchemaDerivationMethod.None)
				{
					complexType.SetBlockResolved(blockDefault & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
				}
				else
				{
					if (((uint)complexType.Block & 0xFFFFFFF9u) != 0)
					{
						SendValidationEvent("Sch_InvalidComplexTypeBlockValue", complexType);
					}
					complexType.SetBlockResolved(complexType.Block & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
				}
				if (complexType.Final == XmlSchemaDerivationMethod.All)
				{
					complexType.SetFinalResolved(XmlSchemaDerivationMethod.All);
				}
				else if (complexType.Final == XmlSchemaDerivationMethod.None)
				{
					if (finalDefault == XmlSchemaDerivationMethod.All)
					{
						complexType.SetFinalResolved(XmlSchemaDerivationMethod.All);
					}
					else
					{
						complexType.SetFinalResolved(finalDefault & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
					}
				}
				else
				{
					if (((uint)complexType.Final & 0xFFFFFFF9u) != 0)
					{
						SendValidationEvent("Sch_InvalidComplexTypeFinalValue", complexType);
					}
					complexType.SetFinalResolved(complexType.Final & (XmlSchemaDerivationMethod.Extension | XmlSchemaDerivationMethod.Restriction));
				}
			}
			if (complexType.ContentModel != null)
			{
				SetParent(complexType.ContentModel, complexType);
				PreprocessAnnotation(complexType.ContentModel);
				if (complexType.Particle == null)
				{
					_ = complexType.Attributes;
				}
				if (complexType.ContentModel is XmlSchemaSimpleContent)
				{
					XmlSchemaSimpleContent xmlSchemaSimpleContent = (XmlSchemaSimpleContent)complexType.ContentModel;
					if (xmlSchemaSimpleContent.Content == null)
					{
						if (complexType.QualifiedName == XmlQualifiedName.Empty)
						{
							SendValidationEvent("Sch_NoRestOrExt", complexType);
						}
						else
						{
							SendValidationEvent("Sch_NoRestOrExtQName", complexType.QualifiedName.Name, complexType.QualifiedName.Namespace, complexType);
						}
					}
					else
					{
						SetParent(xmlSchemaSimpleContent.Content, xmlSchemaSimpleContent);
						PreprocessAnnotation(xmlSchemaSimpleContent.Content);
						if (xmlSchemaSimpleContent.Content is XmlSchemaSimpleContentExtension)
						{
							XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = (XmlSchemaSimpleContentExtension)xmlSchemaSimpleContent.Content;
							if (xmlSchemaSimpleContentExtension.BaseTypeName.IsEmpty)
							{
								SendValidationEvent("Sch_MissAttribute", "base", xmlSchemaSimpleContentExtension);
							}
							else
							{
								ValidateQNameAttribute(xmlSchemaSimpleContentExtension, "base", xmlSchemaSimpleContentExtension.BaseTypeName);
							}
							PreprocessAttributes(xmlSchemaSimpleContentExtension.Attributes, xmlSchemaSimpleContentExtension.AnyAttribute, xmlSchemaSimpleContentExtension);
							ValidateIdAttribute(xmlSchemaSimpleContentExtension);
						}
						else
						{
							XmlSchemaSimpleContentRestriction xmlSchemaSimpleContentRestriction = (XmlSchemaSimpleContentRestriction)xmlSchemaSimpleContent.Content;
							if (xmlSchemaSimpleContentRestriction.BaseTypeName.IsEmpty)
							{
								SendValidationEvent("Sch_MissAttribute", "base", xmlSchemaSimpleContentRestriction);
							}
							else
							{
								ValidateQNameAttribute(xmlSchemaSimpleContentRestriction, "base", xmlSchemaSimpleContentRestriction.BaseTypeName);
							}
							if (xmlSchemaSimpleContentRestriction.BaseType != null)
							{
								SetParent(xmlSchemaSimpleContentRestriction.BaseType, xmlSchemaSimpleContentRestriction);
								PreprocessSimpleType(xmlSchemaSimpleContentRestriction.BaseType, local: true);
							}
							PreprocessAttributes(xmlSchemaSimpleContentRestriction.Attributes, xmlSchemaSimpleContentRestriction.AnyAttribute, xmlSchemaSimpleContentRestriction);
							ValidateIdAttribute(xmlSchemaSimpleContentRestriction);
						}
					}
					ValidateIdAttribute(xmlSchemaSimpleContent);
				}
				else
				{
					XmlSchemaComplexContent xmlSchemaComplexContent = (XmlSchemaComplexContent)complexType.ContentModel;
					if (xmlSchemaComplexContent.Content == null)
					{
						if (complexType.QualifiedName == XmlQualifiedName.Empty)
						{
							SendValidationEvent("Sch_NoRestOrExt", complexType);
						}
						else
						{
							SendValidationEvent("Sch_NoRestOrExtQName", complexType.QualifiedName.Name, complexType.QualifiedName.Namespace, complexType);
						}
					}
					else
					{
						if (!xmlSchemaComplexContent.HasMixedAttribute && complexType.IsMixed)
						{
							xmlSchemaComplexContent.IsMixed = true;
						}
						SetParent(xmlSchemaComplexContent.Content, xmlSchemaComplexContent);
						PreprocessAnnotation(xmlSchemaComplexContent.Content);
						if (xmlSchemaComplexContent.Content is XmlSchemaComplexContentExtension)
						{
							XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension = (XmlSchemaComplexContentExtension)xmlSchemaComplexContent.Content;
							if (xmlSchemaComplexContentExtension.BaseTypeName.IsEmpty)
							{
								SendValidationEvent("Sch_MissAttribute", "base", xmlSchemaComplexContentExtension);
							}
							else
							{
								ValidateQNameAttribute(xmlSchemaComplexContentExtension, "base", xmlSchemaComplexContentExtension.BaseTypeName);
							}
							if (xmlSchemaComplexContentExtension.Particle != null)
							{
								SetParent(xmlSchemaComplexContentExtension.Particle, xmlSchemaComplexContentExtension);
								PreprocessParticle(xmlSchemaComplexContentExtension.Particle);
							}
							PreprocessAttributes(xmlSchemaComplexContentExtension.Attributes, xmlSchemaComplexContentExtension.AnyAttribute, xmlSchemaComplexContentExtension);
							ValidateIdAttribute(xmlSchemaComplexContentExtension);
						}
						else
						{
							XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction = (XmlSchemaComplexContentRestriction)xmlSchemaComplexContent.Content;
							if (xmlSchemaComplexContentRestriction.BaseTypeName.IsEmpty)
							{
								SendValidationEvent("Sch_MissAttribute", "base", xmlSchemaComplexContentRestriction);
							}
							else
							{
								ValidateQNameAttribute(xmlSchemaComplexContentRestriction, "base", xmlSchemaComplexContentRestriction.BaseTypeName);
							}
							if (xmlSchemaComplexContentRestriction.Particle != null)
							{
								SetParent(xmlSchemaComplexContentRestriction.Particle, xmlSchemaComplexContentRestriction);
								PreprocessParticle(xmlSchemaComplexContentRestriction.Particle);
							}
							PreprocessAttributes(xmlSchemaComplexContentRestriction.Attributes, xmlSchemaComplexContentRestriction.AnyAttribute, xmlSchemaComplexContentRestriction);
							ValidateIdAttribute(xmlSchemaComplexContentRestriction);
						}
						ValidateIdAttribute(xmlSchemaComplexContent);
					}
				}
			}
			else
			{
				if (complexType.Particle != null)
				{
					SetParent(complexType.Particle, complexType);
					PreprocessParticle(complexType.Particle);
				}
				PreprocessAttributes(complexType.Attributes, complexType.AnyAttribute, complexType);
			}
			ValidateIdAttribute(complexType);
		}

		private void PreprocessGroup(XmlSchemaGroup group)
		{
			if (group.Name != null)
			{
				ValidateNameAttribute(group);
				group.SetQualifiedName(new XmlQualifiedName(group.Name, targetNamespace));
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", group);
			}
			if (group.Particle == null)
			{
				SendValidationEvent("Sch_NoGroupParticle", group);
				return;
			}
			if (group.Particle.MinOccursString != null)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "minOccurs", group.Particle);
			}
			if (group.Particle.MaxOccursString != null)
			{
				SendValidationEvent("Sch_ForbiddenAttribute", "maxOccurs", group.Particle);
			}
			PreprocessParticle(group.Particle);
			PreprocessAnnotation(group);
			ValidateIdAttribute(group);
		}

		private void PreprocessNotation(XmlSchemaNotation notation)
		{
			if (notation.Name != null)
			{
				ValidateNameAttribute(notation);
				notation.QualifiedName = new XmlQualifiedName(notation.Name, targetNamespace);
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "name", notation);
			}
			if (notation.Public != null)
			{
				try
				{
					XmlConvert.ToUri(notation.Public);
				}
				catch
				{
					SendValidationEvent("Sch_InvalidPublicAttribute", notation.Public, notation);
				}
			}
			else
			{
				SendValidationEvent("Sch_MissRequiredAttribute", "public", notation);
			}
			if (notation.System != null)
			{
				try
				{
					XmlConvert.ToUri(notation.System);
				}
				catch
				{
					SendValidationEvent("Sch_InvalidSystemAttribute", notation.System, notation);
				}
			}
			PreprocessAnnotation(notation);
			ValidateIdAttribute(notation);
		}

		private void PreprocessParticle(XmlSchemaParticle particle)
		{
			if (particle is XmlSchemaAll)
			{
				if (particle.MinOccurs != 0m && particle.MinOccurs != 1m)
				{
					particle.MinOccurs = 1m;
					SendValidationEvent("Sch_InvalidAllMin", particle);
				}
				if (particle.MaxOccurs != 1m)
				{
					particle.MaxOccurs = 1m;
					SendValidationEvent("Sch_InvalidAllMax", particle);
				}
				foreach (XmlSchemaElement item in ((XmlSchemaAll)particle).Items)
				{
					if (item.MaxOccurs != 0m && item.MaxOccurs != 1m)
					{
						item.MaxOccurs = 1m;
						SendValidationEvent("Sch_InvalidAllElementMax", item);
					}
					SetParent(item, particle);
					PreprocessLocalElement(item);
				}
			}
			else
			{
				if (particle.MinOccurs > particle.MaxOccurs)
				{
					particle.MinOccurs = particle.MaxOccurs;
					SendValidationEvent("Sch_MinGtMax", particle);
				}
				if (particle is XmlSchemaChoice)
				{
					foreach (XmlSchemaObject item2 in ((XmlSchemaChoice)particle).Items)
					{
						SetParent(item2, particle);
						if (item2 is XmlSchemaElement)
						{
							PreprocessLocalElement((XmlSchemaElement)item2);
						}
						else
						{
							PreprocessParticle((XmlSchemaParticle)item2);
						}
					}
				}
				else if (particle is XmlSchemaSequence)
				{
					foreach (XmlSchemaObject item3 in ((XmlSchemaSequence)particle).Items)
					{
						SetParent(item3, particle);
						if (item3 is XmlSchemaElement)
						{
							PreprocessLocalElement((XmlSchemaElement)item3);
						}
						else
						{
							PreprocessParticle((XmlSchemaParticle)item3);
						}
					}
				}
				else if (particle is XmlSchemaGroupRef)
				{
					XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef)particle;
					if (xmlSchemaGroupRef.RefName.IsEmpty)
					{
						SendValidationEvent("Sch_MissAttribute", "ref", xmlSchemaGroupRef);
					}
					else
					{
						ValidateQNameAttribute(xmlSchemaGroupRef, "ref", xmlSchemaGroupRef.RefName);
					}
				}
				else if (particle is XmlSchemaAny)
				{
					try
					{
						((XmlSchemaAny)particle).BuildNamespaceListV1Compat(targetNamespace);
					}
					catch
					{
						SendValidationEvent("Sch_InvalidAny", particle);
					}
				}
			}
			PreprocessAnnotation(particle);
			ValidateIdAttribute(particle);
		}

		private void PreprocessAttributes(XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, XmlSchemaObject parent)
		{
			foreach (XmlSchemaAnnotated attribute in attributes)
			{
				SetParent(attribute, parent);
				if (attribute is XmlSchemaAttribute)
				{
					PreprocessLocalAttribute((XmlSchemaAttribute)attribute);
					continue;
				}
				XmlSchemaAttributeGroupRef xmlSchemaAttributeGroupRef = (XmlSchemaAttributeGroupRef)attribute;
				if (xmlSchemaAttributeGroupRef.RefName.IsEmpty)
				{
					SendValidationEvent("Sch_MissAttribute", "ref", xmlSchemaAttributeGroupRef);
				}
				else
				{
					ValidateQNameAttribute(xmlSchemaAttributeGroupRef, "ref", xmlSchemaAttributeGroupRef.RefName);
				}
				PreprocessAnnotation(attribute);
				ValidateIdAttribute(attribute);
			}
			if (anyAttribute != null)
			{
				try
				{
					SetParent(anyAttribute, parent);
					PreprocessAnnotation(anyAttribute);
					anyAttribute.BuildNamespaceListV1Compat(targetNamespace);
				}
				catch
				{
					SendValidationEvent("Sch_InvalidAnyAttribute", anyAttribute);
				}
				ValidateIdAttribute(anyAttribute);
			}
		}

		private void ValidateIdAttribute(XmlSchemaObject xso)
		{
			if (xso.IdAttribute == null)
			{
				return;
			}
			try
			{
				xso.IdAttribute = base.NameTable.Add(XmlConvert.VerifyNCName(xso.IdAttribute));
				if (schema.Ids[xso.IdAttribute] != null)
				{
					SendValidationEvent("Sch_DupIdAttribute", xso);
				}
				else
				{
					schema.Ids.Add(xso.IdAttribute, xso);
				}
			}
			catch (Exception ex)
			{
				SendValidationEvent("Sch_InvalidIdAttribute", ex.Message, xso);
			}
		}

		private void ValidateNameAttribute(XmlSchemaObject xso)
		{
			string nameAttribute = xso.NameAttribute;
			if (nameAttribute == null || nameAttribute.Length == 0)
			{
				SendValidationEvent("Sch_InvalidNameAttributeEx", null, Res.GetString("Sch_NullValue"), xso);
			}
			nameAttribute = XmlComplianceUtil.NonCDataNormalize(nameAttribute);
			int num = ValidateNames.ParseNCName(nameAttribute, 0);
			if (num != nameAttribute.Length)
			{
				string @string = Res.GetString("Xml_BadNameCharWithPos", XmlException.BuildCharExceptionStr(nameAttribute[num])[0], XmlException.BuildCharExceptionStr(nameAttribute[num])[1], num);
				SendValidationEvent("Sch_InvalidNameAttributeEx", nameAttribute, @string, xso);
			}
			else
			{
				xso.NameAttribute = base.NameTable.Add(nameAttribute);
			}
		}

		private void ValidateQNameAttribute(XmlSchemaObject xso, string attributeName, XmlQualifiedName value)
		{
			try
			{
				value.Verify();
				value.Atomize(base.NameTable);
				if (referenceNamespaces[value.Namespace] == null)
				{
					SendValidationEvent("Sch_UnrefNS", value.Namespace, xso, XmlSeverityType.Warning);
				}
			}
			catch (Exception ex)
			{
				SendValidationEvent("Sch_InvalidAttribute", attributeName, ex.Message, xso);
			}
		}

		private void SetParent(XmlSchemaObject child, XmlSchemaObject parent)
		{
			child.Parent = parent;
		}

		private void PreprocessAnnotation(XmlSchemaObject schemaObject)
		{
			if (!(schemaObject is XmlSchemaAnnotated))
			{
				return;
			}
			XmlSchemaAnnotated xmlSchemaAnnotated = schemaObject as XmlSchemaAnnotated;
			if (xmlSchemaAnnotated.Annotation == null)
			{
				return;
			}
			xmlSchemaAnnotated.Annotation.Parent = schemaObject;
			foreach (XmlSchemaObject item in xmlSchemaAnnotated.Annotation.Items)
			{
				item.Parent = xmlSchemaAnnotated.Annotation;
			}
		}

		private Uri ResolveSchemaLocationUri(XmlSchema enclosingSchema, string location)
		{
			try
			{
				return xmlResolver.ResolveUri(enclosingSchema.BaseUri, location);
			}
			catch
			{
				return null;
			}
		}

		private Stream GetSchemaEntity(Uri ruri)
		{
			try
			{
				return (Stream)xmlResolver.GetEntity(ruri, null, null);
			}
			catch
			{
				return null;
			}
		}
	}
	internal sealed class SchemaElementDecl : SchemaDeclBase
	{
		private ContentValidator contentValidator;

		private Hashtable attdefs = new Hashtable();

		private Hashtable prohibitedAttributes = new Hashtable();

		private ArrayList tmpDefaultAttdefs;

		private SchemaAttDef[] defaultAttdefs;

		private bool isAbstract;

		private bool isNillable;

		private XmlSchemaDerivationMethod block;

		private bool isIdDeclared;

		private bool isNotationDeclared;

		private bool hasRequiredAttribute;

		private bool hasNonCDataAttribute;

		private XmlSchemaAnyAttribute anyAttribute;

		private CompiledIdentityConstraint[] constraints;

		private XmlSchemaElement schemaElement;

		public static readonly SchemaElementDecl Empty = new SchemaElementDecl();

		public bool IsAbstract
		{
			get
			{
				return isAbstract;
			}
			set
			{
				isAbstract = value;
			}
		}

		public bool IsNillable
		{
			get
			{
				return isNillable;
			}
			set
			{
				isNillable = value;
			}
		}

		public XmlSchemaDerivationMethod Block
		{
			get
			{
				return block;
			}
			set
			{
				block = value;
			}
		}

		public bool IsIdDeclared
		{
			get
			{
				return isIdDeclared;
			}
			set
			{
				isIdDeclared = value;
			}
		}

		public bool IsNotationDeclared
		{
			get
			{
				return isNotationDeclared;
			}
			set
			{
				isNotationDeclared = value;
			}
		}

		public bool HasDefaultAttribute => defaultAttdefs != null;

		public bool HasRequiredAttribute
		{
			get
			{
				return hasRequiredAttribute;
			}
			set
			{
				hasRequiredAttribute = value;
			}
		}

		public bool HasNonCDataAttribute
		{
			get
			{
				return hasNonCDataAttribute;
			}
			set
			{
				hasNonCDataAttribute = value;
			}
		}

		public ContentValidator ContentValidator
		{
			get
			{
				return contentValidator;
			}
			set
			{
				contentValidator = value;
			}
		}

		public XmlSchemaAnyAttribute AnyAttribute
		{
			get
			{
				return anyAttribute;
			}
			set
			{
				anyAttribute = value;
			}
		}

		public CompiledIdentityConstraint[] Constraints
		{
			get
			{
				return constraints;
			}
			set
			{
				constraints = value;
			}
		}

		public XmlSchemaElement SchemaElement
		{
			get
			{
				return schemaElement;
			}
			set
			{
				schemaElement = value;
			}
		}

		public Hashtable AttDefs => attdefs;

		public SchemaAttDef[] DefaultAttDefs => defaultAttdefs;

		public Hashtable ProhibitedAttributes => prohibitedAttributes;

		public SchemaElementDecl()
		{
		}

		public SchemaElementDecl(XmlSchemaDatatype dtype)
		{
			base.Datatype = dtype;
			contentValidator = ContentValidator.TextOnly;
		}

		public SchemaElementDecl(XmlQualifiedName name, string prefix, SchemaType schemaType)
			: base(name, prefix)
		{
		}

		public static SchemaElementDecl CreateAnyTypeElementDecl()
		{
			SchemaElementDecl schemaElementDecl = new SchemaElementDecl();
			schemaElementDecl.Datatype = DatatypeImplementation.AnySimpleType.Datatype;
			return schemaElementDecl;
		}

		public SchemaElementDecl Clone()
		{
			return (SchemaElementDecl)MemberwiseClone();
		}

		public void AddAttDef(SchemaAttDef attdef)
		{
			attdefs.Add(attdef.Name, attdef);
			if (attdef.Presence == Use.Required || attdef.Presence == Use.RequiredFixed)
			{
				hasRequiredAttribute = true;
			}
			if (attdef.Presence == Use.Default || attdef.Presence == Use.Fixed)
			{
				if (tmpDefaultAttdefs == null)
				{
					tmpDefaultAttdefs = new ArrayList();
				}
				tmpDefaultAttdefs.Add(attdef);
			}
		}

		public void EndAddAttDef()
		{
			if (tmpDefaultAttdefs != null)
			{
				defaultAttdefs = (SchemaAttDef[])tmpDefaultAttdefs.ToArray(typeof(SchemaAttDef));
				tmpDefaultAttdefs = null;
			}
		}

		public SchemaAttDef GetAttDef(XmlQualifiedName qname)
		{
			return (SchemaAttDef)attdefs[qname];
		}

		public void CheckAttributes(Hashtable presence, bool standalone)
		{
			foreach (SchemaAttDef value in attdefs.Values)
			{
				if (presence[value.Name] == null)
				{
					if (value.Presence == Use.Required)
					{
						throw new XmlSchemaException("Sch_MissRequiredAttribute", value.Name.ToString());
					}
					if (standalone && value.IsDeclaredInExternal && (value.Presence == Use.Default || value.Presence == Use.Fixed))
					{
						throw new XmlSchemaException("Sch_StandAlone", string.Empty);
					}
				}
			}
		}
	}
	internal sealed class SchemaEntity
	{
		private XmlQualifiedName name;

		private string url;

		private string pubid;

		private string text;

		private XmlQualifiedName ndata = XmlQualifiedName.Empty;

		private int lineNumber;

		private int linePosition;

		private bool isParameter;

		private bool isExternal;

		private bool isProcessed;

		private bool isDeclaredInExternal;

		private string baseURI;

		private string declaredURI;

		internal XmlQualifiedName Name => name;

		internal string Url
		{
			get
			{
				return url;
			}
			set
			{
				url = value;
				isExternal = true;
			}
		}

		internal string Pubid
		{
			get
			{
				return pubid;
			}
			set
			{
				pubid = value;
			}
		}

		internal bool IsProcessed
		{
			get
			{
				return isProcessed;
			}
			set
			{
				isProcessed = value;
			}
		}

		internal bool IsExternal
		{
			get
			{
				return isExternal;
			}
			set
			{
				isExternal = value;
			}
		}

		internal bool DeclaredInExternal
		{
			get
			{
				return isDeclaredInExternal;
			}
			set
			{
				isDeclaredInExternal = value;
			}
		}

		internal bool IsParEntity
		{
			get
			{
				return isParameter;
			}
			set
			{
				isParameter = value;
			}
		}

		internal XmlQualifiedName NData
		{
			get
			{
				return ndata;
			}
			set
			{
				ndata = value;
			}
		}

		internal string Text
		{
			get
			{
				return text;
			}
			set
			{
				text = value;
				isExternal = false;
			}
		}

		internal int Line
		{
			get
			{
				return lineNumber;
			}
			set
			{
				lineNumber = value;
			}
		}

		internal int Pos
		{
			get
			{
				return linePosition;
			}
			set
			{
				linePosition = value;
			}
		}

		internal string BaseURI
		{
			get
			{
				if (baseURI != null)
				{
					return baseURI;
				}
				return string.Empty;
			}
			set
			{
				baseURI = value;
			}
		}

		internal string DeclaredURI
		{
			get
			{
				if (declaredURI != null)
				{
					return declaredURI;
				}
				return string.Empty;
			}
			set
			{
				declaredURI = value;
			}
		}

		internal SchemaEntity(XmlQualifiedName name, bool isParameter)
		{
			this.name = name;
			this.isParameter = isParameter;
		}

		internal static bool IsPredefinedEntity(string n)
		{
			switch (n)
			{
			default:
				return n == "quot";
			case "lt":
			case "gt":
			case "amp":
			case "apos":
				return true;
			}
		}
	}
	internal enum AttributeMatchState
	{
		AttributeFound,
		AnyIdAttributeFound,
		UndeclaredElementAndAttribute,
		UndeclaredAttribute,
		AnyAttributeLax,
		AnyAttributeSkip,
		ProhibitedAnyAttribute,
		ProhibitedAttribute,
		AttributeNameMismatch,
		ValidateAttributeInvalidCall
	}
	internal class SchemaInfo
	{
		private SchemaType schemaType;

		private Hashtable targetNamespaces = new Hashtable();

		private Hashtable elementDecls = new Hashtable();

		private Hashtable undeclaredElementDecls = new Hashtable();

		private Hashtable elementDeclsByType = new Hashtable();

		private Hashtable attributeDecls = new Hashtable();

		private Hashtable generalEntities;

		private Hashtable parameterEntities;

		private Hashtable notations;

		private XmlQualifiedName docTypeName = XmlQualifiedName.Empty;

		private int errorCount;

		private bool hasNonCDataAttributes;

		private bool hasDefaultAttributes;

		public SchemaType SchemaType
		{
			get
			{
				return schemaType;
			}
			set
			{
				schemaType = value;
			}
		}

		public Hashtable TargetNamespaces => targetNamespaces;

		public Hashtable ElementDecls => elementDecls;

		public Hashtable UndeclaredElementDecls => undeclaredElementDecls;

		public Hashtable ElementDeclsByType => elementDeclsByType;

		public Hashtable AttributeDecls => attributeDecls;

		public Hashtable GeneralEntities
		{
			get
			{
				if (generalEntities == null)
				{
					generalEntities = new Hashtable();
				}
				return generalEntities;
			}
		}

		public Hashtable ParameterEntities
		{
			get
			{
				if (parameterEntities == null)
				{
					parameterEntities = new Hashtable();
				}
				return parameterEntities;
			}
		}

		public Hashtable Notations
		{
			get
			{
				if (notations == null)
				{
					notations = new Hashtable();
				}
				return notations;
			}
		}

		public XmlQualifiedName DocTypeName
		{
			get
			{
				return docTypeName;
			}
			set
			{
				docTypeName = value;
			}
		}

		public int ErrorCount
		{
			get
			{
				return errorCount;
			}
			set
			{
				errorCount = value;
			}
		}

		internal bool HasDefaultAttributes
		{
			get
			{
				return hasDefaultAttributes;
			}
			set
			{
				hasDefaultAttributes = value;
			}
		}

		internal bool HasNonCDataAttributes
		{
			get
			{
				return hasNonCDataAttributes;
			}
			set
			{
				hasNonCDataAttributes = value;
			}
		}

		public SchemaInfo()
		{
			schemaType = SchemaType.None;
		}

		public SchemaElementDecl GetElementDecl(XmlQualifiedName qname)
		{
			return (SchemaElementDecl)elementDecls[qname];
		}

		public SchemaElementDecl GetTypeDecl(XmlQualifiedName qname)
		{
			return (SchemaElementDecl)elementDeclsByType[qname];
		}

		public XmlSchemaElement GetElement(XmlQualifiedName qname)
		{
			return GetElementDecl(qname)?.SchemaElement;
		}

		public XmlSchemaAttribute GetAttribute(XmlQualifiedName qname)
		{
			return ((SchemaAttDef)attributeDecls[qname])?.SchemaAttribute;
		}

		public XmlSchemaElement GetType(XmlQualifiedName qname)
		{
			return GetElementDecl(qname)?.SchemaElement;
		}

		public bool HasSchema(string ns)
		{
			return targetNamespaces[ns] != null;
		}

		public bool Contains(string ns)
		{
			return targetNamespaces[ns] != null;
		}

		public SchemaAttDef GetAttributeXdr(SchemaElementDecl ed, XmlQualifiedName qname)
		{
			SchemaAttDef schemaAttDef = null;
			if (ed != null)
			{
				schemaAttDef = ed.GetAttDef(qname);
				if (schemaAttDef == null)
				{
					if (!ed.ContentValidator.IsOpen || qname.Namespace.Length == 0)
					{
						throw new XmlSchemaException("Sch_UndeclaredAttribute", qname.ToString());
					}
					schemaAttDef = (SchemaAttDef)attributeDecls[qname];
					if (schemaAttDef == null && targetNamespaces.Contains(qname.Namespace))
					{
						throw new XmlSchemaException("Sch_UndeclaredAttribute", qname.ToString());
					}
				}
			}
			return schemaAttDef;
		}

		public SchemaAttDef GetAttributeXsd(SchemaElementDecl ed, XmlQualifiedName qname, XmlSchemaObject partialValidationType, out AttributeMatchState attributeMatchState)
		{
			SchemaAttDef schemaAttDef = null;
			attributeMatchState = AttributeMatchState.UndeclaredAttribute;
			if (ed != null)
			{
				schemaAttDef = ed.GetAttDef(qname);
				if (schemaAttDef != null)
				{
					attributeMatchState = AttributeMatchState.AttributeFound;
					return schemaAttDef;
				}
				XmlSchemaAnyAttribute anyAttribute = ed.AnyAttribute;
				if (anyAttribute != null)
				{
					if (!anyAttribute.NamespaceList.Allows(qname))
					{
						attributeMatchState = AttributeMatchState.ProhibitedAnyAttribute;
					}
					else if (anyAttribute.ProcessContentsCorrect != XmlSchemaContentProcessing.Skip)
					{
						schemaAttDef = (SchemaAttDef)attributeDecls[qname];
						if (schemaAttDef != null)
						{
							if (schemaAttDef.Datatype.TypeCode == XmlTypeCode.Id)
							{
								attributeMatchState = AttributeMatchState.AnyIdAttributeFound;
							}
							else
							{
								attributeMatchState = AttributeMatchState.AttributeFound;
							}
						}
						else if (anyAttribute.ProcessContentsCorrect == XmlSchemaContentProcessing.Lax)
						{
							attributeMatchState = AttributeMatchState.AnyAttributeLax;
						}
					}
					else
					{
						attributeMatchState = AttributeMatchState.AnyAttributeSkip;
					}
				}
				else if (ed.ProhibitedAttributes[qname] != null)
				{
					attributeMatchState = AttributeMatchState.ProhibitedAttribute;
				}
			}
			else if (partialValidationType != null)
			{
				if (partialValidationType is XmlSchemaAttribute xmlSchemaAttribute)
				{
					if (qname.Equals(xmlSchemaAttribute.QualifiedName))
					{
						schemaAttDef = xmlSchemaAttribute.AttDef;
						attributeMatchState = AttributeMatchState.AttributeFound;
					}
					else
					{
						attributeMatchState = AttributeMatchState.AttributeNameMismatch;
					}
				}
				else
				{
					attributeMatchState = AttributeMatchState.ValidateAttributeInvalidCall;
				}
			}
			else
			{
				schemaAttDef = (SchemaAttDef)attributeDecls[qname];
				if (schemaAttDef != null)
				{
					attributeMatchState = AttributeMatchState.AttributeFound;
				}
				else
				{
					attributeMatchState = AttributeMatchState.UndeclaredElementAndAttribute;
				}
			}
			return schemaAttDef;
		}

		public SchemaAttDef GetAttributeXsd(SchemaElementDecl ed, XmlQualifiedName qname, ref bool skip)
		{
			AttributeMatchState attributeMatchState;
			SchemaAttDef attributeXsd = GetAttributeXsd(ed, qname, null, out attributeMatchState);
			switch (attributeMatchState)
			{
			case AttributeMatchState.UndeclaredAttribute:
				throw new XmlSchemaException("Sch_UndeclaredAttribute", qname.ToString());
			case AttributeMatchState.ProhibitedAnyAttribute:
			case AttributeMatchState.ProhibitedAttribute:
				throw new XmlSchemaException("Sch_ProhibitedAttribute", qname.ToString());
			case AttributeMatchState.AnyAttributeSkip:
				skip = true;
				break;
			}
			return attributeXsd;
		}

		public void Add(SchemaInfo sinfo, ValidationEventHandler eventhandler)
		{
			if (schemaType == SchemaType.None)
			{
				schemaType = sinfo.SchemaType;
			}
			else if (schemaType != sinfo.SchemaType)
			{
				eventhandler?.Invoke(this, new ValidationEventArgs(new XmlSchemaException("Sch_MixSchemaTypes", string.Empty)));
				return;
			}
			foreach (string key in sinfo.TargetNamespaces.Keys)
			{
				if (!targetNamespaces.ContainsKey(key))
				{
					targetNamespaces.Add(key, true);
				}
			}
			foreach (DictionaryEntry elementDecl in sinfo.elementDecls)
			{
				if (!elementDecls.ContainsKey(elementDecl.Key))
				{
					elementDecls.Add(elementDecl.Key, elementDecl.Value);
				}
			}
			foreach (DictionaryEntry item in sinfo.elementDeclsByType)
			{
				if (!elementDeclsByType.ContainsKey(item.Key))
				{
					elementDeclsByType.Add(item.Key, item.Value);
				}
			}
			foreach (SchemaAttDef value in sinfo.AttributeDecls.Values)
			{
				if (!attributeDecls.ContainsKey(value.Name))
				{
					attributeDecls.Add(value.Name, value);
				}
			}
			foreach (SchemaNotation value2 in sinfo.Notations.Values)
			{
				if (!Notations.ContainsKey(value2.Name.Name))
				{
					Notations.Add(value2.Name.Name, value2);
				}
			}
		}

		public void Finish()
		{
			Hashtable hashtable = elementDecls;
			for (int i = 0; i < 2; i++)
			{
				foreach (SchemaElementDecl value in hashtable.Values)
				{
					value.EndAddAttDef();
					if (value.HasNonCDataAttribute)
					{
						hasNonCDataAttributes = true;
					}
					if (value.DefaultAttDefs != null)
					{
						hasDefaultAttributes = true;
					}
				}
				hashtable = undeclaredElementDecls;
			}
		}
	}
	internal sealed class SchemaNames
	{
		public enum Token
		{
			Empty,
			SchemaName,
			SchemaType,
			SchemaMaxOccurs,
			SchemaMinOccurs,
			SchemaInfinite,
			SchemaModel,
			SchemaOpen,
			SchemaClosed,
			SchemaContent,
			SchemaMixed,
			SchemaEmpty,
			SchemaElementOnly,
			SchemaTextOnly,
			SchemaOrder,
			SchemaSeq,
			SchemaOne,
			SchemaMany,
			SchemaRequired,
			SchemaYes,
			SchemaNo,
			SchemaString,
			SchemaId,
			SchemaIdref,
			SchemaIdrefs,
			SchemaEntity,
			SchemaEntities,
			SchemaNmtoken,
			SchemaNmtokens,
			SchemaEnumeration,
			SchemaDefault,
			XdrRoot,
			XdrElementType,
			XdrElement,
			XdrGroup,
			XdrAttributeType,
			XdrAttribute,
			XdrDatatype,
			XdrDescription,
			XdrExtends,
			SchemaXdrRootAlias,
			SchemaDtType,
			SchemaDtValues,
			SchemaDtMaxLength,
			SchemaDtMinLength,
			SchemaDtMax,
			SchemaDtMin,
			SchemaDtMinExclusive,
			SchemaDtMaxExclusive,
			SchemaTargetNamespace,
			SchemaVersion,
			SchemaFinalDefault,
			SchemaBlockDefault,
			SchemaFixed,
			SchemaAbstract,
			SchemaBlock,
			SchemaSubstitutionGroup,
			SchemaFinal,
			SchemaNillable,
			SchemaRef,
			SchemaBase,
			SchemaDerivedBy,
			SchemaNamespace,
			SchemaProcessContents,
			SchemaRefer,
			SchemaPublic,
			SchemaSystem,
			SchemaSchemaLocation,
			SchemaValue,
			SchemaSource,
			SchemaAttributeFormDefault,
			SchemaElementFormDefault,
			SchemaUse,
			SchemaForm,
			XsdSchema,
			XsdAnnotation,
			XsdInclude,
			XsdImport,
			XsdElement,
			XsdAttribute,
			xsdAttributeGroup,
			XsdAnyAttribute,
			XsdGroup,
			XsdAll,
			XsdChoice,
			XsdSequence,
			XsdAny,
			XsdNotation,
			XsdSimpleType,
			XsdComplexType,
			XsdUnique,
			XsdKey,
			XsdKeyref,
			XsdSelector,
			XsdField,
			XsdMinExclusive,
			XsdMinInclusive,
			XsdMaxExclusive,
			XsdMaxInclusive,
			XsdTotalDigits,
			XsdFractionDigits,
			XsdLength,
			XsdMinLength,
			XsdMaxLength,
			XsdEnumeration,
			XsdPattern,
			XsdDocumentation,
			XsdAppInfo,
			XsdComplexContent,
			XsdComplexContentExtension,
			XsdComplexContentRestriction,
			XsdSimpleContent,
			XsdSimpleContentExtension,
			XsdSimpleContentRestriction,
			XsdSimpleTypeList,
			XsdSimpleTypeRestriction,
			XsdSimpleTypeUnion,
			XsdWhitespace,
			XsdRedefine,
			SchemaItemType,
			SchemaMemberTypes,
			SchemaXPath,
			XmlLang
		}

		private XmlNameTable nameTable;

		public string NsDataType;

		public string NsDataTypeAlias;

		public string NsDataTypeOld;

		public string NsXml;

		public string NsXmlNs;

		public string NsXdr;

		public string NsXdrAlias;

		public string NsXs;

		public string NsXsi;

		public string XsiType;

		public string XsiNil;

		public string XsiSchemaLocation;

		public string XsiNoNamespaceSchemaLocation;

		public string XsdSchema;

		public string XdrSchema;

		public XmlQualifiedName QnPCData;

		public XmlQualifiedName QnXml;

		public XmlQualifiedName QnXmlNs;

		public XmlQualifiedName QnDtDt;

		public XmlQualifiedName QnXmlLang;

		public XmlQualifiedName QnName;

		public XmlQualifiedName QnType;

		public XmlQualifiedName QnMaxOccurs;

		public XmlQualifiedName QnMinOccurs;

		public XmlQualifiedName QnInfinite;

		public XmlQualifiedName QnModel;

		public XmlQualifiedName QnOpen;

		public XmlQualifiedName QnClosed;

		public XmlQualifiedName QnContent;

		public XmlQualifiedName QnMixed;

		public XmlQualifiedName QnEmpty;

		public XmlQualifiedName QnEltOnly;

		public XmlQualifiedName QnTextOnly;

		public XmlQualifiedName QnOrder;

		public XmlQualifiedName QnSeq;

		public XmlQualifiedName QnOne;

		public XmlQualifiedName QnMany;

		public XmlQualifiedName QnRequired;

		public XmlQualifiedName QnYes;

		public XmlQualifiedName QnNo;

		public XmlQualifiedName QnString;

		public XmlQualifiedName QnID;

		public XmlQualifiedName QnIDRef;

		public XmlQualifiedName QnIDRefs;

		public XmlQualifiedName QnEntity;

		public XmlQualifiedName QnEntities;

		public XmlQualifiedName QnNmToken;

		public XmlQualifiedName QnNmTokens;

		public XmlQualifiedName QnEnumeration;

		public XmlQualifiedName QnDefault;

		public XmlQualifiedName QnXdrSchema;

		public XmlQualifiedName QnXdrElementType;

		public XmlQualifiedName QnXdrElement;

		public XmlQualifiedName QnXdrGroup;

		public XmlQualifiedName QnXdrAttributeType;

		public XmlQualifiedName QnXdrAttribute;

		public XmlQualifiedName QnXdrDataType;

		public XmlQualifiedName QnXdrDescription;

		public XmlQualifiedName QnXdrExtends;

		public XmlQualifiedName QnXdrAliasSchema;

		public XmlQualifiedName QnDtType;

		public XmlQualifiedName QnDtValues;

		public XmlQualifiedName QnDtMaxLength;

		public XmlQualifiedName QnDtMinLength;

		public XmlQualifiedName QnDtMax;

		public XmlQualifiedName QnDtMin;

		public XmlQualifiedName QnDtMinExclusive;

		public XmlQualifiedName QnDtMaxExclusive;

		public XmlQualifiedName QnTargetNamespace;

		public XmlQualifiedName QnVersion;

		public XmlQualifiedName QnFinalDefault;

		public XmlQualifiedName QnBlockDefault;

		public XmlQualifiedName QnFixed;

		public XmlQualifiedName QnAbstract;

		public XmlQualifiedName QnBlock;

		public XmlQualifiedName QnSubstitutionGroup;

		public XmlQualifiedName QnFinal;

		public XmlQualifiedName QnNillable;

		public XmlQualifiedName QnRef;

		public XmlQualifiedName QnBase;

		public XmlQualifiedName QnDerivedBy;

		public XmlQualifiedName QnNamespace;

		public XmlQualifiedName QnProcessContents;

		public XmlQualifiedName QnRefer;

		public XmlQualifiedName QnPublic;

		public XmlQualifiedName QnSystem;

		public XmlQualifiedName QnSchemaLocation;

		public XmlQualifiedName QnValue;

		public XmlQualifiedName QnUse;

		public XmlQualifiedName QnForm;

		public XmlQualifiedName QnElementFormDefault;

		public XmlQualifiedName QnAttributeFormDefault;

		public XmlQualifiedName QnItemType;

		public XmlQualifiedName QnMemberTypes;

		public XmlQualifiedName QnXPath;

		public XmlQualifiedName QnXsdSchema;

		public XmlQualifiedName QnXsdAnnotation;

		public XmlQualifiedName QnXsdInclude;

		public XmlQualifiedName QnXsdImport;

		public XmlQualifiedName QnXsdElement;

		public XmlQualifiedName QnXsdAttribute;

		public XmlQualifiedName QnXsdAttributeGroup;

		public XmlQualifiedName QnXsdAnyAttribute;

		public XmlQualifiedName QnXsdGroup;

		public XmlQualifiedName QnXsdAll;

		public XmlQualifiedName QnXsdChoice;

		public XmlQualifiedName QnXsdSequence;

		public XmlQualifiedName QnXsdAny;

		public XmlQualifiedName QnXsdNotation;

		public XmlQualifiedName QnXsdSimpleType;

		public XmlQualifiedName QnXsdComplexType;

		public XmlQualifiedName QnXsdUnique;

		public XmlQualifiedName QnXsdKey;

		public XmlQualifiedName QnXsdKeyRef;

		public XmlQualifiedName QnXsdSelector;

		public XmlQualifiedName QnXsdField;

		public XmlQualifiedName QnXsdMinExclusive;

		public XmlQualifiedName QnXsdMinInclusive;

		public XmlQualifiedName QnXsdMaxInclusive;

		public XmlQualifiedName QnXsdMaxExclusive;

		public XmlQualifiedName QnXsdTotalDigits;

		public XmlQualifiedName QnXsdFractionDigits;

		public XmlQualifiedName QnXsdLength;

		public XmlQualifiedName QnXsdMinLength;

		public XmlQualifiedName QnXsdMaxLength;

		public XmlQualifiedName QnXsdEnumeration;

		public XmlQualifiedName QnXsdPattern;

		public XmlQualifiedName QnXsdDocumentation;

		public XmlQualifiedName QnXsdAppinfo;

		public XmlQualifiedName QnSource;

		public XmlQualifiedName QnXsdComplexContent;

		public XmlQualifiedName QnXsdSimpleContent;

		public XmlQualifiedName QnXsdRestriction;

		public XmlQualifiedName QnXsdExtension;

		public XmlQualifiedName QnXsdUnion;

		public XmlQualifiedName QnXsdList;

		public XmlQualifiedName QnXsdWhiteSpace;

		public XmlQualifiedName QnXsdRedefine;

		public XmlQualifiedName QnXsdAnyType;

		internal XmlQualifiedName[] TokenToQName = new XmlQualifiedName[123];

		public XmlNameTable NameTable => nameTable;

		public SchemaNames(XmlNameTable nameTable)
		{
			this.nameTable = nameTable;
			NsDataType = nameTable.Add("urn:schemas-microsoft-com:datatypes");
			NsDataTypeAlias = nameTable.Add("uuid:C2F41010-65B3-11D1-A29F-00AA00C14882");
			NsDataTypeOld = nameTable.Add("urn:uuid:C2F41010-65B3-11D1-A29F-00AA00C14882/");
			NsXml = nameTable.Add("http://www.w3.org/XML/1998/namespace");
			NsXmlNs = nameTable.Add("http://www.w3.org/2000/xmlns/");
			NsXdr = nameTable.Add("urn:schemas-microsoft-com:xml-data");
			NsXdrAlias = nameTable.Add("uuid:BDC6E3F0-6DA3-11D1-A2A3-00AA00C14882");
			NsXs = nameTable.Add("http://www.w3.org/2001/XMLSchema");
			NsXsi = nameTable.Add("http://www.w3.org/2001/XMLSchema-instance");
			XsiType = nameTable.Add("type");
			XsiNil = nameTable.Add("nil");
			XsiSchemaLocation = nameTable.Add("schemaLocation");
			XsiNoNamespaceSchemaLocation = nameTable.Add("noNamespaceSchemaLocation");
			XsdSchema = nameTable.Add("schema");
			XdrSchema = nameTable.Add("Schema");
			QnPCData = new XmlQualifiedName(nameTable.Add("#PCDATA"));
			QnXml = new XmlQualifiedName(nameTable.Add("xml"));
			QnXmlNs = new XmlQualifiedName(nameTable.Add("xmlns"), NsXmlNs);
			QnDtDt = new XmlQualifiedName(nameTable.Add("dt"), NsDataType);
			QnXmlLang = new XmlQualifiedName(nameTable.Add("lang"), NsXml);
			QnName = new XmlQualifiedName(nameTable.Add("name"));
			QnType = new XmlQualifiedName(nameTable.Add("type"));
			QnMaxOccurs = new XmlQualifiedName(nameTable.Add("maxOccurs"));
			QnMinOccurs = new XmlQualifiedName(nameTable.Add("minOccurs"));
			QnInfinite = new XmlQualifiedName(nameTable.Add("*"));
			QnModel = new XmlQualifiedName(nameTable.Add("model"));
			QnOpen = new XmlQualifiedName(nameTable.Add("open"));
			QnClosed = new XmlQualifiedName(nameTable.Add("closed"));
			QnContent = new XmlQualifiedName(nameTable.Add("content"));
			QnMixed = new XmlQualifiedName(nameTable.Add("mixed"));
			QnEmpty = new XmlQualifiedName(nameTable.Add("empty"));
			QnEltOnly = new XmlQualifiedName(nameTable.Add("eltOnly"));
			QnTextOnly = new XmlQualifiedName(nameTable.Add("textOnly"));
			QnOrder = new XmlQualifiedName(nameTable.Add("order"));
			QnSeq = new XmlQualifiedName(nameTable.Add("seq"));
			QnOne = new XmlQualifiedName(nameTable.Add("one"));
			QnMany = new XmlQualifiedName(nameTable.Add("many"));
			QnRequired = new XmlQualifiedName(nameTable.Add("required"));
			QnYes = new XmlQualifiedName(nameTable.Add("yes"));
			QnNo = new XmlQualifiedName(nameTable.Add("no"));
			QnString = new XmlQualifiedName(nameTable.Add("string"));
			QnID = new XmlQualifiedName(nameTable.Add("id"));
			QnIDRef = new XmlQualifiedName(nameTable.Add("idref"));
			QnIDRefs = new XmlQualifiedName(nameTable.Add("idrefs"));
			QnEntity = new XmlQualifiedName(nameTable.Add("entity"));
			QnEntities = new XmlQualifiedName(nameTable.Add("entities"));
			QnNmToken = new XmlQualifiedName(nameTable.Add("nmtoken"));
			QnNmTokens = new XmlQualifiedName(nameTable.Add("nmtokens"));
			QnEnumeration = new XmlQualifiedName(nameTable.Add("enumeration"));
			QnDefault = new XmlQualifiedName(nameTable.Add("default"));
			QnTargetNamespace = new XmlQualifiedName(nameTable.Add("targetNamespace"));
			QnVersion = new XmlQualifiedName(nameTable.Add("version"));
			QnFinalDefault = new XmlQualifiedName(nameTable.Add("finalDefault"));
			QnBlockDefault = new XmlQualifiedName(nameTable.Add("blockDefault"));
			QnFixed = new XmlQualifiedName(nameTable.Add("fixed"));
			QnAbstract = new XmlQualifiedName(nameTable.Add("abstract"));
			QnBlock = new XmlQualifiedName(nameTable.Add("block"));
			QnSubstitutionGroup = new XmlQualifiedName(nameTable.Add("substitutionGroup"));
			QnFinal = new XmlQualifiedName(nameTable.Add("final"));
			QnNillable = new XmlQualifiedName(nameTable.Add("nillable"));
			QnRef = new XmlQualifiedName(nameTable.Add("ref"));
			QnBase = new XmlQualifiedName(nameTable.Add("base"));
			QnDerivedBy = new XmlQualifiedName(nameTable.Add("derivedBy"));
			QnNamespace = new XmlQualifiedName(nameTable.Add("namespace"));
			QnProcessContents = new XmlQualifiedName(nameTable.Add("processContents"));
			QnRefer = new XmlQualifiedName(nameTable.Add("refer"));
			QnPublic = new XmlQualifiedName(nameTable.Add("public"));
			QnSystem = new XmlQualifiedName(nameTable.Add("system"));
			QnSchemaLocation = new XmlQualifiedName(nameTable.Add("schemaLocation"));
			QnValue = new XmlQualifiedName(nameTable.Add("value"));
			QnUse = new XmlQualifiedName(nameTable.Add("use"));
			QnForm = new XmlQualifiedName(nameTable.Add("form"));
			QnAttributeFormDefault = new XmlQualifiedName(nameTable.Add("attributeFormDefault"));
			QnElementFormDefault = new XmlQualifiedName(nameTable.Add("elementFormDefault"));
			QnSource = new XmlQualifiedName(nameTable.Add("source"));
			QnMemberTypes = new XmlQualifiedName(nameTable.Add("memberTypes"));
			QnItemType = new XmlQualifiedName(nameTable.Add("itemType"));
			QnXPath = new XmlQualifiedName(nameTable.Add("xpath"));
			QnXdrSchema = new XmlQualifiedName(XdrSchema, NsXdr);
			QnXdrElementType = new XmlQualifiedName(nameTable.Add("ElementType"), NsXdr);
			QnXdrElement = new XmlQualifiedName(nameTable.Add("element"), NsXdr);
			QnXdrGroup = new XmlQualifiedName(nameTable.Add("group"), NsXdr);
			QnXdrAttributeType = new XmlQualifiedName(nameTable.Add("AttributeType"), NsXdr);
			QnXdrAttribute = new XmlQualifiedName(nameTable.Add("attribute"), NsXdr);
			QnXdrDataType = new XmlQualifiedName(nameTable.Add("datatype"), NsXdr);
			QnXdrDescription = new XmlQualifiedName(nameTable.Add("description"), NsXdr);
			QnXdrExtends = new XmlQualifiedName(nameTable.Add("extends"), NsXdr);
			QnXdrAliasSchema = new XmlQualifiedName(nameTable.Add("Schema"), NsDataTypeAlias);
			QnDtType = new XmlQualifiedName(nameTable.Add("type"), NsDataType);
			QnDtValues = new XmlQualifiedName(nameTable.Add("values"), NsDataType);
			QnDtMaxLength = new XmlQualifiedName(nameTable.Add("maxLength"), NsDataType);
			QnDtMinLength = new XmlQualifiedName(nameTable.Add("minLength"), NsDataType);
			QnDtMax = new XmlQualifiedName(nameTable.Add("max"), NsDataType);
			QnDtMin = new XmlQualifiedName(nameTable.Add("min"), NsDataType);
			QnDtMinExclusive = new XmlQualifiedName(nameTable.Add("minExclusive"), NsDataType);
			QnDtMaxExclusive = new XmlQualifiedName(nameTable.Add("maxExclusive"), NsDataType);
			QnXsdSchema = new XmlQualifiedName(XsdSchema, NsXs);
			QnXsdAnnotation = new XmlQualifiedName(nameTable.Add("annotation"), NsXs);
			QnXsdInclude = new XmlQualifiedName(nameTable.Add("include"), NsXs);
			QnXsdImport = new XmlQualifiedName(nameTable.Add("import"), NsXs);
			QnXsdElement = new XmlQualifiedName(nameTable.Add("element"), NsXs);
			QnXsdAttribute = new XmlQualifiedName(nameTable.Add("attribute"), NsXs);
			QnXsdAttributeGroup = new XmlQualifiedName(nameTable.Add("attributeGroup"), NsXs);
			QnXsdAnyAttribute = new XmlQualifiedName(nameTable.Add("anyAttribute"), NsXs);
			QnXsdGroup = new XmlQualifiedName(nameTable.Add("group"), NsXs);
			QnXsdAll = new XmlQualifiedName(nameTable.Add("all"), NsXs);
			QnXsdChoice = new XmlQualifiedName(nameTable.Add("choice"), NsXs);
			QnXsdSequence = new XmlQualifiedName(nameTable.Add("sequence"), NsXs);
			QnXsdAny = new XmlQualifiedName(nameTable.Add("any"), NsXs);
			QnXsdNotation = new XmlQualifiedName(nameTable.Add("notation"), NsXs);
			QnXsdSimpleType = new XmlQualifiedName(nameTable.Add("simpleType"), NsXs);
			QnXsdComplexType = new XmlQualifiedName(nameTable.Add("complexType"), NsXs);
			QnXsdUnique = new XmlQualifiedName(nameTable.Add("unique"), NsXs);
			QnXsdKey = new XmlQualifiedName(nameTable.Add("key"), NsXs);
			QnXsdKeyRef = new XmlQualifiedName(nameTable.Add("keyref"), NsXs);
			QnXsdSelector = new XmlQualifiedName(nameTable.Add("selector"), NsXs);
			QnXsdField = new XmlQualifiedName(nameTable.Add("field"), NsXs);
			QnXsdMinExclusive = new XmlQualifiedName(nameTable.Add("minExclusive"), NsXs);
			QnXsdMinInclusive = new XmlQualifiedName(nameTable.Add("minInclusive"), NsXs);
			QnXsdMaxInclusive = new XmlQualifiedName(nameTable.Add("maxInclusive"), NsXs);
			QnXsdMaxExclusive = new XmlQualifiedName(nameTable.Add("maxExclusive"), NsXs);
			QnXsdTotalDigits = new XmlQualifiedName(nameTable.Add("totalDigits"), NsXs);
			QnXsdFractionDigits = new XmlQualifiedName(nameTable.Add("fractionDigits"), NsXs);
			QnXsdLength = new XmlQualifiedName(nameTable.Add("length"), NsXs);
			QnXsdMinLength = new XmlQualifiedName(nameTable.Add("minLength"), NsXs);
			QnXsdMaxLength = new XmlQualifiedName(nameTable.Add("maxLength"), NsXs);
			QnXsdEnumeration = new XmlQualifiedName(nameTable.Add("enumeration"), NsXs);
			QnXsdPattern = new XmlQualifiedName(nameTable.Add("pattern"), NsXs);
			QnXsdDocumentation = new XmlQualifiedName(nameTable.Add("documentation"), NsXs);
			QnXsdAppinfo = new XmlQualifiedName(nameTable.Add("appinfo"), NsXs);
			QnXsdComplexContent = new XmlQualifiedName(nameTable.Add("complexContent"), NsXs);
			QnXsdSimpleContent = new XmlQualifiedName(nameTable.Add("simpleContent"), NsXs);
			QnXsdRestriction = new XmlQualifiedName(nameTable.Add("restriction"), NsXs);
			QnXsdExtension = new XmlQualifiedName(nameTable.Add("extension"), NsXs);
			QnXsdUnion = new XmlQualifiedName(nameTable.Add("union"), NsXs);
			QnXsdList = new XmlQualifiedName(nameTable.Add("list"), NsXs);
			QnXsdWhiteSpace = new XmlQualifiedName(nameTable.Add("whiteSpace"), NsXs);
			QnXsdRedefine = new XmlQualifiedName(nameTable.Add("redefine"), NsXs);
			QnXsdAnyType = new XmlQualifiedName(nameTable.Add("anyType"), NsXs);
			CreateTokenToQNameTable();
		}

		public void CreateTokenToQNameTable()
		{
			TokenToQName[1] = QnName;
			TokenToQName[2] = QnType;
			TokenToQName[3] = QnMaxOccurs;
			TokenToQName[4] = QnMinOccurs;
			TokenToQName[5] = QnInfinite;
			TokenToQName[6] = QnModel;
			TokenToQName[7] = QnOpen;
			TokenToQName[8] = QnClosed;
			TokenToQName[9] = QnContent;
			TokenToQName[10] = QnMixed;
			TokenToQName[11] = QnEmpty;
			TokenToQName[12] = QnEltOnly;
			TokenToQName[13] = QnTextOnly;
			TokenToQName[14] = QnOrder;
			TokenToQName[15] = QnSeq;
			TokenToQName[16] = QnOne;
			TokenToQName[17] = QnMany;
			TokenToQName[18] = QnRequired;
			TokenToQName[19] = QnYes;
			TokenToQName[20] = QnNo;
			TokenToQName[21] = QnString;
			TokenToQName[22] = QnID;
			TokenToQName[23] = QnIDRef;
			TokenToQName[24] = QnIDRefs;
			TokenToQName[25] = QnEntity;
			TokenToQName[26] = QnEntities;
			TokenToQName[27] = QnNmToken;
			TokenToQName[28] = QnNmTokens;
			TokenToQName[29] = QnEnumeration;
			TokenToQName[30] = QnDefault;
			TokenToQName[31] = QnXdrSchema;
			TokenToQName[32] = QnXdrElementType;
			TokenToQName[33] = QnXdrElement;
			TokenToQName[34] = QnXdrGroup;
			TokenToQName[35] = QnXdrAttributeType;
			TokenToQName[36] = QnXdrAttribute;
			TokenToQName[37] = QnXdrDataType;
			TokenToQName[38] = QnXdrDescription;
			TokenToQName[39] = QnXdrExtends;
			TokenToQName[40] = QnXdrAliasSchema;
			TokenToQName[41] = QnDtType;
			TokenToQName[42] = QnDtValues;
			TokenToQName[43] = QnDtMaxLength;
			TokenToQName[44] = QnDtMinLength;
			TokenToQName[45] = QnDtMax;
			TokenToQName[46] = QnDtMin;
			TokenToQName[47] = QnDtMinExclusive;
			TokenToQName[48] = QnDtMaxExclusive;
			TokenToQName[49] = QnTargetNamespace;
			TokenToQName[50] = QnVersion;
			TokenToQName[51] = QnFinalDefault;
			TokenToQName[52] = QnBlockDefault;
			TokenToQName[53] = QnFixed;
			TokenToQName[54] = QnAbstract;
			TokenToQName[55] = QnBlock;
			TokenToQName[56] = QnSubstitutionGroup;
			TokenToQName[57] = QnFinal;
			TokenToQName[58] = QnNillable;
			TokenToQName[59] = QnRef;
			TokenToQName[60] = QnBase;
			TokenToQName[61] = QnDerivedBy;
			TokenToQName[62] = QnNamespace;
			TokenToQName[63] = QnProcessContents;
			TokenToQName[64] = QnRefer;
			TokenToQName[65] = QnPublic;
			TokenToQName[66] = QnSystem;
			TokenToQName[67] = QnSchemaLocation;
			TokenToQName[68] = QnValue;
			TokenToQName[119] = QnItemType;
			TokenToQName[120] = QnMemberTypes;
			TokenToQName[121] = QnXPath;
			TokenToQName[74] = QnXsdSchema;
			TokenToQName[75] = QnXsdAnnotation;
			TokenToQName[76] = QnXsdInclude;
			TokenToQName[77] = QnXsdImport;
			TokenToQName[78] = QnXsdElement;
			TokenToQName[79] = QnXsdAttribute;
			TokenToQName[80] = QnXsdAttributeGroup;
			TokenToQName[81] = QnXsdAnyAttribute;
			TokenToQName[82] = QnXsdGroup;
			TokenToQName[83] = QnXsdAll;
			TokenToQName[84] = QnXsdChoice;
			TokenToQName[85] = QnXsdSequence;
			TokenToQName[86] = QnXsdAny;
			TokenToQName[87] = QnXsdNotation;
			TokenToQName[88] = QnXsdSimpleType;
			TokenToQName[89] = QnXsdComplexType;
			TokenToQName[90] = QnXsdUnique;
			TokenToQName[91] = QnXsdKey;
			TokenToQName[92] = QnXsdKeyRef;
			TokenToQName[93] = QnXsdSelector;
			TokenToQName[94] = QnXsdField;
			TokenToQName[95] = QnXsdMinExclusive;
			TokenToQName[96] = QnXsdMinInclusive;
			TokenToQName[97] = QnXsdMaxExclusive;
			TokenToQName[98] = QnXsdMaxInclusive;
			TokenToQName[99] = QnXsdTotalDigits;
			TokenToQName[100] = QnXsdFractionDigits;
			TokenToQName[101] = QnXsdLength;
			TokenToQName[102] = QnXsdMinLength;
			TokenToQName[103] = QnXsdMaxLength;
			TokenToQName[104] = QnXsdEnumeration;
			TokenToQName[105] = QnXsdPattern;
			TokenToQName[117] = QnXsdWhiteSpace;
			TokenToQName[106] = QnXsdDocumentation;
			TokenToQName[107] = QnXsdAppinfo;
			TokenToQName[108] = QnXsdComplexContent;
			TokenToQName[110] = QnXsdRestriction;
			TokenToQName[113] = QnXsdRestriction;
			TokenToQName[115] = QnXsdRestriction;
			TokenToQName[109] = QnXsdExtension;
			TokenToQName[112] = QnXsdExtension;
			TokenToQName[111] = QnXsdSimpleContent;
			TokenToQName[116] = QnXsdUnion;
			TokenToQName[114] = QnXsdList;
			TokenToQName[118] = QnXsdRedefine;
			TokenToQName[69] = QnSource;
			TokenToQName[72] = QnUse;
			TokenToQName[73] = QnForm;
			TokenToQName[71] = QnElementFormDefault;
			TokenToQName[70] = QnAttributeFormDefault;
			TokenToQName[122] = QnXmlLang;
			TokenToQName[0] = XmlQualifiedName.Empty;
		}

		public SchemaType SchemaTypeFromRoot(string localName, string ns)
		{
			if (IsXSDRoot(localName, ns))
			{
				return SchemaType.XSD;
			}
			if (IsXDRRoot(localName, XmlSchemaDatatype.XdrCanonizeUri(ns, nameTable, this)))
			{
				return SchemaType.XDR;
			}
			return SchemaType.None;
		}

		public bool IsXSDRoot(string localName, string ns)
		{
			if (Ref.Equal(ns, NsXs))
			{
				return Ref.Equal(localName, XsdSchema);
			}
			return false;
		}

		public bool IsXDRRoot(string localName, string ns)
		{
			if (Ref.Equal(ns, NsXdr))
			{
				return Ref.Equal(localName, XdrSchema);
			}
			return false;
		}

		public XmlQualifiedName GetName(Token token)
		{
			return TokenToQName[(int)token];
		}
	}
	internal class SchemaNamespaceManager : XmlNamespaceManager
	{
		private XmlSchemaObject node;

		public SchemaNamespaceManager(XmlSchemaObject node)
		{
			this.node = node;
		}

		public override string LookupNamespace(string prefix)
		{
			if (prefix == "xml")
			{
				return "http://www.w3.org/XML/1998/namespace";
			}
			for (XmlSchemaObject parent = node; parent != null; parent = parent.Parent)
			{
				Hashtable namespaces = parent.Namespaces.Namespaces;
				if (namespaces != null && namespaces.Count > 0)
				{
					object obj = namespaces[prefix];
					if (obj != null)
					{
						return (string)obj;
					}
				}
			}
			if (prefix.Length != 0)
			{
				return null;
			}
			return string.Empty;
		}

		public override string LookupPrefix(string ns)
		{
			if (ns == "http://www.w3.org/XML/1998/namespace")
			{
				return "xml";
			}
			for (XmlSchemaObject parent = node; parent != null; parent = parent.Parent)
			{
				Hashtable namespaces = parent.Namespaces.Namespaces;
				if (namespaces != null && namespaces.Count > 0)
				{
					foreach (DictionaryEntry item in namespaces)
					{
						if (item.Value.Equals(ns))
						{
							return (string)item.Key;
						}
					}
				}
			}
			return null;
		}
	}
	internal sealed class SchemaNotation
	{
		internal const int SYSTEM = 0;

		internal const int PUBLIC = 1;

		private XmlQualifiedName name;

		private string systemLiteral;

		private string pubid;

		internal XmlQualifiedName Name => name;

		internal string SystemLiteral
		{
			get
			{
				return systemLiteral;
			}
			set
			{
				systemLiteral = value;
			}
		}

		internal string Pubid
		{
			get
			{
				return pubid;
			}
			set
			{
				pubid = value;
			}
		}

		internal SchemaNotation(XmlQualifiedName name)
		{
			this.name = name;
		}
	}
	internal enum SchemaType
	{
		None,
		DTD,
		XDR,
		XSD
	}
	public class ValidationEventArgs : EventArgs
	{
		private XmlSchemaException ex;

		private XmlSeverityType severity;

		public XmlSeverityType Severity => severity;

		public XmlSchemaException Exception => ex;

		public string Message => ex.Message;

		internal ValidationEventArgs(XmlSchemaException ex)
		{
			this.ex = ex;
			severity = XmlSeverityType.Error;
		}

		internal ValidationEventArgs(XmlSchemaException ex, XmlSeverityType severity)
		{
			this.ex = ex;
			this.severity = severity;
		}
	}
	public delegate void ValidationEventHandler(object sender, ValidationEventArgs e);
	[StructLayout(LayoutKind.Explicit)]
	internal struct StateUnion
	{
		[FieldOffset(0)]
		public int State;

		[FieldOffset(0)]
		public int AllElementsRequired;

		[FieldOffset(0)]
		public int CurPosIndex;

		[FieldOffset(0)]
		public int NumberOfRunningPos;
	}
	internal sealed class ValidationState
	{
		public bool IsNill;

		public bool IsDefault;

		public bool NeedValidateChildren;

		public bool CheckRequiredAttribute;

		public bool ValidationSkipped;

		public int Depth;

		public XmlSchemaContentProcessing ProcessContents;

		public XmlSchemaValidity Validity;

		public SchemaElementDecl ElementDecl;

		public SchemaElementDecl ElementDeclBeforeXsi;

		public string LocalName;

		public string Namespace;

		public ConstraintStruct[] Constr;

		public StateUnion CurrentState;

		public bool HasMatched;

		public BitSet[] CurPos = new BitSet[2];

		public BitSet AllElementsSet;

		public List<RangePositionInfo> RunningPositions;

		public bool TooComplex;
	}
	internal sealed class XdrBuilder : SchemaBuilder
	{
		private sealed class DeclBaseInfo
		{
			internal XmlQualifiedName _Name;

			internal string _Prefix;

			internal XmlQualifiedName _TypeName;

			internal string _TypePrefix;

			internal object _Default;

			internal object _Revises;

			internal uint _MaxOccurs;

			internal uint _MinOccurs;

			internal bool _Checking;

			internal SchemaElementDecl _ElementDecl;

			internal SchemaAttDef _Attdef;

			internal DeclBaseInfo _Next;

			internal DeclBaseInfo()
			{
				Reset();
			}

			internal void Reset()
			{
				_Name = XmlQualifiedName.Empty;
				_Prefix = null;
				_TypeName = XmlQualifiedName.Empty;
				_TypePrefix = null;
				_Default = null;
				_Revises = null;
				_MaxOccurs = 1u;
				_MinOccurs = 1u;
				_Checking = false;
				_ElementDecl = null;
				_Next = null;
				_Attdef = null;
			}
		}

		private sealed class GroupContent
		{
			internal uint _MinVal;

			internal uint _MaxVal;

			internal bool _HasMaxAttr;

			internal bool _HasMinAttr;

			internal int _Order;

			internal static void Copy(GroupContent from, GroupContent to)
			{
				to._MinVal = from._MinVal;
				to._MaxVal = from._MaxVal;
				to._Order = from._Order;
			}

			internal static GroupContent Copy(GroupContent other)
			{
				GroupContent groupContent = new GroupContent();
				Copy(other, groupContent);
				return groupContent;
			}
		}

		private sealed class ElementContent
		{
			internal SchemaElementDecl _ElementDecl;

			internal int _ContentAttr;

			internal int _OrderAttr;

			internal bool _MasterGroupRequired;

			internal bool _ExistTerminal;

			internal bool _AllowDataType;

			internal bool _HasDataType;

			internal bool _HasType;

			internal bool _EnumerationRequired;

			internal uint _MinVal;

			internal uint _MaxVal;

			internal uint _MaxLength;

			internal uint _MinLength;

			internal Hashtable _AttDefList;
		}

		private sealed class AttributeContent
		{
			internal SchemaAttDef _AttDef;

			internal XmlQualifiedName _Name;

			internal string _Prefix;

			internal bool _Required;

			internal uint _MinVal;

			internal uint _MaxVal;

			internal uint _MaxLength;

			internal uint _MinLength;

			internal bool _EnumerationRequired;

			internal bool _HasDataType;

			internal bool _Global;

			internal object _Default;
		}

		private delegate void XdrBuildFunction(XdrBuilder builder, object obj, string prefix);

		private delegate void XdrInitFunction(XdrBuilder builder, object obj);

		private delegate void XdrBeginChildFunction(XdrBuilder builder);

		private delegate void XdrEndChildFunction(XdrBuilder builder);

		private sealed class XdrAttributeEntry
		{
			internal SchemaNames.Token _Attribute;

			internal int _SchemaFlags;

			internal XmlSchemaDatatype _Datatype;

			internal XdrBuildFunction _BuildFunc;

			internal XdrAttributeEntry(SchemaNames.Token a, XmlTokenizedType ttype, XdrBuildFunction build)
			{
				_Attribute = a;
				_Datatype = XmlSchemaDatatype.FromXmlTokenizedType(ttype);
				_SchemaFlags = 0;
				_BuildFunc = build;
			}

			internal XdrAttributeEntry(SchemaNames.Token a, XmlTokenizedType ttype, int schemaFlags, XdrBuildFunction build)
			{
				_Attribute = a;
				_Datatype = XmlSchemaDatatype.FromXmlTokenizedType(ttype);
				_SchemaFlags = schemaFlags;
				_BuildFunc = build;
			}
		}

		private sealed class XdrEntry
		{
			internal SchemaNames.Token _Name;

			internal int[] _NextStates;

			internal XdrAttributeEntry[] _Attributes;

			internal XdrInitFunction _InitFunc;

			internal XdrBeginChildFunction _BeginChildFunc;

			internal XdrEndChildFunction _EndChildFunc;

			internal bool _AllowText;

			internal XdrEntry(SchemaNames.Token n, int[] states, XdrAttributeEntry[] attributes, XdrInitFunction init, XdrBeginChildFunction begin, XdrEndChildFunction end, bool fText)
			{
				_Name = n;
				_NextStates = states;
				_Attributes = attributes;
				_InitFunc = init;
				_BeginChildFunc = begin;
				_EndChildFunc = end;
				_AllowText = fText;
			}
		}

		private const int XdrSchema = 1;

		private const int XdrElementType = 2;

		private const int XdrAttributeType = 3;

		private const int XdrElement = 4;

		private const int XdrAttribute = 5;

		private const int XdrGroup = 6;

		private const int XdrElementDatatype = 7;

		private const int XdrAttributeDatatype = 8;

		private const int SchemaFlagsNs = 256;

		private const int StackIncrement = 10;

		private const int SchemaOrderNone = 0;

		private const int SchemaOrderMany = 1;

		private const int SchemaOrderSequence = 2;

		private const int SchemaOrderChoice = 3;

		private const int SchemaOrderAll = 4;

		private const int SchemaContentNone = 0;

		private const int SchemaContentEmpty = 1;

		private const int SchemaContentText = 2;

		private const int SchemaContentMixed = 3;

		private const int SchemaContentElement = 4;

		private const string x_schema = "x-schema:";

		private static readonly int[] S_XDR_Root_Element = new int[1] { 1 };

		private static readonly int[] S_XDR_Root_SubElements = new int[2] { 2, 3 };

		private static readonly int[] S_XDR_ElementType_SubElements = new int[5] { 4, 6, 3, 5, 7 };

		private static readonly int[] S_XDR_AttributeType_SubElements = new int[1] { 8 };

		private static readonly int[] S_XDR_Group_SubElements = new int[2] { 4, 6 };

		private static readonly XdrAttributeEntry[] S_XDR_Root_Attributes = new XdrAttributeEntry[2]
		{
			new XdrAttributeEntry(SchemaNames.Token.SchemaName, XmlTokenizedType.CDATA, XDR_BuildRoot_Name),
			new XdrAttributeEntry(SchemaNames.Token.SchemaId, XmlTokenizedType.QName, XDR_BuildRoot_ID)
		};

		private static readonly XdrAttributeEntry[] S_XDR_ElementType_Attributes = new XdrAttributeEntry[8]
		{
			new XdrAttributeEntry(SchemaNames.Token.SchemaName, XmlTokenizedType.QName, 256, XDR_BuildElementType_Name),
			new XdrAttributeEntry(SchemaNames.Token.SchemaContent, XmlTokenizedType.QName, XDR_BuildElementType_Content),
			new XdrAttributeEntry(SchemaNames.Token.SchemaModel, XmlTokenizedType.QName, XDR_BuildElementType_Model),
			new XdrAttributeEntry(SchemaNames.Token.SchemaOrder, XmlTokenizedType.QName, XDR_BuildElementType_Order),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtType, XmlTokenizedType.CDATA, XDR_BuildElementType_DtType),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtValues, XmlTokenizedType.NMTOKENS, XDR_BuildElementType_DtValues),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtMaxLength, XmlTokenizedType.CDATA, XDR_BuildElementType_DtMaxLength),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtMinLength, XmlTokenizedType.CDATA, XDR_BuildElementType_DtMinLength)
		};

		private static readonly XdrAttributeEntry[] S_XDR_AttributeType_Attributes = new XdrAttributeEntry[7]
		{
			new XdrAttributeEntry(SchemaNames.Token.SchemaName, XmlTokenizedType.QName, XDR_BuildAttributeType_Name),
			new XdrAttributeEntry(SchemaNames.Token.SchemaRequired, XmlTokenizedType.QName, XDR_BuildAttributeType_Required),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDefault, XmlTokenizedType.CDATA, XDR_BuildAttributeType_Default),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtType, XmlTokenizedType.QName, XDR_BuildAttributeType_DtType),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtValues, XmlTokenizedType.NMTOKENS, XDR_BuildAttributeType_DtValues),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtMaxLength, XmlTokenizedType.CDATA, XDR_BuildAttributeType_DtMaxLength),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtMinLength, XmlTokenizedType.CDATA, XDR_BuildAttributeType_DtMinLength)
		};

		private static readonly XdrAttributeEntry[] S_XDR_Element_Attributes = new XdrAttributeEntry[3]
		{
			new XdrAttributeEntry(SchemaNames.Token.SchemaType, XmlTokenizedType.QName, 256, XDR_BuildElement_Type),
			new XdrAttributeEntry(SchemaNames.Token.SchemaMinOccurs, XmlTokenizedType.CDATA, XDR_BuildElement_MinOccurs),
			new XdrAttributeEntry(SchemaNames.Token.SchemaMaxOccurs, XmlTokenizedType.CDATA, XDR_BuildElement_MaxOccurs)
		};

		private static readonly XdrAttributeEntry[] S_XDR_Attribute_Attributes = new XdrAttributeEntry[3]
		{
			new XdrAttributeEntry(SchemaNames.Token.SchemaType, XmlTokenizedType.QName, XDR_BuildAttribute_Type),
			new XdrAttributeEntry(SchemaNames.Token.SchemaRequired, XmlTokenizedType.QName, XDR_BuildAttribute_Required),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDefault, XmlTokenizedType.CDATA, XDR_BuildAttribute_Default)
		};

		private static readonly XdrAttributeEntry[] S_XDR_Group_Attributes = new XdrAttributeEntry[3]
		{
			new XdrAttributeEntry(SchemaNames.Token.SchemaOrder, XmlTokenizedType.QName, XDR_BuildGroup_Order),
			new XdrAttributeEntry(SchemaNames.Token.SchemaMinOccurs, XmlTokenizedType.CDATA, XDR_BuildGroup_MinOccurs),
			new XdrAttributeEntry(SchemaNames.Token.SchemaMaxOccurs, XmlTokenizedType.CDATA, XDR_BuildGroup_MaxOccurs)
		};

		private static readonly XdrAttributeEntry[] S_XDR_ElementDataType_Attributes = new XdrAttributeEntry[4]
		{
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtType, XmlTokenizedType.CDATA, XDR_BuildElementType_DtType),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtValues, XmlTokenizedType.NMTOKENS, XDR_BuildElementType_DtValues),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtMaxLength, XmlTokenizedType.CDATA, XDR_BuildElementType_DtMaxLength),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtMinLength, XmlTokenizedType.CDATA, XDR_BuildElementType_DtMinLength)
		};

		private static readonly XdrAttributeEntry[] S_XDR_AttributeDataType_Attributes = new XdrAttributeEntry[4]
		{
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtType, XmlTokenizedType.QName, XDR_BuildAttributeType_DtType),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtValues, XmlTokenizedType.NMTOKENS, XDR_BuildAttributeType_DtValues),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtMaxLength, XmlTokenizedType.CDATA, XDR_BuildAttributeType_DtMaxLength),
			new XdrAttributeEntry(SchemaNames.Token.SchemaDtMinLength, XmlTokenizedType.CDATA, XDR_BuildAttributeType_DtMinLength)
		};

		private static readonly XdrEntry[] S_SchemaEntries = new XdrEntry[9]
		{
			new XdrEntry(SchemaNames.Token.Empty, S_XDR_Root_Element, null, null, null, null, fText: false),
			new XdrEntry(SchemaNames.Token.XdrRoot, S_XDR_Root_SubElements, S_XDR_Root_Attributes, XDR_InitRoot, XDR_BeginRoot, XDR_EndRoot, fText: false),
			new XdrEntry(SchemaNames.Token.XdrElementType, S_XDR_ElementType_SubElements, S_XDR_ElementType_Attributes, XDR_InitElementType, XDR_BeginElementType, XDR_EndElementType, fText: false),
			new XdrEntry(SchemaNames.Token.XdrAttributeType, S_XDR_AttributeType_SubElements, S_XDR_AttributeType_Attributes, XDR_InitAttributeType, XDR_BeginAttributeType, XDR_EndAttributeType, fText: false),
			new XdrEntry(SchemaNames.Token.XdrElement, null, S_XDR_Element_Attributes, XDR_InitElement, null, XDR_EndElement, fText: false),
			new XdrEntry(SchemaNames.Token.XdrAttribute, null, S_XDR_Attribute_Attributes, XDR_InitAttribute, XDR_BeginAttribute, XDR_EndAttribute, fText: false),
			new XdrEntry(SchemaNames.Token.XdrGroup, S_XDR_Group_SubElements, S_XDR_Group_Attributes, XDR_InitGroup, null, XDR_EndGroup, fText: false),
			new XdrEntry(SchemaNames.Token.XdrDatatype, null, S_XDR_ElementDataType_Attributes, XDR_InitElementDtType, null, XDR_EndElementDtType, fText: true),
			new XdrEntry(SchemaNames.Token.XdrDatatype, null, S_XDR_AttributeDataType_Attributes, XDR_InitAttributeDtType, null, XDR_EndAttributeDtType, fText: true)
		};

		private SchemaInfo _SchemaInfo;

		private string _TargetNamespace;

		private XmlReader _reader;

		private PositionInfo positionInfo;

		private ParticleContentValidator _contentValidator;

		private XdrEntry _CurState;

		private XdrEntry _NextState;

		private HWStack _StateHistory;

		private HWStack _GroupStack;

		private string _XdrName;

		private string _XdrPrefix;

		private ElementContent _ElementDef;

		private GroupContent _GroupDef;

		private AttributeContent _AttributeDef;

		private DeclBaseInfo _UndefinedAttributeTypes;

		private DeclBaseInfo _BaseDecl;

		private XmlNameTable _NameTable;

		private SchemaNames _SchemaNames;

		private XmlNamespaceManager _CurNsMgr;

		private string _Text;

		private ValidationEventHandler validationEventHandler;

		private Hashtable _UndeclaredElements = new Hashtable();

		private XmlResolver xmlResolver;

		internal XmlResolver XmlResolver
		{
			set
			{
				xmlResolver = value;
			}
		}

		internal XdrBuilder(XmlReader reader, XmlNamespaceManager curmgr, SchemaInfo sinfo, string targetNamspace, XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler eventhandler)
		{
			_SchemaInfo = sinfo;
			_TargetNamespace = targetNamspace;
			_reader = reader;
			_CurNsMgr = curmgr;
			validationEventHandler = eventhandler;
			_StateHistory = new HWStack(10);
			_ElementDef = new ElementContent();
			_AttributeDef = new AttributeContent();
			_GroupStack = new HWStack(10);
			_GroupDef = new GroupContent();
			_NameTable = nameTable;
			_SchemaNames = schemaNames;
			_CurState = S_SchemaEntries[0];
			positionInfo = PositionInfo.GetPositionInfo(_reader);
			xmlResolver = XmlReaderSection.CreateDefaultResolver();
		}

		internal override bool ProcessElement(string prefix, string name, string ns)
		{
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(name, XmlSchemaDatatype.XdrCanonizeUri(ns, _NameTable, _SchemaNames));
			if (GetNextState(xmlQualifiedName))
			{
				Push();
				if (_CurState._InitFunc != null)
				{
					_CurState._InitFunc(this, xmlQualifiedName);
				}
				return true;
			}
			if (!IsSkipableElement(xmlQualifiedName))
			{
				SendValidationEvent("Sch_UnsupportedElement", XmlQualifiedName.ToString(name, prefix));
			}
			return false;
		}

		internal override void ProcessAttribute(string prefix, string name, string ns, string value)
		{
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(name, XmlSchemaDatatype.XdrCanonizeUri(ns, _NameTable, _SchemaNames));
			for (int i = 0; i < _CurState._Attributes.Length; i++)
			{
				XdrAttributeEntry xdrAttributeEntry = _CurState._Attributes[i];
				if (!_SchemaNames.TokenToQName[(int)xdrAttributeEntry._Attribute].Equals(xmlQualifiedName))
				{
					continue;
				}
				XdrBuildFunction buildFunc = xdrAttributeEntry._BuildFunc;
				if (xdrAttributeEntry._Datatype.TokenizedType == XmlTokenizedType.QName)
				{
					string prefix2;
					XmlQualifiedName xmlQualifiedName2 = XmlQualifiedName.Parse(value, _CurNsMgr, out prefix2);
					xmlQualifiedName2.Atomize(_NameTable);
					if (prefix2.Length == 0)
					{
						xmlQualifiedName2 = ((!IsGlobal(xdrAttributeEntry._SchemaFlags)) ? new XmlQualifiedName(xmlQualifiedName2.Name) : new XmlQualifiedName(xmlQualifiedName2.Name, _TargetNamespace));
					}
					else if (xdrAttributeEntry._Attribute != SchemaNames.Token.SchemaType)
					{
						throw new XmlException("Xml_UnexpectedToken", "NAME");
					}
					buildFunc(this, xmlQualifiedName2, prefix2);
				}
				else
				{
					buildFunc(this, xdrAttributeEntry._Datatype.ParseValue(value, _NameTable, _CurNsMgr), string.Empty);
				}
				return;
			}
			if ((object)ns == _SchemaNames.NsXmlNs && IsXdrSchema(value))
			{
				LoadSchema(value);
			}
			else if (!IsSkipableAttribute(xmlQualifiedName))
			{
				SendValidationEvent("Sch_UnsupportedAttribute", XmlQualifiedName.ToString(xmlQualifiedName.Name, prefix));
			}
		}

		private bool LoadSchema(string uri)
		{
			if (xmlResolver == null)
			{
				return false;
			}
			uri = _NameTable.Add(uri);
			if (_SchemaInfo.TargetNamespaces.Contains(uri))
			{
				return false;
			}
			SchemaInfo schemaInfo = null;
			Uri baseUri = xmlResolver.ResolveUri(null, _reader.BaseURI);
			XmlReader xmlReader = null;
			try
			{
				Uri uri2 = xmlResolver.ResolveUri(baseUri, uri.Substring("x-schema:".Length));
				Stream input = (Stream)xmlResolver.GetEntity(uri2, null, null);
				xmlReader = new XmlTextReader(uri2.ToString(), input, _NameTable);
				schemaInfo = new SchemaInfo();
				Parser parser = new Parser(SchemaType.XDR, _NameTable, _SchemaNames, validationEventHandler);
				parser.XmlResolver = xmlResolver;
				parser.Parse(xmlReader, uri);
				schemaInfo = parser.XdrSchema;
			}
			catch (XmlException ex)
			{
				SendValidationEvent("Sch_CannotLoadSchema", new string[2] { uri, ex.Message }, XmlSeverityType.Warning);
				schemaInfo = null;
			}
			finally
			{
				xmlReader?.Close();
			}
			if (schemaInfo != null && schemaInfo.ErrorCount == 0)
			{
				_SchemaInfo.Add(schemaInfo, validationEventHandler);
				return true;
			}
			return false;
		}

		internal static bool IsXdrSchema(string uri)
		{
			if (uri.Length >= "x-schema:".Length && string.Compare(uri, 0, "x-schema:", 0, "x-schema:".Length, StringComparison.Ordinal) == 0)
			{
				return !uri.StartsWith("x-schema:#", StringComparison.Ordinal);
			}
			return false;
		}

		internal override bool IsContentParsed()
		{
			return true;
		}

		internal override void ProcessMarkup(XmlNode[] markup)
		{
			throw new InvalidOperationException(Res.GetString("Xml_InvalidOperation"));
		}

		internal override void ProcessCData(string value)
		{
			if (_CurState._AllowText)
			{
				_Text = value;
			}
			else
			{
				SendValidationEvent("Sch_TextNotAllowed", value);
			}
		}

		internal override void StartChildren()
		{
			if (_CurState._BeginChildFunc != null)
			{
				_CurState._BeginChildFunc(this);
			}
		}

		internal override void EndChildren()
		{
			if (_CurState._EndChildFunc != null)
			{
				_CurState._EndChildFunc(this);
			}
			Pop();
		}

		private void Push()
		{
			_StateHistory.Push();
			_StateHistory[_StateHistory.Length - 1] = _CurState;
			_CurState = _NextState;
		}

		private void Pop()
		{
			_CurState = (XdrEntry)_StateHistory.Pop();
		}

		private void PushGroupInfo()
		{
			_GroupStack.Push();
			_GroupStack[_GroupStack.Length - 1] = GroupContent.Copy(_GroupDef);
		}

		private void PopGroupInfo()
		{
			_GroupDef = (GroupContent)_GroupStack.Pop();
		}

		private static void XDR_InitRoot(XdrBuilder builder, object obj)
		{
			builder._SchemaInfo.SchemaType = SchemaType.XDR;
			builder._ElementDef._ElementDecl = null;
			builder._ElementDef._AttDefList = null;
			builder._AttributeDef._AttDef = null;
		}

		private static void XDR_BuildRoot_Name(XdrBuilder builder, object obj, string prefix)
		{
			builder._XdrName = (string)obj;
			builder._XdrPrefix = prefix;
		}

		private static void XDR_BuildRoot_ID(XdrBuilder builder, object obj, string prefix)
		{
		}

		private static void XDR_BeginRoot(XdrBuilder builder)
		{
			if (builder._TargetNamespace == null)
			{
				if (builder._XdrName != null)
				{
					builder._TargetNamespace = builder._NameTable.Add("x-schema:#" + builder._XdrName);
				}
				else
				{
					builder._TargetNamespace = string.Empty;
				}
			}
			builder._SchemaInfo.TargetNamespaces.Add(builder._TargetNamespace, true);
		}

		private static void XDR_EndRoot(XdrBuilder builder)
		{
			while (builder._UndefinedAttributeTypes != null)
			{
				XmlQualifiedName xmlQualifiedName = builder._UndefinedAttributeTypes._TypeName;
				if (xmlQualifiedName.Namespace.Length == 0)
				{
					xmlQualifiedName = new XmlQualifiedName(xmlQualifiedName.Name, builder._TargetNamespace);
				}
				SchemaAttDef schemaAttDef = (SchemaAttDef)builder._SchemaInfo.AttributeDecls[xmlQualifiedName];
				if (schemaAttDef != null)
				{
					builder._UndefinedAttributeTypes._Attdef = schemaAttDef.Clone();
					builder._UndefinedAttributeTypes._Attdef.Name = xmlQualifiedName;
					builder.XDR_CheckAttributeDefault(builder._UndefinedAttributeTypes, builder._UndefinedAttributeTypes._Attdef);
				}
				else
				{
					builder.SendValidationEvent("Sch_UndeclaredAttribute", xmlQualifiedName.Name);
				}
				builder._UndefinedAttributeTypes = builder._UndefinedAttributeTypes._Next;
			}
			foreach (SchemaElementDecl value in builder._UndeclaredElements.Values)
			{
				builder.SendValidationEvent("Sch_UndeclaredElement", XmlQualifiedName.ToString(value.Name.Name, value.Prefix));
			}
		}

		private static void XDR_InitElementType(XdrBuilder builder, object obj)
		{
			builder._ElementDef._ElementDecl = new SchemaElementDecl();
			builder._contentValidator = new ParticleContentValidator(XmlSchemaContentType.Mixed);
			builder._contentValidator.IsOpen = true;
			builder._ElementDef._ContentAttr = 0;
			builder._ElementDef._OrderAttr = 0;
			builder._ElementDef._MasterGroupRequired = false;
			builder._ElementDef._ExistTerminal = false;
			builder._ElementDef._AllowDataType = true;
			builder._ElementDef._HasDataType = false;
			builder._ElementDef._EnumerationRequired = false;
			builder._ElementDef._AttDefList = new Hashtable();
			builder._ElementDef._MaxLength = uint.MaxValue;
			builder._ElementDef._MinLength = uint.MaxValue;
		}

		private static void XDR_BuildElementType_Name(XdrBuilder builder, object obj, string prefix)
		{
			XmlQualifiedName xmlQualifiedName = (XmlQualifiedName)obj;
			if (builder._SchemaInfo.ElementDecls[xmlQualifiedName] != null)
			{
				builder.SendValidationEvent("Sch_DupElementDecl", XmlQualifiedName.ToString(xmlQualifiedName.Name, prefix));
			}
			builder._ElementDef._ElementDecl.Name = xmlQualifiedName;
			builder._ElementDef._ElementDecl.Prefix = prefix;
			builder._SchemaInfo.ElementDecls.Add(xmlQualifiedName, builder._ElementDef._ElementDecl);
			if (builder._UndeclaredElements[xmlQualifiedName] != null)
			{
				builder._UndeclaredElements.Remove(xmlQualifiedName);
			}
		}

		private static void XDR_BuildElementType_Content(XdrBuilder builder, object obj, string prefix)
		{
			builder._ElementDef._ContentAttr = builder.GetContent((XmlQualifiedName)obj);
		}

		private static void XDR_BuildElementType_Model(XdrBuilder builder, object obj, string prefix)
		{
			builder._contentValidator.IsOpen = builder.GetModel((XmlQualifiedName)obj);
		}

		private static void XDR_BuildElementType_Order(XdrBuilder builder, object obj, string prefix)
		{
			builder._ElementDef._OrderAttr = (builder._GroupDef._Order = builder.GetOrder((XmlQualifiedName)obj));
		}

		private static void XDR_BuildElementType_DtType(XdrBuilder builder, object obj, string prefix)
		{
			builder._ElementDef._HasDataType = true;
			string text = ((string)obj).Trim();
			if (text.Length == 0)
			{
				builder.SendValidationEvent("Sch_MissDtvalue");
				return;
			}
			XmlSchemaDatatype xmlSchemaDatatype = XmlSchemaDatatype.FromXdrName(text);
			if (xmlSchemaDatatype == null)
			{
				builder.SendValidationEvent("Sch_UnknownDtType", text);
			}
			builder._ElementDef._ElementDecl.Datatype = xmlSchemaDatatype;
		}

		private static void XDR_BuildElementType_DtValues(XdrBuilder builder, object obj, string prefix)
		{
			builder._ElementDef._EnumerationRequired = true;
			builder._ElementDef._ElementDecl.Values = new ArrayList((string[])obj);
		}

		private static void XDR_BuildElementType_DtMaxLength(XdrBuilder builder, object obj, string prefix)
		{
			ParseDtMaxLength(ref builder._ElementDef._MaxLength, obj, builder);
		}

		private static void XDR_BuildElementType_DtMinLength(XdrBuilder builder, object obj, string prefix)
		{
			ParseDtMinLength(ref builder._ElementDef._MinLength, obj, builder);
		}

		private static void XDR_BeginElementType(XdrBuilder builder)
		{
			string text = null;
			string msg = null;
			if (builder._ElementDef._ElementDecl.Name.IsEmpty)
			{
				text = "Sch_MissAttribute";
				msg = "name";
			}
			else
			{
				if (builder._ElementDef._HasDataType)
				{
					if (!builder._ElementDef._AllowDataType)
					{
						text = "Sch_DataTypeTextOnly";
						goto IL_01f4;
					}
					builder._ElementDef._ContentAttr = 2;
				}
				else if (builder._ElementDef._ContentAttr == 0)
				{
					switch (builder._ElementDef._OrderAttr)
					{
					case 0:
						builder._ElementDef._ContentAttr = 3;
						builder._ElementDef._OrderAttr = 1;
						break;
					case 2:
						builder._ElementDef._ContentAttr = 4;
						break;
					case 3:
						builder._ElementDef._ContentAttr = 4;
						break;
					case 1:
						builder._ElementDef._ContentAttr = 3;
						break;
					}
				}
				bool isOpen = builder._contentValidator.IsOpen;
				ElementContent elementDef = builder._ElementDef;
				switch (builder._ElementDef._ContentAttr)
				{
				case 2:
					builder._ElementDef._ElementDecl.ContentValidator = ContentValidator.TextOnly;
					builder._GroupDef._Order = 1;
					builder._contentValidator = null;
					goto default;
				case 4:
					builder._contentValidator = new ParticleContentValidator(XmlSchemaContentType.ElementOnly);
					if (elementDef._OrderAttr == 0)
					{
						builder._GroupDef._Order = 2;
					}
					elementDef._MasterGroupRequired = true;
					builder._contentValidator.IsOpen = isOpen;
					goto default;
				case 1:
					builder._ElementDef._ElementDecl.ContentValidator = ContentValidator.Empty;
					builder._contentValidator = null;
					goto default;
				case 3:
					if (elementDef._OrderAttr == 0 || elementDef._OrderAttr == 1)
					{
						builder._GroupDef._Order = 1;
						elementDef._MasterGroupRequired = true;
						builder._contentValidator.IsOpen = isOpen;
						goto default;
					}
					text = "Sch_MixedMany";
					break;
				default:
					if (elementDef._ContentAttr == 3 || elementDef._ContentAttr == 4)
					{
						builder._contentValidator.Start();
						builder._contentValidator.OpenGroup();
					}
					break;
				}
			}
			goto IL_01f4;
			IL_01f4:
			if (text != null)
			{
				builder.SendValidationEvent(text, msg);
			}
		}

		private static void XDR_EndElementType(XdrBuilder builder)
		{
			SchemaElementDecl elementDecl = builder._ElementDef._ElementDecl;
			elementDecl?.EndAddAttDef();
			if (builder._UndefinedAttributeTypes != null && builder._ElementDef._AttDefList != null)
			{
				DeclBaseInfo declBaseInfo = builder._UndefinedAttributeTypes;
				DeclBaseInfo declBaseInfo2 = declBaseInfo;
				while (declBaseInfo != null)
				{
					SchemaAttDef schemaAttDef = null;
					if (declBaseInfo._ElementDecl == elementDecl)
					{
						XmlQualifiedName typeName = declBaseInfo._TypeName;
						schemaAttDef = (SchemaAttDef)builder._ElementDef._AttDefList[typeName];
						if (schemaAttDef != null)
						{
							declBaseInfo._Attdef = schemaAttDef.Clone();
							declBaseInfo._Attdef.Name = typeName;
							builder.XDR_CheckAttributeDefault(declBaseInfo, schemaAttDef);
							if (declBaseInfo == builder._UndefinedAttributeTypes)
							{
								declBaseInfo = (builder._UndefinedAttributeTypes = declBaseInfo._Next);
								declBaseInfo2 = declBaseInfo;
							}
							else
							{
								declBaseInfo2._Next = declBaseInfo._Next;
								declBaseInfo = declBaseInfo2._Next;
							}
						}
					}
					if (schemaAttDef == null)
					{
						if (declBaseInfo != builder._UndefinedAttributeTypes)
						{
							declBaseInfo2 = declBaseInfo2._Next;
						}
						declBaseInfo = declBaseInfo._Next;
					}
				}
			}
			if (builder._ElementDef._MasterGroupRequired)
			{
				builder._contentValidator.CloseGroup();
				if (!builder._ElementDef._ExistTerminal)
				{
					if (builder._contentValidator.IsOpen)
					{
						builder._ElementDef._ElementDecl.ContentValidator = ContentValidator.Any;
						builder._contentValidator = null;
					}
					else if (builder._ElementDef._ContentAttr != 3)
					{
						builder.SendValidationEvent("Sch_ElementMissing");
					}
				}
				else if (builder._GroupDef._Order == 1)
				{
					builder._contentValidator.AddStar();
				}
			}
			if (elementDecl.Datatype != null)
			{
				XmlTokenizedType tokenizedType = elementDecl.Datatype.TokenizedType;
				if (tokenizedType == XmlTokenizedType.ENUMERATION && !builder._ElementDef._EnumerationRequired)
				{
					builder.SendValidationEvent("Sch_MissDtvaluesAttribute");
				}
				if (tokenizedType != XmlTokenizedType.ENUMERATION && builder._ElementDef._EnumerationRequired)
				{
					builder.SendValidationEvent("Sch_RequireEnumeration");
				}
			}
			CompareMinMaxLength(builder._ElementDef._MinLength, builder._ElementDef._MaxLength, builder);
			elementDecl.MaxLength = builder._ElementDef._MaxLength;
			elementDecl.MinLength = builder._ElementDef._MinLength;
			if (builder._contentValidator != null)
			{
				builder._ElementDef._ElementDecl.ContentValidator = builder._contentValidator.Finish(useDFA: true);
				builder._contentValidator = null;
			}
			builder._ElementDef._ElementDecl = null;
			builder._ElementDef._AttDefList = null;
		}

		private static void XDR_InitAttributeType(XdrBuilder builder, object obj)
		{
			AttributeContent attributeDef = builder._AttributeDef;
			attributeDef._AttDef = new SchemaAttDef(XmlQualifiedName.Empty, null);
			attributeDef._Required = false;
			attributeDef._Prefix = null;
			attributeDef._Default = null;
			attributeDef._MinVal = 0u;
			attributeDef._MaxVal = 1u;
			attributeDef._EnumerationRequired = false;
			attributeDef._HasDataType = false;
			attributeDef._Global = builder._StateHistory.Length == 2;
			attributeDef._MaxLength = uint.MaxValue;
			attributeDef._MinLength = uint.MaxValue;
		}

		private static void XDR_BuildAttributeType_Name(XdrBuilder builder, object obj, string prefix)
		{
			XmlQualifiedName xmlQualifiedName = (XmlQualifiedName)obj;
			builder._AttributeDef._Name = xmlQualifiedName;
			builder._AttributeDef._Prefix = prefix;
			builder._AttributeDef._AttDef.Name = xmlQualifiedName;
			if (builder._ElementDef._ElementDecl != null)
			{
				if (builder._ElementDef._AttDefList[xmlQualifiedName] == null)
				{
					builder._ElementDef._AttDefList.Add(xmlQualifiedName, builder._AttributeDef._AttDef);
				}
				else
				{
					builder.SendValidationEvent("Sch_DupAttribute", XmlQualifiedName.ToString(xmlQualifiedName.Name, prefix));
				}
				return;
			}
			xmlQualifiedName = new XmlQualifiedName(xmlQualifiedName.Name, builder._TargetNamespace);
			builder._AttributeDef._AttDef.Name = xmlQualifiedName;
			if (builder._SchemaInfo.AttributeDecls[xmlQualifiedName] == null)
			{
				builder._SchemaInfo.AttributeDecls.Add(xmlQualifiedName, builder._AttributeDef._AttDef);
			}
			else
			{
				builder.SendValidationEvent("Sch_DupAttribute", XmlQualifiedName.ToString(xmlQualifiedName.Name, prefix));
			}
		}

		private static void XDR_BuildAttributeType_Required(XdrBuilder builder, object obj, string prefix)
		{
			builder._AttributeDef._Required = IsYes(obj, builder);
		}

		private static void XDR_BuildAttributeType_Default(XdrBuilder builder, object obj, string prefix)
		{
			builder._AttributeDef._Default = obj;
		}

		private static void XDR_BuildAttributeType_DtType(XdrBuilder builder, object obj, string prefix)
		{
			XmlQualifiedName xmlQualifiedName = (XmlQualifiedName)obj;
			builder._AttributeDef._HasDataType = true;
			builder._AttributeDef._AttDef.Datatype = builder.CheckDatatype(xmlQualifiedName.Name);
		}

		private static void XDR_BuildAttributeType_DtValues(XdrBuilder builder, object obj, string prefix)
		{
			builder._AttributeDef._EnumerationRequired = true;
			builder._AttributeDef._AttDef.Values = new ArrayList((string[])obj);
		}

		private static void XDR_BuildAttributeType_DtMaxLength(XdrBuilder builder, object obj, string prefix)
		{
			ParseDtMaxLength(ref builder._AttributeDef._MaxLength, obj, builder);
		}

		private static void XDR_BuildAttributeType_DtMinLength(XdrBuilder builder, object obj, string prefix)
		{
			ParseDtMinLength(ref builder._AttributeDef._MinLength, obj, builder);
		}

		private static void XDR_BeginAttributeType(XdrBuilder builder)
		{
			if (builder._AttributeDef._Name.IsEmpty)
			{
				builder.SendValidationEvent("Sch_MissAttribute");
			}
		}

		private static void XDR_EndAttributeType(XdrBuilder builder)
		{
			string text = null;
			if (builder._AttributeDef._HasDataType && builder._AttributeDef._AttDef.Datatype != null)
			{
				XmlTokenizedType tokenizedType = builder._AttributeDef._AttDef.Datatype.TokenizedType;
				if (tokenizedType == XmlTokenizedType.ENUMERATION && !builder._AttributeDef._EnumerationRequired)
				{
					text = "Sch_MissDtvaluesAttribute";
				}
				else if (tokenizedType != XmlTokenizedType.ENUMERATION && builder._AttributeDef._EnumerationRequired)
				{
					text = "Sch_RequireEnumeration";
				}
				else
				{
					if (builder._AttributeDef._Default == null || tokenizedType != XmlTokenizedType.ID)
					{
						goto IL_00a3;
					}
					text = "Sch_DefaultIdValue";
				}
				goto IL_0164;
			}
			builder._AttributeDef._AttDef.Datatype = XmlSchemaDatatype.FromXmlTokenizedType(XmlTokenizedType.CDATA);
			goto IL_00a3;
			IL_00a3:
			CompareMinMaxLength(builder._AttributeDef._MinLength, builder._AttributeDef._MaxLength, builder);
			builder._AttributeDef._AttDef.MaxLength = builder._AttributeDef._MaxLength;
			builder._AttributeDef._AttDef.MinLength = builder._AttributeDef._MinLength;
			if (builder._AttributeDef._Default != null)
			{
				string text4 = (builder._AttributeDef._AttDef.DefaultValueRaw = (builder._AttributeDef._AttDef.DefaultValueExpanded = (string)builder._AttributeDef._Default));
				builder.CheckDefaultAttValue(builder._AttributeDef._AttDef);
			}
			builder.SetAttributePresence(builder._AttributeDef._AttDef, builder._AttributeDef._Required);
			goto IL_0164;
			IL_0164:
			if (text != null)
			{
				builder.SendValidationEvent(text);
			}
		}

		private static void XDR_InitElement(XdrBuilder builder, object obj)
		{
			if (builder._ElementDef._HasDataType || builder._ElementDef._ContentAttr == 1 || builder._ElementDef._ContentAttr == 2)
			{
				builder.SendValidationEvent("Sch_ElementNotAllowed");
			}
			builder._ElementDef._AllowDataType = false;
			builder._ElementDef._HasType = false;
			builder._ElementDef._MinVal = 1u;
			builder._ElementDef._MaxVal = 1u;
		}

		private static void XDR_BuildElement_Type(XdrBuilder builder, object obj, string prefix)
		{
			XmlQualifiedName xmlQualifiedName = (XmlQualifiedName)obj;
			if (builder._SchemaInfo.ElementDecls[xmlQualifiedName] == null)
			{
				SchemaElementDecl schemaElementDecl = (SchemaElementDecl)builder._UndeclaredElements[xmlQualifiedName];
				if (schemaElementDecl == null)
				{
					schemaElementDecl = new SchemaElementDecl(xmlQualifiedName, prefix, SchemaType.DTD);
					builder._UndeclaredElements.Add(xmlQualifiedName, schemaElementDecl);
				}
			}
			builder._ElementDef._HasType = true;
			if (builder._ElementDef._ExistTerminal)
			{
				builder.AddOrder();
			}
			else
			{
				builder._ElementDef._ExistTerminal = true;
			}
			builder._contentValidator.AddName(xmlQualifiedName, null);
		}

		private static void XDR_BuildElement_MinOccurs(XdrBuilder builder, object obj, string prefix)
		{
			builder._ElementDef._MinVal = ParseMinOccurs(obj, builder);
		}

		private static void XDR_BuildElement_MaxOccurs(XdrBuilder builder, object obj, string prefix)
		{
			builder._ElementDef._MaxVal = ParseMaxOccurs(obj, builder);
		}

		private static void XDR_EndElement(XdrBuilder builder)
		{
			if (builder._ElementDef._HasType)
			{
				HandleMinMax(builder._contentValidator, builder._ElementDef._MinVal, builder._ElementDef._MaxVal);
			}
			else
			{
				builder.SendValidationEvent("Sch_MissAttribute");
			}
		}

		private static void XDR_InitAttribute(XdrBuilder builder, object obj)
		{
			if (builder._BaseDecl == null)
			{
				builder._BaseDecl = new DeclBaseInfo();
			}
			builder._BaseDecl._MinOccurs = 0u;
		}

		private static void XDR_BuildAttribute_Type(XdrBuilder builder, object obj, string prefix)
		{
			builder._BaseDecl._TypeName = (XmlQualifiedName)obj;
			builder._BaseDecl._Prefix = prefix;
		}

		private static void XDR_BuildAttribute_Required(XdrBuilder builder, object obj, string prefix)
		{
			if (IsYes(obj, builder))
			{
				builder._BaseDecl._MinOccurs = 1u;
			}
		}

		private static void XDR_BuildAttribute_Default(XdrBuilder builder, object obj, string prefix)
		{
			builder._BaseDecl._Default = obj;
		}

		private static void XDR_BeginAttribute(XdrBuilder builder)
		{
			if (builder._BaseDecl._TypeName.IsEmpty)
			{
				builder.SendValidationEvent("Sch_MissAttribute");
			}
			SchemaAttDef schemaAttDef = null;
			XmlQualifiedName typeName = builder._BaseDecl._TypeName;
			string prefix = builder._BaseDecl._Prefix;
			if (builder._ElementDef._AttDefList != null)
			{
				schemaAttDef = (SchemaAttDef)builder._ElementDef._AttDefList[typeName];
			}
			if (schemaAttDef == null)
			{
				XmlQualifiedName key = typeName;
				if (prefix.Length == 0)
				{
					key = new XmlQualifiedName(typeName.Name, builder._TargetNamespace);
				}
				SchemaAttDef schemaAttDef2 = (SchemaAttDef)builder._SchemaInfo.AttributeDecls[key];
				if (schemaAttDef2 != null)
				{
					schemaAttDef = schemaAttDef2.Clone();
					schemaAttDef.Name = typeName;
				}
				else if (prefix.Length != 0)
				{
					builder.SendValidationEvent("Sch_UndeclaredAttribute", XmlQualifiedName.ToString(typeName.Name, prefix));
				}
			}
			if (schemaAttDef != null)
			{
				builder.XDR_CheckAttributeDefault(builder._BaseDecl, schemaAttDef);
			}
			else
			{
				schemaAttDef = new SchemaAttDef(typeName, prefix);
				DeclBaseInfo declBaseInfo = new DeclBaseInfo();
				declBaseInfo._Checking = true;
				declBaseInfo._Attdef = schemaAttDef;
				declBaseInfo._TypeName = builder._BaseDecl._TypeName;
				declBaseInfo._ElementDecl = builder._ElementDef._ElementDecl;
				declBaseInfo._MinOccurs = builder._BaseDecl._MinOccurs;
				declBaseInfo._Default = builder._BaseDecl._Default;
				declBaseInfo._Next = builder._UndefinedAttributeTypes;
				builder._UndefinedAttributeTypes = declBaseInfo;
			}
			builder._ElementDef._ElementDecl.AddAttDef(schemaAttDef);
		}

		private static void XDR_EndAttribute(XdrBuilder builder)
		{
			builder._BaseDecl.Reset();
		}

		private static void XDR_InitGroup(XdrBuilder builder, object obj)
		{
			if (builder._ElementDef._ContentAttr == 1 || builder._ElementDef._ContentAttr == 2)
			{
				builder.SendValidationEvent("Sch_GroupDisabled");
			}
			builder.PushGroupInfo();
			builder._GroupDef._MinVal = 1u;
			builder._GroupDef._MaxVal = 1u;
			builder._GroupDef._HasMaxAttr = false;
			builder._GroupDef._HasMinAttr = false;
			if (builder._ElementDef._ExistTerminal)
			{
				builder.AddOrder();
			}
			builder._ElementDef._ExistTerminal = false;
			builder._contentValidator.OpenGroup();
		}

		private static void XDR_BuildGroup_Order(XdrBuilder builder, object obj, string prefix)
		{
			builder._GroupDef._Order = builder.GetOrder((XmlQualifiedName)obj);
			if (builder._ElementDef._ContentAttr == 3 && builder._GroupDef._Order != 1)
			{
				builder.SendValidationEvent("Sch_MixedMany");
			}
		}

		private static void XDR_BuildGroup_MinOccurs(XdrBuilder builder, object obj, string prefix)
		{
			builder._GroupDef._MinVal = ParseMinOccurs(obj, builder);
			builder._GroupDef._HasMinAttr = true;
		}

		private static void XDR_BuildGroup_MaxOccurs(XdrBuilder builder, object obj, string prefix)
		{
			builder._GroupDef._MaxVal = ParseMaxOccurs(obj, builder);
			builder._GroupDef._HasMaxAttr = true;
		}

		private static void XDR_EndGroup(XdrBuilder builder)
		{
			if (!builder._ElementDef._ExistTerminal)
			{
				builder.SendValidationEvent("Sch_ElementMissing");
			}
			builder._contentValidator.CloseGroup();
			if (builder._GroupDef._Order == 1)
			{
				builder._contentValidator.AddStar();
			}
			if (1 == builder._GroupDef._Order && builder._GroupDef._HasMaxAttr && builder._GroupDef._MaxVal != uint.MaxValue)
			{
				builder.SendValidationEvent("Sch_ManyMaxOccurs");
			}
			HandleMinMax(builder._contentValidator, builder._GroupDef._MinVal, builder._GroupDef._MaxVal);
			builder.PopGroupInfo();
		}

		private static void XDR_InitElementDtType(XdrBuilder builder, object obj)
		{
			if (builder._ElementDef._HasDataType)
			{
				builder.SendValidationEvent("Sch_DupDtType");
			}
			if (!builder._ElementDef._AllowDataType)
			{
				builder.SendValidationEvent("Sch_DataTypeTextOnly");
			}
		}

		private static void XDR_EndElementDtType(XdrBuilder builder)
		{
			if (!builder._ElementDef._HasDataType)
			{
				builder.SendValidationEvent("Sch_MissAttribute");
			}
			builder._ElementDef._ElementDecl.ContentValidator = ContentValidator.TextOnly;
			builder._ElementDef._ContentAttr = 2;
			builder._ElementDef._MasterGroupRequired = false;
			builder._contentValidator = null;
		}

		private static void XDR_InitAttributeDtType(XdrBuilder builder, object obj)
		{
			if (builder._AttributeDef._HasDataType)
			{
				builder.SendValidationEvent("Sch_DupDtType");
			}
		}

		private static void XDR_EndAttributeDtType(XdrBuilder builder)
		{
			string text = null;
			if (!builder._AttributeDef._HasDataType)
			{
				text = "Sch_MissAttribute";
			}
			else if (builder._AttributeDef._AttDef.Datatype != null)
			{
				XmlTokenizedType tokenizedType = builder._AttributeDef._AttDef.Datatype.TokenizedType;
				if (tokenizedType == XmlTokenizedType.ENUMERATION && !builder._AttributeDef._EnumerationRequired)
				{
					text = "Sch_MissDtvaluesAttribute";
				}
				else if (tokenizedType != XmlTokenizedType.ENUMERATION && builder._AttributeDef._EnumerationRequired)
				{
					text = "Sch_RequireEnumeration";
				}
			}
			if (text != null)
			{
				builder.SendValidationEvent(text);
			}
		}

		private bool GetNextState(XmlQualifiedName qname)
		{
			if (_CurState._NextStates != null)
			{
				for (int i = 0; i < _CurState._NextStates.Length; i++)
				{
					if (_SchemaNames.TokenToQName[(int)S_SchemaEntries[_CurState._NextStates[i]]._Name].Equals(qname))
					{
						_NextState = S_SchemaEntries[_CurState._NextStates[i]];
						return true;
					}
				}
			}
			return false;
		}

		private bool IsSkipableElement(XmlQualifiedName qname)
		{
			string @namespace = qname.Namespace;
			if (@namespace != null && !Ref.Equal(@namespace, _SchemaNames.NsXdr))
			{
				return true;
			}
			if (_SchemaNames.TokenToQName[38].Equals(qname) || _SchemaNames.TokenToQName[39].Equals(qname))
			{
				return true;
			}
			return false;
		}

		private bool IsSkipableAttribute(XmlQualifiedName qname)
		{
			string @namespace = qname.Namespace;
			if (@namespace.Length != 0 && !Ref.Equal(@namespace, _SchemaNames.NsXdr) && !Ref.Equal(@namespace, _SchemaNames.NsDataType))
			{
				return true;
			}
			if (Ref.Equal(@namespace, _SchemaNames.NsDataType) && _CurState._Name == SchemaNames.Token.XdrDatatype && (_SchemaNames.QnDtMax.Equals(qname) || _SchemaNames.QnDtMin.Equals(qname) || _SchemaNames.QnDtMaxExclusive.Equals(qname) || _SchemaNames.QnDtMinExclusive.Equals(qname)))
			{
				return true;
			}
			return false;
		}

		private int GetOrder(XmlQualifiedName qname)
		{
			int result = 0;
			if (_SchemaNames.TokenToQName[15].Equals(qname))
			{
				result = 2;
			}
			else if (_SchemaNames.TokenToQName[16].Equals(qname))
			{
				result = 3;
			}
			else if (_SchemaNames.TokenToQName[17].Equals(qname))
			{
				result = 1;
			}
			else
			{
				SendValidationEvent("Sch_UnknownOrder", qname.Name);
			}
			return result;
		}

		private void AddOrder()
		{
			switch (_GroupDef._Order)
			{
			case 2:
				_contentValidator.AddSequence();
				break;
			case 1:
			case 3:
				_contentValidator.AddChoice();
				break;
			default:
				throw new XmlException("Xml_UnexpectedToken", "NAME");
			}
		}

		private static bool IsYes(object obj, XdrBuilder builder)
		{
			XmlQualifiedName xmlQualifiedName = (XmlQualifiedName)obj;
			bool result = false;
			if (xmlQualifiedName.Name == "yes")
			{
				result = true;
			}
			else if (xmlQualifiedName.Name != "no")
			{
				builder.SendValidationEvent("Sch_UnknownRequired");
			}
			return result;
		}

		private static uint ParseMinOccurs(object obj, XdrBuilder builder)
		{
			uint n = 1u;
			if (!ParseInteger((string)obj, ref n) || (n != 0 && n != 1))
			{
				builder.SendValidationEvent("Sch_MinOccursInvalid");
			}
			return n;
		}

		private static uint ParseMaxOccurs(object obj, XdrBuilder builder)
		{
			uint n = uint.MaxValue;
			string text = (string)obj;
			if (!text.Equals("*") && (!ParseInteger(text, ref n) || (n != uint.MaxValue && n != 1)))
			{
				builder.SendValidationEvent("Sch_MaxOccursInvalid");
			}
			return n;
		}

		private static void HandleMinMax(ParticleContentValidator pContent, uint cMin, uint cMax)
		{
			if (pContent == null)
			{
				return;
			}
			if (cMax == uint.MaxValue)
			{
				if (cMin == 0)
				{
					pContent.AddStar();
				}
				else
				{
					pContent.AddPlus();
				}
			}
			else if (cMin == 0)
			{
				pContent.AddQMark();
			}
		}

		private static void ParseDtMaxLength(ref uint cVal, object obj, XdrBuilder builder)
		{
			if (-1 != (int)cVal)
			{
				builder.SendValidationEvent("Sch_DupDtMaxLength");
			}
			if (!ParseInteger((string)obj, ref cVal) || cVal < 0)
			{
				builder.SendValidationEvent("Sch_DtMaxLengthInvalid", obj.ToString());
			}
		}

		private static void ParseDtMinLength(ref uint cVal, object obj, XdrBuilder builder)
		{
			if (-1 != (int)cVal)
			{
				builder.SendValidationEvent("Sch_DupDtMinLength");
			}
			if (!ParseInteger((string)obj, ref cVal) || cVal < 0)
			{
				builder.SendValidationEvent("Sch_DtMinLengthInvalid", obj.ToString());
			}
		}

		private static void CompareMinMaxLength(uint cMin, uint cMax, XdrBuilder builder)
		{
			if (cMin != uint.MaxValue && cMax != uint.MaxValue && cMin > cMax)
			{
				builder.SendValidationEvent("Sch_DtMinMaxLength");
			}
		}

		private static bool ParseInteger(string str, ref uint n)
		{
			return uint.TryParse(str, NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite, NumberFormatInfo.InvariantInfo, out n);
		}

		private void XDR_CheckAttributeDefault(DeclBaseInfo decl, SchemaAttDef pAttdef)
		{
			if ((decl._Default != null || pAttdef.DefaultValueTyped != null) && decl._Default != null)
			{
				string text3 = (pAttdef.DefaultValueRaw = (pAttdef.DefaultValueExpanded = (string)decl._Default));
				CheckDefaultAttValue(pAttdef);
			}
			SetAttributePresence(pAttdef, 1 == decl._MinOccurs);
		}

		private void SetAttributePresence(SchemaAttDef pAttdef, bool fRequired)
		{
			if (SchemaDeclBase.Use.Fixed == pAttdef.Presence)
			{
				return;
			}
			if (fRequired || SchemaDeclBase.Use.Required == pAttdef.Presence)
			{
				if (pAttdef.DefaultValueTyped != null)
				{
					pAttdef.Presence = SchemaDeclBase.Use.Fixed;
				}
				else
				{
					pAttdef.Presence = SchemaDeclBase.Use.Required;
				}
			}
			else if (pAttdef.DefaultValueTyped != null)
			{
				pAttdef.Presence = SchemaDeclBase.Use.Default;
			}
			else
			{
				pAttdef.Presence = SchemaDeclBase.Use.Implied;
			}
		}

		private int GetContent(XmlQualifiedName qname)
		{
			int result = 0;
			if (_SchemaNames.TokenToQName[11].Equals(qname))
			{
				result = 1;
				_ElementDef._AllowDataType = false;
			}
			else if (_SchemaNames.TokenToQName[12].Equals(qname))
			{
				result = 4;
				_ElementDef._AllowDataType = false;
			}
			else if (_SchemaNames.TokenToQName[10].Equals(qname))
			{
				result = 3;
				_ElementDef._AllowDataType = false;
			}
			else if (_SchemaNames.TokenToQName[13].Equals(qname))
			{
				result = 2;
			}
			else
			{
				SendValidationEvent("Sch_UnknownContent", qname.Name);
			}
			return result;
		}

		private bool GetModel(XmlQualifiedName qname)
		{
			bool result = false;
			if (_SchemaNames.TokenToQName[7].Equals(qname))
			{
				result = true;
			}
			else if (_SchemaNames.TokenToQName[8].Equals(qname))
			{
				result = false;
			}
			else
			{
				SendValidationEvent("Sch_UnknownModel", qname.Name);
			}
			return result;
		}

		private XmlSchemaDatatype CheckDatatype(string str)
		{
			XmlSchemaDatatype xmlSchemaDatatype = XmlSchemaDatatype.FromXdrName(str);
			if (xmlSchemaDatatype == null)
			{
				SendValidationEvent("Sch_UnknownDtType", str);
			}
			else if (xmlSchemaDatatype.TokenizedType == XmlTokenizedType.ID && !_AttributeDef._Global)
			{
				if (_ElementDef._ElementDecl.IsIdDeclared)
				{
					SendValidationEvent("Sch_IdAttrDeclared", XmlQualifiedName.ToString(_ElementDef._ElementDecl.Name.Name, _ElementDef._ElementDecl.Prefix));
				}
				_ElementDef._ElementDecl.IsIdDeclared = true;
			}
			return xmlSchemaDatatype;
		}

		private void CheckDefaultAttValue(SchemaAttDef attDef)
		{
			string value = attDef.DefaultValueRaw.Trim();
			XdrValidator.CheckDefaultValue(value, attDef, _SchemaInfo, _CurNsMgr, _NameTable, null, validationEventHandler, _reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition);
		}

		private bool IsGlobal(int flags)
		{
			return flags == 256;
		}

		private void SendValidationEvent(string code, string[] args, XmlSeverityType severity)
		{
			SendValidationEvent(new XmlSchemaException(code, args, _reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition), severity);
		}

		private void SendValidationEvent(string code)
		{
			SendValidationEvent(code, string.Empty);
		}

		private void SendValidationEvent(string code, string msg)
		{
			SendValidationEvent(new XmlSchemaException(code, msg, _reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition), XmlSeverityType.Error);
		}

		private void SendValidationEvent(XmlSchemaException e, XmlSeverityType severity)
		{
			_SchemaInfo.ErrorCount++;
			if (validationEventHandler != null)
			{
				validationEventHandler(this, new ValidationEventArgs(e, severity));
			}
			else if (severity == XmlSeverityType.Error)
			{
				throw e;
			}
		}
	}
	internal sealed class XdrValidator : BaseValidator
	{
		private const int STACK_INCREMENT = 10;

		private const string x_schema = "x-schema:";

		private HWStack validationStack;

		private Hashtable attPresence;

		private XmlQualifiedName name = XmlQualifiedName.Empty;

		private XmlNamespaceManager nsManager;

		private bool isProcessContents;

		private Hashtable IDs;

		private IdRefNode idRefListHead;

		private Parser inlineSchemaParser;

		private bool IsInlineSchemaStarted => inlineSchemaParser != null;

		private bool HasSchema => schemaInfo.SchemaType != SchemaType.None;

		public override bool PreserveWhitespace
		{
			get
			{
				if (context.ElementDecl == null)
				{
					return false;
				}
				return context.ElementDecl.ContentValidator.PreserveWhitespace;
			}
		}

		internal XdrValidator(BaseValidator validator)
			: base(validator)
		{
			Init();
		}

		internal XdrValidator(XmlValidatingReaderImpl reader, XmlSchemaCollection schemaCollection, ValidationEventHandler eventHandler)
			: base(reader, schemaCollection, eventHandler)
		{
			Init();
		}

		private void Init()
		{
			nsManager = reader.NamespaceManager;
			if (nsManager == null)
			{
				nsManager = new XmlNamespaceManager(base.NameTable);
				isProcessContents = true;
			}
			validationStack = new HWStack(10);
			textValue = new StringBuilder();
			name = XmlQualifiedName.Empty;
			attPresence = new Hashtable();
			Push(XmlQualifiedName.Empty);
			schemaInfo = new SchemaInfo();
			checkDatatype = false;
		}

		public override void Validate()
		{
			if (IsInlineSchemaStarted)
			{
				ProcessInlineSchema();
				return;
			}
			switch (reader.NodeType)
			{
			case XmlNodeType.Element:
				ValidateElement();
				if (reader.IsEmptyElement)
				{
					goto case XmlNodeType.EndElement;
				}
				break;
			case XmlNodeType.Whitespace:
				ValidateWhitespace();
				break;
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.SignificantWhitespace:
				ValidateText();
				break;
			case XmlNodeType.EndElement:
				ValidateEndElement();
				break;
			}
		}

		private void ValidateElement()
		{
			elementName.Init(reader.LocalName, XmlSchemaDatatype.XdrCanonizeUri(reader.NamespaceURI, base.NameTable, base.SchemaNames));
			ValidateChildElement();
			if (base.SchemaNames.IsXDRRoot(elementName.Name, elementName.Namespace) && reader.Depth > 0)
			{
				inlineSchemaParser = new Parser(SchemaType.XDR, base.NameTable, base.SchemaNames, base.EventHandler);
				inlineSchemaParser.StartParsing(reader, null);
				inlineSchemaParser.ParseReaderNode();
			}
			else
			{
				ProcessElement();
			}
		}

		private void ValidateChildElement()
		{
			if (context.NeedValidateChildren)
			{
				int errorCode = 0;
				context.ElementDecl.ContentValidator.ValidateElement(elementName, context, out errorCode);
				if (errorCode < 0)
				{
					XmlSchemaValidator.ElementValidationError(elementName, context, base.EventHandler, reader, reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition, getParticles: false);
				}
			}
		}

		private void ProcessInlineSchema()
		{
			if (inlineSchemaParser.ParseReaderNode())
			{
				return;
			}
			inlineSchemaParser.FinishParsing();
			SchemaInfo xdrSchema = inlineSchemaParser.XdrSchema;
			if (xdrSchema != null && xdrSchema.ErrorCount == 0)
			{
				foreach (string key in xdrSchema.TargetNamespaces.Keys)
				{
					if (!base.SchemaInfo.HasSchema(key))
					{
						schemaInfo.Add(xdrSchema, base.EventHandler);
						base.SchemaCollection.Add(key, xdrSchema, null, compile: false);
						break;
					}
				}
			}
			inlineSchemaParser = null;
		}

		private void ProcessElement()
		{
			Push(elementName);
			if (isProcessContents)
			{
				nsManager.PopScope();
			}
			context.ElementDecl = ThoroughGetElementDecl();
			if (context.ElementDecl != null)
			{
				ValidateStartElement();
				ValidateEndStartElement();
				context.NeedValidateChildren = true;
				context.ElementDecl.ContentValidator.InitValidation(context);
			}
		}

		private void ValidateEndElement()
		{
			if (isProcessContents)
			{
				nsManager.PopScope();
			}
			if (context.ElementDecl != null)
			{
				if (context.NeedValidateChildren && !context.ElementDecl.ContentValidator.CompleteValidation(context))
				{
					XmlSchemaValidator.CompleteValidationError(context, base.EventHandler, reader, reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition, getParticles: false);
				}
				if (checkDatatype)
				{
					string value = ((!hasSibling) ? textString : textValue.ToString());
					CheckValue(value, null);
					checkDatatype = false;
					textValue.Length = 0;
					textString = string.Empty;
				}
			}
			Pop();
		}

		private SchemaElementDecl ThoroughGetElementDecl()
		{
			if (reader.Depth == 0)
			{
				LoadSchema(string.Empty);
			}
			if (reader.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = reader.NamespaceURI;
					string localName = reader.LocalName;
					if (Ref.Equal(namespaceURI, base.SchemaNames.NsXmlNs))
					{
						LoadSchema(reader.Value);
						if (isProcessContents)
						{
							nsManager.AddNamespace((reader.Prefix.Length == 0) ? string.Empty : reader.LocalName, reader.Value);
						}
					}
					if (Ref.Equal(namespaceURI, base.SchemaNames.QnDtDt.Namespace) && Ref.Equal(localName, base.SchemaNames.QnDtDt.Name))
					{
						reader.SchemaTypeObject = XmlSchemaDatatype.FromXdrName(reader.Value);
					}
				}
				while (reader.MoveToNextAttribute());
				reader.MoveToElement();
			}
			SchemaElementDecl elementDecl = schemaInfo.GetElementDecl(elementName);
			if (elementDecl == null && schemaInfo.TargetNamespaces.Contains(context.Namespace))
			{
				SendValidationEvent("Sch_UndeclaredElement", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
			}
			return elementDecl;
		}

		private void ValidateStartElement()
		{
			if (context.ElementDecl != null)
			{
				if (context.ElementDecl.SchemaType != null)
				{
					reader.SchemaTypeObject = context.ElementDecl.SchemaType;
				}
				else
				{
					reader.SchemaTypeObject = context.ElementDecl.Datatype;
				}
				if (reader.IsEmptyElement && !context.IsNill && context.ElementDecl.DefaultValueTyped != null)
				{
					reader.TypedValueObject = context.ElementDecl.DefaultValueTyped;
					context.IsNill = true;
				}
				if (context.ElementDecl.HasRequiredAttribute)
				{
					attPresence.Clear();
				}
			}
			if (!reader.MoveToFirstAttribute())
			{
				return;
			}
			do
			{
				if ((object)reader.NamespaceURI == base.SchemaNames.NsXmlNs)
				{
					continue;
				}
				try
				{
					reader.SchemaTypeObject = null;
					SchemaAttDef attributeXdr = schemaInfo.GetAttributeXdr(context.ElementDecl, QualifiedName(reader.LocalName, reader.NamespaceURI));
					if (attributeXdr != null)
					{
						if (context.ElementDecl != null && context.ElementDecl.HasRequiredAttribute)
						{
							attPresence.Add(attributeXdr.Name, attributeXdr);
						}
						reader.SchemaTypeObject = ((attributeXdr.SchemaType != null) ? ((object)attributeXdr.SchemaType) : ((object)attributeXdr.Datatype));
						if (attributeXdr.Datatype != null)
						{
							string value = reader.Value;
							CheckValue(value, attributeXdr);
						}
					}
				}
				catch (XmlSchemaException ex)
				{
					ex.SetSource(reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
					SendValidationEvent(ex);
				}
			}
			while (reader.MoveToNextAttribute());
			reader.MoveToElement();
		}

		private void ValidateEndStartElement()
		{
			if (context.ElementDecl.HasDefaultAttribute)
			{
				SchemaAttDef[] defaultAttDefs = context.ElementDecl.DefaultAttDefs;
				foreach (SchemaAttDef attdef in defaultAttDefs)
				{
					reader.AddDefaultAttribute(attdef);
				}
			}
			if (context.ElementDecl.HasRequiredAttribute)
			{
				try
				{
					context.ElementDecl.CheckAttributes(attPresence, reader.StandAlone);
				}
				catch (XmlSchemaException ex)
				{
					ex.SetSource(reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
					SendValidationEvent(ex);
				}
			}
			if (context.ElementDecl.Datatype != null)
			{
				checkDatatype = true;
				hasSibling = false;
				textString = string.Empty;
				textValue.Length = 0;
			}
		}

		private void LoadSchemaFromLocation(string uri)
		{
			if (!XdrBuilder.IsXdrSchema(uri))
			{
				return;
			}
			string relativeUri = uri.Substring("x-schema:".Length);
			XmlReader xmlReader = null;
			SchemaInfo schemaInfo = null;
			try
			{
				Uri uri2 = base.XmlResolver.ResolveUri(base.BaseUri, relativeUri);
				Stream input = (Stream)base.XmlResolver.GetEntity(uri2, null, null);
				xmlReader = new XmlTextReader(uri2.ToString(), input, base.NameTable);
				((XmlTextReader)xmlReader).XmlResolver = base.XmlResolver;
				Parser parser = new Parser(SchemaType.XDR, base.NameTable, base.SchemaNames, base.EventHandler);
				parser.XmlResolver = base.XmlResolver;
				parser.Parse(xmlReader, uri);
				while (xmlReader.Read())
				{
				}
				schemaInfo = parser.XdrSchema;
			}
			catch (XmlSchemaException ex)
			{
				SendValidationEvent("Sch_CannotLoadSchema", new string[2] { uri, ex.Message }, XmlSeverityType.Error);
			}
			catch (Exception ex2)
			{
				SendValidationEvent("Sch_CannotLoadSchema", new string[2] { uri, ex2.Message }, XmlSeverityType.Warning);
			}
			finally
			{
				xmlReader?.Close();
			}
			if (schemaInfo != null && schemaInfo.ErrorCount == 0)
			{
				base.schemaInfo.Add(schemaInfo, base.EventHandler);
				base.SchemaCollection.Add(uri, schemaInfo, null, compile: false);
			}
		}

		private void LoadSchema(string uri)
		{
			if (base.SchemaInfo.TargetNamespaces.Contains(uri) || base.XmlResolver == null)
			{
				return;
			}
			SchemaInfo schemaInfo = null;
			if (base.SchemaCollection != null)
			{
				schemaInfo = base.SchemaCollection.GetSchemaInfo(uri);
			}
			if (schemaInfo != null)
			{
				if (schemaInfo.SchemaType != SchemaType.XDR)
				{
					throw new XmlException("Xml_MultipleValidaitonTypes", string.Empty, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
				}
				base.SchemaInfo.Add(schemaInfo, base.EventHandler);
			}
			else
			{
				LoadSchemaFromLocation(uri);
			}
		}

		private void ProcessTokenizedType(XmlTokenizedType ttype, string name)
		{
			switch (ttype)
			{
			case XmlTokenizedType.ID:
				if (FindId(name) != null)
				{
					SendValidationEvent("Sch_DupId", name);
				}
				else
				{
					AddID(name, context.LocalName);
				}
				break;
			case XmlTokenizedType.IDREF:
			{
				object obj = FindId(name);
				if (obj == null)
				{
					idRefListHead = new IdRefNode(idRefListHead, name, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
				}
				break;
			}
			case XmlTokenizedType.ENTITY:
				BaseValidator.ProcessEntity(schemaInfo, name, this, base.EventHandler, reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
				break;
			case XmlTokenizedType.IDREFS:
				break;
			}
		}

		public override void CompleteValidation()
		{
			if (HasSchema)
			{
				CheckForwardRefs();
			}
			else
			{
				SendValidationEvent(new XmlSchemaException("Xml_NoValidation", string.Empty), XmlSeverityType.Warning);
			}
		}

		private void CheckValue(string value, SchemaAttDef attdef)
		{
			try
			{
				reader.TypedValueObject = null;
				bool flag = attdef != null;
				XmlSchemaDatatype xmlSchemaDatatype = (flag ? attdef.Datatype : context.ElementDecl.Datatype);
				if (xmlSchemaDatatype == null)
				{
					return;
				}
				if (xmlSchemaDatatype.TokenizedType != 0)
				{
					value = value.Trim();
				}
				if (value.Length == 0)
				{
					return;
				}
				object obj = xmlSchemaDatatype.ParseValue(value, base.NameTable, nsManager);
				reader.TypedValueObject = obj;
				XmlTokenizedType tokenizedType = xmlSchemaDatatype.TokenizedType;
				if (tokenizedType == XmlTokenizedType.ENTITY || tokenizedType == XmlTokenizedType.ID || tokenizedType == XmlTokenizedType.IDREF)
				{
					if (xmlSchemaDatatype.Variety == XmlSchemaDatatypeVariety.List)
					{
						string[] array = (string[])obj;
						string[] array2 = array;
						foreach (string text in array2)
						{
							ProcessTokenizedType(xmlSchemaDatatype.TokenizedType, text);
						}
					}
					else
					{
						ProcessTokenizedType(xmlSchemaDatatype.TokenizedType, (string)obj);
					}
				}
				SchemaDeclBase schemaDeclBase = (flag ? ((SchemaDeclBase)attdef) : ((SchemaDeclBase)context.ElementDecl));
				if (schemaDeclBase.MaxLength != uint.MaxValue && value.Length > schemaDeclBase.MaxLength)
				{
					SendValidationEvent("Sch_MaxLengthConstraintFailed", value);
				}
				if (schemaDeclBase.MinLength != uint.MaxValue && value.Length < schemaDeclBase.MinLength)
				{
					SendValidationEvent("Sch_MinLengthConstraintFailed", value);
				}
				if (schemaDeclBase.Values != null && !schemaDeclBase.CheckEnumeration(obj))
				{
					if (xmlSchemaDatatype.TokenizedType == XmlTokenizedType.NOTATION)
					{
						SendValidationEvent("Sch_NotationValue", obj.ToString());
					}
					else
					{
						SendValidationEvent("Sch_EnumerationValue", obj.ToString());
					}
				}
				if (!schemaDeclBase.CheckValue(obj))
				{
					if (flag)
					{
						SendValidationEvent("Sch_FixedAttributeValue", attdef.Name.ToString());
					}
					else
					{
						SendValidationEvent("Sch_FixedElementValue", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
					}
				}
			}
			catch (XmlSchemaException)
			{
				if (attdef != null)
				{
					SendValidationEvent("Sch_AttributeValueDataType", attdef.Name.ToString());
				}
				else
				{
					SendValidationEvent("Sch_ElementValueDataType", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
				}
			}
		}

		public static void CheckDefaultValue(string value, SchemaAttDef attdef, SchemaInfo sinfo, XmlNamespaceManager nsManager, XmlNameTable NameTable, object sender, ValidationEventHandler eventhandler, string baseUri, int lineNo, int linePos)
		{
			try
			{
				XmlSchemaDatatype datatype = attdef.Datatype;
				if (datatype == null)
				{
					return;
				}
				if (datatype.TokenizedType != 0)
				{
					value = value.Trim();
				}
				if (value.Length == 0)
				{
					return;
				}
				object obj = datatype.ParseValue(value, NameTable, nsManager);
				switch (datatype.TokenizedType)
				{
				case XmlTokenizedType.ENTITY:
					if (datatype.Variety == XmlSchemaDatatypeVariety.List)
					{
						string[] array = (string[])obj;
						string[] array2 = array;
						foreach (string text in array2)
						{
							BaseValidator.ProcessEntity(sinfo, text, sender, eventhandler, baseUri, lineNo, linePos);
						}
					}
					else
					{
						BaseValidator.ProcessEntity(sinfo, (string)obj, sender, eventhandler, baseUri, lineNo, linePos);
					}
					break;
				case XmlTokenizedType.ENUMERATION:
					if (!attdef.CheckEnumeration(obj))
					{
						XmlSchemaException ex = new XmlSchemaException("Sch_EnumerationValue", obj.ToString(), baseUri, lineNo, linePos);
						if (eventhandler == null)
						{
							throw ex;
						}
						eventhandler(sender, new ValidationEventArgs(ex));
					}
					break;
				}
				attdef.DefaultValueTyped = obj;
			}
			catch
			{
				XmlSchemaException ex2 = new XmlSchemaException("Sch_AttributeDefaultDataType", attdef.Name.ToString(), baseUri, lineNo, linePos);
				if (eventhandler != null)
				{
					eventhandler(sender, new ValidationEventArgs(ex2));
					return;
				}
				throw ex2;
			}
		}

		internal void AddID(string name, object node)
		{
			if (IDs == null)
			{
				IDs = new Hashtable();
			}
			IDs.Add(name, node);
		}

		public override object FindId(string name)
		{
			if (IDs != null)
			{
				return IDs[name];
			}
			return null;
		}

		private void Push(XmlQualifiedName elementName)
		{
			context = (ValidationState)validationStack.Push();
			if (context == null)
			{
				context = new ValidationState();
				validationStack.AddToTop(context);
			}
			context.LocalName = elementName.Name;
			context.Namespace = elementName.Namespace;
			context.HasMatched = false;
			context.IsNill = false;
			context.NeedValidateChildren = false;
		}

		private void Pop()
		{
			if (validationStack.Length > 1)
			{
				validationStack.Pop();
				context = (ValidationState)validationStack.Peek();
			}
		}

		private void CheckForwardRefs()
		{
			IdRefNode idRefNode = idRefListHead;
			while (idRefNode != null)
			{
				if (FindId(idRefNode.Id) == null)
				{
					SendValidationEvent(new XmlSchemaException("Sch_UndeclaredId", idRefNode.Id, reader.BaseURI, idRefNode.LineNo, idRefNode.LinePos));
				}
				IdRefNode next = idRefNode.Next;
				idRefNode.Next = null;
				idRefNode = next;
			}
			idRefListHead = null;
		}

		private XmlQualifiedName QualifiedName(string name, string ns)
		{
			return new XmlQualifiedName(name, XmlSchemaDatatype.XdrCanonizeUri(ns, base.NameTable, base.SchemaNames));
		}
	}
	public sealed class XmlAtomicValue : XPathItem, ICloneable
	{
		[StructLayout(LayoutKind.Explicit, Size = 8)]
		private struct Union
		{
			[FieldOffset(0)]
			public bool boolVal;

			[FieldOffset(0)]
			public double dblVal;

			[FieldOffset(0)]
			public long i64Val;

			[FieldOffset(0)]
			public int i32Val;

			[FieldOffset(0)]
			public DateTime dtVal;
		}

		private class NamespacePrefixForQName : IXmlNamespaceResolver
		{
			public string prefix;

			public string ns;

			public NamespacePrefixForQName(string prefix, string ns)
			{
				this.ns = ns;
				this.prefix = prefix;
			}

			public string LookupNamespace(string prefix)
			{
				if (prefix == this.prefix)
				{
					return ns;
				}
				return null;
			}

			public string LookupPrefix(string namespaceName)
			{
				if (ns == namespaceName)
				{
					return prefix;
				}
				return null;
			}

			public IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope)
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>(1);
				dictionary[prefix] = ns;
				return dictionary;
			}
		}

		private XmlSchemaType xmlType;

		private object objVal;

		private TypeCode clrType;

		private Union unionVal;

		private NamespacePrefixForQName nsPrefix;

		public override bool IsNode => false;

		public override XmlSchemaType XmlType => xmlType;

		public override Type ValueType => xmlType.Datatype.ValueType;

		public override object TypedValue
		{
			get
			{
				XmlValueConverter valueConverter = xmlType.ValueConverter;
				if (objVal == null)
				{
					switch (clrType)
					{
					case TypeCode.Boolean:
						return valueConverter.ChangeType(unionVal.boolVal, ValueType);
					case TypeCode.Int32:
						return valueConverter.ChangeType(unionVal.i32Val, ValueType);
					case TypeCode.Int64:
						return valueConverter.ChangeType(unionVal.i64Val, ValueType);
					case TypeCode.Double:
						return valueConverter.ChangeType(unionVal.dblVal, ValueType);
					case TypeCode.DateTime:
						return valueConverter.ChangeType(unionVal.dtVal, ValueType);
					}
				}
				return valueConverter.ChangeType(objVal, ValueType, nsPrefix);
			}
		}

		public override bool ValueAsBoolean
		{
			get
			{
				XmlValueConverter valueConverter = xmlType.ValueConverter;
				if (objVal == null)
				{
					switch (clrType)
					{
					case TypeCode.Boolean:
						return unionVal.boolVal;
					case TypeCode.Int32:
						return valueConverter.ToBoolean(unionVal.i32Val);
					case TypeCode.Int64:
						return valueConverter.ToBoolean(unionVal.i64Val);
					case TypeCode.Double:
						return valueConverter.ToBoolean(unionVal.dblVal);
					case TypeCode.DateTime:
						return valueConverter.ToBoolean(unionVal.dtVal);
					}
				}
				return valueConverter.ToBoolean(objVal);
			}
		}

		public override DateTime ValueAsDateTime
		{
			get
			{
				XmlValueConverter valueConverter = xmlType.ValueConverter;
				if (objVal == null)
				{
					switch (clrType)
					{
					case TypeCode.Boolean:
						return valueConverter.ToDateTime(unionVal.boolVal);
					case TypeCode.Int32:
						return valueConverter.ToDateTime(unionVal.i32Val);
					case TypeCode.Int64:
						return valueConverter.ToDateTime(unionVal.i64Val);
					case TypeCode.Double:
						return valueConverter.ToDateTime(unionVal.dblVal);
					case TypeCode.DateTime:
						return unionVal.dtVal;
					}
				}
				return valueConverter.ToDateTime(objVal);
			}
		}

		public override double ValueAsDouble
		{
			get
			{
				XmlValueConverter valueConverter = xmlType.ValueConverter;
				if (objVal == null)
				{
					switch (clrType)
					{
					case TypeCode.Boolean:
						return valueConverter.ToDouble(unionVal.boolVal);
					case TypeCode.Int32:
						return valueConverter.ToDouble(unionVal.i32Val);
					case TypeCode.Int64:
						return valueConverter.ToDouble(unionVal.i64Val);
					case TypeCode.Double:
						return unionVal.dblVal;
					case TypeCode.DateTime:
						return valueConverter.ToDouble(unionVal.dtVal);
					}
				}
				return valueConverter.ToDouble(objVal);
			}
		}

		public override int ValueAsInt
		{
			get
			{
				XmlValueConverter valueConverter = xmlType.ValueConverter;
				if (objVal == null)
				{
					switch (clrType)
					{
					case TypeCode.Boolean:
						return valueConverter.ToInt32(unionVal.boolVal);
					case TypeCode.Int32:
						return unionVal.i32Val;
					case TypeCode.Int64:
						return valueConverter.ToInt32(unionVal.i64Val);
					case TypeCode.Double:
						return valueConverter.ToInt32(unionVal.dblVal);
					case TypeCode.DateTime:
						return valueConverter.ToInt32(unionVal.dtVal);
					}
				}
				return valueConverter.ToInt32(objVal);
			}
		}

		public override long ValueAsLong
		{
			get
			{
				XmlValueConverter valueConverter = xmlType.ValueConverter;
				if (objVal == null)
				{
					switch (clrType)
					{
					case TypeCode.Boolean:
						return valueConverter.ToInt64(unionVal.boolVal);
					case TypeCode.Int32:
						return valueConverter.ToInt64(unionVal.i32Val);
					case TypeCode.Int64:
						return unionVal.i64Val;
					case TypeCode.Double:
						return valueConverter.ToInt64(unionVal.dblVal);
					case TypeCode.DateTime:
						return valueConverter.ToInt64(unionVal.dtVal);
					}
				}
				return valueConverter.ToInt64(objVal);
			}
		}

		public override string Value
		{
			get
			{
				XmlValueConverter valueConverter = xmlType.ValueConverter;
				if (objVal == null)
				{
					switch (clrType)
					{
					case TypeCode.Boolean:
						return valueConverter.ToString(unionVal.boolVal);
					case TypeCode.Int32:
						return valueConverter.ToString(unionVal.i32Val);
					case TypeCode.Int64:
						return valueConverter.ToString(unionVal.i64Val);
					case TypeCode.Double:
						return valueConverter.ToString(unionVal.dblVal);
					case TypeCode.DateTime:
						return valueConverter.ToString(unionVal.dtVal);
					}
				}
				return valueConverter.ToString(objVal, nsPrefix);
			}
		}

		internal XmlAtomicValue(XmlSchemaType xmlType, bool value)
		{
			if (xmlType == null)
			{
				throw new ArgumentNullException("xmlType");
			}
			this.xmlType = xmlType;
			clrType = TypeCode.Boolean;
			unionVal.boolVal = value;
		}

		internal XmlAtomicValue(XmlSchemaType xmlType, DateTime value)
		{
			if (xmlType == null)
			{
				throw new ArgumentNullException("xmlType");
			}
			this.xmlType = xmlType;
			clrType = TypeCode.DateTime;
			unionVal.dtVal = value;
		}

		internal XmlAtomicValue(XmlSchemaType xmlType, double value)
		{
			if (xmlType == null)
			{
				throw new ArgumentNullException("xmlType");
			}
			this.xmlType = xmlType;
			clrType = TypeCode.Double;
			unionVal.dblVal = value;
		}

		internal XmlAtomicValue(XmlSchemaType xmlType, int value)
		{
			if (xmlType == null)
			{
				throw new ArgumentNullException("xmlType");
			}
			this.xmlType = xmlType;
			clrType = TypeCode.Int32;
			unionVal.i32Val = value;
		}

		internal XmlAtomicValue(XmlSchemaType xmlType, long value)
		{
			if (xmlType == null)
			{
				throw new ArgumentNullException("xmlType");
			}
			this.xmlType = xmlType;
			clrType = TypeCode.Int64;
			unionVal.i64Val = value;
		}

		internal XmlAtomicValue(XmlSchemaType xmlType, string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (xmlType == null)
			{
				throw new ArgumentNullException("xmlType");
			}
			this.xmlType = xmlType;
			objVal = value;
		}

		internal XmlAtomicValue(XmlSchemaType xmlType, string value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (xmlType == null)
			{
				throw new ArgumentNullException("xmlType");
			}
			this.xmlType = xmlType;
			objVal = value;
			if (nsResolver != null && (this.xmlType.TypeCode == XmlTypeCode.QName || this.xmlType.TypeCode == XmlTypeCode.Notation))
			{
				string prefixFromQName = GetPrefixFromQName(value);
				nsPrefix = new NamespacePrefixForQName(prefixFromQName, nsResolver.LookupNamespace(prefixFromQName));
			}
		}

		internal XmlAtomicValue(XmlSchemaType xmlType, object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (xmlType == null)
			{
				throw new ArgumentNullException("xmlType");
			}
			this.xmlType = xmlType;
			objVal = value;
		}

		internal XmlAtomicValue(XmlSchemaType xmlType, object value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (xmlType == null)
			{
				throw new ArgumentNullException("xmlType");
			}
			this.xmlType = xmlType;
			objVal = value;
			if (nsResolver != null && (this.xmlType.TypeCode == XmlTypeCode.QName || this.xmlType.TypeCode == XmlTypeCode.Notation))
			{
				XmlQualifiedName xmlQualifiedName = objVal as XmlQualifiedName;
				string @namespace = xmlQualifiedName.Namespace;
				nsPrefix = new NamespacePrefixForQName(nsResolver.LookupPrefix(@namespace), @namespace);
			}
		}

		public XmlAtomicValue Clone()
		{
			return this;
		}

		object ICloneable.Clone()
		{
			return this;
		}

		public override object ValueAs(Type type, IXmlNamespaceResolver nsResolver)
		{
			XmlValueConverter valueConverter = xmlType.ValueConverter;
			if (type == typeof(XPathItem) || type == typeof(XmlAtomicValue))
			{
				return this;
			}
			if (objVal == null)
			{
				switch (clrType)
				{
				case TypeCode.Boolean:
					return valueConverter.ChangeType(unionVal.boolVal, type);
				case TypeCode.Int32:
					return valueConverter.ChangeType(unionVal.i32Val, type);
				case TypeCode.Int64:
					return valueConverter.ChangeType(unionVal.i64Val, type);
				case TypeCode.Double:
					return valueConverter.ChangeType(unionVal.dblVal, type);
				case TypeCode.DateTime:
					return valueConverter.ChangeType(unionVal.dtVal, type);
				}
			}
			return valueConverter.ChangeType(objVal, type, nsResolver);
		}

		public override string ToString()
		{
			return Value;
		}

		private string GetPrefixFromQName(string value)
		{
			int colonOffset;
			int num = ValidateNames.ParseQName(value, 0, out colonOffset);
			if (num == 0 || num != value.Length)
			{
				return null;
			}
			if (colonOffset != 0)
			{
				return value.Substring(0, colonOffset);
			}
			return string.Empty;
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class XmlSchemaObject
	{
		private int lineNum;

		private int linePos;

		private string sourceUri;

		private XmlSerializerNamespaces namespaces;

		private XmlSchemaObject parent;

		private bool isProcessing;

		[XmlIgnore]
		public int LineNumber
		{
			get
			{
				return lineNum;
			}
			set
			{
				lineNum = value;
			}
		}

		[XmlIgnore]
		public int LinePosition
		{
			get
			{
				return linePos;
			}
			set
			{
				linePos = value;
			}
		}

		[XmlIgnore]
		public string SourceUri
		{
			get
			{
				return sourceUri;
			}
			set
			{
				sourceUri = value;
			}
		}

		[XmlIgnore]
		public XmlSchemaObject Parent
		{
			get
			{
				return parent;
			}
			set
			{
				parent = value;
			}
		}

		[XmlNamespaceDeclarations]
		public XmlSerializerNamespaces Namespaces
		{
			get
			{
				if (namespaces == null)
				{
					namespaces = new XmlSerializerNamespaces();
				}
				return namespaces;
			}
			set
			{
				namespaces = value;
			}
		}

		[XmlIgnore]
		internal virtual string IdAttribute
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		[XmlIgnore]
		internal virtual string NameAttribute
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		[XmlIgnore]
		internal bool IsProcessing
		{
			get
			{
				return isProcessing;
			}
			set
			{
				isProcessing = value;
			}
		}

		internal virtual void OnAdd(XmlSchemaObjectCollection container, object item)
		{
		}

		internal virtual void OnRemove(XmlSchemaObjectCollection container, object item)
		{
		}

		internal virtual void OnClear(XmlSchemaObjectCollection container)
		{
		}

		internal virtual void SetUnhandledAttributes(XmlAttribute[] moreAttributes)
		{
		}

		internal virtual void AddAnnotation(XmlSchemaAnnotation annotation)
		{
		}

		internal virtual XmlSchemaObject Clone()
		{
			return (XmlSchemaObject)MemberwiseClone();
		}
	}
	[XmlRoot("schema", Namespace = "http://www.w3.org/2001/XMLSchema")]
	public class XmlSchema : XmlSchemaObject
	{
		public const string Namespace = "http://www.w3.org/2001/XMLSchema";

		public const string InstanceNamespace = "http://www.w3.org/2001/XMLSchema-instance";

		private XmlSchemaForm attributeFormDefault;

		private XmlSchemaForm elementFormDefault;

		private XmlSchemaDerivationMethod blockDefault = XmlSchemaDerivationMethod.None;

		private XmlSchemaDerivationMethod finalDefault = XmlSchemaDerivationMethod.None;

		private string targetNs;

		private string version;

		private XmlSchemaObjectCollection includes = new XmlSchemaObjectCollection();

		private XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();

		private string id;

		private XmlAttribute[] moreAttributes;

		private bool isCompiled;

		private bool isCompiledBySet;

		private bool isPreprocessed;

		private bool isRedefined;

		private int errorCount;

		private XmlSchemaObjectTable attributes;

		private XmlSchemaObjectTable attributeGroups = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable elements = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable types = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable groups = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable notations = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable identityConstraints = new XmlSchemaObjectTable();

		private static int globalIdCounter = -1;

		private ArrayList importedSchemas;

		private ArrayList importedNamespaces;

		private int schemaId = -1;

		private Uri baseUri;

		private bool isChameleon;

		private Hashtable ids = new Hashtable();

		private XmlDocument document;

		private XmlNameTable nameTable;

		[DefaultValue(XmlSchemaForm.None)]
		[XmlAttribute("attributeFormDefault")]
		public XmlSchemaForm AttributeFormDefault
		{
			get
			{
				return attributeFormDefault;
			}
			set
			{
				attributeFormDefault = value;
			}
		}

		[DefaultValue(XmlSchemaDerivationMethod.None)]
		[XmlAttribute("blockDefault")]
		public XmlSchemaDerivationMethod BlockDefault
		{
			get
			{
				return blockDefault;
			}
			set
			{
				blockDefault = value;
			}
		}

		[DefaultValue(XmlSchemaDerivationMethod.None)]
		[XmlAttribute("finalDefault")]
		public XmlSchemaDerivationMethod FinalDefault
		{
			get
			{
				return finalDefault;
			}
			set
			{
				finalDefault = value;
			}
		}

		[DefaultValue(XmlSchemaForm.None)]
		[XmlAttribute("elementFormDefault")]
		public XmlSchemaForm ElementFormDefault
		{
			get
			{
				return elementFormDefault;
			}
			set
			{
				elementFormDefault = value;
			}
		}

		[XmlAttribute("targetNamespace", DataType = "anyURI")]
		public string TargetNamespace
		{
			get
			{
				return targetNs;
			}
			set
			{
				targetNs = value;
			}
		}

		[XmlAttribute("version", DataType = "token")]
		public string Version
		{
			get
			{
				return version;
			}
			set
			{
				version = value;
			}
		}

		[XmlElement("include", typeof(XmlSchemaInclude))]
		[XmlElement("redefine", typeof(XmlSchemaRedefine))]
		[XmlElement("import", typeof(XmlSchemaImport))]
		public XmlSchemaObjectCollection Includes => includes;

		[XmlElement("complexType", typeof(XmlSchemaComplexType))]
		[XmlElement("annotation", typeof(XmlSchemaAnnotation))]
		[XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroup))]
		[XmlElement("group", typeof(XmlSchemaGroup))]
		[XmlElement("notation", typeof(XmlSchemaNotation))]
		[XmlElement("element", typeof(XmlSchemaElement))]
		[XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
		[XmlElement("attribute", typeof(XmlSchemaAttribute))]
		public XmlSchemaObjectCollection Items => items;

		[XmlIgnore]
		public bool IsCompiled
		{
			get
			{
				if (!isCompiled)
				{
					return isCompiledBySet;
				}
				return true;
			}
		}

		[XmlIgnore]
		internal bool IsCompiledBySet
		{
			get
			{
				return isCompiledBySet;
			}
			set
			{
				isCompiledBySet = value;
			}
		}

		[XmlIgnore]
		internal bool IsPreprocessed
		{
			get
			{
				return isPreprocessed;
			}
			set
			{
				isPreprocessed = value;
			}
		}

		[XmlIgnore]
		internal bool IsRedefined
		{
			get
			{
				return isRedefined;
			}
			set
			{
				isRedefined = value;
			}
		}

		[XmlIgnore]
		public XmlSchemaObjectTable Attributes
		{
			get
			{
				if (attributes == null)
				{
					attributes = new XmlSchemaObjectTable();
				}
				return attributes;
			}
		}

		[XmlIgnore]
		public XmlSchemaObjectTable AttributeGroups
		{
			get
			{
				if (attributeGroups == null)
				{
					attributeGroups = new XmlSchemaObjectTable();
				}
				return attributeGroups;
			}
		}

		[XmlIgnore]
		public XmlSchemaObjectTable SchemaTypes
		{
			get
			{
				if (types == null)
				{
					types = new XmlSchemaObjectTable();
				}
				return types;
			}
		}

		[XmlIgnore]
		public XmlSchemaObjectTable Elements
		{
			get
			{
				if (elements == null)
				{
					elements = new XmlSchemaObjectTable();
				}
				return elements;
			}
		}

		[XmlAttribute("id", DataType = "ID")]
		public string Id
		{
			get
			{
				return id;
			}
			set
			{
				id = value;
			}
		}

		[XmlAnyAttribute]
		public XmlAttribute[] UnhandledAttributes
		{
			get
			{
				return moreAttributes;
			}
			set
			{
				moreAttributes = value;
			}
		}

		[XmlIgnore]
		public XmlSchemaObjectTable Groups => groups;

		[XmlIgnore]
		public XmlSchemaObjectTable Notations => notations;

		[XmlIgnore]
		internal XmlSchemaObjectTable IdentityConstraints => identityConstraints;

		[XmlIgnore]
		internal Uri BaseUri
		{
			get
			{
				return baseUri;
			}
			set
			{
				baseUri = value;
			}
		}

		[XmlIgnore]
		internal int SchemaId
		{
			get
			{
				if (schemaId == -1)
				{
					schemaId = Interlocked.Increment(ref globalIdCounter);
				}
				return schemaId;
			}
		}

		[XmlIgnore]
		internal bool IsChameleon
		{
			get
			{
				return isChameleon;
			}
			set
			{
				isChameleon = value;
			}
		}

		[XmlIgnore]
		internal Hashtable Ids => ids;

		[XmlIgnore]
		internal XmlDocument Document
		{
			get
			{
				if (document == null)
				{
					document = new XmlDocument();
				}
				return document;
			}
		}

		[XmlIgnore]
		internal int ErrorCount
		{
			get
			{
				return errorCount;
			}
			set
			{
				errorCount = value;
			}
		}

		[XmlIgnore]
		internal override string IdAttribute
		{
			get
			{
				return Id;
			}
			set
			{
				Id = value;
			}
		}

		internal XmlNameTable NameTable
		{
			get
			{
				if (nameTable == null)
				{
					nameTable = new NameTable();
				}
				return nameTable;
			}
		}

		internal ArrayList ImportedSchemas
		{
			get
			{
				if (importedSchemas == null)
				{
					importedSchemas = new ArrayList();
				}
				return importedSchemas;
			}
		}

		internal ArrayList ImportedNamespaces
		{
			get
			{
				if (importedNamespaces == null)
				{
					importedNamespaces = new ArrayList();
				}
				return importedNamespaces;
			}
		}

		public static XmlSchema Read(TextReader reader, ValidationEventHandler validationEventHandler)
		{
			return Read(new XmlTextReader(reader), validationEventHandler);
		}

		public static XmlSchema Read(Stream stream, ValidationEventHandler validationEventHandler)
		{
			return Read(new XmlTextReader(stream), validationEventHandler);
		}

		public static XmlSchema Read(XmlReader reader, ValidationEventHandler validationEventHandler)
		{
			XmlNameTable xmlNameTable = reader.NameTable;
			Parser parser = new Parser(SchemaType.XSD, xmlNameTable, new SchemaNames(xmlNameTable), validationEventHandler);
			try
			{
				parser.Parse(reader, null);
			}
			catch (XmlSchemaException ex)
			{
				if (validationEventHandler != null)
				{
					validationEventHandler(null, new ValidationEventArgs(ex));
					return null;
				}
				throw ex;
			}
			return parser.XmlSchema;
		}

		public void Write(Stream stream)
		{
			Write(stream, null);
		}

		public void Write(Stream stream, XmlNamespaceManager namespaceManager)
		{
			XmlTextWriter xmlTextWriter = new XmlTextWriter(stream, null);
			xmlTextWriter.Formatting = Formatting.Indented;
			Write(xmlTextWriter, namespaceManager);
		}

		public void Write(TextWriter writer)
		{
			Write(writer, null);
		}

		public void Write(TextWriter writer, XmlNamespaceManager namespaceManager)
		{
			XmlTextWriter xmlTextWriter = new XmlTextWriter(writer);
			xmlTextWriter.Formatting = Formatting.Indented;
			Write(xmlTextWriter, namespaceManager);
		}

		public void Write(XmlWriter writer)
		{
			Write(writer, null);
		}

		public void Write(XmlWriter writer, XmlNamespaceManager namespaceManager)
		{
			XmlSerializer xmlSerializer = new XmlSerializer(typeof(XmlSchema));
			XmlSerializerNamespaces xmlSerializerNamespaces;
			if (namespaceManager != null)
			{
				xmlSerializerNamespaces = new XmlSerializerNamespaces();
				bool flag = false;
				if (base.Namespaces != null)
				{
					flag = base.Namespaces.Namespaces["xs"] != null || base.Namespaces.Namespaces.ContainsValue("http://www.w3.org/2001/XMLSchema");
				}
				if (!flag && namespaceManager.LookupPrefix("http://www.w3.org/2001/XMLSchema") == null && namespaceManager.LookupNamespace("xs") == null)
				{
					xmlSerializerNamespaces.Add("xs", "http://www.w3.org/2001/XMLSchema");
				}
				foreach (string item in namespaceManager)
				{
					if (item != "xml" && item != "xmlns")
					{
						xmlSerializerNamespaces.Add(item, namespaceManager.LookupNamespace(item));
					}
				}
			}
			else if (base.Namespaces != null && base.Namespaces.Count > 0)
			{
				Hashtable hashtable = base.Namespaces.Namespaces;
				if (hashtable["xs"] == null && !hashtable.ContainsValue("http://www.w3.org/2001/XMLSchema"))
				{
					hashtable.Add("xs", "http://www.w3.org/2001/XMLSchema");
				}
				xmlSerializerNamespaces = base.Namespaces;
			}
			else
			{
				xmlSerializerNamespaces = new XmlSerializerNamespaces();
				xmlSerializerNamespaces.Add("xs", "http://www.w3.org/2001/XMLSchema");
				if (targetNs != null && targetNs.Length != 0)
				{
					xmlSerializerNamespaces.Add("tns", targetNs);
				}
			}
			xmlSerializer.Serialize(writer, this, xmlSerializerNamespaces);
		}

		[Obsolete("Use System.Xml.Schema.XmlSchemaSet for schema compilation and validation. http://go.microsoft.com/fwlink/?linkid=14202")]
		public void Compile(ValidationEventHandler validationEventHandler)
		{
			SchemaInfo schemaInfo = new SchemaInfo();
			schemaInfo.SchemaType = SchemaType.XSD;
			CompileSchema(null, XmlReaderSection.CreateDefaultResolver(), schemaInfo, null, validationEventHandler, NameTable, CompileContentModel: false);
		}

		[Obsolete("Use System.Xml.Schema.XmlSchemaSet for schema compilation and validation. http://go.microsoft.com/fwlink/?linkid=14202")]
		public void Compile(ValidationEventHandler validationEventHandler, XmlResolver resolver)
		{
			SchemaInfo schemaInfo = new SchemaInfo();
			schemaInfo.SchemaType = SchemaType.XSD;
			CompileSchema(null, resolver, schemaInfo, null, validationEventHandler, NameTable, CompileContentModel: false);
		}

		internal bool CompileSchema(XmlSchemaCollection xsc, XmlResolver resolver, SchemaInfo schemaInfo, string ns, ValidationEventHandler validationEventHandler, XmlNameTable nameTable, bool CompileContentModel)
		{
			lock (this)
			{
				SchemaCollectionPreprocessor schemaCollectionPreprocessor = new SchemaCollectionPreprocessor(nameTable, null, validationEventHandler);
				schemaCollectionPreprocessor.XmlResolver = resolver;
				if (!schemaCollectionPreprocessor.Execute(this, ns, loadExternals: true, xsc))
				{
					return false;
				}
				SchemaCollectionCompiler schemaCollectionCompiler = new SchemaCollectionCompiler(nameTable, validationEventHandler);
				isCompiled = schemaCollectionCompiler.Execute(this, schemaInfo, CompileContentModel);
				SetIsCompiled(isCompiled);
				return isCompiled;
			}
		}

		internal void CompileSchemaInSet(XmlNameTable nameTable, ValidationEventHandler eventHandler, XmlSchemaCompilationSettings compilationSettings)
		{
			Compiler compiler = new Compiler(nameTable, eventHandler, null, compilationSettings);
			compiler.Prepare(this, cleanup: true);
			isCompiledBySet = compiler.Compile();
		}

		internal new XmlSchema Clone()
		{
			XmlSchema xmlSchema = new XmlSchema();
			xmlSchema.attributeFormDefault = attributeFormDefault;
			xmlSchema.elementFormDefault = elementFormDefault;
			xmlSchema.blockDefault = blockDefault;
			xmlSchema.finalDefault = finalDefault;
			xmlSchema.targetNs = targetNs;
			xmlSchema.version = version;
			xmlSchema.includes = includes;
			xmlSchema.Namespaces = base.Namespaces;
			xmlSchema.items = items;
			xmlSchema.BaseUri = BaseUri;
			SchemaCollectionCompiler.Cleanup(xmlSchema);
			return xmlSchema;
		}

		internal XmlSchema DeepClone()
		{
			XmlSchema xmlSchema = new XmlSchema();
			xmlSchema.attributeFormDefault = attributeFormDefault;
			xmlSchema.elementFormDefault = elementFormDefault;
			xmlSchema.blockDefault = blockDefault;
			xmlSchema.finalDefault = finalDefault;
			xmlSchema.targetNs = targetNs;
			xmlSchema.version = version;
			xmlSchema.isPreprocessed = isPreprocessed;
			foreach (XmlSchemaObject item3 in items)
			{
				XmlSchemaObject item = item3.Clone();
				xmlSchema.Items.Add(item);
			}
			foreach (XmlSchemaExternal include in includes)
			{
				XmlSchemaExternal item2 = (XmlSchemaExternal)include.Clone();
				xmlSchema.Includes.Add(item2);
			}
			xmlSchema.Namespaces = base.Namespaces;
			xmlSchema.BaseUri = BaseUri;
			return xmlSchema;
		}

		internal void SetIsCompiled(bool isCompiled)
		{
			this.isCompiled = isCompiled;
		}

		internal override void SetUnhandledAttributes(XmlAttribute[] moreAttributes)
		{
			this.moreAttributes = moreAttributes;
		}

		internal override void AddAnnotation(XmlSchemaAnnotation annotation)
		{
			items.Add(annotation);
		}

		internal void GetExternalSchemasList(IList extList, XmlSchema schema)
		{
			if (extList.Contains(schema))
			{
				return;
			}
			extList.Add(schema);
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (include.Schema != null)
				{
					GetExternalSchemasList(extList, include.Schema);
				}
			}
		}

		internal void AddCompiledInfo(SchemaInfo schemaInfo)
		{
			foreach (XmlSchemaElement value in elements.Values)
			{
				XmlQualifiedName qualifiedName = value.QualifiedName;
				schemaInfo.TargetNamespaces[qualifiedName.Namespace] = true;
				if (schemaInfo.ElementDecls[qualifiedName] == null)
				{
					schemaInfo.ElementDecls.Add(qualifiedName, value.ElementDecl);
				}
			}
			foreach (XmlSchemaAttribute value2 in attributes.Values)
			{
				XmlQualifiedName qualifiedName = value2.QualifiedName;
				schemaInfo.TargetNamespaces[qualifiedName.Namespace] = true;
				if (schemaInfo.ElementDecls[qualifiedName] == null)
				{
					schemaInfo.AttributeDecls.Add(qualifiedName, value2.AttDef);
				}
			}
			foreach (XmlSchemaType value3 in types.Values)
			{
				XmlQualifiedName qualifiedName = value3.QualifiedName;
				schemaInfo.TargetNamespaces[qualifiedName.Namespace] = true;
				if ((!(value3 is XmlSchemaComplexType) || value3 != XmlSchemaComplexType.AnyType) && schemaInfo.ElementDeclsByType[qualifiedName] == null)
				{
					schemaInfo.ElementDeclsByType.Add(qualifiedName, value3.ElementDecl);
				}
			}
			foreach (XmlSchemaNotation value4 in notations.Values)
			{
				XmlQualifiedName qualifiedName = value4.QualifiedName;
				schemaInfo.TargetNamespaces[qualifiedName.Namespace] = true;
				SchemaNotation schemaNotation = new SchemaNotation(qualifiedName);
				schemaNotation.SystemLiteral = value4.System;
				schemaNotation.Pubid = value4.Public;
				if (schemaInfo.Notations[qualifiedName.Name] == null)
				{
					schemaInfo.Notations.Add(qualifiedName.Name, schemaNotation);
				}
			}
		}
	}
	public class XmlSchemaAnnotated : XmlSchemaObject
	{
		private string id;

		private XmlSchemaAnnotation annotation;

		private XmlAttribute[] moreAttributes;

		[XmlAttribute("id", DataType = "ID")]
		public string Id
		{
			get
			{
				return id;
			}
			set
			{
				id = value;
			}
		}

		[XmlElement("annotation", typeof(XmlSchemaAnnotation))]
		public XmlSchemaAnnotation Annotation
		{
			get
			{
				return annotation;
			}
			set
			{
				annotation = value;
			}
		}

		[XmlAnyAttribute]
		public XmlAttribute[] UnhandledAttributes
		{
			get
			{
				return moreAttributes;
			}
			set
			{
				moreAttributes = value;
			}
		}

		[XmlIgnore]
		internal override string IdAttribute
		{
			get
			{
				return Id;
			}
			set
			{
				Id = value;
			}
		}

		internal override void SetUnhandledAttributes(XmlAttribute[] moreAttributes)
		{
			this.moreAttributes = moreAttributes;
		}

		internal override void AddAnnotation(XmlSchemaAnnotation annotation)
		{
			this.annotation = annotation;
		}
	}
	public abstract class XmlSchemaParticle : XmlSchemaAnnotated
	{
		[Flags]
		private enum Occurs
		{
			None = 0,
			Min = 1,
			Max = 2
		}

		private class EmptyParticle : XmlSchemaParticle
		{
			internal override bool IsEmpty => true;
		}

		private decimal minOccurs = 1m;

		private decimal maxOccurs = 1m;

		private Occurs flags;

		internal static readonly XmlSchemaParticle Empty = new EmptyParticle();

		[XmlAttribute("minOccurs")]
		public string MinOccursString
		{
			get
			{
				if ((flags & Occurs.Min) != 0)
				{
					return XmlConvert.ToString(minOccurs);
				}
				return null;
			}
			set
			{
				if (value == null)
				{
					minOccurs = 1m;
					flags &= ~Occurs.Min;
					return;
				}
				minOccurs = XmlConvert.ToInteger(value);
				if (minOccurs < 0m)
				{
					throw new XmlSchemaException("Sch_MinOccursInvalidXsd", string.Empty);
				}
				flags |= Occurs.Min;
			}
		}

		[XmlAttribute("maxOccurs")]
		public string MaxOccursString
		{
			get
			{
				if ((flags & Occurs.Max) != 0)
				{
					if (!(maxOccurs == decimal.MaxValue))
					{
						return XmlConvert.ToString(maxOccurs);
					}
					return "unbounded";
				}
				return null;
			}
			set
			{
				if (value == null)
				{
					maxOccurs = 1m;
					flags &= ~Occurs.Max;
					return;
				}
				if (value == "unbounded")
				{
					maxOccurs = decimal.MaxValue;
				}
				else
				{
					maxOccurs = XmlConvert.ToInteger(value);
					if (maxOccurs < 0m)
					{
						throw new XmlSchemaException("Sch_MaxOccursInvalidXsd", string.Empty);
					}
					if (maxOccurs == 0m && (flags & Occurs.Min) == 0)
					{
						minOccurs = 0m;
					}
				}
				flags |= Occurs.Max;
			}
		}

		[XmlIgnore]
		public decimal MinOccurs
		{
			get
			{
				return minOccurs;
			}
			set
			{
				if (value < 0m || value != decimal.Truncate(value))
				{
					throw new XmlSchemaException("Sch_MinOccursInvalidXsd", string.Empty);
				}
				minOccurs = value;
				flags |= Occurs.Min;
			}
		}

		[XmlIgnore]
		public decimal MaxOccurs
		{
			get
			{
				return maxOccurs;
			}
			set
			{
				if (value < 0m || value != decimal.Truncate(value))
				{
					throw new XmlSchemaException("Sch_MaxOccursInvalidXsd", string.Empty);
				}
				maxOccurs = value;
				if (maxOccurs == 0m && (flags & Occurs.Min) == 0)
				{
					minOccurs = 0m;
				}
				flags |= Occurs.Max;
			}
		}

		internal virtual bool IsEmpty => maxOccurs == 0m;

		internal bool IsMultipleOccurrence => maxOccurs > 1m;

		internal virtual string NameString => string.Empty;

		internal XmlQualifiedName GetQualifiedName()
		{
			if (this is XmlSchemaElement xmlSchemaElement)
			{
				return xmlSchemaElement.QualifiedName;
			}
			if (this is XmlSchemaAny xmlSchemaAny)
			{
				string @namespace = xmlSchemaAny.Namespace;
				@namespace = ((@namespace == null) ? string.Empty : @namespace.Trim());
				return new XmlQualifiedName("*", (@namespace.Length == 0) ? "##any" : @namespace);
			}
			return XmlQualifiedName.Empty;
		}
	}
	public abstract class XmlSchemaGroupBase : XmlSchemaParticle
	{
		[XmlIgnore]
		public abstract XmlSchemaObjectCollection Items { get; }

		internal abstract void SetItems(XmlSchemaObjectCollection newItems);
	}
	public class XmlSchemaAll : XmlSchemaGroupBase
	{
		private XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();

		[XmlElement("element", typeof(XmlSchemaElement))]
		public override XmlSchemaObjectCollection Items => items;

		internal override bool IsEmpty
		{
			get
			{
				if (!base.IsEmpty)
				{
					return items.Count == 0;
				}
				return true;
			}
		}

		internal override void SetItems(XmlSchemaObjectCollection newItems)
		{
			items = newItems;
		}
	}
	public class XmlSchemaAnnotation : XmlSchemaObject
	{
		private string id;

		private XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();

		private XmlAttribute[] moreAttributes;

		[XmlAttribute("id", DataType = "ID")]
		public string Id
		{
			get
			{
				return id;
			}
			set
			{
				id = value;
			}
		}

		[XmlElement("documentation", typeof(XmlSchemaDocumentation))]
		[XmlElement("appinfo", typeof(XmlSchemaAppInfo))]
		public XmlSchemaObjectCollection Items => items;

		[XmlAnyAttribute]
		public XmlAttribute[] UnhandledAttributes
		{
			get
			{
				return moreAttributes;
			}
			set
			{
				moreAttributes = value;
			}
		}

		[XmlIgnore]
		internal override string IdAttribute
		{
			get
			{
				return Id;
			}
			set
			{
				Id = value;
			}
		}

		internal override void SetUnhandledAttributes(XmlAttribute[] moreAttributes)
		{
			this.moreAttributes = moreAttributes;
		}
	}
	public class XmlSchemaAny : XmlSchemaParticle
	{
		private string ns;

		private XmlSchemaContentProcessing processContents;

		private NamespaceList namespaceList;

		[XmlAttribute("namespace")]
		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		[XmlAttribute("processContents")]
		[DefaultValue(XmlSchemaContentProcessing.None)]
		public XmlSchemaContentProcessing ProcessContents
		{
			get
			{
				return processContents;
			}
			set
			{
				processContents = value;
			}
		}

		[XmlIgnore]
		internal NamespaceList NamespaceList => namespaceList;

		[XmlIgnore]
		internal string ResolvedNamespace
		{
			get
			{
				if (ns == null || ns.Length == 0)
				{
					return "##any";
				}
				return ns;
			}
		}

		[XmlIgnore]
		internal XmlSchemaContentProcessing ProcessContentsCorrect
		{
			get
			{
				if (processContents != 0)
				{
					return processContents;
				}
				return XmlSchemaContentProcessing.Strict;
			}
		}

		internal override string NameString
		{
			get
			{
				switch (namespaceList.Type)
				{
				case NamespaceList.ListType.Any:
					return "##any:*";
				case NamespaceList.ListType.Other:
					return "##other:*";
				case NamespaceList.ListType.Set:
				{
					StringBuilder stringBuilder = new StringBuilder();
					int num = 1;
					foreach (string item in namespaceList.Enumerate)
					{
						stringBuilder.Append(item + ":*");
						if (num < namespaceList.Enumerate.Count)
						{
							stringBuilder.Append(" ");
						}
						num++;
					}
					return stringBuilder.ToString();
				}
				default:
					return string.Empty;
				}
			}
		}

		internal void BuildNamespaceList(string targetNamespace)
		{
			if (ns != null)
			{
				namespaceList = new NamespaceList(ns, targetNamespace);
			}
			else
			{
				namespaceList = new NamespaceList();
			}
		}

		internal void BuildNamespaceListV1Compat(string targetNamespace)
		{
			if (ns != null)
			{
				namespaceList = new NamespaceListV1Compat(ns, targetNamespace);
			}
			else
			{
				namespaceList = new NamespaceList();
			}
		}

		internal bool Allows(XmlQualifiedName qname)
		{
			return namespaceList.Allows(qname.Namespace);
		}
	}
	public class XmlSchemaAnyAttribute : XmlSchemaAnnotated
	{
		private string ns;

		private XmlSchemaContentProcessing processContents;

		private NamespaceList namespaceList;

		[XmlAttribute("namespace")]
		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		[DefaultValue(XmlSchemaContentProcessing.None)]
		[XmlAttribute("processContents")]
		public XmlSchemaContentProcessing ProcessContents
		{
			get
			{
				return processContents;
			}
			set
			{
				processContents = value;
			}
		}

		[XmlIgnore]
		internal NamespaceList NamespaceList => namespaceList;

		[XmlIgnore]
		internal XmlSchemaContentProcessing ProcessContentsCorrect
		{
			get
			{
				if (processContents != 0)
				{
					return processContents;
				}
				return XmlSchemaContentProcessing.Strict;
			}
		}

		internal void BuildNamespaceList(string targetNamespace)
		{
			if (ns != null)
			{
				namespaceList = new NamespaceList(ns, targetNamespace);
			}
			else
			{
				namespaceList = new NamespaceList();
			}
		}

		internal void BuildNamespaceListV1Compat(string targetNamespace)
		{
			if (ns != null)
			{
				namespaceList = new NamespaceListV1Compat(ns, targetNamespace);
			}
			else
			{
				namespaceList = new NamespaceList();
			}
		}

		internal bool Allows(XmlQualifiedName qname)
		{
			return namespaceList.Allows(qname.Namespace);
		}

		internal static bool IsSubset(XmlSchemaAnyAttribute sub, XmlSchemaAnyAttribute super)
		{
			return NamespaceList.IsSubset(sub.NamespaceList, super.NamespaceList);
		}

		internal static XmlSchemaAnyAttribute Intersection(XmlSchemaAnyAttribute o1, XmlSchemaAnyAttribute o2, bool v1Compat)
		{
			NamespaceList namespaceList = NamespaceList.Intersection(o1.NamespaceList, o2.NamespaceList, v1Compat);
			if (namespaceList != null)
			{
				XmlSchemaAnyAttribute xmlSchemaAnyAttribute = new XmlSchemaAnyAttribute();
				xmlSchemaAnyAttribute.namespaceList = namespaceList;
				xmlSchemaAnyAttribute.ProcessContents = o1.ProcessContents;
				xmlSchemaAnyAttribute.Annotation = o1.Annotation;
				return xmlSchemaAnyAttribute;
			}
			return null;
		}

		internal static XmlSchemaAnyAttribute Union(XmlSchemaAnyAttribute o1, XmlSchemaAnyAttribute o2, bool v1Compat)
		{
			NamespaceList namespaceList = NamespaceList.Union(o1.NamespaceList, o2.NamespaceList, v1Compat);
			if (namespaceList != null)
			{
				XmlSchemaAnyAttribute xmlSchemaAnyAttribute = new XmlSchemaAnyAttribute();
				xmlSchemaAnyAttribute.namespaceList = namespaceList;
				xmlSchemaAnyAttribute.processContents = o1.processContents;
				xmlSchemaAnyAttribute.Annotation = o1.Annotation;
				return xmlSchemaAnyAttribute;
			}
			return null;
		}
	}
	public class XmlSchemaAppInfo : XmlSchemaObject
	{
		private string source;

		private XmlNode[] markup;

		[XmlAttribute("source", DataType = "anyURI")]
		public string Source
		{
			get
			{
				return source;
			}
			set
			{
				source = value;
			}
		}

		[XmlAnyElement]
		[XmlText]
		public XmlNode[] Markup
		{
			get
			{
				return markup;
			}
			set
			{
				markup = value;
			}
		}
	}
	public class XmlSchemaAttribute : XmlSchemaAnnotated
	{
		private string defaultValue;

		private string fixedValue;

		private string name;

		private string prefix;

		private XmlSchemaForm form;

		private XmlSchemaUse use;

		private XmlQualifiedName refName = XmlQualifiedName.Empty;

		private XmlQualifiedName typeName = XmlQualifiedName.Empty;

		private XmlQualifiedName qualifiedName = XmlQualifiedName.Empty;

		private XmlSchemaSimpleType type;

		private XmlSchemaSimpleType attributeType;

		private SchemaAttDef attDef;

		[XmlAttribute("default")]
		[DefaultValue(null)]
		public string DefaultValue
		{
			get
			{
				return defaultValue;
			}
			set
			{
				defaultValue = value;
			}
		}

		[XmlAttribute("fixed")]
		[DefaultValue(null)]
		public string FixedValue
		{
			get
			{
				return fixedValue;
			}
			set
			{
				fixedValue = value;
			}
		}

		[DefaultValue(XmlSchemaForm.None)]
		[XmlAttribute("form")]
		public XmlSchemaForm Form
		{
			get
			{
				return form;
			}
			set
			{
				form = value;
			}
		}

		[XmlAttribute("name")]
		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		[XmlAttribute("ref")]
		public XmlQualifiedName RefName
		{
			get
			{
				return refName;
			}
			set
			{
				refName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlAttribute("type")]
		public XmlQualifiedName SchemaTypeName
		{
			get
			{
				return typeName;
			}
			set
			{
				typeName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlElement("simpleType")]
		public XmlSchemaSimpleType SchemaType
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		[XmlAttribute("use")]
		[DefaultValue(XmlSchemaUse.None)]
		public XmlSchemaUse Use
		{
			get
			{
				return use;
			}
			set
			{
				use = value;
			}
		}

		[XmlIgnore]
		public XmlQualifiedName QualifiedName => qualifiedName;

		[XmlIgnore]
		[Obsolete("This property has been deprecated. Please use AttributeSchemaType property that returns a strongly typed attribute type. http://go.microsoft.com/fwlink/?linkid=14202")]
		public object AttributeType
		{
			get
			{
				if (attributeType.QualifiedName.Namespace == "http://www.w3.org/2001/XMLSchema")
				{
					return attributeType.Datatype;
				}
				return attributeType;
			}
		}

		[XmlIgnore]
		public XmlSchemaSimpleType AttributeSchemaType => attributeType;

		[XmlIgnore]
		internal XmlSchemaDatatype Datatype
		{
			get
			{
				if (attributeType != null)
				{
					return attributeType.Datatype;
				}
				return null;
			}
		}

		internal string Prefix => prefix;

		internal SchemaAttDef AttDef
		{
			get
			{
				return attDef;
			}
			set
			{
				attDef = value;
			}
		}

		internal bool HasDefault => defaultValue != null;

		[XmlIgnore]
		internal override string NameAttribute
		{
			get
			{
				return Name;
			}
			set
			{
				Name = value;
			}
		}

		internal XmlReader Validate(XmlReader reader, XmlResolver resolver, XmlSchemaSet schemaSet, ValidationEventHandler valEventHandler)
		{
			if (schemaSet != null)
			{
				XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
				xmlReaderSettings.ValidationType = ValidationType.Schema;
				xmlReaderSettings.Schemas = schemaSet;
				xmlReaderSettings.ValidationEventHandler += valEventHandler;
				return new XsdValidatingReader(reader, resolver, xmlReaderSettings, this);
			}
			return null;
		}

		internal void SetQualifiedName(XmlQualifiedName value)
		{
			qualifiedName = value;
		}

		internal void SetAttributeType(XmlSchemaSimpleType value)
		{
			attributeType = value;
		}

		internal override XmlSchemaObject Clone()
		{
			XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)MemberwiseClone();
			xmlSchemaAttribute.refName = refName.Clone();
			xmlSchemaAttribute.typeName = typeName.Clone();
			return xmlSchemaAttribute;
		}
	}
	public class XmlSchemaAttributeGroup : XmlSchemaAnnotated
	{
		private string name;

		private XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();

		private XmlSchemaAnyAttribute anyAttribute;

		private XmlQualifiedName qname = XmlQualifiedName.Empty;

		private XmlSchemaAttributeGroup redefined;

		private XmlSchemaObjectTable attributeUses;

		private XmlSchemaAnyAttribute attributeWildcard;

		private int selfReferenceCount;

		[XmlAttribute("name")]
		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		[XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
		[XmlElement("attribute", typeof(XmlSchemaAttribute))]
		public XmlSchemaObjectCollection Attributes => attributes;

		[XmlElement("anyAttribute")]
		public XmlSchemaAnyAttribute AnyAttribute
		{
			get
			{
				return anyAttribute;
			}
			set
			{
				anyAttribute = value;
			}
		}

		[XmlIgnore]
		public XmlQualifiedName QualifiedName => qname;

		[XmlIgnore]
		internal XmlSchemaObjectTable AttributeUses
		{
			get
			{
				if (attributeUses == null)
				{
					attributeUses = new XmlSchemaObjectTable();
				}
				return attributeUses;
			}
		}

		[XmlIgnore]
		internal XmlSchemaAnyAttribute AttributeWildcard
		{
			get
			{
				return attributeWildcard;
			}
			set
			{
				attributeWildcard = value;
			}
		}

		[XmlIgnore]
		public XmlSchemaAttributeGroup RedefinedAttributeGroup => redefined;

		[XmlIgnore]
		internal XmlSchemaAttributeGroup Redefined
		{
			get
			{
				return redefined;
			}
			set
			{
				redefined = value;
			}
		}

		[XmlIgnore]
		internal int SelfReferenceCount
		{
			get
			{
				return selfReferenceCount;
			}
			set
			{
				selfReferenceCount = value;
			}
		}

		[XmlIgnore]
		internal override string NameAttribute
		{
			get
			{
				return Name;
			}
			set
			{
				Name = value;
			}
		}

		internal void SetQualifiedName(XmlQualifiedName value)
		{
			qname = value;
		}

		internal override XmlSchemaObject Clone()
		{
			XmlSchemaAttributeGroup xmlSchemaAttributeGroup = (XmlSchemaAttributeGroup)MemberwiseClone();
			if (XmlSchemaComplexType.HasAttributeQNameRef(attributes))
			{
				xmlSchemaAttributeGroup.attributes = XmlSchemaComplexType.CloneAttributes(attributes);
				xmlSchemaAttributeGroup.attributeUses = null;
			}
			return xmlSchemaAttributeGroup;
		}
	}
	public class XmlSchemaAttributeGroupRef : XmlSchemaAnnotated
	{
		private XmlQualifiedName refName = XmlQualifiedName.Empty;

		[XmlAttribute("ref")]
		public XmlQualifiedName RefName
		{
			get
			{
				return refName;
			}
			set
			{
				refName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}
	}
	public class XmlSchemaChoice : XmlSchemaGroupBase
	{
		private XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();

		[XmlElement("sequence", typeof(XmlSchemaSequence))]
		[XmlElement("any", typeof(XmlSchemaAny))]
		[XmlElement("element", typeof(XmlSchemaElement))]
		[XmlElement("choice", typeof(XmlSchemaChoice))]
		[XmlElement("group", typeof(XmlSchemaGroupRef))]
		public override XmlSchemaObjectCollection Items => items;

		internal override bool IsEmpty => base.IsEmpty;

		internal override void SetItems(XmlSchemaObjectCollection newItems)
		{
			items = newItems;
		}
	}
	[Obsolete("Use System.Xml.Schema.XmlSchemaSet for schema compilation and validation. http://go.microsoft.com/fwlink/?linkid=14202")]
	public sealed class XmlSchemaCollection : ICollection, IEnumerable
	{
		private Hashtable collection;

		private XmlNameTable nameTable;

		private SchemaNames schemaNames;

		private ReaderWriterLock wLock;

		private int timeout = -1;

		private bool isThreadSafe = true;

		private ValidationEventHandler validationEventHandler;

		private XmlResolver xmlResolver;

		public int Count => collection.Count;

		public XmlNameTable NameTable => nameTable;

		internal XmlResolver XmlResolver
		{
			set
			{
				xmlResolver = value;
			}
		}

		public XmlSchema this[string ns] => ((XmlSchemaCollectionNode)collection[(ns != null) ? ns : string.Empty])?.Schema;

		bool ICollection.IsSynchronized => true;

		object ICollection.SyncRoot => this;

		int ICollection.Count => collection.Count;

		internal ValidationEventHandler EventHandler
		{
			get
			{
				return validationEventHandler;
			}
			set
			{
				validationEventHandler = value;
			}
		}

		public event ValidationEventHandler ValidationEventHandler
		{
			add
			{
				validationEventHandler = (ValidationEventHandler)Delegate.Combine(validationEventHandler, value);
			}
			remove
			{
				validationEventHandler = (ValidationEventHandler)Delegate.Remove(validationEventHandler, value);
			}
		}

		public XmlSchemaCollection()
			: this(new NameTable())
		{
		}

		public XmlSchemaCollection(XmlNameTable nametable)
		{
			if (nametable == null)
			{
				throw new ArgumentNullException("nametable");
			}
			nameTable = nametable;
			collection = Hashtable.Synchronized(new Hashtable());
			xmlResolver = XmlReaderSection.CreateDefaultResolver();
			isThreadSafe = true;
			if (isThreadSafe)
			{
				wLock = new ReaderWriterLock();
			}
		}

		public XmlSchema Add(string ns, string uri)
		{
			if (uri == null || uri.Length == 0)
			{
				throw new ArgumentNullException("uri");
			}
			XmlTextReader xmlTextReader = new XmlTextReader(uri, nameTable);
			xmlTextReader.XmlResolver = xmlResolver;
			XmlSchema xmlSchema = null;
			try
			{
				xmlSchema = Add(ns, xmlTextReader, xmlResolver);
				while (xmlTextReader.Read())
				{
				}
				return xmlSchema;
			}
			finally
			{
				xmlTextReader.Close();
			}
		}

		public XmlSchema Add(string ns, XmlReader reader)
		{
			return Add(ns, reader, xmlResolver);
		}

		public XmlSchema Add(string ns, XmlReader reader, XmlResolver resolver)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			XmlNameTable nt = reader.NameTable;
			SchemaInfo schemaInfo = new SchemaInfo();
			Parser parser = new Parser(SchemaType.None, nt, GetSchemaNames(nt), validationEventHandler);
			parser.XmlResolver = resolver;
			SchemaType schemaType;
			try
			{
				schemaType = parser.Parse(reader, ns);
			}
			catch (XmlSchemaException e)
			{
				SendValidationEvent(e);
				return null;
			}
			if (schemaType == SchemaType.XSD)
			{
				schemaInfo.SchemaType = SchemaType.XSD;
				return Add(ns, schemaInfo, parser.XmlSchema, compile: true, resolver);
			}
			_ = parser.XdrSchema;
			return Add(ns, parser.XdrSchema, null, compile: true, resolver);
		}

		public XmlSchema Add(XmlSchema schema)
		{
			return Add(schema, xmlResolver);
		}

		public XmlSchema Add(XmlSchema schema, XmlResolver resolver)
		{
			if (schema == null)
			{
				throw new ArgumentNullException("schema");
			}
			SchemaInfo schemaInfo = new SchemaInfo();
			schemaInfo.SchemaType = SchemaType.XSD;
			return Add(schema.TargetNamespace, schemaInfo, schema, compile: true, resolver);
		}

		public void Add(XmlSchemaCollection schema)
		{
			if (schema == null)
			{
				throw new ArgumentNullException("schema");
			}
			if (this != schema)
			{
				IDictionaryEnumerator enumerator = schema.collection.GetEnumerator();
				while (enumerator.MoveNext())
				{
					XmlSchemaCollectionNode xmlSchemaCollectionNode = (XmlSchemaCollectionNode)enumerator.Value;
					Add(xmlSchemaCollectionNode.NamespaceURI, xmlSchemaCollectionNode);
				}
			}
		}

		public bool Contains(XmlSchema schema)
		{
			if (schema == null)
			{
				throw new ArgumentNullException("schema");
			}
			return this[schema.TargetNamespace] != null;
		}

		public bool Contains(string ns)
		{
			return collection[(ns != null) ? ns : string.Empty] != null;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new XmlSchemaCollectionEnumerator(collection);
		}

		public XmlSchemaCollectionEnumerator GetEnumerator()
		{
			return new XmlSchemaCollectionEnumerator(collection);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			XmlSchemaCollectionEnumerator enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (index == array.Length && array.IsFixedSize)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				array.SetValue(enumerator.Current, index++);
			}
		}

		public void CopyTo(XmlSchema[] array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			XmlSchemaCollectionEnumerator enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				XmlSchema current = enumerator.Current;
				if (current != null)
				{
					if (index == array.Length)
					{
						throw new ArgumentOutOfRangeException("index");
					}
					array[index++] = enumerator.Current;
				}
			}
		}

		internal SchemaInfo GetSchemaInfo(string ns)
		{
			return ((XmlSchemaCollectionNode)collection[(ns != null) ? ns : string.Empty])?.SchemaInfo;
		}

		internal SchemaNames GetSchemaNames(XmlNameTable nt)
		{
			if (nameTable != nt)
			{
				return new SchemaNames(nt);
			}
			if (schemaNames == null)
			{
				schemaNames = new SchemaNames(nameTable);
			}
			return schemaNames;
		}

		internal XmlSchema Add(string ns, SchemaInfo schemaInfo, XmlSchema schema, bool compile)
		{
			return Add(ns, schemaInfo, schema, compile, xmlResolver);
		}

		private XmlSchema Add(string ns, SchemaInfo schemaInfo, XmlSchema schema, bool compile, XmlResolver resolver)
		{
			int num = 0;
			if (schema != null)
			{
				if (schema.ErrorCount == 0 && compile)
				{
					if (!schema.CompileSchema(this, resolver, schemaInfo, ns, validationEventHandler, nameTable, CompileContentModel: true))
					{
						num = 1;
					}
					ns = ((schema.TargetNamespace == null) ? string.Empty : schema.TargetNamespace);
				}
				num += schema.ErrorCount;
			}
			else
			{
				num += schemaInfo.ErrorCount;
				ns = NameTable.Add(ns);
			}
			if (num == 0)
			{
				XmlSchemaCollectionNode xmlSchemaCollectionNode = new XmlSchemaCollectionNode();
				xmlSchemaCollectionNode.NamespaceURI = ns;
				xmlSchemaCollectionNode.SchemaInfo = schemaInfo;
				xmlSchemaCollectionNode.Schema = schema;
				Add(ns, xmlSchemaCollectionNode);
				return schema;
			}
			return null;
		}

		private void Add(string ns, XmlSchemaCollectionNode node)
		{
			if (isThreadSafe)
			{
				wLock.AcquireWriterLock(timeout);
			}
			try
			{
				if (collection[ns] != null)
				{
					collection.Remove(ns);
				}
				collection.Add(ns, node);
			}
			finally
			{
				if (isThreadSafe)
				{
					wLock.ReleaseWriterLock();
				}
			}
		}

		private void SendValidationEvent(XmlSchemaException e)
		{
			if (validationEventHandler != null)
			{
				validationEventHandler(this, new ValidationEventArgs(e));
				return;
			}
			throw e;
		}
	}
	internal sealed class XmlSchemaCollectionNode
	{
		private string namespaceUri;

		private SchemaInfo schemaInfo;

		private XmlSchema schema;

		internal string NamespaceURI
		{
			get
			{
				return namespaceUri;
			}
			set
			{
				namespaceUri = value;
			}
		}

		internal SchemaInfo SchemaInfo
		{
			get
			{
				return schemaInfo;
			}
			set
			{
				schemaInfo = value;
			}
		}

		internal XmlSchema Schema
		{
			get
			{
				return schema;
			}
			set
			{
				schema = value;
			}
		}
	}
	public sealed class XmlSchemaCollectionEnumerator : IEnumerator
	{
		private IDictionaryEnumerator enumerator;

		object IEnumerator.Current => Current;

		public XmlSchema Current => ((XmlSchemaCollectionNode)enumerator.Value)?.Schema;

		internal XmlSchemaCollectionNode CurrentNode => (XmlSchemaCollectionNode)enumerator.Value;

		internal XmlSchemaCollectionEnumerator(Hashtable collection)
		{
			enumerator = collection.GetEnumerator();
		}

		void IEnumerator.Reset()
		{
			enumerator.Reset();
		}

		bool IEnumerator.MoveNext()
		{
			return enumerator.MoveNext();
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}
	}
	public abstract class XmlSchemaContentModel : XmlSchemaAnnotated
	{
		[XmlIgnore]
		public abstract XmlSchemaContent Content { get; set; }
	}
	public class XmlSchemaComplexContent : XmlSchemaContentModel
	{
		private XmlSchemaContent content;

		private bool isMixed;

		private bool hasMixedAttribute;

		[XmlAttribute("mixed")]
		public bool IsMixed
		{
			get
			{
				return isMixed;
			}
			set
			{
				isMixed = value;
				hasMixedAttribute = true;
			}
		}

		[XmlElement("extension", typeof(XmlSchemaComplexContentExtension))]
		[XmlElement("restriction", typeof(XmlSchemaComplexContentRestriction))]
		public override XmlSchemaContent Content
		{
			get
			{
				return content;
			}
			set
			{
				content = value;
			}
		}

		[XmlIgnore]
		internal bool HasMixedAttribute => hasMixedAttribute;
	}
	public abstract class XmlSchemaContent : XmlSchemaAnnotated
	{
	}
	public class XmlSchemaComplexContentExtension : XmlSchemaContent
	{
		private XmlSchemaParticle particle;

		private XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();

		private XmlSchemaAnyAttribute anyAttribute;

		private XmlQualifiedName baseTypeName = XmlQualifiedName.Empty;

		[XmlAttribute("base")]
		public XmlQualifiedName BaseTypeName
		{
			get
			{
				return baseTypeName;
			}
			set
			{
				baseTypeName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlElement("sequence", typeof(XmlSchemaSequence))]
		[XmlElement("group", typeof(XmlSchemaGroupRef))]
		[XmlElement("choice", typeof(XmlSchemaChoice))]
		[XmlElement("all", typeof(XmlSchemaAll))]
		public XmlSchemaParticle Particle
		{
			get
			{
				return particle;
			}
			set
			{
				particle = value;
			}
		}

		[XmlElement("attribute", typeof(XmlSchemaAttribute))]
		[XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
		public XmlSchemaObjectCollection Attributes => attributes;

		[XmlElement("anyAttribute")]
		public XmlSchemaAnyAttribute AnyAttribute
		{
			get
			{
				return anyAttribute;
			}
			set
			{
				anyAttribute = value;
			}
		}

		internal void SetAttributes(XmlSchemaObjectCollection newAttributes)
		{
			attributes = newAttributes;
		}
	}
	public class XmlSchemaComplexContentRestriction : XmlSchemaContent
	{
		private XmlSchemaParticle particle;

		private XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();

		private XmlSchemaAnyAttribute anyAttribute;

		private XmlQualifiedName baseTypeName = XmlQualifiedName.Empty;

		[XmlAttribute("base")]
		public XmlQualifiedName BaseTypeName
		{
			get
			{
				return baseTypeName;
			}
			set
			{
				baseTypeName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlElement("sequence", typeof(XmlSchemaSequence))]
		[XmlElement("group", typeof(XmlSchemaGroupRef))]
		[XmlElement("choice", typeof(XmlSchemaChoice))]
		[XmlElement("all", typeof(XmlSchemaAll))]
		public XmlSchemaParticle Particle
		{
			get
			{
				return particle;
			}
			set
			{
				particle = value;
			}
		}

		[XmlElement("attribute", typeof(XmlSchemaAttribute))]
		[XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
		public XmlSchemaObjectCollection Attributes => attributes;

		[XmlElement("anyAttribute")]
		public XmlSchemaAnyAttribute AnyAttribute
		{
			get
			{
				return anyAttribute;
			}
			set
			{
				anyAttribute = value;
			}
		}

		internal void SetAttributes(XmlSchemaObjectCollection newAttributes)
		{
			attributes = newAttributes;
		}
	}
	public class XmlSchemaType : XmlSchemaAnnotated
	{
		private string name;

		private XmlSchemaDerivationMethod final = XmlSchemaDerivationMethod.None;

		private XmlSchemaDerivationMethod derivedBy;

		private XmlSchemaType baseSchemaType;

		private XmlSchemaDatatype datatype;

		private XmlSchemaDerivationMethod finalResolved;

		private SchemaElementDecl elementDecl;

		private XmlQualifiedName qname = XmlQualifiedName.Empty;

		private XmlSchemaType redefined;

		private XmlSchemaContentType contentType;

		[XmlAttribute("name")]
		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		[XmlAttribute("final")]
		[DefaultValue(XmlSchemaDerivationMethod.None)]
		public XmlSchemaDerivationMethod Final
		{
			get
			{
				return final;
			}
			set
			{
				final = value;
			}
		}

		[XmlIgnore]
		public XmlQualifiedName QualifiedName => qname;

		[XmlIgnore]
		public XmlSchemaDerivationMethod FinalResolved => finalResolved;

		[XmlIgnore]
		[Obsolete("This property has been deprecated. Please use BaseXmlSchemaType property that returns a strongly typed base schema type. http://go.microsoft.com/fwlink/?linkid=14202")]
		public object BaseSchemaType
		{
			get
			{
				if (baseSchemaType.QualifiedName.Namespace == "http://www.w3.org/2001/XMLSchema")
				{
					return baseSchemaType.Datatype;
				}
				return baseSchemaType;
			}
		}

		[XmlIgnore]
		public XmlSchemaType BaseXmlSchemaType => baseSchemaType;

		[XmlIgnore]
		public XmlSchemaDerivationMethod DerivedBy => derivedBy;

		[XmlIgnore]
		public XmlSchemaDatatype Datatype => datatype;

		[XmlIgnore]
		public virtual bool IsMixed
		{
			get
			{
				return false;
			}
			set
			{
			}
		}

		[XmlIgnore]
		public XmlTypeCode TypeCode
		{
			get
			{
				if (this == XmlSchemaComplexType.AnyType)
				{
					return XmlTypeCode.Item;
				}
				if (datatype == null)
				{
					return XmlTypeCode.None;
				}
				return datatype.TypeCode;
			}
		}

		[XmlIgnore]
		internal XmlValueConverter ValueConverter
		{
			get
			{
				if (datatype == null)
				{
					return XmlUntypedConverter.Untyped;
				}
				return datatype.ValueConverter;
			}
		}

		internal XmlSchemaContentType SchemaContentType => contentType;

		internal SchemaElementDecl ElementDecl
		{
			get
			{
				return elementDecl;
			}
			set
			{
				elementDecl = value;
			}
		}

		[XmlIgnore]
		internal XmlSchemaType Redefined
		{
			get
			{
				return redefined;
			}
			set
			{
				redefined = value;
			}
		}

		internal virtual XmlQualifiedName DerivedFrom => XmlQualifiedName.Empty;

		[XmlIgnore]
		internal override string NameAttribute
		{
			get
			{
				return Name;
			}
			set
			{
				Name = value;
			}
		}

		public static XmlSchemaSimpleType GetBuiltInSimpleType(XmlQualifiedName qualifiedName)
		{
			if (qualifiedName == null)
			{
				throw new ArgumentNullException("qualifiedName");
			}
			return DatatypeImplementation.GetSimpleTypeFromXsdType(qualifiedName);
		}

		public static XmlSchemaSimpleType GetBuiltInSimpleType(XmlTypeCode typeCode)
		{
			return DatatypeImplementation.GetSimpleTypeFromTypeCode(typeCode);
		}

		public static XmlSchemaComplexType GetBuiltInComplexType(XmlTypeCode typeCode)
		{
			if (typeCode == XmlTypeCode.Item)
			{
				return XmlSchemaComplexType.AnyType;
			}
			return null;
		}

		public static XmlSchemaComplexType GetBuiltInComplexType(XmlQualifiedName qualifiedName)
		{
			if (qualifiedName == null)
			{
				throw new ArgumentNullException("qualifiedName");
			}
			if (qualifiedName.Equals(XmlSchemaComplexType.AnyType.QualifiedName))
			{
				return XmlSchemaComplexType.AnyType;
			}
			if (qualifiedName.Equals(XmlSchemaComplexType.UntypedAnyType.QualifiedName))
			{
				return XmlSchemaComplexType.UntypedAnyType;
			}
			return null;
		}

		internal XmlReader Validate(XmlReader reader, XmlResolver resolver, XmlSchemaSet schemaSet, ValidationEventHandler valEventHandler)
		{
			if (schemaSet != null)
			{
				XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
				xmlReaderSettings.ValidationType = ValidationType.Schema;
				xmlReaderSettings.Schemas = schemaSet;
				xmlReaderSettings.ValidationEventHandler += valEventHandler;
				return new XsdValidatingReader(reader, resolver, xmlReaderSettings, this);
			}
			return null;
		}

		internal void SetQualifiedName(XmlQualifiedName value)
		{
			qname = value;
		}

		internal void SetFinalResolved(XmlSchemaDerivationMethod value)
		{
			finalResolved = value;
		}

		internal void SetBaseSchemaType(XmlSchemaType value)
		{
			baseSchemaType = value;
		}

		internal void SetDerivedBy(XmlSchemaDerivationMethod value)
		{
			derivedBy = value;
		}

		internal void SetDatatype(XmlSchemaDatatype value)
		{
			datatype = value;
		}

		internal void SetContentType(XmlSchemaContentType value)
		{
			contentType = value;
		}

		public static bool IsDerivedFrom(XmlSchemaType derivedType, XmlSchemaType baseType, XmlSchemaDerivationMethod except)
		{
			if (derivedType == null || baseType == null)
			{
				return false;
			}
			if (derivedType == baseType)
			{
				return true;
			}
			if (baseType == XmlSchemaComplexType.AnyType)
			{
				return true;
			}
			do
			{
				XmlSchemaSimpleType xmlSchemaSimpleType = derivedType as XmlSchemaSimpleType;
				if (baseType is XmlSchemaSimpleType xmlSchemaSimpleType2 && xmlSchemaSimpleType != null)
				{
					if (xmlSchemaSimpleType2 == DatatypeImplementation.AnySimpleType)
					{
						return true;
					}
					if ((except & derivedType.DerivedBy) != 0 || !xmlSchemaSimpleType.Datatype.IsDerivedFrom(xmlSchemaSimpleType2.Datatype))
					{
						return false;
					}
					return true;
				}
				if ((except & derivedType.DerivedBy) != 0)
				{
					return false;
				}
				derivedType = derivedType.BaseXmlSchemaType;
				if (derivedType == baseType)
				{
					return true;
				}
			}
			while (derivedType != null);
			return false;
		}

		internal static bool IsDerivedFromDatatype(XmlSchemaDatatype derivedDataType, XmlSchemaDatatype baseDataType, XmlSchemaDerivationMethod except)
		{
			if (DatatypeImplementation.AnySimpleType.Datatype == baseDataType)
			{
				return true;
			}
			return derivedDataType.IsDerivedFrom(baseDataType);
		}
	}
	public class XmlSchemaComplexType : XmlSchemaType
	{
		private const byte wildCardMask = 1;

		private const byte dupDeclMask = 2;

		private const byte isMixedMask = 4;

		private const byte isAbstractMask = 8;

		private XmlSchemaDerivationMethod block = XmlSchemaDerivationMethod.None;

		private XmlSchemaContentModel contentModel;

		private XmlSchemaParticle particle;

		private XmlSchemaObjectCollection attributes;

		private XmlSchemaAnyAttribute anyAttribute;

		private XmlSchemaParticle contentTypeParticle = XmlSchemaParticle.Empty;

		private XmlSchemaDerivationMethod blockResolved;

		private XmlSchemaObjectTable localElements;

		private XmlSchemaObjectTable attributeUses;

		private XmlSchemaAnyAttribute attributeWildcard;

		private static XmlSchemaComplexType anyTypeLax;

		private static XmlSchemaComplexType anyTypeSkip;

		private static XmlSchemaComplexType untypedAnyType;

		private byte pvFlags;

		[XmlIgnore]
		internal static XmlSchemaComplexType AnyType => anyTypeLax;

		[XmlIgnore]
		internal static XmlSchemaComplexType UntypedAnyType => untypedAnyType;

		[XmlIgnore]
		internal static XmlSchemaComplexType AnyTypeSkip => anyTypeSkip;

		internal static ContentValidator AnyTypeContentValidator => anyTypeLax.ElementDecl.ContentValidator;

		[XmlAttribute("abstract")]
		[DefaultValue(false)]
		public bool IsAbstract
		{
			get
			{
				return (pvFlags & 8) != 0;
			}
			set
			{
				if (value)
				{
					pvFlags |= 8;
				}
				else
				{
					pvFlags = (byte)(pvFlags & 0xFFFFFFF7u);
				}
			}
		}

		[XmlAttribute("block")]
		[DefaultValue(XmlSchemaDerivationMethod.None)]
		public XmlSchemaDerivationMethod Block
		{
			get
			{
				return block;
			}
			set
			{
				block = value;
			}
		}

		[DefaultValue(false)]
		[XmlAttribute("mixed")]
		public override bool IsMixed
		{
			get
			{
				return (pvFlags & 4) != 0;
			}
			set
			{
				if (value)
				{
					pvFlags |= 4;
				}
				else
				{
					pvFlags = (byte)(pvFlags & 0xFFFFFFFBu);
				}
			}
		}

		[XmlElement("complexContent", typeof(XmlSchemaComplexContent))]
		[XmlElement("simpleContent", typeof(XmlSchemaSimpleContent))]
		public XmlSchemaContentModel ContentModel
		{
			get
			{
				return contentModel;
			}
			set
			{
				contentModel = value;
			}
		}

		[XmlElement("sequence", typeof(XmlSchemaSequence))]
		[XmlElement("all", typeof(XmlSchemaAll))]
		[XmlElement("choice", typeof(XmlSchemaChoice))]
		[XmlElement("group", typeof(XmlSchemaGroupRef))]
		public XmlSchemaParticle Particle
		{
			get
			{
				return particle;
			}
			set
			{
				particle = value;
			}
		}

		[XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
		[XmlElement("attribute", typeof(XmlSchemaAttribute))]
		public XmlSchemaObjectCollection Attributes
		{
			get
			{
				if (attributes == null)
				{
					attributes = new XmlSchemaObjectCollection();
				}
				return attributes;
			}
		}

		[XmlElement("anyAttribute")]
		public XmlSchemaAnyAttribute AnyAttribute
		{
			get
			{
				return anyAttribute;
			}
			set
			{
				anyAttribute = value;
			}
		}

		[XmlIgnore]
		public XmlSchemaContentType ContentType => base.SchemaContentType;

		[XmlIgnore]
		public XmlSchemaParticle ContentTypeParticle => contentTypeParticle;

		[XmlIgnore]
		public XmlSchemaDerivationMethod BlockResolved => blockResolved;

		[XmlIgnore]
		public XmlSchemaObjectTable AttributeUses
		{
			get
			{
				if (attributeUses == null)
				{
					attributeUses = new XmlSchemaObjectTable();
				}
				return attributeUses;
			}
		}

		[XmlIgnore]
		public XmlSchemaAnyAttribute AttributeWildcard => attributeWildcard;

		[XmlIgnore]
		internal XmlSchemaObjectTable LocalElements
		{
			get
			{
				if (localElements == null)
				{
					localElements = new XmlSchemaObjectTable();
				}
				return localElements;
			}
		}

		internal bool HasWildCard
		{
			get
			{
				return (pvFlags & 1) != 0;
			}
			set
			{
				if (value)
				{
					pvFlags |= 1;
				}
				else
				{
					pvFlags = (byte)(pvFlags & 0xFFFFFFFEu);
				}
			}
		}

		internal bool HasDuplicateDecls
		{
			get
			{
				return (pvFlags & 2) != 0;
			}
			set
			{
				if (value)
				{
					pvFlags |= 2;
				}
				else
				{
					pvFlags = (byte)(pvFlags & 0xFFFFFFFDu);
				}
			}
		}

		internal override XmlQualifiedName DerivedFrom
		{
			get
			{
				if (contentModel == null)
				{
					return XmlQualifiedName.Empty;
				}
				if (contentModel.Content is XmlSchemaComplexContentRestriction)
				{
					return ((XmlSchemaComplexContentRestriction)contentModel.Content).BaseTypeName;
				}
				if (contentModel.Content is XmlSchemaComplexContentExtension)
				{
					return ((XmlSchemaComplexContentExtension)contentModel.Content).BaseTypeName;
				}
				if (contentModel.Content is XmlSchemaSimpleContentRestriction)
				{
					return ((XmlSchemaSimpleContentRestriction)contentModel.Content).BaseTypeName;
				}
				if (contentModel.Content is XmlSchemaSimpleContentExtension)
				{
					return ((XmlSchemaSimpleContentExtension)contentModel.Content).BaseTypeName;
				}
				return XmlQualifiedName.Empty;
			}
		}

		static XmlSchemaComplexType()
		{
			anyTypeLax = CreateAnyType(XmlSchemaContentProcessing.Lax);
			anyTypeSkip = CreateAnyType(XmlSchemaContentProcessing.Skip);
			untypedAnyType = new XmlSchemaComplexType();
			untypedAnyType.SetQualifiedName(new XmlQualifiedName("untypedAny", "http://www.w3.org/2003/11/xpath-datatypes"));
			untypedAnyType.IsMixed = true;
			untypedAnyType.SetContentTypeParticle(anyTypeLax.ContentTypeParticle);
			untypedAnyType.SetContentType(XmlSchemaContentType.Mixed);
			untypedAnyType.ElementDecl = SchemaElementDecl.CreateAnyTypeElementDecl();
			untypedAnyType.ElementDecl.SchemaType = untypedAnyType;
			untypedAnyType.ElementDecl.ContentValidator = AnyTypeContentValidator;
		}

		private static XmlSchemaComplexType CreateAnyType(XmlSchemaContentProcessing processContents)
		{
			XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();
			xmlSchemaComplexType.SetQualifiedName(DatatypeImplementation.QnAnyType);
			XmlSchemaAny xmlSchemaAny = new XmlSchemaAny();
			xmlSchemaAny.MinOccurs = 0m;
			xmlSchemaAny.MaxOccurs = decimal.MaxValue;
			xmlSchemaAny.ProcessContents = processContents;
			xmlSchemaAny.BuildNamespaceList(null);
			XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
			xmlSchemaSequence.Items.Add(xmlSchemaAny);
			xmlSchemaComplexType.SetContentTypeParticle(xmlSchemaSequence);
			xmlSchemaComplexType.SetContentType(XmlSchemaContentType.Mixed);
			xmlSchemaComplexType.ElementDecl = SchemaElementDecl.CreateAnyTypeElementDecl();
			xmlSchemaComplexType.ElementDecl.SchemaType = xmlSchemaComplexType;
			ParticleContentValidator particleContentValidator = new ParticleContentValidator(XmlSchemaContentType.Mixed);
			particleContentValidator.Start();
			particleContentValidator.OpenGroup();
			particleContentValidator.AddNamespaceList(xmlSchemaAny.NamespaceList, xmlSchemaAny);
			particleContentValidator.AddStar();
			particleContentValidator.CloseGroup();
			ContentValidator contentValidator = particleContentValidator.Finish(useDFA: true);
			xmlSchemaComplexType.ElementDecl.ContentValidator = contentValidator;
			XmlSchemaAnyAttribute xmlSchemaAnyAttribute = new XmlSchemaAnyAttribute();
			xmlSchemaAnyAttribute.ProcessContents = processContents;
			xmlSchemaAnyAttribute.BuildNamespaceList(null);
			xmlSchemaComplexType.SetAttributeWildcard(xmlSchemaAnyAttribute);
			xmlSchemaComplexType.ElementDecl.AnyAttribute = xmlSchemaAnyAttribute;
			return xmlSchemaComplexType;
		}

		internal void SetContentTypeParticle(XmlSchemaParticle value)
		{
			contentTypeParticle = value;
		}

		internal void SetBlockResolved(XmlSchemaDerivationMethod value)
		{
			blockResolved = value;
		}

		internal void SetAttributeWildcard(XmlSchemaAnyAttribute value)
		{
			attributeWildcard = value;
		}

		internal void SetAttributes(XmlSchemaObjectCollection newAttributes)
		{
			attributes = newAttributes;
		}

		internal bool ContainsIdAttribute(bool findAll)
		{
			int num = 0;
			foreach (XmlSchemaAttribute value in AttributeUses.Values)
			{
				if (value.Use == XmlSchemaUse.Prohibited)
				{
					continue;
				}
				XmlSchemaDatatype xmlSchemaDatatype = value.Datatype;
				if (xmlSchemaDatatype != null && xmlSchemaDatatype.TypeCode == XmlTypeCode.Id)
				{
					num++;
					if (num > 1)
					{
						break;
					}
				}
			}
			if (!findAll)
			{
				return num > 0;
			}
			return num > 1;
		}

		internal override XmlSchemaObject Clone()
		{
			XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)MemberwiseClone();
			if (xmlSchemaComplexType.ContentModel != null)
			{
				if (xmlSchemaComplexType.ContentModel is XmlSchemaSimpleContent xmlSchemaSimpleContent)
				{
					XmlSchemaSimpleContent xmlSchemaSimpleContent2 = (XmlSchemaSimpleContent)xmlSchemaSimpleContent.Clone();
					if (xmlSchemaSimpleContent.Content is XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension)
					{
						XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension2 = (XmlSchemaSimpleContentExtension)xmlSchemaSimpleContentExtension.Clone();
						xmlSchemaSimpleContentExtension2.BaseTypeName = xmlSchemaSimpleContentExtension.BaseTypeName.Clone();
						xmlSchemaSimpleContentExtension2.SetAttributes(CloneAttributes(xmlSchemaSimpleContentExtension.Attributes));
						xmlSchemaSimpleContent2.Content = xmlSchemaSimpleContentExtension2;
					}
					else
					{
						XmlSchemaSimpleContentRestriction xmlSchemaSimpleContentRestriction = (XmlSchemaSimpleContentRestriction)xmlSchemaSimpleContent.Content;
						XmlSchemaSimpleContentRestriction xmlSchemaSimpleContentRestriction2 = (XmlSchemaSimpleContentRestriction)xmlSchemaSimpleContentRestriction.Clone();
						xmlSchemaSimpleContentRestriction2.BaseTypeName = xmlSchemaSimpleContentRestriction.BaseTypeName.Clone();
						xmlSchemaSimpleContentRestriction2.SetAttributes(CloneAttributes(xmlSchemaSimpleContentRestriction.Attributes));
						xmlSchemaSimpleContent2.Content = xmlSchemaSimpleContentRestriction2;
					}
					xmlSchemaComplexType.ContentModel = xmlSchemaSimpleContent2;
				}
				else
				{
					XmlSchemaComplexContent xmlSchemaComplexContent = (XmlSchemaComplexContent)xmlSchemaComplexType.ContentModel;
					XmlSchemaComplexContent xmlSchemaComplexContent2 = (XmlSchemaComplexContent)xmlSchemaComplexContent.Clone();
					if (xmlSchemaComplexContent.Content is XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension)
					{
						XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension2 = (XmlSchemaComplexContentExtension)xmlSchemaComplexContentExtension.Clone();
						xmlSchemaComplexContentExtension2.BaseTypeName = xmlSchemaComplexContentExtension.BaseTypeName.Clone();
						xmlSchemaComplexContentExtension2.SetAttributes(CloneAttributes(xmlSchemaComplexContentExtension.Attributes));
						if (HasParticleRef(xmlSchemaComplexContentExtension.Particle))
						{
							xmlSchemaComplexContentExtension2.Particle = CloneParticle(xmlSchemaComplexContentExtension.Particle);
						}
						xmlSchemaComplexContent2.Content = xmlSchemaComplexContentExtension2;
					}
					else
					{
						XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction = xmlSchemaComplexContent.Content as XmlSchemaComplexContentRestriction;
						XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction2 = (XmlSchemaComplexContentRestriction)xmlSchemaComplexContentRestriction.Clone();
						xmlSchemaComplexContentRestriction2.BaseTypeName = xmlSchemaComplexContentRestriction.BaseTypeName.Clone();
						xmlSchemaComplexContentRestriction2.SetAttributes(CloneAttributes(xmlSchemaComplexContentRestriction.Attributes));
						if (HasParticleRef(xmlSchemaComplexContentRestriction2.Particle))
						{
							xmlSchemaComplexContentRestriction2.Particle = CloneParticle(xmlSchemaComplexContentRestriction2.Particle);
						}
						xmlSchemaComplexContent2.Content = xmlSchemaComplexContentRestriction2;
					}
					xmlSchemaComplexType.ContentModel = xmlSchemaComplexContent2;
				}
			}
			else
			{
				if (HasParticleRef(xmlSchemaComplexType.Particle))
				{
					xmlSchemaComplexType.Particle = CloneParticle(xmlSchemaComplexType.Particle);
				}
				xmlSchemaComplexType.SetAttributes(CloneAttributes(xmlSchemaComplexType.Attributes));
			}
			xmlSchemaComplexType.ClearCompiledState();
			return xmlSchemaComplexType;
		}

		private void ClearCompiledState()
		{
			attributeUses = null;
			localElements = null;
			attributeWildcard = null;
			contentTypeParticle = XmlSchemaParticle.Empty;
			blockResolved = XmlSchemaDerivationMethod.None;
		}

		internal static XmlSchemaObjectCollection CloneAttributes(XmlSchemaObjectCollection attributes)
		{
			if (HasAttributeQNameRef(attributes))
			{
				XmlSchemaObjectCollection xmlSchemaObjectCollection = attributes.Clone();
				for (int i = 0; i < attributes.Count; i++)
				{
					XmlSchemaObject xmlSchemaObject = attributes[i];
					if (xmlSchemaObject is XmlSchemaAttributeGroupRef xmlSchemaAttributeGroupRef)
					{
						XmlSchemaAttributeGroupRef xmlSchemaAttributeGroupRef2 = (XmlSchemaAttributeGroupRef)xmlSchemaAttributeGroupRef.Clone();
						xmlSchemaAttributeGroupRef2.RefName = xmlSchemaAttributeGroupRef.RefName.Clone();
						xmlSchemaObjectCollection[i] = xmlSchemaAttributeGroupRef2;
						continue;
					}
					XmlSchemaAttribute xmlSchemaAttribute = xmlSchemaObject as XmlSchemaAttribute;
					if (!xmlSchemaAttribute.RefName.IsEmpty || !xmlSchemaAttribute.SchemaTypeName.IsEmpty)
					{
						xmlSchemaObjectCollection[i] = xmlSchemaAttribute.Clone();
					}
				}
				return xmlSchemaObjectCollection;
			}
			return attributes;
		}

		private static XmlSchemaObjectCollection CloneGroupBaseParticles(XmlSchemaObjectCollection groupBaseParticles)
		{
			XmlSchemaObjectCollection xmlSchemaObjectCollection = groupBaseParticles.Clone();
			for (int i = 0; i < groupBaseParticles.Count; i++)
			{
				XmlSchemaParticle xmlSchemaParticle = (XmlSchemaParticle)groupBaseParticles[i];
				xmlSchemaObjectCollection[i] = CloneParticle(xmlSchemaParticle);
			}
			return xmlSchemaObjectCollection;
		}

		internal static XmlSchemaParticle CloneParticle(XmlSchemaParticle particle)
		{
			if (particle is XmlSchemaGroupBase xmlSchemaGroupBase && !(xmlSchemaGroupBase is XmlSchemaAll))
			{
				XmlSchemaGroupBase xmlSchemaGroupBase2 = xmlSchemaGroupBase;
				XmlSchemaObjectCollection items = CloneGroupBaseParticles(xmlSchemaGroupBase.Items);
				xmlSchemaGroupBase2 = (XmlSchemaGroupBase)xmlSchemaGroupBase.Clone();
				xmlSchemaGroupBase2.SetItems(items);
				return xmlSchemaGroupBase2;
			}
			if (particle is XmlSchemaGroupRef)
			{
				XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef)particle.Clone();
				xmlSchemaGroupRef.RefName = xmlSchemaGroupRef.RefName.Clone();
				return xmlSchemaGroupRef;
			}
			if (particle is XmlSchemaElement xmlSchemaElement && (!xmlSchemaElement.RefName.IsEmpty || !xmlSchemaElement.SchemaTypeName.IsEmpty))
			{
				return (XmlSchemaElement)xmlSchemaElement.Clone();
			}
			return particle;
		}

		internal static bool HasParticleRef(XmlSchemaParticle particle)
		{
			if (particle is XmlSchemaGroupBase xmlSchemaGroupBase && !(xmlSchemaGroupBase is XmlSchemaAll))
			{
				bool flag = false;
				int num = 0;
				while (num < xmlSchemaGroupBase.Items.Count && !flag)
				{
					XmlSchemaParticle xmlSchemaParticle = (XmlSchemaParticle)xmlSchemaGroupBase.Items[num++];
					flag = xmlSchemaParticle is XmlSchemaGroupRef || (xmlSchemaParticle is XmlSchemaElement xmlSchemaElement && (!xmlSchemaElement.RefName.IsEmpty || !xmlSchemaElement.SchemaTypeName.IsEmpty)) || HasParticleRef(xmlSchemaParticle);
				}
				return flag;
			}
			if (particle is XmlSchemaGroupRef)
			{
				return true;
			}
			return false;
		}

		internal static bool HasAttributeQNameRef(XmlSchemaObjectCollection attributes)
		{
			foreach (XmlSchemaObject attribute in attributes)
			{
				if (attribute is XmlSchemaAttributeGroupRef)
				{
					return true;
				}
				XmlSchemaAttribute xmlSchemaAttribute = attribute as XmlSchemaAttribute;
				if (!xmlSchemaAttribute.RefName.IsEmpty || !xmlSchemaAttribute.SchemaTypeName.IsEmpty)
				{
					return true;
				}
			}
			return false;
		}
	}
	public enum XmlSchemaContentProcessing
	{
		[XmlIgnore]
		None,
		[XmlEnum("skip")]
		Skip,
		[XmlEnum("lax")]
		Lax,
		[XmlEnum("strict")]
		Strict
	}
	public enum XmlSchemaContentType
	{
		TextOnly,
		Empty,
		ElementOnly,
		Mixed
	}
	[Flags]
	public enum XmlSchemaDerivationMethod
	{
		[XmlEnum("")]
		Empty = 0,
		[XmlEnum("substitution")]
		Substitution = 1,
		[XmlEnum("extension")]
		Extension = 2,
		[XmlEnum("restriction")]
		Restriction = 4,
		[XmlEnum("list")]
		List = 8,
		[XmlEnum("union")]
		Union = 0x10,
		[XmlEnum("#all")]
		All = 0xFF,
		[XmlIgnore]
		None = 0x100
	}
	public class XmlSchemaDocumentation : XmlSchemaObject
	{
		private string source;

		private string language;

		private XmlNode[] markup;

		private static XmlSchemaSimpleType languageType = DatatypeImplementation.GetSimpleTypeFromXsdType(new XmlQualifiedName("language", "http://www.w3.org/2001/XMLSchema"));

		[XmlAttribute("source", DataType = "anyURI")]
		public string Source
		{
			get
			{
				return source;
			}
			set
			{
				source = value;
			}
		}

		[XmlAttribute("xml:lang")]
		public string Language
		{
			get
			{
				return language;
			}
			set
			{
				language = (string)languageType.Datatype.ParseValue(value, null, null);
			}
		}

		[XmlText]
		[XmlAnyElement]
		public XmlNode[] Markup
		{
			get
			{
				return markup;
			}
			set
			{
				markup = value;
			}
		}
	}
	public class XmlSchemaElement : XmlSchemaParticle
	{
		private bool isAbstract;

		private bool hasAbstractAttribute;

		private bool isNillable;

		private bool hasNillableAttribute;

		private bool isLocalTypeDerivationChecked;

		private XmlSchemaDerivationMethod block = XmlSchemaDerivationMethod.None;

		private XmlSchemaDerivationMethod final = XmlSchemaDerivationMethod.None;

		private XmlSchemaForm form;

		private string defaultValue;

		private string fixedValue;

		private string name;

		private XmlQualifiedName refName = XmlQualifiedName.Empty;

		private XmlQualifiedName substitutionGroup = XmlQualifiedName.Empty;

		private XmlQualifiedName typeName = XmlQualifiedName.Empty;

		private XmlSchemaType type;

		private XmlQualifiedName qualifiedName = XmlQualifiedName.Empty;

		private XmlSchemaType elementType;

		private XmlSchemaDerivationMethod blockResolved;

		private XmlSchemaDerivationMethod finalResolved;

		private XmlSchemaObjectCollection constraints;

		private SchemaElementDecl elementDecl;

		[DefaultValue(false)]
		[XmlAttribute("abstract")]
		public bool IsAbstract
		{
			get
			{
				return isAbstract;
			}
			set
			{
				isAbstract = value;
				hasAbstractAttribute = true;
			}
		}

		[DefaultValue(XmlSchemaDerivationMethod.None)]
		[XmlAttribute("block")]
		public XmlSchemaDerivationMethod Block
		{
			get
			{
				return block;
			}
			set
			{
				block = value;
			}
		}

		[XmlAttribute("default")]
		[DefaultValue(null)]
		public string DefaultValue
		{
			get
			{
				return defaultValue;
			}
			set
			{
				defaultValue = value;
			}
		}

		[DefaultValue(XmlSchemaDerivationMethod.None)]
		[XmlAttribute("final")]
		public XmlSchemaDerivationMethod Final
		{
			get
			{
				return final;
			}
			set
			{
				final = value;
			}
		}

		[DefaultValue(null)]
		[XmlAttribute("fixed")]
		public string FixedValue
		{
			get
			{
				return fixedValue;
			}
			set
			{
				fixedValue = value;
			}
		}

		[XmlAttribute("form")]
		[DefaultValue(XmlSchemaForm.None)]
		public XmlSchemaForm Form
		{
			get
			{
				return form;
			}
			set
			{
				form = value;
			}
		}

		[DefaultValue("")]
		[XmlAttribute("name")]
		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		[DefaultValue(false)]
		[XmlAttribute("nillable")]
		public bool IsNillable
		{
			get
			{
				return isNillable;
			}
			set
			{
				isNillable = value;
				hasNillableAttribute = true;
			}
		}

		[XmlIgnore]
		internal bool HasNillableAttribute => hasNillableAttribute;

		[XmlIgnore]
		internal bool HasAbstractAttribute => hasAbstractAttribute;

		[XmlAttribute("ref")]
		public XmlQualifiedName RefName
		{
			get
			{
				return refName;
			}
			set
			{
				refName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlAttribute("substitutionGroup")]
		public XmlQualifiedName SubstitutionGroup
		{
			get
			{
				return substitutionGroup;
			}
			set
			{
				substitutionGroup = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlAttribute("type")]
		public XmlQualifiedName SchemaTypeName
		{
			get
			{
				return typeName;
			}
			set
			{
				typeName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
		[XmlElement("complexType", typeof(XmlSchemaComplexType))]
		public XmlSchemaType SchemaType
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		[XmlElement("keyref", typeof(XmlSchemaKeyref))]
		[XmlElement("unique", typeof(XmlSchemaUnique))]
		[XmlElement("key", typeof(XmlSchemaKey))]
		public XmlSchemaObjectCollection Constraints
		{
			get
			{
				if (constraints == null)
				{
					constraints = new XmlSchemaObjectCollection();
				}
				return constraints;
			}
		}

		[XmlIgnore]
		public XmlQualifiedName QualifiedName => qualifiedName;

		[Obsolete("This property has been deprecated. Please use ElementSchemaType property that returns a strongly typed element type. http://go.microsoft.com/fwlink/?linkid=14202")]
		[XmlIgnore]
		public object ElementType
		{
			get
			{
				if (elementType.QualifiedName.Namespace == "http://www.w3.org/2001/XMLSchema")
				{
					return elementType.Datatype;
				}
				return elementType;
			}
		}

		[XmlIgnore]
		public XmlSchemaType ElementSchemaType => elementType;

		[XmlIgnore]
		public XmlSchemaDerivationMethod BlockResolved => blockResolved;

		[XmlIgnore]
		public XmlSchemaDerivationMethod FinalResolved => finalResolved;

		[XmlIgnore]
		internal bool HasDefault
		{
			get
			{
				if (defaultValue != null)
				{
					return defaultValue.Length > 0;
				}
				return false;
			}
		}

		internal bool HasConstraints
		{
			get
			{
				if (constraints != null)
				{
					return constraints.Count > 0;
				}
				return false;
			}
		}

		internal bool IsLocalTypeDerivationChecked
		{
			get
			{
				return isLocalTypeDerivationChecked;
			}
			set
			{
				isLocalTypeDerivationChecked = value;
			}
		}

		internal SchemaElementDecl ElementDecl
		{
			get
			{
				return elementDecl;
			}
			set
			{
				elementDecl = value;
			}
		}

		[XmlIgnore]
		internal override string NameAttribute
		{
			get
			{
				return Name;
			}
			set
			{
				Name = value;
			}
		}

		[XmlIgnore]
		internal override string NameString => qualifiedName.ToString();

		internal XmlReader Validate(XmlReader reader, XmlResolver resolver, XmlSchemaSet schemaSet, ValidationEventHandler valEventHandler)
		{
			if (schemaSet != null)
			{
				XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
				xmlReaderSettings.ValidationType = ValidationType.Schema;
				xmlReaderSettings.Schemas = schemaSet;
				xmlReaderSettings.ValidationEventHandler += valEventHandler;
				return new XsdValidatingReader(reader, resolver, xmlReaderSettings, this);
			}
			return null;
		}

		internal void SetQualifiedName(XmlQualifiedName value)
		{
			qualifiedName = value;
		}

		internal void SetElementType(XmlSchemaType value)
		{
			elementType = value;
		}

		internal void SetBlockResolved(XmlSchemaDerivationMethod value)
		{
			blockResolved = value;
		}

		internal void SetFinalResolved(XmlSchemaDerivationMethod value)
		{
			finalResolved = value;
		}

		internal override XmlSchemaObject Clone()
		{
			XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)MemberwiseClone();
			xmlSchemaElement.refName = refName.Clone();
			xmlSchemaElement.substitutionGroup = substitutionGroup.Clone();
			xmlSchemaElement.typeName = typeName.Clone();
			xmlSchemaElement.constraints = null;
			return xmlSchemaElement;
		}
	}
	[Serializable]
	public class XmlSchemaException : SystemException
	{
		private string res;

		private string[] args;

		private string sourceUri;

		private int lineNumber;

		private int linePosition;

		[NonSerialized]
		private XmlSchemaObject sourceSchemaObject;

		private string message;

		internal string GetRes => res;

		internal string[] Args => args;

		public string SourceUri => sourceUri;

		public int LineNumber => lineNumber;

		public int LinePosition => linePosition;

		public XmlSchemaObject SourceSchemaObject => sourceSchemaObject;

		public override string Message
		{
			get
			{
				if (message != null)
				{
					return message;
				}
				return base.Message;
			}
		}

		protected XmlSchemaException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			res = (string)info.GetValue("res", typeof(string));
			args = (string[])info.GetValue("args", typeof(string[]));
			sourceUri = (string)info.GetValue("sourceUri", typeof(string));
			lineNumber = (int)info.GetValue("lineNumber", typeof(int));
			linePosition = (int)info.GetValue("linePosition", typeof(int));
			string text = null;
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				if (current.Name == "version")
				{
					text = (string)current.Value;
				}
			}
			if (text == null)
			{
				message = CreateMessage(res, args);
			}
			else
			{
				message = null;
			}
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("res", res);
			info.AddValue("args", args);
			info.AddValue("sourceUri", sourceUri);
			info.AddValue("lineNumber", lineNumber);
			info.AddValue("linePosition", linePosition);
			info.AddValue("version", "2.0");
		}

		public XmlSchemaException()
			: this(null)
		{
		}

		public XmlSchemaException(string message)
			: this(message, (Exception)null, 0, 0)
		{
		}

		public XmlSchemaException(string message, Exception innerException)
			: this(message, innerException, 0, 0)
		{
		}

		public XmlSchemaException(string message, Exception innerException, int lineNumber, int linePosition)
			: this((message == null) ? "Sch_DefaultException" : "Xml_UserException", new string[1] { message }, innerException, null, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaException(string res, string[] args)
			: this(res, args, null, null, 0, 0, null)
		{
		}

		internal XmlSchemaException(string res, string arg)
			: this(res, new string[1] { arg }, null, null, 0, 0, null)
		{
		}

		internal XmlSchemaException(string res, string arg, string sourceUri, int lineNumber, int linePosition)
			: this(res, new string[1] { arg }, null, sourceUri, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaException(string res, string sourceUri, int lineNumber, int linePosition)
			: this(res, null, null, sourceUri, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaException(string res, string[] args, string sourceUri, int lineNumber, int linePosition)
			: this(res, args, null, sourceUri, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaException(string res, XmlSchemaObject source)
			: this(res, (string[])null, source)
		{
		}

		internal XmlSchemaException(string res, string arg, XmlSchemaObject source)
			: this(res, new string[1] { arg }, source)
		{
		}

		internal XmlSchemaException(string res, string[] args, XmlSchemaObject source)
			: this(res, args, null, source.SourceUri, source.LineNumber, source.LinePosition, source)
		{
		}

		internal XmlSchemaException(string res, string[] args, Exception innerException, string sourceUri, int lineNumber, int linePosition, XmlSchemaObject source)
			: base(CreateMessage(res, args), innerException)
		{
			base.HResult = -2146231999;
			this.res = res;
			this.args = args;
			this.sourceUri = sourceUri;
			this.lineNumber = lineNumber;
			this.linePosition = linePosition;
			sourceSchemaObject = source;
		}

		internal static string CreateMessage(string res, string[] args)
		{
			try
			{
				return Res.GetString(res, args);
			}
			catch (MissingManifestResourceException)
			{
				return "UNKNOWN(" + res + ")";
			}
		}

		internal void SetSource(string sourceUri, int lineNumber, int linePosition)
		{
			this.sourceUri = sourceUri;
			this.lineNumber = lineNumber;
			this.linePosition = linePosition;
		}

		internal void SetSchemaObject(XmlSchemaObject source)
		{
			sourceSchemaObject = source;
		}

		internal void SetSource(XmlSchemaObject source)
		{
			sourceSchemaObject = source;
			sourceUri = source.SourceUri;
			lineNumber = source.LineNumber;
			linePosition = source.LinePosition;
		}

		internal void SetResourceId(string resourceId)
		{
			res = resourceId;
		}
	}
	public abstract class XmlSchemaExternal : XmlSchemaObject
	{
		private string location;

		private Uri baseUri;

		private XmlSchema schema;

		private string id;

		private XmlAttribute[] moreAttributes;

		private Compositor compositor;

		[XmlAttribute("schemaLocation", DataType = "anyURI")]
		public string SchemaLocation
		{
			get
			{
				return location;
			}
			set
			{
				location = value;
			}
		}

		[XmlIgnore]
		public XmlSchema Schema
		{
			get
			{
				return schema;
			}
			set
			{
				schema = value;
			}
		}

		[XmlAttribute("id", DataType = "ID")]
		public string Id
		{
			get
			{
				return id;
			}
			set
			{
				id = value;
			}
		}

		[XmlAnyAttribute]
		public XmlAttribute[] UnhandledAttributes
		{
			get
			{
				return moreAttributes;
			}
			set
			{
				moreAttributes = value;
			}
		}

		[XmlIgnore]
		internal Uri BaseUri
		{
			get
			{
				return baseUri;
			}
			set
			{
				baseUri = value;
			}
		}

		[XmlIgnore]
		internal override string IdAttribute
		{
			get
			{
				return Id;
			}
			set
			{
				Id = value;
			}
		}

		internal Compositor Compositor
		{
			get
			{
				return compositor;
			}
			set
			{
				compositor = value;
			}
		}

		internal override void SetUnhandledAttributes(XmlAttribute[] moreAttributes)
		{
			this.moreAttributes = moreAttributes;
		}
	}
	internal enum FacetType
	{
		None,
		Length,
		MinLength,
		MaxLength,
		Pattern,
		Whitespace,
		Enumeration,
		MinExclusive,
		MinInclusive,
		MaxExclusive,
		MaxInclusive,
		TotalDigits,
		FractionDigits
	}
	public abstract class XmlSchemaFacet : XmlSchemaAnnotated
	{
		private string value;

		private bool isFixed;

		private FacetType facetType;

		[XmlAttribute("value")]
		public string Value
		{
			get
			{
				return value;
			}
			set
			{
				this.value = value;
			}
		}

		[DefaultValue(false)]
		[XmlAttribute("fixed")]
		public virtual bool IsFixed
		{
			get
			{
				return isFixed;
			}
			set
			{
				if (!(this is XmlSchemaEnumerationFacet) && !(this is XmlSchemaPatternFacet))
				{
					isFixed = value;
				}
			}
		}

		internal FacetType FacetType
		{
			get
			{
				return facetType;
			}
			set
			{
				facetType = value;
			}
		}
	}
	public abstract class XmlSchemaNumericFacet : XmlSchemaFacet
	{
	}
	public class XmlSchemaLengthFacet : XmlSchemaNumericFacet
	{
		public XmlSchemaLengthFacet()
		{
			base.FacetType = FacetType.Length;
		}
	}
	public class XmlSchemaMinLengthFacet : XmlSchemaNumericFacet
	{
		public XmlSchemaMinLengthFacet()
		{
			base.FacetType = FacetType.MinLength;
		}
	}
	public class XmlSchemaMaxLengthFacet : XmlSchemaNumericFacet
	{
		public XmlSchemaMaxLengthFacet()
		{
			base.FacetType = FacetType.MaxLength;
		}
	}
	public class XmlSchemaPatternFacet : XmlSchemaFacet
	{
		public XmlSchemaPatternFacet()
		{
			base.FacetType = FacetType.Pattern;
		}
	}
	public class XmlSchemaEnumerationFacet : XmlSchemaFacet
	{
		public XmlSchemaEnumerationFacet()
		{
			base.FacetType = FacetType.Enumeration;
		}
	}
	public class XmlSchemaMinExclusiveFacet : XmlSchemaFacet
	{
		public XmlSchemaMinExclusiveFacet()
		{
			base.FacetType = FacetType.MinExclusive;
		}
	}
	public class XmlSchemaMinInclusiveFacet : XmlSchemaFacet
	{
		public XmlSchemaMinInclusiveFacet()
		{
			base.FacetType = FacetType.MinInclusive;
		}
	}
	public class XmlSchemaMaxExclusiveFacet : XmlSchemaFacet
	{
		public XmlSchemaMaxExclusiveFacet()
		{
			base.FacetType = FacetType.MaxExclusive;
		}
	}
	public class XmlSchemaMaxInclusiveFacet : XmlSchemaFacet
	{
		public XmlSchemaMaxInclusiveFacet()
		{
			base.FacetType = FacetType.MaxInclusive;
		}
	}
	public class XmlSchemaTotalDigitsFacet : XmlSchemaNumericFacet
	{
		public XmlSchemaTotalDigitsFacet()
		{
			base.FacetType = FacetType.TotalDigits;
		}
	}
	public class XmlSchemaFractionDigitsFacet : XmlSchemaNumericFacet
	{
		public XmlSchemaFractionDigitsFacet()
		{
			base.FacetType = FacetType.FractionDigits;
		}
	}
	public class XmlSchemaWhiteSpaceFacet : XmlSchemaFacet
	{
		public XmlSchemaWhiteSpaceFacet()
		{
			base.FacetType = FacetType.Whitespace;
		}
	}
	public enum XmlSchemaForm
	{
		[XmlIgnore]
		None,
		[XmlEnum("qualified")]
		Qualified,
		[XmlEnum("unqualified")]
		Unqualified
	}
	public class XmlSchemaGroup : XmlSchemaAnnotated
	{
		private string name;

		private XmlSchemaGroupBase particle;

		private XmlSchemaParticle canonicalParticle;

		private XmlQualifiedName qname = XmlQualifiedName.Empty;

		private XmlSchemaGroup redefined;

		private int selfReferenceCount;

		[XmlAttribute("name")]
		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		[XmlElement("choice", typeof(XmlSchemaChoice))]
		[XmlElement("all", typeof(XmlSchemaAll))]
		[XmlElement("sequence", typeof(XmlSchemaSequence))]
		public XmlSchemaGroupBase Particle
		{
			get
			{
				return particle;
			}
			set
			{
				particle = value;
			}
		}

		[XmlIgnore]
		public XmlQualifiedName QualifiedName => qname;

		[XmlIgnore]
		internal XmlSchemaParticle CanonicalParticle
		{
			get
			{
				return canonicalParticle;
			}
			set
			{
				canonicalParticle = value;
			}
		}

		[XmlIgnore]
		internal XmlSchemaGroup Redefined
		{
			get
			{
				return redefined;
			}
			set
			{
				redefined = value;
			}
		}

		[XmlIgnore]
		internal int SelfReferenceCount
		{
			get
			{
				return selfReferenceCount;
			}
			set
			{
				selfReferenceCount = value;
			}
		}

		[XmlIgnore]
		internal override string NameAttribute
		{
			get
			{
				return Name;
			}
			set
			{
				Name = value;
			}
		}

		internal void SetQualifiedName(XmlQualifiedName value)
		{
			qname = value;
		}

		internal override XmlSchemaObject Clone()
		{
			XmlSchemaGroup xmlSchemaGroup = (XmlSchemaGroup)MemberwiseClone();
			if (XmlSchemaComplexType.HasParticleRef(particle))
			{
				xmlSchemaGroup.particle = XmlSchemaComplexType.CloneParticle(particle) as XmlSchemaGroupBase;
			}
			xmlSchemaGroup.canonicalParticle = XmlSchemaParticle.Empty;
			return xmlSchemaGroup;
		}
	}
	public class XmlSchemaGroupRef : XmlSchemaParticle
	{
		private XmlQualifiedName refName = XmlQualifiedName.Empty;

		private XmlSchemaGroupBase particle;

		private XmlSchemaGroup refined;

		[XmlAttribute("ref")]
		public XmlQualifiedName RefName
		{
			get
			{
				return refName;
			}
			set
			{
				refName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlIgnore]
		public XmlSchemaGroupBase Particle => particle;

		[XmlIgnore]
		internal XmlSchemaGroup Redefined
		{
			get
			{
				return refined;
			}
			set
			{
				refined = value;
			}
		}

		internal void SetParticle(XmlSchemaGroupBase value)
		{
			particle = value;
		}
	}
	public class XmlSchemaIdentityConstraint : XmlSchemaAnnotated
	{
		private string name;

		private XmlSchemaXPath selector;

		private XmlSchemaObjectCollection fields = new XmlSchemaObjectCollection();

		private XmlQualifiedName qualifiedName = XmlQualifiedName.Empty;

		private CompiledIdentityConstraint compiledConstraint;

		[XmlAttribute("name")]
		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		[XmlElement("selector", typeof(XmlSchemaXPath))]
		public XmlSchemaXPath Selector
		{
			get
			{
				return selector;
			}
			set
			{
				selector = value;
			}
		}

		[XmlElement("field", typeof(XmlSchemaXPath))]
		public XmlSchemaObjectCollection Fields => fields;

		[XmlIgnore]
		public XmlQualifiedName QualifiedName => qualifiedName;

		[XmlIgnore]
		internal CompiledIdentityConstraint CompiledConstraint
		{
			get
			{
				return compiledConstraint;
			}
			set
			{
				compiledConstraint = value;
			}
		}

		[XmlIgnore]
		internal override string NameAttribute
		{
			get
			{
				return Name;
			}
			set
			{
				Name = value;
			}
		}

		internal void SetQualifiedName(XmlQualifiedName value)
		{
			qualifiedName = value;
		}
	}
	public class XmlSchemaXPath : XmlSchemaAnnotated
	{
		private string xpath;

		[XmlAttribute("xpath")]
		[DefaultValue("")]
		public string XPath
		{
			get
			{
				return xpath;
			}
			set
			{
				xpath = value;
			}
		}
	}
	public class XmlSchemaUnique : XmlSchemaIdentityConstraint
	{
	}
	public class XmlSchemaKey : XmlSchemaIdentityConstraint
	{
	}
	public class XmlSchemaKeyref : XmlSchemaIdentityConstraint
	{
		private XmlQualifiedName refer = XmlQualifiedName.Empty;

		[XmlAttribute("refer")]
		public XmlQualifiedName Refer
		{
			get
			{
				return refer;
			}
			set
			{
				refer = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}
	}
	public class XmlSchemaImport : XmlSchemaExternal
	{
		private string ns;

		private XmlSchemaAnnotation annotation;

		[XmlAttribute("namespace", DataType = "anyURI")]
		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		[XmlElement("annotation", typeof(XmlSchemaAnnotation))]
		public XmlSchemaAnnotation Annotation
		{
			get
			{
				return annotation;
			}
			set
			{
				annotation = value;
			}
		}

		public XmlSchemaImport()
		{
			base.Compositor = Compositor.Import;
		}

		internal override void AddAnnotation(XmlSchemaAnnotation annotation)
		{
			this.annotation = annotation;
		}
	}
	public class XmlSchemaInclude : XmlSchemaExternal
	{
		private XmlSchemaAnnotation annotation;

		[XmlElement("annotation", typeof(XmlSchemaAnnotation))]
		public XmlSchemaAnnotation Annotation
		{
			get
			{
				return annotation;
			}
			set
			{
				annotation = value;
			}
		}

		public XmlSchemaInclude()
		{
			base.Compositor = Compositor.Include;
		}

		internal override void AddAnnotation(XmlSchemaAnnotation annotation)
		{
			this.annotation = annotation;
		}
	}
	public class XmlSchemaInfo : IXmlSchemaInfo
	{
		private bool isDefault;

		private bool isNil;

		private XmlSchemaElement schemaElement;

		private XmlSchemaAttribute schemaAttribute;

		private XmlSchemaType schemaType;

		private XmlSchemaSimpleType memberType;

		private XmlSchemaValidity validity;

		private XmlSchemaContentType contentType;

		public XmlSchemaValidity Validity
		{
			get
			{
				return validity;
			}
			set
			{
				validity = value;
			}
		}

		public bool IsDefault
		{
			get
			{
				return isDefault;
			}
			set
			{
				isDefault = value;
			}
		}

		public bool IsNil
		{
			get
			{
				return isNil;
			}
			set
			{
				isNil = value;
			}
		}

		public XmlSchemaSimpleType MemberType
		{
			get
			{
				return memberType;
			}
			set
			{
				memberType = value;
			}
		}

		public XmlSchemaType SchemaType
		{
			get
			{
				return schemaType;
			}
			set
			{
				schemaType = value;
				if (schemaType != null)
				{
					contentType = schemaType.SchemaContentType;
				}
				else
				{
					contentType = XmlSchemaContentType.Empty;
				}
			}
		}

		public XmlSchemaElement SchemaElement
		{
			get
			{
				return schemaElement;
			}
			set
			{
				schemaElement = value;
				if (value != null)
				{
					schemaAttribute = null;
				}
			}
		}

		public XmlSchemaAttribute SchemaAttribute
		{
			get
			{
				return schemaAttribute;
			}
			set
			{
				schemaAttribute = value;
				if (value != null)
				{
					schemaElement = null;
				}
			}
		}

		public XmlSchemaContentType ContentType
		{
			get
			{
				return contentType;
			}
			set
			{
				contentType = value;
			}
		}

		internal XmlSchemaType XmlType
		{
			get
			{
				if (memberType != null)
				{
					return memberType;
				}
				return schemaType;
			}
		}

		internal bool HasDefaultValue
		{
			get
			{
				if (schemaElement != null)
				{
					return schemaElement.ElementDecl.DefaultValueTyped != null;
				}
				return false;
			}
		}

		internal bool IsUnionType
		{
			get
			{
				if (schemaType == null || schemaType.Datatype == null)
				{
					return false;
				}
				return schemaType.Datatype.Variety == XmlSchemaDatatypeVariety.Union;
			}
		}

		public XmlSchemaInfo()
		{
			Clear();
		}

		internal XmlSchemaInfo(XmlSchemaValidity validity)
			: this()
		{
			this.validity = validity;
		}

		internal void Clear()
		{
			isNil = false;
			isDefault = false;
			schemaType = null;
			schemaElement = null;
			schemaAttribute = null;
			memberType = null;
			validity = XmlSchemaValidity.NotKnown;
			contentType = XmlSchemaContentType.Empty;
		}
	}
	public class XmlSchemaNotation : XmlSchemaAnnotated
	{
		private string name;

		private string publicId;

		private string systemId;

		private XmlQualifiedName qname = XmlQualifiedName.Empty;

		[XmlAttribute("name")]
		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		[XmlAttribute("public")]
		public string Public
		{
			get
			{
				return publicId;
			}
			set
			{
				publicId = value;
			}
		}

		[XmlAttribute("system")]
		public string System
		{
			get
			{
				return systemId;
			}
			set
			{
				systemId = value;
			}
		}

		[XmlIgnore]
		internal XmlQualifiedName QualifiedName
		{
			get
			{
				return qname;
			}
			set
			{
				qname = value;
			}
		}

		[XmlIgnore]
		internal override string NameAttribute
		{
			get
			{
				return Name;
			}
			set
			{
				Name = value;
			}
		}
	}
	public class XmlSchemaObjectCollection : CollectionBase
	{
		private XmlSchemaObject parent;

		public virtual XmlSchemaObject this[int index]
		{
			get
			{
				return (XmlSchemaObject)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public XmlSchemaObjectCollection()
		{
		}

		public XmlSchemaObjectCollection(XmlSchemaObject parent)
		{
			this.parent = parent;
		}

		public new XmlSchemaObjectEnumerator GetEnumerator()
		{
			return new XmlSchemaObjectEnumerator(base.InnerList.GetEnumerator());
		}

		public int Add(XmlSchemaObject item)
		{
			return base.List.Add(item);
		}

		public void Insert(int index, XmlSchemaObject item)
		{
			base.List.Insert(index, item);
		}

		public int IndexOf(XmlSchemaObject item)
		{
			return base.List.IndexOf(item);
		}

		public bool Contains(XmlSchemaObject item)
		{
			return base.List.Contains(item);
		}

		public void Remove(XmlSchemaObject item)
		{
			base.List.Remove(item);
		}

		public void CopyTo(XmlSchemaObject[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override void OnInsert(int index, object item)
		{
			if (parent != null)
			{
				parent.OnAdd(this, item);
			}
		}

		protected override void OnSet(int index, object oldValue, object newValue)
		{
			if (parent != null)
			{
				parent.OnRemove(this, oldValue);
				parent.OnAdd(this, newValue);
			}
		}

		protected override void OnClear()
		{
			if (parent != null)
			{
				parent.OnClear(this);
			}
		}

		protected override void OnRemove(int index, object item)
		{
			if (parent != null)
			{
				parent.OnRemove(this, item);
			}
		}

		internal XmlSchemaObjectCollection Clone()
		{
			XmlSchemaObjectCollection xmlSchemaObjectCollection = new XmlSchemaObjectCollection();
			xmlSchemaObjectCollection.Add(this);
			return xmlSchemaObjectCollection;
		}

		private void Add(XmlSchemaObjectCollection collToAdd)
		{
			base.InnerList.InsertRange(0, collToAdd);
		}
	}
	public class XmlSchemaObjectEnumerator : IEnumerator
	{
		private IEnumerator enumerator;

		public XmlSchemaObject Current => (XmlSchemaObject)enumerator.Current;

		object IEnumerator.Current => enumerator.Current;

		internal XmlSchemaObjectEnumerator(IEnumerator enumerator)
		{
			this.enumerator = enumerator;
		}

		public void Reset()
		{
			enumerator.Reset();
		}

		public bool MoveNext()
		{
			return enumerator.MoveNext();
		}

		void IEnumerator.Reset()
		{
			enumerator.Reset();
		}

		bool IEnumerator.MoveNext()
		{
			return enumerator.MoveNext();
		}
	}
	public class XmlSchemaObjectTable
	{
		internal enum EnumeratorType
		{
			Keys,
			Values,
			DictionaryEntry
		}

		internal struct XmlSchemaObjectEntry
		{
			internal XmlQualifiedName qname;

			internal XmlSchemaObject xso;

			public XmlSchemaObjectEntry(XmlQualifiedName name, XmlSchemaObject value)
			{
				qname = name;
				xso = value;
			}

			public XmlSchemaObject IsMatch(string localName, string ns)
			{
				if (localName == qname.Name && ns == qname.Namespace)
				{
					return xso;
				}
				return null;
			}

			public void Reset()
			{
				qname = null;
				xso = null;
			}
		}

		internal class NamesCollection : ICollection, IEnumerable
		{
			private List<XmlSchemaObjectEntry> entries;

			private int size;

			public int Count => size;

			public object SyncRoot => ((ICollection)entries).SyncRoot;

			public bool IsSynchronized => ((ICollection)entries).IsSynchronized;

			internal NamesCollection(List<XmlSchemaObjectEntry> entries, int size)
			{
				this.entries = entries;
				this.size = size;
			}

			public void CopyTo(Array array, int arrayIndex)
			{
				if (array == null)
				{
					throw new ArgumentNullException("array");
				}
				if (arrayIndex < 0)
				{
					throw new ArgumentOutOfRangeException("arrayIndex");
				}
				for (int i = 0; i < size; i++)
				{
					array.SetValue(entries[i].qname, arrayIndex++);
				}
			}

			public IEnumerator GetEnumerator()
			{
				return new XSOEnumerator(entries, size, EnumeratorType.Keys);
			}
		}

		internal class ValuesCollection : ICollection, IEnumerable
		{
			private List<XmlSchemaObjectEntry> entries;

			private int size;

			public int Count => size;

			public object SyncRoot => ((ICollection)entries).SyncRoot;

			public bool IsSynchronized => ((ICollection)entries).IsSynchronized;

			internal ValuesCollection(List<XmlSchemaObjectEntry> entries, int size)
			{
				this.entries = entries;
				this.size = size;
			}

			public void CopyTo(Array array, int arrayIndex)
			{
				if (array == null)
				{
					throw new ArgumentNullException("array");
				}
				if (arrayIndex < 0)
				{
					throw new ArgumentOutOfRangeException("arrayIndex");
				}
				for (int i = 0; i < size; i++)
				{
					array.SetValue(entries[i].xso, arrayIndex++);
				}
			}

			public IEnumerator GetEnumerator()
			{
				return new XSOEnumerator(entries, size, EnumeratorType.Values);
			}
		}

		internal class XSOEnumerator : IEnumerator
		{
			private List<XmlSchemaObjectEntry> entries;

			private EnumeratorType enumType;

			protected int currentIndex;

			protected int size;

			protected XmlQualifiedName currentKey;

			protected XmlSchemaObject currentValue;

			public object Current
			{
				get
				{
					if (currentIndex == -1)
					{
						throw new InvalidOperationException(Res.GetString("Sch_EnumNotStarted", string.Empty));
					}
					if (currentIndex >= size)
					{
						throw new InvalidOperationException(Res.GetString("Sch_EnumFinished", string.Empty));
					}
					return enumType switch
					{
						EnumeratorType.Keys => currentKey, 
						EnumeratorType.Values => currentValue, 
						EnumeratorType.DictionaryEntry => new DictionaryEntry(currentKey, currentValue), 
						_ => null, 
					};
				}
			}

			internal XSOEnumerator(List<XmlSchemaObjectEntry> entries, int size, EnumeratorType enumType)
			{
				this.entries = entries;
				this.size = size;
				this.enumType = enumType;
				currentIndex = -1;
			}

			public bool MoveNext()
			{
				if (currentIndex >= size - 1)
				{
					currentValue = null;
					currentKey = null;
					return false;
				}
				currentIndex++;
				currentValue = entries[currentIndex].xso;
				currentKey = entries[currentIndex].qname;
				return true;
			}

			public void Reset()
			{
				currentIndex = -1;
				currentValue = null;
				currentKey = null;
			}
		}

		internal class XSODictionaryEnumerator : XSOEnumerator, IDictionaryEnumerator, IEnumerator
		{
			public DictionaryEntry Entry
			{
				get
				{
					if (currentIndex == -1)
					{
						throw new InvalidOperationException(Res.GetString("Sch_EnumNotStarted", string.Empty));
					}
					if (currentIndex >= size)
					{
						throw new InvalidOperationException(Res.GetString("Sch_EnumFinished", string.Empty));
					}
					return new DictionaryEntry(currentKey, currentValue);
				}
			}

			public object Key
			{
				get
				{
					if (currentIndex == -1)
					{
						throw new InvalidOperationException(Res.GetString("Sch_EnumNotStarted", string.Empty));
					}
					if (currentIndex >= size)
					{
						throw new InvalidOperationException(Res.GetString("Sch_EnumFinished", string.Empty));
					}
					return currentKey;
				}
			}

			public object Value
			{
				get
				{
					if (currentIndex == -1)
					{
						throw new InvalidOperationException(Res.GetString("Sch_EnumNotStarted", string.Empty));
					}
					if (currentIndex >= size)
					{
						throw new InvalidOperationException(Res.GetString("Sch_EnumFinished", string.Empty));
					}
					return currentValue;
				}
			}

			internal XSODictionaryEnumerator(List<XmlSchemaObjectEntry> entries, int size, EnumeratorType enumType)
				: base(entries, size, enumType)
			{
			}
		}

		private Dictionary<XmlQualifiedName, XmlSchemaObject> table = new Dictionary<XmlQualifiedName, XmlSchemaObject>();

		private List<XmlSchemaObjectEntry> entries = new List<XmlSchemaObjectEntry>();

		public int Count => table.Count;

		public XmlSchemaObject this[XmlQualifiedName name]
		{
			get
			{
				if (table.TryGetValue(name, out var value))
				{
					return value;
				}
				return null;
			}
		}

		public ICollection Names => new NamesCollection(entries, table.Count);

		public ICollection Values => new ValuesCollection(entries, table.Count);

		internal XmlSchemaObjectTable()
		{
		}

		internal void Add(XmlQualifiedName name, XmlSchemaObject value)
		{
			table.Add(name, value);
			entries.Add(new XmlSchemaObjectEntry(name, value));
		}

		internal void Insert(XmlQualifiedName name, XmlSchemaObject value)
		{
			XmlSchemaObject value2 = null;
			if (table.TryGetValue(name, out value2))
			{
				table[name] = value;
				int index = FindIndexByValue(value2);
				entries[index] = new XmlSchemaObjectEntry(name, value);
			}
			else
			{
				Add(name, value);
			}
		}

		internal void Replace(XmlQualifiedName name, XmlSchemaObject value)
		{
			if (table.TryGetValue(name, out var value2))
			{
				table[name] = value;
				int index = FindIndexByValue(value2);
				entries[index] = new XmlSchemaObjectEntry(name, value);
			}
		}

		internal void Clear()
		{
			table.Clear();
			entries.Clear();
		}

		internal void Remove(XmlQualifiedName name)
		{
			if (table.TryGetValue(name, out var value))
			{
				table.Remove(name);
				int index = FindIndexByValue(value);
				entries.RemoveAt(index);
			}
		}

		private int FindIndexByValue(XmlSchemaObject xso)
		{
			for (int i = 0; i < entries.Count; i++)
			{
				if (entries[i].xso == xso)
				{
					return i;
				}
			}
			return -1;
		}

		public bool Contains(XmlQualifiedName name)
		{
			return table.ContainsKey(name);
		}

		public IDictionaryEnumerator GetEnumerator()
		{
			return new XSODictionaryEnumerator(entries, table.Count, EnumeratorType.DictionaryEntry);
		}
	}
	public class XmlSchemaRedefine : XmlSchemaExternal
	{
		private XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();

		private XmlSchemaObjectTable attributeGroups = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable types = new XmlSchemaObjectTable();

		private XmlSchemaObjectTable groups = new XmlSchemaObjectTable();

		[XmlElement("complexType", typeof(XmlSchemaComplexType))]
		[XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
		[XmlElement("group", typeof(XmlSchemaGroup))]
		[XmlElement("annotation", typeof(XmlSchemaAnnotation))]
		[XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroup))]
		public XmlSchemaObjectCollection Items => items;

		[XmlIgnore]
		public XmlSchemaObjectTable AttributeGroups => attributeGroups;

		[XmlIgnore]
		public XmlSchemaObjectTable SchemaTypes => types;

		[XmlIgnore]
		public XmlSchemaObjectTable Groups => groups;

		public XmlSchemaRedefine()
		{
			base.Compositor = Compositor.Redefine;
		}

		internal override void AddAnnotation(XmlSchemaAnnotation annotation)
		{
			items.Add(annotation);
		}
	}
	public class XmlSchemaSequence : XmlSchemaGroupBase
	{
		private XmlSchemaObjectCollection items = new XmlSchemaObjectCollection();

		[XmlElement("group", typeof(XmlSchemaGroupRef))]
		[XmlElement("choice", typeof(XmlSchemaChoice))]
		[XmlElement("any", typeof(XmlSchemaAny))]
		[XmlElement("element", typeof(XmlSchemaElement))]
		[XmlElement("sequence", typeof(XmlSchemaSequence))]
		public override XmlSchemaObjectCollection Items => items;

		internal override bool IsEmpty
		{
			get
			{
				if (!base.IsEmpty)
				{
					return items.Count == 0;
				}
				return true;
			}
		}

		internal override void SetItems(XmlSchemaObjectCollection newItems)
		{
			items = newItems;
		}
	}
	public class XmlSchemaSet
	{
		private XmlNameTable nameTable;

		private SchemaNames schemaNames;

		private SortedList schemas;

		private ValidationEventHandler internalEventHandler;

		private ValidationEventHandler eventHandler;

		private bool isCompiled;

		private Hashtable schemaLocations;

		private Hashtable chameleonSchemas;

		private Hashtable targetNamespaces;

		private bool compileAll;

		private SchemaInfo cachedCompiledInfo;

		private XmlReaderSettings readerSettings;

		private XmlSchema schemaForSchema;

		private XmlSchemaCompilationSettings compilationSettings;

		internal XmlSchemaObjectTable elements;

		internal XmlSchemaObjectTable attributes;

		internal XmlSchemaObjectTable schemaTypes;

		internal XmlSchemaObjectTable substitutionGroups;

		private XmlSchemaObjectTable typeExtensions;

		private object internalSyncObject;

		internal object InternalSyncObject
		{
			get
			{
				if (internalSyncObject == null)
				{
					object value = new object();
					Interlocked.CompareExchange(ref internalSyncObject, value, null);
				}
				return internalSyncObject;
			}
		}

		public XmlNameTable NameTable => nameTable;

		public bool IsCompiled => isCompiled;

		public XmlResolver XmlResolver
		{
			set
			{
				readerSettings.XmlResolver = value;
			}
		}

		public XmlSchemaCompilationSettings CompilationSettings
		{
			get
			{
				return compilationSettings;
			}
			set
			{
				compilationSettings = value;
			}
		}

		public int Count => schemas.Count;

		public XmlSchemaObjectTable GlobalElements
		{
			get
			{
				if (elements == null)
				{
					elements = new XmlSchemaObjectTable();
				}
				return elements;
			}
		}

		public XmlSchemaObjectTable GlobalAttributes
		{
			get
			{
				if (attributes == null)
				{
					attributes = new XmlSchemaObjectTable();
				}
				return attributes;
			}
		}

		public XmlSchemaObjectTable GlobalTypes
		{
			get
			{
				if (schemaTypes == null)
				{
					schemaTypes = new XmlSchemaObjectTable();
				}
				return schemaTypes;
			}
		}

		internal XmlSchemaObjectTable SubstitutionGroups
		{
			get
			{
				if (substitutionGroups == null)
				{
					substitutionGroups = new XmlSchemaObjectTable();
				}
				return substitutionGroups;
			}
		}

		internal Hashtable SchemaLocations => schemaLocations;

		internal XmlSchemaObjectTable TypeExtensions
		{
			get
			{
				if (typeExtensions == null)
				{
					typeExtensions = new XmlSchemaObjectTable();
				}
				return typeExtensions;
			}
		}

		internal SchemaInfo CompiledInfo => cachedCompiledInfo;

		internal XmlReaderSettings ReaderSettings => readerSettings;

		internal SortedList SortedSchemas => schemas;

		internal bool CompileAll => compileAll;

		public event ValidationEventHandler ValidationEventHandler
		{
			add
			{
				eventHandler = (ValidationEventHandler)Delegate.Remove(eventHandler, internalEventHandler);
				eventHandler = (ValidationEventHandler)Delegate.Combine(eventHandler, value);
				if (eventHandler == null)
				{
					eventHandler = internalEventHandler;
				}
			}
			remove
			{
				eventHandler = (ValidationEventHandler)Delegate.Remove(eventHandler, value);
				if (eventHandler == null)
				{
					eventHandler = internalEventHandler;
				}
			}
		}

		public XmlSchemaSet()
			: this(new NameTable())
		{
		}

		public XmlSchemaSet(XmlNameTable nameTable)
		{
			if (nameTable == null)
			{
				throw new ArgumentNullException("nameTable");
			}
			this.nameTable = nameTable;
			schemas = new SortedList();
			schemaLocations = new Hashtable();
			chameleonSchemas = new Hashtable();
			targetNamespaces = new Hashtable();
			internalEventHandler = InternalValidationCallback;
			eventHandler = internalEventHandler;
			readerSettings = new XmlReaderSettings();
			readerSettings.NameTable = nameTable;
			readerSettings.ProhibitDtd = true;
			compilationSettings = new XmlSchemaCompilationSettings();
			cachedCompiledInfo = new SchemaInfo();
			compileAll = true;
		}

		public XmlSchema Add(string targetNamespace, string schemaUri)
		{
			if (schemaUri == null || schemaUri.Length == 0)
			{
				throw new ArgumentNullException("schemaUri");
			}
			if (targetNamespace != null)
			{
				targetNamespace = XmlComplianceUtil.CDataNormalize(targetNamespace);
			}
			XmlSchema schema = null;
			lock (InternalSyncObject)
			{
				XmlResolver xmlResolver = readerSettings.GetXmlResolver();
				if (xmlResolver == null)
				{
					xmlResolver = new XmlUrlResolver();
				}
				Uri schemaUri2 = xmlResolver.ResolveUri(null, schemaUri);
				if (IsSchemaLoaded(schemaUri2, targetNamespace, out schema))
				{
					return schema;
				}
				XmlReader xmlReader = XmlReader.Create(schemaUri, readerSettings);
				try
				{
					schema = Add(targetNamespace, ParseSchema(targetNamespace, xmlReader));
					while (xmlReader.Read())
					{
					}
					return schema;
				}
				finally
				{
					xmlReader.Close();
				}
			}
		}

		public XmlSchema Add(string targetNamespace, XmlReader schemaDocument)
		{
			if (schemaDocument == null)
			{
				throw new ArgumentNullException("schemaDocument");
			}
			if (targetNamespace != null)
			{
				targetNamespace = XmlComplianceUtil.CDataNormalize(targetNamespace);
			}
			lock (InternalSyncObject)
			{
				XmlSchema schema = null;
				Uri schemaUri = new Uri(schemaDocument.BaseURI, UriKind.RelativeOrAbsolute);
				if (IsSchemaLoaded(schemaUri, targetNamespace, out schema))
				{
					return schema;
				}
				bool prohibitDtd = readerSettings.ProhibitDtd;
				SetProhibitDtd(schemaDocument);
				schema = Add(targetNamespace, ParseSchema(targetNamespace, schemaDocument));
				readerSettings.ProhibitDtd = prohibitDtd;
				return schema;
			}
		}

		public void Add(XmlSchemaSet schemas)
		{
			if (schemas == null)
			{
				throw new ArgumentNullException("schemas");
			}
			if (this == schemas)
			{
				return;
			}
			bool flag = false;
			try
			{
				while (true)
				{
					if (Monitor.TryEnter(InternalSyncObject))
					{
						if (Monitor.TryEnter(schemas.InternalSyncObject))
						{
							break;
						}
						Monitor.Exit(InternalSyncObject);
					}
				}
				flag = true;
				if (schemas.IsCompiled)
				{
					CopyFromCompiledSet(schemas);
					return;
				}
				bool flag2 = false;
				string text = null;
				foreach (XmlSchema value in schemas.SortedSchemas.Values)
				{
					text = value.TargetNamespace;
					if (text == null)
					{
						text = string.Empty;
					}
					if (!this.schemas.ContainsKey(value.SchemaId) && FindSchemaByNSAndUrl(value.BaseUri, text, null) == null)
					{
						XmlSchema xmlSchema2 = Add(value.TargetNamespace, value);
						if (xmlSchema2 == null)
						{
							flag2 = true;
							break;
						}
					}
				}
				if (!flag2)
				{
					return;
				}
				foreach (XmlSchema value2 in schemas.SortedSchemas.Values)
				{
					this.schemas.Remove(value2.SchemaId);
					schemaLocations.Remove(value2.BaseUri);
				}
			}
			finally
			{
				if (flag)
				{
					Monitor.Exit(InternalSyncObject);
					Monitor.Exit(schemas.InternalSyncObject);
				}
			}
		}

		public XmlSchema Add(XmlSchema schema)
		{
			if (schema == null)
			{
				throw new ArgumentNullException("schema");
			}
			lock (InternalSyncObject)
			{
				if (schemas.ContainsKey(schema.SchemaId))
				{
					return schema;
				}
				return Add(schema.TargetNamespace, schema);
			}
		}

		public XmlSchema Remove(XmlSchema schema)
		{
			return Remove(schema, forceCompile: true);
		}

		public bool RemoveRecursive(XmlSchema schemaToRemove)
		{
			if (schemaToRemove == null)
			{
				throw new ArgumentNullException("schemaToRemove");
			}
			if (!schemas.ContainsKey(schemaToRemove.SchemaId))
			{
				return false;
			}
			lock (InternalSyncObject)
			{
				if (schemas.ContainsKey(schemaToRemove.SchemaId))
				{
					Hashtable hashtable = new Hashtable();
					hashtable.Add(GetTargetNamespace(schemaToRemove), schemaToRemove);
					for (int i = 0; i < schemaToRemove.ImportedNamespaces.Count; i++)
					{
						string text = (string)schemaToRemove.ImportedNamespaces[i];
						if (hashtable[text] == null)
						{
							hashtable.Add(text, text);
						}
					}
					ArrayList arrayList = new ArrayList();
					XmlSchema xmlSchema;
					for (int j = 0; j < schemas.Count; j++)
					{
						xmlSchema = (XmlSchema)schemas.GetByIndex(j);
						if (xmlSchema != schemaToRemove && !schemaToRemove.ImportedSchemas.Contains(xmlSchema))
						{
							arrayList.Add(xmlSchema);
						}
					}
					xmlSchema = null;
					for (int k = 0; k < arrayList.Count; k++)
					{
						xmlSchema = (XmlSchema)arrayList[k];
						if (xmlSchema.ImportedNamespaces.Count <= 0)
						{
							continue;
						}
						foreach (string key in hashtable.Keys)
						{
							if (xmlSchema.ImportedNamespaces.Contains(key))
							{
								SendValidationEvent(new XmlSchemaException("Sch_SchemaNotRemoved", string.Empty), XmlSeverityType.Warning);
								return false;
							}
						}
					}
					RemoveSchemaFromGlobalTables(schemaToRemove);
					Remove(schemaToRemove, forceCompile: false);
					foreach (XmlSchema importedSchema in schemaToRemove.ImportedSchemas)
					{
						RemoveSchemaFromGlobalTables(importedSchema);
						Remove(importedSchema, forceCompile: false);
					}
					return true;
				}
			}
			return false;
		}

		public bool Contains(string targetNamespace)
		{
			if (targetNamespace == null)
			{
				targetNamespace = string.Empty;
			}
			return targetNamespaces[targetNamespace] != null;
		}

		public bool Contains(XmlSchema schema)
		{
			if (schema == null)
			{
				throw new ArgumentNullException("schema");
			}
			return schemas.ContainsValue(schema);
		}

		public void Compile()
		{
			if (schemas.Count == 0)
			{
				ClearTables();
			}
			else
			{
				if (isCompiled)
				{
					return;
				}
				lock (InternalSyncObject)
				{
					if (isCompiled)
					{
						return;
					}
					Compiler compiler = new Compiler(nameTable, eventHandler, schemaForSchema, compilationSettings);
					SchemaInfo schemaInfo = new SchemaInfo();
					int i = 0;
					if (!compileAll)
					{
						compiler.ImportAllCompiledSchemas(this);
					}
					try
					{
						XmlSchema buildInSchema = Preprocessor.GetBuildInSchema();
						for (i = 0; i < schemas.Count; i++)
						{
							XmlSchema xmlSchema = (XmlSchema)schemas.GetByIndex(i);
							Monitor.Enter(xmlSchema);
							if (!xmlSchema.IsPreprocessed)
							{
								SendValidationEvent(new XmlSchemaException("Sch_SchemaNotPreprocessed", string.Empty), XmlSeverityType.Error);
								isCompiled = false;
								return;
							}
							if (xmlSchema.IsCompiledBySet)
							{
								if (!compileAll)
								{
									continue;
								}
								if (xmlSchema == buildInSchema)
								{
									compiler.Prepare(xmlSchema, cleanup: false);
									continue;
								}
							}
							compiler.Prepare(xmlSchema, cleanup: true);
						}
						isCompiled = compiler.Execute(this, schemaInfo);
						if (isCompiled)
						{
							compileAll = false;
							schemaInfo.Add(cachedCompiledInfo, eventHandler);
							cachedCompiledInfo = schemaInfo;
						}
					}
					finally
					{
						if (i == schemas.Count)
						{
							i--;
						}
						for (int num = i; num >= 0; num--)
						{
							XmlSchema xmlSchema2 = (XmlSchema)schemas.GetByIndex(num);
							if (xmlSchema2 == Preprocessor.GetBuildInSchema())
							{
								Monitor.Exit(xmlSchema2);
							}
							else
							{
								xmlSchema2.IsCompiledBySet = isCompiled;
								Monitor.Exit(xmlSchema2);
							}
						}
					}
				}
			}
		}

		public XmlSchema Reprocess(XmlSchema schema)
		{
			if (schema == null)
			{
				throw new ArgumentNullException("schema");
			}
			if (!schemas.ContainsKey(schema.SchemaId))
			{
				throw new ArgumentException(Res.GetString("Sch_SchemaDoesNotExist"), "schema");
			}
			lock (InternalSyncObject)
			{
				RemoveSchemaFromCaches(schema);
				PreprocessSchema(ref schema, schema.TargetNamespace);
				foreach (XmlSchema importedSchema in schema.ImportedSchemas)
				{
					if (!schemas.ContainsKey(importedSchema.SchemaId))
					{
						schemas.Add(importedSchema.SchemaId, importedSchema);
					}
					string targetNamespace = GetTargetNamespace(importedSchema);
					if (targetNamespaces[targetNamespace] == null)
					{
						targetNamespaces.Add(targetNamespace, targetNamespace);
					}
				}
				isCompiled = false;
				return schema;
			}
		}

		public void CopyTo(XmlSchema[] schemas, int index)
		{
			if (schemas == null)
			{
				throw new ArgumentNullException("schemas");
			}
			if (index < 0 || index > schemas.Length - 1)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			this.schemas.Values.CopyTo(schemas, index);
		}

		public ICollection Schemas()
		{
			return schemas.Values;
		}

		public ICollection Schemas(string targetNamespace)
		{
			ArrayList arrayList = new ArrayList();
			if (targetNamespace == null)
			{
				targetNamespace = string.Empty;
			}
			for (int i = 0; i < schemas.Count; i++)
			{
				XmlSchema xmlSchema = (XmlSchema)schemas.GetByIndex(i);
				if (GetTargetNamespace(xmlSchema) == targetNamespace)
				{
					arrayList.Add(xmlSchema);
				}
			}
			return arrayList;
		}

		internal XmlSchema Add(string targetNamespace, XmlSchema schema)
		{
			if (schema == null || schema.ErrorCount != 0)
			{
				return null;
			}
			if (PreprocessSchema(ref schema, targetNamespace))
			{
				AddSchemaToSet(schema);
				isCompiled = false;
				return schema;
			}
			return null;
		}

		internal void Add(string targetNamespace, XmlReader reader, Hashtable validatedNamespaces)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			if (targetNamespace == null)
			{
				targetNamespace = string.Empty;
			}
			if (validatedNamespaces[targetNamespace] != null)
			{
				if (FindSchemaByNSAndUrl(new Uri(reader.BaseURI, UriKind.RelativeOrAbsolute), targetNamespace, null) == null)
				{
					throw new XmlSchemaException("Sch_ComponentAlreadySeenForNS", targetNamespace);
				}
			}
			else
			{
				if (IsSchemaLoaded(new Uri(reader.BaseURI, UriKind.RelativeOrAbsolute), targetNamespace, out var schema))
				{
					return;
				}
				schema = ParseSchema(targetNamespace, reader);
				DictionaryEntry[] array = new DictionaryEntry[schemaLocations.Count];
				schemaLocations.CopyTo(array, 0);
				Add(targetNamespace, schema);
				if (schema.ImportedSchemas.Count <= 0)
				{
					return;
				}
				foreach (XmlSchema importedSchema in schema.ImportedSchemas)
				{
					string text = importedSchema.TargetNamespace;
					if (text == null)
					{
						text = string.Empty;
					}
					if (validatedNamespaces[text] != null && FindSchemaByNSAndUrl(importedSchema.BaseUri, text, array) == null)
					{
						RemoveRecursive(schema);
						throw new XmlSchemaException("Sch_ComponentAlreadySeenForNS", text);
					}
				}
			}
		}

		internal XmlSchema FindSchemaByNSAndUrl(Uri schemaUri, string ns, DictionaryEntry[] locationsTable)
		{
			if (schemaUri == null || schemaUri.OriginalString.Length == 0)
			{
				return null;
			}
			XmlSchema xmlSchema = null;
			if (locationsTable == null)
			{
				xmlSchema = (XmlSchema)schemaLocations[schemaUri];
			}
			else
			{
				for (int i = 0; i < locationsTable.Length; i++)
				{
					if (schemaUri.Equals(locationsTable[i].Key))
					{
						xmlSchema = (XmlSchema)locationsTable[i].Value;
						break;
					}
				}
			}
			if (xmlSchema != null)
			{
				string text = ((xmlSchema.TargetNamespace == null) ? string.Empty : xmlSchema.TargetNamespace);
				if (text == ns)
				{
					return xmlSchema;
				}
				if (text == string.Empty)
				{
					ChameleonKey key = new ChameleonKey(ns, schemaUri);
					xmlSchema = (XmlSchema)chameleonSchemas[key];
				}
				else
				{
					xmlSchema = null;
				}
			}
			return xmlSchema;
		}

		private void SetProhibitDtd(XmlReader reader)
		{
			if (reader.Settings != null)
			{
				readerSettings.ProhibitDtd = reader.Settings.ProhibitDtd;
			}
			else if (reader is XmlTextReader xmlTextReader)
			{
				readerSettings.ProhibitDtd = xmlTextReader.ProhibitDtd;
			}
		}

		private void AddSchemaToSet(XmlSchema schema)
		{
			schemas.Add(schema.SchemaId, schema);
			string targetNamespace = GetTargetNamespace(schema);
			if (targetNamespaces[targetNamespace] == null)
			{
				targetNamespaces.Add(targetNamespace, targetNamespace);
			}
			if (schemaForSchema == null && targetNamespace == "http://www.w3.org/2001/XMLSchema" && schema.SchemaTypes[DatatypeImplementation.QnAnyType] != null)
			{
				schemaForSchema = schema;
			}
			foreach (XmlSchema importedSchema in schema.ImportedSchemas)
			{
				if (!schemas.ContainsKey(importedSchema.SchemaId))
				{
					schemas.Add(importedSchema.SchemaId, importedSchema);
				}
				targetNamespace = GetTargetNamespace(importedSchema);
				if (targetNamespaces[targetNamespace] == null)
				{
					targetNamespaces.Add(targetNamespace, targetNamespace);
				}
				if (schemaForSchema == null && targetNamespace == "http://www.w3.org/2001/XMLSchema" && schema.SchemaTypes[DatatypeImplementation.QnAnyType] != null)
				{
					schemaForSchema = schema;
				}
			}
		}

		private void ProcessNewSubstitutionGroups(XmlSchemaObjectTable substitutionGroupsTable, bool resolve)
		{
			foreach (XmlSchemaSubstitutionGroup value in substitutionGroupsTable.Values)
			{
				if (resolve)
				{
					ResolveSubstitutionGroup(value, substitutionGroupsTable);
				}
				XmlQualifiedName examplar = value.Examplar;
				XmlSchemaSubstitutionGroup xmlSchemaSubstitutionGroup2 = (XmlSchemaSubstitutionGroup)substitutionGroups[examplar];
				if (xmlSchemaSubstitutionGroup2 != null)
				{
					foreach (XmlSchemaElement member in value.Members)
					{
						if (!xmlSchemaSubstitutionGroup2.Members.Contains(member))
						{
							xmlSchemaSubstitutionGroup2.Members.Add(member);
						}
					}
				}
				else
				{
					AddToTable(substitutionGroups, examplar, value);
				}
			}
		}

		private void ResolveSubstitutionGroup(XmlSchemaSubstitutionGroup substitutionGroup, XmlSchemaObjectTable substTable)
		{
			ArrayList arrayList = null;
			XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)elements[substitutionGroup.Examplar];
			if (substitutionGroup.Members.Contains(xmlSchemaElement))
			{
				return;
			}
			foreach (XmlSchemaElement member in substitutionGroup.Members)
			{
				XmlSchemaSubstitutionGroup xmlSchemaSubstitutionGroup = (XmlSchemaSubstitutionGroup)substTable[member.QualifiedName];
				if (xmlSchemaSubstitutionGroup == null)
				{
					continue;
				}
				ResolveSubstitutionGroup(xmlSchemaSubstitutionGroup, substTable);
				foreach (XmlSchemaElement member2 in xmlSchemaSubstitutionGroup.Members)
				{
					if (member2 != member)
					{
						if (arrayList == null)
						{
							arrayList = new ArrayList();
						}
						arrayList.Add(member2);
					}
				}
			}
			if (arrayList != null)
			{
				foreach (XmlSchemaElement item in arrayList)
				{
					substitutionGroup.Members.Add(item);
				}
			}
			substitutionGroup.Members.Add(xmlSchemaElement);
		}

		internal XmlSchema Remove(XmlSchema schema, bool forceCompile)
		{
			if (schema == null)
			{
				throw new ArgumentNullException("schema");
			}
			lock (InternalSyncObject)
			{
				if (schemas.ContainsKey(schema.SchemaId))
				{
					schemas.Remove(schema.SchemaId);
					if (schema.BaseUri != null)
					{
						schemaLocations.Remove(schema.BaseUri);
					}
					string targetNamespace = GetTargetNamespace(schema);
					if (Schemas(targetNamespace).Count == 0)
					{
						targetNamespaces.Remove(targetNamespace);
					}
					if (forceCompile)
					{
						isCompiled = false;
						compileAll = true;
					}
					return schema;
				}
			}
			return null;
		}

		private void ClearTables()
		{
			GlobalElements.Clear();
			GlobalAttributes.Clear();
			GlobalTypes.Clear();
			SubstitutionGroups.Clear();
			TypeExtensions.Clear();
		}

		internal bool PreprocessSchema(ref XmlSchema schema, string targetNamespace)
		{
			Preprocessor preprocessor = new Preprocessor(nameTable, GetSchemaNames(nameTable), eventHandler, compilationSettings);
			preprocessor.XmlResolver = readerSettings.GetXmlResolver_CheckConfig();
			preprocessor.ReaderSettings = readerSettings;
			preprocessor.SchemaLocations = schemaLocations;
			preprocessor.ChameleonSchemas = chameleonSchemas;
			bool result = preprocessor.Execute(schema, targetNamespace, loadExternals: true);
			schema = preprocessor.RootSchema;
			return result;
		}

		internal XmlSchema ParseSchema(string targetNamespace, XmlReader reader)
		{
			XmlNameTable nt = reader.NameTable;
			SchemaNames schemaNames = GetSchemaNames(nt);
			Parser parser = new Parser(SchemaType.XSD, nt, schemaNames, eventHandler);
			parser.XmlResolver = readerSettings.GetXmlResolver_CheckConfig();
			try
			{
				parser.Parse(reader, targetNamespace);
			}
			catch (XmlSchemaException e)
			{
				SendValidationEvent(e, XmlSeverityType.Error);
				return null;
			}
			return parser.XmlSchema;
		}

		internal void CopyFromCompiledSet(XmlSchemaSet otherSet)
		{
			SortedList sortedSchemas = otherSet.SortedSchemas;
			bool flag = ((schemas.Count == 0) ? true : false);
			ArrayList arrayList = new ArrayList();
			SchemaInfo schemaInfo = new SchemaInfo();
			for (int i = 0; i < sortedSchemas.Count; i++)
			{
				XmlSchema xmlSchema = (XmlSchema)sortedSchemas.GetByIndex(i);
				Uri baseUri = xmlSchema.BaseUri;
				if (schemas.ContainsKey(xmlSchema.SchemaId) || (baseUri != null && baseUri.OriginalString.Length != 0 && schemaLocations[baseUri] != null))
				{
					arrayList.Add(xmlSchema);
					continue;
				}
				schemas.Add(xmlSchema.SchemaId, xmlSchema);
				if (baseUri != null && baseUri.OriginalString.Length != 0)
				{
					schemaLocations.Add(baseUri, xmlSchema);
				}
				string targetNamespace = GetTargetNamespace(xmlSchema);
				if (targetNamespaces[targetNamespace] == null)
				{
					targetNamespaces.Add(targetNamespace, targetNamespace);
				}
			}
			VerifyTables();
			foreach (XmlSchemaElement value in otherSet.GlobalElements.Values)
			{
				if (AddToTable(elements, value.QualifiedName, value))
				{
					continue;
				}
				goto IL_026e;
			}
			foreach (XmlSchemaAttribute value2 in otherSet.GlobalAttributes.Values)
			{
				if (AddToTable(attributes, value2.QualifiedName, value2))
				{
					continue;
				}
				goto IL_026e;
			}
			foreach (XmlSchemaType value3 in otherSet.GlobalTypes.Values)
			{
				if (AddToTable(schemaTypes, value3.QualifiedName, value3))
				{
					continue;
				}
				goto IL_026e;
			}
			ProcessNewSubstitutionGroups(otherSet.SubstitutionGroups, resolve: false);
			schemaInfo.Add(cachedCompiledInfo, eventHandler);
			schemaInfo.Add(otherSet.CompiledInfo, eventHandler);
			cachedCompiledInfo = schemaInfo;
			if (flag)
			{
				isCompiled = true;
				compileAll = false;
			}
			return;
			IL_026e:
			foreach (XmlSchema value4 in sortedSchemas.Values)
			{
				if (!arrayList.Contains(value4))
				{
					Remove(value4, forceCompile: false);
				}
			}
			foreach (XmlSchemaElement value5 in otherSet.GlobalElements.Values)
			{
				if (!arrayList.Contains((XmlSchema)value5.Parent))
				{
					elements.Remove(value5.QualifiedName);
				}
			}
			foreach (XmlSchemaAttribute value6 in otherSet.GlobalAttributes.Values)
			{
				if (!arrayList.Contains((XmlSchema)value6.Parent))
				{
					attributes.Remove(value6.QualifiedName);
				}
			}
			foreach (XmlSchemaType value7 in otherSet.GlobalTypes.Values)
			{
				if (!arrayList.Contains((XmlSchema)value7.Parent))
				{
					schemaTypes.Remove(value7.QualifiedName);
				}
			}
		}

		internal XmlResolver GetResolver()
		{
			return readerSettings.GetXmlResolver_CheckConfig();
		}

		internal ValidationEventHandler GetEventHandler()
		{
			return eventHandler;
		}

		internal SchemaNames GetSchemaNames(XmlNameTable nt)
		{
			if (nameTable != nt)
			{
				return new SchemaNames(nt);
			}
			if (schemaNames == null)
			{
				schemaNames = new SchemaNames(nameTable);
			}
			return schemaNames;
		}

		internal bool IsSchemaLoaded(Uri schemaUri, string targetNamespace, out XmlSchema schema)
		{
			schema = null;
			if (targetNamespace == null)
			{
				targetNamespace = string.Empty;
			}
			if (GetSchemaByUri(schemaUri, out schema))
			{
				if (!schemas.ContainsKey(schema.SchemaId) || (targetNamespace.Length != 0 && !(targetNamespace == schema.TargetNamespace)))
				{
					if (schema.TargetNamespace == null)
					{
						XmlSchema xmlSchema = FindSchemaByNSAndUrl(schemaUri, targetNamespace, null);
						if (xmlSchema != null && schemas.ContainsKey(xmlSchema.SchemaId))
						{
							schema = xmlSchema;
						}
						else
						{
							schema = Add(targetNamespace, schema);
						}
					}
					else if (targetNamespace.Length != 0 && targetNamespace != schema.TargetNamespace)
					{
						SendValidationEvent(new XmlSchemaException("Sch_MismatchTargetNamespaceEx", new string[2] { targetNamespace, schema.TargetNamespace }), XmlSeverityType.Error);
						schema = null;
					}
					else
					{
						AddSchemaToSet(schema);
					}
				}
				return true;
			}
			return false;
		}

		internal bool GetSchemaByUri(Uri schemaUri, out XmlSchema schema)
		{
			schema = null;
			if (schemaUri == null || schemaUri.OriginalString.Length == 0)
			{
				return false;
			}
			schema = (XmlSchema)schemaLocations[schemaUri];
			if (schema != null)
			{
				return true;
			}
			return false;
		}

		internal string GetTargetNamespace(XmlSchema schema)
		{
			if (schema.TargetNamespace != null)
			{
				return schema.TargetNamespace;
			}
			return string.Empty;
		}

		private void RemoveSchemaFromCaches(XmlSchema schema)
		{
			List<XmlSchema> list = new List<XmlSchema>();
			schema.GetExternalSchemasList(list, schema);
			foreach (XmlSchema item in list)
			{
				if (item.BaseUri != null && item.BaseUri.OriginalString.Length != 0)
				{
					schemaLocations.Remove(item.BaseUri);
				}
				ICollection keys = chameleonSchemas.Keys;
				ArrayList arrayList = new ArrayList();
				foreach (ChameleonKey item2 in keys)
				{
					if (item2.chameleonLocation.Equals(item.BaseUri))
					{
						arrayList.Add(item2);
					}
				}
				foreach (ChameleonKey item3 in arrayList)
				{
					chameleonSchemas.Remove(item3);
				}
			}
		}

		private void RemoveSchemaFromGlobalTables(XmlSchema schema)
		{
			if (schemas.Count == 0)
			{
				return;
			}
			VerifyTables();
			foreach (XmlSchemaElement value in schema.Elements.Values)
			{
				XmlSchemaElement xmlSchemaElement2 = (XmlSchemaElement)elements[value.QualifiedName];
				if (xmlSchemaElement2 == value)
				{
					elements.Remove(value.QualifiedName);
				}
			}
			foreach (XmlSchemaAttribute value2 in schema.Attributes.Values)
			{
				XmlSchemaAttribute xmlSchemaAttribute2 = (XmlSchemaAttribute)attributes[value2.QualifiedName];
				if (xmlSchemaAttribute2 == value2)
				{
					attributes.Remove(value2.QualifiedName);
				}
			}
			foreach (XmlSchemaType value3 in schema.SchemaTypes.Values)
			{
				XmlSchemaType xmlSchemaType2 = (XmlSchemaType)schemaTypes[value3.QualifiedName];
				if (xmlSchemaType2 == value3)
				{
					schemaTypes.Remove(value3.QualifiedName);
				}
			}
		}

		private bool AddToTable(XmlSchemaObjectTable table, XmlQualifiedName qname, XmlSchemaObject item)
		{
			if (qname.Name.Length == 0)
			{
				return true;
			}
			XmlSchemaObject xmlSchemaObject = table[qname];
			if (xmlSchemaObject != null)
			{
				if (xmlSchemaObject == item || xmlSchemaObject.SourceUri == item.SourceUri)
				{
					return true;
				}
				string res = string.Empty;
				if (item is XmlSchemaComplexType)
				{
					res = "Sch_DupComplexType";
				}
				else if (item is XmlSchemaSimpleType)
				{
					res = "Sch_DupSimpleType";
				}
				else if (item is XmlSchemaElement)
				{
					res = "Sch_DupGlobalElement";
				}
				else if (item is XmlSchemaAttribute)
				{
					if (qname.Namespace == "http://www.w3.org/XML/1998/namespace")
					{
						XmlSchema buildInSchema = Preprocessor.GetBuildInSchema();
						XmlSchemaObject xmlSchemaObject2 = buildInSchema.Attributes[qname];
						if (xmlSchemaObject == xmlSchemaObject2)
						{
							table.Insert(qname, item);
							return true;
						}
						if (item == xmlSchemaObject2)
						{
							return true;
						}
					}
					res = "Sch_DupGlobalAttribute";
				}
				SendValidationEvent(new XmlSchemaException(res, qname.ToString()), XmlSeverityType.Error);
				return false;
			}
			table.Add(qname, item);
			return true;
		}

		private void VerifyTables()
		{
			if (elements == null)
			{
				elements = new XmlSchemaObjectTable();
			}
			if (attributes == null)
			{
				attributes = new XmlSchemaObjectTable();
			}
			if (schemaTypes == null)
			{
				schemaTypes = new XmlSchemaObjectTable();
			}
			if (substitutionGroups == null)
			{
				substitutionGroups = new XmlSchemaObjectTable();
			}
		}

		private void InternalValidationCallback(object sender, ValidationEventArgs e)
		{
			if (e.Severity == XmlSeverityType.Error)
			{
				throw e.Exception;
			}
		}

		private void SendValidationEvent(XmlSchemaException e, XmlSeverityType severity)
		{
			if (eventHandler != null)
			{
				eventHandler(this, new ValidationEventArgs(e, severity));
				return;
			}
			throw e;
		}
	}
	public sealed class XmlSchemaCompilationSettings
	{
		private bool enableUpaCheck;

		public bool EnableUpaCheck
		{
			get
			{
				return enableUpaCheck;
			}
			set
			{
				enableUpaCheck = value;
			}
		}

		public XmlSchemaCompilationSettings()
		{
			enableUpaCheck = true;
		}
	}
	public class XmlSchemaSimpleContent : XmlSchemaContentModel
	{
		private XmlSchemaContent content;

		[XmlElement("extension", typeof(XmlSchemaSimpleContentExtension))]
		[XmlElement("restriction", typeof(XmlSchemaSimpleContentRestriction))]
		public override XmlSchemaContent Content
		{
			get
			{
				return content;
			}
			set
			{
				content = value;
			}
		}
	}
	public class XmlSchemaSimpleContentExtension : XmlSchemaContent
	{
		private XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();

		private XmlSchemaAnyAttribute anyAttribute;

		private XmlQualifiedName baseTypeName = XmlQualifiedName.Empty;

		[XmlAttribute("base")]
		public XmlQualifiedName BaseTypeName
		{
			get
			{
				return baseTypeName;
			}
			set
			{
				baseTypeName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlElement("attribute", typeof(XmlSchemaAttribute))]
		[XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
		public XmlSchemaObjectCollection Attributes => attributes;

		[XmlElement("anyAttribute")]
		public XmlSchemaAnyAttribute AnyAttribute
		{
			get
			{
				return anyAttribute;
			}
			set
			{
				anyAttribute = value;
			}
		}

		internal void SetAttributes(XmlSchemaObjectCollection newAttributes)
		{
			attributes = newAttributes;
		}
	}
	public class XmlSchemaSimpleContentRestriction : XmlSchemaContent
	{
		private XmlQualifiedName baseTypeName = XmlQualifiedName.Empty;

		private XmlSchemaSimpleType baseType;

		private XmlSchemaObjectCollection facets = new XmlSchemaObjectCollection();

		private XmlSchemaObjectCollection attributes = new XmlSchemaObjectCollection();

		private XmlSchemaAnyAttribute anyAttribute;

		[XmlAttribute("base")]
		public XmlQualifiedName BaseTypeName
		{
			get
			{
				return baseTypeName;
			}
			set
			{
				baseTypeName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
		public XmlSchemaSimpleType BaseType
		{
			get
			{
				return baseType;
			}
			set
			{
				baseType = value;
			}
		}

		[XmlElement("whiteSpace", typeof(XmlSchemaWhiteSpaceFacet))]
		[XmlElement("maxInclusive", typeof(XmlSchemaMaxInclusiveFacet))]
		[XmlElement("maxExclusive", typeof(XmlSchemaMaxExclusiveFacet))]
		[XmlElement("minInclusive", typeof(XmlSchemaMinInclusiveFacet))]
		[XmlElement("minExclusive", typeof(XmlSchemaMinExclusiveFacet))]
		[XmlElement("totalDigits", typeof(XmlSchemaTotalDigitsFacet))]
		[XmlElement("fractionDigits", typeof(XmlSchemaFractionDigitsFacet))]
		[XmlElement("length", typeof(XmlSchemaLengthFacet))]
		[XmlElement("minLength", typeof(XmlSchemaMinLengthFacet))]
		[XmlElement("maxLength", typeof(XmlSchemaMaxLengthFacet))]
		[XmlElement("pattern", typeof(XmlSchemaPatternFacet))]
		[XmlElement("enumeration", typeof(XmlSchemaEnumerationFacet))]
		public XmlSchemaObjectCollection Facets => facets;

		[XmlElement("attributeGroup", typeof(XmlSchemaAttributeGroupRef))]
		[XmlElement("attribute", typeof(XmlSchemaAttribute))]
		public XmlSchemaObjectCollection Attributes => attributes;

		[XmlElement("anyAttribute")]
		public XmlSchemaAnyAttribute AnyAttribute
		{
			get
			{
				return anyAttribute;
			}
			set
			{
				anyAttribute = value;
			}
		}

		internal void SetAttributes(XmlSchemaObjectCollection newAttributes)
		{
			attributes = newAttributes;
		}
	}
	public class XmlSchemaSimpleType : XmlSchemaType
	{
		private XmlSchemaSimpleTypeContent content;

		[XmlElement("union", typeof(XmlSchemaSimpleTypeUnion))]
		[XmlElement("list", typeof(XmlSchemaSimpleTypeList))]
		[XmlElement("restriction", typeof(XmlSchemaSimpleTypeRestriction))]
		public XmlSchemaSimpleTypeContent Content
		{
			get
			{
				return content;
			}
			set
			{
				content = value;
			}
		}

		internal override XmlQualifiedName DerivedFrom
		{
			get
			{
				if (content == null)
				{
					return XmlQualifiedName.Empty;
				}
				if (content is XmlSchemaSimpleTypeRestriction)
				{
					return ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName;
				}
				return XmlQualifiedName.Empty;
			}
		}

		internal override XmlSchemaObject Clone()
		{
			XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)MemberwiseClone();
			if (content != null)
			{
				xmlSchemaSimpleType.Content = (XmlSchemaSimpleTypeContent)content.Clone();
			}
			return xmlSchemaSimpleType;
		}
	}
	public abstract class XmlSchemaSimpleTypeContent : XmlSchemaAnnotated
	{
	}
	public class XmlSchemaSimpleTypeList : XmlSchemaSimpleTypeContent
	{
		private XmlQualifiedName itemTypeName = XmlQualifiedName.Empty;

		private XmlSchemaSimpleType itemType;

		private XmlSchemaSimpleType baseItemType;

		[XmlAttribute("itemType")]
		public XmlQualifiedName ItemTypeName
		{
			get
			{
				return itemTypeName;
			}
			set
			{
				itemTypeName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
		public XmlSchemaSimpleType ItemType
		{
			get
			{
				return itemType;
			}
			set
			{
				itemType = value;
			}
		}

		[XmlIgnore]
		public XmlSchemaSimpleType BaseItemType
		{
			get
			{
				return baseItemType;
			}
			set
			{
				baseItemType = value;
			}
		}

		internal override XmlSchemaObject Clone()
		{
			XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = (XmlSchemaSimpleTypeList)MemberwiseClone();
			xmlSchemaSimpleTypeList.ItemTypeName = itemTypeName.Clone();
			return xmlSchemaSimpleTypeList;
		}
	}
	public class XmlSchemaSimpleTypeRestriction : XmlSchemaSimpleTypeContent
	{
		private XmlQualifiedName baseTypeName = XmlQualifiedName.Empty;

		private XmlSchemaSimpleType baseType;

		private XmlSchemaObjectCollection facets = new XmlSchemaObjectCollection();

		[XmlAttribute("base")]
		public XmlQualifiedName BaseTypeName
		{
			get
			{
				return baseTypeName;
			}
			set
			{
				baseTypeName = ((value == null) ? XmlQualifiedName.Empty : value);
			}
		}

		[XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
		public XmlSchemaSimpleType BaseType
		{
			get
			{
				return baseType;
			}
			set
			{
				baseType = value;
			}
		}

		[XmlElement("totalDigits", typeof(XmlSchemaTotalDigitsFacet))]
		[XmlElement("maxExclusive", typeof(XmlSchemaMaxExclusiveFacet))]
		[XmlElement("fractionDigits", typeof(XmlSchemaFractionDigitsFacet))]
		[XmlElement("minLength", typeof(XmlSchemaMinLengthFacet))]
		[XmlElement("pattern", typeof(XmlSchemaPatternFacet))]
		[XmlElement("enumeration", typeof(XmlSchemaEnumerationFacet))]
		[XmlElement("maxInclusive", typeof(XmlSchemaMaxInclusiveFacet))]
		[XmlElement("minInclusive", typeof(XmlSchemaMinInclusiveFacet))]
		[XmlElement("minExclusive", typeof(XmlSchemaMinExclusiveFacet))]
		[XmlElement("length", typeof(XmlSchemaLengthFacet))]
		[XmlElement("maxLength", typeof(XmlSchemaMaxLengthFacet))]
		[XmlElement("whiteSpace", typeof(XmlSchemaWhiteSpaceFacet))]
		public XmlSchemaObjectCollection Facets => facets;

		internal override XmlSchemaObject Clone()
		{
			XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)MemberwiseClone();
			xmlSchemaSimpleTypeRestriction.BaseTypeName = baseTypeName.Clone();
			return xmlSchemaSimpleTypeRestriction;
		}
	}
	public class XmlSchemaSimpleTypeUnion : XmlSchemaSimpleTypeContent
	{
		private XmlSchemaObjectCollection baseTypes = new XmlSchemaObjectCollection();

		private XmlQualifiedName[] memberTypes;

		private XmlSchemaSimpleType[] baseMemberTypes;

		[XmlElement("simpleType", typeof(XmlSchemaSimpleType))]
		public XmlSchemaObjectCollection BaseTypes => baseTypes;

		[XmlAttribute("memberTypes")]
		public XmlQualifiedName[] MemberTypes
		{
			get
			{
				return memberTypes;
			}
			set
			{
				memberTypes = value;
			}
		}

		[XmlIgnore]
		public XmlSchemaSimpleType[] BaseMemberTypes => baseMemberTypes;

		internal void SetBaseMemberTypes(XmlSchemaSimpleType[] baseMemberTypes)
		{
			this.baseMemberTypes = baseMemberTypes;
		}

		internal override XmlSchemaObject Clone()
		{
			if (memberTypes != null && memberTypes.Length > 0)
			{
				XmlSchemaSimpleTypeUnion xmlSchemaSimpleTypeUnion = (XmlSchemaSimpleTypeUnion)MemberwiseClone();
				XmlQualifiedName[] array = new XmlQualifiedName[memberTypes.Length];
				for (int i = 0; i < memberTypes.Length; i++)
				{
					array[i] = memberTypes[i].Clone();
				}
				xmlSchemaSimpleTypeUnion.MemberTypes = array;
				return xmlSchemaSimpleTypeUnion;
			}
			return this;
		}
	}
	internal class XmlSchemaSubstitutionGroup : XmlSchemaObject
	{
		private ArrayList membersList = new ArrayList();

		private XmlQualifiedName examplar = XmlQualifiedName.Empty;

		[XmlIgnore]
		internal ArrayList Members => membersList;

		[XmlIgnore]
		internal XmlQualifiedName Examplar
		{
			get
			{
				return examplar;
			}
			set
			{
				examplar = value;
			}
		}
	}
	internal class XmlSchemaSubstitutionGroupV1Compat : XmlSchemaSubstitutionGroup
	{
		private XmlSchemaChoice choice = new XmlSchemaChoice();

		[XmlIgnore]
		internal XmlSchemaChoice Choice => choice;
	}
	public enum XmlSchemaUse
	{
		[XmlIgnore]
		None,
		[XmlEnum("optional")]
		Optional,
		[XmlEnum("prohibited")]
		Prohibited,
		[XmlEnum("required")]
		Required
	}
	[Serializable]
	public class XmlSchemaValidationException : XmlSchemaException
	{
		private object sourceNodeObject;

		public object SourceObject => sourceNodeObject;

		protected XmlSchemaValidationException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
		}

		public XmlSchemaValidationException()
			: base(null)
		{
		}

		public XmlSchemaValidationException(string message)
			: base(message, (Exception)null, 0, 0)
		{
		}

		public XmlSchemaValidationException(string message, Exception innerException)
			: base(message, innerException, 0, 0)
		{
		}

		public XmlSchemaValidationException(string message, Exception innerException, int lineNumber, int linePosition)
			: base(message, innerException, lineNumber, linePosition)
		{
		}

		internal XmlSchemaValidationException(string res, string[] args)
			: base(res, args, null, null, 0, 0, null)
		{
		}

		internal XmlSchemaValidationException(string res, string arg)
			: base(res, new string[1] { arg }, null, null, 0, 0, null)
		{
		}

		internal XmlSchemaValidationException(string res, string arg, string sourceUri, int lineNumber, int linePosition)
			: base(res, new string[1] { arg }, null, sourceUri, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaValidationException(string res, string sourceUri, int lineNumber, int linePosition)
			: base(res, null, null, sourceUri, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaValidationException(string res, string[] args, string sourceUri, int lineNumber, int linePosition)
			: base(res, args, null, sourceUri, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaValidationException(string res, string[] args, Exception innerException, string sourceUri, int lineNumber, int linePosition)
			: base(res, args, innerException, sourceUri, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaValidationException(string res, string[] args, object sourceNode)
			: base(res, args, null, null, 0, 0, null)
		{
			sourceNodeObject = sourceNode;
		}

		internal XmlSchemaValidationException(string res, string[] args, string sourceUri, object sourceNode)
			: base(res, args, null, sourceUri, 0, 0, null)
		{
			sourceNodeObject = sourceNode;
		}

		internal XmlSchemaValidationException(string res, string[] args, string sourceUri, int lineNumber, int linePosition, XmlSchemaObject source, object sourceNode)
			: base(res, args, null, sourceUri, lineNumber, linePosition, source)
		{
			sourceNodeObject = sourceNode;
		}

		protected internal void SetSourceObject(object sourceObject)
		{
			sourceNodeObject = sourceObject;
		}
	}
	public delegate object XmlValueGetter();
	[Flags]
	public enum XmlSchemaValidationFlags
	{
		None = 0,
		ProcessInlineSchema = 1,
		ProcessSchemaLocation = 2,
		ReportValidationWarnings = 4,
		ProcessIdentityConstraints = 8,
		AllowXmlAttributes = 0x10
	}
	internal enum ValidatorState
	{
		None,
		Start,
		TopLevelAttribute,
		TopLevelTextOrWS,
		Element,
		Attribute,
		EndOfAttributes,
		Text,
		Whitespace,
		EndElement,
		SkipToEndElement,
		Finish
	}
	internal class IdRefNode
	{
		internal string Id;

		internal int LineNo;

		internal int LinePos;

		internal IdRefNode Next;

		internal IdRefNode(IdRefNode next, string id, int lineNo, int linePos)
		{
			Id = id;
			LineNo = lineNo;
			LinePos = linePos;
			Next = next;
		}
	}
	public sealed class XmlSchemaValidator
	{
		private const int STACK_INCREMENT = 10;

		private const string Quote = "'";

		private XmlSchemaSet schemaSet;

		private XmlSchemaValidationFlags validationFlags;

		private int startIDConstraint = -1;

		private bool isRoot;

		private bool rootHasSchema;

		private bool attrValid;

		private bool checkEntity;

		private SchemaInfo compiledSchemaInfo;

		private SchemaInfo dtdSchemaInfo;

		private Hashtable validatedNamespaces;

		private HWStack validationStack;

		private ValidationState context;

		private ValidatorState currentState;

		private Hashtable attPresence;

		private SchemaAttDef wildID;

		private Hashtable IDs;

		private IdRefNode idRefListHead;

		private XmlQualifiedName contextQName;

		private string NsXs;

		private string NsXsi;

		private string NsXmlNs;

		private string NsXml;

		private XmlSchemaObject partialValidationType;

		private StringBuilder textValue;

		private ValidationEventHandler eventHandler;

		private object validationEventSender;

		private XmlNameTable nameTable;

		private IXmlLineInfo positionInfo;

		private IXmlLineInfo dummyPositionInfo;

		private XmlResolver xmlResolver;

		private Uri sourceUri;

		private string sourceUriString;

		private IXmlNamespaceResolver nsResolver;

		private XmlSchemaContentProcessing processContents = XmlSchemaContentProcessing.Strict;

		private static XmlSchemaAttribute xsiTypeSO;

		private static XmlSchemaAttribute xsiNilSO;

		private static XmlSchemaAttribute xsiSLSO;

		private static XmlSchemaAttribute xsiNoNsSLSO;

		private string xsiTypeString;

		private string xsiNilString;

		private string xsiSchemaLocationString;

		private string xsiNoNamespaceSchemaLocationString;

		private static readonly XmlSchemaDatatype dtQName = XmlSchemaDatatype.FromXmlTokenizedTypeXsd(XmlTokenizedType.QName);

		private static readonly XmlSchemaDatatype dtCDATA = XmlSchemaDatatype.FromXmlTokenizedType(XmlTokenizedType.CDATA);

		private static readonly XmlSchemaDatatype dtStringArray = dtCDATA.DeriveByList(null);

		private static XmlSchemaParticle[] EmptyParticleArray = new XmlSchemaParticle[0];

		private static XmlSchemaAttribute[] EmptyAttributeArray = new XmlSchemaAttribute[0];

		private XmlCharType xmlCharType = XmlCharType.Instance;

		internal static bool[,] ValidStates = new bool[12, 12]
		{
			{
				true, true, false, false, false, false, false, false, false, false,
				false, false
			},
			{
				false, true, true, true, true, false, false, false, false, false,
				false, true
			},
			{
				false, false, false, false, false, false, false, false, false, false,
				false, true
			},
			{
				false, false, false, true, true, false, false, false, false, false,
				false, true
			},
			{
				false, false, false, true, false, true, true, false, false, true,
				true, false
			},
			{
				false, false, false, false, false, true, true, false, false, true,
				true, false
			},
			{
				false, false, false, false, true, false, false, true, true, true,
				true, false
			},
			{
				false, false, false, false, true, false, false, true, true, true,
				true, false
			},
			{
				false, false, false, false, true, false, false, true, true, true,
				true, false
			},
			{
				false, false, false, true, true, false, false, true, true, true,
				true, true
			},
			{
				false, false, false, true, true, false, false, true, true, true,
				true, true
			},
			{
				false, true, false, false, false, false, false, false, false, false,
				false, false
			}
		};

		private static string[] MethodNames = new string[12]
		{
			"None", "Initialize", "top-level ValidateAttribute", "top-level ValidateText or ValidateWhitespace", "ValidateElement", "ValidateAttribute", "ValidateEndOfAttributes", "ValidateText", "ValidateWhitespace", "ValidateEndElement",
			"SkipToEndElement", "EndValidation"
		};

		public XmlResolver XmlResolver
		{
			set
			{
				xmlResolver = value;
			}
		}

		public IXmlLineInfo LineInfoProvider
		{
			get
			{
				return positionInfo;
			}
			set
			{
				if (value == null)
				{
					positionInfo = dummyPositionInfo;
				}
				else
				{
					positionInfo = value;
				}
			}
		}

		public Uri SourceUri
		{
			get
			{
				return sourceUri;
			}
			set
			{
				sourceUri = value;
				sourceUriString = sourceUri.ToString();
			}
		}

		public object ValidationEventSender
		{
			get
			{
				return validationEventSender;
			}
			set
			{
				validationEventSender = value;
			}
		}

		internal XmlSchemaSet SchemaSet => schemaSet;

		internal XmlSchemaValidationFlags ValidationFlags => validationFlags;

		internal XmlSchemaContentType CurrentContentType
		{
			get
			{
				if (context.ElementDecl == null)
				{
					return XmlSchemaContentType.Empty;
				}
				return context.ElementDecl.ContentValidator.ContentType;
			}
		}

		internal XmlSchemaContentProcessing CurrentProcessContents => processContents;

		private bool StrictlyAssessed
		{
			get
			{
				if ((processContents == XmlSchemaContentProcessing.Strict || processContents == XmlSchemaContentProcessing.Lax) && context.ElementDecl != null)
				{
					return !context.ValidationSkipped;
				}
				return false;
			}
		}

		private bool HasSchema
		{
			get
			{
				if (isRoot)
				{
					isRoot = false;
					if (!compiledSchemaInfo.Contains(context.Namespace))
					{
						rootHasSchema = false;
					}
				}
				return rootHasSchema;
			}
		}

		private bool HasIdentityConstraints
		{
			get
			{
				if (ProcessIdentityConstraints)
				{
					return startIDConstraint != -1;
				}
				return false;
			}
		}

		internal bool ProcessIdentityConstraints => (validationFlags & XmlSchemaValidationFlags.ProcessIdentityConstraints) != 0;

		internal bool ReportValidationWarnings => (validationFlags & XmlSchemaValidationFlags.ReportValidationWarnings) != 0;

		internal bool ProcessInlineSchema => (validationFlags & XmlSchemaValidationFlags.ProcessInlineSchema) != 0;

		internal bool ProcessSchemaLocation => (validationFlags & XmlSchemaValidationFlags.ProcessSchemaLocation) != 0;

		internal bool ProcessSchemaHints
		{
			get
			{
				if ((validationFlags & XmlSchemaValidationFlags.ProcessInlineSchema) == 0)
				{
					return (validationFlags & XmlSchemaValidationFlags.ProcessSchemaLocation) != 0;
				}
				return true;
			}
		}

		public event ValidationEventHandler ValidationEventHandler
		{
			add
			{
				eventHandler = (ValidationEventHandler)Delegate.Combine(eventHandler, value);
			}
			remove
			{
				eventHandler = (ValidationEventHandler)Delegate.Remove(eventHandler, value);
			}
		}

		public XmlSchemaValidator(XmlNameTable nameTable, XmlSchemaSet schemas, IXmlNamespaceResolver namespaceResolver, XmlSchemaValidationFlags validationFlags)
		{
			if (nameTable == null)
			{
				throw new ArgumentNullException("nameTable");
			}
			if (schemas == null)
			{
				throw new ArgumentNullException("schemas");
			}
			if (namespaceResolver == null)
			{
				throw new ArgumentNullException("namespaceResolver");
			}
			this.nameTable = nameTable;
			nsResolver = namespaceResolver;
			this.validationFlags = validationFlags;
			if ((validationFlags & XmlSchemaValidationFlags.ProcessInlineSchema) != 0 || (validationFlags & XmlSchemaValidationFlags.ProcessSchemaLocation) != 0)
			{
				schemaSet = new XmlSchemaSet(nameTable);
				schemaSet.ValidationEventHandler += schemas.GetEventHandler();
				schemaSet.CompilationSettings = schemas.CompilationSettings;
				schemaSet.XmlResolver = schemas.GetResolver();
				schemaSet.Add(schemas);
				validatedNamespaces = new Hashtable();
			}
			else
			{
				schemaSet = schemas;
			}
			Init();
		}

		private void Init()
		{
			validationStack = new HWStack(10);
			attPresence = new Hashtable();
			Push(XmlQualifiedName.Empty);
			dummyPositionInfo = new PositionInfo();
			positionInfo = dummyPositionInfo;
			validationEventSender = this;
			currentState = ValidatorState.None;
			textValue = new StringBuilder(100);
			xmlResolver = XmlReaderSection.CreateDefaultResolver();
			contextQName = new XmlQualifiedName();
			Reset();
			RecompileSchemaSet();
			NsXs = nameTable.Add("http://www.w3.org/2001/XMLSchema");
			NsXsi = nameTable.Add("http://www.w3.org/2001/XMLSchema-instance");
			NsXmlNs = nameTable.Add("http://www.w3.org/2000/xmlns/");
			NsXml = nameTable.Add("http://www.w3.org/XML/1998/namespace");
			xsiTypeString = nameTable.Add("type");
			xsiNilString = nameTable.Add("nil");
			xsiSchemaLocationString = nameTable.Add("schemaLocation");
			xsiNoNamespaceSchemaLocationString = nameTable.Add("noNamespaceSchemaLocation");
		}

		private void Reset()
		{
			isRoot = true;
			rootHasSchema = true;
			while (validationStack.Length > 1)
			{
				validationStack.Pop();
			}
			startIDConstraint = -1;
			partialValidationType = null;
			if (IDs != null)
			{
				IDs.Clear();
			}
			if (ProcessSchemaHints)
			{
				validatedNamespaces.Clear();
			}
		}

		public void AddSchema(XmlSchema schema)
		{
			if (schema == null)
			{
				throw new ArgumentNullException("schema");
			}
			if ((validationFlags & XmlSchemaValidationFlags.ProcessInlineSchema) == 0)
			{
				return;
			}
			string text = schema.TargetNamespace;
			if (text == null)
			{
				text = string.Empty;
			}
			Hashtable schemaLocations = schemaSet.SchemaLocations;
			DictionaryEntry[] array = new DictionaryEntry[schemaLocations.Count];
			schemaLocations.CopyTo(array, 0);
			if (validatedNamespaces[text] != null && schemaSet.FindSchemaByNSAndUrl(schema.BaseUri, text, array) == null)
			{
				SendValidationEvent("Sch_ComponentAlreadySeenForNS", text, XmlSeverityType.Error);
			}
			if (schema.ErrorCount != 0)
			{
				return;
			}
			try
			{
				schemaSet.Add(schema);
				RecompileSchemaSet();
			}
			catch (XmlSchemaException ex)
			{
				SendValidationEvent("Sch_CannotLoadSchema", new string[2]
				{
					schema.BaseUri.ToString(),
					ex.Message
				}, ex);
			}
			foreach (XmlSchema importedSchema in schema.ImportedSchemas)
			{
				text = importedSchema.TargetNamespace;
				if (text == null)
				{
					text = string.Empty;
				}
				if (validatedNamespaces[text] != null && schemaSet.FindSchemaByNSAndUrl(importedSchema.BaseUri, text, array) == null)
				{
					SendValidationEvent("Sch_ComponentAlreadySeenForNS", text, XmlSeverityType.Error);
					schemaSet.RemoveRecursive(schema);
					break;
				}
			}
		}

		public void Initialize()
		{
			if (currentState != 0 && currentState != ValidatorState.Finish)
			{
				throw new InvalidOperationException(Res.GetString("Sch_InvalidStateTransition", MethodNames[(int)currentState], MethodNames[1]));
			}
			currentState = ValidatorState.Start;
			Reset();
		}

		public void Initialize(XmlSchemaObject partialValidationType)
		{
			if (currentState != 0 && currentState != ValidatorState.Finish)
			{
				throw new InvalidOperationException(Res.GetString("Sch_InvalidStateTransition", MethodNames[(int)currentState], MethodNames[1]));
			}
			if (partialValidationType == null)
			{
				throw new ArgumentNullException("partialValidationType");
			}
			if (!(partialValidationType is XmlSchemaElement) && !(partialValidationType is XmlSchemaAttribute) && !(partialValidationType is XmlSchemaType))
			{
				throw new ArgumentException(Res.GetString("Sch_InvalidPartialValidationType"));
			}
			currentState = ValidatorState.Start;
			Reset();
			this.partialValidationType = partialValidationType;
		}

		public void ValidateElement(string localName, string namespaceUri, XmlSchemaInfo schemaInfo)
		{
			ValidateElement(localName, namespaceUri, schemaInfo, null, null, null, null);
		}

		public void ValidateElement(string localName, string namespaceUri, XmlSchemaInfo schemaInfo, string xsiType, string xsiNil, string xsiSchemaLocation, string xsiNoNamespaceSchemaLocation)
		{
			if (localName == null)
			{
				throw new ArgumentNullException("localName");
			}
			if (namespaceUri == null)
			{
				throw new ArgumentNullException("namespaceUri");
			}
			CheckStateTransition(ValidatorState.Element, MethodNames[4]);
			ClearPSVI();
			contextQName.Init(localName, namespaceUri);
			XmlQualifiedName xmlQualifiedName = contextQName;
			bool invalidElementInContext;
			object particle = ValidateElementContext(xmlQualifiedName, out invalidElementInContext);
			SchemaElementDecl schemaElementDecl = FastGetElementDecl(xmlQualifiedName, particle);
			Push(xmlQualifiedName);
			if (invalidElementInContext)
			{
				context.Validity = XmlSchemaValidity.Invalid;
			}
			if ((validationFlags & XmlSchemaValidationFlags.ProcessSchemaLocation) != 0 && xmlResolver != null)
			{
				ProcessSchemaLocations(xsiSchemaLocation, xsiNoNamespaceSchemaLocation);
			}
			if (processContents != XmlSchemaContentProcessing.Skip)
			{
				if (schemaElementDecl == null && partialValidationType == null)
				{
					schemaElementDecl = compiledSchemaInfo.GetElementDecl(xmlQualifiedName);
				}
				bool declFound = schemaElementDecl != null;
				if (xsiType != null || xsiNil != null)
				{
					schemaElementDecl = CheckXsiTypeAndNil(schemaElementDecl, xsiType, xsiNil, ref declFound);
				}
				if (schemaElementDecl == null)
				{
					ThrowDeclNotFoundWarningOrError(declFound);
				}
			}
			context.ElementDecl = schemaElementDecl;
			XmlSchemaElement schemaElement = null;
			XmlSchemaType schemaType = null;
			if (schemaElementDecl != null)
			{
				CheckElementProperties();
				attPresence.Clear();
				context.NeedValidateChildren = processContents != XmlSchemaContentProcessing.Skip;
				ValidateStartElementIdentityConstraints();
				schemaElementDecl.ContentValidator.InitValidation(context);
				schemaType = schemaElementDecl.SchemaType;
				schemaElement = GetSchemaElement();
			}
			if (schemaInfo != null)
			{
				schemaInfo.SchemaType = schemaType;
				schemaInfo.SchemaElement = schemaElement;
				schemaInfo.IsNil = context.IsNill;
				schemaInfo.Validity = context.Validity;
			}
			if (ProcessSchemaHints && validatedNamespaces[namespaceUri] == null)
			{
				validatedNamespaces.Add(namespaceUri, namespaceUri);
			}
			if (isRoot)
			{
				isRoot = false;
			}
		}

		public object ValidateAttribute(string localName, string namespaceUri, string attributeValue, XmlSchemaInfo schemaInfo)
		{
			if (attributeValue == null)
			{
				throw new ArgumentNullException("attributeValue");
			}
			return ValidateAttribute(localName, namespaceUri, null, attributeValue, schemaInfo);
		}

		public object ValidateAttribute(string localName, string namespaceUri, XmlValueGetter attributeValue, XmlSchemaInfo schemaInfo)
		{
			if (attributeValue == null)
			{
				throw new ArgumentNullException("attributeValue");
			}
			return ValidateAttribute(localName, namespaceUri, attributeValue, null, schemaInfo);
		}

		private object ValidateAttribute(string lName, string ns, XmlValueGetter attributeValueGetter, string attributeStringValue, XmlSchemaInfo schemaInfo)
		{
			if (lName == null)
			{
				throw new ArgumentNullException("localName");
			}
			if (ns == null)
			{
				throw new ArgumentNullException("namespaceUri");
			}
			ValidatorState validatorState = ((validationStack.Length > 1) ? ValidatorState.Attribute : ValidatorState.TopLevelAttribute);
			CheckStateTransition(validatorState, MethodNames[(int)validatorState]);
			object obj = null;
			attrValid = true;
			XmlSchemaValidity validity = XmlSchemaValidity.NotKnown;
			XmlSchemaAttribute xmlSchemaAttribute = null;
			XmlSchemaSimpleType memberType = null;
			ns = nameTable.Add(ns);
			if (Ref.Equal(ns, NsXmlNs))
			{
				return null;
			}
			SchemaAttDef schemaAttDef = null;
			SchemaElementDecl elementDecl = context.ElementDecl;
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(lName, ns);
			if (attPresence[xmlQualifiedName] != null)
			{
				SendValidationEvent("Sch_DuplicateAttribute", xmlQualifiedName.ToString());
				schemaInfo?.Clear();
				return null;
			}
			if (!Ref.Equal(ns, NsXsi))
			{
				XmlSchemaObject xmlSchemaObject = ((currentState == ValidatorState.TopLevelAttribute) ? partialValidationType : null);
				schemaAttDef = compiledSchemaInfo.GetAttributeXsd(elementDecl, xmlQualifiedName, xmlSchemaObject, out var attributeMatchState);
				switch (attributeMatchState)
				{
				case AttributeMatchState.UndeclaredElementAndAttribute:
					if ((schemaAttDef = CheckIsXmlAttribute(xmlQualifiedName)) == null)
					{
						if (elementDecl == null && processContents == XmlSchemaContentProcessing.Strict && xmlQualifiedName.Namespace.Length != 0 && compiledSchemaInfo.Contains(xmlQualifiedName.Namespace))
						{
							attrValid = false;
							SendValidationEvent("Sch_UndeclaredAttribute", xmlQualifiedName.ToString());
						}
						else if (processContents != XmlSchemaContentProcessing.Skip)
						{
							SendValidationEvent("Sch_NoAttributeSchemaFound", xmlQualifiedName.ToString(), XmlSeverityType.Warning);
						}
						break;
					}
					goto case AttributeMatchState.AttributeFound;
				case AttributeMatchState.UndeclaredAttribute:
					if ((schemaAttDef = CheckIsXmlAttribute(xmlQualifiedName)) == null)
					{
						attrValid = false;
						SendValidationEvent("Sch_UndeclaredAttribute", xmlQualifiedName.ToString());
						break;
					}
					goto case AttributeMatchState.AttributeFound;
				case AttributeMatchState.ProhibitedAnyAttribute:
					if ((schemaAttDef = CheckIsXmlAttribute(xmlQualifiedName)) == null)
					{
						attrValid = false;
						SendValidationEvent("Sch_ProhibitedAttribute", xmlQualifiedName.ToString());
						break;
					}
					goto case AttributeMatchState.AttributeFound;
				case AttributeMatchState.ProhibitedAttribute:
					attrValid = false;
					SendValidationEvent("Sch_ProhibitedAttribute", xmlQualifiedName.ToString());
					break;
				case AttributeMatchState.AttributeNameMismatch:
					attrValid = false;
					SendValidationEvent("Sch_SchemaAttributeNameMismatch", new string[2]
					{
						xmlQualifiedName.ToString(),
						((XmlSchemaAttribute)xmlSchemaObject).QualifiedName.ToString()
					});
					break;
				case AttributeMatchState.ValidateAttributeInvalidCall:
					currentState = ValidatorState.Start;
					attrValid = false;
					SendValidationEvent("Sch_ValidateAttributeInvalidCall", string.Empty);
					break;
				case AttributeMatchState.AnyIdAttributeFound:
					if (wildID == null)
					{
						wildID = schemaAttDef;
						XmlSchemaComplexType xmlSchemaComplexType = elementDecl.SchemaType as XmlSchemaComplexType;
						if (xmlSchemaComplexType.ContainsIdAttribute(findAll: false))
						{
							SendValidationEvent("Sch_AttrUseAndWildId", string.Empty);
							break;
						}
						goto case AttributeMatchState.AttributeFound;
					}
					SendValidationEvent("Sch_MoreThanOneWildId", string.Empty);
					break;
				case AttributeMatchState.AttributeFound:
				{
					xmlSchemaAttribute = schemaAttDef.SchemaAttribute;
					if (elementDecl != null)
					{
						attPresence.Add(xmlQualifiedName, schemaAttDef);
					}
					object obj2 = ((attributeValueGetter == null) ? attributeStringValue : attributeValueGetter());
					obj = CheckAttributeValue(obj2, schemaAttDef);
					XmlSchemaDatatype datatype = schemaAttDef.Datatype;
					if (datatype.Variety == XmlSchemaDatatypeVariety.Union && obj != null)
					{
						XsdSimpleValue xsdSimpleValue = obj as XsdSimpleValue;
						memberType = xsdSimpleValue.XmlType;
						datatype = xsdSimpleValue.XmlType.Datatype;
						obj = xsdSimpleValue.TypedValue;
					}
					CheckTokenizedTypes(datatype, obj, attrValue: true);
					if (HasIdentityConstraints)
					{
						AttributeIdentityConstraints(xmlQualifiedName.Name, xmlQualifiedName.Namespace, obj, obj2.ToString(), datatype);
					}
					break;
				}
				case AttributeMatchState.AnyAttributeLax:
					SendValidationEvent("Sch_NoAttributeSchemaFound", xmlQualifiedName.ToString(), XmlSeverityType.Warning);
					break;
				}
			}
			else
			{
				lName = nameTable.Add(lName);
				if (Ref.Equal(lName, xsiTypeString) || Ref.Equal(lName, xsiNilString) || Ref.Equal(lName, xsiSchemaLocationString) || Ref.Equal(lName, xsiNoNamespaceSchemaLocationString))
				{
					attPresence.Add(xmlQualifiedName, SchemaAttDef.Empty);
				}
				else
				{
					attrValid = false;
					SendValidationEvent("Sch_NotXsiAttribute", xmlQualifiedName.ToString());
				}
			}
			if (!attrValid)
			{
				validity = XmlSchemaValidity.Invalid;
			}
			else if (schemaAttDef != null)
			{
				validity = XmlSchemaValidity.Valid;
			}
			if (schemaInfo != null)
			{
				schemaInfo.SchemaAttribute = xmlSchemaAttribute;
				schemaInfo.SchemaType = xmlSchemaAttribute?.AttributeSchemaType;
				schemaInfo.MemberType = memberType;
				schemaInfo.IsDefault = false;
				schemaInfo.Validity = validity;
			}
			if (ProcessSchemaHints && validatedNamespaces[ns] == null)
			{
				validatedNamespaces.Add(ns, ns);
			}
			return obj;
		}

		public void GetUnspecifiedDefaultAttributes(ArrayList defaultAttributes)
		{
			if (defaultAttributes == null)
			{
				throw new ArgumentNullException("defaultAttributes");
			}
			CheckStateTransition(ValidatorState.Attribute, "GetUnspecifiedDefaultAttributes");
			GetUnspecifiedDefaultAttributes(defaultAttributes, createNodeData: false);
		}

		public void ValidateEndOfAttributes(XmlSchemaInfo schemaInfo)
		{
			CheckStateTransition(ValidatorState.EndOfAttributes, MethodNames[6]);
			SchemaElementDecl elementDecl = context.ElementDecl;
			if (elementDecl != null && elementDecl.HasRequiredAttribute)
			{
				context.CheckRequiredAttribute = false;
				CheckRequiredAttributes(elementDecl);
			}
			if (schemaInfo != null)
			{
				schemaInfo.Validity = context.Validity;
			}
		}

		public void ValidateText(string elementValue)
		{
			if (elementValue == null)
			{
				throw new ArgumentNullException("elementValue");
			}
			ValidateText(elementValue, null);
		}

		public void ValidateText(XmlValueGetter elementValue)
		{
			if (elementValue == null)
			{
				throw new ArgumentNullException("elementValue");
			}
			ValidateText(null, elementValue);
		}

		private void ValidateText(string elementStringValue, XmlValueGetter elementValueGetter)
		{
			ValidatorState validatorState = ((validationStack.Length > 1) ? ValidatorState.Text : ValidatorState.TopLevelTextOrWS);
			CheckStateTransition(validatorState, MethodNames[(int)validatorState]);
			if (!context.NeedValidateChildren)
			{
				return;
			}
			if (context.IsNill)
			{
				SendValidationEvent("Sch_ContentInNill", QNameString(context.LocalName, context.Namespace));
				return;
			}
			switch (context.ElementDecl.ContentValidator.ContentType)
			{
			case XmlSchemaContentType.Empty:
				SendValidationEvent("Sch_InvalidTextInEmpty", string.Empty);
				break;
			case XmlSchemaContentType.TextOnly:
				if (elementValueGetter != null)
				{
					SaveTextValue(elementValueGetter());
				}
				else
				{
					SaveTextValue(elementStringValue);
				}
				break;
			case XmlSchemaContentType.ElementOnly:
			{
				string str = ((elementValueGetter != null) ? elementValueGetter().ToString() : elementStringValue);
				if (!xmlCharType.IsOnlyWhitespace(str))
				{
					ArrayList arrayList = context.ElementDecl.ContentValidator.ExpectedParticles(context, isRequiredOnly: false);
					if (arrayList == null || arrayList.Count == 0)
					{
						SendValidationEvent("Sch_InvalidTextInElement", BuildElementName(context.LocalName, context.Namespace));
						break;
					}
					SendValidationEvent("Sch_InvalidTextInElementExpecting", new string[2]
					{
						BuildElementName(context.LocalName, context.Namespace),
						PrintExpectedElements(arrayList, getParticles: true)
					});
				}
				break;
			}
			case XmlSchemaContentType.Mixed:
				if (context.ElementDecl.DefaultValueTyped != null)
				{
					if (elementValueGetter != null)
					{
						SaveTextValue(elementValueGetter());
					}
					else
					{
						SaveTextValue(elementStringValue);
					}
				}
				break;
			}
		}

		public void ValidateWhitespace(string elementValue)
		{
			if (elementValue == null)
			{
				throw new ArgumentNullException("elementValue");
			}
			ValidateWhitespace(elementValue, null);
		}

		public void ValidateWhitespace(XmlValueGetter elementValue)
		{
			if (elementValue == null)
			{
				throw new ArgumentNullException("elementValue");
			}
			ValidateWhitespace(null, elementValue);
		}

		private void ValidateWhitespace(string elementStringValue, XmlValueGetter elementValueGetter)
		{
			ValidatorState validatorState = ((validationStack.Length > 1) ? ValidatorState.Whitespace : ValidatorState.TopLevelTextOrWS);
			CheckStateTransition(validatorState, MethodNames[(int)validatorState]);
			if (!context.NeedValidateChildren)
			{
				return;
			}
			if (context.IsNill)
			{
				SendValidationEvent("Sch_ContentInNill", QNameString(context.LocalName, context.Namespace));
			}
			switch (context.ElementDecl.ContentValidator.ContentType)
			{
			case XmlSchemaContentType.Empty:
				SendValidationEvent("Sch_InvalidWhitespaceInEmpty", string.Empty);
				break;
			case XmlSchemaContentType.TextOnly:
				if (elementValueGetter != null)
				{
					SaveTextValue(elementValueGetter());
				}
				else
				{
					SaveTextValue(elementStringValue);
				}
				break;
			case XmlSchemaContentType.Mixed:
				if (context.ElementDecl.DefaultValueTyped != null)
				{
					if (elementValueGetter != null)
					{
						SaveTextValue(elementValueGetter());
					}
					else
					{
						SaveTextValue(elementStringValue);
					}
				}
				break;
			case XmlSchemaContentType.ElementOnly:
				break;
			}
		}

		public object ValidateEndElement(XmlSchemaInfo schemaInfo)
		{
			return InternalValidateEndElement(schemaInfo, null);
		}

		public object ValidateEndElement(XmlSchemaInfo schemaInfo, object typedValue)
		{
			if (typedValue == null)
			{
				throw new ArgumentNullException("typedValue");
			}
			if (textValue.Length > 0)
			{
				throw new InvalidOperationException(Res.GetString("Sch_InvalidEndElementCall"));
			}
			return InternalValidateEndElement(schemaInfo, typedValue);
		}

		public void SkipToEndElement(XmlSchemaInfo schemaInfo)
		{
			if (validationStack.Length <= 1)
			{
				throw new InvalidOperationException(Res.GetString("Sch_InvalidEndElementMultiple", MethodNames[10]));
			}
			CheckStateTransition(ValidatorState.SkipToEndElement, MethodNames[10]);
			if (schemaInfo != null)
			{
				SchemaElementDecl elementDecl = context.ElementDecl;
				if (elementDecl != null)
				{
					schemaInfo.SchemaType = elementDecl.SchemaType;
					schemaInfo.SchemaElement = GetSchemaElement();
				}
				else
				{
					schemaInfo.SchemaType = null;
					schemaInfo.SchemaElement = null;
				}
				schemaInfo.MemberType = null;
				schemaInfo.IsNil = context.IsNill;
				schemaInfo.IsDefault = context.IsDefault;
				schemaInfo.Validity = context.Validity;
			}
			context.ValidationSkipped = true;
			currentState = ValidatorState.SkipToEndElement;
			Pop();
		}

		public void EndValidation()
		{
			if (validationStack.Length > 1)
			{
				throw new InvalidOperationException(Res.GetString("Sch_InvalidEndValidation"));
			}
			CheckStateTransition(ValidatorState.Finish, MethodNames[11]);
			CheckForwardRefs();
		}

		public XmlSchemaParticle[] GetExpectedParticles()
		{
			if (currentState == ValidatorState.Start || currentState == ValidatorState.TopLevelTextOrWS)
			{
				if (partialValidationType != null)
				{
					if (partialValidationType is XmlSchemaElement xmlSchemaElement)
					{
						return new XmlSchemaParticle[1] { xmlSchemaElement };
					}
					return EmptyParticleArray;
				}
				ICollection values = schemaSet.GlobalElements.Values;
				XmlSchemaParticle[] array = new XmlSchemaParticle[values.Count];
				values.CopyTo(array, 0);
				return array;
			}
			if (context.ElementDecl != null)
			{
				ArrayList arrayList = context.ElementDecl.ContentValidator.ExpectedParticles(context, isRequiredOnly: false);
				if (arrayList != null)
				{
					return arrayList.ToArray(typeof(XmlSchemaParticle)) as XmlSchemaParticle[];
				}
			}
			return EmptyParticleArray;
		}

		public XmlSchemaAttribute[] GetExpectedAttributes()
		{
			if (currentState == ValidatorState.Element || currentState == ValidatorState.Attribute)
			{
				SchemaElementDecl elementDecl = context.ElementDecl;
				ArrayList arrayList = new ArrayList();
				if (elementDecl != null)
				{
					foreach (SchemaAttDef value in elementDecl.AttDefs.Values)
					{
						if (attPresence[value.Name] == null)
						{
							arrayList.Add(value.SchemaAttribute);
						}
					}
				}
				if (nsResolver.LookupPrefix(NsXsi) != null)
				{
					AddXsiAttributes(arrayList);
				}
				return arrayList.ToArray(typeof(XmlSchemaAttribute)) as XmlSchemaAttribute[];
			}
			if (currentState == ValidatorState.Start && partialValidationType != null && partialValidationType is XmlSchemaAttribute xmlSchemaAttribute)
			{
				return new XmlSchemaAttribute[1] { xmlSchemaAttribute };
			}
			return EmptyAttributeArray;
		}

		internal void GetUnspecifiedDefaultAttributes(ArrayList defaultAttributes, bool createNodeData)
		{
			currentState = ValidatorState.Attribute;
			SchemaElementDecl elementDecl = context.ElementDecl;
			if (elementDecl == null || !elementDecl.HasDefaultAttribute)
			{
				return;
			}
			SchemaAttDef[] defaultAttDefs = elementDecl.DefaultAttDefs;
			foreach (SchemaAttDef schemaAttDef in defaultAttDefs)
			{
				if (attPresence.Contains(schemaAttDef.Name) || schemaAttDef.DefaultValueTyped == null)
				{
					continue;
				}
				string text = nameTable.Add(schemaAttDef.Name.Namespace);
				string text2 = string.Empty;
				if (text.Length > 0)
				{
					text2 = GetDefaultAttributePrefix(text);
					if (text2 == null || text2.Length == 0)
					{
						SendValidationEvent("Sch_DefaultAttributeNotApplied", new string[2]
						{
							schemaAttDef.Name.ToString(),
							QNameString(context.LocalName, context.Namespace)
						});
						continue;
					}
				}
				XmlSchemaDatatype datatype = schemaAttDef.Datatype;
				if (createNodeData)
				{
					ValidatingReaderNodeData validatingReaderNodeData = new ValidatingReaderNodeData();
					validatingReaderNodeData.LocalName = nameTable.Add(schemaAttDef.Name.Name);
					validatingReaderNodeData.Namespace = text;
					validatingReaderNodeData.Prefix = nameTable.Add(text2);
					validatingReaderNodeData.NodeType = XmlNodeType.Attribute;
					AttributePSVIInfo attributePSVIInfo = new AttributePSVIInfo();
					XmlSchemaInfo attributeSchemaInfo = attributePSVIInfo.attributeSchemaInfo;
					if (schemaAttDef.Datatype.Variety == XmlSchemaDatatypeVariety.Union)
					{
						XsdSimpleValue xsdSimpleValue = schemaAttDef.DefaultValueTyped as XsdSimpleValue;
						attributeSchemaInfo.MemberType = xsdSimpleValue.XmlType;
						datatype = xsdSimpleValue.XmlType.Datatype;
						attributePSVIInfo.typedAttributeValue = xsdSimpleValue.TypedValue;
					}
					else
					{
						attributePSVIInfo.typedAttributeValue = schemaAttDef.DefaultValueTyped;
					}
					attributeSchemaInfo.IsDefault = true;
					attributeSchemaInfo.Validity = XmlSchemaValidity.Valid;
					attributeSchemaInfo.SchemaType = schemaAttDef.SchemaType;
					attributeSchemaInfo.SchemaAttribute = schemaAttDef.SchemaAttribute;
					validatingReaderNodeData.RawValue = attributeSchemaInfo.XmlType.ValueConverter.ToString(attributePSVIInfo.typedAttributeValue);
					validatingReaderNodeData.AttInfo = attributePSVIInfo;
					defaultAttributes.Add(validatingReaderNodeData);
				}
				else
				{
					defaultAttributes.Add(schemaAttDef.SchemaAttribute);
				}
				CheckTokenizedTypes(datatype, schemaAttDef.DefaultValueTyped, attrValue: true);
				if (HasIdentityConstraints)
				{
					AttributeIdentityConstraints(schemaAttDef.Name.Name, schemaAttDef.Name.Namespace, schemaAttDef.DefaultValueTyped, schemaAttDef.DefaultValueRaw, datatype);
				}
			}
		}

		internal void SetDtdSchemaInfo(SchemaInfo dtdSchemaInfo)
		{
			this.dtdSchemaInfo = dtdSchemaInfo;
			checkEntity = true;
		}

		internal string GetConcatenatedValue()
		{
			return textValue.ToString();
		}

		private object InternalValidateEndElement(XmlSchemaInfo schemaInfo, object typedValue)
		{
			if (validationStack.Length <= 1)
			{
				throw new InvalidOperationException(Res.GetString("Sch_InvalidEndElementMultiple", MethodNames[9]));
			}
			CheckStateTransition(ValidatorState.EndElement, MethodNames[9]);
			SchemaElementDecl elementDecl = context.ElementDecl;
			XmlSchemaSimpleType memberType = null;
			XmlSchemaType schemaType = null;
			XmlSchemaElement schemaElement = null;
			string text = string.Empty;
			if (elementDecl != null)
			{
				if (context.CheckRequiredAttribute && elementDecl.HasRequiredAttribute)
				{
					CheckRequiredAttributes(elementDecl);
				}
				if (!context.IsNill && context.NeedValidateChildren)
				{
					switch (elementDecl.ContentValidator.ContentType)
					{
					case XmlSchemaContentType.TextOnly:
						if (typedValue == null)
						{
							text = textValue.ToString();
							typedValue = ValidateAtomicValue(text, out memberType);
						}
						else
						{
							typedValue = ValidateAtomicValue(typedValue, out memberType);
						}
						break;
					case XmlSchemaContentType.Mixed:
						if (elementDecl.DefaultValueTyped != null && typedValue == null)
						{
							text = textValue.ToString();
							typedValue = CheckMixedValueConstraint(text);
						}
						break;
					case XmlSchemaContentType.ElementOnly:
						if (typedValue != null)
						{
							throw new InvalidOperationException(Res.GetString("Sch_InvalidEndElementCallTyped"));
						}
						break;
					}
					if (!elementDecl.ContentValidator.CompleteValidation(context))
					{
						CompleteValidationError(context, eventHandler, nsResolver, sourceUriString, positionInfo.LineNumber, positionInfo.LinePosition, getParticles: true);
						context.Validity = XmlSchemaValidity.Invalid;
					}
				}
				if (HasIdentityConstraints)
				{
					XmlSchemaType xmlSchemaType = ((memberType == null) ? elementDecl.SchemaType : memberType);
					EndElementIdentityConstraints(typedValue, text, xmlSchemaType.Datatype);
				}
				schemaType = elementDecl.SchemaType;
				schemaElement = GetSchemaElement();
			}
			if (schemaInfo != null)
			{
				schemaInfo.SchemaType = schemaType;
				schemaInfo.SchemaElement = schemaElement;
				schemaInfo.MemberType = memberType;
				schemaInfo.IsNil = context.IsNill;
				schemaInfo.IsDefault = context.IsDefault;
				if (context.Validity == XmlSchemaValidity.NotKnown && StrictlyAssessed)
				{
					context.Validity = XmlSchemaValidity.Valid;
				}
				schemaInfo.Validity = context.Validity;
			}
			Pop();
			return typedValue;
		}

		private void ProcessSchemaLocations(string xsiSchemaLocation, string xsiNoNamespaceSchemaLocation)
		{
			bool flag = false;
			if (xsiNoNamespaceSchemaLocation != null)
			{
				flag = true;
				LoadSchema(string.Empty, xsiNoNamespaceSchemaLocation);
			}
			if (xsiSchemaLocation != null)
			{
				object typedValue;
				Exception ex = dtStringArray.TryParseValue(xsiSchemaLocation, nameTable, nsResolver, out typedValue);
				if (ex != null)
				{
					SendValidationEvent(new XmlSchemaException("Sch_InvalidValueDetailed", new string[3] { xsiSchemaLocation, dtStringArray.TypeCodeString, ex.Message }, ex, null, 0, 0, null));
					return;
				}
				string[] array = (string[])typedValue;
				flag = true;
				try
				{
					for (int i = 0; i < array.Length - 1; i += 2)
					{
						LoadSchema(array[i], array[i + 1]);
					}
				}
				catch (XmlSchemaException e)
				{
					SendValidationEvent(e);
				}
			}
			if (flag)
			{
				RecompileSchemaSet();
			}
		}

		private object ValidateElementContext(XmlQualifiedName elementName, out bool invalidElementInContext)
		{
			object obj = null;
			int errorCode = 0;
			XmlSchemaElement xmlSchemaElement = null;
			invalidElementInContext = false;
			if (context.NeedValidateChildren)
			{
				if (context.IsNill)
				{
					SendValidationEvent("Sch_ContentInNill", QNameString(context.LocalName, context.Namespace));
					return null;
				}
				ContentValidator contentValidator = context.ElementDecl.ContentValidator;
				if (contentValidator.ContentType == XmlSchemaContentType.Mixed && context.ElementDecl.Presence == SchemaDeclBase.Use.Fixed)
				{
					SendValidationEvent("Sch_ElementInMixedWithFixed", QNameString(context.LocalName, context.Namespace));
					return null;
				}
				XmlQualifiedName xmlQualifiedName = elementName;
				bool flag = false;
				while (true)
				{
					obj = context.ElementDecl.ContentValidator.ValidateElement(xmlQualifiedName, context, out errorCode);
					if (obj != null)
					{
						break;
					}
					if (errorCode == -2)
					{
						SendValidationEvent("Sch_AllElement", elementName.ToString());
						invalidElementInContext = true;
						processContents = (context.ProcessContents = XmlSchemaContentProcessing.Skip);
						return null;
					}
					flag = true;
					xmlSchemaElement = GetSubstitutionGroupHead(xmlQualifiedName);
					if (xmlSchemaElement == null)
					{
						break;
					}
					xmlQualifiedName = xmlSchemaElement.QualifiedName;
				}
				if (flag)
				{
					if (!(obj is XmlSchemaElement xmlSchemaElement2))
					{
						obj = null;
					}
					else if (xmlSchemaElement2.RefName.IsEmpty)
					{
						SendValidationEvent("Sch_InvalidElementSubstitution", BuildElementName(elementName), BuildElementName(xmlSchemaElement2.QualifiedName));
						invalidElementInContext = true;
						processContents = (context.ProcessContents = XmlSchemaContentProcessing.Skip);
					}
					else
					{
						obj = compiledSchemaInfo.GetElement(elementName);
						context.NeedValidateChildren = true;
					}
				}
				if (obj == null)
				{
					ElementValidationError(elementName, context, eventHandler, nsResolver, sourceUriString, positionInfo.LineNumber, positionInfo.LinePosition, getParticles: true);
					invalidElementInContext = true;
					processContents = (context.ProcessContents = XmlSchemaContentProcessing.Skip);
				}
			}
			return obj;
		}

		private XmlSchemaElement GetSubstitutionGroupHead(XmlQualifiedName member)
		{
			XmlSchemaElement element = compiledSchemaInfo.GetElement(member);
			if (element != null)
			{
				XmlQualifiedName substitutionGroup = element.SubstitutionGroup;
				if (!substitutionGroup.IsEmpty)
				{
					XmlSchemaElement element2 = compiledSchemaInfo.GetElement(substitutionGroup);
					if (element2 != null)
					{
						if ((element2.BlockResolved & XmlSchemaDerivationMethod.Substitution) != 0)
						{
							SendValidationEvent("Sch_SubstitutionNotAllowed", new string[2]
							{
								member.ToString(),
								substitutionGroup.ToString()
							});
							return null;
						}
						if (!XmlSchemaType.IsDerivedFrom(element.ElementSchemaType, element2.ElementSchemaType, element2.BlockResolved))
						{
							SendValidationEvent("Sch_SubstitutionBlocked", new string[2]
							{
								member.ToString(),
								substitutionGroup.ToString()
							});
							return null;
						}
						return element2;
					}
				}
			}
			return null;
		}

		private object ValidateAtomicValue(string stringValue, out XmlSchemaSimpleType memberType)
		{
			object typedValue = null;
			memberType = null;
			SchemaElementDecl elementDecl = context.ElementDecl;
			if (!context.IsNill)
			{
				if (stringValue.Length == 0 && elementDecl.DefaultValueTyped != null)
				{
					SchemaElementDecl elementDeclBeforeXsi = context.ElementDeclBeforeXsi;
					if (elementDeclBeforeXsi != null && elementDeclBeforeXsi != elementDecl)
					{
						Exception ex = elementDecl.Datatype.TryParseValue(elementDecl.DefaultValueRaw, nameTable, nsResolver, out typedValue);
						if (ex != null)
						{
							SendValidationEvent("Sch_InvalidElementDefaultValue", new string[2]
							{
								elementDecl.DefaultValueRaw,
								QNameString(context.LocalName, context.Namespace)
							});
						}
						else
						{
							context.IsDefault = true;
						}
					}
					else
					{
						context.IsDefault = true;
						typedValue = elementDecl.DefaultValueTyped;
					}
				}
				else
				{
					typedValue = CheckElementValue(stringValue);
				}
				XsdSimpleValue xsdSimpleValue = typedValue as XsdSimpleValue;
				XmlSchemaDatatype datatype = elementDecl.Datatype;
				if (xsdSimpleValue != null)
				{
					memberType = xsdSimpleValue.XmlType;
					typedValue = xsdSimpleValue.TypedValue;
					datatype = memberType.Datatype;
				}
				CheckTokenizedTypes(datatype, typedValue, attrValue: false);
			}
			return typedValue;
		}

		private object ValidateAtomicValue(object parsedValue, out XmlSchemaSimpleType memberType)
		{
			memberType = null;
			SchemaElementDecl elementDecl = context.ElementDecl;
			object typedValue = null;
			if (!context.IsNill)
			{
				SchemaDeclBase schemaDeclBase = elementDecl;
				XmlSchemaDatatype datatype = elementDecl.Datatype;
				Exception ex = datatype.TryParseValue(parsedValue, nameTable, nsResolver, out typedValue);
				if (ex != null)
				{
					string text = parsedValue as string;
					if (text == null)
					{
						text = XmlSchemaDatatype.ConcatenatedToString(parsedValue);
					}
					SendValidationEvent("Sch_ElementValueDataTypeDetailed", new string[4]
					{
						QNameString(context.LocalName, context.Namespace),
						text,
						GetTypeName(schemaDeclBase),
						ex.Message
					}, ex);
					return null;
				}
				if (!schemaDeclBase.CheckValue(typedValue))
				{
					SendValidationEvent("Sch_FixedElementValue", QNameString(context.LocalName, context.Namespace));
				}
				if (datatype.Variety == XmlSchemaDatatypeVariety.Union)
				{
					XsdSimpleValue xsdSimpleValue = typedValue as XsdSimpleValue;
					memberType = xsdSimpleValue.XmlType;
					typedValue = xsdSimpleValue.TypedValue;
					datatype = memberType.Datatype;
				}
				CheckTokenizedTypes(datatype, typedValue, attrValue: false);
			}
			return typedValue;
		}

		private string GetTypeName(SchemaDeclBase decl)
		{
			string text = decl.SchemaType.QualifiedName.ToString();
			if (text.Length == 0)
			{
				text = decl.Datatype.TypeCodeString;
			}
			return text;
		}

		private void SaveTextValue(object value)
		{
			string value2 = value.ToString();
			textValue.Append(value2);
		}

		private void Push(XmlQualifiedName elementName)
		{
			context = (ValidationState)validationStack.Push();
			if (context == null)
			{
				context = new ValidationState();
				validationStack.AddToTop(context);
			}
			context.LocalName = elementName.Name;
			context.Namespace = elementName.Namespace;
			context.HasMatched = false;
			context.IsNill = false;
			context.IsDefault = false;
			context.CheckRequiredAttribute = true;
			context.ValidationSkipped = false;
			context.Validity = XmlSchemaValidity.NotKnown;
			context.NeedValidateChildren = false;
			context.ProcessContents = processContents;
			context.ElementDeclBeforeXsi = null;
			context.Constr = null;
		}

		private void Pop()
		{
			ValidationState validationState = (ValidationState)validationStack.Pop();
			if (startIDConstraint == validationStack.Length)
			{
				startIDConstraint = -1;
			}
			context = (ValidationState)validationStack.Peek();
			if (validationState.Validity == XmlSchemaValidity.Invalid)
			{
				context.Validity = XmlSchemaValidity.Invalid;
			}
			if (validationState.ValidationSkipped)
			{
				context.ValidationSkipped = true;
			}
			processContents = context.ProcessContents;
		}

		private void AddXsiAttributes(ArrayList attList)
		{
			BuildXsiAttributes();
			if (attPresence[xsiTypeSO.QualifiedName] == null)
			{
				attList.Add(xsiTypeSO);
			}
			if (attPresence[xsiNilSO.QualifiedName] == null)
			{
				attList.Add(xsiNilSO);
			}
			if (attPresence[xsiSLSO.QualifiedName] == null)
			{
				attList.Add(xsiSLSO);
			}
			if (attPresence[xsiNoNsSLSO.QualifiedName] == null)
			{
				attList.Add(xsiNoNsSLSO);
			}
		}

		private SchemaElementDecl FastGetElementDecl(XmlQualifiedName elementName, object particle)
		{
			SchemaElementDecl schemaElementDecl = null;
			if (particle != null)
			{
				if (particle is XmlSchemaElement xmlSchemaElement)
				{
					schemaElementDecl = xmlSchemaElement.ElementDecl;
				}
				else
				{
					XmlSchemaAny xmlSchemaAny = (XmlSchemaAny)particle;
					processContents = xmlSchemaAny.ProcessContentsCorrect;
				}
			}
			if (schemaElementDecl == null && processContents != XmlSchemaContentProcessing.Skip)
			{
				if (isRoot && partialValidationType != null)
				{
					if (partialValidationType is XmlSchemaElement)
					{
						XmlSchemaElement xmlSchemaElement2 = (XmlSchemaElement)partialValidationType;
						if (elementName.Equals(xmlSchemaElement2.QualifiedName))
						{
							schemaElementDecl = xmlSchemaElement2.ElementDecl;
						}
						else
						{
							SendValidationEvent("Sch_SchemaElementNameMismatch", elementName.ToString(), xmlSchemaElement2.QualifiedName.ToString());
						}
					}
					else if (partialValidationType is XmlSchemaType)
					{
						XmlSchemaType xmlSchemaType = (XmlSchemaType)partialValidationType;
						schemaElementDecl = xmlSchemaType.ElementDecl;
					}
					else
					{
						SendValidationEvent("Sch_ValidateElementInvalidCall", string.Empty);
					}
				}
				else
				{
					schemaElementDecl = compiledSchemaInfo.GetElementDecl(elementName);
				}
			}
			return schemaElementDecl;
		}

		private SchemaElementDecl CheckXsiTypeAndNil(SchemaElementDecl elementDecl, string xsiType, string xsiNil, ref bool declFound)
		{
			XmlQualifiedName xmlQualifiedName = XmlQualifiedName.Empty;
			if (xsiType != null)
			{
				object typedValue = null;
				Exception ex = dtQName.TryParseValue(xsiType, nameTable, nsResolver, out typedValue);
				if (ex != null)
				{
					SendValidationEvent(new XmlSchemaException("Sch_InvalidValueDetailed", new string[3] { xsiType, dtQName.TypeCodeString, ex.Message }, ex, null, 0, 0, null));
				}
				else
				{
					xmlQualifiedName = typedValue as XmlQualifiedName;
				}
			}
			if (elementDecl != null)
			{
				if (elementDecl.IsNillable)
				{
					if (xsiNil != null)
					{
						context.IsNill = XmlConvert.ToBoolean(xsiNil);
						if (context.IsNill && elementDecl.Presence == SchemaDeclBase.Use.Fixed)
						{
							SendValidationEvent("Sch_XsiNilAndFixed");
						}
					}
				}
				else if (xsiNil != null)
				{
					SendValidationEvent("Sch_InvalidXsiNill");
				}
			}
			if (xmlQualifiedName.IsEmpty)
			{
				if (elementDecl != null && elementDecl.IsAbstract)
				{
					SendValidationEvent("Sch_AbstractElement", QNameString(context.LocalName, context.Namespace));
					elementDecl = null;
				}
			}
			else
			{
				SchemaElementDecl schemaElementDecl = compiledSchemaInfo.GetTypeDecl(xmlQualifiedName);
				XmlSeverityType severity = XmlSeverityType.Warning;
				if (HasSchema && processContents == XmlSchemaContentProcessing.Strict)
				{
					severity = XmlSeverityType.Error;
				}
				if (schemaElementDecl == null && xmlQualifiedName.Namespace == NsXs)
				{
					XmlSchemaType xmlSchemaType = DatatypeImplementation.GetSimpleTypeFromXsdType(xmlQualifiedName);
					if (xmlSchemaType == null)
					{
						xmlSchemaType = XmlSchemaType.GetBuiltInComplexType(xmlQualifiedName);
					}
					if (xmlSchemaType != null)
					{
						schemaElementDecl = xmlSchemaType.ElementDecl;
					}
				}
				if (schemaElementDecl == null)
				{
					SendValidationEvent("Sch_XsiTypeNotFound", xmlQualifiedName.ToString(), severity);
					elementDecl = null;
				}
				else
				{
					declFound = true;
					if (schemaElementDecl.IsAbstract)
					{
						SendValidationEvent("Sch_XsiTypeAbstract", xmlQualifiedName.ToString(), severity);
						elementDecl = null;
					}
					else if (elementDecl != null && !XmlSchemaType.IsDerivedFrom(schemaElementDecl.SchemaType, elementDecl.SchemaType, elementDecl.Block))
					{
						SendValidationEvent("Sch_XsiTypeBlockedEx", new string[2]
						{
							xmlQualifiedName.ToString(),
							QNameString(context.LocalName, context.Namespace)
						});
						elementDecl = null;
					}
					else
					{
						if (elementDecl != null)
						{
							schemaElementDecl = schemaElementDecl.Clone();
							schemaElementDecl.Constraints = elementDecl.Constraints;
							schemaElementDecl.DefaultValueRaw = elementDecl.DefaultValueRaw;
							schemaElementDecl.DefaultValueTyped = elementDecl.DefaultValueTyped;
							schemaElementDecl.Block = elementDecl.Block;
						}
						context.ElementDeclBeforeXsi = elementDecl;
						elementDecl = schemaElementDecl;
					}
				}
			}
			return elementDecl;
		}

		private void ThrowDeclNotFoundWarningOrError(bool declFound)
		{
			if (declFound)
			{
				processContents = (context.ProcessContents = XmlSchemaContentProcessing.Skip);
				context.NeedValidateChildren = false;
			}
			else if (HasSchema && processContents == XmlSchemaContentProcessing.Strict)
			{
				processContents = (context.ProcessContents = XmlSchemaContentProcessing.Skip);
				context.NeedValidateChildren = false;
				SendValidationEvent("Sch_UndeclaredElement", QNameString(context.LocalName, context.Namespace));
			}
			else
			{
				SendValidationEvent("Sch_NoElementSchemaFound", QNameString(context.LocalName, context.Namespace), XmlSeverityType.Warning);
			}
		}

		private void CheckElementProperties()
		{
			if (context.ElementDecl.IsAbstract)
			{
				SendValidationEvent("Sch_AbstractElement", QNameString(context.LocalName, context.Namespace));
			}
		}

		private void ValidateStartElementIdentityConstraints()
		{
			if (ProcessIdentityConstraints && context.ElementDecl.Constraints != null)
			{
				AddIdentityConstraints();
			}
			if (HasIdentityConstraints)
			{
				ElementIdentityConstraints();
			}
		}

		private SchemaAttDef CheckIsXmlAttribute(XmlQualifiedName attQName)
		{
			SchemaAttDef result = null;
			if (Ref.Equal(attQName.Namespace, NsXml) && (validationFlags & XmlSchemaValidationFlags.AllowXmlAttributes) != 0)
			{
				if (!compiledSchemaInfo.Contains(NsXml))
				{
					AddXmlNamespaceSchema();
				}
				result = (SchemaAttDef)compiledSchemaInfo.AttributeDecls[attQName];
			}
			return result;
		}

		private void AddXmlNamespaceSchema()
		{
			XmlSchemaSet xmlSchemaSet = new XmlSchemaSet();
			xmlSchemaSet.Add(Preprocessor.GetBuildInSchema());
			xmlSchemaSet.Compile();
			schemaSet.Add(xmlSchemaSet);
			RecompileSchemaSet();
		}

		internal object CheckMixedValueConstraint(string elementValue)
		{
			SchemaElementDecl elementDecl = context.ElementDecl;
			if (context.IsNill)
			{
				return null;
			}
			if (elementValue.Length == 0)
			{
				context.IsDefault = true;
				return elementDecl.DefaultValueTyped;
			}
			SchemaDeclBase schemaDeclBase = elementDecl;
			if (schemaDeclBase.Presence == SchemaDeclBase.Use.Fixed && !elementValue.Equals(elementDecl.DefaultValueRaw))
			{
				SendValidationEvent("Sch_FixedElementValue", elementDecl.Name.ToString());
			}
			return elementValue;
		}

		private void LoadSchema(string uri, string url)
		{
			XmlReader xmlReader = null;
			try
			{
				Uri uri2 = xmlResolver.ResolveUri(sourceUri, url);
				Stream input = (Stream)xmlResolver.GetEntity(uri2, null, null);
				XmlReaderSettings readerSettings = schemaSet.ReaderSettings;
				readerSettings.CloseInput = true;
				readerSettings.XmlResolver = xmlResolver;
				xmlReader = XmlReader.Create(input, readerSettings, uri2.ToString());
				schemaSet.Add(uri, xmlReader, validatedNamespaces);
				while (xmlReader.Read())
				{
				}
			}
			catch (XmlSchemaException ex)
			{
				SendValidationEvent("Sch_CannotLoadSchema", new string[2] { uri, ex.Message }, ex);
			}
			catch (Exception ex2)
			{
				SendValidationEvent("Sch_CannotLoadSchema", new string[2] { uri, ex2.Message }, ex2, XmlSeverityType.Warning);
			}
			finally
			{
				xmlReader?.Close();
			}
		}

		internal void RecompileSchemaSet()
		{
			if (!schemaSet.IsCompiled)
			{
				try
				{
					schemaSet.Compile();
				}
				catch (XmlSchemaException e)
				{
					SendValidationEvent(e);
				}
			}
			compiledSchemaInfo = schemaSet.CompiledInfo;
		}

		private void ProcessTokenizedType(XmlTokenizedType ttype, string name, bool attrValue)
		{
			switch (ttype)
			{
			case XmlTokenizedType.ID:
				if (!ProcessIdentityConstraints)
				{
					break;
				}
				if (FindId(name) != null)
				{
					if (attrValue)
					{
						attrValid = false;
					}
					SendValidationEvent("Sch_DupId", name);
				}
				else
				{
					if (IDs == null)
					{
						IDs = new Hashtable();
					}
					IDs.Add(name, context.LocalName);
				}
				break;
			case XmlTokenizedType.IDREF:
				if (ProcessIdentityConstraints)
				{
					object obj = FindId(name);
					if (obj == null)
					{
						idRefListHead = new IdRefNode(idRefListHead, name, positionInfo.LineNumber, positionInfo.LinePosition);
					}
				}
				break;
			case XmlTokenizedType.ENTITY:
				ProcessEntity(name);
				break;
			case XmlTokenizedType.IDREFS:
				break;
			}
		}

		private object CheckAttributeValue(object value, SchemaAttDef attdef)
		{
			object typedValue = null;
			XmlSchemaDatatype datatype = attdef.Datatype;
			string text = value as string;
			Exception ex = null;
			if (text != null)
			{
				ex = datatype.TryParseValue(text, nameTable, nsResolver, out typedValue);
				if (ex == null)
				{
					goto IL_0050;
				}
			}
			else
			{
				ex = datatype.TryParseValue(value, nameTable, nsResolver, out typedValue);
				if (ex == null)
				{
					goto IL_0050;
				}
			}
			attrValid = false;
			if (text == null)
			{
				text = XmlSchemaDatatype.ConcatenatedToString(value);
			}
			SendValidationEvent("Sch_AttributeValueDataTypeDetailed", new string[4]
			{
				attdef.Name.ToString(),
				text,
				GetTypeName(attdef),
				ex.Message
			}, ex);
			return null;
			IL_0050:
			if (!attdef.CheckValue(typedValue))
			{
				attrValid = false;
				SendValidationEvent("Sch_FixedAttributeValue", attdef.Name.ToString());
			}
			return typedValue;
		}

		private object CheckElementValue(string stringValue)
		{
			object typedValue = null;
			SchemaDeclBase elementDecl = context.ElementDecl;
			XmlSchemaDatatype datatype = elementDecl.Datatype;
			Exception ex = datatype.TryParseValue(stringValue, nameTable, nsResolver, out typedValue);
			if (ex != null)
			{
				SendValidationEvent("Sch_ElementValueDataTypeDetailed", new string[4]
				{
					QNameString(context.LocalName, context.Namespace),
					stringValue,
					GetTypeName(elementDecl),
					ex.Message
				}, ex);
				return null;
			}
			if (!elementDecl.CheckValue(typedValue))
			{
				SendValidationEvent("Sch_FixedElementValue", QNameString(context.LocalName, context.Namespace));
			}
			return typedValue;
		}

		private void CheckTokenizedTypes(XmlSchemaDatatype dtype, object typedValue, bool attrValue)
		{
			if (typedValue == null)
			{
				return;
			}
			XmlTokenizedType tokenizedType = dtype.TokenizedType;
			if (tokenizedType != XmlTokenizedType.ENTITY && tokenizedType != XmlTokenizedType.ID && tokenizedType != XmlTokenizedType.IDREF)
			{
				return;
			}
			if (dtype.Variety == XmlSchemaDatatypeVariety.List)
			{
				string[] array = (string[])typedValue;
				string[] array2 = array;
				foreach (string name in array2)
				{
					ProcessTokenizedType(dtype.TokenizedType, name, attrValue);
				}
			}
			else
			{
				ProcessTokenizedType(dtype.TokenizedType, (string)typedValue, attrValue);
			}
		}

		private object FindId(string name)
		{
			if (IDs != null)
			{
				return IDs[name];
			}
			return null;
		}

		private void CheckForwardRefs()
		{
			IdRefNode idRefNode = idRefListHead;
			while (idRefNode != null)
			{
				if (FindId(idRefNode.Id) == null)
				{
					SendValidationEvent(new XmlSchemaValidationException("Sch_UndeclaredId", idRefNode.Id, sourceUriString, idRefNode.LineNo, idRefNode.LinePos), XmlSeverityType.Error);
				}
				IdRefNode next = idRefNode.Next;
				idRefNode.Next = null;
				idRefNode = next;
			}
			idRefListHead = null;
		}

		private void CheckStateTransition(ValidatorState toState, string methodName)
		{
			if (!ValidStates[(int)currentState, (int)toState])
			{
				if (currentState == ValidatorState.None)
				{
					throw new InvalidOperationException(Res.GetString("Sch_InvalidStartTransition", methodName, MethodNames[1]));
				}
				throw new InvalidOperationException(Res.GetString("Sch_InvalidStateTransition", MethodNames[(int)currentState], methodName));
			}
			currentState = toState;
		}

		private void ClearPSVI()
		{
			if (textValue != null)
			{
				textValue.Length = 0;
			}
			attPresence.Clear();
			wildID = null;
		}

		private void CheckRequiredAttributes(SchemaElementDecl currentElementDecl)
		{
			Hashtable attDefs = currentElementDecl.AttDefs;
			foreach (SchemaAttDef value in attDefs.Values)
			{
				if (attPresence[value.Name] == null && (value.Presence == SchemaDeclBase.Use.Required || value.Presence == SchemaDeclBase.Use.RequiredFixed))
				{
					SendValidationEvent("Sch_MissRequiredAttribute", value.Name.ToString());
				}
			}
		}

		private XmlSchemaElement GetSchemaElement()
		{
			SchemaElementDecl elementDeclBeforeXsi = context.ElementDeclBeforeXsi;
			SchemaElementDecl elementDecl = context.ElementDecl;
			if (elementDeclBeforeXsi != null && elementDeclBeforeXsi.SchemaElement != null)
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)elementDeclBeforeXsi.SchemaElement.Clone();
				xmlSchemaElement.SchemaTypeName = XmlQualifiedName.Empty;
				xmlSchemaElement.SchemaType = elementDecl.SchemaType;
				xmlSchemaElement.SetElementType(elementDecl.SchemaType);
				xmlSchemaElement.ElementDecl = elementDecl;
				return xmlSchemaElement;
			}
			return elementDecl.SchemaElement;
		}

		internal string GetDefaultAttributePrefix(string attributeNS)
		{
			IDictionary<string, string> namespacesInScope = nsResolver.GetNamespacesInScope(XmlNamespaceScope.All);
			string text = null;
			foreach (KeyValuePair<string, string> item in namespacesInScope)
			{
				string strA = nameTable.Add(item.Value);
				if (Ref.Equal(strA, attributeNS))
				{
					text = item.Key;
					if (text.Length != 0)
					{
						return text;
					}
				}
			}
			return text;
		}

		private void AddIdentityConstraints()
		{
			SchemaElementDecl elementDecl = context.ElementDecl;
			context.Constr = new ConstraintStruct[elementDecl.Constraints.Length];
			int num = 0;
			CompiledIdentityConstraint[] constraints = elementDecl.Constraints;
			foreach (CompiledIdentityConstraint constraint in constraints)
			{
				context.Constr[num++] = new ConstraintStruct(constraint);
			}
			ConstraintStruct[] constr = context.Constr;
			foreach (ConstraintStruct constraintStruct in constr)
			{
				if (constraintStruct.constraint.Role != CompiledIdentityConstraint.ConstraintRole.Keyref)
				{
					continue;
				}
				bool flag = false;
				for (int num2 = validationStack.Length - 1; num2 >= ((startIDConstraint >= 0) ? startIDConstraint : (validationStack.Length - 1)); num2--)
				{
					if (((ValidationState)validationStack[num2]).Constr != null)
					{
						ConstraintStruct[] constr2 = ((ValidationState)validationStack[num2]).Constr;
						foreach (ConstraintStruct constraintStruct2 in constr2)
						{
							if (constraintStruct2.constraint.name == constraintStruct.constraint.refer)
							{
								flag = true;
								if (constraintStruct2.keyrefTable == null)
								{
									constraintStruct2.keyrefTable = new Hashtable();
								}
								constraintStruct.qualifiedTable = constraintStruct2.keyrefTable;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
				}
				if (!flag)
				{
					SendValidationEvent("Sch_RefNotInScope", QNameString(context.LocalName, context.Namespace));
				}
			}
			if (startIDConstraint == -1)
			{
				startIDConstraint = validationStack.Length - 1;
			}
		}

		private void ElementIdentityConstraints()
		{
			SchemaElementDecl elementDecl = context.ElementDecl;
			string localName = context.LocalName;
			string @namespace = context.Namespace;
			for (int i = startIDConstraint; i < validationStack.Length; i++)
			{
				if (((ValidationState)validationStack[i]).Constr == null)
				{
					continue;
				}
				ConstraintStruct[] constr = ((ValidationState)validationStack[i]).Constr;
				foreach (ConstraintStruct constraintStruct in constr)
				{
					if (constraintStruct.axisSelector.MoveToStartElement(localName, @namespace))
					{
						constraintStruct.axisSelector.PushKS(positionInfo.LineNumber, positionInfo.LinePosition);
					}
					foreach (LocatedActiveAxis axisField in constraintStruct.axisFields)
					{
						if (axisField.MoveToStartElement(localName, @namespace) && elementDecl != null)
						{
							if (elementDecl.Datatype == null || elementDecl.ContentValidator.ContentType == XmlSchemaContentType.Mixed)
							{
								SendValidationEvent("Sch_FieldSimpleTypeExpected", localName);
							}
							else
							{
								axisField.isMatched = true;
							}
						}
					}
				}
			}
		}

		private void AttributeIdentityConstraints(string name, string ns, object obj, string sobj, XmlSchemaDatatype datatype)
		{
			for (int i = startIDConstraint; i < validationStack.Length; i++)
			{
				if (((ValidationState)validationStack[i]).Constr == null)
				{
					continue;
				}
				ConstraintStruct[] constr = ((ValidationState)validationStack[i]).Constr;
				foreach (ConstraintStruct constraintStruct in constr)
				{
					foreach (LocatedActiveAxis axisField in constraintStruct.axisFields)
					{
						if (axisField.MoveToAttribute(name, ns))
						{
							if (axisField.Ks[axisField.Column] != null)
							{
								SendValidationEvent("Sch_FieldSingleValueExpected", name);
							}
							else
							{
								axisField.Ks[axisField.Column] = new TypedObject(obj, sobj, datatype);
							}
						}
					}
				}
			}
		}

		private void EndElementIdentityConstraints(object typedValue, string stringValue, XmlSchemaDatatype datatype)
		{
			string localName = context.LocalName;
			string @namespace = context.Namespace;
			for (int num = validationStack.Length - 1; num >= startIDConstraint; num--)
			{
				if (((ValidationState)validationStack[num]).Constr != null)
				{
					ConstraintStruct[] constr = ((ValidationState)validationStack[num]).Constr;
					foreach (ConstraintStruct constraintStruct in constr)
					{
						foreach (LocatedActiveAxis axisField in constraintStruct.axisFields)
						{
							if (axisField.isMatched)
							{
								axisField.isMatched = false;
								if (axisField.Ks[axisField.Column] != null)
								{
									SendValidationEvent("Sch_FieldSingleValueExpected", localName);
								}
								else if (typedValue != null && stringValue.Length != 0)
								{
									axisField.Ks[axisField.Column] = new TypedObject(typedValue, stringValue, datatype);
								}
							}
							axisField.EndElement(localName, @namespace);
						}
						if (!constraintStruct.axisSelector.EndElement(localName, @namespace))
						{
							continue;
						}
						KeySequence keySequence = constraintStruct.axisSelector.PopKS();
						switch (constraintStruct.constraint.Role)
						{
						case CompiledIdentityConstraint.ConstraintRole.Key:
							if (!keySequence.IsQualified())
							{
								SendValidationEvent(new XmlSchemaValidationException("Sch_MissingKey", constraintStruct.constraint.name.ToString(), sourceUriString, keySequence.PosLine, keySequence.PosCol));
							}
							else if (constraintStruct.qualifiedTable.Contains(keySequence))
							{
								SendValidationEvent(new XmlSchemaValidationException("Sch_DuplicateKey", new string[2]
								{
									keySequence.ToString(),
									constraintStruct.constraint.name.ToString()
								}, sourceUriString, keySequence.PosLine, keySequence.PosCol));
							}
							else
							{
								constraintStruct.qualifiedTable.Add(keySequence, keySequence);
							}
							break;
						case CompiledIdentityConstraint.ConstraintRole.Unique:
							if (keySequence.IsQualified())
							{
								if (constraintStruct.qualifiedTable.Contains(keySequence))
								{
									SendValidationEvent(new XmlSchemaValidationException("Sch_DuplicateKey", new string[2]
									{
										keySequence.ToString(),
										constraintStruct.constraint.name.ToString()
									}, sourceUriString, keySequence.PosLine, keySequence.PosCol));
								}
								else
								{
									constraintStruct.qualifiedTable.Add(keySequence, keySequence);
								}
							}
							break;
						case CompiledIdentityConstraint.ConstraintRole.Keyref:
							if (constraintStruct.qualifiedTable != null && keySequence.IsQualified() && !constraintStruct.qualifiedTable.Contains(keySequence))
							{
								constraintStruct.qualifiedTable.Add(keySequence, keySequence);
							}
							break;
						}
					}
				}
			}
			ConstraintStruct[] constr2 = ((ValidationState)validationStack[validationStack.Length - 1]).Constr;
			if (constr2 == null)
			{
				return;
			}
			ConstraintStruct[] array = constr2;
			foreach (ConstraintStruct constraintStruct2 in array)
			{
				if (constraintStruct2.constraint.Role == CompiledIdentityConstraint.ConstraintRole.Keyref || constraintStruct2.keyrefTable == null)
				{
					continue;
				}
				foreach (KeySequence key in constraintStruct2.keyrefTable.Keys)
				{
					if (!constraintStruct2.qualifiedTable.Contains(key))
					{
						SendValidationEvent(new XmlSchemaValidationException("Sch_UnresolvedKeyref", key.ToString(), sourceUriString, key.PosLine, key.PosCol));
					}
				}
			}
		}

		private static void BuildXsiAttributes()
		{
			if (xsiTypeSO == null)
			{
				XmlSchemaAttribute xmlSchemaAttribute = new XmlSchemaAttribute();
				xmlSchemaAttribute.Name = "type";
				xmlSchemaAttribute.SetQualifiedName(new XmlQualifiedName("type", "http://www.w3.org/2001/XMLSchema-instance"));
				xmlSchemaAttribute.SetAttributeType(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.QName));
				Interlocked.CompareExchange(ref xsiTypeSO, xmlSchemaAttribute, null);
			}
			if (xsiNilSO == null)
			{
				XmlSchemaAttribute xmlSchemaAttribute2 = new XmlSchemaAttribute();
				xmlSchemaAttribute2.Name = "nil";
				xmlSchemaAttribute2.SetQualifiedName(new XmlQualifiedName("nil", "http://www.w3.org/2001/XMLSchema-instance"));
				xmlSchemaAttribute2.SetAttributeType(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean));
				Interlocked.CompareExchange(ref xsiNilSO, xmlSchemaAttribute2, null);
			}
			if (xsiSLSO == null)
			{
				XmlSchemaSimpleType builtInSimpleType = XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String);
				XmlSchemaAttribute xmlSchemaAttribute3 = new XmlSchemaAttribute();
				xmlSchemaAttribute3.Name = "schemaLocation";
				xmlSchemaAttribute3.SetQualifiedName(new XmlQualifiedName("schemaLocation", "http://www.w3.org/2001/XMLSchema-instance"));
				xmlSchemaAttribute3.SetAttributeType(builtInSimpleType);
				Interlocked.CompareExchange(ref xsiSLSO, xmlSchemaAttribute3, null);
			}
			if (xsiNoNsSLSO == null)
			{
				XmlSchemaSimpleType builtInSimpleType2 = XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String);
				XmlSchemaAttribute xmlSchemaAttribute4 = new XmlSchemaAttribute();
				xmlSchemaAttribute4.Name = "noNamespaceSchemaLocation";
				xmlSchemaAttribute4.SetQualifiedName(new XmlQualifiedName("noNamespaceSchemaLocation", "http://www.w3.org/2001/XMLSchema-instance"));
				xmlSchemaAttribute4.SetAttributeType(builtInSimpleType2);
				Interlocked.CompareExchange(ref xsiNoNsSLSO, xmlSchemaAttribute4, null);
			}
		}

		internal static void ElementValidationError(XmlQualifiedName name, ValidationState context, ValidationEventHandler eventHandler, object sender, string sourceUri, int lineNo, int linePos, bool getParticles)
		{
			ArrayList arrayList = null;
			if (context.ElementDecl == null)
			{
				return;
			}
			ContentValidator contentValidator = context.ElementDecl.ContentValidator;
			XmlSchemaContentType contentType = contentValidator.ContentType;
			if (contentType == XmlSchemaContentType.ElementOnly || (contentType == XmlSchemaContentType.Mixed && contentValidator != ContentValidator.Mixed && contentValidator != ContentValidator.Any))
			{
				arrayList = ((!getParticles) ? contentValidator.ExpectedElements(context, isRequiredOnly: false) : contentValidator.ExpectedParticles(context, isRequiredOnly: false));
				if (arrayList == null || arrayList.Count == 0)
				{
					if (context.TooComplex)
					{
						SendValidationEvent(eventHandler, sender, new XmlSchemaValidationException("Sch_InvalidElementContentComplex", new string[3]
						{
							BuildElementName(context.LocalName, context.Namespace),
							BuildElementName(name),
							Res.GetString("Sch_ComplexContentModel")
						}, sourceUri, lineNo, linePos), XmlSeverityType.Error);
					}
					else
					{
						SendValidationEvent(eventHandler, sender, new XmlSchemaValidationException("Sch_InvalidElementContent", new string[2]
						{
							BuildElementName(context.LocalName, context.Namespace),
							BuildElementName(name)
						}, sourceUri, lineNo, linePos), XmlSeverityType.Error);
					}
				}
				else if (context.TooComplex)
				{
					SendValidationEvent(eventHandler, sender, new XmlSchemaValidationException("Sch_InvalidElementContentExpectingComplex", new string[4]
					{
						BuildElementName(context.LocalName, context.Namespace),
						BuildElementName(name),
						PrintExpectedElements(arrayList, getParticles),
						Res.GetString("Sch_ComplexContentModel")
					}, sourceUri, lineNo, linePos), XmlSeverityType.Error);
				}
				else
				{
					SendValidationEvent(eventHandler, sender, new XmlSchemaValidationException("Sch_InvalidElementContentExpecting", new string[3]
					{
						BuildElementName(context.LocalName, context.Namespace),
						BuildElementName(name),
						PrintExpectedElements(arrayList, getParticles)
					}, sourceUri, lineNo, linePos), XmlSeverityType.Error);
				}
			}
			else if (contentType == XmlSchemaContentType.Empty)
			{
				SendValidationEvent(eventHandler, sender, new XmlSchemaValidationException("Sch_InvalidElementInEmptyEx", new string[2]
				{
					QNameString(context.LocalName, context.Namespace),
					name.ToString()
				}, sourceUri, lineNo, linePos), XmlSeverityType.Error);
			}
			else if (!contentValidator.IsOpen)
			{
				SendValidationEvent(eventHandler, sender, new XmlSchemaValidationException("Sch_InvalidElementInTextOnlyEx", new string[2]
				{
					QNameString(context.LocalName, context.Namespace),
					name.ToString()
				}, sourceUri, lineNo, linePos), XmlSeverityType.Error);
			}
		}

		internal static void CompleteValidationError(ValidationState context, ValidationEventHandler eventHandler, object sender, string sourceUri, int lineNo, int linePos, bool getParticles)
		{
			ArrayList arrayList = null;
			if (context.ElementDecl != null)
			{
				arrayList = ((!getParticles) ? context.ElementDecl.ContentValidator.ExpectedElements(context, isRequiredOnly: true) : context.ElementDecl.ContentValidator.ExpectedParticles(context, isRequiredOnly: true));
			}
			if (arrayList == null || arrayList.Count == 0)
			{
				if (context.TooComplex)
				{
					SendValidationEvent(eventHandler, sender, new XmlSchemaValidationException("Sch_IncompleteContentComplex", new string[2]
					{
						BuildElementName(context.LocalName, context.Namespace),
						Res.GetString("Sch_ComplexContentModel")
					}, sourceUri, lineNo, linePos), XmlSeverityType.Error);
				}
				SendValidationEvent(eventHandler, sender, new XmlSchemaValidationException("Sch_IncompleteContent", BuildElementName(context.LocalName, context.Namespace), sourceUri, lineNo, linePos), XmlSeverityType.Error);
			}
			else if (context.TooComplex)
			{
				SendValidationEvent(eventHandler, sender, new XmlSchemaValidationException("Sch_IncompleteContentExpectingComplex", new string[3]
				{
					BuildElementName(context.LocalName, context.Namespace),
					PrintExpectedElements(arrayList, getParticles),
					Res.GetString("Sch_ComplexContentModel")
				}, sourceUri, lineNo, linePos), XmlSeverityType.Error);
			}
			else
			{
				SendValidationEvent(eventHandler, sender, new XmlSchemaValidationException("Sch_IncompleteContentExpecting", new string[2]
				{
					BuildElementName(context.LocalName, context.Namespace),
					PrintExpectedElements(arrayList, getParticles)
				}, sourceUri, lineNo, linePos), XmlSeverityType.Error);
			}
		}

		internal static string PrintExpectedElements(ArrayList expected, bool getParticles)
		{
			if (getParticles)
			{
				string @string = Res.GetString("Sch_ContinuationString", " ");
				XmlSchemaParticle xmlSchemaParticle = null;
				XmlSchemaParticle xmlSchemaParticle2 = null;
				ArrayList arrayList = new ArrayList();
				StringBuilder stringBuilder = new StringBuilder();
				if (expected.Count == 1)
				{
					xmlSchemaParticle2 = expected[0] as XmlSchemaParticle;
				}
				else
				{
					for (int i = 1; i < expected.Count; i++)
					{
						xmlSchemaParticle = expected[i - 1] as XmlSchemaParticle;
						xmlSchemaParticle2 = expected[i] as XmlSchemaParticle;
						XmlQualifiedName qualifiedName = xmlSchemaParticle.GetQualifiedName();
						if (qualifiedName.Namespace != xmlSchemaParticle2.GetQualifiedName().Namespace)
						{
							arrayList.Add(qualifiedName);
							PrintNamesWithNS(arrayList, stringBuilder);
							arrayList.Clear();
							stringBuilder.Append(@string);
						}
						else
						{
							arrayList.Add(qualifiedName);
						}
					}
				}
				arrayList.Add(xmlSchemaParticle2.GetQualifiedName());
				PrintNamesWithNS(arrayList, stringBuilder);
				return stringBuilder.ToString();
			}
			return PrintNames(expected);
		}

		private static string PrintNames(ArrayList expected)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("'");
			stringBuilder.Append(expected[0].ToString());
			for (int i = 1; i < expected.Count; i++)
			{
				stringBuilder.Append(" ");
				stringBuilder.Append(expected[i].ToString());
			}
			stringBuilder.Append("'");
			return stringBuilder.ToString();
		}

		private static void PrintNamesWithNS(ArrayList expected, StringBuilder builder)
		{
			XmlQualifiedName xmlQualifiedName = null;
			xmlQualifiedName = expected[0] as XmlQualifiedName;
			if (expected.Count == 1)
			{
				if (xmlQualifiedName.Name == "*")
				{
					EnumerateAny(builder, xmlQualifiedName.Namespace);
				}
				else if (xmlQualifiedName.Namespace.Length != 0)
				{
					builder.Append(Res.GetString("Sch_ElementNameAndNamespace", xmlQualifiedName.Name, xmlQualifiedName.Namespace));
				}
				else
				{
					builder.Append(Res.GetString("Sch_ElementName", xmlQualifiedName.Name));
				}
				return;
			}
			bool flag = false;
			bool flag2 = true;
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < expected.Count; i++)
			{
				xmlQualifiedName = expected[i] as XmlQualifiedName;
				if (xmlQualifiedName.Name == "*")
				{
					flag = true;
					continue;
				}
				if (flag2)
				{
					flag2 = false;
				}
				else
				{
					stringBuilder.Append(", ");
				}
				stringBuilder.Append(xmlQualifiedName.Name);
			}
			if (flag)
			{
				stringBuilder.Append(", ");
				stringBuilder.Append(Res.GetString("Sch_AnyElement"));
			}
			else if (xmlQualifiedName.Namespace.Length != 0)
			{
				builder.Append(Res.GetString("Sch_ElementNameAndNamespace", stringBuilder.ToString(), xmlQualifiedName.Namespace));
			}
			else
			{
				builder.Append(Res.GetString("Sch_ElementName", stringBuilder.ToString()));
			}
		}

		private static void EnumerateAny(StringBuilder builder, string namespaces)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (namespaces == "##any" || namespaces == "##other")
			{
				stringBuilder.Append(namespaces);
			}
			else
			{
				string[] array = XmlConvert.SplitString(namespaces);
				stringBuilder.Append(array[0]);
				for (int i = 1; i < array.Length; i++)
				{
					stringBuilder.Append(", ");
					stringBuilder.Append(array[i]);
				}
			}
			builder.Append(Res.GetString("Sch_AnyElementNS", stringBuilder.ToString()));
		}

		internal static string QNameString(string localName, string ns)
		{
			if (ns.Length == 0)
			{
				return localName;
			}
			return ns + ":" + localName;
		}

		internal static string BuildElementName(XmlQualifiedName qname)
		{
			return BuildElementName(qname.Name, qname.Namespace);
		}

		internal static string BuildElementName(string localName, string ns)
		{
			if (ns.Length != 0)
			{
				return Res.GetString("Sch_ElementNameAndNamespace", localName, ns);
			}
			return Res.GetString("Sch_ElementName", localName);
		}

		private void ProcessEntity(string name)
		{
			if (checkEntity)
			{
				SchemaEntity schemaEntity = null;
				if (dtdSchemaInfo != null)
				{
					schemaEntity = (SchemaEntity)dtdSchemaInfo.GeneralEntities[new XmlQualifiedName(name)];
				}
				if (schemaEntity == null)
				{
					SendValidationEvent("Sch_UndeclaredEntity", name);
				}
				else if (!schemaEntity.NData.IsEmpty)
				{
					SendValidationEvent("Sch_UnparsedEntityRef", name);
				}
			}
		}

		private void SendValidationEvent(string code)
		{
			SendValidationEvent(code, string.Empty);
		}

		private void SendValidationEvent(string code, string[] args)
		{
			SendValidationEvent(new XmlSchemaValidationException(code, args, sourceUriString, positionInfo.LineNumber, positionInfo.LinePosition));
		}

		private void SendValidationEvent(string code, string arg)
		{
			SendValidationEvent(new XmlSchemaValidationException(code, arg, sourceUriString, positionInfo.LineNumber, positionInfo.LinePosition));
		}

		private void SendValidationEvent(string code, string arg1, string arg2)
		{
			SendValidationEvent(new XmlSchemaValidationException(code, new string[2] { arg1, arg2 }, sourceUriString, positionInfo.LineNumber, positionInfo.LinePosition));
		}

		private void SendValidationEvent(string code, string[] args, Exception innerException, XmlSeverityType severity)
		{
			if (severity != XmlSeverityType.Warning || ReportValidationWarnings)
			{
				SendValidationEvent(new XmlSchemaValidationException(code, args, innerException, sourceUriString, positionInfo.LineNumber, positionInfo.LinePosition), severity);
			}
		}

		private void SendValidationEvent(string code, string[] args, Exception innerException)
		{
			SendValidationEvent(new XmlSchemaValidationException(code, args, innerException, sourceUriString, positionInfo.LineNumber, positionInfo.LinePosition), XmlSeverityType.Error);
		}

		private void SendValidationEvent(XmlSchemaValidationException e)
		{
			SendValidationEvent(e, XmlSeverityType.Error);
		}

		private void SendValidationEvent(XmlSchemaException e)
		{
			SendValidationEvent(new XmlSchemaValidationException(e.GetRes, e.Args, e.SourceUri, e.LineNumber, e.LinePosition), XmlSeverityType.Error);
		}

		private void SendValidationEvent(string code, string msg, XmlSeverityType severity)
		{
			if (severity != XmlSeverityType.Warning || ReportValidationWarnings)
			{
				SendValidationEvent(new XmlSchemaValidationException(code, msg, sourceUriString, positionInfo.LineNumber, positionInfo.LinePosition), severity);
			}
		}

		private void SendValidationEvent(XmlSchemaValidationException e, XmlSeverityType severity)
		{
			bool flag = false;
			if (severity == XmlSeverityType.Error)
			{
				flag = true;
				context.Validity = XmlSchemaValidity.Invalid;
			}
			if (flag)
			{
				if (eventHandler == null)
				{
					throw e;
				}
				eventHandler(validationEventSender, new ValidationEventArgs(e, severity));
			}
			else if (ReportValidationWarnings && eventHandler != null)
			{
				eventHandler(validationEventSender, new ValidationEventArgs(e, severity));
			}
		}

		internal static void SendValidationEvent(ValidationEventHandler eventHandler, object sender, XmlSchemaValidationException e, XmlSeverityType severity)
		{
			if (eventHandler != null)
			{
				eventHandler(sender, new ValidationEventArgs(e, severity));
			}
			else if (severity == XmlSeverityType.Error)
			{
				throw e;
			}
		}
	}
	public enum XmlSchemaValidity
	{
		NotKnown,
		Valid,
		Invalid
	}
	public enum XmlSeverityType
	{
		Error,
		Warning
	}
}
namespace System.Xml
{
	public enum XmlTokenizedType
	{
		CDATA,
		ID,
		IDREF,
		IDREFS,
		ENTITY,
		ENTITIES,
		NMTOKEN,
		NMTOKENS,
		NOTATION,
		ENUMERATION,
		QName,
		NCName,
		None
	}
}
namespace System.Xml.Schema
{
	public enum XmlTypeCode
	{
		None,
		Item,
		Node,
		Document,
		Element,
		Attribute,
		Namespace,
		ProcessingInstruction,
		Comment,
		Text,
		AnyAtomicType,
		UntypedAtomic,
		String,
		Boolean,
		Decimal,
		Float,
		Double,
		Duration,
		DateTime,
		Time,
		Date,
		GYearMonth,
		GYear,
		GMonthDay,
		GDay,
		GMonth,
		HexBinary,
		Base64Binary,
		AnyUri,
		QName,
		Notation,
		NormalizedString,
		Token,
		Language,
		NmToken,
		Name,
		NCName,
		Id,
		Idref,
		Entity,
		Integer,
		NonPositiveInteger,
		NegativeInteger,
		Long,
		Int,
		Short,
		Byte,
		NonNegativeInteger,
		UnsignedLong,
		UnsignedInt,
		UnsignedShort,
		UnsignedByte,
		PositiveInteger,
		YearMonthDuration,
		DayTimeDuration
	}
	internal abstract class XmlValueConverter
	{
		public abstract bool ToBoolean(bool value);

		public abstract bool ToBoolean(long value);

		public abstract bool ToBoolean(int value);

		public abstract bool ToBoolean(decimal value);

		public abstract bool ToBoolean(float value);

		public abstract bool ToBoolean(double value);

		public abstract bool ToBoolean(DateTime value);

		public abstract bool ToBoolean(DateTimeOffset value);

		public abstract bool ToBoolean(string value);

		public abstract bool ToBoolean(object value);

		public abstract int ToInt32(bool value);

		public abstract int ToInt32(int value);

		public abstract int ToInt32(long value);

		public abstract int ToInt32(decimal value);

		public abstract int ToInt32(float value);

		public abstract int ToInt32(double value);

		public abstract int ToInt32(DateTime value);

		public abstract int ToInt32(DateTimeOffset value);

		public abstract int ToInt32(string value);

		public abstract int ToInt32(object value);

		public abstract long ToInt64(bool value);

		public abstract long ToInt64(int value);

		public abstract long ToInt64(long value);

		public abstract long ToInt64(decimal value);

		public abstract long ToInt64(float value);

		public abstract long ToInt64(double value);

		public abstract long ToInt64(DateTime value);

		public abstract long ToInt64(DateTimeOffset value);

		public abstract long ToInt64(string value);

		public abstract long ToInt64(object value);

		public abstract decimal ToDecimal(bool value);

		public abstract decimal ToDecimal(int value);

		public abstract decimal ToDecimal(long value);

		public abstract decimal ToDecimal(decimal value);

		public abstract decimal ToDecimal(float value);

		public abstract decimal ToDecimal(double value);

		public abstract decimal ToDecimal(DateTime value);

		public abstract decimal ToDecimal(DateTimeOffset value);

		public abstract decimal ToDecimal(string value);

		public abstract decimal ToDecimal(object value);

		public abstract double ToDouble(bool value);

		public abstract double ToDouble(int value);

		public abstract double ToDouble(long value);

		public abstract double ToDouble(decimal value);

		public abstract double ToDouble(float value);

		public abstract double ToDouble(double value);

		public abstract double ToDouble(DateTime value);

		public abstract double ToDouble(DateTimeOffset value);

		public abstract double ToDouble(string value);

		public abstract double ToDouble(object value);

		public abstract float ToSingle(bool value);

		public abstract float ToSingle(int value);

		public abstract float ToSingle(long value);

		public abstract float ToSingle(decimal value);

		public abstract float ToSingle(float value);

		public abstract float ToSingle(double value);

		public abstract float ToSingle(DateTime value);

		public abstract float ToSingle(DateTimeOffset value);

		public abstract float ToSingle(string value);

		public abstract float ToSingle(object value);

		public abstract DateTime ToDateTime(bool value);

		public abstract DateTime ToDateTime(int value);

		public abstract DateTime ToDateTime(long value);

		public abstract DateTime ToDateTime(decimal value);

		public abstract DateTime ToDateTime(float value);

		public abstract DateTime ToDateTime(double value);

		public abstract DateTime ToDateTime(DateTime value);

		public abstract DateTime ToDateTime(DateTimeOffset value);

		public abstract DateTime ToDateTime(string value);

		public abstract DateTime ToDateTime(object value);

		public abstract DateTimeOffset ToDateTimeOffset(bool value);

		public abstract DateTimeOffset ToDateTimeOffset(int value);

		public abstract DateTimeOffset ToDateTimeOffset(long value);

		public abstract DateTimeOffset ToDateTimeOffset(decimal value);

		public abstract DateTimeOffset ToDateTimeOffset(float value);

		public abstract DateTimeOffset ToDateTimeOffset(double value);

		public abstract DateTimeOffset ToDateTimeOffset(DateTime value);

		public abstract DateTimeOffset ToDateTimeOffset(DateTimeOffset value);

		public abstract DateTimeOffset ToDateTimeOffset(string value);

		public abstract DateTimeOffset ToDateTimeOffset(object value);

		public abstract string ToString(bool value);

		public abstract string ToString(int value);

		public abstract string ToString(long value);

		public abstract string ToString(decimal value);

		public abstract string ToString(float value);

		public abstract string ToString(double value);

		public abstract string ToString(DateTime value);

		public abstract string ToString(DateTimeOffset value);

		public abstract string ToString(string value);

		public abstract string ToString(string value, IXmlNamespaceResolver nsResolver);

		public abstract string ToString(object value);

		public abstract string ToString(object value, IXmlNamespaceResolver nsResolver);

		public abstract object ChangeType(bool value, Type destinationType);

		public abstract object ChangeType(int value, Type destinationType);

		public abstract object ChangeType(long value, Type destinationType);

		public abstract object ChangeType(decimal value, Type destinationType);

		public abstract object ChangeType(float value, Type destinationType);

		public abstract object ChangeType(double value, Type destinationType);

		public abstract object ChangeType(DateTime value, Type destinationType);

		public abstract object ChangeType(DateTimeOffset value, Type destinationType);

		public abstract object ChangeType(string value, Type destinationType);

		public abstract object ChangeType(string value, Type destinationType, IXmlNamespaceResolver nsResolver);

		public abstract object ChangeType(object value, Type destinationType);

		public abstract object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver);
	}
	internal abstract class XmlBaseConverter : XmlValueConverter
	{
		private XmlSchemaType schemaType;

		private XmlTypeCode typeCode;

		private Type clrTypeDefault;

		protected static readonly Type ICollectionType = typeof(ICollection);

		protected static readonly Type IEnumerableType = typeof(IEnumerable);

		protected static readonly Type IListType = typeof(IList);

		protected static readonly Type ObjectArrayType = typeof(object[]);

		protected static readonly Type StringArrayType = typeof(string[]);

		protected static readonly Type XmlAtomicValueArrayType = typeof(XmlAtomicValue[]);

		protected static readonly Type DecimalType = typeof(decimal);

		protected static readonly Type Int32Type = typeof(int);

		protected static readonly Type Int64Type = typeof(long);

		protected static readonly Type StringType = typeof(string);

		protected static readonly Type XmlAtomicValueType = typeof(XmlAtomicValue);

		protected static readonly Type ObjectType = typeof(object);

		protected static readonly Type ByteType = typeof(byte);

		protected static readonly Type Int16Type = typeof(short);

		protected static readonly Type SByteType = typeof(sbyte);

		protected static readonly Type UInt16Type = typeof(ushort);

		protected static readonly Type UInt32Type = typeof(uint);

		protected static readonly Type UInt64Type = typeof(ulong);

		protected static readonly Type XPathItemType = typeof(XPathItem);

		protected static readonly Type DoubleType = typeof(double);

		protected static readonly Type SingleType = typeof(float);

		protected static readonly Type DateTimeType = typeof(DateTime);

		protected static readonly Type DateTimeOffsetType = typeof(DateTimeOffset);

		protected static readonly Type BooleanType = typeof(bool);

		protected static readonly Type ByteArrayType = typeof(byte[]);

		protected static readonly Type XmlQualifiedNameType = typeof(XmlQualifiedName);

		protected static readonly Type UriType = typeof(Uri);

		protected static readonly Type TimeSpanType = typeof(TimeSpan);

		protected static readonly Type XPathNavigatorType = typeof(XPathNavigator);

		protected XmlSchemaType SchemaType => schemaType;

		protected XmlTypeCode TypeCode => typeCode;

		protected string XmlTypeName
		{
			get
			{
				XmlSchemaType baseXmlSchemaType = schemaType;
				if (baseXmlSchemaType != null)
				{
					while (baseXmlSchemaType.QualifiedName.IsEmpty)
					{
						baseXmlSchemaType = baseXmlSchemaType.BaseXmlSchemaType;
					}
					return QNameToString(baseXmlSchemaType.QualifiedName);
				}
				if (typeCode == XmlTypeCode.Node)
				{
					return "node";
				}
				if (typeCode == XmlTypeCode.AnyAtomicType)
				{
					return "xdt:anyAtomicType";
				}
				return "item";
			}
		}

		protected Type DefaultClrType => clrTypeDefault;

		protected XmlBaseConverter(XmlSchemaType schemaType)
		{
			XmlSchemaDatatype datatype = schemaType.Datatype;
			while (schemaType != null && !(schemaType is XmlSchemaSimpleType))
			{
				schemaType = schemaType.BaseXmlSchemaType;
			}
			if (schemaType == null)
			{
				schemaType = XmlSchemaType.GetBuiltInSimpleType(datatype.TypeCode);
			}
			this.schemaType = schemaType;
			typeCode = schemaType.TypeCode;
			clrTypeDefault = schemaType.Datatype.ValueType;
		}

		protected XmlBaseConverter(XmlTypeCode typeCode)
		{
			switch (typeCode)
			{
			case XmlTypeCode.Item:
				clrTypeDefault = XPathItemType;
				break;
			case XmlTypeCode.Node:
				clrTypeDefault = XPathNavigatorType;
				break;
			case XmlTypeCode.AnyAtomicType:
				clrTypeDefault = XmlAtomicValueType;
				break;
			}
			this.typeCode = typeCode;
		}

		protected XmlBaseConverter(XmlBaseConverter converterAtomic)
		{
			schemaType = converterAtomic.schemaType;
			typeCode = converterAtomic.typeCode;
			clrTypeDefault = Array.CreateInstance(converterAtomic.DefaultClrType, 0).GetType();
		}

		protected XmlBaseConverter(XmlBaseConverter converterAtomic, Type clrTypeDefault)
		{
			schemaType = converterAtomic.schemaType;
			typeCode = converterAtomic.typeCode;
			this.clrTypeDefault = clrTypeDefault;
		}

		public override bool ToBoolean(bool value)
		{
			return (bool)ChangeType(value, BooleanType, null);
		}

		public override bool ToBoolean(DateTime value)
		{
			return (bool)ChangeType(value, BooleanType, null);
		}

		public override bool ToBoolean(DateTimeOffset value)
		{
			return (bool)ChangeType(value, BooleanType, null);
		}

		public override bool ToBoolean(decimal value)
		{
			return (bool)ChangeType(value, BooleanType, null);
		}

		public override bool ToBoolean(double value)
		{
			return (bool)ChangeType(value, BooleanType, null);
		}

		public override bool ToBoolean(int value)
		{
			return (bool)ChangeType(value, BooleanType, null);
		}

		public override bool ToBoolean(long value)
		{
			return (bool)ChangeType(value, BooleanType, null);
		}

		public override bool ToBoolean(float value)
		{
			return (bool)ChangeType(value, BooleanType, null);
		}

		public override bool ToBoolean(string value)
		{
			return (bool)ChangeType((object)value, BooleanType, (IXmlNamespaceResolver)null);
		}

		public override bool ToBoolean(object value)
		{
			return (bool)ChangeType(value, BooleanType, null);
		}

		public override DateTime ToDateTime(bool value)
		{
			return (DateTime)ChangeType(value, DateTimeType, null);
		}

		public override DateTime ToDateTime(DateTime value)
		{
			return (DateTime)ChangeType(value, DateTimeType, null);
		}

		public override DateTime ToDateTime(DateTimeOffset value)
		{
			return (DateTime)ChangeType(value, DateTimeType, null);
		}

		public override DateTime ToDateTime(decimal value)
		{
			return (DateTime)ChangeType(value, DateTimeType, null);
		}

		public override DateTime ToDateTime(double value)
		{
			return (DateTime)ChangeType(value, DateTimeType, null);
		}

		public override DateTime ToDateTime(int value)
		{
			return (DateTime)ChangeType(value, DateTimeType, null);
		}

		public override DateTime ToDateTime(long value)
		{
			return (DateTime)ChangeType(value, DateTimeType, null);
		}

		public override DateTime ToDateTime(float value)
		{
			return (DateTime)ChangeType(value, DateTimeType, null);
		}

		public override DateTime ToDateTime(string value)
		{
			return (DateTime)ChangeType((object)value, DateTimeType, (IXmlNamespaceResolver)null);
		}

		public override DateTime ToDateTime(object value)
		{
			return (DateTime)ChangeType(value, DateTimeType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(bool value)
		{
			return (DateTimeOffset)ChangeType(value, DateTimeOffsetType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(DateTime value)
		{
			return (DateTimeOffset)ChangeType(value, DateTimeOffsetType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(DateTimeOffset value)
		{
			return (DateTimeOffset)ChangeType(value, DateTimeOffsetType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(decimal value)
		{
			return (DateTimeOffset)ChangeType(value, DateTimeOffsetType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(double value)
		{
			return (DateTimeOffset)ChangeType(value, DateTimeOffsetType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(int value)
		{
			return (DateTimeOffset)ChangeType(value, DateTimeOffsetType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(long value)
		{
			return (DateTimeOffset)ChangeType(value, DateTimeOffsetType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(float value)
		{
			return (DateTimeOffset)ChangeType(value, DateTimeOffsetType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(string value)
		{
			return (DateTimeOffset)ChangeType((object)value, DateTimeOffsetType, (IXmlNamespaceResolver)null);
		}

		public override DateTimeOffset ToDateTimeOffset(object value)
		{
			return (DateTimeOffset)ChangeType(value, DateTimeOffsetType, null);
		}

		public override decimal ToDecimal(bool value)
		{
			return (decimal)ChangeType(value, DecimalType, null);
		}

		public override decimal ToDecimal(DateTime value)
		{
			return (decimal)ChangeType(value, DecimalType, null);
		}

		public override decimal ToDecimal(DateTimeOffset value)
		{
			return (decimal)ChangeType(value, DecimalType, null);
		}

		public override decimal ToDecimal(decimal value)
		{
			return (decimal)ChangeType(value, DecimalType, null);
		}

		public override decimal ToDecimal(double value)
		{
			return (decimal)ChangeType(value, DecimalType, null);
		}

		public override decimal ToDecimal(int value)
		{
			return (decimal)ChangeType(value, DecimalType, null);
		}

		public override decimal ToDecimal(long value)
		{
			return (decimal)ChangeType(value, DecimalType, null);
		}

		public override decimal ToDecimal(float value)
		{
			return (decimal)ChangeType(value, DecimalType, null);
		}

		public override decimal ToDecimal(string value)
		{
			return (decimal)ChangeType((object)value, DecimalType, (IXmlNamespaceResolver)null);
		}

		public override decimal ToDecimal(object value)
		{
			return (decimal)ChangeType(value, DecimalType, null);
		}

		public override double ToDouble(bool value)
		{
			return (double)ChangeType(value, DoubleType, null);
		}

		public override double ToDouble(DateTime value)
		{
			return (double)ChangeType(value, DoubleType, null);
		}

		public override double ToDouble(DateTimeOffset value)
		{
			return (double)ChangeType(value, DoubleType, null);
		}

		public override double ToDouble(decimal value)
		{
			return (double)ChangeType(value, DoubleType, null);
		}

		public override double ToDouble(double value)
		{
			return (double)ChangeType(value, DoubleType, null);
		}

		public override double ToDouble(int value)
		{
			return (double)ChangeType(value, DoubleType, null);
		}

		public override double ToDouble(long value)
		{
			return (double)ChangeType(value, DoubleType, null);
		}

		public override double ToDouble(float value)
		{
			return (double)ChangeType(value, DoubleType, null);
		}

		public override double ToDouble(string value)
		{
			return (double)ChangeType((object)value, DoubleType, (IXmlNamespaceResolver)null);
		}

		public override double ToDouble(object value)
		{
			return (double)ChangeType(value, DoubleType, null);
		}

		public override int ToInt32(bool value)
		{
			return (int)ChangeType(value, Int32Type, null);
		}

		public override int ToInt32(DateTime value)
		{
			return (int)ChangeType(value, Int32Type, null);
		}

		public override int ToInt32(DateTimeOffset value)
		{
			return (int)ChangeType(value, Int32Type, null);
		}

		public override int ToInt32(decimal value)
		{
			return (int)ChangeType(value, Int32Type, null);
		}

		public override int ToInt32(double value)
		{
			return (int)ChangeType(value, Int32Type, null);
		}

		public override int ToInt32(int value)
		{
			return (int)ChangeType(value, Int32Type, null);
		}

		public override int ToInt32(long value)
		{
			return (int)ChangeType(value, Int32Type, null);
		}

		public override int ToInt32(float value)
		{
			return (int)ChangeType(value, Int32Type, null);
		}

		public override int ToInt32(string value)
		{
			return (int)ChangeType((object)value, Int32Type, (IXmlNamespaceResolver)null);
		}

		public override int ToInt32(object value)
		{
			return (int)ChangeType(value, Int32Type, null);
		}

		public override long ToInt64(bool value)
		{
			return (long)ChangeType(value, Int64Type, null);
		}

		public override long ToInt64(DateTime value)
		{
			return (long)ChangeType(value, Int64Type, null);
		}

		public override long ToInt64(DateTimeOffset value)
		{
			return (long)ChangeType(value, Int64Type, null);
		}

		public override long ToInt64(decimal value)
		{
			return (long)ChangeType(value, Int64Type, null);
		}

		public override long ToInt64(double value)
		{
			return (long)ChangeType(value, Int64Type, null);
		}

		public override long ToInt64(int value)
		{
			return (long)ChangeType(value, Int64Type, null);
		}

		public override long ToInt64(long value)
		{
			return (long)ChangeType(value, Int64Type, null);
		}

		public override long ToInt64(float value)
		{
			return (long)ChangeType(value, Int64Type, null);
		}

		public override long ToInt64(string value)
		{
			return (long)ChangeType((object)value, Int64Type, (IXmlNamespaceResolver)null);
		}

		public override long ToInt64(object value)
		{
			return (long)ChangeType(value, Int64Type, null);
		}

		public override float ToSingle(bool value)
		{
			return (float)ChangeType(value, SingleType, null);
		}

		public override float ToSingle(DateTime value)
		{
			return (float)ChangeType(value, SingleType, null);
		}

		public override float ToSingle(DateTimeOffset value)
		{
			return (float)ChangeType(value, SingleType, null);
		}

		public override float ToSingle(decimal value)
		{
			return (float)ChangeType(value, SingleType, null);
		}

		public override float ToSingle(double value)
		{
			return (float)ChangeType(value, SingleType, null);
		}

		public override float ToSingle(int value)
		{
			return (float)ChangeType(value, SingleType, null);
		}

		public override float ToSingle(long value)
		{
			return (float)ChangeType(value, SingleType, null);
		}

		public override float ToSingle(float value)
		{
			return (float)ChangeType(value, SingleType, null);
		}

		public override float ToSingle(string value)
		{
			return (float)ChangeType((object)value, SingleType, (IXmlNamespaceResolver)null);
		}

		public override float ToSingle(object value)
		{
			return (float)ChangeType(value, SingleType, null);
		}

		public override string ToString(bool value)
		{
			return (string)ChangeType(value, StringType, null);
		}

		public override string ToString(DateTime value)
		{
			return (string)ChangeType(value, StringType, null);
		}

		public override string ToString(DateTimeOffset value)
		{
			return (string)ChangeType(value, StringType, null);
		}

		public override string ToString(decimal value)
		{
			return (string)ChangeType(value, StringType, null);
		}

		public override string ToString(double value)
		{
			return (string)ChangeType(value, StringType, null);
		}

		public override string ToString(int value)
		{
			return (string)ChangeType(value, StringType, null);
		}

		public override string ToString(long value)
		{
			return (string)ChangeType(value, StringType, null);
		}

		public override string ToString(float value)
		{
			return (string)ChangeType(value, StringType, null);
		}

		public override string ToString(string value, IXmlNamespaceResolver nsResolver)
		{
			return (string)ChangeType((object)value, StringType, nsResolver);
		}

		public override string ToString(object value, IXmlNamespaceResolver nsResolver)
		{
			return (string)ChangeType(value, StringType, nsResolver);
		}

		public override string ToString(string value)
		{
			return ToString(value, null);
		}

		public override string ToString(object value)
		{
			return ToString(value, null);
		}

		public override object ChangeType(bool value, Type destinationType)
		{
			return ChangeType(value, destinationType, null);
		}

		public override object ChangeType(DateTime value, Type destinationType)
		{
			return ChangeType(value, destinationType, null);
		}

		public override object ChangeType(DateTimeOffset value, Type destinationType)
		{
			return ChangeType(value, destinationType, null);
		}

		public override object ChangeType(decimal value, Type destinationType)
		{
			return ChangeType(value, destinationType, null);
		}

		public override object ChangeType(double value, Type destinationType)
		{
			return ChangeType(value, destinationType, null);
		}

		public override object ChangeType(int value, Type destinationType)
		{
			return ChangeType(value, destinationType, null);
		}

		public override object ChangeType(long value, Type destinationType)
		{
			return ChangeType(value, destinationType, null);
		}

		public override object ChangeType(float value, Type destinationType)
		{
			return ChangeType(value, destinationType, null);
		}

		public override object ChangeType(string value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			return ChangeType((object)value, destinationType, nsResolver);
		}

		public override object ChangeType(string value, Type destinationType)
		{
			return ChangeType(value, destinationType, null);
		}

		public override object ChangeType(object value, Type destinationType)
		{
			return ChangeType(value, destinationType, null);
		}

		protected static bool IsDerivedFrom(Type derivedType, Type baseType)
		{
			while (derivedType != null)
			{
				if (derivedType == baseType)
				{
					return true;
				}
				derivedType = derivedType.BaseType;
			}
			return false;
		}

		protected Exception CreateInvalidClrMappingException(Type sourceType, Type destinationType)
		{
			if (sourceType == destinationType)
			{
				return new InvalidCastException(Res.GetString("XmlConvert_TypeBadMapping", XmlTypeName, sourceType.Name));
			}
			return new InvalidCastException(Res.GetString("XmlConvert_TypeBadMapping2", XmlTypeName, sourceType.Name, destinationType.Name));
		}

		protected static string QNameToString(XmlQualifiedName name)
		{
			if (name.Namespace.Length == 0)
			{
				return name.Name;
			}
			if (name.Namespace == "http://www.w3.org/2001/XMLSchema")
			{
				return "xs:" + name.Name;
			}
			if (name.Namespace == "http://www.w3.org/2003/11/xpath-datatypes")
			{
				return "xdt:" + name.Name;
			}
			return "{" + name.Namespace + "}" + name.Name;
		}

		protected virtual object ChangeListType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			throw CreateInvalidClrMappingException(value.GetType(), destinationType);
		}

		protected static byte[] StringToBase64Binary(string value)
		{
			return Convert.FromBase64String(XmlConvert.TrimString(value));
		}

		protected static DateTime StringToDate(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.Date);
		}

		protected static DateTime StringToDateTime(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.DateTime);
		}

		protected static TimeSpan StringToDayTimeDuration(string value)
		{
			return new XsdDuration(value, XsdDuration.DurationType.DayTimeDuration).ToTimeSpan(XsdDuration.DurationType.DayTimeDuration);
		}

		protected static TimeSpan StringToDuration(string value)
		{
			return new XsdDuration(value, XsdDuration.DurationType.Duration).ToTimeSpan(XsdDuration.DurationType.Duration);
		}

		protected static DateTime StringToGDay(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GDay);
		}

		protected static DateTime StringToGMonth(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GMonth);
		}

		protected static DateTime StringToGMonthDay(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GMonthDay);
		}

		protected static DateTime StringToGYear(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GYear);
		}

		protected static DateTime StringToGYearMonth(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GYearMonth);
		}

		protected static DateTimeOffset StringToDateOffset(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.Date);
		}

		protected static DateTimeOffset StringToDateTimeOffset(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.DateTime);
		}

		protected static DateTimeOffset StringToGDayOffset(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GDay);
		}

		protected static DateTimeOffset StringToGMonthOffset(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GMonth);
		}

		protected static DateTimeOffset StringToGMonthDayOffset(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GMonthDay);
		}

		protected static DateTimeOffset StringToGYearOffset(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GYear);
		}

		protected static DateTimeOffset StringToGYearMonthOffset(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GYearMonth);
		}

		protected static byte[] StringToHexBinary(string value)
		{
			try
			{
				return XmlConvert.FromBinHexString(XmlConvert.TrimString(value), allowOddCount: false);
			}
			catch (XmlException ex)
			{
				throw new FormatException(ex.Message);
			}
		}

		protected static XmlQualifiedName StringToQName(string value, IXmlNamespaceResolver nsResolver)
		{
			value = value.Trim();
			string prefix;
			string localName;
			try
			{
				ValidateNames.ParseQNameThrow(value, out prefix, out localName);
			}
			catch (XmlException ex)
			{
				throw new FormatException(ex.Message);
			}
			if (nsResolver == null)
			{
				throw new InvalidCastException(Res.GetString("XmlConvert_TypeNoNamespace", value, prefix));
			}
			string text = nsResolver.LookupNamespace(prefix);
			if (text == null)
			{
				throw new InvalidCastException(Res.GetString("XmlConvert_TypeNoNamespace", value, prefix));
			}
			return new XmlQualifiedName(localName, text);
		}

		protected static DateTime StringToTime(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.Time);
		}

		protected static DateTimeOffset StringToTimeOffset(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.Time);
		}

		protected static TimeSpan StringToYearMonthDuration(string value)
		{
			return new XsdDuration(value, XsdDuration.DurationType.YearMonthDuration).ToTimeSpan(XsdDuration.DurationType.YearMonthDuration);
		}

		protected static string AnyUriToString(Uri value)
		{
			return value.OriginalString;
		}

		protected static string Base64BinaryToString(byte[] value)
		{
			return Convert.ToBase64String(value);
		}

		protected static string DateToString(DateTime value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.Date).ToString();
		}

		protected static string DateTimeToString(DateTime value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.DateTime).ToString();
		}

		protected static string DayTimeDurationToString(TimeSpan value)
		{
			return new XsdDuration(value, XsdDuration.DurationType.DayTimeDuration).ToString(XsdDuration.DurationType.DayTimeDuration);
		}

		protected static string DurationToString(TimeSpan value)
		{
			return new XsdDuration(value, XsdDuration.DurationType.Duration).ToString(XsdDuration.DurationType.Duration);
		}

		protected static string GDayToString(DateTime value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GDay).ToString();
		}

		protected static string GMonthToString(DateTime value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GMonth).ToString();
		}

		protected static string GMonthDayToString(DateTime value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GMonthDay).ToString();
		}

		protected static string GYearToString(DateTime value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GYear).ToString();
		}

		protected static string GYearMonthToString(DateTime value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GYearMonth).ToString();
		}

		protected static string DateOffsetToString(DateTimeOffset value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.Date).ToString();
		}

		protected static string DateTimeOffsetToString(DateTimeOffset value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.DateTime).ToString();
		}

		protected static string GDayOffsetToString(DateTimeOffset value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GDay).ToString();
		}

		protected static string GMonthOffsetToString(DateTimeOffset value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GMonth).ToString();
		}

		protected static string GMonthDayOffsetToString(DateTimeOffset value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GMonthDay).ToString();
		}

		protected static string GYearOffsetToString(DateTimeOffset value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GYear).ToString();
		}

		protected static string GYearMonthOffsetToString(DateTimeOffset value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.GYearMonth).ToString();
		}

		protected static string QNameToString(XmlQualifiedName qname, IXmlNamespaceResolver nsResolver)
		{
			if (nsResolver == null)
			{
				return "{" + qname.Namespace + "}" + qname.Name;
			}
			string text = nsResolver.LookupPrefix(qname.Namespace);
			if (text == null)
			{
				throw new InvalidCastException(Res.GetString("XmlConvert_TypeNoPrefix", qname.ToString(), qname.Namespace));
			}
			if (text.Length == 0)
			{
				return qname.Name;
			}
			return text + ":" + qname.Name;
		}

		protected static string TimeToString(DateTime value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.Time).ToString();
		}

		protected static string TimeOffsetToString(DateTimeOffset value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.Time).ToString();
		}

		protected static string YearMonthDurationToString(TimeSpan value)
		{
			return new XsdDuration(value, XsdDuration.DurationType.YearMonthDuration).ToString(XsdDuration.DurationType.YearMonthDuration);
		}

		internal static DateTime DateTimeOffsetToDateTime(DateTimeOffset value)
		{
			return value.LocalDateTime;
		}

		internal static int DecimalToInt32(decimal value)
		{
			if (value < -2147483648m || value > 2147483647m)
			{
				throw new OverflowException(Res.GetString("XmlConvert_Overflow", XmlConvert.ToString(value), "Int32"));
			}
			return (int)value;
		}

		protected static long DecimalToInt64(decimal value)
		{
			if (value < new decimal(long.MinValue) || value > new decimal(long.MaxValue))
			{
				throw new OverflowException(Res.GetString("XmlConvert_Overflow", XmlConvert.ToString(value), "Int64"));
			}
			return (long)value;
		}

		protected static ulong DecimalToUInt64(decimal value)
		{
			if (value < 0m || value > 18446744073709551615m)
			{
				throw new OverflowException(Res.GetString("XmlConvert_Overflow", XmlConvert.ToString(value), "UInt64"));
			}
			return (ulong)value;
		}

		protected static byte Int32ToByte(int value)
		{
			if (value < 0 || value > 255)
			{
				throw new OverflowException(Res.GetString("XmlConvert_Overflow", XmlConvert.ToString(value), "Byte"));
			}
			return (byte)value;
		}

		protected static short Int32ToInt16(int value)
		{
			if (value < -32768 || value > 32767)
			{
				throw new OverflowException(Res.GetString("XmlConvert_Overflow", XmlConvert.ToString(value), "Int16"));
			}
			return (short)value;
		}

		protected static sbyte Int32ToSByte(int value)
		{
			if (value < -128 || value > 127)
			{
				throw new OverflowException(Res.GetString("XmlConvert_Overflow", XmlConvert.ToString(value), "SByte"));
			}
			return (sbyte)value;
		}

		protected static ushort Int32ToUInt16(int value)
		{
			if (value < 0 || value > 65535)
			{
				throw new OverflowException(Res.GetString("XmlConvert_Overflow", XmlConvert.ToString(value), "UInt16"));
			}
			return (ushort)value;
		}

		protected static int Int64ToInt32(long value)
		{
			if (value < int.MinValue || value > int.MaxValue)
			{
				throw new OverflowException(Res.GetString("XmlConvert_Overflow", XmlConvert.ToString(value), "Int32"));
			}
			return (int)value;
		}

		protected static uint Int64ToUInt32(long value)
		{
			if (value < 0 || value > uint.MaxValue)
			{
				throw new OverflowException(Res.GetString("XmlConvert_Overflow", XmlConvert.ToString(value), "UInt32"));
			}
			return (uint)value;
		}

		protected static DateTime UntypedAtomicToDateTime(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.AllXsd);
		}

		protected static DateTimeOffset UntypedAtomicToDateTimeOffset(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.AllXsd);
		}
	}
	internal class XmlNumeric10Converter : XmlBaseConverter
	{
		protected XmlNumeric10Converter(XmlSchemaType schemaType)
			: base(schemaType)
		{
		}

		public static XmlValueConverter Create(XmlSchemaType schemaType)
		{
			return new XmlNumeric10Converter(schemaType);
		}

		public override decimal ToDecimal(decimal value)
		{
			return value;
		}

		public override decimal ToDecimal(int value)
		{
			return value;
		}

		public override decimal ToDecimal(long value)
		{
			return value;
		}

		public override decimal ToDecimal(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (base.TypeCode == XmlTypeCode.Decimal)
			{
				return XmlConvert.ToDecimal(value);
			}
			return XmlConvert.ToInteger(value);
		}

		public override decimal ToDecimal(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.DecimalType)
			{
				return (decimal)value;
			}
			if (type == XmlBaseConverter.Int32Type)
			{
				return (int)value;
			}
			if (type == XmlBaseConverter.Int64Type)
			{
				return (long)value;
			}
			if (type == XmlBaseConverter.StringType)
			{
				return ToDecimal((string)value);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return (decimal)((XmlAtomicValue)value).ValueAs(XmlBaseConverter.DecimalType);
			}
			return (decimal)ChangeTypeWildcardDestination(value, XmlBaseConverter.DecimalType, null);
		}

		public override int ToInt32(decimal value)
		{
			return XmlBaseConverter.DecimalToInt32(value);
		}

		public override int ToInt32(int value)
		{
			return value;
		}

		public override int ToInt32(long value)
		{
			return XmlBaseConverter.Int64ToInt32(value);
		}

		public override int ToInt32(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (base.TypeCode == XmlTypeCode.Decimal)
			{
				return XmlBaseConverter.DecimalToInt32(XmlConvert.ToDecimal(value));
			}
			return XmlConvert.ToInt32(value);
		}

		public override int ToInt32(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.DecimalType)
			{
				return XmlBaseConverter.DecimalToInt32((decimal)value);
			}
			if (type == XmlBaseConverter.Int32Type)
			{
				return (int)value;
			}
			if (type == XmlBaseConverter.Int64Type)
			{
				return XmlBaseConverter.Int64ToInt32((long)value);
			}
			if (type == XmlBaseConverter.StringType)
			{
				return ToInt32((string)value);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsInt;
			}
			return (int)ChangeTypeWildcardDestination(value, XmlBaseConverter.Int32Type, null);
		}

		public override long ToInt64(decimal value)
		{
			return XmlBaseConverter.DecimalToInt64(value);
		}

		public override long ToInt64(int value)
		{
			return value;
		}

		public override long ToInt64(long value)
		{
			return value;
		}

		public override long ToInt64(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (base.TypeCode == XmlTypeCode.Decimal)
			{
				return XmlBaseConverter.DecimalToInt64(XmlConvert.ToDecimal(value));
			}
			return XmlConvert.ToInt64(value);
		}

		public override long ToInt64(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.DecimalType)
			{
				return XmlBaseConverter.DecimalToInt64((decimal)value);
			}
			if (type == XmlBaseConverter.Int32Type)
			{
				return (int)value;
			}
			if (type == XmlBaseConverter.Int64Type)
			{
				return (long)value;
			}
			if (type == XmlBaseConverter.StringType)
			{
				return ToInt64((string)value);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsLong;
			}
			return (long)ChangeTypeWildcardDestination(value, XmlBaseConverter.Int64Type, null);
		}

		public override string ToString(decimal value)
		{
			if (base.TypeCode == XmlTypeCode.Decimal)
			{
				return XmlConvert.ToString(value);
			}
			return XmlConvert.ToString(decimal.Truncate(value));
		}

		public override string ToString(int value)
		{
			return XmlConvert.ToString(value);
		}

		public override string ToString(long value)
		{
			return XmlConvert.ToString(value);
		}

		public override string ToString(string value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return value;
		}

		public override string ToString(object value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.DecimalType)
			{
				return ToString((decimal)value);
			}
			if (type == XmlBaseConverter.Int32Type)
			{
				return XmlConvert.ToString((int)value);
			}
			if (type == XmlBaseConverter.Int64Type)
			{
				return XmlConvert.ToString((long)value);
			}
			if (type == XmlBaseConverter.StringType)
			{
				return (string)value;
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).Value;
			}
			return (string)ChangeTypeWildcardDestination(value, XmlBaseConverter.StringType, nsResolver);
		}

		public override object ChangeType(decimal value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DecimalType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.Int32Type)
			{
				return XmlBaseConverter.DecimalToInt32(value);
			}
			if (destinationType == XmlBaseConverter.Int64Type)
			{
				return XmlBaseConverter.DecimalToInt64(value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(int value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DecimalType)
			{
				return (decimal)value;
			}
			if (destinationType == XmlBaseConverter.Int32Type)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.Int64Type)
			{
				return (long)value;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToString(value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(long value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DecimalType)
			{
				return (decimal)value;
			}
			if (destinationType == XmlBaseConverter.Int32Type)
			{
				return XmlBaseConverter.Int64ToInt32(value);
			}
			if (destinationType == XmlBaseConverter.Int64Type)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToString(value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(string value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DecimalType)
			{
				return ToDecimal(value);
			}
			if (destinationType == XmlBaseConverter.Int32Type)
			{
				return ToInt32(value);
			}
			if (destinationType == XmlBaseConverter.Int64Type)
			{
				return ToInt64(value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeTypeWildcardSource(value, destinationType, nsResolver);
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			Type type = value.GetType();
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DecimalType)
			{
				return ToDecimal(value);
			}
			if (destinationType == XmlBaseConverter.Int32Type)
			{
				return ToInt32(value);
			}
			if (destinationType == XmlBaseConverter.Int64Type)
			{
				return ToInt64(value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value, nsResolver);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				if (type == XmlBaseConverter.DecimalType)
				{
					return new XmlAtomicValue(base.SchemaType, value);
				}
				if (type == XmlBaseConverter.Int32Type)
				{
					return new XmlAtomicValue(base.SchemaType, (int)value);
				}
				if (type == XmlBaseConverter.Int64Type)
				{
					return new XmlAtomicValue(base.SchemaType, (long)value);
				}
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				if (type == XmlBaseConverter.DecimalType)
				{
					return new XmlAtomicValue(base.SchemaType, value);
				}
				if (type == XmlBaseConverter.Int32Type)
				{
					return new XmlAtomicValue(base.SchemaType, (int)value);
				}
				if (type == XmlBaseConverter.Int64Type)
				{
					return new XmlAtomicValue(base.SchemaType, (long)value);
				}
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			if (destinationType == XmlBaseConverter.ByteType)
			{
				return XmlBaseConverter.Int32ToByte(ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.Int16Type)
			{
				return XmlBaseConverter.Int32ToInt16(ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.SByteType)
			{
				return XmlBaseConverter.Int32ToSByte(ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.UInt16Type)
			{
				return XmlBaseConverter.Int32ToUInt16(ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.UInt32Type)
			{
				return XmlBaseConverter.Int64ToUInt32(ToInt64(value));
			}
			if (destinationType == XmlBaseConverter.UInt64Type)
			{
				return XmlBaseConverter.DecimalToUInt64(ToDecimal(value));
			}
			if (type == XmlBaseConverter.ByteType)
			{
				return ChangeType((byte)value, destinationType);
			}
			if (type == XmlBaseConverter.Int16Type)
			{
				return ChangeType((short)value, destinationType);
			}
			if (type == XmlBaseConverter.SByteType)
			{
				return ChangeType((sbyte)value, destinationType);
			}
			if (type == XmlBaseConverter.UInt16Type)
			{
				return ChangeType((ushort)value, destinationType);
			}
			if (type == XmlBaseConverter.UInt32Type)
			{
				return ChangeType((uint)value, destinationType);
			}
			if (type == XmlBaseConverter.UInt64Type)
			{
				return ChangeType((decimal)(ulong)value, destinationType);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		private object ChangeTypeWildcardDestination(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			Type type = value.GetType();
			if (type == XmlBaseConverter.ByteType)
			{
				return ChangeType((byte)value, destinationType);
			}
			if (type == XmlBaseConverter.Int16Type)
			{
				return ChangeType((short)value, destinationType);
			}
			if (type == XmlBaseConverter.SByteType)
			{
				return ChangeType((sbyte)value, destinationType);
			}
			if (type == XmlBaseConverter.UInt16Type)
			{
				return ChangeType((ushort)value, destinationType);
			}
			if (type == XmlBaseConverter.UInt32Type)
			{
				return ChangeType((uint)value, destinationType);
			}
			if (type == XmlBaseConverter.UInt64Type)
			{
				return ChangeType((decimal)(ulong)value, destinationType);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		private object ChangeTypeWildcardSource(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (destinationType == XmlBaseConverter.ByteType)
			{
				return XmlBaseConverter.Int32ToByte(ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.Int16Type)
			{
				return XmlBaseConverter.Int32ToInt16(ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.SByteType)
			{
				return XmlBaseConverter.Int32ToSByte(ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.UInt16Type)
			{
				return XmlBaseConverter.Int32ToUInt16(ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.UInt32Type)
			{
				return XmlBaseConverter.Int64ToUInt32(ToInt64(value));
			}
			if (destinationType == XmlBaseConverter.UInt64Type)
			{
				return XmlBaseConverter.DecimalToUInt64(ToDecimal(value));
			}
			return ChangeListType(value, destinationType, nsResolver);
		}
	}
	internal class XmlNumeric2Converter : XmlBaseConverter
	{
		protected XmlNumeric2Converter(XmlSchemaType schemaType)
			: base(schemaType)
		{
		}

		public static XmlValueConverter Create(XmlSchemaType schemaType)
		{
			return new XmlNumeric2Converter(schemaType);
		}

		public override double ToDouble(double value)
		{
			return value;
		}

		public override double ToDouble(float value)
		{
			return value;
		}

		public override double ToDouble(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (base.TypeCode == XmlTypeCode.Float)
			{
				return XmlConvert.ToSingle(value);
			}
			return XmlConvert.ToDouble(value);
		}

		public override double ToDouble(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.DoubleType)
			{
				return (double)value;
			}
			if (type == XmlBaseConverter.SingleType)
			{
				return (float)value;
			}
			if (type == XmlBaseConverter.StringType)
			{
				return ToDouble((string)value);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsDouble;
			}
			return (double)ChangeListType(value, XmlBaseConverter.DoubleType, null);
		}

		public override float ToSingle(double value)
		{
			return (float)value;
		}

		public override float ToSingle(float value)
		{
			return value;
		}

		public override float ToSingle(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (base.TypeCode == XmlTypeCode.Float)
			{
				return XmlConvert.ToSingle(value);
			}
			return (float)XmlConvert.ToDouble(value);
		}

		public override float ToSingle(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.DoubleType)
			{
				return (float)(double)value;
			}
			if (type == XmlBaseConverter.SingleType)
			{
				return (float)value;
			}
			if (type == XmlBaseConverter.StringType)
			{
				return ToSingle((string)value);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return (float)((XmlAtomicValue)value).ValueAs(XmlBaseConverter.SingleType);
			}
			return (float)ChangeListType(value, XmlBaseConverter.SingleType, null);
		}

		public override string ToString(double value)
		{
			if (base.TypeCode == XmlTypeCode.Float)
			{
				return XmlConvert.ToString(ToSingle(value));
			}
			return XmlConvert.ToString(value);
		}

		public override string ToString(float value)
		{
			if (base.TypeCode == XmlTypeCode.Float)
			{
				return XmlConvert.ToString(value);
			}
			return XmlConvert.ToString((double)value);
		}

		public override string ToString(string value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return value;
		}

		public override string ToString(object value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.DoubleType)
			{
				return ToString((double)value);
			}
			if (type == XmlBaseConverter.SingleType)
			{
				return ToString((float)value);
			}
			if (type == XmlBaseConverter.StringType)
			{
				return (string)value;
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).Value;
			}
			return (string)ChangeListType(value, XmlBaseConverter.StringType, nsResolver);
		}

		public override object ChangeType(double value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DoubleType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.SingleType)
			{
				return (float)value;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeListType(value, destinationType, null);
		}

		public override object ChangeType(float value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DoubleType)
			{
				return (double)value;
			}
			if (destinationType == XmlBaseConverter.SingleType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeListType(value, destinationType, null);
		}

		public override object ChangeType(string value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DoubleType)
			{
				return ToDouble(value);
			}
			if (destinationType == XmlBaseConverter.SingleType)
			{
				return ToSingle(value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			Type type = value.GetType();
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DoubleType)
			{
				return ToDouble(value);
			}
			if (destinationType == XmlBaseConverter.SingleType)
			{
				return ToSingle(value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value, nsResolver);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				if (type == XmlBaseConverter.DoubleType)
				{
					return new XmlAtomicValue(base.SchemaType, (double)value);
				}
				if (type == XmlBaseConverter.SingleType)
				{
					return new XmlAtomicValue(base.SchemaType, value);
				}
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				if (type == XmlBaseConverter.DoubleType)
				{
					return new XmlAtomicValue(base.SchemaType, (double)value);
				}
				if (type == XmlBaseConverter.SingleType)
				{
					return new XmlAtomicValue(base.SchemaType, value);
				}
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			return ChangeListType(value, destinationType, nsResolver);
		}
	}
	internal class XmlDateTimeConverter : XmlBaseConverter
	{
		protected XmlDateTimeConverter(XmlSchemaType schemaType)
			: base(schemaType)
		{
		}

		public static XmlValueConverter Create(XmlSchemaType schemaType)
		{
			return new XmlDateTimeConverter(schemaType);
		}

		public override DateTime ToDateTime(DateTime value)
		{
			return value;
		}

		public override DateTime ToDateTime(DateTimeOffset value)
		{
			return XmlBaseConverter.DateTimeOffsetToDateTime(value);
		}

		public override DateTime ToDateTime(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return base.TypeCode switch
			{
				XmlTypeCode.Date => XmlBaseConverter.StringToDate(value), 
				XmlTypeCode.Time => XmlBaseConverter.StringToTime(value), 
				XmlTypeCode.GDay => XmlBaseConverter.StringToGDay(value), 
				XmlTypeCode.GMonth => XmlBaseConverter.StringToGMonth(value), 
				XmlTypeCode.GMonthDay => XmlBaseConverter.StringToGMonthDay(value), 
				XmlTypeCode.GYear => XmlBaseConverter.StringToGYear(value), 
				XmlTypeCode.GYearMonth => XmlBaseConverter.StringToGYearMonth(value), 
				_ => XmlBaseConverter.StringToDateTime(value), 
			};
		}

		public override DateTime ToDateTime(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.DateTimeType)
			{
				return (DateTime)value;
			}
			if (type == XmlBaseConverter.DateTimeOffsetType)
			{
				return ToDateTime((DateTimeOffset)value);
			}
			if (type == XmlBaseConverter.StringType)
			{
				return ToDateTime((string)value);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsDateTime;
			}
			return (DateTime)ChangeListType(value, XmlBaseConverter.DateTimeType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(DateTime value)
		{
			return new DateTimeOffset(value);
		}

		public override DateTimeOffset ToDateTimeOffset(DateTimeOffset value)
		{
			return value;
		}

		public override DateTimeOffset ToDateTimeOffset(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return base.TypeCode switch
			{
				XmlTypeCode.Date => XmlBaseConverter.StringToDateOffset(value), 
				XmlTypeCode.Time => XmlBaseConverter.StringToTimeOffset(value), 
				XmlTypeCode.GDay => XmlBaseConverter.StringToGDayOffset(value), 
				XmlTypeCode.GMonth => XmlBaseConverter.StringToGMonthOffset(value), 
				XmlTypeCode.GMonthDay => XmlBaseConverter.StringToGMonthDayOffset(value), 
				XmlTypeCode.GYear => XmlBaseConverter.StringToGYearOffset(value), 
				XmlTypeCode.GYearMonth => XmlBaseConverter.StringToGYearMonthOffset(value), 
				_ => XmlBaseConverter.StringToDateTimeOffset(value), 
			};
		}

		public override DateTimeOffset ToDateTimeOffset(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.DateTimeType)
			{
				return ToDateTimeOffset((DateTime)value);
			}
			if (type == XmlBaseConverter.DateTimeOffsetType)
			{
				return (DateTimeOffset)value;
			}
			if (type == XmlBaseConverter.StringType)
			{
				return ToDateTimeOffset((string)value);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsDateTime;
			}
			return (DateTimeOffset)ChangeListType(value, XmlBaseConverter.DateTimeOffsetType, null);
		}

		public override string ToString(DateTime value)
		{
			return base.TypeCode switch
			{
				XmlTypeCode.Date => XmlBaseConverter.DateToString(value), 
				XmlTypeCode.Time => XmlBaseConverter.TimeToString(value), 
				XmlTypeCode.GDay => XmlBaseConverter.GDayToString(value), 
				XmlTypeCode.GMonth => XmlBaseConverter.GMonthToString(value), 
				XmlTypeCode.GMonthDay => XmlBaseConverter.GMonthDayToString(value), 
				XmlTypeCode.GYear => XmlBaseConverter.GYearToString(value), 
				XmlTypeCode.GYearMonth => XmlBaseConverter.GYearMonthToString(value), 
				_ => XmlBaseConverter.DateTimeToString(value), 
			};
		}

		public override string ToString(DateTimeOffset value)
		{
			return base.TypeCode switch
			{
				XmlTypeCode.Date => XmlBaseConverter.DateOffsetToString(value), 
				XmlTypeCode.Time => XmlBaseConverter.TimeOffsetToString(value), 
				XmlTypeCode.GDay => XmlBaseConverter.GDayOffsetToString(value), 
				XmlTypeCode.GMonth => XmlBaseConverter.GMonthOffsetToString(value), 
				XmlTypeCode.GMonthDay => XmlBaseConverter.GMonthDayOffsetToString(value), 
				XmlTypeCode.GYear => XmlBaseConverter.GYearOffsetToString(value), 
				XmlTypeCode.GYearMonth => XmlBaseConverter.GYearMonthOffsetToString(value), 
				_ => XmlBaseConverter.DateTimeOffsetToString(value), 
			};
		}

		public override string ToString(string value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return value;
		}

		public override string ToString(object value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.DateTimeType)
			{
				return ToString((DateTime)value);
			}
			if (type == XmlBaseConverter.DateTimeOffsetType)
			{
				return ToString((DateTimeOffset)value);
			}
			if (type == XmlBaseConverter.StringType)
			{
				return (string)value;
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).Value;
			}
			return (string)ChangeListType(value, XmlBaseConverter.StringType, nsResolver);
		}

		public override object ChangeType(DateTime value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DateTimeType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.DateTimeOffsetType)
			{
				return ToDateTimeOffset(value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeListType(value, destinationType, null);
		}

		public override object ChangeType(DateTimeOffset value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DateTimeType)
			{
				return ToDateTime(value);
			}
			if (destinationType == XmlBaseConverter.DateTimeOffsetType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeListType(value, destinationType, null);
		}

		public override object ChangeType(string value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DateTimeType)
			{
				return ToDateTime(value);
			}
			if (destinationType == XmlBaseConverter.DateTimeOffsetType)
			{
				return ToDateTimeOffset(value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			Type type = value.GetType();
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.DateTimeType)
			{
				return ToDateTime(value);
			}
			if (destinationType == XmlBaseConverter.DateTimeOffsetType)
			{
				return ToDateTimeOffset(value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value, nsResolver);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				if (type == XmlBaseConverter.DateTimeType)
				{
					return new XmlAtomicValue(base.SchemaType, (DateTime)value);
				}
				if (type == XmlBaseConverter.DateTimeOffsetType)
				{
					return new XmlAtomicValue(base.SchemaType, (DateTimeOffset)value);
				}
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				if (type == XmlBaseConverter.DateTimeType)
				{
					return new XmlAtomicValue(base.SchemaType, (DateTime)value);
				}
				if (type == XmlBaseConverter.DateTimeOffsetType)
				{
					return new XmlAtomicValue(base.SchemaType, (DateTimeOffset)value);
				}
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			return ChangeListType(value, destinationType, nsResolver);
		}
	}
	internal class XmlBooleanConverter : XmlBaseConverter
	{
		protected XmlBooleanConverter(XmlSchemaType schemaType)
			: base(schemaType)
		{
		}

		public static XmlValueConverter Create(XmlSchemaType schemaType)
		{
			return new XmlBooleanConverter(schemaType);
		}

		public override bool ToBoolean(bool value)
		{
			return value;
		}

		public override bool ToBoolean(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return XmlConvert.ToBoolean(value);
		}

		public override bool ToBoolean(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.BooleanType)
			{
				return (bool)value;
			}
			if (type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToBoolean((string)value);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsBoolean;
			}
			return (bool)ChangeListType(value, XmlBaseConverter.BooleanType, null);
		}

		public override string ToString(bool value)
		{
			return XmlConvert.ToString(value);
		}

		public override string ToString(string value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return value;
		}

		public override string ToString(object value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.BooleanType)
			{
				return XmlConvert.ToString((bool)value);
			}
			if (type == XmlBaseConverter.StringType)
			{
				return (string)value;
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).Value;
			}
			return (string)ChangeListType(value, XmlBaseConverter.StringType, nsResolver);
		}

		public override object ChangeType(bool value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.BooleanType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToString(value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeListType(value, destinationType, null);
		}

		public override object ChangeType(string value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.BooleanType)
			{
				return XmlConvert.ToBoolean(value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			Type type = value.GetType();
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.BooleanType)
			{
				return ToBoolean(value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value, nsResolver);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				if (type == XmlBaseConverter.BooleanType)
				{
					return new XmlAtomicValue(base.SchemaType, (bool)value);
				}
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				if (type == XmlBaseConverter.BooleanType)
				{
					return new XmlAtomicValue(base.SchemaType, (bool)value);
				}
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			return ChangeListType(value, destinationType, nsResolver);
		}
	}
	internal class XmlMiscConverter : XmlBaseConverter
	{
		protected XmlMiscConverter(XmlSchemaType schemaType)
			: base(schemaType)
		{
		}

		public static XmlValueConverter Create(XmlSchemaType schemaType)
		{
			return new XmlMiscConverter(schemaType);
		}

		public override string ToString(string value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return value;
		}

		public override string ToString(object value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.ByteArrayType)
			{
				switch (base.TypeCode)
				{
				case XmlTypeCode.Base64Binary:
					return XmlBaseConverter.Base64BinaryToString((byte[])value);
				case XmlTypeCode.HexBinary:
					return XmlConvert.ToBinHexString((byte[])value);
				}
			}
			if (type == XmlBaseConverter.StringType)
			{
				return (string)value;
			}
			if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.UriType) && base.TypeCode == XmlTypeCode.AnyUri)
			{
				return XmlBaseConverter.AnyUriToString((Uri)value);
			}
			if (type == XmlBaseConverter.TimeSpanType)
			{
				switch (base.TypeCode)
				{
				case XmlTypeCode.DayTimeDuration:
					return XmlBaseConverter.DayTimeDurationToString((TimeSpan)value);
				case XmlTypeCode.Duration:
					return XmlBaseConverter.DurationToString((TimeSpan)value);
				case XmlTypeCode.YearMonthDuration:
					return XmlBaseConverter.YearMonthDurationToString((TimeSpan)value);
				}
			}
			if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.XmlQualifiedNameType))
			{
				switch (base.TypeCode)
				{
				case XmlTypeCode.Notation:
					return XmlBaseConverter.QNameToString((XmlQualifiedName)value, nsResolver);
				case XmlTypeCode.QName:
					return XmlBaseConverter.QNameToString((XmlQualifiedName)value, nsResolver);
				}
			}
			return (string)ChangeTypeWildcardDestination(value, XmlBaseConverter.StringType, nsResolver);
		}

		public override object ChangeType(string value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.ByteArrayType)
			{
				switch (base.TypeCode)
				{
				case XmlTypeCode.Base64Binary:
					return XmlBaseConverter.StringToBase64Binary(value);
				case XmlTypeCode.HexBinary:
					return XmlBaseConverter.StringToHexBinary(value);
				}
			}
			if (destinationType == XmlBaseConverter.XmlQualifiedNameType)
			{
				switch (base.TypeCode)
				{
				case XmlTypeCode.Notation:
					return XmlBaseConverter.StringToQName(value, nsResolver);
				case XmlTypeCode.QName:
					return XmlBaseConverter.StringToQName(value, nsResolver);
				}
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.TimeSpanType)
			{
				switch (base.TypeCode)
				{
				case XmlTypeCode.DayTimeDuration:
					return XmlBaseConverter.StringToDayTimeDuration(value);
				case XmlTypeCode.Duration:
					return XmlBaseConverter.StringToDuration(value);
				case XmlTypeCode.YearMonthDuration:
					return XmlBaseConverter.StringToYearMonthDuration(value);
				}
			}
			if (destinationType == XmlBaseConverter.UriType && base.TypeCode == XmlTypeCode.AnyUri)
			{
				return XmlConvert.ToUri(value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value, nsResolver);
			}
			return ChangeTypeWildcardSource(value, destinationType, nsResolver);
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			Type type = value.GetType();
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.ByteArrayType)
			{
				if (type == XmlBaseConverter.ByteArrayType)
				{
					switch (base.TypeCode)
					{
					case XmlTypeCode.Base64Binary:
						return (byte[])value;
					case XmlTypeCode.HexBinary:
						return (byte[])value;
					}
				}
				if (type == XmlBaseConverter.StringType)
				{
					switch (base.TypeCode)
					{
					case XmlTypeCode.Base64Binary:
						return XmlBaseConverter.StringToBase64Binary((string)value);
					case XmlTypeCode.HexBinary:
						return XmlBaseConverter.StringToHexBinary((string)value);
					}
				}
			}
			if (destinationType == XmlBaseConverter.XmlQualifiedNameType)
			{
				if (type == XmlBaseConverter.StringType)
				{
					switch (base.TypeCode)
					{
					case XmlTypeCode.Notation:
						return XmlBaseConverter.StringToQName((string)value, nsResolver);
					case XmlTypeCode.QName:
						return XmlBaseConverter.StringToQName((string)value, nsResolver);
					}
				}
				if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.XmlQualifiedNameType))
				{
					switch (base.TypeCode)
					{
					case XmlTypeCode.Notation:
						return (XmlQualifiedName)value;
					case XmlTypeCode.QName:
						return (XmlQualifiedName)value;
					}
				}
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value, nsResolver);
			}
			if (destinationType == XmlBaseConverter.TimeSpanType)
			{
				if (type == XmlBaseConverter.StringType)
				{
					switch (base.TypeCode)
					{
					case XmlTypeCode.DayTimeDuration:
						return XmlBaseConverter.StringToDayTimeDuration((string)value);
					case XmlTypeCode.Duration:
						return XmlBaseConverter.StringToDuration((string)value);
					case XmlTypeCode.YearMonthDuration:
						return XmlBaseConverter.StringToYearMonthDuration((string)value);
					}
				}
				if (type == XmlBaseConverter.TimeSpanType)
				{
					switch (base.TypeCode)
					{
					case XmlTypeCode.DayTimeDuration:
						return (TimeSpan)value;
					case XmlTypeCode.Duration:
						return (TimeSpan)value;
					case XmlTypeCode.YearMonthDuration:
						return (TimeSpan)value;
					}
				}
			}
			if (destinationType == XmlBaseConverter.UriType)
			{
				if (type == XmlBaseConverter.StringType && base.TypeCode == XmlTypeCode.AnyUri)
				{
					return XmlConvert.ToUri((string)value);
				}
				if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.UriType) && base.TypeCode == XmlTypeCode.AnyUri)
				{
					return (Uri)value;
				}
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				if (type == XmlBaseConverter.ByteArrayType)
				{
					switch (base.TypeCode)
					{
					case XmlTypeCode.Base64Binary:
						return new XmlAtomicValue(base.SchemaType, value);
					case XmlTypeCode.HexBinary:
						return new XmlAtomicValue(base.SchemaType, value);
					}
				}
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value, nsResolver);
				}
				if (type == XmlBaseConverter.TimeSpanType)
				{
					switch (base.TypeCode)
					{
					case XmlTypeCode.DayTimeDuration:
						return new XmlAtomicValue(base.SchemaType, value);
					case XmlTypeCode.Duration:
						return new XmlAtomicValue(base.SchemaType, value);
					case XmlTypeCode.YearMonthDuration:
						return new XmlAtomicValue(base.SchemaType, value);
					}
				}
				if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.UriType) && base.TypeCode == XmlTypeCode.AnyUri)
				{
					return new XmlAtomicValue(base.SchemaType, value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
				if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.XmlQualifiedNameType))
				{
					switch (base.TypeCode)
					{
					case XmlTypeCode.Notation:
						return new XmlAtomicValue(base.SchemaType, value, nsResolver);
					case XmlTypeCode.QName:
						return new XmlAtomicValue(base.SchemaType, value, nsResolver);
					}
				}
			}
			if (destinationType == XmlBaseConverter.XPathItemType && type == XmlBaseConverter.XmlAtomicValueType)
			{
				return (XmlAtomicValue)value;
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return (XPathItem)ChangeType(value, XmlBaseConverter.XmlAtomicValueType, nsResolver);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAs(destinationType, nsResolver);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		private object ChangeTypeWildcardDestination(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAs(destinationType, nsResolver);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		private object ChangeTypeWildcardSource(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return (XPathItem)ChangeType(value, XmlBaseConverter.XmlAtomicValueType, nsResolver);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}
	}
	internal class XmlStringConverter : XmlBaseConverter
	{
		protected XmlStringConverter(XmlSchemaType schemaType)
			: base(schemaType)
		{
		}

		public static XmlValueConverter Create(XmlSchemaType schemaType)
		{
			return new XmlStringConverter(schemaType);
		}

		public override string ToString(string value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return value;
		}

		public override string ToString(object value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.StringType)
			{
				return (string)value;
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).Value;
			}
			return (string)ChangeListType(value, XmlBaseConverter.StringType, nsResolver);
		}

		public override object ChangeType(string value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return value;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			Type type = value.GetType();
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value, nsResolver);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			return ChangeListType(value, destinationType, nsResolver);
		}
	}
	internal class XmlListConverter : XmlBaseConverter
	{
		protected XmlValueConverter atomicConverter;

		protected XmlListConverter(XmlBaseConverter atomicConverter)
			: base(atomicConverter)
		{
			this.atomicConverter = atomicConverter;
		}

		protected XmlListConverter(XmlBaseConverter atomicConverter, Type clrTypeDefault)
			: base(atomicConverter, clrTypeDefault)
		{
			this.atomicConverter = atomicConverter;
		}

		protected XmlListConverter(XmlSchemaType schemaType)
			: base(schemaType)
		{
		}

		public static XmlValueConverter Create(XmlValueConverter atomicConverter)
		{
			if (atomicConverter == XmlUntypedConverter.Untyped)
			{
				return XmlUntypedConverter.UntypedList;
			}
			if (atomicConverter == XmlAnyConverter.Item)
			{
				return XmlAnyListConverter.ItemList;
			}
			if (atomicConverter == XmlAnyConverter.AnyAtomic)
			{
				return XmlAnyListConverter.AnyAtomicList;
			}
			return new XmlListConverter((XmlBaseConverter)atomicConverter);
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		protected override object ChangeListType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			Type type = value.GetType();
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (!(value is IEnumerable) || !IsListType(destinationType))
			{
				throw CreateInvalidClrMappingException(type, destinationType);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				if (type == XmlBaseConverter.StringType)
				{
					return value;
				}
				return ListAsString((IEnumerable)value, nsResolver);
			}
			if (type == XmlBaseConverter.StringType)
			{
				value = StringAsList((string)value);
			}
			if (destinationType.IsArray)
			{
				Type elementType = destinationType.GetElementType();
				if (elementType == XmlBaseConverter.ObjectType)
				{
					return ToArray<object>(value, nsResolver);
				}
				if (type == destinationType)
				{
					return value;
				}
				if (elementType == XmlBaseConverter.BooleanType)
				{
					return ToArray<bool>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.ByteType)
				{
					return ToArray<byte>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.ByteArrayType)
				{
					return ToArray<byte[]>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.DateTimeType)
				{
					return ToArray<DateTime>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.DateTimeOffsetType)
				{
					return ToArray<DateTimeOffset>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.DecimalType)
				{
					return ToArray<decimal>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.DoubleType)
				{
					return ToArray<double>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.Int16Type)
				{
					return ToArray<short>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.Int32Type)
				{
					return ToArray<int>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.Int64Type)
				{
					return ToArray<long>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.SByteType)
				{
					return ToArray<sbyte>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.SingleType)
				{
					return ToArray<float>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.StringType)
				{
					return ToArray<string>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.TimeSpanType)
				{
					return ToArray<TimeSpan>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.UInt16Type)
				{
					return ToArray<ushort>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.UInt32Type)
				{
					return ToArray<uint>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.UInt64Type)
				{
					return ToArray<ulong>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.UriType)
				{
					return ToArray<Uri>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.XmlAtomicValueType)
				{
					return ToArray<XmlAtomicValue>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.XmlQualifiedNameType)
				{
					return ToArray<XmlQualifiedName>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.XPathItemType)
				{
					return ToArray<XPathItem>(value, nsResolver);
				}
				if (elementType == XmlBaseConverter.XPathNavigatorType)
				{
					return ToArray<XPathNavigator>(value, nsResolver);
				}
				throw CreateInvalidClrMappingException(type, destinationType);
			}
			if (type == base.DefaultClrType && type != XmlBaseConverter.ObjectArrayType)
			{
				return value;
			}
			return ToList(value, nsResolver);
		}

		private bool IsListType(Type type)
		{
			if (type == XmlBaseConverter.IListType || type == XmlBaseConverter.ICollectionType || type == XmlBaseConverter.IEnumerableType || type == XmlBaseConverter.StringType)
			{
				return true;
			}
			return type.IsArray;
		}

		private T[] ToArray<T>(object list, IXmlNamespaceResolver nsResolver)
		{
			if (list is IList list2)
			{
				T[] array = new T[list2.Count];
				for (int i = 0; i < list2.Count; i++)
				{
					array[i] = (T)atomicConverter.ChangeType(list2[i], typeof(T), nsResolver);
				}
				return array;
			}
			IEnumerable enumerable = list as IEnumerable;
			List<T> list3 = new List<T>();
			foreach (object item in enumerable)
			{
				list3.Add((T)atomicConverter.ChangeType(item, typeof(T), nsResolver));
			}
			return list3.ToArray();
		}

		private IList ToList(object list, IXmlNamespaceResolver nsResolver)
		{
			if (list is IList list2)
			{
				object[] array = new object[list2.Count];
				for (int i = 0; i < list2.Count; i++)
				{
					array[i] = atomicConverter.ChangeType(list2[i], XmlBaseConverter.ObjectType, nsResolver);
				}
				return array;
			}
			IEnumerable enumerable = list as IEnumerable;
			List<object> list3 = new List<object>();
			foreach (object item in enumerable)
			{
				list3.Add(atomicConverter.ChangeType(item, XmlBaseConverter.ObjectType, nsResolver));
			}
			return list3;
		}

		private List<string> StringAsList(string value)
		{
			return new List<string>(XmlConvert.SplitString(value));
		}

		private string ListAsString(IEnumerable list, IXmlNamespaceResolver nsResolver)
		{
			StringBuilder stringBuilder = new StringBuilder();
			foreach (object item in list)
			{
				if (stringBuilder.Length != 0)
				{
					stringBuilder.Append(' ');
				}
				stringBuilder.Append(atomicConverter.ToString(item, nsResolver));
			}
			return stringBuilder.ToString();
		}

		private new Exception CreateInvalidClrMappingException(Type sourceType, Type destinationType)
		{
			if (sourceType == destinationType)
			{
				return new InvalidCastException(Res.GetString("XmlConvert_TypeListBadMapping", base.XmlTypeName, sourceType.Name));
			}
			return new InvalidCastException(Res.GetString("XmlConvert_TypeListBadMapping2", base.XmlTypeName, sourceType.Name, destinationType.Name));
		}
	}
	internal class XmlUntypedConverter : XmlListConverter
	{
		private bool allowListToList;

		public static readonly XmlValueConverter Untyped = new XmlUntypedConverter(new XmlUntypedConverter(), allowListToList: false);

		public static readonly XmlValueConverter UntypedList = new XmlUntypedConverter(new XmlUntypedConverter(), allowListToList: true);

		protected XmlUntypedConverter()
			: base(DatatypeImplementation.UntypedAtomicType)
		{
		}

		protected XmlUntypedConverter(XmlUntypedConverter atomicConverter, bool allowListToList)
			: base(atomicConverter, allowListToList ? XmlBaseConverter.StringArrayType : XmlBaseConverter.StringType)
		{
			this.allowListToList = allowListToList;
		}

		public override bool ToBoolean(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return XmlConvert.ToBoolean(value);
		}

		public override bool ToBoolean(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToBoolean((string)value);
			}
			return (bool)ChangeTypeWildcardDestination(value, XmlBaseConverter.BooleanType, null);
		}

		public override DateTime ToDateTime(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return XmlBaseConverter.UntypedAtomicToDateTime(value);
		}

		public override DateTime ToDateTime(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.UntypedAtomicToDateTime((string)value);
			}
			return (DateTime)ChangeTypeWildcardDestination(value, XmlBaseConverter.DateTimeType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return XmlBaseConverter.UntypedAtomicToDateTimeOffset(value);
		}

		public override DateTimeOffset ToDateTimeOffset(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.UntypedAtomicToDateTimeOffset((string)value);
			}
			return (DateTimeOffset)ChangeTypeWildcardDestination(value, XmlBaseConverter.DateTimeOffsetType, null);
		}

		public override decimal ToDecimal(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return XmlConvert.ToDecimal(value);
		}

		public override decimal ToDecimal(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToDecimal((string)value);
			}
			return (decimal)ChangeTypeWildcardDestination(value, XmlBaseConverter.DecimalType, null);
		}

		public override double ToDouble(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return XmlConvert.ToDouble(value);
		}

		public override double ToDouble(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToDouble((string)value);
			}
			return (double)ChangeTypeWildcardDestination(value, XmlBaseConverter.DoubleType, null);
		}

		public override int ToInt32(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return XmlConvert.ToInt32(value);
		}

		public override int ToInt32(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToInt32((string)value);
			}
			return (int)ChangeTypeWildcardDestination(value, XmlBaseConverter.Int32Type, null);
		}

		public override long ToInt64(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return XmlConvert.ToInt64(value);
		}

		public override long ToInt64(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToInt64((string)value);
			}
			return (long)ChangeTypeWildcardDestination(value, XmlBaseConverter.Int64Type, null);
		}

		public override float ToSingle(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return XmlConvert.ToSingle(value);
		}

		public override float ToSingle(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToSingle((string)value);
			}
			return (float)ChangeTypeWildcardDestination(value, XmlBaseConverter.SingleType, null);
		}

		public override string ToString(bool value)
		{
			return XmlConvert.ToString(value);
		}

		public override string ToString(DateTime value)
		{
			return XmlBaseConverter.DateTimeToString(value);
		}

		public override string ToString(DateTimeOffset value)
		{
			return XmlBaseConverter.DateTimeOffsetToString(value);
		}

		public override string ToString(decimal value)
		{
			return XmlConvert.ToString(value);
		}

		public override string ToString(double value)
		{
			return XmlConvert.ToString(value);
		}

		public override string ToString(int value)
		{
			return XmlConvert.ToString(value);
		}

		public override string ToString(long value)
		{
			return XmlConvert.ToString(value);
		}

		public override string ToString(float value)
		{
			return XmlConvert.ToString(value);
		}

		public override string ToString(string value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return value;
		}

		public override string ToString(object value, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.BooleanType)
			{
				return XmlConvert.ToString((bool)value);
			}
			if (type == XmlBaseConverter.ByteType)
			{
				return XmlConvert.ToString((byte)value);
			}
			if (type == XmlBaseConverter.ByteArrayType)
			{
				return XmlBaseConverter.Base64BinaryToString((byte[])value);
			}
			if (type == XmlBaseConverter.DateTimeType)
			{
				return XmlBaseConverter.DateTimeToString((DateTime)value);
			}
			if (type == XmlBaseConverter.DateTimeOffsetType)
			{
				return XmlBaseConverter.DateTimeOffsetToString((DateTimeOffset)value);
			}
			if (type == XmlBaseConverter.DecimalType)
			{
				return XmlConvert.ToString((decimal)value);
			}
			if (type == XmlBaseConverter.DoubleType)
			{
				return XmlConvert.ToString((double)value);
			}
			if (type == XmlBaseConverter.Int16Type)
			{
				return XmlConvert.ToString((short)value);
			}
			if (type == XmlBaseConverter.Int32Type)
			{
				return XmlConvert.ToString((int)value);
			}
			if (type == XmlBaseConverter.Int64Type)
			{
				return XmlConvert.ToString((long)value);
			}
			if (type == XmlBaseConverter.SByteType)
			{
				return XmlConvert.ToString((sbyte)value);
			}
			if (type == XmlBaseConverter.SingleType)
			{
				return XmlConvert.ToString((float)value);
			}
			if (type == XmlBaseConverter.StringType)
			{
				return (string)value;
			}
			if (type == XmlBaseConverter.TimeSpanType)
			{
				return XmlBaseConverter.DurationToString((TimeSpan)value);
			}
			if (type == XmlBaseConverter.UInt16Type)
			{
				return XmlConvert.ToString((ushort)value);
			}
			if (type == XmlBaseConverter.UInt32Type)
			{
				return XmlConvert.ToString((uint)value);
			}
			if (type == XmlBaseConverter.UInt64Type)
			{
				return XmlConvert.ToString((ulong)value);
			}
			if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.UriType))
			{
				return XmlBaseConverter.AnyUriToString((Uri)value);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return (string)((XmlAtomicValue)value).ValueAs(XmlBaseConverter.StringType, nsResolver);
			}
			if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.XmlQualifiedNameType))
			{
				return XmlBaseConverter.QNameToString((XmlQualifiedName)value, nsResolver);
			}
			return (string)ChangeTypeWildcardDestination(value, XmlBaseConverter.StringType, nsResolver);
		}

		public override object ChangeType(bool value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToString(value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(DateTime value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.DateTimeToString(value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(DateTimeOffset value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.DateTimeOffsetToString(value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(decimal value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToString(value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(double value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToString(value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(int value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToString(value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(long value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToString(value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(float value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToString(value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(string value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.BooleanType)
			{
				return XmlConvert.ToBoolean(value);
			}
			if (destinationType == XmlBaseConverter.ByteType)
			{
				return XmlBaseConverter.Int32ToByte(XmlConvert.ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.ByteArrayType)
			{
				return XmlBaseConverter.StringToBase64Binary(value);
			}
			if (destinationType == XmlBaseConverter.DateTimeType)
			{
				return XmlBaseConverter.UntypedAtomicToDateTime(value);
			}
			if (destinationType == XmlBaseConverter.DateTimeOffsetType)
			{
				return XmlBaseConverter.UntypedAtomicToDateTimeOffset(value);
			}
			if (destinationType == XmlBaseConverter.DecimalType)
			{
				return XmlConvert.ToDecimal(value);
			}
			if (destinationType == XmlBaseConverter.DoubleType)
			{
				return XmlConvert.ToDouble(value);
			}
			if (destinationType == XmlBaseConverter.Int16Type)
			{
				return XmlBaseConverter.Int32ToInt16(XmlConvert.ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.Int32Type)
			{
				return XmlConvert.ToInt32(value);
			}
			if (destinationType == XmlBaseConverter.Int64Type)
			{
				return XmlConvert.ToInt64(value);
			}
			if (destinationType == XmlBaseConverter.SByteType)
			{
				return XmlBaseConverter.Int32ToSByte(XmlConvert.ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.SingleType)
			{
				return XmlConvert.ToSingle(value);
			}
			if (destinationType == XmlBaseConverter.TimeSpanType)
			{
				return XmlBaseConverter.StringToDuration(value);
			}
			if (destinationType == XmlBaseConverter.UInt16Type)
			{
				return XmlBaseConverter.Int32ToUInt16(XmlConvert.ToInt32(value));
			}
			if (destinationType == XmlBaseConverter.UInt32Type)
			{
				return XmlBaseConverter.Int64ToUInt32(XmlConvert.ToInt64(value));
			}
			if (destinationType == XmlBaseConverter.UInt64Type)
			{
				return XmlBaseConverter.DecimalToUInt64(XmlConvert.ToDecimal(value));
			}
			if (destinationType == XmlBaseConverter.UriType)
			{
				return XmlConvert.ToUri(value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.XmlQualifiedNameType)
			{
				return XmlBaseConverter.StringToQName(value, nsResolver);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, value);
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return value;
			}
			return ChangeTypeWildcardSource(value, destinationType, nsResolver);
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			Type type = value.GetType();
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.BooleanType && type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToBoolean((string)value);
			}
			if (destinationType == XmlBaseConverter.ByteType && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.Int32ToByte(XmlConvert.ToInt32((string)value));
			}
			if (destinationType == XmlBaseConverter.ByteArrayType && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.StringToBase64Binary((string)value);
			}
			if (destinationType == XmlBaseConverter.DateTimeType && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.UntypedAtomicToDateTime((string)value);
			}
			if (destinationType == XmlBaseConverter.DateTimeOffsetType && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.UntypedAtomicToDateTimeOffset((string)value);
			}
			if (destinationType == XmlBaseConverter.DecimalType && type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToDecimal((string)value);
			}
			if (destinationType == XmlBaseConverter.DoubleType && type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToDouble((string)value);
			}
			if (destinationType == XmlBaseConverter.Int16Type && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.Int32ToInt16(XmlConvert.ToInt32((string)value));
			}
			if (destinationType == XmlBaseConverter.Int32Type && type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToInt32((string)value);
			}
			if (destinationType == XmlBaseConverter.Int64Type && type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToInt64((string)value);
			}
			if (destinationType == XmlBaseConverter.SByteType && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.Int32ToSByte(XmlConvert.ToInt32((string)value));
			}
			if (destinationType == XmlBaseConverter.SingleType && type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToSingle((string)value);
			}
			if (destinationType == XmlBaseConverter.TimeSpanType && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.StringToDuration((string)value);
			}
			if (destinationType == XmlBaseConverter.UInt16Type && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.Int32ToUInt16(XmlConvert.ToInt32((string)value));
			}
			if (destinationType == XmlBaseConverter.UInt32Type && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.Int64ToUInt32(XmlConvert.ToInt64((string)value));
			}
			if (destinationType == XmlBaseConverter.UInt64Type && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.DecimalToUInt64(XmlConvert.ToDecimal((string)value));
			}
			if (destinationType == XmlBaseConverter.UriType && type == XmlBaseConverter.StringType)
			{
				return XmlConvert.ToUri((string)value);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			if (destinationType == XmlBaseConverter.XmlQualifiedNameType && type == XmlBaseConverter.StringType)
			{
				return XmlBaseConverter.StringToQName((string)value, nsResolver);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(base.SchemaType, (string)value);
				}
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
			}
			if (destinationType == XmlBaseConverter.StringType)
			{
				return ToString(value, nsResolver);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, ToString(value, nsResolver));
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, ToString(value, nsResolver));
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAs(destinationType, nsResolver);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		private object ChangeTypeWildcardDestination(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAs(destinationType, nsResolver);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		private object ChangeTypeWildcardSource(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(base.SchemaType, ToString(value, nsResolver));
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return new XmlAtomicValue(base.SchemaType, ToString(value, nsResolver));
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		protected override object ChangeListType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			Type type = value.GetType();
			if (atomicConverter == null || (!allowListToList && type != XmlBaseConverter.StringType && destinationType != XmlBaseConverter.StringType))
			{
				if (SupportsType(type))
				{
					throw new InvalidCastException(Res.GetString("XmlConvert_TypeToString", base.XmlTypeName, type.Name));
				}
				if (SupportsType(destinationType))
				{
					throw new InvalidCastException(Res.GetString("XmlConvert_TypeFromString", base.XmlTypeName, destinationType.Name));
				}
				throw CreateInvalidClrMappingException(type, destinationType);
			}
			return base.ChangeListType(value, destinationType, nsResolver);
		}

		private bool SupportsType(Type clrType)
		{
			if (clrType == XmlBaseConverter.BooleanType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.ByteType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.ByteArrayType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.DateTimeType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.DateTimeOffsetType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.DecimalType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.DoubleType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.Int16Type)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.Int32Type)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.Int64Type)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.SByteType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.SingleType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.TimeSpanType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.UInt16Type)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.UInt32Type)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.UInt64Type)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.UriType)
			{
				return true;
			}
			if (clrType == XmlBaseConverter.XmlQualifiedNameType)
			{
				return true;
			}
			return false;
		}
	}
	internal class XmlNodeConverter : XmlBaseConverter
	{
		public static readonly XmlValueConverter Node = new XmlNodeConverter();

		protected XmlNodeConverter()
			: base(XmlTypeCode.Node)
		{
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			Type type = value.GetType();
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.XPathNavigatorType && XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.XPathNavigatorType))
			{
				return (XPathNavigator)value;
			}
			if (destinationType == XmlBaseConverter.XPathItemType && XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.XPathNavigatorType))
			{
				return (XPathItem)value;
			}
			return ChangeListType(value, destinationType, nsResolver);
		}
	}
	internal class XmlAnyConverter : XmlBaseConverter
	{
		public static readonly XmlValueConverter Item = new XmlAnyConverter(XmlTypeCode.Item);

		public static readonly XmlValueConverter AnyAtomic = new XmlAnyConverter(XmlTypeCode.AnyAtomicType);

		protected XmlAnyConverter(XmlTypeCode typeCode)
			: base(typeCode)
		{
		}

		public override bool ToBoolean(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsBoolean;
			}
			return (bool)ChangeTypeWildcardDestination(value, XmlBaseConverter.BooleanType, null);
		}

		public override DateTime ToDateTime(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsDateTime;
			}
			return (DateTime)ChangeTypeWildcardDestination(value, XmlBaseConverter.DateTimeType, null);
		}

		public override DateTimeOffset ToDateTimeOffset(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return (DateTimeOffset)((XmlAtomicValue)value).ValueAs(XmlBaseConverter.DateTimeOffsetType);
			}
			return (DateTimeOffset)ChangeTypeWildcardDestination(value, XmlBaseConverter.DateTimeOffsetType, null);
		}

		public override decimal ToDecimal(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return (decimal)((XmlAtomicValue)value).ValueAs(XmlBaseConverter.DecimalType);
			}
			return (decimal)ChangeTypeWildcardDestination(value, XmlBaseConverter.DecimalType, null);
		}

		public override double ToDouble(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsDouble;
			}
			return (double)ChangeTypeWildcardDestination(value, XmlBaseConverter.DoubleType, null);
		}

		public override int ToInt32(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsInt;
			}
			return (int)ChangeTypeWildcardDestination(value, XmlBaseConverter.Int32Type, null);
		}

		public override long ToInt64(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsLong;
			}
			return (long)ChangeTypeWildcardDestination(value, XmlBaseConverter.Int64Type, null);
		}

		public override float ToSingle(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return (float)((XmlAtomicValue)value).ValueAs(XmlBaseConverter.SingleType);
			}
			return (float)ChangeTypeWildcardDestination(value, XmlBaseConverter.SingleType, null);
		}

		public override object ChangeType(bool value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean), value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(DateTime value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.DateTime), value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(DateTimeOffset value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.DateTime), value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(decimal value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(double value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double), value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(int value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int), value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(long value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Long), value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(float value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Float), value);
			}
			return ChangeTypeWildcardSource(value, destinationType, null);
		}

		public override object ChangeType(string value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), value);
			}
			return ChangeTypeWildcardSource(value, destinationType, nsResolver);
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			Type type = value.GetType();
			if (destinationType == XmlBaseConverter.ObjectType)
			{
				destinationType = base.DefaultClrType;
			}
			if (destinationType == XmlBaseConverter.BooleanType && type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsBoolean;
			}
			if (destinationType == XmlBaseConverter.DateTimeType && type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsDateTime;
			}
			if (destinationType == XmlBaseConverter.DateTimeOffsetType && type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAs(XmlBaseConverter.DateTimeOffsetType);
			}
			if (destinationType == XmlBaseConverter.DecimalType && type == XmlBaseConverter.XmlAtomicValueType)
			{
				return (decimal)((XmlAtomicValue)value).ValueAs(XmlBaseConverter.DecimalType);
			}
			if (destinationType == XmlBaseConverter.DoubleType && type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsDouble;
			}
			if (destinationType == XmlBaseConverter.Int32Type && type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsInt;
			}
			if (destinationType == XmlBaseConverter.Int64Type && type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAsLong;
			}
			if (destinationType == XmlBaseConverter.SingleType && type == XmlBaseConverter.XmlAtomicValueType)
			{
				return (float)((XmlAtomicValue)value).ValueAs(XmlBaseConverter.SingleType);
			}
			if (destinationType == XmlBaseConverter.XmlAtomicValueType)
			{
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
				if (type == XmlBaseConverter.BooleanType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean), (bool)value);
				}
				if (type == XmlBaseConverter.ByteType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.UnsignedByte), value);
				}
				if (type == XmlBaseConverter.ByteArrayType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Base64Binary), value);
				}
				if (type == XmlBaseConverter.DateTimeType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.DateTime), (DateTime)value);
				}
				if (type == XmlBaseConverter.DateTimeOffsetType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.DateTime), (DateTimeOffset)value);
				}
				if (type == XmlBaseConverter.DecimalType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), value);
				}
				if (type == XmlBaseConverter.DoubleType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double), (double)value);
				}
				if (type == XmlBaseConverter.Int16Type)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Short), value);
				}
				if (type == XmlBaseConverter.Int32Type)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Int), (int)value);
				}
				if (type == XmlBaseConverter.Int64Type)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Long), (long)value);
				}
				if (type == XmlBaseConverter.SByteType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Byte), value);
				}
				if (type == XmlBaseConverter.SingleType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Float), value);
				}
				if (type == XmlBaseConverter.StringType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), (string)value);
				}
				if (type == XmlBaseConverter.TimeSpanType)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Duration), value);
				}
				if (type == XmlBaseConverter.UInt16Type)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.UnsignedShort), value);
				}
				if (type == XmlBaseConverter.UInt32Type)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.UnsignedInt), value);
				}
				if (type == XmlBaseConverter.UInt64Type)
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.UnsignedLong), value);
				}
				if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.UriType))
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri), value);
				}
				if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.XmlQualifiedNameType))
				{
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.QName), value, nsResolver);
				}
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				if (type == XmlBaseConverter.XmlAtomicValueType)
				{
					return (XmlAtomicValue)value;
				}
				if (XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.XPathNavigatorType))
				{
					return (XPathNavigator)value;
				}
			}
			if (destinationType == XmlBaseConverter.XPathNavigatorType && XmlBaseConverter.IsDerivedFrom(type, XmlBaseConverter.XPathNavigatorType))
			{
				return ToNavigator((XPathNavigator)value);
			}
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return (XPathItem)ChangeType(value, XmlBaseConverter.XmlAtomicValueType, nsResolver);
			}
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAs(destinationType, nsResolver);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		private object ChangeTypeWildcardDestination(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType)
			{
				return ((XmlAtomicValue)value).ValueAs(destinationType, nsResolver);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		private object ChangeTypeWildcardSource(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (destinationType == XmlBaseConverter.XPathItemType)
			{
				return (XPathItem)ChangeType(value, XmlBaseConverter.XmlAtomicValueType, nsResolver);
			}
			return ChangeListType(value, destinationType, nsResolver);
		}

		private XPathNavigator ToNavigator(XPathNavigator nav)
		{
			if (base.TypeCode != XmlTypeCode.Item)
			{
				throw CreateInvalidClrMappingException(XmlBaseConverter.XPathNavigatorType, XmlBaseConverter.XPathNavigatorType);
			}
			return nav;
		}
	}
	internal class XmlAnyListConverter : XmlListConverter
	{
		public static readonly XmlValueConverter ItemList = new XmlAnyListConverter((XmlBaseConverter)XmlAnyConverter.Item);

		public static readonly XmlValueConverter AnyAtomicList = new XmlAnyListConverter((XmlBaseConverter)XmlAnyConverter.AnyAtomic);

		protected XmlAnyListConverter(XmlBaseConverter atomicConverter)
			: base(atomicConverter)
		{
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (!(value is IEnumerable) || value.GetType() == XmlBaseConverter.StringType || value.GetType() == XmlBaseConverter.ByteArrayType)
			{
				value = new object[1] { value };
			}
			return ChangeListType(value, destinationType, nsResolver);
		}
	}
	internal class XmlUnionConverter : XmlBaseConverter
	{
		private XmlValueConverter[] converters;

		private bool hasAtomicMember;

		private bool hasListMember;

		protected XmlUnionConverter(XmlSchemaType schemaType)
			: base(schemaType)
		{
			while (schemaType.DerivedBy == XmlSchemaDerivationMethod.Restriction)
			{
				schemaType = schemaType.BaseXmlSchemaType;
			}
			XmlSchemaSimpleType[] baseMemberTypes = ((XmlSchemaSimpleTypeUnion)((XmlSchemaSimpleType)schemaType).Content).BaseMemberTypes;
			converters = new XmlValueConverter[baseMemberTypes.Length];
			for (int i = 0; i < baseMemberTypes.Length; i++)
			{
				converters[i] = baseMemberTypes[i].ValueConverter;
				if (baseMemberTypes[i].Datatype.Variety == XmlSchemaDatatypeVariety.List)
				{
					hasListMember = true;
				}
				else if (baseMemberTypes[i].Datatype.Variety == XmlSchemaDatatypeVariety.Atomic)
				{
					hasAtomicMember = true;
				}
			}
		}

		public static XmlValueConverter Create(XmlSchemaType schemaType)
		{
			return new XmlUnionConverter(schemaType);
		}

		public override object ChangeType(object value, Type destinationType, IXmlNamespaceResolver nsResolver)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			Type type = value.GetType();
			if (type == XmlBaseConverter.XmlAtomicValueType && hasAtomicMember)
			{
				return ((XmlAtomicValue)value).ValueAs(destinationType, nsResolver);
			}
			if (type == XmlBaseConverter.XmlAtomicValueArrayType && hasListMember)
			{
				return XmlAnyListConverter.ItemList.ChangeType(value, destinationType, nsResolver);
			}
			if (type == XmlBaseConverter.StringType)
			{
				if (destinationType == XmlBaseConverter.StringType)
				{
					return value;
				}
				XsdSimpleValue xsdSimpleValue = (XsdSimpleValue)base.SchemaType.Datatype.ParseValue((string)value, new NameTable(), nsResolver, createAtomicValue: true);
				return xsdSimpleValue.XmlType.ValueConverter.ChangeType((string)value, destinationType, nsResolver);
			}
			throw CreateInvalidClrMappingException(type, destinationType);
		}
	}
	internal sealed class XsdBuilder : SchemaBuilder
	{
		private enum State
		{
			Root,
			Schema,
			Annotation,
			Include,
			Import,
			Element,
			Attribute,
			AttributeGroup,
			AttributeGroupRef,
			AnyAttribute,
			Group,
			GroupRef,
			All,
			Choice,
			Sequence,
			Any,
			Notation,
			SimpleType,
			ComplexType,
			ComplexContent,
			ComplexContentRestriction,
			ComplexContentExtension,
			SimpleContent,
			SimpleContentExtension,
			SimpleContentRestriction,
			SimpleTypeUnion,
			SimpleTypeList,
			SimpleTypeRestriction,
			Unique,
			Key,
			KeyRef,
			Selector,
			Field,
			MinExclusive,
			MinInclusive,
			MaxExclusive,
			MaxInclusive,
			TotalDigits,
			FractionDigits,
			Length,
			MinLength,
			MaxLength,
			Enumeration,
			Pattern,
			WhiteSpace,
			AppInfo,
			Documentation,
			Redefine
		}

		private delegate void XsdBuildFunction(XsdBuilder builder, string value);

		private delegate void XsdInitFunction(XsdBuilder builder, string value);

		private delegate void XsdEndChildFunction(XsdBuilder builder);

		private sealed class XsdAttributeEntry
		{
			public SchemaNames.Token Attribute;

			public XsdBuildFunction BuildFunc;

			public XsdAttributeEntry(SchemaNames.Token a, XsdBuildFunction build)
			{
				Attribute = a;
				BuildFunc = build;
			}
		}

		private sealed class XsdEntry
		{
			public SchemaNames.Token Name;

			public State CurrentState;

			public State[] NextStates;

			public XsdAttributeEntry[] Attributes;

			public XsdInitFunction InitFunc;

			public XsdEndChildFunction EndChildFunc;

			public bool ParseContent;

			public XsdEntry(SchemaNames.Token n, State state, State[] nextStates, XsdAttributeEntry[] attributes, XsdInitFunction init, XsdEndChildFunction end, bool parseContent)
			{
				Name = n;
				CurrentState = state;
				NextStates = nextStates;
				Attributes = attributes;
				InitFunc = init;
				EndChildFunc = end;
				ParseContent = parseContent;
			}
		}

		private class BuilderNamespaceManager : XmlNamespaceManager
		{
			private XmlNamespaceManager nsMgr;

			private XmlReader reader;

			public BuilderNamespaceManager(XmlNamespaceManager nsMgr, XmlReader reader)
			{
				this.nsMgr = nsMgr;
				this.reader = reader;
			}

			public override string LookupNamespace(string prefix)
			{
				string text = nsMgr.LookupNamespace(prefix);
				if (text == null)
				{
					text = reader.LookupNamespace(prefix);
				}
				return text;
			}
		}

		private const int STACK_INCREMENT = 10;

		private static readonly State[] SchemaElement = new State[1] { State.Schema };

		private static readonly State[] SchemaSubelements = new State[11]
		{
			State.Annotation,
			State.Include,
			State.Import,
			State.Redefine,
			State.ComplexType,
			State.SimpleType,
			State.Element,
			State.Attribute,
			State.AttributeGroup,
			State.Group,
			State.Notation
		};

		private static readonly State[] AttributeSubelements = new State[2]
		{
			State.Annotation,
			State.SimpleType
		};

		private static readonly State[] ElementSubelements = new State[6]
		{
			State.Annotation,
			State.SimpleType,
			State.ComplexType,
			State.Unique,
			State.Key,
			State.KeyRef
		};

		private static readonly State[] ComplexTypeSubelements = new State[10]
		{
			State.Annotation,
			State.SimpleContent,
			State.ComplexContent,
			State.GroupRef,
			State.All,
			State.Choice,
			State.Sequence,
			State.Attribute,
			State.AttributeGroupRef,
			State.AnyAttribute
		};

		private static readonly State[] SimpleContentSubelements = new State[3]
		{
			State.Annotation,
			State.SimpleContentRestriction,
			State.SimpleContentExtension
		};

		private static readonly State[] SimpleContentExtensionSubelements = new State[4]
		{
			State.Annotation,
			State.Attribute,
			State.AttributeGroupRef,
			State.AnyAttribute
		};

		private static readonly State[] SimpleContentRestrictionSubelements = new State[17]
		{
			State.Annotation,
			State.SimpleType,
			State.Enumeration,
			State.Length,
			State.MaxExclusive,
			State.MaxInclusive,
			State.MaxLength,
			State.MinExclusive,
			State.MinInclusive,
			State.MinLength,
			State.Pattern,
			State.TotalDigits,
			State.FractionDigits,
			State.WhiteSpace,
			State.Attribute,
			State.AttributeGroupRef,
			State.AnyAttribute
		};

		private static readonly State[] ComplexContentSubelements = new State[3]
		{
			State.Annotation,
			State.ComplexContentRestriction,
			State.ComplexContentExtension
		};

		private static readonly State[] ComplexContentExtensionSubelements = new State[8]
		{
			State.Annotation,
			State.GroupRef,
			State.All,
			State.Choice,
			State.Sequence,
			State.Attribute,
			State.AttributeGroupRef,
			State.AnyAttribute
		};

		private static readonly State[] ComplexContentRestrictionSubelements = new State[8]
		{
			State.Annotation,
			State.GroupRef,
			State.All,
			State.Choice,
			State.Sequence,
			State.Attribute,
			State.AttributeGroupRef,
			State.AnyAttribute
		};

		private static readonly State[] SimpleTypeSubelements = new State[4]
		{
			State.Annotation,
			State.SimpleTypeList,
			State.SimpleTypeRestriction,
			State.SimpleTypeUnion
		};

		private static readonly State[] SimpleTypeRestrictionSubelements = new State[14]
		{
			State.Annotation,
			State.SimpleType,
			State.Enumeration,
			State.Length,
			State.MaxExclusive,
			State.MaxInclusive,
			State.MaxLength,
			State.MinExclusive,
			State.MinInclusive,
			State.MinLength,
			State.Pattern,
			State.TotalDigits,
			State.FractionDigits,
			State.WhiteSpace
		};

		private static readonly State[] SimpleTypeListSubelements = new State[2]
		{
			State.Annotation,
			State.SimpleType
		};

		private static readonly State[] SimpleTypeUnionSubelements = new State[2]
		{
			State.Annotation,
			State.SimpleType
		};

		private static readonly State[] RedefineSubelements = new State[5]
		{
			State.Annotation,
			State.AttributeGroup,
			State.ComplexType,
			State.Group,
			State.SimpleType
		};

		private static readonly State[] AttributeGroupSubelements = new State[4]
		{
			State.Annotation,
			State.Attribute,
			State.AttributeGroupRef,
			State.AnyAttribute
		};

		private static readonly State[] GroupSubelements = new State[4]
		{
			State.Annotation,
			State.All,
			State.Choice,
			State.Sequence
		};

		private static readonly State[] AllSubelements = new State[2]
		{
			State.Annotation,
			State.Element
		};

		private static readonly State[] ChoiceSequenceSubelements = new State[6]
		{
			State.Annotation,
			State.Element,
			State.GroupRef,
			State.Choice,
			State.Sequence,
			State.Any
		};

		private static readonly State[] IdentityConstraintSubelements = new State[3]
		{
			State.Annotation,
			State.Selector,
			State.Field
		};

		private static readonly State[] AnnotationSubelements = new State[2]
		{
			State.AppInfo,
			State.Documentation
		};

		private static readonly State[] AnnotatedSubelements = new State[1] { State.Annotation };

		private static readonly XsdAttributeEntry[] SchemaAttributes = new XsdAttributeEntry[7]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaAttributeFormDefault, BuildSchema_AttributeFormDefault),
			new XsdAttributeEntry(SchemaNames.Token.SchemaElementFormDefault, BuildSchema_ElementFormDefault),
			new XsdAttributeEntry(SchemaNames.Token.SchemaTargetNamespace, BuildSchema_TargetNamespace),
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaVersion, BuildSchema_Version),
			new XsdAttributeEntry(SchemaNames.Token.SchemaFinalDefault, BuildSchema_FinalDefault),
			new XsdAttributeEntry(SchemaNames.Token.SchemaBlockDefault, BuildSchema_BlockDefault)
		};

		private static readonly XsdAttributeEntry[] AttributeAttributes = new XsdAttributeEntry[8]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaDefault, BuildAttribute_Default),
			new XsdAttributeEntry(SchemaNames.Token.SchemaFixed, BuildAttribute_Fixed),
			new XsdAttributeEntry(SchemaNames.Token.SchemaForm, BuildAttribute_Form),
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaName, BuildAttribute_Name),
			new XsdAttributeEntry(SchemaNames.Token.SchemaRef, BuildAttribute_Ref),
			new XsdAttributeEntry(SchemaNames.Token.SchemaType, BuildAttribute_Type),
			new XsdAttributeEntry(SchemaNames.Token.SchemaUse, BuildAttribute_Use)
		};

		private static readonly XsdAttributeEntry[] ElementAttributes = new XsdAttributeEntry[14]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaAbstract, BuildElement_Abstract),
			new XsdAttributeEntry(SchemaNames.Token.SchemaBlock, BuildElement_Block),
			new XsdAttributeEntry(SchemaNames.Token.SchemaDefault, BuildElement_Default),
			new XsdAttributeEntry(SchemaNames.Token.SchemaFinal, BuildElement_Final),
			new XsdAttributeEntry(SchemaNames.Token.SchemaFixed, BuildElement_Fixed),
			new XsdAttributeEntry(SchemaNames.Token.SchemaForm, BuildElement_Form),
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMaxOccurs, BuildElement_MaxOccurs),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMinOccurs, BuildElement_MinOccurs),
			new XsdAttributeEntry(SchemaNames.Token.SchemaName, BuildElement_Name),
			new XsdAttributeEntry(SchemaNames.Token.SchemaNillable, BuildElement_Nillable),
			new XsdAttributeEntry(SchemaNames.Token.SchemaRef, BuildElement_Ref),
			new XsdAttributeEntry(SchemaNames.Token.SchemaSubstitutionGroup, BuildElement_SubstitutionGroup),
			new XsdAttributeEntry(SchemaNames.Token.SchemaType, BuildElement_Type)
		};

		private static readonly XsdAttributeEntry[] ComplexTypeAttributes = new XsdAttributeEntry[6]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaAbstract, BuildComplexType_Abstract),
			new XsdAttributeEntry(SchemaNames.Token.SchemaBlock, BuildComplexType_Block),
			new XsdAttributeEntry(SchemaNames.Token.SchemaFinal, BuildComplexType_Final),
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMixed, BuildComplexType_Mixed),
			new XsdAttributeEntry(SchemaNames.Token.SchemaName, BuildComplexType_Name)
		};

		private static readonly XsdAttributeEntry[] SimpleContentAttributes = new XsdAttributeEntry[1]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id)
		};

		private static readonly XsdAttributeEntry[] SimpleContentExtensionAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaBase, BuildSimpleContentExtension_Base),
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id)
		};

		private static readonly XsdAttributeEntry[] SimpleContentRestrictionAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaBase, BuildSimpleContentRestriction_Base),
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id)
		};

		private static readonly XsdAttributeEntry[] ComplexContentAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMixed, BuildComplexContent_Mixed)
		};

		private static readonly XsdAttributeEntry[] ComplexContentExtensionAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaBase, BuildComplexContentExtension_Base),
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id)
		};

		private static readonly XsdAttributeEntry[] ComplexContentRestrictionAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaBase, BuildComplexContentRestriction_Base),
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id)
		};

		private static readonly XsdAttributeEntry[] SimpleTypeAttributes = new XsdAttributeEntry[3]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaFinal, BuildSimpleType_Final),
			new XsdAttributeEntry(SchemaNames.Token.SchemaName, BuildSimpleType_Name)
		};

		private static readonly XsdAttributeEntry[] SimpleTypeRestrictionAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaBase, BuildSimpleTypeRestriction_Base),
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id)
		};

		private static readonly XsdAttributeEntry[] SimpleTypeUnionAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMemberTypes, BuildSimpleTypeUnion_MemberTypes)
		};

		private static readonly XsdAttributeEntry[] SimpleTypeListAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaItemType, BuildSimpleTypeList_ItemType)
		};

		private static readonly XsdAttributeEntry[] AttributeGroupAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaName, BuildAttributeGroup_Name)
		};

		private static readonly XsdAttributeEntry[] AttributeGroupRefAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaRef, BuildAttributeGroupRef_Ref)
		};

		private static readonly XsdAttributeEntry[] GroupAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaName, BuildGroup_Name)
		};

		private static readonly XsdAttributeEntry[] GroupRefAttributes = new XsdAttributeEntry[4]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMaxOccurs, BuildParticle_MaxOccurs),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMinOccurs, BuildParticle_MinOccurs),
			new XsdAttributeEntry(SchemaNames.Token.SchemaRef, BuildGroupRef_Ref)
		};

		private static readonly XsdAttributeEntry[] ParticleAttributes = new XsdAttributeEntry[3]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMaxOccurs, BuildParticle_MaxOccurs),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMinOccurs, BuildParticle_MinOccurs)
		};

		private static readonly XsdAttributeEntry[] AnyAttributes = new XsdAttributeEntry[5]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMaxOccurs, BuildParticle_MaxOccurs),
			new XsdAttributeEntry(SchemaNames.Token.SchemaMinOccurs, BuildParticle_MinOccurs),
			new XsdAttributeEntry(SchemaNames.Token.SchemaNamespace, BuildAny_Namespace),
			new XsdAttributeEntry(SchemaNames.Token.SchemaProcessContents, BuildAny_ProcessContents)
		};

		private static readonly XsdAttributeEntry[] IdentityConstraintAttributes = new XsdAttributeEntry[3]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaName, BuildIdentityConstraint_Name),
			new XsdAttributeEntry(SchemaNames.Token.SchemaRefer, BuildIdentityConstraint_Refer)
		};

		private static readonly XsdAttributeEntry[] SelectorAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaXPath, BuildSelector_XPath)
		};

		private static readonly XsdAttributeEntry[] FieldAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaXPath, BuildField_XPath)
		};

		private static readonly XsdAttributeEntry[] NotationAttributes = new XsdAttributeEntry[4]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaName, BuildNotation_Name),
			new XsdAttributeEntry(SchemaNames.Token.SchemaPublic, BuildNotation_Public),
			new XsdAttributeEntry(SchemaNames.Token.SchemaSystem, BuildNotation_System)
		};

		private static readonly XsdAttributeEntry[] IncludeAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaSchemaLocation, BuildInclude_SchemaLocation)
		};

		private static readonly XsdAttributeEntry[] ImportAttributes = new XsdAttributeEntry[3]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaNamespace, BuildImport_Namespace),
			new XsdAttributeEntry(SchemaNames.Token.SchemaSchemaLocation, BuildImport_SchemaLocation)
		};

		private static readonly XsdAttributeEntry[] FacetAttributes = new XsdAttributeEntry[3]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaFixed, BuildFacet_Fixed),
			new XsdAttributeEntry(SchemaNames.Token.SchemaValue, BuildFacet_Value)
		};

		private static readonly XsdAttributeEntry[] AnyAttributeAttributes = new XsdAttributeEntry[3]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaNamespace, BuildAnyAttribute_Namespace),
			new XsdAttributeEntry(SchemaNames.Token.SchemaProcessContents, BuildAnyAttribute_ProcessContents)
		};

		private static readonly XsdAttributeEntry[] DocumentationAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaSource, BuildDocumentation_Source),
			new XsdAttributeEntry(SchemaNames.Token.XmlLang, BuildDocumentation_XmlLang)
		};

		private static readonly XsdAttributeEntry[] AppinfoAttributes = new XsdAttributeEntry[1]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaSource, BuildAppinfo_Source)
		};

		private static readonly XsdAttributeEntry[] RedefineAttributes = new XsdAttributeEntry[2]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id),
			new XsdAttributeEntry(SchemaNames.Token.SchemaSchemaLocation, BuildRedefine_SchemaLocation)
		};

		private static readonly XsdAttributeEntry[] AnnotationAttributes = new XsdAttributeEntry[1]
		{
			new XsdAttributeEntry(SchemaNames.Token.SchemaId, BuildAnnotated_Id)
		};

		private static readonly XsdEntry[] SchemaEntries = new XsdEntry[48]
		{
			new XsdEntry(SchemaNames.Token.Empty, State.Root, SchemaElement, null, null, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdSchema, State.Schema, SchemaSubelements, SchemaAttributes, InitSchema, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdAnnotation, State.Annotation, AnnotationSubelements, AnnotationAttributes, InitAnnotation, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdInclude, State.Include, AnnotatedSubelements, IncludeAttributes, InitInclude, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdImport, State.Import, AnnotatedSubelements, ImportAttributes, InitImport, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdElement, State.Element, ElementSubelements, ElementAttributes, InitElement, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdAttribute, State.Attribute, AttributeSubelements, AttributeAttributes, InitAttribute, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.xsdAttributeGroup, State.AttributeGroup, AttributeGroupSubelements, AttributeGroupAttributes, InitAttributeGroup, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.xsdAttributeGroup, State.AttributeGroupRef, AnnotatedSubelements, AttributeGroupRefAttributes, InitAttributeGroupRef, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdAnyAttribute, State.AnyAttribute, AnnotatedSubelements, AnyAttributeAttributes, InitAnyAttribute, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdGroup, State.Group, GroupSubelements, GroupAttributes, InitGroup, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdGroup, State.GroupRef, AnnotatedSubelements, GroupRefAttributes, InitGroupRef, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdAll, State.All, AllSubelements, ParticleAttributes, InitAll, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdChoice, State.Choice, ChoiceSequenceSubelements, ParticleAttributes, InitChoice, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdSequence, State.Sequence, ChoiceSequenceSubelements, ParticleAttributes, InitSequence, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdAny, State.Any, AnnotatedSubelements, AnyAttributes, InitAny, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdNotation, State.Notation, AnnotatedSubelements, NotationAttributes, InitNotation, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdSimpleType, State.SimpleType, SimpleTypeSubelements, SimpleTypeAttributes, InitSimpleType, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdComplexType, State.ComplexType, ComplexTypeSubelements, ComplexTypeAttributes, InitComplexType, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdComplexContent, State.ComplexContent, ComplexContentSubelements, ComplexContentAttributes, InitComplexContent, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdComplexContentRestriction, State.ComplexContentRestriction, ComplexContentRestrictionSubelements, ComplexContentRestrictionAttributes, InitComplexContentRestriction, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdComplexContentExtension, State.ComplexContentExtension, ComplexContentExtensionSubelements, ComplexContentExtensionAttributes, InitComplexContentExtension, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdSimpleContent, State.SimpleContent, SimpleContentSubelements, SimpleContentAttributes, InitSimpleContent, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdSimpleContentExtension, State.SimpleContentExtension, SimpleContentExtensionSubelements, SimpleContentExtensionAttributes, InitSimpleContentExtension, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdSimpleContentRestriction, State.SimpleContentRestriction, SimpleContentRestrictionSubelements, SimpleContentRestrictionAttributes, InitSimpleContentRestriction, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdSimpleTypeUnion, State.SimpleTypeUnion, SimpleTypeUnionSubelements, SimpleTypeUnionAttributes, InitSimpleTypeUnion, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdSimpleTypeList, State.SimpleTypeList, SimpleTypeListSubelements, SimpleTypeListAttributes, InitSimpleTypeList, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdSimpleTypeRestriction, State.SimpleTypeRestriction, SimpleTypeRestrictionSubelements, SimpleTypeRestrictionAttributes, InitSimpleTypeRestriction, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdUnique, State.Unique, IdentityConstraintSubelements, IdentityConstraintAttributes, InitIdentityConstraint, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdKey, State.Key, IdentityConstraintSubelements, IdentityConstraintAttributes, InitIdentityConstraint, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdKeyref, State.KeyRef, IdentityConstraintSubelements, IdentityConstraintAttributes, InitIdentityConstraint, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdSelector, State.Selector, AnnotatedSubelements, SelectorAttributes, InitSelector, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdField, State.Field, AnnotatedSubelements, FieldAttributes, InitField, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdMinExclusive, State.MinExclusive, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdMinInclusive, State.MinInclusive, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdMaxExclusive, State.MaxExclusive, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdMaxInclusive, State.MaxInclusive, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdTotalDigits, State.TotalDigits, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdFractionDigits, State.FractionDigits, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdLength, State.Length, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdMinLength, State.MinLength, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdMaxLength, State.MaxLength, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdEnumeration, State.Enumeration, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdPattern, State.Pattern, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdWhitespace, State.WhiteSpace, AnnotatedSubelements, FacetAttributes, InitFacet, null, parseContent: true),
			new XsdEntry(SchemaNames.Token.XsdAppInfo, State.AppInfo, null, AppinfoAttributes, InitAppinfo, EndAppinfo, parseContent: false),
			new XsdEntry(SchemaNames.Token.XsdDocumentation, State.Documentation, null, DocumentationAttributes, InitDocumentation, EndDocumentation, parseContent: false),
			new XsdEntry(SchemaNames.Token.XsdRedefine, State.Redefine, RedefineSubelements, RedefineAttributes, InitRedefine, EndRedefine, parseContent: true)
		};

		private static readonly int[] DerivationMethodValues = new int[6] { 1, 2, 4, 8, 16, 255 };

		private static readonly string[] DerivationMethodStrings = new string[6] { "substitution", "extension", "restriction", "list", "union", "#all" };

		private static readonly string[] FormStringValues = new string[2] { "qualified", "unqualified" };

		private static readonly string[] UseStringValues = new string[3] { "optional", "prohibited", "required" };

		private static readonly string[] ProcessContentsStringValues = new string[3] { "skip", "lax", "strict" };

		private XmlReader reader;

		private PositionInfo positionInfo;

		private XsdEntry currentEntry;

		private XsdEntry nextEntry;

		private bool hasChild;

		private HWStack stateHistory = new HWStack(10);

		private Stack containerStack = new Stack();

		private XmlNameTable nameTable;

		private SchemaNames schemaNames;

		private XmlNamespaceManager namespaceManager;

		private bool canIncludeImport;

		private XmlSchema schema;

		private XmlSchemaObject xso;

		private XmlSchemaElement element;

		private XmlSchemaAny anyElement;

		private XmlSchemaAttribute attribute;

		private XmlSchemaAnyAttribute anyAttribute;

		private XmlSchemaComplexType complexType;

		private XmlSchemaSimpleType simpleType;

		private XmlSchemaComplexContent complexContent;

		private XmlSchemaComplexContentExtension complexContentExtension;

		private XmlSchemaComplexContentRestriction complexContentRestriction;

		private XmlSchemaSimpleContent simpleContent;

		private XmlSchemaSimpleContentExtension simpleContentExtension;

		private XmlSchemaSimpleContentRestriction simpleContentRestriction;

		private XmlSchemaSimpleTypeUnion simpleTypeUnion;

		private XmlSchemaSimpleTypeList simpleTypeList;

		private XmlSchemaSimpleTypeRestriction simpleTypeRestriction;

		private XmlSchemaGroup group;

		private XmlSchemaGroupRef groupRef;

		private XmlSchemaAll all;

		private XmlSchemaChoice choice;

		private XmlSchemaSequence sequence;

		private XmlSchemaParticle particle;

		private XmlSchemaAttributeGroup attributeGroup;

		private XmlSchemaAttributeGroupRef attributeGroupRef;

		private XmlSchemaNotation notation;

		private XmlSchemaIdentityConstraint identityConstraint;

		private XmlSchemaXPath xpath;

		private XmlSchemaInclude include;

		private XmlSchemaImport import;

		private XmlSchemaAnnotation annotation;

		private XmlSchemaAppInfo appInfo;

		private XmlSchemaDocumentation documentation;

		private XmlSchemaFacet facet;

		private XmlNode[] markup;

		private XmlSchemaRedefine redefine;

		private ValidationEventHandler validationEventHandler;

		private ArrayList unhandledAttributes = new ArrayList();

		private Hashtable namespaces;

		private SchemaNames.Token CurrentElement => currentEntry.Name;

		private SchemaNames.Token ParentElement => ((XsdEntry)stateHistory[stateHistory.Length - 1]).Name;

		private XmlSchemaObject ParentContainer => (XmlSchemaObject)containerStack.Peek();

		internal XsdBuilder(XmlReader reader, XmlNamespaceManager curmgr, XmlSchema schema, XmlNameTable nameTable, SchemaNames schemaNames, ValidationEventHandler eventhandler)
		{
			this.reader = reader;
			xso = (this.schema = schema);
			namespaceManager = new BuilderNamespaceManager(curmgr, reader);
			validationEventHandler = eventhandler;
			this.nameTable = nameTable;
			this.schemaNames = schemaNames;
			stateHistory = new HWStack(10);
			currentEntry = SchemaEntries[0];
			positionInfo = PositionInfo.GetPositionInfo(reader);
		}

		internal override bool ProcessElement(string prefix, string name, string ns)
		{
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(name, ns);
			if (GetNextState(xmlQualifiedName))
			{
				Push();
				xso = null;
				currentEntry.InitFunc(this, null);
				RecordPosition();
				return true;
			}
			if (!IsSkipableElement(xmlQualifiedName))
			{
				SendValidationEvent("Sch_UnsupportedElement", xmlQualifiedName.ToString());
			}
			return false;
		}

		internal override void ProcessAttribute(string prefix, string name, string ns, string value)
		{
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(name, ns);
			if (currentEntry.Attributes != null)
			{
				for (int i = 0; i < currentEntry.Attributes.Length; i++)
				{
					XsdAttributeEntry xsdAttributeEntry = currentEntry.Attributes[i];
					if (schemaNames.TokenToQName[(int)xsdAttributeEntry.Attribute].Equals(xmlQualifiedName))
					{
						try
						{
							xsdAttributeEntry.BuildFunc(this, value);
							return;
						}
						catch (XmlSchemaException ex)
						{
							ex.SetSource(reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition);
							SendValidationEvent("Sch_InvalidXsdAttributeDatatypeValue", new string[2] { name, ex.Message }, XmlSeverityType.Error);
							return;
						}
					}
				}
			}
			if (ns != schemaNames.NsXs && ns.Length != 0)
			{
				if (ns == schemaNames.NsXmlNs)
				{
					if (namespaces == null)
					{
						namespaces = new Hashtable();
					}
					namespaces.Add((name == schemaNames.QnXmlNs.Name) ? string.Empty : name, value);
				}
				else
				{
					XmlAttribute xmlAttribute = new XmlAttribute(prefix, name, ns, schema.Document);
					xmlAttribute.Value = value;
					unhandledAttributes.Add(xmlAttribute);
				}
			}
			else
			{
				SendValidationEvent("Sch_UnsupportedAttribute", xmlQualifiedName.ToString());
			}
		}

		internal override bool IsContentParsed()
		{
			return currentEntry.ParseContent;
		}

		internal override void ProcessMarkup(XmlNode[] markup)
		{
			this.markup = markup;
		}

		internal override void ProcessCData(string value)
		{
			SendValidationEvent("Sch_TextNotAllowed", value);
		}

		internal override void StartChildren()
		{
			if (xso != null)
			{
				if (namespaces != null && namespaces.Count > 0)
				{
					xso.Namespaces.Namespaces = namespaces;
					namespaces = null;
				}
				if (unhandledAttributes.Count != 0)
				{
					xso.SetUnhandledAttributes((XmlAttribute[])unhandledAttributes.ToArray(typeof(XmlAttribute)));
					unhandledAttributes.Clear();
				}
			}
		}

		internal override void EndChildren()
		{
			if (currentEntry.EndChildFunc != null)
			{
				currentEntry.EndChildFunc(this);
			}
			Pop();
		}

		private void Push()
		{
			stateHistory.Push();
			stateHistory[stateHistory.Length - 1] = currentEntry;
			containerStack.Push(GetContainer(currentEntry.CurrentState));
			currentEntry = nextEntry;
			if (currentEntry.Name != SchemaNames.Token.XsdAnnotation)
			{
				hasChild = false;
			}
		}

		private void Pop()
		{
			currentEntry = (XsdEntry)stateHistory.Pop();
			SetContainer(currentEntry.CurrentState, containerStack.Pop());
			hasChild = true;
		}

		private XmlSchemaObject GetContainer(State state)
		{
			XmlSchemaObject result = null;
			switch (state)
			{
			case State.Schema:
				result = schema;
				break;
			case State.Annotation:
				result = annotation;
				break;
			case State.Include:
				result = include;
				break;
			case State.Import:
				result = import;
				break;
			case State.Element:
				result = element;
				break;
			case State.Attribute:
				result = attribute;
				break;
			case State.AttributeGroup:
				result = attributeGroup;
				break;
			case State.AttributeGroupRef:
				result = attributeGroupRef;
				break;
			case State.AnyAttribute:
				result = anyAttribute;
				break;
			case State.Group:
				result = group;
				break;
			case State.GroupRef:
				result = groupRef;
				break;
			case State.All:
				result = all;
				break;
			case State.Choice:
				result = choice;
				break;
			case State.Sequence:
				result = sequence;
				break;
			case State.Any:
				result = anyElement;
				break;
			case State.Notation:
				result = notation;
				break;
			case State.SimpleType:
				result = simpleType;
				break;
			case State.ComplexType:
				result = complexType;
				break;
			case State.ComplexContent:
				result = complexContent;
				break;
			case State.ComplexContentExtension:
				result = complexContentExtension;
				break;
			case State.ComplexContentRestriction:
				result = complexContentRestriction;
				break;
			case State.SimpleContent:
				result = simpleContent;
				break;
			case State.SimpleContentExtension:
				result = simpleContentExtension;
				break;
			case State.SimpleContentRestriction:
				result = simpleContentRestriction;
				break;
			case State.SimpleTypeUnion:
				result = simpleTypeUnion;
				break;
			case State.SimpleTypeList:
				result = simpleTypeList;
				break;
			case State.SimpleTypeRestriction:
				result = simpleTypeRestriction;
				break;
			case State.Unique:
			case State.Key:
			case State.KeyRef:
				result = identityConstraint;
				break;
			case State.Selector:
			case State.Field:
				result = xpath;
				break;
			case State.MinExclusive:
			case State.MinInclusive:
			case State.MaxExclusive:
			case State.MaxInclusive:
			case State.TotalDigits:
			case State.FractionDigits:
			case State.Length:
			case State.MinLength:
			case State.MaxLength:
			case State.Enumeration:
			case State.Pattern:
			case State.WhiteSpace:
				result = facet;
				break;
			case State.AppInfo:
				result = appInfo;
				break;
			case State.Documentation:
				result = documentation;
				break;
			case State.Redefine:
				result = redefine;
				break;
			}
			return result;
		}

		private void SetContainer(State state, object container)
		{
			switch (state)
			{
			case State.Annotation:
				annotation = (XmlSchemaAnnotation)container;
				break;
			case State.Include:
				include = (XmlSchemaInclude)container;
				break;
			case State.Import:
				import = (XmlSchemaImport)container;
				break;
			case State.Element:
				element = (XmlSchemaElement)container;
				break;
			case State.Attribute:
				attribute = (XmlSchemaAttribute)container;
				break;
			case State.AttributeGroup:
				attributeGroup = (XmlSchemaAttributeGroup)container;
				break;
			case State.AttributeGroupRef:
				attributeGroupRef = (XmlSchemaAttributeGroupRef)container;
				break;
			case State.AnyAttribute:
				anyAttribute = (XmlSchemaAnyAttribute)container;
				break;
			case State.Group:
				group = (XmlSchemaGroup)container;
				break;
			case State.GroupRef:
				groupRef = (XmlSchemaGroupRef)container;
				break;
			case State.All:
				all = (XmlSchemaAll)container;
				break;
			case State.Choice:
				choice = (XmlSchemaChoice)container;
				break;
			case State.Sequence:
				sequence = (XmlSchemaSequence)container;
				break;
			case State.Any:
				anyElement = (XmlSchemaAny)container;
				break;
			case State.Notation:
				notation = (XmlSchemaNotation)container;
				break;
			case State.SimpleType:
				simpleType = (XmlSchemaSimpleType)container;
				break;
			case State.ComplexType:
				complexType = (XmlSchemaComplexType)container;
				break;
			case State.ComplexContent:
				complexContent = (XmlSchemaComplexContent)container;
				break;
			case State.ComplexContentExtension:
				complexContentExtension = (XmlSchemaComplexContentExtension)container;
				break;
			case State.ComplexContentRestriction:
				complexContentRestriction = (XmlSchemaComplexContentRestriction)container;
				break;
			case State.SimpleContent:
				simpleContent = (XmlSchemaSimpleContent)container;
				break;
			case State.SimpleContentExtension:
				simpleContentExtension = (XmlSchemaSimpleContentExtension)container;
				break;
			case State.SimpleContentRestriction:
				simpleContentRestriction = (XmlSchemaSimpleContentRestriction)container;
				break;
			case State.SimpleTypeUnion:
				simpleTypeUnion = (XmlSchemaSimpleTypeUnion)container;
				break;
			case State.SimpleTypeList:
				simpleTypeList = (XmlSchemaSimpleTypeList)container;
				break;
			case State.SimpleTypeRestriction:
				simpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)container;
				break;
			case State.Unique:
			case State.Key:
			case State.KeyRef:
				identityConstraint = (XmlSchemaIdentityConstraint)container;
				break;
			case State.Selector:
			case State.Field:
				xpath = (XmlSchemaXPath)container;
				break;
			case State.MinExclusive:
			case State.MinInclusive:
			case State.MaxExclusive:
			case State.MaxInclusive:
			case State.TotalDigits:
			case State.FractionDigits:
			case State.Length:
			case State.MinLength:
			case State.MaxLength:
			case State.Enumeration:
			case State.Pattern:
			case State.WhiteSpace:
				facet = (XmlSchemaFacet)container;
				break;
			case State.AppInfo:
				appInfo = (XmlSchemaAppInfo)container;
				break;
			case State.Documentation:
				documentation = (XmlSchemaDocumentation)container;
				break;
			case State.Redefine:
				redefine = (XmlSchemaRedefine)container;
				break;
			case State.Root:
			case State.Schema:
				break;
			}
		}

		private static void BuildAnnotated_Id(XsdBuilder builder, string value)
		{
			builder.xso.IdAttribute = value;
		}

		private static void BuildSchema_AttributeFormDefault(XsdBuilder builder, string value)
		{
			builder.schema.AttributeFormDefault = (XmlSchemaForm)builder.ParseEnum(value, "attributeFormDefault", FormStringValues);
		}

		private static void BuildSchema_ElementFormDefault(XsdBuilder builder, string value)
		{
			builder.schema.ElementFormDefault = (XmlSchemaForm)builder.ParseEnum(value, "elementFormDefault", FormStringValues);
		}

		private static void BuildSchema_TargetNamespace(XsdBuilder builder, string value)
		{
			builder.schema.TargetNamespace = value;
		}

		private static void BuildSchema_Version(XsdBuilder builder, string value)
		{
			builder.schema.Version = value;
		}

		private static void BuildSchema_FinalDefault(XsdBuilder builder, string value)
		{
			builder.schema.FinalDefault = (XmlSchemaDerivationMethod)builder.ParseBlockFinalEnum(value, "finalDefault");
		}

		private static void BuildSchema_BlockDefault(XsdBuilder builder, string value)
		{
			builder.schema.BlockDefault = (XmlSchemaDerivationMethod)builder.ParseBlockFinalEnum(value, "blockDefault");
		}

		private static void InitSchema(XsdBuilder builder, string value)
		{
			builder.canIncludeImport = true;
			builder.xso = builder.schema;
		}

		private static void InitInclude(XsdBuilder builder, string value)
		{
			if (!builder.canIncludeImport)
			{
				builder.SendValidationEvent("Sch_IncludeLocation", null);
			}
			builder.xso = (builder.include = new XmlSchemaInclude());
			builder.schema.Includes.Add(builder.include);
		}

		private static void BuildInclude_SchemaLocation(XsdBuilder builder, string value)
		{
			builder.include.SchemaLocation = value;
		}

		private static void InitImport(XsdBuilder builder, string value)
		{
			if (!builder.canIncludeImport)
			{
				builder.SendValidationEvent("Sch_ImportLocation", null);
			}
			builder.xso = (builder.import = new XmlSchemaImport());
			builder.schema.Includes.Add(builder.import);
		}

		private static void BuildImport_Namespace(XsdBuilder builder, string value)
		{
			builder.import.Namespace = value;
		}

		private static void BuildImport_SchemaLocation(XsdBuilder builder, string value)
		{
			builder.import.SchemaLocation = value;
		}

		private static void InitRedefine(XsdBuilder builder, string value)
		{
			if (!builder.canIncludeImport)
			{
				builder.SendValidationEvent("Sch_RedefineLocation", null);
			}
			builder.xso = (builder.redefine = new XmlSchemaRedefine());
			builder.schema.Includes.Add(builder.redefine);
		}

		private static void BuildRedefine_SchemaLocation(XsdBuilder builder, string value)
		{
			builder.redefine.SchemaLocation = value;
		}

		private static void EndRedefine(XsdBuilder builder)
		{
			builder.canIncludeImport = true;
		}

		private static void InitAttribute(XsdBuilder builder, string value)
		{
			builder.xso = (builder.attribute = new XmlSchemaAttribute());
			if (builder.ParentElement == SchemaNames.Token.XsdSchema)
			{
				builder.schema.Items.Add(builder.attribute);
			}
			else
			{
				builder.AddAttribute(builder.attribute);
			}
			builder.canIncludeImport = false;
		}

		private static void BuildAttribute_Default(XsdBuilder builder, string value)
		{
			builder.attribute.DefaultValue = value;
		}

		private static void BuildAttribute_Fixed(XsdBuilder builder, string value)
		{
			builder.attribute.FixedValue = value;
		}

		private static void BuildAttribute_Form(XsdBuilder builder, string value)
		{
			builder.attribute.Form = (XmlSchemaForm)builder.ParseEnum(value, "form", FormStringValues);
		}

		private static void BuildAttribute_Use(XsdBuilder builder, string value)
		{
			builder.attribute.Use = (XmlSchemaUse)builder.ParseEnum(value, "use", UseStringValues);
		}

		private static void BuildAttribute_Ref(XsdBuilder builder, string value)
		{
			builder.attribute.RefName = builder.ParseQName(value, "ref");
		}

		private static void BuildAttribute_Name(XsdBuilder builder, string value)
		{
			builder.attribute.Name = value;
		}

		private static void BuildAttribute_Type(XsdBuilder builder, string value)
		{
			builder.attribute.SchemaTypeName = builder.ParseQName(value, "type");
		}

		private static void InitElement(XsdBuilder builder, string value)
		{
			builder.xso = (builder.element = new XmlSchemaElement());
			builder.canIncludeImport = false;
			switch (builder.ParentElement)
			{
			case SchemaNames.Token.XsdSchema:
				builder.schema.Items.Add(builder.element);
				break;
			case SchemaNames.Token.XsdAll:
				builder.all.Items.Add(builder.element);
				break;
			case SchemaNames.Token.XsdChoice:
				builder.choice.Items.Add(builder.element);
				break;
			case SchemaNames.Token.XsdSequence:
				builder.sequence.Items.Add(builder.element);
				break;
			}
		}

		private static void BuildElement_Abstract(XsdBuilder builder, string value)
		{
			builder.element.IsAbstract = builder.ParseBoolean(value, "abstract");
		}

		private static void BuildElement_Block(XsdBuilder builder, string value)
		{
			builder.element.Block = (XmlSchemaDerivationMethod)builder.ParseBlockFinalEnum(value, "block");
		}

		private static void BuildElement_Default(XsdBuilder builder, string value)
		{
			builder.element.DefaultValue = value;
		}

		private static void BuildElement_Form(XsdBuilder builder, string value)
		{
			builder.element.Form = (XmlSchemaForm)builder.ParseEnum(value, "form", FormStringValues);
		}

		private static void BuildElement_SubstitutionGroup(XsdBuilder builder, string value)
		{
			builder.element.SubstitutionGroup = builder.ParseQName(value, "substitutionGroup");
		}

		private static void BuildElement_Final(XsdBuilder builder, string value)
		{
			builder.element.Final = (XmlSchemaDerivationMethod)builder.ParseBlockFinalEnum(value, "final");
		}

		private static void BuildElement_Fixed(XsdBuilder builder, string value)
		{
			builder.element.FixedValue = value;
		}

		private static void BuildElement_MaxOccurs(XsdBuilder builder, string value)
		{
			builder.SetMaxOccurs(builder.element, value);
		}

		private static void BuildElement_MinOccurs(XsdBuilder builder, string value)
		{
			builder.SetMinOccurs(builder.element, value);
		}

		private static void BuildElement_Name(XsdBuilder builder, string value)
		{
			builder.element.Name = value;
		}

		private static void BuildElement_Nillable(XsdBuilder builder, string value)
		{
			builder.element.IsNillable = builder.ParseBoolean(value, "nillable");
		}

		private static void BuildElement_Ref(XsdBuilder builder, string value)
		{
			builder.element.RefName = builder.ParseQName(value, "ref");
		}

		private static void BuildElement_Type(XsdBuilder builder, string value)
		{
			builder.element.SchemaTypeName = builder.ParseQName(value, "type");
		}

		private static void InitSimpleType(XsdBuilder builder, string value)
		{
			builder.xso = (builder.simpleType = new XmlSchemaSimpleType());
			switch (builder.ParentElement)
			{
			case SchemaNames.Token.XsdSchema:
				builder.canIncludeImport = false;
				builder.schema.Items.Add(builder.simpleType);
				break;
			case SchemaNames.Token.XsdRedefine:
				builder.redefine.Items.Add(builder.simpleType);
				break;
			case SchemaNames.Token.XsdAttribute:
				if (builder.attribute.SchemaType != null)
				{
					builder.SendValidationEvent("Sch_DupXsdElement", "simpleType");
				}
				builder.attribute.SchemaType = builder.simpleType;
				break;
			case SchemaNames.Token.XsdElement:
				if (builder.element.SchemaType != null)
				{
					builder.SendValidationEvent("Sch_DupXsdElement", "simpleType");
				}
				if (builder.element.Constraints.Count != 0)
				{
					builder.SendValidationEvent("Sch_TypeAfterConstraints", null);
				}
				builder.element.SchemaType = builder.simpleType;
				break;
			case SchemaNames.Token.XsdSimpleTypeList:
				if (builder.simpleTypeList.ItemType != null)
				{
					builder.SendValidationEvent("Sch_DupXsdElement", "simpleType");
				}
				builder.simpleTypeList.ItemType = builder.simpleType;
				break;
			case SchemaNames.Token.XsdSimpleTypeRestriction:
				if (builder.simpleTypeRestriction.BaseType != null)
				{
					builder.SendValidationEvent("Sch_DupXsdElement", "simpleType");
				}
				builder.simpleTypeRestriction.BaseType = builder.simpleType;
				break;
			case SchemaNames.Token.XsdSimpleContentRestriction:
				if (builder.simpleContentRestriction.BaseType != null)
				{
					builder.SendValidationEvent("Sch_DupXsdElement", "simpleType");
				}
				if (builder.simpleContentRestriction.Attributes.Count != 0 || builder.simpleContentRestriction.AnyAttribute != null || builder.simpleContentRestriction.Facets.Count != 0)
				{
					builder.SendValidationEvent("Sch_SimpleTypeRestriction", null);
				}
				builder.simpleContentRestriction.BaseType = builder.simpleType;
				break;
			case SchemaNames.Token.XsdSimpleTypeUnion:
				builder.simpleTypeUnion.BaseTypes.Add(builder.simpleType);
				break;
			}
		}

		private static void BuildSimpleType_Name(XsdBuilder builder, string value)
		{
			builder.simpleType.Name = value;
		}

		private static void BuildSimpleType_Final(XsdBuilder builder, string value)
		{
			builder.simpleType.Final = (XmlSchemaDerivationMethod)builder.ParseBlockFinalEnum(value, "final");
		}

		private static void InitSimpleTypeUnion(XsdBuilder builder, string value)
		{
			if (builder.simpleType.Content != null)
			{
				builder.SendValidationEvent("Sch_DupSimpleTypeChild", null);
			}
			builder.xso = (builder.simpleTypeUnion = new XmlSchemaSimpleTypeUnion());
			builder.simpleType.Content = builder.simpleTypeUnion;
		}

		private static void BuildSimpleTypeUnion_MemberTypes(XsdBuilder builder, string value)
		{
			XmlSchemaDatatype xmlSchemaDatatype = XmlSchemaDatatype.FromXmlTokenizedTypeXsd(XmlTokenizedType.QName).DeriveByList(null);
			try
			{
				builder.simpleTypeUnion.MemberTypes = (XmlQualifiedName[])xmlSchemaDatatype.ParseValue(value, builder.nameTable, builder.namespaceManager);
			}
			catch (XmlSchemaException ex)
			{
				ex.SetSource(builder.reader.BaseURI, builder.positionInfo.LineNumber, builder.positionInfo.LinePosition);
				builder.SendValidationEvent(ex);
			}
		}

		private static void InitSimpleTypeList(XsdBuilder builder, string value)
		{
			if (builder.simpleType.Content != null)
			{
				builder.SendValidationEvent("Sch_DupSimpleTypeChild", null);
			}
			builder.xso = (builder.simpleTypeList = new XmlSchemaSimpleTypeList());
			builder.simpleType.Content = builder.simpleTypeList;
		}

		private static void BuildSimpleTypeList_ItemType(XsdBuilder builder, string value)
		{
			builder.simpleTypeList.ItemTypeName = builder.ParseQName(value, "itemType");
		}

		private static void InitSimpleTypeRestriction(XsdBuilder builder, string value)
		{
			if (builder.simpleType.Content != null)
			{
				builder.SendValidationEvent("Sch_DupSimpleTypeChild", null);
			}
			builder.xso = (builder.simpleTypeRestriction = new XmlSchemaSimpleTypeRestriction());
			builder.simpleType.Content = builder.simpleTypeRestriction;
		}

		private static void BuildSimpleTypeRestriction_Base(XsdBuilder builder, string value)
		{
			builder.simpleTypeRestriction.BaseTypeName = builder.ParseQName(value, "base");
		}

		private static void InitComplexType(XsdBuilder builder, string value)
		{
			builder.xso = (builder.complexType = new XmlSchemaComplexType());
			switch (builder.ParentElement)
			{
			case SchemaNames.Token.XsdSchema:
				builder.canIncludeImport = false;
				builder.schema.Items.Add(builder.complexType);
				break;
			case SchemaNames.Token.XsdRedefine:
				builder.redefine.Items.Add(builder.complexType);
				break;
			case SchemaNames.Token.XsdElement:
				if (builder.element.SchemaType != null)
				{
					builder.SendValidationEvent("Sch_DupElement", "complexType");
				}
				if (builder.element.Constraints.Count != 0)
				{
					builder.SendValidationEvent("Sch_TypeAfterConstraints", null);
				}
				builder.element.SchemaType = builder.complexType;
				break;
			}
		}

		private static void BuildComplexType_Abstract(XsdBuilder builder, string value)
		{
			builder.complexType.IsAbstract = builder.ParseBoolean(value, "abstract");
		}

		private static void BuildComplexType_Block(XsdBuilder builder, string value)
		{
			builder.complexType.Block = (XmlSchemaDerivationMethod)builder.ParseBlockFinalEnum(value, "block");
		}

		private static void BuildComplexType_Final(XsdBuilder builder, string value)
		{
			builder.complexType.Final = (XmlSchemaDerivationMethod)builder.ParseBlockFinalEnum(value, "final");
		}

		private static void BuildComplexType_Mixed(XsdBuilder builder, string value)
		{
			builder.complexType.IsMixed = builder.ParseBoolean(value, "mixed");
		}

		private static void BuildComplexType_Name(XsdBuilder builder, string value)
		{
			builder.complexType.Name = value;
		}

		private static void InitComplexContent(XsdBuilder builder, string value)
		{
			if (builder.complexType.ContentModel != null || builder.complexType.Particle != null || builder.complexType.Attributes.Count != 0 || builder.complexType.AnyAttribute != null)
			{
				builder.SendValidationEvent("Sch_ComplexTypeContentModel", "complexContent");
			}
			builder.xso = (builder.complexContent = new XmlSchemaComplexContent());
			builder.complexType.ContentModel = builder.complexContent;
		}

		private static void BuildComplexContent_Mixed(XsdBuilder builder, string value)
		{
			builder.complexContent.IsMixed = builder.ParseBoolean(value, "mixed");
		}

		private static void InitComplexContentExtension(XsdBuilder builder, string value)
		{
			if (builder.complexContent.Content != null)
			{
				builder.SendValidationEvent("Sch_ComplexContentContentModel", "extension");
			}
			builder.xso = (builder.complexContentExtension = new XmlSchemaComplexContentExtension());
			builder.complexContent.Content = builder.complexContentExtension;
		}

		private static void BuildComplexContentExtension_Base(XsdBuilder builder, string value)
		{
			builder.complexContentExtension.BaseTypeName = builder.ParseQName(value, "base");
		}

		private static void InitComplexContentRestriction(XsdBuilder builder, string value)
		{
			builder.xso = (builder.complexContentRestriction = new XmlSchemaComplexContentRestriction());
			builder.complexContent.Content = builder.complexContentRestriction;
		}

		private static void BuildComplexContentRestriction_Base(XsdBuilder builder, string value)
		{
			builder.complexContentRestriction.BaseTypeName = builder.ParseQName(value, "base");
		}

		private static void InitSimpleContent(XsdBuilder builder, string value)
		{
			if (builder.complexType.ContentModel != null || builder.complexType.Particle != null || builder.complexType.Attributes.Count != 0 || builder.complexType.AnyAttribute != null)
			{
				builder.SendValidationEvent("Sch_ComplexTypeContentModel", "simpleContent");
			}
			builder.xso = (builder.simpleContent = new XmlSchemaSimpleContent());
			builder.complexType.ContentModel = builder.simpleContent;
		}

		private static void InitSimpleContentExtension(XsdBuilder builder, string value)
		{
			if (builder.simpleContent.Content != null)
			{
				builder.SendValidationEvent("Sch_DupElement", "extension");
			}
			builder.xso = (builder.simpleContentExtension = new XmlSchemaSimpleContentExtension());
			builder.simpleContent.Content = builder.simpleContentExtension;
		}

		private static void BuildSimpleContentExtension_Base(XsdBuilder builder, string value)
		{
			builder.simpleContentExtension.BaseTypeName = builder.ParseQName(value, "base");
		}

		private static void InitSimpleContentRestriction(XsdBuilder builder, string value)
		{
			if (builder.simpleContent.Content != null)
			{
				builder.SendValidationEvent("Sch_DupElement", "restriction");
			}
			builder.xso = (builder.simpleContentRestriction = new XmlSchemaSimpleContentRestriction());
			builder.simpleContent.Content = builder.simpleContentRestriction;
		}

		private static void BuildSimpleContentRestriction_Base(XsdBuilder builder, string value)
		{
			builder.simpleContentRestriction.BaseTypeName = builder.ParseQName(value, "base");
		}

		private static void InitAttributeGroup(XsdBuilder builder, string value)
		{
			builder.canIncludeImport = false;
			builder.xso = (builder.attributeGroup = new XmlSchemaAttributeGroup());
			switch (builder.ParentElement)
			{
			case SchemaNames.Token.XsdSchema:
				builder.schema.Items.Add(builder.attributeGroup);
				break;
			case SchemaNames.Token.XsdRedefine:
				builder.redefine.Items.Add(builder.attributeGroup);
				break;
			}
		}

		private static void BuildAttributeGroup_Name(XsdBuilder builder, string value)
		{
			builder.attributeGroup.Name = value;
		}

		private static void InitAttributeGroupRef(XsdBuilder builder, string value)
		{
			builder.xso = (builder.attributeGroupRef = new XmlSchemaAttributeGroupRef());
			builder.AddAttribute(builder.attributeGroupRef);
		}

		private static void BuildAttributeGroupRef_Ref(XsdBuilder builder, string value)
		{
			builder.attributeGroupRef.RefName = builder.ParseQName(value, "ref");
		}

		private static void InitAnyAttribute(XsdBuilder builder, string value)
		{
			builder.xso = (builder.anyAttribute = new XmlSchemaAnyAttribute());
			switch (builder.ParentElement)
			{
			case SchemaNames.Token.XsdComplexType:
				if (builder.complexType.ContentModel != null)
				{
					builder.SendValidationEvent("Sch_AttributeMutuallyExclusive", "anyAttribute");
				}
				if (builder.complexType.AnyAttribute != null)
				{
					builder.SendValidationEvent("Sch_DupElement", "anyAttribute");
				}
				builder.complexType.AnyAttribute = builder.anyAttribute;
				break;
			case SchemaNames.Token.XsdSimpleContentRestriction:
				if (builder.simpleContentRestriction.AnyAttribute != null)
				{
					builder.SendValidationEvent("Sch_DupElement", "anyAttribute");
				}
				builder.simpleContentRestriction.AnyAttribute = builder.anyAttribute;
				break;
			case SchemaNames.Token.XsdSimpleContentExtension:
				if (builder.simpleContentExtension.AnyAttribute != null)
				{
					builder.SendValidationEvent("Sch_DupElement", "anyAttribute");
				}
				builder.simpleContentExtension.AnyAttribute = builder.anyAttribute;
				break;
			case SchemaNames.Token.XsdComplexContentExtension:
				if (builder.complexContentExtension.AnyAttribute != null)
				{
					builder.SendValidationEvent("Sch_DupElement", "anyAttribute");
				}
				builder.complexContentExtension.AnyAttribute = builder.anyAttribute;
				break;
			case SchemaNames.Token.XsdComplexContentRestriction:
				if (builder.complexContentRestriction.AnyAttribute != null)
				{
					builder.SendValidationEvent("Sch_DupElement", "anyAttribute");
				}
				builder.complexContentRestriction.AnyAttribute = builder.anyAttribute;
				break;
			case SchemaNames.Token.xsdAttributeGroup:
				if (builder.attributeGroup.AnyAttribute != null)
				{
					builder.SendValidationEvent("Sch_DupElement", "anyAttribute");
				}
				builder.attributeGroup.AnyAttribute = builder.anyAttribute;
				break;
			}
		}

		private static void BuildAnyAttribute_Namespace(XsdBuilder builder, string value)
		{
			builder.anyAttribute.Namespace = value;
		}

		private static void BuildAnyAttribute_ProcessContents(XsdBuilder builder, string value)
		{
			builder.anyAttribute.ProcessContents = (XmlSchemaContentProcessing)builder.ParseEnum(value, "processContents", ProcessContentsStringValues);
		}

		private static void InitGroup(XsdBuilder builder, string value)
		{
			builder.xso = (builder.group = new XmlSchemaGroup());
			builder.canIncludeImport = false;
			switch (builder.ParentElement)
			{
			case SchemaNames.Token.XsdSchema:
				builder.schema.Items.Add(builder.group);
				break;
			case SchemaNames.Token.XsdRedefine:
				builder.redefine.Items.Add(builder.group);
				break;
			}
		}

		private static void BuildGroup_Name(XsdBuilder builder, string value)
		{
			builder.group.Name = value;
		}

		private static void InitGroupRef(XsdBuilder builder, string value)
		{
			builder.xso = (builder.particle = (builder.groupRef = new XmlSchemaGroupRef()));
			builder.AddParticle(builder.groupRef);
		}

		private static void BuildParticle_MaxOccurs(XsdBuilder builder, string value)
		{
			builder.SetMaxOccurs(builder.particle, value);
		}

		private static void BuildParticle_MinOccurs(XsdBuilder builder, string value)
		{
			builder.SetMinOccurs(builder.particle, value);
		}

		private static void BuildGroupRef_Ref(XsdBuilder builder, string value)
		{
			builder.groupRef.RefName = builder.ParseQName(value, "ref");
		}

		private static void InitAll(XsdBuilder builder, string value)
		{
			builder.xso = (builder.particle = (builder.all = new XmlSchemaAll()));
			builder.AddParticle(builder.all);
		}

		private static void InitChoice(XsdBuilder builder, string value)
		{
			builder.xso = (builder.particle = (builder.choice = new XmlSchemaChoice()));
			builder.AddParticle(builder.choice);
		}

		private static void InitSequence(XsdBuilder builder, string value)
		{
			builder.xso = (builder.particle = (builder.sequence = new XmlSchemaSequence()));
			builder.AddParticle(builder.sequence);
		}

		private static void InitAny(XsdBuilder builder, string value)
		{
			builder.xso = (builder.particle = (builder.anyElement = new XmlSchemaAny()));
			builder.AddParticle(builder.anyElement);
		}

		private static void BuildAny_Namespace(XsdBuilder builder, string value)
		{
			builder.anyElement.Namespace = value;
		}

		private static void BuildAny_ProcessContents(XsdBuilder builder, string value)
		{
			builder.anyElement.ProcessContents = (XmlSchemaContentProcessing)builder.ParseEnum(value, "processContents", ProcessContentsStringValues);
		}

		private static void InitNotation(XsdBuilder builder, string value)
		{
			builder.xso = (builder.notation = new XmlSchemaNotation());
			builder.canIncludeImport = false;
			builder.schema.Items.Add(builder.notation);
		}

		private static void BuildNotation_Name(XsdBuilder builder, string value)
		{
			builder.notation.Name = value;
		}

		private static void BuildNotation_Public(XsdBuilder builder, string value)
		{
			builder.notation.Public = value;
		}

		private static void BuildNotation_System(XsdBuilder builder, string value)
		{
			builder.notation.System = value;
		}

		private static void InitFacet(XsdBuilder builder, string value)
		{
			switch (builder.CurrentElement)
			{
			case SchemaNames.Token.XsdEnumeration:
				builder.facet = new XmlSchemaEnumerationFacet();
				break;
			case SchemaNames.Token.XsdLength:
				builder.facet = new XmlSchemaLengthFacet();
				break;
			case SchemaNames.Token.XsdMaxExclusive:
				builder.facet = new XmlSchemaMaxExclusiveFacet();
				break;
			case SchemaNames.Token.XsdMaxInclusive:
				builder.facet = new XmlSchemaMaxInclusiveFacet();
				break;
			case SchemaNames.Token.XsdMaxLength:
				builder.facet = new XmlSchemaMaxLengthFacet();
				break;
			case SchemaNames.Token.XsdMinExclusive:
				builder.facet = new XmlSchemaMinExclusiveFacet();
				break;
			case SchemaNames.Token.XsdMinInclusive:
				builder.facet = new XmlSchemaMinInclusiveFacet();
				break;
			case SchemaNames.Token.XsdMinLength:
				builder.facet = new XmlSchemaMinLengthFacet();
				break;
			case SchemaNames.Token.XsdPattern:
				builder.facet = new XmlSchemaPatternFacet();
				break;
			case SchemaNames.Token.XsdTotalDigits:
				builder.facet = new XmlSchemaTotalDigitsFacet();
				break;
			case SchemaNames.Token.XsdFractionDigits:
				builder.facet = new XmlSchemaFractionDigitsFacet();
				break;
			case SchemaNames.Token.XsdWhitespace:
				builder.facet = new XmlSchemaWhiteSpaceFacet();
				break;
			}
			builder.xso = builder.facet;
			if (SchemaNames.Token.XsdSimpleTypeRestriction == builder.ParentElement)
			{
				builder.simpleTypeRestriction.Facets.Add(builder.facet);
				return;
			}
			if (builder.simpleContentRestriction.Attributes.Count != 0 || builder.simpleContentRestriction.AnyAttribute != null)
			{
				builder.SendValidationEvent("Sch_InvalidFacetPosition", null);
			}
			builder.simpleContentRestriction.Facets.Add(builder.facet);
		}

		private static void BuildFacet_Fixed(XsdBuilder builder, string value)
		{
			builder.facet.IsFixed = builder.ParseBoolean(value, "fixed");
		}

		private static void BuildFacet_Value(XsdBuilder builder, string value)
		{
			builder.facet.Value = value;
		}

		private static void InitIdentityConstraint(XsdBuilder builder, string value)
		{
			if (!builder.element.RefName.IsEmpty)
			{
				builder.SendValidationEvent("Sch_ElementRef", null);
			}
			switch (builder.CurrentElement)
			{
			case SchemaNames.Token.XsdUnique:
				builder.xso = (builder.identityConstraint = new XmlSchemaUnique());
				break;
			case SchemaNames.Token.XsdKey:
				builder.xso = (builder.identityConstraint = new XmlSchemaKey());
				break;
			case SchemaNames.Token.XsdKeyref:
				builder.xso = (builder.identityConstraint = new XmlSchemaKeyref());
				break;
			}
			builder.element.Constraints.Add(builder.identityConstraint);
		}

		private static void BuildIdentityConstraint_Name(XsdBuilder builder, string value)
		{
			builder.identityConstraint.Name = value;
		}

		private static void BuildIdentityConstraint_Refer(XsdBuilder builder, string value)
		{
			if (builder.identityConstraint is XmlSchemaKeyref)
			{
				((XmlSchemaKeyref)builder.identityConstraint).Refer = builder.ParseQName(value, "refer");
			}
			else
			{
				builder.SendValidationEvent("Sch_UnsupportedAttribute", "refer");
			}
		}

		private static void InitSelector(XsdBuilder builder, string value)
		{
			builder.xso = (builder.xpath = new XmlSchemaXPath());
			if (builder.identityConstraint.Selector == null)
			{
				builder.identityConstraint.Selector = builder.xpath;
			}
			else
			{
				builder.SendValidationEvent("Sch_DupSelector", builder.identityConstraint.Name);
			}
		}

		private static void BuildSelector_XPath(XsdBuilder builder, string value)
		{
			builder.xpath.XPath = value;
		}

		private static void InitField(XsdBuilder builder, string value)
		{
			builder.xso = (builder.xpath = new XmlSchemaXPath());
			if (builder.identityConstraint.Selector == null)
			{
				builder.SendValidationEvent("Sch_SelectorBeforeFields", builder.identityConstraint.Name);
			}
			builder.identityConstraint.Fields.Add(builder.xpath);
		}

		private static void BuildField_XPath(XsdBuilder builder, string value)
		{
			builder.xpath.XPath = value;
		}

		private static void InitAnnotation(XsdBuilder builder, string value)
		{
			if (builder.hasChild && builder.ParentElement != SchemaNames.Token.XsdSchema)
			{
				builder.SendValidationEvent("Sch_AnnotationLocation", null);
			}
			builder.xso = (builder.annotation = new XmlSchemaAnnotation());
			builder.ParentContainer.AddAnnotation(builder.annotation);
		}

		private static void InitAppinfo(XsdBuilder builder, string value)
		{
			builder.xso = (builder.appInfo = new XmlSchemaAppInfo());
			builder.annotation.Items.Add(builder.appInfo);
			builder.markup = new XmlNode[0];
		}

		private static void BuildAppinfo_Source(XsdBuilder builder, string value)
		{
			builder.appInfo.Source = ParseUriReference(value);
		}

		private static void EndAppinfo(XsdBuilder builder)
		{
			builder.appInfo.Markup = builder.markup;
		}

		private static void InitDocumentation(XsdBuilder builder, string value)
		{
			builder.xso = (builder.documentation = new XmlSchemaDocumentation());
			builder.annotation.Items.Add(builder.documentation);
			builder.markup = new XmlNode[0];
		}

		private static void BuildDocumentation_Source(XsdBuilder builder, string value)
		{
			builder.documentation.Source = ParseUriReference(value);
		}

		private static void BuildDocumentation_XmlLang(XsdBuilder builder, string value)
		{
			try
			{
				builder.documentation.Language = value;
			}
			catch (XmlSchemaException ex)
			{
				ex.SetSource(builder.reader.BaseURI, builder.positionInfo.LineNumber, builder.positionInfo.LinePosition);
				builder.SendValidationEvent(ex);
			}
		}

		private static void EndDocumentation(XsdBuilder builder)
		{
			builder.documentation.Markup = builder.markup;
		}

		private void AddAttribute(XmlSchemaObject value)
		{
			switch (ParentElement)
			{
			case SchemaNames.Token.XsdComplexType:
				if (complexType.ContentModel != null)
				{
					SendValidationEvent("Sch_AttributeMutuallyExclusive", "attribute");
				}
				if (complexType.AnyAttribute != null)
				{
					SendValidationEvent("Sch_AnyAttributeLastChild", null);
				}
				complexType.Attributes.Add(value);
				break;
			case SchemaNames.Token.XsdSimpleContentRestriction:
				if (simpleContentRestriction.AnyAttribute != null)
				{
					SendValidationEvent("Sch_AnyAttributeLastChild", null);
				}
				simpleContentRestriction.Attributes.Add(value);
				break;
			case SchemaNames.Token.XsdSimpleContentExtension:
				if (simpleContentExtension.AnyAttribute != null)
				{
					SendValidationEvent("Sch_AnyAttributeLastChild", null);
				}
				simpleContentExtension.Attributes.Add(value);
				break;
			case SchemaNames.Token.XsdComplexContentExtension:
				if (complexContentExtension.AnyAttribute != null)
				{
					SendValidationEvent("Sch_AnyAttributeLastChild", null);
				}
				complexContentExtension.Attributes.Add(value);
				break;
			case SchemaNames.Token.XsdComplexContentRestriction:
				if (complexContentRestriction.AnyAttribute != null)
				{
					SendValidationEvent("Sch_AnyAttributeLastChild", null);
				}
				complexContentRestriction.Attributes.Add(value);
				break;
			case SchemaNames.Token.xsdAttributeGroup:
				if (attributeGroup.AnyAttribute != null)
				{
					SendValidationEvent("Sch_AnyAttributeLastChild", null);
				}
				attributeGroup.Attributes.Add(value);
				break;
			}
		}

		private void AddParticle(XmlSchemaParticle particle)
		{
			switch (ParentElement)
			{
			case SchemaNames.Token.XsdComplexType:
				if (complexType.ContentModel != null || complexType.Attributes.Count != 0 || complexType.AnyAttribute != null || complexType.Particle != null)
				{
					SendValidationEvent("Sch_ComplexTypeContentModel", "complexType");
				}
				complexType.Particle = particle;
				break;
			case SchemaNames.Token.XsdComplexContentExtension:
				if (complexContentExtension.Particle != null || complexContentExtension.Attributes.Count != 0 || complexContentExtension.AnyAttribute != null)
				{
					SendValidationEvent("Sch_ComplexContentContentModel", "ComplexContentExtension");
				}
				complexContentExtension.Particle = particle;
				break;
			case SchemaNames.Token.XsdComplexContentRestriction:
				if (complexContentRestriction.Particle != null || complexContentRestriction.Attributes.Count != 0 || complexContentRestriction.AnyAttribute != null)
				{
					SendValidationEvent("Sch_ComplexContentContentModel", "ComplexContentExtension");
				}
				complexContentRestriction.Particle = particle;
				break;
			case SchemaNames.Token.XsdGroup:
				if (group.Particle != null)
				{
					SendValidationEvent("Sch_DupGroupParticle", "particle");
				}
				group.Particle = (XmlSchemaGroupBase)particle;
				break;
			case SchemaNames.Token.XsdChoice:
			case SchemaNames.Token.XsdSequence:
				((XmlSchemaGroupBase)ParentContainer).Items.Add(particle);
				break;
			}
		}

		private bool GetNextState(XmlQualifiedName qname)
		{
			if (currentEntry.NextStates != null)
			{
				State[] nextStates = currentEntry.NextStates;
				foreach (State state in nextStates)
				{
					if (schemaNames.TokenToQName[(int)SchemaEntries[(int)state].Name].Equals(qname))
					{
						nextEntry = SchemaEntries[(int)state];
						return true;
					}
				}
			}
			return false;
		}

		private bool IsSkipableElement(XmlQualifiedName qname)
		{
			if (CurrentElement != SchemaNames.Token.XsdDocumentation)
			{
				return CurrentElement == SchemaNames.Token.XsdAppInfo;
			}
			return true;
		}

		private void SetMinOccurs(XmlSchemaParticle particle, string value)
		{
			try
			{
				particle.MinOccursString = value;
			}
			catch (Exception)
			{
				SendValidationEvent("Sch_MinOccursInvalidXsd", null);
			}
		}

		private void SetMaxOccurs(XmlSchemaParticle particle, string value)
		{
			try
			{
				particle.MaxOccursString = value;
			}
			catch (Exception)
			{
				SendValidationEvent("Sch_MaxOccursInvalidXsd", null);
			}
		}

		private bool ParseBoolean(string value, string attributeName)
		{
			try
			{
				return XmlConvert.ToBoolean(value);
			}
			catch (Exception)
			{
				SendValidationEvent("Sch_InvalidXsdAttributeValue", attributeName, value, null);
				return false;
			}
		}

		private int ParseEnum(string value, string attributeName, string[] values)
		{
			string text = value.Trim();
			for (int i = 0; i < values.Length; i++)
			{
				if (values[i] == text)
				{
					return i + 1;
				}
			}
			SendValidationEvent("Sch_InvalidXsdAttributeValue", attributeName, text, null);
			return 0;
		}

		private XmlQualifiedName ParseQName(string value, string attributeName)
		{
			try
			{
				value = XmlComplianceUtil.NonCDataNormalize(value);
				string prefix;
				return XmlQualifiedName.Parse(value, namespaceManager, out prefix);
			}
			catch (Exception)
			{
				SendValidationEvent("Sch_InvalidXsdAttributeValue", attributeName, value, null);
				return XmlQualifiedName.Empty;
			}
		}

		private int ParseBlockFinalEnum(string value, string attributeName)
		{
			int num = 0;
			string[] array = XmlConvert.SplitString(value);
			for (int i = 0; i < array.Length; i++)
			{
				bool flag = false;
				for (int j = 0; j < DerivationMethodStrings.Length; j++)
				{
					if (array[i] == DerivationMethodStrings[j])
					{
						if ((num & DerivationMethodValues[j]) != 0 && (num & DerivationMethodValues[j]) != DerivationMethodValues[j])
						{
							SendValidationEvent("Sch_InvalidXsdAttributeValue", attributeName, value, null);
							return 0;
						}
						num |= DerivationMethodValues[j];
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					SendValidationEvent("Sch_InvalidXsdAttributeValue", attributeName, value, null);
					return 0;
				}
				if (num == 255 && value.Length > 4)
				{
					SendValidationEvent("Sch_InvalidXsdAttributeValue", attributeName, value, null);
					return 0;
				}
			}
			return num;
		}

		private static string ParseUriReference(string s)
		{
			return s;
		}

		private void SendValidationEvent(string code, string arg0, string arg1, string arg2)
		{
			SendValidationEvent(new XmlSchemaException(code, new string[3] { arg0, arg1, arg2 }, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition));
		}

		private void SendValidationEvent(string code, string msg)
		{
			SendValidationEvent(new XmlSchemaException(code, msg, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition));
		}

		private void SendValidationEvent(string code, string[] args, XmlSeverityType severity)
		{
			SendValidationEvent(new XmlSchemaException(code, args, reader.BaseURI, positionInfo.LineNumber, positionInfo.LinePosition), severity);
		}

		private void SendValidationEvent(XmlSchemaException e, XmlSeverityType severity)
		{
			schema.ErrorCount++;
			e.SetSchemaObject(schema);
			if (validationEventHandler != null)
			{
				validationEventHandler(null, new ValidationEventArgs(e, severity));
			}
			else if (severity == XmlSeverityType.Error)
			{
				throw e;
			}
		}

		private void SendValidationEvent(XmlSchemaException e)
		{
			SendValidationEvent(e, XmlSeverityType.Error);
		}

		private void RecordPosition()
		{
			xso.SourceUri = reader.BaseURI;
			xso.LineNumber = positionInfo.LineNumber;
			xso.LinePosition = positionInfo.LinePosition;
			if (xso != schema)
			{
				xso.Parent = ParentContainer;
			}
		}
	}
	[Flags]
	internal enum XsdDateTimeFlags
	{
		DateTime = 1,
		Time = 2,
		Date = 4,
		GYearMonth = 8,
		GYear = 0x10,
		GMonthDay = 0x20,
		GDay = 0x40,
		GMonth = 0x80,
		XdrDateTimeNoTz = 0x100,
		XdrDateTime = 0x200,
		XdrTimeNoTz = 0x400,
		AllXsd = 0xFF
	}
	internal struct XsdDateTime
	{
		private enum DateTimeTypeCode
		{
			DateTime,
			Time,
			Date,
			GYearMonth,
			GYear,
			GMonthDay,
			GDay,
			GMonth,
			XdrDateTime
		}

		private enum XsdDateTimeKind
		{
			Unspecified,
			Zulu,
			LocalWestOfZulu,
			LocalEastOfZulu
		}

		private struct Parser
		{
			private const int leapYear = 1904;

			private const int firstMonth = 1;

			private const int firstDay = 1;

			public DateTimeTypeCode typeCode;

			public int year;

			public int month;

			public int day;

			public int hour;

			public int minute;

			public int second;

			public int fraction;

			public XsdDateTimeKind kind;

			public int zoneHour;

			public int zoneMinute;

			private string text;

			private int length;

			private static int[] Power10 = new int[7] { -1, 10, 100, 1000, 10000, 100000, 1000000 };

			public bool Parse(string text, XsdDateTimeFlags kinds)
			{
				this.text = text;
				length = text.Length;
				int i;
				for (i = 0; i < length && char.IsWhiteSpace(text[i]); i++)
				{
				}
				if (Test(kinds, XsdDateTimeFlags.DateTime | XsdDateTimeFlags.Date | XsdDateTimeFlags.XdrDateTimeNoTz | XsdDateTimeFlags.XdrDateTime) && ParseDate(i))
				{
					if (Test(kinds, XsdDateTimeFlags.DateTime) && ParseChar(i + Lzyyyy_MM_dd, 'T') && ParseTimeAndZoneAndWhitespace(i + Lzyyyy_MM_ddT))
					{
						typeCode = DateTimeTypeCode.DateTime;
						return true;
					}
					if (Test(kinds, XsdDateTimeFlags.Date) && ParseZoneAndWhitespace(i + Lzyyyy_MM_dd))
					{
						typeCode = DateTimeTypeCode.Date;
						return true;
					}
					if (Test(kinds, XsdDateTimeFlags.XdrDateTime) && (ParseZoneAndWhitespace(i + Lzyyyy_MM_dd) || (ParseChar(i + Lzyyyy_MM_dd, 'T') && ParseTimeAndZoneAndWhitespace(i + Lzyyyy_MM_ddT))))
					{
						typeCode = DateTimeTypeCode.XdrDateTime;
						return true;
					}
					if (Test(kinds, XsdDateTimeFlags.XdrDateTimeNoTz))
					{
						if (!ParseChar(i + Lzyyyy_MM_dd, 'T'))
						{
							typeCode = DateTimeTypeCode.XdrDateTime;
							return true;
						}
						if (ParseTimeAndWhitespace(i + Lzyyyy_MM_ddT))
						{
							typeCode = DateTimeTypeCode.XdrDateTime;
							return true;
						}
					}
				}
				if (Test(kinds, XsdDateTimeFlags.Time) && ParseTimeAndZoneAndWhitespace(i))
				{
					year = 1904;
					month = 1;
					day = 1;
					typeCode = DateTimeTypeCode.Time;
					return true;
				}
				if (Test(kinds, XsdDateTimeFlags.XdrTimeNoTz) && ParseTimeAndWhitespace(i))
				{
					year = 1904;
					month = 1;
					day = 1;
					typeCode = DateTimeTypeCode.Time;
					return true;
				}
				if (Test(kinds, XsdDateTimeFlags.GYearMonth | XsdDateTimeFlags.GYear) && Parse4Dig(i, ref year) && 1 <= year)
				{
					if (Test(kinds, XsdDateTimeFlags.GYearMonth) && ParseChar(i + Lzyyyy, '-') && Parse2Dig(i + Lzyyyy_, ref month) && 1 <= month && month <= 12 && ParseZoneAndWhitespace(i + Lzyyyy_MM))
					{
						day = 1;
						typeCode = DateTimeTypeCode.GYearMonth;
						return true;
					}
					if (Test(kinds, XsdDateTimeFlags.GYear) && ParseZoneAndWhitespace(i + Lzyyyy))
					{
						month = 1;
						day = 1;
						typeCode = DateTimeTypeCode.GYear;
						return true;
					}
				}
				if (Test(kinds, XsdDateTimeFlags.GMonthDay | XsdDateTimeFlags.GMonth) && ParseChar(i, '-') && ParseChar(i + Lz_, '-') && Parse2Dig(i + Lz__, ref month) && 1 <= month && month <= 12)
				{
					if (Test(kinds, XsdDateTimeFlags.GMonthDay) && ParseChar(i + Lz__mm, '-') && Parse2Dig(i + Lz__mm_, ref day) && 1 <= day && day <= DateTime.DaysInMonth(1904, month) && ParseZoneAndWhitespace(i + Lz__mm_dd))
					{
						year = 1904;
						typeCode = DateTimeTypeCode.GMonthDay;
						return true;
					}
					if (Test(kinds, XsdDateTimeFlags.GMonth) && (ParseZoneAndWhitespace(i + Lz__mm) || (ParseChar(i + Lz__mm, '-') && ParseChar(i + Lz__mm_, '-') && ParseZoneAndWhitespace(i + Lz__mm__))))
					{
						year = 1904;
						day = 1;
						typeCode = DateTimeTypeCode.GMonth;
						return true;
					}
				}
				if (Test(kinds, XsdDateTimeFlags.GDay) && ParseChar(i, '-') && ParseChar(i + Lz_, '-') && ParseChar(i + Lz__, '-') && Parse2Dig(i + Lz___, ref day) && 1 <= day && day <= DateTime.DaysInMonth(1904, 1) && ParseZoneAndWhitespace(i + Lz___dd))
				{
					year = 1904;
					month = 1;
					typeCode = DateTimeTypeCode.GDay;
					return true;
				}
				return false;
			}

			private bool ParseDate(int start)
			{
				if (Parse4Dig(start, ref year) && 1 <= year && ParseChar(start + Lzyyyy, '-') && Parse2Dig(start + Lzyyyy_, ref month) && 1 <= month && month <= 12 && ParseChar(start + Lzyyyy_MM, '-') && Parse2Dig(start + Lzyyyy_MM_, ref day) && 1 <= day)
				{
					return day <= DateTime.DaysInMonth(year, month);
				}
				return false;
			}

			private bool ParseTimeAndZoneAndWhitespace(int start)
			{
				if (ParseTime(ref start) && ParseZoneAndWhitespace(start))
				{
					return true;
				}
				return false;
			}

			private bool ParseTimeAndWhitespace(int start)
			{
				if (ParseTime(ref start))
				{
					while (start < length)
					{
						start++;
					}
					return start == length;
				}
				return false;
			}

			private bool ParseTime(ref int start)
			{
				if (Parse2Dig(start, ref hour) && hour < 24 && ParseChar(start + LzHH, ':') && Parse2Dig(start + LzHH_, ref minute) && minute < 60 && ParseChar(start + LzHH_mm, ':') && Parse2Dig(start + LzHH_mm_, ref second) && second < 60)
				{
					start += LzHH_mm_ss;
					if (ParseChar(start, '.'))
					{
						fraction = 0;
						int num = 0;
						int num2 = 0;
						while (++start < length)
						{
							int num3 = text[start] - 48;
							if (9u < (uint)num3)
							{
								break;
							}
							if (num < 7)
							{
								fraction = fraction * 10 + num3;
							}
							else if (num == 7)
							{
								if (5 < num3)
								{
									num2 = 1;
								}
								else if (num3 == 5)
								{
									num2 = -1;
								}
							}
							else if (num2 < 0 && num3 != 0)
							{
								num2 = 1;
							}
							num++;
						}
						if (num < 7)
						{
							if (num == 0)
							{
								return false;
							}
							fraction *= Power10[7 - num];
						}
						else
						{
							if (num2 < 0)
							{
								num2 = fraction & 1;
							}
							fraction += num2;
						}
					}
					return true;
				}
				hour = 0;
				return false;
			}

			private bool ParseZoneAndWhitespace(int start)
			{
				if (start < length)
				{
					char c = text[start];
					if (c == 'Z' || c == 'z')
					{
						kind = XsdDateTimeKind.Zulu;
						start++;
					}
					else if (start + 5 < length && Parse2Dig(start + Lz_, ref zoneHour) && zoneHour <= 99 && ParseChar(start + Lz_zz, ':') && Parse2Dig(start + Lz_zz_, ref zoneMinute) && zoneMinute <= 99)
					{
						switch (c)
						{
						case '-':
							kind = XsdDateTimeKind.LocalWestOfZulu;
							start += Lz_zz_zz;
							break;
						case '+':
							kind = XsdDateTimeKind.LocalEastOfZulu;
							start += Lz_zz_zz;
							break;
						}
					}
				}
				while (start < length && char.IsWhiteSpace(text[start]))
				{
					start++;
				}
				return start == length;
			}

			private bool Parse4Dig(int start, ref int num)
			{
				if (start + 3 < length)
				{
					int num2 = text[start] - 48;
					int num3 = text[start + 1] - 48;
					int num4 = text[start + 2] - 48;
					int num5 = text[start + 3] - 48;
					if (0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10 && 0 <= num4 && num4 < 10 && 0 <= num5 && num5 < 10)
					{
						num = ((num2 * 10 + num3) * 10 + num4) * 10 + num5;
						return true;
					}
				}
				return false;
			}

			private bool Parse2Dig(int start, ref int num)
			{
				if (start + 1 < length)
				{
					int num2 = text[start] - 48;
					int num3 = text[start + 1] - 48;
					if (0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10)
					{
						num = num2 * 10 + num3;
						return true;
					}
				}
				return false;
			}

			private bool ParseChar(int start, char ch)
			{
				if (start < length)
				{
					return text[start] == ch;
				}
				return false;
			}

			private static bool Test(XsdDateTimeFlags left, XsdDateTimeFlags right)
			{
				return (left & right) != 0;
			}
		}

		private const uint TypeMask = 4278190080u;

		private const uint KindMask = 16711680u;

		private const uint ZoneHourMask = 65280u;

		private const uint ZoneMinuteMask = 255u;

		private const int TypeShift = 24;

		private const int KindShift = 16;

		private const int ZoneHourShift = 8;

		private const short maxFractionDigits = 7;

		private DateTime dt;

		private uint extra;

		private static readonly int Lzyyyy = "yyyy".Length;

		private static readonly int Lzyyyy_ = "yyyy-".Length;

		private static readonly int Lzyyyy_MM = "yyyy-MM".Length;

		private static readonly int Lzyyyy_MM_ = "yyyy-MM-".Length;

		private static readonly int Lzyyyy_MM_dd = "yyyy-MM-dd".Length;

		private static readonly int Lzyyyy_MM_ddT = "yyyy-MM-ddT".Length;

		private static readonly int LzHH = "HH".Length;

		private static readonly int LzHH_ = "HH:".Length;

		private static readonly int LzHH_mm = "HH:mm".Length;

		private static readonly int LzHH_mm_ = "HH:mm:".Length;

		private static readonly int LzHH_mm_ss = "HH:mm:ss".Length;

		private static readonly int Lz_ = "-".Length;

		private static readonly int Lz_zz = "-zz".Length;

		private static readonly int Lz_zz_ = "-zz:".Length;

		private static readonly int Lz_zz_zz = "-zz:zz".Length;

		private static readonly int Lz__ = "--".Length;

		private static readonly int Lz__mm = "--MM".Length;

		private static readonly int Lz__mm_ = "--MM-".Length;

		private static readonly int Lz__mm__ = "--MM--".Length;

		private static readonly int Lz__mm_dd = "--MM-dd".Length;

		private static readonly int Lz___ = "---".Length;

		private static readonly int Lz___dd = "---dd".Length;

		private static readonly XmlTypeCode[] typeCodes = new XmlTypeCode[8]
		{
			XmlTypeCode.DateTime,
			XmlTypeCode.Time,
			XmlTypeCode.Date,
			XmlTypeCode.GYearMonth,
			XmlTypeCode.GYear,
			XmlTypeCode.GMonthDay,
			XmlTypeCode.GDay,
			XmlTypeCode.GMonth
		};

		private DateTimeTypeCode InternalTypeCode => (DateTimeTypeCode)((extra & 0xFF000000u) >> 24);

		private XsdDateTimeKind InternalKind => (XsdDateTimeKind)((extra & 0xFF0000) >> 16);

		public XmlTypeCode TypeCode => typeCodes[(int)InternalTypeCode];

		public DateTimeKind Kind => InternalKind switch
		{
			XsdDateTimeKind.Unspecified => DateTimeKind.Unspecified, 
			XsdDateTimeKind.Zulu => DateTimeKind.Utc, 
			_ => DateTimeKind.Local, 
		};

		public int Year => dt.Year;

		public int Month => dt.Month;

		public int Day => dt.Day;

		public int Hour => dt.Hour;

		public int Minute => dt.Minute;

		public int Second => dt.Second;

		public int Fraction => (int)(dt.Ticks - new DateTime(dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second).Ticks);

		public int ZoneHour => (int)((extra & 0xFF00) >> 8);

		public int ZoneMinute => (int)(extra & 0xFF);

		public XsdDateTime(string text)
			: this(text, XsdDateTimeFlags.AllXsd)
		{
		}

		public XsdDateTime(string text, XsdDateTimeFlags kinds)
		{
			this = default(XsdDateTime);
			Parser parser = default(Parser);
			if (!parser.Parse(text, kinds))
			{
				throw new FormatException(Res.GetString("XmlConvert_BadFormat", text, kinds));
			}
			InitiateXsdDateTime(parser);
		}

		private XsdDateTime(Parser parser)
		{
			this = default(XsdDateTime);
			InitiateXsdDateTime(parser);
		}

		private void InitiateXsdDateTime(Parser parser)
		{
			dt = new DateTime(parser.year, parser.month, parser.day, parser.hour, parser.minute, parser.second);
			if (parser.fraction != 0)
			{
				dt = dt.AddTicks(parser.fraction);
			}
			extra = (uint)(((int)parser.typeCode << 24) | ((int)parser.kind << 16) | (parser.zoneHour << 8) | parser.zoneMinute);
		}

		internal static bool TryParse(string text, XsdDateTimeFlags kinds, out XsdDateTime result)
		{
			Parser parser = default(Parser);
			if (!parser.Parse(text, kinds))
			{
				result = default(XsdDateTime);
				return false;
			}
			result = new XsdDateTime(parser);
			return true;
		}

		public XsdDateTime(DateTime dateTime, XsdDateTimeFlags kinds)
		{
			dt = dateTime;
			DateTimeTypeCode dateTimeTypeCode = (DateTimeTypeCode)(Bits.LeastPosition((uint)kinds) - 1);
			int num = 0;
			int num2 = 0;
			XsdDateTimeKind xsdDateTimeKind;
			switch (dateTime.Kind)
			{
			case DateTimeKind.Unspecified:
				xsdDateTimeKind = XsdDateTimeKind.Unspecified;
				break;
			case DateTimeKind.Utc:
				xsdDateTimeKind = XsdDateTimeKind.Zulu;
				break;
			default:
			{
				TimeSpan utcOffset = TimeZone.CurrentTimeZone.GetUtcOffset(dateTime);
				if (utcOffset.Ticks < 0)
				{
					xsdDateTimeKind = XsdDateTimeKind.LocalWestOfZulu;
					num = -utcOffset.Hours;
					num2 = -utcOffset.Minutes;
				}
				else
				{
					xsdDateTimeKind = XsdDateTimeKind.LocalEastOfZulu;
					num = utcOffset.Hours;
					num2 = utcOffset.Minutes;
				}
				break;
			}
			}
			extra = (uint)(((int)dateTimeTypeCode << 24) | ((int)xsdDateTimeKind << 16) | (num << 8) | num2);
		}

		public XsdDateTime(DateTimeOffset dateTimeOffset)
			: this(dateTimeOffset, XsdDateTimeFlags.DateTime)
		{
		}

		public XsdDateTime(DateTimeOffset dateTimeOffset, XsdDateTimeFlags kinds)
		{
			dt = dateTimeOffset.DateTime;
			TimeSpan timeSpan = dateTimeOffset.Offset;
			DateTimeTypeCode dateTimeTypeCode = (DateTimeTypeCode)(Bits.LeastPosition((uint)kinds) - 1);
			XsdDateTimeKind xsdDateTimeKind;
			if (!(timeSpan.TotalMinutes < 0.0))
			{
				xsdDateTimeKind = ((!(timeSpan.TotalMinutes > 0.0)) ? XsdDateTimeKind.Zulu : XsdDateTimeKind.LocalEastOfZulu);
			}
			else
			{
				timeSpan = timeSpan.Negate();
				xsdDateTimeKind = XsdDateTimeKind.LocalWestOfZulu;
			}
			extra = (uint)(((int)dateTimeTypeCode << 24) | ((int)xsdDateTimeKind << 16) | (timeSpan.Hours << 8) | timeSpan.Minutes);
		}

		public DateTime ToZulu()
		{
			return InternalKind switch
			{
				XsdDateTimeKind.Zulu => new DateTime(dt.Ticks, DateTimeKind.Utc), 
				XsdDateTimeKind.LocalEastOfZulu => new DateTime(dt.Subtract(new TimeSpan(ZoneHour, ZoneMinute, 0)).Ticks, DateTimeKind.Utc), 
				XsdDateTimeKind.LocalWestOfZulu => new DateTime(dt.Add(new TimeSpan(ZoneHour, ZoneMinute, 0)).Ticks, DateTimeKind.Utc), 
				_ => dt, 
			};
		}

		public static implicit operator DateTime(XsdDateTime xdt)
		{
			DateTime result;
			switch (xdt.InternalTypeCode)
			{
			case DateTimeTypeCode.GDay:
			case DateTimeTypeCode.GMonth:
				result = new DateTime(DateTime.Now.Year, xdt.Month, xdt.Day);
				break;
			case DateTimeTypeCode.Time:
			{
				DateTime now = DateTime.Now;
				TimeSpan value = new DateTime(now.Year, now.Month, now.Day) - new DateTime(xdt.Year, xdt.Month, xdt.Day);
				result = xdt.dt.Add(value);
				break;
			}
			default:
				result = xdt.dt;
				break;
			}
			switch (xdt.InternalKind)
			{
			case XsdDateTimeKind.Zulu:
				result = new DateTime(result.Ticks, DateTimeKind.Utc);
				break;
			case XsdDateTimeKind.LocalEastOfZulu:
				try
				{
					result = result.Subtract(new TimeSpan(xdt.ZoneHour, xdt.ZoneMinute, 0));
				}
				catch (ArgumentOutOfRangeException)
				{
					return new DateTime(DateTime.MinValue.Ticks, DateTimeKind.Local);
				}
				result = new DateTime(result.Ticks, DateTimeKind.Utc).ToLocalTime();
				break;
			case XsdDateTimeKind.LocalWestOfZulu:
				try
				{
					result = result.Add(new TimeSpan(xdt.ZoneHour, xdt.ZoneMinute, 0));
				}
				catch (ArgumentOutOfRangeException)
				{
					return new DateTime(DateTime.MaxValue.Ticks, DateTimeKind.Local);
				}
				result = new DateTime(result.Ticks, DateTimeKind.Utc).ToLocalTime();
				break;
			}
			return result;
		}

		public static implicit operator DateTimeOffset(XsdDateTime xdt)
		{
			DateTime dateTime;
			switch (xdt.InternalTypeCode)
			{
			case DateTimeTypeCode.GDay:
			case DateTimeTypeCode.GMonth:
				dateTime = new DateTime(DateTime.Now.Year, xdt.Month, xdt.Day);
				break;
			case DateTimeTypeCode.Time:
			{
				DateTime now = DateTime.Now;
				TimeSpan value = new DateTime(now.Year, now.Month, now.Day) - new DateTime(xdt.Year, xdt.Month, xdt.Day);
				dateTime = xdt.dt.Add(value);
				break;
			}
			default:
				dateTime = xdt.dt;
				break;
			}
			return xdt.InternalKind switch
			{
				XsdDateTimeKind.LocalEastOfZulu => new DateTimeOffset(dateTime, new TimeSpan(xdt.ZoneHour, xdt.ZoneMinute, 0)), 
				XsdDateTimeKind.LocalWestOfZulu => new DateTimeOffset(dateTime, new TimeSpan(-xdt.ZoneHour, -xdt.ZoneMinute, 0)), 
				XsdDateTimeKind.Zulu => new DateTimeOffset(dateTime, new TimeSpan(0L)), 
				_ => new DateTimeOffset(dateTime, TimeZone.CurrentTimeZone.GetUtcOffset(dateTime)), 
			};
		}

		public static int Compare(XsdDateTime left, XsdDateTime right)
		{
			if (left.extra == right.extra)
			{
				return DateTime.Compare(left.dt, right.dt);
			}
			if (left.InternalTypeCode != right.InternalTypeCode)
			{
				throw new ArgumentException(Res.GetString("Sch_XsdDateTimeCompare", left.TypeCode, right.TypeCode));
			}
			return DateTime.Compare(left.GetZuluDateTime(), right.GetZuluDateTime());
		}

		public int CompareTo(object value)
		{
			if (value == null)
			{
				return 1;
			}
			return Compare(this, (XsdDateTime)value);
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			switch (InternalTypeCode)
			{
			case DateTimeTypeCode.DateTime:
				PrintDate(stringBuilder);
				stringBuilder.Append('T');
				PrintTime(stringBuilder);
				break;
			case DateTimeTypeCode.Time:
				PrintTime(stringBuilder);
				break;
			case DateTimeTypeCode.Date:
				PrintDate(stringBuilder);
				break;
			case DateTimeTypeCode.GYearMonth:
			{
				char[] array = new char[Lzyyyy_MM];
				IntToCharArray(array, 0, Year, 4);
				array[Lzyyyy] = '-';
				ShortToCharArray(array, Lzyyyy_, Month);
				stringBuilder.Append(array);
				break;
			}
			case DateTimeTypeCode.GYear:
			{
				char[] array = new char[Lzyyyy];
				IntToCharArray(array, 0, Year, 4);
				stringBuilder.Append(array);
				break;
			}
			case DateTimeTypeCode.GMonthDay:
			{
				char[] array = new char[Lz__mm_dd];
				array[0] = '-';
				array[Lz_] = '-';
				ShortToCharArray(array, Lz__, Month);
				array[Lz__mm] = '-';
				ShortToCharArray(array, Lz__mm_, Day);
				stringBuilder.Append(array);
				break;
			}
			case DateTimeTypeCode.GDay:
			{
				char[] array = new char[Lz___dd];
				array[0] = '-';
				array[Lz_] = '-';
				array[Lz__] = '-';
				ShortToCharArray(array, Lz___, Day);
				stringBuilder.Append(array);
				break;
			}
			case DateTimeTypeCode.GMonth:
			{
				char[] array = new char[Lz__mm__];
				array[0] = '-';
				array[Lz_] = '-';
				ShortToCharArray(array, Lz__, Month);
				array[Lz__mm] = '-';
				array[Lz__mm_] = '-';
				stringBuilder.Append(array);
				break;
			}
			}
			PrintZone(stringBuilder);
			return stringBuilder.ToString();
		}

		private void PrintDate(StringBuilder sb)
		{
			char[] array = new char[Lzyyyy_MM_dd];
			IntToCharArray(array, 0, Year, 4);
			array[Lzyyyy] = '-';
			ShortToCharArray(array, Lzyyyy_, Month);
			array[Lzyyyy_MM] = '-';
			ShortToCharArray(array, Lzyyyy_MM_, Day);
			sb.Append(array);
		}

		private void PrintTime(StringBuilder sb)
		{
			char[] array = new char[LzHH_mm_ss];
			ShortToCharArray(array, 0, Hour);
			array[LzHH] = ':';
			ShortToCharArray(array, LzHH_, Minute);
			array[LzHH_mm] = ':';
			ShortToCharArray(array, LzHH_mm_, Second);
			sb.Append(array);
			int num = Fraction;
			if (num != 0)
			{
				int num2 = 7;
				while (num % 10 == 0)
				{
					num2--;
					num /= 10;
				}
				array = new char[num2 + 1];
				array[0] = '.';
				IntToCharArray(array, 1, num, num2);
				sb.Append(array);
			}
		}

		private void PrintZone(StringBuilder sb)
		{
			switch (InternalKind)
			{
			case XsdDateTimeKind.Zulu:
				sb.Append('Z');
				break;
			case XsdDateTimeKind.LocalWestOfZulu:
			{
				char[] array = new char[Lz_zz_zz];
				array[0] = '-';
				ShortToCharArray(array, Lz_, ZoneHour);
				array[Lz_zz] = ':';
				ShortToCharArray(array, Lz_zz_, ZoneMinute);
				sb.Append(array);
				break;
			}
			case XsdDateTimeKind.LocalEastOfZulu:
			{
				char[] array = new char[Lz_zz_zz];
				array[0] = '+';
				ShortToCharArray(array, Lz_, ZoneHour);
				array[Lz_zz] = ':';
				ShortToCharArray(array, Lz_zz_, ZoneMinute);
				sb.Append(array);
				break;
			}
			}
		}

		private void IntToCharArray(char[] text, int start, int value, int digits)
		{
			while (digits-- != 0)
			{
				text[start + digits] = (char)(value % 10 + 48);
				value /= 10;
			}
		}

		private void ShortToCharArray(char[] text, int start, int value)
		{
			text[start] = (char)(value / 10 + 48);
			text[start + 1] = (char)(value % 10 + 48);
		}

		private DateTime GetZuluDateTime()
		{
			return InternalKind switch
			{
				XsdDateTimeKind.Zulu => dt, 
				XsdDateTimeKind.LocalEastOfZulu => dt.Subtract(new TimeSpan(ZoneHour, ZoneMinute, 0)), 
				XsdDateTimeKind.LocalWestOfZulu => dt.Add(new TimeSpan(ZoneHour, ZoneMinute, 0)), 
				_ => dt.ToUniversalTime(), 
			};
		}
	}
	internal struct XsdDuration
	{
		private enum Parts
		{
			HasNone = 0,
			HasYears = 1,
			HasMonths = 2,
			HasDays = 4,
			HasHours = 8,
			HasMinutes = 0x10,
			HasSeconds = 0x20
		}

		internal enum DurationType
		{
			Duration,
			YearMonthDuration,
			DayTimeDuration
		}

		private const uint NegativeBit = 2147483648u;

		private int years;

		private int months;

		private int days;

		private int hours;

		private int minutes;

		private int seconds;

		private uint nanoseconds;

		public bool IsNegative => (nanoseconds & 0x80000000u) != 0;

		public int Years => years;

		public int Months => months;

		public int Days => days;

		public int Hours => hours;

		public int Minutes => minutes;

		public int Seconds => seconds;

		public int Nanoseconds => (int)(nanoseconds & 0x7FFFFFFF);

		public int Microseconds => Nanoseconds / 1000;

		public int Milliseconds => Nanoseconds / 1000000;

		public XsdDuration(bool isNegative, int years, int months, int days, int hours, int minutes, int seconds, int nanoseconds)
		{
			if (years < 0)
			{
				throw new ArgumentOutOfRangeException("years");
			}
			if (months < 0)
			{
				throw new ArgumentOutOfRangeException("months");
			}
			if (days < 0)
			{
				throw new ArgumentOutOfRangeException("days");
			}
			if (hours < 0)
			{
				throw new ArgumentOutOfRangeException("hours");
			}
			if (minutes < 0)
			{
				throw new ArgumentOutOfRangeException("minutes");
			}
			if (seconds < 0)
			{
				throw new ArgumentOutOfRangeException("seconds");
			}
			if (nanoseconds < 0 || nanoseconds > 999999999)
			{
				throw new ArgumentOutOfRangeException("nanoseconds");
			}
			this.years = years;
			this.months = months;
			this.days = days;
			this.hours = hours;
			this.minutes = minutes;
			this.seconds = seconds;
			this.nanoseconds = (uint)nanoseconds;
			if (isNegative)
			{
				this.nanoseconds |= 2147483648u;
			}
		}

		public XsdDuration(TimeSpan timeSpan)
			: this(timeSpan, DurationType.Duration)
		{
		}

		internal XsdDuration(TimeSpan timeSpan, DurationType durationType)
		{
			long ticks = timeSpan.Ticks;
			bool flag;
			ulong num;
			if (ticks < 0)
			{
				flag = true;
				num = (ulong)(-ticks);
			}
			else
			{
				flag = false;
				num = (ulong)ticks;
			}
			if (durationType == DurationType.YearMonthDuration)
			{
				int num2 = (int)(num / 315360000000000uL);
				int num3 = (int)(num % 315360000000000uL / 25920000000000uL);
				if (num3 == 12)
				{
					num2++;
					num3 = 0;
				}
				this = new XsdDuration(flag, num2, num3, 0, 0, 0, 0, 0);
				return;
			}
			nanoseconds = (uint)((int)(num % 10000000uL) * 100);
			if (flag)
			{
				nanoseconds |= 2147483648u;
			}
			years = 0;
			months = 0;
			days = (int)(num / 864000000000uL);
			hours = (int)(num / 36000000000uL % 24uL);
			minutes = (int)(num / 600000000uL % 60uL);
			seconds = (int)(num / 10000000uL % 60uL);
		}

		public XsdDuration(string s)
			: this(s, DurationType.Duration)
		{
		}

		public XsdDuration(string s, DurationType durationType)
		{
			XsdDuration result;
			Exception ex = TryParse(s, durationType, out result);
			if (ex != null)
			{
				throw ex;
			}
			years = result.Years;
			months = result.Months;
			days = result.Days;
			hours = result.Hours;
			minutes = result.Minutes;
			seconds = result.Seconds;
			nanoseconds = (uint)result.Nanoseconds;
			if (result.IsNegative)
			{
				nanoseconds |= 2147483648u;
			}
		}

		public XsdDuration Normalize()
		{
			int num = Years;
			int num2 = Months;
			int num3 = Days;
			int num4 = Hours;
			int num5 = Minutes;
			int num6 = Seconds;
			try
			{
				if (num2 >= 12)
				{
					checked
					{
						num += unchecked(num2 / 12);
					}
					num2 %= 12;
				}
				if (num6 >= 60)
				{
					checked
					{
						num5 += unchecked(num6 / 60);
					}
					num6 %= 60;
				}
				if (num5 >= 60)
				{
					checked
					{
						num4 += unchecked(num5 / 60);
					}
					num5 %= 60;
				}
				if (num4 >= 24)
				{
					checked
					{
						num3 += unchecked(num4 / 24);
					}
					num4 %= 24;
				}
			}
			catch (OverflowException)
			{
				throw new OverflowException(Res.GetString("XmlConvert_Overflow", ToString(), "Duration"));
			}
			return new XsdDuration(IsNegative, num, num2, num3, num4, num5, num6, Nanoseconds);
		}

		public TimeSpan ToTimeSpan()
		{
			return ToTimeSpan(DurationType.Duration);
		}

		internal TimeSpan ToTimeSpan(DurationType durationType)
		{
			TimeSpan result;
			Exception ex = TryToTimeSpan(durationType, out result);
			if (ex != null)
			{
				throw ex;
			}
			return result;
		}

		internal Exception TryToTimeSpan(out TimeSpan result)
		{
			return TryToTimeSpan(DurationType.Duration, out result);
		}

		internal Exception TryToTimeSpan(DurationType durationType, out TimeSpan result)
		{
			Exception ex = null;
			ulong num = 0uL;
			checked
			{
				try
				{
					if (durationType != DurationType.DayTimeDuration)
					{
						num += ((ulong)years + unchecked(checked((ulong)months) / 12uL)) * 365uL;
						num += unchecked(checked((ulong)months) % 12uL) * 30uL;
					}
					if (durationType != DurationType.YearMonthDuration)
					{
						num += (ulong)days;
						num *= 24uL;
						num += (ulong)hours;
						num *= 60uL;
						num += (ulong)minutes;
						num *= 60uL;
						num += (ulong)seconds;
						num *= 10000000uL;
						num += unchecked(checked((ulong)Nanoseconds) / 100uL);
					}
					else
					{
						num *= 864000000000uL;
					}
					if (IsNegative)
					{
						if (num == 9223372036854775808uL)
						{
							result = new TimeSpan(long.MinValue);
						}
						else
						{
							result = new TimeSpan(-(long)num);
						}
					}
					else
					{
						result = new TimeSpan((long)num);
					}
					return null;
				}
				catch (OverflowException)
				{
					result = TimeSpan.MinValue;
					return new OverflowException(Res.GetString("XmlConvert_Overflow", durationType, "TimeSpan"));
				}
			}
		}

		public override string ToString()
		{
			return ToString(DurationType.Duration);
		}

		internal string ToString(DurationType durationType)
		{
			StringBuilder stringBuilder = new StringBuilder(20);
			if (IsNegative)
			{
				stringBuilder.Append('-');
			}
			stringBuilder.Append('P');
			if (durationType != DurationType.DayTimeDuration)
			{
				if (years != 0)
				{
					stringBuilder.Append(XmlConvert.ToString(years));
					stringBuilder.Append('Y');
				}
				if (months != 0)
				{
					stringBuilder.Append(XmlConvert.ToString(months));
					stringBuilder.Append('M');
				}
			}
			if (durationType != DurationType.YearMonthDuration)
			{
				if (days != 0)
				{
					stringBuilder.Append(XmlConvert.ToString(days));
					stringBuilder.Append('D');
				}
				if (hours != 0 || minutes != 0 || seconds != 0 || Nanoseconds != 0)
				{
					stringBuilder.Append('T');
					if (hours != 0)
					{
						stringBuilder.Append(XmlConvert.ToString(hours));
						stringBuilder.Append('H');
					}
					if (minutes != 0)
					{
						stringBuilder.Append(XmlConvert.ToString(minutes));
						stringBuilder.Append('M');
					}
					int num = Nanoseconds;
					if (seconds != 0 || num != 0)
					{
						stringBuilder.Append(XmlConvert.ToString(seconds));
						if (num != 0)
						{
							stringBuilder.Append('.');
							int length = stringBuilder.Length;
							stringBuilder.Length += 9;
							int num2 = stringBuilder.Length - 1;
							for (int num3 = num2; num3 >= length; num3--)
							{
								int num4 = num % 10;
								stringBuilder[num3] = (char)(num4 + 48);
								if (num2 == num3 && num4 == 0)
								{
									num2--;
								}
								num /= 10;
							}
							stringBuilder.Length = num2 + 1;
						}
						stringBuilder.Append('S');
					}
				}
				if (stringBuilder[stringBuilder.Length - 1] == 'P')
				{
					stringBuilder.Append("T0S");
				}
			}
			else if (stringBuilder[stringBuilder.Length - 1] == 'P')
			{
				stringBuilder.Append("0M");
			}
			return stringBuilder.ToString();
		}

		internal static Exception TryParse(string s, out XsdDuration result)
		{
			return TryParse(s, DurationType.Duration, out result);
		}

		internal static Exception TryParse(string s, DurationType durationType, out XsdDuration result)
		{
			Parts parts = Parts.HasNone;
			result = default(XsdDuration);
			s = s.Trim();
			int length = s.Length;
			int offset = 0;
			int i = 0;
			int result2;
			if (offset < length)
			{
				if (s[offset] == '-')
				{
					offset++;
					result.nanoseconds = 2147483648u;
				}
				else
				{
					result.nanoseconds = 0u;
				}
				if (offset < length && s[offset++] == 'P')
				{
					string text = TryParseDigits(s, ref offset, eatDigits: false, out result2, out i);
					if (text != null)
					{
						goto IL_0301;
					}
					if (offset < length)
					{
						if (s[offset] != 'Y')
						{
							goto IL_00c1;
						}
						if (i != 0)
						{
							parts |= Parts.HasYears;
							result.years = result2;
							if (++offset == length)
							{
								goto IL_02bb;
							}
							text = TryParseDigits(s, ref offset, eatDigits: false, out result2, out i);
							if (text != null)
							{
								goto IL_0301;
							}
							if (offset < length)
							{
								goto IL_00c1;
							}
						}
					}
				}
			}
			goto IL_02d8;
			IL_02bb:
			if (parts != 0)
			{
				if (durationType == DurationType.DayTimeDuration)
				{
					if ((parts & (Parts)3) == 0)
					{
						goto IL_02d6;
					}
				}
				else if (durationType != DurationType.YearMonthDuration || (parts & (Parts)(-4)) == 0)
				{
					goto IL_02d6;
				}
			}
			goto IL_02d8;
			IL_00c1:
			if (s[offset] != 'M')
			{
				goto IL_0106;
			}
			if (i != 0)
			{
				parts |= Parts.HasMonths;
				result.months = result2;
				if (++offset == length)
				{
					goto IL_02bb;
				}
				string text = TryParseDigits(s, ref offset, eatDigits: false, out result2, out i);
				if (text != null)
				{
					goto IL_0301;
				}
				if (offset < length)
				{
					goto IL_0106;
				}
			}
			goto IL_02d8;
			IL_014b:
			if (s[offset] != 'T')
			{
				goto IL_02b3;
			}
			if (i == 0)
			{
				offset++;
				string text = TryParseDigits(s, ref offset, eatDigits: false, out result2, out i);
				if (text != null)
				{
					goto IL_0301;
				}
				if (offset < length)
				{
					if (s[offset] != 'H')
					{
						goto IL_01c4;
					}
					if (i != 0)
					{
						parts |= Parts.HasHours;
						result.hours = result2;
						if (++offset == length)
						{
							goto IL_02bb;
						}
						text = TryParseDigits(s, ref offset, eatDigits: false, out result2, out i);
						if (text != null)
						{
							goto IL_0301;
						}
						if (offset < length)
						{
							goto IL_01c4;
						}
					}
				}
			}
			goto IL_02d8;
			IL_020a:
			if (s[offset] == '.')
			{
				offset++;
				parts |= Parts.HasSeconds;
				result.seconds = result2;
				string text = TryParseDigits(s, ref offset, eatDigits: true, out result2, out i);
				if (text != null)
				{
					goto IL_0301;
				}
				if (i == 0)
				{
					result2 = 0;
				}
				while (i > 9)
				{
					result2 /= 10;
					i--;
				}
				for (; i < 9; i++)
				{
					result2 *= 10;
				}
				result.nanoseconds |= (uint)result2;
				if (offset >= length || s[offset] != 'S')
				{
					goto IL_02d8;
				}
				if (++offset == length)
				{
					goto IL_02bb;
				}
			}
			else if (s[offset] == 'S')
			{
				if (i == 0)
				{
					goto IL_02d8;
				}
				parts |= Parts.HasSeconds;
				result.seconds = result2;
				if (++offset == length)
				{
					goto IL_02bb;
				}
			}
			goto IL_02b3;
			IL_02d6:
			return null;
			IL_01c4:
			if (s[offset] != 'M')
			{
				goto IL_020a;
			}
			if (i != 0)
			{
				parts |= Parts.HasMinutes;
				result.minutes = result2;
				if (++offset == length)
				{
					goto IL_02bb;
				}
				string text = TryParseDigits(s, ref offset, eatDigits: false, out result2, out i);
				if (text != null)
				{
					goto IL_0301;
				}
				if (offset < length)
				{
					goto IL_020a;
				}
			}
			goto IL_02d8;
			IL_02b3:
			if (i == 0 && offset == length)
			{
				goto IL_02bb;
			}
			goto IL_02d8;
			IL_0106:
			if (s[offset] != 'D')
			{
				goto IL_014b;
			}
			if (i != 0)
			{
				parts |= Parts.HasDays;
				result.days = result2;
				if (++offset == length)
				{
					goto IL_02bb;
				}
				string text = TryParseDigits(s, ref offset, eatDigits: false, out result2, out i);
				if (text != null)
				{
					goto IL_0301;
				}
				if (offset < length)
				{
					goto IL_014b;
				}
			}
			goto IL_02d8;
			IL_0301:
			return new OverflowException(Res.GetString("XmlConvert_Overflow", s, durationType));
			IL_02d8:
			return new FormatException(Res.GetString("XmlConvert_BadFormat", s, durationType));
		}

		private static string TryParseDigits(string s, ref int offset, bool eatDigits, out int result, out int numDigits)
		{
			int num = offset;
			int length = s.Length;
			result = 0;
			numDigits = 0;
			while (offset < length && s[offset] >= '0' && s[offset] <= '9')
			{
				int num2 = s[offset] - 48;
				if (result > (int.MaxValue - num2) / 10)
				{
					if (!eatDigits)
					{
						return "XmlConvert_Overflow";
					}
					numDigits = offset - num;
					while (offset < length && s[offset] >= '0' && s[offset] <= '9')
					{
						offset++;
					}
					return null;
				}
				result = result * 10 + num2;
				offset++;
			}
			numDigits = offset - num;
			return null;
		}
	}
	internal sealed class XsdValidator : BaseValidator
	{
		private const int STACK_INCREMENT = 10;

		private int startIDConstraint = -1;

		private HWStack validationStack;

		private Hashtable attPresence;

		private XmlNamespaceManager nsManager;

		private bool bManageNamespaces;

		private Hashtable IDs;

		private IdRefNode idRefListHead;

		private Parser inlineSchemaParser;

		private XmlSchemaContentProcessing processContents;

		private static readonly XmlSchemaDatatype dtCDATA = XmlSchemaDatatype.FromXmlTokenizedType(XmlTokenizedType.CDATA);

		private static readonly XmlSchemaDatatype dtQName = XmlSchemaDatatype.FromXmlTokenizedTypeXsd(XmlTokenizedType.QName);

		private static readonly XmlSchemaDatatype dtStringArray = dtCDATA.DeriveByList(null);

		private string NsXmlNs;

		private string NsXs;

		private string NsXsi;

		private string XsiType;

		private string XsiNil;

		private string XsiSchemaLocation;

		private string XsiNoNamespaceSchemaLocation;

		private string XsdSchema;

		public ValidationState Context
		{
			set
			{
				context = value;
			}
		}

		public static XmlSchemaDatatype DtQName => dtQName;

		private bool IsInlineSchemaStarted => inlineSchemaParser != null;

		private bool HasSchema => schemaInfo.SchemaType != SchemaType.None;

		public override bool PreserveWhitespace
		{
			get
			{
				if (context.ElementDecl == null)
				{
					return false;
				}
				return context.ElementDecl.ContentValidator.PreserveWhitespace;
			}
		}

		private bool HasIdentityConstraints => startIDConstraint != -1;

		internal XsdValidator(BaseValidator validator)
			: base(validator)
		{
			Init();
		}

		internal XsdValidator(XmlValidatingReaderImpl reader, XmlSchemaCollection schemaCollection, ValidationEventHandler eventHandler)
			: base(reader, schemaCollection, eventHandler)
		{
			Init();
		}

		private void Init()
		{
			nsManager = reader.NamespaceManager;
			if (nsManager == null)
			{
				nsManager = new XmlNamespaceManager(base.NameTable);
				bManageNamespaces = true;
			}
			validationStack = new HWStack(10);
			textValue = new StringBuilder();
			attPresence = new Hashtable();
			schemaInfo = new SchemaInfo();
			checkDatatype = false;
			processContents = XmlSchemaContentProcessing.Strict;
			Push(XmlQualifiedName.Empty);
			NsXmlNs = base.NameTable.Add("http://www.w3.org/2000/xmlns/");
			NsXs = base.NameTable.Add("http://www.w3.org/2001/XMLSchema");
			NsXsi = base.NameTable.Add("http://www.w3.org/2001/XMLSchema-instance");
			XsiType = base.NameTable.Add("type");
			XsiNil = base.NameTable.Add("nil");
			XsiSchemaLocation = base.NameTable.Add("schemaLocation");
			XsiNoNamespaceSchemaLocation = base.NameTable.Add("noNamespaceSchemaLocation");
			XsdSchema = base.NameTable.Add("schema");
		}

		public override void Validate()
		{
			if (IsInlineSchemaStarted)
			{
				ProcessInlineSchema();
				return;
			}
			switch (reader.NodeType)
			{
			case XmlNodeType.Element:
				ValidateElement();
				if (reader.IsEmptyElement)
				{
					goto case XmlNodeType.EndElement;
				}
				break;
			case XmlNodeType.Whitespace:
				ValidateWhitespace();
				break;
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.SignificantWhitespace:
				ValidateText();
				break;
			case XmlNodeType.EndElement:
				ValidateEndElement();
				break;
			}
		}

		public override void CompleteValidation()
		{
			CheckForwardRefs();
		}

		private void ProcessInlineSchema()
		{
			if (inlineSchemaParser.ParseReaderNode())
			{
				return;
			}
			inlineSchemaParser.FinishParsing();
			XmlSchema xmlSchema = inlineSchemaParser.XmlSchema;
			string text = null;
			if (xmlSchema != null && xmlSchema.ErrorCount == 0)
			{
				try
				{
					SchemaInfo schemaInfo = new SchemaInfo();
					schemaInfo.SchemaType = SchemaType.XSD;
					text = ((xmlSchema.TargetNamespace == null) ? string.Empty : xmlSchema.TargetNamespace);
					if (!base.SchemaInfo.TargetNamespaces.Contains(text) && base.SchemaCollection.Add(text, schemaInfo, xmlSchema, compile: true) != null)
					{
						base.SchemaInfo.Add(schemaInfo, base.EventHandler);
					}
				}
				catch (XmlSchemaException ex)
				{
					SendValidationEvent("Sch_CannotLoadSchema", new string[2]
					{
						base.BaseUri.AbsoluteUri,
						ex.Message
					}, XmlSeverityType.Error);
				}
			}
			inlineSchemaParser = null;
		}

		private void ValidateElement()
		{
			elementName.Init(reader.LocalName, reader.NamespaceURI);
			object particle = ValidateChildElement();
			if (IsXSDRoot(elementName.Name, elementName.Namespace) && reader.Depth > 0)
			{
				inlineSchemaParser = new Parser(SchemaType.XSD, base.NameTable, base.SchemaNames, base.EventHandler);
				inlineSchemaParser.StartParsing(reader, null);
				inlineSchemaParser.ParseReaderNode();
			}
			else
			{
				ProcessElement(particle);
			}
		}

		private object ValidateChildElement()
		{
			object obj = null;
			int errorCode = 0;
			if (context.NeedValidateChildren)
			{
				if (context.IsNill)
				{
					SendValidationEvent("Sch_ContentInNill", elementName.ToString());
					return null;
				}
				obj = context.ElementDecl.ContentValidator.ValidateElement(elementName, context, out errorCode);
				if (obj == null)
				{
					processContents = (context.ProcessContents = XmlSchemaContentProcessing.Skip);
					if (errorCode == -2)
					{
						SendValidationEvent("Sch_AllElement", elementName.ToString());
					}
					XmlSchemaValidator.ElementValidationError(elementName, context, base.EventHandler, reader, reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition, getParticles: false);
				}
			}
			return obj;
		}

		private void ProcessElement(object particle)
		{
			SchemaElementDecl schemaElementDecl = FastGetElementDecl(particle);
			Push(elementName);
			if (bManageNamespaces)
			{
				nsManager.PushScope();
			}
			ProcessXsiAttributes(out var xsiType, out var xsiNil);
			if (processContents != XmlSchemaContentProcessing.Skip)
			{
				if (schemaElementDecl == null || !xsiType.IsEmpty || xsiNil != null)
				{
					schemaElementDecl = ThoroughGetElementDecl(schemaElementDecl, xsiType, xsiNil);
				}
				if (schemaElementDecl == null)
				{
					if (HasSchema && processContents == XmlSchemaContentProcessing.Strict)
					{
						SendValidationEvent("Sch_UndeclaredElement", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
					}
					else
					{
						SendValidationEvent("Sch_NoElementSchemaFound", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace), XmlSeverityType.Warning);
					}
				}
			}
			context.ElementDecl = schemaElementDecl;
			ValidateStartElementIdentityConstraints();
			ValidateStartElement();
			if (context.ElementDecl != null)
			{
				ValidateEndStartElement();
				context.NeedValidateChildren = processContents != XmlSchemaContentProcessing.Skip;
				context.ElementDecl.ContentValidator.InitValidation(context);
			}
		}

		private void ProcessXsiAttributes(out XmlQualifiedName xsiType, out string xsiNil)
		{
			string[] array = null;
			string text = null;
			xsiType = XmlQualifiedName.Empty;
			xsiNil = null;
			if (reader.Depth == 0)
			{
				LoadSchema(string.Empty, null);
				foreach (string value in nsManager.GetNamespacesInScope(XmlNamespaceScope.ExcludeXml).Values)
				{
					LoadSchema(value, null);
				}
			}
			if (reader.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = reader.NamespaceURI;
					string localName = reader.LocalName;
					if (Ref.Equal(namespaceURI, NsXmlNs))
					{
						LoadSchema(reader.Value, null);
						if (bManageNamespaces)
						{
							nsManager.AddNamespace((reader.Prefix.Length == 0) ? string.Empty : reader.LocalName, reader.Value);
						}
					}
					else if (Ref.Equal(namespaceURI, NsXsi))
					{
						if (Ref.Equal(localName, XsiSchemaLocation))
						{
							array = (string[])dtStringArray.ParseValue(reader.Value, base.NameTable, nsManager);
						}
						else if (Ref.Equal(localName, XsiNoNamespaceSchemaLocation))
						{
							text = reader.Value;
						}
						else if (Ref.Equal(localName, XsiType))
						{
							xsiType = (XmlQualifiedName)dtQName.ParseValue(reader.Value, base.NameTable, nsManager);
						}
						else if (Ref.Equal(localName, XsiNil))
						{
							xsiNil = reader.Value;
						}
					}
				}
				while (reader.MoveToNextAttribute());
				reader.MoveToElement();
			}
			if (text != null)
			{
				LoadSchema(string.Empty, text);
			}
			if (array != null)
			{
				for (int i = 0; i < array.Length - 1; i += 2)
				{
					LoadSchema(array[i], array[i + 1]);
				}
			}
		}

		private void ValidateEndElement()
		{
			if (bManageNamespaces)
			{
				nsManager.PopScope();
			}
			if (context.ElementDecl != null)
			{
				if (!context.IsNill)
				{
					if (context.NeedValidateChildren && !context.ElementDecl.ContentValidator.CompleteValidation(context))
					{
						XmlSchemaValidator.CompleteValidationError(context, base.EventHandler, reader, reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition, getParticles: false);
					}
					if (checkDatatype && !context.IsNill)
					{
						string text = ((!hasSibling) ? textString : textValue.ToString());
						if (text.Length != 0 || context.ElementDecl.DefaultValueTyped == null)
						{
							CheckValue(text, null);
							checkDatatype = false;
						}
					}
				}
				if (HasIdentityConstraints)
				{
					EndElementIdentityConstraints();
				}
			}
			Pop();
		}

		private SchemaElementDecl FastGetElementDecl(object particle)
		{
			SchemaElementDecl result = null;
			if (particle != null)
			{
				if (particle is XmlSchemaElement xmlSchemaElement)
				{
					result = xmlSchemaElement.ElementDecl;
				}
				else
				{
					XmlSchemaAny xmlSchemaAny = (XmlSchemaAny)particle;
					processContents = xmlSchemaAny.ProcessContentsCorrect;
				}
			}
			return result;
		}

		private SchemaElementDecl ThoroughGetElementDecl(SchemaElementDecl elementDecl, XmlQualifiedName xsiType, string xsiNil)
		{
			if (elementDecl == null)
			{
				elementDecl = schemaInfo.GetElementDecl(elementName);
			}
			if (elementDecl != null)
			{
				if (xsiType.IsEmpty)
				{
					if (elementDecl.IsAbstract)
					{
						SendValidationEvent("Sch_AbstractElement", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
						elementDecl = null;
					}
				}
				else if (xsiNil != null && xsiNil.Equals("true"))
				{
					SendValidationEvent("Sch_XsiNilAndType");
				}
				else
				{
					SchemaElementDecl schemaElementDecl = (SchemaElementDecl)schemaInfo.ElementDeclsByType[xsiType];
					if (schemaElementDecl == null && xsiType.Namespace == NsXs)
					{
						XmlSchemaSimpleType simpleTypeFromXsdType = DatatypeImplementation.GetSimpleTypeFromXsdType(new XmlQualifiedName(xsiType.Name, NsXs));
						if (simpleTypeFromXsdType != null)
						{
							schemaElementDecl = simpleTypeFromXsdType.ElementDecl;
						}
					}
					if (schemaElementDecl == null)
					{
						SendValidationEvent("Sch_XsiTypeNotFound", xsiType.ToString());
						elementDecl = null;
					}
					else if (!XmlSchemaType.IsDerivedFrom(schemaElementDecl.SchemaType, elementDecl.SchemaType, elementDecl.Block))
					{
						SendValidationEvent("Sch_XsiTypeBlockedEx", new string[2]
						{
							xsiType.ToString(),
							XmlSchemaValidator.QNameString(context.LocalName, context.Namespace)
						});
						elementDecl = null;
					}
					else
					{
						elementDecl = schemaElementDecl;
					}
				}
				if (elementDecl != null && elementDecl.IsNillable)
				{
					if (xsiNil != null)
					{
						context.IsNill = XmlConvert.ToBoolean(xsiNil);
						if (context.IsNill && elementDecl.DefaultValueTyped != null)
						{
							SendValidationEvent("Sch_XsiNilAndFixed");
						}
					}
				}
				else if (xsiNil != null)
				{
					SendValidationEvent("Sch_InvalidXsiNill");
				}
			}
			return elementDecl;
		}

		private void ValidateStartElement()
		{
			if (context.ElementDecl != null)
			{
				if (context.ElementDecl.IsAbstract)
				{
					SendValidationEvent("Sch_AbstractElement", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
				}
				reader.SchemaTypeObject = context.ElementDecl.SchemaType;
				if (reader.IsEmptyElement && !context.IsNill && context.ElementDecl.DefaultValueTyped != null)
				{
					reader.TypedValueObject = UnWrapUnion(context.ElementDecl.DefaultValueTyped);
					context.IsNill = true;
				}
				else
				{
					reader.TypedValueObject = null;
				}
				if (context.ElementDecl.HasRequiredAttribute || HasIdentityConstraints)
				{
					attPresence.Clear();
				}
			}
			if (!reader.MoveToFirstAttribute())
			{
				return;
			}
			do
			{
				if ((object)reader.NamespaceURI == NsXmlNs || (object)reader.NamespaceURI == NsXsi)
				{
					continue;
				}
				try
				{
					reader.SchemaTypeObject = null;
					XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(reader.LocalName, reader.NamespaceURI);
					bool skip = processContents == XmlSchemaContentProcessing.Skip;
					SchemaAttDef attributeXsd = schemaInfo.GetAttributeXsd(context.ElementDecl, xmlQualifiedName, ref skip);
					if (attributeXsd != null)
					{
						if (context.ElementDecl != null && (context.ElementDecl.HasRequiredAttribute || startIDConstraint != -1))
						{
							attPresence.Add(attributeXsd.Name, attributeXsd);
						}
						reader.SchemaTypeObject = attributeXsd.SchemaType;
						if (attributeXsd.Datatype != null)
						{
							CheckValue(reader.Value, attributeXsd);
						}
						if (HasIdentityConstraints)
						{
							AttributeIdentityConstraints(reader.LocalName, reader.NamespaceURI, reader.TypedValueObject, reader.Value, attributeXsd);
						}
					}
					else if (!skip)
					{
						if (context.ElementDecl == null && processContents == XmlSchemaContentProcessing.Strict && xmlQualifiedName.Namespace.Length != 0 && schemaInfo.Contains(xmlQualifiedName.Namespace))
						{
							SendValidationEvent("Sch_UndeclaredAttribute", xmlQualifiedName.ToString());
						}
						else
						{
							SendValidationEvent("Sch_NoAttributeSchemaFound", xmlQualifiedName.ToString(), XmlSeverityType.Warning);
						}
					}
				}
				catch (XmlSchemaException ex)
				{
					ex.SetSource(reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
					SendValidationEvent(ex);
				}
			}
			while (reader.MoveToNextAttribute());
			reader.MoveToElement();
		}

		private void ValidateEndStartElement()
		{
			if (context.ElementDecl.HasDefaultAttribute)
			{
				SchemaAttDef[] defaultAttDefs = context.ElementDecl.DefaultAttDefs;
				foreach (SchemaAttDef schemaAttDef in defaultAttDefs)
				{
					reader.AddDefaultAttribute(schemaAttDef);
					if (HasIdentityConstraints && !attPresence.Contains(schemaAttDef.Name))
					{
						AttributeIdentityConstraints(schemaAttDef.Name.Name, schemaAttDef.Name.Namespace, UnWrapUnion(schemaAttDef.DefaultValueTyped), schemaAttDef.DefaultValueRaw, schemaAttDef);
					}
				}
			}
			if (context.ElementDecl.HasRequiredAttribute)
			{
				try
				{
					context.ElementDecl.CheckAttributes(attPresence, reader.StandAlone);
				}
				catch (XmlSchemaException ex)
				{
					ex.SetSource(reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
					SendValidationEvent(ex);
				}
			}
			if (context.ElementDecl.Datatype != null)
			{
				checkDatatype = true;
				hasSibling = false;
				textString = string.Empty;
				textValue.Length = 0;
			}
		}

		private void LoadSchemaFromLocation(string uri, string url)
		{
			XmlReader xmlReader = null;
			SchemaInfo schemaInfo = null;
			try
			{
				Uri uri2 = base.XmlResolver.ResolveUri(base.BaseUri, url);
				Stream input = (Stream)base.XmlResolver.GetEntity(uri2, null, null);
				xmlReader = new XmlTextReader(uri2.ToString(), input, base.NameTable);
				Parser parser = new Parser(SchemaType.XSD, base.NameTable, base.SchemaNames, base.EventHandler);
				parser.XmlResolver = base.XmlResolver;
				SchemaType schemaType = parser.Parse(xmlReader, uri);
				schemaInfo = new SchemaInfo();
				schemaInfo.SchemaType = schemaType;
				if (schemaType == SchemaType.XSD)
				{
					if (base.SchemaCollection.EventHandler == null)
					{
						base.SchemaCollection.EventHandler = base.EventHandler;
					}
					base.SchemaCollection.Add(uri, schemaInfo, parser.XmlSchema, compile: true);
				}
				base.SchemaInfo.Add(schemaInfo, base.EventHandler);
				while (xmlReader.Read())
				{
				}
			}
			catch (XmlSchemaException ex)
			{
				schemaInfo = null;
				SendValidationEvent("Sch_CannotLoadSchema", new string[2] { uri, ex.Message }, XmlSeverityType.Error);
			}
			catch (Exception ex2)
			{
				schemaInfo = null;
				SendValidationEvent("Sch_CannotLoadSchema", new string[2] { uri, ex2.Message }, XmlSeverityType.Warning);
			}
			finally
			{
				xmlReader?.Close();
			}
		}

		private void LoadSchema(string uri, string url)
		{
			if (base.XmlResolver == null || (base.SchemaInfo.TargetNamespaces.Contains(uri) && nsManager.LookupPrefix(uri) != null))
			{
				return;
			}
			SchemaInfo schemaInfo = null;
			if (base.SchemaCollection != null)
			{
				schemaInfo = base.SchemaCollection.GetSchemaInfo(uri);
			}
			if (schemaInfo != null)
			{
				if (schemaInfo.SchemaType != SchemaType.XSD)
				{
					throw new XmlException("Xml_MultipleValidaitonTypes", string.Empty, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
				}
				base.SchemaInfo.Add(schemaInfo, base.EventHandler);
			}
			else if (url != null)
			{
				LoadSchemaFromLocation(uri, url);
			}
		}

		private void ProcessTokenizedType(XmlTokenizedType ttype, string name)
		{
			switch (ttype)
			{
			case XmlTokenizedType.ID:
				if (FindId(name) != null)
				{
					SendValidationEvent("Sch_DupId", name);
				}
				else
				{
					AddID(name, context.LocalName);
				}
				break;
			case XmlTokenizedType.IDREF:
			{
				object obj = FindId(name);
				if (obj == null)
				{
					idRefListHead = new IdRefNode(idRefListHead, name, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
				}
				break;
			}
			case XmlTokenizedType.ENTITY:
				BaseValidator.ProcessEntity(schemaInfo, name, this, base.EventHandler, reader.BaseURI, base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
				break;
			case XmlTokenizedType.IDREFS:
				break;
			}
		}

		private void CheckValue(string value, SchemaAttDef attdef)
		{
			try
			{
				reader.TypedValueObject = null;
				bool flag = attdef != null;
				XmlSchemaDatatype xmlSchemaDatatype = (flag ? attdef.Datatype : context.ElementDecl.Datatype);
				if (xmlSchemaDatatype == null)
				{
					return;
				}
				object obj = xmlSchemaDatatype.ParseValue(value, base.NameTable, nsManager, createAtomicValue: true);
				XmlTokenizedType tokenizedType = xmlSchemaDatatype.TokenizedType;
				if (tokenizedType == XmlTokenizedType.ENTITY || tokenizedType == XmlTokenizedType.ID || tokenizedType == XmlTokenizedType.IDREF)
				{
					if (xmlSchemaDatatype.Variety == XmlSchemaDatatypeVariety.List)
					{
						string[] array = (string[])obj;
						string[] array2 = array;
						foreach (string name in array2)
						{
							ProcessTokenizedType(xmlSchemaDatatype.TokenizedType, name);
						}
					}
					else
					{
						ProcessTokenizedType(xmlSchemaDatatype.TokenizedType, (string)obj);
					}
				}
				SchemaDeclBase schemaDeclBase = (flag ? ((SchemaDeclBase)attdef) : ((SchemaDeclBase)context.ElementDecl));
				if (!schemaDeclBase.CheckValue(obj))
				{
					if (flag)
					{
						SendValidationEvent("Sch_FixedAttributeValue", attdef.Name.ToString());
					}
					else
					{
						SendValidationEvent("Sch_FixedElementValue", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
					}
				}
				if (xmlSchemaDatatype.Variety == XmlSchemaDatatypeVariety.Union)
				{
					obj = UnWrapUnion(obj);
				}
				reader.TypedValueObject = obj;
			}
			catch (XmlSchemaException)
			{
				if (attdef != null)
				{
					SendValidationEvent("Sch_AttributeValueDataType", attdef.Name.ToString());
				}
				else
				{
					SendValidationEvent("Sch_ElementValueDataType", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
				}
			}
		}

		internal void AddID(string name, object node)
		{
			if (IDs == null)
			{
				IDs = new Hashtable();
			}
			IDs.Add(name, node);
		}

		public override object FindId(string name)
		{
			if (IDs != null)
			{
				return IDs[name];
			}
			return null;
		}

		public bool IsXSDRoot(string localName, string ns)
		{
			if (Ref.Equal(ns, NsXs))
			{
				return Ref.Equal(localName, XsdSchema);
			}
			return false;
		}

		private void Push(XmlQualifiedName elementName)
		{
			context = (ValidationState)validationStack.Push();
			if (context == null)
			{
				context = new ValidationState();
				validationStack.AddToTop(context);
			}
			context.LocalName = elementName.Name;
			context.Namespace = elementName.Namespace;
			context.HasMatched = false;
			context.IsNill = false;
			context.ProcessContents = processContents;
			context.NeedValidateChildren = false;
			context.Constr = null;
		}

		private void Pop()
		{
			if (validationStack.Length > 1)
			{
				validationStack.Pop();
				if (startIDConstraint == validationStack.Length)
				{
					startIDConstraint = -1;
				}
				context = (ValidationState)validationStack.Peek();
				processContents = context.ProcessContents;
			}
		}

		private void CheckForwardRefs()
		{
			IdRefNode idRefNode = idRefListHead;
			while (idRefNode != null)
			{
				if (FindId(idRefNode.Id) == null)
				{
					SendValidationEvent(new XmlSchemaException("Sch_UndeclaredId", idRefNode.Id, reader.BaseURI, idRefNode.LineNo, idRefNode.LinePos));
				}
				IdRefNode next = idRefNode.Next;
				idRefNode.Next = null;
				idRefNode = next;
			}
			idRefListHead = null;
		}

		private void ValidateStartElementIdentityConstraints()
		{
			if (context.ElementDecl != null)
			{
				if (context.ElementDecl.Constraints != null)
				{
					AddIdentityConstraints();
				}
				if (HasIdentityConstraints)
				{
					ElementIdentityConstraints();
				}
			}
		}

		private void AddIdentityConstraints()
		{
			context.Constr = new ConstraintStruct[context.ElementDecl.Constraints.Length];
			int num = 0;
			CompiledIdentityConstraint[] constraints = context.ElementDecl.Constraints;
			foreach (CompiledIdentityConstraint constraint in constraints)
			{
				context.Constr[num++] = new ConstraintStruct(constraint);
			}
			ConstraintStruct[] constr = context.Constr;
			foreach (ConstraintStruct constraintStruct in constr)
			{
				if (constraintStruct.constraint.Role != CompiledIdentityConstraint.ConstraintRole.Keyref)
				{
					continue;
				}
				bool flag = false;
				for (int num2 = validationStack.Length - 1; num2 >= ((startIDConstraint >= 0) ? startIDConstraint : (validationStack.Length - 1)); num2--)
				{
					if (((ValidationState)validationStack[num2]).Constr != null)
					{
						ConstraintStruct[] constr2 = ((ValidationState)validationStack[num2]).Constr;
						foreach (ConstraintStruct constraintStruct2 in constr2)
						{
							if (constraintStruct2.constraint.name == constraintStruct.constraint.refer)
							{
								flag = true;
								if (constraintStruct2.keyrefTable == null)
								{
									constraintStruct2.keyrefTable = new Hashtable();
								}
								constraintStruct.qualifiedTable = constraintStruct2.keyrefTable;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
				}
				if (!flag)
				{
					SendValidationEvent("Sch_RefNotInScope", XmlSchemaValidator.QNameString(context.LocalName, context.Namespace));
				}
			}
			if (startIDConstraint == -1)
			{
				startIDConstraint = validationStack.Length - 1;
			}
		}

		private void ElementIdentityConstraints()
		{
			for (int i = startIDConstraint; i < validationStack.Length; i++)
			{
				if (((ValidationState)validationStack[i]).Constr == null)
				{
					continue;
				}
				ConstraintStruct[] constr = ((ValidationState)validationStack[i]).Constr;
				foreach (ConstraintStruct constraintStruct in constr)
				{
					if (constraintStruct.axisSelector.MoveToStartElement(reader.LocalName, reader.NamespaceURI))
					{
						constraintStruct.axisSelector.PushKS(base.PositionInfo.LineNumber, base.PositionInfo.LinePosition);
					}
					foreach (LocatedActiveAxis axisField in constraintStruct.axisFields)
					{
						if (axisField.MoveToStartElement(reader.LocalName, reader.NamespaceURI) && context.ElementDecl != null)
						{
							if (context.ElementDecl.Datatype == null)
							{
								SendValidationEvent("Sch_FieldSimpleTypeExpected", reader.LocalName);
							}
							else
							{
								axisField.isMatched = true;
							}
						}
					}
				}
			}
		}

		private void AttributeIdentityConstraints(string name, string ns, object obj, string sobj, SchemaAttDef attdef)
		{
			for (int i = startIDConstraint; i < validationStack.Length; i++)
			{
				if (((ValidationState)validationStack[i]).Constr == null)
				{
					continue;
				}
				ConstraintStruct[] constr = ((ValidationState)validationStack[i]).Constr;
				foreach (ConstraintStruct constraintStruct in constr)
				{
					foreach (LocatedActiveAxis axisField in constraintStruct.axisFields)
					{
						if (axisField.MoveToAttribute(name, ns))
						{
							if (axisField.Ks[axisField.Column] != null)
							{
								SendValidationEvent("Sch_FieldSingleValueExpected", name);
							}
							else if (attdef != null && attdef.Datatype != null)
							{
								axisField.Ks[axisField.Column] = new TypedObject(obj, sobj, attdef.Datatype);
							}
						}
					}
				}
			}
		}

		private object UnWrapUnion(object typedValue)
		{
			if (typedValue is XsdSimpleValue xsdSimpleValue)
			{
				typedValue = xsdSimpleValue.TypedValue;
			}
			return typedValue;
		}

		private void EndElementIdentityConstraints()
		{
			for (int num = validationStack.Length - 1; num >= startIDConstraint; num--)
			{
				if (((ValidationState)validationStack[num]).Constr != null)
				{
					ConstraintStruct[] constr = ((ValidationState)validationStack[num]).Constr;
					foreach (ConstraintStruct constraintStruct in constr)
					{
						foreach (LocatedActiveAxis axisField in constraintStruct.axisFields)
						{
							if (axisField.isMatched)
							{
								axisField.isMatched = false;
								if (axisField.Ks[axisField.Column] != null)
								{
									SendValidationEvent("Sch_FieldSingleValueExpected", reader.LocalName);
								}
								else
								{
									string text = ((!hasSibling) ? textString : textValue.ToString());
									if (reader.TypedValueObject != null && text.Length != 0)
									{
										axisField.Ks[axisField.Column] = new TypedObject(reader.TypedValueObject, text, context.ElementDecl.Datatype);
									}
								}
							}
							axisField.EndElement(reader.LocalName, reader.NamespaceURI);
						}
						if (!constraintStruct.axisSelector.EndElement(reader.LocalName, reader.NamespaceURI))
						{
							continue;
						}
						KeySequence keySequence = constraintStruct.axisSelector.PopKS();
						switch (constraintStruct.constraint.Role)
						{
						case CompiledIdentityConstraint.ConstraintRole.Key:
							if (!keySequence.IsQualified())
							{
								SendValidationEvent(new XmlSchemaException("Sch_MissingKey", constraintStruct.constraint.name.ToString(), reader.BaseURI, keySequence.PosLine, keySequence.PosCol));
							}
							else if (constraintStruct.qualifiedTable.Contains(keySequence))
							{
								SendValidationEvent(new XmlSchemaException("Sch_DuplicateKey", new string[2]
								{
									keySequence.ToString(),
									constraintStruct.constraint.name.ToString()
								}, reader.BaseURI, keySequence.PosLine, keySequence.PosCol));
							}
							else
							{
								constraintStruct.qualifiedTable.Add(keySequence, keySequence);
							}
							break;
						case CompiledIdentityConstraint.ConstraintRole.Unique:
							if (keySequence.IsQualified())
							{
								if (constraintStruct.qualifiedTable.Contains(keySequence))
								{
									SendValidationEvent(new XmlSchemaException("Sch_DuplicateKey", new string[2]
									{
										keySequence.ToString(),
										constraintStruct.constraint.name.ToString()
									}, reader.BaseURI, keySequence.PosLine, keySequence.PosCol));
								}
								else
								{
									constraintStruct.qualifiedTable.Add(keySequence, keySequence);
								}
							}
							break;
						case CompiledIdentityConstraint.ConstraintRole.Keyref:
							if (constraintStruct.qualifiedTable != null && keySequence.IsQualified() && !constraintStruct.qualifiedTable.Contains(keySequence))
							{
								constraintStruct.qualifiedTable.Add(keySequence, keySequence);
							}
							break;
						}
					}
				}
			}
			ConstraintStruct[] constr2 = ((ValidationState)validationStack[validationStack.Length - 1]).Constr;
			if (constr2 == null)
			{
				return;
			}
			ConstraintStruct[] array = constr2;
			foreach (ConstraintStruct constraintStruct2 in array)
			{
				if (constraintStruct2.constraint.Role == CompiledIdentityConstraint.ConstraintRole.Keyref || constraintStruct2.keyrefTable == null)
				{
					continue;
				}
				foreach (KeySequence key in constraintStruct2.keyrefTable.Keys)
				{
					if (!constraintStruct2.qualifiedTable.Contains(key))
					{
						SendValidationEvent(new XmlSchemaException("Sch_UnresolvedKeyref", key.ToString(), reader.BaseURI, key.PosLine, key.PosCol));
					}
				}
			}
		}
	}
	public sealed class XmlSchemaInference
	{
		public enum InferenceOption
		{
			Restricted,
			Relaxed
		}

		internal const short HC_ST_boolean = 0;

		internal const short HC_ST_byte = 1;

		internal const short HC_ST_unsignedByte = 2;

		internal const short HC_ST_short = 3;

		internal const short HC_ST_unsignedShort = 4;

		internal const short HC_ST_int = 5;

		internal const short HC_ST_unsignedInt = 6;

		internal const short HC_ST_long = 7;

		internal const short HC_ST_unsignedLong = 8;

		internal const short HC_ST_integer = 9;

		internal const short HC_ST_decimal = 10;

		internal const short HC_ST_float = 11;

		internal const short HC_ST_double = 12;

		internal const short HC_ST_duration = 13;

		internal const short HC_ST_dateTime = 14;

		internal const short HC_ST_time = 15;

		internal const short HC_ST_date = 16;

		internal const short HC_ST_gYearMonth = 17;

		internal const short HC_ST_string = 18;

		internal const short HC_ST_Count = 19;

		internal const int TF_boolean = 1;

		internal const int TF_byte = 2;

		internal const int TF_unsignedByte = 4;

		internal const int TF_short = 8;

		internal const int TF_unsignedShort = 16;

		internal const int TF_int = 32;

		internal const int TF_unsignedInt = 64;

		internal const int TF_long = 128;

		internal const int TF_unsignedLong = 256;

		internal const int TF_integer = 512;

		internal const int TF_decimal = 1024;

		internal const int TF_float = 2048;

		internal const int TF_double = 4096;

		internal const int TF_duration = 8192;

		internal const int TF_dateTime = 16384;

		internal const int TF_time = 32768;

		internal const int TF_date = 65536;

		internal const int TF_gYearMonth = 131072;

		internal const int TF_string = 262144;

		internal static XmlQualifiedName ST_boolean = new XmlQualifiedName("boolean", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_byte = new XmlQualifiedName("byte", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_unsignedByte = new XmlQualifiedName("unsignedByte", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_short = new XmlQualifiedName("short", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_unsignedShort = new XmlQualifiedName("unsignedShort", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_int = new XmlQualifiedName("int", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_unsignedInt = new XmlQualifiedName("unsignedInt", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_long = new XmlQualifiedName("long", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_unsignedLong = new XmlQualifiedName("unsignedLong", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_integer = new XmlQualifiedName("integer", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_decimal = new XmlQualifiedName("decimal", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_float = new XmlQualifiedName("float", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_double = new XmlQualifiedName("double", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_duration = new XmlQualifiedName("duration", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_dateTime = new XmlQualifiedName("dateTime", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_time = new XmlQualifiedName("time", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_date = new XmlQualifiedName("date", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_gYearMonth = new XmlQualifiedName("gYearMonth", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_string = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName ST_anySimpleType = new XmlQualifiedName("anySimpleType", "http://www.w3.org/2001/XMLSchema");

		internal static XmlQualifiedName[] SimpleTypes = new XmlQualifiedName[19]
		{
			ST_boolean, ST_byte, ST_unsignedByte, ST_short, ST_unsignedShort, ST_int, ST_unsignedInt, ST_long, ST_unsignedLong, ST_integer,
			ST_decimal, ST_float, ST_double, ST_duration, ST_dateTime, ST_time, ST_date, ST_gYearMonth, ST_string
		};

		private XmlSchema rootSchema;

		private XmlSchemaSet schemaSet;

		private XmlReader xtr;

		private NameTable nametable;

		private string TargetNamespace;

		private XmlNamespaceManager NamespaceManager;

		private ArrayList schemaList;

		private InferenceOption occurrence;

		private InferenceOption typeInference;

		public InferenceOption Occurrence
		{
			get
			{
				return occurrence;
			}
			set
			{
				occurrence = value;
			}
		}

		public InferenceOption TypeInference
		{
			get
			{
				return typeInference;
			}
			set
			{
				typeInference = value;
			}
		}

		public XmlSchemaInference()
		{
			nametable = new NameTable();
			NamespaceManager = new XmlNamespaceManager(nametable);
			NamespaceManager.AddNamespace("xs", "http://www.w3.org/2001/XMLSchema");
			schemaList = new ArrayList();
		}

		public XmlSchemaSet InferSchema(XmlReader instanceDocument)
		{
			return InferSchema1(instanceDocument, new XmlSchemaSet(nametable));
		}

		public XmlSchemaSet InferSchema(XmlReader instanceDocument, XmlSchemaSet schemas)
		{
			if (schemas == null)
			{
				schemas = new XmlSchemaSet(nametable);
			}
			return InferSchema1(instanceDocument, schemas);
		}

		internal XmlSchemaSet InferSchema1(XmlReader instanceDocument, XmlSchemaSet schemas)
		{
			if (instanceDocument == null)
			{
				throw new ArgumentNullException("instanceDocument");
			}
			rootSchema = null;
			xtr = instanceDocument;
			schemas.Compile();
			schemaSet = schemas;
			while (xtr.NodeType != XmlNodeType.Element && xtr.Read())
			{
			}
			if (xtr.NodeType == XmlNodeType.Element)
			{
				TargetNamespace = xtr.NamespaceURI;
				if (xtr.NamespaceURI == "http://www.w3.org/2001/XMLSchema")
				{
					throw new XmlSchemaInferenceException("SchInf_schema", 0, 0);
				}
				XmlSchemaElement xse = null;
				foreach (XmlSchemaElement value in schemas.GlobalElements.Values)
				{
					if (value.Name == xtr.LocalName && value.QualifiedName.Namespace == xtr.NamespaceURI)
					{
						rootSchema = value.Parent as XmlSchema;
						xse = value;
						break;
					}
				}
				if (rootSchema == null)
				{
					xse = AddElement(xtr.LocalName, xtr.Prefix, xtr.NamespaceURI, null, null, -1);
				}
				else
				{
					InferElement(xse, bCreatingNewType: false, rootSchema);
				}
				foreach (string item in NamespaceManager)
				{
					if (!item.Equals("xml") && !item.Equals("xmlns"))
					{
						string text2 = NamespaceManager.LookupNamespace(nametable.Get(item));
						if (text2.Length != 0)
						{
							rootSchema.Namespaces.Add(item, text2);
						}
					}
				}
				schemas.Reprocess(rootSchema);
				schemas.Compile();
				return schemas;
			}
			throw new XmlSchemaInferenceException("SchInf_NoElement", 0, 0);
		}

		private XmlSchemaAttribute AddAttribute(string localName, string prefix, string childURI, string attrValue, bool bCreatingNewType, XmlSchema parentSchema, XmlSchemaObjectCollection addLocation, XmlSchemaObjectTable compiledAttributes)
		{
			if (childURI == "http://www.w3.org/2001/XMLSchema")
			{
				throw new XmlSchemaInferenceException("SchInf_schema", 0, 0);
			}
			XmlSchemaAttribute xmlSchemaAttribute = null;
			int iTypeFlags = -1;
			XmlSchemaAttribute xmlSchemaAttribute2 = null;
			XmlSchema xmlSchema = null;
			bool flag = true;
			ICollection attributes = ((compiledAttributes.Count <= 0) ? addLocation : compiledAttributes.Values);
			if (childURI == "http://www.w3.org/XML/1998/namespace")
			{
				XmlSchemaAttribute xmlSchemaAttribute3 = null;
				xmlSchemaAttribute3 = FindAttributeRef(attributes, localName, childURI);
				if (xmlSchemaAttribute3 == null)
				{
					xmlSchemaAttribute3 = new XmlSchemaAttribute();
					xmlSchemaAttribute3.RefName = new XmlQualifiedName(localName, childURI);
					if (bCreatingNewType && Occurrence == InferenceOption.Restricted)
					{
						xmlSchemaAttribute3.Use = XmlSchemaUse.Required;
					}
					else
					{
						xmlSchemaAttribute3.Use = XmlSchemaUse.Optional;
					}
					addLocation.Add(xmlSchemaAttribute3);
				}
				xmlSchemaAttribute2 = xmlSchemaAttribute3;
			}
			else
			{
				if (childURI.Length == 0)
				{
					xmlSchema = parentSchema;
					flag = false;
				}
				else if (childURI != null && !schemaSet.Contains(childURI))
				{
					xmlSchema = new XmlSchema();
					xmlSchema.AttributeFormDefault = XmlSchemaForm.Unqualified;
					xmlSchema.ElementFormDefault = XmlSchemaForm.Qualified;
					if (childURI.Length != 0)
					{
						xmlSchema.TargetNamespace = childURI;
					}
					schemaSet.Add(xmlSchema);
					if (prefix.Length != 0 && string.Compare(prefix, "xml", StringComparison.OrdinalIgnoreCase) != 0)
					{
						NamespaceManager.AddNamespace(prefix, childURI);
					}
				}
				else if (schemaSet.Schemas(childURI) is ArrayList arrayList && arrayList.Count > 0)
				{
					xmlSchema = arrayList[0] as XmlSchema;
				}
				if (childURI.Length != 0)
				{
					XmlSchemaAttribute xmlSchemaAttribute4 = null;
					xmlSchemaAttribute4 = FindAttributeRef(attributes, localName, childURI);
					if (xmlSchemaAttribute4 == null)
					{
						xmlSchemaAttribute4 = new XmlSchemaAttribute();
						xmlSchemaAttribute4.RefName = new XmlQualifiedName(localName, childURI);
						if (bCreatingNewType && Occurrence == InferenceOption.Restricted)
						{
							xmlSchemaAttribute4.Use = XmlSchemaUse.Required;
						}
						else
						{
							xmlSchemaAttribute4.Use = XmlSchemaUse.Optional;
						}
						addLocation.Add(xmlSchemaAttribute4);
					}
					xmlSchemaAttribute2 = xmlSchemaAttribute4;
					xmlSchemaAttribute = FindAttribute(xmlSchema.Items, localName);
					if (xmlSchemaAttribute == null)
					{
						xmlSchemaAttribute = new XmlSchemaAttribute();
						xmlSchemaAttribute.Name = localName;
						xmlSchemaAttribute.SchemaTypeName = RefineSimpleType(attrValue, ref iTypeFlags);
						xmlSchemaAttribute.LineNumber = iTypeFlags;
						xmlSchema.Items.Add(xmlSchemaAttribute);
					}
					else
					{
						if (xmlSchemaAttribute.Parent == null)
						{
							iTypeFlags = xmlSchemaAttribute.LineNumber;
						}
						else
						{
							iTypeFlags = GetSchemaType(xmlSchemaAttribute.SchemaTypeName);
							xmlSchemaAttribute.Parent = null;
						}
						xmlSchemaAttribute.SchemaTypeName = RefineSimpleType(attrValue, ref iTypeFlags);
						xmlSchemaAttribute.LineNumber = iTypeFlags;
					}
				}
				else
				{
					xmlSchemaAttribute = FindAttribute(attributes, localName);
					if (xmlSchemaAttribute == null)
					{
						xmlSchemaAttribute = new XmlSchemaAttribute();
						xmlSchemaAttribute.Name = localName;
						xmlSchemaAttribute.SchemaTypeName = RefineSimpleType(attrValue, ref iTypeFlags);
						xmlSchemaAttribute.LineNumber = iTypeFlags;
						if (bCreatingNewType && Occurrence == InferenceOption.Restricted)
						{
							xmlSchemaAttribute.Use = XmlSchemaUse.Required;
						}
						else
						{
							xmlSchemaAttribute.Use = XmlSchemaUse.Optional;
						}
						addLocation.Add(xmlSchemaAttribute);
						if (xmlSchema.AttributeFormDefault != XmlSchemaForm.Unqualified)
						{
							xmlSchemaAttribute.Form = XmlSchemaForm.Unqualified;
						}
					}
					else
					{
						if (xmlSchemaAttribute.Parent == null)
						{
							iTypeFlags = xmlSchemaAttribute.LineNumber;
						}
						else
						{
							iTypeFlags = GetSchemaType(xmlSchemaAttribute.SchemaTypeName);
							xmlSchemaAttribute.Parent = null;
						}
						xmlSchemaAttribute.SchemaTypeName = RefineSimpleType(attrValue, ref iTypeFlags);
						xmlSchemaAttribute.LineNumber = iTypeFlags;
					}
					xmlSchemaAttribute2 = xmlSchemaAttribute;
				}
			}
			string @namespace = null;
			if (flag && childURI != parentSchema.TargetNamespace)
			{
				foreach (XmlSchemaExternal include in parentSchema.Includes)
				{
					if (include is XmlSchemaImport xmlSchemaImport && xmlSchemaImport.Namespace == childURI)
					{
						flag = false;
					}
				}
				if (flag)
				{
					XmlSchemaImport xmlSchemaImport2 = new XmlSchemaImport();
					xmlSchemaImport2.Schema = xmlSchema;
					if (childURI.Length != 0)
					{
						@namespace = childURI;
					}
					xmlSchemaImport2.Namespace = @namespace;
					parentSchema.Includes.Add(xmlSchemaImport2);
				}
			}
			return xmlSchemaAttribute2;
		}

		private XmlSchema CreateXmlSchema(string targetNS)
		{
			XmlSchema xmlSchema = new XmlSchema();
			xmlSchema.AttributeFormDefault = XmlSchemaForm.Unqualified;
			xmlSchema.ElementFormDefault = XmlSchemaForm.Qualified;
			xmlSchema.TargetNamespace = targetNS;
			schemaSet.Add(xmlSchema);
			return xmlSchema;
		}

		private XmlSchemaElement AddElement(string localName, string prefix, string childURI, XmlSchema parentSchema, XmlSchemaObjectCollection addLocation, int positionWithinCollection)
		{
			if (childURI == "http://www.w3.org/2001/XMLSchema")
			{
				throw new XmlSchemaInferenceException("SchInf_schema", 0, 0);
			}
			XmlSchemaElement xmlSchemaElement = null;
			XmlSchemaElement xmlSchemaElement2 = xmlSchemaElement;
			XmlSchema parentSchema2 = null;
			bool bCreatingNewType = true;
			if (childURI == string.Empty)
			{
				childURI = null;
			}
			if (parentSchema != null && childURI == parentSchema.TargetNamespace)
			{
				xmlSchemaElement = new XmlSchemaElement();
				xmlSchemaElement.Name = localName;
				parentSchema2 = parentSchema;
				if (parentSchema2.ElementFormDefault != XmlSchemaForm.Qualified && addLocation != null)
				{
					xmlSchemaElement.Form = XmlSchemaForm.Qualified;
				}
			}
			else if (schemaSet.Contains(childURI))
			{
				xmlSchemaElement = FindGlobalElement(childURI, localName, out parentSchema2);
				if (xmlSchemaElement == null)
				{
					if (schemaSet.Schemas(childURI) is ArrayList arrayList && arrayList.Count > 0)
					{
						parentSchema2 = arrayList[0] as XmlSchema;
					}
					xmlSchemaElement = new XmlSchemaElement();
					xmlSchemaElement.Name = localName;
					parentSchema2.Items.Add(xmlSchemaElement);
				}
				else
				{
					bCreatingNewType = false;
				}
			}
			else
			{
				parentSchema2 = CreateXmlSchema(childURI);
				if (prefix.Length != 0)
				{
					NamespaceManager.AddNamespace(prefix, childURI);
				}
				xmlSchemaElement = new XmlSchemaElement();
				xmlSchemaElement.Name = localName;
				parentSchema2.Items.Add(xmlSchemaElement);
			}
			if (parentSchema == null)
			{
				parentSchema = parentSchema2;
				rootSchema = parentSchema;
			}
			if (childURI != parentSchema.TargetNamespace)
			{
				bool flag = true;
				foreach (XmlSchemaExternal include in parentSchema.Includes)
				{
					if (include is XmlSchemaImport xmlSchemaImport && xmlSchemaImport.Namespace == childURI)
					{
						flag = false;
					}
				}
				if (flag)
				{
					XmlSchemaImport xmlSchemaImport2 = new XmlSchemaImport();
					xmlSchemaImport2.Schema = parentSchema2;
					xmlSchemaImport2.Namespace = childURI;
					parentSchema.Includes.Add(xmlSchemaImport2);
				}
			}
			xmlSchemaElement2 = xmlSchemaElement;
			if (addLocation != null)
			{
				if (childURI == parentSchema.TargetNamespace)
				{
					if (Occurrence == InferenceOption.Relaxed)
					{
						xmlSchemaElement.MinOccurs = 0m;
					}
					if (positionWithinCollection == -1)
					{
						positionWithinCollection = addLocation.Add(xmlSchemaElement);
					}
					else
					{
						addLocation.Insert(positionWithinCollection, xmlSchemaElement);
					}
				}
				else
				{
					XmlSchemaElement xmlSchemaElement3 = new XmlSchemaElement();
					xmlSchemaElement3.RefName = new XmlQualifiedName(localName, childURI);
					if (Occurrence == InferenceOption.Relaxed)
					{
						xmlSchemaElement3.MinOccurs = 0m;
					}
					if (positionWithinCollection == -1)
					{
						positionWithinCollection = addLocation.Add(xmlSchemaElement3);
					}
					else
					{
						addLocation.Insert(positionWithinCollection, xmlSchemaElement3);
					}
					xmlSchemaElement2 = xmlSchemaElement3;
				}
			}
			InferElement(xmlSchemaElement, bCreatingNewType, parentSchema2);
			return xmlSchemaElement2;
		}

		internal void InferElement(XmlSchemaElement xse, bool bCreatingNewType, XmlSchema parentSchema)
		{
			bool isEmptyElement = xtr.IsEmptyElement;
			int lastUsedSeqItem = -1;
			Hashtable hashtable = new Hashtable();
			XmlSchemaType effectiveSchemaType = GetEffectiveSchemaType(xse, bCreatingNewType);
			XmlSchemaComplexType xmlSchemaComplexType = effectiveSchemaType as XmlSchemaComplexType;
			if (xtr.MoveToFirstAttribute())
			{
				ProcessAttributes(ref xse, effectiveSchemaType, bCreatingNewType, parentSchema);
			}
			else if (!bCreatingNewType && xmlSchemaComplexType != null)
			{
				MakeExistingAttributesOptional(xmlSchemaComplexType, null);
			}
			if (xmlSchemaComplexType == null || xmlSchemaComplexType == XmlSchemaComplexType.AnyType)
			{
				xmlSchemaComplexType = xse.SchemaType as XmlSchemaComplexType;
			}
			if (isEmptyElement)
			{
				if (!bCreatingNewType)
				{
					if (xmlSchemaComplexType != null)
					{
						if (xmlSchemaComplexType.Particle != null)
						{
							xmlSchemaComplexType.Particle.MinOccurs = 0m;
						}
						else if (xmlSchemaComplexType.ContentModel != null)
						{
							XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = CheckSimpleContentExtension(xmlSchemaComplexType);
							xmlSchemaSimpleContentExtension.BaseTypeName = ST_string;
							xmlSchemaSimpleContentExtension.LineNumber = 262144;
						}
					}
					else if (!xse.SchemaTypeName.IsEmpty)
					{
						xse.LineNumber = 262144;
						xse.SchemaTypeName = ST_string;
					}
				}
				else
				{
					xse.LineNumber = 262144;
				}
				return;
			}
			bool flag = false;
			do
			{
				xtr.Read();
				if (xtr.NodeType == XmlNodeType.Whitespace)
				{
					flag = true;
				}
				if (xtr.NodeType == XmlNodeType.EntityReference)
				{
					throw new XmlSchemaInferenceException("SchInf_entity", 0, 0);
				}
			}
			while (!xtr.EOF && xtr.NodeType != XmlNodeType.EndElement && xtr.NodeType != XmlNodeType.CDATA && xtr.NodeType != XmlNodeType.Element && xtr.NodeType != XmlNodeType.Text);
			if (xtr.NodeType == XmlNodeType.EndElement)
			{
				if (flag)
				{
					if (xmlSchemaComplexType != null)
					{
						if (xmlSchemaComplexType.ContentModel != null)
						{
							XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension2 = CheckSimpleContentExtension(xmlSchemaComplexType);
							xmlSchemaSimpleContentExtension2.BaseTypeName = ST_string;
							xmlSchemaSimpleContentExtension2.LineNumber = 262144;
						}
						else if (bCreatingNewType)
						{
							XmlSchemaSimpleContent xmlSchemaSimpleContent = (XmlSchemaSimpleContent)(xmlSchemaComplexType.ContentModel = new XmlSchemaSimpleContent());
							XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension3 = (XmlSchemaSimpleContentExtension)(xmlSchemaSimpleContent.Content = new XmlSchemaSimpleContentExtension());
							MoveAttributes(xmlSchemaComplexType, xmlSchemaSimpleContentExtension3, bCreatingNewType);
							xmlSchemaSimpleContentExtension3.BaseTypeName = ST_string;
							xmlSchemaSimpleContentExtension3.LineNumber = 262144;
						}
						else
						{
							xmlSchemaComplexType.IsMixed = true;
						}
					}
					else
					{
						xse.SchemaTypeName = ST_string;
						xse.LineNumber = 262144;
					}
				}
				if (bCreatingNewType)
				{
					xse.LineNumber = 262144;
				}
				else if (xmlSchemaComplexType != null)
				{
					if (xmlSchemaComplexType.Particle != null)
					{
						xmlSchemaComplexType.Particle.MinOccurs = 0m;
					}
					else if (xmlSchemaComplexType.ContentModel != null)
					{
						XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension4 = CheckSimpleContentExtension(xmlSchemaComplexType);
						xmlSchemaSimpleContentExtension4.BaseTypeName = ST_string;
						xmlSchemaSimpleContentExtension4.LineNumber = 262144;
					}
				}
				else if (!xse.SchemaTypeName.IsEmpty)
				{
					xse.LineNumber = 262144;
					xse.SchemaTypeName = ST_string;
				}
				return;
			}
			int num = 0;
			bool flag2 = false;
			while (!xtr.EOF && xtr.NodeType != XmlNodeType.EndElement)
			{
				bool flag3 = false;
				num++;
				if (xtr.NodeType == XmlNodeType.Text || xtr.NodeType == XmlNodeType.CDATA)
				{
					if (xmlSchemaComplexType != null)
					{
						if (xmlSchemaComplexType.Particle != null)
						{
							xmlSchemaComplexType.IsMixed = true;
							if (num == 1)
							{
								do
								{
									xtr.Read();
								}
								while (!xtr.EOF && (xtr.NodeType == XmlNodeType.CDATA || xtr.NodeType == XmlNodeType.Text || xtr.NodeType == XmlNodeType.Comment || xtr.NodeType == XmlNodeType.ProcessingInstruction || xtr.NodeType == XmlNodeType.Whitespace || xtr.NodeType == XmlNodeType.SignificantWhitespace || xtr.NodeType == XmlNodeType.XmlDeclaration));
								flag3 = true;
								if (xtr.NodeType == XmlNodeType.EndElement)
								{
									xmlSchemaComplexType.Particle.MinOccurs = 0m;
								}
							}
						}
						else if (xmlSchemaComplexType.ContentModel != null)
						{
							XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension5 = CheckSimpleContentExtension(xmlSchemaComplexType);
							if (xtr.NodeType == XmlNodeType.Text && num == 1)
							{
								int num2 = -1;
								if (xse.Parent == null)
								{
									num2 = xmlSchemaSimpleContentExtension5.LineNumber;
								}
								else
								{
									num2 = GetSchemaType(xmlSchemaSimpleContentExtension5.BaseTypeName);
									xse.Parent = null;
								}
								xmlSchemaSimpleContentExtension5.BaseTypeName = RefineSimpleType(xtr.Value, ref num2);
								xmlSchemaSimpleContentExtension5.LineNumber = num2;
							}
							else
							{
								xmlSchemaSimpleContentExtension5.BaseTypeName = ST_string;
								xmlSchemaSimpleContentExtension5.LineNumber = 262144;
							}
						}
						else
						{
							XmlSchemaSimpleContent xmlSchemaSimpleContent2 = (XmlSchemaSimpleContent)(xmlSchemaComplexType.ContentModel = new XmlSchemaSimpleContent());
							XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension6 = (XmlSchemaSimpleContentExtension)(xmlSchemaSimpleContent2.Content = new XmlSchemaSimpleContentExtension());
							MoveAttributes(xmlSchemaComplexType, xmlSchemaSimpleContentExtension6, bCreatingNewType);
							if (xtr.NodeType == XmlNodeType.Text)
							{
								int iTypeFlags = (bCreatingNewType ? (-1) : 262144);
								xmlSchemaSimpleContentExtension6.BaseTypeName = RefineSimpleType(xtr.Value, ref iTypeFlags);
								xmlSchemaSimpleContentExtension6.LineNumber = iTypeFlags;
							}
							else
							{
								xmlSchemaSimpleContentExtension6.BaseTypeName = ST_string;
								xmlSchemaSimpleContentExtension6.LineNumber = 262144;
							}
						}
					}
					else if (num > 1)
					{
						xse.SchemaTypeName = ST_string;
						xse.LineNumber = 262144;
					}
					else
					{
						int iTypeFlags2 = -1;
						if (bCreatingNewType)
						{
							if (xtr.NodeType == XmlNodeType.Text)
							{
								xse.SchemaTypeName = RefineSimpleType(xtr.Value, ref iTypeFlags2);
								xse.LineNumber = iTypeFlags2;
							}
							else
							{
								xse.SchemaTypeName = ST_string;
								xse.LineNumber = 262144;
							}
						}
						else if (xtr.NodeType == XmlNodeType.Text)
						{
							if (xse.Parent == null)
							{
								iTypeFlags2 = xse.LineNumber;
							}
							else
							{
								iTypeFlags2 = GetSchemaType(xse.SchemaTypeName);
								if (iTypeFlags2 == -1 && xse.LineNumber == 262144)
								{
									iTypeFlags2 = 262144;
								}
								xse.Parent = null;
							}
							xse.SchemaTypeName = RefineSimpleType(xtr.Value, ref iTypeFlags2);
							xse.LineNumber = iTypeFlags2;
						}
						else
						{
							xse.SchemaTypeName = ST_string;
							xse.LineNumber = 262144;
						}
					}
				}
				else if (xtr.NodeType == XmlNodeType.Element)
				{
					XmlQualifiedName key = new XmlQualifiedName(xtr.LocalName, xtr.NamespaceURI);
					bool setMaxoccurs = false;
					if (hashtable.Contains(key))
					{
						setMaxoccurs = true;
					}
					else
					{
						hashtable.Add(key, null);
					}
					if (xmlSchemaComplexType == null)
					{
						xmlSchemaComplexType = (XmlSchemaComplexType)(xse.SchemaType = new XmlSchemaComplexType());
						if (!xse.SchemaTypeName.IsEmpty)
						{
							xmlSchemaComplexType.IsMixed = true;
							xse.SchemaTypeName = XmlQualifiedName.Empty;
						}
					}
					if (xmlSchemaComplexType.ContentModel != null)
					{
						XmlSchemaSimpleContentExtension scExtension = CheckSimpleContentExtension(xmlSchemaComplexType);
						MoveAttributes(scExtension, xmlSchemaComplexType);
						xmlSchemaComplexType.ContentModel = null;
						xmlSchemaComplexType.IsMixed = true;
						if (xmlSchemaComplexType.Particle != null)
						{
							throw new XmlSchemaInferenceException("SchInf_particle", 0, 0);
						}
						xmlSchemaComplexType.Particle = new XmlSchemaSequence();
						flag2 = true;
						AddElement(xtr.LocalName, xtr.Prefix, xtr.NamespaceURI, parentSchema, ((XmlSchemaSequence)xmlSchemaComplexType.Particle).Items, -1);
						lastUsedSeqItem = 0;
						if (!bCreatingNewType)
						{
							xmlSchemaComplexType.Particle.MinOccurs = 0m;
						}
					}
					else if (xmlSchemaComplexType.Particle == null)
					{
						xmlSchemaComplexType.Particle = new XmlSchemaSequence();
						flag2 = true;
						AddElement(xtr.LocalName, xtr.Prefix, xtr.NamespaceURI, parentSchema, ((XmlSchemaSequence)xmlSchemaComplexType.Particle).Items, -1);
						if (!bCreatingNewType)
						{
							((XmlSchemaSequence)xmlSchemaComplexType.Particle).MinOccurs = 0m;
						}
						lastUsedSeqItem = 0;
					}
					else
					{
						bool bParticleChanged = false;
						FindMatchingElement(bCreatingNewType || flag2, xtr, xmlSchemaComplexType, ref lastUsedSeqItem, ref bParticleChanged, parentSchema, setMaxoccurs);
					}
				}
				else if (xtr.NodeType == XmlNodeType.Text)
				{
					if (xmlSchemaComplexType == null)
					{
						throw new XmlSchemaInferenceException("SchInf_ct", 0, 0);
					}
					xmlSchemaComplexType.IsMixed = true;
				}
				do
				{
					if (xtr.NodeType == XmlNodeType.EntityReference)
					{
						throw new XmlSchemaInferenceException("SchInf_entity", 0, 0);
					}
					if (!flag3)
					{
						xtr.Read();
					}
					else
					{
						flag3 = false;
					}
				}
				while (!xtr.EOF && xtr.NodeType != XmlNodeType.EndElement && xtr.NodeType != XmlNodeType.CDATA && xtr.NodeType != XmlNodeType.Element && xtr.NodeType != XmlNodeType.Text);
			}
			if (lastUsedSeqItem == -1)
			{
				return;
			}
			while (++lastUsedSeqItem < ((XmlSchemaSequence)xmlSchemaComplexType.Particle).Items.Count)
			{
				if (((XmlSchemaSequence)xmlSchemaComplexType.Particle).Items[lastUsedSeqItem].GetType() != typeof(XmlSchemaElement))
				{
					throw new XmlSchemaInferenceException("SchInf_seq", 0, 0);
				}
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)((XmlSchemaSequence)xmlSchemaComplexType.Particle).Items[lastUsedSeqItem];
				xmlSchemaElement.MinOccurs = 0m;
			}
		}

		private XmlSchemaSimpleContentExtension CheckSimpleContentExtension(XmlSchemaComplexType ct)
		{
			if (!(ct.ContentModel is XmlSchemaSimpleContent xmlSchemaSimpleContent))
			{
				throw new XmlSchemaInferenceException("SchInf_simplecontent", 0, 0);
			}
			if (!(xmlSchemaSimpleContent.Content is XmlSchemaSimpleContentExtension result))
			{
				throw new XmlSchemaInferenceException("SchInf_extension", 0, 0);
			}
			return result;
		}

		private XmlSchemaType GetEffectiveSchemaType(XmlSchemaElement elem, bool bCreatingNewType)
		{
			XmlSchemaType xmlSchemaType = null;
			if (!bCreatingNewType && elem.ElementSchemaType != null)
			{
				xmlSchemaType = elem.ElementSchemaType;
			}
			else if (elem.SchemaType != null)
			{
				xmlSchemaType = elem.SchemaType;
			}
			else if (elem.SchemaTypeName != XmlQualifiedName.Empty)
			{
				xmlSchemaType = schemaSet.GlobalTypes[elem.SchemaTypeName] as XmlSchemaType;
				if (xmlSchemaType == null)
				{
					xmlSchemaType = XmlSchemaType.GetBuiltInSimpleType(elem.SchemaTypeName);
				}
				if (xmlSchemaType == null)
				{
					xmlSchemaType = XmlSchemaType.GetBuiltInComplexType(elem.SchemaTypeName);
				}
			}
			return xmlSchemaType;
		}

		internal XmlSchemaElement FindMatchingElement(bool bCreatingNewType, XmlReader xtr, XmlSchemaComplexType ct, ref int lastUsedSeqItem, ref bool bParticleChanged, XmlSchema parentSchema, bool setMaxoccurs)
		{
			if (xtr.NamespaceURI == "http://www.w3.org/2001/XMLSchema")
			{
				throw new XmlSchemaInferenceException("SchInf_schema", 0, 0);
			}
			bool flag = lastUsedSeqItem == -1;
			XmlSchemaObjectCollection xmlSchemaObjectCollection = new XmlSchemaObjectCollection();
			if (ct.Particle.GetType() == typeof(XmlSchemaSequence))
			{
				string text = xtr.NamespaceURI;
				if (text.Length == 0)
				{
					text = null;
				}
				XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence)ct.Particle;
				if (xmlSchemaSequence.Items.Count < 1 && !bCreatingNewType)
				{
					lastUsedSeqItem = 0;
					XmlSchemaElement xmlSchemaElement = AddElement(xtr.LocalName, xtr.Prefix, xtr.NamespaceURI, parentSchema, xmlSchemaSequence.Items, -1);
					xmlSchemaElement.MinOccurs = 0m;
					return xmlSchemaElement;
				}
				if (xmlSchemaSequence.Items[0].GetType() == typeof(XmlSchemaChoice))
				{
					XmlSchemaChoice xmlSchemaChoice = (XmlSchemaChoice)xmlSchemaSequence.Items[0];
					foreach (XmlSchemaParticle item in xmlSchemaChoice.Items)
					{
						if (!(item is XmlSchemaElement xmlSchemaElement2))
						{
							throw new XmlSchemaInferenceException("SchInf_UnknownParticle", 0, 0);
						}
						if (xmlSchemaElement2.Name == xtr.LocalName && parentSchema.TargetNamespace == text)
						{
							InferElement(xmlSchemaElement2, bCreatingNewType: false, parentSchema);
							SetMinMaxOccurs(xmlSchemaElement2, setMaxoccurs);
							return xmlSchemaElement2;
						}
						if (xmlSchemaElement2.RefName.Name == xtr.LocalName && xmlSchemaElement2.RefName.Namespace == xtr.NamespaceURI)
						{
							XmlSchemaElement xmlSchemaElement3 = FindGlobalElement(text, xtr.LocalName, out parentSchema);
							InferElement(xmlSchemaElement3, bCreatingNewType: false, parentSchema);
							SetMinMaxOccurs(xmlSchemaElement2, setMaxoccurs);
							return xmlSchemaElement3;
						}
					}
					return AddElement(xtr.LocalName, xtr.Prefix, xtr.NamespaceURI, parentSchema, xmlSchemaChoice.Items, -1);
				}
				int num = 0;
				if (lastUsedSeqItem >= 0)
				{
					num = lastUsedSeqItem;
				}
				XmlSchemaParticle xmlSchemaParticle2 = xmlSchemaSequence.Items[num] as XmlSchemaParticle;
				if (!(xmlSchemaParticle2 is XmlSchemaElement xmlSchemaElement4))
				{
					throw new XmlSchemaInferenceException("SchInf_UnknownParticle", 0, 0);
				}
				if (xmlSchemaElement4.Name == xtr.LocalName && parentSchema.TargetNamespace == text)
				{
					if (!flag)
					{
						xmlSchemaElement4.MaxOccurs = decimal.MaxValue;
					}
					lastUsedSeqItem = num;
					InferElement(xmlSchemaElement4, bCreatingNewType: false, parentSchema);
					SetMinMaxOccurs(xmlSchemaElement4, setMaxOccurs: false);
					return xmlSchemaElement4;
				}
				if (xmlSchemaElement4.RefName.Name == xtr.LocalName && xmlSchemaElement4.RefName.Namespace == xtr.NamespaceURI)
				{
					if (!flag)
					{
						xmlSchemaElement4.MaxOccurs = decimal.MaxValue;
					}
					lastUsedSeqItem = num;
					XmlSchemaElement xse = FindGlobalElement(text, xtr.LocalName, out parentSchema);
					InferElement(xse, bCreatingNewType: false, parentSchema);
					SetMinMaxOccurs(xmlSchemaElement4, setMaxOccurs: false);
					return xmlSchemaElement4;
				}
				if (flag && xmlSchemaElement4.MinOccurs != 0m)
				{
					xmlSchemaObjectCollection.Add(xmlSchemaElement4);
				}
				for (num++; num < xmlSchemaSequence.Items.Count; num++)
				{
					xmlSchemaParticle2 = xmlSchemaSequence.Items[num] as XmlSchemaParticle;
					if (!(xmlSchemaParticle2 is XmlSchemaElement xmlSchemaElement5))
					{
						throw new XmlSchemaInferenceException("SchInf_UnknownParticle", 0, 0);
					}
					if (xmlSchemaElement5.Name == xtr.LocalName && parentSchema.TargetNamespace == text)
					{
						lastUsedSeqItem = num;
						foreach (XmlSchemaElement item2 in xmlSchemaObjectCollection)
						{
							item2.MinOccurs = 0m;
						}
						InferElement(xmlSchemaElement5, bCreatingNewType: false, parentSchema);
						SetMinMaxOccurs(xmlSchemaElement5, setMaxoccurs);
						return xmlSchemaElement5;
					}
					if (xmlSchemaElement5.RefName.Name == xtr.LocalName && xmlSchemaElement5.RefName.Namespace == xtr.NamespaceURI)
					{
						lastUsedSeqItem = num;
						foreach (XmlSchemaElement item3 in xmlSchemaObjectCollection)
						{
							item3.MinOccurs = 0m;
						}
						XmlSchemaElement xmlSchemaElement8 = FindGlobalElement(text, xtr.LocalName, out parentSchema);
						InferElement(xmlSchemaElement8, bCreatingNewType: false, parentSchema);
						SetMinMaxOccurs(xmlSchemaElement5, setMaxoccurs);
						return xmlSchemaElement8;
					}
					xmlSchemaObjectCollection.Add(xmlSchemaElement5);
				}
				XmlSchemaElement xmlSchemaElement9 = null;
				XmlSchemaElement xse2 = null;
				if (parentSchema.TargetNamespace == text)
				{
					xmlSchemaElement9 = FindElement(xmlSchemaSequence.Items, xtr.LocalName);
					xse2 = xmlSchemaElement9;
				}
				else
				{
					xmlSchemaElement9 = FindElementRef(xmlSchemaSequence.Items, xtr.LocalName, xtr.NamespaceURI);
					if (xmlSchemaElement9 != null)
					{
						xse2 = FindGlobalElement(text, xtr.LocalName, out parentSchema);
					}
				}
				if (xmlSchemaElement9 != null)
				{
					XmlSchemaChoice xmlSchemaChoice2 = new XmlSchemaChoice();
					xmlSchemaChoice2.MaxOccurs = decimal.MaxValue;
					SetMinMaxOccurs(xmlSchemaElement9, setMaxoccurs);
					InferElement(xse2, bCreatingNewType: false, parentSchema);
					foreach (XmlSchemaElement item4 in xmlSchemaSequence.Items)
					{
						xmlSchemaChoice2.Items.Add(CreateNewElementforChoice(item4));
					}
					xmlSchemaSequence.Items.Clear();
					xmlSchemaSequence.Items.Add(xmlSchemaChoice2);
					return xmlSchemaElement9;
				}
				xmlSchemaElement9 = AddElement(xtr.LocalName, xtr.Prefix, xtr.NamespaceURI, parentSchema, xmlSchemaSequence.Items, ++lastUsedSeqItem);
				if (!bCreatingNewType)
				{
					xmlSchemaElement9.MinOccurs = 0m;
				}
				return xmlSchemaElement9;
			}
			throw new XmlSchemaInferenceException("SchInf_noseq", 0, 0);
		}

		internal void ProcessAttributes(ref XmlSchemaElement xse, XmlSchemaType effectiveSchemaType, bool bCreatingNewType, XmlSchema parentSchema)
		{
			XmlSchemaObjectCollection xmlSchemaObjectCollection = new XmlSchemaObjectCollection();
			XmlSchemaComplexType xmlSchemaComplexType = effectiveSchemaType as XmlSchemaComplexType;
			do
			{
				if (xtr.NamespaceURI == "http://www.w3.org/2001/XMLSchema")
				{
					throw new XmlSchemaInferenceException("SchInf_schema", 0, 0);
				}
				if (xtr.NamespaceURI == "http://www.w3.org/2000/xmlns/")
				{
					if (xtr.Prefix == "xmlns")
					{
						NamespaceManager.AddNamespace(xtr.LocalName, xtr.Value);
					}
					continue;
				}
				if (xtr.NamespaceURI == "http://www.w3.org/2001/XMLSchema-instance")
				{
					string localName = xtr.LocalName;
					if (localName == "nil")
					{
						xse.IsNillable = true;
					}
					else if (localName != "type" && localName != "schemaLocation" && localName != "noNamespaceSchemaLocation")
					{
						throw new XmlSchemaInferenceException("Sch_NotXsiAttribute", localName);
					}
					continue;
				}
				if (xmlSchemaComplexType == null || xmlSchemaComplexType == XmlSchemaComplexType.AnyType)
				{
					xmlSchemaComplexType = new XmlSchemaComplexType();
					xse.SchemaType = xmlSchemaComplexType;
				}
				XmlSchemaAttribute xmlSchemaAttribute = null;
				if (effectiveSchemaType != null && effectiveSchemaType.Datatype != null && !xse.SchemaTypeName.IsEmpty)
				{
					XmlSchemaSimpleContent xmlSchemaSimpleContent = (XmlSchemaSimpleContent)(xmlSchemaComplexType.ContentModel = new XmlSchemaSimpleContent());
					XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = (XmlSchemaSimpleContentExtension)(xmlSchemaSimpleContent.Content = new XmlSchemaSimpleContentExtension());
					xmlSchemaSimpleContentExtension.BaseTypeName = xse.SchemaTypeName;
					xmlSchemaSimpleContentExtension.LineNumber = xse.LineNumber;
					xse.LineNumber = 0;
					xse.SchemaTypeName = XmlQualifiedName.Empty;
				}
				if (xmlSchemaComplexType.ContentModel != null)
				{
					XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension2 = CheckSimpleContentExtension(xmlSchemaComplexType);
					xmlSchemaAttribute = AddAttribute(xtr.LocalName, xtr.Prefix, xtr.NamespaceURI, xtr.Value, bCreatingNewType, parentSchema, xmlSchemaSimpleContentExtension2.Attributes, xmlSchemaComplexType.AttributeUses);
				}
				else
				{
					xmlSchemaAttribute = AddAttribute(xtr.LocalName, xtr.Prefix, xtr.NamespaceURI, xtr.Value, bCreatingNewType, parentSchema, xmlSchemaComplexType.Attributes, xmlSchemaComplexType.AttributeUses);
				}
				if (xmlSchemaAttribute != null)
				{
					xmlSchemaObjectCollection.Add(xmlSchemaAttribute);
				}
			}
			while (xtr.MoveToNextAttribute());
			if (!bCreatingNewType && xmlSchemaComplexType != null)
			{
				MakeExistingAttributesOptional(xmlSchemaComplexType, xmlSchemaObjectCollection);
			}
		}

		private void MoveAttributes(XmlSchemaSimpleContentExtension scExtension, XmlSchemaComplexType ct)
		{
			foreach (XmlSchemaAttribute attribute in scExtension.Attributes)
			{
				ct.Attributes.Add(attribute);
			}
		}

		private void MoveAttributes(XmlSchemaComplexType ct, XmlSchemaSimpleContentExtension simpleContentExtension, bool bCreatingNewType)
		{
			ICollection collection = ((bCreatingNewType || ct.AttributeUses.Count <= 0) ? ct.Attributes : ct.AttributeUses.Values);
			foreach (XmlSchemaAttribute item in collection)
			{
				simpleContentExtension.Attributes.Add(item);
			}
			ct.Attributes.Clear();
		}

		internal XmlSchemaAttribute FindAttribute(ICollection attributes, string attrName)
		{
			foreach (XmlSchemaObject attribute in attributes)
			{
				if (attribute is XmlSchemaAttribute xmlSchemaAttribute && xmlSchemaAttribute.Name == attrName)
				{
					return xmlSchemaAttribute;
				}
			}
			return null;
		}

		internal XmlSchemaElement FindGlobalElement(string namespaceURI, string localName, out XmlSchema parentSchema)
		{
			ICollection collection = schemaSet.Schemas(namespaceURI);
			XmlSchemaElement xmlSchemaElement = null;
			parentSchema = null;
			foreach (XmlSchema item in collection)
			{
				xmlSchemaElement = FindElement(item.Items, localName);
				if (xmlSchemaElement != null)
				{
					parentSchema = item;
					return xmlSchemaElement;
				}
			}
			return null;
		}

		internal XmlSchemaElement FindElement(XmlSchemaObjectCollection elements, string elementName)
		{
			foreach (XmlSchemaObject element in elements)
			{
				if (element is XmlSchemaElement xmlSchemaElement && xmlSchemaElement.RefName != null && xmlSchemaElement.Name == elementName)
				{
					return xmlSchemaElement;
				}
			}
			return null;
		}

		internal XmlSchemaAttribute FindAttributeRef(ICollection attributes, string attributeName, string nsURI)
		{
			foreach (XmlSchemaObject attribute in attributes)
			{
				if (attribute is XmlSchemaAttribute xmlSchemaAttribute && xmlSchemaAttribute.RefName.Name == attributeName && xmlSchemaAttribute.RefName.Namespace == nsURI)
				{
					return xmlSchemaAttribute;
				}
			}
			return null;
		}

		internal XmlSchemaElement FindElementRef(XmlSchemaObjectCollection elements, string elementName, string nsURI)
		{
			foreach (XmlSchemaObject element in elements)
			{
				if (element is XmlSchemaElement xmlSchemaElement && xmlSchemaElement.RefName != null && xmlSchemaElement.RefName.Name == elementName && xmlSchemaElement.RefName.Namespace == nsURI)
				{
					return xmlSchemaElement;
				}
			}
			return null;
		}

		internal void MakeExistingAttributesOptional(XmlSchemaComplexType ct, XmlSchemaObjectCollection attributesInInstance)
		{
			if (ct == null)
			{
				throw new XmlSchemaInferenceException("SchInf_noct", 0, 0);
			}
			if (ct.ContentModel != null)
			{
				XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = CheckSimpleContentExtension(ct);
				SwitchUseToOptional(xmlSchemaSimpleContentExtension.Attributes, attributesInInstance);
			}
			else
			{
				SwitchUseToOptional(ct.Attributes, attributesInInstance);
			}
		}

		private void SwitchUseToOptional(XmlSchemaObjectCollection attributes, XmlSchemaObjectCollection attributesInInstance)
		{
			foreach (XmlSchemaObject attribute in attributes)
			{
				if (!(attribute is XmlSchemaAttribute))
				{
					continue;
				}
				XmlSchemaAttribute xmlSchemaAttribute = attribute as XmlSchemaAttribute;
				if (attributesInInstance != null)
				{
					if (xmlSchemaAttribute.RefName.Name.Length == 0)
					{
						if (FindAttribute(attributesInInstance, xmlSchemaAttribute.Name) == null)
						{
							xmlSchemaAttribute.Use = XmlSchemaUse.Optional;
						}
					}
					else if (FindAttributeRef(attributesInInstance, xmlSchemaAttribute.RefName.Name, xmlSchemaAttribute.RefName.Namespace) == null)
					{
						xmlSchemaAttribute.Use = XmlSchemaUse.Optional;
					}
				}
				else
				{
					xmlSchemaAttribute.Use = XmlSchemaUse.Optional;
				}
			}
		}

		internal XmlQualifiedName RefineSimpleType(string s, ref int iTypeFlags)
		{
			bool bNeedsRangeCheck = false;
			s = s.Trim();
			if (iTypeFlags == 262144 || typeInference == InferenceOption.Relaxed)
			{
				return ST_string;
			}
			iTypeFlags &= InferSimpleType(s, ref bNeedsRangeCheck);
			if (iTypeFlags == 262144)
			{
				return ST_string;
			}
			if (bNeedsRangeCheck)
			{
				if (((uint)iTypeFlags & 2u) != 0)
				{
					try
					{
						XmlConvert.ToSByte(s);
						if (((uint)iTypeFlags & 4u) != 0)
						{
							return ST_unsignedByte;
						}
						return ST_byte;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags &= -3;
				}
				if (((uint)iTypeFlags & 4u) != 0)
				{
					try
					{
						XmlConvert.ToByte(s);
						return ST_unsignedByte;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags &= -5;
				}
				if (((uint)iTypeFlags & 8u) != 0)
				{
					try
					{
						XmlConvert.ToInt16(s);
						if (((uint)iTypeFlags & 0x10u) != 0)
						{
							return ST_unsignedShort;
						}
						return ST_short;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags &= -9;
				}
				if (((uint)iTypeFlags & 0x10u) != 0)
				{
					try
					{
						XmlConvert.ToUInt16(s);
						return ST_unsignedShort;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags &= -17;
				}
				if (((uint)iTypeFlags & 0x20u) != 0)
				{
					try
					{
						XmlConvert.ToInt32(s);
						if (((uint)iTypeFlags & 0x40u) != 0)
						{
							return ST_unsignedInt;
						}
						return ST_int;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags &= -33;
				}
				if (((uint)iTypeFlags & 0x40u) != 0)
				{
					try
					{
						XmlConvert.ToUInt32(s);
						return ST_unsignedInt;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags &= -65;
				}
				if (((uint)iTypeFlags & 0x80u) != 0)
				{
					try
					{
						XmlConvert.ToInt64(s);
						if (((uint)iTypeFlags & 0x100u) != 0)
						{
							return ST_unsignedLong;
						}
						return ST_long;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags &= -129;
				}
				if (((uint)iTypeFlags & 0x100u) != 0)
				{
					try
					{
						XmlConvert.ToUInt64(s);
						return ST_unsignedLong;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags &= -257;
				}
				if (((uint)iTypeFlags & 0x800u) != 0)
				{
					try
					{
						XmlConvert.ToSingle(s);
						if (((uint)iTypeFlags & 0x200u) != 0)
						{
							return ST_integer;
						}
						if (((uint)iTypeFlags & 0x400u) != 0)
						{
							return ST_decimal;
						}
						return ST_float;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags &= -2049;
				}
				if (((uint)iTypeFlags & 0x1000u) != 0)
				{
					try
					{
						XmlConvert.ToDouble(s);
						if (((uint)iTypeFlags & 0x200u) != 0)
						{
							return ST_integer;
						}
						if (((uint)iTypeFlags & 0x400u) != 0)
						{
							return ST_decimal;
						}
						return ST_double;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags &= -4097;
				}
				if (((uint)iTypeFlags & 0x200u) != 0)
				{
					return ST_integer;
				}
				if (((uint)iTypeFlags & 0x400u) != 0)
				{
					return ST_decimal;
				}
				if (iTypeFlags == 393216)
				{
					try
					{
						XmlConvert.ToDateTime(s, XmlDateTimeSerializationMode.RoundtripKind);
						return ST_gYearMonth;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags = 262144;
					return ST_string;
				}
				if (iTypeFlags == 270336)
				{
					try
					{
						XmlConvert.ToTimeSpan(s);
						return ST_duration;
					}
					catch (FormatException)
					{
					}
					catch (OverflowException)
					{
					}
					iTypeFlags = 262144;
					return ST_string;
				}
				if (iTypeFlags == 262145)
				{
					return ST_boolean;
				}
			}
			return iTypeFlags switch
			{
				262144 => ST_string, 
				1 => ST_boolean, 
				2 => ST_byte, 
				4 => ST_unsignedByte, 
				8 => ST_short, 
				16 => ST_unsignedShort, 
				32 => ST_int, 
				64 => ST_unsignedInt, 
				128 => ST_long, 
				256 => ST_unsignedLong, 
				512 => ST_integer, 
				1024 => ST_decimal, 
				2048 => ST_float, 
				4096 => ST_double, 
				8192 => ST_duration, 
				16384 => ST_dateTime, 
				32768 => ST_time, 
				65536 => ST_date, 
				131072 => ST_gYearMonth, 
				262145 => ST_boolean, 
				278528 => ST_dateTime, 
				327680 => ST_date, 
				294912 => ST_time, 
				268288 => ST_float, 
				266240 => ST_double, 
				_ => ST_string, 
			};
		}

		internal static int InferSimpleType(string s, ref bool bNeedsRangeCheck)
		{
			bool flag = false;
			bool flag2 = false;
			bool bDate = false;
			bool bTime = false;
			bool flag3 = false;
			if (s.Length == 0)
			{
				return 262144;
			}
			int num = 0;
			switch (s[num])
			{
			case 'f':
			case 't':
				if (s == "true")
				{
					return 262145;
				}
				if (s == "false")
				{
					return 262145;
				}
				return 262144;
			case 'N':
				if (s == "NaN")
				{
					return 268288;
				}
				return 262144;
			case 'I':
				if (s.Substring(num) == "INF")
				{
					return 268288;
				}
				return 262144;
			case '.':
			{
				bNeedsRangeCheck = true;
				num++;
				if (num == s.Length)
				{
					if (num == 1 || (num == 2 && (flag2 || flag)))
					{
						return 262144;
					}
					return 269312;
				}
				char c14 = s[num];
				if (c14 != 'E' && c14 != 'e')
				{
					if (s[num] < '0' || s[num] > '9')
					{
						return 262144;
					}
					while (true)
					{
						num++;
						if (num == s.Length)
						{
							return 269312;
						}
						char c15 = s[num];
						if (c15 == 'E' || c15 == 'e')
						{
							break;
						}
						if (s[num] < '0' || s[num] > '9')
						{
							return 262144;
						}
					}
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				switch (s[num])
				{
				default:
					if (s[num] < '0' || s[num] > '9')
					{
						return 262144;
					}
					break;
				case '+':
				case '-':
					num++;
					if (num == s.Length)
					{
						return 262144;
					}
					if (s[num] < '0' || s[num] > '9')
					{
						return 262144;
					}
					break;
				}
				do
				{
					num++;
					if (num == s.Length)
					{
						return 268288;
					}
				}
				while (s[num] >= '0' && s[num] <= '9');
				return 262144;
			}
			case '-':
			{
				flag = true;
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				char c13 = s[num];
				if (c13 == '.')
				{
					goto case '.';
				}
				if (c13 == 'I')
				{
					goto case 'I';
				}
				if (c13 == 'P')
				{
					goto case 'P';
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				goto case '0';
			}
			case '+':
			{
				flag2 = true;
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				char c = s[num];
				if (c == '.')
				{
					goto case '.';
				}
				if (c == 'P')
				{
					goto case 'P';
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				goto case '0';
			}
			case 'P':
			{
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				char c2 = s[num];
				if (c2 != 'T')
				{
					if (s[num] < '0' || s[num] > '9')
					{
						return 262144;
					}
					while (true)
					{
						num++;
						if (num == s.Length)
						{
							return 262144;
						}
						char c3 = s[num];
						if (c3 != 'D')
						{
							if (c3 == 'M')
							{
								goto IL_0451;
							}
							if (c3 != 'Y')
							{
								if (s[num] < '0' || s[num] > '9')
								{
									return 262144;
								}
								continue;
							}
							num++;
							if (num == s.Length)
							{
								bNeedsRangeCheck = true;
								return 270336;
							}
							char c4 = s[num];
							if (c4 == 'T')
							{
								break;
							}
							if (s[num] < '0' || s[num] > '9')
							{
								return 262144;
							}
							while (true)
							{
								num++;
								if (num == s.Length)
								{
									return 262144;
								}
								char c5 = s[num];
								if (c5 == 'D')
								{
									break;
								}
								if (c5 != 'M')
								{
									if (s[num] < '0' || s[num] > '9')
									{
										return 262144;
									}
									continue;
								}
								goto IL_0451;
							}
						}
						goto IL_04df;
						IL_04df:
						num++;
						if (num == s.Length)
						{
							bNeedsRangeCheck = true;
							return 270336;
						}
						char c6 = s[num];
						if (c6 == 'T')
						{
							break;
						}
						return 262144;
						IL_0451:
						num++;
						if (num == s.Length)
						{
							bNeedsRangeCheck = true;
							return 270336;
						}
						char c7 = s[num];
						if (c7 == 'T')
						{
							break;
						}
						if (s[num] < '0' || s[num] > '9')
						{
							return 262144;
						}
						while (true)
						{
							num++;
							if (num == s.Length)
							{
								return 262144;
							}
							char c8 = s[num];
							if (c8 == 'D')
							{
								break;
							}
							if (s[num] < '0' || s[num] > '9')
							{
								return 262144;
							}
						}
						goto IL_04df;
					}
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				while (true)
				{
					num++;
					if (num == s.Length)
					{
						return 262144;
					}
					char c9 = s[num];
					if (c9 <= 'H')
					{
						if (c9 != '.')
						{
							if (c9 != 'H')
							{
								goto IL_058b;
							}
							num++;
							if (num == s.Length)
							{
								bNeedsRangeCheck = true;
								return 270336;
							}
							if (s[num] < '0' || s[num] > '9')
							{
								return 262144;
							}
							while (true)
							{
								num++;
								if (num == s.Length)
								{
									return 262144;
								}
								char c10 = s[num];
								if (c10 == '.')
								{
									break;
								}
								if (c10 != 'M')
								{
									if (c10 == 'S')
									{
										goto end_IL_0542;
									}
									if (s[num] < '0' || s[num] > '9')
									{
										return 262144;
									}
									continue;
								}
								goto IL_0636;
							}
						}
						goto IL_06ba;
					}
					if (c9 != 'M')
					{
						if (c9 == 'S')
						{
							break;
						}
						goto IL_058b;
					}
					goto IL_0636;
					IL_058b:
					if (s[num] < '0' || s[num] > '9')
					{
						return 262144;
					}
					continue;
					IL_06ba:
					num++;
					if (num == s.Length)
					{
						bNeedsRangeCheck = true;
						return 270336;
					}
					if (s[num] < '0' || s[num] > '9')
					{
						return 262144;
					}
					while (true)
					{
						num++;
						if (num == s.Length)
						{
							return 262144;
						}
						char c11 = s[num];
						if (c11 == 'S')
						{
							break;
						}
						if (s[num] < '0' || s[num] > '9')
						{
							return 262144;
						}
					}
					break;
					IL_0636:
					num++;
					if (num == s.Length)
					{
						bNeedsRangeCheck = true;
						return 270336;
					}
					if (s[num] < '0' || s[num] > '9')
					{
						return 262144;
					}
					while (true)
					{
						num++;
						if (num == s.Length)
						{
							return 262144;
						}
						char c12 = s[num];
						if (c12 == '.')
						{
							break;
						}
						if (c12 == 'S')
						{
							goto end_IL_0542;
						}
						if (s[num] < '0' || s[num] > '9')
						{
							return 262144;
						}
					}
					goto IL_06ba;
					continue;
					end_IL_0542:
					break;
				}
				num++;
				if (num == s.Length)
				{
					bNeedsRangeCheck = true;
					return 270336;
				}
				return 262144;
			}
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			{
				num++;
				if (num == s.Length)
				{
					bNeedsRangeCheck = true;
					if (flag || flag2)
					{
						return 269994;
					}
					if (s == "0" || s == "1")
					{
						return 270335;
					}
					return 270334;
				}
				char c16 = s[num];
				if (c16 != '.')
				{
					if (c16 == 'E' || c16 == 'e')
					{
						bNeedsRangeCheck = true;
						return 268288;
					}
					if (s[num] < '0' || s[num] > '9')
					{
						return 262144;
					}
					num++;
					if (num == s.Length)
					{
						bNeedsRangeCheck = true;
						if (flag || flag2)
						{
							return 269994;
						}
						return 270334;
					}
					char c17 = s[num];
					if (c17 <= ':')
					{
						if (c17 == '.')
						{
							goto case '.';
						}
						if (c17 == ':')
						{
							bTime = true;
							goto IL_0cc1;
						}
					}
					else if (c17 == 'E' || c17 == 'e')
					{
						bNeedsRangeCheck = true;
						return 268288;
					}
					if (s[num] < '0' || s[num] > '9')
					{
						return 262144;
					}
					num++;
					if (num == s.Length)
					{
						bNeedsRangeCheck = true;
						if (flag || flag2)
						{
							return 269994;
						}
						return 270334;
					}
					char c18 = s[num];
					if (c18 != '.')
					{
						if (c18 == 'E' || c18 == 'e')
						{
							bNeedsRangeCheck = true;
							return 268288;
						}
						if (s[num] < '0' || s[num] > '9')
						{
							return 262144;
						}
						while (true)
						{
							num++;
							if (num == s.Length)
							{
								break;
							}
							switch (s[num])
							{
							case '.':
								break;
							case '-':
								goto IL_091b;
							case 'E':
							case 'e':
								bNeedsRangeCheck = true;
								return 268288;
							default:
								goto IL_0928;
							}
							goto case '.';
							IL_0928:
							if (s[num] < '0' || s[num] > '9')
							{
								return 262144;
							}
						}
						bNeedsRangeCheck = true;
						if (flag || flag2)
						{
							return 269994;
						}
						return 270334;
					}
				}
				goto case '.';
			}
			default:
				{
					return 262144;
				}
				IL_091b:
				bDate = true;
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					bNeedsRangeCheck = true;
					return 393216;
				}
				switch (s[num])
				{
				case 'Z':
				case 'z':
					break;
				case '+':
					goto IL_09fb;
				default:
					return 262144;
				case '-':
					goto IL_0a09;
				}
				flag3 = true;
				goto IL_0ae1;
				IL_09fb:
				flag3 = true;
				goto IL_0b0d;
				IL_0b9d:
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					if (flag3)
					{
						bNeedsRangeCheck = true;
						return 393216;
					}
					return DateTime(s, bDate, bTime);
				}
				return 262144;
				IL_0ad3:
				flag3 = true;
				goto IL_0b9d;
				IL_0e0e:
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				while (true)
				{
					num++;
					if (num == s.Length)
					{
						return DateTime(s, bDate, bTime);
					}
					switch (s[num])
					{
					case 'Z':
					case 'z':
						break;
					case '+':
					case '-':
						goto IL_0b0d;
					default:
						goto IL_0e8d;
					}
					break;
					IL_0e8d:
					if (s[num] < '0' || s[num] > '9')
					{
						return 262144;
					}
				}
				goto IL_0ae1;
				IL_0ae1:
				num++;
				if (num == s.Length)
				{
					if (flag3)
					{
						bNeedsRangeCheck = true;
						return 393216;
					}
					return DateTime(s, bDate, bTime);
				}
				return 262144;
				IL_0cc1:
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] != ':')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return DateTime(s, bDate, bTime);
				}
				switch (s[num])
				{
				case 'Z':
				case 'z':
					break;
				case '+':
				case '-':
					goto IL_0b0d;
				default:
					return 262144;
				case '.':
					goto IL_0e0e;
				}
				goto IL_0ae1;
				IL_0a09:
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return DateTime(s, bDate, bTime);
				}
				switch (s[num])
				{
				case 'T':
					break;
				case ':':
					goto IL_0ad3;
				default:
					return 262144;
				case 'Z':
				case 'z':
					goto IL_0ae1;
				case '+':
				case '-':
					goto IL_0b0d;
				}
				bTime = true;
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] != ':')
				{
					return 262144;
				}
				goto IL_0cc1;
				IL_0b0d:
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] < '0' || s[num] > '9')
				{
					return 262144;
				}
				num++;
				if (num == s.Length)
				{
					return 262144;
				}
				if (s[num] != ':')
				{
					return 262144;
				}
				goto IL_0b9d;
			}
		}

		internal static int DateTime(string s, bool bDate, bool bTime)
		{
			try
			{
				XmlConvert.ToDateTime(s, XmlDateTimeSerializationMode.RoundtripKind);
			}
			catch (FormatException)
			{
				return 262144;
			}
			if (bDate && bTime)
			{
				return 278528;
			}
			if (bDate)
			{
				return 327680;
			}
			if (bTime)
			{
				return 294912;
			}
			return 262144;
		}

		private XmlSchemaElement CreateNewElementforChoice(XmlSchemaElement copyElement)
		{
			XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
			xmlSchemaElement.Annotation = copyElement.Annotation;
			xmlSchemaElement.Block = copyElement.Block;
			xmlSchemaElement.DefaultValue = copyElement.DefaultValue;
			xmlSchemaElement.Final = copyElement.Final;
			xmlSchemaElement.FixedValue = copyElement.FixedValue;
			xmlSchemaElement.Form = copyElement.Form;
			xmlSchemaElement.Id = copyElement.Id;
			if (copyElement.IsNillable)
			{
				xmlSchemaElement.IsNillable = copyElement.IsNillable;
			}
			xmlSchemaElement.LineNumber = copyElement.LineNumber;
			xmlSchemaElement.LinePosition = copyElement.LinePosition;
			xmlSchemaElement.Name = copyElement.Name;
			xmlSchemaElement.Namespaces = copyElement.Namespaces;
			xmlSchemaElement.RefName = copyElement.RefName;
			xmlSchemaElement.SchemaType = copyElement.SchemaType;
			xmlSchemaElement.SchemaTypeName = copyElement.SchemaTypeName;
			xmlSchemaElement.SourceUri = copyElement.SourceUri;
			xmlSchemaElement.SubstitutionGroup = copyElement.SubstitutionGroup;
			xmlSchemaElement.UnhandledAttributes = copyElement.UnhandledAttributes;
			if (copyElement.MinOccurs != 1m && Occurrence == InferenceOption.Relaxed)
			{
				xmlSchemaElement.MinOccurs = copyElement.MinOccurs;
			}
			if (copyElement.MaxOccurs != 1m)
			{
				xmlSchemaElement.MaxOccurs = copyElement.MaxOccurs;
			}
			return xmlSchemaElement;
		}

		private static int GetSchemaType(XmlQualifiedName qname)
		{
			if (qname == SimpleTypes[0])
			{
				return 262145;
			}
			if (qname == SimpleTypes[1])
			{
				return 269994;
			}
			if (qname == SimpleTypes[2])
			{
				return 270334;
			}
			if (qname == SimpleTypes[3])
			{
				return 269992;
			}
			if (qname == SimpleTypes[4])
			{
				return 270328;
			}
			if (qname == SimpleTypes[5])
			{
				return 269984;
			}
			if (qname == SimpleTypes[6])
			{
				return 270304;
			}
			if (qname == SimpleTypes[7])
			{
				return 269952;
			}
			if (qname == SimpleTypes[8])
			{
				return 270208;
			}
			if (qname == SimpleTypes[9])
			{
				return 269824;
			}
			if (qname == SimpleTypes[10])
			{
				return 269312;
			}
			if (qname == SimpleTypes[11])
			{
				return 268288;
			}
			if (qname == SimpleTypes[12])
			{
				return 266240;
			}
			if (qname == SimpleTypes[13])
			{
				return 270336;
			}
			if (qname == SimpleTypes[14])
			{
				return 278528;
			}
			if (qname == SimpleTypes[15])
			{
				return 294912;
			}
			if (qname == SimpleTypes[16])
			{
				return 65536;
			}
			if (qname == SimpleTypes[17])
			{
				return 131072;
			}
			if (qname == SimpleTypes[18])
			{
				return 262144;
			}
			if (qname == null || qname.IsEmpty)
			{
				return -1;
			}
			throw new XmlSchemaInferenceException("SchInf_schematype", 0, 0);
		}

		internal void SetMinMaxOccurs(XmlSchemaElement el, bool setMaxOccurs)
		{
			if (Occurrence == InferenceOption.Relaxed)
			{
				if (setMaxOccurs || el.MaxOccurs > 1m)
				{
					el.MaxOccurs = decimal.MaxValue;
				}
				el.MinOccurs = 0m;
			}
			else if (el.MinOccurs > 1m)
			{
				el.MinOccurs = 1m;
			}
		}
	}
	[Serializable]
	public class XmlSchemaInferenceException : XmlSchemaException
	{
		protected XmlSchemaInferenceException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
		}

		public XmlSchemaInferenceException()
			: base(null)
		{
		}

		public XmlSchemaInferenceException(string message)
			: base(message, (Exception)null, 0, 0)
		{
		}

		public XmlSchemaInferenceException(string message, Exception innerException)
			: base(message, innerException, 0, 0)
		{
		}

		public XmlSchemaInferenceException(string message, Exception innerException, int lineNumber, int linePosition)
			: base(message, innerException, lineNumber, linePosition)
		{
		}

		internal XmlSchemaInferenceException(string res, string[] args)
			: base(res, args, null, null, 0, 0, null)
		{
		}

		internal XmlSchemaInferenceException(string res, string arg)
			: base(res, new string[1] { arg }, null, null, 0, 0, null)
		{
		}

		internal XmlSchemaInferenceException(string res, string arg, string sourceUri, int lineNumber, int linePosition)
			: base(res, new string[1] { arg }, null, sourceUri, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaInferenceException(string res, string sourceUri, int lineNumber, int linePosition)
			: base(res, null, null, sourceUri, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaInferenceException(string res, string[] args, string sourceUri, int lineNumber, int linePosition)
			: base(res, args, null, sourceUri, lineNumber, linePosition, null)
		{
		}

		internal XmlSchemaInferenceException(string res, int lineNumber, int linePosition)
			: base(res, null, null, null, lineNumber, linePosition, null)
		{
		}
	}
}
namespace System.Xml.Serialization
{
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class CodeExporter
	{
		private Hashtable exportedMappings;

		private Hashtable exportedClasses;

		private CodeNamespace codeNamespace;

		private CodeCompileUnit codeCompileUnit;

		private bool rootExported;

		private TypeScope scope;

		private CodeAttributeDeclarationCollection includeMetadata = new CodeAttributeDeclarationCollection();

		private CodeGenerationOptions options;

		private CodeDomProvider codeProvider;

		private CodeAttributeDeclaration generatedCodeAttribute;

		internal CodeCompileUnit CodeCompileUnit => codeCompileUnit;

		internal CodeNamespace CodeNamespace
		{
			get
			{
				if (codeNamespace == null)
				{
					codeNamespace = new CodeNamespace();
				}
				return codeNamespace;
			}
		}

		internal CodeDomProvider CodeProvider
		{
			get
			{
				if (codeProvider == null)
				{
					codeProvider = new CSharpCodeProvider();
				}
				return codeProvider;
			}
		}

		internal Hashtable ExportedClasses
		{
			get
			{
				if (exportedClasses == null)
				{
					exportedClasses = new Hashtable();
				}
				return exportedClasses;
			}
		}

		internal Hashtable ExportedMappings
		{
			get
			{
				if (exportedMappings == null)
				{
					exportedMappings = new Hashtable();
				}
				return exportedMappings;
			}
		}

		internal bool GenerateProperties => (options & CodeGenerationOptions.GenerateProperties) != 0;

		internal CodeAttributeDeclaration GeneratedCodeAttribute
		{
			get
			{
				if (generatedCodeAttribute == null)
				{
					CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(typeof(GeneratedCodeAttribute).FullName);
					Assembly assembly = Assembly.GetEntryAssembly();
					if (assembly == null)
					{
						assembly = Assembly.GetExecutingAssembly();
						if (assembly == null)
						{
							assembly = typeof(CodeExporter).Assembly;
						}
					}
					AssemblyName name = assembly.GetName();
					codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(name.Name)));
					string productVersion = GetProductVersion(assembly);
					codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression((productVersion == null) ? name.Version.ToString() : productVersion)));
					generatedCodeAttribute = codeAttributeDeclaration;
				}
				return generatedCodeAttribute;
			}
		}

		public CodeAttributeDeclarationCollection IncludeMetadata => includeMetadata;

		internal TypeScope Scope => scope;

		private bool EnableDataBinding => (options & CodeGenerationOptions.EnableDataBinding) != 0;

		internal static CodeMemberMethod RaisePropertyChangedEventMethod
		{
			get
			{
				CodeMemberMethod codeMemberMethod = new CodeMemberMethod();
				codeMemberMethod.Name = "RaisePropertyChanged";
				codeMemberMethod.Attributes = (MemberAttributes)12290;
				CodeArgumentReferenceExpression codeArgumentReferenceExpression = new CodeArgumentReferenceExpression("propertyName");
				codeMemberMethod.Parameters.Add(new CodeParameterDeclarationExpression(typeof(string), codeArgumentReferenceExpression.ParameterName));
				CodeVariableReferenceExpression codeVariableReferenceExpression = new CodeVariableReferenceExpression("propertyChanged");
				codeMemberMethod.Statements.Add(new CodeVariableDeclarationStatement(typeof(PropertyChangedEventHandler), codeVariableReferenceExpression.VariableName, new CodeEventReferenceExpression(new CodeThisReferenceExpression(), PropertyChangedEvent.Name)));
				CodeConditionStatement codeConditionStatement = new CodeConditionStatement(new CodeBinaryOperatorExpression(codeVariableReferenceExpression, CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null)));
				codeMemberMethod.Statements.Add(codeConditionStatement);
				codeConditionStatement.TrueStatements.Add(new CodeDelegateInvokeExpression(codeVariableReferenceExpression, new CodeThisReferenceExpression(), new CodeObjectCreateExpression(typeof(PropertyChangedEventArgs), codeArgumentReferenceExpression)));
				return codeMemberMethod;
			}
		}

		internal static CodeMemberEvent PropertyChangedEvent
		{
			get
			{
				CodeMemberEvent codeMemberEvent = new CodeMemberEvent();
				codeMemberEvent.Attributes = MemberAttributes.Public;
				codeMemberEvent.Name = "PropertyChanged";
				codeMemberEvent.Type = new CodeTypeReference(typeof(PropertyChangedEventHandler));
				codeMemberEvent.ImplementationTypes.Add(typeof(INotifyPropertyChanged));
				return codeMemberEvent;
			}
		}

		internal CodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit, CodeDomProvider codeProvider, CodeGenerationOptions options, Hashtable exportedMappings)
		{
			if (codeNamespace != null)
			{
				CodeGenerator.ValidateIdentifiers(codeNamespace);
			}
			this.codeNamespace = codeNamespace;
			if (codeCompileUnit != null)
			{
				if (!codeCompileUnit.ReferencedAssemblies.Contains("System.dll"))
				{
					codeCompileUnit.ReferencedAssemblies.Add("System.dll");
				}
				if (!codeCompileUnit.ReferencedAssemblies.Contains("System.Xml.dll"))
				{
					codeCompileUnit.ReferencedAssemblies.Add("System.Xml.dll");
				}
			}
			this.codeCompileUnit = codeCompileUnit;
			this.options = options;
			this.exportedMappings = exportedMappings;
			this.codeProvider = codeProvider;
		}

		internal static CodeAttributeDeclaration FindAttributeDeclaration(Type type, CodeAttributeDeclarationCollection metadata)
		{
			foreach (CodeAttributeDeclaration metadatum in metadata)
			{
				if (metadatum.Name == type.FullName || metadatum.Name == type.Name)
				{
					return metadatum;
				}
			}
			return null;
		}

		private static string GetProductVersion(Assembly assembly)
		{
			object[] customAttributes = assembly.GetCustomAttributes(inherit: true);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				if (customAttributes[i] is AssemblyInformationalVersionAttribute)
				{
					AssemblyInformationalVersionAttribute assemblyInformationalVersionAttribute = (AssemblyInformationalVersionAttribute)customAttributes[i];
					return assemblyInformationalVersionAttribute.InformationalVersion;
				}
			}
			return null;
		}

		internal void CheckScope(TypeScope scope)
		{
			if (this.scope == null)
			{
				this.scope = scope;
			}
			else if (this.scope != scope)
			{
				throw new InvalidOperationException(Res.GetString("XmlMappingsScopeMismatch"));
			}
		}

		internal abstract void ExportDerivedStructs(StructMapping mapping);

		internal abstract void EnsureTypesExported(Accessor[] accessors, string ns);

		internal static void AddWarningComment(CodeCommentStatementCollection comments, string text)
		{
			comments.Add(new CodeCommentStatement(Res.GetString("XmlCodegenWarningDetails", text), docComment: false));
		}

		internal void ExportRoot(StructMapping mapping, Type includeType)
		{
			if (rootExported)
			{
				return;
			}
			rootExported = true;
			ExportDerivedStructs(mapping);
			for (StructMapping structMapping = mapping.DerivedMappings; structMapping != null; structMapping = structMapping.NextDerivedMapping)
			{
				if (!structMapping.ReferencedByElement && structMapping.IncludeInSchema && !structMapping.IsAnonymousType)
				{
					CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(includeType.FullName);
					codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodeTypeOfExpression(structMapping.TypeDesc.FullName)));
					includeMetadata.Add(codeAttributeDeclaration);
				}
			}
			Hashtable hashtable = new Hashtable();
			foreach (TypeMapping typeMapping in Scope.TypeMappings)
			{
				if (typeMapping is ArrayMapping)
				{
					ArrayMapping arrayMapping = (ArrayMapping)typeMapping;
					if (ShouldInclude(arrayMapping) && !hashtable.Contains(arrayMapping.TypeDesc.FullName))
					{
						CodeAttributeDeclaration codeAttributeDeclaration2 = new CodeAttributeDeclaration(includeType.FullName);
						codeAttributeDeclaration2.Arguments.Add(new CodeAttributeArgument(new CodeTypeOfExpression(arrayMapping.TypeDesc.FullName)));
						includeMetadata.Add(codeAttributeDeclaration2);
						hashtable.Add(arrayMapping.TypeDesc.FullName, string.Empty);
						EnsureTypesExported(arrayMapping.Elements, arrayMapping.Namespace);
					}
				}
			}
		}

		private static bool ShouldInclude(ArrayMapping arrayMapping)
		{
			if (arrayMapping.ReferencedByElement)
			{
				return false;
			}
			if (arrayMapping.Next != null)
			{
				return false;
			}
			if (arrayMapping.Elements.Length == 1)
			{
				TypeKind kind = arrayMapping.Elements[0].Mapping.TypeDesc.Kind;
				if (kind == TypeKind.Node)
				{
					return false;
				}
			}
			for (int i = 0; i < arrayMapping.Elements.Length; i++)
			{
				if (arrayMapping.Elements[i].Name != arrayMapping.Elements[i].Mapping.DefaultElementName)
				{
					return false;
				}
			}
			return true;
		}

		internal CodeTypeDeclaration ExportEnum(EnumMapping mapping, Type type)
		{
			CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration(mapping.TypeDesc.Name);
			codeTypeDeclaration.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
			codeTypeDeclaration.IsEnum = true;
			if (mapping.IsFlags && mapping.Constants.Length > 31)
			{
				codeTypeDeclaration.BaseTypes.Add(new CodeTypeReference(typeof(long)));
			}
			codeTypeDeclaration.TypeAttributes |= TypeAttributes.Public;
			CodeNamespace.Types.Add(codeTypeDeclaration);
			for (int i = 0; i < mapping.Constants.Length; i++)
			{
				ExportConstant(codeTypeDeclaration, mapping.Constants[i], type, mapping.IsFlags, 1L << i);
			}
			if (mapping.IsFlags)
			{
				CodeAttributeDeclaration value = new CodeAttributeDeclaration(typeof(FlagsAttribute).FullName);
				codeTypeDeclaration.CustomAttributes.Add(value);
			}
			CodeGenerator.ValidateIdentifiers(codeTypeDeclaration);
			return codeTypeDeclaration;
		}

		internal void AddTypeMetadata(CodeAttributeDeclarationCollection metadata, Type type, string defaultName, string name, string ns, bool includeInSchema)
		{
			CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(type.FullName);
			if (name == null || name.Length == 0)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("AnonymousType", new CodePrimitiveExpression(true)));
			}
			else if (defaultName != name)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("TypeName", new CodePrimitiveExpression(name)));
			}
			if (ns != null && ns.Length != 0)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(ns)));
			}
			if (!includeInSchema)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("IncludeInSchema", new CodePrimitiveExpression(false)));
			}
			if (codeAttributeDeclaration.Arguments.Count > 0)
			{
				metadata.Add(codeAttributeDeclaration);
			}
		}

		internal static void AddIncludeMetadata(CodeAttributeDeclarationCollection metadata, StructMapping mapping, Type type)
		{
			if (!mapping.IsAnonymousType)
			{
				for (StructMapping structMapping = mapping.DerivedMappings; structMapping != null; structMapping = structMapping.NextDerivedMapping)
				{
					CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(type.FullName);
					codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodeTypeOfExpression(structMapping.TypeDesc.FullName)));
					metadata.Add(codeAttributeDeclaration);
					AddIncludeMetadata(metadata, structMapping, type);
				}
			}
		}

		internal static void ExportConstant(CodeTypeDeclaration codeClass, ConstantMapping constant, Type type, bool init, long enumValue)
		{
			CodeMemberField codeMemberField = new CodeMemberField(typeof(int).FullName, constant.Name);
			codeMemberField.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
			if (init)
			{
				codeMemberField.InitExpression = new CodePrimitiveExpression(enumValue);
			}
			codeClass.Members.Add(codeMemberField);
			if (constant.XmlName != constant.Name)
			{
				CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(type.FullName);
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(constant.XmlName)));
				codeMemberField.CustomAttributes.Add(codeAttributeDeclaration);
			}
		}

		internal static object PromoteType(Type type, object value)
		{
			if (type == typeof(sbyte))
			{
				return ((IConvertible)value).ToInt16(null);
			}
			if (type == typeof(ushort))
			{
				return ((IConvertible)value).ToInt32(null);
			}
			if (type == typeof(uint))
			{
				return ((IConvertible)value).ToInt64(null);
			}
			if (type == typeof(ulong))
			{
				return ((IConvertible)value).ToDecimal(null);
			}
			return value;
		}

		internal CodeMemberProperty CreatePropertyDeclaration(CodeMemberField field, string name, string typeName)
		{
			CodeMemberProperty codeMemberProperty = new CodeMemberProperty();
			codeMemberProperty.Type = new CodeTypeReference(typeName);
			codeMemberProperty.Name = name;
			codeMemberProperty.Attributes = (codeMemberProperty.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
			CodeMethodReturnStatement codeMethodReturnStatement = new CodeMethodReturnStatement();
			codeMethodReturnStatement.Expression = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), field.Name);
			codeMemberProperty.GetStatements.Add(codeMethodReturnStatement);
			CodeAssignStatement codeAssignStatement = new CodeAssignStatement();
			CodeExpression left = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), field.Name);
			CodeExpression right = new CodePropertySetValueReferenceExpression();
			codeAssignStatement.Left = left;
			codeAssignStatement.Right = right;
			if (EnableDataBinding)
			{
				codeMemberProperty.SetStatements.Add(codeAssignStatement);
				codeMemberProperty.SetStatements.Add(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), RaisePropertyChangedEventMethod.Name, new CodePrimitiveExpression(name)));
			}
			else
			{
				codeMemberProperty.SetStatements.Add(codeAssignStatement);
			}
			return codeMemberProperty;
		}

		internal static string MakeFieldName(string name)
		{
			return CodeIdentifier.MakeCamel(name) + "Field";
		}

		internal void AddPropertyChangedNotifier(CodeTypeDeclaration codeClass)
		{
			if (EnableDataBinding && codeClass != null)
			{
				if (codeClass.BaseTypes.Count == 0)
				{
					codeClass.BaseTypes.Add(typeof(object));
				}
				codeClass.BaseTypes.Add(new CodeTypeReference(typeof(INotifyPropertyChanged)));
				codeClass.Members.Add(PropertyChangedEvent);
				codeClass.Members.Add(RaisePropertyChangedEventMethod);
			}
		}
	}
	[Flags]
	public enum CodeGenerationOptions
	{
		[XmlIgnore]
		None = 0,
		[XmlEnum("properties")]
		GenerateProperties = 1,
		[XmlEnum("newAsync")]
		GenerateNewAsync = 2,
		[XmlEnum("oldAsync")]
		GenerateOldAsync = 4,
		[XmlEnum("order")]
		GenerateOrder = 8,
		[XmlEnum("enableDataBinding")]
		EnableDataBinding = 0x10
	}
	public class CodeIdentifier
	{
		internal const int MaxIdentifierLength = 511;

		internal static CodeDomProvider csharp = new CSharpCodeProvider();

		[Obsolete("This class should never get constructed as it contains only static methods.")]
		public CodeIdentifier()
		{
		}

		public static string MakePascal(string identifier)
		{
			identifier = MakeValid(identifier);
			if (identifier.Length <= 2)
			{
				return identifier.ToUpper(CultureInfo.InvariantCulture);
			}
			if (char.IsLower(identifier[0]))
			{
				return char.ToUpper(identifier[0], CultureInfo.InvariantCulture).ToString(CultureInfo.InvariantCulture) + identifier.Substring(1);
			}
			return identifier;
		}

		public static string MakeCamel(string identifier)
		{
			identifier = MakeValid(identifier);
			if (identifier.Length <= 2)
			{
				return identifier.ToLower(CultureInfo.InvariantCulture);
			}
			if (char.IsUpper(identifier[0]))
			{
				return char.ToLower(identifier[0], CultureInfo.InvariantCulture).ToString(CultureInfo.InvariantCulture) + identifier.Substring(1);
			}
			return identifier;
		}

		public static string MakeValid(string identifier)
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < identifier.Length; i++)
			{
				if (stringBuilder.Length >= 511)
				{
					break;
				}
				char c = identifier[i];
				if (IsValid(c))
				{
					if (stringBuilder.Length == 0 && !IsValidStart(c))
					{
						stringBuilder.Append("Item");
					}
					stringBuilder.Append(c);
				}
			}
			if (stringBuilder.Length == 0)
			{
				return "Item";
			}
			return stringBuilder.ToString();
		}

		internal static string MakeValidInternal(string identifier)
		{
			if (identifier.Length > 30)
			{
				return "Item";
			}
			return MakeValid(identifier);
		}

		private static bool IsValidStart(char c)
		{
			if (char.GetUnicodeCategory(c) == UnicodeCategory.DecimalDigitNumber)
			{
				return false;
			}
			return true;
		}

		private static bool IsValid(char c)
		{
			switch (char.GetUnicodeCategory(c))
			{
			case UnicodeCategory.EnclosingMark:
			case UnicodeCategory.LetterNumber:
			case UnicodeCategory.OtherNumber:
			case UnicodeCategory.SpaceSeparator:
			case UnicodeCategory.LineSeparator:
			case UnicodeCategory.ParagraphSeparator:
			case UnicodeCategory.Control:
			case UnicodeCategory.Format:
			case UnicodeCategory.Surrogate:
			case UnicodeCategory.PrivateUse:
			case UnicodeCategory.DashPunctuation:
			case UnicodeCategory.OpenPunctuation:
			case UnicodeCategory.ClosePunctuation:
			case UnicodeCategory.InitialQuotePunctuation:
			case UnicodeCategory.FinalQuotePunctuation:
			case UnicodeCategory.OtherPunctuation:
			case UnicodeCategory.MathSymbol:
			case UnicodeCategory.CurrencySymbol:
			case UnicodeCategory.ModifierSymbol:
			case UnicodeCategory.OtherSymbol:
			case UnicodeCategory.OtherNotAssigned:
				return false;
			default:
				return false;
			case UnicodeCategory.UppercaseLetter:
			case UnicodeCategory.LowercaseLetter:
			case UnicodeCategory.TitlecaseLetter:
			case UnicodeCategory.ModifierLetter:
			case UnicodeCategory.OtherLetter:
			case UnicodeCategory.NonSpacingMark:
			case UnicodeCategory.SpacingCombiningMark:
			case UnicodeCategory.DecimalDigitNumber:
			case UnicodeCategory.ConnectorPunctuation:
				return true;
			}
		}

		internal static void CheckValidIdentifier(string ident)
		{
			if (!CodeGenerator.IsValidLanguageIndependentIdentifier(ident))
			{
				throw new ArgumentException(Res.GetString("XmlInvalidIdentifier", ident), "ident");
			}
		}

		internal static string GetCSharpName(string name)
		{
			return EscapeKeywords(name.Replace('+', '.'), csharp);
		}

		private static int GetCSharpName(Type t, Type[] parameters, int index, StringBuilder sb)
		{
			if (t.DeclaringType != null && t.DeclaringType != t)
			{
				index = GetCSharpName(t.DeclaringType, parameters, index, sb);
				sb.Append(".");
			}
			string name = t.Name;
			int num = name.IndexOf('`');
			if (num < 0)
			{
				num = name.IndexOf('!');
			}
			if (num > 0)
			{
				EscapeKeywords(name.Substring(0, num), csharp, sb);
				sb.Append("<");
				int num2 = int.Parse(name.Substring(num + 1), CultureInfo.InvariantCulture) + index;
				while (index < num2)
				{
					sb.Append(GetCSharpName(parameters[index]));
					if (index < num2 - 1)
					{
						sb.Append(",");
					}
					index++;
				}
				sb.Append(">");
			}
			else
			{
				EscapeKeywords(name, csharp, sb);
			}
			return index;
		}

		internal static string GetCSharpName(Type t)
		{
			int num = 0;
			while (t.IsArray)
			{
				t = t.GetElementType();
				num++;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("global::");
			string @namespace = t.Namespace;
			if (@namespace != null && @namespace.Length > 0)
			{
				string[] array = @namespace.Split('.');
				for (int i = 0; i < array.Length; i++)
				{
					EscapeKeywords(array[i], csharp, stringBuilder);
					stringBuilder.Append(".");
				}
			}
			Type[] parameters = ((t.IsGenericType || t.ContainsGenericParameters) ? t.GetGenericArguments() : new Type[0]);
			GetCSharpName(t, parameters, 0, stringBuilder);
			for (int j = 0; j < num; j++)
			{
				stringBuilder.Append("[]");
			}
			return stringBuilder.ToString();
		}

		private static void EscapeKeywords(string identifier, CodeDomProvider codeProvider, StringBuilder sb)
		{
			if (identifier != null && identifier.Length != 0)
			{
				int num = 0;
				while (identifier.EndsWith("[]", StringComparison.Ordinal))
				{
					num++;
					identifier = identifier.Substring(0, identifier.Length - 2);
				}
				if (identifier.Length > 0)
				{
					CheckValidIdentifier(identifier);
					identifier = codeProvider.CreateEscapedIdentifier(identifier);
					sb.Append(identifier);
				}
				for (int i = 0; i < num; i++)
				{
					sb.Append("[]");
				}
			}
		}

		private static string EscapeKeywords(string identifier, CodeDomProvider codeProvider)
		{
			if (identifier == null || identifier.Length == 0)
			{
				return identifier;
			}
			string[] array = identifier.Split('.', ',', '<', '>');
			StringBuilder stringBuilder = new StringBuilder();
			int num = -1;
			for (int i = 0; i < array.Length; i++)
			{
				if (num >= 0)
				{
					stringBuilder.Append(identifier.Substring(num, 1));
				}
				num++;
				num += array[i].Length;
				string identifier2 = array[i].Trim();
				EscapeKeywords(identifier2, codeProvider, stringBuilder);
			}
			if (stringBuilder.Length == identifier.Length)
			{
				return identifier;
			}
			return stringBuilder.ToString();
		}
	}
	internal class CaseInsensitiveKeyComparer : CaseInsensitiveComparer, IEqualityComparer
	{
		public CaseInsensitiveKeyComparer()
			: base(CultureInfo.CurrentCulture)
		{
		}

		bool IEqualityComparer.Equals(object x, object y)
		{
			return Compare(x, y) == 0;
		}

		int IEqualityComparer.GetHashCode(object obj)
		{
			if (!(obj is string text))
			{
				throw new ArgumentException(null, "obj");
			}
			return text.ToUpper(CultureInfo.CurrentCulture).GetHashCode();
		}
	}
	public class CodeIdentifiers
	{
		private Hashtable identifiers;

		private Hashtable reservedIdentifiers;

		private ArrayList list;

		private bool camelCase;

		public bool UseCamelCasing
		{
			get
			{
				return camelCase;
			}
			set
			{
				camelCase = value;
			}
		}

		public CodeIdentifiers()
			: this(caseSensitive: true)
		{
		}

		public CodeIdentifiers(bool caseSensitive)
		{
			if (caseSensitive)
			{
				identifiers = new Hashtable();
				reservedIdentifiers = new Hashtable();
			}
			else
			{
				IEqualityComparer equalityComparer = new CaseInsensitiveKeyComparer();
				identifiers = new Hashtable(equalityComparer);
				reservedIdentifiers = new Hashtable(equalityComparer);
			}
			list = new ArrayList();
		}

		public void Clear()
		{
			identifiers.Clear();
			list.Clear();
		}

		public string MakeRightCase(string identifier)
		{
			if (camelCase)
			{
				return CodeIdentifier.MakeCamel(identifier);
			}
			return CodeIdentifier.MakePascal(identifier);
		}

		public string MakeUnique(string identifier)
		{
			if (IsInUse(identifier))
			{
				int num = 1;
				string text;
				while (true)
				{
					text = identifier + num.ToString(CultureInfo.InvariantCulture);
					if (!IsInUse(text))
					{
						break;
					}
					num++;
				}
				identifier = text;
			}
			if (identifier.Length > 511)
			{
				return MakeUnique("Item");
			}
			return identifier;
		}

		public void AddReserved(string identifier)
		{
			reservedIdentifiers.Add(identifier, identifier);
		}

		public void RemoveReserved(string identifier)
		{
			reservedIdentifiers.Remove(identifier);
		}

		public string AddUnique(string identifier, object value)
		{
			identifier = MakeUnique(identifier);
			Add(identifier, value);
			return identifier;
		}

		public bool IsInUse(string identifier)
		{
			if (!identifiers.Contains(identifier))
			{
				return reservedIdentifiers.Contains(identifier);
			}
			return true;
		}

		public void Add(string identifier, object value)
		{
			identifiers.Add(identifier, value);
			list.Add(value);
		}

		public void Remove(string identifier)
		{
			list.Remove(identifiers[identifier]);
			identifiers.Remove(identifier);
		}

		public object ToArray(Type type)
		{
			Array array = Array.CreateInstance(type, list.Count);
			list.CopyTo(array, 0);
			return array;
		}

		internal CodeIdentifiers Clone()
		{
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			codeIdentifiers.identifiers = (Hashtable)identifiers.Clone();
			codeIdentifiers.reservedIdentifiers = (Hashtable)reservedIdentifiers.Clone();
			codeIdentifiers.list = (ArrayList)list.Clone();
			codeIdentifiers.camelCase = camelCase;
			return codeIdentifiers;
		}
	}
	internal class TempAssembly
	{
		internal class TempMethod
		{
			internal MethodInfo writeMethod;

			internal MethodInfo readMethod;

			internal string name;

			internal string ns;

			internal bool isSoap;

			internal string methodKey;
		}

		internal sealed class TempMethodDictionary : DictionaryBase
		{
			internal TempMethod this[string key] => (TempMethod)base.Dictionary[key];

			internal void Add(string key, TempMethod value)
			{
				base.Dictionary.Add(key, value);
			}
		}

		private const string GeneratedAssemblyNamespace = "Microsoft.Xml.Serialization.GeneratedAssembly";

		private Assembly assembly;

		private bool pregeneratedAssmbly;

		private XmlSerializerImplementation contract;

		private Hashtable writerMethods;

		private Hashtable readerMethods;

		private TempMethodDictionary methods;

		private static object[] emptyObjectArray = new object[0];

		private Hashtable assemblies = new Hashtable();

		private static FileIOPermission fileIOPermission;

		internal XmlSerializerImplementation Contract
		{
			get
			{
				if (contract == null)
				{
					contract = (XmlSerializerImplementation)Activator.CreateInstance(GetTypeFromAssembly(assembly, "XmlSerializerContract"));
				}
				return contract;
			}
		}

		internal static FileIOPermission FileIOPermission
		{
			get
			{
				if (fileIOPermission == null)
				{
					fileIOPermission = new FileIOPermission(PermissionState.Unrestricted);
				}
				return fileIOPermission;
			}
		}

		internal bool NeedAssembyResolve
		{
			get
			{
				if (assemblies != null)
				{
					return assemblies.Count > 0;
				}
				return false;
			}
		}

		private TempAssembly()
		{
		}

		internal TempAssembly(XmlMapping[] xmlMappings, Type[] types, string defaultNamespace, string location, Evidence evidence)
		{
			assembly = GenerateAssembly(xmlMappings, types, defaultNamespace, evidence, XmlSerializerCompilerParameters.Create(location), null, assemblies);
			InitAssemblyMethods(xmlMappings);
		}

		internal TempAssembly(XmlMapping[] xmlMappings, Assembly assembly, XmlSerializerImplementation contract)
		{
			this.assembly = assembly;
			InitAssemblyMethods(xmlMappings);
			this.contract = contract;
			pregeneratedAssmbly = true;
		}

		internal TempAssembly(XmlSerializerImplementation contract)
		{
			this.contract = contract;
			pregeneratedAssmbly = true;
		}

		internal void InitAssemblyMethods(XmlMapping[] xmlMappings)
		{
			methods = new TempMethodDictionary();
			for (int i = 0; i < xmlMappings.Length; i++)
			{
				TempMethod tempMethod = new TempMethod();
				tempMethod.isSoap = xmlMappings[i].IsSoap;
				tempMethod.methodKey = xmlMappings[i].Key;
				if (xmlMappings[i] is XmlTypeMapping xmlTypeMapping)
				{
					tempMethod.name = xmlTypeMapping.ElementName;
					tempMethod.ns = xmlTypeMapping.Namespace;
				}
				methods.Add(xmlMappings[i].Key, tempMethod);
			}
		}

		internal static Assembly LoadGeneratedAssembly(Type type, string defaultNamespace, out XmlSerializerImplementation contract)
		{
			Assembly assembly = null;
			contract = null;
			string text = null;
			bool enabled = DiagnosticsSwitches.PregenEventLog.Enabled;
			object[] customAttributes = type.GetCustomAttributes(typeof(XmlSerializerAssemblyAttribute), inherit: false);
			if (customAttributes.Length == 0)
			{
				AssemblyName name = GetName(type.Assembly, copyName: true);
				text = (name.Name = Compiler.GetTempAssemblyName(name, defaultNamespace));
				name.CodeBase = null;
				name.CultureInfo = CultureInfo.InvariantCulture;
				try
				{
					assembly = Assembly.Load(name);
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					if (enabled)
					{
						Log(ex.Message, EventLogEntryType.Information);
					}
					byte[] publicKeyToken = name.GetPublicKeyToken();
					if (publicKeyToken != null && publicKeyToken.Length > 0)
					{
						return null;
					}
					assembly = Assembly.LoadWithPartialName(text, null);
				}
				catch
				{
					if (enabled)
					{
						Log(Res.GetString("XmlNonCLSCompliantException"), EventLogEntryType.Information);
					}
					return null;
				}
				if (assembly == null)
				{
					if (enabled)
					{
						Log(Res.GetString("XmlPregenCannotLoad", text), EventLogEntryType.Information);
					}
					return null;
				}
				if (!IsSerializerVersionMatch(assembly, type, defaultNamespace, null))
				{
					if (enabled)
					{
						Log(Res.GetString("XmlSerializerExpiredDetails", text, type.FullName), EventLogEntryType.Error);
					}
					return null;
				}
			}
			else
			{
				XmlSerializerAssemblyAttribute xmlSerializerAssemblyAttribute = (XmlSerializerAssemblyAttribute)customAttributes[0];
				if (xmlSerializerAssemblyAttribute.AssemblyName != null && xmlSerializerAssemblyAttribute.CodeBase != null)
				{
					throw new InvalidOperationException(Res.GetString("XmlPregenInvalidXmlSerializerAssemblyAttribute", "AssemblyName", "CodeBase"));
				}
				if (xmlSerializerAssemblyAttribute.AssemblyName != null)
				{
					text = xmlSerializerAssemblyAttribute.AssemblyName;
					assembly = Assembly.LoadWithPartialName(text, null);
				}
				else if (xmlSerializerAssemblyAttribute.CodeBase != null && xmlSerializerAssemblyAttribute.CodeBase.Length > 0)
				{
					text = xmlSerializerAssemblyAttribute.CodeBase;
					assembly = Assembly.LoadFrom(text);
				}
				else
				{
					text = type.Assembly.FullName;
					assembly = type.Assembly;
				}
				if (assembly == null)
				{
					throw new FileNotFoundException(null, text);
				}
			}
			Type typeFromAssembly = GetTypeFromAssembly(assembly, "XmlSerializerContract");
			contract = (XmlSerializerImplementation)Activator.CreateInstance(typeFromAssembly);
			if (contract.CanSerialize(type))
			{
				return assembly;
			}
			if (enabled)
			{
				Log(Res.GetString("XmlSerializerExpiredDetails", text, type.FullName), EventLogEntryType.Error);
			}
			return null;
		}

		private static void Log(string message, EventLogEntryType type)
		{
			new EventLogPermission(PermissionState.Unrestricted).Assert();
			EventLog.WriteEntry("XmlSerializer", message, type);
		}

		private static AssemblyName GetName(Assembly assembly, bool copyName)
		{
			PermissionSet permissionSet = new PermissionSet(PermissionState.None);
			permissionSet.AddPermission(new FileIOPermission(PermissionState.Unrestricted));
			permissionSet.Assert();
			return assembly.GetName(copyName);
		}

		private static bool IsSerializerVersionMatch(Assembly serializer, Type type, string defaultNamespace, string location)
		{
			if (serializer == null)
			{
				return false;
			}
			object[] customAttributes = serializer.GetCustomAttributes(typeof(XmlSerializerVersionAttribute), inherit: false);
			if (customAttributes.Length != 1)
			{
				return false;
			}
			XmlSerializerVersionAttribute xmlSerializerVersionAttribute = (XmlSerializerVersionAttribute)customAttributes[0];
			if (xmlSerializerVersionAttribute.ParentAssemblyId == GenerateAssemblyId(type) && xmlSerializerVersionAttribute.Namespace == defaultNamespace)
			{
				return true;
			}
			return false;
		}

		private static string GenerateAssemblyId(Type type)
		{
			Module[] modules = type.Assembly.GetModules();
			ArrayList arrayList = new ArrayList();
			for (int i = 0; i < modules.Length; i++)
			{
				arrayList.Add(modules[i].ModuleVersionId.ToString());
			}
			arrayList.Sort();
			StringBuilder stringBuilder = new StringBuilder();
			for (int j = 0; j < arrayList.Count; j++)
			{
				stringBuilder.Append(arrayList[j].ToString());
				stringBuilder.Append(",");
			}
			return stringBuilder.ToString();
		}

		internal static Assembly GenerateAssembly(XmlMapping[] xmlMappings, Type[] types, string defaultNamespace, Evidence evidence, XmlSerializerCompilerParameters parameters, Assembly assembly, Hashtable assemblies)
		{
			FileIOPermission.Assert();
			for (int i = 0; i < xmlMappings.Length; i++)
			{
				xmlMappings[i].CheckShallow();
			}
			Compiler compiler = new Compiler();
			try
			{
				Hashtable hashtable = new Hashtable();
				foreach (XmlMapping xmlMapping in xmlMappings)
				{
					hashtable[xmlMapping.Scope] = xmlMapping;
				}
				TypeScope[] array = new TypeScope[hashtable.Keys.Count];
				hashtable.Keys.CopyTo(array, 0);
				assemblies.Clear();
				Hashtable types2 = new Hashtable();
				TypeScope[] array2 = array;
				foreach (TypeScope typeScope in array2)
				{
					foreach (Type type3 in typeScope.Types)
					{
						compiler.AddImport(type3, types2);
						Assembly assembly2 = type3.Assembly;
						string fullName = assembly2.FullName;
						if (assemblies[fullName] == null && !assembly2.GlobalAssemblyCache)
						{
							assemblies[fullName] = assembly2;
						}
					}
				}
				for (int l = 0; l < types.Length; l++)
				{
					compiler.AddImport(types[l], types2);
				}
				compiler.AddImport(typeof(object).Assembly);
				compiler.AddImport(typeof(XmlSerializer).Assembly);
				IndentedWriter indentedWriter = new IndentedWriter(compiler.Source, compact: false);
				indentedWriter.WriteLine("#if _DYNAMIC_XMLSERIALIZER_COMPILATION");
				indentedWriter.WriteLine("[assembly:System.Security.AllowPartiallyTrustedCallers()]");
				indentedWriter.WriteLine("[assembly:System.Security.SecurityTransparent()]");
				indentedWriter.WriteLine("#endif");
				if (types != null && types.Length > 0 && types[0] != null)
				{
					indentedWriter.WriteLine("[assembly:System.Reflection.AssemblyVersionAttribute(\"" + types[0].Assembly.GetName().Version.ToString() + "\")]");
				}
				if (assembly != null && types.Length > 0)
				{
					for (int m = 0; m < types.Length; m++)
					{
						Type type2 = types[m];
						if (type2 != null && DynamicAssemblies.IsTypeDynamic(type2))
						{
							throw new InvalidOperationException(Res.GetString("XmlPregenTypeDynamic", types[m].FullName));
						}
					}
					indentedWriter.Write("[assembly:");
					indentedWriter.Write(typeof(XmlSerializerVersionAttribute).FullName);
					indentedWriter.Write("(");
					indentedWriter.Write("ParentAssemblyId=");
					ReflectionAwareCodeGen.WriteQuotedCSharpString(indentedWriter, GenerateAssemblyId(types[0]));
					indentedWriter.Write(", Version=");
					ReflectionAwareCodeGen.WriteQuotedCSharpString(indentedWriter, "2.0.0.0");
					if (defaultNamespace != null)
					{
						indentedWriter.Write(", Namespace=");
						ReflectionAwareCodeGen.WriteQuotedCSharpString(indentedWriter, defaultNamespace);
					}
					indentedWriter.WriteLine(")]");
				}
				CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
				codeIdentifiers.AddUnique("XmlSerializationWriter", "XmlSerializationWriter");
				codeIdentifiers.AddUnique("XmlSerializationReader", "XmlSerializationReader");
				string text = null;
				if (types != null && types.Length == 1 && types[0] != null)
				{
					text = CodeIdentifier.MakeValid(types[0].Name);
					if (types[0].IsArray)
					{
						text += "Array";
					}
				}
				indentedWriter.WriteLine("namespace Microsoft.Xml.Serialization.GeneratedAssembly {");
				indentedWriter.Indent++;
				indentedWriter.WriteLine();
				string text2 = "XmlSerializationWriter" + text;
				text2 = codeIdentifiers.AddUnique(text2, text2);
				XmlSerializationWriterCodeGen xmlSerializationWriterCodeGen = new XmlSerializationWriterCodeGen(indentedWriter, array, "public", text2);
				xmlSerializationWriterCodeGen.GenerateBegin();
				string[] array3 = new string[xmlMappings.Length];
				for (int n = 0; n < xmlMappings.Length; n++)
				{
					array3[n] = xmlSerializationWriterCodeGen.GenerateElement(xmlMappings[n]);
				}
				xmlSerializationWriterCodeGen.GenerateEnd();
				indentedWriter.WriteLine();
				string text3 = "XmlSerializationReader" + text;
				text3 = codeIdentifiers.AddUnique(text3, text3);
				XmlSerializationReaderCodeGen xmlSerializationReaderCodeGen = new XmlSerializationReaderCodeGen(indentedWriter, array, "public", text3);
				xmlSerializationReaderCodeGen.GenerateBegin();
				string[] array4 = new string[xmlMappings.Length];
				for (int num = 0; num < xmlMappings.Length; num++)
				{
					array4[num] = xmlSerializationReaderCodeGen.GenerateElement(xmlMappings[num]);
				}
				xmlSerializationReaderCodeGen.GenerateEnd(array4, xmlMappings, types);
				string baseSerializer = xmlSerializationReaderCodeGen.GenerateBaseSerializer("XmlSerializer1", text3, text2, codeIdentifiers);
				Hashtable hashtable2 = new Hashtable();
				for (int num2 = 0; num2 < xmlMappings.Length; num2++)
				{
					if (hashtable2[xmlMappings[num2].Key] == null)
					{
						hashtable2[xmlMappings[num2].Key] = xmlSerializationReaderCodeGen.GenerateTypedSerializer(array4[num2], array3[num2], xmlMappings[num2], codeIdentifiers, baseSerializer, text3, text2);
					}
				}
				xmlSerializationReaderCodeGen.GenerateSerializerContract("XmlSerializerContract", xmlMappings, types, text3, array4, text2, array3, hashtable2);
				indentedWriter.Indent--;
				indentedWriter.WriteLine("}");
				return compiler.Compile(assembly, defaultNamespace, parameters, evidence);
			}
			finally
			{
				compiler.Close();
			}
		}

		private static MethodInfo GetMethodFromType(Type type, string methodName, Assembly assembly)
		{
			MethodInfo method = type.GetMethod(methodName);
			if (method != null)
			{
				return method;
			}
			MissingMethodException ex = new MissingMethodException(type.FullName, methodName);
			if (assembly != null)
			{
				throw new InvalidOperationException(Res.GetString("XmlSerializerExpired", assembly.FullName, assembly.CodeBase), ex);
			}
			throw ex;
		}

		internal static Type GetTypeFromAssembly(Assembly assembly, string typeName)
		{
			typeName = "Microsoft.Xml.Serialization.GeneratedAssembly." + typeName;
			Type type = assembly.GetType(typeName);
			if (type == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlMissingType", typeName, assembly.FullName));
			}
			return type;
		}

		internal bool CanRead(XmlMapping mapping, XmlReader xmlReader)
		{
			if (mapping == null)
			{
				return false;
			}
			if (mapping.Accessor.Any)
			{
				return true;
			}
			TempMethod tempMethod = methods[mapping.Key];
			return xmlReader.IsStartElement(tempMethod.name, tempMethod.ns);
		}

		private string ValidateEncodingStyle(string encodingStyle, string methodKey)
		{
			if (encodingStyle != null && encodingStyle.Length > 0)
			{
				if (!methods[methodKey].isSoap)
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidEncodingNotEncoded1", encodingStyle));
				}
				if (encodingStyle != "http://schemas.xmlsoap.org/soap/encoding/" && encodingStyle != "http://www.w3.org/2003/05/soap-encoding")
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidEncoding3", encodingStyle, "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/2003/05/soap-encoding"));
				}
			}
			else if (methods[methodKey].isSoap)
			{
				encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
			}
			return encodingStyle;
		}

		internal object InvokeReader(XmlMapping mapping, XmlReader xmlReader, XmlDeserializationEvents events, string encodingStyle)
		{
			XmlSerializationReader xmlSerializationReader = null;
			try
			{
				encodingStyle = ValidateEncodingStyle(encodingStyle, mapping.Key);
				xmlSerializationReader = Contract.Reader;
				xmlSerializationReader.Init(xmlReader, events, encodingStyle, this);
				if (methods[mapping.Key].readMethod == null)
				{
					if (readerMethods == null)
					{
						readerMethods = Contract.ReadMethods;
					}
					string text = (string)readerMethods[mapping.Key];
					if (text == null)
					{
						throw new InvalidOperationException(Res.GetString("XmlNotSerializable", mapping.Accessor.Name));
					}
					methods[mapping.Key].readMethod = GetMethodFromType(xmlSerializationReader.GetType(), text, pregeneratedAssmbly ? assembly : null);
				}
				return methods[mapping.Key].readMethod.Invoke(xmlSerializationReader, emptyObjectArray);
			}
			catch (SecurityException innerException)
			{
				throw new InvalidOperationException(Res.GetString("XmlNoPartialTrust"), innerException);
			}
			finally
			{
				xmlSerializationReader?.Dispose();
			}
		}

		internal void InvokeWriter(XmlMapping mapping, XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces, string encodingStyle, string id)
		{
			XmlSerializationWriter xmlSerializationWriter = null;
			try
			{
				encodingStyle = ValidateEncodingStyle(encodingStyle, mapping.Key);
				xmlSerializationWriter = Contract.Writer;
				xmlSerializationWriter.Init(xmlWriter, namespaces, encodingStyle, id, this);
				if (methods[mapping.Key].writeMethod == null)
				{
					if (writerMethods == null)
					{
						writerMethods = Contract.WriteMethods;
					}
					string text = (string)writerMethods[mapping.Key];
					if (text == null)
					{
						throw new InvalidOperationException(Res.GetString("XmlNotSerializable", mapping.Accessor.Name));
					}
					methods[mapping.Key].writeMethod = GetMethodFromType(xmlSerializationWriter.GetType(), text, pregeneratedAssmbly ? assembly : null);
				}
				methods[mapping.Key].writeMethod.Invoke(xmlSerializationWriter, new object[1] { o });
			}
			catch (SecurityException innerException)
			{
				throw new InvalidOperationException(Res.GetString("XmlNoPartialTrust"), innerException);
			}
			finally
			{
				xmlSerializationWriter?.Dispose();
			}
		}

		internal Assembly GetReferencedAssembly(string name)
		{
			if (assemblies == null || name == null)
			{
				return null;
			}
			return (Assembly)assemblies[name];
		}
	}
	internal sealed class XmlSerializerCompilerParameters
	{
		private bool needTempDirAccess;

		private CompilerParameters parameters;

		internal bool IsNeedTempDirAccess => needTempDirAccess;

		internal CompilerParameters CodeDomParameters => parameters;

		private XmlSerializerCompilerParameters(CompilerParameters parameters, bool needTempDirAccess)
		{
			this.needTempDirAccess = needTempDirAccess;
			this.parameters = parameters;
		}

		internal static XmlSerializerCompilerParameters Create(string location)
		{
			CompilerParameters compilerParameters = new CompilerParameters();
			compilerParameters.GenerateInMemory = true;
			if (string.IsNullOrEmpty(location))
			{
				location = ((!(ConfigurationManager.GetSection(ConfigurationStrings.XmlSerializerSectionPath) is XmlSerializerSection xmlSerializerSection)) ? location : xmlSerializerSection.TempFilesLocation);
				if (!string.IsNullOrEmpty(location))
				{
					location = location.Trim();
				}
			}
			compilerParameters.TempFiles = new TempFileCollection(location);
			return new XmlSerializerCompilerParameters(compilerParameters, string.IsNullOrEmpty(location));
		}

		internal static XmlSerializerCompilerParameters Create(CompilerParameters parameters, bool needTempDirAccess)
		{
			return new XmlSerializerCompilerParameters(parameters, needTempDirAccess);
		}
	}
	internal class TempAssemblyCacheKey
	{
		private string ns;

		private object type;

		internal TempAssemblyCacheKey(string ns, object type)
		{
			this.type = type;
			this.ns = ns;
		}

		public override bool Equals(object o)
		{
			if (!(o is TempAssemblyCacheKey tempAssemblyCacheKey))
			{
				return false;
			}
			if (tempAssemblyCacheKey.type == type)
			{
				return tempAssemblyCacheKey.ns == ns;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((ns != null) ? ns.GetHashCode() : 0) ^ ((type != null) ? type.GetHashCode() : 0);
		}
	}
	internal class TempAssemblyCache
	{
		private Hashtable cache = new Hashtable();

		internal TempAssembly this[string ns, object o] => (TempAssembly)cache[new TempAssemblyCacheKey(ns, o)];

		internal void Add(string ns, object o, TempAssembly assembly)
		{
			TempAssemblyCacheKey key = new TempAssemblyCacheKey(ns, o);
			lock (this)
			{
				if (cache[key] == assembly)
				{
					return;
				}
				Hashtable hashtable = new Hashtable();
				foreach (object key2 in cache.Keys)
				{
					hashtable.Add(key2, cache[key2]);
				}
				cache = hashtable;
				cache[key] = assembly;
			}
		}
	}
	internal class Compiler
	{
		private bool debugEnabled = DiagnosticsSwitches.KeepTempFiles.Enabled;

		private Hashtable imports = new Hashtable();

		private StringWriter writer = new StringWriter(CultureInfo.InvariantCulture);

		protected string[] Imports
		{
			get
			{
				string[] array = new string[imports.Values.Count];
				imports.Values.CopyTo(array, 0);
				return array;
			}
		}

		internal TextWriter Source => writer;

		internal void AddImport(Type type, Hashtable types)
		{
			if (type == null || TypeScope.IsKnownType(type) || types[type] != null)
			{
				return;
			}
			types[type] = type;
			Type baseType = type.BaseType;
			if (baseType != null)
			{
				AddImport(baseType, types);
			}
			Type declaringType = type.DeclaringType;
			if (declaringType != null)
			{
				AddImport(declaringType, types);
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type type2 in interfaces)
			{
				AddImport(type2, types);
			}
			ConstructorInfo[] constructors = type.GetConstructors();
			for (int j = 0; j < constructors.Length; j++)
			{
				ParameterInfo[] parameters = constructors[j].GetParameters();
				for (int k = 0; k < parameters.Length; k++)
				{
					AddImport(parameters[k].ParameterType, types);
				}
			}
			if (type.IsGenericType)
			{
				Type[] genericArguments = type.GetGenericArguments();
				for (int l = 0; l < genericArguments.Length; l++)
				{
					AddImport(genericArguments[l], types);
				}
			}
			TempAssembly.FileIOPermission.Assert();
			Module module = type.Module;
			Assembly assembly = module.Assembly;
			if (DynamicAssemblies.IsTypeDynamic(type))
			{
				DynamicAssemblies.Add(assembly);
			}
			else
			{
				imports[assembly] = assembly.Location;
			}
		}

		internal void AddImport(Assembly assembly)
		{
			TempAssembly.FileIOPermission.Assert();
			imports[assembly] = assembly.Location;
		}

		internal void Close()
		{
		}

		internal static string GetTempAssemblyPath(string baseDir, Assembly assembly, string defaultNamespace)
		{
			if (assembly.Location == null || assembly.Location.Length == 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlPregenAssemblyDynamic", assembly.Location));
			}
			PermissionSet permissionSet = new PermissionSet(PermissionState.None);
			permissionSet.AddPermission(new FileIOPermission(PermissionState.Unrestricted));
			permissionSet.AddPermission(new EnvironmentPermission(PermissionState.Unrestricted));
			permissionSet.Assert();
			try
			{
				if (baseDir != null && baseDir.Length > 0)
				{
					if (!Directory.Exists(baseDir))
					{
						throw new UnauthorizedAccessException(Res.GetString("XmlPregenMissingDirectory", baseDir));
					}
				}
				else
				{
					baseDir = Path.GetTempPath();
					if (!Directory.Exists(baseDir))
					{
						throw new UnauthorizedAccessException(Res.GetString("XmlPregenMissingTempDirectory"));
					}
				}
				baseDir = ((!baseDir.EndsWith("\\", StringComparison.Ordinal)) ? (baseDir + "\\" + GetTempAssemblyName(assembly.GetName(), defaultNamespace)) : (baseDir + GetTempAssemblyName(assembly.GetName(), defaultNamespace)));
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
			return baseDir + ".dll";
		}

		internal static string GetTempAssemblyName(AssemblyName parent, string ns)
		{
			return parent.Name + ".XmlSerializers" + ((ns == null || ns.Length == 0) ? "" : ("." + ns.GetHashCode()));
		}

		internal Assembly Compile(Assembly parent, string ns, XmlSerializerCompilerParameters xmlParameters, Evidence evidence)
		{
			CodeDomProvider codeDomProvider = new CSharpCodeProvider();
			CompilerParameters codeDomParameters = xmlParameters.CodeDomParameters;
			codeDomParameters.ReferencedAssemblies.AddRange(Imports);
			if (debugEnabled)
			{
				codeDomParameters.GenerateInMemory = false;
				codeDomParameters.IncludeDebugInformation = true;
				codeDomParameters.TempFiles.KeepFiles = true;
			}
			PermissionSet permissionSet = new PermissionSet(PermissionState.None);
			if (xmlParameters.IsNeedTempDirAccess)
			{
				permissionSet.AddPermission(TempAssembly.FileIOPermission);
			}
			permissionSet.AddPermission(new EnvironmentPermission(PermissionState.Unrestricted));
			permissionSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode));
			permissionSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.ControlEvidence));
			permissionSet.Assert();
			if (parent != null && (codeDomParameters.OutputAssembly == null || codeDomParameters.OutputAssembly.Length == 0))
			{
				string text = AssemblyNameFromOptions(codeDomParameters.CompilerOptions);
				if (text == null)
				{
					text = GetTempAssemblyPath(codeDomParameters.TempFiles.TempDir, parent, ns);
				}
				codeDomParameters.OutputAssembly = text;
			}
			if (codeDomParameters.CompilerOptions == null || codeDomParameters.CompilerOptions.Length == 0)
			{
				codeDomParameters.CompilerOptions = "/nostdlib";
			}
			else
			{
				codeDomParameters.CompilerOptions += " /nostdlib";
			}
			codeDomParameters.CompilerOptions += " /D:_DYNAMIC_XMLSERIALIZER_COMPILATION";
			codeDomParameters.Evidence = evidence;
			CompilerResults compilerResults = null;
			Assembly assembly = null;
			try
			{
				compilerResults = codeDomProvider.CompileAssemblyFromSource(codeDomParameters, writer.ToString());
				if (compilerResults.Errors.Count > 0)
				{
					StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
					stringWriter.WriteLine(Res.GetString("XmlCompilerError", compilerResults.NativeCompilerReturnValue.ToString(CultureInfo.InvariantCulture)));
					bool flag = false;
					foreach (CompilerError error in compilerResults.Errors)
					{
						error.FileName = "";
						if (!error.IsWarning || error.ErrorNumber == "CS1595")
						{
							flag = true;
							stringWriter.WriteLine(error.ToString());
						}
					}
					if (flag)
					{
						throw new InvalidOperationException(stringWriter.ToString());
					}
				}
				assembly = compilerResults.CompiledAssembly;
			}
			catch (UnauthorizedAccessException)
			{
				string currentUser = GetCurrentUser();
				if (currentUser == null || currentUser.Length == 0)
				{
					throw new UnauthorizedAccessException(Res.GetString("XmlSerializerAccessDenied"));
				}
				throw new UnauthorizedAccessException(Res.GetString("XmlIdentityAccessDenied", currentUser));
			}
			catch (FileLoadException innerException)
			{
				throw new InvalidOperationException(Res.GetString("XmlSerializerCompileFailed"), innerException);
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
			if (assembly == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlInternalError"));
			}
			return assembly;
		}

		private static string AssemblyNameFromOptions(string options)
		{
			if (options == null || options.Length == 0)
			{
				return null;
			}
			string result = null;
			string[] array = options.ToLower(CultureInfo.InvariantCulture).Split(null);
			for (int i = 0; i < array.Length; i++)
			{
				string text = array[i].Trim();
				if (text.StartsWith("/out:", StringComparison.Ordinal))
				{
					result = text.Substring(5);
				}
			}
			return result;
		}

		internal static string GetCurrentUser()
		{
			try
			{
				WindowsIdentity current = WindowsIdentity.GetCurrent();
				if (current != null && current.Name != null)
				{
					return current.Name;
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
			}
			catch
			{
			}
			return "";
		}
	}
	public class ImportContext
	{
		private bool shareTypes;

		private SchemaObjectCache cache;

		private Hashtable mappings;

		private Hashtable elements;

		private CodeIdentifiers typeIdentifiers;

		internal SchemaObjectCache Cache
		{
			get
			{
				if (cache == null)
				{
					cache = new SchemaObjectCache();
				}
				return cache;
			}
		}

		internal Hashtable Elements
		{
			get
			{
				if (elements == null)
				{
					elements = new Hashtable();
				}
				return elements;
			}
		}

		internal Hashtable Mappings
		{
			get
			{
				if (mappings == null)
				{
					mappings = new Hashtable();
				}
				return mappings;
			}
		}

		public CodeIdentifiers TypeIdentifiers
		{
			get
			{
				if (typeIdentifiers == null)
				{
					typeIdentifiers = new CodeIdentifiers();
				}
				return typeIdentifiers;
			}
		}

		public bool ShareTypes => shareTypes;

		public StringCollection Warnings => Cache.Warnings;

		public ImportContext(CodeIdentifiers identifiers, bool shareTypes)
		{
			typeIdentifiers = identifiers;
			this.shareTypes = shareTypes;
		}

		internal ImportContext()
			: this(null, shareTypes: false)
		{
		}
	}
	internal class SchemaObjectCache
	{
		private Hashtable graph;

		private Hashtable hash;

		private Hashtable objectCache;

		private StringCollection warnings;

		internal Hashtable looks = new Hashtable();

		private Hashtable Graph
		{
			get
			{
				if (graph == null)
				{
					graph = new Hashtable();
				}
				return graph;
			}
		}

		private Hashtable Hash
		{
			get
			{
				if (hash == null)
				{
					hash = new Hashtable();
				}
				return hash;
			}
		}

		private Hashtable ObjectCache
		{
			get
			{
				if (objectCache == null)
				{
					objectCache = new Hashtable();
				}
				return objectCache;
			}
		}

		internal StringCollection Warnings
		{
			get
			{
				if (warnings == null)
				{
					warnings = new StringCollection();
				}
				return warnings;
			}
		}

		internal XmlSchemaObject AddItem(XmlSchemaObject item, XmlQualifiedName qname, XmlSchemas schemas)
		{
			if (item == null)
			{
				return null;
			}
			if (qname == null || qname.IsEmpty)
			{
				return null;
			}
			string key = item.GetType().Name + ":" + qname.ToString();
			ArrayList arrayList = (ArrayList)ObjectCache[key];
			if (arrayList == null)
			{
				arrayList = new ArrayList();
				ObjectCache[key] = arrayList;
			}
			for (int i = 0; i < arrayList.Count; i++)
			{
				XmlSchemaObject xmlSchemaObject = (XmlSchemaObject)arrayList[i];
				if (xmlSchemaObject == item)
				{
					return xmlSchemaObject;
				}
				if (Match(xmlSchemaObject, item, shareTypes: true))
				{
					return xmlSchemaObject;
				}
				Warnings.Add(Res.GetString("XmlMismatchSchemaObjects", item.GetType().Name, qname.Name, qname.Namespace));
				Warnings.Add("DEBUG:Cached item key:\r\n" + (string)looks[xmlSchemaObject] + "\r\nnew item key:\r\n" + (string)looks[item]);
			}
			arrayList.Add(item);
			return item;
		}

		internal bool Match(XmlSchemaObject o1, XmlSchemaObject o2, bool shareTypes)
		{
			if (o1 == o2)
			{
				return true;
			}
			if (o1.GetType() != o2.GetType())
			{
				return false;
			}
			if (Hash[o1] == null)
			{
				Hash[o1] = GetHash(o1);
			}
			int num = (int)Hash[o1];
			int num2 = GetHash(o2);
			if (num != num2)
			{
				return false;
			}
			if (shareTypes)
			{
				return CompositeHash(o1, num) == CompositeHash(o2, num2);
			}
			return true;
		}

		private ArrayList GetDependencies(XmlSchemaObject o, ArrayList deps, Hashtable refs)
		{
			if (refs[o] == null)
			{
				refs[o] = o;
				deps.Add(o);
				if (Graph[o] is ArrayList arrayList)
				{
					for (int i = 0; i < arrayList.Count; i++)
					{
						GetDependencies((XmlSchemaObject)arrayList[i], deps, refs);
					}
				}
			}
			return deps;
		}

		private int CompositeHash(XmlSchemaObject o, int hash)
		{
			ArrayList dependencies = GetDependencies(o, new ArrayList(), new Hashtable());
			double num = 0.0;
			for (int i = 0; i < dependencies.Count; i++)
			{
				object obj = Hash[dependencies[i]];
				if (obj is int)
				{
					num += (double)((int)obj / dependencies.Count);
				}
			}
			return (int)num;
		}

		internal void GenerateSchemaGraph(XmlSchemas schemas)
		{
			SchemaGraph schemaGraph = new SchemaGraph(Graph, schemas);
			ArrayList items = schemaGraph.GetItems();
			for (int i = 0; i < items.Count; i++)
			{
				GetHash((XmlSchemaObject)items[i]);
			}
		}

		private int GetHash(XmlSchemaObject o)
		{
			object obj = Hash[o];
			if (obj != null && !(obj is XmlSchemaObject))
			{
				return (int)obj;
			}
			string text = ToString(o, new SchemaObjectWriter());
			looks[o] = text;
			int hashCode = text.GetHashCode();
			Hash[o] = hashCode;
			return hashCode;
		}

		private string ToString(XmlSchemaObject o, SchemaObjectWriter writer)
		{
			return writer.WriteXmlSchemaObject(o);
		}
	}
	internal class SchemaGraph
	{
		private ArrayList empty = new ArrayList();

		private XmlSchemas schemas;

		private Hashtable scope;

		private int items;

		internal SchemaGraph(Hashtable scope, XmlSchemas schemas)
		{
			this.scope = scope;
			schemas.Compile(null, fullCompile: false);
			this.schemas = schemas;
			items = 0;
			foreach (XmlSchema schema in schemas)
			{
				items += schema.Items.Count;
				foreach (XmlSchemaObject item in schema.Items)
				{
					Depends(item);
				}
			}
		}

		internal ArrayList GetItems()
		{
			return new ArrayList(scope.Keys);
		}

		internal void AddRef(ArrayList list, XmlSchemaObject o)
		{
			if (o != null && !schemas.IsReference(o) && o.Parent is XmlSchema)
			{
				string targetNamespace = ((XmlSchema)o.Parent).TargetNamespace;
				if (!(targetNamespace == "http://www.w3.org/2001/XMLSchema") && !list.Contains(o))
				{
					list.Add(o);
				}
			}
		}

		internal ArrayList Depends(XmlSchemaObject item)
		{
			if (item.Parent is XmlSchema)
			{
				if (scope[item] != null)
				{
					return (ArrayList)scope[item];
				}
				ArrayList arrayList = new ArrayList();
				Depends(item, arrayList);
				scope.Add(item, arrayList);
				return arrayList;
			}
			return empty;
		}

		internal void Depends(XmlSchemaObject item, ArrayList refs)
		{
			if (item == null || scope[item] != null)
			{
				return;
			}
			Type type = item.GetType();
			if (typeof(XmlSchemaType).IsAssignableFrom(type))
			{
				XmlQualifiedName xmlQualifiedName = XmlQualifiedName.Empty;
				XmlSchemaType xmlSchemaType = null;
				XmlSchemaParticle xmlSchemaParticle = null;
				XmlSchemaObjectCollection xmlSchemaObjectCollection = null;
				if (item is XmlSchemaComplexType)
				{
					XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)item;
					if (xmlSchemaComplexType.ContentModel != null)
					{
						XmlSchemaContent content = xmlSchemaComplexType.ContentModel.Content;
						if (content is XmlSchemaComplexContentRestriction)
						{
							xmlQualifiedName = ((XmlSchemaComplexContentRestriction)content).BaseTypeName;
							xmlSchemaObjectCollection = ((XmlSchemaComplexContentRestriction)content).Attributes;
						}
						else if (content is XmlSchemaSimpleContentRestriction)
						{
							XmlSchemaSimpleContentRestriction xmlSchemaSimpleContentRestriction = (XmlSchemaSimpleContentRestriction)content;
							if (xmlSchemaSimpleContentRestriction.BaseType != null)
							{
								xmlSchemaType = xmlSchemaSimpleContentRestriction.BaseType;
							}
							else
							{
								xmlQualifiedName = xmlSchemaSimpleContentRestriction.BaseTypeName;
							}
							xmlSchemaObjectCollection = xmlSchemaSimpleContentRestriction.Attributes;
						}
						else if (content is XmlSchemaComplexContentExtension)
						{
							XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension = (XmlSchemaComplexContentExtension)content;
							xmlSchemaObjectCollection = xmlSchemaComplexContentExtension.Attributes;
							xmlSchemaParticle = xmlSchemaComplexContentExtension.Particle;
							xmlQualifiedName = xmlSchemaComplexContentExtension.BaseTypeName;
						}
						else if (content is XmlSchemaSimpleContentExtension)
						{
							XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = (XmlSchemaSimpleContentExtension)content;
							xmlSchemaObjectCollection = xmlSchemaSimpleContentExtension.Attributes;
							xmlQualifiedName = xmlSchemaSimpleContentExtension.BaseTypeName;
						}
					}
					else
					{
						xmlSchemaObjectCollection = xmlSchemaComplexType.Attributes;
						xmlSchemaParticle = xmlSchemaComplexType.Particle;
					}
					if (xmlSchemaParticle is XmlSchemaGroupRef)
					{
						XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef)xmlSchemaParticle;
						xmlSchemaParticle = ((XmlSchemaGroup)schemas.Find(xmlSchemaGroupRef.RefName, typeof(XmlSchemaGroup), checkCache: false)).Particle;
					}
					else if (xmlSchemaParticle is XmlSchemaGroupBase)
					{
						xmlSchemaParticle = (XmlSchemaGroupBase)xmlSchemaParticle;
					}
				}
				else if (item is XmlSchemaSimpleType)
				{
					XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)item;
					XmlSchemaSimpleTypeContent content2 = xmlSchemaSimpleType.Content;
					if (content2 is XmlSchemaSimpleTypeRestriction)
					{
						xmlSchemaType = ((XmlSchemaSimpleTypeRestriction)content2).BaseType;
						xmlQualifiedName = ((XmlSchemaSimpleTypeRestriction)content2).BaseTypeName;
					}
					else if (content2 is XmlSchemaSimpleTypeList)
					{
						XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = (XmlSchemaSimpleTypeList)content2;
						if (xmlSchemaSimpleTypeList.ItemTypeName != null && !xmlSchemaSimpleTypeList.ItemTypeName.IsEmpty)
						{
							xmlQualifiedName = xmlSchemaSimpleTypeList.ItemTypeName;
						}
						if (xmlSchemaSimpleTypeList.ItemType != null)
						{
							xmlSchemaType = xmlSchemaSimpleTypeList.ItemType;
						}
					}
					else if (content2 is XmlSchemaSimpleTypeRestriction)
					{
						xmlQualifiedName = ((XmlSchemaSimpleTypeRestriction)content2).BaseTypeName;
					}
					else if (type == typeof(XmlSchemaSimpleTypeUnion))
					{
						XmlQualifiedName[] memberTypes = ((XmlSchemaSimpleTypeUnion)item).MemberTypes;
						if (memberTypes != null)
						{
							for (int i = 0; i < memberTypes.Length; i++)
							{
								XmlSchemaType o = (XmlSchemaType)schemas.Find(memberTypes[i], typeof(XmlSchemaType), checkCache: false);
								AddRef(refs, o);
							}
						}
					}
				}
				if (xmlSchemaType == null && !xmlQualifiedName.IsEmpty && xmlQualifiedName.Namespace != "http://www.w3.org/2001/XMLSchema")
				{
					xmlSchemaType = (XmlSchemaType)schemas.Find(xmlQualifiedName, typeof(XmlSchemaType), checkCache: false);
				}
				if (xmlSchemaType != null)
				{
					AddRef(refs, xmlSchemaType);
				}
				if (xmlSchemaParticle != null)
				{
					Depends(xmlSchemaParticle, refs);
				}
				if (xmlSchemaObjectCollection != null)
				{
					for (int j = 0; j < xmlSchemaObjectCollection.Count; j++)
					{
						Depends(xmlSchemaObjectCollection[j], refs);
					}
				}
			}
			else if (type == typeof(XmlSchemaElement))
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)item;
				if (!xmlSchemaElement.SubstitutionGroup.IsEmpty && xmlSchemaElement.SubstitutionGroup.Namespace != "http://www.w3.org/2001/XMLSchema")
				{
					XmlSchemaElement o2 = (XmlSchemaElement)schemas.Find(xmlSchemaElement.SubstitutionGroup, typeof(XmlSchemaElement), checkCache: false);
					AddRef(refs, o2);
				}
				if (!xmlSchemaElement.RefName.IsEmpty)
				{
					xmlSchemaElement = (XmlSchemaElement)schemas.Find(xmlSchemaElement.RefName, typeof(XmlSchemaElement), checkCache: false);
					AddRef(refs, xmlSchemaElement);
				}
				else if (!xmlSchemaElement.SchemaTypeName.IsEmpty)
				{
					XmlSchemaType o3 = (XmlSchemaType)schemas.Find(xmlSchemaElement.SchemaTypeName, typeof(XmlSchemaType), checkCache: false);
					AddRef(refs, o3);
				}
				else
				{
					Depends(xmlSchemaElement.SchemaType, refs);
				}
			}
			else if (type == typeof(XmlSchemaGroup))
			{
				Depends(((XmlSchemaGroup)item).Particle);
			}
			else if (type == typeof(XmlSchemaGroupRef))
			{
				XmlSchemaGroup o4 = (XmlSchemaGroup)schemas.Find(((XmlSchemaGroupRef)item).RefName, typeof(XmlSchemaGroup), checkCache: false);
				AddRef(refs, o4);
			}
			else if (typeof(XmlSchemaGroupBase).IsAssignableFrom(type))
			{
				foreach (XmlSchemaObject item2 in ((XmlSchemaGroupBase)item).Items)
				{
					Depends(item2, refs);
				}
			}
			else if (type == typeof(XmlSchemaAttributeGroupRef))
			{
				XmlSchemaAttributeGroup o5 = (XmlSchemaAttributeGroup)schemas.Find(((XmlSchemaAttributeGroupRef)item).RefName, typeof(XmlSchemaAttributeGroup), checkCache: false);
				AddRef(refs, o5);
			}
			else if (type == typeof(XmlSchemaAttributeGroup))
			{
				foreach (XmlSchemaObject attribute in ((XmlSchemaAttributeGroup)item).Attributes)
				{
					Depends(attribute, refs);
				}
			}
			else if (type == typeof(XmlSchemaAttribute))
			{
				XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)item;
				if (!xmlSchemaAttribute.RefName.IsEmpty)
				{
					xmlSchemaAttribute = (XmlSchemaAttribute)schemas.Find(xmlSchemaAttribute.RefName, typeof(XmlSchemaAttribute), checkCache: false);
					AddRef(refs, xmlSchemaAttribute);
				}
				else if (!xmlSchemaAttribute.SchemaTypeName.IsEmpty)
				{
					XmlSchemaType o6 = (XmlSchemaType)schemas.Find(xmlSchemaAttribute.SchemaTypeName, typeof(XmlSchemaType), checkCache: false);
					AddRef(refs, o6);
				}
				else
				{
					Depends(xmlSchemaAttribute.SchemaType, refs);
				}
			}
			if (!typeof(XmlSchemaAnnotated).IsAssignableFrom(type))
			{
				return;
			}
			XmlAttribute[] unhandledAttributes = ((XmlSchemaAnnotated)item).UnhandledAttributes;
			if (unhandledAttributes == null)
			{
				return;
			}
			foreach (XmlAttribute xmlAttribute in unhandledAttributes)
			{
				if (xmlAttribute.LocalName == "arrayType" && xmlAttribute.NamespaceURI == "http://schemas.xmlsoap.org/wsdl/")
				{
					string dims;
					XmlQualifiedName name = TypeScope.ParseWsdlArrayType(xmlAttribute.Value, out dims, item);
					XmlSchemaType o7 = (XmlSchemaType)schemas.Find(name, typeof(XmlSchemaType), checkCache: false);
					AddRef(refs, o7);
				}
			}
		}
	}
	internal class IndentedWriter
	{
		private TextWriter writer;

		private bool needIndent;

		private int indentLevel;

		private bool compact;

		internal int Indent
		{
			get
			{
				return indentLevel;
			}
			set
			{
				indentLevel = value;
			}
		}

		internal IndentedWriter(TextWriter writer, bool compact)
		{
			this.writer = writer;
			this.compact = compact;
		}

		internal void Write(string s)
		{
			if (needIndent)
			{
				WriteIndent();
			}
			writer.Write(s);
		}

		internal void Write(char c)
		{
			if (needIndent)
			{
				WriteIndent();
			}
			writer.Write(c);
		}

		internal void WriteLine(string s)
		{
			if (needIndent)
			{
				WriteIndent();
			}
			writer.WriteLine(s);
			needIndent = true;
		}

		internal void WriteLine()
		{
			writer.WriteLine();
			needIndent = true;
		}

		internal void WriteIndent()
		{
			needIndent = false;
			if (!compact)
			{
				for (int i = 0; i < indentLevel; i++)
				{
					writer.Write("    ");
				}
			}
		}
	}
	public interface IXmlSerializable
	{
		XmlSchema GetSchema();

		void ReadXml(XmlReader reader);

		void WriteXml(XmlWriter writer);
	}
	public interface IXmlTextParser
	{
		bool Normalized { get; set; }

		WhitespaceHandling WhitespaceHandling { get; set; }
	}
	internal abstract class Accessor
	{
		private string name;

		private object defaultValue;

		private string ns;

		private TypeMapping mapping;

		private bool any;

		private string anyNs;

		private bool topLevelInSchema;

		private bool isFixed;

		private bool isOptional;

		private XmlSchemaForm form;

		internal TypeMapping Mapping
		{
			get
			{
				return mapping;
			}
			set
			{
				mapping = value;
			}
		}

		internal object Default
		{
			get
			{
				return defaultValue;
			}
			set
			{
				defaultValue = value;
			}
		}

		internal bool HasDefault
		{
			get
			{
				if (defaultValue != null)
				{
					return defaultValue != DBNull.Value;
				}
				return false;
			}
		}

		internal virtual string Name
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		internal bool Any
		{
			get
			{
				return any;
			}
			set
			{
				any = value;
			}
		}

		internal string AnyNamespaces
		{
			get
			{
				return anyNs;
			}
			set
			{
				anyNs = value;
			}
		}

		internal string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		internal XmlSchemaForm Form
		{
			get
			{
				return form;
			}
			set
			{
				form = value;
			}
		}

		internal bool IsFixed
		{
			get
			{
				return isFixed;
			}
			set
			{
				isFixed = value;
			}
		}

		internal bool IsOptional
		{
			get
			{
				return isOptional;
			}
			set
			{
				isOptional = value;
			}
		}

		internal bool IsTopLevelInSchema
		{
			get
			{
				return topLevelInSchema;
			}
			set
			{
				topLevelInSchema = value;
			}
		}

		internal Accessor()
		{
		}

		internal static string EscapeName(string name)
		{
			if (name == null || name.Length == 0)
			{
				return name;
			}
			return XmlConvert.EncodeLocalName(name);
		}

		internal static string EscapeQName(string name)
		{
			if (name == null || name.Length == 0)
			{
				return name;
			}
			int num = name.LastIndexOf(':');
			if (num < 0)
			{
				return XmlConvert.EncodeLocalName(name);
			}
			if (num == 0 || num == name.Length - 1)
			{
				throw new ArgumentException(Res.GetString("Xml_InvalidNameChars", name), "name");
			}
			return new XmlQualifiedName(XmlConvert.EncodeLocalName(name.Substring(num + 1)), XmlConvert.EncodeLocalName(name.Substring(0, num))).ToString();
		}

		internal static string UnescapeName(string name)
		{
			return XmlConvert.DecodeName(name);
		}

		internal string ToString(string defaultNs)
		{
			if (Any)
			{
				return ((Namespace == null) ? "##any" : Namespace) + ":" + Name;
			}
			if (!(Namespace == defaultNs))
			{
				return Namespace + ":" + Name;
			}
			return Name;
		}
	}
	internal class ElementAccessor : Accessor
	{
		private bool nullable;

		private bool isSoap;

		private bool unbounded;

		internal bool IsSoap
		{
			get
			{
				return isSoap;
			}
			set
			{
				isSoap = value;
			}
		}

		internal bool IsNullable
		{
			get
			{
				return nullable;
			}
			set
			{
				nullable = value;
			}
		}

		internal bool IsUnbounded
		{
			get
			{
				return unbounded;
			}
			set
			{
				unbounded = value;
			}
		}

		internal ElementAccessor Clone()
		{
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.nullable = nullable;
			elementAccessor.IsTopLevelInSchema = base.IsTopLevelInSchema;
			elementAccessor.Form = base.Form;
			elementAccessor.isSoap = isSoap;
			elementAccessor.Name = Name;
			elementAccessor.Default = base.Default;
			elementAccessor.Namespace = base.Namespace;
			elementAccessor.Mapping = base.Mapping;
			elementAccessor.Any = base.Any;
			return elementAccessor;
		}
	}
	internal class ChoiceIdentifierAccessor : Accessor
	{
		private string memberName;

		private string[] memberIds;

		internal string MemberName
		{
			get
			{
				return memberName;
			}
			set
			{
				memberName = value;
			}
		}

		internal string[] MemberIds
		{
			get
			{
				return memberIds;
			}
			set
			{
				memberIds = value;
			}
		}
	}
	internal class TextAccessor : Accessor
	{
	}
	internal class XmlnsAccessor : Accessor
	{
	}
	internal class AttributeAccessor : Accessor
	{
		private bool isSpecial;

		private bool isList;

		internal bool IsSpecialXmlNamespace => isSpecial;

		internal bool IsList
		{
			get
			{
				return isList;
			}
			set
			{
				isList = value;
			}
		}

		internal void CheckSpecial()
		{
			int num = Name.LastIndexOf(':');
			if (num >= 0)
			{
				if (!Name.StartsWith("xml:", StringComparison.Ordinal))
				{
					throw new InvalidOperationException(Res.GetString("Xml_InvalidNameChars", Name));
				}
				Name = Name.Substring("xml:".Length);
				base.Namespace = "http://www.w3.org/XML/1998/namespace";
				isSpecial = true;
			}
			else if (base.Namespace == "http://www.w3.org/XML/1998/namespace")
			{
				isSpecial = true;
			}
			else
			{
				isSpecial = false;
			}
			if (isSpecial)
			{
				base.Form = XmlSchemaForm.Qualified;
			}
		}
	}
	internal abstract class Mapping
	{
		private bool isSoap;

		internal bool IsSoap
		{
			get
			{
				return isSoap;
			}
			set
			{
				isSoap = value;
			}
		}

		internal Mapping()
		{
		}
	}
	internal abstract class TypeMapping : Mapping
	{
		private TypeDesc typeDesc;

		private string typeNs;

		private string typeName;

		private bool referencedByElement;

		private bool referencedByTopLevelElement;

		private bool includeInSchema = true;

		private bool reference;

		internal bool ReferencedByTopLevelElement
		{
			get
			{
				return referencedByTopLevelElement;
			}
			set
			{
				referencedByTopLevelElement = value;
			}
		}

		internal bool ReferencedByElement
		{
			get
			{
				if (!referencedByElement)
				{
					return referencedByTopLevelElement;
				}
				return true;
			}
			set
			{
				referencedByElement = value;
			}
		}

		internal string Namespace
		{
			get
			{
				return typeNs;
			}
			set
			{
				typeNs = value;
			}
		}

		internal string TypeName
		{
			get
			{
				return typeName;
			}
			set
			{
				typeName = value;
			}
		}

		internal TypeDesc TypeDesc
		{
			get
			{
				return typeDesc;
			}
			set
			{
				typeDesc = value;
			}
		}

		internal bool IncludeInSchema
		{
			get
			{
				return includeInSchema;
			}
			set
			{
				includeInSchema = value;
			}
		}

		internal virtual bool IsList
		{
			get
			{
				return false;
			}
			set
			{
			}
		}

		internal bool IsReference
		{
			get
			{
				return reference;
			}
			set
			{
				reference = value;
			}
		}

		internal bool IsAnonymousType
		{
			get
			{
				if (typeName != null)
				{
					return typeName.Length == 0;
				}
				return true;
			}
		}

		internal virtual string DefaultElementName
		{
			get
			{
				if (!IsAnonymousType)
				{
					return typeName;
				}
				return XmlConvert.EncodeLocalName(typeDesc.Name);
			}
		}
	}
	internal class PrimitiveMapping : TypeMapping
	{
		private bool isList;

		internal override bool IsList
		{
			get
			{
				return isList;
			}
			set
			{
				isList = value;
			}
		}
	}
	internal class NullableMapping : TypeMapping
	{
		private TypeMapping baseMapping;

		internal TypeMapping BaseMapping
		{
			get
			{
				return baseMapping;
			}
			set
			{
				baseMapping = value;
			}
		}

		internal override string DefaultElementName => BaseMapping.DefaultElementName;
	}
	internal class ArrayMapping : TypeMapping
	{
		private ElementAccessor[] elements;

		private ElementAccessor[] sortedElements;

		private ArrayMapping next;

		private StructMapping topLevelMapping;

		internal ElementAccessor[] Elements
		{
			get
			{
				return elements;
			}
			set
			{
				elements = value;
				sortedElements = null;
			}
		}

		internal ElementAccessor[] ElementsSortedByDerivation
		{
			get
			{
				if (sortedElements != null)
				{
					return sortedElements;
				}
				if (elements == null)
				{
					return null;
				}
				sortedElements = new ElementAccessor[elements.Length];
				Array.Copy(elements, 0, sortedElements, 0, elements.Length);
				AccessorMapping.SortMostToLeastDerived(sortedElements);
				return sortedElements;
			}
		}

		internal ArrayMapping Next
		{
			get
			{
				return next;
			}
			set
			{
				next = value;
			}
		}

		internal StructMapping TopLevelMapping
		{
			get
			{
				return topLevelMapping;
			}
			set
			{
				topLevelMapping = value;
			}
		}
	}
	internal class EnumMapping : PrimitiveMapping
	{
		private ConstantMapping[] constants;

		private bool isFlags;

		internal bool IsFlags
		{
			get
			{
				return isFlags;
			}
			set
			{
				isFlags = value;
			}
		}

		internal ConstantMapping[] Constants
		{
			get
			{
				return constants;
			}
			set
			{
				constants = value;
			}
		}
	}
	internal class ConstantMapping : Mapping
	{
		private string xmlName;

		private string name;

		private long value;

		internal string XmlName
		{
			get
			{
				if (xmlName != null)
				{
					return xmlName;
				}
				return string.Empty;
			}
			set
			{
				xmlName = value;
			}
		}

		internal string Name
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		internal long Value
		{
			get
			{
				return value;
			}
			set
			{
				this.value = value;
			}
		}
	}
	internal interface INameScope
	{
		object this[string name, string ns] { get; set; }
	}
	internal class StructMapping : TypeMapping, INameScope
	{
		private MemberMapping[] members;

		private StructMapping baseMapping;

		private StructMapping derivedMappings;

		private StructMapping nextDerivedMapping;

		private MemberMapping xmlnsMember;

		private bool hasSimpleContent;

		private bool openModel;

		private bool isSequence;

		private NameTable elements;

		private NameTable attributes;

		private CodeIdentifiers scope;

		internal StructMapping BaseMapping
		{
			get
			{
				return baseMapping;
			}
			set
			{
				baseMapping = value;
				if (!base.IsAnonymousType && baseMapping != null)
				{
					nextDerivedMapping = baseMapping.derivedMappings;
					baseMapping.derivedMappings = this;
				}
				if (!value.isSequence || isSequence)
				{
					return;
				}
				isSequence = true;
				if (baseMapping.IsSequence)
				{
					for (StructMapping structMapping = derivedMappings; structMapping != null; structMapping = structMapping.NextDerivedMapping)
					{
						structMapping.SetSequence();
					}
				}
			}
		}

		internal StructMapping DerivedMappings => derivedMappings;

		internal bool IsFullyInitialized
		{
			get
			{
				if (baseMapping != null)
				{
					return Members != null;
				}
				return false;
			}
		}

		internal NameTable LocalElements
		{
			get
			{
				if (elements == null)
				{
					elements = new NameTable();
				}
				return elements;
			}
		}

		internal NameTable LocalAttributes
		{
			get
			{
				if (attributes == null)
				{
					attributes = new NameTable();
				}
				return attributes;
			}
		}

		object INameScope.this[string name, string ns]
		{
			get
			{
				object obj = LocalElements[name, ns];
				if (obj != null)
				{
					return obj;
				}
				if (baseMapping != null)
				{
					return ((INameScope)baseMapping)[name, ns];
				}
				return null;
			}
			set
			{
				LocalElements[name, ns] = value;
			}
		}

		internal StructMapping NextDerivedMapping => nextDerivedMapping;

		internal bool HasSimpleContent => hasSimpleContent;

		internal bool HasXmlnsMember
		{
			get
			{
				for (StructMapping structMapping = this; structMapping != null; structMapping = structMapping.BaseMapping)
				{
					if (structMapping.XmlnsMember != null)
					{
						return true;
					}
				}
				return false;
			}
		}

		internal MemberMapping[] Members
		{
			get
			{
				return members;
			}
			set
			{
				members = value;
			}
		}

		internal MemberMapping XmlnsMember
		{
			get
			{
				return xmlnsMember;
			}
			set
			{
				xmlnsMember = value;
			}
		}

		internal bool IsOpenModel
		{
			get
			{
				return openModel;
			}
			set
			{
				openModel = value;
			}
		}

		internal CodeIdentifiers Scope
		{
			get
			{
				if (scope == null)
				{
					scope = new CodeIdentifiers();
				}
				return scope;
			}
			set
			{
				scope = value;
			}
		}

		internal bool HasElements
		{
			get
			{
				if (elements != null)
				{
					return elements.Values.Count > 0;
				}
				return false;
			}
		}

		internal bool IsSequence
		{
			get
			{
				if (isSequence)
				{
					return !base.TypeDesc.IsRoot;
				}
				return false;
			}
			set
			{
				isSequence = value;
			}
		}

		internal MemberMapping FindDeclaringMapping(MemberMapping member, out StructMapping declaringMapping, string parent)
		{
			declaringMapping = null;
			if (BaseMapping != null)
			{
				MemberMapping memberMapping = BaseMapping.FindDeclaringMapping(member, out declaringMapping, parent);
				if (memberMapping != null)
				{
					return memberMapping;
				}
			}
			if (members == null)
			{
				return null;
			}
			for (int i = 0; i < members.Length; i++)
			{
				if (members[i].Name == member.Name)
				{
					if (members[i].TypeDesc != member.TypeDesc)
					{
						throw new InvalidOperationException(Res.GetString("XmlHiddenMember", parent, member.Name, member.TypeDesc.FullName, base.TypeName, members[i].Name, members[i].TypeDesc.FullName));
					}
					if (!members[i].Match(member))
					{
						throw new InvalidOperationException(Res.GetString("XmlInvalidXmlOverride", parent, member.Name, base.TypeName, members[i].Name));
					}
					declaringMapping = this;
					return members[i];
				}
			}
			return null;
		}

		internal bool Declares(MemberMapping member, string parent)
		{
			StructMapping declaringMapping;
			return FindDeclaringMapping(member, out declaringMapping, parent) != null;
		}

		internal void SetContentModel(TextAccessor text, bool hasElements)
		{
			if (BaseMapping == null || BaseMapping.TypeDesc.IsRoot)
			{
				hasSimpleContent = !hasElements && text != null && !text.Mapping.IsList;
			}
			else if (BaseMapping.HasSimpleContent)
			{
				if (text != null || hasElements)
				{
					throw new InvalidOperationException(Res.GetString("XmlIllegalSimpleContentExtension", base.TypeDesc.FullName, BaseMapping.TypeDesc.FullName));
				}
				hasSimpleContent = true;
			}
			else
			{
				hasSimpleContent = false;
			}
			if (!hasSimpleContent && text != null && !text.Mapping.TypeDesc.CanBeTextValue)
			{
				throw new InvalidOperationException(Res.GetString("XmlIllegalTypedTextAttribute", base.TypeDesc.FullName, text.Name, text.Mapping.TypeDesc.FullName));
			}
		}

		internal bool HasExplicitSequence()
		{
			if (members != null)
			{
				for (int i = 0; i < members.Length; i++)
				{
					if (members[i].IsParticle && members[i].IsSequence)
					{
						return true;
					}
				}
			}
			if (baseMapping != null)
			{
				return baseMapping.HasExplicitSequence();
			}
			return false;
		}

		internal void SetSequence()
		{
			if (!base.TypeDesc.IsRoot)
			{
				StructMapping structMapping = this;
				while (!structMapping.BaseMapping.IsSequence && structMapping.BaseMapping != null && !structMapping.BaseMapping.TypeDesc.IsRoot)
				{
					structMapping = structMapping.BaseMapping;
				}
				structMapping.IsSequence = true;
				for (StructMapping structMapping2 = structMapping.DerivedMappings; structMapping2 != null; structMapping2 = structMapping2.NextDerivedMapping)
				{
					structMapping2.SetSequence();
				}
			}
		}
	}
	internal abstract class AccessorMapping : Mapping
	{
		internal class AccessorComparer : IComparer
		{
			public int Compare(object o1, object o2)
			{
				if (o1 == o2)
				{
					return 0;
				}
				Accessor accessor = (Accessor)o1;
				Accessor accessor2 = (Accessor)o2;
				int weight = accessor.Mapping.TypeDesc.Weight;
				int weight2 = accessor2.Mapping.TypeDesc.Weight;
				if (weight == weight2)
				{
					return 0;
				}
				if (weight < weight2)
				{
					return 1;
				}
				return -1;
			}
		}

		private TypeDesc typeDesc;

		private AttributeAccessor attribute;

		private ElementAccessor[] elements;

		private ElementAccessor[] sortedElements;

		private TextAccessor text;

		private ChoiceIdentifierAccessor choiceIdentifier;

		private XmlnsAccessor xmlns;

		private bool ignore;

		internal bool IsAttribute => attribute != null;

		internal bool IsText
		{
			get
			{
				if (text != null)
				{
					if (elements != null)
					{
						return elements.Length == 0;
					}
					return true;
				}
				return false;
			}
		}

		internal bool IsParticle
		{
			get
			{
				if (elements != null)
				{
					return elements.Length > 0;
				}
				return false;
			}
		}

		internal TypeDesc TypeDesc
		{
			get
			{
				return typeDesc;
			}
			set
			{
				typeDesc = value;
			}
		}

		internal AttributeAccessor Attribute
		{
			get
			{
				return attribute;
			}
			set
			{
				attribute = value;
			}
		}

		internal ElementAccessor[] Elements
		{
			get
			{
				return elements;
			}
			set
			{
				elements = value;
				sortedElements = null;
			}
		}

		internal ElementAccessor[] ElementsSortedByDerivation
		{
			get
			{
				if (sortedElements != null)
				{
					return sortedElements;
				}
				if (elements == null)
				{
					return null;
				}
				sortedElements = new ElementAccessor[elements.Length];
				Array.Copy(elements, 0, sortedElements, 0, elements.Length);
				SortMostToLeastDerived(sortedElements);
				return sortedElements;
			}
		}

		internal TextAccessor Text
		{
			get
			{
				return text;
			}
			set
			{
				text = value;
			}
		}

		internal ChoiceIdentifierAccessor ChoiceIdentifier
		{
			get
			{
				return choiceIdentifier;
			}
			set
			{
				choiceIdentifier = value;
			}
		}

		internal XmlnsAccessor Xmlns
		{
			get
			{
				return xmlns;
			}
			set
			{
				xmlns = value;
			}
		}

		internal bool Ignore
		{
			get
			{
				return ignore;
			}
			set
			{
				ignore = value;
			}
		}

		internal Accessor Accessor
		{
			get
			{
				if (xmlns != null)
				{
					return xmlns;
				}
				if (attribute != null)
				{
					return attribute;
				}
				if (elements != null && elements.Length > 0)
				{
					return elements[0];
				}
				return text;
			}
		}

		internal bool IsNeedNullable
		{
			get
			{
				if (xmlns != null)
				{
					return false;
				}
				if (attribute != null)
				{
					return false;
				}
				if (elements != null && elements.Length == 1)
				{
					return IsNeedNullableMember(elements[0]);
				}
				return false;
			}
		}

		internal static void SortMostToLeastDerived(ElementAccessor[] elements)
		{
			Array.Sort(elements, new AccessorComparer());
		}

		private static bool IsNeedNullableMember(ElementAccessor element)
		{
			if (element.Mapping is ArrayMapping)
			{
				ArrayMapping arrayMapping = (ArrayMapping)element.Mapping;
				if (arrayMapping.Elements != null && arrayMapping.Elements.Length == 1)
				{
					return IsNeedNullableMember(arrayMapping.Elements[0]);
				}
				return false;
			}
			if (element.IsNullable)
			{
				return element.Mapping.TypeDesc.IsValueType;
			}
			return false;
		}

		internal static bool ElementsMatch(ElementAccessor[] a, ElementAccessor[] b)
		{
			if (a == null)
			{
				if (b == null)
				{
					return true;
				}
				return false;
			}
			if (b == null)
			{
				return false;
			}
			if (a.Length != b.Length)
			{
				return false;
			}
			for (int i = 0; i < a.Length; i++)
			{
				if (a[i].Name != b[i].Name || a[i].Namespace != b[i].Namespace || a[i].Form != b[i].Form || a[i].IsNullable != b[i].IsNullable)
				{
					return false;
				}
			}
			return true;
		}

		internal bool Match(AccessorMapping mapping)
		{
			if (Elements != null && Elements.Length > 0)
			{
				if (!ElementsMatch(Elements, mapping.Elements))
				{
					return false;
				}
				if (Text == null)
				{
					return mapping.Text == null;
				}
			}
			if (Attribute != null)
			{
				if (mapping.Attribute == null)
				{
					return false;
				}
				if (Attribute.Name == mapping.Attribute.Name && Attribute.Namespace == mapping.Attribute.Namespace)
				{
					return Attribute.Form == mapping.Attribute.Form;
				}
				return false;
			}
			if (Text != null)
			{
				return mapping.Text != null;
			}
			return mapping.Accessor == null;
		}
	}
	internal class MemberMappingComparer : IComparer
	{
		public int Compare(object o1, object o2)
		{
			MemberMapping memberMapping = (MemberMapping)o1;
			MemberMapping memberMapping2 = (MemberMapping)o2;
			if (memberMapping.IsText)
			{
				if (memberMapping2.IsText)
				{
					return 0;
				}
				return 1;
			}
			if (memberMapping2.IsText)
			{
				return -1;
			}
			if (memberMapping.SequenceId < 0 && memberMapping2.SequenceId < 0)
			{
				return 0;
			}
			if (memberMapping.SequenceId < 0)
			{
				return 1;
			}
			if (memberMapping2.SequenceId < 0)
			{
				return -1;
			}
			if (memberMapping.SequenceId < memberMapping2.SequenceId)
			{
				return -1;
			}
			if (memberMapping.SequenceId > memberMapping2.SequenceId)
			{
				return 1;
			}
			return 0;
		}
	}
	internal class MemberMapping : AccessorMapping
	{
		private string name;

		private bool checkShouldPersist;

		private SpecifiedAccessor checkSpecified;

		private bool isReturnValue;

		private bool readOnly;

		private int sequenceId = -1;

		internal bool CheckShouldPersist
		{
			get
			{
				return checkShouldPersist;
			}
			set
			{
				checkShouldPersist = value;
			}
		}

		internal SpecifiedAccessor CheckSpecified
		{
			get
			{
				return checkSpecified;
			}
			set
			{
				checkSpecified = value;
			}
		}

		internal string Name
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		internal bool IsReturnValue
		{
			get
			{
				return isReturnValue;
			}
			set
			{
				isReturnValue = value;
			}
		}

		internal bool ReadOnly
		{
			get
			{
				return readOnly;
			}
			set
			{
				readOnly = value;
			}
		}

		internal bool IsSequence => sequenceId >= 0;

		internal int SequenceId
		{
			get
			{
				return sequenceId;
			}
			set
			{
				sequenceId = value;
			}
		}

		private string GetNullableType(TypeDesc td)
		{
			if (td.IsMappedType || (!td.IsValueType && (base.Elements[0].IsSoap || td.ArrayElementTypeDesc == null)))
			{
				return td.FullName;
			}
			if (td.ArrayElementTypeDesc != null)
			{
				return GetNullableType(td.ArrayElementTypeDesc) + "[]";
			}
			return "System.Nullable`1[" + td.FullName + "]";
		}

		internal string GetTypeName(CodeDomProvider codeProvider)
		{
			if (base.IsNeedNullable && codeProvider.Supports(GeneratorSupport.GenericTypeReference))
			{
				return GetNullableType(base.TypeDesc);
			}
			return base.TypeDesc.FullName;
		}
	}
	internal class MembersMapping : TypeMapping
	{
		private MemberMapping[] members;

		private bool hasWrapperElement = true;

		private bool validateRpcWrapperElement;

		private bool writeAccessors = true;

		private MemberMapping xmlnsMember;

		internal MemberMapping[] Members
		{
			get
			{
				return members;
			}
			set
			{
				members = value;
			}
		}

		internal MemberMapping XmlnsMember
		{
			get
			{
				return xmlnsMember;
			}
			set
			{
				xmlnsMember = value;
			}
		}

		internal bool HasWrapperElement
		{
			get
			{
				return hasWrapperElement;
			}
			set
			{
				hasWrapperElement = value;
			}
		}

		internal bool ValidateRpcWrapperElement
		{
			get
			{
				return validateRpcWrapperElement;
			}
			set
			{
				validateRpcWrapperElement = value;
			}
		}

		internal bool WriteAccessors
		{
			get
			{
				return writeAccessors;
			}
			set
			{
				writeAccessors = value;
			}
		}
	}
	internal class SpecialMapping : TypeMapping
	{
		private bool namedAny;

		internal bool NamedAny
		{
			get
			{
				return namedAny;
			}
			set
			{
				namedAny = value;
			}
		}
	}
	internal class SerializableMapping : SpecialMapping
	{
		private XmlSchema schema;

		private Type type;

		private bool needSchema = true;

		private MethodInfo getSchemaMethod;

		private XmlQualifiedName xsiType;

		private XmlSchemaType xsdType;

		private XmlSchemaSet schemas;

		private bool any;

		private string namespaces;

		private SerializableMapping baseMapping;

		private SerializableMapping derivedMappings;

		private SerializableMapping nextDerivedMapping;

		private SerializableMapping next;

		internal bool IsAny
		{
			get
			{
				if (any)
				{
					return true;
				}
				if (getSchemaMethod == null)
				{
					return false;
				}
				if (needSchema && typeof(XmlSchemaType).IsAssignableFrom(getSchemaMethod.ReturnType))
				{
					return false;
				}
				RetrieveSerializableSchema();
				return any;
			}
		}

		internal string NamespaceList
		{
			get
			{
				RetrieveSerializableSchema();
				if (namespaces == null)
				{
					if (schemas != null)
					{
						StringBuilder stringBuilder = new StringBuilder();
						foreach (XmlSchema item in schemas.Schemas())
						{
							if (item.TargetNamespace != null && item.TargetNamespace.Length > 0)
							{
								if (stringBuilder.Length > 0)
								{
									stringBuilder.Append(" ");
								}
								stringBuilder.Append(item.TargetNamespace);
							}
						}
						namespaces = stringBuilder.ToString();
					}
					else
					{
						namespaces = string.Empty;
					}
				}
				return namespaces;
			}
		}

		internal SerializableMapping DerivedMappings => derivedMappings;

		internal SerializableMapping NextDerivedMapping => nextDerivedMapping;

		internal SerializableMapping Next
		{
			get
			{
				return next;
			}
			set
			{
				next = value;
			}
		}

		internal Type Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		internal XmlSchemaSet Schemas
		{
			get
			{
				RetrieveSerializableSchema();
				return schemas;
			}
		}

		internal XmlSchema Schema
		{
			get
			{
				RetrieveSerializableSchema();
				return schema;
			}
		}

		internal XmlQualifiedName XsiType
		{
			get
			{
				if (!needSchema)
				{
					return xsiType;
				}
				if (getSchemaMethod == null)
				{
					return null;
				}
				if (typeof(XmlSchemaType).IsAssignableFrom(getSchemaMethod.ReturnType))
				{
					return null;
				}
				RetrieveSerializableSchema();
				return xsiType;
			}
		}

		internal XmlSchemaType XsdType
		{
			get
			{
				RetrieveSerializableSchema();
				return xsdType;
			}
		}

		internal SerializableMapping()
		{
		}

		internal SerializableMapping(MethodInfo getSchemaMethod, bool any, string ns)
		{
			this.getSchemaMethod = getSchemaMethod;
			this.any = any;
			base.Namespace = ns;
			needSchema = getSchemaMethod != null;
		}

		internal SerializableMapping(XmlQualifiedName xsiType, XmlSchemaSet schemas)
		{
			this.xsiType = xsiType;
			this.schemas = schemas;
			base.TypeName = xsiType.Name;
			base.Namespace = xsiType.Namespace;
			needSchema = false;
		}

		internal void SetBaseMapping(SerializableMapping mapping)
		{
			baseMapping = mapping;
			if (baseMapping != null)
			{
				nextDerivedMapping = baseMapping.derivedMappings;
				baseMapping.derivedMappings = this;
				if (this == nextDerivedMapping)
				{
					throw new InvalidOperationException(Res.GetString("XmlCircularDerivation", base.TypeDesc.FullName));
				}
			}
		}

		internal static void ValidationCallbackWithErrorCode(object sender, ValidationEventArgs args)
		{
			if (args.Severity == XmlSeverityType.Error)
			{
				throw new InvalidOperationException(Res.GetString("XmlSerializableSchemaError", typeof(IXmlSerializable).Name, args.Message));
			}
		}

		internal void CheckDuplicateElement(XmlSchemaElement element, string elementNs)
		{
			if (element == null || element.Parent == null || !(element.Parent is XmlSchema))
			{
				return;
			}
			XmlSchemaObjectTable xmlSchemaObjectTable = null;
			if (Schema != null && Schema.TargetNamespace == elementNs)
			{
				XmlSchemas.Preprocess(Schema);
				xmlSchemaObjectTable = Schema.Elements;
			}
			else
			{
				if (Schemas == null)
				{
					return;
				}
				xmlSchemaObjectTable = Schemas.GlobalElements;
			}
			foreach (XmlSchemaElement value in xmlSchemaObjectTable.Values)
			{
				if (value.Name == element.Name && value.QualifiedName.Namespace == elementNs)
				{
					if (Match(value, element))
					{
						break;
					}
					throw new InvalidOperationException(Res.GetString("XmlSerializableRootDupName", getSchemaMethod.DeclaringType.FullName, value.Name, elementNs));
				}
			}
		}

		private bool Match(XmlSchemaElement e1, XmlSchemaElement e2)
		{
			if (e1.IsNillable != e2.IsNillable)
			{
				return false;
			}
			if (e1.RefName != e2.RefName)
			{
				return false;
			}
			if (e1.SchemaType != e2.SchemaType)
			{
				return false;
			}
			if (e1.SchemaTypeName != e2.SchemaTypeName)
			{
				return false;
			}
			if (e1.MinOccurs != e2.MinOccurs)
			{
				return false;
			}
			if (e1.MaxOccurs != e2.MaxOccurs)
			{
				return false;
			}
			if (e1.IsAbstract != e2.IsAbstract)
			{
				return false;
			}
			if (e1.DefaultValue != e2.DefaultValue)
			{
				return false;
			}
			if (e1.SubstitutionGroup != e2.SubstitutionGroup)
			{
				return false;
			}
			return true;
		}

		private void RetrieveSerializableSchema()
		{
			if (!needSchema)
			{
				return;
			}
			needSchema = false;
			if (getSchemaMethod != null)
			{
				if (schemas == null)
				{
					schemas = new XmlSchemaSet();
				}
				object obj = getSchemaMethod.Invoke(null, new object[1] { schemas });
				xsiType = XmlQualifiedName.Empty;
				if (obj != null)
				{
					if (typeof(XmlSchemaType).IsAssignableFrom(getSchemaMethod.ReturnType))
					{
						xsdType = (XmlSchemaType)obj;
						xsiType = xsdType.QualifiedName;
					}
					else
					{
						if (!typeof(XmlQualifiedName).IsAssignableFrom(getSchemaMethod.ReturnType))
						{
							throw new InvalidOperationException(Res.GetString("XmlGetSchemaMethodReturnType", type.Name, getSchemaMethod.Name, typeof(XmlSchemaProviderAttribute).Name, typeof(XmlQualifiedName).FullName));
						}
						xsiType = (XmlQualifiedName)obj;
						if (xsiType.IsEmpty)
						{
							throw new InvalidOperationException(Res.GetString("XmlGetSchemaEmptyTypeName", type.FullName, getSchemaMethod.Name));
						}
					}
				}
				else
				{
					any = true;
				}
				schemas.ValidationEventHandler += ValidationCallbackWithErrorCode;
				schemas.Compile();
				if (!xsiType.IsEmpty && xsiType.Namespace != "http://www.w3.org/2001/XMLSchema")
				{
					ArrayList arrayList = (ArrayList)schemas.Schemas(xsiType.Namespace);
					if (arrayList.Count == 0)
					{
						throw new InvalidOperationException(Res.GetString("XmlMissingSchema", xsiType.Namespace));
					}
					if (arrayList.Count > 1)
					{
						throw new InvalidOperationException(Res.GetString("XmlGetSchemaInclude", xsiType.Namespace, getSchemaMethod.DeclaringType.FullName, getSchemaMethod.Name));
					}
					XmlSchema xmlSchema = (XmlSchema)arrayList[0];
					if (xmlSchema == null)
					{
						throw new InvalidOperationException(Res.GetString("XmlMissingSchema", xsiType.Namespace));
					}
					xsdType = (XmlSchemaType)xmlSchema.SchemaTypes[xsiType];
					if (xsdType == null)
					{
						throw new InvalidOperationException(Res.GetString("XmlGetSchemaTypeMissing", getSchemaMethod.DeclaringType.FullName, getSchemaMethod.Name, xsiType.Name, xsiType.Namespace));
					}
					xsdType = ((xsdType.Redefined != null) ? xsdType.Redefined : xsdType);
				}
			}
			else
			{
				IXmlSerializable xmlSerializable = (IXmlSerializable)Activator.CreateInstance(type);
				schema = xmlSerializable.GetSchema();
				if (schema != null && (schema.Id == null || schema.Id.Length == 0))
				{
					throw new InvalidOperationException(Res.GetString("XmlSerializableNameMissing1", type.FullName));
				}
			}
		}
	}
	internal class ModelScope
	{
		private TypeScope typeScope;

		private Hashtable models = new Hashtable();

		private Hashtable arrayModels = new Hashtable();

		internal TypeScope TypeScope => typeScope;

		internal ModelScope(TypeScope typeScope)
		{
			this.typeScope = typeScope;
		}

		internal TypeModel GetTypeModel(Type type)
		{
			return GetTypeModel(type, directReference: true);
		}

		internal TypeModel GetTypeModel(Type type, bool directReference)
		{
			TypeModel typeModel = (TypeModel)models[type];
			if (typeModel != null)
			{
				return typeModel;
			}
			TypeDesc typeDesc = typeScope.GetTypeDesc(type, null, directReference);
			switch (typeDesc.Kind)
			{
			case TypeKind.Enum:
				typeModel = new EnumModel(type, typeDesc, this);
				break;
			case TypeKind.Primitive:
				typeModel = new PrimitiveModel(type, typeDesc, this);
				break;
			case TypeKind.Array:
			case TypeKind.Collection:
			case TypeKind.Enumerable:
				typeModel = new ArrayModel(type, typeDesc, this);
				break;
			case TypeKind.Root:
			case TypeKind.Struct:
			case TypeKind.Class:
				typeModel = new StructModel(type, typeDesc, this);
				break;
			default:
				if (!typeDesc.IsSpecial)
				{
					throw new NotSupportedException(Res.GetString("XmlUnsupportedTypeKind", type.FullName));
				}
				typeModel = new SpecialModel(type, typeDesc, this);
				break;
			}
			models.Add(type, typeModel);
			return typeModel;
		}

		internal ArrayModel GetArrayModel(Type type)
		{
			TypeModel typeModel = (TypeModel)arrayModels[type];
			if (typeModel == null)
			{
				typeModel = GetTypeModel(type);
				if (!(typeModel is ArrayModel))
				{
					TypeDesc arrayTypeDesc = typeScope.GetArrayTypeDesc(type);
					typeModel = new ArrayModel(type, arrayTypeDesc, this);
				}
				arrayModels.Add(type, typeModel);
			}
			return (ArrayModel)typeModel;
		}
	}
	internal abstract class TypeModel
	{
		private TypeDesc typeDesc;

		private Type type;

		private ModelScope scope;

		internal Type Type => type;

		internal ModelScope ModelScope => scope;

		internal TypeDesc TypeDesc => typeDesc;

		protected TypeModel(Type type, TypeDesc typeDesc, ModelScope scope)
		{
			this.scope = scope;
			this.type = type;
			this.typeDesc = typeDesc;
		}
	}
	internal class ArrayModel : TypeModel
	{
		internal TypeModel Element => base.ModelScope.GetTypeModel(TypeScope.GetArrayElementType(base.Type, null));

		internal ArrayModel(Type type, TypeDesc typeDesc, ModelScope scope)
			: base(type, typeDesc, scope)
		{
		}
	}
	internal class PrimitiveModel : TypeModel
	{
		internal PrimitiveModel(Type type, TypeDesc typeDesc, ModelScope scope)
			: base(type, typeDesc, scope)
		{
		}
	}
	internal class SpecialModel : TypeModel
	{
		internal SpecialModel(Type type, TypeDesc typeDesc, ModelScope scope)
			: base(type, typeDesc, scope)
		{
		}
	}
	internal class StructModel : TypeModel
	{
		internal StructModel(Type type, TypeDesc typeDesc, ModelScope scope)
			: base(type, typeDesc, scope)
		{
		}

		internal MemberInfo[] GetMemberInfos()
		{
			MemberInfo[] members = base.Type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
			MemberInfo[] array = new MemberInfo[members.Length];
			int num = 0;
			for (int i = 0; i < members.Length; i++)
			{
				if ((members[i].MemberType & MemberTypes.Property) == 0)
				{
					array[num++] = members[i];
				}
			}
			for (int j = 0; j < members.Length; j++)
			{
				if ((members[j].MemberType & MemberTypes.Property) != 0)
				{
					array[num++] = members[j];
				}
			}
			return array;
		}

		internal FieldModel GetFieldModel(MemberInfo memberInfo)
		{
			FieldModel fieldModel = null;
			if (memberInfo is FieldInfo)
			{
				fieldModel = GetFieldModel((FieldInfo)memberInfo);
			}
			else if (memberInfo is PropertyInfo)
			{
				fieldModel = GetPropertyModel((PropertyInfo)memberInfo);
			}
			if (fieldModel != null && fieldModel.ReadOnly && fieldModel.FieldTypeDesc.Kind != TypeKind.Collection && fieldModel.FieldTypeDesc.Kind != TypeKind.Enumerable)
			{
				return null;
			}
			return fieldModel;
		}

		private void CheckSupportedMember(TypeDesc typeDesc, MemberInfo member, Type type)
		{
			if (typeDesc == null)
			{
				return;
			}
			if (typeDesc.IsUnsupported)
			{
				if (typeDesc.Exception == null)
				{
					typeDesc.Exception = new NotSupportedException(Res.GetString("XmlSerializerUnsupportedType", typeDesc.FullName));
				}
				throw new InvalidOperationException(Res.GetString("XmlSerializerUnsupportedMember", member.DeclaringType.FullName + "." + member.Name, type.FullName), typeDesc.Exception);
			}
			CheckSupportedMember(typeDesc.BaseTypeDesc, member, type);
			CheckSupportedMember(typeDesc.ArrayElementTypeDesc, member, type);
		}

		private FieldModel GetFieldModel(FieldInfo fieldInfo)
		{
			if (fieldInfo.IsStatic)
			{
				return null;
			}
			if (fieldInfo.DeclaringType != base.Type)
			{
				return null;
			}
			TypeDesc typeDesc = base.ModelScope.TypeScope.GetTypeDesc(fieldInfo.FieldType, fieldInfo, directReference: true, throwOnError: false);
			if (fieldInfo.IsInitOnly && typeDesc.Kind != TypeKind.Collection && typeDesc.Kind != TypeKind.Enumerable)
			{
				return null;
			}
			CheckSupportedMember(typeDesc, fieldInfo, fieldInfo.FieldType);
			return new FieldModel(fieldInfo, fieldInfo.FieldType, typeDesc);
		}

		private FieldModel GetPropertyModel(PropertyInfo propertyInfo)
		{
			if (propertyInfo.DeclaringType != base.Type)
			{
				return null;
			}
			if (CheckPropertyRead(propertyInfo))
			{
				TypeDesc typeDesc = base.ModelScope.TypeScope.GetTypeDesc(propertyInfo.PropertyType, propertyInfo, directReference: true, throwOnError: false);
				if (!propertyInfo.CanWrite && typeDesc.Kind != TypeKind.Collection && typeDesc.Kind != TypeKind.Enumerable)
				{
					return null;
				}
				CheckSupportedMember(typeDesc, propertyInfo, propertyInfo.PropertyType);
				return new FieldModel(propertyInfo, propertyInfo.PropertyType, typeDesc);
			}
			return null;
		}

		internal static bool CheckPropertyRead(PropertyInfo propertyInfo)
		{
			if (!propertyInfo.CanRead)
			{
				return false;
			}
			MethodInfo getMethod = propertyInfo.GetGetMethod();
			if (getMethod.IsStatic)
			{
				return false;
			}
			ParameterInfo[] parameters = getMethod.GetParameters();
			if (parameters.Length > 0)
			{
				return false;
			}
			return true;
		}
	}
	internal enum SpecifiedAccessor
	{
		None,
		ReadOnly,
		ReadWrite
	}
	internal class FieldModel
	{
		private SpecifiedAccessor checkSpecified;

		private bool checkShouldPersist;

		private bool readOnly;

		private bool isProperty;

		private Type fieldType;

		private string name;

		private TypeDesc fieldTypeDesc;

		internal string Name => name;

		internal Type FieldType => fieldType;

		internal TypeDesc FieldTypeDesc => fieldTypeDesc;

		internal bool CheckShouldPersist => checkShouldPersist;

		internal SpecifiedAccessor CheckSpecified => checkSpecified;

		internal bool ReadOnly => readOnly;

		internal bool IsProperty => isProperty;

		internal FieldModel(string name, Type fieldType, TypeDesc fieldTypeDesc, bool checkSpecified, bool checkShouldPersist)
			: this(name, fieldType, fieldTypeDesc, checkSpecified, checkShouldPersist, readOnly: false)
		{
		}

		internal FieldModel(string name, Type fieldType, TypeDesc fieldTypeDesc, bool checkSpecified, bool checkShouldPersist, bool readOnly)
		{
			this.fieldTypeDesc = fieldTypeDesc;
			this.name = name;
			this.fieldType = fieldType;
			this.checkSpecified = (checkSpecified ? SpecifiedAccessor.ReadWrite : SpecifiedAccessor.None);
			this.checkShouldPersist = checkShouldPersist;
			this.readOnly = readOnly;
		}

		internal FieldModel(MemberInfo memberInfo, Type fieldType, TypeDesc fieldTypeDesc)
		{
			name = memberInfo.Name;
			this.fieldType = fieldType;
			this.fieldTypeDesc = fieldTypeDesc;
			checkShouldPersist = memberInfo.DeclaringType.GetMethod("ShouldSerialize" + memberInfo.Name, new Type[0]) != null;
			FieldInfo field = memberInfo.DeclaringType.GetField(memberInfo.Name + "Specified");
			if (field != null)
			{
				if (field.FieldType != typeof(bool))
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidSpecifiedType", field.Name, field.FieldType.FullName, typeof(bool).FullName));
				}
				checkSpecified = (field.IsInitOnly ? SpecifiedAccessor.ReadOnly : SpecifiedAccessor.ReadWrite);
			}
			else
			{
				PropertyInfo property = memberInfo.DeclaringType.GetProperty(memberInfo.Name + "Specified");
				if (property != null)
				{
					if (StructModel.CheckPropertyRead(property))
					{
						checkSpecified = ((!property.CanWrite) ? SpecifiedAccessor.ReadOnly : SpecifiedAccessor.ReadWrite);
					}
					if (checkSpecified != 0 && property.PropertyType != typeof(bool))
					{
						throw new InvalidOperationException(Res.GetString("XmlInvalidSpecifiedType", property.Name, property.PropertyType.FullName, typeof(bool).FullName));
					}
				}
			}
			if (memberInfo is PropertyInfo)
			{
				readOnly = !((PropertyInfo)memberInfo).CanWrite;
				isProperty = true;
			}
			else if (memberInfo is FieldInfo)
			{
				readOnly = ((FieldInfo)memberInfo).IsInitOnly;
			}
		}
	}
	internal class ConstantModel
	{
		private FieldInfo fieldInfo;

		private long value;

		internal string Name => fieldInfo.Name;

		internal long Value => value;

		internal FieldInfo FieldInfo => fieldInfo;

		internal ConstantModel(FieldInfo fieldInfo, long value)
		{
			this.fieldInfo = fieldInfo;
			this.value = value;
		}
	}
	internal class EnumModel : TypeModel
	{
		private ConstantModel[] constants;

		internal ConstantModel[] Constants
		{
			get
			{
				if (constants == null)
				{
					ArrayList arrayList = new ArrayList();
					FieldInfo[] fields = base.Type.GetFields();
					foreach (FieldInfo fieldInfo in fields)
					{
						ConstantModel constantModel = GetConstantModel(fieldInfo);
						if (constantModel != null)
						{
							arrayList.Add(constantModel);
						}
					}
					constants = (ConstantModel[])arrayList.ToArray(typeof(ConstantModel));
				}
				return constants;
			}
		}

		internal EnumModel(Type type, TypeDesc typeDesc, ModelScope scope)
			: base(type, typeDesc, scope)
		{
		}

		private ConstantModel GetConstantModel(FieldInfo fieldInfo)
		{
			if (fieldInfo.IsSpecialName)
			{
				return null;
			}
			return new ConstantModel(fieldInfo, ((IConvertible)fieldInfo.GetValue(null)).ToInt64(null));
		}
	}
	internal class NameKey
	{
		private string ns;

		private string name;

		internal NameKey(string name, string ns)
		{
			this.name = name;
			this.ns = ns;
		}

		public override bool Equals(object other)
		{
			if (!(other is NameKey))
			{
				return false;
			}
			NameKey nameKey = (NameKey)other;
			if (name == nameKey.name)
			{
				return ns == nameKey.ns;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((ns == null) ? "<null>".GetHashCode() : ns.GetHashCode()) ^ ((name != null) ? name.GetHashCode() : 0);
		}
	}
	internal class NameTable : INameScope
	{
		private Hashtable table = new Hashtable();

		internal object this[XmlQualifiedName qname]
		{
			get
			{
				return table[new NameKey(qname.Name, qname.Namespace)];
			}
			set
			{
				table[new NameKey(qname.Name, qname.Namespace)] = value;
			}
		}

		internal object this[string name, string ns]
		{
			get
			{
				return table[new NameKey(name, ns)];
			}
			set
			{
				table[new NameKey(name, ns)] = value;
			}
		}

		object INameScope.this[string name, string ns]
		{
			get
			{
				return table[new NameKey(name, ns)];
			}
			set
			{
				table[new NameKey(name, ns)] = value;
			}
		}

		internal ICollection Values => table.Values;

		internal void Add(XmlQualifiedName qname, object value)
		{
			Add(qname.Name, qname.Namespace, value);
		}

		internal void Add(string name, string ns, object value)
		{
			NameKey key = new NameKey(name, ns);
			table.Add(key, value);
		}

		internal Array ToArray(Type type)
		{
			Array array = Array.CreateInstance(type, table.Count);
			table.Values.CopyTo(array, 0);
			return array;
		}
	}
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	public abstract class SchemaImporter
	{
		private XmlSchemas schemas;

		private StructMapping root;

		private CodeGenerationOptions options;

		private CodeDomProvider codeProvider;

		private TypeScope scope;

		private ImportContext context;

		private bool rootImported;

		private NameTable typesInUse;

		private NameTable groupsInUse;

		private SchemaImporterExtensionCollection extensions;

		internal ImportContext Context
		{
			get
			{
				if (context == null)
				{
					context = new ImportContext();
				}
				return context;
			}
		}

		internal CodeDomProvider CodeProvider
		{
			get
			{
				if (codeProvider == null)
				{
					codeProvider = new CSharpCodeProvider();
				}
				return codeProvider;
			}
		}

		public SchemaImporterExtensionCollection Extensions
		{
			get
			{
				if (extensions == null)
				{
					extensions = new SchemaImporterExtensionCollection();
				}
				return extensions;
			}
		}

		internal Hashtable ImportedElements => Context.Elements;

		internal Hashtable ImportedMappings => Context.Mappings;

		internal CodeIdentifiers TypeIdentifiers => Context.TypeIdentifiers;

		internal XmlSchemas Schemas
		{
			get
			{
				if (schemas == null)
				{
					schemas = new XmlSchemas();
				}
				return schemas;
			}
		}

		internal TypeScope Scope
		{
			get
			{
				if (scope == null)
				{
					scope = new TypeScope();
				}
				return scope;
			}
		}

		internal NameTable GroupsInUse
		{
			get
			{
				if (groupsInUse == null)
				{
					groupsInUse = new NameTable();
				}
				return groupsInUse;
			}
		}

		internal NameTable TypesInUse
		{
			get
			{
				if (typesInUse == null)
				{
					typesInUse = new NameTable();
				}
				return typesInUse;
			}
		}

		internal CodeGenerationOptions Options => options;

		internal SchemaImporter(XmlSchemas schemas, CodeGenerationOptions options, CodeDomProvider codeProvider, ImportContext context)
		{
			if (!schemas.Contains("http://www.w3.org/2001/XMLSchema"))
			{
				schemas.AddReference(XmlSchemas.XsdSchema);
				schemas.SchemaSet.Add(XmlSchemas.XsdSchema);
			}
			if (!schemas.Contains("http://www.w3.org/XML/1998/namespace"))
			{
				schemas.AddReference(XmlSchemas.XmlSchema);
				schemas.SchemaSet.Add(XmlSchemas.XmlSchema);
			}
			this.schemas = schemas;
			this.options = options;
			this.codeProvider = codeProvider;
			this.context = context;
			Schemas.SetCache(Context.Cache, Context.ShareTypes);
			if (System.Configuration.PrivilegedConfigurationManager.GetSection(ConfigurationStrings.SchemaImporterExtensionsSectionPath) is SchemaImporterExtensionsSection schemaImporterExtensionsSection)
			{
				extensions = schemaImporterExtensionsSection.SchemaImporterExtensionsInternal;
			}
			else
			{
				extensions = new SchemaImporterExtensionCollection();
			}
		}

		internal void MakeDerived(StructMapping structMapping, Type baseType, bool baseTypeCanBeIndirect)
		{
			structMapping.ReferencedByTopLevelElement = true;
			if (baseType == null)
			{
				return;
			}
			TypeDesc typeDesc = Scope.GetTypeDesc(baseType);
			if (typeDesc == null)
			{
				return;
			}
			TypeDesc typeDesc2 = structMapping.TypeDesc;
			if (baseTypeCanBeIndirect)
			{
				while (typeDesc2.BaseTypeDesc != null && typeDesc2.BaseTypeDesc != typeDesc)
				{
					typeDesc2 = typeDesc2.BaseTypeDesc;
				}
			}
			if (typeDesc2.BaseTypeDesc != null && typeDesc2.BaseTypeDesc != typeDesc)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidBaseType", structMapping.TypeDesc.FullName, baseType.FullName, typeDesc2.BaseTypeDesc.FullName));
			}
			typeDesc2.BaseTypeDesc = typeDesc;
		}

		internal string GenerateUniqueTypeName(string typeName)
		{
			typeName = CodeIdentifier.MakeValid(typeName);
			return TypeIdentifiers.AddUnique(typeName, typeName);
		}

		private StructMapping CreateRootMapping()
		{
			TypeDesc typeDesc = Scope.GetTypeDesc(typeof(object));
			StructMapping structMapping = new StructMapping();
			structMapping.TypeDesc = typeDesc;
			structMapping.Members = new MemberMapping[0];
			structMapping.IncludeInSchema = false;
			structMapping.TypeName = "anyType";
			structMapping.Namespace = "http://www.w3.org/2001/XMLSchema";
			return structMapping;
		}

		internal StructMapping GetRootMapping()
		{
			if (root == null)
			{
				root = CreateRootMapping();
			}
			return root;
		}

		internal StructMapping ImportRootMapping()
		{
			if (!rootImported)
			{
				rootImported = true;
				ImportDerivedTypes(XmlQualifiedName.Empty);
			}
			return GetRootMapping();
		}

		internal abstract void ImportDerivedTypes(XmlQualifiedName baseName);

		internal void AddReference(XmlQualifiedName name, NameTable references, string error)
		{
			if (!(name.Namespace == "http://www.w3.org/2001/XMLSchema"))
			{
				if (references[name] != null)
				{
					throw new InvalidOperationException(Res.GetString(error, name.Name, name.Namespace));
				}
				references[name] = name;
			}
		}

		internal void RemoveReference(XmlQualifiedName name, NameTable references)
		{
			references[name] = null;
		}

		internal void AddReservedIdentifiersForDataBinding(CodeIdentifiers scope)
		{
			if ((options & CodeGenerationOptions.EnableDataBinding) != 0)
			{
				scope.AddReserved(CodeExporter.PropertyChangedEvent.Name);
				scope.AddReserved(CodeExporter.RaisePropertyChangedEventMethod.Name);
			}
		}
	}
	internal class XmlAttributeComparer : IComparer
	{
		public int Compare(object o1, object o2)
		{
			XmlAttribute xmlAttribute = (XmlAttribute)o1;
			XmlAttribute xmlAttribute2 = (XmlAttribute)o2;
			int num = string.Compare(xmlAttribute.NamespaceURI, xmlAttribute2.NamespaceURI, StringComparison.Ordinal);
			if (num == 0)
			{
				return string.Compare(xmlAttribute.Name, xmlAttribute2.Name, StringComparison.Ordinal);
			}
			return num;
		}
	}
	internal class XmlFacetComparer : IComparer
	{
		public int Compare(object o1, object o2)
		{
			XmlSchemaFacet xmlSchemaFacet = (XmlSchemaFacet)o1;
			XmlSchemaFacet xmlSchemaFacet2 = (XmlSchemaFacet)o2;
			return string.Compare(xmlSchemaFacet.GetType().Name + ":" + xmlSchemaFacet.Value, xmlSchemaFacet2.GetType().Name + ":" + xmlSchemaFacet2.Value, StringComparison.Ordinal);
		}
	}
	internal class QNameComparer : IComparer
	{
		public int Compare(object o1, object o2)
		{
			XmlQualifiedName xmlQualifiedName = (XmlQualifiedName)o1;
			XmlQualifiedName xmlQualifiedName2 = (XmlQualifiedName)o2;
			int num = string.Compare(xmlQualifiedName.Namespace, xmlQualifiedName2.Namespace, StringComparison.Ordinal);
			if (num == 0)
			{
				return string.Compare(xmlQualifiedName.Name, xmlQualifiedName2.Name, StringComparison.Ordinal);
			}
			return num;
		}
	}
	internal class XmlSchemaObjectComparer : IComparer
	{
		private QNameComparer comparer = new QNameComparer();

		public int Compare(object o1, object o2)
		{
			return comparer.Compare(NameOf((XmlSchemaObject)o1), NameOf((XmlSchemaObject)o2));
		}

		internal static XmlQualifiedName NameOf(XmlSchemaObject o)
		{
			if (o is XmlSchemaAttribute)
			{
				return ((XmlSchemaAttribute)o).QualifiedName;
			}
			if (o is XmlSchemaAttributeGroup)
			{
				return ((XmlSchemaAttributeGroup)o).QualifiedName;
			}
			if (o is XmlSchemaComplexType)
			{
				return ((XmlSchemaComplexType)o).QualifiedName;
			}
			if (o is XmlSchemaSimpleType)
			{
				return ((XmlSchemaSimpleType)o).QualifiedName;
			}
			if (o is XmlSchemaElement)
			{
				return ((XmlSchemaElement)o).QualifiedName;
			}
			if (o is XmlSchemaGroup)
			{
				return ((XmlSchemaGroup)o).QualifiedName;
			}
			if (o is XmlSchemaGroupRef)
			{
				return ((XmlSchemaGroupRef)o).RefName;
			}
			if (o is XmlSchemaNotation)
			{
				return ((XmlSchemaNotation)o).QualifiedName;
			}
			if (o is XmlSchemaSequence)
			{
				XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence)o;
				if (xmlSchemaSequence.Items.Count == 0)
				{
					return new XmlQualifiedName(".sequence", Namespace(o));
				}
				return NameOf(xmlSchemaSequence.Items[0]);
			}
			if (o is XmlSchemaAll)
			{
				XmlSchemaAll xmlSchemaAll = (XmlSchemaAll)o;
				if (xmlSchemaAll.Items.Count == 0)
				{
					return new XmlQualifiedName(".all", Namespace(o));
				}
				return NameOf(xmlSchemaAll.Items);
			}
			if (o is XmlSchemaChoice)
			{
				XmlSchemaChoice xmlSchemaChoice = (XmlSchemaChoice)o;
				if (xmlSchemaChoice.Items.Count == 0)
				{
					return new XmlQualifiedName(".choice", Namespace(o));
				}
				return NameOf(xmlSchemaChoice.Items);
			}
			if (o is XmlSchemaAny)
			{
				return new XmlQualifiedName("*", SchemaObjectWriter.ToString(((XmlSchemaAny)o).NamespaceList));
			}
			if (o is XmlSchemaIdentityConstraint)
			{
				return ((XmlSchemaIdentityConstraint)o).QualifiedName;
			}
			return new XmlQualifiedName("?", Namespace(o));
		}

		internal static XmlQualifiedName NameOf(XmlSchemaObjectCollection items)
		{
			ArrayList arrayList = new ArrayList();
			for (int i = 0; i < items.Count; i++)
			{
				arrayList.Add(NameOf(items[i]));
			}
			arrayList.Sort(new QNameComparer());
			return (XmlQualifiedName)arrayList[0];
		}

		internal static string Namespace(XmlSchemaObject o)
		{
			while (o != null && !(o is XmlSchema))
			{
				o = o.Parent;
			}
			if (o != null)
			{
				return ((XmlSchema)o).TargetNamespace;
			}
			return "";
		}
	}
	internal class SchemaObjectWriter
	{
		private StringBuilder w = new StringBuilder();

		private int indentLevel = -1;

		private void WriteIndent()
		{
			for (int i = 0; i < indentLevel; i++)
			{
				w.Append(" ");
			}
		}

		protected void WriteAttribute(string localName, string ns, string value)
		{
			if (value != null && value.Length != 0)
			{
				w.Append(",");
				w.Append(ns);
				if (ns != null && ns.Length != 0)
				{
					w.Append(":");
				}
				w.Append(localName);
				w.Append("=");
				w.Append(value);
			}
		}

		protected void WriteAttribute(string localName, string ns, XmlQualifiedName value)
		{
			if (!value.IsEmpty)
			{
				WriteAttribute(localName, ns, value.ToString());
			}
		}

		protected void WriteStartElement(string name)
		{
			NewLine();
			indentLevel++;
			w.Append("[");
			w.Append(name);
		}

		protected void WriteEndElement()
		{
			w.Append("]");
			indentLevel--;
		}

		protected void NewLine()
		{
			w.Append(Environment.NewLine);
			WriteIndent();
		}

		protected string GetString()
		{
			return w.ToString();
		}

		private void WriteAttribute(XmlAttribute a)
		{
			if (a.Value != null)
			{
				WriteAttribute(a.Name, a.NamespaceURI, a.Value);
			}
		}

		private void WriteAttributes(XmlAttribute[] a, XmlSchemaObject o)
		{
			if (a != null)
			{
				ArrayList arrayList = new ArrayList();
				for (int i = 0; i < a.Length; i++)
				{
					arrayList.Add(a[i]);
				}
				arrayList.Sort(new XmlAttributeComparer());
				for (int j = 0; j < arrayList.Count; j++)
				{
					XmlAttribute a2 = (XmlAttribute)arrayList[j];
					WriteAttribute(a2);
				}
			}
		}

		internal static string ToString(NamespaceList list)
		{
			if (list == null)
			{
				return null;
			}
			switch (list.Type)
			{
			case NamespaceList.ListType.Any:
				return "##any";
			case NamespaceList.ListType.Other:
				return "##other";
			case NamespaceList.ListType.Set:
			{
				ArrayList arrayList = new ArrayList();
				foreach (string item in list.Enumerate)
				{
					arrayList.Add(item);
				}
				arrayList.Sort();
				StringBuilder stringBuilder = new StringBuilder();
				bool flag = true;
				foreach (string item2 in arrayList)
				{
					if (flag)
					{
						flag = false;
					}
					else
					{
						stringBuilder.Append(" ");
					}
					if (item2.Length == 0)
					{
						stringBuilder.Append("##local");
					}
					else
					{
						stringBuilder.Append(item2);
					}
				}
				return stringBuilder.ToString();
			}
			default:
				return list.ToString();
			}
		}

		internal string WriteXmlSchemaObject(XmlSchemaObject o)
		{
			if (o == null)
			{
				return string.Empty;
			}
			Write3_XmlSchemaObject(o);
			return GetString();
		}

		private void WriteSortedItems(XmlSchemaObjectCollection items)
		{
			if (items != null)
			{
				ArrayList arrayList = new ArrayList();
				for (int i = 0; i < items.Count; i++)
				{
					arrayList.Add(items[i]);
				}
				arrayList.Sort(new XmlSchemaObjectComparer());
				for (int j = 0; j < arrayList.Count; j++)
				{
					Write3_XmlSchemaObject((XmlSchemaObject)arrayList[j]);
				}
			}
		}

		private void Write1_XmlSchemaAttribute(XmlSchemaAttribute o)
		{
			if (o == null)
			{
				return;
			}
			WriteStartElement("attribute");
			WriteAttribute("id", "", o.Id);
			WriteAttributes(o.UnhandledAttributes, o);
			WriteAttribute("default", "", o.DefaultValue);
			WriteAttribute("fixed", "", o.FixedValue);
			if (o.Parent != null && !(o.Parent is XmlSchema))
			{
				if (o.QualifiedName != null && !o.QualifiedName.IsEmpty && o.QualifiedName.Namespace != null && o.QualifiedName.Namespace.Length != 0)
				{
					WriteAttribute("form", "", "qualified");
				}
				else
				{
					WriteAttribute("form", "", "unqualified");
				}
			}
			WriteAttribute("name", "", o.Name);
			if (!o.RefName.IsEmpty)
			{
				WriteAttribute("ref", "", o.RefName);
			}
			else if (!o.SchemaTypeName.IsEmpty)
			{
				WriteAttribute("type", "", o.SchemaTypeName);
			}
			XmlSchemaUse v = ((o.Use == XmlSchemaUse.None) ? XmlSchemaUse.Optional : o.Use);
			WriteAttribute("use", "", Write30_XmlSchemaUse(v));
			Write5_XmlSchemaAnnotation(o.Annotation);
			Write9_XmlSchemaSimpleType(o.SchemaType);
			WriteEndElement();
		}

		private void Write3_XmlSchemaObject(XmlSchemaObject o)
		{
			if (o != null)
			{
				Type type = o.GetType();
				if (type == typeof(XmlSchemaComplexType))
				{
					Write35_XmlSchemaComplexType((XmlSchemaComplexType)o);
				}
				else if (type == typeof(XmlSchemaSimpleType))
				{
					Write9_XmlSchemaSimpleType((XmlSchemaSimpleType)o);
				}
				else if (type == typeof(XmlSchemaElement))
				{
					Write46_XmlSchemaElement((XmlSchemaElement)o);
				}
				else if (type == typeof(XmlSchemaAppInfo))
				{
					Write7_XmlSchemaAppInfo((XmlSchemaAppInfo)o);
				}
				else if (type == typeof(XmlSchemaDocumentation))
				{
					Write6_XmlSchemaDocumentation((XmlSchemaDocumentation)o);
				}
				else if (type == typeof(XmlSchemaAnnotation))
				{
					Write5_XmlSchemaAnnotation((XmlSchemaAnnotation)o);
				}
				else if (type == typeof(XmlSchemaGroup))
				{
					Write57_XmlSchemaGroup((XmlSchemaGroup)o);
				}
				else if (type == typeof(XmlSchemaXPath))
				{
					Write49_XmlSchemaXPath("xpath", "", (XmlSchemaXPath)o);
				}
				else if (type == typeof(XmlSchemaIdentityConstraint))
				{
					Write48_XmlSchemaIdentityConstraint((XmlSchemaIdentityConstraint)o);
				}
				else if (type == typeof(XmlSchemaUnique))
				{
					Write51_XmlSchemaUnique((XmlSchemaUnique)o);
				}
				else if (type == typeof(XmlSchemaKeyref))
				{
					Write50_XmlSchemaKeyref((XmlSchemaKeyref)o);
				}
				else if (type == typeof(XmlSchemaKey))
				{
					Write47_XmlSchemaKey((XmlSchemaKey)o);
				}
				else if (type == typeof(XmlSchemaGroupRef))
				{
					Write55_XmlSchemaGroupRef((XmlSchemaGroupRef)o);
				}
				else if (type == typeof(XmlSchemaAny))
				{
					Write53_XmlSchemaAny((XmlSchemaAny)o);
				}
				else if (type == typeof(XmlSchemaSequence))
				{
					Write54_XmlSchemaSequence((XmlSchemaSequence)o);
				}
				else if (type == typeof(XmlSchemaChoice))
				{
					Write52_XmlSchemaChoice((XmlSchemaChoice)o);
				}
				else if (type == typeof(XmlSchemaAll))
				{
					Write43_XmlSchemaAll((XmlSchemaAll)o);
				}
				else if (type == typeof(XmlSchemaComplexContentRestriction))
				{
					Write56_XmlSchemaComplexContentRestriction((XmlSchemaComplexContentRestriction)o);
				}
				else if (type == typeof(XmlSchemaComplexContentExtension))
				{
					Write42_XmlSchemaComplexContentExtension((XmlSchemaComplexContentExtension)o);
				}
				else if (type == typeof(XmlSchemaSimpleContentRestriction))
				{
					Write40_XmlSchemaSimpleContentRestriction((XmlSchemaSimpleContentRestriction)o);
				}
				else if (type == typeof(XmlSchemaSimpleContentExtension))
				{
					Write38_XmlSchemaSimpleContentExtension((XmlSchemaSimpleContentExtension)o);
				}
				else if (type == typeof(XmlSchemaComplexContent))
				{
					Write41_XmlSchemaComplexContent((XmlSchemaComplexContent)o);
				}
				else if (type == typeof(XmlSchemaSimpleContent))
				{
					Write36_XmlSchemaSimpleContent((XmlSchemaSimpleContent)o);
				}
				else if (type == typeof(XmlSchemaAnyAttribute))
				{
					Write33_XmlSchemaAnyAttribute((XmlSchemaAnyAttribute)o);
				}
				else if (type == typeof(XmlSchemaAttributeGroupRef))
				{
					Write32_XmlSchemaAttributeGroupRef((XmlSchemaAttributeGroupRef)o);
				}
				else if (type == typeof(XmlSchemaAttributeGroup))
				{
					Write31_XmlSchemaAttributeGroup((XmlSchemaAttributeGroup)o);
				}
				else if (type == typeof(XmlSchemaSimpleTypeRestriction))
				{
					Write15_XmlSchemaSimpleTypeRestriction((XmlSchemaSimpleTypeRestriction)o);
				}
				else if (type == typeof(XmlSchemaSimpleTypeList))
				{
					Write14_XmlSchemaSimpleTypeList((XmlSchemaSimpleTypeList)o);
				}
				else if (type == typeof(XmlSchemaSimpleTypeUnion))
				{
					Write12_XmlSchemaSimpleTypeUnion((XmlSchemaSimpleTypeUnion)o);
				}
				else if (type == typeof(XmlSchemaAttribute))
				{
					Write1_XmlSchemaAttribute((XmlSchemaAttribute)o);
				}
			}
		}

		private void Write5_XmlSchemaAnnotation(XmlSchemaAnnotation o)
		{
			if (o == null)
			{
				return;
			}
			WriteStartElement("annotation");
			WriteAttribute("id", "", o.Id);
			WriteAttributes(o.UnhandledAttributes, o);
			XmlSchemaObjectCollection items = o.Items;
			if (items != null)
			{
				for (int i = 0; i < items.Count; i++)
				{
					XmlSchemaObject xmlSchemaObject = items[i];
					if (xmlSchemaObject is XmlSchemaAppInfo)
					{
						Write7_XmlSchemaAppInfo((XmlSchemaAppInfo)xmlSchemaObject);
					}
					else if (xmlSchemaObject is XmlSchemaDocumentation)
					{
						Write6_XmlSchemaDocumentation((XmlSchemaDocumentation)xmlSchemaObject);
					}
				}
			}
			WriteEndElement();
		}

		private void Write6_XmlSchemaDocumentation(XmlSchemaDocumentation o)
		{
			if (o == null)
			{
				return;
			}
			WriteStartElement("documentation");
			WriteAttribute("source", "", o.Source);
			WriteAttribute("lang", "http://www.w3.org/XML/1998/namespace", o.Language);
			XmlNode[] markup = o.Markup;
			if (markup != null)
			{
				foreach (XmlNode xmlNode in markup)
				{
					WriteStartElement("node");
					WriteAttribute("xml", "", xmlNode.OuterXml);
				}
			}
			WriteEndElement();
		}

		private void Write7_XmlSchemaAppInfo(XmlSchemaAppInfo o)
		{
			if (o == null)
			{
				return;
			}
			WriteStartElement("appinfo");
			WriteAttribute("source", "", o.Source);
			XmlNode[] markup = o.Markup;
			if (markup != null)
			{
				foreach (XmlNode xmlNode in markup)
				{
					WriteStartElement("node");
					WriteAttribute("xml", "", xmlNode.OuterXml);
				}
			}
			WriteEndElement();
		}

		private void Write9_XmlSchemaSimpleType(XmlSchemaSimpleType o)
		{
			if (o != null)
			{
				WriteStartElement("simpleType");
				WriteAttribute("id", "", o.Id);
				WriteAttributes(o.UnhandledAttributes, o);
				WriteAttribute("name", "", o.Name);
				WriteAttribute("final", "", Write11_XmlSchemaDerivationMethod(o.FinalResolved));
				Write5_XmlSchemaAnnotation(o.Annotation);
				if (o.Content is XmlSchemaSimpleTypeUnion)
				{
					Write12_XmlSchemaSimpleTypeUnion((XmlSchemaSimpleTypeUnion)o.Content);
				}
				else if (o.Content is XmlSchemaSimpleTypeRestriction)
				{
					Write15_XmlSchemaSimpleTypeRestriction((XmlSchemaSimpleTypeRestriction)o.Content);
				}
				else if (o.Content is XmlSchemaSimpleTypeList)
				{
					Write14_XmlSchemaSimpleTypeList((XmlSchemaSimpleTypeList)o.Content);
				}
				WriteEndElement();
			}
		}

		private string Write11_XmlSchemaDerivationMethod(XmlSchemaDerivationMethod v)
		{
			return v.ToString();
		}

		private void Write12_XmlSchemaSimpleTypeUnion(XmlSchemaSimpleTypeUnion o)
		{
			if (o == null)
			{
				return;
			}
			WriteStartElement("union");
			WriteAttribute("id", "", o.Id);
			WriteAttributes(o.UnhandledAttributes, o);
			if (o.MemberTypes != null)
			{
				ArrayList arrayList = new ArrayList();
				for (int i = 0; i < o.MemberTypes.Length; i++)
				{
					arrayList.Add(o.MemberTypes[i]);
				}
				arrayList.Sort(new QNameComparer());
				w.Append(",");
				w.Append("memberTypes=");
				for (int j = 0; j < arrayList.Count; j++)
				{
					XmlQualifiedName xmlQualifiedName = (XmlQualifiedName)arrayList[j];
					w.Append(xmlQualifiedName.ToString());
					w.Append(",");
				}
			}
			Write5_XmlSchemaAnnotation(o.Annotation);
			WriteSortedItems(o.BaseTypes);
			WriteEndElement();
		}

		private void Write14_XmlSchemaSimpleTypeList(XmlSchemaSimpleTypeList o)
		{
			if (o != null)
			{
				WriteStartElement("list");
				WriteAttribute("id", "", o.Id);
				WriteAttributes(o.UnhandledAttributes, o);
				if (!o.ItemTypeName.IsEmpty)
				{
					WriteAttribute("itemType", "", o.ItemTypeName);
				}
				Write5_XmlSchemaAnnotation(o.Annotation);
				Write9_XmlSchemaSimpleType(o.ItemType);
				WriteEndElement();
			}
		}

		private void Write15_XmlSchemaSimpleTypeRestriction(XmlSchemaSimpleTypeRestriction o)
		{
			if (o != null)
			{
				WriteStartElement("restriction");
				WriteAttribute("id", "", o.Id);
				WriteAttributes(o.UnhandledAttributes, o);
				if (!o.BaseTypeName.IsEmpty)
				{
					WriteAttribute("base", "", o.BaseTypeName);
				}
				Write5_XmlSchemaAnnotation(o.Annotation);
				Write9_XmlSchemaSimpleType(o.BaseType);
				WriteFacets(o.Facets);
				WriteEndElement();
			}
		}

		private void WriteFacets(XmlSchemaObjectCollection facets)
		{
			if (facets == null)
			{
				return;
			}
			ArrayList arrayList = new ArrayList();
			for (int i = 0; i < facets.Count; i++)
			{
				arrayList.Add(facets[i]);
			}
			arrayList.Sort(new XmlFacetComparer());
			for (int j = 0; j < arrayList.Count; j++)
			{
				XmlSchemaObject xmlSchemaObject = (XmlSchemaObject)arrayList[j];
				if (xmlSchemaObject is XmlSchemaMinExclusiveFacet)
				{
					Write_XmlSchemaFacet("minExclusive", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaMaxInclusiveFacet)
				{
					Write_XmlSchemaFacet("maxInclusive", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaMaxExclusiveFacet)
				{
					Write_XmlSchemaFacet("maxExclusive", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaMinInclusiveFacet)
				{
					Write_XmlSchemaFacet("minInclusive", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaLengthFacet)
				{
					Write_XmlSchemaFacet("length", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaEnumerationFacet)
				{
					Write_XmlSchemaFacet("enumeration", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaMinLengthFacet)
				{
					Write_XmlSchemaFacet("minLength", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaPatternFacet)
				{
					Write_XmlSchemaFacet("pattern", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaTotalDigitsFacet)
				{
					Write_XmlSchemaFacet("totalDigits", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaMaxLengthFacet)
				{
					Write_XmlSchemaFacet("maxLength", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaWhiteSpaceFacet)
				{
					Write_XmlSchemaFacet("whiteSpace", (XmlSchemaFacet)xmlSchemaObject);
				}
				else if (xmlSchemaObject is XmlSchemaFractionDigitsFacet)
				{
					Write_XmlSchemaFacet("fractionDigit", (XmlSchemaFacet)xmlSchemaObject);
				}
			}
		}

		private void Write_XmlSchemaFacet(string name, XmlSchemaFacet o)
		{
			if (o != null)
			{
				WriteStartElement(name);
				WriteAttribute("id", "", o.Id);
				WriteAttribute("value", "", o.Value);
				if (o.IsFixed)
				{
					WriteAttribute("fixed", "", XmlConvert.ToString(o.IsFixed));
				}
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				WriteEndElement();
			}
		}

		private string Write30_XmlSchemaUse(XmlSchemaUse v)
		{
			string result = null;
			switch (v)
			{
			case XmlSchemaUse.Optional:
				result = "optional";
				break;
			case XmlSchemaUse.Prohibited:
				result = "prohibited";
				break;
			case XmlSchemaUse.Required:
				result = "required";
				break;
			}
			return result;
		}

		private void Write31_XmlSchemaAttributeGroup(XmlSchemaAttributeGroup o)
		{
			if (o != null)
			{
				WriteStartElement("attributeGroup");
				WriteAttribute("id", "", o.Id);
				WriteAttribute("name", "", o.Name);
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				WriteSortedItems(o.Attributes);
				Write33_XmlSchemaAnyAttribute(o.AnyAttribute);
				WriteEndElement();
			}
		}

		private void Write32_XmlSchemaAttributeGroupRef(XmlSchemaAttributeGroupRef o)
		{
			if (o != null)
			{
				WriteStartElement("attributeGroup");
				WriteAttribute("id", "", o.Id);
				if (!o.RefName.IsEmpty)
				{
					WriteAttribute("ref", "", o.RefName);
				}
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				WriteEndElement();
			}
		}

		private void Write33_XmlSchemaAnyAttribute(XmlSchemaAnyAttribute o)
		{
			if (o != null)
			{
				WriteStartElement("anyAttribute");
				WriteAttribute("id", "", o.Id);
				WriteAttribute("namespace", "", ToString(o.NamespaceList));
				XmlSchemaContentProcessing v = ((o.ProcessContents == XmlSchemaContentProcessing.None) ? XmlSchemaContentProcessing.Strict : o.ProcessContents);
				WriteAttribute("processContents", "", Write34_XmlSchemaContentProcessing(v));
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				WriteEndElement();
			}
		}

		private string Write34_XmlSchemaContentProcessing(XmlSchemaContentProcessing v)
		{
			string result = null;
			switch (v)
			{
			case XmlSchemaContentProcessing.Skip:
				result = "skip";
				break;
			case XmlSchemaContentProcessing.Lax:
				result = "lax";
				break;
			case XmlSchemaContentProcessing.Strict:
				result = "strict";
				break;
			}
			return result;
		}

		private void Write35_XmlSchemaComplexType(XmlSchemaComplexType o)
		{
			if (o != null)
			{
				WriteStartElement("complexType");
				WriteAttribute("id", "", o.Id);
				WriteAttribute("name", "", o.Name);
				WriteAttribute("final", "", Write11_XmlSchemaDerivationMethod(o.FinalResolved));
				if (o.IsAbstract)
				{
					WriteAttribute("abstract", "", XmlConvert.ToString(o.IsAbstract));
				}
				WriteAttribute("block", "", Write11_XmlSchemaDerivationMethod(o.BlockResolved));
				if (o.IsMixed)
				{
					WriteAttribute("mixed", "", XmlConvert.ToString(o.IsMixed));
				}
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				if (o.ContentModel is XmlSchemaComplexContent)
				{
					Write41_XmlSchemaComplexContent((XmlSchemaComplexContent)o.ContentModel);
				}
				else if (o.ContentModel is XmlSchemaSimpleContent)
				{
					Write36_XmlSchemaSimpleContent((XmlSchemaSimpleContent)o.ContentModel);
				}
				if (o.Particle is XmlSchemaSequence)
				{
					Write54_XmlSchemaSequence((XmlSchemaSequence)o.Particle);
				}
				else if (o.Particle is XmlSchemaGroupRef)
				{
					Write55_XmlSchemaGroupRef((XmlSchemaGroupRef)o.Particle);
				}
				else if (o.Particle is XmlSchemaChoice)
				{
					Write52_XmlSchemaChoice((XmlSchemaChoice)o.Particle);
				}
				else if (o.Particle is XmlSchemaAll)
				{
					Write43_XmlSchemaAll((XmlSchemaAll)o.Particle);
				}
				WriteSortedItems(o.Attributes);
				Write33_XmlSchemaAnyAttribute(o.AnyAttribute);
				WriteEndElement();
			}
		}

		private void Write36_XmlSchemaSimpleContent(XmlSchemaSimpleContent o)
		{
			if (o != null)
			{
				WriteStartElement("simpleContent");
				WriteAttribute("id", "", o.Id);
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				if (o.Content is XmlSchemaSimpleContentRestriction)
				{
					Write40_XmlSchemaSimpleContentRestriction((XmlSchemaSimpleContentRestriction)o.Content);
				}
				else if (o.Content is XmlSchemaSimpleContentExtension)
				{
					Write38_XmlSchemaSimpleContentExtension((XmlSchemaSimpleContentExtension)o.Content);
				}
				WriteEndElement();
			}
		}

		private void Write38_XmlSchemaSimpleContentExtension(XmlSchemaSimpleContentExtension o)
		{
			if (o != null)
			{
				WriteStartElement("extension");
				WriteAttribute("id", "", o.Id);
				WriteAttributes(o.UnhandledAttributes, o);
				if (!o.BaseTypeName.IsEmpty)
				{
					WriteAttribute("base", "", o.BaseTypeName);
				}
				Write5_XmlSchemaAnnotation(o.Annotation);
				WriteSortedItems(o.Attributes);
				Write33_XmlSchemaAnyAttribute(o.AnyAttribute);
				WriteEndElement();
			}
		}

		private void Write40_XmlSchemaSimpleContentRestriction(XmlSchemaSimpleContentRestriction o)
		{
			if (o != null)
			{
				WriteStartElement("restriction");
				WriteAttribute("id", "", o.Id);
				WriteAttributes(o.UnhandledAttributes, o);
				if (!o.BaseTypeName.IsEmpty)
				{
					WriteAttribute("base", "", o.BaseTypeName);
				}
				Write5_XmlSchemaAnnotation(o.Annotation);
				Write9_XmlSchemaSimpleType(o.BaseType);
				WriteFacets(o.Facets);
				WriteSortedItems(o.Attributes);
				Write33_XmlSchemaAnyAttribute(o.AnyAttribute);
				WriteEndElement();
			}
		}

		private void Write41_XmlSchemaComplexContent(XmlSchemaComplexContent o)
		{
			if (o != null)
			{
				WriteStartElement("complexContent");
				WriteAttribute("id", "", o.Id);
				WriteAttribute("mixed", "", XmlConvert.ToString(o.IsMixed));
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				if (o.Content is XmlSchemaComplexContentRestriction)
				{
					Write56_XmlSchemaComplexContentRestriction((XmlSchemaComplexContentRestriction)o.Content);
				}
				else if (o.Content is XmlSchemaComplexContentExtension)
				{
					Write42_XmlSchemaComplexContentExtension((XmlSchemaComplexContentExtension)o.Content);
				}
				WriteEndElement();
			}
		}

		private void Write42_XmlSchemaComplexContentExtension(XmlSchemaComplexContentExtension o)
		{
			if (o != null)
			{
				WriteStartElement("extension");
				WriteAttribute("id", "", o.Id);
				WriteAttributes(o.UnhandledAttributes, o);
				if (!o.BaseTypeName.IsEmpty)
				{
					WriteAttribute("base", "", o.BaseTypeName);
				}
				Write5_XmlSchemaAnnotation(o.Annotation);
				if (o.Particle is XmlSchemaSequence)
				{
					Write54_XmlSchemaSequence((XmlSchemaSequence)o.Particle);
				}
				else if (o.Particle is XmlSchemaGroupRef)
				{
					Write55_XmlSchemaGroupRef((XmlSchemaGroupRef)o.Particle);
				}
				else if (o.Particle is XmlSchemaChoice)
				{
					Write52_XmlSchemaChoice((XmlSchemaChoice)o.Particle);
				}
				else if (o.Particle is XmlSchemaAll)
				{
					Write43_XmlSchemaAll((XmlSchemaAll)o.Particle);
				}
				WriteSortedItems(o.Attributes);
				Write33_XmlSchemaAnyAttribute(o.AnyAttribute);
				WriteEndElement();
			}
		}

		private void Write43_XmlSchemaAll(XmlSchemaAll o)
		{
			if (o != null)
			{
				WriteStartElement("all");
				WriteAttribute("id", "", o.Id);
				WriteAttribute("minOccurs", "", XmlConvert.ToString(o.MinOccurs));
				WriteAttribute("maxOccurs", "", (o.MaxOccurs == decimal.MaxValue) ? "unbounded" : XmlConvert.ToString(o.MaxOccurs));
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				WriteSortedItems(o.Items);
				WriteEndElement();
			}
		}

		private void Write46_XmlSchemaElement(XmlSchemaElement o)
		{
			if (o == null)
			{
				return;
			}
			o.GetType();
			WriteStartElement("element");
			WriteAttribute("id", "", o.Id);
			WriteAttribute("minOccurs", "", XmlConvert.ToString(o.MinOccurs));
			WriteAttribute("maxOccurs", "", (o.MaxOccurs == decimal.MaxValue) ? "unbounded" : XmlConvert.ToString(o.MaxOccurs));
			if (o.IsAbstract)
			{
				WriteAttribute("abstract", "", XmlConvert.ToString(o.IsAbstract));
			}
			WriteAttribute("block", "", Write11_XmlSchemaDerivationMethod(o.BlockResolved));
			WriteAttribute("default", "", o.DefaultValue);
			WriteAttribute("final", "", Write11_XmlSchemaDerivationMethod(o.FinalResolved));
			WriteAttribute("fixed", "", o.FixedValue);
			if (o.Parent != null && !(o.Parent is XmlSchema))
			{
				if (o.QualifiedName != null && !o.QualifiedName.IsEmpty && o.QualifiedName.Namespace != null && o.QualifiedName.Namespace.Length != 0)
				{
					WriteAttribute("form", "", "qualified");
				}
				else
				{
					WriteAttribute("form", "", "unqualified");
				}
			}
			if (o.Name != null && o.Name.Length != 0)
			{
				WriteAttribute("name", "", o.Name);
			}
			if (o.IsNillable)
			{
				WriteAttribute("nillable", "", XmlConvert.ToString(o.IsNillable));
			}
			if (!o.SubstitutionGroup.IsEmpty)
			{
				WriteAttribute("substitutionGroup", "", o.SubstitutionGroup);
			}
			if (!o.RefName.IsEmpty)
			{
				WriteAttribute("ref", "", o.RefName);
			}
			else if (!o.SchemaTypeName.IsEmpty)
			{
				WriteAttribute("type", "", o.SchemaTypeName);
			}
			WriteAttributes(o.UnhandledAttributes, o);
			Write5_XmlSchemaAnnotation(o.Annotation);
			if (o.SchemaType is XmlSchemaComplexType)
			{
				Write35_XmlSchemaComplexType((XmlSchemaComplexType)o.SchemaType);
			}
			else if (o.SchemaType is XmlSchemaSimpleType)
			{
				Write9_XmlSchemaSimpleType((XmlSchemaSimpleType)o.SchemaType);
			}
			WriteSortedItems(o.Constraints);
			WriteEndElement();
		}

		private void Write47_XmlSchemaKey(XmlSchemaKey o)
		{
			if (o == null)
			{
				return;
			}
			o.GetType();
			WriteStartElement("key");
			WriteAttribute("id", "", o.Id);
			WriteAttribute("name", "", o.Name);
			WriteAttributes(o.UnhandledAttributes, o);
			Write5_XmlSchemaAnnotation(o.Annotation);
			Write49_XmlSchemaXPath("selector", "", o.Selector);
			XmlSchemaObjectCollection fields = o.Fields;
			if (fields != null)
			{
				for (int i = 0; i < fields.Count; i++)
				{
					Write49_XmlSchemaXPath("field", "", (XmlSchemaXPath)fields[i]);
				}
			}
			WriteEndElement();
		}

		private void Write48_XmlSchemaIdentityConstraint(XmlSchemaIdentityConstraint o)
		{
			if (o != null)
			{
				Type type = o.GetType();
				if (type == typeof(XmlSchemaUnique))
				{
					Write51_XmlSchemaUnique((XmlSchemaUnique)o);
				}
				else if (type == typeof(XmlSchemaKeyref))
				{
					Write50_XmlSchemaKeyref((XmlSchemaKeyref)o);
				}
				else if (type == typeof(XmlSchemaKey))
				{
					Write47_XmlSchemaKey((XmlSchemaKey)o);
				}
			}
		}

		private void Write49_XmlSchemaXPath(string name, string ns, XmlSchemaXPath o)
		{
			if (o != null)
			{
				WriteStartElement(name);
				WriteAttribute("id", "", o.Id);
				WriteAttribute("xpath", "", o.XPath);
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				WriteEndElement();
			}
		}

		private void Write50_XmlSchemaKeyref(XmlSchemaKeyref o)
		{
			if (o == null)
			{
				return;
			}
			o.GetType();
			WriteStartElement("keyref");
			WriteAttribute("id", "", o.Id);
			WriteAttribute("name", "", o.Name);
			WriteAttributes(o.UnhandledAttributes, o);
			WriteAttribute("refer", "", o.Refer);
			Write5_XmlSchemaAnnotation(o.Annotation);
			Write49_XmlSchemaXPath("selector", "", o.Selector);
			XmlSchemaObjectCollection fields = o.Fields;
			if (fields != null)
			{
				for (int i = 0; i < fields.Count; i++)
				{
					Write49_XmlSchemaXPath("field", "", (XmlSchemaXPath)fields[i]);
				}
			}
			WriteEndElement();
		}

		private void Write51_XmlSchemaUnique(XmlSchemaUnique o)
		{
			if (o == null)
			{
				return;
			}
			o.GetType();
			WriteStartElement("unique");
			WriteAttribute("id", "", o.Id);
			WriteAttribute("name", "", o.Name);
			WriteAttributes(o.UnhandledAttributes, o);
			Write5_XmlSchemaAnnotation(o.Annotation);
			Write49_XmlSchemaXPath("selector", "", o.Selector);
			XmlSchemaObjectCollection fields = o.Fields;
			if (fields != null)
			{
				for (int i = 0; i < fields.Count; i++)
				{
					Write49_XmlSchemaXPath("field", "", (XmlSchemaXPath)fields[i]);
				}
			}
			WriteEndElement();
		}

		private void Write52_XmlSchemaChoice(XmlSchemaChoice o)
		{
			if (o != null)
			{
				o.GetType();
				WriteStartElement("choice");
				WriteAttribute("id", "", o.Id);
				WriteAttribute("minOccurs", "", XmlConvert.ToString(o.MinOccurs));
				WriteAttribute("maxOccurs", "", (o.MaxOccurs == decimal.MaxValue) ? "unbounded" : XmlConvert.ToString(o.MaxOccurs));
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				WriteSortedItems(o.Items);
				WriteEndElement();
			}
		}

		private void Write53_XmlSchemaAny(XmlSchemaAny o)
		{
			if (o != null)
			{
				WriteStartElement("any");
				WriteAttribute("id", "", o.Id);
				WriteAttribute("minOccurs", "", XmlConvert.ToString(o.MinOccurs));
				WriteAttribute("maxOccurs", "", (o.MaxOccurs == decimal.MaxValue) ? "unbounded" : XmlConvert.ToString(o.MaxOccurs));
				WriteAttribute("namespace", "", ToString(o.NamespaceList));
				XmlSchemaContentProcessing v = ((o.ProcessContents == XmlSchemaContentProcessing.None) ? XmlSchemaContentProcessing.Strict : o.ProcessContents);
				WriteAttribute("processContents", "", Write34_XmlSchemaContentProcessing(v));
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				WriteEndElement();
			}
		}

		private void Write54_XmlSchemaSequence(XmlSchemaSequence o)
		{
			if (o == null)
			{
				return;
			}
			WriteStartElement("sequence");
			WriteAttribute("id", "", o.Id);
			WriteAttribute("minOccurs", "", XmlConvert.ToString(o.MinOccurs));
			WriteAttribute("maxOccurs", "", (o.MaxOccurs == decimal.MaxValue) ? "unbounded" : XmlConvert.ToString(o.MaxOccurs));
			WriteAttributes(o.UnhandledAttributes, o);
			Write5_XmlSchemaAnnotation(o.Annotation);
			XmlSchemaObjectCollection items = o.Items;
			if (items != null)
			{
				for (int i = 0; i < items.Count; i++)
				{
					XmlSchemaObject xmlSchemaObject = items[i];
					if (xmlSchemaObject is XmlSchemaAny)
					{
						Write53_XmlSchemaAny((XmlSchemaAny)xmlSchemaObject);
					}
					else if (xmlSchemaObject is XmlSchemaSequence)
					{
						Write54_XmlSchemaSequence((XmlSchemaSequence)xmlSchemaObject);
					}
					else if (xmlSchemaObject is XmlSchemaChoice)
					{
						Write52_XmlSchemaChoice((XmlSchemaChoice)xmlSchemaObject);
					}
					else if (xmlSchemaObject is XmlSchemaElement)
					{
						Write46_XmlSchemaElement((XmlSchemaElement)xmlSchemaObject);
					}
					else if (xmlSchemaObject is XmlSchemaGroupRef)
					{
						Write55_XmlSchemaGroupRef((XmlSchemaGroupRef)xmlSchemaObject);
					}
				}
			}
			WriteEndElement();
		}

		private void Write55_XmlSchemaGroupRef(XmlSchemaGroupRef o)
		{
			if (o != null)
			{
				WriteStartElement("group");
				WriteAttribute("id", "", o.Id);
				WriteAttribute("minOccurs", "", XmlConvert.ToString(o.MinOccurs));
				WriteAttribute("maxOccurs", "", (o.MaxOccurs == decimal.MaxValue) ? "unbounded" : XmlConvert.ToString(o.MaxOccurs));
				if (!o.RefName.IsEmpty)
				{
					WriteAttribute("ref", "", o.RefName);
				}
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				WriteEndElement();
			}
		}

		private void Write56_XmlSchemaComplexContentRestriction(XmlSchemaComplexContentRestriction o)
		{
			if (o != null)
			{
				WriteStartElement("restriction");
				WriteAttribute("id", "", o.Id);
				WriteAttributes(o.UnhandledAttributes, o);
				if (!o.BaseTypeName.IsEmpty)
				{
					WriteAttribute("base", "", o.BaseTypeName);
				}
				Write5_XmlSchemaAnnotation(o.Annotation);
				if (o.Particle is XmlSchemaSequence)
				{
					Write54_XmlSchemaSequence((XmlSchemaSequence)o.Particle);
				}
				else if (o.Particle is XmlSchemaGroupRef)
				{
					Write55_XmlSchemaGroupRef((XmlSchemaGroupRef)o.Particle);
				}
				else if (o.Particle is XmlSchemaChoice)
				{
					Write52_XmlSchemaChoice((XmlSchemaChoice)o.Particle);
				}
				else if (o.Particle is XmlSchemaAll)
				{
					Write43_XmlSchemaAll((XmlSchemaAll)o.Particle);
				}
				WriteSortedItems(o.Attributes);
				Write33_XmlSchemaAnyAttribute(o.AnyAttribute);
				WriteEndElement();
			}
		}

		private void Write57_XmlSchemaGroup(XmlSchemaGroup o)
		{
			if (o != null)
			{
				WriteStartElement("group");
				WriteAttribute("id", "", o.Id);
				WriteAttribute("name", "", o.Name);
				WriteAttributes(o.UnhandledAttributes, o);
				Write5_XmlSchemaAnnotation(o.Annotation);
				if (o.Particle is XmlSchemaSequence)
				{
					Write54_XmlSchemaSequence((XmlSchemaSequence)o.Particle);
				}
				else if (o.Particle is XmlSchemaChoice)
				{
					Write52_XmlSchemaChoice((XmlSchemaChoice)o.Particle);
				}
				else if (o.Particle is XmlSchemaAll)
				{
					Write43_XmlSchemaAll((XmlSchemaAll)o.Particle);
				}
				WriteEndElement();
			}
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
	public class SoapAttributeAttribute : Attribute
	{
		private string attributeName;

		private string ns;

		private string dataType;

		public string AttributeName
		{
			get
			{
				if (attributeName != null)
				{
					return attributeName;
				}
				return string.Empty;
			}
			set
			{
				attributeName = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		public string DataType
		{
			get
			{
				if (dataType != null)
				{
					return dataType;
				}
				return string.Empty;
			}
			set
			{
				dataType = value;
			}
		}

		public SoapAttributeAttribute()
		{
		}

		public SoapAttributeAttribute(string attributeName)
		{
			this.attributeName = attributeName;
		}
	}
	public class SoapAttributeOverrides
	{
		private Hashtable types = new Hashtable();

		public SoapAttributes this[Type type] => this[type, string.Empty];

		public SoapAttributes this[Type type, string member]
		{
			get
			{
				Hashtable hashtable = (Hashtable)types[type];
				if (hashtable == null)
				{
					return null;
				}
				return (SoapAttributes)hashtable[member];
			}
		}

		public void Add(Type type, SoapAttributes attributes)
		{
			Add(type, string.Empty, attributes);
		}

		public void Add(Type type, string member, SoapAttributes attributes)
		{
			Hashtable hashtable = (Hashtable)types[type];
			if (hashtable == null)
			{
				hashtable = new Hashtable();
				types.Add(type, hashtable);
			}
			else if (hashtable[member] != null)
			{
				throw new InvalidOperationException(Res.GetString("XmlMultipleAttributeOverrides", type.FullName, member));
			}
			hashtable.Add(member, attributes);
		}
	}
	internal enum SoapAttributeFlags
	{
		Enum = 1,
		Type = 2,
		Element = 4,
		Attribute = 8
	}
	public class SoapAttributes
	{
		private bool soapIgnore;

		private SoapTypeAttribute soapType;

		private SoapElementAttribute soapElement;

		private SoapAttributeAttribute soapAttribute;

		private SoapEnumAttribute soapEnum;

		private object soapDefaultValue;

		internal SoapAttributeFlags SoapFlags
		{
			get
			{
				SoapAttributeFlags soapAttributeFlags = (SoapAttributeFlags)0;
				if (soapElement != null)
				{
					soapAttributeFlags |= SoapAttributeFlags.Element;
				}
				if (soapAttribute != null)
				{
					soapAttributeFlags |= SoapAttributeFlags.Attribute;
				}
				if (soapEnum != null)
				{
					soapAttributeFlags |= SoapAttributeFlags.Enum;
				}
				if (soapType != null)
				{
					soapAttributeFlags |= SoapAttributeFlags.Type;
				}
				return soapAttributeFlags;
			}
		}

		public SoapTypeAttribute SoapType
		{
			get
			{
				return soapType;
			}
			set
			{
				soapType = value;
			}
		}

		public SoapEnumAttribute SoapEnum
		{
			get
			{
				return soapEnum;
			}
			set
			{
				soapEnum = value;
			}
		}

		public bool SoapIgnore
		{
			get
			{
				return soapIgnore;
			}
			set
			{
				soapIgnore = value;
			}
		}

		public SoapElementAttribute SoapElement
		{
			get
			{
				return soapElement;
			}
			set
			{
				soapElement = value;
			}
		}

		public SoapAttributeAttribute SoapAttribute
		{
			get
			{
				return soapAttribute;
			}
			set
			{
				soapAttribute = value;
			}
		}

		public object SoapDefaultValue
		{
			get
			{
				return soapDefaultValue;
			}
			set
			{
				soapDefaultValue = value;
			}
		}

		public SoapAttributes()
		{
		}

		public SoapAttributes(ICustomAttributeProvider provider)
		{
			object[] customAttributes = provider.GetCustomAttributes(inherit: false);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				if (customAttributes[i] is SoapIgnoreAttribute || customAttributes[i] is ObsoleteAttribute)
				{
					soapIgnore = true;
					break;
				}
				if (customAttributes[i] is SoapElementAttribute)
				{
					soapElement = (SoapElementAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is SoapAttributeAttribute)
				{
					soapAttribute = (SoapAttributeAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is SoapTypeAttribute)
				{
					soapType = (SoapTypeAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is SoapEnumAttribute)
				{
					soapEnum = (SoapEnumAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is DefaultValueAttribute)
				{
					soapDefaultValue = ((DefaultValueAttribute)customAttributes[i]).Value;
				}
			}
			if (soapIgnore)
			{
				soapElement = null;
				soapAttribute = null;
				soapType = null;
				soapEnum = null;
				soapDefaultValue = null;
			}
		}
	}
	public class SoapCodeExporter : CodeExporter
	{
		public SoapCodeExporter(CodeNamespace codeNamespace)
			: base(codeNamespace, null, null, CodeGenerationOptions.GenerateProperties, null)
		{
		}

		public SoapCodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit)
			: base(codeNamespace, codeCompileUnit, null, CodeGenerationOptions.GenerateProperties, null)
		{
		}

		public SoapCodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit, CodeGenerationOptions options)
			: base(codeNamespace, codeCompileUnit, null, CodeGenerationOptions.GenerateProperties, null)
		{
		}

		public SoapCodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit, CodeGenerationOptions options, Hashtable mappings)
			: base(codeNamespace, codeCompileUnit, null, options, mappings)
		{
		}

		public SoapCodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit, CodeDomProvider codeProvider, CodeGenerationOptions options, Hashtable mappings)
			: base(codeNamespace, codeCompileUnit, codeProvider, options, mappings)
		{
		}

		public void ExportTypeMapping(XmlTypeMapping xmlTypeMapping)
		{
			xmlTypeMapping.CheckShallow();
			CheckScope(xmlTypeMapping.Scope);
			ExportElement(xmlTypeMapping.Accessor);
		}

		public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping)
		{
			xmlMembersMapping.CheckShallow();
			CheckScope(xmlMembersMapping.Scope);
			for (int i = 0; i < xmlMembersMapping.Count; i++)
			{
				ExportElement((ElementAccessor)xmlMembersMapping[i].Accessor);
			}
		}

		private void ExportElement(ElementAccessor element)
		{
			ExportType(element.Mapping);
		}

		private void ExportType(TypeMapping mapping)
		{
			if (mapping.IsReference || base.ExportedMappings[mapping] != null)
			{
				return;
			}
			CodeTypeDeclaration codeTypeDeclaration = null;
			base.ExportedMappings.Add(mapping, mapping);
			if (mapping is EnumMapping)
			{
				codeTypeDeclaration = ExportEnum((EnumMapping)mapping, typeof(SoapEnumAttribute));
			}
			else if (mapping is StructMapping)
			{
				codeTypeDeclaration = ExportStruct((StructMapping)mapping);
			}
			else if (mapping is ArrayMapping)
			{
				EnsureTypesExported(((ArrayMapping)mapping).Elements, null);
			}
			if (codeTypeDeclaration != null)
			{
				codeTypeDeclaration.CustomAttributes.Add(base.GeneratedCodeAttribute);
				codeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(SerializableAttribute).FullName));
				if (!codeTypeDeclaration.IsEnum)
				{
					codeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DebuggerStepThroughAttribute).FullName));
					codeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DesignerCategoryAttribute).FullName, new CodeAttributeArgument(new CodePrimitiveExpression("code"))));
				}
				AddTypeMetadata(codeTypeDeclaration.CustomAttributes, typeof(SoapTypeAttribute), mapping.TypeDesc.Name, Accessor.UnescapeName(mapping.TypeName), mapping.Namespace, mapping.IncludeInSchema);
				base.ExportedClasses.Add(mapping, codeTypeDeclaration);
			}
		}

		private CodeTypeDeclaration ExportStruct(StructMapping mapping)
		{
			if (mapping.TypeDesc.IsRoot)
			{
				ExportRoot(mapping, typeof(SoapIncludeAttribute));
				return null;
			}
			if (!mapping.IncludeInSchema)
			{
				return null;
			}
			string name = mapping.TypeDesc.Name;
			string text = ((mapping.TypeDesc.BaseTypeDesc == null) ? string.Empty : mapping.TypeDesc.BaseTypeDesc.Name);
			CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration(name);
			codeTypeDeclaration.IsPartial = base.CodeProvider.Supports(GeneratorSupport.PartialTypes);
			codeTypeDeclaration.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
			base.CodeNamespace.Types.Add(codeTypeDeclaration);
			if (text != null && text.Length > 0)
			{
				codeTypeDeclaration.BaseTypes.Add(text);
			}
			else
			{
				AddPropertyChangedNotifier(codeTypeDeclaration);
			}
			codeTypeDeclaration.TypeAttributes |= TypeAttributes.Public;
			if (mapping.TypeDesc.IsAbstract)
			{
				codeTypeDeclaration.TypeAttributes |= TypeAttributes.Abstract;
			}
			CodeExporter.AddIncludeMetadata(codeTypeDeclaration.CustomAttributes, mapping, typeof(SoapIncludeAttribute));
			if (base.GenerateProperties)
			{
				for (int i = 0; i < mapping.Members.Length; i++)
				{
					ExportProperty(codeTypeDeclaration, mapping.Members[i], mapping.Scope);
				}
			}
			else
			{
				for (int j = 0; j < mapping.Members.Length; j++)
				{
					ExportMember(codeTypeDeclaration, mapping.Members[j]);
				}
			}
			for (int k = 0; k < mapping.Members.Length; k++)
			{
				EnsureTypesExported(mapping.Members[k].Elements, null);
			}
			if (mapping.BaseMapping != null)
			{
				ExportType(mapping.BaseMapping);
			}
			ExportDerivedStructs(mapping);
			CodeGenerator.ValidateIdentifiers(codeTypeDeclaration);
			return codeTypeDeclaration;
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		internal override void ExportDerivedStructs(StructMapping mapping)
		{
			for (StructMapping structMapping = mapping.DerivedMappings; structMapping != null; structMapping = structMapping.NextDerivedMapping)
			{
				ExportType(structMapping);
			}
		}

		public void AddMappingMetadata(CodeAttributeDeclarationCollection metadata, XmlMemberMapping member, bool forceUseMemberName)
		{
			AddMemberMetadata(metadata, member.Mapping, forceUseMemberName);
		}

		public void AddMappingMetadata(CodeAttributeDeclarationCollection metadata, XmlMemberMapping member)
		{
			AddMemberMetadata(metadata, member.Mapping, forceUseMemberName: false);
		}

		private void AddElementMetadata(CodeAttributeDeclarationCollection metadata, string elementName, TypeDesc typeDesc, bool isNullable)
		{
			CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(typeof(SoapElementAttribute).FullName);
			if (elementName != null)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(elementName)));
			}
			if (typeDesc != null && typeDesc.IsAmbiguousDataType)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("DataType", new CodePrimitiveExpression(typeDesc.DataType.Name)));
			}
			if (isNullable)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("IsNullable", new CodePrimitiveExpression(true)));
			}
			metadata.Add(codeAttributeDeclaration);
		}

		private void AddMemberMetadata(CodeAttributeDeclarationCollection metadata, MemberMapping member, bool forceUseMemberName)
		{
			if (member.Elements.Length != 0)
			{
				ElementAccessor elementAccessor = member.Elements[0];
				TypeMapping mapping = elementAccessor.Mapping;
				string text = Accessor.UnescapeName(elementAccessor.Name);
				bool flag = text == member.Name && !forceUseMemberName;
				if (!flag || mapping.TypeDesc.IsAmbiguousDataType || elementAccessor.IsNullable)
				{
					AddElementMetadata(metadata, flag ? null : text, mapping.TypeDesc.IsAmbiguousDataType ? mapping.TypeDesc : null, elementAccessor.IsNullable);
				}
			}
		}

		private void ExportMember(CodeTypeDeclaration codeClass, MemberMapping member)
		{
			string typeName = member.GetTypeName(base.CodeProvider);
			CodeMemberField codeMemberField = new CodeMemberField(typeName, member.Name);
			codeMemberField.Attributes = (codeMemberField.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
			codeMemberField.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
			codeClass.Members.Add(codeMemberField);
			AddMemberMetadata(codeMemberField.CustomAttributes, member, forceUseMemberName: false);
			if (member.CheckSpecified != 0)
			{
				codeMemberField = new CodeMemberField(typeof(bool).FullName, member.Name + "Specified");
				codeMemberField.Attributes = (codeMemberField.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
				codeMemberField.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
				CodeAttributeDeclaration value = new CodeAttributeDeclaration(typeof(SoapIgnoreAttribute).FullName);
				codeMemberField.CustomAttributes.Add(value);
				codeClass.Members.Add(codeMemberField);
			}
		}

		private void ExportProperty(CodeTypeDeclaration codeClass, MemberMapping member, CodeIdentifiers memberScope)
		{
			string text = memberScope.AddUnique(CodeExporter.MakeFieldName(member.Name), member);
			string typeName = member.GetTypeName(base.CodeProvider);
			CodeMemberField codeMemberField = new CodeMemberField(typeName, text);
			codeMemberField.Attributes = MemberAttributes.Private;
			codeClass.Members.Add(codeMemberField);
			CodeMemberProperty codeMemberProperty = CreatePropertyDeclaration(codeMemberField, member.Name, typeName);
			codeMemberProperty.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
			AddMemberMetadata(codeMemberProperty.CustomAttributes, member, forceUseMemberName: false);
			codeClass.Members.Add(codeMemberProperty);
			if (member.CheckSpecified != 0)
			{
				codeMemberField = new CodeMemberField(typeof(bool).FullName, text + "Specified");
				codeMemberField.Attributes = MemberAttributes.Private;
				codeClass.Members.Add(codeMemberField);
				codeMemberProperty = CreatePropertyDeclaration(codeMemberField, member.Name + "Specified", typeof(bool).FullName);
				codeMemberProperty.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
				CodeAttributeDeclaration value = new CodeAttributeDeclaration(typeof(SoapIgnoreAttribute).FullName);
				codeMemberProperty.CustomAttributes.Add(value);
				codeClass.Members.Add(codeMemberProperty);
			}
		}

		internal override void EnsureTypesExported(Accessor[] accessors, string ns)
		{
			if (accessors != null)
			{
				for (int i = 0; i < accessors.Length; i++)
				{
					ExportType(accessors[i].Mapping);
				}
			}
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
	public class SoapElementAttribute : Attribute
	{
		private string elementName;

		private string dataType;

		private bool nullable;

		public string ElementName
		{
			get
			{
				if (elementName != null)
				{
					return elementName;
				}
				return string.Empty;
			}
			set
			{
				elementName = value;
			}
		}

		public string DataType
		{
			get
			{
				if (dataType != null)
				{
					return dataType;
				}
				return string.Empty;
			}
			set
			{
				dataType = value;
			}
		}

		public bool IsNullable
		{
			get
			{
				return nullable;
			}
			set
			{
				nullable = value;
			}
		}

		public SoapElementAttribute()
		{
		}

		public SoapElementAttribute(string elementName)
		{
			this.elementName = elementName;
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	public class SoapEnumAttribute : Attribute
	{
		private string name;

		public string Name
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		public SoapEnumAttribute()
		{
		}

		public SoapEnumAttribute(string name)
		{
			this.name = name;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
	public class SoapIgnoreAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Interface, AllowMultiple = true)]
	public class SoapIncludeAttribute : Attribute
	{
		private Type type;

		public Type Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public SoapIncludeAttribute(Type type)
		{
			this.type = type;
		}
	}
	public class SoapReflectionImporter
	{
		private TypeScope typeScope;

		private SoapAttributeOverrides attributeOverrides;

		private NameTable types = new NameTable();

		private NameTable nullables = new NameTable();

		private StructMapping root;

		private string defaultNs;

		private ModelScope modelScope;

		public SoapReflectionImporter()
			: this(null, null)
		{
		}

		public SoapReflectionImporter(string defaultNamespace)
			: this(null, defaultNamespace)
		{
		}

		public SoapReflectionImporter(SoapAttributeOverrides attributeOverrides)
			: this(attributeOverrides, null)
		{
		}

		public SoapReflectionImporter(SoapAttributeOverrides attributeOverrides, string defaultNamespace)
		{
			if (defaultNamespace == null)
			{
				defaultNamespace = string.Empty;
			}
			if (attributeOverrides == null)
			{
				attributeOverrides = new SoapAttributeOverrides();
			}
			this.attributeOverrides = attributeOverrides;
			defaultNs = defaultNamespace;
			typeScope = new TypeScope();
			modelScope = new ModelScope(typeScope);
		}

		public void IncludeTypes(ICustomAttributeProvider provider)
		{
			IncludeTypes(provider, new RecursionLimiter());
		}

		private void IncludeTypes(ICustomAttributeProvider provider, RecursionLimiter limiter)
		{
			object[] customAttributes = provider.GetCustomAttributes(typeof(SoapIncludeAttribute), inherit: false);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				IncludeType(((SoapIncludeAttribute)customAttributes[i]).Type, limiter);
			}
		}

		public void IncludeType(Type type)
		{
			IncludeType(type, new RecursionLimiter());
		}

		private void IncludeType(Type type, RecursionLimiter limiter)
		{
			ImportTypeMapping(modelScope.GetTypeModel(type), limiter);
		}

		public XmlTypeMapping ImportTypeMapping(Type type)
		{
			return ImportTypeMapping(type, null);
		}

		public XmlTypeMapping ImportTypeMapping(Type type, string defaultNamespace)
		{
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.IsSoap = true;
			elementAccessor.Mapping = ImportTypeMapping(modelScope.GetTypeModel(type), new RecursionLimiter());
			elementAccessor.Name = elementAccessor.Mapping.DefaultElementName;
			elementAccessor.Namespace = ((elementAccessor.Mapping.Namespace == null) ? defaultNamespace : elementAccessor.Mapping.Namespace);
			elementAccessor.Form = XmlSchemaForm.Qualified;
			XmlTypeMapping xmlTypeMapping = new XmlTypeMapping(typeScope, elementAccessor);
			xmlTypeMapping.SetKeyInternal(XmlMapping.GenerateKey(type, null, defaultNamespace));
			xmlTypeMapping.IsSoap = true;
			xmlTypeMapping.GenerateSerializer = true;
			return xmlTypeMapping;
		}

		public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members)
		{
			return ImportMembersMapping(elementName, ns, members, hasWrapperElement: true, writeAccessors: true, validate: false);
		}

		public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool writeAccessors)
		{
			return ImportMembersMapping(elementName, ns, members, hasWrapperElement, writeAccessors, validate: false);
		}

		public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool writeAccessors, bool validate)
		{
			return ImportMembersMapping(elementName, ns, members, hasWrapperElement, writeAccessors, validate, XmlMappingAccess.Read | XmlMappingAccess.Write);
		}

		public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool writeAccessors, bool validate, XmlMappingAccess access)
		{
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.IsSoap = true;
			elementAccessor.Name = ((elementName == null || elementName.Length == 0) ? elementName : XmlConvert.EncodeLocalName(elementName));
			elementAccessor.Mapping = ImportMembersMapping(members, ns, hasWrapperElement, writeAccessors, validate, new RecursionLimiter());
			elementAccessor.Mapping.TypeName = elementName;
			elementAccessor.Namespace = ((elementAccessor.Mapping.Namespace == null) ? ns : elementAccessor.Mapping.Namespace);
			elementAccessor.Form = XmlSchemaForm.Qualified;
			XmlMembersMapping xmlMembersMapping = new XmlMembersMapping(typeScope, elementAccessor, access);
			xmlMembersMapping.IsSoap = true;
			xmlMembersMapping.GenerateSerializer = true;
			return xmlMembersMapping;
		}

		private Exception ReflectionException(string context, Exception e)
		{
			return new InvalidOperationException(Res.GetString("XmlReflectionError", context), e);
		}

		private SoapAttributes GetAttributes(Type type)
		{
			SoapAttributes soapAttributes = attributeOverrides[type];
			if (soapAttributes != null)
			{
				return soapAttributes;
			}
			return new SoapAttributes(type);
		}

		private SoapAttributes GetAttributes(MemberInfo memberInfo)
		{
			SoapAttributes soapAttributes = attributeOverrides[memberInfo.DeclaringType, memberInfo.Name];
			if (soapAttributes != null)
			{
				return soapAttributes;
			}
			return new SoapAttributes(memberInfo);
		}

		private TypeMapping ImportTypeMapping(TypeModel model, RecursionLimiter limiter)
		{
			return ImportTypeMapping(model, string.Empty, limiter);
		}

		private TypeMapping ImportTypeMapping(TypeModel model, string dataType, RecursionLimiter limiter)
		{
			if (dataType.Length > 0)
			{
				if (!model.TypeDesc.IsPrimitive)
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidDataTypeUsage", dataType, "SoapElementAttribute.DataType"));
				}
				TypeDesc typeDesc = typeScope.GetTypeDesc(dataType, "http://www.w3.org/2001/XMLSchema");
				if (typeDesc == null)
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidXsdDataType", dataType, "SoapElementAttribute.DataType", new XmlQualifiedName(dataType, "http://www.w3.org/2001/XMLSchema").ToString()));
				}
				if (model.TypeDesc.FullName != typeDesc.FullName)
				{
					throw new InvalidOperationException(Res.GetString("XmlDataTypeMismatch", dataType, "SoapElementAttribute.DataType", model.TypeDesc.FullName));
				}
			}
			SoapAttributes attributes = GetAttributes(model.Type);
			if (((uint)attributes.SoapFlags & 0xFFFFFFFDu) != 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidTypeAttributes", model.Type.FullName));
			}
			switch (model.TypeDesc.Kind)
			{
			case TypeKind.Enum:
				return ImportEnumMapping((EnumModel)model);
			case TypeKind.Primitive:
				return ImportPrimitiveMapping((PrimitiveModel)model, dataType);
			case TypeKind.Array:
			case TypeKind.Collection:
			case TypeKind.Enumerable:
				return ImportArrayLikeMapping((ArrayModel)model, limiter);
			case TypeKind.Root:
			case TypeKind.Struct:
			case TypeKind.Class:
				if (model.TypeDesc.IsOptionalValue)
				{
					TypeDesc baseTypeDesc = model.TypeDesc.BaseTypeDesc;
					SoapAttributes attributes2 = GetAttributes(baseTypeDesc.Type);
					string @namespace = defaultNs;
					if (attributes2.SoapType != null && attributes2.SoapType.Namespace != null)
					{
						@namespace = attributes2.SoapType.Namespace;
					}
					TypeDesc typeDesc2 = (string.IsNullOrEmpty(dataType) ? model.TypeDesc.BaseTypeDesc : typeScope.GetTypeDesc(dataType, "http://www.w3.org/2001/XMLSchema"));
					string typeName = (string.IsNullOrEmpty(dataType) ? model.TypeDesc.BaseTypeDesc.Name : dataType);
					TypeMapping typeMapping = GetTypeMapping(typeName, @namespace, typeDesc2);
					if (typeMapping == null)
					{
						typeMapping = ImportTypeMapping(modelScope.GetTypeModel(baseTypeDesc.Type), dataType, limiter);
					}
					return CreateNullableMapping(typeMapping, model.TypeDesc.Type);
				}
				return ImportStructLikeMapping((StructModel)model, limiter);
			default:
				throw new NotSupportedException(Res.GetString("XmlUnsupportedSoapTypeKind", model.TypeDesc.FullName));
			}
		}

		private StructMapping CreateRootMapping()
		{
			TypeDesc typeDesc = typeScope.GetTypeDesc(typeof(object));
			StructMapping structMapping = new StructMapping();
			structMapping.IsSoap = true;
			structMapping.TypeDesc = typeDesc;
			structMapping.Members = new MemberMapping[0];
			structMapping.IncludeInSchema = false;
			structMapping.TypeName = "anyType";
			structMapping.Namespace = "http://www.w3.org/2001/XMLSchema";
			return structMapping;
		}

		private StructMapping GetRootMapping()
		{
			if (root == null)
			{
				root = CreateRootMapping();
				typeScope.AddTypeMapping(root);
			}
			return root;
		}

		private TypeMapping GetTypeMapping(string typeName, string ns, TypeDesc typeDesc)
		{
			TypeMapping typeMapping = (TypeMapping)types[typeName, ns];
			if (typeMapping == null)
			{
				return null;
			}
			if (typeMapping.TypeDesc != typeDesc)
			{
				throw new InvalidOperationException(Res.GetString("XmlTypesDuplicate", typeDesc.FullName, typeMapping.TypeDesc.FullName, typeName, ns));
			}
			return typeMapping;
		}

		private NullableMapping CreateNullableMapping(TypeMapping baseMapping, Type type)
		{
			TypeDesc nullableTypeDesc = baseMapping.TypeDesc.GetNullableTypeDesc(type);
			TypeMapping typeMapping = (TypeMapping)nullables[baseMapping.TypeName, baseMapping.Namespace];
			NullableMapping nullableMapping;
			if (typeMapping != null)
			{
				if (typeMapping is NullableMapping)
				{
					nullableMapping = (NullableMapping)typeMapping;
					if (nullableMapping.BaseMapping is PrimitiveMapping && baseMapping is PrimitiveMapping)
					{
						return nullableMapping;
					}
					if (nullableMapping.BaseMapping == baseMapping)
					{
						return nullableMapping;
					}
					throw new InvalidOperationException(Res.GetString("XmlTypesDuplicate", nullableTypeDesc.FullName, typeMapping.TypeDesc.FullName, nullableTypeDesc.Name, typeMapping.Namespace));
				}
				if (!(baseMapping is PrimitiveMapping))
				{
					throw new InvalidOperationException(Res.GetString("XmlTypesDuplicate", nullableTypeDesc.FullName, typeMapping.TypeDesc.FullName, nullableTypeDesc.Name, typeMapping.Namespace));
				}
			}
			nullableMapping = new NullableMapping();
			nullableMapping.BaseMapping = baseMapping;
			nullableMapping.TypeDesc = nullableTypeDesc;
			nullableMapping.TypeName = baseMapping.TypeName;
			nullableMapping.Namespace = baseMapping.Namespace;
			nullableMapping.IncludeInSchema = false;
			nullables.Add(baseMapping.TypeName, nullableMapping.Namespace, nullableMapping);
			typeScope.AddTypeMapping(nullableMapping);
			return nullableMapping;
		}

		private StructMapping ImportStructLikeMapping(StructModel model, RecursionLimiter limiter)
		{
			if (model.TypeDesc.Kind == TypeKind.Root)
			{
				return GetRootMapping();
			}
			SoapAttributes attributes = GetAttributes(model.Type);
			string @namespace = defaultNs;
			if (attributes.SoapType != null && attributes.SoapType.Namespace != null)
			{
				@namespace = attributes.SoapType.Namespace;
			}
			string name = XsdTypeName(model.Type, attributes, model.TypeDesc.Name);
			name = XmlConvert.EncodeLocalName(name);
			StructMapping structMapping = (StructMapping)GetTypeMapping(name, @namespace, model.TypeDesc);
			if (structMapping == null)
			{
				structMapping = new StructMapping();
				structMapping.IsSoap = true;
				structMapping.TypeDesc = model.TypeDesc;
				structMapping.Namespace = @namespace;
				structMapping.TypeName = name;
				if (attributes.SoapType != null)
				{
					structMapping.IncludeInSchema = attributes.SoapType.IncludeInSchema;
				}
				typeScope.AddTypeMapping(structMapping);
				types.Add(name, @namespace, structMapping);
				if (limiter.IsExceededLimit)
				{
					limiter.DeferredWorkItems.Add(new ImportStructWorkItem(model, structMapping));
					return structMapping;
				}
				limiter.Depth++;
				InitializeStructMembers(structMapping, model, limiter);
				while (limiter.DeferredWorkItems.Count > 0)
				{
					int index = limiter.DeferredWorkItems.Count - 1;
					ImportStructWorkItem importStructWorkItem = limiter.DeferredWorkItems[index];
					if (InitializeStructMembers(importStructWorkItem.Mapping, importStructWorkItem.Model, limiter))
					{
						limiter.DeferredWorkItems.RemoveAt(index);
					}
				}
				limiter.Depth--;
			}
			return structMapping;
		}

		private bool InitializeStructMembers(StructMapping mapping, StructModel model, RecursionLimiter limiter)
		{
			if (mapping.IsFullyInitialized)
			{
				return true;
			}
			if (model.TypeDesc.BaseTypeDesc != null)
			{
				StructMapping baseMapping = ImportStructLikeMapping((StructModel)modelScope.GetTypeModel(model.Type.BaseType, directReference: false), limiter);
				int num = limiter.DeferredWorkItems.IndexOf(mapping.BaseMapping);
				if (num >= 0)
				{
					if (!limiter.DeferredWorkItems.Contains(mapping))
					{
						limiter.DeferredWorkItems.Add(new ImportStructWorkItem(model, mapping));
					}
					int num2 = limiter.DeferredWorkItems.Count - 1;
					if (num < num2)
					{
						ImportStructWorkItem value = limiter.DeferredWorkItems[num];
						limiter.DeferredWorkItems[num] = limiter.DeferredWorkItems[num2];
						limiter.DeferredWorkItems[num2] = value;
					}
					return false;
				}
				mapping.BaseMapping = baseMapping;
			}
			ArrayList arrayList = new ArrayList();
			MemberInfo[] memberInfos = model.GetMemberInfos();
			foreach (MemberInfo memberInfo in memberInfos)
			{
				if ((memberInfo.MemberType & (MemberTypes.Field | MemberTypes.Property)) == 0)
				{
					continue;
				}
				SoapAttributes attributes = GetAttributes(memberInfo);
				if (attributes.SoapIgnore)
				{
					continue;
				}
				FieldModel fieldModel = model.GetFieldModel(memberInfo);
				if (fieldModel == null)
				{
					continue;
				}
				MemberMapping memberMapping = ImportFieldMapping(fieldModel, attributes, mapping.Namespace, limiter);
				if (memberMapping == null)
				{
					continue;
				}
				if (!memberMapping.TypeDesc.IsPrimitive && !memberMapping.TypeDesc.IsEnum && !memberMapping.TypeDesc.IsOptionalValue)
				{
					if (model.TypeDesc.IsValueType)
					{
						throw new NotSupportedException(Res.GetString("XmlRpcRefsInValueType", model.TypeDesc.FullName));
					}
					if (memberMapping.TypeDesc.IsValueType)
					{
						throw new NotSupportedException(Res.GetString("XmlRpcNestedValueType", memberMapping.TypeDesc.FullName));
					}
				}
				if (mapping.BaseMapping == null || !mapping.BaseMapping.Declares(memberMapping, mapping.TypeName))
				{
					arrayList.Add(memberMapping);
				}
			}
			mapping.Members = (MemberMapping[])arrayList.ToArray(typeof(MemberMapping));
			if (mapping.BaseMapping == null)
			{
				mapping.BaseMapping = GetRootMapping();
			}
			IncludeTypes(model.Type, limiter);
			return true;
		}

		private ArrayMapping ImportArrayLikeMapping(ArrayModel model, RecursionLimiter limiter)
		{
			ArrayMapping arrayMapping = new ArrayMapping();
			arrayMapping.IsSoap = true;
			TypeMapping typeMapping = ImportTypeMapping(model.Element, limiter);
			if (typeMapping.TypeDesc.IsValueType && !typeMapping.TypeDesc.IsPrimitive && !typeMapping.TypeDesc.IsEnum)
			{
				throw new NotSupportedException(Res.GetString("XmlRpcArrayOfValueTypes", model.TypeDesc.FullName));
			}
			arrayMapping.TypeDesc = model.TypeDesc;
			arrayMapping.Elements = new ElementAccessor[1] { CreateElementAccessor(typeMapping, arrayMapping.Namespace) };
			SetArrayMappingType(arrayMapping);
			ArrayMapping arrayMapping2 = (ArrayMapping)types[arrayMapping.TypeName, arrayMapping.Namespace];
			if (arrayMapping2 != null)
			{
				ArrayMapping next = arrayMapping2;
				while (arrayMapping2 != null)
				{
					if (arrayMapping2.TypeDesc == model.TypeDesc)
					{
						return arrayMapping2;
					}
					arrayMapping2 = arrayMapping2.Next;
				}
				arrayMapping.Next = next;
				types[arrayMapping.TypeName, arrayMapping.Namespace] = arrayMapping;
				return arrayMapping;
			}
			typeScope.AddTypeMapping(arrayMapping);
			types.Add(arrayMapping.TypeName, arrayMapping.Namespace, arrayMapping);
			IncludeTypes(model.Type);
			return arrayMapping;
		}

		private void SetArrayMappingType(ArrayMapping mapping)
		{
			bool flag = false;
			TypeMapping typeMapping = ((mapping.Elements.Length != 1) ? null : mapping.Elements[0].Mapping);
			string text;
			string identifier;
			if (typeMapping is EnumMapping)
			{
				text = typeMapping.Namespace;
				identifier = typeMapping.TypeName;
			}
			else if (typeMapping is PrimitiveMapping)
			{
				text = (typeMapping.TypeDesc.IsXsdType ? "http://www.w3.org/2001/XMLSchema" : "http://microsoft.com/wsdl/types/");
				identifier = typeMapping.TypeDesc.DataType.Name;
				flag = true;
			}
			else if (typeMapping is StructMapping)
			{
				if (typeMapping.TypeDesc.IsRoot)
				{
					text = "http://www.w3.org/2001/XMLSchema";
					identifier = "anyType";
					flag = true;
				}
				else
				{
					text = typeMapping.Namespace;
					identifier = typeMapping.TypeName;
				}
			}
			else
			{
				if (!(typeMapping is ArrayMapping))
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidSoapArray", mapping.TypeDesc.FullName));
				}
				text = typeMapping.Namespace;
				identifier = typeMapping.TypeName;
			}
			identifier = CodeIdentifier.MakePascal(identifier);
			string text2 = "ArrayOf" + identifier;
			string text3 = (flag ? defaultNs : text);
			int num = 1;
			TypeMapping typeMapping2 = (TypeMapping)types[text2, text3];
			while (typeMapping2 != null)
			{
				if (typeMapping2 is ArrayMapping)
				{
					ArrayMapping arrayMapping = (ArrayMapping)typeMapping2;
					if (AccessorMapping.ElementsMatch(arrayMapping.Elements, mapping.Elements))
					{
						break;
					}
				}
				text2 = identifier + num.ToString(CultureInfo.InvariantCulture);
				typeMapping2 = (TypeMapping)types[text2, text3];
				num++;
			}
			mapping.Namespace = text3;
			mapping.TypeName = text2;
		}

		private PrimitiveMapping ImportPrimitiveMapping(PrimitiveModel model, string dataType)
		{
			PrimitiveMapping primitiveMapping = new PrimitiveMapping();
			primitiveMapping.IsSoap = true;
			if (dataType.Length > 0)
			{
				primitiveMapping.TypeDesc = typeScope.GetTypeDesc(dataType, "http://www.w3.org/2001/XMLSchema");
				if (primitiveMapping.TypeDesc == null)
				{
					primitiveMapping.TypeDesc = typeScope.GetTypeDesc(dataType, "http://microsoft.com/wsdl/types/");
					if (primitiveMapping.TypeDesc == null)
					{
						throw new InvalidOperationException(Res.GetString("XmlUdeclaredXsdType", dataType));
					}
				}
			}
			else
			{
				primitiveMapping.TypeDesc = model.TypeDesc;
			}
			primitiveMapping.TypeName = primitiveMapping.TypeDesc.DataType.Name;
			primitiveMapping.Namespace = (primitiveMapping.TypeDesc.IsXsdType ? "http://www.w3.org/2001/XMLSchema" : "http://microsoft.com/wsdl/types/");
			return primitiveMapping;
		}

		private EnumMapping ImportEnumMapping(EnumModel model)
		{
			SoapAttributes attributes = GetAttributes(model.Type);
			string @namespace = defaultNs;
			if (attributes.SoapType != null && attributes.SoapType.Namespace != null)
			{
				@namespace = attributes.SoapType.Namespace;
			}
			string name = XsdTypeName(model.Type, attributes, model.TypeDesc.Name);
			name = XmlConvert.EncodeLocalName(name);
			EnumMapping enumMapping = (EnumMapping)GetTypeMapping(name, @namespace, model.TypeDesc);
			if (enumMapping == null)
			{
				enumMapping = new EnumMapping();
				enumMapping.IsSoap = true;
				enumMapping.TypeDesc = model.TypeDesc;
				enumMapping.TypeName = name;
				enumMapping.Namespace = @namespace;
				enumMapping.IsFlags = model.Type.IsDefined(typeof(FlagsAttribute), inherit: false);
				typeScope.AddTypeMapping(enumMapping);
				types.Add(name, @namespace, enumMapping);
				ArrayList arrayList = new ArrayList();
				for (int i = 0; i < model.Constants.Length; i++)
				{
					ConstantMapping constantMapping = ImportConstantMapping(model.Constants[i]);
					if (constantMapping != null)
					{
						arrayList.Add(constantMapping);
					}
				}
				if (arrayList.Count == 0)
				{
					throw new InvalidOperationException(Res.GetString("XmlNoSerializableMembers", model.TypeDesc.FullName));
				}
				enumMapping.Constants = (ConstantMapping[])arrayList.ToArray(typeof(ConstantMapping));
			}
			return enumMapping;
		}

		private ConstantMapping ImportConstantMapping(ConstantModel model)
		{
			SoapAttributes attributes = GetAttributes(model.FieldInfo);
			if (attributes.SoapIgnore)
			{
				return null;
			}
			if (((uint)attributes.SoapFlags & 0xFFFFFFFEu) != 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidEnumAttribute"));
			}
			if (attributes.SoapEnum == null)
			{
				attributes.SoapEnum = new SoapEnumAttribute();
			}
			ConstantMapping constantMapping = new ConstantMapping();
			constantMapping.XmlName = ((attributes.SoapEnum.Name.Length == 0) ? model.Name : attributes.SoapEnum.Name);
			constantMapping.Name = model.Name;
			constantMapping.Value = model.Value;
			return constantMapping;
		}

		private MembersMapping ImportMembersMapping(XmlReflectionMember[] xmlReflectionMembers, string ns, bool hasWrapperElement, bool writeAccessors, bool validateWrapperElement, RecursionLimiter limiter)
		{
			MembersMapping membersMapping = new MembersMapping();
			membersMapping.TypeDesc = typeScope.GetTypeDesc(typeof(object[]));
			MemberMapping[] array = new MemberMapping[xmlReflectionMembers.Length];
			for (int i = 0; i < array.Length; i++)
			{
				try
				{
					XmlReflectionMember xmlReflectionMember = xmlReflectionMembers[i];
					MemberMapping memberMapping = ImportMemberMapping(xmlReflectionMember, ns, xmlReflectionMembers, (!hasWrapperElement) ? XmlSchemaForm.Qualified : XmlSchemaForm.Unqualified, limiter);
					if (xmlReflectionMember.IsReturnValue && writeAccessors)
					{
						if (i > 0)
						{
							throw new InvalidOperationException(Res.GetString("XmlInvalidReturnPosition"));
						}
						memberMapping.IsReturnValue = true;
					}
					array[i] = memberMapping;
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					throw ReflectionException(xmlReflectionMembers[i].MemberName, ex);
				}
				catch
				{
					throw ReflectionException(xmlReflectionMembers[i].MemberName, null);
				}
			}
			membersMapping.Members = array;
			membersMapping.HasWrapperElement = hasWrapperElement;
			if (hasWrapperElement)
			{
				membersMapping.ValidateRpcWrapperElement = validateWrapperElement;
			}
			membersMapping.WriteAccessors = writeAccessors;
			membersMapping.IsSoap = true;
			if (hasWrapperElement && !writeAccessors)
			{
				membersMapping.Namespace = ns;
			}
			return membersMapping;
		}

		private MemberMapping ImportMemberMapping(XmlReflectionMember xmlReflectionMember, string ns, XmlReflectionMember[] xmlReflectionMembers, XmlSchemaForm form, RecursionLimiter limiter)
		{
			SoapAttributes soapAttributes = xmlReflectionMember.SoapAttributes;
			if (soapAttributes.SoapIgnore)
			{
				return null;
			}
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.IsSoap = true;
			memberMapping.Name = xmlReflectionMember.MemberName;
			bool checkSpecified = XmlReflectionImporter.FindSpecifiedMember(xmlReflectionMember.MemberName, xmlReflectionMembers) != null;
			FieldModel fieldModel = new FieldModel(xmlReflectionMember.MemberName, xmlReflectionMember.MemberType, typeScope.GetTypeDesc(xmlReflectionMember.MemberType), checkSpecified, checkShouldPersist: false);
			memberMapping.CheckShouldPersist = fieldModel.CheckShouldPersist;
			memberMapping.CheckSpecified = fieldModel.CheckSpecified;
			memberMapping.ReadOnly = fieldModel.ReadOnly;
			ImportAccessorMapping(memberMapping, fieldModel, soapAttributes, ns, form, limiter);
			if (xmlReflectionMember.OverrideIsNullable)
			{
				memberMapping.Elements[0].IsNullable = false;
			}
			return memberMapping;
		}

		private MemberMapping ImportFieldMapping(FieldModel model, SoapAttributes a, string ns, RecursionLimiter limiter)
		{
			if (a.SoapIgnore)
			{
				return null;
			}
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.IsSoap = true;
			memberMapping.Name = model.Name;
			memberMapping.CheckShouldPersist = model.CheckShouldPersist;
			memberMapping.CheckSpecified = model.CheckSpecified;
			memberMapping.ReadOnly = model.ReadOnly;
			ImportAccessorMapping(memberMapping, model, a, ns, XmlSchemaForm.Unqualified, limiter);
			return memberMapping;
		}

		private void ImportAccessorMapping(MemberMapping accessor, FieldModel model, SoapAttributes a, string ns, XmlSchemaForm form, RecursionLimiter limiter)
		{
			Type fieldType = model.FieldType;
			string name = model.Name;
			accessor.TypeDesc = typeScope.GetTypeDesc(fieldType);
			if (accessor.TypeDesc.IsVoid)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidVoid"));
			}
			SoapAttributeFlags soapFlags = a.SoapFlags;
			if ((soapFlags & SoapAttributeFlags.Attribute) == SoapAttributeFlags.Attribute)
			{
				if (!accessor.TypeDesc.IsPrimitive && !accessor.TypeDesc.IsEnum)
				{
					throw new InvalidOperationException(Res.GetString("XmlIllegalSoapAttribute", name, accessor.TypeDesc.FullName));
				}
				if ((soapFlags & SoapAttributeFlags.Attribute) != soapFlags)
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidElementAttribute"));
				}
				AttributeAccessor attributeAccessor = new AttributeAccessor();
				attributeAccessor.Name = Accessor.EscapeQName((a.SoapAttribute == null || a.SoapAttribute.AttributeName.Length == 0) ? name : a.SoapAttribute.AttributeName);
				attributeAccessor.Namespace = ((a.SoapAttribute == null || a.SoapAttribute.Namespace == null) ? ns : a.SoapAttribute.Namespace);
				attributeAccessor.Form = XmlSchemaForm.Qualified;
				attributeAccessor.Mapping = ImportTypeMapping(modelScope.GetTypeModel(fieldType), (a.SoapAttribute == null) ? string.Empty : a.SoapAttribute.DataType, limiter);
				attributeAccessor.Default = GetDefaultValue(model.FieldTypeDesc, a);
				accessor.Attribute = attributeAccessor;
				accessor.Elements = new ElementAccessor[0];
			}
			else
			{
				if ((soapFlags & SoapAttributeFlags.Element) != soapFlags)
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidElementAttribute"));
				}
				ElementAccessor elementAccessor = new ElementAccessor();
				elementAccessor.IsSoap = true;
				elementAccessor.Name = XmlConvert.EncodeLocalName((a.SoapElement == null || a.SoapElement.ElementName.Length == 0) ? name : a.SoapElement.ElementName);
				elementAccessor.Namespace = ns;
				elementAccessor.Form = form;
				elementAccessor.Mapping = ImportTypeMapping(modelScope.GetTypeModel(fieldType), (a.SoapElement == null) ? string.Empty : a.SoapElement.DataType, limiter);
				if (a.SoapElement != null)
				{
					elementAccessor.IsNullable = a.SoapElement.IsNullable;
				}
				accessor.Elements = new ElementAccessor[1] { elementAccessor };
			}
		}

		private static ElementAccessor CreateElementAccessor(TypeMapping mapping, string ns)
		{
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.IsSoap = true;
			elementAccessor.Name = mapping.TypeName;
			elementAccessor.Namespace = ns;
			elementAccessor.Mapping = mapping;
			return elementAccessor;
		}

		private object GetDefaultValue(TypeDesc fieldTypeDesc, SoapAttributes a)
		{
			if (a.SoapDefaultValue == null || a.SoapDefaultValue == DBNull.Value)
			{
				return null;
			}
			if (fieldTypeDesc.Kind != TypeKind.Primitive && fieldTypeDesc.Kind != TypeKind.Enum)
			{
				a.SoapDefaultValue = null;
				return a.SoapDefaultValue;
			}
			if (fieldTypeDesc.Kind == TypeKind.Enum)
			{
				if (fieldTypeDesc != typeScope.GetTypeDesc(a.SoapDefaultValue.GetType()))
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidDefaultEnumValue", a.SoapDefaultValue.GetType().FullName, fieldTypeDesc.FullName));
				}
				string text = Enum.Format(a.SoapDefaultValue.GetType(), a.SoapDefaultValue, "G").Replace(",", " ");
				string text2 = Enum.Format(a.SoapDefaultValue.GetType(), a.SoapDefaultValue, "D");
				if (text == text2)
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidDefaultValue", text, a.SoapDefaultValue.GetType().FullName));
				}
				return text;
			}
			return a.SoapDefaultValue;
		}

		internal string XsdTypeName(Type type)
		{
			if (type == typeof(object))
			{
				return "anyType";
			}
			TypeDesc typeDesc = typeScope.GetTypeDesc(type);
			if (typeDesc.IsPrimitive && typeDesc.DataType != null && typeDesc.DataType.Name != null && typeDesc.DataType.Name.Length > 0)
			{
				return typeDesc.DataType.Name;
			}
			return XsdTypeName(type, GetAttributes(type), typeDesc.Name);
		}

		internal string XsdTypeName(Type type, SoapAttributes a, string name)
		{
			string text = name;
			if (a.SoapType != null && a.SoapType.TypeName.Length > 0)
			{
				text = a.SoapType.TypeName;
			}
			if (type.IsGenericType && text.IndexOf('{') >= 0)
			{
				Type genericTypeDefinition = type.GetGenericTypeDefinition();
				Type[] genericArguments = genericTypeDefinition.GetGenericArguments();
				Type[] genericArguments2 = type.GetGenericArguments();
				for (int i = 0; i < genericArguments.Length; i++)
				{
					string text2 = string.Concat("{", genericArguments[i], "}");
					if (text.Contains(text2))
					{
						text = text.Replace(text2, XsdTypeName(genericArguments2[i]));
						if (text.IndexOf('{') < 0)
						{
							break;
						}
					}
				}
			}
			return text;
		}
	}
	public class SoapSchemaExporter
	{
		internal const XmlSchemaForm elementFormDefault = XmlSchemaForm.Qualified;

		private XmlSchemas schemas;

		private Hashtable types = new Hashtable();

		private bool exportedRoot;

		private TypeScope scope;

		private XmlDocument document;

		private static XmlQualifiedName ArrayQName = new XmlQualifiedName("Array", "http://schemas.xmlsoap.org/soap/encoding/");

		private static XmlQualifiedName ArrayTypeQName = new XmlQualifiedName("arrayType", "http://schemas.xmlsoap.org/soap/encoding/");

		internal XmlDocument Document
		{
			get
			{
				if (document == null)
				{
					document = new XmlDocument();
				}
				return document;
			}
		}

		public SoapSchemaExporter(XmlSchemas schemas)
		{
			this.schemas = schemas;
		}

		public void ExportTypeMapping(XmlTypeMapping xmlTypeMapping)
		{
			CheckScope(xmlTypeMapping.Scope);
			ExportTypeMapping(xmlTypeMapping.Mapping, null);
		}

		public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping)
		{
			ExportMembersMapping(xmlMembersMapping, exportEnclosingType: false);
		}

		public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping, bool exportEnclosingType)
		{
			CheckScope(xmlMembersMapping.Scope);
			MembersMapping membersMapping = (MembersMapping)xmlMembersMapping.Accessor.Mapping;
			if (exportEnclosingType)
			{
				ExportTypeMapping(membersMapping, null);
				return;
			}
			MemberMapping[] members = membersMapping.Members;
			foreach (MemberMapping memberMapping in members)
			{
				if (memberMapping.Elements.Length > 0)
				{
					ExportTypeMapping(memberMapping.Elements[0].Mapping, null);
				}
			}
		}

		private void CheckScope(TypeScope scope)
		{
			if (this.scope == null)
			{
				this.scope = scope;
			}
			else if (this.scope != scope)
			{
				throw new InvalidOperationException(Res.GetString("XmlMappingsScopeMismatch"));
			}
		}

		private void CheckForDuplicateType(string newTypeName, string newNamespace)
		{
			XmlSchema xmlSchema = schemas[newNamespace];
			if (xmlSchema == null)
			{
				return;
			}
			foreach (XmlSchemaObject item in xmlSchema.Items)
			{
				if (item is XmlSchemaType xmlSchemaType && xmlSchemaType.Name == newTypeName)
				{
					throw new InvalidOperationException(Res.GetString("XmlDuplicateTypeName", newTypeName, newNamespace));
				}
			}
		}

		private void AddSchemaItem(XmlSchemaObject item, string ns, string referencingNs)
		{
			if (!SchemaContainsItem(item, ns))
			{
				XmlSchema xmlSchema = schemas[ns];
				if (xmlSchema == null)
				{
					xmlSchema = new XmlSchema();
					xmlSchema.TargetNamespace = ((ns == null || ns.Length == 0) ? null : ns);
					xmlSchema.ElementFormDefault = XmlSchemaForm.Qualified;
					schemas.Add(xmlSchema);
				}
				xmlSchema.Items.Add(item);
			}
			if (referencingNs != null)
			{
				AddSchemaImport(ns, referencingNs);
			}
		}

		private void AddSchemaImport(string ns, string referencingNs)
		{
			if (referencingNs != null && ns != null && !(ns == referencingNs))
			{
				XmlSchema xmlSchema = schemas[referencingNs];
				if (xmlSchema == null)
				{
					throw new InvalidOperationException(Res.GetString("XmlMissingSchema", referencingNs));
				}
				if (ns != null && ns.Length > 0 && FindImport(xmlSchema, ns) == null)
				{
					XmlSchemaImport xmlSchemaImport = new XmlSchemaImport();
					xmlSchemaImport.Namespace = ns;
					xmlSchema.Includes.Add(xmlSchemaImport);
				}
			}
		}

		private bool SchemaContainsItem(XmlSchemaObject item, string ns)
		{
			return schemas[ns]?.Items.Contains(item) ?? false;
		}

		private XmlSchemaImport FindImport(XmlSchema schema, string ns)
		{
			foreach (XmlSchemaObject include in schema.Includes)
			{
				if (include is XmlSchemaImport)
				{
					XmlSchemaImport xmlSchemaImport = (XmlSchemaImport)include;
					if (xmlSchemaImport.Namespace == ns)
					{
						return xmlSchemaImport;
					}
				}
			}
			return null;
		}

		private XmlQualifiedName ExportTypeMapping(TypeMapping mapping, string ns)
		{
			if (mapping is ArrayMapping)
			{
				return ExportArrayMapping((ArrayMapping)mapping, ns);
			}
			if (mapping is EnumMapping)
			{
				return ExportEnumMapping((EnumMapping)mapping, ns);
			}
			if (mapping is PrimitiveMapping)
			{
				PrimitiveMapping primitiveMapping = (PrimitiveMapping)mapping;
				if (primitiveMapping.TypeDesc.IsXsdType)
				{
					return ExportPrimitiveMapping(primitiveMapping);
				}
				return ExportNonXsdPrimitiveMapping(primitiveMapping, ns);
			}
			if (mapping is StructMapping)
			{
				return ExportStructMapping((StructMapping)mapping, ns);
			}
			if (mapping is NullableMapping)
			{
				return ExportTypeMapping(((NullableMapping)mapping).BaseMapping, ns);
			}
			if (mapping is MembersMapping)
			{
				return ExportMembersMapping((MembersMapping)mapping, ns);
			}
			throw new ArgumentException(Res.GetString("XmlInternalError"), "mapping");
		}

		private XmlQualifiedName ExportNonXsdPrimitiveMapping(PrimitiveMapping mapping, string ns)
		{
			XmlSchemaType dataType = mapping.TypeDesc.DataType;
			if (!SchemaContainsItem(dataType, "http://microsoft.com/wsdl/types/"))
			{
				AddSchemaItem(dataType, "http://microsoft.com/wsdl/types/", ns);
			}
			else
			{
				AddSchemaImport("http://microsoft.com/wsdl/types/", ns);
			}
			return new XmlQualifiedName(mapping.TypeDesc.DataType.Name, "http://microsoft.com/wsdl/types/");
		}

		private XmlQualifiedName ExportPrimitiveMapping(PrimitiveMapping mapping)
		{
			return new XmlQualifiedName(mapping.TypeDesc.DataType.Name, "http://www.w3.org/2001/XMLSchema");
		}

		private XmlQualifiedName ExportArrayMapping(ArrayMapping mapping, string ns)
		{
			while (mapping.Next != null)
			{
				mapping = mapping.Next;
			}
			XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)types[mapping];
			if (xmlSchemaComplexType == null)
			{
				CheckForDuplicateType(mapping.TypeName, mapping.Namespace);
				xmlSchemaComplexType = new XmlSchemaComplexType();
				xmlSchemaComplexType.Name = mapping.TypeName;
				types.Add(mapping, xmlSchemaComplexType);
				AddSchemaItem(xmlSchemaComplexType, mapping.Namespace, ns);
				AddSchemaImport("http://schemas.xmlsoap.org/soap/encoding/", mapping.Namespace);
				AddSchemaImport("http://schemas.xmlsoap.org/wsdl/", mapping.Namespace);
				XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction = new XmlSchemaComplexContentRestriction();
				XmlQualifiedName xmlQualifiedName = ExportTypeMapping(mapping.Elements[0].Mapping, mapping.Namespace);
				if (xmlQualifiedName.IsEmpty)
				{
					xmlQualifiedName = new XmlQualifiedName("anyType", "http://www.w3.org/2001/XMLSchema");
				}
				XmlSchemaAttribute xmlSchemaAttribute = new XmlSchemaAttribute();
				xmlSchemaAttribute.RefName = ArrayTypeQName;
				XmlAttribute xmlAttribute = new XmlAttribute("wsdl", "arrayType", "http://schemas.xmlsoap.org/wsdl/", Document);
				xmlAttribute.Value = xmlQualifiedName.Namespace + ":" + xmlQualifiedName.Name + "[]";
				xmlSchemaAttribute.UnhandledAttributes = new XmlAttribute[1] { xmlAttribute };
				xmlSchemaComplexContentRestriction.Attributes.Add(xmlSchemaAttribute);
				xmlSchemaComplexContentRestriction.BaseTypeName = ArrayQName;
				XmlSchemaComplexContent xmlSchemaComplexContent = new XmlSchemaComplexContent();
				xmlSchemaComplexContent.Content = xmlSchemaComplexContentRestriction;
				xmlSchemaComplexType.ContentModel = xmlSchemaComplexContent;
				if (xmlQualifiedName.Namespace != "http://www.w3.org/2001/XMLSchema")
				{
					AddSchemaImport(xmlQualifiedName.Namespace, mapping.Namespace);
				}
			}
			else
			{
				AddSchemaImport(mapping.Namespace, ns);
			}
			return new XmlQualifiedName(mapping.TypeName, mapping.Namespace);
		}

		private void ExportElementAccessors(XmlSchemaGroupBase group, ElementAccessor[] accessors, bool repeats, bool valueTypeOptional, string ns)
		{
			if (accessors.Length == 0)
			{
				return;
			}
			if (accessors.Length == 1)
			{
				ExportElementAccessor(group, accessors[0], repeats, valueTypeOptional, ns);
				return;
			}
			XmlSchemaChoice xmlSchemaChoice = new XmlSchemaChoice();
			xmlSchemaChoice.MaxOccurs = (repeats ? decimal.MaxValue : 1m);
			xmlSchemaChoice.MinOccurs = ((!repeats) ? 1 : 0);
			for (int i = 0; i < accessors.Length; i++)
			{
				ExportElementAccessor(xmlSchemaChoice, accessors[i], repeats: false, valueTypeOptional, ns);
			}
			if (xmlSchemaChoice.Items.Count > 0)
			{
				group.Items.Add(xmlSchemaChoice);
			}
		}

		private void ExportElementAccessor(XmlSchemaGroupBase group, ElementAccessor accessor, bool repeats, bool valueTypeOptional, string ns)
		{
			XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
			xmlSchemaElement.MinOccurs = ((!repeats && !valueTypeOptional) ? 1 : 0);
			xmlSchemaElement.MaxOccurs = (repeats ? decimal.MaxValue : 1m);
			xmlSchemaElement.Name = accessor.Name;
			xmlSchemaElement.IsNillable = accessor.IsNullable || accessor.Mapping is NullableMapping;
			xmlSchemaElement.Form = XmlSchemaForm.Unqualified;
			xmlSchemaElement.SchemaTypeName = ExportTypeMapping(accessor.Mapping, accessor.Namespace);
			group.Items.Add(xmlSchemaElement);
		}

		private XmlQualifiedName ExportRootMapping(StructMapping mapping)
		{
			if (!exportedRoot)
			{
				exportedRoot = true;
				ExportDerivedMappings(mapping);
			}
			return new XmlQualifiedName("anyType", "http://www.w3.org/2001/XMLSchema");
		}

		private XmlQualifiedName ExportStructMapping(StructMapping mapping, string ns)
		{
			if (mapping.TypeDesc.IsRoot)
			{
				return ExportRootMapping(mapping);
			}
			XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)types[mapping];
			if (xmlSchemaComplexType == null)
			{
				if (!mapping.IncludeInSchema)
				{
					throw new InvalidOperationException(Res.GetString("XmlSoapCannotIncludeInSchema", mapping.TypeDesc.Name));
				}
				CheckForDuplicateType(mapping.TypeName, mapping.Namespace);
				xmlSchemaComplexType = new XmlSchemaComplexType();
				xmlSchemaComplexType.Name = mapping.TypeName;
				types.Add(mapping, xmlSchemaComplexType);
				AddSchemaItem(xmlSchemaComplexType, mapping.Namespace, ns);
				xmlSchemaComplexType.IsAbstract = mapping.TypeDesc.IsAbstract;
				if (mapping.BaseMapping != null && mapping.BaseMapping.IncludeInSchema)
				{
					XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension = new XmlSchemaComplexContentExtension();
					xmlSchemaComplexContentExtension.BaseTypeName = ExportStructMapping(mapping.BaseMapping, mapping.Namespace);
					XmlSchemaComplexContent xmlSchemaComplexContent = new XmlSchemaComplexContent();
					xmlSchemaComplexContent.Content = xmlSchemaComplexContentExtension;
					xmlSchemaComplexType.ContentModel = xmlSchemaComplexContent;
				}
				ExportTypeMembers(xmlSchemaComplexType, mapping.Members, mapping.Namespace);
				ExportDerivedMappings(mapping);
			}
			else
			{
				AddSchemaImport(mapping.Namespace, ns);
			}
			return new XmlQualifiedName(xmlSchemaComplexType.Name, mapping.Namespace);
		}

		private XmlQualifiedName ExportMembersMapping(MembersMapping mapping, string ns)
		{
			XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)types[mapping];
			if (xmlSchemaComplexType == null)
			{
				CheckForDuplicateType(mapping.TypeName, mapping.Namespace);
				xmlSchemaComplexType = new XmlSchemaComplexType();
				xmlSchemaComplexType.Name = mapping.TypeName;
				types.Add(mapping, xmlSchemaComplexType);
				AddSchemaItem(xmlSchemaComplexType, mapping.Namespace, ns);
				ExportTypeMembers(xmlSchemaComplexType, mapping.Members, mapping.Namespace);
			}
			else
			{
				AddSchemaImport(mapping.Namespace, ns);
			}
			return new XmlQualifiedName(xmlSchemaComplexType.Name, mapping.Namespace);
		}

		private void ExportTypeMembers(XmlSchemaComplexType type, MemberMapping[] members, string ns)
		{
			XmlSchemaGroupBase xmlSchemaGroupBase = new XmlSchemaSequence();
			foreach (MemberMapping memberMapping in members)
			{
				if (memberMapping.Elements.Length > 0)
				{
					bool valueTypeOptional = memberMapping.CheckSpecified != 0 || memberMapping.CheckShouldPersist || !memberMapping.TypeDesc.IsValueType;
					ExportElementAccessors(xmlSchemaGroupBase, memberMapping.Elements, repeats: false, valueTypeOptional, ns);
				}
			}
			if (xmlSchemaGroupBase.Items.Count <= 0)
			{
				return;
			}
			if (type.ContentModel != null)
			{
				if (type.ContentModel.Content is XmlSchemaComplexContentExtension)
				{
					((XmlSchemaComplexContentExtension)type.ContentModel.Content).Particle = xmlSchemaGroupBase;
					return;
				}
				if (!(type.ContentModel.Content is XmlSchemaComplexContentRestriction))
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidContent", type.ContentModel.Content.GetType().Name));
				}
				((XmlSchemaComplexContentRestriction)type.ContentModel.Content).Particle = xmlSchemaGroupBase;
			}
			else
			{
				type.Particle = xmlSchemaGroupBase;
			}
		}

		private void ExportDerivedMappings(StructMapping mapping)
		{
			for (StructMapping structMapping = mapping.DerivedMappings; structMapping != null; structMapping = structMapping.NextDerivedMapping)
			{
				if (structMapping.IncludeInSchema)
				{
					ExportStructMapping(structMapping, mapping.TypeDesc.IsRoot ? null : mapping.Namespace);
				}
			}
		}

		private XmlQualifiedName ExportEnumMapping(EnumMapping mapping, string ns)
		{
			XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)types[mapping];
			if (xmlSchemaSimpleType == null)
			{
				CheckForDuplicateType(mapping.TypeName, mapping.Namespace);
				xmlSchemaSimpleType = new XmlSchemaSimpleType();
				xmlSchemaSimpleType.Name = mapping.TypeName;
				types.Add(mapping, xmlSchemaSimpleType);
				AddSchemaItem(xmlSchemaSimpleType, mapping.Namespace, ns);
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = new XmlSchemaSimpleTypeRestriction();
				xmlSchemaSimpleTypeRestriction.BaseTypeName = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
				for (int i = 0; i < mapping.Constants.Length; i++)
				{
					ConstantMapping constantMapping = mapping.Constants[i];
					XmlSchemaEnumerationFacet xmlSchemaEnumerationFacet = new XmlSchemaEnumerationFacet();
					xmlSchemaEnumerationFacet.Value = constantMapping.XmlName;
					xmlSchemaSimpleTypeRestriction.Facets.Add(xmlSchemaEnumerationFacet);
				}
				if (!mapping.IsFlags)
				{
					xmlSchemaSimpleType.Content = xmlSchemaSimpleTypeRestriction;
				}
				else
				{
					XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = new XmlSchemaSimpleTypeList();
					XmlSchemaSimpleType xmlSchemaSimpleType2 = new XmlSchemaSimpleType();
					xmlSchemaSimpleType2.Content = xmlSchemaSimpleTypeRestriction;
					xmlSchemaSimpleTypeList.ItemType = xmlSchemaSimpleType2;
					xmlSchemaSimpleType.Content = xmlSchemaSimpleTypeList;
				}
			}
			else
			{
				AddSchemaImport(mapping.Namespace, ns);
			}
			return new XmlQualifiedName(mapping.TypeName, mapping.Namespace);
		}
	}
	public class SoapSchemaImporter : SchemaImporter
	{
		public SoapSchemaImporter(XmlSchemas schemas)
			: base(schemas, CodeGenerationOptions.GenerateProperties, null, new ImportContext())
		{
		}

		public SoapSchemaImporter(XmlSchemas schemas, CodeIdentifiers typeIdentifiers)
			: base(schemas, CodeGenerationOptions.GenerateProperties, null, new ImportContext(typeIdentifiers, shareTypes: false))
		{
		}

		public SoapSchemaImporter(XmlSchemas schemas, CodeIdentifiers typeIdentifiers, CodeGenerationOptions options)
			: base(schemas, options, null, new ImportContext(typeIdentifiers, shareTypes: false))
		{
		}

		public SoapSchemaImporter(XmlSchemas schemas, CodeGenerationOptions options, ImportContext context)
			: base(schemas, options, null, context)
		{
		}

		public SoapSchemaImporter(XmlSchemas schemas, CodeGenerationOptions options, CodeDomProvider codeProvider, ImportContext context)
			: base(schemas, options, codeProvider, context)
		{
		}

		public XmlTypeMapping ImportDerivedTypeMapping(XmlQualifiedName name, Type baseType, bool baseTypeCanBeIndirect)
		{
			TypeMapping typeMapping = ImportType(name, excludeFromImport: false);
			if (typeMapping is StructMapping)
			{
				MakeDerived((StructMapping)typeMapping, baseType, baseTypeCanBeIndirect);
			}
			else if (baseType != null)
			{
				throw new InvalidOperationException(Res.GetString("XmlPrimitiveBaseType", name.Name, name.Namespace, baseType.FullName));
			}
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.IsSoap = true;
			elementAccessor.Name = name.Name;
			elementAccessor.Namespace = name.Namespace;
			elementAccessor.Mapping = typeMapping;
			elementAccessor.IsNullable = true;
			elementAccessor.Form = XmlSchemaForm.Qualified;
			return new XmlTypeMapping(base.Scope, elementAccessor);
		}

		public XmlMembersMapping ImportMembersMapping(string name, string ns, SoapSchemaMember member)
		{
			TypeMapping typeMapping = ImportType(member.MemberType, excludeFromImport: true);
			if (!(typeMapping is StructMapping))
			{
				return ImportMembersMapping(name, ns, new SoapSchemaMember[1] { member });
			}
			MembersMapping membersMapping = new MembersMapping();
			membersMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(object[]));
			membersMapping.Members = ((StructMapping)typeMapping).Members;
			membersMapping.HasWrapperElement = true;
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.IsSoap = true;
			elementAccessor.Name = name;
			elementAccessor.Namespace = ((typeMapping.Namespace != null) ? typeMapping.Namespace : ns);
			elementAccessor.Mapping = membersMapping;
			elementAccessor.IsNullable = false;
			elementAccessor.Form = XmlSchemaForm.Qualified;
			return new XmlMembersMapping(base.Scope, elementAccessor, XmlMappingAccess.Read | XmlMappingAccess.Write);
		}

		public XmlMembersMapping ImportMembersMapping(string name, string ns, SoapSchemaMember[] members)
		{
			return ImportMembersMapping(name, ns, members, hasWrapperElement: true);
		}

		public XmlMembersMapping ImportMembersMapping(string name, string ns, SoapSchemaMember[] members, bool hasWrapperElement)
		{
			return ImportMembersMapping(name, ns, members, hasWrapperElement, null, baseTypeCanBeIndirect: false);
		}

		public XmlMembersMapping ImportMembersMapping(string name, string ns, SoapSchemaMember[] members, bool hasWrapperElement, Type baseType, bool baseTypeCanBeIndirect)
		{
			XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();
			XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence)(xmlSchemaComplexType.Particle = new XmlSchemaSequence());
			foreach (SoapSchemaMember soapSchemaMember in members)
			{
				XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
				xmlSchemaElement.Name = soapSchemaMember.MemberName;
				xmlSchemaElement.SchemaTypeName = soapSchemaMember.MemberType;
				xmlSchemaSequence.Items.Add(xmlSchemaElement);
			}
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			codeIdentifiers.UseCamelCasing = true;
			MembersMapping membersMapping = new MembersMapping();
			membersMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(object[]));
			membersMapping.Members = ImportTypeMembers(xmlSchemaComplexType, ns, codeIdentifiers);
			membersMapping.HasWrapperElement = hasWrapperElement;
			if (baseType != null)
			{
				for (int j = 0; j < membersMapping.Members.Length; j++)
				{
					MemberMapping memberMapping = membersMapping.Members[j];
					if (memberMapping.Accessor.Mapping is StructMapping)
					{
						MakeDerived((StructMapping)memberMapping.Accessor.Mapping, baseType, baseTypeCanBeIndirect);
					}
				}
			}
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.IsSoap = true;
			elementAccessor.Name = name;
			elementAccessor.Namespace = ns;
			elementAccessor.Mapping = membersMapping;
			elementAccessor.IsNullable = false;
			elementAccessor.Form = XmlSchemaForm.Qualified;
			return new XmlMembersMapping(base.Scope, elementAccessor, XmlMappingAccess.Read | XmlMappingAccess.Write);
		}

		private ElementAccessor ImportElement(XmlSchemaElement element, string ns)
		{
			if (!element.RefName.IsEmpty)
			{
				throw new InvalidOperationException(Res.GetString("RefSyntaxNotSupportedForElements0", element.RefName.Name, element.RefName.Namespace));
			}
			if (element.Name.Length == 0)
			{
				XmlQualifiedName parentName = XmlSchemas.GetParentName(element);
				throw new InvalidOperationException(Res.GetString("XmlElementHasNoName", parentName.Name, parentName.Namespace));
			}
			TypeMapping mapping = ImportElementType(element, ns);
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.IsSoap = true;
			elementAccessor.Name = element.Name;
			elementAccessor.Namespace = ns;
			elementAccessor.Mapping = mapping;
			elementAccessor.IsNullable = element.IsNillable;
			elementAccessor.Form = XmlSchemaForm.None;
			return elementAccessor;
		}

		private TypeMapping ImportElementType(XmlSchemaElement element, string ns)
		{
			TypeMapping typeMapping;
			if (!element.SchemaTypeName.IsEmpty)
			{
				typeMapping = ImportType(element.SchemaTypeName, excludeFromImport: false);
			}
			else
			{
				if (element.SchemaType == null)
				{
					if (!element.SubstitutionGroup.IsEmpty)
					{
						XmlQualifiedName parentName = XmlSchemas.GetParentName(element);
						throw new InvalidOperationException(Res.GetString("XmlInvalidSubstitutionGroupUse", parentName.Name, parentName.Namespace));
					}
					XmlQualifiedName parentName2 = XmlSchemas.GetParentName(element);
					throw new InvalidOperationException(Res.GetString("XmlElementMissingType", parentName2.Name, parentName2.Namespace, element.Name));
				}
				XmlQualifiedName parentName3 = XmlSchemas.GetParentName(element);
				if (!(element.SchemaType is XmlSchemaComplexType))
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidSchemaElementType", parentName3.Name, parentName3.Namespace, element.Name));
				}
				typeMapping = ImportType((XmlSchemaComplexType)element.SchemaType, ns, excludeFromImport: false);
				if (!(typeMapping is ArrayMapping))
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidSchemaElementType", parentName3.Name, parentName3.Namespace, element.Name));
				}
			}
			typeMapping.ReferencedByElement = true;
			return typeMapping;
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		internal override void ImportDerivedTypes(XmlQualifiedName baseName)
		{
			foreach (XmlSchema schema in base.Schemas)
			{
				if (base.Schemas.IsReference(schema) || XmlSchemas.IsDataSet(schema))
				{
					continue;
				}
				XmlSchemas.Preprocess(schema);
				foreach (object value in schema.SchemaTypes.Values)
				{
					if (value is XmlSchemaType)
					{
						XmlSchemaType xmlSchemaType = (XmlSchemaType)value;
						if (xmlSchemaType.DerivedFrom == baseName)
						{
							ImportType(xmlSchemaType.QualifiedName, excludeFromImport: false);
						}
					}
				}
			}
		}

		private TypeMapping ImportType(XmlQualifiedName name, bool excludeFromImport)
		{
			if (name.Name == "anyType" && name.Namespace == "http://www.w3.org/2001/XMLSchema")
			{
				return ImportRootMapping();
			}
			object obj = FindType(name);
			TypeMapping typeMapping = (TypeMapping)base.ImportedMappings[obj];
			if (typeMapping == null)
			{
				if (obj is XmlSchemaComplexType)
				{
					typeMapping = ImportType((XmlSchemaComplexType)obj, name.Namespace, excludeFromImport);
				}
				else
				{
					if (!(obj is XmlSchemaSimpleType))
					{
						throw new InvalidOperationException(Res.GetString("XmlInternalError"));
					}
					typeMapping = ImportDataType((XmlSchemaSimpleType)obj, name.Namespace, name.Name, isList: false);
				}
			}
			if (excludeFromImport)
			{
				typeMapping.IncludeInSchema = false;
			}
			return typeMapping;
		}

		private TypeMapping ImportType(XmlSchemaComplexType type, string typeNs, bool excludeFromImport)
		{
			if (type.Redefined != null)
			{
				throw new NotSupportedException(Res.GetString("XmlUnsupportedRedefine", type.Name, typeNs));
			}
			TypeMapping typeMapping = ImportAnyType(type, typeNs);
			if (typeMapping == null)
			{
				typeMapping = ImportArrayMapping(type, typeNs);
			}
			if (typeMapping == null)
			{
				typeMapping = ImportStructType(type, typeNs, excludeFromImport);
			}
			return typeMapping;
		}

		private TypeMapping ImportAnyType(XmlSchemaComplexType type, string typeNs)
		{
			if (type.Particle == null)
			{
				return null;
			}
			if (!(type.Particle is XmlSchemaAll) && !(type.Particle is XmlSchemaSequence))
			{
				return null;
			}
			XmlSchemaGroupBase xmlSchemaGroupBase = (XmlSchemaGroupBase)type.Particle;
			if (xmlSchemaGroupBase.Items.Count != 1 || !(xmlSchemaGroupBase.Items[0] is XmlSchemaAny))
			{
				return null;
			}
			return ImportRootMapping();
		}

		private StructMapping ImportStructType(XmlSchemaComplexType type, string typeNs, bool excludeFromImport)
		{
			if (type.Name == null)
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)type.Parent;
				XmlQualifiedName parentName = XmlSchemas.GetParentName(xmlSchemaElement);
				throw new InvalidOperationException(Res.GetString("XmlInvalidSchemaElementType", parentName.Name, parentName.Namespace, xmlSchemaElement.Name));
			}
			TypeDesc baseTypeDesc = null;
			Mapping mapping = null;
			if (!type.DerivedFrom.IsEmpty)
			{
				mapping = ImportType(type.DerivedFrom, excludeFromImport);
				if (mapping is StructMapping)
				{
					baseTypeDesc = ((StructMapping)mapping).TypeDesc;
				}
				else
				{
					mapping = null;
				}
			}
			if (mapping == null)
			{
				mapping = GetRootMapping();
			}
			Mapping mapping2 = (Mapping)base.ImportedMappings[type];
			if (mapping2 != null)
			{
				return (StructMapping)mapping2;
			}
			string text = GenerateUniqueTypeName(Accessor.UnescapeName(type.Name));
			StructMapping structMapping = new StructMapping();
			structMapping.IsReference = base.Schemas.IsReference(type);
			TypeFlags typeFlags = TypeFlags.Reference;
			if (type.IsAbstract)
			{
				typeFlags |= TypeFlags.Abstract;
			}
			structMapping.TypeDesc = new TypeDesc(text, text, TypeKind.Struct, baseTypeDesc, typeFlags);
			structMapping.Namespace = typeNs;
			structMapping.TypeName = type.Name;
			structMapping.BaseMapping = (StructMapping)mapping;
			base.ImportedMappings.Add(type, structMapping);
			if (excludeFromImport)
			{
				structMapping.IncludeInSchema = false;
			}
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			codeIdentifiers.AddReserved(text);
			AddReservedIdentifiersForDataBinding(codeIdentifiers);
			structMapping.Members = ImportTypeMembers(type, typeNs, codeIdentifiers);
			base.Scope.AddTypeMapping(structMapping);
			ImportDerivedTypes(new XmlQualifiedName(type.Name, typeNs));
			return structMapping;
		}

		private MemberMapping[] ImportTypeMembers(XmlSchemaComplexType type, string typeNs, CodeIdentifiers members)
		{
			if (type.AnyAttribute != null)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidAnyAttributeUse", type.Name, type.QualifiedName.Namespace));
			}
			XmlSchemaObjectCollection attributes = type.Attributes;
			for (int i = 0; i < attributes.Count; i++)
			{
				object obj = attributes[i];
				if (obj is XmlSchemaAttributeGroup)
				{
					throw new InvalidOperationException(Res.GetString("XmlSoapInvalidAttributeUse", type.Name, type.QualifiedName.Namespace));
				}
				if (obj is XmlSchemaAttribute)
				{
					XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)obj;
					if (xmlSchemaAttribute.Use != XmlSchemaUse.Prohibited)
					{
						throw new InvalidOperationException(Res.GetString("XmlSoapInvalidAttributeUse", type.Name, type.QualifiedName.Namespace));
					}
				}
			}
			if (type.Particle != null)
			{
				ImportGroup(type.Particle, members, typeNs);
			}
			else if (type.ContentModel != null && type.ContentModel is XmlSchemaComplexContent)
			{
				XmlSchemaComplexContent xmlSchemaComplexContent = (XmlSchemaComplexContent)type.ContentModel;
				if (xmlSchemaComplexContent.Content is XmlSchemaComplexContentExtension)
				{
					if (((XmlSchemaComplexContentExtension)xmlSchemaComplexContent.Content).Particle != null)
					{
						ImportGroup(((XmlSchemaComplexContentExtension)xmlSchemaComplexContent.Content).Particle, members, typeNs);
					}
				}
				else if (xmlSchemaComplexContent.Content is XmlSchemaComplexContentRestriction && ((XmlSchemaComplexContentRestriction)xmlSchemaComplexContent.Content).Particle != null)
				{
					ImportGroup(((XmlSchemaComplexContentRestriction)xmlSchemaComplexContent.Content).Particle, members, typeNs);
				}
			}
			return (MemberMapping[])members.ToArray(typeof(MemberMapping));
		}

		private void ImportGroup(XmlSchemaParticle group, CodeIdentifiers members, string ns)
		{
			if (group is XmlSchemaChoice)
			{
				XmlQualifiedName parentName = XmlSchemas.GetParentName(group);
				throw new InvalidOperationException(Res.GetString("XmlSoapInvalidChoice", parentName.Name, parentName.Namespace));
			}
			ImportGroupMembers(group, members, ns);
		}

		private void ImportGroupMembers(XmlSchemaParticle particle, CodeIdentifiers members, string ns)
		{
			XmlQualifiedName parentName = XmlSchemas.GetParentName(particle);
			if (particle is XmlSchemaGroupRef)
			{
				throw new InvalidOperationException(Res.GetString("XmlSoapUnsupportedGroupRef", parentName.Name, parentName.Namespace));
			}
			if (!(particle is XmlSchemaGroupBase))
			{
				return;
			}
			XmlSchemaGroupBase xmlSchemaGroupBase = (XmlSchemaGroupBase)particle;
			if (xmlSchemaGroupBase.IsMultipleOccurrence)
			{
				throw new InvalidOperationException(Res.GetString("XmlSoapUnsupportedGroupRepeat", parentName.Name, parentName.Namespace));
			}
			for (int i = 0; i < xmlSchemaGroupBase.Items.Count; i++)
			{
				object obj = xmlSchemaGroupBase.Items[i];
				if (obj is XmlSchemaGroupBase || obj is XmlSchemaGroupRef)
				{
					throw new InvalidOperationException(Res.GetString("XmlSoapUnsupportedGroupNested", parentName.Name, parentName.Namespace));
				}
				if (obj is XmlSchemaElement)
				{
					ImportElementMember((XmlSchemaElement)obj, members, ns);
				}
				else if (obj is XmlSchemaAny)
				{
					throw new InvalidOperationException(Res.GetString("XmlSoapUnsupportedGroupAny", parentName.Name, parentName.Namespace));
				}
			}
		}

		private ElementAccessor ImportArray(XmlSchemaElement element, string ns)
		{
			if (element.SchemaType == null)
			{
				return null;
			}
			if (!element.IsMultipleOccurrence)
			{
				return null;
			}
			XmlSchemaType schemaType = element.SchemaType;
			ArrayMapping arrayMapping = ImportArrayMapping(schemaType, ns);
			if (arrayMapping == null)
			{
				return null;
			}
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.IsSoap = true;
			elementAccessor.Name = element.Name;
			elementAccessor.Namespace = ns;
			elementAccessor.Mapping = arrayMapping;
			elementAccessor.IsNullable = false;
			elementAccessor.Form = XmlSchemaForm.None;
			return elementAccessor;
		}

		private ArrayMapping ImportArrayMapping(XmlSchemaType type, string ns)
		{
			ArrayMapping arrayMapping;
			if (type.Name == "Array" && ns == "http://schemas.xmlsoap.org/soap/encoding/")
			{
				arrayMapping = new ArrayMapping();
				TypeMapping rootMapping = GetRootMapping();
				ElementAccessor elementAccessor = new ElementAccessor();
				elementAccessor.IsSoap = true;
				elementAccessor.Name = "anyType";
				elementAccessor.Namespace = ns;
				elementAccessor.Mapping = rootMapping;
				elementAccessor.IsNullable = true;
				elementAccessor.Form = XmlSchemaForm.None;
				arrayMapping.Elements = new ElementAccessor[1] { elementAccessor };
				arrayMapping.TypeDesc = elementAccessor.Mapping.TypeDesc.CreateArrayTypeDesc();
				arrayMapping.TypeName = "ArrayOf" + CodeIdentifier.MakePascal(elementAccessor.Mapping.TypeName);
				return arrayMapping;
			}
			if (!(type.DerivedFrom.Name == "Array") || !(type.DerivedFrom.Namespace == "http://schemas.xmlsoap.org/soap/encoding/"))
			{
				return null;
			}
			XmlSchemaContentModel contentModel = ((XmlSchemaComplexType)type).ContentModel;
			if (!(contentModel.Content is XmlSchemaComplexContentRestriction))
			{
				return null;
			}
			arrayMapping = new ArrayMapping();
			XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction = (XmlSchemaComplexContentRestriction)contentModel.Content;
			for (int i = 0; i < xmlSchemaComplexContentRestriction.Attributes.Count; i++)
			{
				if (!(xmlSchemaComplexContentRestriction.Attributes[i] is XmlSchemaAttribute xmlSchemaAttribute) || !(xmlSchemaAttribute.RefName.Name == "arrayType") || !(xmlSchemaAttribute.RefName.Namespace == "http://schemas.xmlsoap.org/soap/encoding/"))
				{
					continue;
				}
				string text = null;
				if (xmlSchemaAttribute.UnhandledAttributes != null)
				{
					XmlAttribute[] unhandledAttributes = xmlSchemaAttribute.UnhandledAttributes;
					foreach (XmlAttribute xmlAttribute in unhandledAttributes)
					{
						if (xmlAttribute.LocalName == "arrayType" && xmlAttribute.NamespaceURI == "http://schemas.xmlsoap.org/wsdl/")
						{
							text = xmlAttribute.Value;
							break;
						}
					}
				}
				if (text != null)
				{
					string dims;
					XmlQualifiedName xmlQualifiedName = TypeScope.ParseWsdlArrayType(text, out dims, xmlSchemaAttribute);
					TypeDesc typeDesc = base.Scope.GetTypeDesc(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
					TypeMapping typeMapping;
					if (typeDesc != null && typeDesc.IsPrimitive)
					{
						typeMapping = new PrimitiveMapping();
						typeMapping.TypeDesc = typeDesc;
						typeMapping.TypeName = typeDesc.DataType.Name;
					}
					else
					{
						typeMapping = ImportType(xmlQualifiedName, excludeFromImport: false);
					}
					ElementAccessor elementAccessor2 = new ElementAccessor();
					elementAccessor2.IsSoap = true;
					elementAccessor2.Name = xmlQualifiedName.Name;
					elementAccessor2.Namespace = ns;
					elementAccessor2.Mapping = typeMapping;
					elementAccessor2.IsNullable = true;
					elementAccessor2.Form = XmlSchemaForm.None;
					arrayMapping.Elements = new ElementAccessor[1] { elementAccessor2 };
					arrayMapping.TypeDesc = elementAccessor2.Mapping.TypeDesc.CreateArrayTypeDesc();
					arrayMapping.TypeName = "ArrayOf" + CodeIdentifier.MakePascal(elementAccessor2.Mapping.TypeName);
					return arrayMapping;
				}
			}
			XmlSchemaParticle particle = xmlSchemaComplexContentRestriction.Particle;
			if (particle is XmlSchemaAll || particle is XmlSchemaSequence)
			{
				XmlSchemaGroupBase xmlSchemaGroupBase = (XmlSchemaGroupBase)particle;
				if (xmlSchemaGroupBase.Items.Count != 1 || !(xmlSchemaGroupBase.Items[0] is XmlSchemaElement))
				{
					return null;
				}
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)xmlSchemaGroupBase.Items[0];
				if (!xmlSchemaElement.IsMultipleOccurrence)
				{
					return null;
				}
				ElementAccessor elementAccessor3 = ImportElement(xmlSchemaElement, ns);
				arrayMapping.Elements = new ElementAccessor[1] { elementAccessor3 };
				arrayMapping.TypeDesc = elementAccessor3.Mapping.TypeDesc.CreateArrayTypeDesc();
				return arrayMapping;
			}
			return null;
		}

		private void ImportElementMember(XmlSchemaElement element, CodeIdentifiers members, string ns)
		{
			ElementAccessor elementAccessor;
			if ((elementAccessor = ImportArray(element, ns)) == null)
			{
				elementAccessor = ImportElement(element, ns);
			}
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.Name = CodeIdentifier.MakeValid(Accessor.UnescapeName(elementAccessor.Name));
			memberMapping.Name = members.AddUnique(memberMapping.Name, memberMapping);
			if (memberMapping.Name.EndsWith("Specified", StringComparison.Ordinal))
			{
				string name = memberMapping.Name;
				memberMapping.Name = members.AddUnique(memberMapping.Name, memberMapping);
				members.Remove(name);
			}
			memberMapping.TypeDesc = elementAccessor.Mapping.TypeDesc;
			memberMapping.Elements = new ElementAccessor[1] { elementAccessor };
			if (element.IsMultipleOccurrence)
			{
				memberMapping.TypeDesc = memberMapping.TypeDesc.CreateArrayTypeDesc();
			}
			if (element.MinOccurs == 0m && memberMapping.TypeDesc.IsValueType && !memberMapping.TypeDesc.HasIsEmpty)
			{
				memberMapping.CheckSpecified = SpecifiedAccessor.ReadWrite;
			}
		}

		private TypeMapping ImportDataType(XmlSchemaSimpleType dataType, string typeNs, string identifier, bool isList)
		{
			TypeMapping typeMapping = ImportNonXsdPrimitiveDataType(dataType, typeNs);
			if (typeMapping != null)
			{
				return typeMapping;
			}
			if (dataType.Content is XmlSchemaSimpleTypeRestriction)
			{
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)dataType.Content;
				foreach (XmlSchemaObject facet in xmlSchemaSimpleTypeRestriction.Facets)
				{
					if (facet is XmlSchemaEnumerationFacet)
					{
						return ImportEnumeratedDataType(dataType, typeNs, identifier, isList);
					}
				}
			}
			else if (dataType.Content is XmlSchemaSimpleTypeList || dataType.Content is XmlSchemaSimpleTypeUnion)
			{
				if (dataType.Content is XmlSchemaSimpleTypeList)
				{
					XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = (XmlSchemaSimpleTypeList)dataType.Content;
					if (xmlSchemaSimpleTypeList.ItemType != null)
					{
						typeMapping = ImportDataType(xmlSchemaSimpleTypeList.ItemType, typeNs, identifier, isList: true);
						if (typeMapping != null)
						{
							return typeMapping;
						}
					}
				}
				typeMapping = new PrimitiveMapping();
				typeMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(string));
				typeMapping.TypeName = typeMapping.TypeDesc.DataType.Name;
				return typeMapping;
			}
			return ImportPrimitiveDataType(dataType);
		}

		private TypeMapping ImportEnumeratedDataType(XmlSchemaSimpleType dataType, string typeNs, string identifier, bool isList)
		{
			TypeMapping typeMapping = (TypeMapping)base.ImportedMappings[dataType];
			if (typeMapping != null)
			{
				return typeMapping;
			}
			XmlSchemaSimpleType dataType2 = FindDataType(dataType.DerivedFrom);
			TypeDesc typeDesc = base.Scope.GetTypeDesc(dataType2);
			if (typeDesc != null && typeDesc != base.Scope.GetTypeDesc(typeof(string)))
			{
				return ImportPrimitiveDataType(dataType);
			}
			identifier = Accessor.UnescapeName(identifier);
			string text = GenerateUniqueTypeName(identifier);
			EnumMapping enumMapping = new EnumMapping();
			enumMapping.IsReference = base.Schemas.IsReference(dataType);
			enumMapping.TypeDesc = new TypeDesc(text, text, TypeKind.Enum, null, TypeFlags.None);
			enumMapping.TypeName = identifier;
			enumMapping.Namespace = typeNs;
			enumMapping.IsFlags = isList;
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			if (!(dataType.Content is XmlSchemaSimpleTypeRestriction))
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidEnumContent", dataType.Content.GetType().Name, identifier));
			}
			XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)dataType.Content;
			for (int i = 0; i < xmlSchemaSimpleTypeRestriction.Facets.Count; i++)
			{
				object obj = xmlSchemaSimpleTypeRestriction.Facets[i];
				if (obj is XmlSchemaEnumerationFacet)
				{
					XmlSchemaEnumerationFacet xmlSchemaEnumerationFacet = (XmlSchemaEnumerationFacet)obj;
					ConstantMapping constantMapping = new ConstantMapping();
					string identifier2 = CodeIdentifier.MakeValid(xmlSchemaEnumerationFacet.Value);
					constantMapping.Name = codeIdentifiers.AddUnique(identifier2, constantMapping);
					constantMapping.XmlName = xmlSchemaEnumerationFacet.Value;
					constantMapping.Value = i;
				}
			}
			enumMapping.Constants = (ConstantMapping[])codeIdentifiers.ToArray(typeof(ConstantMapping));
			if (isList && enumMapping.Constants.Length > 63)
			{
				typeMapping = new PrimitiveMapping();
				typeMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(string));
				typeMapping.TypeName = typeMapping.TypeDesc.DataType.Name;
				base.ImportedMappings.Add(dataType, typeMapping);
				return typeMapping;
			}
			base.ImportedMappings.Add(dataType, enumMapping);
			base.Scope.AddTypeMapping(enumMapping);
			return enumMapping;
		}

		private PrimitiveMapping ImportPrimitiveDataType(XmlSchemaSimpleType dataType)
		{
			TypeDesc dataTypeSource = GetDataTypeSource(dataType);
			PrimitiveMapping primitiveMapping = new PrimitiveMapping();
			primitiveMapping.TypeDesc = dataTypeSource;
			primitiveMapping.TypeName = dataTypeSource.DataType.Name;
			return primitiveMapping;
		}

		private PrimitiveMapping ImportNonXsdPrimitiveDataType(XmlSchemaSimpleType dataType, string ns)
		{
			PrimitiveMapping primitiveMapping = null;
			TypeDesc typeDesc = null;
			if (dataType.Name != null && dataType.Name.Length != 0)
			{
				typeDesc = base.Scope.GetTypeDesc(dataType.Name, ns);
				if (typeDesc != null)
				{
					primitiveMapping = new PrimitiveMapping();
					primitiveMapping.TypeDesc = typeDesc;
					primitiveMapping.TypeName = typeDesc.DataType.Name;
				}
			}
			return primitiveMapping;
		}

		private TypeDesc GetDataTypeSource(XmlSchemaSimpleType dataType)
		{
			if (dataType.Name != null && dataType.Name.Length != 0)
			{
				TypeDesc typeDesc = base.Scope.GetTypeDesc(dataType);
				if (typeDesc != null)
				{
					return typeDesc;
				}
			}
			if (!dataType.DerivedFrom.IsEmpty)
			{
				return GetDataTypeSource(FindDataType(dataType.DerivedFrom));
			}
			return base.Scope.GetTypeDesc(typeof(string));
		}

		private XmlSchemaSimpleType FindDataType(XmlQualifiedName name)
		{
			TypeDesc typeDesc = base.Scope.GetTypeDesc(name.Name, name.Namespace);
			if (typeDesc != null && typeDesc.DataType is XmlSchemaSimpleType)
			{
				return (XmlSchemaSimpleType)typeDesc.DataType;
			}
			XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)base.Schemas.Find(name, typeof(XmlSchemaSimpleType));
			if (xmlSchemaSimpleType != null)
			{
				return xmlSchemaSimpleType;
			}
			if (name.Namespace == "http://www.w3.org/2001/XMLSchema")
			{
				return (XmlSchemaSimpleType)base.Scope.GetTypeDesc(typeof(string)).DataType;
			}
			throw new InvalidOperationException(Res.GetString("XmlMissingDataType", name.ToString()));
		}

		private object FindType(XmlQualifiedName name)
		{
			if (name != null && name.Namespace == "http://schemas.xmlsoap.org/soap/encoding/")
			{
				object obj = base.Schemas.Find(name, typeof(XmlSchemaComplexType));
				if (obj != null)
				{
					XmlSchemaType xmlSchemaType = (XmlSchemaType)obj;
					XmlQualifiedName derivedFrom = xmlSchemaType.DerivedFrom;
					if (!derivedFrom.IsEmpty)
					{
						return FindType(derivedFrom);
					}
					return xmlSchemaType;
				}
				return FindDataType(name);
			}
			object obj2 = base.Schemas.Find(name, typeof(XmlSchemaComplexType));
			if (obj2 != null)
			{
				return obj2;
			}
			return FindDataType(name);
		}
	}
	public class SoapSchemaMember
	{
		private string memberName;

		private XmlQualifiedName type = XmlQualifiedName.Empty;

		public XmlQualifiedName MemberType
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public string MemberName
		{
			get
			{
				if (memberName != null)
				{
					return memberName;
				}
				return string.Empty;
			}
			set
			{
				memberName = value;
			}
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Interface)]
	public class SoapTypeAttribute : Attribute
	{
		private string ns;

		private string typeName;

		private bool includeInSchema = true;

		public bool IncludeInSchema
		{
			get
			{
				return includeInSchema;
			}
			set
			{
				includeInSchema = value;
			}
		}

		public string TypeName
		{
			get
			{
				if (typeName != null)
				{
					return typeName;
				}
				return string.Empty;
			}
			set
			{
				typeName = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		public SoapTypeAttribute()
		{
		}

		public SoapTypeAttribute(string typeName)
		{
			this.typeName = typeName;
		}

		public SoapTypeAttribute(string typeName, string ns)
		{
			this.typeName = typeName;
			this.ns = ns;
		}
	}
	internal enum TypeKind
	{
		Root,
		Primitive,
		Enum,
		Struct,
		Class,
		Array,
		Collection,
		Enumerable,
		Void,
		Node,
		Attribute,
		Serializable
	}
	internal enum TypeFlags
	{
		None = 0,
		Abstract = 1,
		Reference = 2,
		Special = 4,
		CanBeAttributeValue = 8,
		CanBeTextValue = 0x10,
		CanBeElementValue = 0x20,
		HasCustomFormatter = 0x40,
		AmbiguousDataType = 0x80,
		IgnoreDefault = 0x200,
		HasIsEmpty = 0x400,
		HasDefaultConstructor = 0x800,
		XmlEncodingNotRequired = 0x1000,
		UseReflection = 0x4000,
		CollapseWhitespace = 0x8000,
		OptionalValue = 0x10000,
		CtorInaccessible = 0x20000,
		UsePrivateImplementation = 0x40000,
		GenericInterface = 0x80000,
		Unsupported = 0x100000
	}
	internal class TypeDesc
	{
		private string name;

		private string fullName;

		private string cSharpName;

		private TypeDesc arrayElementTypeDesc;

		private TypeDesc arrayTypeDesc;

		private TypeDesc nullableTypeDesc;

		private TypeKind kind;

		private XmlSchemaType dataType;

		private Type type;

		private TypeDesc baseTypeDesc;

		private TypeFlags flags;

		private string formatterName;

		private bool isXsdType;

		private bool isMixed;

		private MappedTypeDesc extendedType;

		private int weight;

		private Exception exception;

		internal TypeFlags Flags => flags;

		internal bool IsXsdType => isXsdType;

		internal bool IsMappedType => extendedType != null;

		internal MappedTypeDesc ExtendedType => extendedType;

		internal string Name => name;

		internal string FullName => fullName;

		internal string CSharpName
		{
			get
			{
				if (cSharpName == null)
				{
					cSharpName = ((type == null) ? CodeIdentifier.GetCSharpName(fullName) : CodeIdentifier.GetCSharpName(type));
				}
				return cSharpName;
			}
		}

		internal XmlSchemaType DataType => dataType;

		internal Type Type => type;

		internal string FormatterName => formatterName;

		internal TypeKind Kind => kind;

		internal bool IsValueType => (flags & TypeFlags.Reference) == 0;

		internal bool CanBeAttributeValue => (flags & TypeFlags.CanBeAttributeValue) != 0;

		internal bool XmlEncodingNotRequired => (flags & TypeFlags.XmlEncodingNotRequired) != 0;

		internal bool CanBeElementValue => (flags & TypeFlags.CanBeElementValue) != 0;

		internal bool CanBeTextValue => (flags & TypeFlags.CanBeTextValue) != 0;

		internal bool IsMixed
		{
			get
			{
				if (!isMixed)
				{
					return CanBeTextValue;
				}
				return true;
			}
			set
			{
				isMixed = value;
			}
		}

		internal bool IsSpecial => (flags & TypeFlags.Special) != 0;

		internal bool IsAmbiguousDataType => (flags & TypeFlags.AmbiguousDataType) != 0;

		internal bool HasCustomFormatter => (flags & TypeFlags.HasCustomFormatter) != 0;

		internal bool HasDefaultSupport => (flags & TypeFlags.IgnoreDefault) == 0;

		internal bool HasIsEmpty => (flags & TypeFlags.HasIsEmpty) != 0;

		internal bool CollapseWhitespace => (flags & TypeFlags.CollapseWhitespace) != 0;

		internal bool HasDefaultConstructor => (flags & TypeFlags.HasDefaultConstructor) != 0;

		internal bool IsUnsupported => (flags & TypeFlags.Unsupported) != 0;

		internal bool IsGenericInterface => (flags & TypeFlags.GenericInterface) != 0;

		internal bool IsPrivateImplementation => (flags & TypeFlags.UsePrivateImplementation) != 0;

		internal bool CannotNew
		{
			get
			{
				if (HasDefaultConstructor)
				{
					return ConstructorInaccessible;
				}
				return true;
			}
		}

		internal bool IsAbstract => (flags & TypeFlags.Abstract) != 0;

		internal bool IsOptionalValue => (flags & TypeFlags.OptionalValue) != 0;

		internal bool UseReflection => (flags & TypeFlags.UseReflection) != 0;

		internal bool IsVoid => kind == TypeKind.Void;

		internal bool IsClass => kind == TypeKind.Class;

		internal bool IsStructLike
		{
			get
			{
				if (kind != TypeKind.Struct)
				{
					return kind == TypeKind.Class;
				}
				return true;
			}
		}

		internal bool IsArrayLike
		{
			get
			{
				if (kind != TypeKind.Array && kind != TypeKind.Collection)
				{
					return kind == TypeKind.Enumerable;
				}
				return true;
			}
		}

		internal bool IsCollection => kind == TypeKind.Collection;

		internal bool IsEnumerable => kind == TypeKind.Enumerable;

		internal bool IsArray => kind == TypeKind.Array;

		internal bool IsPrimitive => kind == TypeKind.Primitive;

		internal bool IsEnum => kind == TypeKind.Enum;

		internal bool IsNullable => !IsValueType;

		internal bool IsRoot => kind == TypeKind.Root;

		internal bool ConstructorInaccessible => (flags & TypeFlags.CtorInaccessible) != 0;

		internal Exception Exception
		{
			get
			{
				return exception;
			}
			set
			{
				exception = value;
			}
		}

		internal string ArrayLengthName
		{
			get
			{
				if (kind != TypeKind.Array)
				{
					return "Count";
				}
				return "Length";
			}
		}

		internal TypeDesc ArrayElementTypeDesc
		{
			get
			{
				return arrayElementTypeDesc;
			}
			set
			{
				arrayElementTypeDesc = value;
			}
		}

		internal int Weight => weight;

		internal TypeDesc BaseTypeDesc
		{
			get
			{
				return baseTypeDesc;
			}
			set
			{
				baseTypeDesc = value;
				weight = ((baseTypeDesc != null) ? (baseTypeDesc.Weight + 1) : 0);
			}
		}

		internal TypeDesc(string name, string fullName, XmlSchemaType dataType, TypeKind kind, TypeDesc baseTypeDesc, TypeFlags flags, string formatterName)
		{
			this.name = name.Replace('+', '.');
			this.fullName = fullName.Replace('+', '.');
			this.kind = kind;
			this.baseTypeDesc = baseTypeDesc;
			this.flags = flags;
			isXsdType = kind == TypeKind.Primitive;
			if (isXsdType)
			{
				weight = 1;
			}
			else if (kind == TypeKind.Enum)
			{
				weight = 2;
			}
			else if (this.kind == TypeKind.Root)
			{
				weight = -1;
			}
			else
			{
				weight = ((baseTypeDesc != null) ? (baseTypeDesc.Weight + 1) : 0);
			}
			this.dataType = dataType;
			this.formatterName = formatterName;
		}

		internal TypeDesc(string name, string fullName, XmlSchemaType dataType, TypeKind kind, TypeDesc baseTypeDesc, TypeFlags flags)
			: this(name, fullName, dataType, kind, baseTypeDesc, flags, null)
		{
		}

		internal TypeDesc(string name, string fullName, TypeKind kind, TypeDesc baseTypeDesc, TypeFlags flags)
			: this(name, fullName, null, kind, baseTypeDesc, flags, null)
		{
		}

		internal TypeDesc(Type type, bool isXsdType, XmlSchemaType dataType, string formatterName, TypeFlags flags)
			: this(type.Name, type.FullName, dataType, TypeKind.Primitive, null, flags, formatterName)
		{
			this.isXsdType = isXsdType;
			this.type = type;
		}

		internal TypeDesc(Type type, string name, string fullName, TypeKind kind, TypeDesc baseTypeDesc, TypeFlags flags, TypeDesc arrayElementTypeDesc)
			: this(name, fullName, null, kind, baseTypeDesc, flags, null)
		{
			this.arrayElementTypeDesc = arrayElementTypeDesc;
			this.type = type;
		}

		public override string ToString()
		{
			return fullName;
		}

		internal TypeDesc GetNullableTypeDesc(Type type)
		{
			if (IsOptionalValue)
			{
				return this;
			}
			if (nullableTypeDesc == null)
			{
				nullableTypeDesc = new TypeDesc("NullableOf" + name, "System.Nullable`1[" + fullName + "]", null, TypeKind.Struct, this, flags | TypeFlags.OptionalValue, formatterName);
				nullableTypeDesc.type = type;
			}
			return nullableTypeDesc;
		}

		internal void CheckSupported()
		{
			if (IsUnsupported)
			{
				if (Exception != null)
				{
					throw Exception;
				}
				throw new NotSupportedException(Res.GetString("XmlSerializerUnsupportedType", FullName));
			}
			if (baseTypeDesc != null)
			{
				baseTypeDesc.CheckSupported();
			}
			if (arrayElementTypeDesc != null)
			{
				arrayElementTypeDesc.CheckSupported();
			}
		}

		internal void CheckNeedConstructor()
		{
			if (!IsValueType && !IsAbstract && !HasDefaultConstructor)
			{
				flags |= TypeFlags.Unsupported;
				exception = new InvalidOperationException(Res.GetString("XmlConstructorInaccessible", FullName));
			}
		}

		internal TypeDesc CreateArrayTypeDesc()
		{
			if (arrayTypeDesc == null)
			{
				arrayTypeDesc = new TypeDesc(null, name + "[]", fullName + "[]", TypeKind.Array, null, TypeFlags.Reference | (flags & TypeFlags.UseReflection), this);
			}
			return arrayTypeDesc;
		}

		internal TypeDesc CreateMappedTypeDesc(MappedTypeDesc extension)
		{
			TypeDesc typeDesc = new TypeDesc(extension.Name, extension.Name, null, kind, baseTypeDesc, flags, null);
			typeDesc.isXsdType = isXsdType;
			typeDesc.isMixed = isMixed;
			typeDesc.extendedType = extension;
			typeDesc.dataType = dataType;
			return typeDesc;
		}

		internal bool IsDerivedFrom(TypeDesc baseTypeDesc)
		{
			for (TypeDesc typeDesc = this; typeDesc != null; typeDesc = typeDesc.BaseTypeDesc)
			{
				if (typeDesc == baseTypeDesc)
				{
					return true;
				}
			}
			return baseTypeDesc.IsRoot;
		}

		internal static TypeDesc FindCommonBaseTypeDesc(TypeDesc[] typeDescs)
		{
			if (typeDescs.Length == 0)
			{
				return null;
			}
			TypeDesc typeDesc = null;
			int num = int.MaxValue;
			for (int i = 0; i < typeDescs.Length; i++)
			{
				int num2 = typeDescs[i].Weight;
				if (num2 < num)
				{
					num = num2;
					typeDesc = typeDescs[i];
				}
			}
			while (typeDesc != null)
			{
				int j;
				for (j = 0; j < typeDescs.Length && typeDescs[j].IsDerivedFrom(typeDesc); j++)
				{
				}
				if (j == typeDescs.Length)
				{
					break;
				}
				typeDesc = typeDesc.BaseTypeDesc;
			}
			return typeDesc;
		}
	}
	internal class TypeScope
	{
		private Hashtable typeDescs = new Hashtable();

		private Hashtable arrayTypeDescs = new Hashtable();

		private ArrayList typeMappings = new ArrayList();

		private static Hashtable primitiveTypes;

		private static Hashtable primitiveDataTypes;

		private static NameTable primitiveNames;

		private static string[] unsupportedTypes;

		internal ICollection Types => typeDescs.Keys;

		internal ICollection TypeMappings => typeMappings;

		internal static Hashtable PrimtiveTypes => primitiveTypes;

		static TypeScope()
		{
			primitiveTypes = new Hashtable();
			primitiveDataTypes = new Hashtable();
			primitiveNames = new NameTable();
			unsupportedTypes = new string[20]
			{
				"anyURI", "duration", "ENTITY", "ENTITIES", "gDay", "gMonth", "gMonthDay", "gYear", "gYearMonth", "ID",
				"IDREF", "IDREFS", "integer", "language", "negativeInteger", "nonNegativeInteger", "nonPositiveInteger", "NOTATION", "positiveInteger", "token"
			};
			AddPrimitive(typeof(string), "string", "String", (TypeFlags)2106);
			AddPrimitive(typeof(int), "int", "Int32", (TypeFlags)4136);
			AddPrimitive(typeof(bool), "boolean", "Boolean", (TypeFlags)4136);
			AddPrimitive(typeof(short), "short", "Int16", (TypeFlags)4136);
			AddPrimitive(typeof(long), "long", "Int64", (TypeFlags)4136);
			AddPrimitive(typeof(float), "float", "Single", (TypeFlags)4136);
			AddPrimitive(typeof(double), "double", "Double", (TypeFlags)4136);
			AddPrimitive(typeof(decimal), "decimal", "Decimal", (TypeFlags)4136);
			AddPrimitive(typeof(DateTime), "dateTime", "DateTime", (TypeFlags)4200);
			AddPrimitive(typeof(XmlQualifiedName), "QName", "XmlQualifiedName", (TypeFlags)5226);
			AddPrimitive(typeof(byte), "unsignedByte", "Byte", (TypeFlags)4136);
			AddPrimitive(typeof(sbyte), "byte", "SByte", (TypeFlags)4136);
			AddPrimitive(typeof(ushort), "unsignedShort", "UInt16", (TypeFlags)4136);
			AddPrimitive(typeof(uint), "unsignedInt", "UInt32", (TypeFlags)4136);
			AddPrimitive(typeof(ulong), "unsignedLong", "UInt64", (TypeFlags)4136);
			AddPrimitive(typeof(DateTime), "date", "Date", (TypeFlags)4328);
			AddPrimitive(typeof(DateTime), "time", "Time", (TypeFlags)4328);
			AddPrimitive(typeof(string), "Name", "XmlName", (TypeFlags)234);
			AddPrimitive(typeof(string), "NCName", "XmlNCName", (TypeFlags)234);
			AddPrimitive(typeof(string), "NMTOKEN", "XmlNmToken", (TypeFlags)234);
			AddPrimitive(typeof(string), "NMTOKENS", "XmlNmTokens", (TypeFlags)234);
			AddPrimitive(typeof(byte[]), "base64Binary", "ByteArrayBase64", (TypeFlags)6890);
			AddPrimitive(typeof(byte[]), "hexBinary", "ByteArrayHex", (TypeFlags)6890);
			XmlSchemaPatternFacet xmlSchemaPatternFacet = new XmlSchemaPatternFacet
			{
				Value = "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"
			};
			AddNonXsdPrimitive(typeof(Guid), "guid", "http://microsoft.com/wsdl/types/", "Guid", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), new XmlSchemaFacet[1] { xmlSchemaPatternFacet }, (TypeFlags)4648);
			AddNonXsdPrimitive(typeof(char), "char", "http://microsoft.com/wsdl/types/", "Char", new XmlQualifiedName("unsignedShort", "http://www.w3.org/2001/XMLSchema"), new XmlSchemaFacet[0], (TypeFlags)616);
			AddSoapEncodedTypes("http://schemas.xmlsoap.org/soap/encoding/");
			AddPrimitive(typeof(string), "normalizedString", "String", (TypeFlags)2234);
			for (int i = 0; i < unsupportedTypes.Length; i++)
			{
				AddPrimitive(typeof(string), unsupportedTypes[i], "String", (TypeFlags)32954);
			}
		}

		internal static bool IsKnownType(Type type)
		{
			if (type == typeof(object))
			{
				return true;
			}
			if (type.IsEnum)
			{
				return false;
			}
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.String:
				return true;
			case TypeCode.Int32:
				return true;
			case TypeCode.Boolean:
				return true;
			case TypeCode.Int16:
				return true;
			case TypeCode.Int64:
				return true;
			case TypeCode.Single:
				return true;
			case TypeCode.Double:
				return true;
			case TypeCode.Decimal:
				return true;
			case TypeCode.DateTime:
				return true;
			case TypeCode.Byte:
				return true;
			case TypeCode.SByte:
				return true;
			case TypeCode.UInt16:
				return true;
			case TypeCode.UInt32:
				return true;
			case TypeCode.UInt64:
				return true;
			case TypeCode.Char:
				return true;
			default:
				if (type == typeof(XmlQualifiedName))
				{
					return true;
				}
				if (type == typeof(byte[]))
				{
					return true;
				}
				if (type == typeof(Guid))
				{
					return true;
				}
				if (type == typeof(XmlNode[]))
				{
					return true;
				}
				return false;
			}
		}

		private static void AddSoapEncodedTypes(string ns)
		{
			AddSoapEncodedPrimitive(typeof(string), "normalizedString", ns, "String", new XmlQualifiedName("normalizedString", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)2218);
			for (int i = 0; i < unsupportedTypes.Length; i++)
			{
				AddSoapEncodedPrimitive(typeof(string), unsupportedTypes[i], ns, "String", new XmlQualifiedName(unsupportedTypes[i], "http://www.w3.org/2001/XMLSchema"), (TypeFlags)32938);
			}
			AddSoapEncodedPrimitive(typeof(string), "string", ns, "String", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)58);
			AddSoapEncodedPrimitive(typeof(int), "int", ns, "Int32", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(bool), "boolean", ns, "Boolean", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(short), "short", ns, "Int16", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(long), "long", ns, "Int64", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(float), "float", ns, "Single", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(double), "double", ns, "Double", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(decimal), "decimal", ns, "Decimal", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(DateTime), "dateTime", ns, "DateTime", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4200);
			AddSoapEncodedPrimitive(typeof(XmlQualifiedName), "QName", ns, "XmlQualifiedName", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)5226);
			AddSoapEncodedPrimitive(typeof(byte), "unsignedByte", ns, "Byte", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(sbyte), "byte", ns, "SByte", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(ushort), "unsignedShort", ns, "UInt16", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(uint), "unsignedInt", ns, "UInt32", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(ulong), "unsignedLong", ns, "UInt64", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4136);
			AddSoapEncodedPrimitive(typeof(DateTime), "date", ns, "Date", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4328);
			AddSoapEncodedPrimitive(typeof(DateTime), "time", ns, "Time", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4328);
			AddSoapEncodedPrimitive(typeof(string), "Name", ns, "XmlName", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)234);
			AddSoapEncodedPrimitive(typeof(string), "NCName", ns, "XmlNCName", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)234);
			AddSoapEncodedPrimitive(typeof(string), "NMTOKEN", ns, "XmlNmToken", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)234);
			AddSoapEncodedPrimitive(typeof(string), "NMTOKENS", ns, "XmlNmTokens", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)234);
			AddSoapEncodedPrimitive(typeof(byte[]), "base64Binary", ns, "ByteArrayBase64", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4842);
			AddSoapEncodedPrimitive(typeof(byte[]), "hexBinary", ns, "ByteArrayHex", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)4842);
			AddSoapEncodedPrimitive(typeof(string), "arrayCoordinate", ns, "String", new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)40);
			AddSoapEncodedPrimitive(typeof(byte[]), "base64", ns, "ByteArrayBase64", new XmlQualifiedName("base64Binary", "http://www.w3.org/2001/XMLSchema"), (TypeFlags)554);
		}

		private static void AddPrimitive(Type type, string dataTypeName, string formatterName, TypeFlags flags)
		{
			XmlSchemaSimpleType xmlSchemaSimpleType = new XmlSchemaSimpleType();
			xmlSchemaSimpleType.Name = dataTypeName;
			TypeDesc value = new TypeDesc(type, isXsdType: true, xmlSchemaSimpleType, formatterName, flags);
			if (primitiveTypes[type] == null)
			{
				primitiveTypes.Add(type, value);
			}
			primitiveDataTypes.Add(xmlSchemaSimpleType, value);
			primitiveNames.Add(dataTypeName, "http://www.w3.org/2001/XMLSchema", value);
		}

		private static void AddNonXsdPrimitive(Type type, string dataTypeName, string ns, string formatterName, XmlQualifiedName baseTypeName, XmlSchemaFacet[] facets, TypeFlags flags)
		{
			XmlSchemaSimpleType xmlSchemaSimpleType = new XmlSchemaSimpleType();
			xmlSchemaSimpleType.Name = dataTypeName;
			XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = new XmlSchemaSimpleTypeRestriction();
			xmlSchemaSimpleTypeRestriction.BaseTypeName = baseTypeName;
			foreach (XmlSchemaFacet item in facets)
			{
				xmlSchemaSimpleTypeRestriction.Facets.Add(item);
			}
			xmlSchemaSimpleType.Content = xmlSchemaSimpleTypeRestriction;
			TypeDesc value = new TypeDesc(type, isXsdType: false, xmlSchemaSimpleType, formatterName, flags);
			if (primitiveTypes[type] == null)
			{
				primitiveTypes.Add(type, value);
			}
			primitiveDataTypes.Add(xmlSchemaSimpleType, value);
			primitiveNames.Add(dataTypeName, ns, value);
		}

		private static void AddSoapEncodedPrimitive(Type type, string dataTypeName, string ns, string formatterName, XmlQualifiedName baseTypeName, TypeFlags flags)
		{
			AddNonXsdPrimitive(type, dataTypeName, ns, formatterName, baseTypeName, new XmlSchemaFacet[0], flags);
		}

		internal TypeDesc GetTypeDesc(string name, string ns)
		{
			return GetTypeDesc(name, ns, (TypeFlags)56);
		}

		internal TypeDesc GetTypeDesc(string name, string ns, TypeFlags flags)
		{
			TypeDesc typeDesc = (TypeDesc)primitiveNames[name, ns];
			if (typeDesc != null && (typeDesc.Flags & flags) != 0)
			{
				return typeDesc;
			}
			return null;
		}

		internal TypeDesc GetTypeDesc(XmlSchemaSimpleType dataType)
		{
			return (TypeDesc)primitiveDataTypes[dataType];
		}

		internal TypeDesc GetTypeDesc(Type type)
		{
			return GetTypeDesc(type, null, directReference: true, throwOnError: true);
		}

		internal TypeDesc GetTypeDesc(Type type, MemberInfo source)
		{
			return GetTypeDesc(type, source, directReference: true, throwOnError: true);
		}

		internal TypeDesc GetTypeDesc(Type type, MemberInfo source, bool directReference)
		{
			return GetTypeDesc(type, source, directReference, throwOnError: true);
		}

		internal TypeDesc GetTypeDesc(Type type, MemberInfo source, bool directReference, bool throwOnError)
		{
			if (type.ContainsGenericParameters)
			{
				throw new InvalidOperationException(Res.GetString("XmlUnsupportedOpenGenericType", type.ToString()));
			}
			TypeDesc typeDesc = (TypeDesc)primitiveTypes[type];
			if (typeDesc == null)
			{
				typeDesc = (TypeDesc)typeDescs[type];
				if (typeDesc == null)
				{
					typeDesc = ImportTypeDesc(type, source, directReference);
				}
			}
			if (throwOnError)
			{
				typeDesc.CheckSupported();
			}
			return typeDesc;
		}

		internal TypeDesc GetArrayTypeDesc(Type type)
		{
			TypeDesc typeDesc = (TypeDesc)arrayTypeDescs[type];
			if (typeDesc == null)
			{
				typeDesc = GetTypeDesc(type);
				if (!typeDesc.IsArrayLike)
				{
					typeDesc = ImportTypeDesc(type, null, directReference: false);
				}
				typeDesc.CheckSupported();
				arrayTypeDescs.Add(type, typeDesc);
			}
			return typeDesc;
		}

		internal TypeMapping GetTypeMappingFromTypeDesc(TypeDesc typeDesc)
		{
			foreach (TypeMapping typeMapping in TypeMappings)
			{
				if (typeMapping.TypeDesc == typeDesc)
				{
					return typeMapping;
				}
			}
			return null;
		}

		internal Type GetTypeFromTypeDesc(TypeDesc typeDesc)
		{
			if (typeDesc.Type != null)
			{
				return typeDesc.Type;
			}
			foreach (DictionaryEntry typeDesc2 in typeDescs)
			{
				if (typeDesc2.Value == typeDesc)
				{
					return typeDesc2.Key as Type;
				}
			}
			return null;
		}

		private TypeDesc ImportTypeDesc(Type type, MemberInfo memberInfo, bool directReference)
		{
			TypeDesc typeDesc = null;
			Type type2 = null;
			Type type3 = null;
			TypeFlags flags = TypeFlags.None;
			Exception exception = null;
			if (!type.IsPublic && !type.IsNestedPublic)
			{
				flags |= TypeFlags.Unsupported;
				exception = new InvalidOperationException(Res.GetString("XmlTypeInaccessible", type.FullName));
			}
			else if (type.IsAbstract && type.IsSealed)
			{
				flags |= TypeFlags.Unsupported;
				exception = new InvalidOperationException(Res.GetString("XmlTypeStatic", type.FullName));
			}
			if (DynamicAssemblies.IsTypeDynamic(type))
			{
				flags |= TypeFlags.UseReflection;
			}
			if (!type.IsValueType)
			{
				flags |= TypeFlags.Reference;
			}
			TypeKind typeKind;
			if (type == typeof(object))
			{
				typeKind = TypeKind.Root;
				flags |= TypeFlags.HasDefaultConstructor;
			}
			else if (type == typeof(ValueType))
			{
				typeKind = TypeKind.Enum;
				flags |= TypeFlags.Unsupported;
				if (exception == null)
				{
					exception = new NotSupportedException(Res.GetString("XmlSerializerUnsupportedType", type.FullName));
				}
			}
			else if (type == typeof(void))
			{
				typeKind = TypeKind.Void;
			}
			else if (typeof(IXmlSerializable).IsAssignableFrom(type))
			{
				typeKind = TypeKind.Serializable;
				flags |= (TypeFlags)36;
				flags |= GetConstructorFlags(type, ref exception);
			}
			else if (type.IsArray)
			{
				typeKind = TypeKind.Array;
				if (type.GetArrayRank() > 1)
				{
					flags |= TypeFlags.Unsupported;
					if (exception == null)
					{
						exception = new NotSupportedException(Res.GetString("XmlUnsupportedRank", type.FullName));
					}
				}
				type2 = type.GetElementType();
				flags |= TypeFlags.HasDefaultConstructor;
			}
			else if (typeof(ICollection).IsAssignableFrom(type))
			{
				typeKind = TypeKind.Collection;
				type2 = GetCollectionElementType(type, (memberInfo == null) ? null : (memberInfo.DeclaringType.FullName + "." + memberInfo.Name));
				flags |= GetConstructorFlags(type, ref exception);
			}
			else if (type == typeof(XmlQualifiedName))
			{
				typeKind = TypeKind.Primitive;
			}
			else if (type.IsPrimitive)
			{
				typeKind = TypeKind.Primitive;
				flags |= TypeFlags.Unsupported;
				if (exception == null)
				{
					exception = new NotSupportedException(Res.GetString("XmlSerializerUnsupportedType", type.FullName));
				}
			}
			else if (type.IsEnum)
			{
				typeKind = TypeKind.Enum;
			}
			else if (type.IsValueType)
			{
				typeKind = TypeKind.Struct;
				if (IsOptionalValue(type))
				{
					type3 = type.GetGenericArguments()[0];
					flags |= TypeFlags.OptionalValue;
				}
				else
				{
					type3 = type.BaseType;
				}
				if (type.IsAbstract)
				{
					flags |= TypeFlags.Abstract;
				}
			}
			else if (type.IsClass)
			{
				if (type == typeof(XmlAttribute))
				{
					typeKind = TypeKind.Attribute;
					flags |= (TypeFlags)12;
				}
				else if (typeof(XmlNode).IsAssignableFrom(type))
				{
					typeKind = TypeKind.Node;
					type3 = type.BaseType;
					flags |= (TypeFlags)52;
					if (typeof(XmlText).IsAssignableFrom(type))
					{
						flags &= (TypeFlags)(-33);
					}
					else if (typeof(XmlElement).IsAssignableFrom(type))
					{
						flags &= (TypeFlags)(-17);
					}
					else if (type.IsAssignableFrom(typeof(XmlAttribute)))
					{
						flags |= TypeFlags.CanBeAttributeValue;
					}
				}
				else
				{
					typeKind = TypeKind.Class;
					type3 = type.BaseType;
					if (type.IsAbstract)
					{
						flags |= TypeFlags.Abstract;
					}
				}
			}
			else if (type.IsInterface)
			{
				typeKind = TypeKind.Void;
				flags |= TypeFlags.Unsupported;
				if (exception == null)
				{
					exception = ((memberInfo != null) ? new NotSupportedException(Res.GetString("XmlUnsupportedInterfaceDetails", memberInfo.DeclaringType.FullName + "." + memberInfo.Name, type.FullName)) : new NotSupportedException(Res.GetString("XmlUnsupportedInterface", type.FullName)));
				}
			}
			else
			{
				typeKind = TypeKind.Void;
				flags |= TypeFlags.Unsupported;
				if (exception == null)
				{
					exception = new NotSupportedException(Res.GetString("XmlSerializerUnsupportedType", type.FullName));
				}
			}
			if (typeKind == TypeKind.Class && !type.IsAbstract)
			{
				flags |= GetConstructorFlags(type, ref exception);
			}
			if ((typeKind == TypeKind.Struct || typeKind == TypeKind.Class) && typeof(IEnumerable).IsAssignableFrom(type))
			{
				type2 = GetEnumeratorElementType(type, ref flags);
				typeKind = TypeKind.Enumerable;
				flags |= GetConstructorFlags(type, ref exception);
			}
			typeDesc = new TypeDesc(type, CodeIdentifier.MakeValid(TypeName(type)), type.ToString(), typeKind, null, flags, null);
			typeDesc.Exception = exception;
			if (directReference && (typeDesc.IsClass || typeKind == TypeKind.Serializable))
			{
				typeDesc.CheckNeedConstructor();
			}
			if (typeDesc.IsUnsupported)
			{
				return typeDesc;
			}
			typeDescs.Add(type, typeDesc);
			if (type2 != null)
			{
				TypeDesc typeDesc2 = GetTypeDesc(type2, memberInfo, directReference: true, throwOnError: false);
				if (directReference && (typeDesc2.IsCollection || typeDesc2.IsEnumerable) && !typeDesc2.IsPrimitive)
				{
					typeDesc2.CheckNeedConstructor();
				}
				typeDesc.ArrayElementTypeDesc = typeDesc2;
			}
			if (type3 != null && type3 != typeof(object) && type3 != typeof(ValueType))
			{
				typeDesc.BaseTypeDesc = GetTypeDesc(type3, memberInfo, directReference: false, throwOnError: false);
			}
			if (type.IsNestedPublic)
			{
				Type declaringType = type.DeclaringType;
				while (declaringType != null && !declaringType.ContainsGenericParameters)
				{
					GetTypeDesc(declaringType, null, directReference: false);
					declaringType = declaringType.DeclaringType;
				}
			}
			return typeDesc;
		}

		internal static bool IsOptionalValue(Type type)
		{
			if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>).GetGenericTypeDefinition())
			{
				return true;
			}
			return false;
		}

		internal static string TypeName(Type t)
		{
			if (t.IsArray)
			{
				return "ArrayOf" + TypeName(t.GetElementType());
			}
			if (t.IsGenericType)
			{
				StringBuilder stringBuilder = new StringBuilder();
				StringBuilder stringBuilder2 = new StringBuilder();
				string text = t.Name;
				int num = text.IndexOf("`", StringComparison.Ordinal);
				if (num >= 0)
				{
					text = text.Substring(0, num);
				}
				stringBuilder.Append(text);
				stringBuilder.Append("Of");
				Type[] genericArguments = t.GetGenericArguments();
				for (int i = 0; i < genericArguments.Length; i++)
				{
					stringBuilder.Append(TypeName(genericArguments[i]));
					stringBuilder2.Append(genericArguments[i].Namespace);
				}
				return stringBuilder.ToString();
			}
			return t.Name;
		}

		internal static Type GetArrayElementType(Type type, string memberInfo)
		{
			if (type.IsArray)
			{
				return type.GetElementType();
			}
			if (typeof(ICollection).IsAssignableFrom(type))
			{
				return GetCollectionElementType(type, memberInfo);
			}
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				TypeFlags flags = TypeFlags.None;
				return GetEnumeratorElementType(type, ref flags);
			}
			return null;
		}

		internal static MemberMapping[] GetAllMembers(StructMapping mapping)
		{
			if (mapping.BaseMapping == null)
			{
				return mapping.Members;
			}
			ArrayList arrayList = new ArrayList();
			GetAllMembers(mapping, arrayList);
			return (MemberMapping[])arrayList.ToArray(typeof(MemberMapping));
		}

		internal static void GetAllMembers(StructMapping mapping, ArrayList list)
		{
			if (mapping.BaseMapping != null)
			{
				GetAllMembers(mapping.BaseMapping, list);
			}
			for (int i = 0; i < mapping.Members.Length; i++)
			{
				list.Add(mapping.Members[i]);
			}
		}

		private static TypeFlags GetConstructorFlags(Type type, ref Exception exception)
		{
			ConstructorInfo constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
			if (constructor != null)
			{
				TypeFlags typeFlags = TypeFlags.HasDefaultConstructor;
				if (!constructor.IsPublic)
				{
					typeFlags |= TypeFlags.CtorInaccessible;
				}
				else
				{
					object[] customAttributes = constructor.GetCustomAttributes(typeof(ObsoleteAttribute), inherit: false);
					if (customAttributes != null && customAttributes.Length > 0)
					{
						ObsoleteAttribute obsoleteAttribute = (ObsoleteAttribute)customAttributes[0];
						if (obsoleteAttribute.IsError)
						{
							typeFlags |= TypeFlags.CtorInaccessible;
						}
					}
				}
				return typeFlags;
			}
			return TypeFlags.None;
		}

		private static Type GetEnumeratorElementType(Type type, ref TypeFlags flags)
		{
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				MethodInfo methodInfo = type.GetMethod("GetEnumerator", new Type[0]);
				if (methodInfo == null || !typeof(IEnumerator).IsAssignableFrom(methodInfo.ReturnType))
				{
					methodInfo = null;
					MemberInfo[] member = type.GetMember("System.Collections.Generic.IEnumerable<*", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
					foreach (MemberInfo memberInfo in member)
					{
						methodInfo = memberInfo as MethodInfo;
						if (methodInfo != null && typeof(IEnumerator).IsAssignableFrom(methodInfo.ReturnType))
						{
							flags |= TypeFlags.GenericInterface;
							break;
						}
						methodInfo = null;
					}
					if (methodInfo == null)
					{
						flags |= TypeFlags.UsePrivateImplementation;
						methodInfo = type.GetMethod("System.Collections.IEnumerable.GetEnumerator", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
					}
				}
				if (methodInfo == null || !typeof(IEnumerator).IsAssignableFrom(methodInfo.ReturnType))
				{
					return null;
				}
				XmlAttributes xmlAttributes = new XmlAttributes(methodInfo);
				if (xmlAttributes.XmlIgnore)
				{
					return null;
				}
				PropertyInfo property = methodInfo.ReturnType.GetProperty("Current");
				Type type2 = ((property == null) ? typeof(object) : property.PropertyType);
				MethodInfo method = type.GetMethod("Add", new Type[1] { type2 });
				if (method == null && type2 != typeof(object))
				{
					type2 = typeof(object);
					method = type.GetMethod("Add", new Type[1] { type2 });
				}
				if (method == null)
				{
					throw new InvalidOperationException(Res.GetString("XmlNoAddMethod", type.FullName, type2, "IEnumerable"));
				}
				return type2;
			}
			return null;
		}

		internal static PropertyInfo GetDefaultIndexer(Type type, string memberInfo)
		{
			if (typeof(IDictionary).IsAssignableFrom(type))
			{
				if (memberInfo == null)
				{
					throw new NotSupportedException(Res.GetString("XmlUnsupportedIDictionary", type.FullName));
				}
				throw new NotSupportedException(Res.GetString("XmlUnsupportedIDictionaryDetails", memberInfo, type.FullName));
			}
			MemberInfo[] defaultMembers = type.GetDefaultMembers();
			PropertyInfo propertyInfo = null;
			if (defaultMembers != null && defaultMembers.Length > 0)
			{
				for (Type type2 = type; type2 != null; type2 = type2.BaseType)
				{
					for (int i = 0; i < defaultMembers.Length; i++)
					{
						if (!(defaultMembers[i] is PropertyInfo))
						{
							continue;
						}
						PropertyInfo propertyInfo2 = (PropertyInfo)defaultMembers[i];
						if (propertyInfo2.DeclaringType == type2 && propertyInfo2.CanRead)
						{
							MethodInfo getMethod = propertyInfo2.GetGetMethod();
							ParameterInfo[] parameters = getMethod.GetParameters();
							if (parameters.Length == 1 && parameters[0].ParameterType == typeof(int))
							{
								propertyInfo = propertyInfo2;
								break;
							}
						}
					}
					if (propertyInfo != null)
					{
						break;
					}
				}
			}
			if (propertyInfo == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlNoDefaultAccessors", type.FullName));
			}
			MethodInfo method = type.GetMethod("Add", new Type[1] { propertyInfo.PropertyType });
			if (method == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlNoAddMethod", type.FullName, propertyInfo.PropertyType, "ICollection"));
			}
			return propertyInfo;
		}

		private static Type GetCollectionElementType(Type type, string memberInfo)
		{
			return GetDefaultIndexer(type, memberInfo).PropertyType;
		}

		internal static XmlQualifiedName ParseWsdlArrayType(string type, out string dims, XmlSchemaObject parent)
		{
			int num = type.LastIndexOf(':');
			string text = ((num > 0) ? type.Substring(0, num) : "");
			int num2 = type.IndexOf('[', num + 1);
			if (num2 <= num)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidArrayTypeSyntax", type));
			}
			string name = type.Substring(num + 1, num2 - num - 1);
			dims = type.Substring(num2);
			while (parent != null)
			{
				if (parent.Namespaces != null)
				{
					string text2 = (string)parent.Namespaces.Namespaces[text];
					if (text2 != null)
					{
						text = text2;
						break;
					}
				}
				parent = parent.Parent;
			}
			return new XmlQualifiedName(name, text);
		}

		internal void AddTypeMapping(TypeMapping typeMapping)
		{
			typeMappings.Add(typeMapping);
		}
	}
	internal class Soap
	{
		internal const string Encoding = "http://schemas.xmlsoap.org/soap/encoding/";

		internal const string UrType = "anyType";

		internal const string Array = "Array";

		internal const string ArrayType = "arrayType";

		private Soap()
		{
		}
	}
	internal class Soap12
	{
		internal const string Encoding = "http://www.w3.org/2003/05/soap-encoding";

		internal const string RpcNamespace = "http://www.w3.org/2003/05/soap-rpc";

		internal const string RpcResult = "result";

		private Soap12()
		{
		}
	}
	internal class Wsdl
	{
		internal const string Namespace = "http://schemas.xmlsoap.org/wsdl/";

		internal const string ArrayType = "arrayType";

		private Wsdl()
		{
		}
	}
	internal class UrtTypes
	{
		internal const string Namespace = "http://microsoft.com/wsdl/types/";

		private UrtTypes()
		{
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = false)]
	public class XmlAnyAttributeAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = true)]
	public class XmlAnyElementAttribute : Attribute
	{
		private string name;

		private string ns;

		private int order = -1;

		private bool nsSpecified;

		public string Name
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
				nsSpecified = true;
			}
		}

		public int Order
		{
			get
			{
				return order;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(Res.GetString("XmlDisallowNegativeValues"), "Order");
				}
				order = value;
			}
		}

		internal bool NamespaceSpecified => nsSpecified;

		public XmlAnyElementAttribute()
		{
		}

		public XmlAnyElementAttribute(string name)
		{
			this.name = name;
		}

		public XmlAnyElementAttribute(string name, string ns)
		{
			this.name = name;
			this.ns = ns;
			nsSpecified = true;
		}
	}
	public class XmlAnyElementAttributes : CollectionBase
	{
		public XmlAnyElementAttribute this[int index]
		{
			get
			{
				return (XmlAnyElementAttribute)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public int Add(XmlAnyElementAttribute attribute)
		{
			return base.List.Add(attribute);
		}

		public void Insert(int index, XmlAnyElementAttribute attribute)
		{
			base.List.Insert(index, attribute);
		}

		public int IndexOf(XmlAnyElementAttribute attribute)
		{
			return base.List.IndexOf(attribute);
		}

		public bool Contains(XmlAnyElementAttribute attribute)
		{
			return base.List.Contains(attribute);
		}

		public void Remove(XmlAnyElementAttribute attribute)
		{
			base.List.Remove(attribute);
		}

		public void CopyTo(XmlAnyElementAttribute[] array, int index)
		{
			base.List.CopyTo(array, index);
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = false)]
	public class XmlArrayAttribute : Attribute
	{
		private string elementName;

		private string ns;

		private bool nullable;

		private XmlSchemaForm form;

		private int order = -1;

		public string ElementName
		{
			get
			{
				if (elementName != null)
				{
					return elementName;
				}
				return string.Empty;
			}
			set
			{
				elementName = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		public bool IsNullable
		{
			get
			{
				return nullable;
			}
			set
			{
				nullable = value;
			}
		}

		public XmlSchemaForm Form
		{
			get
			{
				return form;
			}
			set
			{
				form = value;
			}
		}

		public int Order
		{
			get
			{
				return order;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(Res.GetString("XmlDisallowNegativeValues"), "Order");
				}
				order = value;
			}
		}

		public XmlArrayAttribute()
		{
		}

		public XmlArrayAttribute(string elementName)
		{
			this.elementName = elementName;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = true)]
	public class XmlArrayItemAttribute : Attribute
	{
		private string elementName;

		private Type type;

		private string ns;

		private string dataType;

		private bool nullable;

		private bool nullableSpecified;

		private XmlSchemaForm form;

		private int nestingLevel;

		public Type Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public string ElementName
		{
			get
			{
				if (elementName != null)
				{
					return elementName;
				}
				return string.Empty;
			}
			set
			{
				elementName = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		public int NestingLevel
		{
			get
			{
				return nestingLevel;
			}
			set
			{
				nestingLevel = value;
			}
		}

		public string DataType
		{
			get
			{
				if (dataType != null)
				{
					return dataType;
				}
				return string.Empty;
			}
			set
			{
				dataType = value;
			}
		}

		public bool IsNullable
		{
			get
			{
				return nullable;
			}
			set
			{
				nullable = value;
				nullableSpecified = true;
			}
		}

		internal bool IsNullableSpecified => nullableSpecified;

		public XmlSchemaForm Form
		{
			get
			{
				return form;
			}
			set
			{
				form = value;
			}
		}

		public XmlArrayItemAttribute()
		{
		}

		public XmlArrayItemAttribute(string elementName)
		{
			this.elementName = elementName;
		}

		public XmlArrayItemAttribute(Type type)
		{
			this.type = type;
		}

		public XmlArrayItemAttribute(string elementName, Type type)
		{
			this.elementName = elementName;
			this.type = type;
		}
	}
	public class XmlArrayItemAttributes : CollectionBase
	{
		public XmlArrayItemAttribute this[int index]
		{
			get
			{
				return (XmlArrayItemAttribute)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public int Add(XmlArrayItemAttribute attribute)
		{
			return base.List.Add(attribute);
		}

		public void Insert(int index, XmlArrayItemAttribute attribute)
		{
			base.List.Insert(index, attribute);
		}

		public int IndexOf(XmlArrayItemAttribute attribute)
		{
			return base.List.IndexOf(attribute);
		}

		public bool Contains(XmlArrayItemAttribute attribute)
		{
			return base.List.Contains(attribute);
		}

		public void Remove(XmlArrayItemAttribute attribute)
		{
			base.List.Remove(attribute);
		}

		public void CopyTo(XmlArrayItemAttribute[] array, int index)
		{
			base.List.CopyTo(array, index);
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
	public class XmlAttributeAttribute : Attribute
	{
		private string attributeName;

		private Type type;

		private string ns;

		private string dataType;

		private XmlSchemaForm form;

		public Type Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public string AttributeName
		{
			get
			{
				if (attributeName != null)
				{
					return attributeName;
				}
				return string.Empty;
			}
			set
			{
				attributeName = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		public string DataType
		{
			get
			{
				if (dataType != null)
				{
					return dataType;
				}
				return string.Empty;
			}
			set
			{
				dataType = value;
			}
		}

		public XmlSchemaForm Form
		{
			get
			{
				return form;
			}
			set
			{
				form = value;
			}
		}

		public XmlAttributeAttribute()
		{
		}

		public XmlAttributeAttribute(string attributeName)
		{
			this.attributeName = attributeName;
		}

		public XmlAttributeAttribute(Type type)
		{
			this.type = type;
		}

		public XmlAttributeAttribute(string attributeName, Type type)
		{
			this.attributeName = attributeName;
			this.type = type;
		}
	}
	public class XmlAttributeOverrides
	{
		private Hashtable types = new Hashtable();

		public XmlAttributes this[Type type] => this[type, string.Empty];

		public XmlAttributes this[Type type, string member]
		{
			get
			{
				Hashtable hashtable = (Hashtable)types[type];
				if (hashtable == null)
				{
					return null;
				}
				return (XmlAttributes)hashtable[member];
			}
		}

		public void Add(Type type, XmlAttributes attributes)
		{
			Add(type, string.Empty, attributes);
		}

		public void Add(Type type, string member, XmlAttributes attributes)
		{
			Hashtable hashtable = (Hashtable)types[type];
			if (hashtable == null)
			{
				hashtable = new Hashtable();
				types.Add(type, hashtable);
			}
			else if (hashtable[member] != null)
			{
				throw new InvalidOperationException(Res.GetString("XmlAttributeSetAgain", type.FullName, member));
			}
			hashtable.Add(member, attributes);
		}
	}
	internal enum XmlAttributeFlags
	{
		Enum = 1,
		Array = 2,
		Text = 4,
		ArrayItems = 8,
		Elements = 0x10,
		Attribute = 0x20,
		Root = 0x40,
		Type = 0x80,
		AnyElements = 0x100,
		AnyAttribute = 0x200,
		ChoiceIdentifier = 0x400,
		XmlnsDeclarations = 0x800
	}
	public class XmlAttributes
	{
		private XmlElementAttributes xmlElements = new XmlElementAttributes();

		private XmlArrayItemAttributes xmlArrayItems = new XmlArrayItemAttributes();

		private XmlAnyElementAttributes xmlAnyElements = new XmlAnyElementAttributes();

		private XmlArrayAttribute xmlArray;

		private XmlAttributeAttribute xmlAttribute;

		private XmlTextAttribute xmlText;

		private XmlEnumAttribute xmlEnum;

		private bool xmlIgnore;

		private bool xmlns;

		private object xmlDefaultValue;

		private XmlRootAttribute xmlRoot;

		private XmlTypeAttribute xmlType;

		private XmlAnyAttributeAttribute xmlAnyAttribute;

		private XmlChoiceIdentifierAttribute xmlChoiceIdentifier;

		private static Type ignoreAttributeType;

		internal XmlAttributeFlags XmlFlags
		{
			get
			{
				XmlAttributeFlags xmlAttributeFlags = (XmlAttributeFlags)0;
				if (xmlElements.Count > 0)
				{
					xmlAttributeFlags |= XmlAttributeFlags.Elements;
				}
				if (xmlArrayItems.Count > 0)
				{
					xmlAttributeFlags |= XmlAttributeFlags.ArrayItems;
				}
				if (xmlAnyElements.Count > 0)
				{
					xmlAttributeFlags |= XmlAttributeFlags.AnyElements;
				}
				if (xmlArray != null)
				{
					xmlAttributeFlags |= XmlAttributeFlags.Array;
				}
				if (xmlAttribute != null)
				{
					xmlAttributeFlags |= XmlAttributeFlags.Attribute;
				}
				if (xmlText != null)
				{
					xmlAttributeFlags |= XmlAttributeFlags.Text;
				}
				if (xmlEnum != null)
				{
					xmlAttributeFlags |= XmlAttributeFlags.Enum;
				}
				if (xmlRoot != null)
				{
					xmlAttributeFlags |= XmlAttributeFlags.Root;
				}
				if (xmlType != null)
				{
					xmlAttributeFlags |= XmlAttributeFlags.Type;
				}
				if (xmlAnyAttribute != null)
				{
					xmlAttributeFlags |= XmlAttributeFlags.AnyAttribute;
				}
				if (xmlChoiceIdentifier != null)
				{
					xmlAttributeFlags |= XmlAttributeFlags.ChoiceIdentifier;
				}
				if (xmlns)
				{
					xmlAttributeFlags |= XmlAttributeFlags.XmlnsDeclarations;
				}
				return xmlAttributeFlags;
			}
		}

		private static Type IgnoreAttribute
		{
			get
			{
				if (ignoreAttributeType == null)
				{
					ignoreAttributeType = typeof(object).Assembly.GetType("System.XmlIgnoreMemberAttribute");
					if (ignoreAttributeType == null)
					{
						ignoreAttributeType = typeof(XmlIgnoreAttribute);
					}
				}
				return ignoreAttributeType;
			}
		}

		public XmlElementAttributes XmlElements => xmlElements;

		public XmlAttributeAttribute XmlAttribute
		{
			get
			{
				return xmlAttribute;
			}
			set
			{
				xmlAttribute = value;
			}
		}

		public XmlEnumAttribute XmlEnum
		{
			get
			{
				return xmlEnum;
			}
			set
			{
				xmlEnum = value;
			}
		}

		public XmlTextAttribute XmlText
		{
			get
			{
				return xmlText;
			}
			set
			{
				xmlText = value;
			}
		}

		public XmlArrayAttribute XmlArray
		{
			get
			{
				return xmlArray;
			}
			set
			{
				xmlArray = value;
			}
		}

		public XmlArrayItemAttributes XmlArrayItems => xmlArrayItems;

		public object XmlDefaultValue
		{
			get
			{
				return xmlDefaultValue;
			}
			set
			{
				xmlDefaultValue = value;
			}
		}

		public bool XmlIgnore
		{
			get
			{
				return xmlIgnore;
			}
			set
			{
				xmlIgnore = value;
			}
		}

		public XmlTypeAttribute XmlType
		{
			get
			{
				return xmlType;
			}
			set
			{
				xmlType = value;
			}
		}

		public XmlRootAttribute XmlRoot
		{
			get
			{
				return xmlRoot;
			}
			set
			{
				xmlRoot = value;
			}
		}

		public XmlAnyElementAttributes XmlAnyElements => xmlAnyElements;

		public XmlAnyAttributeAttribute XmlAnyAttribute
		{
			get
			{
				return xmlAnyAttribute;
			}
			set
			{
				xmlAnyAttribute = value;
			}
		}

		public XmlChoiceIdentifierAttribute XmlChoiceIdentifier => xmlChoiceIdentifier;

		public bool Xmlns
		{
			get
			{
				return xmlns;
			}
			set
			{
				xmlns = value;
			}
		}

		public XmlAttributes()
		{
		}

		public XmlAttributes(ICustomAttributeProvider provider)
		{
			object[] customAttributes = provider.GetCustomAttributes(inherit: false);
			XmlAnyElementAttribute xmlAnyElementAttribute = null;
			for (int i = 0; i < customAttributes.Length; i++)
			{
				if (customAttributes[i] is XmlIgnoreAttribute || customAttributes[i] is ObsoleteAttribute || customAttributes[i].GetType() == IgnoreAttribute)
				{
					xmlIgnore = true;
					break;
				}
				if (customAttributes[i] is XmlElementAttribute)
				{
					xmlElements.Add((XmlElementAttribute)customAttributes[i]);
				}
				else if (customAttributes[i] is XmlArrayItemAttribute)
				{
					xmlArrayItems.Add((XmlArrayItemAttribute)customAttributes[i]);
				}
				else if (customAttributes[i] is XmlAnyElementAttribute)
				{
					XmlAnyElementAttribute xmlAnyElementAttribute2 = (XmlAnyElementAttribute)customAttributes[i];
					if ((xmlAnyElementAttribute2.Name == null || xmlAnyElementAttribute2.Name.Length == 0) && xmlAnyElementAttribute2.NamespaceSpecified && xmlAnyElementAttribute2.Namespace == null)
					{
						xmlAnyElementAttribute = xmlAnyElementAttribute2;
					}
					else
					{
						xmlAnyElements.Add((XmlAnyElementAttribute)customAttributes[i]);
					}
				}
				else if (customAttributes[i] is DefaultValueAttribute)
				{
					xmlDefaultValue = ((DefaultValueAttribute)customAttributes[i]).Value;
				}
				else if (customAttributes[i] is XmlAttributeAttribute)
				{
					xmlAttribute = (XmlAttributeAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is XmlArrayAttribute)
				{
					xmlArray = (XmlArrayAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is XmlTextAttribute)
				{
					xmlText = (XmlTextAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is XmlEnumAttribute)
				{
					xmlEnum = (XmlEnumAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is XmlRootAttribute)
				{
					xmlRoot = (XmlRootAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is XmlTypeAttribute)
				{
					xmlType = (XmlTypeAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is XmlAnyAttributeAttribute)
				{
					xmlAnyAttribute = (XmlAnyAttributeAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is XmlChoiceIdentifierAttribute)
				{
					xmlChoiceIdentifier = (XmlChoiceIdentifierAttribute)customAttributes[i];
				}
				else if (customAttributes[i] is XmlNamespaceDeclarationsAttribute)
				{
					xmlns = true;
				}
			}
			if (xmlIgnore)
			{
				xmlElements.Clear();
				xmlArrayItems.Clear();
				xmlAnyElements.Clear();
				xmlDefaultValue = null;
				xmlAttribute = null;
				xmlArray = null;
				xmlText = null;
				xmlEnum = null;
				xmlType = null;
				xmlAnyAttribute = null;
				xmlChoiceIdentifier = null;
				xmlns = false;
			}
			else if (xmlAnyElementAttribute != null)
			{
				xmlAnyElements.Add(xmlAnyElementAttribute);
			}
		}

		internal static object GetAttr(ICustomAttributeProvider provider, Type attrType)
		{
			object[] customAttributes = provider.GetCustomAttributes(attrType, inherit: false);
			if (customAttributes.Length == 0)
			{
				return null;
			}
			return customAttributes[0];
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = false)]
	public class XmlChoiceIdentifierAttribute : Attribute
	{
		private string name;

		public string MemberName
		{
			get
			{
				if (name != null)
				{
					return name;
				}
				return string.Empty;
			}
			set
			{
				name = value;
			}
		}

		public XmlChoiceIdentifierAttribute()
		{
		}

		public XmlChoiceIdentifierAttribute(string name)
		{
			this.name = name;
		}
	}
	public class XmlCodeExporter : CodeExporter
	{
		public XmlCodeExporter(CodeNamespace codeNamespace)
			: base(codeNamespace, null, null, CodeGenerationOptions.GenerateProperties, null)
		{
		}

		public XmlCodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit)
			: base(codeNamespace, codeCompileUnit, null, CodeGenerationOptions.GenerateProperties, null)
		{
		}

		public XmlCodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit, CodeGenerationOptions options)
			: base(codeNamespace, codeCompileUnit, null, options, null)
		{
		}

		public XmlCodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit, CodeGenerationOptions options, Hashtable mappings)
			: base(codeNamespace, codeCompileUnit, null, options, mappings)
		{
		}

		public XmlCodeExporter(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit, CodeDomProvider codeProvider, CodeGenerationOptions options, Hashtable mappings)
			: base(codeNamespace, codeCompileUnit, codeProvider, options, mappings)
		{
		}

		public void ExportTypeMapping(XmlTypeMapping xmlTypeMapping)
		{
			xmlTypeMapping.CheckShallow();
			CheckScope(xmlTypeMapping.Scope);
			if (xmlTypeMapping.Accessor.Any)
			{
				throw new InvalidOperationException(Res.GetString("XmlIllegalWildcard"));
			}
			ExportElement(xmlTypeMapping.Accessor);
		}

		public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping)
		{
			xmlMembersMapping.CheckShallow();
			CheckScope(xmlMembersMapping.Scope);
			for (int i = 0; i < xmlMembersMapping.Count; i++)
			{
				AccessorMapping mapping = xmlMembersMapping[i].Mapping;
				if (mapping.Xmlns != null)
				{
					continue;
				}
				if (mapping.Attribute != null)
				{
					ExportType(mapping.Attribute.Mapping, Accessor.UnescapeName(mapping.Attribute.Name), mapping.Attribute.Namespace, null, checkReference: false);
				}
				if (mapping.Elements != null)
				{
					for (int j = 0; j < mapping.Elements.Length; j++)
					{
						ElementAccessor elementAccessor = mapping.Elements[j];
						ExportType(elementAccessor.Mapping, Accessor.UnescapeName(elementAccessor.Name), elementAccessor.Namespace, null, checkReference: false);
					}
				}
				if (mapping.Text != null)
				{
					ExportType(mapping.Text.Mapping, Accessor.UnescapeName(mapping.Text.Name), mapping.Text.Namespace, null, checkReference: false);
				}
			}
		}

		private void ExportElement(ElementAccessor element)
		{
			ExportType(element.Mapping, Accessor.UnescapeName(element.Name), element.Namespace, element, checkReference: true);
		}

		private void ExportType(TypeMapping mapping, string ns)
		{
			ExportType(mapping, null, ns, null, checkReference: true);
		}

		private void ExportType(TypeMapping mapping, string name, string ns, ElementAccessor rootElement, bool checkReference)
		{
			if ((mapping.IsReference && mapping.Namespace != "http://schemas.xmlsoap.org/soap/encoding/") || (mapping is StructMapping && checkReference && ((StructMapping)mapping).ReferencedByTopLevelElement && rootElement == null))
			{
				return;
			}
			if (mapping is ArrayMapping && rootElement != null && rootElement.IsTopLevelInSchema && ((ArrayMapping)mapping).TopLevelMapping != null)
			{
				mapping = ((ArrayMapping)mapping).TopLevelMapping;
			}
			CodeTypeDeclaration codeTypeDeclaration = null;
			if (base.ExportedMappings[mapping] == null)
			{
				base.ExportedMappings.Add(mapping, mapping);
				if (mapping.TypeDesc.IsMappedType)
				{
					codeTypeDeclaration = mapping.TypeDesc.ExtendedType.ExportTypeDefinition(base.CodeNamespace, base.CodeCompileUnit);
				}
				else if (mapping is EnumMapping)
				{
					codeTypeDeclaration = ExportEnum((EnumMapping)mapping, typeof(XmlEnumAttribute));
				}
				else if (mapping is StructMapping)
				{
					codeTypeDeclaration = ExportStruct((StructMapping)mapping);
				}
				else if (mapping is ArrayMapping)
				{
					EnsureTypesExported(((ArrayMapping)mapping).Elements, ns);
				}
				if (codeTypeDeclaration != null)
				{
					if (!mapping.TypeDesc.IsMappedType)
					{
						codeTypeDeclaration.CustomAttributes.Add(base.GeneratedCodeAttribute);
						codeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(SerializableAttribute).FullName));
						if (!codeTypeDeclaration.IsEnum)
						{
							codeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DebuggerStepThroughAttribute).FullName));
							codeTypeDeclaration.CustomAttributes.Add(new CodeAttributeDeclaration(typeof(DesignerCategoryAttribute).FullName, new CodeAttributeArgument(new CodePrimitiveExpression("code"))));
						}
						AddTypeMetadata(codeTypeDeclaration.CustomAttributes, typeof(XmlTypeAttribute), mapping.TypeDesc.Name, Accessor.UnescapeName(mapping.TypeName), mapping.Namespace, mapping.IncludeInSchema);
					}
					else if (CodeExporter.FindAttributeDeclaration(typeof(GeneratedCodeAttribute), codeTypeDeclaration.CustomAttributes) == null)
					{
						codeTypeDeclaration.CustomAttributes.Add(base.GeneratedCodeAttribute);
					}
					base.ExportedClasses.Add(mapping, codeTypeDeclaration);
				}
			}
			else
			{
				codeTypeDeclaration = (CodeTypeDeclaration)base.ExportedClasses[mapping];
			}
			if (codeTypeDeclaration != null && rootElement != null)
			{
				AddRootMetadata(codeTypeDeclaration.CustomAttributes, mapping, name, ns, rootElement);
			}
		}

		private void AddRootMetadata(CodeAttributeDeclarationCollection metadata, TypeMapping typeMapping, string name, string ns, ElementAccessor rootElement)
		{
			string fullName = typeof(XmlRootAttribute).FullName;
			foreach (CodeAttributeDeclaration metadatum in metadata)
			{
				if (metadatum.Name == fullName)
				{
					return;
				}
			}
			CodeAttributeDeclaration codeAttributeDeclaration2 = new CodeAttributeDeclaration(fullName);
			if (typeMapping.TypeDesc.Name != name)
			{
				codeAttributeDeclaration2.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(name)));
			}
			if (ns != null)
			{
				codeAttributeDeclaration2.Arguments.Add(new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(ns)));
			}
			if (typeMapping.TypeDesc != null && typeMapping.TypeDesc.IsAmbiguousDataType)
			{
				codeAttributeDeclaration2.Arguments.Add(new CodeAttributeArgument("DataType", new CodePrimitiveExpression(typeMapping.TypeDesc.DataType.Name)));
			}
			if ((object)rootElement.IsNullable != null)
			{
				codeAttributeDeclaration2.Arguments.Add(new CodeAttributeArgument("IsNullable", new CodePrimitiveExpression(rootElement.IsNullable)));
			}
			metadata.Add(codeAttributeDeclaration2);
		}

		private CodeAttributeArgument[] GetDefaultValueArguments(PrimitiveMapping mapping, object value, out CodeExpression initExpression)
		{
			initExpression = null;
			if (value == null)
			{
				return null;
			}
			CodeExpression codeExpression = null;
			CodeExpression codeExpression2 = null;
			Type type = value.GetType();
			CodeAttributeArgument[] result = null;
			if (mapping is EnumMapping)
			{
				if (((EnumMapping)mapping).IsFlags)
				{
					string[] array = ((string)value).Split(null);
					for (int i = 0; i < array.Length; i++)
					{
						if (array[i].Length != 0)
						{
							CodeExpression codeExpression3 = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(mapping.TypeDesc.FullName), array[i]);
							codeExpression = ((codeExpression == null) ? codeExpression3 : new CodeBinaryOperatorExpression(codeExpression, CodeBinaryOperatorType.BitwiseOr, codeExpression3));
						}
					}
				}
				else
				{
					codeExpression = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(mapping.TypeDesc.FullName), (string)value);
				}
				initExpression = codeExpression;
				result = new CodeAttributeArgument[1]
				{
					new CodeAttributeArgument(codeExpression)
				};
			}
			else if (type == typeof(bool) || type == typeof(int) || type == typeof(string) || type == typeof(double))
			{
				codeExpression = (initExpression = new CodePrimitiveExpression(value));
				result = new CodeAttributeArgument[1]
				{
					new CodeAttributeArgument(codeExpression)
				};
			}
			else if (type == typeof(short) || type == typeof(long) || type == typeof(float) || type == typeof(byte) || type == typeof(decimal))
			{
				codeExpression = new CodePrimitiveExpression(Convert.ToString(value, NumberFormatInfo.InvariantInfo));
				codeExpression2 = new CodeTypeOfExpression(type.FullName);
				result = new CodeAttributeArgument[2]
				{
					new CodeAttributeArgument(codeExpression2),
					new CodeAttributeArgument(codeExpression)
				};
				initExpression = new CodeCastExpression(type.FullName, new CodePrimitiveExpression(value));
			}
			else if (type == typeof(sbyte) || type == typeof(ushort) || type == typeof(uint) || type == typeof(ulong))
			{
				value = CodeExporter.PromoteType(type, value);
				codeExpression = new CodePrimitiveExpression(Convert.ToString(value, NumberFormatInfo.InvariantInfo));
				codeExpression2 = new CodeTypeOfExpression(type.FullName);
				result = new CodeAttributeArgument[2]
				{
					new CodeAttributeArgument(codeExpression2),
					new CodeAttributeArgument(codeExpression)
				};
				initExpression = new CodeCastExpression(type.FullName, new CodePrimitiveExpression(value));
			}
			else if (type == typeof(DateTime))
			{
				DateTime value2 = (DateTime)value;
				string value3;
				long ticks;
				if (mapping.TypeDesc.FormatterName == "Date")
				{
					value3 = XmlCustomFormatter.FromDate(value2);
					ticks = new DateTime(value2.Year, value2.Month, value2.Day).Ticks;
				}
				else if (mapping.TypeDesc.FormatterName == "Time")
				{
					value3 = XmlCustomFormatter.FromDateTime(value2);
					ticks = value2.Ticks;
				}
				else
				{
					value3 = XmlCustomFormatter.FromDateTime(value2);
					ticks = value2.Ticks;
				}
				codeExpression = new CodePrimitiveExpression(value3);
				codeExpression2 = new CodeTypeOfExpression(type.FullName);
				result = new CodeAttributeArgument[2]
				{
					new CodeAttributeArgument(codeExpression2),
					new CodeAttributeArgument(codeExpression)
				};
				initExpression = new CodeObjectCreateExpression(new CodeTypeReference(typeof(DateTime)), new CodePrimitiveExpression(ticks));
			}
			else if (type == typeof(Guid))
			{
				codeExpression = new CodePrimitiveExpression(Convert.ToString(value, NumberFormatInfo.InvariantInfo));
				codeExpression2 = new CodeTypeOfExpression(type.FullName);
				result = new CodeAttributeArgument[2]
				{
					new CodeAttributeArgument(codeExpression2),
					new CodeAttributeArgument(codeExpression)
				};
				initExpression = new CodeObjectCreateExpression(new CodeTypeReference(typeof(Guid)), codeExpression);
			}
			if (mapping.TypeDesc.FullName != type.ToString() && !(mapping is EnumMapping))
			{
				initExpression = new CodeCastExpression(mapping.TypeDesc.FullName, initExpression);
			}
			return result;
		}

		private object ImportDefault(TypeMapping mapping, string defaultValue)
		{
			if (defaultValue == null)
			{
				return null;
			}
			if (mapping.IsList)
			{
				string[] array = defaultValue.Trim().Split(null);
				int num = 0;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] != null && array[i].Length > 0)
					{
						num++;
					}
				}
				object[] array2 = new object[num];
				num = 0;
				for (int j = 0; j < array.Length; j++)
				{
					if (array[j] != null && array[j].Length > 0)
					{
						array2[num++] = ImportDefaultValue(mapping, array[j]);
					}
				}
				return array2;
			}
			return ImportDefaultValue(mapping, defaultValue);
		}

		private object ImportDefaultValue(TypeMapping mapping, string defaultValue)
		{
			if (defaultValue == null)
			{
				return null;
			}
			if (!(mapping is PrimitiveMapping))
			{
				return DBNull.Value;
			}
			if (mapping is EnumMapping)
			{
				EnumMapping enumMapping = (EnumMapping)mapping;
				ConstantMapping[] constants = enumMapping.Constants;
				if (enumMapping.IsFlags)
				{
					Hashtable hashtable = new Hashtable();
					string[] array = new string[constants.Length];
					long[] array2 = new long[constants.Length];
					for (int i = 0; i < constants.Length; i++)
					{
						array2[i] = (enumMapping.IsFlags ? (1L << i) : i);
						array[i] = constants[i].Name;
						hashtable.Add(constants[i].Name, array2[i]);
					}
					long val = XmlCustomFormatter.ToEnum(defaultValue, hashtable, enumMapping.TypeName, validate: true);
					return XmlCustomFormatter.FromEnum(val, array, array2, enumMapping.TypeDesc.FullName);
				}
				for (int j = 0; j < constants.Length; j++)
				{
					if (constants[j].XmlName == defaultValue)
					{
						return constants[j].Name;
					}
				}
				throw new InvalidOperationException(Res.GetString("XmlInvalidDefaultValue", defaultValue, enumMapping.TypeDesc.FullName));
			}
			PrimitiveMapping primitiveMapping = (PrimitiveMapping)mapping;
			if (!primitiveMapping.TypeDesc.HasCustomFormatter)
			{
				if (primitiveMapping.TypeDesc.FormatterName == "String")
				{
					return defaultValue;
				}
				if (primitiveMapping.TypeDesc.FormatterName == "DateTime")
				{
					return XmlCustomFormatter.ToDateTime(defaultValue);
				}
				Type typeFromHandle = typeof(XmlConvert);
				MethodInfo method = typeFromHandle.GetMethod("To" + primitiveMapping.TypeDesc.FormatterName, new Type[1] { typeof(string) });
				if (method != null)
				{
					return method.Invoke(typeFromHandle, new object[1] { defaultValue });
				}
			}
			else if (primitiveMapping.TypeDesc.HasDefaultSupport)
			{
				return XmlCustomFormatter.ToDefaultValue(defaultValue, primitiveMapping.TypeDesc.FormatterName);
			}
			return DBNull.Value;
		}

		private void AddDefaultValueAttribute(CodeMemberField field, CodeAttributeDeclarationCollection metadata, object defaultValue, TypeMapping mapping, CodeCommentStatementCollection comments, TypeDesc memberTypeDesc, Accessor accessor, CodeConstructor ctor)
		{
			string text = (accessor.IsFixed ? "fixed" : "default");
			if (!memberTypeDesc.HasDefaultSupport)
			{
				if (comments != null && defaultValue is string)
				{
					DropDefaultAttribute(accessor, comments, memberTypeDesc.FullName);
					CodeExporter.AddWarningComment(comments, Res.GetString("XmlDropAttributeValue", text, mapping.TypeName, defaultValue.ToString()));
				}
				return;
			}
			if (memberTypeDesc.IsArrayLike && accessor is ElementAccessor)
			{
				if (comments != null && defaultValue is string)
				{
					DropDefaultAttribute(accessor, comments, memberTypeDesc.FullName);
					CodeExporter.AddWarningComment(comments, Res.GetString("XmlDropArrayAttributeValue", text, defaultValue.ToString(), ((ElementAccessor)accessor).Name));
				}
				return;
			}
			if (mapping.TypeDesc.IsMappedType && field != null && defaultValue is string)
			{
				SchemaImporterExtension extension = mapping.TypeDesc.ExtendedType.Extension;
				CodeExpression codeExpression = extension.ImportDefaultValue((string)defaultValue, mapping.TypeDesc.FullName);
				if (codeExpression != null)
				{
					if (ctor != null)
					{
						AddInitializationStatement(ctor, field, codeExpression);
					}
					else
					{
						field.InitExpression = extension.ImportDefaultValue((string)defaultValue, mapping.TypeDesc.FullName);
					}
				}
				if (comments != null)
				{
					DropDefaultAttribute(accessor, comments, mapping.TypeDesc.FullName);
					if (codeExpression == null)
					{
						CodeExporter.AddWarningComment(comments, Res.GetString("XmlNotKnownDefaultValue", extension.GetType().FullName, text, (string)defaultValue, mapping.TypeName, mapping.Namespace));
					}
				}
				return;
			}
			object obj = null;
			if (defaultValue is string || defaultValue == null)
			{
				obj = ImportDefault(mapping, (string)defaultValue);
			}
			if (obj == null)
			{
				return;
			}
			if (!(mapping is PrimitiveMapping))
			{
				DropDefaultAttribute(accessor, comments, memberTypeDesc.FullName);
				CodeExporter.AddWarningComment(comments, Res.GetString("XmlDropNonPrimitiveAttributeValue", text, defaultValue.ToString()));
				return;
			}
			PrimitiveMapping primitiveMapping = (PrimitiveMapping)mapping;
			if (comments != null && !primitiveMapping.TypeDesc.HasDefaultSupport && primitiveMapping.TypeDesc.IsMappedType)
			{
				DropDefaultAttribute(accessor, comments, primitiveMapping.TypeDesc.FullName);
				return;
			}
			if (obj == DBNull.Value)
			{
				if (comments != null)
				{
					CodeExporter.AddWarningComment(comments, Res.GetString("XmlDropAttributeValue", text, primitiveMapping.TypeName, defaultValue.ToString()));
				}
				return;
			}
			CodeAttributeArgument[] array = null;
			CodeExpression initExpression = null;
			if (primitiveMapping.IsList)
			{
				object[] array2 = (object[])obj;
				CodeExpression[] array3 = new CodeExpression[array2.Length];
				for (int i = 0; i < array2.Length; i++)
				{
					GetDefaultValueArguments(primitiveMapping, array2[i], out array3[i]);
				}
				initExpression = new CodeArrayCreateExpression(field.Type, array3);
			}
			else
			{
				array = GetDefaultValueArguments(primitiveMapping, obj, out initExpression);
			}
			if (field != null)
			{
				if (ctor != null)
				{
					AddInitializationStatement(ctor, field, initExpression);
				}
				else
				{
					field.InitExpression = initExpression;
				}
			}
			if (array != null && primitiveMapping.TypeDesc.HasDefaultSupport && accessor.IsOptional && !accessor.IsFixed)
			{
				CodeAttributeDeclaration value = new CodeAttributeDeclaration(typeof(DefaultValueAttribute).FullName, array);
				metadata.Add(value);
			}
			else if (comments != null)
			{
				DropDefaultAttribute(accessor, comments, memberTypeDesc.FullName);
			}
		}

		private static void AddInitializationStatement(CodeConstructor ctor, CodeMemberField field, CodeExpression init)
		{
			CodeAssignStatement codeAssignStatement = new CodeAssignStatement();
			codeAssignStatement.Left = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), field.Name);
			codeAssignStatement.Right = init;
			ctor.Statements.Add(codeAssignStatement);
		}

		private static void DropDefaultAttribute(Accessor accessor, CodeCommentStatementCollection comments, string type)
		{
			if (!accessor.IsFixed && accessor.IsOptional)
			{
				CodeExporter.AddWarningComment(comments, Res.GetString("XmlDropDefaultAttribute", type));
			}
		}

		private CodeTypeDeclaration ExportStruct(StructMapping mapping)
		{
			if (mapping.TypeDesc.IsRoot)
			{
				ExportRoot(mapping, typeof(XmlIncludeAttribute));
				return null;
			}
			string name = mapping.TypeDesc.Name;
			string text = ((mapping.TypeDesc.BaseTypeDesc == null || mapping.TypeDesc.BaseTypeDesc.IsRoot) ? string.Empty : mapping.TypeDesc.BaseTypeDesc.FullName);
			CodeTypeDeclaration codeTypeDeclaration = new CodeTypeDeclaration(name);
			codeTypeDeclaration.IsPartial = base.CodeProvider.Supports(GeneratorSupport.PartialTypes);
			codeTypeDeclaration.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
			base.CodeNamespace.Types.Add(codeTypeDeclaration);
			CodeConstructor codeConstructor = new CodeConstructor();
			codeConstructor.Attributes = (codeConstructor.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
			codeTypeDeclaration.Members.Add(codeConstructor);
			if (mapping.TypeDesc.IsAbstract)
			{
				codeConstructor.Attributes |= MemberAttributes.Abstract;
			}
			if (text != null && text.Length > 0)
			{
				codeTypeDeclaration.BaseTypes.Add(text);
			}
			else
			{
				AddPropertyChangedNotifier(codeTypeDeclaration);
			}
			codeTypeDeclaration.TypeAttributes |= TypeAttributes.Public;
			if (mapping.TypeDesc.IsAbstract)
			{
				codeTypeDeclaration.TypeAttributes |= TypeAttributes.Abstract;
			}
			CodeExporter.AddIncludeMetadata(codeTypeDeclaration.CustomAttributes, mapping, typeof(XmlIncludeAttribute));
			if (mapping.IsSequence)
			{
				int num = 0;
				for (int i = 0; i < mapping.Members.Length; i++)
				{
					MemberMapping memberMapping = mapping.Members[i];
					if (memberMapping.IsParticle && memberMapping.SequenceId < 0)
					{
						memberMapping.SequenceId = num++;
					}
				}
			}
			if (base.GenerateProperties)
			{
				for (int j = 0; j < mapping.Members.Length; j++)
				{
					ExportProperty(codeTypeDeclaration, mapping.Members[j], mapping.Namespace, mapping.Scope, codeConstructor);
				}
			}
			else
			{
				for (int k = 0; k < mapping.Members.Length; k++)
				{
					ExportMember(codeTypeDeclaration, mapping.Members[k], mapping.Namespace, codeConstructor);
				}
			}
			for (int l = 0; l < mapping.Members.Length; l++)
			{
				if (mapping.Members[l].Xmlns == null)
				{
					EnsureTypesExported(mapping.Members[l].Elements, mapping.Namespace);
					EnsureTypesExported(mapping.Members[l].Attribute, mapping.Namespace);
					EnsureTypesExported(mapping.Members[l].Text, mapping.Namespace);
				}
			}
			if (mapping.BaseMapping != null)
			{
				ExportType(mapping.BaseMapping, null, mapping.Namespace, null, checkReference: false);
			}
			ExportDerivedStructs(mapping);
			CodeGenerator.ValidateIdentifiers(codeTypeDeclaration);
			if (codeConstructor.Statements.Count == 0)
			{
				codeTypeDeclaration.Members.Remove(codeConstructor);
			}
			return codeTypeDeclaration;
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		internal override void ExportDerivedStructs(StructMapping mapping)
		{
			for (StructMapping structMapping = mapping.DerivedMappings; structMapping != null; structMapping = structMapping.NextDerivedMapping)
			{
				ExportType(structMapping, mapping.Namespace);
			}
		}

		public void AddMappingMetadata(CodeAttributeDeclarationCollection metadata, XmlTypeMapping mapping, string ns)
		{
			mapping.CheckShallow();
			CheckScope(mapping.Scope);
			if (!(mapping.Mapping is StructMapping) && !(mapping.Mapping is EnumMapping))
			{
				AddRootMetadata(metadata, mapping.Mapping, Accessor.UnescapeName(mapping.Accessor.Name), mapping.Accessor.Namespace, mapping.Accessor);
			}
		}

		public void AddMappingMetadata(CodeAttributeDeclarationCollection metadata, XmlMemberMapping member, string ns, bool forceUseMemberName)
		{
			AddMemberMetadata(null, metadata, member.Mapping, ns, forceUseMemberName, null, null);
		}

		public void AddMappingMetadata(CodeAttributeDeclarationCollection metadata, XmlMemberMapping member, string ns)
		{
			AddMemberMetadata(null, metadata, member.Mapping, ns, forceUseMemberName: false, null, null);
		}

		private void ExportArrayElements(CodeAttributeDeclarationCollection metadata, ArrayMapping array, string ns, TypeDesc elementTypeDesc, int nestingLevel)
		{
			for (int i = 0; i < array.Elements.Length; i++)
			{
				ElementAccessor elementAccessor = array.Elements[i];
				TypeMapping mapping = elementAccessor.Mapping;
				string text = Accessor.UnescapeName(elementAccessor.Name);
				bool flag = !elementAccessor.Mapping.TypeDesc.IsArray && text == elementAccessor.Mapping.TypeName;
				bool flag2 = mapping.TypeDesc == elementTypeDesc;
				bool flag3 = elementAccessor.Form == XmlSchemaForm.Unqualified || elementAccessor.Namespace == ns;
				bool flag4 = elementAccessor.IsNullable == mapping.TypeDesc.IsNullable;
				bool flag5 = elementAccessor.Form != XmlSchemaForm.Unqualified;
				if (!flag || !flag2 || !flag3 || !flag4 || !flag5 || nestingLevel > 0)
				{
					ExportArrayItem(metadata, flag ? null : text, flag3 ? null : elementAccessor.Namespace, flag2 ? null : mapping.TypeDesc, mapping.TypeDesc, elementAccessor.IsNullable, (!flag5) ? elementAccessor.Form : XmlSchemaForm.None, nestingLevel);
				}
				if (mapping is ArrayMapping)
				{
					ExportArrayElements(metadata, (ArrayMapping)mapping, ns, elementTypeDesc.ArrayElementTypeDesc, nestingLevel + 1);
				}
			}
		}

		private void AddMemberMetadata(CodeMemberField field, CodeAttributeDeclarationCollection metadata, MemberMapping member, string ns, bool forceUseMemberName, CodeCommentStatementCollection comments, CodeConstructor ctor)
		{
			if (member.Xmlns != null)
			{
				CodeAttributeDeclaration value = new CodeAttributeDeclaration(typeof(XmlNamespaceDeclarationsAttribute).FullName);
				metadata.Add(value);
				return;
			}
			if (member.Attribute != null)
			{
				AttributeAccessor attribute = member.Attribute;
				if (attribute.Any)
				{
					ExportAnyAttribute(metadata);
					return;
				}
				TypeMapping mapping = attribute.Mapping;
				string text = Accessor.UnescapeName(attribute.Name);
				bool flag = mapping.TypeDesc == member.TypeDesc || (member.TypeDesc.IsArrayLike && mapping.TypeDesc == member.TypeDesc.ArrayElementTypeDesc);
				bool flag2 = text == member.Name && !forceUseMemberName;
				bool flag3 = attribute.Namespace == ns;
				bool flag4 = attribute.Form != XmlSchemaForm.Qualified;
				ExportAttribute(metadata, flag2 ? null : text, (flag3 || flag4) ? null : attribute.Namespace, flag ? null : mapping.TypeDesc, mapping.TypeDesc, (!flag4) ? attribute.Form : XmlSchemaForm.None);
				AddDefaultValueAttribute(field, metadata, attribute.Default, mapping, comments, member.TypeDesc, attribute, ctor);
				return;
			}
			if (member.Text != null)
			{
				TypeMapping mapping2 = member.Text.Mapping;
				bool flag5 = mapping2.TypeDesc == member.TypeDesc || (member.TypeDesc.IsArrayLike && mapping2.TypeDesc == member.TypeDesc.ArrayElementTypeDesc);
				ExportText(metadata, flag5 ? null : mapping2.TypeDesc, mapping2.TypeDesc.IsAmbiguousDataType ? mapping2.TypeDesc.DataType.Name : null);
			}
			if (member.Elements.Length == 1)
			{
				ElementAccessor elementAccessor = member.Elements[0];
				TypeMapping mapping3 = elementAccessor.Mapping;
				string text2 = Accessor.UnescapeName(elementAccessor.Name);
				bool flag6 = text2 == member.Name && !forceUseMemberName;
				bool flag7 = mapping3 is ArrayMapping;
				bool flag8 = elementAccessor.Namespace == ns;
				bool flag9 = elementAccessor.Form != XmlSchemaForm.Unqualified;
				if (elementAccessor.Any)
				{
					ExportAnyElement(metadata, text2, elementAccessor.Namespace, member.SequenceId);
				}
				else if (flag7)
				{
					_ = mapping3.TypeDesc;
					_ = member.TypeDesc;
					ArrayMapping array = (ArrayMapping)mapping3;
					if (!flag6 || !flag8 || elementAccessor.IsNullable || !flag9 || member.SequenceId != -1)
					{
						ExportArray(metadata, flag6 ? null : text2, flag8 ? null : elementAccessor.Namespace, elementAccessor.IsNullable, (!flag9) ? elementAccessor.Form : XmlSchemaForm.None, member.SequenceId);
					}
					else if (mapping3.TypeDesc.ArrayElementTypeDesc == new TypeScope().GetTypeDesc(typeof(byte)))
					{
						ExportArray(metadata, null, null, isNullable: false, XmlSchemaForm.None, member.SequenceId);
					}
					ExportArrayElements(metadata, array, elementAccessor.Namespace, member.TypeDesc.ArrayElementTypeDesc, 0);
				}
				else
				{
					bool flag10 = mapping3.TypeDesc == member.TypeDesc || (member.TypeDesc.IsArrayLike && mapping3.TypeDesc == member.TypeDesc.ArrayElementTypeDesc);
					if (member.TypeDesc.IsArrayLike)
					{
						flag6 = false;
					}
					ExportElement(metadata, flag6 ? null : text2, flag8 ? null : elementAccessor.Namespace, flag10 ? null : mapping3.TypeDesc, mapping3.TypeDesc, elementAccessor.IsNullable, (!flag9) ? elementAccessor.Form : XmlSchemaForm.None, member.SequenceId);
				}
				AddDefaultValueAttribute(field, metadata, elementAccessor.Default, mapping3, comments, member.TypeDesc, elementAccessor, ctor);
			}
			else
			{
				for (int i = 0; i < member.Elements.Length; i++)
				{
					ElementAccessor elementAccessor2 = member.Elements[i];
					string name = Accessor.UnescapeName(elementAccessor2.Name);
					bool flag11 = elementAccessor2.Namespace == ns;
					if (elementAccessor2.Any)
					{
						ExportAnyElement(metadata, name, elementAccessor2.Namespace, member.SequenceId);
						continue;
					}
					bool flag12 = elementAccessor2.Form != XmlSchemaForm.Unqualified;
					ExportElement(metadata, name, flag11 ? null : elementAccessor2.Namespace, elementAccessor2.Mapping.TypeDesc, elementAccessor2.Mapping.TypeDesc, elementAccessor2.IsNullable, (!flag12) ? elementAccessor2.Form : XmlSchemaForm.None, member.SequenceId);
				}
			}
			if (member.ChoiceIdentifier != null)
			{
				CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(typeof(XmlChoiceIdentifierAttribute).FullName);
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(member.ChoiceIdentifier.MemberName)));
				metadata.Add(codeAttributeDeclaration);
			}
			if (member.Ignore)
			{
				CodeAttributeDeclaration value2 = new CodeAttributeDeclaration(typeof(XmlIgnoreAttribute).FullName);
				metadata.Add(value2);
			}
		}

		private void ExportMember(CodeTypeDeclaration codeClass, MemberMapping member, string ns, CodeConstructor ctor)
		{
			string typeName = member.GetTypeName(base.CodeProvider);
			CodeMemberField codeMemberField = new CodeMemberField(typeName, member.Name);
			codeMemberField.Attributes = (codeMemberField.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
			codeMemberField.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
			codeClass.Members.Add(codeMemberField);
			AddMemberMetadata(codeMemberField, codeMemberField.CustomAttributes, member, ns, forceUseMemberName: false, codeMemberField.Comments, ctor);
			if (member.CheckSpecified != 0)
			{
				codeMemberField = new CodeMemberField(typeof(bool).FullName, member.Name + "Specified");
				codeMemberField.Attributes = (codeMemberField.Attributes & (MemberAttributes)(-61441)) | MemberAttributes.Public;
				codeMemberField.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
				CodeAttributeDeclaration value = new CodeAttributeDeclaration(typeof(XmlIgnoreAttribute).FullName);
				codeMemberField.CustomAttributes.Add(value);
				codeClass.Members.Add(codeMemberField);
			}
		}

		private void ExportProperty(CodeTypeDeclaration codeClass, MemberMapping member, string ns, CodeIdentifiers memberScope, CodeConstructor ctor)
		{
			string text = memberScope.AddUnique(CodeExporter.MakeFieldName(member.Name), member);
			string typeName = member.GetTypeName(base.CodeProvider);
			CodeMemberField codeMemberField = new CodeMemberField(typeName, text);
			codeMemberField.Attributes = MemberAttributes.Private;
			codeClass.Members.Add(codeMemberField);
			CodeMemberProperty codeMemberProperty = CreatePropertyDeclaration(codeMemberField, member.Name, typeName);
			codeMemberProperty.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
			AddMemberMetadata(codeMemberField, codeMemberProperty.CustomAttributes, member, ns, forceUseMemberName: false, codeMemberProperty.Comments, ctor);
			codeClass.Members.Add(codeMemberProperty);
			if (member.CheckSpecified != 0)
			{
				codeMemberField = new CodeMemberField(typeof(bool).FullName, text + "Specified");
				codeMemberField.Attributes = MemberAttributes.Private;
				codeClass.Members.Add(codeMemberField);
				codeMemberProperty = CreatePropertyDeclaration(codeMemberField, member.Name + "Specified", typeof(bool).FullName);
				codeMemberProperty.Comments.Add(new CodeCommentStatement(Res.GetString("XmlRemarks"), docComment: true));
				CodeAttributeDeclaration value = new CodeAttributeDeclaration(typeof(XmlIgnoreAttribute).FullName);
				codeMemberProperty.CustomAttributes.Add(value);
				codeClass.Members.Add(codeMemberProperty);
			}
		}

		private void ExportText(CodeAttributeDeclarationCollection metadata, TypeDesc typeDesc, string dataType)
		{
			CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(typeof(XmlTextAttribute).FullName);
			if (typeDesc != null)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodeTypeOfExpression(typeDesc.FullName)));
			}
			if (dataType != null)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("DataType", new CodePrimitiveExpression(dataType)));
			}
			metadata.Add(codeAttributeDeclaration);
		}

		private void ExportAttribute(CodeAttributeDeclarationCollection metadata, string name, string ns, TypeDesc typeDesc, TypeDesc dataTypeDesc, XmlSchemaForm form)
		{
			ExportMetadata(metadata, typeof(XmlAttributeAttribute), name, ns, typeDesc, dataTypeDesc, null, form, 0, -1);
		}

		private void ExportArrayItem(CodeAttributeDeclarationCollection metadata, string name, string ns, TypeDesc typeDesc, TypeDesc dataTypeDesc, bool isNullable, XmlSchemaForm form, int nestingLevel)
		{
			ExportMetadata(metadata, typeof(XmlArrayItemAttribute), name, ns, typeDesc, dataTypeDesc, isNullable ? null : ((object)false), form, nestingLevel, -1);
		}

		private void ExportElement(CodeAttributeDeclarationCollection metadata, string name, string ns, TypeDesc typeDesc, TypeDesc dataTypeDesc, bool isNullable, XmlSchemaForm form, int sequenceId)
		{
			ExportMetadata(metadata, typeof(XmlElementAttribute), name, ns, typeDesc, dataTypeDesc, isNullable ? ((object)true) : null, form, 0, sequenceId);
		}

		private void ExportArray(CodeAttributeDeclarationCollection metadata, string name, string ns, bool isNullable, XmlSchemaForm form, int sequenceId)
		{
			ExportMetadata(metadata, typeof(XmlArrayAttribute), name, ns, null, null, isNullable ? ((object)true) : null, form, 0, sequenceId);
		}

		private void ExportMetadata(CodeAttributeDeclarationCollection metadata, Type attributeType, string name, string ns, TypeDesc typeDesc, TypeDesc dataTypeDesc, object isNullable, XmlSchemaForm form, int nestingLevel, int sequenceId)
		{
			CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(attributeType.FullName);
			if (name != null)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(name)));
			}
			if (typeDesc != null)
			{
				if (isNullable != null && (bool)isNullable && typeDesc.IsValueType && !typeDesc.IsMappedType && base.CodeProvider.Supports(GeneratorSupport.GenericTypeReference))
				{
					codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodeTypeOfExpression("System.Nullable`1[" + typeDesc.FullName + "]")));
					isNullable = null;
				}
				else
				{
					codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument(new CodeTypeOfExpression(typeDesc.FullName)));
				}
			}
			if (form != 0)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("Form", new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(XmlSchemaForm).FullName), Enum.Format(typeof(XmlSchemaForm), form, "G"))));
				if (form == XmlSchemaForm.Unqualified && ns != null && ns.Length == 0)
				{
					ns = null;
				}
			}
			if (ns != null)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(ns)));
			}
			if (dataTypeDesc != null && dataTypeDesc.IsAmbiguousDataType && !dataTypeDesc.IsMappedType)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("DataType", new CodePrimitiveExpression(dataTypeDesc.DataType.Name)));
			}
			if (isNullable != null)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("IsNullable", new CodePrimitiveExpression((bool)isNullable)));
			}
			if (nestingLevel > 0)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("NestingLevel", new CodePrimitiveExpression(nestingLevel)));
			}
			if (sequenceId >= 0)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("Order", new CodePrimitiveExpression(sequenceId)));
			}
			if (codeAttributeDeclaration.Arguments.Count != 0 || attributeType != typeof(XmlElementAttribute))
			{
				metadata.Add(codeAttributeDeclaration);
			}
		}

		private void ExportAnyElement(CodeAttributeDeclarationCollection metadata, string name, string ns, int sequenceId)
		{
			CodeAttributeDeclaration codeAttributeDeclaration = new CodeAttributeDeclaration(typeof(XmlAnyElementAttribute).FullName);
			if (name != null && name.Length > 0)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("Name", new CodePrimitiveExpression(name)));
			}
			if (ns != null)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("Namespace", new CodePrimitiveExpression(ns)));
			}
			if (sequenceId >= 0)
			{
				codeAttributeDeclaration.Arguments.Add(new CodeAttributeArgument("Order", new CodePrimitiveExpression(sequenceId)));
			}
			metadata.Add(codeAttributeDeclaration);
		}

		private void ExportAnyAttribute(CodeAttributeDeclarationCollection metadata)
		{
			metadata.Add(new CodeAttributeDeclaration(typeof(XmlAnyAttributeAttribute).FullName));
		}

		internal override void EnsureTypesExported(Accessor[] accessors, string ns)
		{
			if (accessors != null)
			{
				for (int i = 0; i < accessors.Length; i++)
				{
					EnsureTypesExported(accessors[i], ns);
				}
			}
		}

		private void EnsureTypesExported(Accessor accessor, string ns)
		{
			if (accessor != null)
			{
				ExportType(accessor.Mapping, null, ns, null, checkReference: false);
			}
		}
	}
	internal class XmlCountingReader : XmlReader, IXmlTextParser, IXmlLineInfo
	{
		private XmlReader innerReader;

		private int advanceCount;

		internal int AdvanceCount => advanceCount;

		public override XmlReaderSettings Settings => innerReader.Settings;

		public override XmlNodeType NodeType => innerReader.NodeType;

		public override string Name => innerReader.Name;

		public override string LocalName => innerReader.LocalName;

		public override string NamespaceURI => innerReader.NamespaceURI;

		public override string Prefix => innerReader.Prefix;

		public override bool HasValue => innerReader.HasValue;

		public override string Value => innerReader.Value;

		public override int Depth => innerReader.Depth;

		public override string BaseURI => innerReader.BaseURI;

		public override bool IsEmptyElement => innerReader.IsEmptyElement;

		public override bool IsDefault => innerReader.IsDefault;

		public override char QuoteChar => innerReader.QuoteChar;

		public override XmlSpace XmlSpace => innerReader.XmlSpace;

		public override string XmlLang => innerReader.XmlLang;

		public override IXmlSchemaInfo SchemaInfo => innerReader.SchemaInfo;

		public override Type ValueType => innerReader.ValueType;

		public override int AttributeCount => innerReader.AttributeCount;

		public override string this[int i] => innerReader[i];

		public override string this[string name] => innerReader[name];

		public override string this[string name, string namespaceURI] => innerReader[name, namespaceURI];

		public override bool EOF => innerReader.EOF;

		public override ReadState ReadState => innerReader.ReadState;

		public override XmlNameTable NameTable => innerReader.NameTable;

		public override bool CanResolveEntity => innerReader.CanResolveEntity;

		public override bool CanReadBinaryContent => innerReader.CanReadBinaryContent;

		public override bool CanReadValueChunk => innerReader.CanReadValueChunk;

		public override bool HasAttributes => innerReader.HasAttributes;

		bool IXmlTextParser.Normalized
		{
			get
			{
				if (!(innerReader is XmlTextReader xmlTextReader))
				{
					if (innerReader is IXmlTextParser xmlTextParser)
					{
						return xmlTextParser.Normalized;
					}
					return false;
				}
				return xmlTextReader.Normalization;
			}
			set
			{
				if (!(innerReader is XmlTextReader xmlTextReader))
				{
					if (innerReader is IXmlTextParser xmlTextParser)
					{
						xmlTextParser.Normalized = value;
					}
				}
				else
				{
					xmlTextReader.Normalization = value;
				}
			}
		}

		WhitespaceHandling IXmlTextParser.WhitespaceHandling
		{
			get
			{
				if (!(innerReader is XmlTextReader xmlTextReader))
				{
					if (innerReader is IXmlTextParser xmlTextParser)
					{
						return xmlTextParser.WhitespaceHandling;
					}
					return WhitespaceHandling.None;
				}
				return xmlTextReader.WhitespaceHandling;
			}
			set
			{
				if (!(innerReader is XmlTextReader xmlTextReader))
				{
					if (innerReader is IXmlTextParser xmlTextParser)
					{
						xmlTextParser.WhitespaceHandling = value;
					}
				}
				else
				{
					xmlTextReader.WhitespaceHandling = value;
				}
			}
		}

		int IXmlLineInfo.LineNumber
		{
			get
			{
				if (innerReader is IXmlLineInfo xmlLineInfo)
				{
					return xmlLineInfo.LineNumber;
				}
				return 0;
			}
		}

		int IXmlLineInfo.LinePosition
		{
			get
			{
				if (innerReader is IXmlLineInfo xmlLineInfo)
				{
					return xmlLineInfo.LinePosition;
				}
				return 0;
			}
		}

		internal XmlCountingReader(XmlReader xmlReader)
		{
			if (xmlReader == null)
			{
				throw new ArgumentNullException("xmlReader");
			}
			innerReader = xmlReader;
			advanceCount = 0;
		}

		private void IncrementCount()
		{
			if (advanceCount == int.MaxValue)
			{
				advanceCount = 0;
			}
			else
			{
				advanceCount++;
			}
		}

		public override void Close()
		{
			innerReader.Close();
		}

		public override string GetAttribute(string name)
		{
			return innerReader.GetAttribute(name);
		}

		public override string GetAttribute(string name, string namespaceURI)
		{
			return innerReader.GetAttribute(name, namespaceURI);
		}

		public override string GetAttribute(int i)
		{
			return innerReader.GetAttribute(i);
		}

		public override bool MoveToAttribute(string name)
		{
			return innerReader.MoveToAttribute(name);
		}

		public override bool MoveToAttribute(string name, string ns)
		{
			return innerReader.MoveToAttribute(name, ns);
		}

		public override void MoveToAttribute(int i)
		{
			innerReader.MoveToAttribute(i);
		}

		public override bool MoveToFirstAttribute()
		{
			return innerReader.MoveToFirstAttribute();
		}

		public override bool MoveToNextAttribute()
		{
			return innerReader.MoveToNextAttribute();
		}

		public override bool MoveToElement()
		{
			return innerReader.MoveToElement();
		}

		public override string LookupNamespace(string prefix)
		{
			return innerReader.LookupNamespace(prefix);
		}

		public override bool ReadAttributeValue()
		{
			return innerReader.ReadAttributeValue();
		}

		public override void ResolveEntity()
		{
			innerReader.ResolveEntity();
		}

		public override bool IsStartElement()
		{
			return innerReader.IsStartElement();
		}

		public override bool IsStartElement(string name)
		{
			return innerReader.IsStartElement(name);
		}

		public override bool IsStartElement(string localname, string ns)
		{
			return innerReader.IsStartElement(localname, ns);
		}

		public override XmlReader ReadSubtree()
		{
			return innerReader.ReadSubtree();
		}

		public override XmlNodeType MoveToContent()
		{
			return innerReader.MoveToContent();
		}

		public override bool Read()
		{
			IncrementCount();
			return innerReader.Read();
		}

		public override void Skip()
		{
			IncrementCount();
			innerReader.Skip();
		}

		public override string ReadInnerXml()
		{
			if (innerReader.NodeType != XmlNodeType.Attribute)
			{
				IncrementCount();
			}
			return innerReader.ReadInnerXml();
		}

		public override string ReadOuterXml()
		{
			if (innerReader.NodeType != XmlNodeType.Attribute)
			{
				IncrementCount();
			}
			return innerReader.ReadOuterXml();
		}

		public override object ReadContentAsObject()
		{
			IncrementCount();
			return innerReader.ReadContentAsObject();
		}

		public override bool ReadContentAsBoolean()
		{
			IncrementCount();
			return innerReader.ReadContentAsBoolean();
		}

		public override DateTime ReadContentAsDateTime()
		{
			IncrementCount();
			return innerReader.ReadContentAsDateTime();
		}

		public override double ReadContentAsDouble()
		{
			IncrementCount();
			return innerReader.ReadContentAsDouble();
		}

		public override int ReadContentAsInt()
		{
			IncrementCount();
			return innerReader.ReadContentAsInt();
		}

		public override long ReadContentAsLong()
		{
			IncrementCount();
			return innerReader.ReadContentAsLong();
		}

		public override string ReadContentAsString()
		{
			IncrementCount();
			return innerReader.ReadContentAsString();
		}

		public override object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver)
		{
			IncrementCount();
			return innerReader.ReadContentAs(returnType, namespaceResolver);
		}

		public override object ReadElementContentAsObject()
		{
			IncrementCount();
			return innerReader.ReadElementContentAsObject();
		}

		public override object ReadElementContentAsObject(string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadElementContentAsObject(localName, namespaceURI);
		}

		public override bool ReadElementContentAsBoolean()
		{
			IncrementCount();
			return innerReader.ReadElementContentAsBoolean();
		}

		public override bool ReadElementContentAsBoolean(string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadElementContentAsBoolean(localName, namespaceURI);
		}

		public override DateTime ReadElementContentAsDateTime()
		{
			IncrementCount();
			return innerReader.ReadElementContentAsDateTime();
		}

		public override DateTime ReadElementContentAsDateTime(string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadElementContentAsDateTime(localName, namespaceURI);
		}

		public override double ReadElementContentAsDouble()
		{
			IncrementCount();
			return innerReader.ReadElementContentAsDouble();
		}

		public override double ReadElementContentAsDouble(string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadElementContentAsDouble(localName, namespaceURI);
		}

		public override int ReadElementContentAsInt()
		{
			IncrementCount();
			return innerReader.ReadElementContentAsInt();
		}

		public override int ReadElementContentAsInt(string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadElementContentAsInt(localName, namespaceURI);
		}

		public override long ReadElementContentAsLong()
		{
			IncrementCount();
			return innerReader.ReadElementContentAsLong();
		}

		public override long ReadElementContentAsLong(string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadElementContentAsLong(localName, namespaceURI);
		}

		public override string ReadElementContentAsString()
		{
			IncrementCount();
			return innerReader.ReadElementContentAsString();
		}

		public override string ReadElementContentAsString(string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadElementContentAsString(localName, namespaceURI);
		}

		public override object ReadElementContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver)
		{
			IncrementCount();
			return innerReader.ReadElementContentAs(returnType, namespaceResolver);
		}

		public override object ReadElementContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadElementContentAs(returnType, namespaceResolver, localName, namespaceURI);
		}

		public override int ReadContentAsBase64(byte[] buffer, int index, int count)
		{
			IncrementCount();
			return innerReader.ReadContentAsBase64(buffer, index, count);
		}

		public override int ReadElementContentAsBase64(byte[] buffer, int index, int count)
		{
			IncrementCount();
			return innerReader.ReadElementContentAsBase64(buffer, index, count);
		}

		public override int ReadContentAsBinHex(byte[] buffer, int index, int count)
		{
			IncrementCount();
			return innerReader.ReadContentAsBinHex(buffer, index, count);
		}

		public override int ReadElementContentAsBinHex(byte[] buffer, int index, int count)
		{
			IncrementCount();
			return innerReader.ReadElementContentAsBinHex(buffer, index, count);
		}

		public override int ReadValueChunk(char[] buffer, int index, int count)
		{
			IncrementCount();
			return innerReader.ReadValueChunk(buffer, index, count);
		}

		public override string ReadString()
		{
			IncrementCount();
			return innerReader.ReadString();
		}

		public override void ReadStartElement()
		{
			IncrementCount();
			innerReader.ReadStartElement();
		}

		public override void ReadStartElement(string name)
		{
			IncrementCount();
			innerReader.ReadStartElement(name);
		}

		public override void ReadStartElement(string localname, string ns)
		{
			IncrementCount();
			innerReader.ReadStartElement(localname, ns);
		}

		public override string ReadElementString()
		{
			IncrementCount();
			return innerReader.ReadElementString();
		}

		public override string ReadElementString(string name)
		{
			IncrementCount();
			return innerReader.ReadElementString(name);
		}

		public override string ReadElementString(string localname, string ns)
		{
			IncrementCount();
			return innerReader.ReadElementString(localname, ns);
		}

		public override void ReadEndElement()
		{
			IncrementCount();
			innerReader.ReadEndElement();
		}

		public override bool ReadToFollowing(string name)
		{
			IncrementCount();
			return ReadToFollowing(name);
		}

		public override bool ReadToFollowing(string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadToFollowing(localName, namespaceURI);
		}

		public override bool ReadToDescendant(string name)
		{
			IncrementCount();
			return innerReader.ReadToDescendant(name);
		}

		public override bool ReadToDescendant(string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadToDescendant(localName, namespaceURI);
		}

		public override bool ReadToNextSibling(string name)
		{
			IncrementCount();
			return innerReader.ReadToNextSibling(name);
		}

		public override bool ReadToNextSibling(string localName, string namespaceURI)
		{
			IncrementCount();
			return innerReader.ReadToNextSibling(localName, namespaceURI);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				((IDisposable)innerReader)?.Dispose();
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		bool IXmlLineInfo.HasLineInfo()
		{
			if (innerReader is IXmlLineInfo xmlLineInfo)
			{
				return xmlLineInfo.HasLineInfo();
			}
			return false;
		}
	}
	internal class XmlCustomFormatter
	{
		private static DateTimeSerializationSection.DateTimeSerializationMode mode;

		private static string[] allDateTimeFormats = new string[65]
		{
			"yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz", "yyyy", "---dd", "---ddZ", "---ddzzzzzz", "--MM-dd", "--MM-ddZ", "--MM-ddzzzzzz", "--MM--", "--MM--Z",
			"--MM--zzzzzz", "yyyy-MM", "yyyy-MMZ", "yyyy-MMzzzzzz", "yyyyzzzzzz", "yyyy-MM-dd", "yyyy-MM-ddZ", "yyyy-MM-ddzzzzzz", "HH:mm:ss", "HH:mm:ss.f",
			"HH:mm:ss.ff", "HH:mm:ss.fff", "HH:mm:ss.ffff", "HH:mm:ss.fffff", "HH:mm:ss.ffffff", "HH:mm:ss.fffffff", "HH:mm:ssZ", "HH:mm:ss.fZ", "HH:mm:ss.ffZ", "HH:mm:ss.fffZ",
			"HH:mm:ss.ffffZ", "HH:mm:ss.fffffZ", "HH:mm:ss.ffffffZ", "HH:mm:ss.fffffffZ", "HH:mm:sszzzzzz", "HH:mm:ss.fzzzzzz", "HH:mm:ss.ffzzzzzz", "HH:mm:ss.fffzzzzzz", "HH:mm:ss.ffffzzzzzz", "HH:mm:ss.fffffzzzzzz",
			"HH:mm:ss.ffffffzzzzzz", "HH:mm:ss.fffffffzzzzzz", "yyyy-MM-ddTHH:mm:ss", "yyyy-MM-ddTHH:mm:ss.f", "yyyy-MM-ddTHH:mm:ss.ff", "yyyy-MM-ddTHH:mm:ss.fff", "yyyy-MM-ddTHH:mm:ss.ffff", "yyyy-MM-ddTHH:mm:ss.fffff", "yyyy-MM-ddTHH:mm:ss.ffffff", "yyyy-MM-ddTHH:mm:ss.fffffff",
			"yyyy-MM-ddTHH:mm:ssZ", "yyyy-MM-ddTHH:mm:ss.fZ", "yyyy-MM-ddTHH:mm:ss.ffZ", "yyyy-MM-ddTHH:mm:ss.fffZ", "yyyy-MM-ddTHH:mm:ss.ffffZ", "yyyy-MM-ddTHH:mm:ss.fffffZ", "yyyy-MM-ddTHH:mm:ss.ffffffZ", "yyyy-MM-ddTHH:mm:ss.fffffffZ", "yyyy-MM-ddTHH:mm:sszzzzzz", "yyyy-MM-ddTHH:mm:ss.fzzzzzz",
			"yyyy-MM-ddTHH:mm:ss.ffzzzzzz", "yyyy-MM-ddTHH:mm:ss.fffzzzzzz", "yyyy-MM-ddTHH:mm:ss.ffffzzzzzz", "yyyy-MM-ddTHH:mm:ss.fffffzzzzzz", "yyyy-MM-ddTHH:mm:ss.ffffffzzzzzz"
		};

		private static string[] allDateFormats = new string[17]
		{
			"yyyy-MM-ddzzzzzz", "yyyy-MM-dd", "yyyy-MM-ddZ", "yyyy", "---dd", "---ddZ", "---ddzzzzzz", "--MM-dd", "--MM-ddZ", "--MM-ddzzzzzz",
			"--MM--", "--MM--Z", "--MM--zzzzzz", "yyyy-MM", "yyyy-MMZ", "yyyy-MMzzzzzz", "yyyyzzzzzz"
		};

		private static string[] allTimeFormats = new string[24]
		{
			"HH:mm:ss.fffffffzzzzzz", "HH:mm:ss", "HH:mm:ss.f", "HH:mm:ss.ff", "HH:mm:ss.fff", "HH:mm:ss.ffff", "HH:mm:ss.fffff", "HH:mm:ss.ffffff", "HH:mm:ss.fffffff", "HH:mm:ssZ",
			"HH:mm:ss.fZ", "HH:mm:ss.ffZ", "HH:mm:ss.fffZ", "HH:mm:ss.ffffZ", "HH:mm:ss.fffffZ", "HH:mm:ss.ffffffZ", "HH:mm:ss.fffffffZ", "HH:mm:sszzzzzz", "HH:mm:ss.fzzzzzz", "HH:mm:ss.ffzzzzzz",
			"HH:mm:ss.fffzzzzzz", "HH:mm:ss.ffffzzzzzz", "HH:mm:ss.fffffzzzzzz", "HH:mm:ss.ffffffzzzzzz"
		};

		private static DateTimeSerializationSection.DateTimeSerializationMode Mode
		{
			get
			{
				if (mode == DateTimeSerializationSection.DateTimeSerializationMode.Default)
				{
					if (System.Configuration.PrivilegedConfigurationManager.GetSection(ConfigurationStrings.DateTimeSerializationSectionPath) is DateTimeSerializationSection dateTimeSerializationSection)
					{
						mode = dateTimeSerializationSection.Mode;
					}
					else
					{
						mode = DateTimeSerializationSection.DateTimeSerializationMode.Roundtrip;
					}
				}
				return mode;
			}
		}

		private XmlCustomFormatter()
		{
		}

		internal static string FromDefaultValue(object value, string formatter)
		{
			if (value == null)
			{
				return null;
			}
			Type type = value.GetType();
			if (type == typeof(DateTime))
			{
				switch (formatter)
				{
				case "DateTime":
					return FromDateTime((DateTime)value);
				case "Date":
					return FromDate((DateTime)value);
				case "Time":
					return FromTime((DateTime)value);
				}
			}
			else if (type == typeof(string))
			{
				switch (formatter)
				{
				case "XmlName":
					return FromXmlName((string)value);
				case "XmlNCName":
					return FromXmlNCName((string)value);
				case "XmlNmToken":
					return FromXmlNmToken((string)value);
				case "XmlNmTokens":
					return FromXmlNmTokens((string)value);
				}
			}
			throw new Exception(Res.GetString("XmlUnsupportedDefaultType", type.FullName));
		}

		internal static string FromDate(DateTime value)
		{
			return XmlConvert.ToString(value, "yyyy-MM-dd");
		}

		internal static string FromTime(DateTime value)
		{
			return XmlConvert.ToString(DateTime.MinValue + value.TimeOfDay, "HH:mm:ss.fffffffzzzzzz");
		}

		internal static string FromDateTime(DateTime value)
		{
			if (Mode == DateTimeSerializationSection.DateTimeSerializationMode.Local)
			{
				return XmlConvert.ToString(value, "yyyy-MM-ddTHH:mm:ss.fffffffzzzzzz");
			}
			return XmlConvert.ToString(value, XmlDateTimeSerializationMode.RoundtripKind);
		}

		internal static string FromChar(char value)
		{
			return XmlConvert.ToString((ushort)value);
		}

		internal static string FromXmlName(string name)
		{
			return XmlConvert.EncodeName(name);
		}

		internal static string FromXmlNCName(string ncName)
		{
			return XmlConvert.EncodeLocalName(ncName);
		}

		internal static string FromXmlNmToken(string nmToken)
		{
			return XmlConvert.EncodeNmToken(nmToken);
		}

		internal static string FromXmlNmTokens(string nmTokens)
		{
			if (nmTokens == null)
			{
				return null;
			}
			if (nmTokens.IndexOf(' ') < 0)
			{
				return FromXmlNmToken(nmTokens);
			}
			string[] array = nmTokens.Split(' ');
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < array.Length; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append(' ');
				}
				stringBuilder.Append(FromXmlNmToken(array[i]));
			}
			return stringBuilder.ToString();
		}

		internal static void WriteArrayBase64(XmlWriter writer, byte[] inData, int start, int count)
		{
			if (inData != null && count != 0)
			{
				writer.WriteBase64(inData, start, count);
			}
		}

		internal static string FromByteArrayHex(byte[] value)
		{
			if (value == null)
			{
				return null;
			}
			if (value.Length == 0)
			{
				return "";
			}
			return XmlConvert.ToBinHexString(value);
		}

		internal static string FromEnum(long val, string[] vals, long[] ids, string typeName)
		{
			long num = val;
			StringBuilder stringBuilder = new StringBuilder();
			int num2 = -1;
			for (int i = 0; i < ids.Length; i++)
			{
				if (ids[i] == 0)
				{
					num2 = i;
					continue;
				}
				if (val == 0)
				{
					break;
				}
				if ((ids[i] & num) == ids[i])
				{
					if (stringBuilder.Length != 0)
					{
						stringBuilder.Append(" ");
					}
					stringBuilder.Append(vals[i]);
					val &= ~ids[i];
				}
			}
			if (val != 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlUnknownConstant", num, (typeName == null) ? "enum" : typeName));
			}
			if (stringBuilder.Length == 0 && num2 >= 0)
			{
				stringBuilder.Append(vals[num2]);
			}
			return stringBuilder.ToString();
		}

		internal static object ToDefaultValue(string value, string formatter)
		{
			return formatter switch
			{
				"DateTime" => ToDateTime(value), 
				"Date" => ToDate(value), 
				"Time" => ToTime(value), 
				"XmlName" => ToXmlName(value), 
				"XmlNCName" => ToXmlNCName(value), 
				"XmlNmToken" => ToXmlNmToken(value), 
				"XmlNmTokens" => ToXmlNmTokens(value), 
				_ => throw new Exception(Res.GetString("XmlUnsupportedDefaultValue", formatter)), 
			};
		}

		internal static DateTime ToDateTime(string value)
		{
			if (Mode == DateTimeSerializationSection.DateTimeSerializationMode.Local)
			{
				return ToDateTime(value, allDateTimeFormats);
			}
			return XmlConvert.ToDateTime(value, XmlDateTimeSerializationMode.RoundtripKind);
		}

		internal static DateTime ToDateTime(string value, string[] formats)
		{
			return XmlConvert.ToDateTime(value, formats);
		}

		internal static DateTime ToDate(string value)
		{
			return ToDateTime(value, allDateFormats);
		}

		internal static DateTime ToTime(string value)
		{
			return DateTime.ParseExact(value, allTimeFormats, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowLeadingWhite | DateTimeStyles.AllowTrailingWhite | DateTimeStyles.NoCurrentDateDefault);
		}

		internal static char ToChar(string value)
		{
			return (char)XmlConvert.ToUInt16(value);
		}

		internal static string ToXmlName(string value)
		{
			return XmlConvert.DecodeName(CollapseWhitespace(value));
		}

		internal static string ToXmlNCName(string value)
		{
			return XmlConvert.DecodeName(CollapseWhitespace(value));
		}

		internal static string ToXmlNmToken(string value)
		{
			return XmlConvert.DecodeName(CollapseWhitespace(value));
		}

		internal static string ToXmlNmTokens(string value)
		{
			return XmlConvert.DecodeName(CollapseWhitespace(value));
		}

		internal static byte[] ToByteArrayBase64(string value)
		{
			if (value == null)
			{
				return null;
			}
			value = value.Trim();
			if (value.Length == 0)
			{
				return new byte[0];
			}
			return Convert.FromBase64String(value);
		}

		internal static byte[] ToByteArrayHex(string value)
		{
			if (value == null)
			{
				return null;
			}
			value = value.Trim();
			return XmlConvert.FromBinHexString(value);
		}

		internal static long ToEnum(string val, Hashtable vals, string typeName, bool validate)
		{
			long num = 0L;
			string[] array = val.Split(null);
			for (int i = 0; i < array.Length; i++)
			{
				object obj = vals[array[i]];
				if (obj != null)
				{
					num |= (long)obj;
				}
				else if (validate && array[i].Length > 0)
				{
					throw new InvalidOperationException(Res.GetString("XmlUnknownConstant", array[i], typeName));
				}
			}
			return num;
		}

		private static string CollapseWhitespace(string value)
		{
			return value?.Trim();
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = true)]
	public class XmlElementAttribute : Attribute
	{
		private string elementName;

		private Type type;

		private string ns;

		private string dataType;

		private bool nullable;

		private bool nullableSpecified;

		private XmlSchemaForm form;

		private int order = -1;

		public Type Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public string ElementName
		{
			get
			{
				if (elementName != null)
				{
					return elementName;
				}
				return string.Empty;
			}
			set
			{
				elementName = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		public string DataType
		{
			get
			{
				if (dataType != null)
				{
					return dataType;
				}
				return string.Empty;
			}
			set
			{
				dataType = value;
			}
		}

		public bool IsNullable
		{
			get
			{
				return nullable;
			}
			set
			{
				nullable = value;
				nullableSpecified = true;
			}
		}

		internal bool IsNullableSpecified => nullableSpecified;

		public XmlSchemaForm Form
		{
			get
			{
				return form;
			}
			set
			{
				form = value;
			}
		}

		public int Order
		{
			get
			{
				return order;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(Res.GetString("XmlDisallowNegativeValues"), "Order");
				}
				order = value;
			}
		}

		public XmlElementAttribute()
		{
		}

		public XmlElementAttribute(string elementName)
		{
			this.elementName = elementName;
		}

		public XmlElementAttribute(Type type)
		{
			this.type = type;
		}

		public XmlElementAttribute(string elementName, Type type)
		{
			this.elementName = elementName;
			this.type = type;
		}
	}
	public class XmlElementAttributes : CollectionBase
	{
		public XmlElementAttribute this[int index]
		{
			get
			{
				return (XmlElementAttribute)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public int Add(XmlElementAttribute attribute)
		{
			return base.List.Add(attribute);
		}

		public void Insert(int index, XmlElementAttribute attribute)
		{
			base.List.Insert(index, attribute);
		}

		public int IndexOf(XmlElementAttribute attribute)
		{
			return base.List.IndexOf(attribute);
		}

		public bool Contains(XmlElementAttribute attribute)
		{
			return base.List.Contains(attribute);
		}

		public void Remove(XmlElementAttribute attribute)
		{
			base.List.Remove(attribute);
		}

		public void CopyTo(XmlElementAttribute[] array, int index)
		{
			base.List.CopyTo(array, index);
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	public class XmlEnumAttribute : Attribute
	{
		private string name;

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public XmlEnumAttribute()
		{
		}

		public XmlEnumAttribute(string name)
		{
			this.name = name;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
	public class XmlIgnoreAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Interface, AllowMultiple = true)]
	public class XmlIncludeAttribute : Attribute
	{
		private Type type;

		public Type Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public XmlIncludeAttribute(Type type)
		{
			this.type = type;
		}
	}
	[Flags]
	public enum XmlMappingAccess
	{
		None = 0,
		Read = 1,
		Write = 2
	}
	public abstract class XmlMapping
	{
		private TypeScope scope;

		private bool generateSerializer;

		private bool isSoap;

		private ElementAccessor accessor;

		private string key;

		private bool shallow;

		private XmlMappingAccess access;

		internal ElementAccessor Accessor => accessor;

		internal TypeScope Scope => scope;

		public string ElementName => System.Xml.Serialization.Accessor.UnescapeName(Accessor.Name);

		public string XsdElementName => Accessor.Name;

		public string Namespace => accessor.Namespace;

		internal bool GenerateSerializer
		{
			get
			{
				return generateSerializer;
			}
			set
			{
				generateSerializer = value;
			}
		}

		internal bool IsReadable => (access & XmlMappingAccess.Read) != 0;

		internal bool IsWriteable => (access & XmlMappingAccess.Write) != 0;

		internal bool IsSoap
		{
			get
			{
				return isSoap;
			}
			set
			{
				isSoap = value;
			}
		}

		internal string Key => key;

		internal XmlMapping(TypeScope scope, ElementAccessor accessor)
			: this(scope, accessor, XmlMappingAccess.Read | XmlMappingAccess.Write)
		{
		}

		internal XmlMapping(TypeScope scope, ElementAccessor accessor, XmlMappingAccess access)
		{
			this.scope = scope;
			this.accessor = accessor;
			this.access = access;
			shallow = scope == null;
		}

		public void SetKey(string key)
		{
			SetKeyInternal(key);
		}

		internal void SetKeyInternal(string key)
		{
			this.key = key;
		}

		internal static string GenerateKey(Type type, XmlRootAttribute root, string ns)
		{
			if (root == null)
			{
				root = (XmlRootAttribute)XmlAttributes.GetAttr(type, typeof(XmlRootAttribute));
			}
			return type.FullName + ":" + ((root == null) ? string.Empty : root.Key) + ":" + ((ns == null) ? string.Empty : ns);
		}

		internal void CheckShallow()
		{
			if (shallow)
			{
				throw new InvalidOperationException(Res.GetString("XmlMelformMapping"));
			}
		}

		internal static bool IsShallow(XmlMapping[] mappings)
		{
			for (int i = 0; i < mappings.Length; i++)
			{
				if (mappings[i] == null || mappings[i].shallow)
				{
					return true;
				}
			}
			return false;
		}
	}
	public class XmlMemberMapping
	{
		private MemberMapping mapping;

		internal MemberMapping Mapping => mapping;

		internal Accessor Accessor => mapping.Accessor;

		public bool Any => Accessor.Any;

		public string ElementName => Accessor.UnescapeName(Accessor.Name);

		public string XsdElementName => Accessor.Name;

		public string Namespace => Accessor.Namespace;

		public string MemberName => mapping.Name;

		public string TypeName
		{
			get
			{
				if (Accessor.Mapping == null)
				{
					return string.Empty;
				}
				return Accessor.Mapping.TypeName;
			}
		}

		public string TypeNamespace
		{
			get
			{
				if (Accessor.Mapping == null)
				{
					return null;
				}
				return Accessor.Mapping.Namespace;
			}
		}

		public string TypeFullName => mapping.TypeDesc.FullName;

		public bool CheckSpecified => mapping.CheckSpecified != SpecifiedAccessor.None;

		internal bool IsNullable => mapping.IsNeedNullable;

		internal XmlMemberMapping(MemberMapping mapping)
		{
			this.mapping = mapping;
		}

		public string GenerateTypeName(CodeDomProvider codeProvider)
		{
			return mapping.GetTypeName(codeProvider);
		}
	}
	public class XmlMembersMapping : XmlMapping
	{
		private XmlMemberMapping[] mappings;

		public string TypeName => base.Accessor.Mapping.TypeName;

		public string TypeNamespace => base.Accessor.Mapping.Namespace;

		public XmlMemberMapping this[int index] => mappings[index];

		public int Count => mappings.Length;

		internal XmlMembersMapping(TypeScope scope, ElementAccessor accessor, XmlMappingAccess access)
			: base(scope, accessor, access)
		{
			MembersMapping membersMapping = (MembersMapping)accessor.Mapping;
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(":");
			mappings = new XmlMemberMapping[membersMapping.Members.Length];
			for (int i = 0; i < mappings.Length; i++)
			{
				if (membersMapping.Members[i].TypeDesc.Type != null)
				{
					stringBuilder.Append(XmlMapping.GenerateKey(membersMapping.Members[i].TypeDesc.Type, null, null));
					stringBuilder.Append(":");
				}
				mappings[i] = new XmlMemberMapping(membersMapping.Members[i]);
			}
			SetKeyInternal(stringBuilder.ToString());
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = false)]
	public class XmlNamespaceDeclarationsAttribute : Attribute
	{
	}
	public class XmlReflectionImporter
	{
		private enum ImportContext
		{
			Text,
			Attribute,
			Element
		}

		private TypeScope typeScope;

		private XmlAttributeOverrides attributeOverrides;

		private XmlAttributes defaultAttributes = new XmlAttributes();

		private NameTable types = new NameTable();

		private NameTable nullables = new NameTable();

		private NameTable elements = new NameTable();

		private NameTable xsdAttributes;

		private Hashtable specials;

		private Hashtable anonymous = new Hashtable();

		private NameTable serializables;

		private StructMapping root;

		private string defaultNs;

		private ModelScope modelScope;

		private int arrayNestingLevel;

		private XmlArrayItemAttributes savedArrayItemAttributes;

		private string savedArrayNamespace;

		private int choiceNum = 1;

		public XmlReflectionImporter()
			: this(null, null)
		{
		}

		public XmlReflectionImporter(string defaultNamespace)
			: this(null, defaultNamespace)
		{
		}

		public XmlReflectionImporter(XmlAttributeOverrides attributeOverrides)
			: this(attributeOverrides, null)
		{
		}

		public XmlReflectionImporter(XmlAttributeOverrides attributeOverrides, string defaultNamespace)
		{
			if (defaultNamespace == null)
			{
				defaultNamespace = string.Empty;
			}
			if (attributeOverrides == null)
			{
				attributeOverrides = new XmlAttributeOverrides();
			}
			this.attributeOverrides = attributeOverrides;
			defaultNs = defaultNamespace;
			typeScope = new TypeScope();
			modelScope = new ModelScope(typeScope);
		}

		public void IncludeTypes(ICustomAttributeProvider provider)
		{
			IncludeTypes(provider, new RecursionLimiter());
		}

		private void IncludeTypes(ICustomAttributeProvider provider, RecursionLimiter limiter)
		{
			object[] customAttributes = provider.GetCustomAttributes(typeof(XmlIncludeAttribute), inherit: false);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				Type type = ((XmlIncludeAttribute)customAttributes[i]).Type;
				IncludeType(type, limiter);
			}
		}

		public void IncludeType(Type type)
		{
			IncludeType(type, new RecursionLimiter());
		}

		private void IncludeType(Type type, RecursionLimiter limiter)
		{
			int num = arrayNestingLevel;
			XmlArrayItemAttributes xmlArrayItemAttributes = savedArrayItemAttributes;
			string text = savedArrayNamespace;
			arrayNestingLevel = 0;
			savedArrayItemAttributes = null;
			savedArrayNamespace = null;
			TypeMapping typeMapping = ImportTypeMapping(modelScope.GetTypeModel(type), defaultNs, ImportContext.Element, string.Empty, null, limiter);
			if (typeMapping.IsAnonymousType && !typeMapping.TypeDesc.IsSpecial)
			{
				throw new InvalidOperationException(Res.GetString("XmlAnonymousInclude", type.FullName));
			}
			arrayNestingLevel = num;
			savedArrayItemAttributes = xmlArrayItemAttributes;
			savedArrayNamespace = text;
		}

		public XmlTypeMapping ImportTypeMapping(Type type)
		{
			return ImportTypeMapping(type, null, null);
		}

		public XmlTypeMapping ImportTypeMapping(Type type, string defaultNamespace)
		{
			return ImportTypeMapping(type, null, defaultNamespace);
		}

		public XmlTypeMapping ImportTypeMapping(Type type, XmlRootAttribute root)
		{
			return ImportTypeMapping(type, root, null);
		}

		public XmlTypeMapping ImportTypeMapping(Type type, XmlRootAttribute root, string defaultNamespace)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			XmlTypeMapping xmlTypeMapping = new XmlTypeMapping(typeScope, ImportElement(modelScope.GetTypeModel(type), root, defaultNamespace, new RecursionLimiter()));
			xmlTypeMapping.SetKeyInternal(XmlMapping.GenerateKey(type, root, defaultNamespace));
			xmlTypeMapping.GenerateSerializer = true;
			return xmlTypeMapping;
		}

		public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement)
		{
			return ImportMembersMapping(elementName, ns, members, hasWrapperElement, rpc: false);
		}

		public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool rpc)
		{
			return ImportMembersMapping(elementName, ns, members, hasWrapperElement, rpc, openModel: false);
		}

		public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool rpc, bool openModel)
		{
			return ImportMembersMapping(elementName, ns, members, hasWrapperElement, rpc, openModel, XmlMappingAccess.Read | XmlMappingAccess.Write);
		}

		public XmlMembersMapping ImportMembersMapping(string elementName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool rpc, bool openModel, XmlMappingAccess access)
		{
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.Name = ((elementName == null || elementName.Length == 0) ? elementName : XmlConvert.EncodeLocalName(elementName));
			elementAccessor.Namespace = ns;
			MembersMapping membersMapping = (MembersMapping)(elementAccessor.Mapping = ImportMembersMapping(members, ns, hasWrapperElement, rpc, openModel, new RecursionLimiter()));
			elementAccessor.Form = XmlSchemaForm.Qualified;
			if (!rpc)
			{
				if (hasWrapperElement)
				{
					elementAccessor = (ElementAccessor)ReconcileAccessor(elementAccessor, elements);
				}
				else
				{
					MemberMapping[] members2 = membersMapping.Members;
					foreach (MemberMapping memberMapping in members2)
					{
						if (memberMapping.Elements != null && memberMapping.Elements.Length > 0)
						{
							memberMapping.Elements[0] = (ElementAccessor)ReconcileAccessor(memberMapping.Elements[0], elements);
						}
					}
				}
			}
			XmlMembersMapping xmlMembersMapping = new XmlMembersMapping(typeScope, elementAccessor, access);
			xmlMembersMapping.GenerateSerializer = true;
			return xmlMembersMapping;
		}

		private XmlAttributes GetAttributes(Type type, bool canBeSimpleType)
		{
			XmlAttributes xmlAttributes = attributeOverrides[type];
			if (xmlAttributes != null)
			{
				return xmlAttributes;
			}
			if (canBeSimpleType && TypeScope.IsKnownType(type))
			{
				return defaultAttributes;
			}
			return new XmlAttributes(type);
		}

		private XmlAttributes GetAttributes(MemberInfo memberInfo)
		{
			XmlAttributes xmlAttributes = attributeOverrides[memberInfo.DeclaringType, memberInfo.Name];
			if (xmlAttributes != null)
			{
				return xmlAttributes;
			}
			return new XmlAttributes(memberInfo);
		}

		private ElementAccessor ImportElement(TypeModel model, XmlRootAttribute root, string defaultNamespace, RecursionLimiter limiter)
		{
			XmlAttributes attributes = GetAttributes(model.Type, canBeSimpleType: true);
			if (root == null)
			{
				root = attributes.XmlRoot;
			}
			string text = root?.Namespace;
			if (text == null)
			{
				text = defaultNamespace;
			}
			if (text == null)
			{
				text = defaultNs;
			}
			arrayNestingLevel = -1;
			savedArrayItemAttributes = null;
			savedArrayNamespace = null;
			ElementAccessor elementAccessor = CreateElementAccessor(ImportTypeMapping(model, text, ImportContext.Element, string.Empty, attributes, limiter), text);
			if (root != null)
			{
				if (root.ElementName.Length > 0)
				{
					elementAccessor.Name = XmlConvert.EncodeLocalName(root.ElementName);
				}
				if (root.IsNullableSpecified && !root.IsNullable && model.TypeDesc.IsOptionalValue)
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidNotNullable", model.TypeDesc.BaseTypeDesc.FullName, "XmlRoot"));
				}
				elementAccessor.IsNullable = (root.IsNullableSpecified ? root.IsNullable : (model.TypeDesc.IsNullable || model.TypeDesc.IsOptionalValue));
				CheckNullable(elementAccessor.IsNullable, model.TypeDesc, elementAccessor.Mapping);
			}
			else
			{
				elementAccessor.IsNullable = model.TypeDesc.IsNullable || model.TypeDesc.IsOptionalValue;
			}
			elementAccessor.Form = XmlSchemaForm.Qualified;
			return (ElementAccessor)ReconcileAccessor(elementAccessor, elements);
		}

		private static string GetMappingName(Mapping mapping)
		{
			if (mapping is MembersMapping)
			{
				return "(method)";
			}
			if (mapping is TypeMapping)
			{
				return ((TypeMapping)mapping).TypeDesc.FullName;
			}
			throw new ArgumentException(Res.GetString("XmlInternalError"), "mapping");
		}

		private ElementAccessor ReconcileLocalAccessor(ElementAccessor accessor, string ns)
		{
			if (accessor.Namespace == ns)
			{
				return accessor;
			}
			return (ElementAccessor)ReconcileAccessor(accessor, elements);
		}

		private Accessor ReconcileAccessor(Accessor accessor, NameTable accessors)
		{
			if (accessor.Any && accessor.Name.Length == 0)
			{
				return accessor;
			}
			Accessor accessor2 = (Accessor)accessors[accessor.Name, accessor.Namespace];
			if (accessor2 == null)
			{
				accessor.IsTopLevelInSchema = true;
				accessors.Add(accessor.Name, accessor.Namespace, accessor);
				return accessor;
			}
			if (accessor2.Mapping == accessor.Mapping)
			{
				return accessor2;
			}
			if (!(accessor.Mapping is MembersMapping) && !(accessor2.Mapping is MembersMapping) && (accessor.Mapping.TypeDesc == accessor2.Mapping.TypeDesc || (accessor2.Mapping is NullableMapping && accessor.Mapping.TypeDesc == ((NullableMapping)accessor2.Mapping).BaseMapping.TypeDesc) || (accessor.Mapping is NullableMapping && ((NullableMapping)accessor.Mapping).BaseMapping.TypeDesc == accessor2.Mapping.TypeDesc)))
			{
				string text = Convert.ToString(accessor.Default, CultureInfo.InvariantCulture);
				string text2 = Convert.ToString(accessor2.Default, CultureInfo.InvariantCulture);
				if (text == text2)
				{
					return accessor2;
				}
				throw new InvalidOperationException(Res.GetString("XmlCannotReconcileAccessorDefault", accessor.Name, accessor.Namespace, text, text2));
			}
			if (accessor.Mapping is MembersMapping || accessor2.Mapping is MembersMapping)
			{
				throw new InvalidOperationException(Res.GetString("XmlMethodTypeNameConflict", accessor.Name, accessor.Namespace));
			}
			if (accessor.Mapping is ArrayMapping)
			{
				if (!(accessor2.Mapping is ArrayMapping))
				{
					throw new InvalidOperationException(Res.GetString("XmlCannotReconcileAccessor", accessor.Name, accessor.Namespace, GetMappingName(accessor2.Mapping), GetMappingName(accessor.Mapping)));
				}
				ArrayMapping arrayMapping = (ArrayMapping)accessor.Mapping;
				ArrayMapping arrayMapping2 = (arrayMapping.IsAnonymousType ? null : ((ArrayMapping)types[accessor2.Mapping.TypeName, accessor2.Mapping.Namespace]));
				ArrayMapping next = arrayMapping2;
				while (arrayMapping2 != null)
				{
					if (arrayMapping2 == accessor.Mapping)
					{
						return accessor2;
					}
					arrayMapping2 = arrayMapping2.Next;
				}
				arrayMapping.Next = next;
				if (!arrayMapping.IsAnonymousType)
				{
					types[accessor2.Mapping.TypeName, accessor2.Mapping.Namespace] = arrayMapping;
				}
				return accessor2;
			}
			if (accessor is AttributeAccessor)
			{
				throw new InvalidOperationException(Res.GetString("XmlCannotReconcileAttributeAccessor", accessor.Name, accessor.Namespace, GetMappingName(accessor2.Mapping), GetMappingName(accessor.Mapping)));
			}
			throw new InvalidOperationException(Res.GetString("XmlCannotReconcileAccessor", accessor.Name, accessor.Namespace, GetMappingName(accessor2.Mapping), GetMappingName(accessor.Mapping)));
		}

		private Exception CreateReflectionException(string context, Exception e)
		{
			return new InvalidOperationException(Res.GetString("XmlReflectionError", context), e);
		}

		private Exception CreateTypeReflectionException(string context, Exception e)
		{
			return new InvalidOperationException(Res.GetString("XmlTypeReflectionError", context), e);
		}

		private Exception CreateMemberReflectionException(FieldModel model, Exception e)
		{
			return new InvalidOperationException(Res.GetString(model.IsProperty ? "XmlPropertyReflectionError" : "XmlFieldReflectionError", model.Name), e);
		}

		private TypeMapping ImportTypeMapping(TypeModel model, string ns, ImportContext context, string dataType, XmlAttributes a, RecursionLimiter limiter)
		{
			return ImportTypeMapping(model, ns, context, dataType, a, repeats: false, openModel: false, limiter);
		}

		private TypeMapping ImportTypeMapping(TypeModel model, string ns, ImportContext context, string dataType, XmlAttributes a, bool repeats, bool openModel, RecursionLimiter limiter)
		{
			try
			{
				if (dataType.Length > 0)
				{
					TypeDesc typeDesc = (TypeScope.IsOptionalValue(model.Type) ? model.TypeDesc.BaseTypeDesc : model.TypeDesc);
					if (!typeDesc.IsPrimitive)
					{
						throw new InvalidOperationException(Res.GetString("XmlInvalidDataTypeUsage", dataType, "XmlElementAttribute.DataType"));
					}
					TypeDesc typeDesc2 = typeScope.GetTypeDesc(dataType, "http://www.w3.org/2001/XMLSchema");
					if (typeDesc2 == null)
					{
						throw new InvalidOperationException(Res.GetString("XmlInvalidXsdDataType", dataType, "XmlElementAttribute.DataType", new XmlQualifiedName(dataType, "http://www.w3.org/2001/XMLSchema").ToString()));
					}
					if (typeDesc.FullName != typeDesc2.FullName)
					{
						throw new InvalidOperationException(Res.GetString("XmlDataTypeMismatch", dataType, "XmlElementAttribute.DataType", typeDesc.FullName));
					}
				}
				if (a == null)
				{
					a = GetAttributes(model.Type, canBeSimpleType: false);
				}
				if (((uint)a.XmlFlags & 0xFFFFFF3Fu) != 0)
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidTypeAttributes", model.Type.FullName));
				}
				switch (model.TypeDesc.Kind)
				{
				case TypeKind.Enum:
					return ImportEnumMapping((EnumModel)model, ns, repeats);
				case TypeKind.Primitive:
					if (a.XmlFlags != 0)
					{
						throw InvalidAttributeUseException(model.Type);
					}
					return ImportPrimitiveMapping((PrimitiveModel)model, context, dataType, repeats);
				case TypeKind.Array:
				case TypeKind.Collection:
				case TypeKind.Enumerable:
				{
					if (context != ImportContext.Element)
					{
						throw UnsupportedException(model.TypeDesc, context);
					}
					arrayNestingLevel++;
					ArrayMapping result = ImportArrayLikeMapping((ArrayModel)model, ns, limiter);
					arrayNestingLevel--;
					return result;
				}
				case TypeKind.Root:
				case TypeKind.Struct:
				case TypeKind.Class:
					if (context != ImportContext.Element)
					{
						throw UnsupportedException(model.TypeDesc, context);
					}
					if (model.TypeDesc.IsOptionalValue)
					{
						TypeDesc typeDesc3 = (string.IsNullOrEmpty(dataType) ? model.TypeDesc.BaseTypeDesc : typeScope.GetTypeDesc(dataType, "http://www.w3.org/2001/XMLSchema"));
						string typeName = ((typeDesc3.DataType == null) ? typeDesc3.Name : typeDesc3.DataType.Name);
						TypeMapping typeMapping = GetTypeMapping(typeName, ns, typeDesc3, types, null);
						if (typeMapping == null)
						{
							typeMapping = ImportTypeMapping(modelScope.GetTypeModel(model.TypeDesc.BaseTypeDesc.Type), ns, context, dataType, null, repeats, openModel, limiter);
						}
						return CreateNullableMapping(typeMapping, model.TypeDesc.Type);
					}
					return ImportStructLikeMapping((StructModel)model, ns, openModel, a, limiter);
				default:
					if (model.TypeDesc.Kind == TypeKind.Serializable)
					{
						if (((uint)a.XmlFlags & 0xFFFFFFBFu) != 0)
						{
							throw new InvalidOperationException(Res.GetString("XmlSerializableAttributes", model.TypeDesc.FullName, typeof(XmlSchemaProviderAttribute).Name));
						}
					}
					else if (a.XmlFlags != 0)
					{
						throw InvalidAttributeUseException(model.Type);
					}
					if (model.TypeDesc.IsSpecial)
					{
						return ImportSpecialMapping(model.Type, model.TypeDesc, ns, context, limiter);
					}
					throw UnsupportedException(model.TypeDesc, context);
				}
			}
			catch (Exception ex)
			{
				if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
				{
					throw;
				}
				throw CreateTypeReflectionException(model.TypeDesc.FullName, ex);
			}
			catch
			{
				throw CreateTypeReflectionException(model.TypeDesc.FullName, null);
			}
		}

		internal static MethodInfo GetMethodFromSchemaProvider(XmlSchemaProviderAttribute provider, Type type)
		{
			if (provider.IsAny)
			{
				return null;
			}
			if (provider.MethodName == null)
			{
				throw new ArgumentNullException("MethodName");
			}
			if (!CodeGenerator.IsValidLanguageIndependentIdentifier(provider.MethodName))
			{
				throw new ArgumentException(Res.GetString("XmlGetSchemaMethodName", provider.MethodName), "MethodName");
			}
			MethodInfo method = (method = type.GetMethod(provider.MethodName, BindingFlags.Static | BindingFlags.Public, null, new Type[1] { typeof(XmlSchemaSet) }, null));
			if (method == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlGetSchemaMethodMissing", provider.MethodName, typeof(XmlSchemaSet).Name, type.FullName));
			}
			if (!typeof(XmlQualifiedName).IsAssignableFrom(method.ReturnType) && !typeof(XmlSchemaType).IsAssignableFrom(method.ReturnType))
			{
				throw new InvalidOperationException(Res.GetString("XmlGetSchemaMethodReturnType", type.Name, provider.MethodName, typeof(XmlSchemaProviderAttribute).Name, typeof(XmlQualifiedName).FullName, typeof(XmlSchemaType).FullName));
			}
			return method;
		}

		private SpecialMapping ImportSpecialMapping(Type type, TypeDesc typeDesc, string ns, ImportContext context, RecursionLimiter limiter)
		{
			if (specials == null)
			{
				specials = new Hashtable();
			}
			SpecialMapping specialMapping = (SpecialMapping)specials[type];
			if (specialMapping != null)
			{
				CheckContext(specialMapping.TypeDesc, context);
				return specialMapping;
			}
			if (typeDesc.Kind == TypeKind.Serializable)
			{
				SerializableMapping serializableMapping = null;
				object[] customAttributes = type.GetCustomAttributes(typeof(XmlSchemaProviderAttribute), inherit: false);
				if (customAttributes.Length > 0)
				{
					XmlSchemaProviderAttribute xmlSchemaProviderAttribute = (XmlSchemaProviderAttribute)customAttributes[0];
					MethodInfo methodFromSchemaProvider = GetMethodFromSchemaProvider(xmlSchemaProviderAttribute, type);
					serializableMapping = new SerializableMapping(methodFromSchemaProvider, xmlSchemaProviderAttribute.IsAny, ns);
					XmlQualifiedName xsiType = serializableMapping.XsiType;
					if (xsiType != null && !xsiType.IsEmpty)
					{
						if (serializables == null)
						{
							serializables = new NameTable();
						}
						SerializableMapping serializableMapping2 = (SerializableMapping)serializables[xsiType];
						if (serializableMapping2 != null)
						{
							if (serializableMapping2.Type == null)
							{
								serializableMapping = serializableMapping2;
							}
							else if (serializableMapping2.Type != type)
							{
								SerializableMapping next = serializableMapping2.Next;
								serializableMapping2.Next = serializableMapping;
								serializableMapping.Next = next;
							}
						}
						else
						{
							XmlSchemaType xsdType = serializableMapping.XsdType;
							if (xsdType != null)
							{
								SetBase(serializableMapping, xsdType.DerivedFrom);
							}
							serializables[xsiType] = serializableMapping;
						}
						serializableMapping.TypeName = xsiType.Name;
						serializableMapping.Namespace = xsiType.Namespace;
					}
					serializableMapping.TypeDesc = typeDesc;
					serializableMapping.Type = type;
					IncludeTypes(type);
				}
				else
				{
					serializableMapping = new SerializableMapping();
					serializableMapping.TypeDesc = typeDesc;
					serializableMapping.Type = type;
				}
				specialMapping = serializableMapping;
			}
			else
			{
				specialMapping = new SpecialMapping();
				specialMapping.TypeDesc = typeDesc;
			}
			CheckContext(typeDesc, context);
			specials.Add(type, specialMapping);
			typeScope.AddTypeMapping(specialMapping);
			return specialMapping;
		}

		internal static void ValidationCallbackWithErrorCode(object sender, ValidationEventArgs args)
		{
			if (args.Severity == XmlSeverityType.Error)
			{
				throw new InvalidOperationException(Res.GetString("XmlSerializableSchemaError", typeof(IXmlSerializable).Name, args.Message));
			}
		}

		internal void SetBase(SerializableMapping mapping, XmlQualifiedName baseQname)
		{
			if (!baseQname.IsEmpty && !(baseQname.Namespace == "http://www.w3.org/2001/XMLSchema"))
			{
				XmlSchemaSet schemas = mapping.Schemas;
				ArrayList arrayList = (ArrayList)schemas.Schemas(baseQname.Namespace);
				if (arrayList.Count == 0)
				{
					throw new InvalidOperationException(Res.GetString("XmlMissingSchema", baseQname.Namespace));
				}
				if (arrayList.Count > 1)
				{
					throw new InvalidOperationException(Res.GetString("XmlGetSchemaInclude", baseQname.Namespace, typeof(IXmlSerializable).Name, "GetSchema"));
				}
				XmlSchema xmlSchema = (XmlSchema)arrayList[0];
				XmlSchemaType xmlSchemaType = (XmlSchemaType)xmlSchema.SchemaTypes[baseQname];
				xmlSchemaType = ((xmlSchemaType.Redefined != null) ? xmlSchemaType.Redefined : xmlSchemaType);
				if (serializables[baseQname] == null)
				{
					SerializableMapping serializableMapping = new SerializableMapping(baseQname, schemas);
					SetBase(serializableMapping, xmlSchemaType.DerivedFrom);
					serializables.Add(baseQname, serializableMapping);
				}
				mapping.SetBaseMapping((SerializableMapping)serializables[baseQname]);
			}
		}

		private static string GetContextName(ImportContext context)
		{
			return context switch
			{
				ImportContext.Element => "element", 
				ImportContext.Attribute => "attribute", 
				ImportContext.Text => "text", 
				_ => throw new ArgumentException(Res.GetString("XmlInternalError"), "context"), 
			};
		}

		private static Exception InvalidAttributeUseException(Type type)
		{
			return new InvalidOperationException(Res.GetString("XmlInvalidAttributeUse", type.FullName));
		}

		private static Exception UnsupportedException(TypeDesc typeDesc, ImportContext context)
		{
			return new InvalidOperationException(Res.GetString("XmlIllegalTypeContext", typeDesc.FullName, GetContextName(context)));
		}

		private StructMapping CreateRootMapping()
		{
			TypeDesc typeDesc = typeScope.GetTypeDesc(typeof(object));
			StructMapping structMapping = new StructMapping();
			structMapping.TypeDesc = typeDesc;
			structMapping.TypeName = "anyType";
			structMapping.Namespace = "http://www.w3.org/2001/XMLSchema";
			structMapping.Members = new MemberMapping[0];
			structMapping.IncludeInSchema = false;
			return structMapping;
		}

		private NullableMapping CreateNullableMapping(TypeMapping baseMapping, Type type)
		{
			TypeDesc nullableTypeDesc = baseMapping.TypeDesc.GetNullableTypeDesc(type);
			TypeMapping typeMapping = (baseMapping.IsAnonymousType ? ((TypeMapping)anonymous[type]) : ((TypeMapping)nullables[baseMapping.TypeName, baseMapping.Namespace]));
			NullableMapping nullableMapping;
			if (typeMapping != null)
			{
				if (typeMapping is NullableMapping)
				{
					nullableMapping = (NullableMapping)typeMapping;
					if (nullableMapping.BaseMapping is PrimitiveMapping && baseMapping is PrimitiveMapping)
					{
						return nullableMapping;
					}
					if (nullableMapping.BaseMapping == baseMapping)
					{
						return nullableMapping;
					}
					throw new InvalidOperationException(Res.GetString("XmlTypesDuplicate", nullableTypeDesc.FullName, typeMapping.TypeDesc.FullName, nullableTypeDesc.Name, typeMapping.Namespace));
				}
				throw new InvalidOperationException(Res.GetString("XmlTypesDuplicate", nullableTypeDesc.FullName, typeMapping.TypeDesc.FullName, nullableTypeDesc.Name, typeMapping.Namespace));
			}
			nullableMapping = new NullableMapping();
			nullableMapping.BaseMapping = baseMapping;
			nullableMapping.TypeDesc = nullableTypeDesc;
			nullableMapping.TypeName = baseMapping.TypeName;
			nullableMapping.Namespace = baseMapping.Namespace;
			nullableMapping.IncludeInSchema = baseMapping.IncludeInSchema;
			if (!baseMapping.IsAnonymousType)
			{
				nullables.Add(baseMapping.TypeName, baseMapping.Namespace, nullableMapping);
			}
			else
			{
				anonymous[type] = nullableMapping;
			}
			typeScope.AddTypeMapping(nullableMapping);
			return nullableMapping;
		}

		private StructMapping GetRootMapping()
		{
			if (root == null)
			{
				root = CreateRootMapping();
				typeScope.AddTypeMapping(root);
			}
			return root;
		}

		private TypeMapping GetTypeMapping(string typeName, string ns, TypeDesc typeDesc, NameTable typeLib, Type type)
		{
			TypeMapping typeMapping = ((typeName != null && typeName.Length != 0) ? ((TypeMapping)typeLib[typeName, ns]) : ((type == null) ? null : ((TypeMapping)anonymous[type])));
			if (typeMapping == null)
			{
				return null;
			}
			if (!typeMapping.IsAnonymousType && typeMapping.TypeDesc != typeDesc)
			{
				throw new InvalidOperationException(Res.GetString("XmlTypesDuplicate", typeDesc.FullName, typeMapping.TypeDesc.FullName, typeName, ns));
			}
			return typeMapping;
		}

		private StructMapping ImportStructLikeMapping(StructModel model, string ns, bool openModel, XmlAttributes a, RecursionLimiter limiter)
		{
			if (model.TypeDesc.Kind == TypeKind.Root)
			{
				return GetRootMapping();
			}
			if (a == null)
			{
				a = GetAttributes(model.Type, canBeSimpleType: false);
			}
			string text = ns;
			if (a.XmlType != null && a.XmlType.Namespace != null)
			{
				text = a.XmlType.Namespace;
			}
			else if (a.XmlRoot != null && a.XmlRoot.Namespace != null)
			{
				text = a.XmlRoot.Namespace;
			}
			string name = (IsAnonymousType(a, ns) ? null : XsdTypeName(model.Type, a, model.TypeDesc.Name));
			name = XmlConvert.EncodeLocalName(name);
			StructMapping structMapping = (StructMapping)GetTypeMapping(name, text, model.TypeDesc, types, model.Type);
			if (structMapping == null)
			{
				structMapping = new StructMapping();
				structMapping.TypeDesc = model.TypeDesc;
				structMapping.Namespace = text;
				structMapping.TypeName = name;
				if (!structMapping.IsAnonymousType)
				{
					types.Add(name, text, structMapping);
				}
				else
				{
					anonymous[model.Type] = structMapping;
				}
				if (a.XmlType != null)
				{
					structMapping.IncludeInSchema = a.XmlType.IncludeInSchema;
				}
				if (limiter.IsExceededLimit)
				{
					limiter.DeferredWorkItems.Add(new ImportStructWorkItem(model, structMapping));
					return structMapping;
				}
				limiter.Depth++;
				InitializeStructMembers(structMapping, model, openModel, name, limiter);
				while (limiter.DeferredWorkItems.Count > 0)
				{
					int index = limiter.DeferredWorkItems.Count - 1;
					ImportStructWorkItem importStructWorkItem = limiter.DeferredWorkItems[index];
					if (InitializeStructMembers(importStructWorkItem.Mapping, importStructWorkItem.Model, openModel, name, limiter))
					{
						limiter.DeferredWorkItems.RemoveAt(index);
					}
				}
				limiter.Depth--;
			}
			return structMapping;
		}

		private bool InitializeStructMembers(StructMapping mapping, StructModel model, bool openModel, string typeName, RecursionLimiter limiter)
		{
			if (mapping.IsFullyInitialized)
			{
				return true;
			}
			if (model.TypeDesc.BaseTypeDesc != null)
			{
				TypeModel typeModel = modelScope.GetTypeModel(model.Type.BaseType, directReference: false);
				if (!(typeModel is StructModel))
				{
					throw new NotSupportedException(Res.GetString("XmlUnsupportedInheritance", model.Type.BaseType.FullName));
				}
				StructMapping structMapping = ImportStructLikeMapping((StructModel)typeModel, mapping.Namespace, openModel, null, limiter);
				int num = limiter.DeferredWorkItems.IndexOf(structMapping);
				if (num >= 0)
				{
					if (!limiter.DeferredWorkItems.Contains(mapping))
					{
						limiter.DeferredWorkItems.Add(new ImportStructWorkItem(model, mapping));
					}
					int num2 = limiter.DeferredWorkItems.Count - 1;
					if (num < num2)
					{
						ImportStructWorkItem value = limiter.DeferredWorkItems[num];
						limiter.DeferredWorkItems[num] = limiter.DeferredWorkItems[num2];
						limiter.DeferredWorkItems[num2] = value;
					}
					return false;
				}
				mapping.BaseMapping = structMapping;
				ICollection values = mapping.BaseMapping.LocalAttributes.Values;
				foreach (AttributeAccessor item in values)
				{
					AddUniqueAccessor(mapping.LocalAttributes, item);
				}
				if (!mapping.BaseMapping.HasExplicitSequence())
				{
					values = mapping.BaseMapping.LocalElements.Values;
					foreach (ElementAccessor item2 in values)
					{
						AddUniqueAccessor(mapping.LocalElements, item2);
					}
				}
			}
			ArrayList arrayList = new ArrayList();
			TextAccessor textAccessor = null;
			bool hasElements = false;
			bool flag = false;
			MemberInfo[] memberInfos = model.GetMemberInfos();
			foreach (MemberInfo memberInfo in memberInfos)
			{
				if ((memberInfo.MemberType & (MemberTypes.Field | MemberTypes.Property)) == 0)
				{
					continue;
				}
				XmlAttributes attributes = GetAttributes(memberInfo);
				if (attributes.XmlIgnore)
				{
					continue;
				}
				FieldModel fieldModel = model.GetFieldModel(memberInfo);
				if (fieldModel == null)
				{
					continue;
				}
				try
				{
					MemberMapping memberMapping = ImportFieldMapping(model, fieldModel, attributes, mapping.Namespace, limiter);
					if (memberMapping == null || (mapping.BaseMapping != null && mapping.BaseMapping.Declares(memberMapping, mapping.TypeName)))
					{
						continue;
					}
					flag |= memberMapping.IsSequence;
					AddUniqueAccessor(memberMapping, mapping.LocalElements, mapping.LocalAttributes, flag);
					if (memberMapping.Text != null)
					{
						if (!memberMapping.Text.Mapping.TypeDesc.CanBeTextValue && memberMapping.Text.Mapping.IsList)
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalTypedTextAttribute", typeName, memberMapping.Text.Name, memberMapping.Text.Mapping.TypeDesc.FullName));
						}
						if (textAccessor != null)
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalMultipleText", model.Type.FullName));
						}
						textAccessor = memberMapping.Text;
					}
					if (memberMapping.Xmlns != null)
					{
						if (mapping.XmlnsMember != null)
						{
							throw new InvalidOperationException(Res.GetString("XmlMultipleXmlns", model.Type.FullName));
						}
						mapping.XmlnsMember = memberMapping;
					}
					if (memberMapping.Elements != null && memberMapping.Elements.Length != 0)
					{
						hasElements = true;
					}
					arrayList.Add(memberMapping);
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					throw CreateMemberReflectionException(fieldModel, ex);
				}
				catch
				{
					throw CreateMemberReflectionException(fieldModel, null);
				}
			}
			mapping.SetContentModel(textAccessor, hasElements);
			if (flag)
			{
				Hashtable hashtable = new Hashtable();
				for (int j = 0; j < arrayList.Count; j++)
				{
					MemberMapping memberMapping2 = (MemberMapping)arrayList[j];
					if (memberMapping2.IsParticle)
					{
						if (!memberMapping2.IsSequence)
						{
							throw new InvalidOperationException(Res.GetString("XmlSequenceInconsistent", "Order", memberMapping2.Name));
						}
						if (hashtable[memberMapping2.SequenceId] != null)
						{
							throw new InvalidOperationException(Res.GetString("XmlSequenceUnique", memberMapping2.SequenceId.ToString(CultureInfo.InvariantCulture), "Order", memberMapping2.Name));
						}
						hashtable[memberMapping2.SequenceId] = memberMapping2;
					}
				}
				arrayList.Sort(new MemberMappingComparer());
			}
			mapping.Members = (MemberMapping[])arrayList.ToArray(typeof(MemberMapping));
			if (mapping.BaseMapping == null)
			{
				mapping.BaseMapping = GetRootMapping();
			}
			if (mapping.XmlnsMember != null && mapping.BaseMapping.HasXmlnsMember)
			{
				throw new InvalidOperationException(Res.GetString("XmlMultipleXmlns", model.Type.FullName));
			}
			IncludeTypes(model.Type, limiter);
			typeScope.AddTypeMapping(mapping);
			if (openModel)
			{
				mapping.IsOpenModel = true;
			}
			return true;
		}

		private static bool IsAnonymousType(XmlAttributes a, string contextNs)
		{
			if (a.XmlType != null && a.XmlType.AnonymousType)
			{
				string @namespace = a.XmlType.Namespace;
				if (!string.IsNullOrEmpty(@namespace))
				{
					return @namespace == contextNs;
				}
				return true;
			}
			return false;
		}

		internal string XsdTypeName(Type type)
		{
			if (type == typeof(object))
			{
				return "anyType";
			}
			TypeDesc typeDesc = typeScope.GetTypeDesc(type);
			if (typeDesc.IsPrimitive && typeDesc.DataType != null && typeDesc.DataType.Name != null && typeDesc.DataType.Name.Length > 0)
			{
				return typeDesc.DataType.Name;
			}
			return XsdTypeName(type, GetAttributes(type, canBeSimpleType: false), typeDesc.Name);
		}

		internal string XsdTypeName(Type type, XmlAttributes a, string name)
		{
			string text = name;
			if (a.XmlType != null && a.XmlType.TypeName.Length > 0)
			{
				text = a.XmlType.TypeName;
			}
			if (type.IsGenericType && text.IndexOf('{') >= 0)
			{
				Type genericTypeDefinition = type.GetGenericTypeDefinition();
				Type[] genericArguments = genericTypeDefinition.GetGenericArguments();
				Type[] genericArguments2 = type.GetGenericArguments();
				for (int i = 0; i < genericArguments.Length; i++)
				{
					string text2 = string.Concat("{", genericArguments[i], "}");
					if (text.Contains(text2))
					{
						text = text.Replace(text2, XsdTypeName(genericArguments2[i]));
						if (text.IndexOf('{') < 0)
						{
							break;
						}
					}
				}
			}
			return text;
		}

		private static int CountAtLevel(XmlArrayItemAttributes attributes, int level)
		{
			int num = 0;
			for (int i = 0; i < attributes.Count; i++)
			{
				if (attributes[i].NestingLevel == level)
				{
					num++;
				}
			}
			return num;
		}

		private void SetArrayMappingType(ArrayMapping mapping, string defaultNs, Type type)
		{
			XmlAttributes attributes = GetAttributes(type, canBeSimpleType: false);
			if (IsAnonymousType(attributes, defaultNs))
			{
				mapping.TypeName = null;
				mapping.Namespace = defaultNs;
				return;
			}
			ElementAccessor elementAccessor = null;
			TypeMapping typeMapping;
			if (mapping.Elements.Length == 1)
			{
				elementAccessor = mapping.Elements[0];
				typeMapping = elementAccessor.Mapping;
			}
			else
			{
				typeMapping = null;
			}
			bool flag = true;
			string text;
			string name;
			if (attributes.XmlType != null)
			{
				text = attributes.XmlType.Namespace;
				name = XsdTypeName(type, attributes, attributes.XmlType.TypeName);
				name = XmlConvert.EncodeLocalName(name);
				flag = name == null;
			}
			else if (typeMapping is EnumMapping)
			{
				text = typeMapping.Namespace;
				name = typeMapping.DefaultElementName;
			}
			else if (typeMapping is PrimitiveMapping)
			{
				text = defaultNs;
				name = typeMapping.TypeDesc.DataType.Name;
			}
			else if (typeMapping is StructMapping && typeMapping.TypeDesc.IsRoot)
			{
				text = defaultNs;
				name = "anyType";
			}
			else if (typeMapping != null)
			{
				text = ((typeMapping.Namespace == "http://www.w3.org/2001/XMLSchema") ? defaultNs : typeMapping.Namespace);
				name = typeMapping.DefaultElementName;
			}
			else
			{
				text = defaultNs;
				name = "Choice" + choiceNum++;
			}
			if (name == null)
			{
				name = "Any";
			}
			if (elementAccessor != null)
			{
				text = elementAccessor.Namespace;
			}
			if (text == null)
			{
				text = defaultNs;
			}
			string text2 = (name = (flag ? ("ArrayOf" + CodeIdentifier.MakePascal(name)) : name));
			int num = 1;
			TypeMapping typeMapping2 = (TypeMapping)types[text2, text];
			while (typeMapping2 != null)
			{
				if (typeMapping2 is ArrayMapping)
				{
					ArrayMapping arrayMapping = (ArrayMapping)typeMapping2;
					if (AccessorMapping.ElementsMatch(arrayMapping.Elements, mapping.Elements))
					{
						break;
					}
				}
				text2 = name + num.ToString(CultureInfo.InvariantCulture);
				typeMapping2 = (TypeMapping)types[text2, text];
				num++;
			}
			mapping.TypeName = text2;
			mapping.Namespace = text;
		}

		private ArrayMapping ImportArrayLikeMapping(ArrayModel model, string ns, RecursionLimiter limiter)
		{
			ArrayMapping arrayMapping = new ArrayMapping();
			arrayMapping.TypeDesc = model.TypeDesc;
			if (savedArrayItemAttributes == null)
			{
				savedArrayItemAttributes = new XmlArrayItemAttributes();
			}
			if (CountAtLevel(savedArrayItemAttributes, arrayNestingLevel) == 0)
			{
				savedArrayItemAttributes.Add(CreateArrayItemAttribute(typeScope.GetTypeDesc(model.Element.Type), arrayNestingLevel));
			}
			CreateArrayElementsFromAttributes(arrayMapping, savedArrayItemAttributes, model.Element.Type, (savedArrayNamespace == null) ? ns : savedArrayNamespace, limiter);
			SetArrayMappingType(arrayMapping, ns, model.Type);
			for (int i = 0; i < arrayMapping.Elements.Length; i++)
			{
				arrayMapping.Elements[i] = ReconcileLocalAccessor(arrayMapping.Elements[i], arrayMapping.Namespace);
			}
			IncludeTypes(model.Type);
			ArrayMapping arrayMapping2 = (ArrayMapping)types[arrayMapping.TypeName, arrayMapping.Namespace];
			if (arrayMapping2 != null)
			{
				ArrayMapping next = arrayMapping2;
				while (arrayMapping2 != null)
				{
					if (arrayMapping2.TypeDesc == model.TypeDesc)
					{
						return arrayMapping2;
					}
					arrayMapping2 = arrayMapping2.Next;
				}
				arrayMapping.Next = next;
				if (!arrayMapping.IsAnonymousType)
				{
					types[arrayMapping.TypeName, arrayMapping.Namespace] = arrayMapping;
				}
				else
				{
					anonymous[model.Type] = arrayMapping;
				}
				return arrayMapping;
			}
			typeScope.AddTypeMapping(arrayMapping);
			if (!arrayMapping.IsAnonymousType)
			{
				types.Add(arrayMapping.TypeName, arrayMapping.Namespace, arrayMapping);
			}
			else
			{
				anonymous[model.Type] = arrayMapping;
			}
			return arrayMapping;
		}

		private void CheckContext(TypeDesc typeDesc, ImportContext context)
		{
			switch (context)
			{
			case ImportContext.Element:
				if (typeDesc.CanBeElementValue)
				{
					return;
				}
				break;
			case ImportContext.Attribute:
				if (typeDesc.CanBeAttributeValue)
				{
					return;
				}
				break;
			case ImportContext.Text:
				if (typeDesc.CanBeTextValue || typeDesc.IsEnum || typeDesc.IsPrimitive)
				{
					return;
				}
				break;
			default:
				throw new ArgumentException(Res.GetString("XmlInternalError"), "context");
			}
			throw UnsupportedException(typeDesc, context);
		}

		private PrimitiveMapping ImportPrimitiveMapping(PrimitiveModel model, ImportContext context, string dataType, bool repeats)
		{
			PrimitiveMapping primitiveMapping = new PrimitiveMapping();
			if (dataType.Length > 0)
			{
				primitiveMapping.TypeDesc = typeScope.GetTypeDesc(dataType, "http://www.w3.org/2001/XMLSchema");
				if (primitiveMapping.TypeDesc == null)
				{
					primitiveMapping.TypeDesc = typeScope.GetTypeDesc(dataType, "http://microsoft.com/wsdl/types/");
					if (primitiveMapping.TypeDesc == null)
					{
						throw new InvalidOperationException(Res.GetString("XmlUdeclaredXsdType", dataType));
					}
				}
			}
			else
			{
				primitiveMapping.TypeDesc = model.TypeDesc;
			}
			primitiveMapping.TypeName = primitiveMapping.TypeDesc.DataType.Name;
			primitiveMapping.Namespace = (primitiveMapping.TypeDesc.IsXsdType ? "http://www.w3.org/2001/XMLSchema" : "http://microsoft.com/wsdl/types/");
			primitiveMapping.IsList = repeats;
			CheckContext(primitiveMapping.TypeDesc, context);
			return primitiveMapping;
		}

		private EnumMapping ImportEnumMapping(EnumModel model, string ns, bool repeats)
		{
			XmlAttributes attributes = GetAttributes(model.Type, canBeSimpleType: false);
			string text = ns;
			if (attributes.XmlType != null && attributes.XmlType.Namespace != null)
			{
				text = attributes.XmlType.Namespace;
			}
			string name = (IsAnonymousType(attributes, ns) ? null : XsdTypeName(model.Type, attributes, model.TypeDesc.Name));
			name = XmlConvert.EncodeLocalName(name);
			EnumMapping enumMapping = (EnumMapping)GetTypeMapping(name, text, model.TypeDesc, types, model.Type);
			if (enumMapping == null)
			{
				enumMapping = new EnumMapping();
				enumMapping.TypeDesc = model.TypeDesc;
				enumMapping.TypeName = name;
				enumMapping.Namespace = text;
				enumMapping.IsFlags = model.Type.IsDefined(typeof(FlagsAttribute), inherit: false);
				if (enumMapping.IsFlags && repeats)
				{
					throw new InvalidOperationException(Res.GetString("XmlIllegalAttributeFlagsArray", model.TypeDesc.FullName));
				}
				enumMapping.IsList = repeats;
				enumMapping.IncludeInSchema = attributes.XmlType == null || attributes.XmlType.IncludeInSchema;
				if (!enumMapping.IsAnonymousType)
				{
					types.Add(name, text, enumMapping);
				}
				else
				{
					anonymous[model.Type] = enumMapping;
				}
				ArrayList arrayList = new ArrayList();
				for (int i = 0; i < model.Constants.Length; i++)
				{
					ConstantMapping constantMapping = ImportConstantMapping(model.Constants[i]);
					if (constantMapping != null)
					{
						arrayList.Add(constantMapping);
					}
				}
				if (arrayList.Count == 0)
				{
					throw new InvalidOperationException(Res.GetString("XmlNoSerializableMembers", model.TypeDesc.FullName));
				}
				enumMapping.Constants = (ConstantMapping[])arrayList.ToArray(typeof(ConstantMapping));
				typeScope.AddTypeMapping(enumMapping);
			}
			return enumMapping;
		}

		private ConstantMapping ImportConstantMapping(ConstantModel model)
		{
			XmlAttributes attributes = GetAttributes(model.FieldInfo);
			if (attributes.XmlIgnore)
			{
				return null;
			}
			if (((uint)attributes.XmlFlags & 0xFFFFFFFEu) != 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidConstantAttribute"));
			}
			if (attributes.XmlEnum == null)
			{
				attributes.XmlEnum = new XmlEnumAttribute();
			}
			ConstantMapping constantMapping = new ConstantMapping();
			constantMapping.XmlName = ((attributes.XmlEnum.Name == null) ? model.Name : attributes.XmlEnum.Name);
			constantMapping.Name = model.Name;
			constantMapping.Value = model.Value;
			return constantMapping;
		}

		private MembersMapping ImportMembersMapping(XmlReflectionMember[] xmlReflectionMembers, string ns, bool hasWrapperElement, bool rpc, bool openModel, RecursionLimiter limiter)
		{
			MembersMapping membersMapping = new MembersMapping();
			membersMapping.TypeDesc = typeScope.GetTypeDesc(typeof(object[]));
			MemberMapping[] array = new MemberMapping[xmlReflectionMembers.Length];
			NameTable nameTable = new NameTable();
			NameTable attributes = new NameTable();
			TextAccessor textAccessor = null;
			bool flag = false;
			for (int i = 0; i < array.Length; i++)
			{
				try
				{
					MemberMapping memberMapping = ImportMemberMapping(xmlReflectionMembers[i], ns, xmlReflectionMembers, rpc, openModel, limiter);
					if (!hasWrapperElement && memberMapping.Attribute != null)
					{
						if (rpc)
						{
							throw new InvalidOperationException(Res.GetString("XmlRpcLitAttributeAttributes"));
						}
						throw new InvalidOperationException(Res.GetString("XmlInvalidAttributeType", "XmlAttribute"));
					}
					if (rpc && xmlReflectionMembers[i].IsReturnValue)
					{
						if (i > 0)
						{
							throw new InvalidOperationException(Res.GetString("XmlInvalidReturnPosition"));
						}
						memberMapping.IsReturnValue = true;
					}
					array[i] = memberMapping;
					flag |= memberMapping.IsSequence;
					if (!xmlReflectionMembers[i].XmlAttributes.XmlIgnore)
					{
						AddUniqueAccessor(memberMapping, nameTable, attributes, flag);
					}
					array[i] = memberMapping;
					if (memberMapping.Text != null)
					{
						if (textAccessor != null)
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalMultipleTextMembers"));
						}
						textAccessor = memberMapping.Text;
					}
					if (memberMapping.Xmlns != null)
					{
						if (membersMapping.XmlnsMember != null)
						{
							throw new InvalidOperationException(Res.GetString("XmlMultipleXmlnsMembers"));
						}
						membersMapping.XmlnsMember = memberMapping;
					}
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					throw CreateReflectionException(xmlReflectionMembers[i].MemberName, ex);
				}
				catch
				{
					throw CreateReflectionException(xmlReflectionMembers[i].MemberName, null);
				}
			}
			if (flag)
			{
				throw new InvalidOperationException(Res.GetString("XmlSequenceMembers", "Order"));
			}
			membersMapping.Members = array;
			membersMapping.HasWrapperElement = hasWrapperElement;
			return membersMapping;
		}

		private MemberMapping ImportMemberMapping(XmlReflectionMember xmlReflectionMember, string ns, XmlReflectionMember[] xmlReflectionMembers, bool rpc, bool openModel, RecursionLimiter limiter)
		{
			XmlSchemaForm form = ((!rpc) ? XmlSchemaForm.Qualified : XmlSchemaForm.Unqualified);
			XmlAttributes xmlAttributes = xmlReflectionMember.XmlAttributes;
			TypeDesc typeDesc = typeScope.GetTypeDesc(xmlReflectionMember.MemberType);
			if (xmlAttributes.XmlFlags == (XmlAttributeFlags)0)
			{
				if (typeDesc.IsArrayLike)
				{
					XmlArrayAttribute xmlArrayAttribute = CreateArrayAttribute(typeDesc);
					xmlArrayAttribute.ElementName = xmlReflectionMember.MemberName;
					xmlArrayAttribute.Namespace = (rpc ? null : ns);
					xmlArrayAttribute.Form = form;
					xmlAttributes.XmlArray = xmlArrayAttribute;
				}
				else
				{
					XmlElementAttribute xmlElementAttribute = CreateElementAttribute(typeDesc);
					if (typeDesc.IsStructLike)
					{
						XmlAttributes xmlAttributes2 = new XmlAttributes(xmlReflectionMember.MemberType);
						if (xmlAttributes2.XmlRoot != null)
						{
							if (xmlAttributes2.XmlRoot.ElementName.Length > 0)
							{
								xmlElementAttribute.ElementName = xmlAttributes2.XmlRoot.ElementName;
							}
							if (rpc)
							{
								xmlElementAttribute.Namespace = null;
								if (xmlAttributes2.XmlRoot.IsNullableSpecified)
								{
									xmlElementAttribute.IsNullable = xmlAttributes2.XmlRoot.IsNullable;
								}
							}
							else
							{
								xmlElementAttribute.Namespace = xmlAttributes2.XmlRoot.Namespace;
								xmlElementAttribute.IsNullable = xmlAttributes2.XmlRoot.IsNullable;
							}
						}
					}
					if (xmlElementAttribute.ElementName.Length == 0)
					{
						xmlElementAttribute.ElementName = xmlReflectionMember.MemberName;
					}
					if (xmlElementAttribute.Namespace == null && !rpc)
					{
						xmlElementAttribute.Namespace = ns;
					}
					xmlElementAttribute.Form = form;
					xmlAttributes.XmlElements.Add(xmlElementAttribute);
				}
			}
			else if (xmlAttributes.XmlRoot != null)
			{
				CheckNullable(xmlAttributes.XmlRoot.IsNullable, typeDesc, null);
			}
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.Name = xmlReflectionMember.MemberName;
			bool checkSpecified = FindSpecifiedMember(xmlReflectionMember.MemberName, xmlReflectionMembers) != null;
			FieldModel fieldModel = new FieldModel(xmlReflectionMember.MemberName, xmlReflectionMember.MemberType, typeScope.GetTypeDesc(xmlReflectionMember.MemberType), checkSpecified, checkShouldPersist: false);
			memberMapping.CheckShouldPersist = fieldModel.CheckShouldPersist;
			memberMapping.CheckSpecified = fieldModel.CheckSpecified;
			memberMapping.ReadOnly = fieldModel.ReadOnly;
			Type choiceIdentifierType = null;
			if (xmlAttributes.XmlChoiceIdentifier != null)
			{
				choiceIdentifierType = GetChoiceIdentifierType(xmlAttributes.XmlChoiceIdentifier, xmlReflectionMembers, typeDesc.IsArrayLike, fieldModel.Name);
			}
			ImportAccessorMapping(memberMapping, fieldModel, xmlAttributes, ns, choiceIdentifierType, rpc, openModel, limiter);
			if (xmlReflectionMember.OverrideIsNullable && memberMapping.Elements.Length > 0)
			{
				memberMapping.Elements[0].IsNullable = false;
			}
			return memberMapping;
		}

		internal static XmlReflectionMember FindSpecifiedMember(string memberName, XmlReflectionMember[] reflectionMembers)
		{
			for (int i = 0; i < reflectionMembers.Length; i++)
			{
				if (string.Compare(reflectionMembers[i].MemberName, memberName + "Specified", StringComparison.Ordinal) == 0)
				{
					return reflectionMembers[i];
				}
			}
			return null;
		}

		private MemberMapping ImportFieldMapping(StructModel parent, FieldModel model, XmlAttributes a, string ns, RecursionLimiter limiter)
		{
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.Name = model.Name;
			memberMapping.CheckShouldPersist = model.CheckShouldPersist;
			memberMapping.CheckSpecified = model.CheckSpecified;
			memberMapping.ReadOnly = model.ReadOnly;
			Type choiceIdentifierType = null;
			if (a.XmlChoiceIdentifier != null)
			{
				choiceIdentifierType = GetChoiceIdentifierType(a.XmlChoiceIdentifier, parent, model.FieldTypeDesc.IsArrayLike, model.Name);
			}
			ImportAccessorMapping(memberMapping, model, a, ns, choiceIdentifierType, rpc: false, openModel: false, limiter);
			return memberMapping;
		}

		private Type CheckChoiceIdentifierType(Type type, bool isArrayLike, string identifierName, string memberName)
		{
			if (type.IsArray)
			{
				if (!isArrayLike)
				{
					throw new InvalidOperationException(Res.GetString("XmlChoiceIdentifierType", identifierName, memberName, type.GetElementType().FullName));
				}
				type = type.GetElementType();
			}
			else if (isArrayLike)
			{
				throw new InvalidOperationException(Res.GetString("XmlChoiceIdentifierArrayType", identifierName, memberName, type.FullName));
			}
			if (!type.IsEnum)
			{
				throw new InvalidOperationException(Res.GetString("XmlChoiceIdentifierTypeEnum", identifierName));
			}
			return type;
		}

		private Type GetChoiceIdentifierType(XmlChoiceIdentifierAttribute choice, XmlReflectionMember[] xmlReflectionMembers, bool isArrayLike, string accessorName)
		{
			for (int i = 0; i < xmlReflectionMembers.Length; i++)
			{
				if (choice.MemberName == xmlReflectionMembers[i].MemberName)
				{
					return CheckChoiceIdentifierType(xmlReflectionMembers[i].MemberType, isArrayLike, choice.MemberName, accessorName);
				}
			}
			throw new InvalidOperationException(Res.GetString("XmlChoiceIdentiferMemberMissing", choice.MemberName, accessorName));
		}

		private Type GetChoiceIdentifierType(XmlChoiceIdentifierAttribute choice, StructModel structModel, bool isArrayLike, string accessorName)
		{
			MemberInfo[] array = structModel.Type.GetMember(choice.MemberName, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
			if (array == null || array.Length == 0)
			{
				PropertyInfo property = structModel.Type.GetProperty(choice.MemberName, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
				if (property == null)
				{
					throw new InvalidOperationException(Res.GetString("XmlChoiceIdentiferMemberMissing", choice.MemberName, accessorName));
				}
				array = new MemberInfo[1] { property };
			}
			else if (array.Length > 1)
			{
				throw new InvalidOperationException(Res.GetString("XmlChoiceIdentiferAmbiguous", choice.MemberName));
			}
			FieldModel fieldModel = structModel.GetFieldModel(array[0]);
			if (fieldModel == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlChoiceIdentiferMemberMissing", choice.MemberName, accessorName));
			}
			Type fieldType = fieldModel.FieldType;
			return CheckChoiceIdentifierType(fieldType, isArrayLike, choice.MemberName, accessorName);
		}

		private void CreateArrayElementsFromAttributes(ArrayMapping arrayMapping, XmlArrayItemAttributes attributes, Type arrayElementType, string arrayElementNs, RecursionLimiter limiter)
		{
			NameTable nameTable = new NameTable();
			int num = 0;
			while (attributes != null && num < attributes.Count)
			{
				XmlArrayItemAttribute xmlArrayItemAttribute = attributes[num];
				if (xmlArrayItemAttribute.NestingLevel == arrayNestingLevel)
				{
					Type type = ((xmlArrayItemAttribute.Type != null) ? xmlArrayItemAttribute.Type : arrayElementType);
					TypeDesc typeDesc = typeScope.GetTypeDesc(type);
					ElementAccessor elementAccessor = new ElementAccessor();
					elementAccessor.Namespace = ((xmlArrayItemAttribute.Namespace == null) ? arrayElementNs : xmlArrayItemAttribute.Namespace);
					elementAccessor.Mapping = ImportTypeMapping(modelScope.GetTypeModel(type), elementAccessor.Namespace, ImportContext.Element, xmlArrayItemAttribute.DataType, null, limiter);
					elementAccessor.Name = ((xmlArrayItemAttribute.ElementName.Length == 0) ? elementAccessor.Mapping.DefaultElementName : XmlConvert.EncodeLocalName(xmlArrayItemAttribute.ElementName));
					elementAccessor.IsNullable = (xmlArrayItemAttribute.IsNullableSpecified ? xmlArrayItemAttribute.IsNullable : (typeDesc.IsNullable || typeDesc.IsOptionalValue));
					elementAccessor.Form = ((xmlArrayItemAttribute.Form == XmlSchemaForm.None) ? XmlSchemaForm.Qualified : xmlArrayItemAttribute.Form);
					CheckForm(elementAccessor.Form, arrayElementNs != elementAccessor.Namespace);
					CheckNullable(elementAccessor.IsNullable, typeDesc, elementAccessor.Mapping);
					AddUniqueAccessor(nameTable, elementAccessor);
				}
				num++;
			}
			arrayMapping.Elements = (ElementAccessor[])nameTable.ToArray(typeof(ElementAccessor));
		}

		private void ImportAccessorMapping(MemberMapping accessor, FieldModel model, XmlAttributes a, string ns, Type choiceIdentifierType, bool rpc, bool openModel, RecursionLimiter limiter)
		{
			XmlSchemaForm xmlSchemaForm = XmlSchemaForm.Qualified;
			int num = arrayNestingLevel;
			int num2 = -1;
			XmlArrayItemAttributes xmlArrayItemAttributes = savedArrayItemAttributes;
			string text = savedArrayNamespace;
			arrayNestingLevel = 0;
			savedArrayItemAttributes = null;
			savedArrayNamespace = null;
			Type fieldType = model.FieldType;
			string name = model.Name;
			ArrayList arrayList = new ArrayList();
			NameTable nameTable = new NameTable();
			accessor.TypeDesc = typeScope.GetTypeDesc(fieldType);
			XmlAttributeFlags xmlFlags = a.XmlFlags;
			accessor.Ignore = a.XmlIgnore;
			if (rpc)
			{
				CheckTopLevelAttributes(a, name);
			}
			else
			{
				CheckAmbiguousChoice(a, fieldType, name);
			}
			XmlAttributeFlags xmlAttributeFlags = (XmlAttributeFlags)1300;
			XmlAttributeFlags xmlAttributeFlags2 = (XmlAttributeFlags)544;
			XmlAttributeFlags xmlAttributeFlags3 = (XmlAttributeFlags)10;
			if ((xmlFlags & xmlAttributeFlags3) != 0 && fieldType == typeof(byte[]))
			{
				accessor.TypeDesc = typeScope.GetArrayTypeDesc(fieldType);
			}
			if (a.XmlChoiceIdentifier != null)
			{
				accessor.ChoiceIdentifier = new ChoiceIdentifierAccessor();
				accessor.ChoiceIdentifier.MemberName = a.XmlChoiceIdentifier.MemberName;
				accessor.ChoiceIdentifier.Mapping = ImportTypeMapping(modelScope.GetTypeModel(choiceIdentifierType), ns, ImportContext.Element, string.Empty, null, limiter);
				CheckChoiceIdentifierMapping((EnumMapping)accessor.ChoiceIdentifier.Mapping);
			}
			if (accessor.TypeDesc.IsArrayLike)
			{
				Type arrayElementType = TypeScope.GetArrayElementType(fieldType, model.FieldTypeDesc.FullName + "." + model.Name);
				if ((xmlFlags & xmlAttributeFlags2) != 0)
				{
					if ((xmlFlags & xmlAttributeFlags2) != xmlFlags)
					{
						throw new InvalidOperationException(Res.GetString("XmlIllegalAttributesArrayAttribute"));
					}
					if (a.XmlAttribute != null && !accessor.TypeDesc.ArrayElementTypeDesc.IsPrimitive && !accessor.TypeDesc.ArrayElementTypeDesc.IsEnum)
					{
						if (accessor.TypeDesc.ArrayElementTypeDesc.Kind == TypeKind.Serializable)
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalAttrOrTextInterface", name, accessor.TypeDesc.ArrayElementTypeDesc.FullName, typeof(IXmlSerializable).Name));
						}
						throw new InvalidOperationException(Res.GetString("XmlIllegalAttrOrText", name, accessor.TypeDesc.ArrayElementTypeDesc.FullName));
					}
					bool flag = a.XmlAttribute != null && (accessor.TypeDesc.ArrayElementTypeDesc.IsPrimitive || accessor.TypeDesc.ArrayElementTypeDesc.IsEnum);
					if (a.XmlAnyAttribute != null)
					{
						a.XmlAttribute = new XmlAttributeAttribute();
					}
					AttributeAccessor attributeAccessor = new AttributeAccessor();
					Type type = ((a.XmlAttribute.Type == null) ? arrayElementType : a.XmlAttribute.Type);
					typeScope.GetTypeDesc(type);
					attributeAccessor.Name = Accessor.EscapeQName((a.XmlAttribute.AttributeName.Length == 0) ? name : a.XmlAttribute.AttributeName);
					attributeAccessor.Namespace = ((a.XmlAttribute.Namespace == null) ? ns : a.XmlAttribute.Namespace);
					attributeAccessor.Form = a.XmlAttribute.Form;
					if (attributeAccessor.Form == XmlSchemaForm.None && ns != attributeAccessor.Namespace)
					{
						attributeAccessor.Form = XmlSchemaForm.Qualified;
					}
					attributeAccessor.CheckSpecial();
					CheckForm(attributeAccessor.Form, ns != attributeAccessor.Namespace);
					attributeAccessor.Mapping = ImportTypeMapping(modelScope.GetTypeModel(type), ns, ImportContext.Attribute, a.XmlAttribute.DataType, null, flag, openModel: false, limiter);
					attributeAccessor.IsList = flag;
					attributeAccessor.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
					attributeAccessor.Any = a.XmlAnyAttribute != null;
					if (attributeAccessor.Form == XmlSchemaForm.Qualified && attributeAccessor.Namespace != ns)
					{
						if (xsdAttributes == null)
						{
							xsdAttributes = new NameTable();
						}
						attributeAccessor = (AttributeAccessor)ReconcileAccessor(attributeAccessor, xsdAttributes);
					}
					accessor.Attribute = attributeAccessor;
				}
				else if ((xmlFlags & xmlAttributeFlags) != 0)
				{
					if ((xmlFlags & xmlAttributeFlags) != xmlFlags)
					{
						throw new InvalidOperationException(Res.GetString("XmlIllegalElementsArrayAttribute"));
					}
					if (a.XmlText != null)
					{
						TextAccessor textAccessor = new TextAccessor();
						Type type2 = ((a.XmlText.Type == null) ? arrayElementType : a.XmlText.Type);
						TypeDesc typeDesc = typeScope.GetTypeDesc(type2);
						textAccessor.Name = name;
						textAccessor.Mapping = ImportTypeMapping(modelScope.GetTypeModel(type2), ns, ImportContext.Text, a.XmlText.DataType, null, repeats: true, openModel: false, limiter);
						if (!(textAccessor.Mapping is SpecialMapping) && typeDesc != typeScope.GetTypeDesc(typeof(string)))
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalArrayTextAttribute", name));
						}
						accessor.Text = textAccessor;
					}
					if (a.XmlText == null && a.XmlElements.Count == 0 && a.XmlAnyElements.Count == 0)
					{
						a.XmlElements.Add(CreateElementAttribute(accessor.TypeDesc));
					}
					for (int i = 0; i < a.XmlElements.Count; i++)
					{
						XmlElementAttribute xmlElementAttribute = a.XmlElements[i];
						Type type3 = ((xmlElementAttribute.Type == null) ? arrayElementType : xmlElementAttribute.Type);
						TypeDesc typeDesc2 = typeScope.GetTypeDesc(type3);
						TypeModel typeModel = modelScope.GetTypeModel(type3);
						ElementAccessor elementAccessor = new ElementAccessor();
						elementAccessor.Namespace = (rpc ? null : ((xmlElementAttribute.Namespace == null) ? ns : xmlElementAttribute.Namespace));
						elementAccessor.Mapping = ImportTypeMapping(typeModel, rpc ? ns : elementAccessor.Namespace, ImportContext.Element, xmlElementAttribute.DataType, null, limiter);
						if (a.XmlElements.Count == 1)
						{
							elementAccessor.Name = XmlConvert.EncodeLocalName((xmlElementAttribute.ElementName.Length == 0) ? name : xmlElementAttribute.ElementName);
						}
						else
						{
							elementAccessor.Name = ((xmlElementAttribute.ElementName.Length == 0) ? elementAccessor.Mapping.DefaultElementName : XmlConvert.EncodeLocalName(xmlElementAttribute.ElementName));
						}
						elementAccessor.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
						if (xmlElementAttribute.IsNullableSpecified && !xmlElementAttribute.IsNullable && typeModel.TypeDesc.IsOptionalValue)
						{
							throw new InvalidOperationException(Res.GetString("XmlInvalidNotNullable", typeModel.TypeDesc.BaseTypeDesc.FullName, "XmlElement"));
						}
						elementAccessor.IsNullable = (xmlElementAttribute.IsNullableSpecified ? xmlElementAttribute.IsNullable : typeModel.TypeDesc.IsOptionalValue);
						elementAccessor.Form = (rpc ? XmlSchemaForm.Unqualified : ((xmlElementAttribute.Form == XmlSchemaForm.None) ? xmlSchemaForm : xmlElementAttribute.Form));
						CheckNullable(elementAccessor.IsNullable, typeDesc2, elementAccessor.Mapping);
						if (!rpc)
						{
							CheckForm(elementAccessor.Form, ns != elementAccessor.Namespace);
							elementAccessor = ReconcileLocalAccessor(elementAccessor, ns);
						}
						if (xmlElementAttribute.Order != -1)
						{
							if (xmlElementAttribute.Order != num2 && num2 != -1)
							{
								throw new InvalidOperationException(Res.GetString("XmlSequenceMatch", "Order"));
							}
							num2 = xmlElementAttribute.Order;
						}
						AddUniqueAccessor(nameTable, elementAccessor);
						arrayList.Add(elementAccessor);
					}
					NameTable nameTable2 = new NameTable();
					for (int j = 0; j < a.XmlAnyElements.Count; j++)
					{
						XmlAnyElementAttribute xmlAnyElementAttribute = a.XmlAnyElements[j];
						Type type4 = (typeof(IXmlSerializable).IsAssignableFrom(arrayElementType) ? arrayElementType : (typeof(XmlNode).IsAssignableFrom(arrayElementType) ? arrayElementType : typeof(XmlElement)));
						if (!arrayElementType.IsAssignableFrom(type4))
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalAnyElement", arrayElementType.FullName));
						}
						string name2 = ((xmlAnyElementAttribute.Name.Length == 0) ? xmlAnyElementAttribute.Name : XmlConvert.EncodeLocalName(xmlAnyElementAttribute.Name));
						string text2 = (xmlAnyElementAttribute.NamespaceSpecified ? xmlAnyElementAttribute.Namespace : null);
						if (nameTable2[name2, text2] != null)
						{
							continue;
						}
						nameTable2[name2, text2] = xmlAnyElementAttribute;
						if (nameTable[name2, (text2 == null) ? ns : text2] != null)
						{
							throw new InvalidOperationException(Res.GetString("XmlAnyElementDuplicate", name, xmlAnyElementAttribute.Name, (xmlAnyElementAttribute.Namespace == null) ? "null" : xmlAnyElementAttribute.Namespace));
						}
						ElementAccessor elementAccessor2 = new ElementAccessor();
						elementAccessor2.Name = name2;
						elementAccessor2.Namespace = ((text2 == null) ? ns : text2);
						elementAccessor2.Any = true;
						elementAccessor2.AnyNamespaces = text2;
						TypeDesc typeDesc3 = typeScope.GetTypeDesc(type4);
						TypeModel typeModel2 = modelScope.GetTypeModel(type4);
						if (elementAccessor2.Name.Length > 0)
						{
							typeModel2.TypeDesc.IsMixed = true;
						}
						elementAccessor2.Mapping = ImportTypeMapping(typeModel2, elementAccessor2.Namespace, ImportContext.Element, string.Empty, null, limiter);
						elementAccessor2.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
						elementAccessor2.IsNullable = false;
						elementAccessor2.Form = xmlSchemaForm;
						CheckNullable(elementAccessor2.IsNullable, typeDesc3, elementAccessor2.Mapping);
						if (!rpc)
						{
							CheckForm(elementAccessor2.Form, ns != elementAccessor2.Namespace);
							elementAccessor2 = ReconcileLocalAccessor(elementAccessor2, ns);
						}
						nameTable.Add(elementAccessor2.Name, elementAccessor2.Namespace, elementAccessor2);
						arrayList.Add(elementAccessor2);
						if (xmlAnyElementAttribute.Order != -1)
						{
							if (xmlAnyElementAttribute.Order != num2 && num2 != -1)
							{
								throw new InvalidOperationException(Res.GetString("XmlSequenceMatch", "Order"));
							}
							num2 = xmlAnyElementAttribute.Order;
						}
					}
				}
				else
				{
					if ((xmlFlags & xmlAttributeFlags3) != 0 && (xmlFlags & xmlAttributeFlags3) != xmlFlags)
					{
						throw new InvalidOperationException(Res.GetString("XmlIllegalArrayArrayAttribute"));
					}
					TypeDesc typeDesc4 = typeScope.GetTypeDesc(arrayElementType);
					if (a.XmlArray == null)
					{
						a.XmlArray = CreateArrayAttribute(accessor.TypeDesc);
					}
					if (CountAtLevel(a.XmlArrayItems, arrayNestingLevel) == 0)
					{
						a.XmlArrayItems.Add(CreateArrayItemAttribute(typeDesc4, arrayNestingLevel));
					}
					ElementAccessor elementAccessor3 = new ElementAccessor();
					elementAccessor3.Name = XmlConvert.EncodeLocalName((a.XmlArray.ElementName.Length == 0) ? name : a.XmlArray.ElementName);
					elementAccessor3.Namespace = (rpc ? null : ((a.XmlArray.Namespace == null) ? ns : a.XmlArray.Namespace));
					savedArrayItemAttributes = a.XmlArrayItems;
					savedArrayNamespace = elementAccessor3.Namespace;
					ArrayMapping arrayMapping = (ArrayMapping)(elementAccessor3.Mapping = ImportArrayLikeMapping(modelScope.GetArrayModel(fieldType), ns, limiter));
					elementAccessor3.IsNullable = a.XmlArray.IsNullable;
					elementAccessor3.Form = (rpc ? XmlSchemaForm.Unqualified : ((a.XmlArray.Form == XmlSchemaForm.None) ? xmlSchemaForm : a.XmlArray.Form));
					num2 = a.XmlArray.Order;
					CheckNullable(elementAccessor3.IsNullable, accessor.TypeDesc, elementAccessor3.Mapping);
					if (!rpc)
					{
						CheckForm(elementAccessor3.Form, ns != elementAccessor3.Namespace);
						elementAccessor3 = ReconcileLocalAccessor(elementAccessor3, ns);
					}
					savedArrayItemAttributes = null;
					savedArrayNamespace = null;
					AddUniqueAccessor(nameTable, elementAccessor3);
					arrayList.Add(elementAccessor3);
				}
			}
			else if (!accessor.TypeDesc.IsVoid)
			{
				XmlAttributeFlags xmlAttributeFlags4 = (XmlAttributeFlags)3380;
				if ((xmlFlags & xmlAttributeFlags4) != xmlFlags)
				{
					throw new InvalidOperationException(Res.GetString("XmlIllegalAttribute"));
				}
				if (accessor.TypeDesc.IsPrimitive || accessor.TypeDesc.IsEnum)
				{
					if (a.XmlAnyElements.Count > 0)
					{
						throw new InvalidOperationException(Res.GetString("XmlIllegalAnyElement", accessor.TypeDesc.FullName));
					}
					if (a.XmlAttribute != null)
					{
						if (a.XmlElements.Count > 0)
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalAttribute"));
						}
						if (a.XmlAttribute.Type != null)
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalType", "XmlAttribute"));
						}
						AttributeAccessor attributeAccessor2 = new AttributeAccessor();
						attributeAccessor2.Name = Accessor.EscapeQName((a.XmlAttribute.AttributeName.Length == 0) ? name : a.XmlAttribute.AttributeName);
						attributeAccessor2.Namespace = ((a.XmlAttribute.Namespace == null) ? ns : a.XmlAttribute.Namespace);
						attributeAccessor2.Form = a.XmlAttribute.Form;
						if (attributeAccessor2.Form == XmlSchemaForm.None && ns != attributeAccessor2.Namespace)
						{
							attributeAccessor2.Form = XmlSchemaForm.Qualified;
						}
						attributeAccessor2.CheckSpecial();
						CheckForm(attributeAccessor2.Form, ns != attributeAccessor2.Namespace);
						attributeAccessor2.Mapping = ImportTypeMapping(modelScope.GetTypeModel(fieldType), ns, ImportContext.Attribute, a.XmlAttribute.DataType, null, limiter);
						attributeAccessor2.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
						attributeAccessor2.Any = a.XmlAnyAttribute != null;
						if (attributeAccessor2.Form == XmlSchemaForm.Qualified && attributeAccessor2.Namespace != ns)
						{
							if (xsdAttributes == null)
							{
								xsdAttributes = new NameTable();
							}
							attributeAccessor2 = (AttributeAccessor)ReconcileAccessor(attributeAccessor2, xsdAttributes);
						}
						accessor.Attribute = attributeAccessor2;
					}
					else
					{
						if (a.XmlText != null)
						{
							if (a.XmlText.Type != null && a.XmlText.Type != fieldType)
							{
								throw new InvalidOperationException(Res.GetString("XmlIllegalType", "XmlText"));
							}
							TextAccessor textAccessor2 = new TextAccessor();
							textAccessor2.Name = name;
							textAccessor2.Mapping = ImportTypeMapping(modelScope.GetTypeModel(fieldType), ns, ImportContext.Text, a.XmlText.DataType, null, limiter);
							accessor.Text = textAccessor2;
						}
						else if (a.XmlElements.Count == 0)
						{
							a.XmlElements.Add(CreateElementAttribute(accessor.TypeDesc));
						}
						for (int k = 0; k < a.XmlElements.Count; k++)
						{
							XmlElementAttribute xmlElementAttribute2 = a.XmlElements[k];
							if (xmlElementAttribute2.Type != null && typeScope.GetTypeDesc(xmlElementAttribute2.Type) != accessor.TypeDesc)
							{
								throw new InvalidOperationException(Res.GetString("XmlIllegalType", "XmlElement"));
							}
							ElementAccessor elementAccessor4 = new ElementAccessor();
							elementAccessor4.Name = XmlConvert.EncodeLocalName((xmlElementAttribute2.ElementName.Length == 0) ? name : xmlElementAttribute2.ElementName);
							elementAccessor4.Namespace = (rpc ? null : ((xmlElementAttribute2.Namespace == null) ? ns : xmlElementAttribute2.Namespace));
							TypeModel typeModel3 = modelScope.GetTypeModel(fieldType);
							elementAccessor4.Mapping = ImportTypeMapping(typeModel3, rpc ? ns : elementAccessor4.Namespace, ImportContext.Element, xmlElementAttribute2.DataType, null, limiter);
							if (elementAccessor4.Mapping.TypeDesc.Kind == TypeKind.Node)
							{
								elementAccessor4.Any = true;
							}
							elementAccessor4.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
							if (xmlElementAttribute2.IsNullableSpecified && !xmlElementAttribute2.IsNullable && typeModel3.TypeDesc.IsOptionalValue)
							{
								throw new InvalidOperationException(Res.GetString("XmlInvalidNotNullable", typeModel3.TypeDesc.BaseTypeDesc.FullName, "XmlElement"));
							}
							elementAccessor4.IsNullable = (xmlElementAttribute2.IsNullableSpecified ? xmlElementAttribute2.IsNullable : typeModel3.TypeDesc.IsOptionalValue);
							elementAccessor4.Form = (rpc ? XmlSchemaForm.Unqualified : ((xmlElementAttribute2.Form == XmlSchemaForm.None) ? xmlSchemaForm : xmlElementAttribute2.Form));
							CheckNullable(elementAccessor4.IsNullable, accessor.TypeDesc, elementAccessor4.Mapping);
							if (!rpc)
							{
								CheckForm(elementAccessor4.Form, ns != elementAccessor4.Namespace);
								elementAccessor4 = ReconcileLocalAccessor(elementAccessor4, ns);
							}
							if (xmlElementAttribute2.Order != -1)
							{
								if (xmlElementAttribute2.Order != num2 && num2 != -1)
								{
									throw new InvalidOperationException(Res.GetString("XmlSequenceMatch", "Order"));
								}
								num2 = xmlElementAttribute2.Order;
							}
							AddUniqueAccessor(nameTable, elementAccessor4);
							arrayList.Add(elementAccessor4);
						}
					}
				}
				else if (a.Xmlns)
				{
					if (xmlFlags != XmlAttributeFlags.XmlnsDeclarations)
					{
						throw new InvalidOperationException(Res.GetString("XmlSoleXmlnsAttribute"));
					}
					if (fieldType != typeof(XmlSerializerNamespaces))
					{
						throw new InvalidOperationException(Res.GetString("XmlXmlnsInvalidType", name, fieldType.FullName, typeof(XmlSerializerNamespaces).FullName));
					}
					accessor.Xmlns = new XmlnsAccessor();
					accessor.Ignore = true;
				}
				else
				{
					if (a.XmlAttribute != null || a.XmlText != null)
					{
						if (accessor.TypeDesc.Kind == TypeKind.Serializable)
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalAttrOrTextInterface", name, accessor.TypeDesc.FullName, typeof(IXmlSerializable).Name));
						}
						throw new InvalidOperationException(Res.GetString("XmlIllegalAttrOrText", name, accessor.TypeDesc));
					}
					if (a.XmlElements.Count == 0 && a.XmlAnyElements.Count == 0)
					{
						a.XmlElements.Add(CreateElementAttribute(accessor.TypeDesc));
					}
					for (int l = 0; l < a.XmlElements.Count; l++)
					{
						XmlElementAttribute xmlElementAttribute3 = a.XmlElements[l];
						Type type5 = ((xmlElementAttribute3.Type == null) ? fieldType : xmlElementAttribute3.Type);
						TypeDesc typeDesc5 = typeScope.GetTypeDesc(type5);
						ElementAccessor elementAccessor5 = new ElementAccessor();
						TypeModel typeModel4 = modelScope.GetTypeModel(type5);
						elementAccessor5.Namespace = (rpc ? null : ((xmlElementAttribute3.Namespace == null) ? ns : xmlElementAttribute3.Namespace));
						elementAccessor5.Mapping = ImportTypeMapping(typeModel4, rpc ? ns : elementAccessor5.Namespace, ImportContext.Element, xmlElementAttribute3.DataType, null, repeats: false, openModel, limiter);
						if (a.XmlElements.Count == 1)
						{
							elementAccessor5.Name = XmlConvert.EncodeLocalName((xmlElementAttribute3.ElementName.Length == 0) ? name : xmlElementAttribute3.ElementName);
						}
						else
						{
							elementAccessor5.Name = ((xmlElementAttribute3.ElementName.Length == 0) ? elementAccessor5.Mapping.DefaultElementName : XmlConvert.EncodeLocalName(xmlElementAttribute3.ElementName));
						}
						elementAccessor5.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
						if (xmlElementAttribute3.IsNullableSpecified && !xmlElementAttribute3.IsNullable && typeModel4.TypeDesc.IsOptionalValue)
						{
							throw new InvalidOperationException(Res.GetString("XmlInvalidNotNullable", typeModel4.TypeDesc.BaseTypeDesc.FullName, "XmlElement"));
						}
						elementAccessor5.IsNullable = (xmlElementAttribute3.IsNullableSpecified ? xmlElementAttribute3.IsNullable : typeModel4.TypeDesc.IsOptionalValue);
						elementAccessor5.Form = (rpc ? XmlSchemaForm.Unqualified : ((xmlElementAttribute3.Form == XmlSchemaForm.None) ? xmlSchemaForm : xmlElementAttribute3.Form));
						CheckNullable(elementAccessor5.IsNullable, typeDesc5, elementAccessor5.Mapping);
						if (!rpc)
						{
							CheckForm(elementAccessor5.Form, ns != elementAccessor5.Namespace);
							elementAccessor5 = ReconcileLocalAccessor(elementAccessor5, ns);
						}
						if (xmlElementAttribute3.Order != -1)
						{
							if (xmlElementAttribute3.Order != num2 && num2 != -1)
							{
								throw new InvalidOperationException(Res.GetString("XmlSequenceMatch", "Order"));
							}
							num2 = xmlElementAttribute3.Order;
						}
						AddUniqueAccessor(nameTable, elementAccessor5);
						arrayList.Add(elementAccessor5);
					}
					NameTable nameTable3 = new NameTable();
					for (int m = 0; m < a.XmlAnyElements.Count; m++)
					{
						XmlAnyElementAttribute xmlAnyElementAttribute2 = a.XmlAnyElements[m];
						Type type6 = (typeof(IXmlSerializable).IsAssignableFrom(fieldType) ? fieldType : (typeof(XmlNode).IsAssignableFrom(fieldType) ? fieldType : typeof(XmlElement)));
						if (!fieldType.IsAssignableFrom(type6))
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalAnyElement", fieldType.FullName));
						}
						string name3 = ((xmlAnyElementAttribute2.Name.Length == 0) ? xmlAnyElementAttribute2.Name : XmlConvert.EncodeLocalName(xmlAnyElementAttribute2.Name));
						string text3 = (xmlAnyElementAttribute2.NamespaceSpecified ? xmlAnyElementAttribute2.Namespace : null);
						if (nameTable3[name3, text3] != null)
						{
							continue;
						}
						nameTable3[name3, text3] = xmlAnyElementAttribute2;
						if (nameTable[name3, (text3 == null) ? ns : text3] != null)
						{
							throw new InvalidOperationException(Res.GetString("XmlAnyElementDuplicate", name, xmlAnyElementAttribute2.Name, (xmlAnyElementAttribute2.Namespace == null) ? "null" : xmlAnyElementAttribute2.Namespace));
						}
						ElementAccessor elementAccessor6 = new ElementAccessor();
						elementAccessor6.Name = name3;
						elementAccessor6.Namespace = ((text3 == null) ? ns : text3);
						elementAccessor6.Any = true;
						elementAccessor6.AnyNamespaces = text3;
						TypeDesc typeDesc6 = typeScope.GetTypeDesc(type6);
						TypeModel typeModel5 = modelScope.GetTypeModel(type6);
						if (elementAccessor6.Name.Length > 0)
						{
							typeModel5.TypeDesc.IsMixed = true;
						}
						elementAccessor6.Mapping = ImportTypeMapping(typeModel5, elementAccessor6.Namespace, ImportContext.Element, string.Empty, null, repeats: false, openModel, limiter);
						elementAccessor6.Default = GetDefaultValue(model.FieldTypeDesc, model.FieldType, a);
						elementAccessor6.IsNullable = false;
						elementAccessor6.Form = xmlSchemaForm;
						CheckNullable(elementAccessor6.IsNullable, typeDesc6, elementAccessor6.Mapping);
						if (!rpc)
						{
							CheckForm(elementAccessor6.Form, ns != elementAccessor6.Namespace);
							elementAccessor6 = ReconcileLocalAccessor(elementAccessor6, ns);
						}
						if (xmlAnyElementAttribute2.Order != -1)
						{
							if (xmlAnyElementAttribute2.Order != num2 && num2 != -1)
							{
								throw new InvalidOperationException(Res.GetString("XmlSequenceMatch", "Order"));
							}
							num2 = xmlAnyElementAttribute2.Order;
						}
						nameTable.Add(elementAccessor6.Name, elementAccessor6.Namespace, elementAccessor6);
						arrayList.Add(elementAccessor6);
					}
				}
			}
			accessor.Elements = (ElementAccessor[])arrayList.ToArray(typeof(ElementAccessor));
			accessor.SequenceId = num2;
			if (rpc)
			{
				if (accessor.TypeDesc.IsArrayLike && accessor.Elements.Length > 0 && !(accessor.Elements[0].Mapping is ArrayMapping))
				{
					throw new InvalidOperationException(Res.GetString("XmlRpcLitArrayElement", accessor.Elements[0].Name));
				}
				if (accessor.Xmlns != null)
				{
					throw new InvalidOperationException(Res.GetString("XmlRpcLitXmlns", accessor.Name));
				}
			}
			if (accessor.ChoiceIdentifier != null)
			{
				accessor.ChoiceIdentifier.MemberIds = new string[accessor.Elements.Length];
				for (int n = 0; n < accessor.Elements.Length; n++)
				{
					bool flag2 = false;
					ElementAccessor elementAccessor7 = accessor.Elements[n];
					EnumMapping enumMapping = (EnumMapping)accessor.ChoiceIdentifier.Mapping;
					for (int num3 = 0; num3 < enumMapping.Constants.Length; num3++)
					{
						string xmlName = enumMapping.Constants[num3].XmlName;
						if (elementAccessor7.Any && elementAccessor7.Name.Length == 0)
						{
							string text4 = ((elementAccessor7.AnyNamespaces == null) ? "##any" : elementAccessor7.AnyNamespaces);
							if (xmlName.Substring(0, xmlName.Length - 1) == text4)
							{
								accessor.ChoiceIdentifier.MemberIds[n] = enumMapping.Constants[num3].Name;
								flag2 = true;
								break;
							}
							continue;
						}
						int num4 = xmlName.LastIndexOf(':');
						string text5 = ((num4 < 0) ? enumMapping.Namespace : xmlName.Substring(0, num4));
						string text6 = ((num4 < 0) ? xmlName : xmlName.Substring(num4 + 1));
						if (elementAccessor7.Name == text6 && ((elementAccessor7.Form == XmlSchemaForm.Unqualified && string.IsNullOrEmpty(text5)) || elementAccessor7.Namespace == text5))
						{
							accessor.ChoiceIdentifier.MemberIds[n] = enumMapping.Constants[num3].Name;
							flag2 = true;
							break;
						}
					}
					if (!flag2)
					{
						if (elementAccessor7.Any && elementAccessor7.Name.Length == 0)
						{
							throw new InvalidOperationException(Res.GetString("XmlChoiceMissingAnyValue", accessor.ChoiceIdentifier.Mapping.TypeDesc.FullName));
						}
						string text7 = ((elementAccessor7.Namespace != null && elementAccessor7.Namespace.Length > 0) ? (elementAccessor7.Namespace + ":" + elementAccessor7.Name) : elementAccessor7.Name);
						throw new InvalidOperationException(Res.GetString("XmlChoiceMissingValue", accessor.ChoiceIdentifier.Mapping.TypeDesc.FullName, text7, elementAccessor7.Name, elementAccessor7.Namespace));
					}
				}
			}
			arrayNestingLevel = num;
			savedArrayItemAttributes = xmlArrayItemAttributes;
			savedArrayNamespace = text;
		}

		private void CheckTopLevelAttributes(XmlAttributes a, string accessorName)
		{
			XmlAttributeFlags xmlFlags = a.XmlFlags;
			if ((xmlFlags & (XmlAttributeFlags)544) != 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlRpcLitAttributeAttributes"));
			}
			if ((xmlFlags & (XmlAttributeFlags)1284) != 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlRpcLitAttributes"));
			}
			if (a.XmlElements != null && a.XmlElements.Count > 0)
			{
				if (a.XmlElements.Count > 1)
				{
					throw new InvalidOperationException(Res.GetString("XmlRpcLitElements"));
				}
				XmlElementAttribute xmlElementAttribute = a.XmlElements[0];
				if (xmlElementAttribute.Namespace != null)
				{
					throw new InvalidOperationException(Res.GetString("XmlRpcLitElementNamespace", "Namespace", xmlElementAttribute.Namespace));
				}
				if (xmlElementAttribute.IsNullable)
				{
					throw new InvalidOperationException(Res.GetString("XmlRpcLitElementNullable", "IsNullable", "true"));
				}
			}
			if (a.XmlArray != null && a.XmlArray.Namespace != null)
			{
				throw new InvalidOperationException(Res.GetString("XmlRpcLitElementNamespace", "Namespace", a.XmlArray.Namespace));
			}
		}

		private void CheckAmbiguousChoice(XmlAttributes a, Type accessorType, string accessorName)
		{
			Hashtable hashtable = new Hashtable();
			XmlElementAttributes xmlElements = a.XmlElements;
			if (xmlElements != null && xmlElements.Count >= 2 && a.XmlChoiceIdentifier == null)
			{
				for (int i = 0; i < xmlElements.Count; i++)
				{
					Type key = ((xmlElements[i].Type == null) ? accessorType : xmlElements[i].Type);
					if (hashtable.Contains(key))
					{
						throw new InvalidOperationException(Res.GetString("XmlChoiceIdentiferMissing", typeof(XmlChoiceIdentifierAttribute).Name, accessorName));
					}
					hashtable.Add(key, false);
				}
			}
			if (hashtable.Contains(typeof(XmlElement)) && a.XmlAnyElements.Count > 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlChoiceIdentiferMissing", typeof(XmlChoiceIdentifierAttribute).Name, accessorName));
			}
			XmlArrayItemAttributes xmlArrayItems = a.XmlArrayItems;
			if (xmlArrayItems == null || xmlArrayItems.Count < 2)
			{
				return;
			}
			NameTable nameTable = new NameTable();
			for (int j = 0; j < xmlArrayItems.Count; j++)
			{
				Type type = ((xmlArrayItems[j].Type == null) ? accessorType : xmlArrayItems[j].Type);
				string ns = xmlArrayItems[j].NestingLevel.ToString(CultureInfo.InvariantCulture);
				XmlArrayItemAttribute xmlArrayItemAttribute = (XmlArrayItemAttribute)nameTable[type.FullName, ns];
				if (xmlArrayItemAttribute != null)
				{
					throw new InvalidOperationException(Res.GetString("XmlArrayItemAmbiguousTypes", accessorName, xmlArrayItemAttribute.ElementName, xmlArrayItems[j].ElementName, typeof(XmlElementAttribute).Name, typeof(XmlChoiceIdentifierAttribute).Name, accessorName));
				}
				nameTable[type.FullName, ns] = xmlArrayItems[j];
			}
		}

		private void CheckChoiceIdentifierMapping(EnumMapping choiceMapping)
		{
			NameTable nameTable = new NameTable();
			for (int i = 0; i < choiceMapping.Constants.Length; i++)
			{
				string xmlName = choiceMapping.Constants[i].XmlName;
				int num = xmlName.LastIndexOf(':');
				string name = ((num < 0) ? xmlName : xmlName.Substring(num + 1));
				string ns = ((num < 0) ? "" : xmlName.Substring(0, num));
				if (nameTable[name, ns] != null)
				{
					throw new InvalidOperationException(Res.GetString("XmlChoiceIdDuplicate", choiceMapping.TypeName, xmlName));
				}
				nameTable.Add(name, ns, choiceMapping.Constants[i]);
			}
		}

		private object GetDefaultValue(TypeDesc fieldTypeDesc, Type t, XmlAttributes a)
		{
			if (a.XmlDefaultValue == null || a.XmlDefaultValue == DBNull.Value)
			{
				return null;
			}
			if (fieldTypeDesc.Kind != TypeKind.Primitive && fieldTypeDesc.Kind != TypeKind.Enum)
			{
				a.XmlDefaultValue = null;
				return a.XmlDefaultValue;
			}
			if (fieldTypeDesc.Kind == TypeKind.Enum)
			{
				string text = Enum.Format(t, a.XmlDefaultValue, "G").Replace(",", " ");
				string text2 = Enum.Format(t, a.XmlDefaultValue, "D");
				if (text == text2)
				{
					throw new InvalidOperationException(Res.GetString("XmlInvalidDefaultValue", text, a.XmlDefaultValue.GetType().FullName));
				}
				return text;
			}
			return a.XmlDefaultValue;
		}

		private static XmlArrayItemAttribute CreateArrayItemAttribute(TypeDesc typeDesc, int nestingLevel)
		{
			XmlArrayItemAttribute xmlArrayItemAttribute = new XmlArrayItemAttribute();
			xmlArrayItemAttribute.NestingLevel = nestingLevel;
			return xmlArrayItemAttribute;
		}

		private static XmlArrayAttribute CreateArrayAttribute(TypeDesc typeDesc)
		{
			return new XmlArrayAttribute();
		}

		private static XmlElementAttribute CreateElementAttribute(TypeDesc typeDesc)
		{
			XmlElementAttribute xmlElementAttribute = new XmlElementAttribute();
			xmlElementAttribute.IsNullable = typeDesc.IsOptionalValue;
			return xmlElementAttribute;
		}

		private static void AddUniqueAccessor(INameScope scope, Accessor accessor)
		{
			Accessor accessor2 = (Accessor)scope[accessor.Name, accessor.Namespace];
			if (accessor2 != null)
			{
				if (accessor is ElementAccessor)
				{
					throw new InvalidOperationException(Res.GetString("XmlDuplicateElementName", accessor2.Name, accessor2.Namespace));
				}
				throw new InvalidOperationException(Res.GetString("XmlDuplicateAttributeName", accessor2.Name, accessor2.Namespace));
			}
			scope[accessor.Name, accessor.Namespace] = accessor;
		}

		private static void AddUniqueAccessor(MemberMapping member, INameScope elements, INameScope attributes, bool isSequence)
		{
			if (member.Attribute != null)
			{
				AddUniqueAccessor(attributes, member.Attribute);
			}
			else if (!isSequence && member.Elements != null && member.Elements.Length > 0)
			{
				for (int i = 0; i < member.Elements.Length; i++)
				{
					AddUniqueAccessor(elements, member.Elements[i]);
				}
			}
		}

		private static void CheckForm(XmlSchemaForm form, bool isQualified)
		{
			if (isQualified && form == XmlSchemaForm.Unqualified)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidFormUnqualified"));
			}
		}

		private static void CheckNullable(bool isNullable, TypeDesc typeDesc, TypeMapping mapping)
		{
			if (mapping is NullableMapping || mapping is SerializableMapping || !isNullable || typeDesc.IsNullable)
			{
				return;
			}
			throw new InvalidOperationException(Res.GetString("XmlInvalidIsNullable", typeDesc.FullName));
		}

		private static ElementAccessor CreateElementAccessor(TypeMapping mapping, string ns)
		{
			ElementAccessor elementAccessor = new ElementAccessor();
			bool flag = mapping.TypeDesc.Kind == TypeKind.Node;
			if (!flag && mapping is SerializableMapping)
			{
				flag = ((SerializableMapping)mapping).IsAny;
			}
			if (flag)
			{
				elementAccessor.Any = true;
			}
			else
			{
				elementAccessor.Name = mapping.DefaultElementName;
				elementAccessor.Namespace = ns;
			}
			elementAccessor.Mapping = mapping;
			return elementAccessor;
		}

		internal static XmlTypeMapping GetTopLevelMapping(Type type, string defaultNamespace)
		{
			XmlAttributes xmlAttributes = new XmlAttributes(type);
			TypeDesc typeDesc = new TypeScope().GetTypeDesc(type);
			ElementAccessor elementAccessor = new ElementAccessor();
			if (typeDesc.Kind == TypeKind.Node)
			{
				elementAccessor.Any = true;
			}
			else
			{
				string @namespace = ((xmlAttributes.XmlRoot == null) ? defaultNamespace : xmlAttributes.XmlRoot.Namespace);
				string text = string.Empty;
				if (xmlAttributes.XmlType != null)
				{
					text = xmlAttributes.XmlType.TypeName;
				}
				if (text.Length == 0)
				{
					text = type.Name;
				}
				elementAccessor.Name = XmlConvert.EncodeLocalName(text);
				elementAccessor.Namespace = @namespace;
			}
			XmlTypeMapping xmlTypeMapping = new XmlTypeMapping(null, elementAccessor);
			xmlTypeMapping.SetKeyInternal(XmlMapping.GenerateKey(type, xmlAttributes.XmlRoot, defaultNamespace));
			return xmlTypeMapping;
		}
	}
	internal class ImportStructWorkItem
	{
		private StructModel model;

		private StructMapping mapping;

		internal StructModel Model => model;

		internal StructMapping Mapping => mapping;

		internal ImportStructWorkItem(StructModel model, StructMapping mapping)
		{
			this.model = model;
			this.mapping = mapping;
		}
	}
	internal class WorkItems
	{
		private ArrayList list = new ArrayList();

		internal ImportStructWorkItem this[int index]
		{
			get
			{
				return (ImportStructWorkItem)list[index];
			}
			set
			{
				list[index] = value;
			}
		}

		internal int Count => list.Count;

		internal void Add(ImportStructWorkItem item)
		{
			list.Add(item);
		}

		internal bool Contains(StructMapping mapping)
		{
			return IndexOf(mapping) >= 0;
		}

		internal int IndexOf(StructMapping mapping)
		{
			for (int i = 0; i < Count; i++)
			{
				if (this[i].Mapping == mapping)
				{
					return i;
				}
			}
			return -1;
		}

		internal void RemoveAt(int index)
		{
			list.RemoveAt(index);
		}
	}
	internal class RecursionLimiter
	{
		private int maxDepth;

		private int depth;

		private WorkItems deferredWorkItems;

		internal bool IsExceededLimit => depth > maxDepth;

		internal int Depth
		{
			get
			{
				return depth;
			}
			set
			{
				depth = value;
			}
		}

		internal WorkItems DeferredWorkItems
		{
			get
			{
				if (deferredWorkItems == null)
				{
					deferredWorkItems = new WorkItems();
				}
				return deferredWorkItems;
			}
		}

		internal RecursionLimiter()
		{
			depth = 0;
			maxDepth = (DiagnosticsSwitches.NonRecursiveTypeLoading.Enabled ? 1 : int.MaxValue);
		}
	}
	public class XmlReflectionMember
	{
		private string memberName;

		private Type type;

		private XmlAttributes xmlAttributes = new XmlAttributes();

		private SoapAttributes soapAttributes = new SoapAttributes();

		private bool isReturnValue;

		private bool overrideIsNullable;

		public Type MemberType
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public XmlAttributes XmlAttributes
		{
			get
			{
				return xmlAttributes;
			}
			set
			{
				xmlAttributes = value;
			}
		}

		public SoapAttributes SoapAttributes
		{
			get
			{
				return soapAttributes;
			}
			set
			{
				soapAttributes = value;
			}
		}

		public string MemberName
		{
			get
			{
				if (memberName != null)
				{
					return memberName;
				}
				return string.Empty;
			}
			set
			{
				memberName = value;
			}
		}

		public bool IsReturnValue
		{
			get
			{
				return isReturnValue;
			}
			set
			{
				isReturnValue = value;
			}
		}

		public bool OverrideIsNullable
		{
			get
			{
				return overrideIsNullable;
			}
			set
			{
				overrideIsNullable = value;
			}
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Interface | AttributeTargets.ReturnValue)]
	public class XmlRootAttribute : Attribute
	{
		private string elementName;

		private string ns;

		private string dataType;

		private bool nullable = true;

		private bool nullableSpecified;

		public string ElementName
		{
			get
			{
				if (elementName != null)
				{
					return elementName;
				}
				return string.Empty;
			}
			set
			{
				elementName = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		public string DataType
		{
			get
			{
				if (dataType != null)
				{
					return dataType;
				}
				return string.Empty;
			}
			set
			{
				dataType = value;
			}
		}

		public bool IsNullable
		{
			get
			{
				return nullable;
			}
			set
			{
				nullable = value;
				nullableSpecified = true;
			}
		}

		internal bool IsNullableSpecified => nullableSpecified;

		internal string Key => ((ns == null) ? string.Empty : ns) + ":" + ElementName + ":" + nullable;

		public XmlRootAttribute()
		{
		}

		public XmlRootAttribute(string elementName)
		{
			this.elementName = elementName;
		}
	}
	public class XmlSchemaExporter
	{
		internal const XmlSchemaForm elementFormDefault = XmlSchemaForm.Qualified;

		internal const XmlSchemaForm attributeFormDefault = XmlSchemaForm.Unqualified;

		private XmlSchemas schemas;

		private Hashtable elements = new Hashtable();

		private Hashtable attributes = new Hashtable();

		private Hashtable types = new Hashtable();

		private Hashtable references = new Hashtable();

		private bool needToExportRoot;

		private TypeScope scope;

		public XmlSchemaExporter(XmlSchemas schemas)
		{
			this.schemas = schemas;
		}

		public void ExportTypeMapping(XmlTypeMapping xmlTypeMapping)
		{
			xmlTypeMapping.CheckShallow();
			CheckScope(xmlTypeMapping.Scope);
			ExportElement(xmlTypeMapping.Accessor);
			ExportRootIfNecessary(xmlTypeMapping.Scope);
		}

		public XmlQualifiedName ExportTypeMapping(XmlMembersMapping xmlMembersMapping)
		{
			xmlMembersMapping.CheckShallow();
			CheckScope(xmlMembersMapping.Scope);
			MembersMapping membersMapping = (MembersMapping)xmlMembersMapping.Accessor.Mapping;
			if (membersMapping.Members.Length == 1 && membersMapping.Members[0].Elements[0].Mapping is SpecialMapping)
			{
				SpecialMapping mapping = (SpecialMapping)membersMapping.Members[0].Elements[0].Mapping;
				XmlSchemaType xmlSchemaType = ExportSpecialMapping(mapping, xmlMembersMapping.Accessor.Namespace, isAny: false, null);
				if (xmlSchemaType != null && xmlSchemaType.Name != null && xmlSchemaType.Name.Length > 0)
				{
					xmlSchemaType.Name = xmlMembersMapping.Accessor.Name;
					AddSchemaItem(xmlSchemaType, xmlMembersMapping.Accessor.Namespace, null);
				}
				ExportRootIfNecessary(xmlMembersMapping.Scope);
				return new XmlQualifiedName(xmlMembersMapping.Accessor.Name, xmlMembersMapping.Accessor.Namespace);
			}
			return null;
		}

		public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping)
		{
			ExportMembersMapping(xmlMembersMapping, exportEnclosingType: true);
		}

		public void ExportMembersMapping(XmlMembersMapping xmlMembersMapping, bool exportEnclosingType)
		{
			xmlMembersMapping.CheckShallow();
			MembersMapping membersMapping = (MembersMapping)xmlMembersMapping.Accessor.Mapping;
			CheckScope(xmlMembersMapping.Scope);
			if (membersMapping.HasWrapperElement && exportEnclosingType)
			{
				ExportElement(xmlMembersMapping.Accessor);
			}
			else
			{
				MemberMapping[] members = membersMapping.Members;
				foreach (MemberMapping memberMapping in members)
				{
					if (memberMapping.Attribute != null)
					{
						throw new InvalidOperationException(Res.GetString("XmlBareAttributeMember", memberMapping.Attribute.Name));
					}
					if (memberMapping.Text != null)
					{
						throw new InvalidOperationException(Res.GetString("XmlBareTextMember", memberMapping.Text.Name));
					}
					if (memberMapping.Elements != null && memberMapping.Elements.Length != 0)
					{
						if (memberMapping.TypeDesc.IsArrayLike && !(memberMapping.Elements[0].Mapping is ArrayMapping))
						{
							throw new InvalidOperationException(Res.GetString("XmlIllegalArrayElement", memberMapping.Elements[0].Name));
						}
						if (exportEnclosingType)
						{
							ExportElement(memberMapping.Elements[0]);
						}
						else
						{
							ExportMapping(memberMapping.Elements[0].Mapping, memberMapping.Elements[0].Namespace, memberMapping.Elements[0].Any);
						}
					}
				}
			}
			ExportRootIfNecessary(xmlMembersMapping.Scope);
		}

		private static XmlSchemaType FindSchemaType(string name, XmlSchemaObjectCollection items)
		{
			foreach (XmlSchemaObject item in items)
			{
				if (item is XmlSchemaType xmlSchemaType && xmlSchemaType.Name == name)
				{
					return xmlSchemaType;
				}
			}
			return null;
		}

		private static bool IsAnyType(XmlSchemaType schemaType, bool mixed, bool unbounded)
		{
			if (schemaType is XmlSchemaComplexType xmlSchemaComplexType)
			{
				if (xmlSchemaComplexType.IsMixed != mixed)
				{
					return false;
				}
				if (xmlSchemaComplexType.Particle is XmlSchemaSequence)
				{
					XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence)xmlSchemaComplexType.Particle;
					if (xmlSchemaSequence.Items.Count == 1 && xmlSchemaSequence.Items[0] is XmlSchemaAny)
					{
						XmlSchemaAny xmlSchemaAny = (XmlSchemaAny)xmlSchemaSequence.Items[0];
						return unbounded == xmlSchemaAny.IsMultipleOccurrence;
					}
				}
			}
			return false;
		}

		public string ExportAnyType(string ns)
		{
			string text = "any";
			int num = 0;
			XmlSchema xmlSchema = schemas[ns];
			if (xmlSchema != null)
			{
				while (true)
				{
					XmlSchemaType xmlSchemaType = FindSchemaType(text, xmlSchema.Items);
					if (xmlSchemaType == null)
					{
						break;
					}
					if (IsAnyType(xmlSchemaType, mixed: true, unbounded: true))
					{
						return text;
					}
					num++;
					text = "any" + num.ToString(CultureInfo.InvariantCulture);
				}
			}
			XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();
			xmlSchemaComplexType.Name = text;
			xmlSchemaComplexType.IsMixed = true;
			XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
			XmlSchemaAny xmlSchemaAny = new XmlSchemaAny();
			xmlSchemaAny.MinOccurs = 0m;
			xmlSchemaAny.MaxOccurs = decimal.MaxValue;
			xmlSchemaSequence.Items.Add(xmlSchemaAny);
			xmlSchemaComplexType.Particle = xmlSchemaSequence;
			AddSchemaItem(xmlSchemaComplexType, ns, null);
			return text;
		}

		public string ExportAnyType(XmlMembersMapping members)
		{
			if (members.Count == 1 && members[0].Any && members[0].ElementName.Length == 0)
			{
				XmlMemberMapping xmlMemberMapping = members[0];
				string @namespace = xmlMemberMapping.Namespace;
				bool flag = xmlMemberMapping.Mapping.TypeDesc.IsArrayLike;
				bool flag2 = ((flag && xmlMemberMapping.Mapping.TypeDesc.ArrayElementTypeDesc != null) ? xmlMemberMapping.Mapping.TypeDesc.ArrayElementTypeDesc.IsMixed : xmlMemberMapping.Mapping.TypeDesc.IsMixed);
				if (flag2 && xmlMemberMapping.Mapping.TypeDesc.IsMixed)
				{
					flag = true;
				}
				string text = (flag2 ? "any" : (flag ? "anyElements" : "anyElement"));
				string text2 = text;
				int num = 0;
				XmlSchema xmlSchema = schemas[@namespace];
				if (xmlSchema != null)
				{
					while (true)
					{
						XmlSchemaType xmlSchemaType = FindSchemaType(text2, xmlSchema.Items);
						if (xmlSchemaType == null)
						{
							break;
						}
						if (IsAnyType(xmlSchemaType, flag2, flag))
						{
							return text2;
						}
						num++;
						text2 = text + num.ToString(CultureInfo.InvariantCulture);
					}
				}
				XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();
				xmlSchemaComplexType.Name = text2;
				xmlSchemaComplexType.IsMixed = flag2;
				XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
				XmlSchemaAny xmlSchemaAny = new XmlSchemaAny();
				xmlSchemaAny.MinOccurs = 0m;
				if (flag)
				{
					xmlSchemaAny.MaxOccurs = decimal.MaxValue;
				}
				xmlSchemaSequence.Items.Add(xmlSchemaAny);
				xmlSchemaComplexType.Particle = xmlSchemaSequence;
				AddSchemaItem(xmlSchemaComplexType, @namespace, null);
				return text2;
			}
			return null;
		}

		private void CheckScope(TypeScope scope)
		{
			if (this.scope == null)
			{
				this.scope = scope;
			}
			else if (this.scope != scope)
			{
				throw new InvalidOperationException(Res.GetString("XmlMappingsScopeMismatch"));
			}
		}

		private XmlSchemaElement ExportElement(ElementAccessor accessor)
		{
			if (!accessor.Mapping.IncludeInSchema && !accessor.Mapping.TypeDesc.IsRoot)
			{
				return null;
			}
			if (accessor.Any && accessor.Name.Length == 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlIllegalWildcard"));
			}
			XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)elements[accessor];
			if (xmlSchemaElement != null)
			{
				return xmlSchemaElement;
			}
			xmlSchemaElement = new XmlSchemaElement();
			xmlSchemaElement.Name = accessor.Name;
			xmlSchemaElement.IsNillable = accessor.IsNullable;
			elements.Add(accessor, xmlSchemaElement);
			xmlSchemaElement.Form = accessor.Form;
			AddSchemaItem(xmlSchemaElement, accessor.Namespace, null);
			ExportElementMapping(xmlSchemaElement, accessor.Mapping, accessor.Namespace, accessor.Any);
			return xmlSchemaElement;
		}

		private void CheckForDuplicateType(TypeMapping mapping, string newNamespace)
		{
			if (mapping.IsAnonymousType)
			{
				return;
			}
			string typeName = mapping.TypeName;
			XmlSchema xmlSchema = schemas[newNamespace];
			if (xmlSchema == null)
			{
				return;
			}
			foreach (XmlSchemaObject item in xmlSchema.Items)
			{
				if (item is XmlSchemaType xmlSchemaType && xmlSchemaType.Name == typeName)
				{
					throw new InvalidOperationException(Res.GetString("XmlDuplicateTypeName", typeName, newNamespace));
				}
			}
		}

		private XmlSchema AddSchema(string targetNamespace)
		{
			XmlSchema xmlSchema = new XmlSchema();
			xmlSchema.TargetNamespace = (string.IsNullOrEmpty(targetNamespace) ? null : targetNamespace);
			xmlSchema.ElementFormDefault = XmlSchemaForm.Qualified;
			xmlSchema.AttributeFormDefault = XmlSchemaForm.None;
			schemas.Add(xmlSchema);
			return xmlSchema;
		}

		private void AddSchemaItem(XmlSchemaObject item, string ns, string referencingNs)
		{
			XmlSchema xmlSchema = schemas[ns];
			if (xmlSchema == null)
			{
				xmlSchema = AddSchema(ns);
			}
			if (item is XmlSchemaElement)
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)item;
				if (xmlSchemaElement.Form == XmlSchemaForm.Unqualified)
				{
					throw new InvalidOperationException(Res.GetString("XmlIllegalForm", xmlSchemaElement.Name));
				}
				xmlSchemaElement.Form = XmlSchemaForm.None;
			}
			else if (item is XmlSchemaAttribute)
			{
				XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)item;
				if (xmlSchemaAttribute.Form == XmlSchemaForm.Unqualified)
				{
					throw new InvalidOperationException(Res.GetString("XmlIllegalForm", xmlSchemaAttribute.Name));
				}
				xmlSchemaAttribute.Form = XmlSchemaForm.None;
			}
			xmlSchema.Items.Add(item);
			AddSchemaImport(ns, referencingNs);
		}

		private void AddSchemaImport(string ns, string referencingNs)
		{
			if (referencingNs == null || NamespacesEqual(ns, referencingNs))
			{
				return;
			}
			XmlSchema xmlSchema = schemas[referencingNs];
			if (xmlSchema == null)
			{
				xmlSchema = AddSchema(referencingNs);
			}
			if (FindImport(xmlSchema, ns) == null)
			{
				XmlSchemaImport xmlSchemaImport = new XmlSchemaImport();
				if (ns != null && ns.Length > 0)
				{
					xmlSchemaImport.Namespace = ns;
				}
				xmlSchema.Includes.Add(xmlSchemaImport);
			}
		}

		private static bool NamespacesEqual(string ns1, string ns2)
		{
			if (ns1 == null || ns1.Length == 0)
			{
				if (ns2 != null)
				{
					return ns2.Length == 0;
				}
				return true;
			}
			return ns1 == ns2;
		}

		private bool SchemaContainsItem(XmlSchemaObject item, string ns)
		{
			return schemas[ns]?.Items.Contains(item) ?? false;
		}

		private XmlSchemaImport FindImport(XmlSchema schema, string ns)
		{
			foreach (XmlSchemaObject include in schema.Includes)
			{
				if (include is XmlSchemaImport)
				{
					XmlSchemaImport xmlSchemaImport = (XmlSchemaImport)include;
					if (NamespacesEqual(xmlSchemaImport.Namespace, ns))
					{
						return xmlSchemaImport;
					}
				}
			}
			return null;
		}

		private void ExportMapping(Mapping mapping, string ns, bool isAny)
		{
			if (mapping is ArrayMapping)
			{
				ExportArrayMapping((ArrayMapping)mapping, ns, null);
				return;
			}
			if (mapping is PrimitiveMapping)
			{
				ExportPrimitiveMapping((PrimitiveMapping)mapping, ns);
				return;
			}
			if (mapping is StructMapping)
			{
				ExportStructMapping((StructMapping)mapping, ns, null);
				return;
			}
			if (mapping is MembersMapping)
			{
				ExportMembersMapping((MembersMapping)mapping, ns);
				return;
			}
			if (mapping is SpecialMapping)
			{
				ExportSpecialMapping((SpecialMapping)mapping, ns, isAny, null);
				return;
			}
			if (mapping is NullableMapping)
			{
				ExportMapping(((NullableMapping)mapping).BaseMapping, ns, isAny);
				return;
			}
			throw new ArgumentException(Res.GetString("XmlInternalError"), "mapping");
		}

		private void ExportElementMapping(XmlSchemaElement element, Mapping mapping, string ns, bool isAny)
		{
			if (mapping is ArrayMapping)
			{
				ExportArrayMapping((ArrayMapping)mapping, ns, element);
			}
			else if (mapping is PrimitiveMapping)
			{
				PrimitiveMapping primitiveMapping = (PrimitiveMapping)mapping;
				if (primitiveMapping.IsAnonymousType)
				{
					element.SchemaType = ExportAnonymousPrimitiveMapping(primitiveMapping);
				}
				else
				{
					element.SchemaTypeName = ExportPrimitiveMapping(primitiveMapping, ns);
				}
			}
			else if (mapping is StructMapping)
			{
				ExportStructMapping((StructMapping)mapping, ns, element);
			}
			else if (mapping is MembersMapping)
			{
				element.SchemaType = ExportMembersMapping((MembersMapping)mapping, ns);
			}
			else if (mapping is SpecialMapping)
			{
				ExportSpecialMapping((SpecialMapping)mapping, ns, isAny, element);
			}
			else
			{
				if (!(mapping is NullableMapping))
				{
					throw new ArgumentException(Res.GetString("XmlInternalError"), "mapping");
				}
				ExportElementMapping(element, ((NullableMapping)mapping).BaseMapping, ns, isAny);
			}
		}

		private XmlQualifiedName ExportNonXsdPrimitiveMapping(PrimitiveMapping mapping, string ns)
		{
			XmlSchemaSimpleType item = (XmlSchemaSimpleType)mapping.TypeDesc.DataType;
			if (!SchemaContainsItem(item, "http://microsoft.com/wsdl/types/"))
			{
				AddSchemaItem(item, "http://microsoft.com/wsdl/types/", ns);
			}
			else
			{
				AddSchemaImport(mapping.Namespace, ns);
			}
			return new XmlQualifiedName(mapping.TypeDesc.DataType.Name, "http://microsoft.com/wsdl/types/");
		}

		private XmlSchemaType ExportSpecialMapping(SpecialMapping mapping, string ns, bool isAny, XmlSchemaElement element)
		{
			switch (mapping.TypeDesc.Kind)
			{
			case TypeKind.Node:
			{
				XmlSchemaComplexType xmlSchemaComplexType4 = new XmlSchemaComplexType();
				xmlSchemaComplexType4.IsMixed = mapping.TypeDesc.IsMixed;
				XmlSchemaSequence xmlSchemaSequence4 = new XmlSchemaSequence();
				XmlSchemaAny xmlSchemaAny3 = new XmlSchemaAny();
				if (isAny)
				{
					xmlSchemaComplexType4.AnyAttribute = new XmlSchemaAnyAttribute();
					xmlSchemaComplexType4.IsMixed = true;
					xmlSchemaAny3.MaxOccurs = decimal.MaxValue;
				}
				xmlSchemaSequence4.Items.Add(xmlSchemaAny3);
				xmlSchemaComplexType4.Particle = xmlSchemaSequence4;
				if (element != null)
				{
					element.SchemaType = xmlSchemaComplexType4;
				}
				return xmlSchemaComplexType4;
			}
			case TypeKind.Serializable:
			{
				SerializableMapping serializableMapping = (SerializableMapping)mapping;
				if (serializableMapping.IsAny)
				{
					XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();
					xmlSchemaComplexType.IsMixed = mapping.TypeDesc.IsMixed;
					XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
					XmlSchemaAny xmlSchemaAny = new XmlSchemaAny();
					if (isAny)
					{
						xmlSchemaComplexType.AnyAttribute = new XmlSchemaAnyAttribute();
						xmlSchemaComplexType.IsMixed = true;
						xmlSchemaAny.MaxOccurs = decimal.MaxValue;
					}
					if (serializableMapping.NamespaceList.Length > 0)
					{
						xmlSchemaAny.Namespace = serializableMapping.NamespaceList;
					}
					xmlSchemaAny.ProcessContents = XmlSchemaContentProcessing.Lax;
					if (serializableMapping.Schemas != null)
					{
						foreach (XmlSchema item in serializableMapping.Schemas.Schemas())
						{
							if (item.TargetNamespace != "http://www.w3.org/2001/XMLSchema")
							{
								schemas.Add(item, delay: true);
								AddSchemaImport(item.TargetNamespace, ns);
							}
						}
					}
					xmlSchemaSequence.Items.Add(xmlSchemaAny);
					xmlSchemaComplexType.Particle = xmlSchemaSequence;
					if (element != null)
					{
						element.SchemaType = xmlSchemaComplexType;
					}
					return xmlSchemaComplexType;
				}
				if (serializableMapping.XsiType != null || serializableMapping.XsdType != null)
				{
					XmlSchemaType xmlSchemaType = serializableMapping.XsdType;
					foreach (XmlSchema item2 in serializableMapping.Schemas.Schemas())
					{
						if (item2.TargetNamespace != "http://www.w3.org/2001/XMLSchema")
						{
							schemas.Add(item2, delay: true);
							AddSchemaImport(item2.TargetNamespace, ns);
							if (!serializableMapping.XsiType.IsEmpty && serializableMapping.XsiType.Namespace == item2.TargetNamespace)
							{
								xmlSchemaType = (XmlSchemaType)item2.SchemaTypes[serializableMapping.XsiType];
							}
						}
					}
					if (element != null)
					{
						element.SchemaTypeName = serializableMapping.XsiType;
						if (element.SchemaTypeName.IsEmpty)
						{
							element.SchemaType = xmlSchemaType;
						}
					}
					serializableMapping.CheckDuplicateElement(element, ns);
					return xmlSchemaType;
				}
				if (serializableMapping.Schema != null)
				{
					XmlSchemaComplexType xmlSchemaComplexType2 = new XmlSchemaComplexType();
					XmlSchemaAny xmlSchemaAny2 = new XmlSchemaAny();
					XmlSchemaSequence xmlSchemaSequence2 = new XmlSchemaSequence();
					xmlSchemaSequence2.Items.Add(xmlSchemaAny2);
					xmlSchemaComplexType2.Particle = xmlSchemaSequence2;
					string targetNamespace = serializableMapping.Schema.TargetNamespace;
					xmlSchemaAny2.Namespace = ((targetNamespace == null) ? "" : targetNamespace);
					XmlSchema xmlSchema3 = schemas[targetNamespace];
					if (xmlSchema3 == null)
					{
						schemas.Add(serializableMapping.Schema);
					}
					else if (xmlSchema3 != serializableMapping.Schema)
					{
						throw new InvalidOperationException(Res.GetString("XmlDuplicateNamespace", targetNamespace));
					}
					if (element != null)
					{
						element.SchemaType = xmlSchemaComplexType2;
					}
					serializableMapping.CheckDuplicateElement(element, ns);
					return xmlSchemaComplexType2;
				}
				XmlSchemaComplexType xmlSchemaComplexType3 = new XmlSchemaComplexType();
				XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
				xmlSchemaElement.RefName = new XmlQualifiedName("schema", "http://www.w3.org/2001/XMLSchema");
				XmlSchemaSequence xmlSchemaSequence3 = new XmlSchemaSequence();
				xmlSchemaSequence3.Items.Add(xmlSchemaElement);
				xmlSchemaSequence3.Items.Add(new XmlSchemaAny());
				xmlSchemaComplexType3.Particle = xmlSchemaSequence3;
				AddSchemaImport("http://www.w3.org/2001/XMLSchema", ns);
				if (element != null)
				{
					element.SchemaType = xmlSchemaComplexType3;
				}
				return xmlSchemaComplexType3;
			}
			default:
				throw new ArgumentException(Res.GetString("XmlInternalError"), "mapping");
			}
		}

		private XmlSchemaType ExportMembersMapping(MembersMapping mapping, string ns)
		{
			XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();
			ExportTypeMembers(xmlSchemaComplexType, mapping.Members, mapping.TypeName, ns, hasSimpleContent: false, openModel: false);
			if (mapping.XmlnsMember != null)
			{
				AddXmlnsAnnotation(xmlSchemaComplexType, mapping.XmlnsMember.Name);
			}
			return xmlSchemaComplexType;
		}

		private XmlSchemaType ExportAnonymousPrimitiveMapping(PrimitiveMapping mapping)
		{
			if (mapping is EnumMapping)
			{
				return ExportEnumMapping((EnumMapping)mapping, null);
			}
			throw new InvalidOperationException(Res.GetString("XmlInternalErrorDetails", "Unsuported anonymous mapping type: " + mapping.ToString()));
		}

		private XmlQualifiedName ExportPrimitiveMapping(PrimitiveMapping mapping, string ns)
		{
			if (mapping is EnumMapping)
			{
				XmlSchemaType xmlSchemaType = ExportEnumMapping((EnumMapping)mapping, ns);
				return new XmlQualifiedName(xmlSchemaType.Name, mapping.Namespace);
			}
			if (mapping.TypeDesc.IsXsdType)
			{
				return new XmlQualifiedName(mapping.TypeDesc.DataType.Name, "http://www.w3.org/2001/XMLSchema");
			}
			return ExportNonXsdPrimitiveMapping(mapping, ns);
		}

		private void ExportArrayMapping(ArrayMapping mapping, string ns, XmlSchemaElement element)
		{
			ArrayMapping arrayMapping = mapping;
			while (arrayMapping.Next != null)
			{
				arrayMapping = arrayMapping.Next;
			}
			XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)types[arrayMapping];
			if (xmlSchemaComplexType == null)
			{
				CheckForDuplicateType(arrayMapping, arrayMapping.Namespace);
				xmlSchemaComplexType = new XmlSchemaComplexType();
				if (!mapping.IsAnonymousType)
				{
					xmlSchemaComplexType.Name = mapping.TypeName;
					AddSchemaItem(xmlSchemaComplexType, mapping.Namespace, ns);
				}
				if (!arrayMapping.IsAnonymousType)
				{
					types.Add(arrayMapping, xmlSchemaComplexType);
				}
				XmlSchemaSequence xmlSchemaSequence = new XmlSchemaSequence();
				ExportElementAccessors(xmlSchemaSequence, mapping.Elements, repeats: true, valueTypeOptional: false, mapping.Namespace);
				if (xmlSchemaSequence.Items.Count > 0)
				{
					if (xmlSchemaSequence.Items[0] is XmlSchemaChoice)
					{
						xmlSchemaComplexType.Particle = (XmlSchemaChoice)xmlSchemaSequence.Items[0];
					}
					else
					{
						xmlSchemaComplexType.Particle = xmlSchemaSequence;
					}
				}
			}
			else
			{
				AddSchemaImport(mapping.Namespace, ns);
			}
			if (element != null)
			{
				if (mapping.IsAnonymousType)
				{
					element.SchemaType = xmlSchemaComplexType;
				}
				else
				{
					element.SchemaTypeName = new XmlQualifiedName(xmlSchemaComplexType.Name, mapping.Namespace);
				}
			}
		}

		private void ExportElementAccessors(XmlSchemaGroupBase group, ElementAccessor[] accessors, bool repeats, bool valueTypeOptional, string ns)
		{
			if (accessors.Length == 0)
			{
				return;
			}
			if (accessors.Length == 1)
			{
				ExportElementAccessor(group, accessors[0], repeats, valueTypeOptional, ns);
				return;
			}
			XmlSchemaChoice xmlSchemaChoice = new XmlSchemaChoice();
			xmlSchemaChoice.MaxOccurs = (repeats ? decimal.MaxValue : 1m);
			xmlSchemaChoice.MinOccurs = ((!repeats) ? 1 : 0);
			for (int i = 0; i < accessors.Length; i++)
			{
				ExportElementAccessor(xmlSchemaChoice, accessors[i], repeats: false, valueTypeOptional, ns);
			}
			if (xmlSchemaChoice.Items.Count > 0)
			{
				group.Items.Add(xmlSchemaChoice);
			}
		}

		private void ExportAttributeAccessor(XmlSchemaComplexType type, AttributeAccessor accessor, bool valueTypeOptional, string ns)
		{
			if (accessor == null)
			{
				return;
			}
			XmlSchemaObjectCollection xmlSchemaObjectCollection;
			if (type.ContentModel != null)
			{
				if (type.ContentModel.Content is XmlSchemaComplexContentRestriction)
				{
					xmlSchemaObjectCollection = ((XmlSchemaComplexContentRestriction)type.ContentModel.Content).Attributes;
				}
				else if (type.ContentModel.Content is XmlSchemaComplexContentExtension)
				{
					xmlSchemaObjectCollection = ((XmlSchemaComplexContentExtension)type.ContentModel.Content).Attributes;
				}
				else
				{
					if (!(type.ContentModel.Content is XmlSchemaSimpleContentExtension))
					{
						throw new InvalidOperationException(Res.GetString("XmlInvalidContent", type.ContentModel.Content.GetType().Name));
					}
					xmlSchemaObjectCollection = ((XmlSchemaSimpleContentExtension)type.ContentModel.Content).Attributes;
				}
			}
			else
			{
				xmlSchemaObjectCollection = type.Attributes;
			}
			if (accessor.IsSpecialXmlNamespace)
			{
				AddSchemaImport("http://www.w3.org/XML/1998/namespace", ns);
				XmlSchemaAttribute xmlSchemaAttribute = new XmlSchemaAttribute();
				xmlSchemaAttribute.Use = XmlSchemaUse.Optional;
				xmlSchemaAttribute.RefName = new XmlQualifiedName(accessor.Name, "http://www.w3.org/XML/1998/namespace");
				xmlSchemaObjectCollection.Add(xmlSchemaAttribute);
				return;
			}
			if (accessor.Any)
			{
				if (type.ContentModel == null)
				{
					type.AnyAttribute = new XmlSchemaAnyAttribute();
					return;
				}
				XmlSchemaContent content = type.ContentModel.Content;
				if (content is XmlSchemaComplexContentExtension)
				{
					XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension = (XmlSchemaComplexContentExtension)content;
					xmlSchemaComplexContentExtension.AnyAttribute = new XmlSchemaAnyAttribute();
				}
				else if (content is XmlSchemaComplexContentRestriction)
				{
					XmlSchemaComplexContentRestriction xmlSchemaComplexContentRestriction = (XmlSchemaComplexContentRestriction)content;
					xmlSchemaComplexContentRestriction.AnyAttribute = new XmlSchemaAnyAttribute();
				}
				else if (type.ContentModel.Content is XmlSchemaSimpleContentExtension)
				{
					XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = (XmlSchemaSimpleContentExtension)content;
					xmlSchemaSimpleContentExtension.AnyAttribute = new XmlSchemaAnyAttribute();
				}
				return;
			}
			XmlSchemaAttribute xmlSchemaAttribute2 = new XmlSchemaAttribute();
			xmlSchemaAttribute2.Use = XmlSchemaUse.None;
			if (!accessor.HasDefault && !valueTypeOptional && accessor.Mapping.TypeDesc.IsValueType)
			{
				xmlSchemaAttribute2.Use = XmlSchemaUse.Required;
			}
			xmlSchemaAttribute2.Name = accessor.Name;
			if (accessor.Namespace == null || accessor.Namespace == ns)
			{
				XmlSchema xmlSchema = schemas[ns];
				if (xmlSchema == null)
				{
					xmlSchemaAttribute2.Form = ((accessor.Form != XmlSchemaForm.Unqualified) ? accessor.Form : XmlSchemaForm.None);
				}
				else
				{
					xmlSchemaAttribute2.Form = ((accessor.Form != xmlSchema.AttributeFormDefault) ? accessor.Form : XmlSchemaForm.None);
				}
				xmlSchemaObjectCollection.Add(xmlSchemaAttribute2);
			}
			else
			{
				if (attributes[accessor] == null)
				{
					xmlSchemaAttribute2.Use = XmlSchemaUse.None;
					xmlSchemaAttribute2.Form = accessor.Form;
					AddSchemaItem(xmlSchemaAttribute2, accessor.Namespace, ns);
					attributes.Add(accessor, accessor);
				}
				XmlSchemaAttribute xmlSchemaAttribute3 = new XmlSchemaAttribute();
				xmlSchemaAttribute3.Use = XmlSchemaUse.None;
				xmlSchemaAttribute3.RefName = new XmlQualifiedName(accessor.Name, accessor.Namespace);
				xmlSchemaObjectCollection.Add(xmlSchemaAttribute3);
				AddSchemaImport(accessor.Namespace, ns);
			}
			if (accessor.Mapping is PrimitiveMapping)
			{
				PrimitiveMapping primitiveMapping = (PrimitiveMapping)accessor.Mapping;
				if (primitiveMapping.IsList)
				{
					XmlSchemaSimpleType xmlSchemaSimpleType = new XmlSchemaSimpleType();
					XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = new XmlSchemaSimpleTypeList();
					if (primitiveMapping.IsAnonymousType)
					{
						xmlSchemaSimpleTypeList.ItemType = (XmlSchemaSimpleType)ExportAnonymousPrimitiveMapping(primitiveMapping);
					}
					else
					{
						xmlSchemaSimpleTypeList.ItemTypeName = ExportPrimitiveMapping(primitiveMapping, (accessor.Namespace == null) ? ns : accessor.Namespace);
					}
					xmlSchemaSimpleType.Content = xmlSchemaSimpleTypeList;
					xmlSchemaAttribute2.SchemaType = xmlSchemaSimpleType;
				}
				else if (primitiveMapping.IsAnonymousType)
				{
					xmlSchemaAttribute2.SchemaType = (XmlSchemaSimpleType)ExportAnonymousPrimitiveMapping(primitiveMapping);
				}
				else
				{
					xmlSchemaAttribute2.SchemaTypeName = ExportPrimitiveMapping(primitiveMapping, (accessor.Namespace == null) ? ns : accessor.Namespace);
				}
			}
			else if (!(accessor.Mapping is SpecialMapping))
			{
				throw new InvalidOperationException(Res.GetString("XmlInternalError"));
			}
			if (accessor.HasDefault)
			{
				xmlSchemaAttribute2.DefaultValue = ExportDefaultValue(accessor.Mapping, accessor.Default);
			}
		}

		private void ExportElementAccessor(XmlSchemaGroupBase group, ElementAccessor accessor, bool repeats, bool valueTypeOptional, string ns)
		{
			if (accessor.Any && accessor.Name.Length == 0)
			{
				XmlSchemaAny xmlSchemaAny = new XmlSchemaAny();
				xmlSchemaAny.MinOccurs = 0m;
				xmlSchemaAny.MaxOccurs = (repeats ? decimal.MaxValue : 1m);
				if (accessor.Namespace != null && accessor.Namespace.Length > 0 && accessor.Namespace != ns)
				{
					xmlSchemaAny.Namespace = accessor.Namespace;
				}
				group.Items.Add(xmlSchemaAny);
				return;
			}
			XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)elements[accessor];
			int num = ((!repeats && !accessor.HasDefault && (accessor.IsNullable || accessor.Mapping.TypeDesc.IsValueType) && !valueTypeOptional) ? 1 : 0);
			decimal maxOccurs = ((repeats || accessor.IsUnbounded) ? decimal.MaxValue : 1m);
			if (xmlSchemaElement == null)
			{
				xmlSchemaElement = new XmlSchemaElement();
				xmlSchemaElement.IsNillable = accessor.IsNullable;
				xmlSchemaElement.Name = accessor.Name;
				if (accessor.HasDefault)
				{
					xmlSchemaElement.DefaultValue = ExportDefaultValue(accessor.Mapping, accessor.Default);
				}
				if (accessor.IsTopLevelInSchema)
				{
					elements.Add(accessor, xmlSchemaElement);
					xmlSchemaElement.Form = accessor.Form;
					AddSchemaItem(xmlSchemaElement, accessor.Namespace, ns);
				}
				else
				{
					xmlSchemaElement.MinOccurs = num;
					xmlSchemaElement.MaxOccurs = maxOccurs;
					XmlSchema xmlSchema = schemas[ns];
					if (xmlSchema == null)
					{
						xmlSchemaElement.Form = ((accessor.Form != XmlSchemaForm.Qualified) ? accessor.Form : XmlSchemaForm.None);
					}
					else
					{
						xmlSchemaElement.Form = ((accessor.Form != xmlSchema.ElementFormDefault) ? accessor.Form : XmlSchemaForm.None);
					}
				}
				ExportElementMapping(xmlSchemaElement, accessor.Mapping, accessor.Namespace, accessor.Any);
			}
			if (accessor.IsTopLevelInSchema)
			{
				XmlSchemaElement xmlSchemaElement2 = new XmlSchemaElement();
				xmlSchemaElement2.RefName = new XmlQualifiedName(accessor.Name, accessor.Namespace);
				xmlSchemaElement2.MinOccurs = num;
				xmlSchemaElement2.MaxOccurs = maxOccurs;
				group.Items.Add(xmlSchemaElement2);
				AddSchemaImport(accessor.Namespace, ns);
			}
			else
			{
				group.Items.Add(xmlSchemaElement);
			}
		}

		internal static string ExportDefaultValue(TypeMapping mapping, object value)
		{
			if (!(mapping is PrimitiveMapping))
			{
				return null;
			}
			if (value == null || value == DBNull.Value)
			{
				return null;
			}
			if (mapping is EnumMapping)
			{
				EnumMapping enumMapping = (EnumMapping)mapping;
				ConstantMapping[] constants = enumMapping.Constants;
				if (enumMapping.IsFlags)
				{
					string[] array = new string[constants.Length];
					long[] array2 = new long[constants.Length];
					Hashtable hashtable = new Hashtable();
					for (int i = 0; i < constants.Length; i++)
					{
						array[i] = constants[i].XmlName;
						array2[i] = 1 << i;
						hashtable.Add(constants[i].Name, array2[i]);
					}
					long num = XmlCustomFormatter.ToEnum((string)value, hashtable, enumMapping.TypeName, validate: false);
					if (num == 0)
					{
						return null;
					}
					return XmlCustomFormatter.FromEnum(num, array, array2, mapping.TypeDesc.FullName);
				}
				for (int j = 0; j < constants.Length; j++)
				{
					if (constants[j].Name == (string)value)
					{
						return constants[j].XmlName;
					}
				}
				return null;
			}
			PrimitiveMapping primitiveMapping = (PrimitiveMapping)mapping;
			if (!primitiveMapping.TypeDesc.HasCustomFormatter)
			{
				if (primitiveMapping.TypeDesc.FormatterName == "String")
				{
					return (string)value;
				}
				Type typeFromHandle = typeof(XmlConvert);
				MethodInfo method = typeFromHandle.GetMethod("ToString", new Type[1] { primitiveMapping.TypeDesc.Type });
				if (method != null)
				{
					return (string)method.Invoke(typeFromHandle, new object[1] { value });
				}
				throw new InvalidOperationException(Res.GetString("XmlInvalidDefaultValue", value.ToString(), primitiveMapping.TypeDesc.Name));
			}
			string text = XmlCustomFormatter.FromDefaultValue(value, primitiveMapping.TypeDesc.FormatterName);
			if (text == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidDefaultValue", value.ToString(), primitiveMapping.TypeDesc.Name));
			}
			return text;
		}

		private void ExportRootIfNecessary(TypeScope typeScope)
		{
			if (!needToExportRoot)
			{
				return;
			}
			foreach (TypeMapping typeMapping in typeScope.TypeMappings)
			{
				if (typeMapping is StructMapping && typeMapping.TypeDesc.IsRoot)
				{
					ExportDerivedMappings((StructMapping)typeMapping);
				}
				else if (typeMapping is ArrayMapping)
				{
					ExportArrayMapping((ArrayMapping)typeMapping, typeMapping.Namespace, null);
				}
				else if (typeMapping is SerializableMapping)
				{
					ExportSpecialMapping((SerializableMapping)typeMapping, typeMapping.Namespace, isAny: false, null);
				}
			}
		}

		private XmlQualifiedName ExportStructMapping(StructMapping mapping, string ns, XmlSchemaElement element)
		{
			if (mapping.TypeDesc.IsRoot)
			{
				needToExportRoot = true;
				return XmlQualifiedName.Empty;
			}
			if (mapping.IsAnonymousType)
			{
				if (references[mapping] != null)
				{
					throw new InvalidOperationException(Res.GetString("XmlCircularReference2", mapping.TypeDesc.Name, "AnonymousType", "false"));
				}
				references[mapping] = mapping;
			}
			XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)types[mapping];
			if (xmlSchemaComplexType == null)
			{
				if (!mapping.IncludeInSchema)
				{
					throw new InvalidOperationException(Res.GetString("XmlCannotIncludeInSchema", mapping.TypeDesc.Name));
				}
				CheckForDuplicateType(mapping, mapping.Namespace);
				xmlSchemaComplexType = new XmlSchemaComplexType();
				if (!mapping.IsAnonymousType)
				{
					xmlSchemaComplexType.Name = mapping.TypeName;
					AddSchemaItem(xmlSchemaComplexType, mapping.Namespace, ns);
					types.Add(mapping, xmlSchemaComplexType);
				}
				xmlSchemaComplexType.IsAbstract = mapping.TypeDesc.IsAbstract;
				bool openModel = mapping.IsOpenModel;
				if (mapping.BaseMapping != null && mapping.BaseMapping.IncludeInSchema)
				{
					if (mapping.BaseMapping.IsAnonymousType)
					{
						throw new InvalidOperationException(Res.GetString("XmlAnonymousBaseType", mapping.TypeDesc.Name, mapping.BaseMapping.TypeDesc.Name, "AnonymousType", "false"));
					}
					if (mapping.HasSimpleContent)
					{
						XmlSchemaSimpleContent xmlSchemaSimpleContent = new XmlSchemaSimpleContent();
						XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = new XmlSchemaSimpleContentExtension();
						xmlSchemaSimpleContentExtension.BaseTypeName = ExportStructMapping(mapping.BaseMapping, mapping.Namespace, null);
						xmlSchemaSimpleContent.Content = xmlSchemaSimpleContentExtension;
						xmlSchemaComplexType.ContentModel = xmlSchemaSimpleContent;
					}
					else
					{
						XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension = new XmlSchemaComplexContentExtension();
						xmlSchemaComplexContentExtension.BaseTypeName = ExportStructMapping(mapping.BaseMapping, mapping.Namespace, null);
						XmlSchemaComplexContent xmlSchemaComplexContent = new XmlSchemaComplexContent();
						xmlSchemaComplexContent.Content = xmlSchemaComplexContentExtension;
						xmlSchemaComplexContent.IsMixed = XmlSchemaImporter.IsMixed((XmlSchemaComplexType)types[mapping.BaseMapping]);
						xmlSchemaComplexType.ContentModel = xmlSchemaComplexContent;
					}
					openModel = false;
				}
				ExportTypeMembers(xmlSchemaComplexType, mapping.Members, mapping.TypeName, mapping.Namespace, mapping.HasSimpleContent, openModel);
				ExportDerivedMappings(mapping);
				if (mapping.XmlnsMember != null)
				{
					AddXmlnsAnnotation(xmlSchemaComplexType, mapping.XmlnsMember.Name);
				}
			}
			else
			{
				AddSchemaImport(mapping.Namespace, ns);
			}
			if (mapping.IsAnonymousType)
			{
				references[mapping] = null;
				if (element != null)
				{
					element.SchemaType = xmlSchemaComplexType;
				}
				return XmlQualifiedName.Empty;
			}
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(xmlSchemaComplexType.Name, mapping.Namespace);
			if (element != null)
			{
				element.SchemaTypeName = xmlQualifiedName;
			}
			return xmlQualifiedName;
		}

		private void ExportTypeMembers(XmlSchemaComplexType type, MemberMapping[] members, string name, string ns, bool hasSimpleContent, bool openModel)
		{
			XmlSchemaGroupBase xmlSchemaGroupBase = new XmlSchemaSequence();
			TypeMapping typeMapping = null;
			foreach (MemberMapping memberMapping in members)
			{
				if (memberMapping.Ignore)
				{
					continue;
				}
				if (memberMapping.Text != null)
				{
					if (typeMapping != null)
					{
						throw new InvalidOperationException(Res.GetString("XmlIllegalMultipleText", name));
					}
					typeMapping = memberMapping.Text.Mapping;
				}
				if (memberMapping.Elements.Length > 0)
				{
					bool repeats = memberMapping.TypeDesc.IsArrayLike && (memberMapping.Elements.Length != 1 || !(memberMapping.Elements[0].Mapping is ArrayMapping));
					bool valueTypeOptional = memberMapping.CheckSpecified != 0 || memberMapping.CheckShouldPersist;
					ExportElementAccessors(xmlSchemaGroupBase, memberMapping.Elements, repeats, valueTypeOptional, ns);
				}
			}
			if (xmlSchemaGroupBase.Items.Count > 0)
			{
				if (type.ContentModel != null)
				{
					if (type.ContentModel.Content is XmlSchemaComplexContentRestriction)
					{
						((XmlSchemaComplexContentRestriction)type.ContentModel.Content).Particle = xmlSchemaGroupBase;
					}
					else
					{
						if (!(type.ContentModel.Content is XmlSchemaComplexContentExtension))
						{
							throw new InvalidOperationException(Res.GetString("XmlInvalidContent", type.ContentModel.Content.GetType().Name));
						}
						((XmlSchemaComplexContentExtension)type.ContentModel.Content).Particle = xmlSchemaGroupBase;
					}
				}
				else
				{
					type.Particle = xmlSchemaGroupBase;
				}
			}
			if (typeMapping != null)
			{
				if (hasSimpleContent)
				{
					if (typeMapping is PrimitiveMapping && xmlSchemaGroupBase.Items.Count == 0)
					{
						PrimitiveMapping primitiveMapping = (PrimitiveMapping)typeMapping;
						if (primitiveMapping.IsList)
						{
							type.IsMixed = true;
						}
						else
						{
							if (primitiveMapping.IsAnonymousType)
							{
								throw new InvalidOperationException(Res.GetString("XmlAnonymousBaseType", typeMapping.TypeDesc.Name, primitiveMapping.TypeDesc.Name, "AnonymousType", "false"));
							}
							XmlSchemaSimpleContent xmlSchemaSimpleContent = new XmlSchemaSimpleContent();
							XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = (XmlSchemaSimpleContentExtension)(xmlSchemaSimpleContent.Content = new XmlSchemaSimpleContentExtension());
							type.ContentModel = xmlSchemaSimpleContent;
							xmlSchemaSimpleContentExtension.BaseTypeName = ExportPrimitiveMapping(primitiveMapping, ns);
						}
					}
				}
				else
				{
					type.IsMixed = true;
				}
			}
			bool flag = false;
			for (int j = 0; j < members.Length; j++)
			{
				AttributeAccessor attribute = members[j].Attribute;
				if (attribute != null)
				{
					ExportAttributeAccessor(type, members[j].Attribute, members[j].CheckSpecified != 0 || members[j].CheckShouldPersist, ns);
					if (members[j].Attribute.Any)
					{
						flag = true;
					}
				}
			}
			if (openModel && !flag)
			{
				AttributeAccessor attributeAccessor = new AttributeAccessor();
				attributeAccessor.Any = true;
				ExportAttributeAccessor(type, attributeAccessor, valueTypeOptional: false, ns);
			}
		}

		private void ExportDerivedMappings(StructMapping mapping)
		{
			if (mapping.IsAnonymousType)
			{
				return;
			}
			for (StructMapping structMapping = mapping.DerivedMappings; structMapping != null; structMapping = structMapping.NextDerivedMapping)
			{
				if (structMapping.IncludeInSchema)
				{
					ExportStructMapping(structMapping, structMapping.Namespace, null);
				}
			}
		}

		private XmlSchemaType ExportEnumMapping(EnumMapping mapping, string ns)
		{
			if (!mapping.IncludeInSchema)
			{
				throw new InvalidOperationException(Res.GetString("XmlCannotIncludeInSchema", mapping.TypeDesc.Name));
			}
			XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)types[mapping];
			if (xmlSchemaSimpleType == null)
			{
				CheckForDuplicateType(mapping, mapping.Namespace);
				xmlSchemaSimpleType = new XmlSchemaSimpleType();
				xmlSchemaSimpleType.Name = mapping.TypeName;
				if (!mapping.IsAnonymousType)
				{
					types.Add(mapping, xmlSchemaSimpleType);
					AddSchemaItem(xmlSchemaSimpleType, mapping.Namespace, ns);
				}
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = new XmlSchemaSimpleTypeRestriction();
				xmlSchemaSimpleTypeRestriction.BaseTypeName = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
				for (int i = 0; i < mapping.Constants.Length; i++)
				{
					ConstantMapping constantMapping = mapping.Constants[i];
					XmlSchemaEnumerationFacet xmlSchemaEnumerationFacet = new XmlSchemaEnumerationFacet();
					xmlSchemaEnumerationFacet.Value = constantMapping.XmlName;
					xmlSchemaSimpleTypeRestriction.Facets.Add(xmlSchemaEnumerationFacet);
				}
				if (!mapping.IsFlags)
				{
					xmlSchemaSimpleType.Content = xmlSchemaSimpleTypeRestriction;
				}
				else
				{
					XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = new XmlSchemaSimpleTypeList();
					XmlSchemaSimpleType xmlSchemaSimpleType2 = new XmlSchemaSimpleType();
					xmlSchemaSimpleType2.Content = xmlSchemaSimpleTypeRestriction;
					xmlSchemaSimpleTypeList.ItemType = xmlSchemaSimpleType2;
					xmlSchemaSimpleType.Content = xmlSchemaSimpleTypeList;
				}
			}
			if (!mapping.IsAnonymousType)
			{
				AddSchemaImport(mapping.Namespace, ns);
			}
			return xmlSchemaSimpleType;
		}

		private void AddXmlnsAnnotation(XmlSchemaComplexType type, string xmlnsMemberName)
		{
			XmlSchemaAnnotation xmlSchemaAnnotation = new XmlSchemaAnnotation();
			XmlSchemaAppInfo xmlSchemaAppInfo = new XmlSchemaAppInfo();
			XmlDocument xmlDocument = new XmlDocument();
			XmlElement xmlElement = xmlDocument.CreateElement("keepNamespaceDeclarations");
			if (xmlnsMemberName != null)
			{
				xmlElement.InsertBefore(xmlDocument.CreateTextNode(xmlnsMemberName), null);
			}
			xmlSchemaAppInfo.Markup = new XmlNode[1] { xmlElement };
			xmlSchemaAnnotation.Items.Add(xmlSchemaAppInfo);
			type.Annotation = xmlSchemaAnnotation;
		}
	}
	public class XmlSchemaImporter : SchemaImporter
	{
		private class TypeItems
		{
			internal XmlSchemaObjectCollection Attributes = new XmlSchemaObjectCollection();

			internal XmlSchemaAnyAttribute AnyAttribute;

			internal XmlSchemaGroupBase Particle;

			internal XmlQualifiedName baseSimpleType;

			internal bool IsUnbounded;
		}

		internal class ElementComparer : IComparer
		{
			public int Compare(object o1, object o2)
			{
				ElementAccessor elementAccessor = (ElementAccessor)o1;
				ElementAccessor elementAccessor2 = (ElementAccessor)o2;
				return string.Compare(elementAccessor.ToString(string.Empty), elementAccessor2.ToString(string.Empty), StringComparison.Ordinal);
			}
		}

		internal bool GenerateOrder => (base.Options & CodeGenerationOptions.GenerateOrder) != 0;

		public XmlSchemaImporter(XmlSchemas schemas)
			: base(schemas, CodeGenerationOptions.GenerateProperties, null, new ImportContext())
		{
		}

		public XmlSchemaImporter(XmlSchemas schemas, CodeIdentifiers typeIdentifiers)
			: base(schemas, CodeGenerationOptions.GenerateProperties, null, new ImportContext(typeIdentifiers, shareTypes: false))
		{
		}

		public XmlSchemaImporter(XmlSchemas schemas, CodeIdentifiers typeIdentifiers, CodeGenerationOptions options)
			: base(schemas, options, null, new ImportContext(typeIdentifiers, shareTypes: false))
		{
		}

		public XmlSchemaImporter(XmlSchemas schemas, CodeGenerationOptions options, ImportContext context)
			: base(schemas, options, null, context)
		{
		}

		public XmlSchemaImporter(XmlSchemas schemas, CodeGenerationOptions options, CodeDomProvider codeProvider, ImportContext context)
			: base(schemas, options, codeProvider, context)
		{
		}

		public XmlTypeMapping ImportDerivedTypeMapping(XmlQualifiedName name, Type baseType)
		{
			return ImportDerivedTypeMapping(name, baseType, baseTypeCanBeIndirect: false);
		}

		internal TypeMapping GetDefaultMapping(TypeFlags flags)
		{
			PrimitiveMapping primitiveMapping = new PrimitiveMapping();
			primitiveMapping.TypeDesc = base.Scope.GetTypeDesc("string", "http://www.w3.org/2001/XMLSchema", flags);
			primitiveMapping.TypeName = primitiveMapping.TypeDesc.DataType.Name;
			primitiveMapping.Namespace = "http://www.w3.org/2001/XMLSchema";
			return primitiveMapping;
		}

		public XmlTypeMapping ImportDerivedTypeMapping(XmlQualifiedName name, Type baseType, bool baseTypeCanBeIndirect)
		{
			ElementAccessor elementAccessor = ImportElement(name, typeof(TypeMapping), baseType);
			if (elementAccessor.Mapping is StructMapping)
			{
				MakeDerived((StructMapping)elementAccessor.Mapping, baseType, baseTypeCanBeIndirect);
			}
			else if (baseType != null)
			{
				if (!(elementAccessor.Mapping is ArrayMapping))
				{
					throw new InvalidOperationException(Res.GetString("XmlBadBaseElement", name.Name, name.Namespace, baseType.FullName));
				}
				elementAccessor.Mapping = ((ArrayMapping)elementAccessor.Mapping).TopLevelMapping;
				MakeDerived((StructMapping)elementAccessor.Mapping, baseType, baseTypeCanBeIndirect);
			}
			return new XmlTypeMapping(base.Scope, elementAccessor);
		}

		public XmlTypeMapping ImportSchemaType(XmlQualifiedName typeName)
		{
			return ImportSchemaType(typeName, null, baseTypeCanBeIndirect: false);
		}

		public XmlTypeMapping ImportSchemaType(XmlQualifiedName typeName, Type baseType)
		{
			return ImportSchemaType(typeName, baseType, baseTypeCanBeIndirect: false);
		}

		public XmlTypeMapping ImportSchemaType(XmlQualifiedName typeName, Type baseType, bool baseTypeCanBeIndirect)
		{
			TypeMapping typeMapping = ImportType(typeName, typeof(TypeMapping), baseType, TypeFlags.CanBeElementValue, addref: true);
			typeMapping.ReferencedByElement = false;
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.IsTopLevelInSchema = true;
			elementAccessor.Name = typeName.Name;
			elementAccessor.Namespace = typeName.Namespace;
			elementAccessor.Mapping = typeMapping;
			if (typeMapping is SpecialMapping && ((SpecialMapping)typeMapping).NamedAny)
			{
				elementAccessor.Any = true;
			}
			elementAccessor.IsNullable = typeMapping.TypeDesc.IsNullable;
			elementAccessor.Form = XmlSchemaForm.Qualified;
			if (elementAccessor.Mapping is StructMapping)
			{
				MakeDerived((StructMapping)elementAccessor.Mapping, baseType, baseTypeCanBeIndirect);
			}
			else if (baseType != null)
			{
				if (!(elementAccessor.Mapping is ArrayMapping))
				{
					throw new InvalidOperationException(Res.GetString("XmlBadBaseType", typeName.Name, typeName.Namespace, baseType.FullName));
				}
				elementAccessor.Mapping = ((ArrayMapping)elementAccessor.Mapping).TopLevelMapping;
				MakeDerived((StructMapping)elementAccessor.Mapping, baseType, baseTypeCanBeIndirect);
			}
			return new XmlTypeMapping(base.Scope, elementAccessor);
		}

		public XmlTypeMapping ImportTypeMapping(XmlQualifiedName name)
		{
			return ImportDerivedTypeMapping(name, null);
		}

		public XmlMembersMapping ImportMembersMapping(XmlQualifiedName name)
		{
			return new XmlMembersMapping(base.Scope, ImportElement(name, typeof(MembersMapping), null), XmlMappingAccess.Read | XmlMappingAccess.Write);
		}

		public XmlMembersMapping ImportAnyType(XmlQualifiedName typeName, string elementName)
		{
			TypeMapping typeMapping = ImportType(typeName, typeof(MembersMapping), null, TypeFlags.CanBeElementValue, addref: true);
			MembersMapping membersMapping = typeMapping as MembersMapping;
			if (membersMapping == null)
			{
				XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();
				XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence)(xmlSchemaComplexType.Particle = new XmlSchemaSequence());
				XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
				xmlSchemaElement.Name = elementName;
				xmlSchemaElement.SchemaTypeName = typeName;
				xmlSchemaSequence.Items.Add(xmlSchemaElement);
				membersMapping = ImportMembersType(xmlSchemaComplexType, typeName.Namespace, elementName);
			}
			if (membersMapping.Members.Length != 1 || !membersMapping.Members[0].Accessor.Any)
			{
				return null;
			}
			membersMapping.Members[0].Name = elementName;
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.Name = elementName;
			elementAccessor.Namespace = typeName.Namespace;
			elementAccessor.Mapping = membersMapping;
			elementAccessor.Any = true;
			XmlSchemaObject xmlSchemaObject = base.Schemas.SchemaSet.GlobalTypes[typeName];
			if (xmlSchemaObject != null && xmlSchemaObject.Parent is XmlSchema xmlSchema)
			{
				elementAccessor.Form = ((xmlSchema.ElementFormDefault == XmlSchemaForm.None) ? XmlSchemaForm.Unqualified : xmlSchema.ElementFormDefault);
			}
			return new XmlMembersMapping(base.Scope, elementAccessor, XmlMappingAccess.Read | XmlMappingAccess.Write);
		}

		public XmlMembersMapping ImportMembersMapping(XmlQualifiedName[] names)
		{
			return ImportMembersMapping(names, null, baseTypeCanBeIndirect: false);
		}

		public XmlMembersMapping ImportMembersMapping(XmlQualifiedName[] names, Type baseType, bool baseTypeCanBeIndirect)
		{
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			codeIdentifiers.UseCamelCasing = true;
			MemberMapping[] array = new MemberMapping[names.Length];
			for (int i = 0; i < names.Length; i++)
			{
				XmlQualifiedName name = names[i];
				ElementAccessor elementAccessor = ImportElement(name, typeof(TypeMapping), baseType);
				if (baseType != null && elementAccessor.Mapping is StructMapping)
				{
					MakeDerived((StructMapping)elementAccessor.Mapping, baseType, baseTypeCanBeIndirect);
				}
				MemberMapping memberMapping = new MemberMapping();
				memberMapping.Name = CodeIdentifier.MakeValid(Accessor.UnescapeName(elementAccessor.Name));
				memberMapping.Name = codeIdentifiers.AddUnique(memberMapping.Name, memberMapping);
				memberMapping.TypeDesc = elementAccessor.Mapping.TypeDesc;
				memberMapping.Elements = new ElementAccessor[1] { elementAccessor };
				array[i] = memberMapping;
			}
			MembersMapping membersMapping = new MembersMapping();
			membersMapping.HasWrapperElement = false;
			membersMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(object[]));
			membersMapping.Members = array;
			ElementAccessor elementAccessor2 = new ElementAccessor();
			elementAccessor2.Mapping = membersMapping;
			return new XmlMembersMapping(base.Scope, elementAccessor2, XmlMappingAccess.Read | XmlMappingAccess.Write);
		}

		public XmlMembersMapping ImportMembersMapping(string name, string ns, SoapSchemaMember[] members)
		{
			XmlSchemaComplexType xmlSchemaComplexType = new XmlSchemaComplexType();
			XmlSchemaSequence xmlSchemaSequence = (XmlSchemaSequence)(xmlSchemaComplexType.Particle = new XmlSchemaSequence());
			foreach (SoapSchemaMember soapSchemaMember in members)
			{
				XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
				xmlSchemaElement.Name = soapSchemaMember.MemberName;
				xmlSchemaElement.SchemaTypeName = soapSchemaMember.MemberType;
				xmlSchemaSequence.Items.Add(xmlSchemaElement);
			}
			MembersMapping mapping = ImportMembersType(xmlSchemaComplexType, null, name);
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.Name = Accessor.EscapeName(name);
			elementAccessor.Namespace = ns;
			elementAccessor.Mapping = mapping;
			elementAccessor.IsNullable = false;
			elementAccessor.Form = XmlSchemaForm.Qualified;
			return new XmlMembersMapping(base.Scope, elementAccessor, XmlMappingAccess.Read | XmlMappingAccess.Write);
		}

		private ElementAccessor ImportElement(XmlQualifiedName name, Type desiredMappingType, Type baseType)
		{
			XmlSchemaElement xmlSchemaElement = FindElement(name);
			ElementAccessor elementAccessor = (ElementAccessor)base.ImportedElements[xmlSchemaElement];
			if (elementAccessor != null)
			{
				return elementAccessor;
			}
			elementAccessor = ImportElement(xmlSchemaElement, string.Empty, desiredMappingType, baseType, name.Namespace, topLevelElement: true);
			ElementAccessor elementAccessor2 = (ElementAccessor)base.ImportedElements[xmlSchemaElement];
			if (elementAccessor2 != null)
			{
				return elementAccessor2;
			}
			base.ImportedElements.Add(xmlSchemaElement, elementAccessor);
			return elementAccessor;
		}

		private ElementAccessor ImportElement(XmlSchemaElement element, string identifier, Type desiredMappingType, Type baseType, string ns, bool topLevelElement)
		{
			if (!element.RefName.IsEmpty)
			{
				ElementAccessor elementAccessor = ImportElement(element.RefName, desiredMappingType, baseType);
				if (element.IsMultipleOccurrence && elementAccessor.Mapping is ArrayMapping)
				{
					ElementAccessor elementAccessor2 = elementAccessor.Clone();
					elementAccessor2.IsTopLevelInSchema = false;
					elementAccessor2.Mapping.ReferencedByElement = true;
					return elementAccessor2;
				}
				return elementAccessor;
			}
			if (element.Name.Length == 0)
			{
				XmlQualifiedName parentName = XmlSchemas.GetParentName(element);
				throw new InvalidOperationException(Res.GetString("XmlElementHasNoName", parentName.Name, parentName.Namespace));
			}
			string identifier2 = Accessor.UnescapeName(element.Name);
			identifier = ((identifier.Length != 0) ? (identifier + CodeIdentifier.MakePascal(identifier2)) : CodeIdentifier.MakeValid(identifier2));
			TypeMapping typeMapping = ImportElementType(element, identifier, desiredMappingType, baseType, ns);
			ElementAccessor elementAccessor3 = new ElementAccessor();
			elementAccessor3.IsTopLevelInSchema = element.Parent is XmlSchema;
			elementAccessor3.Name = element.Name;
			elementAccessor3.Namespace = ns;
			elementAccessor3.Mapping = typeMapping;
			elementAccessor3.IsOptional = element.MinOccurs == 0m;
			if (element.DefaultValue != null)
			{
				elementAccessor3.Default = element.DefaultValue;
			}
			else if (element.FixedValue != null)
			{
				elementAccessor3.Default = element.FixedValue;
				elementAccessor3.IsFixed = true;
			}
			if (typeMapping is SpecialMapping && ((SpecialMapping)typeMapping).NamedAny)
			{
				elementAccessor3.Any = true;
			}
			elementAccessor3.IsNullable = element.IsNillable;
			if (topLevelElement)
			{
				elementAccessor3.Form = XmlSchemaForm.Qualified;
			}
			else
			{
				elementAccessor3.Form = ElementForm(ns, element);
			}
			return elementAccessor3;
		}

		private TypeMapping ImportElementType(XmlSchemaElement element, string identifier, Type desiredMappingType, Type baseType, string ns)
		{
			TypeMapping typeMapping;
			if (!element.SchemaTypeName.IsEmpty)
			{
				typeMapping = ImportType(element.SchemaTypeName, desiredMappingType, baseType, TypeFlags.CanBeElementValue, addref: false);
				if (!typeMapping.ReferencedByElement)
				{
					object obj = FindType(element.SchemaTypeName, TypeFlags.CanBeElementValue);
					XmlSchemaObject xmlSchemaObject = element;
					while (xmlSchemaObject.Parent != null && obj != xmlSchemaObject)
					{
						xmlSchemaObject = xmlSchemaObject.Parent;
					}
					typeMapping.ReferencedByElement = obj != xmlSchemaObject;
				}
			}
			else if (element.SchemaType == null)
			{
				typeMapping = ((!element.SubstitutionGroup.IsEmpty) ? ImportElementType(FindElement(element.SubstitutionGroup), identifier, desiredMappingType, baseType, ns) : ((desiredMappingType != typeof(MembersMapping)) ? ((TypeMapping)ImportRootMapping()) : ((TypeMapping)ImportMembersType(new XmlSchemaType(), ns, identifier))));
			}
			else
			{
				typeMapping = ((!(element.SchemaType is XmlSchemaComplexType)) ? ImportDataType((XmlSchemaSimpleType)element.SchemaType, ns, identifier, baseType, (TypeFlags)56, isList: false) : ImportType((XmlSchemaComplexType)element.SchemaType, ns, identifier, desiredMappingType, baseType, TypeFlags.CanBeElementValue));
				typeMapping.ReferencedByElement = true;
			}
			if (!desiredMappingType.IsAssignableFrom(typeMapping.GetType()))
			{
				throw new InvalidOperationException(Res.GetString("XmlElementImportedTwice", element.Name, ns, typeMapping.GetType().Name, desiredMappingType.Name));
			}
			if (!typeMapping.TypeDesc.IsMappedType)
			{
				RunSchemaExtensions(typeMapping, element.SchemaTypeName, element.SchemaType, element, TypeFlags.CanBeElementValue);
			}
			return typeMapping;
		}

		private void RunSchemaExtensions(TypeMapping mapping, XmlQualifiedName qname, XmlSchemaType type, XmlSchemaObject context, TypeFlags flags)
		{
			string text = null;
			SchemaImporterExtension extension = null;
			CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
			CodeNamespace codeNamespace = new CodeNamespace();
			codeCompileUnit.Namespaces.Add(codeNamespace);
			if (!qname.IsEmpty)
			{
				text = FindExtendedType(qname.Name, qname.Namespace, context, codeCompileUnit, codeNamespace, out extension);
			}
			else if (type != null)
			{
				text = FindExtendedType(type, context, codeCompileUnit, codeNamespace, out extension);
			}
			else if (context is XmlSchemaAny)
			{
				text = FindExtendedAnyElement((XmlSchemaAny)context, (flags & TypeFlags.CanBeTextValue) != 0, codeCompileUnit, codeNamespace, out extension);
			}
			if (text == null || text.Length <= 0)
			{
				return;
			}
			text = text.Replace('+', '.');
			try
			{
				CodeGenerator.ValidateIdentifiers(new CodeTypeReference(text));
			}
			catch (ArgumentException)
			{
				if (qname.IsEmpty)
				{
					throw new InvalidOperationException(Res.GetString("XmlImporterExtensionBadLocalTypeName", extension.GetType().FullName, text));
				}
				throw new InvalidOperationException(Res.GetString("XmlImporterExtensionBadTypeName", extension.GetType().FullName, qname.Name, qname.Namespace, text));
			}
			foreach (CodeNamespace @namespace in codeCompileUnit.Namespaces)
			{
				CodeGenerator.ValidateIdentifiers(@namespace);
			}
			mapping.TypeDesc = mapping.TypeDesc.CreateMappedTypeDesc(new MappedTypeDesc(text, qname.Name, qname.Namespace, type, context, extension, codeNamespace, codeCompileUnit.ReferencedAssemblies));
			if (mapping is ArrayMapping)
			{
				TypeMapping topLevelMapping = ((ArrayMapping)mapping).TopLevelMapping;
				topLevelMapping.TypeName = mapping.TypeName;
				topLevelMapping.TypeDesc = mapping.TypeDesc;
			}
			else
			{
				mapping.TypeName = (qname.IsEmpty ? null : text);
			}
		}

		private string GenerateUniqueTypeName(string desiredName, string ns)
		{
			int num = 1;
			string text = desiredName;
			while (true)
			{
				XmlQualifiedName name = new XmlQualifiedName(text, ns);
				object obj = base.Schemas.Find(name, typeof(XmlSchemaType));
				if (obj == null)
				{
					break;
				}
				text = desiredName + num.ToString(CultureInfo.InvariantCulture);
				num++;
			}
			text = CodeIdentifier.MakeValid(text);
			return base.TypeIdentifiers.AddUnique(text, text);
		}

		[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
		internal override void ImportDerivedTypes(XmlQualifiedName baseName)
		{
			foreach (XmlSchema schema in base.Schemas)
			{
				if (base.Schemas.IsReference(schema) || XmlSchemas.IsDataSet(schema))
				{
					continue;
				}
				XmlSchemas.Preprocess(schema);
				foreach (object value in schema.SchemaTypes.Values)
				{
					if (value is XmlSchemaType)
					{
						XmlSchemaType xmlSchemaType = (XmlSchemaType)value;
						if (xmlSchemaType.DerivedFrom == baseName && base.TypesInUse[xmlSchemaType.Name, schema.TargetNamespace] == null)
						{
							ImportType(xmlSchemaType.QualifiedName, typeof(TypeMapping), null, TypeFlags.CanBeElementValue, addref: false);
						}
					}
				}
			}
		}

		private TypeMapping ImportType(XmlQualifiedName name, Type desiredMappingType, Type baseType, TypeFlags flags, bool addref)
		{
			if (name.Name == "anyType" && name.Namespace == "http://www.w3.org/2001/XMLSchema")
			{
				return ImportRootMapping();
			}
			object obj = FindType(name, flags);
			TypeMapping typeMapping = (TypeMapping)base.ImportedMappings[obj];
			if (typeMapping != null && desiredMappingType.IsAssignableFrom(typeMapping.GetType()))
			{
				return typeMapping;
			}
			if (addref)
			{
				AddReference(name, base.TypesInUse, "XmlCircularTypeReference");
			}
			if (obj is XmlSchemaComplexType)
			{
				typeMapping = ImportType((XmlSchemaComplexType)obj, name.Namespace, name.Name, desiredMappingType, baseType, flags);
			}
			else
			{
				if (!(obj is XmlSchemaSimpleType))
				{
					throw new InvalidOperationException(Res.GetString("XmlInternalError"));
				}
				typeMapping = ImportDataType((XmlSchemaSimpleType)obj, name.Namespace, name.Name, baseType, flags, isList: false);
			}
			if (addref && name.Namespace != "http://www.w3.org/2001/XMLSchema")
			{
				RemoveReference(name, base.TypesInUse);
			}
			return typeMapping;
		}

		private TypeMapping ImportType(XmlSchemaComplexType type, string typeNs, string identifier, Type desiredMappingType, Type baseType, TypeFlags flags)
		{
			if (type.Redefined != null)
			{
				throw new NotSupportedException(Res.GetString("XmlUnsupportedRedefine", type.Name, typeNs));
			}
			if (desiredMappingType == typeof(TypeMapping))
			{
				TypeMapping typeMapping = null;
				if (baseType == null && (typeMapping = ImportArrayMapping(type, identifier, typeNs, repeats: false)) == null)
				{
					typeMapping = ImportAnyMapping(type, identifier, typeNs, repeats: false);
				}
				if (typeMapping == null)
				{
					typeMapping = ImportStructType(type, typeNs, identifier, baseType, arrayLike: false);
					if (typeMapping != null && type.Name != null && type.Name.Length != 0)
					{
						ImportDerivedTypes(new XmlQualifiedName(identifier, typeNs));
					}
				}
				return typeMapping;
			}
			if (desiredMappingType == typeof(MembersMapping))
			{
				return ImportMembersType(type, typeNs, identifier);
			}
			throw new ArgumentException(Res.GetString("XmlInternalError"), "desiredMappingType");
		}

		private MembersMapping ImportMembersType(XmlSchemaType type, string typeNs, string identifier)
		{
			if (!type.DerivedFrom.IsEmpty)
			{
				throw new InvalidOperationException(Res.GetString("XmlMembersDeriveError"));
			}
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			codeIdentifiers.UseCamelCasing = true;
			bool needExplicitOrder = false;
			MemberMapping[] members = ImportTypeMembers(type, typeNs, identifier, codeIdentifiers, new CodeIdentifiers(), new NameTable(), ref needExplicitOrder, order: false, allowUnboundedElements: false);
			MembersMapping membersMapping = new MembersMapping();
			membersMapping.HasWrapperElement = true;
			membersMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(object[]));
			membersMapping.Members = members;
			return membersMapping;
		}

		private StructMapping ImportStructType(XmlSchemaType type, string typeNs, string identifier, Type baseType, bool arrayLike)
		{
			TypeDesc typeDesc = null;
			TypeMapping typeMapping = null;
			bool flag = false;
			if (!type.DerivedFrom.IsEmpty)
			{
				typeMapping = ImportType(type.DerivedFrom, typeof(TypeMapping), null, (TypeFlags)48, addref: false);
				if (typeMapping is StructMapping)
				{
					typeDesc = ((StructMapping)typeMapping).TypeDesc;
				}
				else if (typeMapping is ArrayMapping)
				{
					typeMapping = ((ArrayMapping)typeMapping).TopLevelMapping;
					if (typeMapping != null)
					{
						typeMapping.ReferencedByTopLevelElement = false;
						typeMapping.ReferencedByElement = true;
						typeDesc = typeMapping.TypeDesc;
					}
				}
				else
				{
					typeMapping = null;
				}
			}
			if (typeDesc == null && baseType != null)
			{
				typeDesc = base.Scope.GetTypeDesc(baseType);
			}
			if (typeMapping == null)
			{
				typeMapping = GetRootMapping();
				flag = true;
			}
			Mapping mapping = (Mapping)base.ImportedMappings[type];
			if (mapping != null)
			{
				if (mapping is StructMapping)
				{
					return (StructMapping)mapping;
				}
				if (!arrayLike || !(mapping is ArrayMapping))
				{
					throw new InvalidOperationException(Res.GetString("XmlTypeUsedTwice", type.QualifiedName.Name, type.QualifiedName.Namespace));
				}
				ArrayMapping arrayMapping = (ArrayMapping)mapping;
				if (arrayMapping.TopLevelMapping != null)
				{
					return arrayMapping.TopLevelMapping;
				}
			}
			StructMapping structMapping = new StructMapping();
			structMapping.IsReference = base.Schemas.IsReference(type);
			TypeFlags typeFlags = TypeFlags.Reference;
			if (type is XmlSchemaComplexType && ((XmlSchemaComplexType)type).IsAbstract)
			{
				typeFlags |= TypeFlags.Abstract;
			}
			identifier = Accessor.UnescapeName(identifier);
			string text = ((type.Name == null || type.Name.Length == 0) ? GenerateUniqueTypeName(identifier, typeNs) : GenerateUniqueTypeName(identifier));
			structMapping.TypeDesc = new TypeDesc(text, text, TypeKind.Struct, typeDesc, typeFlags);
			structMapping.Namespace = typeNs;
			structMapping.TypeName = ((type.Name == null || type.Name.Length == 0) ? null : identifier);
			structMapping.BaseMapping = (StructMapping)typeMapping;
			if (!arrayLike)
			{
				base.ImportedMappings.Add(type, structMapping);
			}
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			CodeIdentifiers codeIdentifiers2 = structMapping.BaseMapping.Scope.Clone();
			codeIdentifiers.AddReserved(text);
			codeIdentifiers2.AddReserved(text);
			AddReservedIdentifiersForDataBinding(codeIdentifiers);
			if (flag)
			{
				AddReservedIdentifiersForDataBinding(codeIdentifiers2);
			}
			bool needExplicitOrder = false;
			structMapping.Members = ImportTypeMembers(type, typeNs, identifier, codeIdentifiers, codeIdentifiers2, structMapping, ref needExplicitOrder, order: true, allowUnboundedElements: true);
			if (!IsAllGroup(type))
			{
				if (needExplicitOrder && !GenerateOrder)
				{
					structMapping.SetSequence();
				}
				else if (GenerateOrder)
				{
					structMapping.IsSequence = true;
				}
			}
			for (int i = 0; i < structMapping.Members.Length; i++)
			{
				StructMapping declaringMapping;
				MemberMapping memberMapping = ((StructMapping)typeMapping).FindDeclaringMapping(structMapping.Members[i], out declaringMapping, structMapping.TypeName);
				if (memberMapping != null && memberMapping.TypeDesc != structMapping.Members[i].TypeDesc)
				{
					throw new InvalidOperationException(Res.GetString("XmlIllegalOverride", type.Name, memberMapping.Name, memberMapping.TypeDesc.FullName, structMapping.Members[i].TypeDesc.FullName, declaringMapping.TypeDesc.FullName));
				}
			}
			structMapping.Scope = codeIdentifiers2;
			base.Scope.AddTypeMapping(structMapping);
			return structMapping;
		}

		private bool IsAllGroup(XmlSchemaType type)
		{
			TypeItems typeItems = GetTypeItems(type);
			if (typeItems.Particle != null)
			{
				return typeItems.Particle is XmlSchemaAll;
			}
			return false;
		}

		private StructMapping ImportStructDataType(XmlSchemaSimpleType dataType, string typeNs, string identifier, Type baseType)
		{
			identifier = Accessor.UnescapeName(identifier);
			string text = GenerateUniqueTypeName(identifier);
			StructMapping structMapping = new StructMapping();
			structMapping.IsReference = base.Schemas.IsReference(dataType);
			TypeFlags flags = TypeFlags.Reference;
			TypeDesc typeDesc = base.Scope.GetTypeDesc(baseType);
			structMapping.TypeDesc = new TypeDesc(text, text, TypeKind.Struct, typeDesc, flags);
			structMapping.Namespace = typeNs;
			structMapping.TypeName = identifier;
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			codeIdentifiers.AddReserved(text);
			AddReservedIdentifiersForDataBinding(codeIdentifiers);
			ImportTextMember(codeIdentifiers, new CodeIdentifiers(), null);
			structMapping.Members = (MemberMapping[])codeIdentifiers.ToArray(typeof(MemberMapping));
			structMapping.Scope = codeIdentifiers;
			base.Scope.AddTypeMapping(structMapping);
			return structMapping;
		}

		private MemberMapping[] ImportTypeMembers(XmlSchemaType type, string typeNs, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, INameScope elementsScope, ref bool needExplicitOrder, bool order, bool allowUnboundedElements)
		{
			TypeItems typeItems = GetTypeItems(type);
			bool flag = IsMixed(type);
			if (flag)
			{
				XmlSchemaType xmlSchemaType = type;
				while (!xmlSchemaType.DerivedFrom.IsEmpty)
				{
					xmlSchemaType = FindType(xmlSchemaType.DerivedFrom, (TypeFlags)48);
					if (IsMixed(xmlSchemaType))
					{
						flag = false;
						break;
					}
				}
			}
			if (typeItems.Particle != null)
			{
				ImportGroup(typeItems.Particle, identifier, members, membersScope, elementsScope, typeNs, flag, ref needExplicitOrder, order, typeItems.IsUnbounded, allowUnboundedElements);
			}
			for (int i = 0; i < typeItems.Attributes.Count; i++)
			{
				object obj = typeItems.Attributes[i];
				if (obj is XmlSchemaAttribute)
				{
					ImportAttributeMember((XmlSchemaAttribute)obj, identifier, members, membersScope, typeNs);
				}
				else if (obj is XmlSchemaAttributeGroupRef)
				{
					XmlQualifiedName refName = ((XmlSchemaAttributeGroupRef)obj).RefName;
					ImportAttributeGroupMembers(FindAttributeGroup(refName), identifier, members, membersScope, refName.Namespace);
				}
			}
			if (typeItems.AnyAttribute != null)
			{
				ImportAnyAttributeMember(typeItems.AnyAttribute, members, membersScope);
			}
			if (typeItems.baseSimpleType != null || (typeItems.Particle == null && flag))
			{
				ImportTextMember(members, membersScope, flag ? null : typeItems.baseSimpleType);
			}
			ImportXmlnsDeclarationsMember(type, members, membersScope);
			return (MemberMapping[])members.ToArray(typeof(MemberMapping));
		}

		internal static bool IsMixed(XmlSchemaType type)
		{
			if (!(type is XmlSchemaComplexType))
			{
				return false;
			}
			XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)type;
			bool isMixed = xmlSchemaComplexType.IsMixed;
			if (!isMixed && xmlSchemaComplexType.ContentModel != null && xmlSchemaComplexType.ContentModel is XmlSchemaComplexContent)
			{
				isMixed = ((XmlSchemaComplexContent)xmlSchemaComplexType.ContentModel).IsMixed;
			}
			return isMixed;
		}

		private TypeItems GetTypeItems(XmlSchemaType type)
		{
			TypeItems typeItems = new TypeItems();
			if (type is XmlSchemaComplexType)
			{
				XmlSchemaParticle xmlSchemaParticle = null;
				XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)type;
				if (xmlSchemaComplexType.ContentModel != null)
				{
					XmlSchemaContent content = xmlSchemaComplexType.ContentModel.Content;
					if (content is XmlSchemaComplexContentExtension)
					{
						XmlSchemaComplexContentExtension xmlSchemaComplexContentExtension = (XmlSchemaComplexContentExtension)content;
						typeItems.Attributes = xmlSchemaComplexContentExtension.Attributes;
						typeItems.AnyAttribute = xmlSchemaComplexContentExtension.AnyAttribute;
						xmlSchemaParticle = xmlSchemaComplexContentExtension.Particle;
					}
					else if (content is XmlSchemaSimpleContentExtension)
					{
						XmlSchemaSimpleContentExtension xmlSchemaSimpleContentExtension = (XmlSchemaSimpleContentExtension)content;
						typeItems.Attributes = xmlSchemaSimpleContentExtension.Attributes;
						typeItems.AnyAttribute = xmlSchemaSimpleContentExtension.AnyAttribute;
						typeItems.baseSimpleType = xmlSchemaSimpleContentExtension.BaseTypeName;
					}
				}
				else
				{
					typeItems.Attributes = xmlSchemaComplexType.Attributes;
					typeItems.AnyAttribute = xmlSchemaComplexType.AnyAttribute;
					xmlSchemaParticle = xmlSchemaComplexType.Particle;
				}
				if (xmlSchemaParticle is XmlSchemaGroupRef)
				{
					XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef)xmlSchemaParticle;
					typeItems.Particle = FindGroup(xmlSchemaGroupRef.RefName).Particle;
					typeItems.IsUnbounded = xmlSchemaParticle.IsMultipleOccurrence;
				}
				else if (xmlSchemaParticle is XmlSchemaGroupBase)
				{
					typeItems.Particle = (XmlSchemaGroupBase)xmlSchemaParticle;
					typeItems.IsUnbounded = xmlSchemaParticle.IsMultipleOccurrence;
				}
			}
			return typeItems;
		}

		private void ImportGroup(XmlSchemaGroupBase group, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, INameScope elementsScope, string ns, bool mixed, ref bool needExplicitOrder, bool allowDuplicates, bool groupRepeats, bool allowUnboundedElements)
		{
			if (group is XmlSchemaChoice)
			{
				ImportChoiceGroup((XmlSchemaChoice)group, identifier, members, membersScope, elementsScope, ns, groupRepeats, ref needExplicitOrder, allowDuplicates);
			}
			else
			{
				ImportGroupMembers(group, identifier, members, membersScope, elementsScope, ns, groupRepeats, ref mixed, ref needExplicitOrder, allowDuplicates, allowUnboundedElements);
			}
			if (mixed)
			{
				ImportTextMember(members, membersScope, null);
			}
		}

		private MemberMapping ImportChoiceGroup(XmlSchemaGroupBase group, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, INameScope elementsScope, string ns, bool groupRepeats, ref bool needExplicitOrder, bool allowDuplicates)
		{
			NameTable nameTable = new NameTable();
			if (GatherGroupChoices(group, nameTable, identifier, ns, ref needExplicitOrder, allowDuplicates))
			{
				groupRepeats = true;
			}
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.Elements = (ElementAccessor[])nameTable.ToArray(typeof(ElementAccessor));
			Array.Sort(memberMapping.Elements, new ElementComparer());
			AddScopeElements(elementsScope, memberMapping.Elements, ref needExplicitOrder, allowDuplicates);
			bool flag = false;
			bool flag2 = false;
			Hashtable hashtable = new Hashtable(memberMapping.Elements.Length);
			for (int i = 0; i < memberMapping.Elements.Length; i++)
			{
				ElementAccessor elementAccessor = memberMapping.Elements[i];
				string fullName = elementAccessor.Mapping.TypeDesc.FullName;
				object obj = hashtable[fullName];
				if (obj != null)
				{
					flag = true;
					ElementAccessor elementAccessor2 = (ElementAccessor)obj;
					if (!flag2 && elementAccessor2.IsNullable != elementAccessor.IsNullable)
					{
						flag2 = true;
					}
				}
				else
				{
					hashtable.Add(fullName, elementAccessor);
				}
				if (elementAccessor.Mapping is ArrayMapping arrayMapping && IsNeedXmlSerializationAttributes(arrayMapping))
				{
					elementAccessor.Mapping = arrayMapping.TopLevelMapping;
					elementAccessor.Mapping.ReferencedByTopLevelElement = false;
					elementAccessor.Mapping.ReferencedByElement = true;
				}
			}
			if (flag2)
			{
				memberMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(object));
			}
			else
			{
				TypeDesc[] array = new TypeDesc[hashtable.Count];
				IEnumerator enumerator = hashtable.Values.GetEnumerator();
				for (int j = 0; j < array.Length; j++)
				{
					if (!enumerator.MoveNext())
					{
						break;
					}
					array[j] = ((ElementAccessor)enumerator.Current).Mapping.TypeDesc;
				}
				memberMapping.TypeDesc = TypeDesc.FindCommonBaseTypeDesc(array);
				if (memberMapping.TypeDesc == null)
				{
					memberMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(object));
				}
			}
			if (groupRepeats)
			{
				memberMapping.TypeDesc = memberMapping.TypeDesc.CreateArrayTypeDesc();
			}
			if (membersScope != null)
			{
				memberMapping.Name = membersScope.AddUnique(groupRepeats ? "Items" : "Item", memberMapping);
				members?.Add(memberMapping.Name, memberMapping);
			}
			if (flag)
			{
				memberMapping.ChoiceIdentifier = new ChoiceIdentifierAccessor();
				memberMapping.ChoiceIdentifier.MemberName = memberMapping.Name + "ElementName";
				memberMapping.ChoiceIdentifier.Mapping = ImportEnumeratedChoice(memberMapping.Elements, ns, memberMapping.Name + "ChoiceType");
				memberMapping.ChoiceIdentifier.MemberIds = new string[memberMapping.Elements.Length];
				ConstantMapping[] constants = ((EnumMapping)memberMapping.ChoiceIdentifier.Mapping).Constants;
				for (int k = 0; k < memberMapping.Elements.Length; k++)
				{
					memberMapping.ChoiceIdentifier.MemberIds[k] = constants[k].Name;
				}
				MemberMapping memberMapping2 = new MemberMapping();
				memberMapping2.Ignore = true;
				memberMapping2.Name = memberMapping.ChoiceIdentifier.MemberName;
				if (groupRepeats)
				{
					memberMapping2.TypeDesc = memberMapping.ChoiceIdentifier.Mapping.TypeDesc.CreateArrayTypeDesc();
				}
				else
				{
					memberMapping2.TypeDesc = memberMapping.ChoiceIdentifier.Mapping.TypeDesc;
				}
				ElementAccessor elementAccessor3 = new ElementAccessor();
				elementAccessor3.Name = memberMapping2.Name;
				elementAccessor3.Namespace = ns;
				elementAccessor3.Mapping = memberMapping.ChoiceIdentifier.Mapping;
				memberMapping2.Elements = new ElementAccessor[1] { elementAccessor3 };
				if (membersScope != null)
				{
					string text2 = (memberMapping.ChoiceIdentifier.MemberName = membersScope.AddUnique(memberMapping.ChoiceIdentifier.MemberName, memberMapping2));
					string text5 = (elementAccessor3.Name = (memberMapping2.Name = text2));
					members?.Add(elementAccessor3.Name, memberMapping2);
				}
			}
			return memberMapping;
		}

		private bool IsNeedXmlSerializationAttributes(ArrayMapping arrayMapping)
		{
			if (arrayMapping.Elements.Length != 1)
			{
				return true;
			}
			ElementAccessor elementAccessor = arrayMapping.Elements[0];
			TypeMapping mapping = elementAccessor.Mapping;
			if (elementAccessor.Name != mapping.DefaultElementName)
			{
				return true;
			}
			if (elementAccessor.Form != 0 && elementAccessor.Form != XmlSchemaForm.Qualified)
			{
				return true;
			}
			if (elementAccessor.Mapping.TypeDesc != null)
			{
				if (elementAccessor.IsNullable != elementAccessor.Mapping.TypeDesc.IsNullable)
				{
					return true;
				}
				if (elementAccessor.Mapping.TypeDesc.IsAmbiguousDataType)
				{
					return true;
				}
			}
			return false;
		}

		private bool GatherGroupChoices(XmlSchemaGroup group, NameTable choiceElements, string identifier, string ns, ref bool needExplicitOrder, bool allowDuplicates)
		{
			return GatherGroupChoices(group.Particle, choiceElements, identifier, ns, ref needExplicitOrder, allowDuplicates);
		}

		private bool GatherGroupChoices(XmlSchemaParticle particle, NameTable choiceElements, string identifier, string ns, ref bool needExplicitOrder, bool allowDuplicates)
		{
			if (particle is XmlSchemaGroupRef)
			{
				XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef)particle;
				if (!xmlSchemaGroupRef.RefName.IsEmpty)
				{
					AddReference(xmlSchemaGroupRef.RefName, base.GroupsInUse, "XmlCircularGroupReference");
					if (GatherGroupChoices(FindGroup(xmlSchemaGroupRef.RefName), choiceElements, identifier, xmlSchemaGroupRef.RefName.Namespace, ref needExplicitOrder, allowDuplicates))
					{
						RemoveReference(xmlSchemaGroupRef.RefName, base.GroupsInUse);
						return true;
					}
					RemoveReference(xmlSchemaGroupRef.RefName, base.GroupsInUse);
				}
			}
			else if (particle is XmlSchemaGroupBase)
			{
				XmlSchemaGroupBase xmlSchemaGroupBase = (XmlSchemaGroupBase)particle;
				bool flag = xmlSchemaGroupBase.IsMultipleOccurrence;
				XmlSchemaAny xmlSchemaAny = null;
				bool duplicateElements = false;
				for (int i = 0; i < xmlSchemaGroupBase.Items.Count; i++)
				{
					object obj = xmlSchemaGroupBase.Items[i];
					if (obj is XmlSchemaGroupBase || obj is XmlSchemaGroupRef)
					{
						if (GatherGroupChoices((XmlSchemaParticle)obj, choiceElements, identifier, ns, ref needExplicitOrder, allowDuplicates))
						{
							flag = true;
						}
					}
					else if (obj is XmlSchemaAny)
					{
						if (GenerateOrder)
						{
							AddScopeElements(choiceElements, ImportAny((XmlSchemaAny)obj, makeElement: true, ns), ref duplicateElements, allowDuplicates);
						}
						else
						{
							xmlSchemaAny = (XmlSchemaAny)obj;
						}
					}
					else
					{
						if (!(obj is XmlSchemaElement))
						{
							continue;
						}
						XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)obj;
						XmlSchemaElement topLevelElement = GetTopLevelElement(xmlSchemaElement);
						if (topLevelElement != null)
						{
							XmlSchemaElement[] equivalentElements = GetEquivalentElements(topLevelElement);
							for (int j = 0; j < equivalentElements.Length; j++)
							{
								if (equivalentElements[j].IsMultipleOccurrence)
								{
									flag = true;
								}
								AddScopeElement(choiceElements, ImportElement(equivalentElements[j], identifier, typeof(TypeMapping), null, equivalentElements[j].QualifiedName.Namespace, topLevelElement: true), ref duplicateElements, allowDuplicates);
							}
						}
						if (xmlSchemaElement.IsMultipleOccurrence)
						{
							flag = true;
						}
						AddScopeElement(choiceElements, ImportElement(xmlSchemaElement, identifier, typeof(TypeMapping), null, xmlSchemaElement.QualifiedName.Namespace, topLevelElement: false), ref duplicateElements, allowDuplicates);
					}
				}
				if (xmlSchemaAny != null)
				{
					AddScopeElements(choiceElements, ImportAny(xmlSchemaAny, makeElement: true, ns), ref duplicateElements, allowDuplicates);
				}
				if (!flag && !(xmlSchemaGroupBase is XmlSchemaChoice) && xmlSchemaGroupBase.Items.Count > 1)
				{
					flag = true;
				}
				return flag;
			}
			return false;
		}

		private void AddScopeElement(INameScope scope, ElementAccessor element, ref bool duplicateElements, bool allowDuplicates)
		{
			if (scope == null)
			{
				return;
			}
			ElementAccessor elementAccessor = (ElementAccessor)scope[element.Name, element.Namespace];
			if (elementAccessor != null)
			{
				if (!allowDuplicates)
				{
					throw new InvalidOperationException(Res.GetString("XmlDuplicateElementInScope", element.Name, element.Namespace));
				}
				if (elementAccessor.Mapping.TypeDesc != element.Mapping.TypeDesc)
				{
					throw new InvalidOperationException(Res.GetString("XmlDuplicateElementInScope1", element.Name, element.Namespace));
				}
				duplicateElements = true;
			}
			else
			{
				scope[element.Name, element.Namespace] = element;
			}
		}

		private void AddScopeElements(INameScope scope, ElementAccessor[] elements, ref bool duplicateElements, bool allowDuplicates)
		{
			for (int i = 0; i < elements.Length; i++)
			{
				AddScopeElement(scope, elements[i], ref duplicateElements, allowDuplicates);
			}
		}

		private void ImportGroupMembers(XmlSchemaParticle particle, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, INameScope elementsScope, string ns, bool groupRepeats, ref bool mixed, ref bool needExplicitOrder, bool allowDuplicates, bool allowUnboundedElements)
		{
			if (particle is XmlSchemaGroupRef)
			{
				XmlSchemaGroupRef xmlSchemaGroupRef = (XmlSchemaGroupRef)particle;
				if (!xmlSchemaGroupRef.RefName.IsEmpty)
				{
					AddReference(xmlSchemaGroupRef.RefName, base.GroupsInUse, "XmlCircularGroupReference");
					ImportGroupMembers(FindGroup(xmlSchemaGroupRef.RefName).Particle, identifier, members, membersScope, elementsScope, xmlSchemaGroupRef.RefName.Namespace, groupRepeats | xmlSchemaGroupRef.IsMultipleOccurrence, ref mixed, ref needExplicitOrder, allowDuplicates, allowUnboundedElements);
					RemoveReference(xmlSchemaGroupRef.RefName, base.GroupsInUse);
				}
			}
			else
			{
				if (!(particle is XmlSchemaGroupBase))
				{
					return;
				}
				XmlSchemaGroupBase xmlSchemaGroupBase = (XmlSchemaGroupBase)particle;
				if (xmlSchemaGroupBase.IsMultipleOccurrence)
				{
					groupRepeats = true;
				}
				if (GenerateOrder && groupRepeats && xmlSchemaGroupBase.Items.Count > 1)
				{
					ImportChoiceGroup(xmlSchemaGroupBase, identifier, members, membersScope, elementsScope, ns, groupRepeats, ref needExplicitOrder, allowDuplicates);
					return;
				}
				for (int i = 0; i < xmlSchemaGroupBase.Items.Count; i++)
				{
					object obj = xmlSchemaGroupBase.Items[i];
					if (obj is XmlSchemaChoice)
					{
						ImportChoiceGroup((XmlSchemaGroupBase)obj, identifier, members, membersScope, elementsScope, ns, groupRepeats, ref needExplicitOrder, allowDuplicates);
					}
					else if (obj is XmlSchemaElement)
					{
						ImportElementMember((XmlSchemaElement)obj, identifier, members, membersScope, elementsScope, ns, groupRepeats, ref needExplicitOrder, allowDuplicates, allowUnboundedElements);
					}
					else if (obj is XmlSchemaAny)
					{
						ImportAnyMember((XmlSchemaAny)obj, identifier, members, membersScope, elementsScope, ns, ref mixed, ref needExplicitOrder, allowDuplicates);
					}
					else if (obj is XmlSchemaParticle)
					{
						ImportGroupMembers((XmlSchemaParticle)obj, identifier, members, membersScope, elementsScope, ns, groupRepeats, ref mixed, ref needExplicitOrder, allowDuplicates, allowUnboundedElements: true);
					}
				}
			}
		}

		private XmlSchemaElement GetTopLevelElement(XmlSchemaElement element)
		{
			if (!element.RefName.IsEmpty)
			{
				return FindElement(element.RefName);
			}
			return null;
		}

		private XmlSchemaElement[] GetEquivalentElements(XmlSchemaElement element)
		{
			ArrayList arrayList = new ArrayList();
			foreach (XmlSchema item in base.Schemas.SchemaSet.Schemas())
			{
				for (int i = 0; i < item.Items.Count; i++)
				{
					object obj = item.Items[i];
					if (obj is XmlSchemaElement)
					{
						XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)obj;
						if (!xmlSchemaElement.IsAbstract && xmlSchemaElement.SubstitutionGroup.Namespace == item.TargetNamespace && xmlSchemaElement.SubstitutionGroup.Name == element.Name)
						{
							arrayList.Add(xmlSchemaElement);
						}
					}
				}
			}
			return (XmlSchemaElement[])arrayList.ToArray(typeof(XmlSchemaElement));
		}

		private bool ImportSubstitutionGroupMember(XmlSchemaElement element, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns, bool repeats, ref bool needExplicitOrder, bool allowDuplicates)
		{
			XmlSchemaElement[] equivalentElements = GetEquivalentElements(element);
			if (equivalentElements.Length == 0)
			{
				return false;
			}
			XmlSchemaChoice xmlSchemaChoice = new XmlSchemaChoice();
			for (int i = 0; i < equivalentElements.Length; i++)
			{
				xmlSchemaChoice.Items.Add(equivalentElements[i]);
			}
			if (!element.IsAbstract)
			{
				xmlSchemaChoice.Items.Add(element);
			}
			identifier = ((identifier.Length != 0) ? (identifier + CodeIdentifier.MakePascal(Accessor.UnescapeName(element.Name))) : CodeIdentifier.MakeValid(Accessor.UnescapeName(element.Name)));
			ImportChoiceGroup(xmlSchemaChoice, identifier, members, membersScope, null, ns, repeats, ref needExplicitOrder, allowDuplicates);
			return true;
		}

		private void ImportTextMember(CodeIdentifiers members, CodeIdentifiers membersScope, XmlQualifiedName simpleContentType)
		{
			bool flag = false;
			TypeMapping typeMapping;
			if (simpleContentType != null)
			{
				typeMapping = ImportType(simpleContentType, typeof(TypeMapping), null, (TypeFlags)48, addref: false);
				if (!(typeMapping is PrimitiveMapping) && !typeMapping.TypeDesc.CanBeTextValue)
				{
					return;
				}
			}
			else
			{
				flag = true;
				typeMapping = GetDefaultMapping((TypeFlags)48);
			}
			TextAccessor textAccessor = new TextAccessor();
			textAccessor.Mapping = typeMapping;
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.Elements = new ElementAccessor[0];
			memberMapping.Text = textAccessor;
			if (flag)
			{
				memberMapping.TypeDesc = textAccessor.Mapping.TypeDesc.CreateArrayTypeDesc();
				memberMapping.Name = members.MakeRightCase("Text");
			}
			else
			{
				PrimitiveMapping primitiveMapping = (PrimitiveMapping)textAccessor.Mapping;
				if (primitiveMapping.IsList)
				{
					memberMapping.TypeDesc = textAccessor.Mapping.TypeDesc.CreateArrayTypeDesc();
					memberMapping.Name = members.MakeRightCase("Text");
				}
				else
				{
					memberMapping.TypeDesc = textAccessor.Mapping.TypeDesc;
					memberMapping.Name = members.MakeRightCase("Value");
				}
			}
			memberMapping.Name = membersScope.AddUnique(memberMapping.Name, memberMapping);
			members.Add(memberMapping.Name, memberMapping);
		}

		private MemberMapping ImportAnyMember(XmlSchemaAny any, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, INameScope elementsScope, string ns, ref bool mixed, ref bool needExplicitOrder, bool allowDuplicates)
		{
			ElementAccessor[] array = ImportAny(any, !mixed, ns);
			AddScopeElements(elementsScope, array, ref needExplicitOrder, allowDuplicates);
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.Elements = array;
			memberMapping.Name = membersScope.MakeRightCase("Any");
			memberMapping.Name = membersScope.AddUnique(memberMapping.Name, memberMapping);
			members.Add(memberMapping.Name, memberMapping);
			memberMapping.TypeDesc = array[0].Mapping.TypeDesc;
			bool flag = any.IsMultipleOccurrence;
			if (mixed)
			{
				SpecialMapping specialMapping = new SpecialMapping();
				specialMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(XmlNode));
				specialMapping.TypeName = specialMapping.TypeDesc.Name;
				memberMapping.TypeDesc = specialMapping.TypeDesc;
				TextAccessor textAccessor = new TextAccessor();
				textAccessor.Mapping = specialMapping;
				memberMapping.Text = textAccessor;
				flag = true;
				mixed = false;
			}
			if (flag)
			{
				memberMapping.TypeDesc = memberMapping.TypeDesc.CreateArrayTypeDesc();
			}
			return memberMapping;
		}

		private ElementAccessor[] ImportAny(XmlSchemaAny any, bool makeElement, string targetNamespace)
		{
			SpecialMapping specialMapping = new SpecialMapping();
			specialMapping.TypeDesc = base.Scope.GetTypeDesc(makeElement ? typeof(XmlElement) : typeof(XmlNode));
			specialMapping.TypeName = specialMapping.TypeDesc.Name;
			TypeFlags typeFlags = TypeFlags.CanBeElementValue;
			if (makeElement)
			{
				typeFlags |= TypeFlags.CanBeTextValue;
			}
			RunSchemaExtensions(specialMapping, XmlQualifiedName.Empty, null, any, typeFlags);
			if (GenerateOrder && any.Namespace != null)
			{
				NamespaceList namespaceList = new NamespaceList(any.Namespace, targetNamespace);
				if (namespaceList.Type == NamespaceList.ListType.Set)
				{
					ICollection enumerate = namespaceList.Enumerate;
					ElementAccessor[] array = new ElementAccessor[(enumerate.Count == 0) ? 1 : enumerate.Count];
					int num = 0;
					foreach (string item in namespaceList.Enumerate)
					{
						ElementAccessor elementAccessor = new ElementAccessor();
						elementAccessor.Mapping = specialMapping;
						elementAccessor.Any = true;
						elementAccessor.Namespace = item;
						array[num++] = elementAccessor;
					}
					if (num > 0)
					{
						return array;
					}
				}
			}
			ElementAccessor elementAccessor2 = new ElementAccessor();
			elementAccessor2.Mapping = specialMapping;
			elementAccessor2.Any = true;
			return new ElementAccessor[1] { elementAccessor2 };
		}

		private ElementAccessor ImportArray(XmlSchemaElement element, string identifier, string ns, bool repeats)
		{
			if (repeats)
			{
				return null;
			}
			if (element.SchemaType == null)
			{
				return null;
			}
			if (element.IsMultipleOccurrence)
			{
				return null;
			}
			XmlSchemaType schemaType = element.SchemaType;
			ArrayMapping arrayMapping = ImportArrayMapping(schemaType, identifier, ns, repeats);
			if (arrayMapping == null)
			{
				return null;
			}
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.Name = element.Name;
			elementAccessor.Namespace = ns;
			elementAccessor.Mapping = arrayMapping;
			if (arrayMapping.TypeDesc.IsNullable)
			{
				elementAccessor.IsNullable = element.IsNillable;
			}
			elementAccessor.Form = ElementForm(ns, element);
			return elementAccessor;
		}

		private ArrayMapping ImportArrayMapping(XmlSchemaType type, string identifier, string ns, bool repeats)
		{
			if (!(type is XmlSchemaComplexType))
			{
				return null;
			}
			if (!type.DerivedFrom.IsEmpty)
			{
				return null;
			}
			if (IsMixed(type))
			{
				return null;
			}
			Mapping mapping = (Mapping)base.ImportedMappings[type];
			if (mapping != null)
			{
				if (mapping is ArrayMapping)
				{
					return (ArrayMapping)mapping;
				}
				return null;
			}
			TypeItems typeItems = GetTypeItems(type);
			if (typeItems.Attributes != null && typeItems.Attributes.Count > 0)
			{
				return null;
			}
			if (typeItems.AnyAttribute != null)
			{
				return null;
			}
			if (typeItems.Particle == null)
			{
				return null;
			}
			XmlSchemaGroupBase particle = typeItems.Particle;
			ArrayMapping arrayMapping = new ArrayMapping();
			arrayMapping.TypeName = identifier;
			arrayMapping.Namespace = ns;
			if (particle is XmlSchemaChoice)
			{
				XmlSchemaChoice xmlSchemaChoice = (XmlSchemaChoice)particle;
				if (!xmlSchemaChoice.IsMultipleOccurrence)
				{
					return null;
				}
				bool needExplicitOrder = false;
				MemberMapping memberMapping = ImportChoiceGroup(xmlSchemaChoice, identifier, null, null, null, ns, groupRepeats: true, ref needExplicitOrder, allowDuplicates: false);
				if (memberMapping.ChoiceIdentifier != null)
				{
					return null;
				}
				arrayMapping.TypeDesc = memberMapping.TypeDesc;
				arrayMapping.Elements = memberMapping.Elements;
				arrayMapping.TypeName = ((type.Name == null || type.Name.Length == 0) ? ("ArrayOf" + CodeIdentifier.MakePascal(arrayMapping.TypeDesc.Name)) : type.Name);
			}
			else
			{
				if (!(particle is XmlSchemaAll) && !(particle is XmlSchemaSequence))
				{
					return null;
				}
				if (particle.Items.Count != 1 || !(particle.Items[0] is XmlSchemaElement))
				{
					return null;
				}
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)particle.Items[0];
				if (!xmlSchemaElement.IsMultipleOccurrence)
				{
					return null;
				}
				ElementAccessor elementAccessor = ImportElement(xmlSchemaElement, identifier, typeof(TypeMapping), null, ns, topLevelElement: false);
				if (elementAccessor.Any)
				{
					return null;
				}
				arrayMapping.Elements = new ElementAccessor[1] { elementAccessor };
				arrayMapping.TypeDesc = elementAccessor.Mapping.TypeDesc.CreateArrayTypeDesc();
				arrayMapping.TypeName = ((type.Name == null || type.Name.Length == 0) ? ("ArrayOf" + CodeIdentifier.MakePascal(elementAccessor.Mapping.TypeDesc.Name)) : type.Name);
			}
			base.ImportedMappings[type] = arrayMapping;
			base.Scope.AddTypeMapping(arrayMapping);
			arrayMapping.TopLevelMapping = ImportStructType(type, ns, identifier, null, arrayLike: true);
			arrayMapping.TopLevelMapping.ReferencedByTopLevelElement = true;
			if (type.Name != null && type.Name.Length != 0)
			{
				ImportDerivedTypes(new XmlQualifiedName(identifier, ns));
			}
			return arrayMapping;
		}

		private SpecialMapping ImportAnyMapping(XmlSchemaType type, string identifier, string ns, bool repeats)
		{
			if (type == null)
			{
				return null;
			}
			if (!type.DerivedFrom.IsEmpty)
			{
				return null;
			}
			bool flag = IsMixed(type);
			TypeItems typeItems = GetTypeItems(type);
			if (typeItems.Particle == null)
			{
				return null;
			}
			if (!(typeItems.Particle is XmlSchemaAll) && !(typeItems.Particle is XmlSchemaSequence))
			{
				return null;
			}
			if (typeItems.Attributes != null && typeItems.Attributes.Count > 0)
			{
				return null;
			}
			XmlSchemaGroupBase particle = typeItems.Particle;
			if (particle.Items.Count != 1 || !(particle.Items[0] is XmlSchemaAny))
			{
				return null;
			}
			XmlSchemaAny xmlSchemaAny = (XmlSchemaAny)particle.Items[0];
			SpecialMapping specialMapping = new SpecialMapping();
			if (typeItems.AnyAttribute != null && xmlSchemaAny.IsMultipleOccurrence && flag)
			{
				specialMapping.NamedAny = true;
				specialMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(XmlElement));
			}
			else
			{
				if (typeItems.AnyAttribute != null || xmlSchemaAny.IsMultipleOccurrence)
				{
					return null;
				}
				specialMapping.TypeDesc = base.Scope.GetTypeDesc(flag ? typeof(XmlNode) : typeof(XmlElement));
			}
			TypeFlags typeFlags = TypeFlags.CanBeElementValue;
			if (typeItems.AnyAttribute != null || flag)
			{
				typeFlags |= TypeFlags.CanBeTextValue;
			}
			RunSchemaExtensions(specialMapping, XmlQualifiedName.Empty, null, xmlSchemaAny, typeFlags);
			specialMapping.TypeName = specialMapping.TypeDesc.Name;
			if (repeats)
			{
				specialMapping.TypeDesc = specialMapping.TypeDesc.CreateArrayTypeDesc();
			}
			return specialMapping;
		}

		private void ImportElementMember(XmlSchemaElement element, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, INameScope elementsScope, string ns, bool repeats, ref bool needExplicitOrder, bool allowDuplicates, bool allowUnboundedElements)
		{
			repeats |= element.IsMultipleOccurrence;
			XmlSchemaElement topLevelElement = GetTopLevelElement(element);
			if (topLevelElement != null && ImportSubstitutionGroupMember(topLevelElement, identifier, members, membersScope, ns, repeats, ref needExplicitOrder, allowDuplicates))
			{
				return;
			}
			ElementAccessor elementAccessor;
			if ((elementAccessor = ImportArray(element, identifier, ns, repeats)) == null)
			{
				elementAccessor = ImportElement(element, identifier, typeof(TypeMapping), null, ns, topLevelElement: false);
			}
			MemberMapping memberMapping = new MemberMapping();
			string identifier2 = CodeIdentifier.MakeValid(Accessor.UnescapeName(elementAccessor.Name));
			memberMapping.Name = membersScope.AddUnique(identifier2, memberMapping);
			if (memberMapping.Name.EndsWith("Specified", StringComparison.Ordinal))
			{
				identifier2 = memberMapping.Name;
				memberMapping.Name = membersScope.AddUnique(memberMapping.Name, memberMapping);
				membersScope.Remove(identifier2);
			}
			members.Add(memberMapping.Name, memberMapping);
			if (elementAccessor.Mapping.IsList)
			{
				elementAccessor.Mapping = GetDefaultMapping((TypeFlags)48);
				memberMapping.TypeDesc = elementAccessor.Mapping.TypeDesc;
			}
			else
			{
				memberMapping.TypeDesc = elementAccessor.Mapping.TypeDesc;
			}
			AddScopeElement(elementsScope, elementAccessor, ref needExplicitOrder, allowDuplicates);
			memberMapping.Elements = new ElementAccessor[1] { elementAccessor };
			if (element.IsMultipleOccurrence || repeats)
			{
				if (!allowUnboundedElements && elementAccessor.Mapping is ArrayMapping)
				{
					elementAccessor.Mapping = ((ArrayMapping)elementAccessor.Mapping).TopLevelMapping;
					elementAccessor.Mapping.ReferencedByTopLevelElement = false;
					elementAccessor.Mapping.ReferencedByElement = true;
				}
				memberMapping.TypeDesc = elementAccessor.Mapping.TypeDesc.CreateArrayTypeDesc();
			}
			if (element.MinOccurs == 0m && memberMapping.TypeDesc.IsValueType && !element.HasDefault && !memberMapping.TypeDesc.HasIsEmpty)
			{
				memberMapping.CheckSpecified = SpecifiedAccessor.ReadWrite;
			}
		}

		private void ImportAttributeMember(XmlSchemaAttribute attribute, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns)
		{
			AttributeAccessor attributeAccessor = ImportAttribute(attribute, identifier, ns, attribute);
			if (attributeAccessor != null)
			{
				MemberMapping memberMapping = new MemberMapping();
				memberMapping.Elements = new ElementAccessor[0];
				memberMapping.Attribute = attributeAccessor;
				memberMapping.Name = CodeIdentifier.MakeValid(Accessor.UnescapeName(attributeAccessor.Name));
				memberMapping.Name = membersScope.AddUnique(memberMapping.Name, memberMapping);
				if (memberMapping.Name.EndsWith("Specified", StringComparison.Ordinal))
				{
					string name = memberMapping.Name;
					memberMapping.Name = membersScope.AddUnique(memberMapping.Name, memberMapping);
					membersScope.Remove(name);
				}
				members.Add(memberMapping.Name, memberMapping);
				memberMapping.TypeDesc = (attributeAccessor.IsList ? attributeAccessor.Mapping.TypeDesc.CreateArrayTypeDesc() : attributeAccessor.Mapping.TypeDesc);
				if ((attribute.Use == XmlSchemaUse.Optional || attribute.Use == XmlSchemaUse.None) && memberMapping.TypeDesc.IsValueType && !attribute.HasDefault && !memberMapping.TypeDesc.HasIsEmpty)
				{
					memberMapping.CheckSpecified = SpecifiedAccessor.ReadWrite;
				}
			}
		}

		private void ImportAnyAttributeMember(XmlSchemaAnyAttribute any, CodeIdentifiers members, CodeIdentifiers membersScope)
		{
			SpecialMapping specialMapping = new SpecialMapping();
			specialMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(XmlAttribute));
			specialMapping.TypeName = specialMapping.TypeDesc.Name;
			AttributeAccessor attributeAccessor = new AttributeAccessor();
			attributeAccessor.Any = true;
			attributeAccessor.Mapping = specialMapping;
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.Elements = new ElementAccessor[0];
			memberMapping.Attribute = attributeAccessor;
			memberMapping.Name = membersScope.MakeRightCase("AnyAttr");
			memberMapping.Name = membersScope.AddUnique(memberMapping.Name, memberMapping);
			members.Add(memberMapping.Name, memberMapping);
			memberMapping.TypeDesc = attributeAccessor.Mapping.TypeDesc;
			memberMapping.TypeDesc = memberMapping.TypeDesc.CreateArrayTypeDesc();
		}

		private bool KeepXmlnsDeclarations(XmlSchemaType type, out string xmlnsMemberName)
		{
			xmlnsMemberName = null;
			if (type.Annotation == null)
			{
				return false;
			}
			if (type.Annotation.Items == null || type.Annotation.Items.Count == 0)
			{
				return false;
			}
			foreach (XmlSchemaObject item in type.Annotation.Items)
			{
				if (!(item is XmlSchemaAppInfo))
				{
					continue;
				}
				XmlNode[] markup = ((XmlSchemaAppInfo)item).Markup;
				if (markup == null || markup.Length <= 0)
				{
					continue;
				}
				XmlNode[] array = markup;
				foreach (XmlNode xmlNode in array)
				{
					if (!(xmlNode is XmlElement))
					{
						continue;
					}
					XmlElement xmlElement = (XmlElement)xmlNode;
					if (xmlElement.Name == "keepNamespaceDeclarations")
					{
						if (xmlElement.LastNode is XmlText)
						{
							xmlnsMemberName = ((XmlText)xmlElement.LastNode).Value.Trim(null);
						}
						return true;
					}
				}
			}
			return false;
		}

		private void ImportXmlnsDeclarationsMember(XmlSchemaType type, CodeIdentifiers members, CodeIdentifiers membersScope)
		{
			if (KeepXmlnsDeclarations(type, out var xmlnsMemberName))
			{
				TypeDesc typeDesc = base.Scope.GetTypeDesc(typeof(XmlSerializerNamespaces));
				StructMapping structMapping = new StructMapping();
				structMapping.TypeDesc = typeDesc;
				structMapping.TypeName = structMapping.TypeDesc.Name;
				structMapping.Members = new MemberMapping[0];
				structMapping.IncludeInSchema = false;
				structMapping.ReferencedByTopLevelElement = true;
				ElementAccessor elementAccessor = new ElementAccessor();
				elementAccessor.Mapping = structMapping;
				MemberMapping memberMapping = new MemberMapping();
				memberMapping.Elements = new ElementAccessor[1] { elementAccessor };
				memberMapping.Name = CodeIdentifier.MakeValid((xmlnsMemberName == null) ? "Namespaces" : xmlnsMemberName);
				memberMapping.Name = membersScope.AddUnique(memberMapping.Name, memberMapping);
				members.Add(memberMapping.Name, memberMapping);
				memberMapping.TypeDesc = typeDesc;
				memberMapping.Xmlns = new XmlnsAccessor();
				memberMapping.Ignore = true;
			}
		}

		private void ImportAttributeGroupMembers(XmlSchemaAttributeGroup group, string identifier, CodeIdentifiers members, CodeIdentifiers membersScope, string ns)
		{
			for (int i = 0; i < group.Attributes.Count; i++)
			{
				object obj = group.Attributes[i];
				if (obj is XmlSchemaAttributeGroup)
				{
					ImportAttributeGroupMembers((XmlSchemaAttributeGroup)obj, identifier, members, membersScope, ns);
				}
				else if (obj is XmlSchemaAttribute)
				{
					ImportAttributeMember((XmlSchemaAttribute)obj, identifier, members, membersScope, ns);
				}
			}
			if (group.AnyAttribute != null)
			{
				ImportAnyAttributeMember(group.AnyAttribute, members, membersScope);
			}
		}

		private AttributeAccessor ImportSpecialAttribute(XmlQualifiedName name, string identifier)
		{
			PrimitiveMapping primitiveMapping = new PrimitiveMapping();
			primitiveMapping.TypeDesc = base.Scope.GetTypeDesc(typeof(string));
			primitiveMapping.TypeName = primitiveMapping.TypeDesc.DataType.Name;
			AttributeAccessor attributeAccessor = new AttributeAccessor();
			attributeAccessor.Name = name.Name;
			attributeAccessor.Namespace = "http://www.w3.org/XML/1998/namespace";
			attributeAccessor.CheckSpecial();
			attributeAccessor.Mapping = primitiveMapping;
			return attributeAccessor;
		}

		private AttributeAccessor ImportAttribute(XmlSchemaAttribute attribute, string identifier, string ns, XmlSchemaAttribute defaultValueProvider)
		{
			if (attribute.Use == XmlSchemaUse.Prohibited)
			{
				return null;
			}
			if (!attribute.RefName.IsEmpty)
			{
				if (attribute.RefName.Namespace == "http://www.w3.org/XML/1998/namespace")
				{
					return ImportSpecialAttribute(attribute.RefName, identifier);
				}
				return ImportAttribute(FindAttribute(attribute.RefName), identifier, attribute.RefName.Namespace, defaultValueProvider);
			}
			if (attribute.Name.Length == 0)
			{
				throw new InvalidOperationException(Res.GetString("XmlAttributeHasNoName"));
			}
			identifier = ((identifier.Length != 0) ? (identifier + CodeIdentifier.MakePascal(attribute.Name)) : CodeIdentifier.MakeValid(attribute.Name));
			TypeMapping typeMapping = ((!attribute.SchemaTypeName.IsEmpty) ? ImportType(attribute.SchemaTypeName, typeof(TypeMapping), null, TypeFlags.CanBeAttributeValue, addref: false) : ((attribute.SchemaType == null) ? GetDefaultMapping(TypeFlags.CanBeAttributeValue) : ImportDataType(attribute.SchemaType, ns, identifier, null, TypeFlags.CanBeAttributeValue, isList: false)));
			if (typeMapping != null && !typeMapping.TypeDesc.IsMappedType)
			{
				RunSchemaExtensions(typeMapping, attribute.SchemaTypeName, attribute.SchemaType, attribute, (TypeFlags)56);
			}
			AttributeAccessor attributeAccessor = new AttributeAccessor();
			attributeAccessor.Name = attribute.Name;
			attributeAccessor.Namespace = ns;
			attributeAccessor.Form = AttributeForm(ns, attribute);
			attributeAccessor.CheckSpecial();
			attributeAccessor.Mapping = typeMapping;
			attributeAccessor.IsList = typeMapping.IsList;
			attributeAccessor.IsOptional = attribute.Use != XmlSchemaUse.Required;
			if (defaultValueProvider.DefaultValue != null)
			{
				attributeAccessor.Default = defaultValueProvider.DefaultValue;
			}
			else if (defaultValueProvider.FixedValue != null)
			{
				attributeAccessor.Default = defaultValueProvider.FixedValue;
				attributeAccessor.IsFixed = true;
			}
			else if (attribute != defaultValueProvider)
			{
				if (attribute.DefaultValue != null)
				{
					attributeAccessor.Default = attribute.DefaultValue;
				}
				else if (attribute.FixedValue != null)
				{
					attributeAccessor.Default = attribute.FixedValue;
					attributeAccessor.IsFixed = true;
				}
			}
			return attributeAccessor;
		}

		private TypeMapping ImportDataType(XmlSchemaSimpleType dataType, string typeNs, string identifier, Type baseType, TypeFlags flags, bool isList)
		{
			if (baseType != null)
			{
				return ImportStructDataType(dataType, typeNs, identifier, baseType);
			}
			TypeMapping typeMapping = ImportNonXsdPrimitiveDataType(dataType, typeNs, flags);
			if (typeMapping != null)
			{
				return typeMapping;
			}
			if (dataType.Content is XmlSchemaSimpleTypeRestriction)
			{
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)dataType.Content;
				foreach (XmlSchemaObject facet in xmlSchemaSimpleTypeRestriction.Facets)
				{
					if (facet is XmlSchemaEnumerationFacet)
					{
						return ImportEnumeratedDataType(dataType, typeNs, identifier, flags, isList);
					}
				}
				if (xmlSchemaSimpleTypeRestriction.BaseType != null)
				{
					return ImportDataType(xmlSchemaSimpleTypeRestriction.BaseType, typeNs, identifier, null, flags, isList: false);
				}
				AddReference(xmlSchemaSimpleTypeRestriction.BaseTypeName, base.TypesInUse, "XmlCircularTypeReference");
				typeMapping = ImportDataType(FindDataType(xmlSchemaSimpleTypeRestriction.BaseTypeName, flags), xmlSchemaSimpleTypeRestriction.BaseTypeName.Namespace, identifier, null, flags, isList: false);
				if (xmlSchemaSimpleTypeRestriction.BaseTypeName.Namespace != "http://www.w3.org/2001/XMLSchema")
				{
					RemoveReference(xmlSchemaSimpleTypeRestriction.BaseTypeName, base.TypesInUse);
				}
				return typeMapping;
			}
			if (dataType.Content is XmlSchemaSimpleTypeList || dataType.Content is XmlSchemaSimpleTypeUnion)
			{
				if (dataType.Content is XmlSchemaSimpleTypeList)
				{
					XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = (XmlSchemaSimpleTypeList)dataType.Content;
					if (xmlSchemaSimpleTypeList.ItemType != null)
					{
						typeMapping = ImportDataType(xmlSchemaSimpleTypeList.ItemType, typeNs, identifier, null, flags, isList: true);
						if (typeMapping != null)
						{
							typeMapping.TypeName = dataType.Name;
							return typeMapping;
						}
					}
					else if (xmlSchemaSimpleTypeList.ItemTypeName != null && !xmlSchemaSimpleTypeList.ItemTypeName.IsEmpty)
					{
						typeMapping = ImportType(xmlSchemaSimpleTypeList.ItemTypeName, typeof(TypeMapping), null, TypeFlags.CanBeAttributeValue, addref: true);
						if (typeMapping != null && typeMapping is PrimitiveMapping)
						{
							((PrimitiveMapping)typeMapping).IsList = true;
							return typeMapping;
						}
					}
				}
				return GetDefaultMapping(flags);
			}
			return ImportPrimitiveDataType(dataType, flags);
		}

		private TypeMapping ImportEnumeratedDataType(XmlSchemaSimpleType dataType, string typeNs, string identifier, TypeFlags flags, bool isList)
		{
			TypeMapping typeMapping = (TypeMapping)base.ImportedMappings[dataType];
			if (typeMapping != null)
			{
				return typeMapping;
			}
			XmlSchemaType xmlSchemaType = dataType;
			while (!xmlSchemaType.DerivedFrom.IsEmpty)
			{
				xmlSchemaType = FindType(xmlSchemaType.DerivedFrom, (TypeFlags)40);
			}
			if (xmlSchemaType is XmlSchemaComplexType)
			{
				return null;
			}
			TypeDesc typeDesc = base.Scope.GetTypeDesc((XmlSchemaSimpleType)xmlSchemaType);
			if (typeDesc != null && typeDesc.FullName != typeof(string).FullName)
			{
				return ImportPrimitiveDataType(dataType, flags);
			}
			identifier = Accessor.UnescapeName(identifier);
			string text = GenerateUniqueTypeName(identifier);
			EnumMapping enumMapping = new EnumMapping();
			enumMapping.IsReference = base.Schemas.IsReference(dataType);
			enumMapping.TypeDesc = new TypeDesc(text, text, TypeKind.Enum, null, TypeFlags.None);
			if (dataType.Name != null && dataType.Name.Length > 0)
			{
				enumMapping.TypeName = identifier;
			}
			enumMapping.Namespace = typeNs;
			enumMapping.IsFlags = isList;
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			XmlSchemaSimpleTypeContent content = dataType.Content;
			if (content is XmlSchemaSimpleTypeRestriction)
			{
				XmlSchemaSimpleTypeRestriction xmlSchemaSimpleTypeRestriction = (XmlSchemaSimpleTypeRestriction)content;
				for (int i = 0; i < xmlSchemaSimpleTypeRestriction.Facets.Count; i++)
				{
					object obj = xmlSchemaSimpleTypeRestriction.Facets[i];
					if (obj is XmlSchemaEnumerationFacet)
					{
						XmlSchemaEnumerationFacet xmlSchemaEnumerationFacet = (XmlSchemaEnumerationFacet)obj;
						if (typeDesc != null && typeDesc.HasCustomFormatter)
						{
							XmlCustomFormatter.ToDefaultValue(xmlSchemaEnumerationFacet.Value, typeDesc.FormatterName);
						}
						ConstantMapping constantMapping = new ConstantMapping();
						string identifier2 = CodeIdentifier.MakeValid(xmlSchemaEnumerationFacet.Value);
						constantMapping.Name = codeIdentifiers.AddUnique(identifier2, constantMapping);
						constantMapping.XmlName = xmlSchemaEnumerationFacet.Value;
						constantMapping.Value = i;
					}
				}
			}
			enumMapping.Constants = (ConstantMapping[])codeIdentifiers.ToArray(typeof(ConstantMapping));
			if (isList && enumMapping.Constants.Length > 63)
			{
				typeMapping = GetDefaultMapping((TypeFlags)56);
				base.ImportedMappings.Add(dataType, typeMapping);
				return typeMapping;
			}
			base.ImportedMappings.Add(dataType, enumMapping);
			base.Scope.AddTypeMapping(enumMapping);
			return enumMapping;
		}

		private EnumMapping ImportEnumeratedChoice(ElementAccessor[] choice, string typeNs, string typeName)
		{
			typeName = GenerateUniqueTypeName(Accessor.UnescapeName(typeName), typeNs);
			EnumMapping enumMapping = new EnumMapping();
			enumMapping.TypeDesc = new TypeDesc(typeName, typeName, TypeKind.Enum, null, TypeFlags.None);
			enumMapping.TypeName = typeName;
			enumMapping.Namespace = typeNs;
			enumMapping.IsFlags = false;
			enumMapping.IncludeInSchema = false;
			if (GenerateOrder)
			{
				Array.Sort(choice, new ElementComparer());
			}
			CodeIdentifiers codeIdentifiers = new CodeIdentifiers();
			for (int i = 0; i < choice.Length; i++)
			{
				ElementAccessor elementAccessor = choice[i];
				ConstantMapping constantMapping = new ConstantMapping();
				string identifier = CodeIdentifier.MakeValid(elementAccessor.Name);
				constantMapping.Name = codeIdentifiers.AddUnique(identifier, constantMapping);
				constantMapping.XmlName = elementAccessor.ToString(typeNs);
				constantMapping.Value = i;
			}
			enumMapping.Constants = (ConstantMapping[])codeIdentifiers.ToArray(typeof(ConstantMapping));
			base.Scope.AddTypeMapping(enumMapping);
			return enumMapping;
		}

		private PrimitiveMapping ImportPrimitiveDataType(XmlSchemaSimpleType dataType, TypeFlags flags)
		{
			TypeDesc dataTypeSource = GetDataTypeSource(dataType, flags);
			PrimitiveMapping primitiveMapping = new PrimitiveMapping();
			primitiveMapping.TypeDesc = dataTypeSource;
			primitiveMapping.TypeName = dataTypeSource.DataType.Name;
			primitiveMapping.Namespace = (primitiveMapping.TypeDesc.IsXsdType ? "http://www.w3.org/2001/XMLSchema" : "http://microsoft.com/wsdl/types/");
			return primitiveMapping;
		}

		private PrimitiveMapping ImportNonXsdPrimitiveDataType(XmlSchemaSimpleType dataType, string ns, TypeFlags flags)
		{
			PrimitiveMapping primitiveMapping = null;
			TypeDesc typeDesc = null;
			if (dataType.Name != null && dataType.Name.Length != 0)
			{
				typeDesc = base.Scope.GetTypeDesc(dataType.Name, ns, flags);
				if (typeDesc != null)
				{
					primitiveMapping = new PrimitiveMapping();
					primitiveMapping.TypeDesc = typeDesc;
					primitiveMapping.TypeName = typeDesc.DataType.Name;
					primitiveMapping.Namespace = (primitiveMapping.TypeDesc.IsXsdType ? "http://www.w3.org/2001/XMLSchema" : ns);
				}
			}
			return primitiveMapping;
		}

		private XmlSchemaGroup FindGroup(XmlQualifiedName name)
		{
			XmlSchemaGroup xmlSchemaGroup = (XmlSchemaGroup)base.Schemas.Find(name, typeof(XmlSchemaGroup));
			if (xmlSchemaGroup == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlMissingGroup", name.Name));
			}
			return xmlSchemaGroup;
		}

		private XmlSchemaAttributeGroup FindAttributeGroup(XmlQualifiedName name)
		{
			XmlSchemaAttributeGroup xmlSchemaAttributeGroup = (XmlSchemaAttributeGroup)base.Schemas.Find(name, typeof(XmlSchemaAttributeGroup));
			if (xmlSchemaAttributeGroup == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlMissingAttributeGroup", name.Name));
			}
			return xmlSchemaAttributeGroup;
		}

		internal static XmlQualifiedName BaseTypeName(XmlSchemaSimpleType dataType)
		{
			XmlSchemaSimpleTypeContent content = dataType.Content;
			if (content is XmlSchemaSimpleTypeRestriction)
			{
				return ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName;
			}
			if (content is XmlSchemaSimpleTypeList)
			{
				XmlSchemaSimpleTypeList xmlSchemaSimpleTypeList = (XmlSchemaSimpleTypeList)content;
				if (xmlSchemaSimpleTypeList.ItemTypeName != null && !xmlSchemaSimpleTypeList.ItemTypeName.IsEmpty)
				{
					return xmlSchemaSimpleTypeList.ItemTypeName;
				}
				if (xmlSchemaSimpleTypeList.ItemType != null)
				{
					return BaseTypeName(xmlSchemaSimpleTypeList.ItemType);
				}
			}
			return new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
		}

		private TypeDesc GetDataTypeSource(XmlSchemaSimpleType dataType, TypeFlags flags)
		{
			TypeDesc typeDesc = null;
			if (dataType.Name != null && dataType.Name.Length != 0)
			{
				typeDesc = base.Scope.GetTypeDesc(dataType);
				if (typeDesc != null)
				{
					return typeDesc;
				}
			}
			XmlQualifiedName xmlQualifiedName = BaseTypeName(dataType);
			AddReference(xmlQualifiedName, base.TypesInUse, "XmlCircularTypeReference");
			typeDesc = GetDataTypeSource(FindDataType(xmlQualifiedName, flags), flags);
			if (xmlQualifiedName.Namespace != "http://www.w3.org/2001/XMLSchema")
			{
				RemoveReference(xmlQualifiedName, base.TypesInUse);
			}
			return typeDesc;
		}

		private XmlSchemaSimpleType FindDataType(XmlQualifiedName name, TypeFlags flags)
		{
			if (name == null || name.IsEmpty)
			{
				return (XmlSchemaSimpleType)base.Scope.GetTypeDesc(typeof(string)).DataType;
			}
			TypeDesc typeDesc = base.Scope.GetTypeDesc(name.Name, name.Namespace, flags);
			if (typeDesc != null && typeDesc.DataType is XmlSchemaSimpleType)
			{
				return (XmlSchemaSimpleType)typeDesc.DataType;
			}
			XmlSchemaSimpleType xmlSchemaSimpleType = (XmlSchemaSimpleType)base.Schemas.Find(name, typeof(XmlSchemaSimpleType));
			if (xmlSchemaSimpleType != null)
			{
				return xmlSchemaSimpleType;
			}
			if (name.Namespace == "http://www.w3.org/2001/XMLSchema")
			{
				return (XmlSchemaSimpleType)base.Scope.GetTypeDesc("string", "http://www.w3.org/2001/XMLSchema", flags).DataType;
			}
			if (name.Name == "Array" && name.Namespace == "http://schemas.xmlsoap.org/soap/encoding/")
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidEncoding", name.ToString()));
			}
			throw new InvalidOperationException(Res.GetString("XmlMissingDataType", name.ToString()));
		}

		private XmlSchemaType FindType(XmlQualifiedName name, TypeFlags flags)
		{
			if (name == null || name.IsEmpty)
			{
				return base.Scope.GetTypeDesc(typeof(string)).DataType;
			}
			object obj = base.Schemas.Find(name, typeof(XmlSchemaComplexType));
			if (obj != null)
			{
				return (XmlSchemaComplexType)obj;
			}
			return FindDataType(name, flags);
		}

		private XmlSchemaElement FindElement(XmlQualifiedName name)
		{
			XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)base.Schemas.Find(name, typeof(XmlSchemaElement));
			if (xmlSchemaElement == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlMissingElement", name.ToString()));
			}
			return xmlSchemaElement;
		}

		private XmlSchemaAttribute FindAttribute(XmlQualifiedName name)
		{
			XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)base.Schemas.Find(name, typeof(XmlSchemaAttribute));
			if (xmlSchemaAttribute == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlMissingAttribute", name.Name));
			}
			return xmlSchemaAttribute;
		}

		private XmlSchemaForm ElementForm(string ns, XmlSchemaElement element)
		{
			if (element.Form == XmlSchemaForm.None)
			{
				XmlSchemaObject xmlSchemaObject = element;
				while (xmlSchemaObject.Parent != null)
				{
					xmlSchemaObject = xmlSchemaObject.Parent;
				}
				if (xmlSchemaObject is XmlSchema xmlSchema)
				{
					if (ns == null || ns.Length == 0)
					{
						if (xmlSchema.ElementFormDefault != 0)
						{
							return xmlSchema.ElementFormDefault;
						}
						return XmlSchemaForm.Unqualified;
					}
					XmlSchemas.Preprocess(xmlSchema);
					if (element.QualifiedName.Namespace != null && element.QualifiedName.Namespace.Length != 0)
					{
						return XmlSchemaForm.Qualified;
					}
					return XmlSchemaForm.Unqualified;
				}
				return XmlSchemaForm.Qualified;
			}
			return element.Form;
		}

		internal string FindExtendedAnyElement(XmlSchemaAny any, bool mixed, CodeCompileUnit compileUnit, CodeNamespace mainNamespace, out SchemaImporterExtension extension)
		{
			extension = null;
			foreach (SchemaImporterExtension extension2 in base.Extensions)
			{
				string text = extension2.ImportAnyElement(any, mixed, base.Schemas, this, compileUnit, mainNamespace, base.Options, base.CodeProvider);
				if (text != null && text.Length > 0)
				{
					extension = extension2;
					return text;
				}
			}
			return null;
		}

		internal string FindExtendedType(string name, string ns, XmlSchemaObject context, CodeCompileUnit compileUnit, CodeNamespace mainNamespace, out SchemaImporterExtension extension)
		{
			extension = null;
			foreach (SchemaImporterExtension extension2 in base.Extensions)
			{
				string text = extension2.ImportSchemaType(name, ns, context, base.Schemas, this, compileUnit, mainNamespace, base.Options, base.CodeProvider);
				if (text != null && text.Length > 0)
				{
					extension = extension2;
					return text;
				}
			}
			return null;
		}

		internal string FindExtendedType(XmlSchemaType type, XmlSchemaObject context, CodeCompileUnit compileUnit, CodeNamespace mainNamespace, out SchemaImporterExtension extension)
		{
			extension = null;
			foreach (SchemaImporterExtension extension2 in base.Extensions)
			{
				string text = extension2.ImportSchemaType(type, context, base.Schemas, this, compileUnit, mainNamespace, base.Options, base.CodeProvider);
				if (text != null && text.Length > 0)
				{
					extension = extension2;
					return text;
				}
			}
			return null;
		}

		private XmlSchemaForm AttributeForm(string ns, XmlSchemaAttribute attribute)
		{
			if (attribute.Form == XmlSchemaForm.None)
			{
				XmlSchemaObject xmlSchemaObject = attribute;
				while (xmlSchemaObject.Parent != null)
				{
					xmlSchemaObject = xmlSchemaObject.Parent;
				}
				if (xmlSchemaObject is XmlSchema xmlSchema)
				{
					if (ns == null || ns.Length == 0)
					{
						if (xmlSchema.AttributeFormDefault != 0)
						{
							return xmlSchema.AttributeFormDefault;
						}
						return XmlSchemaForm.Unqualified;
					}
					XmlSchemas.Preprocess(xmlSchema);
					if (attribute.QualifiedName.Namespace != null && attribute.QualifiedName.Namespace.Length != 0)
					{
						return XmlSchemaForm.Qualified;
					}
					return XmlSchemaForm.Unqualified;
				}
				return XmlSchemaForm.Unqualified;
			}
			return attribute.Form;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface)]
	public sealed class XmlSchemaProviderAttribute : Attribute
	{
		private string methodName;

		private bool any;

		public string MethodName => methodName;

		public bool IsAny
		{
			get
			{
				return any;
			}
			set
			{
				any = value;
			}
		}

		public XmlSchemaProviderAttribute(string methodName)
		{
			this.methodName = methodName;
		}
	}
	public class XmlSchemas : CollectionBase, IEnumerable<XmlSchema>, IEnumerable
	{
		internal const string xmlSchema = "<?xml version='1.0' encoding='UTF-8' ?> \r\n<xs:schema targetNamespace='http://www.w3.org/XML/1998/namespace' xmlns:xs='http://www.w3.org/2001/XMLSchema' xml:lang='en'>\r\n <xs:attribute name='lang' type='xs:language'/>\r\n <xs:attribute name='space'>\r\n  <xs:simpleType>\r\n   <xs:restriction base='xs:NCName'>\r\n    <xs:enumeration value='default'/>\r\n    <xs:enumeration value='preserve'/>\r\n   </xs:restriction>\r\n  </xs:simpleType>\r\n </xs:attribute>\r\n <xs:attribute name='base' type='xs:anyURI'/>\r\n <xs:attribute name='id' type='xs:ID' />\r\n <xs:attributeGroup name='specialAttrs'>\r\n  <xs:attribute ref='xml:base'/>\r\n  <xs:attribute ref='xml:lang'/>\r\n  <xs:attribute ref='xml:space'/>\r\n </xs:attributeGroup>\r\n</xs:schema>";

		private XmlSchemaSet schemaSet;

		private Hashtable references;

		private SchemaObjectCache cache;

		private bool shareTypes;

		private Hashtable mergedSchemas;

		internal Hashtable delayedSchemas = new Hashtable();

		private bool isCompiled;

		private static XmlSchema xsd;

		private static XmlSchema xml;

		public XmlSchema this[int index]
		{
			get
			{
				return (XmlSchema)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public XmlSchema this[string ns]
		{
			get
			{
				IList list = (IList)SchemaSet.Schemas(ns);
				if (list.Count == 0)
				{
					return null;
				}
				if (list.Count == 1)
				{
					return (XmlSchema)list[0];
				}
				throw new InvalidOperationException(Res.GetString("XmlSchemaDuplicateNamespace", ns));
			}
		}

		internal SchemaObjectCache Cache
		{
			get
			{
				if (cache == null)
				{
					cache = new SchemaObjectCache();
				}
				return cache;
			}
		}

		internal Hashtable MergedSchemas
		{
			get
			{
				if (mergedSchemas == null)
				{
					mergedSchemas = new Hashtable();
				}
				return mergedSchemas;
			}
		}

		internal Hashtable References
		{
			get
			{
				if (references == null)
				{
					references = new Hashtable();
				}
				return references;
			}
		}

		internal XmlSchemaSet SchemaSet
		{
			get
			{
				if (schemaSet == null)
				{
					schemaSet = new XmlSchemaSet();
					schemaSet.XmlResolver = null;
					schemaSet.ValidationEventHandler += IgnoreCompileErrors;
				}
				return schemaSet;
			}
		}

		public bool IsCompiled => isCompiled;

		internal static XmlSchema XsdSchema
		{
			get
			{
				if (xsd == null)
				{
					xsd = CreateFakeXsdSchema("http://www.w3.org/2001/XMLSchema", "schema");
				}
				return xsd;
			}
		}

		internal static XmlSchema XmlSchema
		{
			get
			{
				if (xml == null)
				{
					xml = XmlSchema.Read(new StringReader("<?xml version='1.0' encoding='UTF-8' ?> \r\n<xs:schema targetNamespace='http://www.w3.org/XML/1998/namespace' xmlns:xs='http://www.w3.org/2001/XMLSchema' xml:lang='en'>\r\n <xs:attribute name='lang' type='xs:language'/>\r\n <xs:attribute name='space'>\r\n  <xs:simpleType>\r\n   <xs:restriction base='xs:NCName'>\r\n    <xs:enumeration value='default'/>\r\n    <xs:enumeration value='preserve'/>\r\n   </xs:restriction>\r\n  </xs:simpleType>\r\n </xs:attribute>\r\n <xs:attribute name='base' type='xs:anyURI'/>\r\n <xs:attribute name='id' type='xs:ID' />\r\n <xs:attributeGroup name='specialAttrs'>\r\n  <xs:attribute ref='xml:base'/>\r\n  <xs:attribute ref='xml:lang'/>\r\n  <xs:attribute ref='xml:space'/>\r\n </xs:attributeGroup>\r\n</xs:schema>"), null);
				}
				return xml;
			}
		}

		public IList GetSchemas(string ns)
		{
			return (IList)SchemaSet.Schemas(ns);
		}

		internal int Add(XmlSchema schema, bool delay)
		{
			if (delay)
			{
				if (delayedSchemas[schema] == null)
				{
					delayedSchemas.Add(schema, schema);
				}
				return -1;
			}
			return Add(schema);
		}

		public int Add(XmlSchema schema)
		{
			if (base.List.Contains(schema))
			{
				return base.List.IndexOf(schema);
			}
			return base.List.Add(schema);
		}

		public int Add(XmlSchema schema, Uri baseUri)
		{
			if (base.List.Contains(schema))
			{
				return base.List.IndexOf(schema);
			}
			if (baseUri != null)
			{
				schema.BaseUri = baseUri;
			}
			return base.List.Add(schema);
		}

		public void Add(XmlSchemas schemas)
		{
			foreach (XmlSchema schema in schemas)
			{
				Add(schema);
			}
		}

		public void AddReference(XmlSchema schema)
		{
			References[schema] = schema;
		}

		public void Insert(int index, XmlSchema schema)
		{
			base.List.Insert(index, schema);
		}

		public int IndexOf(XmlSchema schema)
		{
			return base.List.IndexOf(schema);
		}

		public bool Contains(XmlSchema schema)
		{
			return base.List.Contains(schema);
		}

		public bool Contains(string targetNamespace)
		{
			return SchemaSet.Contains(targetNamespace);
		}

		public void Remove(XmlSchema schema)
		{
			base.List.Remove(schema);
		}

		public void CopyTo(XmlSchema[] array, int index)
		{
			base.List.CopyTo(array, index);
		}

		protected override void OnInsert(int index, object value)
		{
			AddName((XmlSchema)value);
		}

		protected override void OnRemove(int index, object value)
		{
			RemoveName((XmlSchema)value);
		}

		protected override void OnClear()
		{
			schemaSet = null;
		}

		protected override void OnSet(int index, object oldValue, object newValue)
		{
			RemoveName((XmlSchema)oldValue);
			AddName((XmlSchema)newValue);
		}

		private void AddName(XmlSchema schema)
		{
			if (isCompiled)
			{
				throw new InvalidOperationException(Res.GetString("XmlSchemaCompiled"));
			}
			if (SchemaSet.Contains(schema))
			{
				SchemaSet.Reprocess(schema);
				return;
			}
			Prepare(schema);
			SchemaSet.Add(schema);
		}

		private void Prepare(XmlSchema schema)
		{
			ArrayList arrayList = new ArrayList();
			string targetNamespace = schema.TargetNamespace;
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (include is XmlSchemaImport && targetNamespace == ((XmlSchemaImport)include).Namespace)
				{
					arrayList.Add(include);
				}
			}
			foreach (XmlSchemaObject item in arrayList)
			{
				schema.Includes.Remove(item);
			}
		}

		private void RemoveName(XmlSchema schema)
		{
			SchemaSet.Remove(schema);
		}

		public object Find(XmlQualifiedName name, Type type)
		{
			return Find(name, type, checkCache: true);
		}

		internal object Find(XmlQualifiedName name, Type type, bool checkCache)
		{
			if (!IsCompiled)
			{
				foreach (XmlSchema item in base.List)
				{
					Preprocess(item);
				}
			}
			IList list = (IList)SchemaSet.Schemas(name.Namespace);
			if (list == null)
			{
				return null;
			}
			foreach (XmlSchema item2 in list)
			{
				Preprocess(item2);
				XmlSchemaObject xmlSchemaObject = null;
				if (typeof(XmlSchemaType).IsAssignableFrom(type))
				{
					xmlSchemaObject = item2.SchemaTypes[name];
					if (xmlSchemaObject == null || !type.IsAssignableFrom(xmlSchemaObject.GetType()))
					{
						continue;
					}
				}
				else if (type == typeof(XmlSchemaGroup))
				{
					xmlSchemaObject = item2.Groups[name];
				}
				else if (type == typeof(XmlSchemaAttributeGroup))
				{
					xmlSchemaObject = item2.AttributeGroups[name];
				}
				else if (type == typeof(XmlSchemaElement))
				{
					xmlSchemaObject = item2.Elements[name];
				}
				else if (type == typeof(XmlSchemaAttribute))
				{
					xmlSchemaObject = item2.Attributes[name];
				}
				else if (type == typeof(XmlSchemaNotation))
				{
					xmlSchemaObject = item2.Notations[name];
				}
				if (xmlSchemaObject != null && shareTypes && checkCache && !IsReference(xmlSchemaObject))
				{
					xmlSchemaObject = Cache.AddItem(xmlSchemaObject, name, this);
				}
				if (xmlSchemaObject != null)
				{
					return xmlSchemaObject;
				}
			}
			return null;
		}

		IEnumerator<XmlSchema> IEnumerable<XmlSchema>.GetEnumerator()
		{
			return new XmlSchemaEnumerator(this);
		}

		internal static void Preprocess(XmlSchema schema)
		{
			if (!schema.IsPreprocessed)
			{
				try
				{
					XmlNameTable nameTable = new System.Xml.NameTable();
					Preprocessor preprocessor = new Preprocessor(nameTable, new SchemaNames(nameTable), null);
					preprocessor.SchemaLocations = new Hashtable();
					preprocessor.Execute(schema, schema.TargetNamespace, loadExternals: false);
				}
				catch (XmlSchemaException ex)
				{
					throw CreateValidationException(ex, ex.Message);
				}
			}
		}

		public static bool IsDataSet(XmlSchema schema)
		{
			foreach (XmlSchemaObject item in schema.Items)
			{
				if (!(item is XmlSchemaElement))
				{
					continue;
				}
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)item;
				if (xmlSchemaElement.UnhandledAttributes == null)
				{
					continue;
				}
				XmlAttribute[] unhandledAttributes = xmlSchemaElement.UnhandledAttributes;
				foreach (XmlAttribute xmlAttribute in unhandledAttributes)
				{
					if (xmlAttribute.LocalName == "IsDataSet" && xmlAttribute.NamespaceURI == "urn:schemas-microsoft-com:xml-msdata" && (xmlAttribute.Value == "True" || xmlAttribute.Value == "true" || xmlAttribute.Value == "1"))
					{
						return true;
					}
				}
			}
			return false;
		}

		private void Merge(XmlSchema schema)
		{
			if (MergedSchemas[schema] == null)
			{
				IList list = (IList)SchemaSet.Schemas(schema.TargetNamespace);
				if (list != null && list.Count > 0)
				{
					MergedSchemas.Add(schema, schema);
					Merge(list, schema);
				}
				else
				{
					Add(schema);
					MergedSchemas.Add(schema, schema);
				}
			}
		}

		private void AddImport(IList schemas, string ns)
		{
			foreach (XmlSchema schema in schemas)
			{
				bool flag = true;
				foreach (XmlSchemaExternal include in schema.Includes)
				{
					if (include is XmlSchemaImport && ((XmlSchemaImport)include).Namespace == ns)
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					XmlSchemaImport xmlSchemaImport = new XmlSchemaImport();
					xmlSchemaImport.Namespace = ns;
					schema.Includes.Add(xmlSchemaImport);
				}
			}
		}

		private void Merge(IList originals, XmlSchema schema)
		{
			foreach (XmlSchema original in originals)
			{
				if (schema == original)
				{
					return;
				}
			}
			foreach (XmlSchemaExternal include in schema.Includes)
			{
				if (include is XmlSchemaImport)
				{
					include.SchemaLocation = null;
					if (include.Schema != null)
					{
						Merge(include.Schema);
					}
					else
					{
						AddImport(originals, ((XmlSchemaImport)include).Namespace);
					}
				}
				else if (include.Schema == null)
				{
					if (include.SchemaLocation != null)
					{
						throw new InvalidOperationException(Res.GetString("XmlSchemaIncludeLocation", GetType().Name, include.SchemaLocation));
					}
				}
				else
				{
					include.SchemaLocation = null;
					Merge(originals, include.Schema);
				}
			}
			bool[] array = new bool[schema.Items.Count];
			int num = 0;
			for (int i = 0; i < schema.Items.Count; i++)
			{
				XmlSchemaObject xmlSchemaObject = schema.Items[i];
				XmlSchemaObject xmlSchemaObject2 = Find(xmlSchemaObject, originals);
				if (xmlSchemaObject2 != null)
				{
					if (!Cache.Match(xmlSchemaObject2, xmlSchemaObject, shareTypes))
					{
						throw new InvalidOperationException(MergeFailedMessage(xmlSchemaObject, xmlSchemaObject2, schema.TargetNamespace));
					}
					array[i] = true;
					num++;
				}
			}
			if (num == schema.Items.Count)
			{
				return;
			}
			XmlSchema xmlSchema2 = (XmlSchema)originals[0];
			for (int j = 0; j < schema.Items.Count; j++)
			{
				if (!array[j])
				{
					xmlSchema2.Items.Add(schema.Items[j]);
				}
			}
			xmlSchema2.IsPreprocessed = false;
			Preprocess(xmlSchema2);
		}

		private static string ItemName(XmlSchemaObject o)
		{
			if (o is XmlSchemaNotation)
			{
				return ((XmlSchemaNotation)o).Name;
			}
			if (o is XmlSchemaGroup)
			{
				return ((XmlSchemaGroup)o).Name;
			}
			if (o is XmlSchemaElement)
			{
				return ((XmlSchemaElement)o).Name;
			}
			if (o is XmlSchemaType)
			{
				return ((XmlSchemaType)o).Name;
			}
			if (o is XmlSchemaAttributeGroup)
			{
				return ((XmlSchemaAttributeGroup)o).Name;
			}
			if (o is XmlSchemaAttribute)
			{
				return ((XmlSchemaAttribute)o).Name;
			}
			return null;
		}

		internal static XmlQualifiedName GetParentName(XmlSchemaObject item)
		{
			while (item.Parent != null)
			{
				if (item.Parent is XmlSchemaType)
				{
					XmlSchemaType xmlSchemaType = (XmlSchemaType)item.Parent;
					if (xmlSchemaType.Name != null && xmlSchemaType.Name.Length != 0)
					{
						return xmlSchemaType.QualifiedName;
					}
				}
				item = item.Parent;
			}
			return XmlQualifiedName.Empty;
		}

		private static string GetSchemaItem(XmlSchemaObject o, string ns, string details)
		{
			if (o == null)
			{
				return null;
			}
			while (o.Parent != null && !(o.Parent is XmlSchema))
			{
				o = o.Parent;
			}
			if (ns == null || ns.Length == 0)
			{
				XmlSchemaObject xmlSchemaObject = o;
				while (xmlSchemaObject.Parent != null)
				{
					xmlSchemaObject = xmlSchemaObject.Parent;
				}
				if (xmlSchemaObject is XmlSchema)
				{
					ns = ((XmlSchema)xmlSchemaObject).TargetNamespace;
				}
			}
			string text = null;
			if (o is XmlSchemaNotation)
			{
				return Res.GetString("XmlSchemaNamedItem", ns, "notation", ((XmlSchemaNotation)o).Name, details);
			}
			if (o is XmlSchemaGroup)
			{
				return Res.GetString("XmlSchemaNamedItem", ns, "group", ((XmlSchemaGroup)o).Name, details);
			}
			if (o is XmlSchemaElement)
			{
				XmlSchemaElement xmlSchemaElement = (XmlSchemaElement)o;
				if (xmlSchemaElement.Name == null || xmlSchemaElement.Name.Length == 0)
				{
					XmlQualifiedName parentName = GetParentName(o);
					return Res.GetString("XmlSchemaElementReference", xmlSchemaElement.RefName.ToString(), parentName.Name, parentName.Namespace);
				}
				return Res.GetString("XmlSchemaNamedItem", ns, "element", xmlSchemaElement.Name, details);
			}
			if (o is XmlSchemaType)
			{
				return Res.GetString("XmlSchemaNamedItem", ns, (o.GetType() == typeof(XmlSchemaSimpleType)) ? "simpleType" : "complexType", ((XmlSchemaType)o).Name, null);
			}
			if (o is XmlSchemaAttributeGroup)
			{
				return Res.GetString("XmlSchemaNamedItem", ns, "attributeGroup", ((XmlSchemaAttributeGroup)o).Name, details);
			}
			if (o is XmlSchemaAttribute)
			{
				XmlSchemaAttribute xmlSchemaAttribute = (XmlSchemaAttribute)o;
				if (xmlSchemaAttribute.Name == null || xmlSchemaAttribute.Name.Length == 0)
				{
					XmlQualifiedName parentName2 = GetParentName(o);
					return Res.GetString("XmlSchemaAttributeReference", xmlSchemaAttribute.RefName.ToString(), parentName2.Name, parentName2.Namespace);
				}
				return Res.GetString("XmlSchemaNamedItem", ns, "attribute", xmlSchemaAttribute.Name, details);
			}
			if (o is XmlSchemaContent)
			{
				XmlQualifiedName parentName3 = GetParentName(o);
				return Res.GetString("XmlSchemaContentDef", parentName3.Name, parentName3.Namespace, null);
			}
			if (o is XmlSchemaExternal)
			{
				string text2 = ((o is XmlSchemaImport) ? "import" : ((o is XmlSchemaInclude) ? "include" : ((o is XmlSchemaRedefine) ? "redefine" : o.GetType().Name)));
				return Res.GetString("XmlSchemaItem", ns, text2, details);
			}
			if (o is XmlSchema)
			{
				return Res.GetString("XmlSchema", ns, details);
			}
			return Res.GetString("XmlSchemaNamedItem", ns, o.GetType().Name, null, details);
		}

		private static string Dump(XmlSchemaObject o)
		{
			XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
			xmlWriterSettings.OmitXmlDeclaration = true;
			xmlWriterSettings.Indent = true;
			XmlSerializer xmlSerializer = new XmlSerializer(o.GetType());
			StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			XmlWriter xmlWriter = XmlWriter.Create(stringWriter, xmlWriterSettings);
			XmlSerializerNamespaces xmlSerializerNamespaces = new XmlSerializerNamespaces();
			xmlSerializerNamespaces.Add("xs", "http://www.w3.org/2001/XMLSchema");
			xmlSerializer.Serialize(xmlWriter, o, xmlSerializerNamespaces);
			return stringWriter.ToString();
		}

		private static string MergeFailedMessage(XmlSchemaObject src, XmlSchemaObject dest, string ns)
		{
			string @string = Res.GetString("XmlSerializableMergeItem", ns, GetSchemaItem(src, ns, null));
			@string = @string + "\r\n" + Dump(src);
			return @string + "\r\n" + Dump(dest);
		}

		internal XmlSchemaObject Find(XmlSchemaObject o, IList originals)
		{
			string text = ItemName(o);
			if (text == null)
			{
				return null;
			}
			Type type = o.GetType();
			foreach (XmlSchema original in originals)
			{
				foreach (XmlSchemaObject item in original.Items)
				{
					if (item.GetType() == type && text == ItemName(item))
					{
						return item;
					}
				}
			}
			return null;
		}

		public void Compile(ValidationEventHandler handler, bool fullCompile)
		{
			if (isCompiled)
			{
				return;
			}
			foreach (XmlSchema value in delayedSchemas.Values)
			{
				Merge(value);
			}
			delayedSchemas.Clear();
			if (fullCompile)
			{
				schemaSet = new XmlSchemaSet();
				schemaSet.XmlResolver = null;
				schemaSet.ValidationEventHandler += handler;
				foreach (XmlSchema value2 in References.Values)
				{
					schemaSet.Add(value2);
				}
				int num = schemaSet.Count;
				foreach (XmlSchema item in base.List)
				{
					if (!SchemaSet.Contains(item))
					{
						schemaSet.Add(item);
						num++;
					}
				}
				if (!SchemaSet.Contains("http://www.w3.org/2001/XMLSchema"))
				{
					AddReference(XsdSchema);
					schemaSet.Add(XsdSchema);
					num++;
				}
				if (!SchemaSet.Contains("http://www.w3.org/XML/1998/namespace"))
				{
					AddReference(XmlSchema);
					schemaSet.Add(XmlSchema);
					num++;
				}
				schemaSet.Compile();
				schemaSet.ValidationEventHandler -= handler;
				isCompiled = schemaSet.IsCompiled && num == schemaSet.Count;
				return;
			}
			try
			{
				XmlNameTable nameTable = new System.Xml.NameTable();
				Preprocessor preprocessor = new Preprocessor(nameTable, new SchemaNames(nameTable), null);
				preprocessor.XmlResolver = null;
				preprocessor.SchemaLocations = new Hashtable();
				preprocessor.ChameleonSchemas = new Hashtable();
				foreach (XmlSchema item2 in SchemaSet.Schemas())
				{
					preprocessor.Execute(item2, item2.TargetNamespace, loadExternals: true);
				}
			}
			catch (XmlSchemaException ex)
			{
				throw CreateValidationException(ex, ex.Message);
			}
		}

		internal static Exception CreateValidationException(XmlSchemaException exception, string message)
		{
			XmlSchemaObject xmlSchemaObject = exception.SourceSchemaObject;
			if (exception.LineNumber == 0 && exception.LinePosition == 0)
			{
				throw new InvalidOperationException(GetSchemaItem(xmlSchemaObject, null, message), exception);
			}
			string text = null;
			if (xmlSchemaObject != null)
			{
				while (xmlSchemaObject.Parent != null)
				{
					xmlSchemaObject = xmlSchemaObject.Parent;
				}
				if (xmlSchemaObject is XmlSchema)
				{
					text = ((XmlSchema)xmlSchemaObject).TargetNamespace;
				}
			}
			throw new InvalidOperationException(Res.GetString("XmlSchemaSyntaxErrorDetails", text, message, exception.LineNumber, exception.LinePosition), exception);
		}

		internal static void IgnoreCompileErrors(object sender, ValidationEventArgs args)
		{
		}

		private static XmlSchema CreateFakeXsdSchema(string ns, string name)
		{
			XmlSchema xmlSchema = new XmlSchema();
			xmlSchema.TargetNamespace = ns;
			XmlSchemaElement xmlSchemaElement = new XmlSchemaElement();
			xmlSchemaElement.Name = name;
			XmlSchemaComplexType xmlSchemaComplexType = (XmlSchemaComplexType)(xmlSchemaElement.SchemaType = new XmlSchemaComplexType());
			xmlSchema.Items.Add(xmlSchemaElement);
			return xmlSchema;
		}

		internal void SetCache(SchemaObjectCache cache, bool shareTypes)
		{
			this.shareTypes = shareTypes;
			this.cache = cache;
			if (shareTypes)
			{
				cache.GenerateSchemaGraph(this);
			}
		}

		internal bool IsReference(XmlSchemaObject type)
		{
			XmlSchemaObject xmlSchemaObject = type;
			while (xmlSchemaObject.Parent != null)
			{
				xmlSchemaObject = xmlSchemaObject.Parent;
			}
			return References.Contains(xmlSchemaObject);
		}
	}
	public class XmlSchemaEnumerator : IEnumerator<XmlSchema>, IDisposable, IEnumerator
	{
		private XmlSchemas list;

		private int idx;

		private int end;

		public XmlSchema Current => list[idx];

		object IEnumerator.Current => list[idx];

		public XmlSchemaEnumerator(XmlSchemas list)
		{
			this.list = list;
			idx = -1;
			end = list.Count - 1;
		}

		public void Dispose()
		{
		}

		public bool MoveNext()
		{
			if (idx >= end)
			{
				return false;
			}
			idx++;
			return true;
		}

		void IEnumerator.Reset()
		{
			idx = -1;
		}
	}
	public abstract class XmlSerializationGeneratedCode
	{
		private TempAssembly tempAssembly;

		private int threadCode;

		private ResolveEventHandler assemblyResolver;

		internal void Init(TempAssembly tempAssembly)
		{
			this.tempAssembly = tempAssembly;
			if (tempAssembly != null && tempAssembly.NeedAssembyResolve)
			{
				threadCode = Thread.CurrentThread.GetHashCode();
				assemblyResolver = OnAssemblyResolve;
				AppDomain.CurrentDomain.AssemblyResolve += assemblyResolver;
			}
		}

		internal void Dispose()
		{
			if (assemblyResolver != null)
			{
				AppDomain.CurrentDomain.AssemblyResolve -= assemblyResolver;
			}
			assemblyResolver = null;
		}

		internal Assembly OnAssemblyResolve(object sender, ResolveEventArgs args)
		{
			if (tempAssembly != null && Thread.CurrentThread.GetHashCode() == threadCode)
			{
				return tempAssembly.GetReferencedAssembly(args.Name);
			}
			return null;
		}
	}
	internal class XmlSerializationCodeGen
	{
		private IndentedWriter writer;

		private int nextMethodNumber;

		private Hashtable methodNames = new Hashtable();

		private ReflectionAwareCodeGen raCodeGen;

		private TypeScope[] scopes;

		private TypeDesc stringTypeDesc;

		private TypeDesc qnameTypeDesc;

		private string access;

		private string className;

		private TypeMapping[] referencedMethods;

		private int references;

		private Hashtable generatedMethods = new Hashtable();

		internal IndentedWriter Writer => writer;

		internal int NextMethodNumber
		{
			get
			{
				return nextMethodNumber;
			}
			set
			{
				nextMethodNumber = value;
			}
		}

		internal ReflectionAwareCodeGen RaCodeGen => raCodeGen;

		internal TypeDesc StringTypeDesc => stringTypeDesc;

		internal TypeDesc QnameTypeDesc => qnameTypeDesc;

		internal string ClassName => className;

		internal string Access => access;

		internal TypeScope[] Scopes => scopes;

		internal Hashtable MethodNames => methodNames;

		internal Hashtable GeneratedMethods => generatedMethods;

		internal XmlSerializationCodeGen(IndentedWriter writer, TypeScope[] scopes, string access, string className)
		{
			this.writer = writer;
			this.scopes = scopes;
			if (scopes.Length > 0)
			{
				stringTypeDesc = scopes[0].GetTypeDesc(typeof(string));
				qnameTypeDesc = scopes[0].GetTypeDesc(typeof(XmlQualifiedName));
			}
			raCodeGen = new ReflectionAwareCodeGen(writer);
			this.className = className;
			this.access = access;
		}

		internal virtual void GenerateMethod(TypeMapping mapping)
		{
		}

		internal void GenerateReferencedMethods()
		{
			while (references > 0)
			{
				TypeMapping mapping = referencedMethods[--references];
				GenerateMethod(mapping);
			}
		}

		internal string ReferenceMapping(TypeMapping mapping)
		{
			if (!mapping.IsSoap && generatedMethods[mapping] == null)
			{
				referencedMethods = EnsureArrayIndex(referencedMethods, references);
				referencedMethods[references++] = mapping;
			}
			return (string)methodNames[mapping];
		}

		private TypeMapping[] EnsureArrayIndex(TypeMapping[] a, int index)
		{
			if (a == null)
			{
				return new TypeMapping[32];
			}
			if (index < a.Length)
			{
				return a;
			}
			TypeMapping[] array = new TypeMapping[a.Length + 32];
			Array.Copy(a, array, index);
			return array;
		}

		internal void WriteQuotedCSharpString(string value)
		{
			raCodeGen.WriteQuotedCSharpString(value);
		}

		internal void GenerateHashtableGetBegin(string privateName, string publicName)
		{
			writer.Write(typeof(Hashtable).FullName);
			writer.Write(" ");
			writer.Write(privateName);
			writer.WriteLine(" = null;");
			writer.Write("public override ");
			writer.Write(typeof(Hashtable).FullName);
			writer.Write(" ");
			writer.Write(publicName);
			writer.WriteLine(" {");
			writer.Indent++;
			writer.WriteLine("get {");
			writer.Indent++;
			writer.Write("if (");
			writer.Write(privateName);
			writer.WriteLine(" == null) {");
			writer.Indent++;
			writer.Write(typeof(Hashtable).FullName);
			writer.Write(" _tmp = new ");
			writer.Write(typeof(Hashtable).FullName);
			writer.WriteLine("();");
		}

		internal void GenerateHashtableGetEnd(string privateName)
		{
			writer.Write("if (");
			writer.Write(privateName);
			writer.Write(" == null) ");
			writer.Write(privateName);
			writer.WriteLine(" = _tmp;");
			writer.Indent--;
			writer.WriteLine("}");
			writer.Write("return ");
			writer.Write(privateName);
			writer.WriteLine(";");
			writer.Indent--;
			writer.WriteLine("}");
			writer.Indent--;
			writer.WriteLine("}");
		}

		internal void GeneratePublicMethods(string privateName, string publicName, string[] methods, XmlMapping[] xmlMappings)
		{
			GenerateHashtableGetBegin(privateName, publicName);
			if (methods != null && methods.Length != 0 && xmlMappings != null && xmlMappings.Length == methods.Length)
			{
				for (int i = 0; i < methods.Length; i++)
				{
					if (methods[i] != null)
					{
						writer.Write("_tmp[");
						WriteQuotedCSharpString(xmlMappings[i].Key);
						writer.Write("] = ");
						WriteQuotedCSharpString(methods[i]);
						writer.WriteLine(";");
					}
				}
			}
			GenerateHashtableGetEnd(privateName);
		}

		internal void GenerateSupportedTypes(Type[] types)
		{
			writer.Write("public override ");
			writer.Write(typeof(bool).FullName);
			writer.Write(" CanSerialize(");
			writer.Write(typeof(Type).FullName);
			writer.WriteLine(" type) {");
			writer.Indent++;
			Hashtable hashtable = new Hashtable();
			foreach (Type type in types)
			{
				if (type != null && (type.IsPublic || type.IsNestedPublic) && hashtable[type] == null && !DynamicAssemblies.IsTypeDynamic(type) && !type.IsGenericType && (!type.ContainsGenericParameters || !DynamicAssemblies.IsTypeDynamic(type.GetGenericArguments())))
				{
					hashtable[type] = type;
					writer.Write("if (type == typeof(");
					writer.Write(CodeIdentifier.GetCSharpName(type));
					writer.WriteLine(")) return true;");
				}
			}
			writer.WriteLine("return false;");
			writer.Indent--;
			writer.WriteLine("}");
		}

		internal string GenerateBaseSerializer(string baseSerializer, string readerClass, string writerClass, CodeIdentifiers classes)
		{
			baseSerializer = CodeIdentifier.MakeValid(baseSerializer);
			baseSerializer = classes.AddUnique(baseSerializer, baseSerializer);
			writer.WriteLine();
			writer.Write("public abstract class ");
			writer.Write(CodeIdentifier.GetCSharpName(baseSerializer));
			writer.Write(" : ");
			writer.Write(typeof(XmlSerializer).FullName);
			writer.WriteLine(" {");
			writer.Indent++;
			writer.Write("protected override ");
			writer.Write(typeof(XmlSerializationReader).FullName);
			writer.WriteLine(" CreateReader() {");
			writer.Indent++;
			writer.Write("return new ");
			writer.Write(readerClass);
			writer.WriteLine("();");
			writer.Indent--;
			writer.WriteLine("}");
			writer.Write("protected override ");
			writer.Write(typeof(XmlSerializationWriter).FullName);
			writer.WriteLine(" CreateWriter() {");
			writer.Indent++;
			writer.Write("return new ");
			writer.Write(writerClass);
			writer.WriteLine("();");
			writer.Indent--;
			writer.WriteLine("}");
			writer.Indent--;
			writer.WriteLine("}");
			return baseSerializer;
		}

		internal string GenerateTypedSerializer(string readMethod, string writeMethod, XmlMapping mapping, CodeIdentifiers classes, string baseSerializer, string readerClass, string writerClass)
		{
			string text = CodeIdentifier.MakeValid(Accessor.UnescapeName(mapping.Accessor.Mapping.TypeDesc.Name));
			text = classes.AddUnique(text + "Serializer", mapping);
			writer.WriteLine();
			writer.Write("public sealed class ");
			writer.Write(CodeIdentifier.GetCSharpName(text));
			writer.Write(" : ");
			writer.Write(baseSerializer);
			writer.WriteLine(" {");
			writer.Indent++;
			writer.WriteLine();
			writer.Write("public override ");
			writer.Write(typeof(bool).FullName);
			writer.Write(" CanDeserialize(");
			writer.Write(typeof(XmlReader).FullName);
			writer.WriteLine(" xmlReader) {");
			writer.Indent++;
			if (mapping.Accessor.Any)
			{
				writer.WriteLine("return true;");
			}
			else
			{
				writer.Write("return xmlReader.IsStartElement(");
				WriteQuotedCSharpString(mapping.Accessor.Name);
				writer.Write(", ");
				WriteQuotedCSharpString(mapping.Accessor.Namespace);
				writer.WriteLine(");");
			}
			writer.Indent--;
			writer.WriteLine("}");
			if (writeMethod != null)
			{
				writer.WriteLine();
				writer.Write("protected override void Serialize(object objectToSerialize, ");
				writer.Write(typeof(XmlSerializationWriter).FullName);
				writer.WriteLine(" writer) {");
				writer.Indent++;
				writer.Write("((");
				writer.Write(writerClass);
				writer.Write(")writer).");
				writer.Write(writeMethod);
				writer.Write("(");
				if (mapping is XmlMembersMapping)
				{
					writer.Write("(object[])");
				}
				writer.WriteLine("objectToSerialize);");
				writer.Indent--;
				writer.WriteLine("}");
			}
			if (readMethod != null)
			{
				writer.WriteLine();
				writer.Write("protected override object Deserialize(");
				writer.Write(typeof(XmlSerializationReader).FullName);
				writer.WriteLine(" reader) {");
				writer.Indent++;
				writer.Write("return ((");
				writer.Write(readerClass);
				writer.Write(")reader).");
				writer.Write(readMethod);
				writer.WriteLine("();");
				writer.Indent--;
				writer.WriteLine("}");
			}
			writer.Indent--;
			writer.WriteLine("}");
			return text;
		}

		private void GenerateTypedSerializers(Hashtable serializers)
		{
			string privateName = "typedSerializers";
			GenerateHashtableGetBegin(privateName, "TypedSerializers");
			foreach (string key in serializers.Keys)
			{
				writer.Write("_tmp.Add(");
				WriteQuotedCSharpString(key);
				writer.Write(", new ");
				writer.Write((string)serializers[key]);
				writer.WriteLine("());");
			}
			GenerateHashtableGetEnd("typedSerializers");
		}

		private void GenerateGetSerializer(Hashtable serializers, XmlMapping[] xmlMappings)
		{
			writer.Write("public override ");
			writer.Write(typeof(XmlSerializer).FullName);
			writer.Write(" GetSerializer(");
			writer.Write(typeof(Type).FullName);
			writer.WriteLine(" type) {");
			writer.Indent++;
			for (int i = 0; i < xmlMappings.Length; i++)
			{
				if (xmlMappings[i] is XmlTypeMapping)
				{
					Type type = xmlMappings[i].Accessor.Mapping.TypeDesc.Type;
					if (type != null && (type.IsPublic || type.IsNestedPublic) && !DynamicAssemblies.IsTypeDynamic(type) && !type.IsGenericType && (!type.ContainsGenericParameters || !DynamicAssemblies.IsTypeDynamic(type.GetGenericArguments())))
					{
						writer.Write("if (type == typeof(");
						writer.Write(CodeIdentifier.GetCSharpName(type));
						writer.Write(")) return new ");
						writer.Write((string)serializers[xmlMappings[i].Key]);
						writer.WriteLine("();");
					}
				}
			}
			writer.WriteLine("return null;");
			writer.Indent--;
			writer.WriteLine("}");
		}

		internal void GenerateSerializerContract(string className, XmlMapping[] xmlMappings, Type[] types, string readerType, string[] readMethods, string writerType, string[] writerMethods, Hashtable serializers)
		{
			writer.WriteLine();
			writer.Write("public class XmlSerializerContract : global::");
			writer.Write(typeof(XmlSerializerImplementation).FullName);
			writer.WriteLine(" {");
			writer.Indent++;
			writer.Write("public override global::");
			writer.Write(typeof(XmlSerializationReader).FullName);
			writer.Write(" Reader { get { return new ");
			writer.Write(readerType);
			writer.WriteLine("(); } }");
			writer.Write("public override global::");
			writer.Write(typeof(XmlSerializationWriter).FullName);
			writer.Write(" Writer { get { return new ");
			writer.Write(writerType);
			writer.WriteLine("(); } }");
			GeneratePublicMethods("readMethods", "ReadMethods", readMethods, xmlMappings);
			GeneratePublicMethods("writeMethods", "WriteMethods", writerMethods, xmlMappings);
			GenerateTypedSerializers(serializers);
			GenerateSupportedTypes(types);
			GenerateGetSerializer(serializers, xmlMappings);
			writer.Indent--;
			writer.WriteLine("}");
		}

		internal static bool IsWildcard(SpecialMapping mapping)
		{
			if (mapping is SerializableMapping)
			{
				return ((SerializableMapping)mapping).IsAny;
			}
			return mapping.TypeDesc.CanBeElementValue;
		}
	}
	public abstract class XmlSerializationReader : XmlSerializationGeneratedCode
	{
		private struct SoapArrayInfo
		{
			public string qname;

			public int dimensions;

			public int length;

			public int jaggedDimensions;
		}

		protected class Fixup
		{
			private XmlSerializationFixupCallback callback;

			private object source;

			private string[] ids;

			public XmlSerializationFixupCallback Callback => callback;

			public object Source
			{
				get
				{
					return source;
				}
				set
				{
					source = value;
				}
			}

			public string[] Ids => ids;

			public Fixup(object o, XmlSerializationFixupCallback callback, int count)
				: this(o, callback, new string[count])
			{
			}

			public Fixup(object o, XmlSerializationFixupCallback callback, string[] ids)
			{
				this.callback = callback;
				Source = o;
				this.ids = ids;
			}
		}

		protected class CollectionFixup
		{
			private XmlSerializationCollectionFixupCallback callback;

			private object collection;

			private object collectionItems;

			public XmlSerializationCollectionFixupCallback Callback => callback;

			public object Collection => collection;

			public object CollectionItems => collectionItems;

			public CollectionFixup(object collection, XmlSerializationCollectionFixupCallback callback, object collectionItems)
			{
				this.callback = callback;
				this.collection = collection;
				this.collectionItems = collectionItems;
			}
		}

		private XmlReader r;

		private XmlCountingReader countingReader;

		private XmlDocument d;

		private Hashtable callbacks;

		private Hashtable types;

		private Hashtable typesReverse;

		private XmlDeserializationEvents events;

		private Hashtable targets;

		private Hashtable referencedTargets;

		private ArrayList targetsWithoutIds;

		private ArrayList fixups;

		private ArrayList collectionFixups;

		private bool soap12;

		private bool isReturnValue;

		private bool decodeName = true;

		private string schemaNsID;

		private string schemaNs1999ID;

		private string schemaNs2000ID;

		private string schemaNonXsdTypesNsID;

		private string instanceNsID;

		private string instanceNs2000ID;

		private string instanceNs1999ID;

		private string soapNsID;

		private string soap12NsID;

		private string schemaID;

		private string wsdlNsID;

		private string wsdlArrayTypeID;

		private string nullID;

		private string nilID;

		private string typeID;

		private string arrayTypeID;

		private string itemTypeID;

		private string arraySizeID;

		private string arrayID;

		private string urTypeID;

		private string stringID;

		private string intID;

		private string booleanID;

		private string shortID;

		private string longID;

		private string floatID;

		private string doubleID;

		private string decimalID;

		private string dateTimeID;

		private string qnameID;

		private string dateID;

		private string timeID;

		private string hexBinaryID;

		private string base64BinaryID;

		private string base64ID;

		private string unsignedByteID;

		private string byteID;

		private string unsignedShortID;

		private string unsignedIntID;

		private string unsignedLongID;

		private string oldDecimalID;

		private string oldTimeInstantID;

		private string anyURIID;

		private string durationID;

		private string ENTITYID;

		private string ENTITIESID;

		private string gDayID;

		private string gMonthID;

		private string gMonthDayID;

		private string gYearID;

		private string gYearMonthID;

		private string IDID;

		private string IDREFID;

		private string IDREFSID;

		private string integerID;

		private string languageID;

		private string NameID;

		private string NCNameID;

		private string NMTOKENID;

		private string NMTOKENSID;

		private string negativeIntegerID;

		private string nonPositiveIntegerID;

		private string nonNegativeIntegerID;

		private string normalizedStringID;

		private string NOTATIONID;

		private string positiveIntegerID;

		private string tokenID;

		private string charID;

		private string guidID;

		private static bool checkDeserializeAdvances;

		protected bool DecodeName
		{
			get
			{
				return decodeName;
			}
			set
			{
				decodeName = value;
			}
		}

		protected XmlReader Reader => r;

		protected int ReaderCount
		{
			get
			{
				if (!checkDeserializeAdvances)
				{
					return 0;
				}
				return countingReader.AdvanceCount;
			}
		}

		protected XmlDocument Document
		{
			get
			{
				if (d == null)
				{
					d = new XmlDocument(r.NameTable);
					d.SetBaseURI(r.BaseURI);
				}
				return d;
			}
		}

		protected bool IsReturnValue
		{
			get
			{
				if (isReturnValue)
				{
					return !soap12;
				}
				return false;
			}
			set
			{
				isReturnValue = value;
			}
		}

		static XmlSerializationReader()
		{
			checkDeserializeAdvances = ConfigurationManager.GetSection(ConfigurationStrings.XmlSerializerSectionPath) is XmlSerializerSection xmlSerializerSection && xmlSerializerSection.CheckDeserializeAdvances;
		}

		protected abstract void InitIDs();

		internal void Init(XmlReader r, XmlDeserializationEvents events, string encodingStyle, TempAssembly tempAssembly)
		{
			this.events = events;
			if (checkDeserializeAdvances)
			{
				countingReader = new XmlCountingReader(r);
				this.r = countingReader;
			}
			else
			{
				this.r = r;
			}
			d = null;
			soap12 = encodingStyle == "http://www.w3.org/2003/05/soap-encoding";
			Init(tempAssembly);
			schemaNsID = r.NameTable.Add("http://www.w3.org/2001/XMLSchema");
			schemaNs2000ID = r.NameTable.Add("http://www.w3.org/2000/10/XMLSchema");
			schemaNs1999ID = r.NameTable.Add("http://www.w3.org/1999/XMLSchema");
			schemaNonXsdTypesNsID = r.NameTable.Add("http://microsoft.com/wsdl/types/");
			instanceNsID = r.NameTable.Add("http://www.w3.org/2001/XMLSchema-instance");
			instanceNs2000ID = r.NameTable.Add("http://www.w3.org/2000/10/XMLSchema-instance");
			instanceNs1999ID = r.NameTable.Add("http://www.w3.org/1999/XMLSchema-instance");
			soapNsID = r.NameTable.Add("http://schemas.xmlsoap.org/soap/encoding/");
			soap12NsID = r.NameTable.Add("http://www.w3.org/2003/05/soap-encoding");
			schemaID = r.NameTable.Add("schema");
			wsdlNsID = r.NameTable.Add("http://schemas.xmlsoap.org/wsdl/");
			wsdlArrayTypeID = r.NameTable.Add("arrayType");
			nullID = r.NameTable.Add("null");
			nilID = r.NameTable.Add("nil");
			typeID = r.NameTable.Add("type");
			arrayTypeID = r.NameTable.Add("arrayType");
			itemTypeID = r.NameTable.Add("itemType");
			arraySizeID = r.NameTable.Add("arraySize");
			arrayID = r.NameTable.Add("Array");
			urTypeID = r.NameTable.Add("anyType");
			InitIDs();
		}

		protected static Assembly ResolveDynamicAssembly(string assemblyFullName)
		{
			return DynamicAssemblies.Get(assemblyFullName);
		}

		private void InitPrimitiveIDs()
		{
			if (tokenID == null)
			{
				r.NameTable.Add("http://www.w3.org/2001/XMLSchema");
				r.NameTable.Add("http://microsoft.com/wsdl/types/");
				stringID = r.NameTable.Add("string");
				intID = r.NameTable.Add("int");
				booleanID = r.NameTable.Add("boolean");
				shortID = r.NameTable.Add("short");
				longID = r.NameTable.Add("long");
				floatID = r.NameTable.Add("float");
				doubleID = r.NameTable.Add("double");
				decimalID = r.NameTable.Add("decimal");
				dateTimeID = r.NameTable.Add("dateTime");
				qnameID = r.NameTable.Add("QName");
				dateID = r.NameTable.Add("date");
				timeID = r.NameTable.Add("time");
				hexBinaryID = r.NameTable.Add("hexBinary");
				base64BinaryID = r.NameTable.Add("base64Binary");
				unsignedByteID = r.NameTable.Add("unsignedByte");
				byteID = r.NameTable.Add("byte");
				unsignedShortID = r.NameTable.Add("unsignedShort");
				unsignedIntID = r.NameTable.Add("unsignedInt");
				unsignedLongID = r.NameTable.Add("unsignedLong");
				oldDecimalID = r.NameTable.Add("decimal");
				oldTimeInstantID = r.NameTable.Add("timeInstant");
				charID = r.NameTable.Add("char");
				guidID = r.NameTable.Add("guid");
				base64ID = r.NameTable.Add("base64");
				anyURIID = r.NameTable.Add("anyURI");
				durationID = r.NameTable.Add("duration");
				ENTITYID = r.NameTable.Add("ENTITY");
				ENTITIESID = r.NameTable.Add("ENTITIES");
				gDayID = r.NameTable.Add("gDay");
				gMonthID = r.NameTable.Add("gMonth");
				gMonthDayID = r.NameTable.Add("gMonthDay");
				gYearID = r.NameTable.Add("gYear");
				gYearMonthID = r.NameTable.Add("gYearMonth");
				IDID = r.NameTable.Add("ID");
				IDREFID = r.NameTable.Add("IDREF");
				IDREFSID = r.NameTable.Add("IDREFS");
				integerID = r.NameTable.Add("integer");
				languageID = r.NameTable.Add("language");
				NameID = r.NameTable.Add("Name");
				NCNameID = r.NameTable.Add("NCName");
				NMTOKENID = r.NameTable.Add("NMTOKEN");
				NMTOKENSID = r.NameTable.Add("NMTOKENS");
				negativeIntegerID = r.NameTable.Add("negativeInteger");
				nonNegativeIntegerID = r.NameTable.Add("nonNegativeInteger");
				nonPositiveIntegerID = r.NameTable.Add("nonPositiveInteger");
				normalizedStringID = r.NameTable.Add("normalizedString");
				NOTATIONID = r.NameTable.Add("NOTATION");
				positiveIntegerID = r.NameTable.Add("positiveInteger");
				tokenID = r.NameTable.Add("token");
			}
		}

		protected XmlQualifiedName GetXsiType()
		{
			string attribute = r.GetAttribute(typeID, instanceNsID);
			if (attribute == null)
			{
				attribute = r.GetAttribute(typeID, instanceNs2000ID);
				if (attribute == null)
				{
					attribute = r.GetAttribute(typeID, instanceNs1999ID);
					if (attribute == null)
					{
						return null;
					}
				}
			}
			return ToXmlQualifiedName(attribute, decodeName: false);
		}

		private Type GetPrimitiveType(XmlQualifiedName typeName, bool throwOnUnknown)
		{
			InitPrimitiveIDs();
			if ((object)typeName.Namespace == schemaNsID || (object)typeName.Namespace == soapNsID || (object)typeName.Namespace == soap12NsID)
			{
				if ((object)typeName.Name == stringID || (object)typeName.Name == anyURIID || (object)typeName.Name == durationID || (object)typeName.Name == ENTITYID || (object)typeName.Name == ENTITIESID || (object)typeName.Name == gDayID || (object)typeName.Name == gMonthID || (object)typeName.Name == gMonthDayID || (object)typeName.Name == gYearID || (object)typeName.Name == gYearMonthID || (object)typeName.Name == IDID || (object)typeName.Name == IDREFID || (object)typeName.Name == IDREFSID || (object)typeName.Name == integerID || (object)typeName.Name == languageID || (object)typeName.Name == NameID || (object)typeName.Name == NCNameID || (object)typeName.Name == NMTOKENID || (object)typeName.Name == NMTOKENSID || (object)typeName.Name == negativeIntegerID || (object)typeName.Name == nonPositiveIntegerID || (object)typeName.Name == nonNegativeIntegerID || (object)typeName.Name == normalizedStringID || (object)typeName.Name == NOTATIONID || (object)typeName.Name == positiveIntegerID || (object)typeName.Name == tokenID)
				{
					return typeof(string);
				}
				if ((object)typeName.Name == intID)
				{
					return typeof(int);
				}
				if ((object)typeName.Name == booleanID)
				{
					return typeof(bool);
				}
				if ((object)typeName.Name == shortID)
				{
					return typeof(short);
				}
				if ((object)typeName.Name == longID)
				{
					return typeof(long);
				}
				if ((object)typeName.Name == floatID)
				{
					return typeof(float);
				}
				if ((object)typeName.Name == doubleID)
				{
					return typeof(double);
				}
				if ((object)typeName.Name == decimalID)
				{
					return typeof(decimal);
				}
				if ((object)typeName.Name == dateTimeID)
				{
					return typeof(DateTime);
				}
				if ((object)typeName.Name == qnameID)
				{
					return typeof(XmlQualifiedName);
				}
				if ((object)typeName.Name == dateID)
				{
					return typeof(DateTime);
				}
				if ((object)typeName.Name == timeID)
				{
					return typeof(DateTime);
				}
				if ((object)typeName.Name == hexBinaryID)
				{
					return typeof(byte[]);
				}
				if ((object)typeName.Name == base64BinaryID)
				{
					return typeof(byte[]);
				}
				if ((object)typeName.Name == unsignedByteID)
				{
					return typeof(byte);
				}
				if ((object)typeName.Name == byteID)
				{
					return typeof(sbyte);
				}
				if ((object)typeName.Name == unsignedShortID)
				{
					return typeof(ushort);
				}
				if ((object)typeName.Name == unsignedIntID)
				{
					return typeof(uint);
				}
				if ((object)typeName.Name == unsignedLongID)
				{
					return typeof(ulong);
				}
				throw CreateUnknownTypeException(typeName);
			}
			if ((object)typeName.Namespace == schemaNs2000ID || (object)typeName.Namespace == schemaNs1999ID)
			{
				if ((object)typeName.Name == stringID || (object)typeName.Name == anyURIID || (object)typeName.Name == durationID || (object)typeName.Name == ENTITYID || (object)typeName.Name == ENTITIESID || (object)typeName.Name == gDayID || (object)typeName.Name == gMonthID || (object)typeName.Name == gMonthDayID || (object)typeName.Name == gYearID || (object)typeName.Name == gYearMonthID || (object)typeName.Name == IDID || (object)typeName.Name == IDREFID || (object)typeName.Name == IDREFSID || (object)typeName.Name == integerID || (object)typeName.Name == languageID || (object)typeName.Name == NameID || (object)typeName.Name == NCNameID || (object)typeName.Name == NMTOKENID || (object)typeName.Name == NMTOKENSID || (object)typeName.Name == negativeIntegerID || (object)typeName.Name == nonPositiveIntegerID || (object)typeName.Name == nonNegativeIntegerID || (object)typeName.Name == normalizedStringID || (object)typeName.Name == NOTATIONID || (object)typeName.Name == positiveIntegerID || (object)typeName.Name == tokenID)
				{
					return typeof(string);
				}
				if ((object)typeName.Name == intID)
				{
					return typeof(int);
				}
				if ((object)typeName.Name == booleanID)
				{
					return typeof(bool);
				}
				if ((object)typeName.Name == shortID)
				{
					return typeof(short);
				}
				if ((object)typeName.Name == longID)
				{
					return typeof(long);
				}
				if ((object)typeName.Name == floatID)
				{
					return typeof(float);
				}
				if ((object)typeName.Name == doubleID)
				{
					return typeof(double);
				}
				if ((object)typeName.Name == oldDecimalID)
				{
					return typeof(decimal);
				}
				if ((object)typeName.Name == oldTimeInstantID)
				{
					return typeof(DateTime);
				}
				if ((object)typeName.Name == qnameID)
				{
					return typeof(XmlQualifiedName);
				}
				if ((object)typeName.Name == dateID)
				{
					return typeof(DateTime);
				}
				if ((object)typeName.Name == timeID)
				{
					return typeof(DateTime);
				}
				if ((object)typeName.Name == hexBinaryID)
				{
					return typeof(byte[]);
				}
				if ((object)typeName.Name == byteID)
				{
					return typeof(sbyte);
				}
				if ((object)typeName.Name == unsignedShortID)
				{
					return typeof(ushort);
				}
				if ((object)typeName.Name == unsignedIntID)
				{
					return typeof(uint);
				}
				if ((object)typeName.Name == unsignedLongID)
				{
					return typeof(ulong);
				}
				throw CreateUnknownTypeException(typeName);
			}
			if ((object)typeName.Namespace == schemaNonXsdTypesNsID)
			{
				if ((object)typeName.Name == charID)
				{
					return typeof(char);
				}
				if ((object)typeName.Name == guidID)
				{
					return typeof(Guid);
				}
				throw CreateUnknownTypeException(typeName);
			}
			if (throwOnUnknown)
			{
				throw CreateUnknownTypeException(typeName);
			}
			return null;
		}

		private bool IsPrimitiveNamespace(string ns)
		{
			if ((object)ns != schemaNsID && (object)ns != schemaNonXsdTypesNsID && (object)ns != soapNsID && (object)ns != soap12NsID && (object)ns != schemaNs2000ID)
			{
				return (object)ns == schemaNs1999ID;
			}
			return true;
		}

		private string ReadStringValue()
		{
			if (r.IsEmptyElement)
			{
				r.Skip();
				return string.Empty;
			}
			r.ReadStartElement();
			string result = r.ReadString();
			ReadEndElement();
			return result;
		}

		private XmlQualifiedName ReadXmlQualifiedName()
		{
			bool flag = false;
			string value;
			if (r.IsEmptyElement)
			{
				value = string.Empty;
				flag = true;
			}
			else
			{
				r.ReadStartElement();
				value = r.ReadString();
			}
			XmlQualifiedName result = ToXmlQualifiedName(value);
			if (flag)
			{
				r.Skip();
			}
			else
			{
				ReadEndElement();
			}
			return result;
		}

		private byte[] ReadByteArray(bool isBase64)
		{
			ArrayList arrayList = new ArrayList();
			int num = 1024;
			int num2 = -1;
			int num3 = 0;
			int num4 = 0;
			byte[] array = new byte[num];
			arrayList.Add(array);
			while (num2 != 0)
			{
				if (num3 == array.Length)
				{
					num = Math.Min(num * 2, 65536);
					array = new byte[num];
					num3 = 0;
					arrayList.Add(array);
				}
				num2 = ((!isBase64) ? r.ReadElementContentAsBinHex(array, num3, array.Length - num3) : r.ReadElementContentAsBase64(array, num3, array.Length - num3));
				num3 += num2;
				num4 += num2;
			}
			byte[] array2 = new byte[num4];
			num3 = 0;
			foreach (byte[] item in arrayList)
			{
				num = Math.Min(item.Length, num4);
				if (num > 0)
				{
					Buffer.BlockCopy(item, 0, array2, num3, num);
					num3 += num;
					num4 -= num;
				}
			}
			arrayList.Clear();
			return array2;
		}

		protected object ReadTypedPrimitive(XmlQualifiedName type)
		{
			return ReadTypedPrimitive(type, elementCanBeType: false);
		}

		private object ReadTypedPrimitive(XmlQualifiedName type, bool elementCanBeType)
		{
			InitPrimitiveIDs();
			object obj = null;
			if (!IsPrimitiveNamespace(type.Namespace) || (object)type.Name == urTypeID)
			{
				return ReadXmlNodes(elementCanBeType);
			}
			if ((object)type.Namespace == schemaNsID || (object)type.Namespace == soapNsID || (object)type.Namespace == soap12NsID)
			{
				if ((object)type.Name == stringID || (object)type.Name == normalizedStringID)
				{
					return ReadStringValue();
				}
				if ((object)type.Name == anyURIID || (object)type.Name == durationID || (object)type.Name == ENTITYID || (object)type.Name == ENTITIESID || (object)type.Name == gDayID || (object)type.Name == gMonthID || (object)type.Name == gMonthDayID || (object)type.Name == gYearID || (object)type.Name == gYearMonthID || (object)type.Name == IDID || (object)type.Name == IDREFID || (object)type.Name == IDREFSID || (object)type.Name == integerID || (object)type.Name == languageID || (object)type.Name == NameID || (object)type.Name == NCNameID || (object)type.Name == NMTOKENID || (object)type.Name == NMTOKENSID || (object)type.Name == negativeIntegerID || (object)type.Name == nonPositiveIntegerID || (object)type.Name == nonNegativeIntegerID || (object)type.Name == NOTATIONID || (object)type.Name == positiveIntegerID || (object)type.Name == tokenID)
				{
					return CollapseWhitespace(ReadStringValue());
				}
				if ((object)type.Name == intID)
				{
					return XmlConvert.ToInt32(ReadStringValue());
				}
				if ((object)type.Name == booleanID)
				{
					return XmlConvert.ToBoolean(ReadStringValue());
				}
				if ((object)type.Name == shortID)
				{
					return XmlConvert.ToInt16(ReadStringValue());
				}
				if ((object)type.Name == longID)
				{
					return XmlConvert.ToInt64(ReadStringValue());
				}
				if ((object)type.Name == floatID)
				{
					return XmlConvert.ToSingle(ReadStringValue());
				}
				if ((object)type.Name == doubleID)
				{
					return XmlConvert.ToDouble(ReadStringValue());
				}
				if ((object)type.Name == decimalID)
				{
					return XmlConvert.ToDecimal(ReadStringValue());
				}
				if ((object)type.Name == dateTimeID)
				{
					return ToDateTime(ReadStringValue());
				}
				if ((object)type.Name == qnameID)
				{
					return ReadXmlQualifiedName();
				}
				if ((object)type.Name == dateID)
				{
					return ToDate(ReadStringValue());
				}
				if ((object)type.Name == timeID)
				{
					return ToTime(ReadStringValue());
				}
				if ((object)type.Name == unsignedByteID)
				{
					return XmlConvert.ToByte(ReadStringValue());
				}
				if ((object)type.Name == byteID)
				{
					return XmlConvert.ToSByte(ReadStringValue());
				}
				if ((object)type.Name == unsignedShortID)
				{
					return XmlConvert.ToUInt16(ReadStringValue());
				}
				if ((object)type.Name == unsignedIntID)
				{
					return XmlConvert.ToUInt32(ReadStringValue());
				}
				if ((object)type.Name == unsignedLongID)
				{
					return XmlConvert.ToUInt64(ReadStringValue());
				}
				if ((object)type.Name == hexBinaryID)
				{
					return ToByteArrayHex(isNull: false);
				}
				if ((object)type.Name == base64BinaryID)
				{
					return ToByteArrayBase64(isNull: false);
				}
				if ((object)type.Name == base64ID && ((object)type.Namespace == soapNsID || (object)type.Namespace == soap12NsID))
				{
					return ToByteArrayBase64(isNull: false);
				}
				return ReadXmlNodes(elementCanBeType);
			}
			if ((object)type.Namespace == schemaNs2000ID || (object)type.Namespace == schemaNs1999ID)
			{
				if ((object)type.Name == stringID || (object)type.Name == normalizedStringID)
				{
					return ReadStringValue();
				}
				if ((object)type.Name == anyURIID || (object)type.Name == anyURIID || (object)type.Name == durationID || (object)type.Name == ENTITYID || (object)type.Name == ENTITIESID || (object)type.Name == gDayID || (object)type.Name == gMonthID || (object)type.Name == gMonthDayID || (object)type.Name == gYearID || (object)type.Name == gYearMonthID || (object)type.Name == IDID || (object)type.Name == IDREFID || (object)type.Name == IDREFSID || (object)type.Name == integerID || (object)type.Name == languageID || (object)type.Name == NameID || (object)type.Name == NCNameID || (object)type.Name == NMTOKENID || (object)type.Name == NMTOKENSID || (object)type.Name == negativeIntegerID || (object)type.Name == nonPositiveIntegerID || (object)type.Name == nonNegativeIntegerID || (object)type.Name == NOTATIONID || (object)type.Name == positiveIntegerID || (object)type.Name == tokenID)
				{
					return CollapseWhitespace(ReadStringValue());
				}
				if ((object)type.Name == intID)
				{
					return XmlConvert.ToInt32(ReadStringValue());
				}
				if ((object)type.Name == booleanID)
				{
					return XmlConvert.ToBoolean(ReadStringValue());
				}
				if ((object)type.Name == shortID)
				{
					return XmlConvert.ToInt16(ReadStringValue());
				}
				if ((object)type.Name == longID)
				{
					return XmlConvert.ToInt64(ReadStringValue());
				}
				if ((object)type.Name == floatID)
				{
					return XmlConvert.ToSingle(ReadStringValue());
				}
				if ((object)type.Name == doubleID)
				{
					return XmlConvert.ToDouble(ReadStringValue());
				}
				if ((object)type.Name == oldDecimalID)
				{
					return XmlConvert.ToDecimal(ReadStringValue());
				}
				if ((object)type.Name == oldTimeInstantID)
				{
					return ToDateTime(ReadStringValue());
				}
				if ((object)type.Name == qnameID)
				{
					return ReadXmlQualifiedName();
				}
				if ((object)type.Name == dateID)
				{
					return ToDate(ReadStringValue());
				}
				if ((object)type.Name == timeID)
				{
					return ToTime(ReadStringValue());
				}
				if ((object)type.Name == unsignedByteID)
				{
					return XmlConvert.ToByte(ReadStringValue());
				}
				if ((object)type.Name == byteID)
				{
					return XmlConvert.ToSByte(ReadStringValue());
				}
				if ((object)type.Name == unsignedShortID)
				{
					return XmlConvert.ToUInt16(ReadStringValue());
				}
				if ((object)type.Name == unsignedIntID)
				{
					return XmlConvert.ToUInt32(ReadStringValue());
				}
				if ((object)type.Name == unsignedLongID)
				{
					return XmlConvert.ToUInt64(ReadStringValue());
				}
				return ReadXmlNodes(elementCanBeType);
			}
			if ((object)type.Namespace == schemaNonXsdTypesNsID)
			{
				if ((object)type.Name == charID)
				{
					return ToChar(ReadStringValue());
				}
				if ((object)type.Name == guidID)
				{
					return new Guid(CollapseWhitespace(ReadStringValue()));
				}
				return ReadXmlNodes(elementCanBeType);
			}
			return ReadXmlNodes(elementCanBeType);
		}

		protected object ReadTypedNull(XmlQualifiedName type)
		{
			InitPrimitiveIDs();
			object obj = null;
			if (!IsPrimitiveNamespace(type.Namespace) || (object)type.Name == urTypeID)
			{
				return null;
			}
			if ((object)type.Namespace == schemaNsID || (object)type.Namespace == soapNsID || (object)type.Namespace == soap12NsID)
			{
				if ((object)type.Name == stringID || (object)type.Name == anyURIID || (object)type.Name == durationID || (object)type.Name == ENTITYID || (object)type.Name == ENTITIESID || (object)type.Name == gDayID || (object)type.Name == gMonthID || (object)type.Name == gMonthDayID || (object)type.Name == gYearID || (object)type.Name == gYearMonthID || (object)type.Name == IDID || (object)type.Name == IDREFID || (object)type.Name == IDREFSID || (object)type.Name == integerID || (object)type.Name == languageID || (object)type.Name == NameID || (object)type.Name == NCNameID || (object)type.Name == NMTOKENID || (object)type.Name == NMTOKENSID || (object)type.Name == negativeIntegerID || (object)type.Name == nonPositiveIntegerID || (object)type.Name == nonNegativeIntegerID || (object)type.Name == normalizedStringID || (object)type.Name == NOTATIONID || (object)type.Name == positiveIntegerID || (object)type.Name == tokenID)
				{
					return null;
				}
				if ((object)type.Name == intID)
				{
					return (int?)null;
				}
				if ((object)type.Name == booleanID)
				{
					return (bool?)null;
				}
				if ((object)type.Name == shortID)
				{
					return (short?)null;
				}
				if ((object)type.Name == longID)
				{
					return (long?)null;
				}
				if ((object)type.Name == floatID)
				{
					return (float?)null;
				}
				if ((object)type.Name == doubleID)
				{
					return (double?)null;
				}
				if ((object)type.Name == decimalID)
				{
					return (decimal?)null;
				}
				if ((object)type.Name == dateTimeID)
				{
					return (DateTime?)null;
				}
				if ((object)type.Name == qnameID)
				{
					return null;
				}
				if ((object)type.Name == dateID)
				{
					return (DateTime?)null;
				}
				if ((object)type.Name == timeID)
				{
					return (DateTime?)null;
				}
				if ((object)type.Name == unsignedByteID)
				{
					return (byte?)null;
				}
				if ((object)type.Name == byteID)
				{
					return (sbyte?)null;
				}
				if ((object)type.Name == unsignedShortID)
				{
					return (ushort?)null;
				}
				if ((object)type.Name == unsignedIntID)
				{
					return (uint?)null;
				}
				if ((object)type.Name == unsignedLongID)
				{
					return (ulong?)null;
				}
				if ((object)type.Name == hexBinaryID)
				{
					return null;
				}
				if ((object)type.Name == base64BinaryID)
				{
					return null;
				}
				if ((object)type.Name == base64ID && ((object)type.Namespace == soapNsID || (object)type.Namespace == soap12NsID))
				{
					return null;
				}
				return null;
			}
			if ((object)type.Namespace == schemaNonXsdTypesNsID)
			{
				if ((object)type.Name == charID)
				{
					return (char?)null;
				}
				if ((object)type.Name == guidID)
				{
					return (Guid?)null;
				}
				return null;
			}
			return null;
		}

		protected bool IsXmlnsAttribute(string name)
		{
			if (!name.StartsWith("xmlns", StringComparison.Ordinal))
			{
				return false;
			}
			if (name.Length == 5)
			{
				return true;
			}
			return name[5] == ':';
		}

		protected void ParseWsdlArrayType(XmlAttribute attr)
		{
			if ((object)attr.LocalName == wsdlArrayTypeID && (object)attr.NamespaceURI == wsdlNsID)
			{
				int num = attr.Value.LastIndexOf(':');
				if (num < 0)
				{
					attr.Value = r.LookupNamespace("") + ":" + attr.Value;
				}
				else
				{
					attr.Value = r.LookupNamespace(attr.Value.Substring(0, num)) + ":" + attr.Value.Substring(num + 1);
				}
			}
		}

		protected bool ReadNull()
		{
			if (!GetNullAttr())
			{
				return false;
			}
			if (r.IsEmptyElement)
			{
				r.Skip();
				return true;
			}
			r.ReadStartElement();
			int whileIterations = 0;
			int readerCount = ReaderCount;
			while (r.NodeType != XmlNodeType.EndElement)
			{
				UnknownNode(null);
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			ReadEndElement();
			return true;
		}

		protected bool GetNullAttr()
		{
			string attribute = r.GetAttribute(nilID, instanceNsID);
			if (attribute == null)
			{
				attribute = r.GetAttribute(nullID, instanceNsID);
			}
			if (attribute == null)
			{
				attribute = r.GetAttribute(nullID, instanceNs2000ID);
				if (attribute == null)
				{
					attribute = r.GetAttribute(nullID, instanceNs1999ID);
				}
			}
			if (attribute == null || !XmlConvert.ToBoolean(attribute))
			{
				return false;
			}
			return true;
		}

		protected string ReadNullableString()
		{
			if (ReadNull())
			{
				return null;
			}
			return r.ReadElementString();
		}

		protected XmlQualifiedName ReadNullableQualifiedName()
		{
			if (ReadNull())
			{
				return null;
			}
			return ReadElementQualifiedName();
		}

		protected XmlQualifiedName ReadElementQualifiedName()
		{
			if (r.IsEmptyElement)
			{
				XmlQualifiedName result = new XmlQualifiedName(string.Empty, r.LookupNamespace(""));
				r.Skip();
				return result;
			}
			XmlQualifiedName result2 = ToXmlQualifiedName(CollapseWhitespace(r.ReadString()));
			r.ReadEndElement();
			return result2;
		}

		protected XmlDocument ReadXmlDocument(bool wrapped)
		{
			XmlNode xmlNode = ReadXmlNode(wrapped);
			if (xmlNode == null)
			{
				return null;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.AppendChild(xmlDocument.ImportNode(xmlNode, deep: true));
			return xmlDocument;
		}

		protected string CollapseWhitespace(string value)
		{
			return value?.Trim();
		}

		protected XmlNode ReadXmlNode(bool wrapped)
		{
			XmlNode result = null;
			if (wrapped)
			{
				if (ReadNull())
				{
					return null;
				}
				r.ReadStartElement();
				r.MoveToContent();
				if (r.NodeType != XmlNodeType.EndElement)
				{
					result = Document.ReadNode(r);
				}
				int whileIterations = 0;
				int readerCount = ReaderCount;
				while (r.NodeType != XmlNodeType.EndElement)
				{
					UnknownNode(null);
					CheckReaderCount(ref whileIterations, ref readerCount);
				}
				r.ReadEndElement();
			}
			else
			{
				result = Document.ReadNode(r);
			}
			return result;
		}

		protected static byte[] ToByteArrayBase64(string value)
		{
			return XmlCustomFormatter.ToByteArrayBase64(value);
		}

		protected byte[] ToByteArrayBase64(bool isNull)
		{
			if (isNull)
			{
				return null;
			}
			return ReadByteArray(isBase64: true);
		}

		protected static byte[] ToByteArrayHex(string value)
		{
			return XmlCustomFormatter.ToByteArrayHex(value);
		}

		protected byte[] ToByteArrayHex(bool isNull)
		{
			if (isNull)
			{
				return null;
			}
			return ReadByteArray(isBase64: false);
		}

		protected int GetArrayLength(string name, string ns)
		{
			if (GetNullAttr())
			{
				return 0;
			}
			string attribute = r.GetAttribute(arrayTypeID, soapNsID);
			SoapArrayInfo soapArrayInfo = ParseArrayType(attribute);
			if (soapArrayInfo.dimensions != 1)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidArrayDimentions", CurrentTag()));
			}
			XmlQualifiedName xmlQualifiedName = ToXmlQualifiedName(soapArrayInfo.qname, decodeName: false);
			if (xmlQualifiedName.Name != name)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidArrayTypeName", xmlQualifiedName.Name, name, CurrentTag()));
			}
			if (xmlQualifiedName.Namespace != ns)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidArrayTypeNamespace", xmlQualifiedName.Namespace, ns, CurrentTag()));
			}
			return soapArrayInfo.length;
		}

		private SoapArrayInfo ParseArrayType(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException(Res.GetString("XmlMissingArrayType", CurrentTag()));
			}
			if (value.Length == 0)
			{
				throw new ArgumentException(Res.GetString("XmlEmptyArrayType", CurrentTag()), "value");
			}
			char[] array = value.ToCharArray();
			int num = array.Length;
			SoapArrayInfo result = default(SoapArrayInfo);
			int num2 = num - 1;
			if (array[num2] != ']')
			{
				throw new ArgumentException(Res.GetString("XmlInvalidArraySyntax"), "value");
			}
			num2--;
			while (num2 != -1 && array[num2] != '[')
			{
				if (array[num2] == ',')
				{
					throw new ArgumentException(Res.GetString("XmlInvalidArrayDimentions", CurrentTag()), "value");
				}
				num2--;
			}
			if (num2 == -1)
			{
				throw new ArgumentException(Res.GetString("XmlMismatchedArrayBrackets"), "value");
			}
			int num3 = num - num2 - 2;
			if (num3 > 0)
			{
				string text = new string(array, num2 + 1, num3);
				try
				{
					result.length = int.Parse(text, CultureInfo.InvariantCulture);
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					throw new ArgumentException(Res.GetString("XmlInvalidArrayLength", text), "value");
				}
				catch
				{
					throw new ArgumentException(Res.GetString("XmlInvalidArrayLength", text), "value");
				}
			}
			else
			{
				result.length = -1;
			}
			num2--;
			result.jaggedDimensions = 0;
			while (num2 != -1 && array[num2] == ']')
			{
				num2--;
				if (num2 < 0)
				{
					throw new ArgumentException(Res.GetString("XmlMismatchedArrayBrackets"), "value");
				}
				if (array[num2] == ',')
				{
					throw new ArgumentException(Res.GetString("XmlInvalidArrayDimentions", CurrentTag()), "value");
				}
				if (array[num2] != '[')
				{
					throw new ArgumentException(Res.GetString("XmlInvalidArraySyntax"), "value");
				}
				num2--;
				result.jaggedDimensions++;
			}
			result.dimensions = 1;
			result.qname = new string(array, 0, num2 + 1);
			return result;
		}

		private SoapArrayInfo ParseSoap12ArrayType(string itemType, string arraySize)
		{
			SoapArrayInfo result = default(SoapArrayInfo);
			if (itemType != null && itemType.Length > 0)
			{
				result.qname = itemType;
			}
			else
			{
				result.qname = "";
			}
			string[] array = ((arraySize == null || arraySize.Length <= 0) ? new string[0] : arraySize.Split(null));
			result.dimensions = 0;
			result.length = -1;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].Length <= 0)
				{
					continue;
				}
				if (array[i] == "*")
				{
					result.dimensions++;
					continue;
				}
				try
				{
					result.length = int.Parse(array[i], CultureInfo.InvariantCulture);
					result.dimensions++;
				}
				catch (Exception ex)
				{
					if (ex is ThreadAbortException || ex is StackOverflowException || ex is OutOfMemoryException)
					{
						throw;
					}
					throw new ArgumentException(Res.GetString("XmlInvalidArrayLength", array[i]), "value");
				}
				catch
				{
					throw new ArgumentException(Res.GetString("XmlInvalidArrayLength", array[i]), "value");
				}
			}
			if (result.dimensions == 0)
			{
				result.dimensions = 1;
			}
			return result;
		}

		protected static DateTime ToDateTime(string value)
		{
			return XmlCustomFormatter.ToDateTime(value);
		}

		protected static DateTime ToDate(string value)
		{
			return XmlCustomFormatter.ToDate(value);
		}

		protected static DateTime ToTime(string value)
		{
			return XmlCustomFormatter.ToTime(value);
		}

		protected static char ToChar(string value)
		{
			return XmlCustomFormatter.ToChar(value);
		}

		protected static long ToEnum(string value, Hashtable h, string typeName)
		{
			return XmlCustomFormatter.ToEnum(value, h, typeName, validate: true);
		}

		protected static string ToXmlName(string value)
		{
			return XmlCustomFormatter.ToXmlName(value);
		}

		protected static string ToXmlNCName(string value)
		{
			return XmlCustomFormatter.ToXmlNCName(value);
		}

		protected static string ToXmlNmToken(string value)
		{
			return XmlCustomFormatter.ToXmlNmToken(value);
		}

		protected static string ToXmlNmTokens(string value)
		{
			return XmlCustomFormatter.ToXmlNmTokens(value);
		}

		protected XmlQualifiedName ToXmlQualifiedName(string value)
		{
			return ToXmlQualifiedName(value, DecodeName);
		}

		internal XmlQualifiedName ToXmlQualifiedName(string value, bool decodeName)
		{
			int num = value?.LastIndexOf(':') ?? (-1);
			string text = ((num < 0) ? null : value.Substring(0, num));
			string text2 = value.Substring(num + 1);
			if (decodeName)
			{
				text = XmlConvert.DecodeName(text);
				text2 = XmlConvert.DecodeName(text2);
			}
			if (text == null || text.Length == 0)
			{
				return new XmlQualifiedName(r.NameTable.Add(value), r.LookupNamespace(string.Empty));
			}
			string text3 = r.LookupNamespace(text);
			if (text3 == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlUndefinedAlias", text));
			}
			return new XmlQualifiedName(r.NameTable.Add(text2), text3);
		}

		protected void UnknownAttribute(object o, XmlAttribute attr)
		{
			UnknownAttribute(o, attr, null);
		}

		protected void UnknownAttribute(object o, XmlAttribute attr, string qnames)
		{
			if (events.OnUnknownAttribute != null)
			{
				GetCurrentPosition(out var lineNumber, out var linePosition);
				XmlAttributeEventArgs e = new XmlAttributeEventArgs(attr, lineNumber, linePosition, o, qnames);
				events.OnUnknownAttribute(events.sender, e);
			}
		}

		protected void UnknownElement(object o, XmlElement elem)
		{
			UnknownElement(o, elem, null);
		}

		protected void UnknownElement(object o, XmlElement elem, string qnames)
		{
			if (events.OnUnknownElement != null)
			{
				GetCurrentPosition(out var lineNumber, out var linePosition);
				XmlElementEventArgs e = new XmlElementEventArgs(elem, lineNumber, linePosition, o, qnames);
				events.OnUnknownElement(events.sender, e);
			}
		}

		protected void UnknownNode(object o)
		{
			UnknownNode(o, null);
		}

		protected void UnknownNode(object o, string qnames)
		{
			if (r.NodeType == XmlNodeType.None || r.NodeType == XmlNodeType.Whitespace)
			{
				r.Read();
			}
			else
			{
				if (r.NodeType == XmlNodeType.EndElement)
				{
					return;
				}
				if (events.OnUnknownNode != null)
				{
					UnknownNode(Document.ReadNode(r), o, qnames);
				}
				else if (r.NodeType != XmlNodeType.Attribute || events.OnUnknownAttribute != null)
				{
					if (r.NodeType == XmlNodeType.Element && events.OnUnknownElement == null)
					{
						r.Skip();
					}
					else
					{
						UnknownNode(Document.ReadNode(r), o, qnames);
					}
				}
			}
		}

		private void UnknownNode(XmlNode unknownNode, object o, string qnames)
		{
			if (unknownNode != null)
			{
				if (unknownNode.NodeType != 0 && unknownNode.NodeType != XmlNodeType.Whitespace && events.OnUnknownNode != null)
				{
					GetCurrentPosition(out var lineNumber, out var linePosition);
					XmlNodeEventArgs e = new XmlNodeEventArgs(unknownNode, lineNumber, linePosition, o);
					events.OnUnknownNode(events.sender, e);
				}
				if (unknownNode.NodeType == XmlNodeType.Attribute)
				{
					UnknownAttribute(o, (XmlAttribute)unknownNode, qnames);
				}
				else if (unknownNode.NodeType == XmlNodeType.Element)
				{
					UnknownElement(o, (XmlElement)unknownNode, qnames);
				}
			}
		}

		private void GetCurrentPosition(out int lineNumber, out int linePosition)
		{
			if (Reader is IXmlLineInfo)
			{
				IXmlLineInfo xmlLineInfo = (IXmlLineInfo)Reader;
				lineNumber = xmlLineInfo.LineNumber;
				linePosition = xmlLineInfo.LinePosition;
			}
			else
			{
				lineNumber = (linePosition = -1);
			}
		}

		protected void UnreferencedObject(string id, object o)
		{
			if (events.OnUnreferencedObject != null)
			{
				UnreferencedObjectEventArgs e = new UnreferencedObjectEventArgs(o, id);
				events.OnUnreferencedObject(events.sender, e);
			}
		}

		private string CurrentTag()
		{
			return r.NodeType switch
			{
				XmlNodeType.Element => "<" + r.LocalName + " xmlns='" + r.NamespaceURI + "'>", 
				XmlNodeType.EndElement => ">", 
				XmlNodeType.Text => r.Value, 
				XmlNodeType.CDATA => "CDATA", 
				XmlNodeType.Comment => "<--", 
				XmlNodeType.ProcessingInstruction => "<?", 
				_ => "(unknown)", 
			};
		}

		protected Exception CreateUnknownTypeException(XmlQualifiedName type)
		{
			return new InvalidOperationException(Res.GetString("XmlUnknownType", type.Name, type.Namespace, CurrentTag()));
		}

		protected Exception CreateReadOnlyCollectionException(string name)
		{
			return new InvalidOperationException(Res.GetString("XmlReadOnlyCollection", name));
		}

		protected Exception CreateAbstractTypeException(string name, string ns)
		{
			return new InvalidOperationException(Res.GetString("XmlAbstractType", name, ns, CurrentTag()));
		}

		protected Exception CreateInaccessibleConstructorException(string typeName)
		{
			return new InvalidOperationException(Res.GetString("XmlConstructorInaccessible", typeName));
		}

		protected Exception CreateCtorHasSecurityException(string typeName)
		{
			return new InvalidOperationException(Res.GetString("XmlConstructorHasSecurityAttributes", typeName));
		}

		protected Exception CreateUnknownNodeException()
		{
			return new InvalidOperationException(Res.GetString("XmlUnknownNode", CurrentTag()));
		}

		protected Exception CreateUnknownConstantException(string value, Type enumType)
		{
			return new InvalidOperationException(Res.GetString("XmlUnknownConstant", value, enumType.Name));
		}

		protected Exception CreateInvalidCastException(Type type, object value)
		{
			return CreateInvalidCastException(type, value, null);
		}

		protected Exception CreateInvalidCastException(Type type, object value, string id)
		{
			if (value == null)
			{
				return new InvalidCastException(Res.GetString("XmlInvalidNullCast", type.FullName));
			}
			if (id == null)
			{
				return new InvalidCastException(Res.GetString("XmlInvalidCast", value.GetType().FullName, type.FullName));
			}
			return new InvalidCastException(Res.GetString("XmlInvalidCastWithId", value.GetType().FullName, type.FullName, id));
		}

		protected Exception CreateBadDerivationException(string xsdDerived, string nsDerived, string xsdBase, string nsBase, string clrDerived, string clrBase)
		{
			return new InvalidOperationException(Res.GetString("XmlSerializableBadDerivation", xsdDerived, nsDerived, xsdBase, nsBase, clrDerived, clrBase));
		}

		protected Exception CreateMissingIXmlSerializableType(string name, string ns, string clrType)
		{
			return new InvalidOperationException(Res.GetString("XmlSerializableMissingClrType", name, ns, typeof(XmlIncludeAttribute).Name, clrType));
		}

		protected Array EnsureArrayIndex(Array a, int index, Type elementType)
		{
			if (a == null)
			{
				return Array.CreateInstance(elementType, 32);
			}
			if (index < a.Length)
			{
				return a;
			}
			Array array = Array.CreateInstance(elementType, a.Length * 2);
			Array.Copy(a, array, index);
			return array;
		}

		protected Array ShrinkArray(Array a, int length, Type elementType, bool isNullable)
		{
			if (a == null)
			{
				if (isNullable)
				{
					return null;
				}
				return Array.CreateInstance(elementType, 0);
			}
			if (a.Length == length)
			{
				return a;
			}
			Array array = Array.CreateInstance(elementType, length);
			Array.Copy(a, array, length);
			return array;
		}

		protected string ReadString(string value)
		{
			return ReadString(value, trim: false);
		}

		protected string ReadString(string value, bool trim)
		{
			string text = r.ReadString();
			if (text != null && trim)
			{
				text = text.Trim();
			}
			if (value == null || value.Length == 0)
			{
				return text;
			}
			return value + text;
		}

		protected IXmlSerializable ReadSerializable(IXmlSerializable serializable)
		{
			return ReadSerializable(serializable, wrappedAny: false);
		}

		protected IXmlSerializable ReadSerializable(IXmlSerializable serializable, bool wrappedAny)
		{
			string text = null;
			string text2 = null;
			if (wrappedAny)
			{
				text = r.LocalName;
				text2 = r.NamespaceURI;
				r.Read();
				r.MoveToContent();
			}
			serializable.ReadXml(r);
			if (wrappedAny)
			{
				while (r.NodeType == XmlNodeType.Whitespace)
				{
					r.Skip();
				}
				if (r.NodeType == XmlNodeType.None)
				{
					r.Skip();
				}
				if (r.NodeType == XmlNodeType.EndElement && r.LocalName == text && r.NamespaceURI == text2)
				{
					Reader.Read();
				}
			}
			return serializable;
		}

		protected bool ReadReference(out string fixupReference)
		{
			string text = (soap12 ? r.GetAttribute("ref", "http://www.w3.org/2003/05/soap-encoding") : r.GetAttribute("href"));
			if (text == null)
			{
				fixupReference = null;
				return false;
			}
			if (!soap12)
			{
				if (!text.StartsWith("#", StringComparison.Ordinal))
				{
					throw new InvalidOperationException(Res.GetString("XmlMissingHref", text));
				}
				fixupReference = text.Substring(1);
			}
			else
			{
				fixupReference = text;
			}
			if (r.IsEmptyElement)
			{
				r.Skip();
			}
			else
			{
				r.ReadStartElement();
				ReadEndElement();
			}
			return true;
		}

		protected void AddTarget(string id, object o)
		{
			if (id == null)
			{
				if (targetsWithoutIds == null)
				{
					targetsWithoutIds = new ArrayList();
				}
				if (o != null)
				{
					targetsWithoutIds.Add(o);
				}
			}
			else
			{
				if (targets == null)
				{
					targets = new Hashtable();
				}
				if (!targets.Contains(id))
				{
					targets.Add(id, o);
				}
			}
		}

		protected void AddFixup(Fixup fixup)
		{
			if (fixups == null)
			{
				fixups = new ArrayList();
			}
			fixups.Add(fixup);
		}

		protected void AddFixup(CollectionFixup fixup)
		{
			if (collectionFixups == null)
			{
				collectionFixups = new ArrayList();
			}
			collectionFixups.Add(fixup);
		}

		protected object GetTarget(string id)
		{
			object obj = ((targets != null) ? targets[id] : null);
			if (obj == null)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidHref", id));
			}
			Referenced(obj);
			return obj;
		}

		protected void Referenced(object o)
		{
			if (o != null)
			{
				if (referencedTargets == null)
				{
					referencedTargets = new Hashtable();
				}
				referencedTargets[o] = o;
			}
		}

		private void HandleUnreferencedObjects()
		{
			if (targets != null)
			{
				foreach (DictionaryEntry target in targets)
				{
					if (referencedTargets == null || !referencedTargets.Contains(target.Value))
					{
						UnreferencedObject((string)target.Key, target.Value);
					}
				}
			}
			if (targetsWithoutIds == null)
			{
				return;
			}
			foreach (object targetsWithoutId in targetsWithoutIds)
			{
				if (referencedTargets == null || !referencedTargets.Contains(targetsWithoutId))
				{
					UnreferencedObject(null, targetsWithoutId);
				}
			}
		}

		private void DoFixups()
		{
			if (fixups == null)
			{
				return;
			}
			for (int i = 0; i < fixups.Count; i++)
			{
				Fixup fixup = (Fixup)fixups[i];
				fixup.Callback(fixup);
			}
			if (collectionFixups != null)
			{
				for (int j = 0; j < collectionFixups.Count; j++)
				{
					CollectionFixup collectionFixup = (CollectionFixup)collectionFixups[j];
					collectionFixup.Callback(collectionFixup.Collection, collectionFixup.CollectionItems);
				}
			}
		}

		protected void FixupArrayRefs(object fixup)
		{
			Fixup fixup2 = (Fixup)fixup;
			Array array = (Array)fixup2.Source;
			for (int i = 0; i < array.Length; i++)
			{
				string text = fixup2.Ids[i];
				if (text != null)
				{
					object target = GetTarget(text);
					try
					{
						array.SetValue(target, i);
					}
					catch (InvalidCastException)
					{
						throw new InvalidOperationException(Res.GetString("XmlInvalidArrayRef", text, target.GetType().FullName, i.ToString(CultureInfo.InvariantCulture)));
					}
				}
			}
		}

		private object ReadArray(string typeName, string typeNs)
		{
			Type type = null;
			SoapArrayInfo soapArrayInfo;
			if (soap12)
			{
				string attribute = r.GetAttribute(itemTypeID, soap12NsID);
				string attribute2 = r.GetAttribute(arraySizeID, soap12NsID);
				Type type2 = (Type)types[new XmlQualifiedName(typeName, typeNs)];
				if (attribute == null && attribute2 == null && (type2 == null || !type2.IsArray))
				{
					return null;
				}
				soapArrayInfo = ParseSoap12ArrayType(attribute, attribute2);
				if (type2 != null)
				{
					type = TypeScope.GetArrayElementType(type2, null);
				}
			}
			else
			{
				string attribute3 = r.GetAttribute(arrayTypeID, soapNsID);
				if (attribute3 == null)
				{
					return null;
				}
				soapArrayInfo = ParseArrayType(attribute3);
			}
			if (soapArrayInfo.dimensions != 1)
			{
				throw new InvalidOperationException(Res.GetString("XmlInvalidArrayDimentions", CurrentTag()));
			}
			Type type3 = null;
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(urTypeID, schemaNsID);
			XmlQualifiedName xmlQualifiedName2;
			if (soapArrayInfo.qname.Length > 0)
			{
				xmlQualifiedName2 = ToXmlQualifiedName(soapArrayInfo.qname, decodeName: false);
				type3 = (Type)types[xmlQualifiedName2];
			}
			else
			{
				xmlQualifiedName2 = xmlQualifiedName;
			}
			if (soap12 && type3 == typeof(object))
			{
				type3 = null;
			}
			bool flag;
			if (type3 == null)
			{
				if (!soap12)
				{
					type3 = GetPrimitiveType(xmlQualifiedName2, throwOnUnknown: true);
					flag = true;
				}
				else
				{
					if (xmlQualifiedName2 != xmlQualifiedName)
					{
						type3 = GetPrimitiveType(xmlQualifiedName2, throwOnUnknown: false);
					}
					if (type3 != null)
					{
						flag = true;
					}
					else if (type == null)
					{
						type3 = typeof(object);
						flag = false;
					}
					else
					{
						type3 = type;
						XmlQualifiedName xmlQualifiedName3 = (XmlQualifiedName)typesReverse[type3];
						if (xmlQualifiedName3 == null)
						{
							xmlQualifiedName3 = XmlSerializationWriter.GetPrimitiveTypeNameInternal(type3);
							flag = true;
						}
						else
						{
							flag = type3.IsPrimitive;
						}
						if (xmlQualifiedName3 != null)
						{
							xmlQualifiedName2 = xmlQualifiedName3;
						}
					}
				}
			}
			else
			{
				flag = type3.IsPrimitive;
			}
			if (!soap12 && soapArrayInfo.jaggedDimensions > 0)
			{
				for (int i = 0; i < soapArrayInfo.jaggedDimensions; i++)
				{
					type3 = type3.MakeArrayType();
				}
			}
			if (r.IsEmptyElement)
			{
				r.Skip();
				return Array.CreateInstance(type3, 0);
			}
			r.ReadStartElement();
			r.MoveToContent();
			int num = 0;
			Array array = null;
			if (type3.IsValueType)
			{
				if (!flag && !type3.IsEnum)
				{
					throw new NotSupportedException(Res.GetString("XmlRpcArrayOfValueTypes", type3.FullName));
				}
				int whileIterations = 0;
				int readerCount = ReaderCount;
				while (r.NodeType != XmlNodeType.EndElement)
				{
					array = EnsureArrayIndex(array, num, type3);
					array.SetValue(ReadReferencedElement(xmlQualifiedName2.Name, xmlQualifiedName2.Namespace), num);
					num++;
					r.MoveToContent();
					CheckReaderCount(ref whileIterations, ref readerCount);
				}
				array = ShrinkArray(array, num, type3, isNullable: false);
			}
			else
			{
				string[] array2 = null;
				int num2 = 0;
				int whileIterations2 = 0;
				int readerCount2 = ReaderCount;
				while (r.NodeType != XmlNodeType.EndElement)
				{
					array = EnsureArrayIndex(array, num, type3);
					array2 = (string[])EnsureArrayIndex(array2, num2, typeof(string));
					string name;
					string ns;
					if (r.NamespaceURI.Length != 0)
					{
						name = r.LocalName;
						ns = (((object)r.NamespaceURI != soapNsID) ? r.NamespaceURI : "http://www.w3.org/2001/XMLSchema");
					}
					else
					{
						name = xmlQualifiedName2.Name;
						ns = xmlQualifiedName2.Namespace;
					}
					array.SetValue(ReadReferencingElement(name, ns, out array2[num2]), num);
					num++;
					num2++;
					r.MoveToContent();
					CheckReaderCount(ref whileIterations2, ref readerCount2);
				}
				if (soap12 && type3 == typeof(object))
				{
					Type type4 = null;
					for (int j = 0; j < num; j++)
					{
						object value = array.GetValue(j);
						if (value != null)
						{
							Type type5 = value.GetType();
							if (type5.IsValueType)
							{
								type4 = null;
								break;
							}
							if (type4 == null || type5.IsAssignableFrom(type4))
							{
								type4 = type5;
							}
							else if (!type4.IsAssignableFrom(type5))
							{
								type4 = null;
								break;
							}
						}
					}
					if (type4 != null)
					{
						type3 = type4;
					}
				}
				array2 = (string[])ShrinkArray(array2, num2, typeof(string), isNullable: false);
				array = ShrinkArray(array, num, type3, isNullable: false);
				Fixup fixup = new Fixup(array, FixupArrayRefs, array2);
				AddFixup(fixup);
			}
			ReadEndElement();
			return array;
		}

		protected abstract void InitCallbacks();

		protected void ReadReferencedElements()
		{
			r.MoveToContent();
			int whileIterations = 0;
			int readerCount = ReaderCount;
			while (r.NodeType != XmlNodeType.EndElement && r.NodeType != 0)
			{
				ReadReferencingElement(null, null, elementCanBeType: true, out var _);
				r.MoveToContent();
				CheckReaderCount(ref whileIterations, ref readerCount);
			}
			DoFixups();
			HandleUnreferencedObjects();
		}

		protected object ReadReferencedElement()
		{
			return ReadReferencedElement(null, null);
		}

		protected object ReadReferencedElement(string name, string ns)
		{
			string fixupReference;
			return ReadReferencingElement(name, ns, out fixupReference);
		}

		protected object ReadReferencingElement(out string fixupReference)
		{
			return ReadReferencingElement(null, null, out fixupReference);
		}

		protected object ReadReferencingElement(string name, string ns, out string fixupReference)
		{
			return ReadReferencingElement(name, ns, elementCanBeType: false, out fixupReference);
		}

		protected object ReadReferencingElement(string name, string ns, bool elementCanBeType, out string fixupReference)
		{
			object obj = null;
			if (callbacks == null)
			{
				callbacks = new Hashtable();
				types = new Hashtable();
				XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(urTypeID, r.NameTable.Add("http://www.w3.org/2001/XMLSchema"));
				types.Add(xmlQualifiedName, typeof(object));
				typesReverse = new Hashtable();
				typesReverse.Add(typeof(object), xmlQualifiedName);
				InitCallbacks();
			}
			r.MoveToContent();
			if (ReadReference(out fixupReference))
			{
				return null;
			}
			if (ReadNull())
			{
				return null;
			}
			string id = (soap12 ? r.GetAttribute("id", "http://www.w3.org/2003/05/soap-encoding") : r.GetAttribute("id", null));
			if ((obj = ReadArray(name, ns)) == null)
			{
				XmlQualifiedName xmlQualifiedName2 = GetXsiType();
				if (xmlQualifiedName2 == null)
				{
					xmlQualifiedName2 = ((name != null) ? new XmlQualifiedName(r.NameTable.Add(name), r.NameTable.Add(ns)) : new XmlQualifiedName(r.NameTable.Add(r.LocalName), r.NameTable.Add(r.NamespaceURI)));
				}
				XmlSerializationReadCallback xmlSerializationReadCallback = (XmlSerializationReadCallback)callbacks[xmlQualifiedName2];
				obj = ((xmlSerializationReadCallback == null) ? ReadTypedPrimitive(xmlQualifiedName2, elementCanBeType) : xmlSerializationReadCallback());
			}
			AddTarget(id, obj);
			return obj;
		}

		protected void AddReadCallback(string name, string ns, Type type, XmlSerializationReadCallback read)
		{
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(r.NameTable.Add(name), r.NameTable.Add(ns));
			callbacks[xmlQualifiedName] = read;
			types[xmlQualifiedName] = type;
			typesReverse[type] = xmlQualifiedName;
		}

		protected void ReadEndElement()
		{
			while (r.NodeType == XmlNodeType.Whitespace)
			{
				r.Skip();
			}
			if (r.NodeType == XmlNodeType.None)
			{
				r.Skip();
			}
			else
			{
				r.ReadEndElement();
			}
		}

		private object ReadXmlNodes(bool elementCanBeType)
		{
			ArrayList arrayList = new ArrayList();
			string localName = Reader.LocalName;
			string namespaceURI = Reader.NamespaceURI;
			string name = Reader.Name;
			string text = null;
			string text2 = null;
			int num = 0;
			int lineNumber = -1;
			int linePosition = -1;
			XmlNode xmlNode = null;
			if (Reader.NodeType == XmlNodeType.Attribute)
			{
				XmlAttribute xmlAttribute = Document.CreateAttribute(name, namespaceURI);
				xmlAttribute.Value = Reader.Value;
				xmlNode = xmlAttribute;
			}
			else
			{
				xmlNode = Document.CreateElement(name, namespaceURI);
			}
			GetCurrentPosition(out lineNumber, out linePosition);
			XmlElement xmlElement = xmlNode as XmlElement;
			while (Reader.MoveToNextAttribute())
			{
				if (IsXmlnsAttribute(Reader.Name) || (Reader.Name == "id" && (!soap12 || Reader.NamespaceURI == "http://www.w3.org/2003/05/soap-encoding")))
				{
					num++;
				}
				if ((object)Reader.LocalName == typeID && ((object)Reader.NamespaceURI == instanceNsID || (object)Reader.NamespaceURI == instanceNs2000ID || (object)Reader.NamespaceURI == instanceNs1999ID))
				{
					string value = Reader.Value;
					int num2 = value.LastIndexOf(':');
					text = ((num2 >= 0) ? value.Substring(num2 + 1) : value);
					text2 = Reader.LookupNamespace((num2 >= 0) ? value.Substring(0, num2) : "");
				}
				XmlAttribute xmlAttribute2 = (XmlAttribute)Document.ReadNode(r);
				arrayList.Add(xmlAttribute2);
				xmlElement?.SetAttributeNode(xmlAttribute2);
			}
			if (elementCanBeType && text == null)
			{
				text = localName;
				text2 = namespaceURI;
				XmlAttribute xmlAttribute3 = Document.CreateAttribute(typeID, instanceNsID);
				xmlAttribute3.Value = name;
				arrayList.Add(xmlAttribute3);
			}
			if (text == "anyType" && ((object)text2 == schemaNsID || (object)text2 == schemaNs1999ID || (object)text2 == schemaNs2000ID))
			{
				num++;
			}
			Reader.MoveToElement();
			if (Reader.IsEmptyElement)
			{
				Reader.Skip();
			}
			else
			{
				Reader.ReadStartElement();
				Reader.MoveToContent();
				int whileIterations = 0;
				int readerCount = ReaderCount;
				while (Reader.NodeType != XmlNodeType.EndElement)
				{
					XmlNode xmlNode2 = Document.ReadNode(r);
					arrayList.Add(xmlNode2);
					xmlElement?.AppendChild(xmlNode2);
					Reader.MoveToContent();
					CheckReaderCount(ref whileIterations, ref readerCount);
				}
				ReadEndElement();
			}
			if (arrayList.Count <= num)
			{
				return new object();
			}
			XmlNode[] result = (XmlNode[])arrayList.ToArray(typeof(XmlNode));
			UnknownNode(xmlNode, null, null);
			return result;
		}

		protected void CheckReaderCount(ref int whileIterations, ref int readerCount)
		{
			if (!checkDeserializeAdvances)
			{
				return;
			}
			whileIterations++;
			if ((whileIterations & 0x80) == 128)
			{
				if (readerCount == ReaderCount)
				{
					throw new InvalidOperationException(Res.GetString("XmlInternalErrorReaderAdvance"));
				}
				readerCount = ReaderCount;
			}
		}
	}
	public delegate void XmlSerializationFixupCallback(object fixup);
	public delegate void XmlSerializationCollectionFixupCallback(object collection, object collectionItems);
	public delegate object XmlSerializationReadCallback();
	internal class XmlSerializationReaderCodeGen : XmlSerializationCodeGen
	{
		private class CreateCollectionInfo
		{
			private string name;

			private TypeDesc td;

			internal string Name => name;

			internal TypeDesc TypeDesc => td;

			internal CreateCollectionInfo(string name, TypeDesc td)
			{
				this.name = name;
				this.td = td;
			}
		}

		private class Member
		{
			private string source;

			private string arrayName;

			private string arraySource;

			private string choiceArrayName;

			private string choiceSource;

			private string choiceArraySource;

			private MemberMapping mapping;

			private bool isArray;

			private bool isList;

			private bool isNullable;

			private bool multiRef;

			private int fixupIndex = -1;

			private string paramsReadSource;

			private string checkSpecifiedSource;

			internal MemberMapping Mapping => mapping;

			internal string Source => source;

			internal string ArrayName => arrayName;

			internal string ArraySource => arraySource;

			internal bool IsList => isList;

			internal bool IsArrayLike
			{
				get
				{
					if (!isArray)
					{
						return isList;
					}
					return true;
				}
			}

			internal bool IsNullable
			{
				get
				{
					return isNullable;
				}
				set
				{
					isNullable = value;
				}
			}

			internal bool MultiRef
			{
				get
				{
					return multiRef;
				}
				set
				{
					multiRef = value;
				}
			}

			internal int FixupIndex
			{
				get
				{
					return fixupIndex;
				}
				set
				{
					fixupIndex = value;
				}
			}

			internal string ParamsReadSource
			{
				get
				{
					return paramsReadSource;
				}
				set
				{
					paramsReadSource = value;
				}
			}

			internal string CheckSpecifiedSource
			{
				get
				{
					return checkSpecifiedSource;
				}
				set
				{
					checkSpecifiedSource = value;
				}
			}

			internal string ChoiceSource => choiceSource;

			internal string ChoiceArrayName => choiceArrayName;

			internal string ChoiceArraySource => choiceArraySource;

			internal Member(XmlSerializationReaderCodeGen outerClass, string source, string arrayName, int i, MemberMapping mapping)
				: this(outerClass, source, null, arrayName, i, mapping, multiRef: false, null)
			{
			}

			internal Member(XmlSerializationReaderCodeGen outerClass, string source, string arrayName, int i, MemberMapping mapping, string choiceSource)
				: this(outerClass, source, null, arrayName, i, mapping, multiRef: false, choiceSource)
			{
			}

			internal Member(XmlSerializationReaderCodeGen outerClass, string source, string arraySource, string arrayName, int i, MemberMapping mapping)
				: this(outerClass, source, arraySource, arrayName, i, mapping, multiRef: false, null)
			{
			}

			internal Member(XmlSerializationReaderCodeGen outerClass, string source, string arraySource, string arrayName, int i, MemberMapping mapping, string choiceSource)
				: this(outerClass, source, arraySource, arrayName, i, mapping, multiRef: false, choiceSource)
			{
			}

			internal Member(XmlSerializationReaderCodeGen outerClass, string source, string arrayName, int i, MemberMapping mapping, bool multiRef)
				: this(outerClass, source, null, arrayName, i, mapping, multiRef, null)
			{
			}

			internal Member(XmlSerializationReaderCodeGen outerClass, string source, string arraySource, string arrayName, int i, MemberMapping mapping, bool multiRef, string choiceSource)
			{
				this.source = source;
				this.arrayName = arrayName + "_" + i.ToString(CultureInfo.InvariantCulture);
				choiceArrayName = "choice_" + this.arrayName;
				this.choiceSource = choiceSource;
				_ = mapping.Elements;
				if (mapping.TypeDesc.IsArrayLike)
				{
					if (arraySource != null)
					{
						this.arraySource = arraySource;
					}
					else
					{
						this.arraySource = outerClass.GetArraySource(mapping.TypeDesc, this.arrayName, multiRef);
					}
					isArray = mapping.TypeDesc.IsArray;
					isList = !isArray;
					if (mapping.ChoiceIdentifier != null)
					{
						choiceArraySource = outerClass.GetArraySource(mapping.TypeDesc, choiceArrayName, multiRef);
						string text = choiceArrayName;
						string text2 = "c" + text;
						bool useReflection = mapping.ChoiceIdentifier.Mapping.TypeDesc.UseReflection;
						string cSharpName = mapping.ChoiceIdentifier.Mapping.TypeDesc.CSharpName;
						string text3 = (useReflection ? "" : ("(" + cSharpName + "[])"));
						string text4 = text + " = " + text3 + "EnsureArrayIndex(" + text + ", " + text2 + ", " + outerClass.RaCodeGen.GetStringForTypeof(cSharpName, useReflection) + ");";
						choiceArraySource = text4 + outerClass.RaCodeGen.GetStringForArrayMember(text, text2 + "++", mapping.ChoiceIdentifier.Mapping.TypeDesc);
					}
					else
					{
						choiceArraySource = this.choiceSource;
					}
				}
				else
				{
					this.arraySource = ((arraySource == null) ? source : arraySource);
					choiceArraySource = this.choiceSource;
				}
				this.mapping = mapping;
			}
		}

		private Hashtable idNames = new Hashtable();

		private Hashtable enums;

		private Hashtable createMethods = new Hashtable();

		private int nextCreateMethodNumber;

		private int nextIdNumber;

		private int nextWhileLoopIndex;

		internal Hashtable Enums
		{
			get
			{
				if (enums == null)
				{
					enums = new Hashtable();
				}
				return enums;
			}
		}

		internal XmlSerializationReaderCodeGen(IndentedWriter writer, TypeScope[] scopes, string access, string className)
			: base(writer, scopes, access, className)
		{
		}

		internal void GenerateBegin()
		{
			base.Writer.Write(base.Access);
			base.Writer.Write(" class ");
			base.Writer.Write(base.ClassName);
			base.Writer.Write(" : ");
			base.Writer.Write(typeof(XmlSerializationReader).FullName);
			base.Writer.WriteLine(" {");
			base.Writer.Indent++;
			TypeScope[] array = base.Scopes;
			foreach (TypeScope typeScope in array)
			{
				foreach (TypeMapping typeMapping3 in typeScope.TypeMappings)
				{
					if (typeMapping3 is StructMapping || typeMapping3 is EnumMapping || typeMapping3 is NullableMapping)
					{
						base.MethodNames.Add(typeMapping3, NextMethodName(typeMapping3.TypeDesc.Name));
					}
				}
				base.RaCodeGen.WriteReflectionInit(typeScope);
			}
			TypeScope[] array2 = base.Scopes;
			foreach (TypeScope typeScope2 in array2)
			{
				foreach (TypeMapping typeMapping4 in typeScope2.TypeMappings)
				{
					if (typeMapping4.IsSoap)
					{
						if (typeMapping4 is StructMapping)
						{
							WriteStructMethod((StructMapping)typeMapping4);
						}
						else if (typeMapping4 is EnumMapping)
						{
							WriteEnumMethod((EnumMapping)typeMapping4);
						}
						else if (typeMapping4 is NullableMapping)
						{
							WriteNullableMethod((NullableMapping)typeMapping4);
						}
					}
				}
			}
		}

		internal override void GenerateMethod(TypeMapping mapping)
		{
			if (!base.GeneratedMethods.Contains(mapping))
			{
				base.GeneratedMethods[mapping] = mapping;
				if (mapping is StructMapping)
				{
					WriteStructMethod((StructMapping)mapping);
				}
				else if (mapping is EnumMapping)
				{
					WriteEnumMethod((EnumMapping)mapping);
				}
				else if (mapping is NullableMapping)
				{
					WriteNullableMethod((NullableMapping)mapping);
				}
			}
		}

		internal void GenerateEnd()
		{
			GenerateEnd(new string[0], new XmlMapping[0], new Type[0]);
		}

		internal void GenerateEnd(string[] methods, XmlMapping[] xmlMappings, Type[] types)
		{
			GenerateReferencedMethods();
			GenerateInitCallbacksMethod();
			foreach (CreateCollectionInfo value in createMethods.Values)
			{
				WriteCreateCollectionMethod(value);
			}
			base.Writer.WriteLine();
			foreach (string value2 in idNames.Values)
			{
				base.Writer.Write("string ");
				base.Writer.Write(value2);
				base.Writer.WriteLine(";");
			}
			base.Writer.WriteLine();
			base.Writer.WriteLine("protected override void InitIDs() {");
			base.Writer.Indent++;
			foreach (string key in idNames.Keys)
			{
				string s2 = (string)idNames[key];
				base.Writer.Write(s2);
				base.Writer.Write(" = Reader.NameTable.Add(");
				WriteQuotedCSharpString(key);
				base.Writer.WriteLine(");");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		internal string GenerateElement(XmlMapping xmlMapping)
		{
			if (!xmlMapping.IsReadable)
			{
				return null;
			}
			if (!xmlMapping.GenerateSerializer)
			{
				throw new ArgumentException(Res.GetString("XmlInternalError"), "xmlMapping");
			}
			if (xmlMapping is XmlTypeMapping)
			{
				return GenerateTypeElement((XmlTypeMapping)xmlMapping);
			}
			if (xmlMapping is XmlMembersMapping)
			{
				return GenerateMembersElement((XmlMembersMapping)xmlMapping);
			}
			throw new ArgumentException(Res.GetString("XmlInternalError"), "xmlMapping");
		}

		private void WriteIsStartTag(string name, string ns)
		{
			base.Writer.Write("if (Reader.IsStartElement(");
			WriteID(name);
			base.Writer.Write(", ");
			WriteID(ns);
			base.Writer.WriteLine(")) {");
			base.Writer.Indent++;
		}

		private void WriteUnknownNode(string func, string node, ElementAccessor e, bool anyIfs)
		{
			if (anyIfs)
			{
				base.Writer.WriteLine("else {");
				base.Writer.Indent++;
			}
			base.Writer.Write(func);
			base.Writer.Write("(");
			base.Writer.Write(node);
			if (e != null)
			{
				base.Writer.Write(", ");
				string text = ((e.Form == XmlSchemaForm.Qualified) ? e.Namespace : "");
				text += ":";
				text += e.Name;
				ReflectionAwareCodeGen.WriteQuotedCSharpString(base.Writer, text);
			}
			base.Writer.WriteLine(");");
			if (anyIfs)
			{
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
		}

		private void GenerateInitCallbacksMethod()
		{
			base.Writer.WriteLine();
			base.Writer.WriteLine("protected override void InitCallbacks() {");
			base.Writer.Indent++;
			string text = NextMethodName("Array");
			bool flag = false;
			TypeScope[] array = base.Scopes;
			foreach (TypeScope typeScope in array)
			{
				foreach (TypeMapping typeMapping in typeScope.TypeMappings)
				{
					if (typeMapping.IsSoap && (typeMapping is StructMapping || typeMapping is EnumMapping || typeMapping is ArrayMapping || typeMapping is NullableMapping) && !typeMapping.TypeDesc.IsRoot)
					{
						string s;
						if (typeMapping is ArrayMapping)
						{
							s = text;
							flag = true;
						}
						else
						{
							s = (string)base.MethodNames[typeMapping];
						}
						base.Writer.Write("AddReadCallback(");
						WriteID(typeMapping.TypeName);
						base.Writer.Write(", ");
						WriteID(typeMapping.Namespace);
						base.Writer.Write(", ");
						base.Writer.Write(base.RaCodeGen.GetStringForTypeof(typeMapping.TypeDesc.CSharpName, typeMapping.TypeDesc.UseReflection));
						base.Writer.Write(", new ");
						base.Writer.Write(typeof(XmlSerializationReadCallback).FullName);
						base.Writer.Write("(this.");
						base.Writer.Write(s);
						base.Writer.WriteLine("));");
					}
				}
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			if (flag)
			{
				base.Writer.WriteLine();
				base.Writer.Write("object ");
				base.Writer.Write(text);
				base.Writer.WriteLine("() {");
				base.Writer.Indent++;
				base.Writer.WriteLine("// dummy array method");
				base.Writer.WriteLine("UnknownNode(null);");
				base.Writer.WriteLine("return null;");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
		}

		private string GenerateMembersElement(XmlMembersMapping xmlMembersMapping)
		{
			if (xmlMembersMapping.Accessor.IsSoap)
			{
				return GenerateEncodedMembersElement(xmlMembersMapping);
			}
			return GenerateLiteralMembersElement(xmlMembersMapping);
		}

		private string GetChoiceIdentifierSource(MemberMapping[] mappings, MemberMapping member)
		{
			string result = null;
			if (member.ChoiceIdentifier != null)
			{
				for (int i = 0; i < mappings.Length; i++)
				{
					if (mappings[i].Name == member.ChoiceIdentifier.MemberName)
					{
						result = "p[" + i.ToString(CultureInfo.InvariantCulture) + "]";
						break;
					}
				}
			}
			return result;
		}

		private string GetChoiceIdentifierSource(MemberMapping mapping, string parent, TypeDesc parentTypeDesc)
		{
			if (mapping.ChoiceIdentifier == null)
			{
				return "";
			}
			CodeIdentifier.CheckValidIdentifier(mapping.ChoiceIdentifier.MemberName);
			return base.RaCodeGen.GetStringForMember(parent, mapping.ChoiceIdentifier.MemberName, parentTypeDesc);
		}

		private string GenerateLiteralMembersElement(XmlMembersMapping xmlMembersMapping)
		{
			ElementAccessor accessor = xmlMembersMapping.Accessor;
			MemberMapping[] members = ((MembersMapping)accessor.Mapping).Members;
			bool hasWrapperElement = ((MembersMapping)accessor.Mapping).HasWrapperElement;
			string text = NextMethodName(accessor.Name);
			base.Writer.WriteLine();
			base.Writer.Write("public object[] ");
			base.Writer.Write(text);
			base.Writer.WriteLine("() {");
			base.Writer.Indent++;
			base.Writer.WriteLine("Reader.MoveToContent();");
			base.Writer.Write("object[] p = new object[");
			base.Writer.Write(members.Length.ToString(CultureInfo.InvariantCulture));
			base.Writer.WriteLine("];");
			InitializeValueTypes("p", members);
			int loopIndex = 0;
			if (hasWrapperElement)
			{
				loopIndex = WriteWhileNotLoopStart();
				base.Writer.Indent++;
				WriteIsStartTag(accessor.Name, (accessor.Form == XmlSchemaForm.Qualified) ? accessor.Namespace : "");
			}
			Member anyText = null;
			Member anyElement = null;
			Member anyAttribute = null;
			ArrayList arrayList = new ArrayList();
			ArrayList arrayList2 = new ArrayList();
			ArrayList arrayList3 = new ArrayList();
			for (int i = 0; i < members.Length; i++)
			{
				MemberMapping memberMapping = members[i];
				string text2 = "p[" + i.ToString(CultureInfo.InvariantCulture) + "]";
				string arraySource = text2;
				if (memberMapping.Xmlns != null)
				{
					arraySource = "((" + memberMapping.TypeDesc.CSharpName + ")" + text2 + ")";
				}
				string choiceIdentifierSource = GetChoiceIdentifierSource(members, memberMapping);
				Member member = new Member(this, text2, arraySource, "a", i, memberMapping, choiceIdentifierSource);
				Member member2 = new Member(this, text2, null, "a", i, memberMapping, choiceIdentifierSource);
				if (!memberMapping.IsSequence)
				{
					member.ParamsReadSource = "paramsRead[" + i.ToString(CultureInfo.InvariantCulture) + "]";
				}
				if (memberMapping.CheckSpecified == SpecifiedAccessor.ReadWrite)
				{
					string text3 = memberMapping.Name + "Specified";
					for (int j = 0; j < members.Length; j++)
					{
						if (members[j].Name == text3)
						{
							member.CheckSpecifiedSource = "p[" + j.ToString(CultureInfo.InvariantCulture) + "]";
							break;
						}
					}
				}
				bool flag = false;
				if (memberMapping.Text != null)
				{
					anyText = member2;
				}
				if (memberMapping.Attribute != null && memberMapping.Attribute.Any)
				{
					anyAttribute = member2;
				}
				if (memberMapping.Attribute != null || memberMapping.Xmlns != null)
				{
					arrayList3.Add(member);
				}
				else if (memberMapping.Text != null)
				{
					arrayList2.Add(member);
				}
				if (!memberMapping.IsSequence)
				{
					for (int k = 0; k < memberMapping.Elements.Length; k++)
					{
						if (memberMapping.Elements[k].Any && memberMapping.Elements[k].Name.Length == 0)
						{
							anyElement = member2;
							if (memberMapping.Attribute == null && memberMapping.Text == null)
							{
								arrayList2.Add(member2);
							}
							flag = true;
							break;
						}
					}
				}
				if (memberMapping.Attribute != null || memberMapping.Text != null || flag)
				{
					arrayList.Add(member2);
					continue;
				}
				if (memberMapping.TypeDesc.IsArrayLike && (memberMapping.Elements.Length != 1 || !(memberMapping.Elements[0].Mapping is ArrayMapping)))
				{
					arrayList.Add(member2);
					arrayList2.Add(member2);
					continue;
				}
				if (memberMapping.TypeDesc.IsArrayLike && !memberMapping.TypeDesc.IsArray)
				{
					member.ParamsReadSource = null;
				}
				arrayList.Add(member);
			}
			Member[] array = (Member[])arrayList.ToArray(typeof(Member));
			Member[] members2 = (Member[])arrayList2.ToArray(typeof(Member));
			if (array.Length > 0 && array[0].Mapping.IsReturnValue)
			{
				base.Writer.WriteLine("IsReturnValue = true;");
			}
			WriteParamsRead(members.Length);
			if (arrayList3.Count > 0)
			{
				Member[] members3 = (Member[])arrayList3.ToArray(typeof(Member));
				WriteMemberBegin(members3);
				WriteAttributes(members3, anyAttribute, "UnknownNode", "(object)p");
				WriteMemberEnd(members3);
				base.Writer.WriteLine("Reader.MoveToElement();");
			}
			WriteMemberBegin(members2);
			if (hasWrapperElement)
			{
				base.Writer.WriteLine("if (Reader.IsEmptyElement) { Reader.Skip(); Reader.MoveToContent(); continue; }");
				base.Writer.WriteLine("Reader.ReadStartElement();");
			}
			if (IsSequence(array))
			{
				base.Writer.WriteLine("int state = 0;");
			}
			int loopIndex2 = WriteWhileNotLoopStart();
			base.Writer.Indent++;
			string text4 = "UnknownNode((object)p, " + ExpectedElements(array) + ");";
			WriteMemberElements(array, text4, text4, anyElement, anyText, null);
			base.Writer.WriteLine("Reader.MoveToContent();");
			WriteWhileLoopEnd(loopIndex2);
			WriteMemberEnd(members2);
			if (hasWrapperElement)
			{
				base.Writer.WriteLine("ReadEndElement();");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
				WriteUnknownNode("UnknownNode", "null", accessor, anyIfs: true);
				base.Writer.WriteLine("Reader.MoveToContent();");
				WriteWhileLoopEnd(loopIndex);
			}
			base.Writer.WriteLine("return p;");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			return text;
		}

		private void InitializeValueTypes(string arrayName, MemberMapping[] mappings)
		{
			for (int i = 0; i < mappings.Length; i++)
			{
				if (mappings[i].TypeDesc.IsValueType)
				{
					base.Writer.Write(arrayName);
					base.Writer.Write("[");
					base.Writer.Write(i.ToString(CultureInfo.InvariantCulture));
					base.Writer.Write("] = ");
					if (mappings[i].TypeDesc.IsOptionalValue && mappings[i].TypeDesc.BaseTypeDesc.UseReflection)
					{
						base.Writer.Write("null");
					}
					else
					{
						base.Writer.Write(base.RaCodeGen.GetStringForCreateInstance(mappings[i].TypeDesc.CSharpName, mappings[i].TypeDesc.UseReflection, ctorInaccessible: false, cast: false));
					}
					base.Writer.WriteLine(";");
				}
			}
		}

		private string GenerateEncodedMembersElement(XmlMembersMapping xmlMembersMapping)
		{
			ElementAccessor accessor = xmlMembersMapping.Accessor;
			MembersMapping membersMapping = (MembersMapping)accessor.Mapping;
			MemberMapping[] members = membersMapping.Members;
			bool hasWrapperElement = membersMapping.HasWrapperElement;
			bool writeAccessors = membersMapping.WriteAccessors;
			string text = NextMethodName(accessor.Name);
			base.Writer.WriteLine();
			base.Writer.Write("public object[] ");
			base.Writer.Write(text);
			base.Writer.WriteLine("() {");
			base.Writer.Indent++;
			base.Writer.WriteLine("Reader.MoveToContent();");
			base.Writer.Write("object[] p = new object[");
			base.Writer.Write(members.Length.ToString(CultureInfo.InvariantCulture));
			base.Writer.WriteLine("];");
			InitializeValueTypes("p", members);
			if (hasWrapperElement)
			{
				WriteReadNonRoots();
				if (membersMapping.ValidateRpcWrapperElement)
				{
					base.Writer.Write("if (!");
					WriteXmlNodeEqual("Reader", accessor.Name, (accessor.Form == XmlSchemaForm.Qualified) ? accessor.Namespace : "");
					base.Writer.WriteLine(") throw CreateUnknownNodeException();");
				}
				base.Writer.WriteLine("bool isEmptyWrapper = Reader.IsEmptyElement;");
				base.Writer.WriteLine("Reader.ReadStartElement();");
			}
			Member[] array = new Member[members.Length];
			for (int i = 0; i < members.Length; i++)
			{
				MemberMapping memberMapping = members[i];
				string text2 = "p[" + i.ToString(CultureInfo.InvariantCulture) + "]";
				string arraySource = text2;
				if (memberMapping.Xmlns != null)
				{
					arraySource = "((" + memberMapping.TypeDesc.CSharpName + ")" + text2 + ")";
				}
				Member member = new Member(this, text2, arraySource, "a", i, memberMapping);
				if (!memberMapping.IsSequence)
				{
					member.ParamsReadSource = "paramsRead[" + i.ToString(CultureInfo.InvariantCulture) + "]";
				}
				array[i] = member;
				if (memberMapping.CheckSpecified != SpecifiedAccessor.ReadWrite)
				{
					continue;
				}
				string text3 = memberMapping.Name + "Specified";
				for (int j = 0; j < members.Length; j++)
				{
					if (members[j].Name == text3)
					{
						member.CheckSpecifiedSource = "p[" + j.ToString(CultureInfo.InvariantCulture) + "]";
						break;
					}
				}
			}
			string fixupMethodName = "fixup_" + text;
			bool flag = WriteMemberFixupBegin(array, fixupMethodName, "p");
			if (array.Length > 0 && array[0].Mapping.IsReturnValue)
			{
				base.Writer.WriteLine("IsReturnValue = true;");
			}
			string text4 = ((!hasWrapperElement && !writeAccessors) ? "hrefList" : null);
			if (text4 != null)
			{
				WriteInitCheckTypeHrefList(text4);
			}
			WriteParamsRead(members.Length);
			int loopIndex = WriteWhileNotLoopStart();
			base.Writer.Indent++;
			string elementElseString = ((text4 == null) ? "UnknownNode((object)p);" : "if (Reader.GetAttribute(\"id\", null) != null) { ReadReferencedElement(); } else { UnknownNode((object)p); }");
			WriteMemberElements(array, elementElseString, "UnknownNode((object)p);", null, null, text4);
			base.Writer.WriteLine("Reader.MoveToContent();");
			WriteWhileLoopEnd(loopIndex);
			if (hasWrapperElement)
			{
				base.Writer.WriteLine("if (!isEmptyWrapper) ReadEndElement();");
			}
			if (text4 != null)
			{
				WriteHandleHrefList(array, text4);
			}
			base.Writer.WriteLine("ReadReferencedElements();");
			base.Writer.WriteLine("return p;");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			if (flag)
			{
				WriteFixupMethod(fixupMethodName, array, "object[]", useReflection: false, typed: false, "p");
			}
			return text;
		}

		private void WriteCreateCollection(TypeDesc td, string source)
		{
			bool useReflection = td.UseReflection;
			string text = ((td.ArrayElementTypeDesc == null) ? "object" : td.ArrayElementTypeDesc.CSharpName) + "[]";
			bool flag = td.ArrayElementTypeDesc != null && td.ArrayElementTypeDesc.UseReflection;
			if (flag)
			{
				text = typeof(Array).FullName;
			}
			base.Writer.Write(text);
			base.Writer.Write(" ");
			base.Writer.Write("ci =");
			base.Writer.Write("(" + text + ")");
			base.Writer.Write(source);
			base.Writer.WriteLine(";");
			base.Writer.WriteLine("for (int i = 0; i < ci.Length; i++) {");
			base.Writer.Indent++;
			base.Writer.Write(base.RaCodeGen.GetStringForMethod("c", td.CSharpName, "Add", useReflection));
			if (!flag)
			{
				base.Writer.Write("ci[i]");
			}
			else
			{
				base.Writer.Write(base.RaCodeGen.GetReflectionVariable(typeof(Array).FullName, "0") + "[ci , i]");
			}
			if (useReflection)
			{
				base.Writer.WriteLine("}");
			}
			base.Writer.WriteLine(");");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private string GenerateTypeElement(XmlTypeMapping xmlTypeMapping)
		{
			ElementAccessor accessor = xmlTypeMapping.Accessor;
			TypeMapping mapping = accessor.Mapping;
			string text = NextMethodName(accessor.Name);
			base.Writer.WriteLine();
			base.Writer.Write("public object ");
			base.Writer.Write(text);
			base.Writer.WriteLine("() {");
			base.Writer.Indent++;
			base.Writer.WriteLine("object o = null;");
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.TypeDesc = mapping.TypeDesc;
			memberMapping.Elements = new ElementAccessor[1] { accessor };
			Member[] array = new Member[1]
			{
				new Member(this, "o", "o", "a", 0, memberMapping)
			};
			base.Writer.WriteLine("Reader.MoveToContent();");
			string elseString = "UnknownNode(null, " + ExpectedElements(array) + ");";
			WriteMemberElements(array, "throw CreateUnknownNodeException();", elseString, accessor.Any ? array[0] : null, null, null);
			if (accessor.IsSoap)
			{
				base.Writer.WriteLine("Referenced(o);");
				base.Writer.WriteLine("ReadReferencedElements();");
			}
			base.Writer.WriteLine("return (object)o;");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			return text;
		}

		private string NextMethodName(string name)
		{
			return "Read" + (++base.NextMethodNumber).ToString(CultureInfo.InvariantCulture) + "_" + CodeIdentifier.MakeValidInternal(name);
		}

		private string NextIdName(string name)
		{
			return "id" + (++nextIdNumber).ToString(CultureInfo.InvariantCulture) + "_" + CodeIdentifier.MakeValidInternal(name);
		}

		private void WritePrimitive(TypeMapping mapping, string source)
		{
			if (mapping is EnumMapping)
			{
				string text = ReferenceMapping(mapping);
				if (text == null)
				{
					throw new InvalidOperationException(Res.GetString("XmlMissingMethodEnum", mapping.TypeDesc.Name));
				}
				if (mapping.IsSoap)
				{
					base.Writer.Write("(");
					base.Writer.Write(mapping.TypeDesc.CSharpName);
					base.Writer.Write(")");
				}
				base.Writer.Write(text);
				base.Writer.Write("(");
				if (!mapping.IsSoap)
				{
					base.Writer.Write(source);
				}
				base.Writer.Write(")");
			}
			else if (mapping.TypeDesc == base.StringTypeDesc)
			{
				base.Writer.Write(source);
			}
			else if (mapping.TypeDesc.FormatterName == "String")
			{
				if (mapping.TypeDesc.CollapseWhitespace)
				{
					base.Writer.Write("CollapseWhitespace(");
					base.Writer.Write(source);
					base.Writer.Write(")");
				}
				else
				{
					base.Writer.Write(source);
				}
			}
			else
			{
				if (!mapping.TypeDesc.HasCustomFormatter)
				{
					base.Writer.Write(typeof(XmlConvert).FullName);
					base.Writer.Write(".");
				}
				base.Writer.Write("To");
				base.Writer.Write(mapping.TypeDesc.FormatterName);
				base.Writer.Write("(");
				base.Writer.Write(source);
				base.Writer.Write(")");
			}
		}

		private string MakeUnique(EnumMapping mapping, string name)
		{
			string text = name;
			object obj = Enums[text];
			if (obj != null)
			{
				if (obj == mapping)
				{
					return null;
				}
				int num = 0;
				while (obj != null)
				{
					num++;
					text = name + num.ToString(CultureInfo.InvariantCulture);
					obj = Enums[text];
				}
			}
			Enums.Add(text, mapping);
			return text;
		}

		private string WriteHashtable(EnumMapping mapping, string typeName)
		{
			CodeIdentifier.CheckValidIdentifier(typeName);
			string text = MakeUnique(mapping, typeName + "Values");
			if (text == null)
			{
				return CodeIdentifier.GetCSharpName(typeName);
			}
			string s = MakeUnique(mapping, "_" + text);
			text = CodeIdentifier.GetCSharpName(text);
			base.Writer.WriteLine();
			base.Writer.Write(typeof(Hashtable).FullName);
			base.Writer.Write(" ");
			base.Writer.Write(s);
			base.Writer.WriteLine(";");
			base.Writer.WriteLine();
			base.Writer.Write("internal ");
			base.Writer.Write(typeof(Hashtable).FullName);
			base.Writer.Write(" ");
			base.Writer.Write(text);
			base.Writer.WriteLine(" {");
			base.Writer.Indent++;
			base.Writer.WriteLine("get {");
			base.Writer.Indent++;
			base.Writer.Write("if ((object)");
			base.Writer.Write(s);
			base.Writer.WriteLine(" == null) {");
			base.Writer.Indent++;
			base.Writer.Write(typeof(Hashtable).FullName);
			base.Writer.Write(" h = new ");
			base.Writer.Write(typeof(Hashtable).FullName);
			base.Writer.WriteLine("();");
			ConstantMapping[] constants = mapping.Constants;
			for (int i = 0; i < constants.Length; i++)
			{
				base.Writer.Write("h.Add(");
				WriteQuotedCSharpString(constants[i].XmlName);
				if (!mapping.TypeDesc.UseReflection)
				{
					base.Writer.Write(", (long)");
					base.Writer.Write(mapping.TypeDesc.CSharpName);
					base.Writer.Write(".@");
					CodeIdentifier.CheckValidIdentifier(constants[i].Name);
					base.Writer.Write(constants[i].Name);
				}
				else
				{
					base.Writer.Write(", ");
					base.Writer.Write(constants[i].Value.ToString(CultureInfo.InvariantCulture) + "L");
				}
				base.Writer.WriteLine(");");
			}
			base.Writer.Write(s);
			base.Writer.WriteLine(" = h;");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			base.Writer.Write("return ");
			base.Writer.Write(s);
			base.Writer.WriteLine(";");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			return text;
		}

		private void WriteEnumMethod(EnumMapping mapping)
		{
			string s = null;
			if (mapping.IsFlags)
			{
				s = WriteHashtable(mapping, mapping.TypeDesc.Name);
			}
			string s2 = (string)base.MethodNames[mapping];
			base.Writer.WriteLine();
			bool useReflection = mapping.TypeDesc.UseReflection;
			string cSharpName = mapping.TypeDesc.CSharpName;
			if (mapping.IsSoap)
			{
				base.Writer.Write("object");
				base.Writer.Write(" ");
				base.Writer.Write(s2);
				base.Writer.WriteLine("() {");
				base.Writer.Indent++;
				base.Writer.WriteLine("string s = Reader.ReadElementString();");
			}
			else
			{
				base.Writer.Write(useReflection ? "object" : cSharpName);
				base.Writer.Write(" ");
				base.Writer.Write(s2);
				base.Writer.WriteLine("(string s) {");
				base.Writer.Indent++;
			}
			ConstantMapping[] constants = mapping.Constants;
			if (mapping.IsFlags)
			{
				if (useReflection)
				{
					base.Writer.Write("return ");
					base.Writer.Write(typeof(Enum).FullName);
					base.Writer.Write(".ToObject(");
					base.Writer.Write(base.RaCodeGen.GetStringForTypeof(cSharpName, useReflection));
					base.Writer.Write(", ToEnum(s, ");
					base.Writer.Write(s);
					base.Writer.Write(", ");
					WriteQuotedCSharpString(cSharpName);
					base.Writer.WriteLine("));");
				}
				else
				{
					base.Writer.Write("return (");
					base.Writer.Write(cSharpName);
					base.Writer.Write(")ToEnum(s, ");
					base.Writer.Write(s);
					base.Writer.Write(", ");
					WriteQuotedCSharpString(cSharpName);
					base.Writer.WriteLine(");");
				}
			}
			else
			{
				base.Writer.WriteLine("switch (s) {");
				base.Writer.Indent++;
				Hashtable hashtable = new Hashtable();
				foreach (ConstantMapping constantMapping in constants)
				{
					CodeIdentifier.CheckValidIdentifier(constantMapping.Name);
					if (hashtable[constantMapping.XmlName] == null)
					{
						base.Writer.Write("case ");
						WriteQuotedCSharpString(constantMapping.XmlName);
						base.Writer.Write(": return ");
						base.Writer.Write(base.RaCodeGen.GetStringForEnumMember(cSharpName, constantMapping.Name, useReflection));
						base.Writer.WriteLine(";");
						hashtable[constantMapping.XmlName] = constantMapping.XmlName;
					}
				}
				base.Writer.Write("default: throw CreateUnknownConstantException(s, ");
				base.Writer.Write(base.RaCodeGen.GetStringForTypeof(cSharpName, useReflection));
				base.Writer.WriteLine(");");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteDerivedTypes(StructMapping mapping, bool isTypedReturn, string returnTypeName)
		{
			for (StructMapping structMapping = mapping.DerivedMappings; structMapping != null; structMapping = structMapping.NextDerivedMapping)
			{
				base.Writer.Write("else if (");
				WriteQNameEqual("xsiType", structMapping.TypeName, structMapping.Namespace);
				base.Writer.WriteLine(")");
				base.Writer.Indent++;
				string s = ReferenceMapping(structMapping);
				base.Writer.Write("return ");
				if (structMapping.TypeDesc.UseReflection && isTypedReturn)
				{
					base.Writer.Write("(" + returnTypeName + ")");
				}
				base.Writer.Write(s);
				base.Writer.Write("(");
				if (structMapping.TypeDesc.IsNullable)
				{
					base.Writer.Write("isNullable, ");
				}
				base.Writer.WriteLine("false);");
				base.Writer.Indent--;
				WriteDerivedTypes(structMapping, isTypedReturn, returnTypeName);
			}
		}

		private void WriteEnumAndArrayTypes()
		{
			TypeScope[] array = base.Scopes;
			foreach (TypeScope typeScope in array)
			{
				foreach (Mapping typeMapping in typeScope.TypeMappings)
				{
					if (typeMapping.IsSoap)
					{
						continue;
					}
					if (typeMapping is EnumMapping)
					{
						EnumMapping enumMapping = (EnumMapping)typeMapping;
						base.Writer.Write("else if (");
						WriteQNameEqual("xsiType", enumMapping.TypeName, enumMapping.Namespace);
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
						base.Writer.WriteLine("Reader.ReadStartElement();");
						string s = ReferenceMapping(enumMapping);
						base.Writer.Write("object e = ");
						base.Writer.Write(s);
						base.Writer.WriteLine("(CollapseWhitespace(Reader.ReadString()));");
						base.Writer.WriteLine("ReadEndElement();");
						base.Writer.WriteLine("return e;");
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
					else
					{
						if (!(typeMapping is ArrayMapping))
						{
							continue;
						}
						ArrayMapping arrayMapping = (ArrayMapping)typeMapping;
						if (!arrayMapping.TypeDesc.HasDefaultConstructor)
						{
							continue;
						}
						base.Writer.Write("else if (");
						WriteQNameEqual("xsiType", arrayMapping.TypeName, arrayMapping.Namespace);
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
						MemberMapping memberMapping = new MemberMapping();
						memberMapping.TypeDesc = arrayMapping.TypeDesc;
						memberMapping.Elements = arrayMapping.Elements;
						Member member = new Member(this, "a", "z", 0, memberMapping);
						TypeDesc typeDesc = arrayMapping.TypeDesc;
						string cSharpName = arrayMapping.TypeDesc.CSharpName;
						if (typeDesc.UseReflection)
						{
							if (typeDesc.IsArray)
							{
								base.Writer.Write(typeof(Array).FullName);
							}
							else
							{
								base.Writer.Write("object");
							}
						}
						else
						{
							base.Writer.Write(cSharpName);
						}
						base.Writer.Write(" a = ");
						if (arrayMapping.TypeDesc.IsValueType)
						{
							base.Writer.Write(base.RaCodeGen.GetStringForCreateInstance(cSharpName, typeDesc.UseReflection, ctorInaccessible: false, cast: false));
							base.Writer.WriteLine(";");
						}
						else
						{
							base.Writer.WriteLine("null;");
						}
						WriteArray(member.Source, member.ArrayName, arrayMapping, readOnly: false, isNullable: false, -1);
						base.Writer.WriteLine("return a;");
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
				}
			}
		}

		private void WriteNullableMethod(NullableMapping nullableMapping)
		{
			string s = (string)base.MethodNames[nullableMapping];
			bool useReflection = nullableMapping.BaseMapping.TypeDesc.UseReflection;
			string s2 = (useReflection ? "object" : nullableMapping.TypeDesc.CSharpName);
			base.Writer.WriteLine();
			base.Writer.Write(s2);
			base.Writer.Write(" ");
			base.Writer.Write(s);
			base.Writer.WriteLine("(bool checkType) {");
			base.Writer.Indent++;
			base.Writer.Write(s2);
			base.Writer.Write(" o = ");
			if (useReflection)
			{
				base.Writer.Write("null");
			}
			else
			{
				base.Writer.Write("default(");
				base.Writer.Write(s2);
				base.Writer.Write(")");
			}
			base.Writer.WriteLine(";");
			base.Writer.WriteLine("if (ReadNull())");
			base.Writer.Indent++;
			base.Writer.WriteLine("return o;");
			base.Writer.Indent--;
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.Mapping = nullableMapping.BaseMapping;
			elementAccessor.Any = false;
			elementAccessor.IsNullable = nullableMapping.BaseMapping.TypeDesc.IsNullable;
			WriteElement("o", null, null, elementAccessor, null, null, checkForNull: false, readOnly: false, -1, -1);
			base.Writer.WriteLine("return o;");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteStructMethod(StructMapping structMapping)
		{
			if (structMapping.IsSoap)
			{
				WriteEncodedStructMethod(structMapping);
			}
			else
			{
				WriteLiteralStructMethod(structMapping);
			}
		}

		private void WriteLiteralStructMethod(StructMapping structMapping)
		{
			string s = (string)base.MethodNames[structMapping];
			bool useReflection = structMapping.TypeDesc.UseReflection;
			string text = (useReflection ? "object" : structMapping.TypeDesc.CSharpName);
			base.Writer.WriteLine();
			base.Writer.Write(text);
			base.Writer.Write(" ");
			base.Writer.Write(s);
			base.Writer.Write("(");
			if (structMapping.TypeDesc.IsNullable)
			{
				base.Writer.Write("bool isNullable, ");
			}
			base.Writer.WriteLine("bool checkType) {");
			base.Writer.Indent++;
			base.Writer.Write(typeof(XmlQualifiedName).FullName);
			base.Writer.WriteLine(" xsiType = checkType ? GetXsiType() : null;");
			base.Writer.WriteLine("bool isNull = false;");
			if (structMapping.TypeDesc.IsNullable)
			{
				base.Writer.WriteLine("if (isNullable) isNull = ReadNull();");
			}
			base.Writer.WriteLine("if (checkType) {");
			if (structMapping.TypeDesc.IsRoot)
			{
				base.Writer.Indent++;
				base.Writer.WriteLine("if (isNull) {");
				base.Writer.Indent++;
				base.Writer.WriteLine("if (xsiType != null) return (" + text + ")ReadTypedNull(xsiType);");
				base.Writer.Write("else return ");
				if (structMapping.TypeDesc.IsValueType)
				{
					base.Writer.Write(base.RaCodeGen.GetStringForCreateInstance(structMapping.TypeDesc.CSharpName, useReflection, ctorInaccessible: false, cast: false));
					base.Writer.WriteLine(";");
				}
				else
				{
					base.Writer.WriteLine("null;");
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			base.Writer.Write("if (xsiType == null");
			if (!structMapping.TypeDesc.IsRoot)
			{
				base.Writer.Write(" || ");
				WriteQNameEqual("xsiType", structMapping.TypeName, structMapping.Namespace);
			}
			base.Writer.WriteLine(") {");
			if (structMapping.TypeDesc.IsRoot)
			{
				base.Writer.Indent++;
				base.Writer.WriteLine("return ReadTypedPrimitive(new System.Xml.XmlQualifiedName(\"anyType\", \"http://www.w3.org/2001/XMLSchema\"));");
				base.Writer.Indent--;
			}
			base.Writer.WriteLine("}");
			WriteDerivedTypes(structMapping, !useReflection && !structMapping.TypeDesc.IsRoot, text);
			if (structMapping.TypeDesc.IsRoot)
			{
				WriteEnumAndArrayTypes();
			}
			base.Writer.WriteLine("else");
			base.Writer.Indent++;
			if (structMapping.TypeDesc.IsRoot)
			{
				base.Writer.Write("return ReadTypedPrimitive((");
			}
			else
			{
				base.Writer.Write("throw CreateUnknownTypeException((");
			}
			base.Writer.Write(typeof(XmlQualifiedName).FullName);
			base.Writer.WriteLine(")xsiType);");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			if (structMapping.TypeDesc.IsNullable)
			{
				base.Writer.WriteLine("if (isNull) return null;");
			}
			if (structMapping.TypeDesc.IsAbstract)
			{
				base.Writer.Write("throw CreateAbstractTypeException(");
				WriteQuotedCSharpString(structMapping.TypeName);
				base.Writer.Write(", ");
				WriteQuotedCSharpString(structMapping.Namespace);
				base.Writer.WriteLine(");");
			}
			else
			{
				if (structMapping.TypeDesc.Type != null && typeof(XmlSchemaObject).IsAssignableFrom(structMapping.TypeDesc.Type))
				{
					base.Writer.WriteLine("DecodeName = false;");
				}
				WriteCreateMapping(structMapping, "o");
				MemberMapping[] allMembers = TypeScope.GetAllMembers(structMapping);
				Member member = null;
				Member member2 = null;
				Member member3 = null;
				bool flag = structMapping.HasExplicitSequence();
				ArrayList arrayList = new ArrayList(allMembers.Length);
				ArrayList arrayList2 = new ArrayList(allMembers.Length);
				ArrayList arrayList3 = new ArrayList(allMembers.Length);
				for (int i = 0; i < allMembers.Length; i++)
				{
					MemberMapping memberMapping = allMembers[i];
					CodeIdentifier.CheckValidIdentifier(memberMapping.Name);
					string stringForMember = base.RaCodeGen.GetStringForMember("o", memberMapping.Name, structMapping.TypeDesc);
					Member member4 = new Member(this, stringForMember, "a", i, memberMapping, GetChoiceIdentifierSource(memberMapping, "o", structMapping.TypeDesc));
					if (!memberMapping.IsSequence)
					{
						member4.ParamsReadSource = "paramsRead[" + i.ToString(CultureInfo.InvariantCulture) + "]";
					}
					member4.IsNullable = memberMapping.TypeDesc.IsNullable;
					if (memberMapping.CheckSpecified == SpecifiedAccessor.ReadWrite)
					{
						member4.CheckSpecifiedSource = base.RaCodeGen.GetStringForMember("o", memberMapping.Name + "Specified", structMapping.TypeDesc);
					}
					if (memberMapping.Text != null)
					{
						member = member4;
					}
					if (memberMapping.Attribute != null && memberMapping.Attribute.Any)
					{
						member3 = member4;
					}
					if (!flag)
					{
						for (int j = 0; j < memberMapping.Elements.Length; j++)
						{
							if (memberMapping.Elements[j].Any && (memberMapping.Elements[j].Name == null || memberMapping.Elements[j].Name.Length == 0))
							{
								member2 = member4;
								break;
							}
						}
					}
					else if (memberMapping.IsParticle && !memberMapping.IsSequence)
					{
						structMapping.FindDeclaringMapping(memberMapping, out var declaringMapping, structMapping.TypeName);
						throw new InvalidOperationException(Res.GetString("XmlSequenceHierarchy", structMapping.TypeDesc.FullName, memberMapping.Name, declaringMapping.TypeDesc.FullName, "Order"));
					}
					if (memberMapping.Attribute == null && memberMapping.Elements.Length == 1 && memberMapping.Elements[0].Mapping is ArrayMapping)
					{
						Member member5 = new Member(this, stringForMember, stringForMember, "a", i, memberMapping, GetChoiceIdentifierSource(memberMapping, "o", structMapping.TypeDesc));
						member5.CheckSpecifiedSource = member4.CheckSpecifiedSource;
						arrayList3.Add(member5);
					}
					else
					{
						arrayList3.Add(member4);
					}
					if (!memberMapping.TypeDesc.IsArrayLike)
					{
						continue;
					}
					arrayList.Add(member4);
					if (memberMapping.TypeDesc.IsArrayLike && (memberMapping.Elements.Length != 1 || !(memberMapping.Elements[0].Mapping is ArrayMapping)))
					{
						member4.ParamsReadSource = null;
						if (member4 != member && member4 != member2)
						{
							arrayList2.Add(member4);
						}
					}
					else if (!memberMapping.TypeDesc.IsArray)
					{
						member4.ParamsReadSource = null;
					}
				}
				if (member2 != null)
				{
					arrayList2.Add(member2);
				}
				if (member != null && member != member2)
				{
					arrayList2.Add(member);
				}
				Member[] members = (Member[])arrayList.ToArray(typeof(Member));
				Member[] members2 = (Member[])arrayList2.ToArray(typeof(Member));
				Member[] members3 = (Member[])arrayList3.ToArray(typeof(Member));
				WriteMemberBegin(members);
				WriteParamsRead(allMembers.Length);
				WriteAttributes(members3, member3, "UnknownNode", "(object)o");
				if (member3 != null)
				{
					WriteMemberEnd(members);
				}
				base.Writer.WriteLine("Reader.MoveToElement();");
				base.Writer.WriteLine("if (Reader.IsEmptyElement) {");
				base.Writer.Indent++;
				base.Writer.WriteLine("Reader.Skip();");
				WriteMemberEnd(members2);
				base.Writer.WriteLine("return o;");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
				base.Writer.WriteLine("Reader.ReadStartElement();");
				if (IsSequence(members3))
				{
					base.Writer.WriteLine("int state = 0;");
				}
				int loopIndex = WriteWhileNotLoopStart();
				base.Writer.Indent++;
				string text2 = "UnknownNode((object)o, " + ExpectedElements(members3) + ");";
				WriteMemberElements(members3, text2, text2, member2, member, null);
				base.Writer.WriteLine("Reader.MoveToContent();");
				WriteWhileLoopEnd(loopIndex);
				WriteMemberEnd(members2);
				base.Writer.WriteLine("ReadEndElement();");
				base.Writer.WriteLine("return o;");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteEncodedStructMethod(StructMapping structMapping)
		{
			if (structMapping.TypeDesc.IsRoot)
			{
				return;
			}
			_ = structMapping.TypeDesc.UseReflection;
			string text = (string)base.MethodNames[structMapping];
			base.Writer.WriteLine();
			base.Writer.Write("object");
			base.Writer.Write(" ");
			base.Writer.Write(text);
			base.Writer.Write("(");
			base.Writer.WriteLine(") {");
			base.Writer.Indent++;
			Member[] array;
			bool flag;
			string fixupMethodName;
			if (structMapping.TypeDesc.IsAbstract)
			{
				base.Writer.Write("throw CreateAbstractTypeException(");
				WriteQuotedCSharpString(structMapping.TypeName);
				base.Writer.Write(", ");
				WriteQuotedCSharpString(structMapping.Namespace);
				base.Writer.WriteLine(");");
				array = new Member[0];
				flag = false;
				fixupMethodName = null;
			}
			else
			{
				WriteCreateMapping(structMapping, "o");
				MemberMapping[] allMembers = TypeScope.GetAllMembers(structMapping);
				array = new Member[allMembers.Length];
				for (int i = 0; i < allMembers.Length; i++)
				{
					MemberMapping memberMapping = allMembers[i];
					CodeIdentifier.CheckValidIdentifier(memberMapping.Name);
					string stringForMember = base.RaCodeGen.GetStringForMember("o", memberMapping.Name, structMapping.TypeDesc);
					Member member = new Member(this, stringForMember, stringForMember, "a", i, memberMapping, GetChoiceIdentifierSource(memberMapping, "o", structMapping.TypeDesc));
					if (memberMapping.CheckSpecified == SpecifiedAccessor.ReadWrite)
					{
						member.CheckSpecifiedSource = base.RaCodeGen.GetStringForMember("o", memberMapping.Name + "Specified", structMapping.TypeDesc);
					}
					if (!memberMapping.IsSequence)
					{
						member.ParamsReadSource = "paramsRead[" + i.ToString(CultureInfo.InvariantCulture) + "]";
					}
					array[i] = member;
				}
				fixupMethodName = "fixup_" + text;
				flag = WriteMemberFixupBegin(array, fixupMethodName, "o");
				WriteParamsRead(allMembers.Length);
				WriteAttributes(array, null, "UnknownNode", "(object)o");
				base.Writer.WriteLine("Reader.MoveToElement();");
				base.Writer.WriteLine("if (Reader.IsEmptyElement) { Reader.Skip(); return o; }");
				base.Writer.WriteLine("Reader.ReadStartElement();");
				int loopIndex = WriteWhileNotLoopStart();
				base.Writer.Indent++;
				WriteMemberElements(array, "UnknownNode((object)o);", "UnknownNode((object)o);", null, null, null);
				base.Writer.WriteLine("Reader.MoveToContent();");
				WriteWhileLoopEnd(loopIndex);
				base.Writer.WriteLine("ReadEndElement();");
				base.Writer.WriteLine("return o;");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			if (flag)
			{
				WriteFixupMethod(fixupMethodName, array, structMapping.TypeDesc.CSharpName, structMapping.TypeDesc.UseReflection, typed: true, "o");
			}
		}

		private void WriteFixupMethod(string fixupMethodName, Member[] members, string typeName, bool useReflection, bool typed, string source)
		{
			base.Writer.WriteLine();
			base.Writer.Write("void ");
			base.Writer.Write(fixupMethodName);
			base.Writer.WriteLine("(object objFixup) {");
			base.Writer.Indent++;
			base.Writer.WriteLine("Fixup fixup = (Fixup)objFixup;");
			WriteLocalDecl(typeName, source, "fixup.Source", useReflection);
			base.Writer.WriteLine("string[] ids = fixup.Ids;");
			foreach (Member member in members)
			{
				if (!member.MultiRef)
				{
					continue;
				}
				string text = member.FixupIndex.ToString(CultureInfo.InvariantCulture);
				base.Writer.Write("if (ids[");
				base.Writer.Write(text);
				base.Writer.WriteLine("] != null) {");
				base.Writer.Indent++;
				string arraySource = member.ArraySource;
				string text2 = "GetTarget(ids[" + text + "])";
				TypeDesc typeDesc = member.Mapping.TypeDesc;
				if (typeDesc.IsCollection || typeDesc.IsEnumerable)
				{
					WriteAddCollectionFixup(typeDesc, member.Mapping.ReadOnly, arraySource, text2);
				}
				else
				{
					if (typed)
					{
						base.Writer.WriteLine("try {");
						base.Writer.Indent++;
						WriteSourceBeginTyped(arraySource, member.Mapping.TypeDesc);
					}
					else
					{
						WriteSourceBegin(arraySource);
					}
					base.Writer.Write(text2);
					WriteSourceEnd(arraySource);
					base.Writer.WriteLine(";");
					if (member.Mapping.CheckSpecified == SpecifiedAccessor.ReadWrite && member.CheckSpecifiedSource != null && member.CheckSpecifiedSource.Length > 0)
					{
						base.Writer.Write(member.CheckSpecifiedSource);
						base.Writer.WriteLine(" = true;");
					}
					if (typed)
					{
						WriteCatchCastException(member.Mapping.TypeDesc, text2, "ids[" + text + "]");
					}
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteAddCollectionFixup(TypeDesc typeDesc, bool readOnly, string memberSource, string targetSource)
		{
			base.Writer.WriteLine("// get array of the collection items");
			_ = typeDesc.UseReflection;
			CreateCollectionInfo createCollectionInfo = (CreateCollectionInfo)createMethods[typeDesc];
			if (createCollectionInfo == null)
			{
				string name = "create" + (++nextCreateMethodNumber).ToString(CultureInfo.InvariantCulture) + "_" + typeDesc.Name;
				createCollectionInfo = new CreateCollectionInfo(name, typeDesc);
				createMethods.Add(typeDesc, createCollectionInfo);
			}
			base.Writer.Write("if ((object)(");
			base.Writer.Write(memberSource);
			base.Writer.WriteLine(") == null) {");
			base.Writer.Indent++;
			if (readOnly)
			{
				base.Writer.Write("throw CreateReadOnlyCollectionException(");
				WriteQuotedCSharpString(typeDesc.CSharpName);
				base.Writer.WriteLine(");");
			}
			else
			{
				base.Writer.Write(memberSource);
				base.Writer.Write(" = ");
				base.Writer.Write(base.RaCodeGen.GetStringForCreateInstance(typeDesc.CSharpName, typeDesc.UseReflection, typeDesc.CannotNew, cast: true));
				base.Writer.WriteLine(";");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			base.Writer.Write("CollectionFixup collectionFixup = new CollectionFixup(");
			base.Writer.Write(memberSource);
			base.Writer.Write(", ");
			base.Writer.Write("new ");
			base.Writer.Write(typeof(XmlSerializationCollectionFixupCallback).FullName);
			base.Writer.Write("(this.");
			base.Writer.Write(createCollectionInfo.Name);
			base.Writer.Write("), ");
			base.Writer.Write(targetSource);
			base.Writer.WriteLine(");");
			base.Writer.WriteLine("AddFixup(collectionFixup);");
		}

		private void WriteCreateCollectionMethod(CreateCollectionInfo c)
		{
			base.Writer.Write("void ");
			base.Writer.Write(c.Name);
			base.Writer.WriteLine("(object collection, object collectionItems) {");
			base.Writer.Indent++;
			base.Writer.WriteLine("if (collectionItems == null) return;");
			base.Writer.WriteLine("if (collection == null) return;");
			TypeDesc typeDesc = c.TypeDesc;
			bool useReflection = typeDesc.UseReflection;
			string cSharpName = typeDesc.CSharpName;
			WriteLocalDecl(cSharpName, "c", "collection", useReflection);
			WriteCreateCollection(typeDesc, "collectionItems");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteQNameEqual(string source, string name, string ns)
		{
			base.Writer.Write("((object) ((");
			base.Writer.Write(typeof(XmlQualifiedName).FullName);
			base.Writer.Write(")");
			base.Writer.Write(source);
			base.Writer.Write(").Name == (object)");
			WriteID(name);
			base.Writer.Write(" && (object) ((");
			base.Writer.Write(typeof(XmlQualifiedName).FullName);
			base.Writer.Write(")");
			base.Writer.Write(source);
			base.Writer.Write(").Namespace == (object)");
			WriteID(ns);
			base.Writer.Write(")");
		}

		private void WriteXmlNodeEqual(string source, string name, string ns)
		{
			base.Writer.Write("(");
			if (name != null && name.Length > 0)
			{
				base.Writer.Write("(object) ");
				base.Writer.Write(source);
				base.Writer.Write(".LocalName == (object)");
				WriteID(name);
				base.Writer.Write(" && ");
			}
			base.Writer.Write("(object) ");
			base.Writer.Write(source);
			base.Writer.Write(".NamespaceURI == (object)");
			WriteID(ns);
			base.Writer.Write(")");
		}

		private void WriteID(string name)
		{
			if (name == null)
			{
				name = "";
			}
			string text = (string)idNames[name];
			if (text == null)
			{
				text = NextIdName(name);
				idNames.Add(name, text);
			}
			base.Writer.Write(text);
		}

		private void WriteAttributes(Member[] members, Member anyAttribute, string elseCall, string firstParam)
		{
			int num = 0;
			Member member = null;
			ArrayList arrayList = new ArrayList();
			base.Writer.WriteLine("while (Reader.MoveToNextAttribute()) {");
			base.Writer.Indent++;
			foreach (Member member2 in members)
			{
				if (member2.Mapping.Xmlns != null)
				{
					member = member2;
				}
				else
				{
					if (member2.Mapping.Ignore)
					{
						continue;
					}
					AttributeAccessor attribute = member2.Mapping.Attribute;
					if (attribute != null && !attribute.Any)
					{
						arrayList.Add(attribute);
						if (num++ > 0)
						{
							base.Writer.Write("else ");
						}
						base.Writer.Write("if (");
						if (member2.ParamsReadSource != null)
						{
							base.Writer.Write("!");
							base.Writer.Write(member2.ParamsReadSource);
							base.Writer.Write(" && ");
						}
						if (attribute.IsSpecialXmlNamespace)
						{
							WriteXmlNodeEqual("Reader", attribute.Name, "http://www.w3.org/XML/1998/namespace");
						}
						else
						{
							WriteXmlNodeEqual("Reader", attribute.Name, (attribute.Form == XmlSchemaForm.Qualified) ? attribute.Namespace : "");
						}
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
						WriteAttribute(member2);
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
				}
			}
			if (num > 0)
			{
				base.Writer.Write("else ");
			}
			if (member != null)
			{
				base.Writer.WriteLine("if (IsXmlnsAttribute(Reader.Name)) {");
				base.Writer.Indent++;
				base.Writer.Write("if (");
				base.Writer.Write(member.Source);
				base.Writer.Write(" == null) ");
				base.Writer.Write(member.Source);
				base.Writer.Write(" = new ");
				base.Writer.Write(member.Mapping.TypeDesc.CSharpName);
				base.Writer.WriteLine("();");
				base.Writer.Write("((" + member.Mapping.TypeDesc.CSharpName + ")" + member.ArraySource + ")");
				base.Writer.WriteLine(".Add(Reader.Name.Length == 5 ? \"\" : Reader.LocalName, Reader.Value);");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
				base.Writer.WriteLine("else {");
				base.Writer.Indent++;
			}
			else
			{
				base.Writer.WriteLine("if (!IsXmlnsAttribute(Reader.Name)) {");
				base.Writer.Indent++;
			}
			if (anyAttribute != null)
			{
				base.Writer.Write(typeof(XmlAttribute).FullName);
				base.Writer.Write(" attr = ");
				base.Writer.Write("(");
				base.Writer.Write(typeof(XmlAttribute).FullName);
				base.Writer.WriteLine(") Document.ReadNode(Reader);");
				base.Writer.WriteLine("ParseWsdlArrayType(attr);");
				WriteAttribute(anyAttribute);
			}
			else
			{
				base.Writer.Write(elseCall);
				base.Writer.Write("(");
				base.Writer.Write(firstParam);
				if (arrayList.Count > 0)
				{
					base.Writer.Write(", ");
					string text = "";
					for (int j = 0; j < arrayList.Count; j++)
					{
						AttributeAccessor attributeAccessor = (AttributeAccessor)arrayList[j];
						if (j > 0)
						{
							text += ", ";
						}
						text += (attributeAccessor.IsSpecialXmlNamespace ? "http://www.w3.org/XML/1998/namespace" : (((attributeAccessor.Form == XmlSchemaForm.Qualified) ? attributeAccessor.Namespace : "") + ":" + attributeAccessor.Name));
					}
					WriteQuotedCSharpString(text);
				}
				base.Writer.WriteLine(");");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteAttribute(Member member)
		{
			AttributeAccessor attribute = member.Mapping.Attribute;
			if (attribute.Mapping is SpecialMapping)
			{
				SpecialMapping specialMapping = (SpecialMapping)attribute.Mapping;
				if (specialMapping.TypeDesc.Kind == TypeKind.Attribute)
				{
					WriteSourceBegin(member.ArraySource);
					base.Writer.Write("attr");
					WriteSourceEnd(member.ArraySource);
					base.Writer.WriteLine(";");
				}
				else
				{
					if (!specialMapping.TypeDesc.CanBeAttributeValue)
					{
						throw new InvalidOperationException(Res.GetString("XmlInternalError"));
					}
					base.Writer.Write("if (attr is ");
					base.Writer.Write(typeof(XmlAttribute).FullName);
					base.Writer.WriteLine(") {");
					base.Writer.Indent++;
					WriteSourceBegin(member.ArraySource);
					base.Writer.Write("(");
					base.Writer.Write(typeof(XmlAttribute).FullName);
					base.Writer.Write(")attr");
					WriteSourceEnd(member.ArraySource);
					base.Writer.WriteLine(";");
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
			}
			else if (attribute.IsList)
			{
				base.Writer.WriteLine("string listValues = Reader.Value;");
				base.Writer.WriteLine("string[] vals = listValues.Split(null);");
				base.Writer.WriteLine("for (int i = 0; i < vals.Length; i++) {");
				base.Writer.Indent++;
				string arraySource = GetArraySource(member.Mapping.TypeDesc, member.ArrayName);
				WriteSourceBegin(arraySource);
				WritePrimitive(attribute.Mapping, "vals[i]");
				WriteSourceEnd(arraySource);
				base.Writer.WriteLine(";");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			else
			{
				WriteSourceBegin(member.ArraySource);
				WritePrimitive(attribute.Mapping, attribute.IsList ? "vals[i]" : "Reader.Value");
				WriteSourceEnd(member.ArraySource);
				base.Writer.WriteLine(";");
			}
			if (member.Mapping.CheckSpecified == SpecifiedAccessor.ReadWrite && member.CheckSpecifiedSource != null && member.CheckSpecifiedSource.Length > 0)
			{
				base.Writer.Write(member.CheckSpecifiedSource);
				base.Writer.WriteLine(" = true;");
			}
			if (member.ParamsReadSource != null)
			{
				base.Writer.Write(member.ParamsReadSource);
				base.Writer.WriteLine(" = true;");
			}
		}

		private bool WriteMemberFixupBegin(Member[] members, string fixupMethodName, string source)
		{
			int num = 0;
			foreach (Member member in members)
			{
				if (member.Mapping.Elements.Length != 0)
				{
					TypeMapping mapping = member.Mapping.Elements[0].Mapping;
					if (mapping is StructMapping || mapping is ArrayMapping || mapping is PrimitiveMapping || mapping is NullableMapping)
					{
						member.MultiRef = true;
						member.FixupIndex = num++;
					}
				}
			}
			if (num > 0)
			{
				base.Writer.Write("Fixup fixup = new Fixup(");
				base.Writer.Write(source);
				base.Writer.Write(", ");
				base.Writer.Write("new ");
				base.Writer.Write(typeof(XmlSerializationFixupCallback).FullName);
				base.Writer.Write("(this.");
				base.Writer.Write(fixupMethodName);
				base.Writer.Write("), ");
				base.Writer.Write(num.ToString(CultureInfo.InvariantCulture));
				base.Writer.WriteLine(");");
				base.Writer.WriteLine("AddFixup(fixup);");
				return true;
			}
			return false;
		}

		private void WriteMemberBegin(Member[] members)
		{
			foreach (Member member in members)
			{
				if (!member.IsArrayLike)
				{
					continue;
				}
				string arrayName = member.ArrayName;
				string s = "c" + arrayName;
				TypeDesc typeDesc = member.Mapping.TypeDesc;
				string cSharpName = typeDesc.CSharpName;
				if (member.Mapping.TypeDesc.IsArray)
				{
					WriteArrayLocalDecl(typeDesc.CSharpName, arrayName, "null", typeDesc);
					base.Writer.Write("int ");
					base.Writer.Write(s);
					base.Writer.WriteLine(" = 0;");
					if (member.Mapping.ChoiceIdentifier != null)
					{
						WriteArrayLocalDecl(member.Mapping.ChoiceIdentifier.Mapping.TypeDesc.CSharpName + "[]", member.ChoiceArrayName, "null", member.Mapping.ChoiceIdentifier.Mapping.TypeDesc);
						base.Writer.Write("int c");
						base.Writer.Write(member.ChoiceArrayName);
						base.Writer.WriteLine(" = 0;");
					}
					continue;
				}
				bool useReflection = typeDesc.UseReflection;
				if (member.Source[member.Source.Length - 1] == '(' || member.Source[member.Source.Length - 1] == '{')
				{
					WriteCreateInstance(cSharpName, arrayName, useReflection, typeDesc.CannotNew);
					base.Writer.Write(member.Source);
					base.Writer.Write(arrayName);
					if (member.Source[member.Source.Length - 1] == '{')
					{
						base.Writer.WriteLine("});");
					}
					else
					{
						base.Writer.WriteLine(");");
					}
					continue;
				}
				if (member.IsList && !member.Mapping.ReadOnly && member.Mapping.TypeDesc.IsNullable)
				{
					base.Writer.Write("if ((object)(");
					base.Writer.Write(member.Source);
					base.Writer.Write(") == null) ");
					if (!member.Mapping.TypeDesc.HasDefaultConstructor)
					{
						base.Writer.Write("throw CreateReadOnlyCollectionException(");
						WriteQuotedCSharpString(member.Mapping.TypeDesc.CSharpName);
						base.Writer.WriteLine(");");
					}
					else
					{
						base.Writer.Write(member.Source);
						base.Writer.Write(" = ");
						base.Writer.Write(base.RaCodeGen.GetStringForCreateInstance(cSharpName, useReflection, typeDesc.CannotNew, cast: true));
						base.Writer.WriteLine(";");
					}
				}
				WriteLocalDecl(cSharpName, arrayName, member.Source, useReflection);
			}
		}

		private string ExpectedElements(Member[] members)
		{
			if (IsSequence(members))
			{
				return "null";
			}
			string text = string.Empty;
			bool flag = true;
			foreach (Member member in members)
			{
				if (member.Mapping.Xmlns != null || member.Mapping.Ignore || member.Mapping.IsText || member.Mapping.IsAttribute)
				{
					continue;
				}
				ElementAccessor[] elements = member.Mapping.Elements;
				foreach (ElementAccessor elementAccessor in elements)
				{
					string text2 = ((elementAccessor.Form == XmlSchemaForm.Qualified) ? elementAccessor.Namespace : "");
					if (!elementAccessor.Any || (elementAccessor.Name != null && elementAccessor.Name.Length != 0))
					{
						if (!flag)
						{
							text += ", ";
						}
						text = text + text2 + ":" + elementAccessor.Name;
						flag = false;
					}
				}
			}
			StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			ReflectionAwareCodeGen.WriteQuotedCSharpString(new IndentedWriter(stringWriter, compact: true), text);
			return stringWriter.ToString();
		}

		private void WriteMemberElements(Member[] members, string elementElseString, string elseString, Member anyElement, Member anyText, string checkTypeHrefsSource)
		{
			bool flag = checkTypeHrefsSource != null && checkTypeHrefsSource.Length > 0;
			if (anyText != null)
			{
				base.Writer.WriteLine("string tmp = null;");
			}
			base.Writer.Write("if (Reader.NodeType == ");
			base.Writer.Write(typeof(XmlNodeType).FullName);
			base.Writer.WriteLine(".Element) {");
			base.Writer.Indent++;
			if (flag)
			{
				WriteIfNotSoapRoot(elementElseString + " continue;");
				WriteMemberElementsCheckType(checkTypeHrefsSource);
			}
			else
			{
				WriteMemberElementsIf(members, anyElement, elementElseString, null);
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			if (anyText != null)
			{
				WriteMemberText(anyText, elseString);
			}
			base.Writer.WriteLine("else {");
			base.Writer.Indent++;
			base.Writer.WriteLine(elseString);
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteMemberText(Member anyText, string elseString)
		{
			base.Writer.Write("else if (Reader.NodeType == ");
			base.Writer.Write(typeof(XmlNodeType).FullName);
			base.Writer.WriteLine(".Text || ");
			base.Writer.Write("Reader.NodeType == ");
			base.Writer.Write(typeof(XmlNodeType).FullName);
			base.Writer.WriteLine(".CDATA || ");
			base.Writer.Write("Reader.NodeType == ");
			base.Writer.Write(typeof(XmlNodeType).FullName);
			base.Writer.WriteLine(".Whitespace || ");
			base.Writer.Write("Reader.NodeType == ");
			base.Writer.Write(typeof(XmlNodeType).FullName);
			base.Writer.WriteLine(".SignificantWhitespace) {");
			base.Writer.Indent++;
			if (anyText != null)
			{
				WriteText(anyText);
			}
			else
			{
				base.Writer.Write(elseString);
				base.Writer.WriteLine(";");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteText(Member member)
		{
			TextAccessor text = member.Mapping.Text;
			if (text.Mapping is SpecialMapping)
			{
				SpecialMapping specialMapping = (SpecialMapping)text.Mapping;
				WriteSourceBeginTyped(member.ArraySource, specialMapping.TypeDesc);
				TypeKind kind = specialMapping.TypeDesc.Kind;
				if (kind != TypeKind.Node)
				{
					throw new InvalidOperationException(Res.GetString("XmlInternalError"));
				}
				base.Writer.Write("Document.CreateTextNode(Reader.ReadString())");
				WriteSourceEnd(member.ArraySource);
			}
			else
			{
				if (member.IsArrayLike)
				{
					WriteSourceBegin(member.ArraySource);
					if (text.Mapping.TypeDesc.CollapseWhitespace)
					{
						base.Writer.Write("CollapseWhitespace(Reader.ReadString())");
					}
					else
					{
						base.Writer.Write("Reader.ReadString()");
					}
				}
				else if (text.Mapping.TypeDesc == base.StringTypeDesc || text.Mapping.TypeDesc.FormatterName == "String")
				{
					base.Writer.Write("tmp = ReadString(tmp, ");
					if (text.Mapping.TypeDesc.CollapseWhitespace)
					{
						base.Writer.WriteLine("true);");
					}
					else
					{
						base.Writer.WriteLine("false);");
					}
					WriteSourceBegin(member.ArraySource);
					base.Writer.Write("tmp");
				}
				else
				{
					WriteSourceBegin(member.ArraySource);
					WritePrimitive(text.Mapping, "Reader.ReadString()");
				}
				WriteSourceEnd(member.ArraySource);
			}
			base.Writer.WriteLine(";");
		}

		private void WriteMemberElementsCheckType(string checkTypeHrefsSource)
		{
			base.Writer.WriteLine("string refElemId = null;");
			base.Writer.WriteLine("object refElem = ReadReferencingElement(null, null, true, out refElemId);");
			base.Writer.WriteLine("if (refElemId != null) {");
			base.Writer.Indent++;
			base.Writer.Write(checkTypeHrefsSource);
			base.Writer.WriteLine(".Add(refElemId);");
			base.Writer.Write(checkTypeHrefsSource);
			base.Writer.WriteLine("IsObject.Add(false);");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			base.Writer.WriteLine("else if (refElem != null) {");
			base.Writer.Indent++;
			base.Writer.Write(checkTypeHrefsSource);
			base.Writer.WriteLine(".Add(refElem);");
			base.Writer.Write(checkTypeHrefsSource);
			base.Writer.WriteLine("IsObject.Add(true);");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteMemberElementsElse(Member anyElement, string elementElseString)
		{
			if (anyElement != null)
			{
				ElementAccessor[] elements = anyElement.Mapping.Elements;
				for (int i = 0; i < elements.Length; i++)
				{
					ElementAccessor elementAccessor = elements[i];
					if (elementAccessor.Any && elementAccessor.Name.Length == 0)
					{
						WriteElement(anyElement.ArraySource, anyElement.ArrayName, anyElement.ChoiceArraySource, elementAccessor, anyElement.Mapping.ChoiceIdentifier, (anyElement.Mapping.CheckSpecified == SpecifiedAccessor.ReadWrite) ? anyElement.CheckSpecifiedSource : null, checkForNull: false, readOnly: false, -1, i);
						break;
					}
				}
			}
			else
			{
				base.Writer.WriteLine(elementElseString);
			}
		}

		private bool IsSequence(Member[] members)
		{
			for (int i = 0; i < members.Length; i++)
			{
				if (members[i].Mapping.IsParticle && members[i].Mapping.IsSequence)
				{
					return true;
				}
			}
			return false;
		}

		private void WriteMemberElementsIf(Member[] members, Member anyElement, string elementElseString, string checkTypeSource)
		{
			bool flag = checkTypeSource != null && checkTypeSource.Length > 0;
			int num = 0;
			bool flag2 = IsSequence(members);
			if (flag2)
			{
				base.Writer.WriteLine("switch (state) {");
			}
			int num2 = 0;
			foreach (Member member in members)
			{
				if (member.Mapping.Xmlns != null || member.Mapping.Ignore || (flag2 && (member.Mapping.IsText || member.Mapping.IsAttribute)))
				{
					continue;
				}
				bool flag3 = true;
				ChoiceIdentifierAccessor choiceIdentifier = member.Mapping.ChoiceIdentifier;
				ElementAccessor[] elements = member.Mapping.Elements;
				for (int j = 0; j < elements.Length; j++)
				{
					ElementAccessor elementAccessor = elements[j];
					string ns = ((elementAccessor.Form == XmlSchemaForm.Qualified) ? elementAccessor.Namespace : "");
					if (!flag2 && elementAccessor.Any && (elementAccessor.Name == null || elementAccessor.Name.Length == 0))
					{
						continue;
					}
					if (!flag3 || (!flag2 && num > 0))
					{
						base.Writer.Write("else ");
					}
					else if (flag2)
					{
						base.Writer.Write("case ");
						base.Writer.Write(num2.ToString(CultureInfo.InvariantCulture));
						base.Writer.WriteLine(":");
						base.Writer.Indent++;
					}
					num++;
					flag3 = false;
					base.Writer.Write("if (");
					if (member.ParamsReadSource != null)
					{
						base.Writer.Write("!");
						base.Writer.Write(member.ParamsReadSource);
						base.Writer.Write(" && ");
					}
					if (flag)
					{
						if (elementAccessor.Mapping is NullableMapping)
						{
							TypeDesc typeDesc = ((NullableMapping)elementAccessor.Mapping).BaseMapping.TypeDesc;
							base.Writer.Write(base.RaCodeGen.GetStringForTypeof(typeDesc.CSharpName, typeDesc.UseReflection));
						}
						else
						{
							base.Writer.Write(base.RaCodeGen.GetStringForTypeof(elementAccessor.Mapping.TypeDesc.CSharpName, elementAccessor.Mapping.TypeDesc.UseReflection));
						}
						base.Writer.Write(".IsAssignableFrom(");
						base.Writer.Write(checkTypeSource);
						base.Writer.Write("Type)");
					}
					else
					{
						if (member.Mapping.IsReturnValue)
						{
							base.Writer.Write("(IsReturnValue || ");
						}
						if (flag2 && elementAccessor.Any && elementAccessor.AnyNamespaces == null)
						{
							base.Writer.Write("true");
						}
						else
						{
							WriteXmlNodeEqual("Reader", elementAccessor.Name, ns);
						}
						if (member.Mapping.IsReturnValue)
						{
							base.Writer.Write(")");
						}
					}
					base.Writer.WriteLine(") {");
					base.Writer.Indent++;
					if (flag)
					{
						if (elementAccessor.Mapping.TypeDesc.IsValueType || elementAccessor.Mapping is NullableMapping)
						{
							base.Writer.Write("if (");
							base.Writer.Write(checkTypeSource);
							base.Writer.WriteLine(" != null) {");
							base.Writer.Indent++;
						}
						if (elementAccessor.Mapping is NullableMapping)
						{
							WriteSourceBegin(member.ArraySource);
							TypeDesc typeDesc2 = ((NullableMapping)elementAccessor.Mapping).BaseMapping.TypeDesc;
							base.Writer.Write(base.RaCodeGen.GetStringForCreateInstance(elementAccessor.Mapping.TypeDesc.CSharpName, elementAccessor.Mapping.TypeDesc.UseReflection, ctorInaccessible: false, cast: true, "(" + typeDesc2.CSharpName + ")" + checkTypeSource));
						}
						else
						{
							WriteSourceBeginTyped(member.ArraySource, elementAccessor.Mapping.TypeDesc);
							base.Writer.Write(checkTypeSource);
						}
						WriteSourceEnd(member.ArraySource);
						base.Writer.WriteLine(";");
						if (elementAccessor.Mapping.TypeDesc.IsValueType)
						{
							base.Writer.Indent--;
							base.Writer.WriteLine("}");
						}
						if (member.FixupIndex >= 0)
						{
							base.Writer.Write("fixup.Ids[");
							base.Writer.Write(member.FixupIndex.ToString(CultureInfo.InvariantCulture));
							base.Writer.Write("] = ");
							base.Writer.Write(checkTypeSource);
							base.Writer.WriteLine("Id;");
						}
					}
					else
					{
						WriteElement(member.ArraySource, member.ArrayName, member.ChoiceArraySource, elementAccessor, choiceIdentifier, (member.Mapping.CheckSpecified == SpecifiedAccessor.ReadWrite) ? member.CheckSpecifiedSource : null, member.IsList && member.Mapping.TypeDesc.IsNullable, member.Mapping.ReadOnly, member.FixupIndex, j);
					}
					if (member.Mapping.IsReturnValue)
					{
						base.Writer.WriteLine("IsReturnValue = false;");
					}
					if (member.ParamsReadSource != null)
					{
						base.Writer.Write(member.ParamsReadSource);
						base.Writer.WriteLine(" = true;");
					}
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				if (flag2)
				{
					if (member.IsArrayLike)
					{
						base.Writer.WriteLine("else {");
						base.Writer.Indent++;
					}
					num2++;
					base.Writer.Write("state = ");
					base.Writer.Write(num2.ToString(CultureInfo.InvariantCulture));
					base.Writer.WriteLine(";");
					if (member.IsArrayLike)
					{
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
					base.Writer.WriteLine("break;");
					base.Writer.Indent--;
				}
			}
			if (num > 0)
			{
				if (flag2)
				{
					base.Writer.WriteLine("default:");
				}
				else
				{
					base.Writer.WriteLine("else {");
				}
				base.Writer.Indent++;
			}
			WriteMemberElementsElse(anyElement, elementElseString);
			if (num > 0)
			{
				if (flag2)
				{
					base.Writer.WriteLine("break;");
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
		}

		private string GetArraySource(TypeDesc typeDesc, string arrayName)
		{
			return GetArraySource(typeDesc, arrayName, multiRef: false);
		}

		private string GetArraySource(TypeDesc typeDesc, string arrayName, bool multiRef)
		{
			string text = "c" + arrayName;
			string text2 = "";
			if (multiRef)
			{
				text2 = "soap = (System.Object[])EnsureArrayIndex(soap, " + text + "+2, typeof(System.Object)); ";
			}
			bool useReflection = typeDesc.UseReflection;
			if (typeDesc.IsArray)
			{
				string cSharpName = typeDesc.ArrayElementTypeDesc.CSharpName;
				bool useReflection2 = typeDesc.ArrayElementTypeDesc.UseReflection;
				string text3 = (useReflection ? "" : ("(" + cSharpName + "[])"));
				text2 = text2 + arrayName + " = " + text3 + "EnsureArrayIndex(" + arrayName + ", " + text + ", " + base.RaCodeGen.GetStringForTypeof(cSharpName, useReflection2) + ");";
				string stringForArrayMember = base.RaCodeGen.GetStringForArrayMember(arrayName, text + "++", typeDesc);
				if (multiRef)
				{
					text2 = text2 + " soap[1] = " + arrayName + ";";
					text2 = text2 + " if (ReadReference(out soap[" + text + "+2])) " + stringForArrayMember + " = null; else ";
				}
				return text2 + stringForArrayMember;
			}
			return base.RaCodeGen.GetStringForMethod(arrayName, typeDesc.CSharpName, "Add", useReflection);
		}

		private void WriteMemberEnd(Member[] members)
		{
			WriteMemberEnd(members, soapRefs: false);
		}

		private void WriteMemberEnd(Member[] members, bool soapRefs)
		{
			foreach (Member member in members)
			{
				if (!member.IsArrayLike)
				{
					continue;
				}
				TypeDesc typeDesc = member.Mapping.TypeDesc;
				if (typeDesc.IsArray)
				{
					WriteSourceBegin(member.Source);
					if (soapRefs)
					{
						base.Writer.Write(" soap[1] = ");
					}
					string arrayName = member.ArrayName;
					string s = "c" + arrayName;
					bool useReflection = typeDesc.ArrayElementTypeDesc.UseReflection;
					string cSharpName = typeDesc.ArrayElementTypeDesc.CSharpName;
					if (!useReflection)
					{
						base.Writer.Write("(" + cSharpName + "[])");
					}
					base.Writer.Write("ShrinkArray(");
					base.Writer.Write(arrayName);
					base.Writer.Write(", ");
					base.Writer.Write(s);
					base.Writer.Write(", ");
					base.Writer.Write(base.RaCodeGen.GetStringForTypeof(cSharpName, useReflection));
					base.Writer.Write(", ");
					WriteBooleanValue(member.IsNullable);
					base.Writer.Write(")");
					WriteSourceEnd(member.Source);
					base.Writer.WriteLine(";");
					if (member.Mapping.ChoiceIdentifier != null)
					{
						WriteSourceBegin(member.ChoiceSource);
						arrayName = member.ChoiceArrayName;
						s = "c" + arrayName;
						bool useReflection2 = member.Mapping.ChoiceIdentifier.Mapping.TypeDesc.UseReflection;
						string cSharpName2 = member.Mapping.ChoiceIdentifier.Mapping.TypeDesc.CSharpName;
						if (!useReflection2)
						{
							base.Writer.Write("(" + cSharpName2 + "[])");
						}
						base.Writer.Write("ShrinkArray(");
						base.Writer.Write(arrayName);
						base.Writer.Write(", ");
						base.Writer.Write(s);
						base.Writer.Write(", ");
						base.Writer.Write(base.RaCodeGen.GetStringForTypeof(cSharpName2, useReflection2));
						base.Writer.Write(", ");
						WriteBooleanValue(member.IsNullable);
						base.Writer.Write(")");
						WriteSourceEnd(member.ChoiceSource);
						base.Writer.WriteLine(";");
					}
				}
				else if (typeDesc.IsValueType)
				{
					base.Writer.Write(member.Source);
					base.Writer.Write(" = ");
					base.Writer.Write(member.ArrayName);
					base.Writer.WriteLine(";");
				}
			}
		}

		private void WriteSourceBeginTyped(string source, TypeDesc typeDesc)
		{
			WriteSourceBegin(source);
			if (typeDesc != null && !typeDesc.UseReflection)
			{
				base.Writer.Write("(");
				base.Writer.Write(typeDesc.CSharpName);
				base.Writer.Write(")");
			}
		}

		private void WriteSourceBegin(string source)
		{
			base.Writer.Write(source);
			if (source[source.Length - 1] != '(' && source[source.Length - 1] != '{')
			{
				base.Writer.Write(" = ");
			}
		}

		private void WriteSourceEnd(string source)
		{
			if (source[source.Length - 1] == '(')
			{
				base.Writer.Write(")");
			}
			else if (source[source.Length - 1] == '{')
			{
				base.Writer.Write("})");
			}
		}

		private void WriteArray(string source, string arrayName, ArrayMapping arrayMapping, bool readOnly, bool isNullable, int fixupIndex)
		{
			if (arrayMapping.IsSoap)
			{
				base.Writer.Write("object rre = ");
				base.Writer.Write((fixupIndex >= 0) ? "ReadReferencingElement" : "ReadReferencedElement");
				base.Writer.Write("(");
				WriteID(arrayMapping.TypeName);
				base.Writer.Write(", ");
				WriteID(arrayMapping.Namespace);
				if (fixupIndex >= 0)
				{
					base.Writer.Write(", ");
					base.Writer.Write("out fixup.Ids[");
					base.Writer.Write(fixupIndex.ToString(CultureInfo.InvariantCulture));
					base.Writer.Write("]");
				}
				base.Writer.WriteLine(");");
				TypeDesc typeDesc = arrayMapping.TypeDesc;
				if (typeDesc.IsEnumerable || typeDesc.IsCollection)
				{
					base.Writer.WriteLine("if (rre != null) {");
					base.Writer.Indent++;
					WriteAddCollectionFixup(typeDesc, readOnly, source, "rre");
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				else
				{
					base.Writer.WriteLine("try {");
					base.Writer.Indent++;
					WriteSourceBeginTyped(source, arrayMapping.TypeDesc);
					base.Writer.Write("rre");
					WriteSourceEnd(source);
					base.Writer.WriteLine(";");
					WriteCatchCastException(arrayMapping.TypeDesc, "rre", null);
				}
				return;
			}
			base.Writer.WriteLine("if (!ReadNull()) {");
			base.Writer.Indent++;
			MemberMapping memberMapping = new MemberMapping();
			memberMapping.Elements = arrayMapping.Elements;
			memberMapping.TypeDesc = arrayMapping.TypeDesc;
			memberMapping.ReadOnly = readOnly;
			Member member = new Member(this, source, arrayName, 0, memberMapping, multiRef: false);
			member.IsNullable = false;
			Member[] members = new Member[1] { member };
			WriteMemberBegin(members);
			if (readOnly)
			{
				base.Writer.Write("if (((object)(");
				base.Writer.Write(member.ArrayName);
				base.Writer.Write(") == null) || ");
			}
			else
			{
				base.Writer.Write("if (");
			}
			base.Writer.WriteLine("(Reader.IsEmptyElement)) {");
			base.Writer.Indent++;
			base.Writer.WriteLine("Reader.Skip();");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			base.Writer.WriteLine("else {");
			base.Writer.Indent++;
			base.Writer.WriteLine("Reader.ReadStartElement();");
			int loopIndex = WriteWhileNotLoopStart();
			base.Writer.Indent++;
			string text = "UnknownNode(null, " + ExpectedElements(members) + ");";
			WriteMemberElements(members, text, text, null, null, null);
			base.Writer.WriteLine("Reader.MoveToContent();");
			WriteWhileLoopEnd(loopIndex);
			base.Writer.Indent--;
			base.Writer.WriteLine("ReadEndElement();");
			base.Writer.WriteLine("}");
			WriteMemberEnd(members, soapRefs: false);
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			if (isNullable)
			{
				base.Writer.WriteLine("else {");
				base.Writer.Indent++;
				member.IsNullable = true;
				WriteMemberBegin(members);
				WriteMemberEnd(members);
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
		}

		private void WriteElement(string source, string arrayName, string choiceSource, ElementAccessor element, ChoiceIdentifierAccessor choice, string checkSpecified, bool checkForNull, bool readOnly, int fixupIndex, int elementIndex)
		{
			if (checkSpecified != null && checkSpecified.Length > 0)
			{
				base.Writer.Write(checkSpecified);
				base.Writer.WriteLine(" = true;");
			}
			if (element.Mapping is ArrayMapping)
			{
				WriteArray(source, arrayName, (ArrayMapping)element.Mapping, readOnly, element.IsNullable, fixupIndex);
			}
			else if (element.Mapping is NullableMapping)
			{
				string s = ReferenceMapping(element.Mapping);
				WriteSourceBegin(source);
				base.Writer.Write(s);
				base.Writer.Write("(true)");
				WriteSourceEnd(source);
				base.Writer.WriteLine(";");
			}
			else if (!element.Mapping.IsSoap && element.Mapping is PrimitiveMapping)
			{
				if (element.IsNullable)
				{
					base.Writer.WriteLine("if (ReadNull()) {");
					base.Writer.Indent++;
					WriteSourceBegin(source);
					if (element.Mapping.TypeDesc.IsValueType)
					{
						base.Writer.Write(base.RaCodeGen.GetStringForCreateInstance(element.Mapping.TypeDesc.CSharpName, element.Mapping.TypeDesc.UseReflection, ctorInaccessible: false, cast: false));
					}
					else
					{
						base.Writer.Write("null");
					}
					WriteSourceEnd(source);
					base.Writer.WriteLine(";");
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
					base.Writer.Write("else ");
				}
				if (element.Default != null && element.Default != DBNull.Value && element.Mapping.TypeDesc.IsValueType)
				{
					base.Writer.WriteLine("if (Reader.IsEmptyElement) {");
					base.Writer.Indent++;
					base.Writer.WriteLine("Reader.Skip();");
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
					base.Writer.WriteLine("else {");
				}
				else
				{
					base.Writer.WriteLine("{");
				}
				base.Writer.Indent++;
				WriteSourceBegin(source);
				if (element.Mapping.TypeDesc == base.QnameTypeDesc)
				{
					base.Writer.Write("ReadElementQualifiedName()");
				}
				else
				{
					string source2;
					switch (element.Mapping.TypeDesc.FormatterName)
					{
					case "ByteArrayBase64":
					case "ByteArrayHex":
						source2 = "false";
						break;
					default:
						source2 = "Reader.ReadElementString()";
						break;
					}
					WritePrimitive(element.Mapping, source2);
				}
				WriteSourceEnd(source);
				base.Writer.WriteLine(";");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			else if (element.Mapping is StructMapping || (element.Mapping.IsSoap && element.Mapping is PrimitiveMapping))
			{
				TypeMapping mapping = element.Mapping;
				if (mapping.IsSoap)
				{
					base.Writer.Write("object rre = ");
					base.Writer.Write((fixupIndex >= 0) ? "ReadReferencingElement" : "ReadReferencedElement");
					base.Writer.Write("(");
					WriteID(mapping.TypeName);
					base.Writer.Write(", ");
					WriteID(mapping.Namespace);
					if (fixupIndex >= 0)
					{
						base.Writer.Write(", out fixup.Ids[");
						base.Writer.Write(fixupIndex.ToString(CultureInfo.InvariantCulture));
						base.Writer.Write("]");
					}
					base.Writer.Write(")");
					WriteSourceEnd(source);
					base.Writer.WriteLine(";");
					if (mapping.TypeDesc.IsValueType)
					{
						base.Writer.WriteLine("if (rre != null) {");
						base.Writer.Indent++;
					}
					base.Writer.WriteLine("try {");
					base.Writer.Indent++;
					WriteSourceBeginTyped(source, mapping.TypeDesc);
					base.Writer.Write("rre");
					WriteSourceEnd(source);
					base.Writer.WriteLine(";");
					WriteCatchCastException(mapping.TypeDesc, "rre", null);
					base.Writer.Write("Referenced(");
					base.Writer.Write(source);
					base.Writer.WriteLine(");");
					if (mapping.TypeDesc.IsValueType)
					{
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
				}
				else
				{
					string s2 = ReferenceMapping(mapping);
					if (checkForNull)
					{
						base.Writer.Write("if ((object)(");
						base.Writer.Write(arrayName);
						base.Writer.Write(") == null) Reader.Skip(); else ");
					}
					WriteSourceBegin(source);
					base.Writer.Write(s2);
					base.Writer.Write("(");
					if (mapping.TypeDesc.IsNullable)
					{
						WriteBooleanValue(element.IsNullable);
						base.Writer.Write(", ");
					}
					base.Writer.Write("true");
					base.Writer.Write(")");
					WriteSourceEnd(source);
					base.Writer.WriteLine(";");
				}
			}
			else
			{
				if (!(element.Mapping is SpecialMapping))
				{
					throw new InvalidOperationException(Res.GetString("XmlInternalError"));
				}
				SpecialMapping specialMapping = (SpecialMapping)element.Mapping;
				switch (specialMapping.TypeDesc.Kind)
				{
				case TypeKind.Node:
				{
					bool flag2 = specialMapping.TypeDesc.FullName == typeof(XmlDocument).FullName;
					WriteSourceBeginTyped(source, specialMapping.TypeDesc);
					base.Writer.Write(flag2 ? "ReadXmlDocument(" : "ReadXmlNode(");
					base.Writer.Write(element.Any ? "false" : "true");
					base.Writer.Write(")");
					WriteSourceEnd(source);
					base.Writer.WriteLine(";");
					break;
				}
				case TypeKind.Serializable:
				{
					SerializableMapping serializableMapping = (SerializableMapping)element.Mapping;
					if (serializableMapping.DerivedMappings != null)
					{
						base.Writer.Write(typeof(XmlQualifiedName).FullName);
						base.Writer.WriteLine(" tser = GetXsiType();");
						base.Writer.Write("if (tser == null");
						base.Writer.Write(" || ");
						WriteQNameEqual("tser", serializableMapping.XsiType.Name, serializableMapping.XsiType.Namespace);
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
					}
					WriteSourceBeginTyped(source, serializableMapping.TypeDesc);
					base.Writer.Write("ReadSerializable(( ");
					base.Writer.Write(typeof(IXmlSerializable).FullName);
					base.Writer.Write(")");
					base.Writer.Write(base.RaCodeGen.GetStringForCreateInstance(serializableMapping.TypeDesc.CSharpName, serializableMapping.TypeDesc.UseReflection, serializableMapping.TypeDesc.CannotNew, cast: false));
					bool flag = !element.Any && XmlSerializationCodeGen.IsWildcard(serializableMapping);
					if (flag)
					{
						base.Writer.WriteLine(", true");
					}
					base.Writer.Write(")");
					WriteSourceEnd(source);
					base.Writer.WriteLine(";");
					if (serializableMapping.DerivedMappings != null)
					{
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
						WriteDerivedSerializable(serializableMapping, serializableMapping, source, flag);
						WriteUnknownNode("UnknownNode", "null", null, anyIfs: true);
					}
					break;
				}
				default:
					throw new InvalidOperationException(Res.GetString("XmlInternalError"));
				}
			}
			if (choice != null)
			{
				string cSharpName = choice.Mapping.TypeDesc.CSharpName;
				base.Writer.Write(choiceSource);
				base.Writer.Write(" = ");
				CodeIdentifier.CheckValidIdentifier(choice.MemberIds[elementIndex]);
				base.Writer.Write(base.RaCodeGen.GetStringForEnumMember(cSharpName, choice.MemberIds[elementIndex], choice.Mapping.TypeDesc.UseReflection));
				base.Writer.WriteLine(";");
			}
		}

		private void WriteDerivedSerializable(SerializableMapping head, SerializableMapping mapping, string source, bool isWrappedAny)
		{
			if (mapping == null)
			{
				return;
			}
			for (SerializableMapping serializableMapping = mapping.DerivedMappings; serializableMapping != null; serializableMapping = serializableMapping.NextDerivedMapping)
			{
				base.Writer.Write("else if (tser == null");
				base.Writer.Write(" || ");
				WriteQNameEqual("tser", serializableMapping.XsiType.Name, serializableMapping.XsiType.Namespace);
				base.Writer.WriteLine(") {");
				base.Writer.Indent++;
				if (serializableMapping.Type != null)
				{
					if (head.Type.IsAssignableFrom(serializableMapping.Type))
					{
						WriteSourceBeginTyped(source, head.TypeDesc);
						base.Writer.Write("ReadSerializable(( ");
						base.Writer.Write(typeof(IXmlSerializable).FullName);
						base.Writer.Write(")");
						base.Writer.Write(base.RaCodeGen.GetStringForCreateInstance(serializableMapping.TypeDesc.CSharpName, serializableMapping.TypeDesc.UseReflection, serializableMapping.TypeDesc.CannotNew, cast: false));
						if (isWrappedAny)
						{
							base.Writer.WriteLine(", true");
						}
						base.Writer.Write(")");
						WriteSourceEnd(source);
						base.Writer.WriteLine(";");
					}
					else
					{
						base.Writer.Write("throw CreateBadDerivationException(");
						WriteQuotedCSharpString(serializableMapping.XsiType.Name);
						base.Writer.Write(", ");
						WriteQuotedCSharpString(serializableMapping.XsiType.Namespace);
						base.Writer.Write(", ");
						WriteQuotedCSharpString(head.XsiType.Name);
						base.Writer.Write(", ");
						WriteQuotedCSharpString(head.XsiType.Namespace);
						base.Writer.Write(", ");
						WriteQuotedCSharpString(serializableMapping.Type.FullName);
						base.Writer.Write(", ");
						WriteQuotedCSharpString(head.Type.FullName);
						base.Writer.WriteLine(");");
					}
				}
				else
				{
					base.Writer.WriteLine("// missing real mapping for " + serializableMapping.XsiType);
					base.Writer.Write("throw CreateMissingIXmlSerializableType(");
					WriteQuotedCSharpString(serializableMapping.XsiType.Name);
					base.Writer.Write(", ");
					WriteQuotedCSharpString(serializableMapping.XsiType.Namespace);
					base.Writer.Write(", ");
					WriteQuotedCSharpString(head.Type.FullName);
					base.Writer.WriteLine(");");
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
				WriteDerivedSerializable(head, serializableMapping, source, isWrappedAny);
			}
		}

		private int WriteWhileNotLoopStart()
		{
			base.Writer.WriteLine("Reader.MoveToContent();");
			int result = WriteWhileLoopStartCheck();
			base.Writer.Write("while (Reader.NodeType != ");
			base.Writer.Write(typeof(XmlNodeType).FullName);
			base.Writer.Write(".EndElement && Reader.NodeType != ");
			base.Writer.Write(typeof(XmlNodeType).FullName);
			base.Writer.WriteLine(".None) {");
			return result;
		}

		private void WriteWhileLoopEnd(int loopIndex)
		{
			WriteWhileLoopEndCheck(loopIndex);
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private int WriteWhileLoopStartCheck()
		{
			base.Writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "int whileIterations{0} = 0;", nextWhileLoopIndex));
			base.Writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "int readerCount{0} = ReaderCount;", nextWhileLoopIndex));
			return nextWhileLoopIndex++;
		}

		private void WriteWhileLoopEndCheck(int loopIndex)
		{
			base.Writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "CheckReaderCount(ref whileIterations{0}, ref readerCount{1});", loopIndex, loopIndex));
		}

		private void WriteParamsRead(int length)
		{
			base.Writer.Write("bool[] paramsRead = new bool[");
			base.Writer.Write(length.ToString(CultureInfo.InvariantCulture));
			base.Writer.WriteLine("];");
		}

		private void WriteReadNonRoots()
		{
			base.Writer.WriteLine("Reader.MoveToContent();");
			int loopIndex = WriteWhileLoopStartCheck();
			base.Writer.Write("while (Reader.NodeType == ");
			base.Writer.Write(typeof(XmlNodeType).FullName);
			base.Writer.WriteLine(".Element) {");
			base.Writer.Indent++;
			base.Writer.Write("string root = Reader.GetAttribute(\"root\", \"");
			base.Writer.Write("http://schemas.xmlsoap.org/soap/encoding/");
			base.Writer.WriteLine("\");");
			base.Writer.Write("if (root == null || ");
			base.Writer.Write(typeof(XmlConvert).FullName);
			base.Writer.WriteLine(".ToBoolean(root)) break;");
			base.Writer.WriteLine("ReadReferencedElement();");
			base.Writer.WriteLine("Reader.MoveToContent();");
			WriteWhileLoopEnd(loopIndex);
		}

		private void WriteBooleanValue(bool value)
		{
			base.Writer.Write(value ? "true" : "false");
		}

		private void WriteInitCheckTypeHrefList(string source)
		{
			base.Writer.Write(typeof(ArrayList).FullName);
			base.Writer.Write(" ");
			base.Writer.Write(source);
			base.Writer.Write(" = new ");
			base.Writer.Write(typeof(ArrayList).FullName);
			base.Writer.WriteLine("();");
			base.Writer.Write(typeof(ArrayList).FullName);
			base.Writer.Write(" ");
			base.Writer.Write(source);
			base.Writer.Write("IsObject = new ");
			base.Writer.Write(typeof(ArrayList).FullName);
			base.Writer.WriteLine("();");
		}

		private void WriteHandleHrefList(Member[] members, string listSource)
		{
			base.Writer.WriteLine("int isObjectIndex = 0;");
			base.Writer.Write("foreach (object obj in ");
			base.Writer.Write(listSource);
			base.Writer.WriteLine(") {");
			base.Writer.Indent++;
			base.Writer.WriteLine("bool isReferenced = true;");
			base.Writer.Write("bool isObject = (bool)");
			base.Writer.Write(listSource);
			base.Writer.WriteLine("IsObject[isObjectIndex++];");
			base.Writer.WriteLine("object refObj = isObject ? obj : GetTarget((string)obj);");
			base.Writer.WriteLine("if (refObj == null) continue;");
			base.Writer.Write(typeof(Type).FullName);
			base.Writer.WriteLine(" refObjType = refObj.GetType();");
			base.Writer.WriteLine("string refObjId = null;");
			WriteMemberElementsIf(members, null, "isReferenced = false;", "refObj");
			base.Writer.WriteLine("if (isObject && isReferenced) Referenced(refObj); // need to mark this obj as ref'd since we didn't do GetTarget");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteIfNotSoapRoot(string source)
		{
			base.Writer.Write("if (Reader.GetAttribute(\"root\", \"");
			base.Writer.Write("http://schemas.xmlsoap.org/soap/encoding/");
			base.Writer.WriteLine("\") == \"0\") {");
			base.Writer.Indent++;
			base.Writer.WriteLine(source);
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteCreateMapping(TypeMapping mapping, string local)
		{
			string cSharpName = mapping.TypeDesc.CSharpName;
			bool useReflection = mapping.TypeDesc.UseReflection;
			bool cannotNew = mapping.TypeDesc.CannotNew;
			base.Writer.Write(useReflection ? "object" : cSharpName);
			base.Writer.Write(" ");
			base.Writer.Write(local);
			base.Writer.WriteLine(";");
			if (cannotNew)
			{
				base.Writer.WriteLine("try {");
				base.Writer.Indent++;
			}
			base.Writer.Write(local);
			base.Writer.Write(" = ");
			base.Writer.Write(base.RaCodeGen.GetStringForCreateInstance(cSharpName, useReflection, mapping.TypeDesc.CannotNew, cast: true));
			base.Writer.WriteLine(";");
			if (cannotNew)
			{
				WriteCatchException(typeof(MissingMethodException));
				base.Writer.Indent++;
				base.Writer.Write("throw CreateInaccessibleConstructorException(");
				WriteQuotedCSharpString(cSharpName);
				base.Writer.WriteLine(");");
				WriteCatchException(typeof(SecurityException));
				base.Writer.Indent++;
				base.Writer.Write("throw CreateCtorHasSecurityException(");
				WriteQuotedCSharpString(cSharpName);
				base.Writer.WriteLine(");");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
		}

		private void WriteCatchException(Type exceptionType)
		{
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			base.Writer.Write("catch (");
			base.Writer.Write(exceptionType.FullName);
			base.Writer.WriteLine(") {");
		}

		private void WriteCatchCastException(TypeDesc typeDesc, string source, string id)
		{
			WriteCatchException(typeof(InvalidCastException));
			base.Writer.Indent++;
			base.Writer.Write("throw CreateInvalidCastException(");
			base.Writer.Write(base.RaCodeGen.GetStringForTypeof(typeDesc.CSharpName, typeDesc.UseReflection));
			base.Writer.Write(", ");
			base.Writer.Write(source);
			if (id == null)
			{
				base.Writer.WriteLine(", null);");
			}
			else
			{
				base.Writer.Write(", (string)");
				base.Writer.Write(id);
				base.Writer.WriteLine(");");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteArrayLocalDecl(string typeName, string variableName, string initValue, TypeDesc arrayTypeDesc)
		{
			base.RaCodeGen.WriteArrayLocalDecl(typeName, variableName, initValue, arrayTypeDesc);
		}

		private void WriteCreateInstance(string escapedName, string source, bool useReflection, bool ctorInaccessible)
		{
			base.RaCodeGen.WriteCreateInstance(escapedName, source, useReflection, ctorInaccessible);
		}

		private void WriteLocalDecl(string typeFullName, string variableName, string initValue, bool useReflection)
		{
			base.RaCodeGen.WriteLocalDecl(typeFullName, variableName, initValue, useReflection);
		}
	}
	public abstract class XmlSerializationWriter : XmlSerializationGeneratedCode
	{
		internal class TypeEntry
		{
			internal XmlSerializationWriteCallback callback;

			internal string typeNs;

			internal string typeName;

			internal Type type;
		}

		private XmlWriter w;

		private XmlSerializerNamespaces namespaces;

		private int tempNamespacePrefix;

		private Hashtable usedPrefixes;

		private Hashtable references;

		private string idBase;

		private int nextId;

		private Hashtable typeEntries;

		private ArrayList referencesToWrite;

		private Hashtable objectsInUse;

		private string aliasBase = "q";

		private bool soap12;

		private bool escapeName = true;

		protected bool EscapeName
		{
			get
			{
				return escapeName;
			}
			set
			{
				escapeName = value;
			}
		}

		protected XmlWriter Writer
		{
			get
			{
				return w;
			}
			set
			{
				w = value;
			}
		}

		protected ArrayList Namespaces
		{
			get
			{
				if (namespaces != null)
				{
					return namespaces.NamespaceList;
				}
				return null;
			}
			set
			{
				if (value == null)
				{
					namespaces = null;
					return;
				}
				XmlQualifiedName[] array = (XmlQualifiedName[])value.ToArray(typeof(XmlQualifiedName));
				namespaces = new XmlSerializerNamespaces(array);
			}
		}

		internal void Init(XmlWriter w, XmlSerializerNamespaces namespaces, string encodingStyle, string idBase, TempAssembly tempAssembly)
		{
			this.w = w;
			this.namespaces = namespaces;
			soap12 = encodingStyle == "http://www.w3.org/2003/05/soap-encoding";
			this.idBase = idBase;
			Init(tempAssembly);
		}

		protected static byte[] FromByteArrayBase64(byte[] value)
		{
			return value;
		}

		protected static Assembly ResolveDynamicAssembly(string assemblyFullName)
		{
			return DynamicAssemblies.Get(assemblyFullName);
		}

		protected static string FromByteArrayHex(byte[] value)
		{
			return XmlCustomFormatter.FromByteArrayHex(value);
		}

		protected static string FromDateTime(DateTime value)
		{
			return XmlCustomFormatter.FromDateTime(value);
		}

		protected static string FromDate(DateTime value)
		{
			return XmlCustomFormatter.FromDate(value);
		}

		protected static string FromTime(DateTime value)
		{
			return XmlCustomFormatter.FromTime(value);
		}

		protected static string FromChar(char value)
		{
			return XmlCustomFormatter.FromChar(value);
		}

		protected static string FromEnum(long value, string[] values, long[] ids)
		{
			return XmlCustomFormatter.FromEnum(value, values, ids, null);
		}

		protected static string FromEnum(long value, string[] values, long[] ids, string typeName)
		{
			return XmlCustomFormatter.FromEnum(value, values, ids, typeName);
		}

		protected static string FromXmlName(string name)
		{
			return XmlCustomFormatter.FromXmlName(name);
		}

		protected static string FromXmlNCName(string ncName)
		{
			return XmlCustomFormatter.FromXmlNCName(ncName);
		}

		protected static string FromXmlNmToken(string nmToken)
		{
			return XmlCustomFormatter.FromXmlNmToken(nmToken);
		}

		protected static string FromXmlNmTokens(string nmTokens)
		{
			return XmlCustomFormatter.FromXmlNmTokens(nmTokens);
		}

		protected void WriteXsiType(string name, string ns)
		{
			WriteAttribute("type", "http://www.w3.org/2001/XMLSchema-instance", GetQualifiedName(name, ns));
		}

		private XmlQualifiedName GetPrimitiveTypeName(Type type)
		{
			return GetPrimitiveTypeName(type, throwIfUnknown: true);
		}

		private XmlQualifiedName GetPrimitiveTypeName(Type type, bool throwIfUnknown)
		{
			XmlQualifiedName primitiveTypeNameInternal = GetPrimitiveTypeNameInternal(type);
			if (throwIfUnknown && primitiveTypeNameInternal == null)
			{
				throw CreateUnknownTypeException(type);
			}
			return primitiveTypeNameInternal;
		}

		internal static XmlQualifiedName GetPrimitiveTypeNameInternal(Type type)
		{
			string ns = "http://www.w3.org/2001/XMLSchema";
			string name;
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.String:
				name = "string";
				break;
			case TypeCode.Int32:
				name = "int";
				break;
			case TypeCode.Boolean:
				name = "boolean";
				break;
			case TypeCode.Int16:
				name = "short";
				break;
			case TypeCode.Int64:
				name = "long";
				break;
			case TypeCode.Single:
				name = "float";
				break;
			case TypeCode.Double:
				name = "double";
				break;
			case TypeCode.Decimal:
				name = "decimal";
				break;
			case TypeCode.DateTime:
				name = "dateTime";
				break;
			case TypeCode.Byte:
				name = "unsignedByte";
				break;
			case TypeCode.SByte:
				name = "byte";
				break;
			case TypeCode.UInt16:
				name = "unsignedShort";
				break;
			case TypeCode.UInt32:
				name = "unsignedInt";
				break;
			case TypeCode.UInt64:
				name = "unsignedLong";
				break;
			case TypeCode.Char:
				name = "char";
				ns = "http://microsoft.com/wsdl/types/";
				break;
			default:
				if (type == typeof(XmlQualifiedName))
				{
					name = "QName";
					break;
				}
				if (type == typeof(byte[]))
				{
					name = "base64Binary";
					break;
				}
				if (type == typeof(Guid))
				{
					name = "guid";
					ns = "http://microsoft.com/wsdl/types/";
					break;
				}
				if (type == typeof(XmlNode[]))
				{
					name = "anyType";
					break;
				}
				return null;
			}
			return new XmlQualifiedName(name, ns);
		}

		protected void WriteTypedPrimitive(string name, string ns, object o, bool xsiType)
		{
			string text = null;
			string ns2 = "http://www.w3.org/2001/XMLSchema";
			bool flag = true;
			bool flag2 = false;
			Type type = o.GetType();
			bool flag3 = false;
			string text2;
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.String:
				text = (string)o;
				text2 = "string";
				flag = false;
				break;
			case TypeCode.Int32:
				text = XmlConvert.ToString((int)o);
				text2 = "int";
				break;
			case TypeCode.Boolean:
				text = XmlConvert.ToString((bool)o);
				text2 = "boolean";
				break;
			case TypeCode.Int16:
				text = XmlConvert.ToString((short)o);
				text2 = "short";
				break;
			case TypeCode.Int64:
				text = XmlConvert.ToString((long)o);
				text2 = "long";
				break;
			case TypeCode.Single:
				text = XmlConvert.ToString((float)o);
				text2 = "float";
				break;
			case TypeCode.Double:
				text = XmlConvert.ToString((double)o);
				text2 = "double";
				break;
			case TypeCode.Decimal:
				text = XmlConvert.ToString((decimal)o);
				text2 = "decimal";
				break;
			case TypeCode.DateTime:
				text = FromDateTime((DateTime)o);
				text2 = "dateTime";
				break;
			case TypeCode.Char:
				text = FromChar((char)o);
				text2 = "char";
				ns2 = "http://microsoft.com/wsdl/types/";
				break;
			case TypeCode.Byte:
				text = XmlConvert.ToString((byte)o);
				text2 = "unsignedByte";
				break;
			case TypeCode.SByte:
				text = XmlConvert.ToString((sbyte)o);
				text2 = "byte";
				break;
			case TypeCode.UInt16:
				text = XmlConvert.ToString((ushort)o);
				text2 = "unsignedShort";
				break;
			case TypeCode.UInt32:
				text = XmlConvert.ToString((uint)o);
				text2 = "unsignedInt";
				break;
			case TypeCode.UInt64:
				text = XmlConvert.ToString((ulong)o);
				text2 = "unsignedLong";
				break;
			default:
				if (type == typeof(XmlQualifiedName))
				{
					text2 = "QName";
					flag3 = true;
					if (name == null)
					{
						w.WriteStartElement(text2, ns2);
					}
					else
					{
						w.WriteStartElement(name, ns);
					}
					text = FromXmlQualifiedName((XmlQualifiedName)o, ignoreEmpty: false);
					break;
				}
				if (type == typeof(byte[]))
				{
					text = string.Empty;
					flag2 = true;
					text2 = "base64Binary";
					break;
				}
				if (type == typeof(Guid))
				{
					text = XmlConvert.ToString((Guid)o);
					text2 = "guid";
					ns2 = "http://microsoft.com/wsdl/types/";
					break;
				}
				if (typeof(XmlNode[]).IsAssignableFrom(type))
				{
					if (name == null)
					{
						w.WriteStartElement("anyType", "http://www.w3.org/2001/XMLSchema");
					}
					else
					{
						w.WriteStartElement(name, ns);
					}
					XmlNode[] array = (XmlNode[])o;
					for (int i = 0; i < array.Length; i++)
					{
						if (array[i] != null)
						{
							array[i].WriteTo(w);
						}
					}
					w.WriteEndElement();
					return;
				}
				throw CreateUnknownTypeException(type);
			}
			if (!flag3)
			{
				if (name == null)
				{
					w.WriteStartElement(text2, ns2);
				}
				else
				{
					w.WriteStartElement(name, ns);
				}
			}
			if (xsiType)
			{
				WriteXsiType(text2, ns2);
			}
			if (text == null)
			{
				w.WriteAttributeString("nil", "http://www.w3.org/2001/XMLSchema-instance", "true");
			}
			else if (flag2)
			{
				XmlCustomFormatter.WriteArrayBase64(w, (byte[])o, 0, ((byte[])o).Length);
			}
			else if (flag)
			{
				w.WriteRaw(text);
			}
			else
			{
				w.WriteString(text);
			}
			w.WriteEndElement();
		}

		private string GetQualifiedName(string name, string ns)
		{
			if (ns == null || ns.Length == 0)
			{
				return name;
			}
			string text = w.LookupPrefix(ns);
			if (text == null)
			{
				if (ns == "http://www.w3.org/XML/1998/namespace")
				{
					text = "xml";
				}
				else
				{
					text = NextPrefix();
					WriteAttribute("xmlns", text, null, ns);
				}
			}
			else if (text.Length == 0)
			{
				return name;
			}
			return text + ":" + name;
		}

		protected string FromXmlQualifiedName(XmlQualifiedName xmlQualifiedName)
		{
			return FromXmlQualifiedName(xmlQualifiedName, ignoreEmpty: true);
		}

		protected string FromXmlQualifiedName(XmlQualifiedName xmlQualifiedName, bool ignoreEmpty)
		{
			if (xmlQualifiedName == null)
			{
				return null;
			}
			if (xmlQualifiedName.IsEmpty && ignoreEmpty)
			{
				return null;
			}
			return GetQualifiedName(EscapeName ? XmlConvert.EncodeLocalName(xmlQualifiedName.Name) : xmlQualifiedName.Name, xmlQualifiedName.Namespace);
		}

		protected void WriteStartElement(string name)
		{
			WriteStartElement(name, null, null, writePrefixed: false, null);
		}

		protected void WriteStartElement(string name, string ns)
		{
			WriteStartElement(name, ns, null, writePrefixed: false, null);
		}

		protected void WriteStartElement(string name, string ns, bool writePrefixed)
		{
			WriteStartElement(name, ns, null, writePrefixed, null);
		}

		protected void WriteStartElement(string name, string ns, object o)
		{
			WriteStartElement(name, ns, o, writePrefixed: false, null);
		}

		protected void WriteStartElement(string name, string ns, object o, bool writePrefixed)
		{
			WriteStartElement(name, ns, o, writePrefixed, null);
		}

		protected void WriteStartElement(string name, string ns, object o, bool writePrefixed, XmlSerializerNamespaces xmlns)
		{
			if (o != null && objectsInUse != null)
			{
				if (objectsInUse.ContainsKey(o))
				{
					throw new InvalidOperationException(Res.GetString("XmlCircularReference", o.GetType().FullName));
				}
				objectsInUse.Add(o, o);
			}
			string text = null;
			bool flag = false;
			if (namespaces != null)
			{
				foreach (string key in namespaces.Namespaces.Keys)
				{
					string text3 = (string)namespaces.Namespaces[key];
					if (key.Length > 0 && text3 == ns)
					{
						text = key;
					}
					if (key.Length == 0)
					{
						if (text3 == null || text3.Length == 0)
						{
							flag = true;
						}
						if (ns != text3)
						{
							writePrefixed = true;
						}
					}
				}
				usedPrefixes = ListUsedPrefixes(namespaces.Namespaces, aliasBase);
			}
			if (writePrefixed && text == null && ns != null && ns.Length > 0)
			{
				text = w.LookupPrefix(ns);
				if (text == null || text.Length == 0)
				{
					text = NextPrefix();
				}
			}
			if (text == null && xmlns != null)
			{
				text = xmlns.LookupPrefix(ns);
			}
			if (flag && text == null && ns != null && ns.Length != 0)
			{
				text = NextPrefix();
			}
			w.WriteStartElement(text, name, ns);
			if (namespaces != null)
			{
				foreach (string key2 in namespaces.Namespaces.Keys)
				{
					string text5 = (string)namespaces.Namespaces[key2];
					if (key2.Length == 0 && (text5 == null || text5.Length == 0))
					{
						continue;
					}
					if (text5 == null || text5.Length == 0)
					{
						if (key2.Length > 0)
						{
							throw new InvalidOperationException(Res.GetString("XmlInvalidXmlns", key2));
						}
						WriteAttribute("xmlns", key2, null, text5);
					}
					else if (w.LookupPrefix(text5) == null)
					{
						if (text == null && key2.Length == 0)
						{
							break;
						}
						WriteAttribute("xmlns", key2, null, text5);
					}
				}
			}
			WriteNamespaceDeclarations(xmlns);
		}

		private Hashtable ListUsedPrefixes(Hashtable nsList, string prefix)
		{
			Hashtable hashtable = new Hashtable();
			int length = prefix.Length;
			foreach (string key in namespaces.Namespaces.Keys)
			{
				if (key.Length <= length)
				{
					continue;
				}
				string text2 = key;
				_ = text2.Length;
				if (text2.Length <= length || text2.Length > length + "2147483647".Length || !text2.StartsWith(prefix, StringComparison.Ordinal))
				{
					continue;
				}
				bool flag = true;
				for (int i = length; i < text2.Length; i++)
				{
					if (!char.IsDigit(text2, i))
					{
						flag = false;
						break;
					}
				}
				if (!flag)
				{
					continue;
				}
				long num = long.Parse(text2.Substring(length), CultureInfo.InvariantCulture);
				if (num <= int.MaxValue)
				{
					int num2 = (int)num;
					if (!hashtable.ContainsKey(num2))
					{
						hashtable.Add(num2, num2);
					}
				}
			}
			if (hashtable.Count > 0)
			{
				return hashtable;
			}
			return null;
		}

		protected void WriteNullTagEncoded(string name)
		{
			WriteNullTagEncoded(name, null);
		}

		protected void WriteNullTagEncoded(string name, string ns)
		{
			if (name != null && name.Length != 0)
			{
				WriteStartElement(name, ns, null, writePrefixed: true);
				w.WriteAttributeString("nil", "http://www.w3.org/2001/XMLSchema-instance", "true");
				w.WriteEndElement();
			}
		}

		protected void WriteNullTagLiteral(string name)
		{
			WriteNullTagLiteral(name, null);
		}

		protected void WriteNullTagLiteral(string name, string ns)
		{
			if (name != null && name.Length != 0)
			{
				WriteStartElement(name, ns, null, writePrefixed: false);
				w.WriteAttributeString("nil", "http://www.w3.org/2001/XMLSchema-instance", "true");
				w.WriteEndElement();
			}
		}

		protected void WriteEmptyTag(string name)
		{
			WriteEmptyTag(name, null);
		}

		protected void WriteEmptyTag(string name, string ns)
		{
			if (name != null && name.Length != 0)
			{
				WriteStartElement(name, ns, null, writePrefixed: false);
				w.WriteEndElement();
			}
		}

		protected void WriteEndElement()
		{
			w.WriteEndElement();
		}

		protected void WriteEndElement(object o)
		{
			w.WriteEndElement();
			if (o != null && objectsInUse != null)
			{
				objectsInUse.Remove(o);
			}
		}

		protected void WriteSerializable(IXmlSerializable serializable, string name, string ns, bool isNullable)
		{
			WriteSerializable(serializable, name, ns, isNullable, wrapped: true);
		}

		protected void WriteSerializable(IXmlSerializable serializable, string name, string ns, bool isNullable, bool wrapped)
		{
			if (serializable == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(name, ns);
				}
				return;
			}
			if (wrapped)
			{
				w.WriteStartElement(name, ns);
			}
			serializable.WriteXml(w);
			if (wrapped)
			{
				w.WriteEndElement();
			}
		}

		protected void WriteNullableStringEncoded(string name, string ns, string value, XmlQualifiedName xsiType)
		{
			if (value == null)
			{
				WriteNullTagEncoded(name, ns);
			}
			else
			{
				WriteElementString(name, ns, value, xsiType);
			}
		}

		protected void WriteNullableStringLiteral(string name, string ns, string value)
		{
			if (value == null)
			{
				WriteNullTagLiteral(name, ns);
			}
			else
			{
				WriteElementString(name, ns, value, null);
			}
		}

		protected void WriteNullableStringEncodedRaw(string name, string ns, string value, XmlQualifiedName xsiType)
		{
			if (value == null)
			{
				WriteNullTagEncoded(name, ns);
			}
			else
			{
				WriteElementStringRaw(name, ns, value, xsiType);
			}
		}

		protected void WriteNullableStringEncodedRaw(string name, string ns, byte[] value, XmlQualifiedName xsiType)
		{
			if (value == null)
			{
				WriteNullTagEncoded(name, ns);
			}
			else
			{
				WriteElementStringRaw(name, ns, value, xsiType);
			}
		}

		protected void WriteNullableStringLiteralRaw(string name, string ns, string value)
		{
			if (value == null)
			{
				WriteNullTagLiteral(name, ns);
			}
			else
			{
				WriteElementStringRaw(name, ns, value, null);
			}
		}

		protected void WriteNullableStringLiteralRaw(string name, string ns, byte[] value)
		{
			if (value == null)
			{
				WriteNullTagLiteral(name, ns);
			}
			else
			{
				WriteElementStringRaw(name, ns, value, null);
			}
		}

		protected void WriteNullableQualifiedNameEncoded(string name, string ns, XmlQualifiedName value, XmlQualifiedName xsiType)
		{
			if (value == null)
			{
				WriteNullTagEncoded(name, ns);
			}
			else
			{
				WriteElementQualifiedName(name, ns, value, xsiType);
			}
		}

		protected void WriteNullableQualifiedNameLiteral(string name, string ns, XmlQualifiedName value)
		{
			if (value == null)
			{
				WriteNullTagLiteral(name, ns);
			}
			else
			{
				WriteElementQualifiedName(name, ns, value, null);
			}
		}

		protected void WriteElementEncoded(XmlNode node, string name, string ns, bool isNullable, bool any)
		{
			if (node == null)
			{
				if (isNullable)
				{
					WriteNullTagEncoded(name, ns);
				}
			}
			else
			{
				WriteElement(node, name, ns, isNullable, any);
			}
		}

		protected void WriteElementLiteral(XmlNode node, string name, string ns, bool isNullable, bool any)
		{
			if (node == null)
			{
				if (isNullable)
				{
					WriteNullTagLiteral(name, ns);
				}
			}
			else
			{
				WriteElement(node, name, ns, isNullable, any);
			}
		}

		private void WriteElement(XmlNode node, string name, string ns, bool isNullable, bool any)
		{
			if (typeof(XmlAttribute).IsAssignableFrom(node.GetType()))
			{
				throw new InvalidOperationException(Res.GetString("XmlNoAttributeHere"));
			}
			if (node is XmlDocument)
			{
				node = ((XmlDocument)node).DocumentElement;
				if (node == null)
				{
					if (isNullable)
					{
						WriteNullTagEncoded(name, ns);
					}
					return;
				}
			}
			if (any)
			{
				if (node is XmlElement && name != null && name.Length > 0 && (node.LocalName != name || node.NamespaceURI != ns))
				{
					throw new InvalidOperationException(Res.GetString("XmlElementNameMismatch", node.LocalName, node.NamespaceURI, name, ns));
				}
			}
			else
			{
				w.WriteStartElement(name, ns);
			}
			node.WriteTo(w);
			if (!any)
			{
				w.WriteEndElement();
			}
		}

		protected Exception CreateUnknownTypeException(object o)
		{
			return CreateUnknownTypeException(o.GetType());
		}

		protected Exception CreateUnknownTypeException(Type type)
		{
			if (typeof(IXmlSerializable).IsAssignableFrom(type))
			{
				return new InvalidOperationException(Res.GetString("XmlInvalidSerializable", type.FullName));
			}
			TypeDesc typeDesc = new TypeScope().GetTypeDesc(type);
			if (!typeDesc.IsStructLike)
			{
				return new InvalidOperationException(Res.GetString("XmlInvalidUseOfType", type.FullName));
			}
			return new InvalidOperationException(Res.GetString("XmlUnxpectedType", type.FullName));
		}

		protected Exception CreateMismatchChoiceException(string value, string elementName, string enumValue)
		{
			return new InvalidOperationException(Res.GetString("XmlChoiceMismatchChoiceException", elementName, value, enumValue));
		}

		protected Exception CreateUnknownAnyElementException(string name, string ns)
		{
			return new InvalidOperationException(Res.GetString("XmlUnknownAnyElement", name, ns));
		}

		protected Exception CreateInvalidChoiceIdentifierValueException(string type, string identifier)
		{
			return new InvalidOperationException(Res.GetString("XmlInvalidChoiceIdentifierValue", type, identifier));
		}

		protected Exception CreateChoiceIdentifierValueException(string value, string identifier, string name, string ns)
		{
			return new InvalidOperationException(Res.GetString("XmlChoiceIdentifierMismatch", value, identifier, name, ns));
		}

		protected Exception CreateInvalidEnumValueException(object value, string typeName)
		{
			return new InvalidOperationException(Res.GetString("XmlUnknownConstant", value, typeName));
		}

		protected Exception CreateInvalidAnyTypeException(object o)
		{
			return CreateInvalidAnyTypeException(o.GetType());
		}

		protected Exception CreateInvalidAnyTypeException(Type type)
		{
			return new InvalidOperationException(Res.GetString("XmlIllegalAnyElement", type.FullName));
		}

		protected void WriteReferencingElement(string n, string ns, object o)
		{
			WriteReferencingElement(n, ns, o, isNullable: false);
		}

		protected void WriteReferencingElement(string n, string ns, object o, bool isNullable)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagEncoded(n, ns);
				}
				return;
			}
			WriteStartElement(n, ns, null, writePrefixed: true);
			if (soap12)
			{
				w.WriteAttributeString("ref", "http://www.w3.org/2003/05/soap-encoding", GetId(o, addToReferencesList: true));
			}
			else
			{
				w.WriteAttributeString("href", "#" + GetId(o, addToReferencesList: true));
			}
			w.WriteEndElement();
		}

		private bool IsIdDefined(object o)
		{
			if (references != null)
			{
				return references.Contains(o);
			}
			return false;
		}

		private string GetId(object o, bool addToReferencesList)
		{
			if (references == null)
			{
				references = new Hashtable();
				referencesToWrite = new ArrayList();
			}
			string text = (string)references[o];
			if (text == null)
			{
				text = idBase + "id" + (++nextId).ToString(CultureInfo.InvariantCulture);
				references.Add(o, text);
				if (addToReferencesList)
				{
					referencesToWrite.Add(o);
				}
			}
			return text;
		}

		protected void WriteId(object o)
		{
			WriteId(o, addToReferencesList: true);
		}

		private void WriteId(object o, bool addToReferencesList)
		{
			if (soap12)
			{
				w.WriteAttributeString("id", "http://www.w3.org/2003/05/soap-encoding", GetId(o, addToReferencesList));
			}
			else
			{
				w.WriteAttributeString("id", GetId(o, addToReferencesList));
			}
		}

		protected void WriteXmlAttribute(XmlNode node)
		{
			WriteXmlAttribute(node, null);
		}

		protected void WriteXmlAttribute(XmlNode node, object container)
		{
			if (!(node is XmlAttribute xmlAttribute))
			{
				throw new InvalidOperationException(Res.GetString("XmlNeedAttributeHere"));
			}
			if (xmlAttribute.Value != null)
			{
				if (xmlAttribute.NamespaceURI == "http://schemas.xmlsoap.org/wsdl/" && xmlAttribute.LocalName == "arrayType")
				{
					string dims;
					XmlQualifiedName xmlQualifiedName = TypeScope.ParseWsdlArrayType(xmlAttribute.Value, out dims, (container is XmlSchemaObject) ? ((XmlSchemaObject)container) : null);
					string value = FromXmlQualifiedName(xmlQualifiedName, ignoreEmpty: true) + dims;
					WriteAttribute("arrayType", "http://schemas.xmlsoap.org/wsdl/", value);
				}
				else
				{
					WriteAttribute(xmlAttribute.Name, xmlAttribute.NamespaceURI, xmlAttribute.Value);
				}
			}
		}

		protected void WriteAttribute(string localName, string ns, string value)
		{
			if (value == null || localName == "xmlns" || localName.StartsWith("xmlns:", StringComparison.Ordinal))
			{
				return;
			}
			int num = localName.IndexOf(':');
			if (num < 0)
			{
				if (ns == "http://www.w3.org/XML/1998/namespace")
				{
					string text = w.LookupPrefix(ns);
					if (text == null || text.Length == 0)
					{
						text = "xml";
					}
					w.WriteAttributeString(text, localName, ns, value);
				}
				else
				{
					w.WriteAttributeString(localName, ns, value);
				}
			}
			else
			{
				string prefix = localName.Substring(0, num);
				w.WriteAttributeString(prefix, localName.Substring(num + 1), ns, value);
			}
		}

		protected void WriteAttribute(string localName, string ns, byte[] value)
		{
			if (value == null || localName == "xmlns" || localName.StartsWith("xmlns:", StringComparison.Ordinal))
			{
				return;
			}
			int num = localName.IndexOf(':');
			if (num < 0)
			{
				if (ns == "http://www.w3.org/XML/1998/namespace")
				{
					string text = w.LookupPrefix(ns);
					if (text == null || text.Length == 0)
					{
						text = "xml";
					}
					w.WriteStartAttribute("xml", localName, ns);
				}
				else
				{
					w.WriteStartAttribute(null, localName, ns);
				}
			}
			else
			{
				string text2 = localName.Substring(0, num);
				text2 = w.LookupPrefix(ns);
				w.WriteStartAttribute(text2, localName.Substring(num + 1), ns);
			}
			XmlCustomFormatter.WriteArrayBase64(w, value, 0, value.Length);
			w.WriteEndAttribute();
		}

		protected void WriteAttribute(string localName, string value)
		{
			if (value != null)
			{
				w.WriteAttributeString(localName, null, value);
			}
		}

		protected void WriteAttribute(string localName, byte[] value)
		{
			if (value != null)
			{
				w.WriteStartAttribute(null, localName, null);
				XmlCustomFormatter.WriteArrayBase64(w, value, 0, value.Length);
				w.WriteEndAttribute();
			}
		}

		protected void WriteAttribute(string prefix, string localName, string ns, string value)
		{
			if (value != null)
			{
				w.WriteAttributeString(prefix, localName, null, value);
			}
		}

		protected void WriteValue(string value)
		{
			if (value != null)
			{
				w.WriteString(value);
			}
		}

		protected void WriteValue(byte[] value)
		{
			if (value != null)
			{
				XmlCustomFormatter.WriteArrayBase64(w, value, 0, value.Length);
			}
		}

		protected void WriteStartDocument()
		{
			if (w.WriteState == WriteState.Start)
			{
				w.WriteStartDocument();
			}
		}

		protected void WriteElementString(string localName, string value)
		{
			WriteElementString(localName, null, value, null);
		}

		protected void WriteElementString(string localName, string ns, string value)
		{
			WriteElementString(localName, ns, value, null);
		}

		protected void WriteElementString(string localName, string value, XmlQualifiedName xsiType)
		{
			WriteElementString(localName, null, value, xsiType);
		}

		protected void WriteElementString(string localName, string ns, string value, XmlQualifiedName xsiType)
		{
			if (value != null)
			{
				if (xsiType == null)
				{
					w.WriteElementString(localName, ns, value);
					return;
				}
				w.WriteStartElement(localName, ns);
				WriteXsiType(xsiType.Name, xsiType.Namespace);
				w.WriteString(value);
				w.WriteEndElement();
			}
		}

		protected void WriteElementStringRaw(string localName, string value)
		{
			WriteElementStringRaw(localName, null, value, null);
		}

		protected void WriteElementStringRaw(string localName, byte[] value)
		{
			WriteElementStringRaw(localName, null, value, null);
		}

		protected void WriteElementStringRaw(string localName, string ns, string value)
		{
			WriteElementStringRaw(localName, ns, value, null);
		}

		protected void WriteElementStringRaw(string localName, string ns, byte[] value)
		{
			WriteElementStringRaw(localName, ns, value, null);
		}

		protected void WriteElementStringRaw(string localName, string value, XmlQualifiedName xsiType)
		{
			WriteElementStringRaw(localName, null, value, xsiType);
		}

		protected void WriteElementStringRaw(string localName, byte[] value, XmlQualifiedName xsiType)
		{
			WriteElementStringRaw(localName, null, value, xsiType);
		}

		protected void WriteElementStringRaw(string localName, string ns, string value, XmlQualifiedName xsiType)
		{
			if (value != null)
			{
				w.WriteStartElement(localName, ns);
				if (xsiType != null)
				{
					WriteXsiType(xsiType.Name, xsiType.Namespace);
				}
				w.WriteRaw(value);
				w.WriteEndElement();
			}
		}

		protected void WriteElementStringRaw(string localName, string ns, byte[] value, XmlQualifiedName xsiType)
		{
			if (value != null)
			{
				w.WriteStartElement(localName, ns);
				if (xsiType != null)
				{
					WriteXsiType(xsiType.Name, xsiType.Namespace);
				}
				XmlCustomFormatter.WriteArrayBase64(w, value, 0, value.Length);
				w.WriteEndElement();
			}
		}

		protected void WriteRpcResult(string name, string ns)
		{
			if (soap12)
			{
				WriteElementQualifiedName("result", "http://www.w3.org/2003/05/soap-rpc", new XmlQualifiedName(name, ns), null);
			}
		}

		protected void WriteElementQualifiedName(string localName, XmlQualifiedName value)
		{
			WriteElementQualifiedName(localName, null, value, null);
		}

		protected void WriteElementQualifiedName(string localName, XmlQualifiedName value, XmlQualifiedName xsiType)
		{
			WriteElementQualifiedName(localName, null, value, xsiType);
		}

		protected void WriteElementQualifiedName(string localName, string ns, XmlQualifiedName value)
		{
			WriteElementQualifiedName(localName, ns, value, null);
		}

		protected void WriteElementQualifiedName(string localName, string ns, XmlQualifiedName value, XmlQualifiedName xsiType)
		{
			if (!(value == null))
			{
				if (value.Namespace == null || value.Namespace.Length == 0)
				{
					WriteStartElement(localName, ns, null, writePrefixed: true);
					WriteAttribute("xmlns", "");
				}
				else
				{
					w.WriteStartElement(localName, ns);
				}
				if (xsiType != null)
				{
					WriteXsiType(xsiType.Name, xsiType.Namespace);
				}
				w.WriteString(FromXmlQualifiedName(value, ignoreEmpty: false));
				w.WriteEndElement();
			}
		}

		protected void AddWriteCallback(Type type, string typeName, string typeNs, XmlSerializationWriteCallback callback)
		{
			TypeEntry typeEntry = new TypeEntry();
			typeEntry.typeName = typeName;
			typeEntry.typeNs = typeNs;
			typeEntry.type = type;
			typeEntry.callback = callback;
			typeEntries[type] = typeEntry;
		}

		private void WriteArray(string name, string ns, object o, Type type)
		{
			Type arrayElementType = TypeScope.GetArrayElementType(type, null);
			StringBuilder stringBuilder = new StringBuilder();
			if (!soap12)
			{
				while ((arrayElementType.IsArray || typeof(IEnumerable).IsAssignableFrom(arrayElementType)) && GetPrimitiveTypeName(arrayElementType, throwIfUnknown: false) == null)
				{
					arrayElementType = TypeScope.GetArrayElementType(arrayElementType, null);
					stringBuilder.Append("[]");
				}
			}
			string text;
			string ns2;
			if (arrayElementType == typeof(object))
			{
				text = "anyType";
				ns2 = "http://www.w3.org/2001/XMLSchema";
			}
			else
			{
				TypeEntry typeEntry = GetTypeEntry(arrayElementType);
				if (typeEntry != null)
				{
					text = typeEntry.typeName;
					ns2 = typeEntry.typeNs;
				}
				else if (soap12)
				{
					XmlQualifiedName primitiveTypeName = GetPrimitiveTypeName(arrayElementType, throwIfUnknown: false);
					if (primitiveTypeName != null)
					{
						text = primitiveTypeName.Name;
						ns2 = primitiveTypeName.Namespace;
					}
					else
					{
						for (Type baseType = arrayElementType.BaseType; baseType != null; baseType = baseType.BaseType)
						{
							typeEntry = GetTypeEntry(baseType);
							if (typeEntry != null)
							{
								break;
							}
						}
						if (typeEntry != null)
						{
							text = typeEntry.typeName;
							ns2 = typeEntry.typeNs;
						}
						else
						{
							text = "anyType";
							ns2 = "http://www.w3.org/2001/XMLSchema";
						}
					}
				}
				else
				{
					XmlQualifiedName primitiveTypeName2 = GetPrimitiveTypeName(arrayElementType);
					text = primitiveTypeName2.Name;
					ns2 = primitiveTypeName2.Namespace;
				}
			}
			if (stringBuilder.Length > 0)
			{
				text += stringBuilder.ToString();
			}
			if (soap12 && name != null && name.Length > 0)
			{
				WriteStartElement(name, ns, null, writePrefixed: false);
			}
			else
			{
				WriteStartElement("Array", "http://schemas.xmlsoap.org/soap/encoding/", null, writePrefixed: true);
			}
			WriteId(o, addToReferencesList: false);
			if (type.IsArray)
			{
				Array array = (Array)o;
				int length = array.Length;
				if (soap12)
				{
					w.WriteAttributeString("itemType", "http://www.w3.org/2003/05/soap-encoding", GetQualifiedName(text, ns2));
					w.WriteAttributeString("arraySize", "http://www.w3.org/2003/05/soap-encoding", length.ToString(CultureInfo.InvariantCulture));
				}
				else
				{
					w.WriteAttributeString("arrayType", "http://schemas.xmlsoap.org/soap/encoding/", GetQualifiedName(text, ns2) + "[" + length.ToString(CultureInfo.InvariantCulture) + "]");
				}
				for (int i = 0; i < length; i++)
				{
					WritePotentiallyReferencingElement("Item", "", array.GetValue(i), arrayElementType, suppressReference: false, isNullable: true);
				}
			}
			else
			{
				int num = (typeof(ICollection).IsAssignableFrom(type) ? ((ICollection)o).Count : (-1));
				if (soap12)
				{
					w.WriteAttributeString("itemType", "http://www.w3.org/2003/05/soap-encoding", GetQualifiedName(text, ns2));
					if (num >= 0)
					{
						w.WriteAttributeString("arraySize", "http://www.w3.org/2003/05/soap-encoding", num.ToString(CultureInfo.InvariantCulture));
					}
				}
				else
				{
					string text2 = ((num >= 0) ? ("[" + num + "]") : "[]");
					w.WriteAttributeString("arrayType", "http://schemas.xmlsoap.org/soap/encoding/", GetQualifiedName(text, ns2) + text2);
				}
				IEnumerator enumerator = ((IEnumerable)o).GetEnumerator();
				if (enumerator != null)
				{
					while (enumerator.MoveNext())
					{
						WritePotentiallyReferencingElement("Item", "", enumerator.Current, arrayElementType, suppressReference: false, isNullable: true);
					}
				}
			}
			w.WriteEndElement();
		}

		protected void WritePotentiallyReferencingElement(string n, string ns, object o)
		{
			WritePotentiallyReferencingElement(n, ns, o, null, suppressReference: false, isNullable: false);
		}

		protected void WritePotentiallyReferencingElement(string n, string ns, object o, Type ambientType)
		{
			WritePotentiallyReferencingElement(n, ns, o, ambientType, suppressReference: false, isNullable: false);
		}

		protected void WritePotentiallyReferencingElement(string n, string ns, object o, Type ambientType, bool suppressReference)
		{
			WritePotentiallyReferencingElement(n, ns, o, ambientType, suppressReference, isNullable: false);
		}

		protected void WritePotentiallyReferencingElement(string n, string ns, object o, Type ambientType, bool suppressReference, bool isNullable)
		{
			if (o == null)
			{
				if (isNullable)
				{
					WriteNullTagEncoded(n, ns);
				}
				return;
			}
			Type type = o.GetType();
			if (Convert.GetTypeCode(o) == TypeCode.Object && !(o is Guid) && type != typeof(XmlQualifiedName) && !(o is XmlNode[]) && type != typeof(byte[]))
			{
				if ((suppressReference || soap12) && !IsIdDefined(o))
				{
					WriteReferencedElement(n, ns, o, ambientType);
				}
				else if (n == null)
				{
					TypeEntry typeEntry = GetTypeEntry(type);
					WriteReferencingElement(typeEntry.typeName, typeEntry.typeNs, o, isNullable);
				}
				else
				{
					WriteReferencingElement(n, ns, o, isNullable);
				}
				return;
			}
			bool flag = type != ambientType && !type.IsEnum;
			TypeEntry typeEntry2 = GetTypeEntry(type);
			if (typeEntry2 != null)
			{
				if (n == null)
				{
					WriteStartElement(typeEntry2.typeName, typeEntry2.typeNs, null, writePrefixed: true);
				}
				else
				{
					WriteStartElement(n, ns, null, writePrefixed: true);
				}
				if (flag)
				{
					WriteXsiType(typeEntry2.typeName, typeEntry2.typeNs);
				}
				typeEntry2.callback(o);
				w.WriteEndElement();
			}
			else
			{
				WriteTypedPrimitive(n, ns, o, flag);
			}
		}

		private void WriteReferencedElement(object o, Type ambientType)
		{
			WriteReferencedElement(null, null, o, ambientType);
		}

		private void WriteReferencedElement(string name, string ns, object o, Type ambientType)
		{
			if (name == null)
			{
				name = string.Empty;
			}
			Type type = o.GetType();
			if (type.IsArray || typeof(IEnumerable).IsAssignableFrom(type))
			{
				WriteArray(name, ns, o, type);
				return;
			}
			TypeEntry typeEntry = GetTypeEntry(type);
			if (typeEntry == null)
			{
				throw CreateUnknownTypeException(type);
			}
			WriteStartElement((name.Length == 0) ? typeEntry.typeName : name, (ns == null) ? typeEntry.typeNs : ns, null, writePrefixed: true);
			WriteId(o, addToReferencesList: false);
			if (ambientType != type)
			{
				WriteXsiType(typeEntry.typeName, typeEntry.typeNs);
			}
			typeEntry.callback(o);
			w.WriteEndElement();
		}

		private TypeEntry GetTypeEntry(Type t)
		{
			if (typeEntries == null)
			{
				typeEntries = new Hashtable();
				InitCallbacks();
			}
			return (TypeEntry)typeEntries[t];
		}

		protected abstract void InitCallbacks();

		protected void WriteReferencedElements()
		{
			if (referencesToWrite != null)
			{
				for (int i = 0; i < referencesToWrite.Count; i++)
				{
					WriteReferencedElement(referencesToWrite[i], null);
				}
			}
		}

		protected void TopLevelElement()
		{
			objectsInUse = new Hashtable();
		}

		protected void WriteNamespaceDeclarations(XmlSerializerNamespaces xmlns)
		{
			if (xmlns != null)
			{
				foreach (DictionaryEntry @namespace in xmlns.Namespaces)
				{
					string text = (string)@namespace.Key;
					string text2 = (string)@namespace.Value;
					if (namespaces != null && namespaces.Namespaces[text] is string text3 && text3 != text2)
					{
						throw new InvalidOperationException(Res.GetString("XmlDuplicateNs", text, text2));
					}
					string text4 = ((text2 == null || text2.Length == 0) ? null : Writer.LookupPrefix(text2));
					if (text4 == null || text4 != text)
					{
						WriteAttribute("xmlns", text, null, text2);
					}
				}
			}
			namespaces = null;
		}

		private string NextPrefix()
		{
			if (usedPrefixes == null)
			{
				return aliasBase + ++tempNamespacePrefix;
			}
			while (usedPrefixes.ContainsKey(++tempNamespacePrefix))
			{
			}
			return aliasBase + tempNamespacePrefix;
		}
	}
	public delegate void XmlSerializationWriteCallback(object o);
	internal class XmlSerializationWriterCodeGen : XmlSerializationCodeGen
	{
		internal XmlSerializationWriterCodeGen(IndentedWriter writer, TypeScope[] scopes, string access, string className)
			: base(writer, scopes, access, className)
		{
		}

		internal void GenerateBegin()
		{
			base.Writer.Write(base.Access);
			base.Writer.Write(" class ");
			base.Writer.Write(base.ClassName);
			base.Writer.Write(" : ");
			base.Writer.Write(typeof(XmlSerializationWriter).FullName);
			base.Writer.WriteLine(" {");
			base.Writer.Indent++;
			TypeScope[] array = base.Scopes;
			foreach (TypeScope typeScope in array)
			{
				foreach (TypeMapping typeMapping3 in typeScope.TypeMappings)
				{
					if (typeMapping3 is StructMapping || typeMapping3 is EnumMapping)
					{
						base.MethodNames.Add(typeMapping3, NextMethodName(typeMapping3.TypeDesc.Name));
					}
				}
				base.RaCodeGen.WriteReflectionInit(typeScope);
			}
			TypeScope[] array2 = base.Scopes;
			foreach (TypeScope typeScope2 in array2)
			{
				foreach (TypeMapping typeMapping4 in typeScope2.TypeMappings)
				{
					if (typeMapping4.IsSoap)
					{
						if (typeMapping4 is StructMapping)
						{
							WriteStructMethod((StructMapping)typeMapping4);
						}
						else if (typeMapping4 is EnumMapping)
						{
							WriteEnumMethod((EnumMapping)typeMapping4);
						}
					}
				}
			}
		}

		internal override void GenerateMethod(TypeMapping mapping)
		{
			if (!base.GeneratedMethods.Contains(mapping))
			{
				base.GeneratedMethods[mapping] = mapping;
				if (mapping is StructMapping)
				{
					WriteStructMethod((StructMapping)mapping);
				}
				else if (mapping is EnumMapping)
				{
					WriteEnumMethod((EnumMapping)mapping);
				}
			}
		}

		internal void GenerateEnd()
		{
			GenerateReferencedMethods();
			GenerateInitCallbacksMethod();
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		internal string GenerateElement(XmlMapping xmlMapping)
		{
			if (!xmlMapping.IsWriteable)
			{
				return null;
			}
			if (!xmlMapping.GenerateSerializer)
			{
				throw new ArgumentException(Res.GetString("XmlInternalError"), "xmlMapping");
			}
			if (xmlMapping is XmlTypeMapping)
			{
				return GenerateTypeElement((XmlTypeMapping)xmlMapping);
			}
			if (xmlMapping is XmlMembersMapping)
			{
				return GenerateMembersElement((XmlMembersMapping)xmlMapping);
			}
			throw new ArgumentException(Res.GetString("XmlInternalError"), "xmlMapping");
		}

		private void GenerateInitCallbacksMethod()
		{
			base.Writer.WriteLine();
			base.Writer.WriteLine("protected override void InitCallbacks() {");
			base.Writer.Indent++;
			TypeScope[] array = base.Scopes;
			foreach (TypeScope typeScope in array)
			{
				foreach (TypeMapping typeMapping in typeScope.TypeMappings)
				{
					if (typeMapping.IsSoap && (typeMapping is StructMapping || typeMapping is EnumMapping) && !typeMapping.TypeDesc.IsRoot)
					{
						string s = (string)base.MethodNames[typeMapping];
						base.Writer.Write("AddWriteCallback(");
						base.Writer.Write(base.RaCodeGen.GetStringForTypeof(typeMapping.TypeDesc.CSharpName, typeMapping.TypeDesc.UseReflection));
						base.Writer.Write(", ");
						WriteQuotedCSharpString(typeMapping.TypeName);
						base.Writer.Write(", ");
						WriteQuotedCSharpString(typeMapping.Namespace);
						base.Writer.Write(", new ");
						base.Writer.Write(typeof(XmlSerializationWriteCallback).FullName);
						base.Writer.Write("(this.");
						base.Writer.Write(s);
						base.Writer.WriteLine("));");
					}
				}
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteQualifiedNameElement(string name, string ns, object defaultValue, string source, bool nullable, bool IsSoap, TypeMapping mapping)
		{
			bool flag = defaultValue != null && defaultValue != DBNull.Value;
			if (flag)
			{
				WriteCheckDefault(source, defaultValue, nullable);
				base.Writer.WriteLine(" {");
				base.Writer.Indent++;
			}
			string text = (IsSoap ? "Encoded" : "Literal");
			base.Writer.Write(nullable ? ("WriteNullableQualifiedName" + text) : "WriteElementQualifiedName");
			base.Writer.Write("(");
			WriteQuotedCSharpString(name);
			if (ns != null)
			{
				base.Writer.Write(", ");
				WriteQuotedCSharpString(ns);
			}
			base.Writer.Write(", ");
			base.Writer.Write(source);
			if (IsSoap)
			{
				base.Writer.Write(", new System.Xml.XmlQualifiedName(");
				WriteQuotedCSharpString(mapping.TypeName);
				base.Writer.Write(", ");
				WriteQuotedCSharpString(mapping.Namespace);
				base.Writer.Write(")");
			}
			base.Writer.WriteLine(");");
			if (flag)
			{
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
		}

		private void WriteEnumValue(EnumMapping mapping, string source)
		{
			string s = ReferenceMapping(mapping);
			base.Writer.Write(s);
			base.Writer.Write("(");
			base.Writer.Write(source);
			base.Writer.Write(")");
		}

		private void WritePrimitiveValue(TypeDesc typeDesc, string source, bool isElement)
		{
			if (typeDesc == base.StringTypeDesc || typeDesc.FormatterName == "String")
			{
				base.Writer.Write(source);
			}
			else if (!typeDesc.HasCustomFormatter)
			{
				base.Writer.Write(typeof(XmlConvert).FullName);
				base.Writer.Write(".ToString((");
				base.Writer.Write(typeDesc.CSharpName);
				base.Writer.Write(")");
				base.Writer.Write(source);
				base.Writer.Write(")");
			}
			else
			{
				base.Writer.Write("From");
				base.Writer.Write(typeDesc.FormatterName);
				base.Writer.Write("(");
				base.Writer.Write(source);
				base.Writer.Write(")");
			}
		}

		private void WritePrimitive(string method, string name, string ns, object defaultValue, string source, TypeMapping mapping, bool writeXsiType, bool isElement, bool isNullable)
		{
			TypeDesc typeDesc = mapping.TypeDesc;
			bool flag = defaultValue != null && defaultValue != DBNull.Value && mapping.TypeDesc.HasDefaultSupport;
			if (flag)
			{
				if (mapping is EnumMapping)
				{
					base.Writer.Write("if (");
					if (mapping.TypeDesc.UseReflection)
					{
						base.Writer.Write(base.RaCodeGen.GetStringForEnumLongValue(source, mapping.TypeDesc.UseReflection));
					}
					else
					{
						base.Writer.Write(source);
					}
					base.Writer.Write(" != ");
					if (((EnumMapping)mapping).IsFlags)
					{
						base.Writer.Write("(");
						string[] array = ((string)defaultValue).Split(null);
						for (int i = 0; i < array.Length; i++)
						{
							if (array[i] != null && array[i].Length != 0)
							{
								if (i > 0)
								{
									base.Writer.WriteLine(" | ");
								}
								base.Writer.Write(base.RaCodeGen.GetStringForEnumCompare((EnumMapping)mapping, array[i], mapping.TypeDesc.UseReflection));
							}
						}
						base.Writer.Write(")");
					}
					else
					{
						base.Writer.Write(base.RaCodeGen.GetStringForEnumCompare((EnumMapping)mapping, (string)defaultValue, mapping.TypeDesc.UseReflection));
					}
					base.Writer.Write(")");
				}
				else
				{
					WriteCheckDefault(source, defaultValue, isNullable);
				}
				base.Writer.WriteLine(" {");
				base.Writer.Indent++;
			}
			base.Writer.Write(method);
			base.Writer.Write("(");
			WriteQuotedCSharpString(name);
			if (ns != null)
			{
				base.Writer.Write(", ");
				WriteQuotedCSharpString(ns);
			}
			base.Writer.Write(", ");
			if (mapping is EnumMapping)
			{
				WriteEnumValue((EnumMapping)mapping, source);
			}
			else
			{
				WritePrimitiveValue(typeDesc, source, isElement);
			}
			if (writeXsiType)
			{
				base.Writer.Write(", new System.Xml.XmlQualifiedName(");
				WriteQuotedCSharpString(mapping.TypeName);
				base.Writer.Write(", ");
				WriteQuotedCSharpString(mapping.Namespace);
				base.Writer.Write(")");
			}
			base.Writer.WriteLine(");");
			if (flag)
			{
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
		}

		private void WriteTag(string methodName, string name, string ns)
		{
			base.Writer.Write(methodName);
			base.Writer.Write("(");
			WriteQuotedCSharpString(name);
			base.Writer.Write(", ");
			if (ns == null)
			{
				base.Writer.Write("null");
			}
			else
			{
				WriteQuotedCSharpString(ns);
			}
			base.Writer.WriteLine(");");
		}

		private void WriteTag(string methodName, string name, string ns, bool writePrefixed)
		{
			base.Writer.Write(methodName);
			base.Writer.Write("(");
			WriteQuotedCSharpString(name);
			base.Writer.Write(", ");
			if (ns == null)
			{
				base.Writer.Write("null");
			}
			else
			{
				WriteQuotedCSharpString(ns);
			}
			base.Writer.Write(", null, ");
			if (writePrefixed)
			{
				base.Writer.Write("true");
			}
			else
			{
				base.Writer.Write("false");
			}
			base.Writer.WriteLine(");");
		}

		private void WriteStartElement(string name, string ns, bool writePrefixed)
		{
			WriteTag("WriteStartElement", name, ns, writePrefixed);
		}

		private void WriteEndElement()
		{
			base.Writer.WriteLine("WriteEndElement();");
		}

		private void WriteEndElement(string source)
		{
			base.Writer.Write("WriteEndElement(");
			base.Writer.Write(source);
			base.Writer.WriteLine(");");
		}

		private void WriteEncodedNullTag(string name, string ns)
		{
			WriteTag("WriteNullTagEncoded", name, ns);
		}

		private void WriteLiteralNullTag(string name, string ns)
		{
			WriteTag("WriteNullTagLiteral", name, ns);
		}

		private void WriteEmptyTag(string name, string ns)
		{
			WriteTag("WriteEmptyTag", name, ns);
		}

		private string GenerateMembersElement(XmlMembersMapping xmlMembersMapping)
		{
			ElementAccessor accessor = xmlMembersMapping.Accessor;
			MembersMapping membersMapping = (MembersMapping)accessor.Mapping;
			bool hasWrapperElement = membersMapping.HasWrapperElement;
			bool writeAccessors = membersMapping.WriteAccessors;
			bool flag = xmlMembersMapping.IsSoap && writeAccessors;
			string text = NextMethodName(accessor.Name);
			base.Writer.WriteLine();
			base.Writer.Write("public void ");
			base.Writer.Write(text);
			base.Writer.WriteLine("(object[] p) {");
			base.Writer.Indent++;
			base.Writer.WriteLine("WriteStartDocument();");
			if (!membersMapping.IsSoap)
			{
				base.Writer.WriteLine("TopLevelElement();");
			}
			base.Writer.WriteLine("int pLength = p.Length;");
			if (hasWrapperElement)
			{
				WriteStartElement(accessor.Name, (accessor.Form == XmlSchemaForm.Qualified) ? accessor.Namespace : "", membersMapping.IsSoap);
				int num = FindXmlnsIndex(membersMapping.Members);
				if (num >= 0)
				{
					_ = membersMapping.Members[num];
					string source = "((" + typeof(XmlSerializerNamespaces).FullName + ")p[" + num.ToString(CultureInfo.InvariantCulture) + "])";
					base.Writer.Write("if (pLength > ");
					base.Writer.Write(num.ToString(CultureInfo.InvariantCulture));
					base.Writer.WriteLine(") {");
					base.Writer.Indent++;
					WriteNamespaces(source);
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				for (int i = 0; i < membersMapping.Members.Length; i++)
				{
					MemberMapping memberMapping = membersMapping.Members[i];
					if (memberMapping.Attribute == null || memberMapping.Ignore)
					{
						continue;
					}
					string source2 = "p[" + i.ToString(CultureInfo.InvariantCulture) + "]";
					string text2 = null;
					int num2 = 0;
					if (memberMapping.CheckSpecified != 0)
					{
						string text3 = memberMapping.Name + "Specified";
						for (int j = 0; j < membersMapping.Members.Length; j++)
						{
							if (membersMapping.Members[j].Name == text3)
							{
								text2 = "((bool) p[" + j.ToString(CultureInfo.InvariantCulture) + "])";
								num2 = j;
								break;
							}
						}
					}
					base.Writer.Write("if (pLength > ");
					base.Writer.Write(i.ToString(CultureInfo.InvariantCulture));
					base.Writer.WriteLine(") {");
					base.Writer.Indent++;
					if (text2 != null)
					{
						base.Writer.Write("if (pLength <= ");
						base.Writer.Write(num2.ToString(CultureInfo.InvariantCulture));
						base.Writer.Write(" || ");
						base.Writer.Write(text2);
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
					}
					WriteMember(source2, memberMapping.Attribute, memberMapping.TypeDesc, "p");
					if (text2 != null)
					{
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
			}
			for (int k = 0; k < membersMapping.Members.Length; k++)
			{
				MemberMapping memberMapping2 = membersMapping.Members[k];
				if (memberMapping2.Xmlns != null || memberMapping2.Ignore)
				{
					continue;
				}
				string text4 = null;
				int num3 = 0;
				if (memberMapping2.CheckSpecified != 0)
				{
					string text5 = memberMapping2.Name + "Specified";
					for (int l = 0; l < membersMapping.Members.Length; l++)
					{
						if (membersMapping.Members[l].Name == text5)
						{
							text4 = "((bool) p[" + l.ToString(CultureInfo.InvariantCulture) + "])";
							num3 = l;
							break;
						}
					}
				}
				base.Writer.Write("if (pLength > ");
				base.Writer.Write(k.ToString(CultureInfo.InvariantCulture));
				base.Writer.WriteLine(") {");
				base.Writer.Indent++;
				if (text4 != null)
				{
					base.Writer.Write("if (pLength <= ");
					base.Writer.Write(num3.ToString(CultureInfo.InvariantCulture));
					base.Writer.Write(" || ");
					base.Writer.Write(text4);
					base.Writer.WriteLine(") {");
					base.Writer.Indent++;
				}
				string source3 = "p[" + k.ToString(CultureInfo.InvariantCulture) + "]";
				string choiceSource = null;
				if (memberMapping2.ChoiceIdentifier != null)
				{
					for (int m = 0; m < membersMapping.Members.Length; m++)
					{
						if (membersMapping.Members[m].Name == memberMapping2.ChoiceIdentifier.MemberName)
						{
							choiceSource = ((!memberMapping2.ChoiceIdentifier.Mapping.TypeDesc.UseReflection) ? ("((" + membersMapping.Members[m].TypeDesc.CSharpName + ")p[" + m.ToString(CultureInfo.InvariantCulture) + "])") : ("p[" + m.ToString(CultureInfo.InvariantCulture) + "]"));
							break;
						}
					}
				}
				if (flag && memberMapping2.IsReturnValue && memberMapping2.Elements.Length > 0)
				{
					base.Writer.Write("WriteRpcResult(");
					WriteQuotedCSharpString(memberMapping2.Elements[0].Name);
					base.Writer.Write(", ");
					WriteQuotedCSharpString("");
					base.Writer.WriteLine(");");
				}
				WriteMember(source3, choiceSource, memberMapping2.ElementsSortedByDerivation, memberMapping2.Text, memberMapping2.ChoiceIdentifier, memberMapping2.TypeDesc, writeAccessors || hasWrapperElement);
				if (text4 != null)
				{
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			if (hasWrapperElement)
			{
				WriteEndElement();
			}
			if (accessor.IsSoap)
			{
				if (!hasWrapperElement && !writeAccessors)
				{
					base.Writer.Write("if (pLength > ");
					base.Writer.Write(membersMapping.Members.Length.ToString(CultureInfo.InvariantCulture));
					base.Writer.WriteLine(") {");
					base.Writer.Indent++;
					WriteExtraMembers(membersMapping.Members.Length.ToString(CultureInfo.InvariantCulture), "pLength");
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				base.Writer.WriteLine("WriteReferencedElements();");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			return text;
		}

		private string GenerateTypeElement(XmlTypeMapping xmlTypeMapping)
		{
			ElementAccessor accessor = xmlTypeMapping.Accessor;
			TypeMapping mapping = accessor.Mapping;
			string text = NextMethodName(accessor.Name);
			base.Writer.WriteLine();
			base.Writer.Write("public void ");
			base.Writer.Write(text);
			base.Writer.WriteLine("(object o) {");
			base.Writer.Indent++;
			base.Writer.WriteLine("WriteStartDocument();");
			base.Writer.WriteLine("if (o == null) {");
			base.Writer.Indent++;
			if (accessor.IsNullable)
			{
				if (mapping.IsSoap)
				{
					WriteEncodedNullTag(accessor.Name, (accessor.Form == XmlSchemaForm.Qualified) ? accessor.Namespace : "");
				}
				else
				{
					WriteLiteralNullTag(accessor.Name, (accessor.Form == XmlSchemaForm.Qualified) ? accessor.Namespace : "");
				}
			}
			else
			{
				WriteEmptyTag(accessor.Name, (accessor.Form == XmlSchemaForm.Qualified) ? accessor.Namespace : "");
			}
			base.Writer.WriteLine("return;");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			if (!mapping.IsSoap && !mapping.TypeDesc.IsValueType && !mapping.TypeDesc.Type.IsPrimitive)
			{
				base.Writer.WriteLine("TopLevelElement();");
			}
			WriteMember("o", null, new ElementAccessor[1] { accessor }, null, null, mapping.TypeDesc, !accessor.IsSoap);
			if (mapping.IsSoap)
			{
				base.Writer.WriteLine("WriteReferencedElements();");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			return text;
		}

		private string NextMethodName(string name)
		{
			return "Write" + (++base.NextMethodNumber).ToString(null, NumberFormatInfo.InvariantInfo) + "_" + CodeIdentifier.MakeValidInternal(name);
		}

		private void WriteEnumMethod(EnumMapping mapping)
		{
			string s = (string)base.MethodNames[mapping];
			base.Writer.WriteLine();
			string cSharpName = mapping.TypeDesc.CSharpName;
			if (mapping.IsSoap)
			{
				base.Writer.Write("void ");
				base.Writer.Write(s);
				base.Writer.WriteLine("(object e) {");
				WriteLocalDecl(cSharpName, "v", "e", mapping.TypeDesc.UseReflection);
			}
			else
			{
				base.Writer.Write("string ");
				base.Writer.Write(s);
				base.Writer.Write("(");
				base.Writer.Write(mapping.TypeDesc.UseReflection ? "object" : cSharpName);
				base.Writer.WriteLine(" v) {");
			}
			base.Writer.Indent++;
			base.Writer.WriteLine("string s = null;");
			ConstantMapping[] constants = mapping.Constants;
			if (constants.Length > 0)
			{
				Hashtable hashtable = new Hashtable();
				if (mapping.TypeDesc.UseReflection)
				{
					base.Writer.WriteLine("switch (" + base.RaCodeGen.GetStringForEnumLongValue("v", mapping.TypeDesc.UseReflection) + " ){");
				}
				else
				{
					base.Writer.WriteLine("switch (v) {");
				}
				base.Writer.Indent++;
				foreach (ConstantMapping constantMapping in constants)
				{
					if (hashtable[constantMapping.Value] == null)
					{
						WriteEnumCase(cSharpName, constantMapping, mapping.TypeDesc.UseReflection);
						base.Writer.Write("s = ");
						WriteQuotedCSharpString(constantMapping.XmlName);
						base.Writer.WriteLine("; break;");
						hashtable.Add(constantMapping.Value, constantMapping.Value);
					}
				}
				if (mapping.IsFlags)
				{
					base.Writer.Write("default: s = FromEnum(");
					base.Writer.Write(base.RaCodeGen.GetStringForEnumLongValue("v", mapping.TypeDesc.UseReflection));
					base.Writer.Write(", new string[] {");
					base.Writer.Indent++;
					for (int j = 0; j < constants.Length; j++)
					{
						ConstantMapping constantMapping2 = constants[j];
						if (j > 0)
						{
							base.Writer.WriteLine(", ");
						}
						WriteQuotedCSharpString(constantMapping2.XmlName);
					}
					base.Writer.Write("}, new ");
					base.Writer.Write(typeof(long).FullName);
					base.Writer.Write("[] {");
					for (int k = 0; k < constants.Length; k++)
					{
						ConstantMapping constantMapping3 = constants[k];
						if (k > 0)
						{
							base.Writer.WriteLine(", ");
						}
						base.Writer.Write("(long)");
						if (mapping.TypeDesc.UseReflection)
						{
							base.Writer.Write(constantMapping3.Value.ToString(CultureInfo.InvariantCulture));
							continue;
						}
						base.Writer.Write(cSharpName);
						base.Writer.Write(".@");
						CodeIdentifier.CheckValidIdentifier(constantMapping3.Name);
						base.Writer.Write(constantMapping3.Name);
					}
					base.Writer.Indent--;
					base.Writer.Write("}, ");
					WriteQuotedCSharpString(mapping.TypeDesc.FullName);
					base.Writer.WriteLine("); break;");
				}
				else
				{
					base.Writer.Write("default: throw CreateInvalidEnumValueException(");
					base.Writer.Write(base.RaCodeGen.GetStringForEnumLongValue("v", mapping.TypeDesc.UseReflection));
					base.Writer.Write(".ToString(System.Globalization.CultureInfo.InvariantCulture), ");
					WriteQuotedCSharpString(mapping.TypeDesc.FullName);
					base.Writer.WriteLine(");");
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			if (mapping.IsSoap)
			{
				base.Writer.Write("WriteXsiType(");
				WriteQuotedCSharpString(mapping.TypeName);
				base.Writer.Write(", ");
				WriteQuotedCSharpString(mapping.Namespace);
				base.Writer.WriteLine(");");
				base.Writer.WriteLine("Writer.WriteString(s);");
			}
			else
			{
				base.Writer.WriteLine("return s;");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteDerivedTypes(StructMapping mapping)
		{
			for (StructMapping structMapping = mapping.DerivedMappings; structMapping != null; structMapping = structMapping.NextDerivedMapping)
			{
				string cSharpName = structMapping.TypeDesc.CSharpName;
				base.Writer.Write("else if (");
				WriteTypeCompare("t", cSharpName, structMapping.TypeDesc.UseReflection);
				base.Writer.WriteLine(") {");
				base.Writer.Indent++;
				string s = ReferenceMapping(structMapping);
				base.Writer.Write(s);
				base.Writer.Write("(n, ns,");
				if (!structMapping.TypeDesc.UseReflection)
				{
					base.Writer.Write("(" + cSharpName + ")");
				}
				base.Writer.Write("o");
				if (structMapping.TypeDesc.IsNullable)
				{
					base.Writer.Write(", isNullable");
				}
				base.Writer.Write(", true");
				base.Writer.WriteLine(");");
				base.Writer.WriteLine("return;");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
				WriteDerivedTypes(structMapping);
			}
		}

		private void WriteEnumAndArrayTypes()
		{
			TypeScope[] array = base.Scopes;
			foreach (TypeScope typeScope in array)
			{
				foreach (Mapping typeMapping in typeScope.TypeMappings)
				{
					if (typeMapping is EnumMapping && !typeMapping.IsSoap)
					{
						EnumMapping enumMapping = (EnumMapping)typeMapping;
						string cSharpName = enumMapping.TypeDesc.CSharpName;
						base.Writer.Write("else if (");
						WriteTypeCompare("t", cSharpName, enumMapping.TypeDesc.UseReflection);
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
						string s = ReferenceMapping(enumMapping);
						base.Writer.WriteLine("Writer.WriteStartElement(n, ns);");
						base.Writer.Write("WriteXsiType(");
						WriteQuotedCSharpString(enumMapping.TypeName);
						base.Writer.Write(", ");
						WriteQuotedCSharpString(enumMapping.Namespace);
						base.Writer.WriteLine(");");
						base.Writer.Write("Writer.WriteString(");
						base.Writer.Write(s);
						base.Writer.Write("(");
						if (!enumMapping.TypeDesc.UseReflection)
						{
							base.Writer.Write("(" + cSharpName + ")");
						}
						base.Writer.WriteLine("o));");
						base.Writer.WriteLine("Writer.WriteEndElement();");
						base.Writer.WriteLine("return;");
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
					else if (typeMapping is ArrayMapping && !typeMapping.IsSoap && typeMapping is ArrayMapping arrayMapping && !typeMapping.IsSoap)
					{
						string cSharpName2 = arrayMapping.TypeDesc.CSharpName;
						base.Writer.Write("else if (");
						if (arrayMapping.TypeDesc.IsArray)
						{
							WriteArrayTypeCompare("t", cSharpName2, arrayMapping.TypeDesc.ArrayElementTypeDesc.CSharpName, arrayMapping.TypeDesc.UseReflection);
						}
						else
						{
							WriteTypeCompare("t", cSharpName2, arrayMapping.TypeDesc.UseReflection);
						}
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
						base.Writer.WriteLine("Writer.WriteStartElement(n, ns);");
						base.Writer.Write("WriteXsiType(");
						WriteQuotedCSharpString(arrayMapping.TypeName);
						base.Writer.Write(", ");
						WriteQuotedCSharpString(arrayMapping.Namespace);
						base.Writer.WriteLine(");");
						WriteMember("o", null, arrayMapping.ElementsSortedByDerivation, null, null, arrayMapping.TypeDesc, writeAccessors: true);
						base.Writer.WriteLine("Writer.WriteEndElement();");
						base.Writer.WriteLine("return;");
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
				}
			}
		}

		private void WriteStructMethod(StructMapping mapping)
		{
			if (mapping.IsSoap && mapping.TypeDesc.IsRoot)
			{
				return;
			}
			string s = (string)base.MethodNames[mapping];
			base.Writer.WriteLine();
			base.Writer.Write("void ");
			base.Writer.Write(s);
			string cSharpName = mapping.TypeDesc.CSharpName;
			if (mapping.IsSoap)
			{
				base.Writer.WriteLine("(object s) {");
				base.Writer.Indent++;
				WriteLocalDecl(cSharpName, "o", "s", mapping.TypeDesc.UseReflection);
			}
			else
			{
				base.Writer.Write("(string n, string ns, ");
				base.Writer.Write(mapping.TypeDesc.UseReflection ? "object" : cSharpName);
				base.Writer.Write(" o");
				if (mapping.TypeDesc.IsNullable)
				{
					base.Writer.Write(", bool isNullable");
				}
				base.Writer.WriteLine(", bool needType) {");
				base.Writer.Indent++;
				if (mapping.TypeDesc.IsNullable)
				{
					base.Writer.WriteLine("if ((object)o == null) {");
					base.Writer.Indent++;
					base.Writer.WriteLine("if (isNullable) WriteNullTagLiteral(n, ns);");
					base.Writer.WriteLine("return;");
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				base.Writer.WriteLine("if (!needType) {");
				base.Writer.Indent++;
				base.Writer.Write(typeof(Type).FullName);
				base.Writer.WriteLine(" t = o.GetType();");
				base.Writer.Write("if (");
				WriteTypeCompare("t", cSharpName, mapping.TypeDesc.UseReflection);
				base.Writer.WriteLine(") {");
				base.Writer.WriteLine("}");
				WriteDerivedTypes(mapping);
				if (mapping.TypeDesc.IsRoot)
				{
					WriteEnumAndArrayTypes();
				}
				base.Writer.WriteLine("else {");
				base.Writer.Indent++;
				if (mapping.TypeDesc.IsRoot)
				{
					base.Writer.WriteLine("WriteTypedPrimitive(n, ns, o, true);");
					base.Writer.WriteLine("return;");
				}
				else
				{
					base.Writer.WriteLine("throw CreateUnknownTypeException(o);");
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			if (!mapping.TypeDesc.IsAbstract)
			{
				if (mapping.TypeDesc.Type != null && typeof(XmlSchemaObject).IsAssignableFrom(mapping.TypeDesc.Type))
				{
					base.Writer.WriteLine("EscapeName = false;");
				}
				string text = null;
				MemberMapping[] allMembers = TypeScope.GetAllMembers(mapping);
				int num = FindXmlnsIndex(allMembers);
				if (num >= 0)
				{
					MemberMapping memberMapping = allMembers[num];
					CodeIdentifier.CheckValidIdentifier(memberMapping.Name);
					text = base.RaCodeGen.GetStringForMember("o", memberMapping.Name, mapping.TypeDesc);
					if (mapping.TypeDesc.UseReflection)
					{
						text = "((" + memberMapping.TypeDesc.CSharpName + ")" + text + ")";
					}
				}
				if (!mapping.IsSoap)
				{
					base.Writer.Write("WriteStartElement(n, ns, o, false, ");
					if (text == null)
					{
						base.Writer.Write("null");
					}
					else
					{
						base.Writer.Write(text);
					}
					base.Writer.WriteLine(");");
					if (!mapping.TypeDesc.IsRoot)
					{
						base.Writer.Write("if (needType) WriteXsiType(");
						WriteQuotedCSharpString(mapping.TypeName);
						base.Writer.Write(", ");
						WriteQuotedCSharpString(mapping.Namespace);
						base.Writer.WriteLine(");");
					}
				}
				else if (text != null)
				{
					WriteNamespaces(text);
				}
				foreach (MemberMapping memberMapping2 in allMembers)
				{
					if (memberMapping2.Attribute == null)
					{
						continue;
					}
					CodeIdentifier.CheckValidIdentifier(memberMapping2.Name);
					if (memberMapping2.CheckShouldPersist)
					{
						base.Writer.Write("if (");
						string text2 = base.RaCodeGen.GetStringForMethodInvoke("o", cSharpName, "ShouldSerialize" + memberMapping2.Name, mapping.TypeDesc.UseReflection);
						if (mapping.TypeDesc.UseReflection)
						{
							text2 = "((" + typeof(bool).FullName + ")" + text2 + ")";
						}
						base.Writer.Write(text2);
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
					}
					if (memberMapping2.CheckSpecified != 0)
					{
						base.Writer.Write("if (");
						string text3 = base.RaCodeGen.GetStringForMember("o", memberMapping2.Name + "Specified", mapping.TypeDesc);
						if (mapping.TypeDesc.UseReflection)
						{
							text3 = "((" + typeof(bool).FullName + ")" + text3 + ")";
						}
						base.Writer.Write(text3);
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
					}
					WriteMember(base.RaCodeGen.GetStringForMember("o", memberMapping2.Name, mapping.TypeDesc), memberMapping2.Attribute, memberMapping2.TypeDesc, "o");
					if (memberMapping2.CheckSpecified != 0)
					{
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
					if (memberMapping2.CheckShouldPersist)
					{
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
				}
				foreach (MemberMapping memberMapping3 in allMembers)
				{
					if (memberMapping3.Xmlns != null)
					{
						continue;
					}
					CodeIdentifier.CheckValidIdentifier(memberMapping3.Name);
					bool flag = memberMapping3.CheckShouldPersist && (memberMapping3.Elements.Length > 0 || memberMapping3.Text != null);
					if (flag)
					{
						base.Writer.Write("if (");
						string text4 = base.RaCodeGen.GetStringForMethodInvoke("o", cSharpName, "ShouldSerialize" + memberMapping3.Name, mapping.TypeDesc.UseReflection);
						if (mapping.TypeDesc.UseReflection)
						{
							text4 = "((" + typeof(bool).FullName + ")" + text4 + ")";
						}
						base.Writer.Write(text4);
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
					}
					if (memberMapping3.CheckSpecified != 0)
					{
						base.Writer.Write("if (");
						string text5 = base.RaCodeGen.GetStringForMember("o", memberMapping3.Name + "Specified", mapping.TypeDesc);
						if (mapping.TypeDesc.UseReflection)
						{
							text5 = "((" + typeof(bool).FullName + ")" + text5 + ")";
						}
						base.Writer.Write(text5);
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
					}
					string choiceSource = null;
					if (memberMapping3.ChoiceIdentifier != null)
					{
						CodeIdentifier.CheckValidIdentifier(memberMapping3.ChoiceIdentifier.MemberName);
						choiceSource = base.RaCodeGen.GetStringForMember("o", memberMapping3.ChoiceIdentifier.MemberName, mapping.TypeDesc);
					}
					WriteMember(base.RaCodeGen.GetStringForMember("o", memberMapping3.Name, mapping.TypeDesc), choiceSource, memberMapping3.ElementsSortedByDerivation, memberMapping3.Text, memberMapping3.ChoiceIdentifier, memberMapping3.TypeDesc, writeAccessors: true);
					if (memberMapping3.CheckSpecified != 0)
					{
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
					if (flag)
					{
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
				}
				if (!mapping.IsSoap)
				{
					WriteEndElement("o");
				}
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private bool CanOptimizeWriteListSequence(TypeDesc listElementTypeDesc)
		{
			if (listElementTypeDesc != null)
			{
				return listElementTypeDesc != base.QnameTypeDesc;
			}
			return false;
		}

		private void WriteMember(string source, AttributeAccessor attribute, TypeDesc memberTypeDesc, string parent)
		{
			if (memberTypeDesc.IsAbstract)
			{
				return;
			}
			if (memberTypeDesc.IsArrayLike)
			{
				base.Writer.WriteLine("{");
				base.Writer.Indent++;
				string cSharpName = memberTypeDesc.CSharpName;
				WriteArrayLocalDecl(cSharpName, "a", source, memberTypeDesc);
				if (memberTypeDesc.IsNullable)
				{
					base.Writer.WriteLine("if (a != null) {");
					base.Writer.Indent++;
				}
				if (attribute.IsList)
				{
					if (CanOptimizeWriteListSequence(memberTypeDesc.ArrayElementTypeDesc))
					{
						base.Writer.Write("Writer.WriteStartAttribute(null, ");
						WriteQuotedCSharpString(attribute.Name);
						base.Writer.Write(", ");
						string text = ((attribute.Form == XmlSchemaForm.Qualified) ? attribute.Namespace : string.Empty);
						if (text != null)
						{
							WriteQuotedCSharpString(text);
						}
						else
						{
							base.Writer.Write("null");
						}
						base.Writer.WriteLine(");");
					}
					else
					{
						base.Writer.Write(typeof(StringBuilder).FullName);
						base.Writer.Write(" sb = new ");
						base.Writer.Write(typeof(StringBuilder).FullName);
						base.Writer.WriteLine("();");
					}
				}
				TypeDesc arrayElementTypeDesc = memberTypeDesc.ArrayElementTypeDesc;
				if (memberTypeDesc.IsEnumerable)
				{
					base.Writer.Write(" e = ");
					base.Writer.Write(typeof(IEnumerator).FullName);
					if (memberTypeDesc.IsPrivateImplementation)
					{
						base.Writer.Write("((");
						base.Writer.Write(typeof(IEnumerable).FullName);
						base.Writer.WriteLine(").GetEnumerator();");
					}
					else if (memberTypeDesc.IsGenericInterface)
					{
						if (memberTypeDesc.UseReflection)
						{
							base.Writer.Write("(");
							base.Writer.Write(typeof(IEnumerator).FullName);
							base.Writer.Write(")");
							base.Writer.Write(base.RaCodeGen.GetReflectionVariable(memberTypeDesc.CSharpName, "System.Collections.Generic.IEnumerable*"));
							base.Writer.WriteLine(".Invoke(a, new object[0]);");
						}
						else
						{
							base.Writer.Write("((System.Collections.Generic.IEnumerable<");
							base.Writer.Write(arrayElementTypeDesc.CSharpName);
							base.Writer.WriteLine(">)a).GetEnumerator();");
						}
					}
					else
					{
						if (memberTypeDesc.UseReflection)
						{
							base.Writer.Write("(");
							base.Writer.Write(typeof(IEnumerator).FullName);
							base.Writer.Write(")");
						}
						base.Writer.Write(base.RaCodeGen.GetStringForMethodInvoke("a", memberTypeDesc.CSharpName, "GetEnumerator", memberTypeDesc.UseReflection));
						base.Writer.WriteLine(";");
					}
					base.Writer.WriteLine("if (e != null)");
					base.Writer.WriteLine("while (e.MoveNext()) {");
					base.Writer.Indent++;
					string cSharpName2 = arrayElementTypeDesc.CSharpName;
					WriteLocalDecl(cSharpName2, "ai", "e.Current", arrayElementTypeDesc.UseReflection);
				}
				else
				{
					base.Writer.Write("for (int i = 0; i < ");
					if (memberTypeDesc.IsArray)
					{
						base.Writer.WriteLine("a.Length; i++) {");
					}
					else
					{
						base.Writer.Write("((");
						base.Writer.Write(typeof(ICollection).FullName);
						base.Writer.WriteLine(")a).Count; i++) {");
					}
					base.Writer.Indent++;
					string cSharpName3 = arrayElementTypeDesc.CSharpName;
					WriteLocalDecl(cSharpName3, "ai", base.RaCodeGen.GetStringForArrayMember("a", "i", memberTypeDesc), arrayElementTypeDesc.UseReflection);
				}
				if (attribute.IsList)
				{
					if (CanOptimizeWriteListSequence(memberTypeDesc.ArrayElementTypeDesc))
					{
						base.Writer.WriteLine("if (i != 0) Writer.WriteString(\" \");");
						base.Writer.Write("WriteValue(");
					}
					else
					{
						base.Writer.WriteLine("if (i != 0) sb.Append(\" \");");
						base.Writer.Write("sb.Append(");
					}
					if (attribute.Mapping is EnumMapping)
					{
						WriteEnumValue((EnumMapping)attribute.Mapping, "ai");
					}
					else
					{
						WritePrimitiveValue(arrayElementTypeDesc, "ai", isElement: true);
					}
					base.Writer.WriteLine(");");
				}
				else
				{
					WriteAttribute("ai", attribute, parent);
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
				if (attribute.IsList)
				{
					if (CanOptimizeWriteListSequence(memberTypeDesc.ArrayElementTypeDesc))
					{
						base.Writer.WriteLine("Writer.WriteEndAttribute();");
					}
					else
					{
						base.Writer.WriteLine("if (sb.Length != 0) {");
						base.Writer.Indent++;
						base.Writer.Write("WriteAttribute(");
						WriteQuotedCSharpString(attribute.Name);
						base.Writer.Write(", ");
						string text2 = ((attribute.Form == XmlSchemaForm.Qualified) ? attribute.Namespace : string.Empty);
						if (text2 != null)
						{
							WriteQuotedCSharpString(text2);
							base.Writer.Write(", ");
						}
						base.Writer.WriteLine("sb.ToString());");
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
				}
				if (memberTypeDesc.IsNullable)
				{
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			else
			{
				WriteAttribute(source, attribute, parent);
			}
		}

		private void WriteAttribute(string source, AttributeAccessor attribute, string parent)
		{
			if (attribute.Mapping is SpecialMapping)
			{
				SpecialMapping specialMapping = (SpecialMapping)attribute.Mapping;
				if (specialMapping.TypeDesc.Kind == TypeKind.Attribute || specialMapping.TypeDesc.CanBeAttributeValue)
				{
					base.Writer.Write("WriteXmlAttribute(");
					base.Writer.Write(source);
					base.Writer.Write(", ");
					base.Writer.Write(parent);
					base.Writer.WriteLine(");");
					return;
				}
				throw new InvalidOperationException(Res.GetString("XmlInternalError"));
			}
			TypeDesc typeDesc = attribute.Mapping.TypeDesc;
			if (!typeDesc.UseReflection)
			{
				source = "((" + typeDesc.CSharpName + ")" + source + ")";
			}
			WritePrimitive("WriteAttribute", attribute.Name, (attribute.Form == XmlSchemaForm.Qualified) ? attribute.Namespace : "", attribute.Default, source, attribute.Mapping, writeXsiType: false, isElement: false, isNullable: false);
		}

		private void WriteMember(string source, string choiceSource, ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, TypeDesc memberTypeDesc, bool writeAccessors)
		{
			if (memberTypeDesc.IsArrayLike && (elements.Length != 1 || !(elements[0].Mapping is ArrayMapping)))
			{
				WriteArray(source, choiceSource, elements, text, choice, memberTypeDesc);
			}
			else
			{
				WriteElements(source, choiceSource, elements, text, choice, "a", writeAccessors, memberTypeDesc.IsNullable);
			}
		}

		private void WriteArray(string source, string choiceSource, ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, TypeDesc arrayTypeDesc)
		{
			if (elements.Length != 0 || text != null)
			{
				base.Writer.WriteLine("{");
				base.Writer.Indent++;
				string cSharpName = arrayTypeDesc.CSharpName;
				WriteArrayLocalDecl(cSharpName, "a", source, arrayTypeDesc);
				if (arrayTypeDesc.IsNullable)
				{
					base.Writer.WriteLine("if (a != null) {");
					base.Writer.Indent++;
				}
				if (choice != null)
				{
					_ = choice.Mapping.TypeDesc.UseReflection;
					string cSharpName2 = choice.Mapping.TypeDesc.CSharpName;
					WriteArrayLocalDecl(cSharpName2 + "[]", "c", choiceSource, choice.Mapping.TypeDesc);
					base.Writer.WriteLine("if (c == null || c.Length < a.Length) {");
					base.Writer.Indent++;
					base.Writer.Write("throw CreateInvalidChoiceIdentifierValueException(");
					WriteQuotedCSharpString(choice.Mapping.TypeDesc.FullName);
					base.Writer.Write(", ");
					WriteQuotedCSharpString(choice.MemberName);
					base.Writer.Write(");");
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				WriteArrayItems(elements, text, choice, arrayTypeDesc, "a", "c");
				if (arrayTypeDesc.IsNullable)
				{
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
		}

		private void WriteArrayItems(ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, TypeDesc arrayTypeDesc, string arrayName, string choiceName)
		{
			TypeDesc arrayElementTypeDesc = arrayTypeDesc.ArrayElementTypeDesc;
			if (arrayTypeDesc.IsEnumerable)
			{
				base.Writer.Write(typeof(IEnumerator).FullName);
				base.Writer.Write(" e = ");
				if (arrayTypeDesc.IsPrivateImplementation)
				{
					base.Writer.Write("((");
					base.Writer.Write(typeof(IEnumerable).FullName);
					base.Writer.Write(")");
					base.Writer.Write(arrayName);
					base.Writer.WriteLine(").GetEnumerator();");
				}
				else if (arrayTypeDesc.IsGenericInterface)
				{
					if (arrayTypeDesc.UseReflection)
					{
						base.Writer.Write("(");
						base.Writer.Write(typeof(IEnumerator).FullName);
						base.Writer.Write(")");
						base.Writer.Write(base.RaCodeGen.GetReflectionVariable(arrayTypeDesc.CSharpName, "System.Collections.Generic.IEnumerable*"));
						base.Writer.Write(".Invoke(");
						base.Writer.Write(arrayName);
						base.Writer.WriteLine(", new object[0]);");
					}
					else
					{
						base.Writer.Write("((System.Collections.Generic.IEnumerable<");
						base.Writer.Write(arrayElementTypeDesc.CSharpName);
						base.Writer.Write(">)");
						base.Writer.Write(arrayName);
						base.Writer.WriteLine(").GetEnumerator();");
					}
				}
				else
				{
					if (arrayTypeDesc.UseReflection)
					{
						base.Writer.Write("(");
						base.Writer.Write(typeof(IEnumerator).FullName);
						base.Writer.Write(")");
					}
					base.Writer.Write(base.RaCodeGen.GetStringForMethodInvoke(arrayName, arrayTypeDesc.CSharpName, "GetEnumerator", arrayTypeDesc.UseReflection));
					base.Writer.WriteLine(";");
				}
				base.Writer.WriteLine("if (e != null)");
				base.Writer.WriteLine("while (e.MoveNext()) {");
				base.Writer.Indent++;
				string cSharpName = arrayElementTypeDesc.CSharpName;
				WriteLocalDecl(cSharpName, arrayName + "i", "e.Current", arrayElementTypeDesc.UseReflection);
				WriteElements(arrayName + "i", choiceName + "i", elements, text, choice, arrayName + "a", writeAccessors: true, isNullable: true);
			}
			else
			{
				base.Writer.Write("for (int i");
				base.Writer.Write(arrayName);
				base.Writer.Write(" = 0; i");
				base.Writer.Write(arrayName);
				base.Writer.Write(" < ");
				if (arrayTypeDesc.IsArray)
				{
					base.Writer.Write(arrayName);
					base.Writer.Write(".Length");
				}
				else
				{
					base.Writer.Write("((");
					base.Writer.Write(typeof(ICollection).FullName);
					base.Writer.Write(")");
					base.Writer.Write(arrayName);
					base.Writer.Write(").Count");
				}
				base.Writer.Write("; i");
				base.Writer.Write(arrayName);
				base.Writer.WriteLine("++) {");
				base.Writer.Indent++;
				int num = elements.Length + ((text != null) ? 1 : 0);
				if (num > 1)
				{
					string cSharpName2 = arrayElementTypeDesc.CSharpName;
					WriteLocalDecl(cSharpName2, arrayName + "i", base.RaCodeGen.GetStringForArrayMember(arrayName, "i" + arrayName, arrayTypeDesc), arrayElementTypeDesc.UseReflection);
					if (choice != null)
					{
						string cSharpName3 = choice.Mapping.TypeDesc.CSharpName;
						WriteLocalDecl(cSharpName3, choiceName + "i", base.RaCodeGen.GetStringForArrayMember(choiceName, "i" + arrayName, choice.Mapping.TypeDesc), choice.Mapping.TypeDesc.UseReflection);
					}
					WriteElements(arrayName + "i", choiceName + "i", elements, text, choice, arrayName + "a", writeAccessors: true, arrayElementTypeDesc.IsNullable);
				}
				else
				{
					WriteElements(base.RaCodeGen.GetStringForArrayMember(arrayName, "i" + arrayName, arrayTypeDesc), elements, text, choice, arrayName + "a", writeAccessors: true, arrayElementTypeDesc.IsNullable);
				}
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteElements(string source, ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, string arrayName, bool writeAccessors, bool isNullable)
		{
			WriteElements(source, null, elements, text, choice, arrayName, writeAccessors, isNullable);
		}

		private void WriteElements(string source, string enumSource, ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, string arrayName, bool writeAccessors, bool isNullable)
		{
			if (elements.Length == 0 && text == null)
			{
				return;
			}
			if (elements.Length == 1 && text == null)
			{
				TypeDesc typeDesc = (elements[0].IsUnbounded ? elements[0].Mapping.TypeDesc.CreateArrayTypeDesc() : elements[0].Mapping.TypeDesc);
				if (!elements[0].Any && !elements[0].Mapping.TypeDesc.UseReflection && !elements[0].Mapping.TypeDesc.IsOptionalValue)
				{
					source = "((" + typeDesc.CSharpName + ")" + source + ")";
				}
				WriteElement(source, elements[0], arrayName, writeAccessors);
				return;
			}
			if (isNullable && choice == null)
			{
				base.Writer.Write("if ((object)(");
				base.Writer.Write(source);
				base.Writer.Write(") != null)");
			}
			base.Writer.WriteLine("{");
			base.Writer.Indent++;
			int num = 0;
			ArrayList arrayList = new ArrayList();
			ElementAccessor elementAccessor = null;
			bool flag = false;
			string text2 = choice?.Mapping.TypeDesc.FullName;
			foreach (ElementAccessor elementAccessor2 in elements)
			{
				if (elementAccessor2.Any)
				{
					num++;
					if (elementAccessor2.Name != null && elementAccessor2.Name.Length > 0)
					{
						arrayList.Add(elementAccessor2);
					}
					else if (elementAccessor == null)
					{
						elementAccessor = elementAccessor2;
					}
				}
				else if (choice != null)
				{
					bool useReflection = elementAccessor2.Mapping.TypeDesc.UseReflection;
					string cSharpName = elementAccessor2.Mapping.TypeDesc.CSharpName;
					bool useReflection2 = choice.Mapping.TypeDesc.UseReflection;
					string text3 = (useReflection2 ? "" : (text2 + ".@")) + FindChoiceEnumValue(elementAccessor2, (EnumMapping)choice.Mapping, useReflection2);
					if (flag)
					{
						base.Writer.Write("else ");
					}
					else
					{
						flag = true;
					}
					base.Writer.Write("if (");
					base.Writer.Write(useReflection2 ? base.RaCodeGen.GetStringForEnumLongValue(enumSource, useReflection2) : enumSource);
					base.Writer.Write(" == ");
					base.Writer.Write(text3);
					if (isNullable && !elementAccessor2.IsNullable)
					{
						base.Writer.Write(" && ((object)(");
						base.Writer.Write(source);
						base.Writer.Write(") != null)");
					}
					base.Writer.WriteLine(") {");
					base.Writer.Indent++;
					WriteChoiceTypeCheck(source, cSharpName, useReflection, choice, text3, elementAccessor2.Mapping.TypeDesc);
					string text4 = source;
					if (!useReflection)
					{
						text4 = "((" + cSharpName + ")" + source + ")";
					}
					WriteElement(elementAccessor2.Any ? source : text4, elementAccessor2, arrayName, writeAccessors);
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				else
				{
					bool useReflection3 = elementAccessor2.Mapping.TypeDesc.UseReflection;
					TypeDesc typeDesc2 = (elementAccessor2.IsUnbounded ? elementAccessor2.Mapping.TypeDesc.CreateArrayTypeDesc() : elementAccessor2.Mapping.TypeDesc);
					string cSharpName2 = typeDesc2.CSharpName;
					if (flag)
					{
						base.Writer.Write("else ");
					}
					else
					{
						flag = true;
					}
					base.Writer.Write("if (");
					WriteInstanceOf(source, cSharpName2, useReflection3);
					base.Writer.WriteLine(") {");
					base.Writer.Indent++;
					string text5 = source;
					if (!useReflection3)
					{
						text5 = "((" + cSharpName2 + ")" + source + ")";
					}
					WriteElement(elementAccessor2.Any ? source : text5, elementAccessor2, arrayName, writeAccessors);
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
			}
			if (num > 0)
			{
				if (elements.Length - num > 0)
				{
					base.Writer.Write("else ");
				}
				string fullName = typeof(XmlElement).FullName;
				base.Writer.Write("if (");
				base.Writer.Write(source);
				base.Writer.Write(" is ");
				base.Writer.Write(fullName);
				base.Writer.WriteLine(") {");
				base.Writer.Indent++;
				base.Writer.Write(fullName);
				base.Writer.Write(" elem = (");
				base.Writer.Write(fullName);
				base.Writer.Write(")");
				base.Writer.Write(source);
				base.Writer.WriteLine(";");
				int num2 = 0;
				foreach (ElementAccessor item in arrayList)
				{
					if (num2++ > 0)
					{
						base.Writer.Write("else ");
					}
					string text6 = null;
					_ = item.Mapping.TypeDesc.UseReflection;
					if (choice != null)
					{
						bool useReflection4 = choice.Mapping.TypeDesc.UseReflection;
						text6 = (useReflection4 ? "" : (text2 + ".@")) + FindChoiceEnumValue(item, (EnumMapping)choice.Mapping, useReflection4);
						base.Writer.Write("if (");
						base.Writer.Write(useReflection4 ? base.RaCodeGen.GetStringForEnumLongValue(enumSource, useReflection4) : enumSource);
						base.Writer.Write(" == ");
						base.Writer.Write(text6);
						if (isNullable && !item.IsNullable)
						{
							base.Writer.Write(" && ((object)(");
							base.Writer.Write(source);
							base.Writer.Write(") != null)");
						}
						base.Writer.WriteLine(") {");
						base.Writer.Indent++;
					}
					base.Writer.Write("if (elem.Name == ");
					WriteQuotedCSharpString(item.Name);
					base.Writer.Write(" && elem.NamespaceURI == ");
					WriteQuotedCSharpString(item.Namespace);
					base.Writer.WriteLine(") {");
					base.Writer.Indent++;
					WriteElement("elem", item, arrayName, writeAccessors);
					if (choice != null)
					{
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
						base.Writer.WriteLine("else {");
						base.Writer.Indent++;
						base.Writer.WriteLine("// throw Value '{0}' of the choice identifier '{1}' does not match element '{2}' from namespace '{3}'.");
						base.Writer.Write("throw CreateChoiceIdentifierValueException(");
						WriteQuotedCSharpString(text6);
						base.Writer.Write(", ");
						WriteQuotedCSharpString(choice.MemberName);
						base.Writer.WriteLine(", elem.Name, elem.NamespaceURI);");
						base.Writer.Indent--;
						base.Writer.WriteLine("}");
					}
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				if (num2 > 0)
				{
					base.Writer.WriteLine("else {");
					base.Writer.Indent++;
				}
				if (elementAccessor != null)
				{
					WriteElement("elem", elementAccessor, arrayName, writeAccessors);
				}
				else
				{
					base.Writer.WriteLine("throw CreateUnknownAnyElementException(elem.Name, elem.NamespaceURI);");
				}
				if (num2 > 0)
				{
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			if (text != null)
			{
				bool useReflection5 = text.Mapping.TypeDesc.UseReflection;
				string cSharpName3 = text.Mapping.TypeDesc.CSharpName;
				if (elements.Length > 0)
				{
					base.Writer.Write("else ");
					base.Writer.Write("if (");
					WriteInstanceOf(source, cSharpName3, useReflection5);
					base.Writer.WriteLine(") {");
					base.Writer.Indent++;
					string source2 = source;
					if (!useReflection5)
					{
						source2 = "((" + cSharpName3 + ")" + source + ")";
					}
					WriteText(source2, text);
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
				else
				{
					string source3 = source;
					if (!useReflection5)
					{
						source3 = "((" + cSharpName3 + ")" + source + ")";
					}
					WriteText(source3, text);
				}
			}
			if (elements.Length > 0)
			{
				base.Writer.Write("else ");
				if (isNullable)
				{
					base.Writer.Write(" if ((object)(");
					base.Writer.Write(source);
					base.Writer.Write(") != null)");
				}
				base.Writer.WriteLine("{");
				base.Writer.Indent++;
				base.Writer.Write("throw CreateUnknownTypeException(");
				base.Writer.Write(source);
				base.Writer.WriteLine(");");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteText(string source, TextAccessor text)
		{
			if (text.Mapping is PrimitiveMapping)
			{
				PrimitiveMapping primitiveMapping = (PrimitiveMapping)text.Mapping;
				base.Writer.Write("WriteValue(");
				if (text.Mapping is EnumMapping)
				{
					WriteEnumValue((EnumMapping)text.Mapping, source);
				}
				else
				{
					WritePrimitiveValue(primitiveMapping.TypeDesc, source, isElement: false);
				}
				base.Writer.WriteLine(");");
			}
			else if (text.Mapping is SpecialMapping)
			{
				SpecialMapping specialMapping = (SpecialMapping)text.Mapping;
				TypeKind kind = specialMapping.TypeDesc.Kind;
				if (kind != TypeKind.Node)
				{
					throw new InvalidOperationException(Res.GetString("XmlInternalError"));
				}
				base.Writer.Write(source);
				base.Writer.WriteLine(".WriteTo(Writer);");
			}
		}

		private void WriteElement(string source, ElementAccessor element, string arrayName, bool writeAccessor)
		{
			string text = (writeAccessor ? element.Name : element.Mapping.TypeName);
			string text2 = ((element.Any && element.Name.Length == 0) ? null : ((element.Form != XmlSchemaForm.Qualified) ? "" : (writeAccessor ? element.Namespace : element.Mapping.Namespace)));
			if (element.Mapping is NullableMapping)
			{
				base.Writer.Write("if (");
				base.Writer.Write(source);
				base.Writer.WriteLine(" != null) {");
				base.Writer.Indent++;
				string cSharpName = element.Mapping.TypeDesc.BaseTypeDesc.CSharpName;
				string text3 = source;
				if (!element.Mapping.TypeDesc.BaseTypeDesc.UseReflection)
				{
					text3 = "((" + cSharpName + ")" + source + ")";
				}
				ElementAccessor elementAccessor = element.Clone();
				elementAccessor.Mapping = ((NullableMapping)element.Mapping).BaseMapping;
				WriteElement(elementAccessor.Any ? source : text3, elementAccessor, arrayName, writeAccessor);
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
				if (element.IsNullable)
				{
					base.Writer.WriteLine("else {");
					base.Writer.Indent++;
					WriteLiteralNullTag(element.Name, (element.Form == XmlSchemaForm.Qualified) ? element.Namespace : "");
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
				}
			}
			else if (element.Mapping is ArrayMapping)
			{
				ArrayMapping arrayMapping = (ArrayMapping)element.Mapping;
				if (arrayMapping.IsSoap)
				{
					base.Writer.Write("WritePotentiallyReferencingElement(");
					WriteQuotedCSharpString(text);
					base.Writer.Write(", ");
					WriteQuotedCSharpString(text2);
					base.Writer.Write(", ");
					base.Writer.Write(source);
					if (!writeAccessor)
					{
						base.Writer.Write(", ");
						base.Writer.Write(base.RaCodeGen.GetStringForTypeof(arrayMapping.TypeDesc.CSharpName, arrayMapping.TypeDesc.UseReflection));
						base.Writer.Write(", true, ");
					}
					else
					{
						base.Writer.Write(", null, false, ");
					}
					WriteValue(element.IsNullable);
					base.Writer.WriteLine(");");
					return;
				}
				if (element.IsUnbounded)
				{
					TypeDesc typeDesc = arrayMapping.TypeDesc.CreateArrayTypeDesc();
					string cSharpName2 = typeDesc.CSharpName;
					string text4 = "el" + arrayName;
					string text5 = "c" + text4;
					base.Writer.WriteLine("{");
					base.Writer.Indent++;
					WriteArrayLocalDecl(cSharpName2, text4, source, arrayMapping.TypeDesc);
					if (element.IsNullable)
					{
						WriteNullCheckBegin(text4, element);
					}
					else
					{
						if (arrayMapping.TypeDesc.IsNullable)
						{
							base.Writer.Write("if (");
							base.Writer.Write(text4);
							base.Writer.Write(" != null)");
						}
						base.Writer.WriteLine("{");
						base.Writer.Indent++;
					}
					base.Writer.Write("for (int ");
					base.Writer.Write(text5);
					base.Writer.Write(" = 0; ");
					base.Writer.Write(text5);
					base.Writer.Write(" < ");
					if (typeDesc.IsArray)
					{
						base.Writer.Write(text4);
						base.Writer.Write(".Length");
					}
					else
					{
						base.Writer.Write("((");
						base.Writer.Write(typeof(ICollection).FullName);
						base.Writer.Write(")");
						base.Writer.Write(text4);
						base.Writer.Write(").Count");
					}
					base.Writer.Write("; ");
					base.Writer.Write(text5);
					base.Writer.WriteLine("++) {");
					base.Writer.Indent++;
					element.IsUnbounded = false;
					WriteElement(text4 + "[" + text5 + "]", element, arrayName, writeAccessor);
					element.IsUnbounded = true;
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
					base.Writer.Indent--;
					base.Writer.WriteLine("}");
					return;
				}
				string cSharpName3 = arrayMapping.TypeDesc.CSharpName;
				base.Writer.WriteLine("{");
				base.Writer.Indent++;
				WriteArrayLocalDecl(cSharpName3, arrayName, source, arrayMapping.TypeDesc);
				if (element.IsNullable)
				{
					WriteNullCheckBegin(arrayName, element);
				}
				else
				{
					if (arrayMapping.TypeDesc.IsNullable)
					{
						base.Writer.Write("if (");
						base.Writer.Write(arrayName);
						base.Writer.Write(" != null)");
					}
					base.Writer.WriteLine("{");
					base.Writer.Indent++;
				}
				WriteStartElement(text, text2, writePrefixed: false);
				WriteArrayItems(arrayMapping.ElementsSortedByDerivation, null, null, arrayMapping.TypeDesc, arrayName, null);
				WriteEndElement();
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
			else if (element.Mapping is EnumMapping)
			{
				if (element.Mapping.IsSoap)
				{
					string s = (string)base.MethodNames[element.Mapping];
					base.Writer.Write("Writer.WriteStartElement(");
					WriteQuotedCSharpString(text);
					base.Writer.Write(", ");
					WriteQuotedCSharpString(text2);
					base.Writer.WriteLine(");");
					base.Writer.Write(s);
					base.Writer.Write("(");
					base.Writer.Write(source);
					base.Writer.WriteLine(");");
					WriteEndElement();
				}
				else
				{
					WritePrimitive("WriteElementString", text, text2, element.Default, source, element.Mapping, writeXsiType: false, isElement: true, element.IsNullable);
				}
			}
			else if (element.Mapping is PrimitiveMapping)
			{
				PrimitiveMapping primitiveMapping = (PrimitiveMapping)element.Mapping;
				if (primitiveMapping.TypeDesc == base.QnameTypeDesc)
				{
					WriteQualifiedNameElement(text, text2, element.Default, source, element.IsNullable, primitiveMapping.IsSoap, primitiveMapping);
					return;
				}
				string text6 = (primitiveMapping.IsSoap ? "Encoded" : "Literal");
				string text7 = (primitiveMapping.TypeDesc.XmlEncodingNotRequired ? "Raw" : "");
				WritePrimitive(element.IsNullable ? ("WriteNullableString" + text6 + text7) : ("WriteElementString" + text7), text, text2, element.Default, source, primitiveMapping, primitiveMapping.IsSoap, isElement: true, element.IsNullable);
			}
			else if (element.Mapping is StructMapping)
			{
				StructMapping structMapping = (StructMapping)element.Mapping;
				if (structMapping.IsSoap)
				{
					base.Writer.Write("WritePotentiallyReferencingElement(");
					WriteQuotedCSharpString(text);
					base.Writer.Write(", ");
					WriteQuotedCSharpString(text2);
					base.Writer.Write(", ");
					base.Writer.Write(source);
					if (!writeAccessor)
					{
						base.Writer.Write(", ");
						base.Writer.Write(base.RaCodeGen.GetStringForTypeof(structMapping.TypeDesc.CSharpName, structMapping.TypeDesc.UseReflection));
						base.Writer.Write(", true, ");
					}
					else
					{
						base.Writer.Write(", null, false, ");
					}
					WriteValue(element.IsNullable);
				}
				else
				{
					string s2 = ReferenceMapping(structMapping);
					base.Writer.Write(s2);
					base.Writer.Write("(");
					WriteQuotedCSharpString(text);
					base.Writer.Write(", ");
					if (text2 == null)
					{
						base.Writer.Write("null");
					}
					else
					{
						WriteQuotedCSharpString(text2);
					}
					base.Writer.Write(", ");
					base.Writer.Write(source);
					if (structMapping.TypeDesc.IsNullable)
					{
						base.Writer.Write(", ");
						WriteValue(element.IsNullable);
					}
					base.Writer.Write(", false");
				}
				base.Writer.WriteLine(");");
			}
			else
			{
				if (!(element.Mapping is SpecialMapping))
				{
					throw new InvalidOperationException(Res.GetString("XmlInternalError"));
				}
				SpecialMapping specialMapping = (SpecialMapping)element.Mapping;
				_ = specialMapping.TypeDesc.UseReflection;
				TypeDesc typeDesc2 = specialMapping.TypeDesc;
				_ = typeDesc2.CSharpName;
				if (element.Mapping is SerializableMapping)
				{
					WriteElementCall("WriteSerializable", typeof(IXmlSerializable), source, text, text2, element.IsNullable, !element.Any);
					return;
				}
				base.Writer.Write("if ((");
				base.Writer.Write(source);
				base.Writer.Write(") is ");
				base.Writer.Write(typeof(XmlNode).FullName);
				base.Writer.Write(" || ");
				base.Writer.Write(source);
				base.Writer.Write(" == null");
				base.Writer.WriteLine(") {");
				base.Writer.Indent++;
				WriteElementCall("WriteElementLiteral", typeof(XmlNode), source, text, text2, element.IsNullable, element.Any);
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
				base.Writer.WriteLine("else {");
				base.Writer.Indent++;
				base.Writer.Write("throw CreateInvalidAnyTypeException(");
				base.Writer.Write(source);
				base.Writer.WriteLine(");");
				base.Writer.Indent--;
				base.Writer.WriteLine("}");
			}
		}

		private void WriteElementCall(string func, Type cast, string source, string name, string ns, bool isNullable, bool isAny)
		{
			base.Writer.Write(func);
			base.Writer.Write("((");
			base.Writer.Write(cast.FullName);
			base.Writer.Write(")");
			base.Writer.Write(source);
			base.Writer.Write(", ");
			WriteQuotedCSharpString(name);
			base.Writer.Write(", ");
			WriteQuotedCSharpString(ns);
			base.Writer.Write(", ");
			WriteValue(isNullable);
			base.Writer.Write(", ");
			WriteValue(isAny);
			base.Writer.WriteLine(");");
		}

		private void WriteCheckDefault(string source, object value, bool isNullable)
		{
			base.Writer.Write("if (");
			if (value is string && ((string)value).Length == 0)
			{
				base.Writer.Write("(");
				base.Writer.Write(source);
				if (isNullable)
				{
					base.Writer.Write(" == null) || (");
				}
				else
				{
					base.Writer.Write(" != null) && (");
				}
				base.Writer.Write(source);
				base.Writer.Write(".Length != 0)");
			}
			else
			{
				base.Writer.Write(source);
				base.Writer.Write(" != ");
				WriteValue(value);
			}
			base.Writer.Write(")");
		}

		private void WriteChoiceTypeCheck(string source, string fullTypeName, bool useReflection, ChoiceIdentifierAccessor choice, string enumName, TypeDesc typeDesc)
		{
			base.Writer.Write("if (((object)");
			base.Writer.Write(source);
			base.Writer.Write(") != null && !(");
			WriteInstanceOf(source, fullTypeName, useReflection);
			base.Writer.Write(")) throw CreateMismatchChoiceException(");
			WriteQuotedCSharpString(typeDesc.FullName);
			base.Writer.Write(", ");
			WriteQuotedCSharpString(choice.MemberName);
			base.Writer.Write(", ");
			WriteQuotedCSharpString(enumName);
			base.Writer.WriteLine(");");
		}

		private void WriteNullCheckBegin(string source, ElementAccessor element)
		{
			base.Writer.Write("if ((object)(");
			base.Writer.Write(source);
			base.Writer.WriteLine(") == null) {");
			base.Writer.Indent++;
			WriteLiteralNullTag(element.Name, (element.Form == XmlSchemaForm.Qualified) ? element.Namespace : "");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			base.Writer.WriteLine("else {");
			base.Writer.Indent++;
		}

		private void WriteValue(object value)
		{
			if (value == null)
			{
				base.Writer.Write("null");
				return;
			}
			Type type = value.GetType();
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.String:
			{
				string value2 = (string)value;
				WriteQuotedCSharpString(value2);
				break;
			}
			case TypeCode.Char:
			{
				base.Writer.Write('\'');
				char c = (char)value;
				if (c == '\'')
				{
					base.Writer.Write("'");
				}
				else
				{
					base.Writer.Write(c);
				}
				base.Writer.Write('\'');
				break;
			}
			case TypeCode.Int32:
				base.Writer.Write(((int)value).ToString(null, NumberFormatInfo.InvariantInfo));
				break;
			case TypeCode.Double:
				base.Writer.Write(((double)value).ToString("R", NumberFormatInfo.InvariantInfo));
				break;
			case TypeCode.Boolean:
				base.Writer.Write(((bool)value) ? "true" : "false");
				break;
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
				base.Writer.Write("(");
				base.Writer.Write(type.FullName);
				base.Writer.Write(")");
				base.Writer.Write("(");
				base.Writer.Write(Convert.ToString(value, NumberFormatInfo.InvariantInfo));
				base.Writer.Write(")");
				break;
			case TypeCode.Single:
				base.Writer.Write(((float)value).ToString("R", NumberFormatInfo.InvariantInfo));
				base.Writer.Write("f");
				break;
			case TypeCode.Decimal:
				base.Writer.Write(((decimal)value).ToString(null, NumberFormatInfo.InvariantInfo));
				base.Writer.Write("m");
				break;
			case TypeCode.DateTime:
				base.Writer.Write(" new ");
				base.Writer.Write(type.FullName);
				base.Writer.Write("(");
				base.Writer.Write(((DateTime)value).Ticks.ToString(CultureInfo.InvariantCulture));
				base.Writer.Write(")");
				break;
			default:
				if (type.IsEnum)
				{
					base.Writer.Write(((int)value).ToString(null, NumberFormatInfo.InvariantInfo));
					break;
				}
				throw new InvalidOperationException(Res.GetString("XmlUnsupportedDefaultType", type.FullName));
			}
		}

		private void WriteNamespaces(string source)
		{
			base.Writer.Write("WriteNamespaceDeclarations(");
			base.Writer.Write(source);
			base.Writer.WriteLine(");");
		}

		private int FindXmlnsIndex(MemberMapping[] members)
		{
			for (int i = 0; i < members.Length; i++)
			{
				if (members[i].Xmlns != null)
				{
					return i;
				}
			}
			return -1;
		}

		private void WriteExtraMembers(string loopStartSource, string loopEndSource)
		{
			base.Writer.Write("for (int i = ");
			base.Writer.Write(loopStartSource);
			base.Writer.Write("; i < ");
			base.Writer.Write(loopEndSource);
			base.Writer.WriteLine("; i++) {");
			base.Writer.Indent++;
			base.Writer.WriteLine("if (p[i] != null) {");
			base.Writer.Indent++;
			base.Writer.WriteLine("WritePotentiallyReferencingElement(null, null, p[i], p[i].GetType(), true, false);");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
			base.Writer.Indent--;
			base.Writer.WriteLine("}");
		}

		private void WriteLocalDecl(string typeName, string variableName, string initValue, bool useReflection)
		{
			base.RaCodeGen.WriteLocalDecl(typeName, variableName, initValue, useReflection);
		}

		private void WriteArrayLocalDecl(string typeName, string variableName, string initValue, TypeDesc arrayTypeDesc)
		{
			base.RaCodeGen.WriteArrayLocalDecl(typeName, variableName, initValue, arrayTypeDesc);
		}

		private void WriteTypeCompare(string variable, string escapedTypeName, bool useReflection)
		{
			base.RaCodeGen.WriteTypeCompare(variable, escapedTypeName, useReflection);
		}

		private void WriteInstanceOf(string source, string escapedTypeName, bool useReflection)
		{
			base.RaCodeGen.WriteInstanceOf(source, escapedTypeName, useReflection);
		}

		private void WriteArrayTypeCompare(string variable, string escapedTypeName, string elementTypeName, bool useReflection)
		{
			base.RaCodeGen.WriteArrayTypeCompare(variable, escapedTypeName, elementTypeName, useReflection);
		}

		private void WriteEnumCase(string fullTypeName, ConstantMapping c, bool useReflection)
		{
			base.RaCodeGen.WriteEnumCase(fullTypeName, c, useReflection);
		}

		private string FindChoiceEnumValue(ElementAccessor element, EnumMapping choiceMapping, bool useReflection)
		{
			string text = null;
			for (int i = 0; i < choiceMapping.Constants.Length; i++)
			{
				string xmlName = choiceMapping.Constants[i].XmlName;
				if (element.Any && element.Name.Length == 0)
				{
					if (xmlName == "##any:")
					{
						text = ((!useReflection) ? choiceMapping.Constants[i].Name : choiceMapping.Constants[i].Value.ToString(CultureInfo.InvariantCulture));
						break;
					}
					continue;
				}
				int num = xmlName.LastIndexOf(':');
				string text2 = ((num < 0) ? choiceMapping.Namespace : xmlName.Substring(0, num));
				string text3 = ((num < 0) ? xmlName : xmlName.Substring(num + 1));
				if (element.Name == text3 && ((element.Form == XmlSchemaForm.Unqualified && string.IsNullOrEmpty(text2)) || element.Namespace == text2))
				{
					text = ((!useReflection) ? choiceMapping.Constants[i].Name : choiceMapping.Constants[i].Value.ToString(CultureInfo.InvariantCulture));
					break;
				}
			}
			if (text == null || text.Length == 0)
			{
				if (element.Any && element.Name.Length == 0)
				{
					throw new InvalidOperationException(Res.GetString("XmlChoiceMissingAnyValue", choiceMapping.TypeDesc.FullName));
				}
				throw new InvalidOperationException(Res.GetString("XmlChoiceMissingValue", choiceMapping.TypeDesc.FullName, element.Namespace + ":" + element.Name, element.Name, element.Namespace));
			}
			if (!useReflection)
			{
				CodeIdentifier.CheckValidIdentifier(text);
			}
			return text;
		}
	}
	internal static class DynamicAssemblies
	{
		private static ArrayList assembliesInConfig = new ArrayList();

		private static Hashtable nameToAssemblyMap = new Hashtable();

		private static Hashtable assemblyToNameMap = new Hashtable();

		private static Hashtable tableIsTypeDynamic = Hashtable.Synchronized(new Hashtable());

		private static FileIOPermission fileIOPermission;

		private static FileIOPermission UnrestrictedFileIOPermission
		{
			get
			{
				if (fileIOPermission == null)
				{
					fileIOPermission = new FileIOPermission(PermissionState.Unrestricted);
				}
				return fileIOPermission;
			}
		}

		internal static bool IsTypeDynamic(Type type)
		{
			object obj = tableIsTypeDynamic[type];
			if (obj == null)
			{
				UnrestrictedFileIOPermission.Assert();
				Module module = type.Module;
				Assembly assembly = module.Assembly;
				bool flag = module is ModuleBuilder || assembly.Location == null || assembly.Location.Length == 0;
				if (!flag)
				{
					if (type.IsArray)
					{
						flag = IsTypeDynamic(type.GetElementType());
					}
					else if (type.IsGenericType)
					{
						Type[] genericArguments = type.GetGenericArguments();
						if (genericArguments != null)
						{
							foreach (Type type2 in genericArguments)
							{
								if (type2 != null && !type2.IsGenericParameter)
								{
									flag = IsTypeDynamic(type2);
									if (flag)
									{
										break;
									}
								}
							}
						}
					}
				}
				obj = (tableIsTypeDynamic[type] = flag);
			}
			return (bool)obj;
		}

		internal static bool IsTypeDynamic(Type[] arguments)
		{
			foreach (Type type in arguments)
			{
				if (IsTypeDynamic(type))
				{
					return true;
				}
			}
			return false;
		}

		internal static void Add(Assembly a)
		{
			lock (nameToAssemblyMap)
			{
				if (assemblyToNameMap[a] == null)
				{
					Assembly assembly = nameToAssemblyMap[a.FullName] as Assembly;
					string text = null;
					if (assembly == null)
					{
						text = a.FullName;
					}
					else if (assembly != a)
					{
						text = a.FullName + ", " + nameToAssemblyMap.Count;
					}
					if (text != null)
					{
						nameToAssemblyMap.Add(text, a);
						assemblyToNameMap.Add(a, text);
					}
				}
			}
		}

		internal static Assembly Get(string fullName)
		{
			if (nameToAssemblyMap == null)
			{
				return null;
			}
			return (Assembly)nameToAssemblyMap[fullName];
		}

		internal static string GetName(Assembly a)
		{
			if (assemblyToNameMap == null)
			{
				return null;
			}
			return (string)assemblyToNameMap[a];
		}
	}
	internal class ReflectionAwareCodeGen
	{
		private const string hexDigits = "0123456789ABCDEF";

		private const string arrayMemberKey = "0";

		private Hashtable reflectionVariables;

		private int nextReflectionVariableNumber;

		private IndentedWriter writer;

		private static string helperClassesForUseReflection = "\r\n    sealed class XSFieldInfo {{\r\n       {3} fieldInfo;\r\n        public XSFieldInfo({2} t, {1} memberName){{\r\n            fieldInfo = t.GetField(memberName);\r\n        }}\r\n        public {0} this[{0} o] {{\r\n            get {{\r\n                return fieldInfo.GetValue(o);\r\n            }}\r\n            set {{\r\n                fieldInfo.SetValue(o, value);\r\n            }}\r\n        }}\r\n\r\n    }}\r\n    sealed class XSPropInfo {{\r\n        {4} propInfo;\r\n        public XSPropInfo({2} t, {1} memberName){{\r\n            propInfo = t.GetProperty(memberName);\r\n        }}\r\n        public {0} this[{0} o] {{\r\n            get {{\r\n                return propInfo.GetValue(o, null);\r\n            }}\r\n            set {{\r\n                propInfo.SetValue(o, value, null);\r\n            }}\r\n        }}\r\n    }}\r\n    sealed class XSArrayInfo {{\r\n        {4} propInfo;\r\n        public XSArrayInfo({4} propInfo){{\r\n            this.propInfo = propInfo;\r\n        }}\r\n        public {0} this[{0} a, int i] {{\r\n            get {{\r\n                return propInfo.GetValue(a, new {0}[]{{i}});\r\n            }}\r\n            set {{\r\n                propInfo.SetValue(a, value, new {0}[]{{i}});\r\n            }}\r\n        }}\r\n    }}\r\n";

		internal ReflectionAwareCodeGen(IndentedWriter writer)
		{
			this.writer = writer;
		}

		internal void WriteReflectionInit(TypeScope scope)
		{
			foreach (Type type in scope.Types)
			{
				TypeDesc typeDesc = scope.GetTypeDesc(type);
				if (typeDesc.UseReflection)
				{
					WriteTypeInfo(scope, typeDesc, type);
				}
			}
		}

		private string WriteTypeInfo(TypeScope scope, TypeDesc typeDesc, Type type)
		{
			InitTheFirstTime();
			string cSharpName = typeDesc.CSharpName;
			string text = (string)reflectionVariables[cSharpName];
			if (text != null)
			{
				return text;
			}
			if (type.IsArray)
			{
				text = GenerateVariableName("array", typeDesc.CSharpName);
				TypeDesc arrayElementTypeDesc = typeDesc.ArrayElementTypeDesc;
				if (arrayElementTypeDesc.UseReflection)
				{
					string text2 = WriteTypeInfo(scope, arrayElementTypeDesc, scope.GetTypeFromTypeDesc(arrayElementTypeDesc));
					writer.WriteLine("static " + typeof(Type).FullName + " " + text + " = " + text2 + ".MakeArrayType();");
				}
				else
				{
					string text3 = WriteAssemblyInfo(type);
					writer.Write("static " + typeof(Type).FullName + " " + text + " = " + text3 + ".GetType(");
					WriteQuotedCSharpString(type.FullName);
					writer.WriteLine(");");
				}
			}
			else
			{
				text = GenerateVariableName("type", typeDesc.CSharpName);
				Type underlyingType = Nullable.GetUnderlyingType(type);
				if (underlyingType != null)
				{
					string text4 = WriteTypeInfo(scope, scope.GetTypeDesc(underlyingType), underlyingType);
					writer.WriteLine("static " + typeof(Type).FullName + " " + text + " = typeof(System.Nullable<>).MakeGenericType(new " + typeof(Type).FullName + "[] {" + text4 + "});");
				}
				else
				{
					string text5 = WriteAssemblyInfo(type);
					writer.Write("static " + typeof(Type).FullName + " " + text + " = " + text5 + ".GetType(");
					WriteQuotedCSharpString(type.FullName);
					writer.WriteLine(");");
				}
			}
			reflectionVariables.Add(cSharpName, text);
			TypeMapping typeMappingFromTypeDesc = scope.GetTypeMappingFromTypeDesc(typeDesc);
			if (typeMappingFromTypeDesc != null)
			{
				WriteMappingInfo(typeMappingFromTypeDesc, text, type);
			}
			if (typeDesc.IsCollection || typeDesc.IsEnumerable)
			{
				TypeDesc arrayElementTypeDesc2 = typeDesc.ArrayElementTypeDesc;
				if (arrayElementTypeDesc2.UseReflection)
				{
					WriteTypeInfo(scope, arrayElementTypeDesc2, scope.GetTypeFromTypeDesc(arrayElementTypeDesc2));
				}
				WriteCollectionInfo(text, typeDesc, type);
			}
			return text;
		}

		private void InitTheFirstTime()
		{
			if (reflectionVariables == null)
			{
				reflectionVariables = new Hashtable();
				writer.Write(string.Format(CultureInfo.InvariantCulture, helperClassesForUseReflection, "object", "string", typeof(Type).FullName, typeof(FieldInfo).FullName, typeof(PropertyInfo).FullName, typeof(MemberInfo).FullName, typeof(MemberTypes).FullName));
				WriteDefaultIndexerInit(typeof(IList), typeof(Array).FullName, collectionUseReflection: false, elementUseReflection: false);
			}
		}

		private void WriteMappingInfo(TypeMapping mapping, string typeVariable, Type type)
		{
			string cSharpName = mapping.TypeDesc.CSharpName;
			if (mapping is StructMapping)
			{
				StructMapping structMapping = mapping as StructMapping;
				for (int i = 0; i < structMapping.Members.Length; i++)
				{
					MemberMapping memberMapping = structMapping.Members[i];
					WriteMemberInfo(type, cSharpName, typeVariable, memberMapping.Name);
					if (memberMapping.CheckShouldPersist)
					{
						string memberName = "ShouldSerialize" + memberMapping.Name;
						WriteMethodInfo(cSharpName, typeVariable, memberName, false);
					}
					if (memberMapping.CheckSpecified != 0)
					{
						string memberName2 = memberMapping.Name + "Specified";
						WriteMemberInfo(type, cSharpName, typeVariable, memberName2);
					}
					if (memberMapping.ChoiceIdentifier != null)
					{
						string memberName3 = memberMapping.ChoiceIdentifier.MemberName;
						WriteMemberInfo(type, cSharpName, typeVariable, memberName3);
					}
				}
			}
			else if (mapping is EnumMapping)
			{
				FieldInfo[] fields = type.GetFields();
				for (int j = 0; j < fields.Length; j++)
				{
					WriteMemberInfo(type, cSharpName, typeVariable, fields[j].Name);
				}
			}
		}

		private void WriteCollectionInfo(string typeVariable, TypeDesc typeDesc, Type type)
		{
			string cSharpName = CodeIdentifier.GetCSharpName(type);
			string cSharpName2 = typeDesc.ArrayElementTypeDesc.CSharpName;
			bool useReflection = typeDesc.ArrayElementTypeDesc.UseReflection;
			if (typeDesc.IsCollection)
			{
				WriteDefaultIndexerInit(type, cSharpName, typeDesc.UseReflection, useReflection);
			}
			else if (typeDesc.IsEnumerable)
			{
				if (typeDesc.IsGenericInterface)
				{
					WriteMethodInfo(cSharpName, typeVariable, "System.Collections.Generic.IEnumerable*", true);
				}
				else if (!typeDesc.IsPrivateImplementation)
				{
					WriteMethodInfo(cSharpName, typeVariable, "GetEnumerator", true);
				}
			}
			WriteMethodInfo(cSharpName, typeVariable, "Add", false, GetStringForTypeof(cSharpName2, useReflection));
		}

		private string WriteAssemblyInfo(Type type)
		{
			string fullName = type.Assembly.FullName;
			string text = (string)reflectionVariables[fullName];
			if (text == null)
			{
				int num = fullName.IndexOf(',');
				string fullName2 = ((num > -1) ? fullName.Substring(0, num) : fullName);
				text = GenerateVariableName("assembly", fullName2);
				writer.Write("static " + typeof(Assembly).FullName + " " + text + " = ResolveDynamicAssembly(");
				WriteQuotedCSharpString(DynamicAssemblies.GetName(type.Assembly));
				writer.WriteLine(");");
				reflectionVariables.Add(fullName, text);
			}
			return text;
		}

		private string WriteMemberInfo(Type type, string escapedName, string typeVariable, string memberName)
		{
			MemberInfo[] member = type.GetMember(memberName);
			for (int i = 0; i < member.Length; i++)
			{
				switch (member[i].MemberType)
				{
				case MemberTypes.Property:
				{
					string text2 = GenerateVariableName("prop", memberName);
					writer.Write("static XSPropInfo " + text2 + " = new XSPropInfo(" + typeVariable + ", ");
					WriteQuotedCSharpString(memberName);
					writer.WriteLine(");");
					reflectionVariables.Add(memberName + ":" + escapedName, text2);
					return text2;
				}
				case MemberTypes.Field:
				{
					string text = GenerateVariableName("field", memberName);
					writer.Write("static XSFieldInfo " + text + " = new XSFieldInfo(" + typeVariable + ", ");
					WriteQuotedCSharpString(memberName);
					writer.WriteLine(");");
					reflectionVariables.Add(memberName + ":" + escapedName, text);
					return text;
				}
				}
			}
			throw new InvalidOperationException(Res.GetString("XmlSerializerUnsupportedType", member[0].ToString()));
		}

		private string WriteMethodInfo(string escapedName, string typeVariable, string memberName, bool isNonPublic, params string[] paramTypes)
		{
			string text = GenerateVariableName("method", memberName);
			writer.Write("static " + typeof(MethodInfo).FullName + " " + text + " = " + typeVariable + ".GetMethod(");
			WriteQuotedCSharpString(memberName);
			writer.Write(", ");
			string fullName = typeof(BindingFlags).FullName;
			writer.Write(fullName);
			writer.Write(".Public | ");
			writer.Write(fullName);
			writer.Write(".Instance | ");
			writer.Write(fullName);
			writer.Write(".Static");
			if (isNonPublic)
			{
				writer.Write(" | ");
				writer.Write(fullName);
				writer.Write(".NonPublic");
			}
			writer.Write(", null, ");
			writer.Write("new " + typeof(Type).FullName + "[] { ");
			for (int i = 0; i < paramTypes.Length; i++)
			{
				writer.Write(paramTypes[i]);
				if (i < paramTypes.Length - 1)
				{
					writer.Write(", ");
				}
			}
			writer.WriteLine("}, null);");
			reflectionVariables.Add(memberName + ":" + escapedName, text);
			return text;
		}

		private string WriteDefaultIndexerInit(Type type, string escapedName, bool collectionUseReflection, bool elementUseReflection)
		{
			string text = GenerateVariableName("item", escapedName);
			PropertyInfo defaultIndexer = TypeScope.GetDefaultIndexer(type, null);
			writer.Write("static XSArrayInfo ");
			writer.Write(text);
			writer.Write("= new XSArrayInfo(");
			writer.Write(GetStringForTypeof(CodeIdentifier.GetCSharpName(type), collectionUseReflection));
			writer.Write(".GetProperty(");
			WriteQuotedCSharpString(defaultIndexer.Name);
			writer.Write(",");
			writer.Write(GetStringForTypeof(CodeIdentifier.GetCSharpName(defaultIndexer.PropertyType), elementUseReflection));
			writer.Write(",new ");
			writer.Write(typeof(Type[]).FullName);
			writer.WriteLine("{typeof(int)}));");
			reflectionVariables.Add("0:" + escapedName, text);
			return text;
		}

		private string GenerateVariableName(string prefix, string fullName)
		{
			nextReflectionVariableNumber++;
			return prefix + nextReflectionVariableNumber + "_" + CodeIdentifier.MakeValidInternal(fullName.Replace('.', '_'));
		}

		internal string GetReflectionVariable(string typeFullName, string memberName)
		{
			string key = ((memberName != null) ? (memberName + ":" + typeFullName) : typeFullName);
			return (string)reflectionVariables[key];
		}

		internal string GetStringForMethodInvoke(string obj, string escapedTypeName, string methodName, bool useReflection, params string[] args)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (useReflection)
			{
				stringBuilder.Append(GetReflectionVariable(escapedTypeName, methodName));
				stringBuilder.Append(".Invoke(");
				stringBuilder.Append(obj);
				stringBuilder.Append(", new object[] {");
			}
			else
			{
				stringBuilder.Append(obj);
				stringBuilder.Append(".@");
				stringBuilder.Append(methodName);
				stringBuilder.Append("(");
			}
			for (int i = 0; i < args.Length; i++)
			{
				if (i != 0)
				{
					stringBuilder.Append(", ");
				}
				stringBuilder.Append(args[i]);
			}
			if (useReflection)
			{
				stringBuilder.Append("})");
			}
			else
			{
				stringBuilder.Append(")");
			}
			return stringBuilder.ToString();
		}

		internal string GetStringForEnumCompare(EnumMapping mapping, string memberName, bool useReflection)
		{
			if (!useReflection)
			{
				CodeIdentifier.CheckValidIdentifier(memberName);
				return mapping.TypeDesc.CSharpName + ".@" + memberName;
			}
			string stringForEnumMember = GetStringForEnumMember(mapping.TypeDesc.CSharpName, memberName, useReflection);
			return GetStringForEnumLongValue(stringForEnumMember, useReflection);
		}

		internal string GetStringForEnumLongValue(string variable, bool useReflection)
		{
			if (useReflection)
			{
				return typeof(Convert).FullName + ".ToInt64(" + variable + ")";
			}
			return "((" + typeof(long).FullName + ")" + variable + ")";
		}

		internal string GetStringForTypeof(string typeFullName, bool useReflection)
		{
			if (useReflection)
			{
				return GetReflectionVariable(typeFullName, null);
			}
			return "typeof(" + typeFullName + ")";
		}

		internal string GetStringForMember(string obj, string memberName, TypeDesc typeDesc)
		{
			if (!typeDesc.UseReflection)
			{
				return obj + ".@" + memberName;
			}
			while (typeDesc != null)
			{
				string cSharpName = typeDesc.CSharpName;
				string reflectionVariable = GetReflectionVariable(cSharpName, memberName);
				if (reflectionVariable != null)
				{
					return reflectionVariable + "[" + obj + "]";
				}
				typeDesc = typeDesc.BaseTypeDesc;
				if (typeDesc != null && !typeDesc.UseReflection)
				{
					return "((" + typeDesc.CSharpName + ")" + obj + ").@" + memberName;
				}
			}
			return "[" + obj + "]";
		}

		internal string GetStringForEnumMember(string typeFullName, string memberName, bool useReflection)
		{
			if (!useReflection)
			{
				return typeFullName + ".@" + memberName;
			}
			string reflectionVariable = GetReflectionVariable(typeFullName, memberName);
			return reflectionVariable + "[null]";
		}

		internal string GetStringForArrayMember(string arrayName, string subscript, TypeDesc arrayTypeDesc)
		{
			if (!arrayTypeDesc.UseReflection)
			{
				return arrayName + "[" + subscript + "]";
			}
			string typeFullName = (arrayTypeDesc.IsCollection ? arrayTypeDesc.CSharpName : typeof(Array).FullName);
			string reflectionVariable = GetReflectionVariable(typeFullName, "0");
			return reflectionVariable + "[" + arrayName + ", " + subscript + "]";
		}

		internal string GetStringForMethod(string obj, string typeFullName, string memberName, bool useReflection)
		{
			if (!useReflection)
			{
				return obj + "." + memberName + "(";
			}
			string reflectionVariable = GetReflectionVariable(typeFullName, memberName);
			return reflectionVariable + ".Invoke(" + obj + ", new object[]{";
		}

		internal string GetStringForCreateInstance(string escapedTypeName, bool useReflection, bool ctorInaccessible, bool cast)
		{
			return GetStringForCreateInstance(escapedTypeName, useReflection, ctorInaccessible, cast, string.Empty);
		}

		internal string GetStringForCreateInstance(string escapedTypeName, bool useReflection, bool ctorInaccessible, bool cast, string arg)
		{
			if (!useReflection && !ctorInaccessible)
			{
				return "new " + escapedTypeName + "(" + arg + ")";
			}
			return GetStringForCreateInstance(GetStringForTypeof(escapedTypeName, useReflection), (cast && !useReflection) ? escapedTypeName : null, ctorInaccessible, arg);
		}

		internal string GetStringForCreateInstance(string type, string cast, bool nonPublic, string arg)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (cast != null && cast.Length > 0)
			{
				stringBuilder.Append("(");
				stringBuilder.Append(cast);
				stringBuilder.Append(")");
			}
			stringBuilder.Append(typeof(Activator).FullName);
			stringBuilder.Append(".CreateInstance(");
			stringBuilder.Append(type);
			stringBuilder.Append(", ");
			string fullName = typeof(BindingFlags).FullName;
			stringBuilder.Append(fullName);
			stringBuilder.Append(".Instance | ");
			stringBuilder.Append(fullName);
			stringBuilder.Append(".Public | ");
			stringBuilder.Append(fullName);
			stringBuilder.Append(".CreateInstance");
			if (nonPublic)
			{
				stringBuilder.Append(" | ");
				stringBuilder.Append(fullName);
				stringBuilder.Append(".NonPublic");
			}
			if (arg == null || arg.Length == 0)
			{
				stringBuilder.Append(", null, new object[0], null)");
			}
			else
			{
				stringBuilder.Append(", null, new object[] { ");
				stringBuilder.Append(arg);
				stringBuilder.Append(" }, null)");
			}
			return stringBuilder.ToString();
		}

		internal void WriteLocalDecl(string typeFullName, string variableName, string initValue, bool useReflection)
		{
			if (useReflection)
			{
				typeFullName = "object";
			}
			writer.Write(typeFullName);
			writer.Write(" ");
			writer.Write(variableName);
			if (initValue != null)
			{
				writer.Write(" = ");
				if (!useReflection && initValue != "null")
				{
					writer.Write("(" + typeFullName + ")");
				}
				writer.Write(initValue);
			}
			writer.WriteLine(";");
		}

		internal void WriteCreateInstance(string escapedName, string source, bool useReflection, bool ctorInaccessible)
		{
			writer.Write(useReflection ? "object" : escapedName);
			writer.Write(" ");
			writer.Write(source);
			writer.Write(" = ");
			writer.Write(GetStringForCreateInstance(escapedName, useReflection, ctorInaccessible, !useReflection && ctorInaccessible));
			writer.WriteLine(";");
		}

		internal void WriteInstanceOf(string source, string escapedTypeName, bool useReflection)
		{
			if (!useReflection)
			{
				writer.Write(source);
				writer.Write(" is ");
				writer.Write(escapedTypeName);
			}
			else
			{
				writer.Write(GetReflectionVariable(escapedTypeName, null));
				writer.Write(".IsAssignableFrom(");
				writer.Write(source);
				writer.Write(".GetType())");
			}
		}

		internal void WriteArrayLocalDecl(string typeName, string variableName, string initValue, TypeDesc arrayTypeDesc)
		{
			if (arrayTypeDesc.UseReflection)
			{
				typeName = (arrayTypeDesc.IsEnumerable ? typeof(IEnumerable).FullName : ((!arrayTypeDesc.IsCollection) ? typeof(Array).FullName : typeof(ICollection).FullName));
			}
			writer.Write(typeName);
			writer.Write(" ");
			writer.Write(variableName);
			if (initValue != null)
			{
				writer.Write(" = ");
				if (initValue != "null")
				{
					writer.Write("(" + typeName + ")");
				}
				writer.Write(initValue);
			}
			writer.WriteLine(";");
		}

		internal void WriteEnumCase(string fullTypeName, ConstantMapping c, bool useReflection)
		{
			writer.Write("case ");
			if (useReflection)
			{
				writer.Write(c.Value.ToString(CultureInfo.InvariantCulture));
			}
			else
			{
				writer.Write(fullTypeName);
				writer.Write(".@");
				CodeIdentifier.CheckValidIdentifier(c.Name);
				writer.Write(c.Name);
			}
			writer.Write(": ");
		}

		internal void WriteTypeCompare(string variable, string escapedTypeName, bool useReflection)
		{
			writer.Write(variable);
			writer.Write(" == ");
			writer.Write(GetStringForTypeof(escapedTypeName, useReflection));
		}

		internal void WriteArrayTypeCompare(string variable, string escapedTypeName, string elementTypeName, bool useReflection)
		{
			if (!useReflection)
			{
				writer.Write(variable);
				writer.Write(" == typeof(");
				writer.Write(escapedTypeName);
				writer.Write(")");
			}
			else
			{
				writer.Write(variable);
				writer.Write(".IsArray ");
				writer.Write(" && ");
				WriteTypeCompare(variable + ".GetElementType()", elementTypeName, useReflection);
			}
		}

		internal static void WriteQuotedCSharpString(IndentedWriter writer, string value)
		{
			if (value == null)
			{
				writer.Write("null");
				return;
			}
			writer.Write("@\"");
			foreach (char c in value)
			{
				if (c < ' ')
				{
					switch (c)
					{
					case '\r':
						writer.Write("\\r");
						continue;
					case '\n':
						writer.Write("\\n");
						continue;
					case '\t':
						writer.Write("\\t");
						continue;
					}
					byte b = (byte)c;
					writer.Write("\\x");
					writer.Write("0123456789ABCDEF"[b >> 4]);
					writer.Write("0123456789ABCDEF"[b & 0xF]);
				}
				else if (c == '"')
				{
					writer.Write("\"\"");
				}
				else
				{
					writer.Write(c);
				}
			}
			writer.Write("\"");
		}

		internal void WriteQuotedCSharpString(string value)
		{
			WriteQuotedCSharpString(writer, value);
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Interface, AllowMultiple = false)]
	public sealed class XmlSerializerAssemblyAttribute : Attribute
	{
		private string assemblyName;

		private string codeBase;

		public string CodeBase
		{
			get
			{
				return codeBase;
			}
			set
			{
				codeBase = value;
			}
		}

		public string AssemblyName
		{
			get
			{
				return assemblyName;
			}
			set
			{
				assemblyName = value;
			}
		}

		public XmlSerializerAssemblyAttribute()
			: this(null, null)
		{
		}

		public XmlSerializerAssemblyAttribute(string assemblyName)
			: this(assemblyName, null)
		{
		}

		public XmlSerializerAssemblyAttribute(string assemblyName, string codeBase)
		{
			this.assemblyName = assemblyName;
			this.codeBase = codeBase;
		}
	}
	public struct XmlDeserializationEvents
	{
		private XmlNodeEventHandler onUnknownNode;

		private XmlAttributeEventHandler onUnknownAttribute;

		private XmlElementEventHandler onUnknownElement;

		private UnreferencedObjectEventHandler onUnreferencedObject;

		internal object sender;

		public XmlNodeEventHandler OnUnknownNode
		{
			get
			{
				return onUnknownNode;
			}
			set
			{
				onUnknownNode = value;
			}
		}

		public XmlAttributeEventHandler OnUnknownAttribute
		{
			get
			{
				return onUnknownAttribute;
			}
			set
			{
				onUnknownAttribute = value;
			}
		}

		public XmlElementEventHandler OnUnknownElement
		{
			get
			{
				return onUnknownElement;
			}
			set
			{
				onUnknownElement = value;
			}
		}

		public UnreferencedObjectEventHandler OnUnreferencedObject
		{
			get
			{
				return onUnreferencedObject;
			}
			set
			{
				onUnreferencedObject = value;
			}
		}
	}
	public abstract class XmlSerializerImplementation
	{
		public virtual XmlSerializationReader Reader
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public virtual XmlSerializationWriter Writer
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public virtual Hashtable ReadMethods
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public virtual Hashtable WriteMethods
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public virtual Hashtable TypedSerializers
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public virtual bool CanSerialize(Type type)
		{
			throw new NotSupportedException();
		}

		public virtual XmlSerializer GetSerializer(Type type)
		{
			throw new NotSupportedException();
		}
	}
	public class XmlSerializer
	{
		private class XmlSerializerMappingKey
		{
			public XmlMapping Mapping;

			public XmlSerializerMappingKey(XmlMapping mapping)
			{
				Mapping = mapping;
			}

			public override bool Equals(object obj)
			{
				if (!(obj is XmlSerializerMappingKey xmlSerializerMappingKey))
				{
					return false;
				}
				if (Mapping.Key != xmlSerializerMappingKey.Mapping.Key)
				{
					return false;
				}
				if (Mapping.ElementName != xmlSerializerMappingKey.Mapping.ElementName)
				{
					return false;
				}
				if (Mapping.Namespace != xmlSerializerMappingKey.Mapping.Namespace)
				{
					return false;
				}
				if (Mapping.IsSoap != xmlSerializerMappingKey.Mapping.IsSoap)
				{
					return false;
				}
				return true;
			}

			public override int GetHashCode()
			{
				int num = ((!Mapping.IsSoap) ? 1 : 0);
				if (Mapping.Key != null)
				{
					num ^= Mapping.Key.GetHashCode();
				}
				if (Mapping.ElementName != null)
				{
					num ^= Mapping.ElementName.GetHashCode();
				}
				if (Mapping.Namespace != null)
				{
					num ^= Mapping.Namespace.GetHashCode();
				}
				return num;
			}
		}

		private TempAssembly tempAssembly;

		private bool typedSerializer;

		private Type primitiveType;

		private XmlMapping mapping;

		private XmlDeserializationEvents events = default(XmlDeserializationEvents);

		private static TempAssemblyCache cache = new TempAssemblyCache();

		private static XmlSerializerNamespaces defaultNamespaces;

		private static Hashtable xmlSerializerTable = new Hashtable();

		private static XmlSerializerNamespaces DefaultNamespaces
		{
			get
			{
				if (defaultNamespaces == null)
				{
					XmlSerializerNamespaces xmlSerializerNamespaces = new XmlSerializerNamespaces();
					xmlSerializerNamespaces.AddInternal("xsi", "http://www.w3.org/2001/XMLSchema-instance");
					xmlSerializerNamespaces.AddInternal("xsd", "http://www.w3.org/2001/XMLSchema");
					if (defaultNamespaces == null)
					{
						defaultNamespaces = xmlSerializerNamespaces;
					}
				}
				return defaultNamespaces;
			}
		}

		public event XmlNodeEventHandler UnknownNode
		{
			add
			{
				ref XmlDeserializationEvents reference = ref events;
				reference.OnUnknownNode = (XmlNodeEventHandler)Delegate.Combine(reference.OnUnknownNode, value);
			}
			remove
			{
				ref XmlDeserializationEvents reference = ref events;
				reference.OnUnknownNode = (XmlNodeEventHandler)Delegate.Remove(reference.OnUnknownNode, value);
			}
		}

		public event XmlAttributeEventHandler UnknownAttribute
		{
			add
			{
				ref XmlDeserializationEvents reference = ref events;
				reference.OnUnknownAttribute = (XmlAttributeEventHandler)Delegate.Combine(reference.OnUnknownAttribute, value);
			}
			remove
			{
				ref XmlDeserializationEvents reference = ref events;
				reference.OnUnknownAttribute = (XmlAttributeEventHandler)Delegate.Remove(reference.OnUnknownAttribute, value);
			}
		}

		public event XmlElementEventHandler UnknownElement
		{
			add
			{
				ref XmlDeserializationEvents reference = ref events;
				reference.OnUnknownElement = (XmlElementEventHandler)Delegate.Combine(reference.OnUnknownElement, value);
			}
			remove
			{
				ref XmlDeserializationEvents reference = ref events;
				reference.OnUnknownElement = (XmlElementEventHandler)Delegate.Remove(reference.OnUnknownElement, value);
			}
		}

		public event UnreferencedObjectEventHandler UnreferencedObject
		{
			add
			{
				ref XmlDeserializationEvents reference = ref events;
				reference.OnUnreferencedObject = (UnreferencedObjectEventHandler)Delegate.Combine(reference.OnUnreferencedObject, value);
			}
			remove
			{
				ref XmlDeserializationEvents reference = ref events;
				reference.OnUnreferencedObject = (UnreferencedObjectEventHandler)Delegate.Remove(reference.OnUnreferencedObject, value);
			}
		}

		protected XmlSerializer()
		{
		}

		public XmlSerializer(Type type, XmlAttributeOverrides overrides, Type[] extraTypes, XmlRootAttribute root, string defaultNamespace)
			: this(type, overrides, extraTypes, root, defaultNamespace, null, null)
		{
		}

		public XmlSerializer(Type type, XmlRootAttribute root)
			: this(type, null, new Type[0], root, null, null, null)
		{
		}

		public XmlSerializer(Type type, Type[] extraTypes)
			: this(type, null, extraTypes, null, null, null, null)
		{
		}

		public XmlSerializer(Type type, XmlAttributeOverrides overrides)
			: this(type, overrides, new Type[0], null, null, null, null)
		{
		}

		public XmlSerializer(XmlTypeMapping xmlTypeMapping)
		{
			tempAssembly = GenerateTempAssembly(xmlTypeMapping);
			mapping = xmlTypeMapping;
		}

		public XmlSerializer(Type type)
			: this(type, (string)null)
		{
		}

		public XmlSerializer(Type type, string defaultNamespace)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			mapping = GetKnownMapping(type, defaultNamespace);
			if (mapping != null)
			{
				primitiveType = type;
				return;
			}
			tempAssembly = cache[defaultNamespace, type];
			if (tempAssembly == null)
			{
				lock (cache)
				{
					tempAssembly = cache[defaultNamespace, type];
					if (tempAssembly == null)
					{
						XmlSerializerImplementation contract;
						Assembly assembly = TempAssembly.LoadGeneratedAssembly(type, defaultNamespace, out contract);
						if (assembly == null)
						{
							XmlReflectionImporter xmlReflectionImporter = new XmlReflectionImporter(defaultNamespace);
							mapping = xmlReflectionImporter.ImportTypeMapping(type, null, defaultNamespace);
							tempAssembly = GenerateTempAssembly(mapping, type, defaultNamespace);
						}
						else
						{
							mapping = XmlReflectionImporter.GetTopLevelMapping(type, defaultNamespace);
							tempAssembly = new TempAssembly(new XmlMapping[1] { mapping }, assembly, contract);
						}
					}
					cache.Add(defaultNamespace, type, tempAssembly);
				}
			}
			if (mapping == null)
			{
				mapping = XmlReflectionImporter.GetTopLevelMapping(type, defaultNamespace);
			}
		}

		public XmlSerializer(Type type, XmlAttributeOverrides overrides, Type[] extraTypes, XmlRootAttribute root, string defaultNamespace, string location, Evidence evidence)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			XmlReflectionImporter xmlReflectionImporter = new XmlReflectionImporter(overrides, defaultNamespace);
			for (int i = 0; i < extraTypes.Length; i++)
			{
				xmlReflectionImporter.IncludeType(extraTypes[i]);
			}
			mapping = xmlReflectionImporter.ImportTypeMapping(type, root, defaultNamespace);
			if (location != null)
			{
				DemandForUserLocation();
			}
			tempAssembly = GenerateTempAssembly(mapping, type, defaultNamespace, location, evidence);
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		private void DemandForUserLocation()
		{
		}

		internal static TempAssembly GenerateTempAssembly(XmlMapping xmlMapping)
		{
			return GenerateTempAssembly(xmlMapping, null, null);
		}

		internal static TempAssembly GenerateTempAssembly(XmlMapping xmlMapping, Type type, string defaultNamespace)
		{
			if (xmlMapping == null)
			{
				throw new ArgumentNullException("xmlMapping");
			}
			return new TempAssembly(new XmlMapping[1] { xmlMapping }, new Type[1] { type }, defaultNamespace, null, null);
		}

		internal static TempAssembly GenerateTempAssembly(XmlMapping xmlMapping, Type type, string defaultNamespace, string location, Evidence evidence)
		{
			return new TempAssembly(new XmlMapping[1] { xmlMapping }, new Type[1] { type }, defaultNamespace, location, evidence);
		}

		public void Serialize(TextWriter textWriter, object o)
		{
			Serialize(textWriter, o, null);
		}

		public void Serialize(TextWriter textWriter, object o, XmlSerializerNamespaces namespaces)
		{
			XmlTextWriter xmlTextWriter = new XmlTextWriter(textWriter);
			xmlTextWriter.Formatting = Formatting.Indented;
			xmlTextWriter.Indentation = 2;
			Serialize(xmlTextWriter, o, namespaces);
		}

		public void Serialize(Stream stream, object o)
		{
			Serialize(stream, o, null);
		}

		public void Serialize(Stream stream, object o, XmlSerializerNamespaces namespaces)
		{
			XmlTextWriter xmlTextWriter = new XmlTextWriter(stream, null);
			xmlTextWriter.Formatting = Formatting.Indented;
			xmlTextWriter.Indentation = 2;
			Serialize(xmlTextWriter, o, namespaces);
		}

		public void Serialize(XmlWriter xmlWriter, object o)
		{
			Serialize(xmlWriter, o, null);
		}

		public void Serialize(XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces)
		{
			Serialize(xmlWriter, o, namespaces, null);
		}

		public void Serialize(XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces, string encodingStyle)
		{
			Serialize(xmlWriter, o, namespaces, encodingStyle, null);
		}

		public void Serialize(XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces, string encodingStyle, string id)
		{
			try
			{
				if (primitiveType != null)
				{
					if (encodingStyle != null && encodingStyle.Length > 0)
					{
						throw new InvalidOperationException(Res.GetString("XmlInvalidEncodingNotEncoded1", encodingStyle));
					}
					SerializePrimitive(xmlWriter, o, namespaces);
				}
				else if (tempAssembly == null || typedSerializer)
				{
					XmlSerializationWriter xmlSerializationWriter = CreateWriter();
					xmlSerializationWriter.Init(xmlWriter, (namespaces == null || namespaces.Count == 0) ? DefaultNamespaces : namespaces, encodingStyle, id, tempAssembly);
					try
					{
						Serialize(o, xmlSerializationWriter);
					}
					finally
					{
						xmlSerializationWriter.Dispose();
					}
				}
				else
				{
					tempAssembly.InvokeWriter(mapping, xmlWriter, o, (namespaces == null || namespaces.Count == 0) ? DefaultNamespaces : namespaces, encodingStyle, id);
				}
			}
			catch (Exception innerException)
			{
				if (innerException is ThreadAbortException || innerException is StackOverflowException || innerException is OutOfMemoryException)
				{
					throw;
				}
				if (innerException is TargetInvocationException)
				{
					innerException = innerException.InnerException;
				}
				throw new InvalidOperationException(Res.GetString("XmlGenError"), innerException);
			}
			catch
			{
				throw new InvalidOperationException(Res.GetString("XmlGenError"), null);
			}
			xmlWriter.Flush();
		}

		public object Deserialize(Stream stream)
		{
			XmlTextReader xmlTextReader = new XmlTextReader(stream);
			xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
			xmlTextReader.Normalization = true;
			xmlTextReader.XmlResolver = null;
			return Deserialize(xmlTextReader, null);
		}

		public object Deserialize(TextReader textReader)
		{
			XmlTextReader xmlTextReader = new XmlTextReader(textReader);
			xmlTextReader.WhitespaceHandling = WhitespaceHandling.Significant;
			xmlTextReader.Normalization = true;
			xmlTextReader.XmlResolver = null;
			return Deserialize(xmlTextReader, null);
		}

		public object Deserialize(XmlReader xmlReader)
		{
			return Deserialize(xmlReader, null);
		}

		public object Deserialize(XmlReader xmlReader, XmlDeserializationEvents events)
		{
			return Deserialize(xmlReader, null, events);
		}

		public object Deserialize(XmlReader xmlReader, string encodingStyle)
		{
			return Deserialize(xmlReader, encodingStyle, events);
		}

		public object Deserialize(XmlReader xmlReader, string encodingStyle, XmlDeserializationEvents events)
		{
			events.sender = this;
			try
			{
				if (primitiveType != null)
				{
					if (encodingStyle != null && encodingStyle.Length > 0)
					{
						throw new InvalidOperationException(Res.GetString("XmlInvalidEncodingNotEncoded1", encodingStyle));
					}
					return DeserializePrimitive(xmlReader, events);
				}
				if (tempAssembly == null || typedSerializer)
				{
					XmlSerializationReader xmlSerializationReader = CreateReader();
					xmlSerializationReader.Init(xmlReader, events, encodingStyle, tempAssembly);
					try
					{
						return Deserialize(xmlSerializationReader);
					}
					finally
					{
						xmlSerializationReader.Dispose();
					}
				}
				return tempAssembly.InvokeReader(mapping, xmlReader, events, encodingStyle);
			}
			catch (Exception innerException)
			{
				if (innerException is ThreadAbortException || innerException is StackOverflowException || innerException is OutOfMemoryException)
				{
					throw;
				}
				if (innerException is TargetInvocationException)
				{
					innerException = innerException.InnerException;
				}
				if (xmlReader is IXmlLineInfo)
				{
					IXmlLineInfo xmlLineInfo = (IXmlLineInfo)xmlReader;
					throw new InvalidOperationException(Res.GetString("XmlSerializeErrorDetails", xmlLineInfo.LineNumber.ToString(CultureInfo.InvariantCulture), xmlLineInfo.LinePosition.ToString(CultureInfo.InvariantCulture)), innerException);
				}
				throw new InvalidOperationException(Res.GetString("XmlSerializeError"), innerException);
			}
			catch
			{
				if (xmlReader is IXmlLineInfo)
				{
					IXmlLineInfo xmlLineInfo2 = (IXmlLineInfo)xmlReader;
					throw new InvalidOperationException(Res.GetString("XmlSerializeErrorDetails", xmlLineInfo2.LineNumber.ToString(CultureInfo.InvariantCulture), xmlLineInfo2.LinePosition.ToString(CultureInfo.InvariantCulture)), null);
				}
				throw new InvalidOperationException(Res.GetString("XmlSerializeError"), null);
			}
		}

		public virtual bool CanDeserialize(XmlReader xmlReader)
		{
			if (primitiveType != null)
			{
				TypeDesc typeDesc = (TypeDesc)TypeScope.PrimtiveTypes[primitiveType];
				return xmlReader.IsStartElement(typeDesc.DataType.Name, string.Empty);
			}
			if (tempAssembly != null)
			{
				return tempAssembly.CanRead(mapping, xmlReader);
			}
			return false;
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public static XmlSerializer[] FromMappings(XmlMapping[] mappings)
		{
			return FromMappings(mappings, (Type)null);
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public static XmlSerializer[] FromMappings(XmlMapping[] mappings, Type type)
		{
			if (mappings == null || mappings.Length == 0)
			{
				return new XmlSerializer[0];
			}
			XmlSerializerImplementation contract = null;
			Assembly assembly = ((type == null) ? null : TempAssembly.LoadGeneratedAssembly(type, null, out contract));
			TempAssembly tempAssembly = null;
			if (assembly == null)
			{
				if (XmlMapping.IsShallow(mappings))
				{
					return new XmlSerializer[0];
				}
				if (type == null)
				{
					tempAssembly = new TempAssembly(mappings, new Type[1] { type }, null, null, null);
					XmlSerializer[] array = new XmlSerializer[mappings.Length];
					contract = tempAssembly.Contract;
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = (XmlSerializer)contract.TypedSerializers[mappings[i].Key];
						array[i].SetTempAssembly(tempAssembly, mappings[i]);
					}
					return array;
				}
				return GetSerializersFromCache(mappings, type);
			}
			XmlSerializer[] array2 = new XmlSerializer[mappings.Length];
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j] = (XmlSerializer)contract.TypedSerializers[mappings[j].Key];
			}
			return array2;
		}

		private static XmlSerializer[] GetSerializersFromCache(XmlMapping[] mappings, Type type)
		{
			XmlSerializer[] array = new XmlSerializer[mappings.Length];
			Hashtable hashtable = null;
			lock (xmlSerializerTable)
			{
				hashtable = xmlSerializerTable[type] as Hashtable;
				if (hashtable == null)
				{
					hashtable = new Hashtable();
					xmlSerializerTable[type] = hashtable;
				}
			}
			lock (hashtable)
			{
				Hashtable hashtable2 = new Hashtable();
				for (int i = 0; i < mappings.Length; i++)
				{
					XmlSerializerMappingKey key = new XmlSerializerMappingKey(mappings[i]);
					array[i] = hashtable[key] as XmlSerializer;
					if (array[i] == null)
					{
						hashtable2.Add(key, i);
					}
				}
				if (hashtable2.Count > 0)
				{
					XmlMapping[] array2 = new XmlMapping[hashtable2.Count];
					int num = 0;
					foreach (XmlSerializerMappingKey key2 in hashtable2.Keys)
					{
						array2[num++] = key2.Mapping;
					}
					TempAssembly tempAssembly = new TempAssembly(array2, new Type[1] { type }, null, null, null);
					XmlSerializerImplementation contract = tempAssembly.Contract;
					{
						foreach (XmlSerializerMappingKey key3 in hashtable2.Keys)
						{
							num = (int)hashtable2[key3];
							array[num] = (XmlSerializer)contract.TypedSerializers[key3.Mapping.Key];
							array[num].SetTempAssembly(tempAssembly, key3.Mapping);
							hashtable[key3] = array[num];
						}
						return array;
					}
				}
				return array;
			}
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public static XmlSerializer[] FromMappings(XmlMapping[] mappings, Evidence evidence)
		{
			if (mappings == null || mappings.Length == 0)
			{
				return new XmlSerializer[0];
			}
			if (XmlMapping.IsShallow(mappings))
			{
				return new XmlSerializer[0];
			}
			TempAssembly tempAssembly = new TempAssembly(mappings, new Type[0], null, null, evidence);
			XmlSerializerImplementation contract = tempAssembly.Contract;
			XmlSerializer[] array = new XmlSerializer[mappings.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = (XmlSerializer)contract.TypedSerializers[mappings[i].Key];
			}
			return array;
		}

		[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
		public static Assembly GenerateSerializer(Type[] types, XmlMapping[] mappings)
		{
			CompilerParameters compilerParameters = new CompilerParameters();
			compilerParameters.TempFiles = new TempFileCollection();
			compilerParameters.GenerateInMemory = false;
			compilerParameters.IncludeDebugInformation = false;
			return GenerateSerializer(types, mappings, compilerParameters);
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public static Assembly GenerateSerializer(Type[] types, XmlMapping[] mappings, CompilerParameters parameters)
		{
			if (types == null || types.Length == 0)
			{
				return null;
			}
			if (mappings == null)
			{
				throw new ArgumentNullException("mappings");
			}
			if (XmlMapping.IsShallow(mappings))
			{
				throw new InvalidOperationException(Res.GetString("XmlMelformMapping"));
			}
			Assembly assembly = null;
			foreach (Type type in types)
			{
				if (DynamicAssemblies.IsTypeDynamic(type))
				{
					throw new InvalidOperationException(Res.GetString("XmlPregenTypeDynamic", type.FullName));
				}
				if (assembly == null)
				{
					assembly = type.Assembly;
				}
				else if (type.Assembly != assembly)
				{
					throw new ArgumentException(Res.GetString("XmlPregenOrphanType", type.FullName, assembly.Location), "types");
				}
			}
			return TempAssembly.GenerateAssembly(mappings, types, null, null, XmlSerializerCompilerParameters.Create(parameters, needTempDirAccess: true), assembly, new Hashtable());
		}

		public static XmlSerializer[] FromTypes(Type[] types)
		{
			if (types == null)
			{
				return new XmlSerializer[0];
			}
			XmlReflectionImporter xmlReflectionImporter = new XmlReflectionImporter();
			XmlTypeMapping[] array = new XmlTypeMapping[types.Length];
			for (int i = 0; i < types.Length; i++)
			{
				array[i] = xmlReflectionImporter.ImportTypeMapping(types[i]);
			}
			return FromMappings(array);
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public static string GetXmlSerializerAssemblyName(Type type)
		{
			return GetXmlSerializerAssemblyName(type, null);
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public static string GetXmlSerializerAssemblyName(Type type, string defaultNamespace)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			return Compiler.GetTempAssemblyName(type.Assembly.GetName(), defaultNamespace);
		}

		protected virtual XmlSerializationReader CreateReader()
		{
			throw new NotImplementedException();
		}

		protected virtual object Deserialize(XmlSerializationReader reader)
		{
			throw new NotImplementedException();
		}

		protected virtual XmlSerializationWriter CreateWriter()
		{
			throw new NotImplementedException();
		}

		protected virtual void Serialize(object o, XmlSerializationWriter writer)
		{
			throw new NotImplementedException();
		}

		internal void SetTempAssembly(TempAssembly tempAssembly, XmlMapping mapping)
		{
			this.tempAssembly = tempAssembly;
			this.mapping = mapping;
			typedSerializer = true;
		}

		private static XmlTypeMapping GetKnownMapping(Type type, string ns)
		{
			if (ns != null && ns != string.Empty)
			{
				return null;
			}
			TypeDesc typeDesc = (TypeDesc)TypeScope.PrimtiveTypes[type];
			if (typeDesc == null)
			{
				return null;
			}
			ElementAccessor elementAccessor = new ElementAccessor();
			elementAccessor.Name = typeDesc.DataType.Name;
			XmlTypeMapping xmlTypeMapping = new XmlTypeMapping(null, elementAccessor);
			xmlTypeMapping.SetKeyInternal(XmlMapping.GenerateKey(type, null, null));
			return xmlTypeMapping;
		}

		private void SerializePrimitive(XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces)
		{
			XmlSerializationPrimitiveWriter xmlSerializationPrimitiveWriter = new XmlSerializationPrimitiveWriter();
			xmlSerializationPrimitiveWriter.Init(xmlWriter, namespaces, null, null, null);
			switch (Type.GetTypeCode(primitiveType))
			{
			case TypeCode.String:
				xmlSerializationPrimitiveWriter.Write_string(o);
				return;
			case TypeCode.Int32:
				xmlSerializationPrimitiveWriter.Write_int(o);
				return;
			case TypeCode.Boolean:
				xmlSerializationPrimitiveWriter.Write_boolean(o);
				return;
			case TypeCode.Int16:
				xmlSerializationPrimitiveWriter.Write_short(o);
				return;
			case TypeCode.Int64:
				xmlSerializationPrimitiveWriter.Write_long(o);
				return;
			case TypeCode.Single:
				xmlSerializationPrimitiveWriter.Write_float(o);
				return;
			case TypeCode.Double:
				xmlSerializationPrimitiveWriter.Write_double(o);
				return;
			case TypeCode.Decimal:
				xmlSerializationPrimitiveWriter.Write_decimal(o);
				return;
			case TypeCode.DateTime:
				xmlSerializationPrimitiveWriter.Write_dateTime(o);
				return;
			case TypeCode.Char:
				xmlSerializationPrimitiveWriter.Write_char(o);
				return;
			case TypeCode.Byte:
				xmlSerializationPrimitiveWriter.Write_unsignedByte(o);
				return;
			case TypeCode.SByte:
				xmlSerializationPrimitiveWriter.Write_byte(o);
				return;
			case TypeCode.UInt16:
				xmlSerializationPrimitiveWriter.Write_unsignedShort(o);
				return;
			case TypeCode.UInt32:
				xmlSerializationPrimitiveWriter.Write_unsignedInt(o);
				return;
			case TypeCode.UInt64:
				xmlSerializationPrimitiveWriter.Write_unsignedLong(o);
				return;
			}
			if (primitiveType == typeof(XmlQualifiedName))
			{
				xmlSerializationPrimitiveWriter.Write_QName(o);
				return;
			}
			if (primitiveType == typeof(byte[]))
			{
				xmlSerializationPrimitiveWriter.Write_base64Binary(o);
				return;
			}
			if (primitiveType == typeof(Guid))
			{
				xmlSerializationPrimitiveWriter.Write_guid(o);
				return;
			}
			throw new InvalidOperationException(Res.GetString("XmlUnxpectedType", primitiveType.FullName));
		}

		private object DeserializePrimitive(XmlReader xmlReader, XmlDeserializationEvents events)
		{
			XmlSerializationPrimitiveReader xmlSerializationPrimitiveReader = new XmlSerializationPrimitiveReader();
			xmlSerializationPrimitiveReader.Init(xmlReader, events, null, null);
			switch (Type.GetTypeCode(primitiveType))
			{
			case TypeCode.String:
				return xmlSerializationPrimitiveReader.Read_string();
			case TypeCode.Int32:
				return xmlSerializationPrimitiveReader.Read_int();
			case TypeCode.Boolean:
				return xmlSerializationPrimitiveReader.Read_boolean();
			case TypeCode.Int16:
				return xmlSerializationPrimitiveReader.Read_short();
			case TypeCode.Int64:
				return xmlSerializationPrimitiveReader.Read_long();
			case TypeCode.Single:
				return xmlSerializationPrimitiveReader.Read_float();
			case TypeCode.Double:
				return xmlSerializationPrimitiveReader.Read_double();
			case TypeCode.Decimal:
				return xmlSerializationPrimitiveReader.Read_decimal();
			case TypeCode.DateTime:
				return xmlSerializationPrimitiveReader.Read_dateTime();
			case TypeCode.Char:
				return xmlSerializationPrimitiveReader.Read_char();
			case TypeCode.Byte:
				return xmlSerializationPrimitiveReader.Read_unsignedByte();
			case TypeCode.SByte:
				return xmlSerializationPrimitiveReader.Read_byte();
			case TypeCode.UInt16:
				return xmlSerializationPrimitiveReader.Read_unsignedShort();
			case TypeCode.UInt32:
				return xmlSerializationPrimitiveReader.Read_unsignedInt();
			case TypeCode.UInt64:
				return xmlSerializationPrimitiveReader.Read_unsignedLong();
			default:
				if (primitiveType == typeof(XmlQualifiedName))
				{
					return xmlSerializationPrimitiveReader.Read_QName();
				}
				if (primitiveType == typeof(byte[]))
				{
					return xmlSerializationPrimitiveReader.Read_base64Binary();
				}
				if (primitiveType == typeof(Guid))
				{
					return xmlSerializationPrimitiveReader.Read_guid();
				}
				throw new InvalidOperationException(Res.GetString("XmlUnxpectedType", primitiveType.FullName));
			}
		}
	}
	public class XmlSerializerFactory
	{
		private static TempAssemblyCache cache = new TempAssemblyCache();

		public XmlSerializer CreateSerializer(Type type, XmlAttributeOverrides overrides, Type[] extraTypes, XmlRootAttribute root, string defaultNamespace)
		{
			return CreateSerializer(type, overrides, extraTypes, root, defaultNamespace, null, null);
		}

		public XmlSerializer CreateSerializer(Type type, XmlRootAttribute root)
		{
			return CreateSerializer(type, null, new Type[0], root, null, null, null);
		}

		public XmlSerializer CreateSerializer(Type type, Type[] extraTypes)
		{
			return CreateSerializer(type, null, extraTypes, null, null, null, null);
		}

		public XmlSerializer CreateSerializer(Type type, XmlAttributeOverrides overrides)
		{
			return CreateSerializer(type, overrides, new Type[0], null, null, null, null);
		}

		public XmlSerializer CreateSerializer(XmlTypeMapping xmlTypeMapping)
		{
			TempAssembly tempAssembly = XmlSerializer.GenerateTempAssembly(xmlTypeMapping);
			return (XmlSerializer)tempAssembly.Contract.TypedSerializers[xmlTypeMapping.Key];
		}

		public XmlSerializer CreateSerializer(Type type)
		{
			return CreateSerializer(type, (string)null);
		}

		public XmlSerializer CreateSerializer(Type type, string defaultNamespace)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			TempAssembly tempAssembly = cache[defaultNamespace, type];
			XmlTypeMapping xmlTypeMapping = null;
			if (tempAssembly == null)
			{
				lock (cache)
				{
					tempAssembly = cache[defaultNamespace, type];
					if (tempAssembly == null)
					{
						XmlSerializerImplementation contract;
						Assembly assembly = TempAssembly.LoadGeneratedAssembly(type, defaultNamespace, out contract);
						if (assembly == null)
						{
							XmlReflectionImporter xmlReflectionImporter = new XmlReflectionImporter(defaultNamespace);
							xmlTypeMapping = xmlReflectionImporter.ImportTypeMapping(type, null, defaultNamespace);
							tempAssembly = XmlSerializer.GenerateTempAssembly(xmlTypeMapping, type, defaultNamespace);
						}
						else
						{
							tempAssembly = new TempAssembly(contract);
						}
						cache.Add(defaultNamespace, type, tempAssembly);
					}
				}
			}
			if (xmlTypeMapping == null)
			{
				xmlTypeMapping = XmlReflectionImporter.GetTopLevelMapping(type, defaultNamespace);
			}
			return tempAssembly.Contract.GetSerializer(type);
		}

		public XmlSerializer CreateSerializer(Type type, XmlAttributeOverrides overrides, Type[] extraTypes, XmlRootAttribute root, string defaultNamespace, string location, Evidence evidence)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			XmlReflectionImporter xmlReflectionImporter = new XmlReflectionImporter(overrides, defaultNamespace);
			for (int i = 0; i < extraTypes.Length; i++)
			{
				xmlReflectionImporter.IncludeType(extraTypes[i]);
			}
			XmlTypeMapping xmlTypeMapping = xmlReflectionImporter.ImportTypeMapping(type, root, defaultNamespace);
			TempAssembly tempAssembly = XmlSerializer.GenerateTempAssembly(xmlTypeMapping, type, defaultNamespace, location, evidence);
			return (XmlSerializer)tempAssembly.Contract.TypedSerializers[xmlTypeMapping.Key];
		}
	}
	public class XmlSerializerNamespaces
	{
		private Hashtable namespaces;

		public int Count => Namespaces.Count;

		internal ArrayList NamespaceList
		{
			get
			{
				if (namespaces == null || namespaces.Count == 0)
				{
					return null;
				}
				ArrayList arrayList = new ArrayList();
				foreach (string key in Namespaces.Keys)
				{
					arrayList.Add(new XmlQualifiedName(key, (string)Namespaces[key]));
				}
				return arrayList;
			}
		}

		internal Hashtable Namespaces
		{
			get
			{
				if (namespaces == null)
				{
					namespaces = new Hashtable();
				}
				return namespaces;
			}
			set
			{
				namespaces = value;
			}
		}

		public XmlSerializerNamespaces()
		{
		}

		public XmlSerializerNamespaces(XmlSerializerNamespaces namespaces)
		{
			this.namespaces = (Hashtable)namespaces.Namespaces.Clone();
		}

		public XmlSerializerNamespaces(XmlQualifiedName[] namespaces)
		{
			foreach (XmlQualifiedName xmlQualifiedName in namespaces)
			{
				Add(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
			}
		}

		public void Add(string prefix, string ns)
		{
			if (prefix != null && prefix.Length > 0)
			{
				XmlConvert.VerifyNCName(prefix);
			}
			if (ns != null && ns.Length > 0)
			{
				XmlConvert.ToUri(ns);
			}
			AddInternal(prefix, ns);
		}

		internal void AddInternal(string prefix, string ns)
		{
			Namespaces[prefix] = ns;
		}

		public XmlQualifiedName[] ToArray()
		{
			if (NamespaceList == null)
			{
				return new XmlQualifiedName[0];
			}
			return (XmlQualifiedName[])NamespaceList.ToArray(typeof(XmlQualifiedName));
		}

		internal string LookupPrefix(string ns)
		{
			if (string.IsNullOrEmpty(ns))
			{
				return null;
			}
			if (namespaces == null || namespaces.Count == 0)
			{
				return null;
			}
			foreach (string key in namespaces.Keys)
			{
				if (!string.IsNullOrEmpty(key) && (string)namespaces[key] == ns)
				{
					return key;
				}
			}
			return null;
		}
	}
	[AttributeUsage(AttributeTargets.Assembly)]
	public sealed class XmlSerializerVersionAttribute : Attribute
	{
		private string mvid;

		private string serializerVersion;

		private string ns;

		private Type type;

		public string ParentAssemblyId
		{
			get
			{
				return mvid;
			}
			set
			{
				mvid = value;
			}
		}

		public string Version
		{
			get
			{
				return serializerVersion;
			}
			set
			{
				serializerVersion = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		public Type Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public XmlSerializerVersionAttribute()
		{
		}

		public XmlSerializerVersionAttribute(Type type)
		{
			this.type = type;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
	public class XmlTextAttribute : Attribute
	{
		private Type type;

		private string dataType;

		public Type Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		public string DataType
		{
			get
			{
				if (dataType != null)
				{
					return dataType;
				}
				return string.Empty;
			}
			set
			{
				dataType = value;
			}
		}

		public XmlTextAttribute()
		{
		}

		public XmlTextAttribute(Type type)
		{
			this.type = type;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Interface)]
	public class XmlTypeAttribute : Attribute
	{
		private bool includeInSchema = true;

		private bool anonymousType;

		private string ns;

		private string typeName;

		public bool AnonymousType
		{
			get
			{
				return anonymousType;
			}
			set
			{
				anonymousType = value;
			}
		}

		public bool IncludeInSchema
		{
			get
			{
				return includeInSchema;
			}
			set
			{
				includeInSchema = value;
			}
		}

		public string TypeName
		{
			get
			{
				if (typeName != null)
				{
					return typeName;
				}
				return string.Empty;
			}
			set
			{
				typeName = value;
			}
		}

		public string Namespace
		{
			get
			{
				return ns;
			}
			set
			{
				ns = value;
			}
		}

		public XmlTypeAttribute()
		{
		}

		public XmlTypeAttribute(string typeName)
		{
			this.typeName = typeName;
		}
	}
	public class XmlTypeMapping : XmlMapping
	{
		internal TypeMapping Mapping => base.Accessor.Mapping;

		public string TypeName => Mapping.TypeDesc.Name;

		public string TypeFullName => Mapping.TypeDesc.FullName;

		public string XsdTypeName => Mapping.TypeName;

		public string XsdTypeNamespace => Mapping.Namespace;

		internal XmlTypeMapping(TypeScope scope, ElementAccessor accessor)
			: base(scope, accessor)
		{
		}
	}
	public delegate void XmlAttributeEventHandler(object sender, XmlAttributeEventArgs e);
	public class XmlAttributeEventArgs : EventArgs
	{
		private object o;

		private XmlAttribute attr;

		private string qnames;

		private int lineNumber;

		private int linePosition;

		public object ObjectBeingDeserialized => o;

		public XmlAttribute Attr => attr;

		public int LineNumber => lineNumber;

		public int LinePosition => linePosition;

		public string ExpectedAttributes
		{
			get
			{
				if (qnames != null)
				{
					return qnames;
				}
				return string.Empty;
			}
		}

		internal XmlAttributeEventArgs(XmlAttribute attr, int lineNumber, int linePosition, object o, string qnames)
		{
			this.attr = attr;
			this.o = o;
			this.qnames = qnames;
			this.lineNumber = lineNumber;
			this.linePosition = linePosition;
		}
	}
	public delegate void XmlElementEventHandler(object sender, XmlElementEventArgs e);
	public class XmlElementEventArgs : EventArgs
	{
		private object o;

		private XmlElement elem;

		private string qnames;

		private int lineNumber;

		private int linePosition;

		public object ObjectBeingDeserialized => o;

		public XmlElement Element => elem;

		public int LineNumber => lineNumber;

		public int LinePosition => linePosition;

		public string ExpectedElements
		{
			get
			{
				if (qnames != null)
				{
					return qnames;
				}
				return string.Empty;
			}
		}

		internal XmlElementEventArgs(XmlElement elem, int lineNumber, int linePosition, object o, string qnames)
		{
			this.elem = elem;
			this.o = o;
			this.qnames = qnames;
			this.lineNumber = lineNumber;
			this.linePosition = linePosition;
		}
	}
	public delegate void XmlNodeEventHandler(object sender, XmlNodeEventArgs e);
	public class XmlNodeEventArgs : EventArgs
	{
		private object o;

		private XmlNode xmlNode;

		private int lineNumber;

		private int linePosition;

		public object ObjectBeingDeserialized => o;

		public XmlNodeType NodeType => xmlNode.NodeType;

		public string Name => xmlNode.Name;

		public string LocalName => xmlNode.LocalName;

		public string NamespaceURI => xmlNode.NamespaceURI;

		public string Text => xmlNode.Value;

		public int LineNumber => lineNumber;

		public int LinePosition => linePosition;

		internal XmlNodeEventArgs(XmlNode xmlNode, int lineNumber, int linePosition, object o)
		{
			this.o = o;
			this.xmlNode = xmlNode;
			this.lineNumber = lineNumber;
			this.linePosition = linePosition;
		}
	}
	public delegate void UnreferencedObjectEventHandler(object sender, UnreferencedObjectEventArgs e);
	public class UnreferencedObjectEventArgs : EventArgs
	{
		private object o;

		private string id;

		public object UnreferencedObject => o;

		public string UnreferencedId => id;

		public UnreferencedObjectEventArgs(object o, string id)
		{
			this.o = o;
			this.id = id;
		}
	}
}
namespace System.Xml.Serialization.Advanced
{
	public abstract class SchemaImporterExtension
	{
		public virtual string ImportSchemaType(string name, string ns, XmlSchemaObject context, XmlSchemas schemas, XmlSchemaImporter importer, CodeCompileUnit compileUnit, CodeNamespace mainNamespace, CodeGenerationOptions options, CodeDomProvider codeProvider)
		{
			return null;
		}

		public virtual string ImportSchemaType(XmlSchemaType type, XmlSchemaObject context, XmlSchemas schemas, XmlSchemaImporter importer, CodeCompileUnit compileUnit, CodeNamespace mainNamespace, CodeGenerationOptions options, CodeDomProvider codeProvider)
		{
			return null;
		}

		public virtual string ImportAnyElement(XmlSchemaAny any, bool mixed, XmlSchemas schemas, XmlSchemaImporter importer, CodeCompileUnit compileUnit, CodeNamespace mainNamespace, CodeGenerationOptions options, CodeDomProvider codeProvider)
		{
			return null;
		}

		public virtual CodeExpression ImportDefaultValue(string value, string type)
		{
			return null;
		}
	}
	public class SchemaImporterExtensionCollection : CollectionBase
	{
		private Hashtable exNames;

		internal Hashtable Names
		{
			get
			{
				if (exNames == null)
				{
					exNames = new Hashtable();
				}
				return exNames;
			}
		}

		public SchemaImporterExtension this[int index]
		{
			get
			{
				return (SchemaImporterExtension)base.List[index];
			}
			set
			{
				base.List[index] = value;
			}
		}

		public int Add(SchemaImporterExtension extension)
		{
			return Add(extension.GetType().FullName, extension);
		}

		public int Add(string name, Type type)
		{
			if (type.IsSubclassOf(typeof(SchemaImporterExtension)))
			{
				return Add(name, (SchemaImporterExtension)Activator.CreateInstance(type));
			}
			throw new ArgumentException(Res.GetString("XmlInvalidSchemaExtension", type));
		}

		public void Remove(string name)
		{
			if (Names[name] != null)
			{
				base.List.Remove(Names[name]);
				Names[name] = null;
			}
		}

		public new void Clear()
		{
			Names.Clear();
			base.List.Clear();
		}

		internal SchemaImporterExtensionCollection Clone()
		{
			SchemaImporterExtensionCollection schemaImporterExtensionCollection = new SchemaImporterExtensionCollection();
			schemaImporterExtensionCollection.exNames = (Hashtable)Names.Clone();
			foreach (object item in base.List)
			{
				schemaImporterExtensionCollection.List.Add(item);
			}
			return schemaImporterExtensionCollection;
		}

		internal int Add(string name, SchemaImporterExtension extension)
		{
			if (Names[name] != null)
			{
				if (Names[name].GetType() != extension.GetType())
				{
					throw new InvalidOperationException(Res.GetString("XmlConfigurationDuplicateExtension", name));
				}
				return -1;
			}
			Names[name] = extension;
			return base.List.Add(extension);
		}

		public void Insert(int index, SchemaImporterExtension extension)
		{
			base.List.Insert(index, extension);
		}

		public int IndexOf(SchemaImporterExtension extension)
		{
			return base.List.IndexOf(extension);
		}

		public bool Contains(SchemaImporterExtension extension)
		{
			return base.List.Contains(extension);
		}

		public void Remove(SchemaImporterExtension extension)
		{
			base.List.Remove(extension);
		}

		public void CopyTo(SchemaImporterExtension[] array, int index)
		{
			base.List.CopyTo(array, index);
		}
	}
	internal class MappedTypeDesc
	{
		private string name;

		private string ns;

		private XmlSchemaType xsdType;

		private XmlSchemaObject context;

		private string clrType;

		private SchemaImporterExtension extension;

		private CodeNamespace code;

		private bool exported;

		private StringCollection references;

		internal SchemaImporterExtension Extension => extension;

		internal string Name => clrType;

		internal StringCollection ReferencedAssemblies
		{
			get
			{
				if (references == null)
				{
					references = new StringCollection();
				}
				return references;
			}
		}

		internal MappedTypeDesc(string clrType, string name, string ns, XmlSchemaType xsdType, XmlSchemaObject context, SchemaImporterExtension extension, CodeNamespace code, StringCollection references)
		{
			this.clrType = clrType.Replace('+', '.');
			this.name = name;
			this.ns = ns;
			this.xsdType = xsdType;
			this.context = context;
			this.code = code;
			this.references = references;
			this.extension = extension;
		}

		internal CodeTypeDeclaration ExportTypeDefinition(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit)
		{
			if (exported)
			{
				return null;
			}
			exported = true;
			foreach (CodeNamespaceImport import in code.Imports)
			{
				codeNamespace.Imports.Add(import);
			}
			CodeTypeDeclaration codeTypeDeclaration = null;
			string @string = Res.GetString("XmlExtensionComment", extension.GetType().FullName);
			foreach (CodeTypeDeclaration type in code.Types)
			{
				if (clrType == type.Name)
				{
					if (codeTypeDeclaration != null)
					{
						throw new InvalidOperationException(Res.GetString("XmlExtensionDuplicateDefinition", extension.GetType().FullName, clrType));
					}
					codeTypeDeclaration = type;
				}
				type.Comments.Add(new CodeCommentStatement(@string, docComment: false));
				codeNamespace.Types.Add(type);
			}
			if (codeCompileUnit != null)
			{
				StringEnumerator enumerator3 = ReferencedAssemblies.GetEnumerator();
				try
				{
					while (enumerator3.MoveNext())
					{
						string current = enumerator3.Current;
						if (!codeCompileUnit.ReferencedAssemblies.Contains(current))
						{
							codeCompileUnit.ReferencedAssemblies.Add(current);
						}
					}
					return codeTypeDeclaration;
				}
				finally
				{
					if (enumerator3 is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
			}
			return codeTypeDeclaration;
		}
	}
}
namespace System.Xml.Serialization
{
	internal class XmlSerializationPrimitiveWriter : XmlSerializationWriter
	{
		internal void Write_string(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteNullTagLiteral("string", "");
				return;
			}
			TopLevelElement();
			WriteNullableStringLiteral("string", "", (string)o);
		}

		internal void Write_int(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("int", "");
			}
			else
			{
				WriteElementStringRaw("int", "", XmlConvert.ToString((int)o));
			}
		}

		internal void Write_boolean(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("boolean", "");
			}
			else
			{
				WriteElementStringRaw("boolean", "", XmlConvert.ToString((bool)o));
			}
		}

		internal void Write_short(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("short", "");
			}
			else
			{
				WriteElementStringRaw("short", "", XmlConvert.ToString((short)o));
			}
		}

		internal void Write_long(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("long", "");
			}
			else
			{
				WriteElementStringRaw("long", "", XmlConvert.ToString((long)o));
			}
		}

		internal void Write_float(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("float", "");
			}
			else
			{
				WriteElementStringRaw("float", "", XmlConvert.ToString((float)o));
			}
		}

		internal void Write_double(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("double", "");
			}
			else
			{
				WriteElementStringRaw("double", "", XmlConvert.ToString((double)o));
			}
		}

		internal void Write_decimal(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("decimal", "");
			}
			else
			{
				WriteElementStringRaw("decimal", "", XmlConvert.ToString((decimal)o));
			}
		}

		internal void Write_dateTime(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("dateTime", "");
			}
			else
			{
				WriteElementStringRaw("dateTime", "", XmlSerializationWriter.FromDateTime((DateTime)o));
			}
		}

		internal void Write_unsignedByte(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("unsignedByte", "");
			}
			else
			{
				WriteElementStringRaw("unsignedByte", "", XmlConvert.ToString((byte)o));
			}
		}

		internal void Write_byte(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("byte", "");
			}
			else
			{
				WriteElementStringRaw("byte", "", XmlConvert.ToString((sbyte)o));
			}
		}

		internal void Write_unsignedShort(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("unsignedShort", "");
			}
			else
			{
				WriteElementStringRaw("unsignedShort", "", XmlConvert.ToString((ushort)o));
			}
		}

		internal void Write_unsignedInt(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("unsignedInt", "");
			}
			else
			{
				WriteElementStringRaw("unsignedInt", "", XmlConvert.ToString((uint)o));
			}
		}

		internal void Write_unsignedLong(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("unsignedLong", "");
			}
			else
			{
				WriteElementStringRaw("unsignedLong", "", XmlConvert.ToString((ulong)o));
			}
		}

		internal void Write_base64Binary(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteNullTagLiteral("base64Binary", "");
				return;
			}
			TopLevelElement();
			WriteNullableStringLiteralRaw("base64Binary", "", XmlSerializationWriter.FromByteArrayBase64((byte[])o));
		}

		internal void Write_guid(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("guid", "");
			}
			else
			{
				WriteElementStringRaw("guid", "", XmlConvert.ToString((Guid)o));
			}
		}

		internal void Write_char(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteEmptyTag("char", "");
			}
			else
			{
				WriteElementString("char", "", XmlSerializationWriter.FromChar((char)o));
			}
		}

		internal void Write_QName(object o)
		{
			WriteStartDocument();
			if (o == null)
			{
				WriteNullTagLiteral("QName", "");
				return;
			}
			TopLevelElement();
			WriteNullableQualifiedNameLiteral("QName", "", (XmlQualifiedName)o);
		}

		protected override void InitCallbacks()
		{
		}
	}
	internal class XmlSerializationPrimitiveReader : XmlSerializationReader
	{
		private string id4_boolean;

		private string id14_unsignedInt;

		private string id15_unsignedLong;

		private string id7_float;

		private string id10_dateTime;

		private string id6_long;

		private string id9_decimal;

		private string id8_double;

		private string id17_guid;

		private string id2_Item;

		private string id13_unsignedShort;

		private string id18_char;

		private string id3_int;

		private string id12_byte;

		private string id16_base64Binary;

		private string id11_unsignedByte;

		private string id5_short;

		private string id1_string;

		private string id1_QName;

		internal object Read_string()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id1_string || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = ((!ReadNull()) ? base.Reader.ReadElementString() : null);
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_int()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id3_int || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToInt32(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_boolean()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id4_boolean || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToBoolean(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_short()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id5_short || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToInt16(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_long()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id6_long || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToInt64(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_float()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id7_float || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToSingle(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_double()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id8_double || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToDouble(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_decimal()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id9_decimal || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToDecimal(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_dateTime()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id10_dateTime || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlSerializationReader.ToDateTime(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_unsignedByte()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id11_unsignedByte || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToByte(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_byte()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id12_byte || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToSByte(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_unsignedShort()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id13_unsignedShort || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToUInt16(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_unsignedInt()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id14_unsignedInt || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToUInt32(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_unsignedLong()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id15_unsignedLong || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToUInt64(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_base64Binary()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id16_base64Binary || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = ((!ReadNull()) ? ToByteArrayBase64(isNull: false) : null);
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_guid()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id17_guid || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlConvert.ToGuid(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_char()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id18_char || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = XmlSerializationReader.ToChar(base.Reader.ReadElementString());
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		internal object Read_QName()
		{
			object result = null;
			base.Reader.MoveToContent();
			if (base.Reader.NodeType == XmlNodeType.Element)
			{
				if ((object)base.Reader.LocalName != id1_QName || (object)base.Reader.NamespaceURI != id2_Item)
				{
					throw CreateUnknownNodeException();
				}
				result = ((!ReadNull()) ? ReadElementQualifiedName() : null);
			}
			else
			{
				UnknownNode(null);
			}
			return result;
		}

		protected override void InitCallbacks()
		{
		}

		protected override void InitIDs()
		{
			id4_boolean = base.Reader.NameTable.Add("boolean");
			id14_unsignedInt = base.Reader.NameTable.Add("unsignedInt");
			id15_unsignedLong = base.Reader.NameTable.Add("unsignedLong");
			id7_float = base.Reader.NameTable.Add("float");
			id10_dateTime = base.Reader.NameTable.Add("dateTime");
			id6_long = base.Reader.NameTable.Add("long");
			id9_decimal = base.Reader.NameTable.Add("decimal");
			id8_double = base.Reader.NameTable.Add("double");
			id17_guid = base.Reader.NameTable.Add("guid");
			id2_Item = base.Reader.NameTable.Add("");
			id13_unsignedShort = base.Reader.NameTable.Add("unsignedShort");
			id18_char = base.Reader.NameTable.Add("char");
			id3_int = base.Reader.NameTable.Add("int");
			id12_byte = base.Reader.NameTable.Add("byte");
			id16_base64Binary = base.Reader.NameTable.Add("base64Binary");
			id11_unsignedByte = base.Reader.NameTable.Add("unsignedByte");
			id5_short = base.Reader.NameTable.Add("short");
			id1_string = base.Reader.NameTable.Add("string");
			id1_QName = base.Reader.NameTable.Add("QName");
		}
	}
}
namespace System.Xml.Serialization.Configuration
{
	internal static class ConfigurationStrings
	{
		internal const string Name = "name";

		internal const string SchemaImporterExtensionsSectionName = "schemaImporterExtensions";

		internal const string DateTimeSerializationSectionName = "dateTimeSerialization";

		internal const string XmlSerializerSectionName = "xmlSerializer";

		internal const string SectionGroupName = "system.xml.serialization";

		internal const string SqlTypesSchemaImporterChar = "SqlTypesSchemaImporterChar";

		internal const string SqlTypesSchemaImporterNChar = "SqlTypesSchemaImporterNChar";

		internal const string SqlTypesSchemaImporterVarChar = "SqlTypesSchemaImporterVarChar";

		internal const string SqlTypesSchemaImporterNVarChar = "SqlTypesSchemaImporterNVarChar";

		internal const string SqlTypesSchemaImporterText = "SqlTypesSchemaImporterText";

		internal const string SqlTypesSchemaImporterNText = "SqlTypesSchemaImporterNText";

		internal const string SqlTypesSchemaImporterVarBinary = "SqlTypesSchemaImporterVarBinary";

		internal const string SqlTypesSchemaImporterBinary = "SqlTypesSchemaImporterBinary";

		internal const string SqlTypesSchemaImporterImage = "SqlTypesSchemaImporterImage";

		internal const string SqlTypesSchemaImporterDecimal = "SqlTypesSchemaImporterDecimal";

		internal const string SqlTypesSchemaImporterNumeric = "SqlTypesSchemaImporterNumeric";

		internal const string SqlTypesSchemaImporterBigInt = "SqlTypesSchemaImporterBigInt";

		internal const string SqlTypesSchemaImporterInt = "SqlTypesSchemaImporterInt";

		internal const string SqlTypesSchemaImporterSmallInt = "SqlTypesSchemaImporterSmallInt";

		internal const string SqlTypesSchemaImporterTinyInt = "SqlTypesSchemaImporterTinyInt";

		internal const string SqlTypesSchemaImporterBit = "SqlTypesSchemaImporterBit";

		internal const string SqlTypesSchemaImporterFloat = "SqlTypesSchemaImporterFloat";

		internal const string SqlTypesSchemaImporterReal = "SqlTypesSchemaImporterReal";

		internal const string SqlTypesSchemaImporterDateTime = "SqlTypesSchemaImporterDateTime";

		internal const string SqlTypesSchemaImporterSmallDateTime = "SqlTypesSchemaImporterSmallDateTime";

		internal const string SqlTypesSchemaImporterMoney = "SqlTypesSchemaImporterMoney";

		internal const string SqlTypesSchemaImporterSmallMoney = "SqlTypesSchemaImporterSmallMoney";

		internal const string SqlTypesSchemaImporterUniqueIdentifier = "SqlTypesSchemaImporterUniqueIdentifier";

		internal const string Type = "type";

		internal const string Mode = "mode";

		internal const string CheckDeserializeAdvances = "checkDeserializeAdvances";

		internal const string TempFilesLocation = "tempFilesLocation";

		internal static string SchemaImporterExtensionsSectionPath => GetSectionPath("schemaImporterExtensions");

		internal static string DateTimeSerializationSectionPath => GetSectionPath("dateTimeSerialization");

		internal static string XmlSerializerSectionPath => GetSectionPath("xmlSerializer");

		private static string GetSectionPath(string sectionName)
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}/{1}", "system.xml.serialization", sectionName);
		}
	}
	public sealed class DateTimeSerializationSection : ConfigurationSection
	{
		public enum DateTimeSerializationMode
		{
			Default,
			Roundtrip,
			Local
		}

		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty mode = new ConfigurationProperty("mode", typeof(DateTimeSerializationMode), DateTimeSerializationMode.Roundtrip, new EnumConverter(typeof(DateTimeSerializationMode)), null, ConfigurationPropertyOptions.None);

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		[ConfigurationProperty("mode", DefaultValue = DateTimeSerializationMode.Roundtrip)]
		public DateTimeSerializationMode Mode
		{
			get
			{
				return (DateTimeSerializationMode)base[mode];
			}
			set
			{
				base[mode] = value;
			}
		}

		public DateTimeSerializationSection()
		{
			properties.Add(mode);
		}
	}
	public sealed class SchemaImporterExtensionElement : ConfigurationElement
	{
		private class TypeAndName
		{
			public readonly Type type;

			public readonly string name;

			public TypeAndName(string name)
			{
				type = Type.GetType(name, throwOnError: true, ignoreCase: true);
				this.name = name;
			}

			public TypeAndName(Type type)
			{
				this.type = type;
			}

			public override int GetHashCode()
			{
				return type.GetHashCode();
			}

			public override bool Equals(object comparand)
			{
				return type.Equals(((TypeAndName)comparand).type);
			}
		}

		private class TypeTypeConverter : TypeConverter
		{
			public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
			{
				if (sourceType == typeof(string))
				{
					return true;
				}
				return base.CanConvertFrom(context, sourceType);
			}

			public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
			{
				if (value is string)
				{
					return new TypeAndName((string)value);
				}
				return base.ConvertFrom(context, culture, value);
			}

			public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
			{
				if (destinationType == typeof(string))
				{
					TypeAndName typeAndName = (TypeAndName)value;
					if (typeAndName.name != null)
					{
						return typeAndName.name;
					}
					return typeAndName.type.AssemblyQualifiedName;
				}
				return base.ConvertTo(context, culture, value, destinationType);
			}
		}

		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty name = new ConfigurationProperty("name", typeof(string), null, ConfigurationPropertyOptions.IsKey);

		private readonly ConfigurationProperty type = new ConfigurationProperty("type", typeof(Type), null, new TypeTypeConverter(), null, ConfigurationPropertyOptions.IsRequired);

		[ConfigurationProperty("name", IsRequired = true, IsKey = true)]
		public string Name
		{
			get
			{
				return (string)base[name];
			}
			set
			{
				base[name] = value;
			}
		}

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		[ConfigurationProperty("type", IsRequired = true, IsKey = false)]
		[TypeConverter(typeof(TypeTypeConverter))]
		public Type Type
		{
			get
			{
				return ((TypeAndName)base[type]).type;
			}
			set
			{
				base[type] = new TypeAndName(value);
			}
		}

		internal string Key => Name;

		public SchemaImporterExtensionElement()
		{
			properties.Add(name);
			properties.Add(type);
		}

		public SchemaImporterExtensionElement(string name, string type)
			: this()
		{
			Name = name;
			base[this.type] = new TypeAndName(type);
		}

		public SchemaImporterExtensionElement(string name, Type type)
			: this()
		{
			Name = name;
			Type = type;
		}
	}
	[ConfigurationCollection(typeof(SchemaImporterExtensionElement))]
	public sealed class SchemaImporterExtensionElementCollection : ConfigurationElementCollection
	{
		public SchemaImporterExtensionElement this[int index]
		{
			get
			{
				return (SchemaImporterExtensionElement)BaseGet(index);
			}
			set
			{
				if (BaseGet(index) != null)
				{
					BaseRemoveAt(index);
				}
				BaseAdd(index, value);
			}
		}

		public new SchemaImporterExtensionElement this[string name]
		{
			get
			{
				return (SchemaImporterExtensionElement)BaseGet(name);
			}
			set
			{
				if (BaseGet(name) != null)
				{
					BaseRemove(name);
				}
				BaseAdd(value);
			}
		}

		public void Add(SchemaImporterExtensionElement element)
		{
			BaseAdd(element);
		}

		public void Clear()
		{
			BaseClear();
		}

		protected override ConfigurationElement CreateNewElement()
		{
			return new SchemaImporterExtensionElement();
		}

		protected override object GetElementKey(ConfigurationElement element)
		{
			return ((SchemaImporterExtensionElement)element).Key;
		}

		public int IndexOf(SchemaImporterExtensionElement element)
		{
			return BaseIndexOf(element);
		}

		public void Remove(SchemaImporterExtensionElement element)
		{
			BaseRemove(element.Key);
		}

		public void Remove(string name)
		{
			BaseRemove(name);
		}

		public void RemoveAt(int index)
		{
			BaseRemoveAt(index);
		}
	}
	public sealed class SchemaImporterExtensionsSection : ConfigurationSection
	{
		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty schemaImporterExtensions = new ConfigurationProperty(null, typeof(SchemaImporterExtensionElementCollection), null, ConfigurationPropertyOptions.IsDefaultCollection);

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		[ConfigurationProperty("", IsDefaultCollection = true)]
		public SchemaImporterExtensionElementCollection SchemaImporterExtensions => (SchemaImporterExtensionElementCollection)base[schemaImporterExtensions];

		internal SchemaImporterExtensionCollection SchemaImporterExtensionsInternal
		{
			get
			{
				SchemaImporterExtensionCollection schemaImporterExtensionCollection = new SchemaImporterExtensionCollection();
				foreach (SchemaImporterExtensionElement schemaImporterExtension in SchemaImporterExtensions)
				{
					schemaImporterExtensionCollection.Add(schemaImporterExtension.Name, schemaImporterExtension.Type);
				}
				return schemaImporterExtensionCollection;
			}
		}

		public SchemaImporterExtensionsSection()
		{
			properties.Add(schemaImporterExtensions);
		}

		private static string GetSqlTypeSchemaImporter(string typeName)
		{
			return "System.Data.SqlTypes." + typeName + ", System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
		}

		protected override void InitializeDefault()
		{
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterChar", GetSqlTypeSchemaImporter("TypeCharSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterNChar", GetSqlTypeSchemaImporter("TypeNCharSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterVarChar", GetSqlTypeSchemaImporter("TypeVarCharSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterNVarChar", GetSqlTypeSchemaImporter("TypeNVarCharSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterText", GetSqlTypeSchemaImporter("TypeTextSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterNText", GetSqlTypeSchemaImporter("TypeNTextSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterVarBinary", GetSqlTypeSchemaImporter("TypeVarBinarySchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterBinary", GetSqlTypeSchemaImporter("TypeBinarySchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterImage", GetSqlTypeSchemaImporter("TypeVarImageSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterDecimal", GetSqlTypeSchemaImporter("TypeDecimalSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterNumeric", GetSqlTypeSchemaImporter("TypeNumericSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterBigInt", GetSqlTypeSchemaImporter("TypeBigIntSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterInt", GetSqlTypeSchemaImporter("TypeIntSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterSmallInt", GetSqlTypeSchemaImporter("TypeSmallIntSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterTinyInt", GetSqlTypeSchemaImporter("TypeTinyIntSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterBit", GetSqlTypeSchemaImporter("TypeBitSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterFloat", GetSqlTypeSchemaImporter("TypeFloatSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterReal", GetSqlTypeSchemaImporter("TypeRealSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterDateTime", GetSqlTypeSchemaImporter("TypeDateTimeSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterSmallDateTime", GetSqlTypeSchemaImporter("TypeSmallDateTimeSchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterMoney", GetSqlTypeSchemaImporter("TypeMoneySchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterSmallMoney", GetSqlTypeSchemaImporter("TypeSmallMoneySchemaImporterExtension")));
			SchemaImporterExtensions.Add(new SchemaImporterExtensionElement("SqlTypesSchemaImporterUniqueIdentifier", GetSqlTypeSchemaImporter("TypeUniqueIdentifierSchemaImporterExtension")));
		}
	}
	public sealed class SerializationSectionGroup : ConfigurationSectionGroup
	{
		[ConfigurationProperty("schemaImporterExtensions")]
		public SchemaImporterExtensionsSection SchemaImporterExtensions => (SchemaImporterExtensionsSection)base.Sections["schemaImporterExtensions"];

		[ConfigurationProperty("dateTimeSerialization")]
		public DateTimeSerializationSection DateTimeSerialization => (DateTimeSerializationSection)base.Sections["dateTimeSerialization"];

		public XmlSerializerSection XmlSerializer => (XmlSerializerSection)base.Sections["xmlSerializer"];
	}
	public sealed class XmlSerializerSection : ConfigurationSection
	{
		private ConfigurationPropertyCollection properties = new ConfigurationPropertyCollection();

		private readonly ConfigurationProperty checkDeserializeAdvances = new ConfigurationProperty("checkDeserializeAdvances", typeof(bool), false, ConfigurationPropertyOptions.None);

		private readonly ConfigurationProperty tempFilesLocation = new ConfigurationProperty("tempFilesLocation", typeof(string), null, null, new RootedPathValidator(), ConfigurationPropertyOptions.None);

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		[ConfigurationProperty("checkDeserializeAdvances", DefaultValue = false)]
		public bool CheckDeserializeAdvances
		{
			get
			{
				return (bool)base[checkDeserializeAdvances];
			}
			set
			{
				base[checkDeserializeAdvances] = value;
			}
		}

		[ConfigurationProperty("tempFilesLocation", DefaultValue = null)]
		public string TempFilesLocation
		{
			get
			{
				return (string)base[tempFilesLocation];
			}
			set
			{
				base[tempFilesLocation] = value;
			}
		}

		public XmlSerializerSection()
		{
			properties.Add(checkDeserializeAdvances);
			properties.Add(tempFilesLocation);
		}
	}
	public class RootedPathValidator : ConfigurationValidatorBase
	{
		public override bool CanValidate(Type type)
		{
			return type == typeof(string);
		}

		public override void Validate(object value)
		{
			string text = value as string;
			if (string.IsNullOrEmpty(text))
			{
				return;
			}
			text = text.Trim();
			if (!string.IsNullOrEmpty(text))
			{
				if (!Path.IsPathRooted(text))
				{
					throw new ConfigurationErrorsException();
				}
				char c = text[0];
				if (c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar)
				{
					throw new ConfigurationErrorsException();
				}
			}
		}
	}
}
