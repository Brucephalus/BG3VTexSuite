
// C:\WINDOWS\Microsoft.NET\assembly\GAC_MSIL\System.Data.SqlXml\v4.0_4.0.0.0__b77a5c561934e089\System.Data.SqlXml.dll
// System.Data.SqlXml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v4.0.30319
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 00000000000000000400000000000000

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Configuration;
using System.Diagnostics;
using System.Diagnostics.SymbolStore;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Permissions;
using System.Security.Policy;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml.Schema;
using System.Xml.Utils;
using System.Xml.XmlConfiguration;
using System.Xml.XPath;
using System.Xml.Xsl.IlGen;
using System.Xml.Xsl.Qil;
using System.Xml.Xsl.Runtime;
using System.Xml.Xsl.XPath;
using System.Xml.Xsl.Xslt;
using System.Xml.Xsl.XsltOld.Debugger;
using Microsoft.CSharp;
using Microsoft.VisualBasic;
using MS.Internal.Xml.XPath;

[assembly: CompilationRelaxations(8)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: Dependency("System.Xml,", LoadHint.Always)]
[assembly: InternalsVisibleTo("System.Xml, PublicKey=00000000000000000400000000000000")]
[assembly: ComVisible(false)]
[assembly: CLSCompliant(true)]
[assembly: AllowPartiallyTrustedCallers]
[assembly: SecurityRules(SecurityRuleSet.Level1, SkipVerificationInFullTrust = true)]
[assembly: AssemblyTitle("System.Data.SqlXml.dll")]
[assembly: AssemblyDescription("System.Data.SqlXml.dll")]
[assembly: AssemblyDefaultAlias("System.Data.SqlXml.dll")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyFileVersion("4.8.9037.0")]
[assembly: AssemblyInformationalVersion("4.8.9037.0")]
[assembly: SatelliteContractVersion("4.0.0.0")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: AssemblyDelaySign(true)]
[assembly: AssemblyKeyFile("f:\\dd\\tools\\devdiv\\EcmaPublicKey.snk")]
[assembly: AssemblySignatureKey("002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3", "a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d")]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: DefaultDllImportSearchPaths(DllImportSearchPath.System32 | DllImportSearchPath.AssemblyDirectory)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("4.0.0.0")]
[module: UnverifiableCode]
namespace System.Xml.Utils
{
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class ResDescriptionAttribute : DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = Res.GetString(base.Description);
				}
				return base.Description;
			}
		}

		public ResDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class ResCategoryAttribute : CategoryAttribute
	{
		public ResCategoryAttribute(string category)
			: base(category)
		{
		}

		protected override string GetLocalizedString(string value)
		{
			return Res.GetString(value);
		}
	}
	internal sealed class Res
	{
		internal const string Xml_UserException = "Xml_UserException";

		internal const string Xml_ErrorFilePosition = "Xml_ErrorFilePosition";

		internal const string Xml_InvalidOperation = "Xml_InvalidOperation";

		internal const string Xml_EndOfInnerExceptionStack = "Xml_EndOfInnerExceptionStack";

		internal const string XPath_UnclosedString = "XPath_UnclosedString";

		internal const string XPath_ScientificNotation = "XPath_ScientificNotation";

		internal const string XPath_UnexpectedToken = "XPath_UnexpectedToken";

		internal const string XPath_NodeTestExpected = "XPath_NodeTestExpected";

		internal const string XPath_EofExpected = "XPath_EofExpected";

		internal const string XPath_TokenExpected = "XPath_TokenExpected";

		internal const string XPath_InvalidAxisInPattern = "XPath_InvalidAxisInPattern";

		internal const string XPath_PredicateAfterDot = "XPath_PredicateAfterDot";

		internal const string XPath_PredicateAfterDotDot = "XPath_PredicateAfterDotDot";

		internal const string XPath_NArgsExpected = "XPath_NArgsExpected";

		internal const string XPath_NOrMArgsExpected = "XPath_NOrMArgsExpected";

		internal const string XPath_AtLeastNArgsExpected = "XPath_AtLeastNArgsExpected";

		internal const string XPath_AtMostMArgsExpected = "XPath_AtMostMArgsExpected";

		internal const string XPath_NodeSetArgumentExpected = "XPath_NodeSetArgumentExpected";

		internal const string XPath_NodeSetExpected = "XPath_NodeSetExpected";

		internal const string XPath_RtfInPathExpr = "XPath_RtfInPathExpr";

		internal const string Xslt_WarningAsError = "Xslt_WarningAsError";

		internal const string Xslt_InputTooComplex = "Xslt_InputTooComplex";

		internal const string Xslt_CannotLoadStylesheet = "Xslt_CannotLoadStylesheet";

		internal const string Xslt_WrongStylesheetElement = "Xslt_WrongStylesheetElement";

		internal const string Xslt_WdXslNamespace = "Xslt_WdXslNamespace";

		internal const string Xslt_NotAtTop = "Xslt_NotAtTop";

		internal const string Xslt_UnexpectedElement = "Xslt_UnexpectedElement";

		internal const string Xslt_NullNsAtTopLevel = "Xslt_NullNsAtTopLevel";

		internal const string Xslt_TextNodesNotAllowed = "Xslt_TextNodesNotAllowed";

		internal const string Xslt_NotEmptyContents = "Xslt_NotEmptyContents";

		internal const string Xslt_InvalidAttribute = "Xslt_InvalidAttribute";

		internal const string Xslt_MissingAttribute = "Xslt_MissingAttribute";

		internal const string Xslt_InvalidAttrValue = "Xslt_InvalidAttrValue";

		internal const string Xslt_BistateAttribute = "Xslt_BistateAttribute";

		internal const string Xslt_CharAttribute = "Xslt_CharAttribute";

		internal const string Xslt_CircularInclude = "Xslt_CircularInclude";

		internal const string Xslt_SingleRightBraceInAvt = "Xslt_SingleRightBraceInAvt";

		internal const string Xslt_VariableCntSel2 = "Xslt_VariableCntSel2";

		internal const string Xslt_KeyCntUse = "Xslt_KeyCntUse";

		internal const string Xslt_DupTemplateName = "Xslt_DupTemplateName";

		internal const string Xslt_BothMatchNameAbsent = "Xslt_BothMatchNameAbsent";

		internal const string Xslt_InvalidVariable = "Xslt_InvalidVariable";

		internal const string Xslt_DupGlobalVariable = "Xslt_DupGlobalVariable";

		internal const string Xslt_DupLocalVariable = "Xslt_DupLocalVariable";

		internal const string Xslt_DupNsAlias = "Xslt_DupNsAlias";

		internal const string Xslt_EmptyAttrValue = "Xslt_EmptyAttrValue";

		internal const string Xslt_EmptyNsAlias = "Xslt_EmptyNsAlias";

		internal const string Xslt_UnknownXsltFunction = "Xslt_UnknownXsltFunction";

		internal const string Xslt_UnsupportedXsltFunction = "Xslt_UnsupportedXsltFunction";

		internal const string Xslt_NoAttributeSet = "Xslt_NoAttributeSet";

		internal const string Xslt_UndefinedKey = "Xslt_UndefinedKey";

		internal const string Xslt_CircularAttributeSet = "Xslt_CircularAttributeSet";

		internal const string Xslt_InvalidCallTemplate = "Xslt_InvalidCallTemplate";

		internal const string Xslt_InvalidPrefix = "Xslt_InvalidPrefix";

		internal const string Xslt_ScriptXsltNamespace = "Xslt_ScriptXsltNamespace";

		internal const string Xslt_ScriptInvalidLanguage = "Xslt_ScriptInvalidLanguage";

		internal const string Xslt_ScriptMixedLanguages = "Xslt_ScriptMixedLanguages";

		internal const string Xslt_ScriptCompileException = "Xslt_ScriptCompileException";

		internal const string Xslt_ScriptNotAtTop = "Xslt_ScriptNotAtTop";

		internal const string Xslt_AssemblyNameHref = "Xslt_AssemblyNameHref";

		internal const string Xslt_ScriptAndExtensionClash = "Xslt_ScriptAndExtensionClash";

		internal const string Xslt_NoDecimalFormat = "Xslt_NoDecimalFormat";

		internal const string Xslt_DecimalFormatSignsNotDistinct = "Xslt_DecimalFormatSignsNotDistinct";

		internal const string Xslt_DecimalFormatRedefined = "Xslt_DecimalFormatRedefined";

		internal const string Xslt_UnknownExtensionElement = "Xslt_UnknownExtensionElement";

		internal const string Xslt_ModeWithoutMatch = "Xslt_ModeWithoutMatch";

		internal const string Xslt_ModeListEmpty = "Xslt_ModeListEmpty";

		internal const string Xslt_ModeListDup = "Xslt_ModeListDup";

		internal const string Xslt_ModeListAll = "Xslt_ModeListAll";

		internal const string Xslt_PriorityWithoutMatch = "Xslt_PriorityWithoutMatch";

		internal const string Xslt_InvalidApplyImports = "Xslt_InvalidApplyImports";

		internal const string Xslt_DuplicateWithParam = "Xslt_DuplicateWithParam";

		internal const string Xslt_ReservedNS = "Xslt_ReservedNS";

		internal const string Xslt_XmlnsAttr = "Xslt_XmlnsAttr";

		internal const string Xslt_NoWhen = "Xslt_NoWhen";

		internal const string Xslt_WhenAfterOtherwise = "Xslt_WhenAfterOtherwise";

		internal const string Xslt_DupOtherwise = "Xslt_DupOtherwise";

		internal const string Xslt_AttributeRedefinition = "Xslt_AttributeRedefinition";

		internal const string Xslt_InvalidMethod = "Xslt_InvalidMethod";

		internal const string Xslt_InvalidEncoding = "Xslt_InvalidEncoding";

		internal const string Xslt_InvalidLanguage = "Xslt_InvalidLanguage";

		internal const string Xslt_InvalidCompareOption = "Xslt_InvalidCompareOption";

		internal const string Xslt_KeyNotAllowed = "Xslt_KeyNotAllowed";

		internal const string Xslt_VariablesNotAllowed = "Xslt_VariablesNotAllowed";

		internal const string Xslt_CurrentNotAllowed = "Xslt_CurrentNotAllowed";

		internal const string Xslt_DocumentFuncProhibited = "Xslt_DocumentFuncProhibited";

		internal const string Xslt_ScriptsProhibited = "Xslt_ScriptsProhibited";

		internal const string Xslt_ItemNull = "Xslt_ItemNull";

		internal const string Xslt_NodeSetNotNode = "Xslt_NodeSetNotNode";

		internal const string Xslt_UnsupportedClrType = "Xslt_UnsupportedClrType";

		internal const string Xslt_NotYetImplemented = "Xslt_NotYetImplemented";

		internal const string Xslt_SchemaDeclaration = "Xslt_SchemaDeclaration";

		internal const string Xslt_SchemaAttribute = "Xslt_SchemaAttribute";

		internal const string Xslt_SchemaAttributeValue = "Xslt_SchemaAttributeValue";

		internal const string Xslt_ElementCntSel = "Xslt_ElementCntSel";

		internal const string Xslt_PerformSortCntSel = "Xslt_PerformSortCntSel";

		internal const string Xslt_RequiredAndSelect = "Xslt_RequiredAndSelect";

		internal const string Xslt_NoSelectNoContent = "Xslt_NoSelectNoContent";

		internal const string Xslt_NonTemplateTunnel = "Xslt_NonTemplateTunnel";

		internal const string Xslt_RequiredOnFunction = "Xslt_RequiredOnFunction";

		internal const string Xslt_ExcludeDefault = "Xslt_ExcludeDefault";

		internal const string Xslt_CollationSyntax = "Xslt_CollationSyntax";

		internal const string Xslt_AnalyzeStringDupChild = "Xslt_AnalyzeStringDupChild";

		internal const string Xslt_AnalyzeStringChildOrder = "Xslt_AnalyzeStringChildOrder";

		internal const string Xslt_AnalyzeStringEmpty = "Xslt_AnalyzeStringEmpty";

		internal const string Xslt_SortStable = "Xslt_SortStable";

		internal const string Xslt_InputTypeAnnotations = "Xslt_InputTypeAnnotations";

		internal const string Coll_BadOptFormat = "Coll_BadOptFormat";

		internal const string Coll_Unsupported = "Coll_Unsupported";

		internal const string Coll_UnsupportedLanguage = "Coll_UnsupportedLanguage";

		internal const string Coll_UnsupportedOpt = "Coll_UnsupportedOpt";

		internal const string Coll_UnsupportedOptVal = "Coll_UnsupportedOptVal";

		internal const string Coll_UnsupportedSortOpt = "Coll_UnsupportedSortOpt";

		internal const string Qil_Validation = "Qil_Validation";

		internal const string XmlIl_TooManyParameters = "XmlIl_TooManyParameters";

		internal const string XmlIl_BadXmlState = "XmlIl_BadXmlState";

		internal const string XmlIl_BadXmlStateAttr = "XmlIl_BadXmlStateAttr";

		internal const string XmlIl_NmspAfterAttr = "XmlIl_NmspAfterAttr";

		internal const string XmlIl_NmspConflict = "XmlIl_NmspConflict";

		internal const string XmlIl_CantResolveEntity = "XmlIl_CantResolveEntity";

		internal const string XmlIl_NoDefaultDocument = "XmlIl_NoDefaultDocument";

		internal const string XmlIl_UnknownDocument = "XmlIl_UnknownDocument";

		internal const string XmlIl_UnknownParam = "XmlIl_UnknownParam";

		internal const string XmlIl_UnknownExtObj = "XmlIl_UnknownExtObj";

		internal const string XmlIl_CantStripNav = "XmlIl_CantStripNav";

		internal const string XmlIl_ExtensionError = "XmlIl_ExtensionError";

		internal const string XmlIl_TopLevelAttrNmsp = "XmlIl_TopLevelAttrNmsp";

		internal const string XmlIl_NoExtensionMethod = "XmlIl_NoExtensionMethod";

		internal const string XmlIl_AmbiguousExtensionMethod = "XmlIl_AmbiguousExtensionMethod";

		internal const string XmlIl_NonPublicExtensionMethod = "XmlIl_NonPublicExtensionMethod";

		internal const string XmlIl_GenericExtensionMethod = "XmlIl_GenericExtensionMethod";

		internal const string XmlIl_ByRefType = "XmlIl_ByRefType";

		internal const string XmlIl_DocumentLoadError = "XmlIl_DocumentLoadError";

		internal const string Xslt_CompileError = "Xslt_CompileError";

		internal const string Xslt_CompileError2 = "Xslt_CompileError2";

		internal const string Xslt_UnsuppFunction = "Xslt_UnsuppFunction";

		internal const string Xslt_NotFirstImport = "Xslt_NotFirstImport";

		internal const string Xslt_UnexpectedKeyword = "Xslt_UnexpectedKeyword";

		internal const string Xslt_InvalidContents = "Xslt_InvalidContents";

		internal const string Xslt_CantResolve = "Xslt_CantResolve";

		internal const string Xslt_SingleRightAvt = "Xslt_SingleRightAvt";

		internal const string Xslt_OpenBracesAvt = "Xslt_OpenBracesAvt";

		internal const string Xslt_OpenLiteralAvt = "Xslt_OpenLiteralAvt";

		internal const string Xslt_NestedAvt = "Xslt_NestedAvt";

		internal const string Xslt_EmptyAvtExpr = "Xslt_EmptyAvtExpr";

		internal const string Xslt_InvalidXPath = "Xslt_InvalidXPath";

		internal const string Xslt_InvalidQName = "Xslt_InvalidQName";

		internal const string Xslt_NoStylesheetLoaded = "Xslt_NoStylesheetLoaded";

		internal const string Xslt_TemplateNoAttrib = "Xslt_TemplateNoAttrib";

		internal const string Xslt_DupVarName = "Xslt_DupVarName";

		internal const string Xslt_WrongNumberArgs = "Xslt_WrongNumberArgs";

		internal const string Xslt_NoNodeSetConversion = "Xslt_NoNodeSetConversion";

		internal const string Xslt_NoNavigatorConversion = "Xslt_NoNavigatorConversion";

		internal const string Xslt_FunctionFailed = "Xslt_FunctionFailed";

		internal const string Xslt_InvalidFormat = "Xslt_InvalidFormat";

		internal const string Xslt_InvalidFormat1 = "Xslt_InvalidFormat1";

		internal const string Xslt_InvalidFormat2 = "Xslt_InvalidFormat2";

		internal const string Xslt_InvalidFormat3 = "Xslt_InvalidFormat3";

		internal const string Xslt_InvalidFormat4 = "Xslt_InvalidFormat4";

		internal const string Xslt_InvalidFormat5 = "Xslt_InvalidFormat5";

		internal const string Xslt_InvalidFormat8 = "Xslt_InvalidFormat8";

		internal const string Xslt_ScriptCompileErrors = "Xslt_ScriptCompileErrors";

		internal const string Xslt_ScriptInvalidPrefix = "Xslt_ScriptInvalidPrefix";

		internal const string Xslt_ScriptDub = "Xslt_ScriptDub";

		internal const string Xslt_ScriptEmpty = "Xslt_ScriptEmpty";

		internal const string Xslt_DupDecimalFormat = "Xslt_DupDecimalFormat";

		internal const string Xslt_CircularReference = "Xslt_CircularReference";

		internal const string Xslt_InvalidExtensionNamespace = "Xslt_InvalidExtensionNamespace";

		internal const string Xslt_InvalidModeAttribute = "Xslt_InvalidModeAttribute";

		internal const string Xslt_MultipleRoots = "Xslt_MultipleRoots";

		internal const string Xslt_ApplyImports = "Xslt_ApplyImports";

		internal const string Xslt_Terminate = "Xslt_Terminate";

		internal const string Xslt_InvalidPattern = "Xslt_InvalidPattern";

		internal const string Xslt_EmptyTagRequired = "Xslt_EmptyTagRequired";

		internal const string Xslt_WrongNamespace = "Xslt_WrongNamespace";

		internal const string Xslt_InvalidFormat6 = "Xslt_InvalidFormat6";

		internal const string Xslt_InvalidFormat7 = "Xslt_InvalidFormat7";

		internal const string Xslt_ScriptMixLang = "Xslt_ScriptMixLang";

		internal const string Xslt_ScriptInvalidLang = "Xslt_ScriptInvalidLang";

		internal const string Xslt_InvalidExtensionPermitions = "Xslt_InvalidExtensionPermitions";

		internal const string Xslt_InvalidParamNamespace = "Xslt_InvalidParamNamespace";

		internal const string Xslt_DuplicateParametr = "Xslt_DuplicateParametr";

		internal const string Xslt_VariableCntSel = "Xslt_VariableCntSel";

		private static Res loader;

		private ResourceManager resources;

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal Res()
		{
			resources = new ResourceManager("System.Xml.Utils", GetType().Assembly);
		}

		private static Res GetLoader()
		{
			if (loader == null)
			{
				Res value = new Res();
				Interlocked.CompareExchange(ref loader, value, null);
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			Res res = GetLoader();
			if (res == null)
			{
				return null;
			}
			string @string = res.resources.GetString(name, Culture);
			if (args != null && args.Length != 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static string GetString(string name, out bool usedFallback)
		{
			usedFallback = false;
			return GetString(name);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System.Xml.Xsl
{
	internal interface ISourceLineInfo
	{
		string Uri { get; }

		bool IsNoSource { get; }

		Location Start { get; }

		Location End { get; }
	}
	internal struct Int32Pair
	{
		private int left;

		private int right;

		public int Left => left;

		public int Right => right;

		public Int32Pair(int left, int right)
		{
			this.left = left;
			this.right = right;
		}

		public override bool Equals(object other)
		{
			if (other is Int32Pair int32Pair)
			{
				if (left == int32Pair.left)
				{
					return right == int32Pair.right;
				}
				return false;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return left.GetHashCode() ^ right.GetHashCode();
		}
	}
	internal struct StringPair
	{
		private string left;

		private string right;

		public string Left => left;

		public string Right => right;

		public StringPair(string left, string right)
		{
			this.left = left;
			this.right = right;
		}
	}
	[DebuggerDisplay("({Line},{Pos})")]
	internal struct Location
	{
		private ulong value;

		public int Line => (int)(value >> 32);

		public int Pos => (int)value;

		public Location(int line, int pos)
		{
			value = (ulong)(((long)line << 32) | (uint)pos);
		}

		public Location(Location that)
		{
			value = that.value;
		}

		public bool LessOrEqual(Location that)
		{
			return value <= that.value;
		}
	}
	[DebuggerDisplay("{Uri} [{StartLine},{StartPos} -- {EndLine},{EndPos}]")]
	internal class SourceLineInfo : ISourceLineInfo
	{
		protected string uriString;

		protected Location start;

		protected Location end;

		protected const int NoSourceMagicNumber = 16707566;

		public static SourceLineInfo NoSource = new SourceLineInfo(string.Empty, 16707566, 0, 16707566, 0);

		public string Uri => uriString;

		public int StartLine => start.Line;

		public int StartPos => start.Pos;

		public int EndLine => end.Line;

		public int EndPos => end.Pos;

		public Location End => end;

		public Location Start => start;

		public bool IsNoSource => StartLine == 16707566;

		public SourceLineInfo(string uriString, int startLine, int startPos, int endLine, int endPos)
			: this(uriString, new Location(startLine, startPos), new Location(endLine, endPos))
		{
		}

		public SourceLineInfo(string uriString, Location start, Location end)
		{
			this.uriString = uriString;
			this.start = start;
			this.end = end;
		}

		[Conditional("DEBUG")]
		public static void Validate(ISourceLineInfo lineInfo)
		{
			if (lineInfo.Start.Line != 0)
			{
				_ = lineInfo.Start.Line;
				_ = 16707566;
			}
		}

		public static string GetFileName(string uriString)
		{
			if (uriString.Length != 0 && System.Uri.TryCreate(uriString, UriKind.Absolute, out var result) && result.IsFile)
			{
				return result.LocalPath;
			}
			return uriString;
		}
	}
	internal class QueryReaderSettings
	{
		private bool validatingReader;

		private XmlReaderSettings xmlReaderSettings;

		private XmlNameTable xmlNameTable;

		private EntityHandling entityHandling;

		private bool namespaces;

		private bool normalization;

		private bool prohibitDtd;

		private WhitespaceHandling whitespaceHandling;

		private XmlResolver xmlResolver;

		public XmlNameTable NameTable
		{
			get
			{
				if (xmlReaderSettings == null)
				{
					return xmlNameTable;
				}
				return xmlReaderSettings.NameTable;
			}
		}

		public QueryReaderSettings(XmlNameTable xmlNameTable)
		{
			xmlReaderSettings = new XmlReaderSettings();
			xmlReaderSettings.NameTable = xmlNameTable;
			xmlReaderSettings.ConformanceLevel = ConformanceLevel.Document;
			xmlReaderSettings.XmlResolver = null;
			xmlReaderSettings.DtdProcessing = DtdProcessing.Prohibit;
			xmlReaderSettings.CloseInput = true;
		}

		public QueryReaderSettings(XmlReader reader)
		{
			if (reader is XmlValidatingReader xmlValidatingReader)
			{
				validatingReader = true;
				reader = xmlValidatingReader.Impl.Reader;
			}
			xmlReaderSettings = reader.Settings;
			if (xmlReaderSettings != null)
			{
				xmlReaderSettings = xmlReaderSettings.Clone();
				xmlReaderSettings.NameTable = reader.NameTable;
				xmlReaderSettings.CloseInput = true;
				xmlReaderSettings.LineNumberOffset = 0;
				xmlReaderSettings.LinePositionOffset = 0;
				if (reader is XmlTextReaderImpl xmlTextReaderImpl)
				{
					xmlReaderSettings.XmlResolver = xmlTextReaderImpl.GetResolver();
				}
				return;
			}
			xmlNameTable = reader.NameTable;
			if (reader is XmlTextReader xmlTextReader)
			{
				XmlTextReaderImpl impl = xmlTextReader.Impl;
				entityHandling = impl.EntityHandling;
				namespaces = impl.Namespaces;
				normalization = impl.Normalization;
				prohibitDtd = impl.DtdProcessing == DtdProcessing.Prohibit;
				whitespaceHandling = impl.WhitespaceHandling;
				xmlResolver = impl.GetResolver();
			}
			else
			{
				entityHandling = EntityHandling.ExpandEntities;
				namespaces = true;
				normalization = true;
				prohibitDtd = true;
				whitespaceHandling = WhitespaceHandling.All;
				xmlResolver = null;
			}
		}

		public XmlReader CreateReader(Stream stream, string baseUri)
		{
			XmlReader xmlReader;
			if (xmlReaderSettings != null)
			{
				xmlReader = XmlReader.Create(stream, xmlReaderSettings, baseUri);
			}
			else
			{
				XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl(baseUri, stream, xmlNameTable);
				xmlTextReaderImpl.EntityHandling = entityHandling;
				xmlTextReaderImpl.Namespaces = namespaces;
				xmlTextReaderImpl.Normalization = normalization;
				xmlTextReaderImpl.DtdProcessing = ((!prohibitDtd) ? DtdProcessing.Parse : DtdProcessing.Prohibit);
				xmlTextReaderImpl.WhitespaceHandling = whitespaceHandling;
				xmlTextReaderImpl.XmlResolver = xmlResolver;
				xmlReader = xmlTextReaderImpl;
			}
			if (validatingReader)
			{
				xmlReader = new XmlValidatingReader(xmlReader);
			}
			return xmlReader;
		}
	}
	internal class XmlILCommand
	{
		private ExecuteDelegate delExec;

		private XmlQueryStaticData staticData;

		public ExecuteDelegate ExecuteDelegate => delExec;

		public XmlQueryStaticData StaticData => staticData;

		public XmlILCommand(ExecuteDelegate delExec, XmlQueryStaticData staticData)
		{
			this.delExec = delExec;
			this.staticData = staticData;
		}

		public IList Evaluate(string contextDocumentUri, XmlResolver dataSources, XsltArgumentList argumentList)
		{
			XmlCachedSequenceWriter xmlCachedSequenceWriter = new XmlCachedSequenceWriter();
			Execute(contextDocumentUri, dataSources, argumentList, xmlCachedSequenceWriter);
			return xmlCachedSequenceWriter.ResultSequence;
		}

		public void Execute(object defaultDocument, XmlResolver dataSources, XsltArgumentList argumentList, XmlWriter writer)
		{
			try
			{
				if (writer is XmlAsyncCheckWriter)
				{
					writer = ((XmlAsyncCheckWriter)writer).CoreWriter;
				}
				if (writer is XmlWellFormedWriter xmlWellFormedWriter && xmlWellFormedWriter.RawWriter != null && xmlWellFormedWriter.WriteState == WriteState.Start && xmlWellFormedWriter.Settings.ConformanceLevel != ConformanceLevel.Document)
				{
					Execute(defaultDocument, dataSources, argumentList, new XmlMergeSequenceWriter(xmlWellFormedWriter.RawWriter));
				}
				else
				{
					Execute(defaultDocument, dataSources, argumentList, new XmlMergeSequenceWriter(new XmlRawWriterWrapper(writer)));
				}
			}
			finally
			{
				writer.Flush();
			}
		}

		private void Execute(object defaultDocument, XmlResolver dataSources, XsltArgumentList argumentList, XmlSequenceWriter results)
		{
			if (dataSources == null)
			{
				dataSources = XmlNullResolver.Singleton;
			}
			delExec(new XmlQueryRuntime(staticData, defaultDocument, dataSources, argumentList, results));
		}
	}
	internal delegate void ExecuteDelegate(XmlQueryRuntime runtime);
	internal class XmlILGenerator
	{
		private QilExpression qil;

		private GenerateHelper helper;

		private XmlILOptimizerVisitor optVisitor;

		private XmlILVisitor xmlIlVisitor;

		private XmlILModule module;

		public XmlILCommand Generate(QilExpression query, TypeBuilder typeBldr)
		{
			qil = query;
			bool useLRE = !qil.IsDebug && typeBldr == null;
			bool isDebug = qil.IsDebug;
			optVisitor = new XmlILOptimizerVisitor(qil, !qil.IsDebug);
			qil = optVisitor.Optimize();
			XmlILModule.CreateModulePermissionSet.Assert();
			if (typeBldr != null)
			{
				module = new XmlILModule(typeBldr);
			}
			else
			{
				module = new XmlILModule(useLRE, isDebug);
			}
			helper = new GenerateHelper(module, qil.IsDebug);
			CreateHelperFunctions();
			MethodInfo methExec = module.DefineMethod("Execute", typeof(void), new Type[0], new string[0], XmlILMethodAttributes.NonUser);
			XmlILMethodAttributes xmlAttrs = ((qil.Root.SourceLine == null) ? XmlILMethodAttributes.NonUser : XmlILMethodAttributes.None);
			MethodInfo methRoot = module.DefineMethod("Root", typeof(void), new Type[0], new string[0], xmlAttrs);
			foreach (EarlyBoundInfo earlyBoundType in qil.EarlyBoundTypes)
			{
				helper.StaticData.DeclareEarlyBound(earlyBoundType.NamespaceUri, earlyBoundType.EarlyBoundType);
			}
			CreateFunctionMetadata(qil.FunctionList);
			CreateGlobalValueMetadata(qil.GlobalVariableList);
			CreateGlobalValueMetadata(qil.GlobalParameterList);
			GenerateExecuteFunction(methExec, methRoot);
			xmlIlVisitor = new XmlILVisitor();
			xmlIlVisitor.Visit(qil, helper, methRoot);
			XmlQueryStaticData staticData = new XmlQueryStaticData(qil.DefaultWriterSettings, qil.WhitespaceRules, helper.StaticData);
			if (typeBldr != null)
			{
				CreateTypeInitializer(staticData);
				module.BakeMethods();
				return null;
			}
			module.BakeMethods();
			ExecuteDelegate delExec = (ExecuteDelegate)module.CreateDelegate("Execute", typeof(ExecuteDelegate));
			return new XmlILCommand(delExec, staticData);
		}

		private void CreateFunctionMetadata(IList<QilNode> funcList)
		{
			foreach (QilFunction func in funcList)
			{
				Type[] array = new Type[func.Arguments.Count];
				string[] array2 = new string[func.Arguments.Count];
				for (int i = 0; i < func.Arguments.Count; i++)
				{
					QilParameter qilParameter = (QilParameter)func.Arguments[i];
					array[i] = XmlILTypeHelper.GetStorageType(qilParameter.XmlType);
					if (qilParameter.DebugName != null)
					{
						array2[i] = qilParameter.DebugName;
					}
				}
				Type returnType = ((!XmlILConstructInfo.Read(func).PushToWriterLast) ? XmlILTypeHelper.GetStorageType(func.XmlType) : typeof(void));
				XmlILMethodAttributes xmlAttrs = ((func.SourceLine == null) ? XmlILMethodAttributes.NonUser : XmlILMethodAttributes.None);
				MethodInfo functionBinding = module.DefineMethod(func.DebugName, returnType, array, array2, xmlAttrs);
				for (int j = 0; j < func.Arguments.Count; j++)
				{
					XmlILAnnotation.Write(func.Arguments[j]).ArgumentPosition = j;
				}
				XmlILAnnotation.Write(func).FunctionBinding = functionBinding;
			}
		}

		private void CreateGlobalValueMetadata(IList<QilNode> globalList)
		{
			foreach (QilReference global in globalList)
			{
				Type storageType = XmlILTypeHelper.GetStorageType(global.XmlType);
				XmlILMethodAttributes xmlAttrs = ((global.SourceLine == null) ? XmlILMethodAttributes.NonUser : XmlILMethodAttributes.None);
				MethodInfo functionBinding = module.DefineMethod(global.DebugName.ToString(), storageType, new Type[0], new string[0], xmlAttrs);
				XmlILAnnotation.Write(global).FunctionBinding = functionBinding;
			}
		}

		private MethodInfo GenerateExecuteFunction(MethodInfo methExec, MethodInfo methRoot)
		{
			helper.MethodBegin(methExec, null, initWriters: false);
			EvaluateGlobalValues(qil.GlobalVariableList);
			EvaluateGlobalValues(qil.GlobalParameterList);
			helper.LoadQueryRuntime();
			helper.Call(methRoot);
			helper.MethodEnd();
			return methExec;
		}

		private void CreateHelperFunctions()
		{
			MethodInfo methInfo = module.DefineMethod("SyncToNavigator", typeof(XPathNavigator), new Type[2]
			{
				typeof(XPathNavigator),
				typeof(XPathNavigator)
			}, new string[2], (XmlILMethodAttributes)3);
			helper.MethodBegin(methInfo, null, initWriters: false);
			Label label = helper.DefineLabel();
			helper.Emit(OpCodes.Ldarg_0);
			helper.Emit(OpCodes.Brfalse, label);
			helper.Emit(OpCodes.Ldarg_0);
			helper.Emit(OpCodes.Ldarg_1);
			helper.Call(XmlILMethods.NavMoveTo);
			helper.Emit(OpCodes.Brfalse, label);
			helper.Emit(OpCodes.Ldarg_0);
			helper.Emit(OpCodes.Ret);
			helper.MarkLabel(label);
			helper.Emit(OpCodes.Ldarg_1);
			helper.Call(XmlILMethods.NavClone);
			helper.MethodEnd();
		}

		private void EvaluateGlobalValues(IList<QilNode> iterList)
		{
			foreach (QilIterator iter in iterList)
			{
				if (qil.IsDebug || OptimizerPatterns.Read(iter).MatchesPattern(OptimizerPatternName.MaybeSideEffects))
				{
					MethodInfo functionBinding = XmlILAnnotation.Write(iter).FunctionBinding;
					helper.LoadQueryRuntime();
					helper.Call(functionBinding);
					helper.Emit(OpCodes.Pop);
				}
			}
		}

		public void CreateTypeInitializer(XmlQueryStaticData staticData)
		{
			staticData.GetObjectData(out var data, out var ebTypes);
			FieldInfo fldInfo = module.DefineInitializedData("__staticData", data);
			FieldInfo fldInfo2 = module.DefineField("staticData", typeof(object));
			FieldInfo fldInfo3 = module.DefineField("ebTypes", typeof(Type[]));
			ConstructorInfo methInfo = module.DefineTypeInitializer();
			helper.MethodBegin(methInfo, null, initWriters: false);
			helper.LoadInteger(data.Length);
			helper.Emit(OpCodes.Newarr, typeof(byte));
			helper.Emit(OpCodes.Dup);
			helper.Emit(OpCodes.Ldtoken, fldInfo);
			helper.Call(XmlILMethods.InitializeArray);
			helper.Emit(OpCodes.Stsfld, fldInfo2);
			if (ebTypes != null)
			{
				LocalBuilder locBldr = helper.DeclareLocal("$$$types", typeof(Type[]));
				helper.LoadInteger(ebTypes.Length);
				helper.Emit(OpCodes.Newarr, typeof(Type));
				helper.Emit(OpCodes.Stloc, locBldr);
				for (int i = 0; i < ebTypes.Length; i++)
				{
					helper.Emit(OpCodes.Ldloc, locBldr);
					helper.LoadInteger(i);
					helper.LoadType(ebTypes[i]);
					helper.Emit(OpCodes.Stelem_Ref);
				}
				helper.Emit(OpCodes.Ldloc, locBldr);
				helper.Emit(OpCodes.Stsfld, fldInfo3);
			}
			helper.MethodEnd();
		}
	}
	[Flags]
	internal enum XmlNodeKindFlags
	{
		None = 0,
		Document = 1,
		Element = 2,
		Attribute = 4,
		Text = 8,
		Comment = 0x10,
		PI = 0x20,
		Namespace = 0x40,
		Content = 0x3A,
		Any = 0x7F
	}
	internal class XmlQualifiedNameTest : XmlQualifiedName
	{
		private bool exclude;

		private const string wildcard = "*";

		private static XmlQualifiedNameTest wc = New("*", "*");

		public static XmlQualifiedNameTest Wildcard => wc;

		public bool IsWildcard => (object)this == Wildcard;

		public bool IsNameWildcard => (object)base.Name == "*";

		public bool IsNamespaceWildcard => (object)base.Namespace == "*";

		private XmlQualifiedNameTest(string name, string ns, bool exclude)
			: base(name, ns)
		{
			this.exclude = exclude;
		}

		public static XmlQualifiedNameTest New(string name, string ns)
		{
			if (ns == null && name == null)
			{
				return Wildcard;
			}
			return new XmlQualifiedNameTest((name == null) ? "*" : name, (ns == null) ? "*" : ns, exclude: false);
		}

		private bool IsNameSubsetOf(XmlQualifiedNameTest other)
		{
			if (!other.IsNameWildcard)
			{
				return base.Name == other.Name;
			}
			return true;
		}

		private bool IsNamespaceSubsetOf(XmlQualifiedNameTest other)
		{
			if (!other.IsNamespaceWildcard && (exclude != other.exclude || !(base.Namespace == other.Namespace)))
			{
				if (other.exclude && !exclude)
				{
					return base.Namespace != other.Namespace;
				}
				return false;
			}
			return true;
		}

		public bool IsSubsetOf(XmlQualifiedNameTest other)
		{
			if (IsNameSubsetOf(other))
			{
				return IsNamespaceSubsetOf(other);
			}
			return false;
		}

		public bool HasIntersection(XmlQualifiedNameTest other)
		{
			if (IsNamespaceSubsetOf(other) || other.IsNamespaceSubsetOf(this))
			{
				if (!IsNameSubsetOf(other))
				{
					return other.IsNameSubsetOf(this);
				}
				return true;
			}
			return false;
		}

		public override string ToString()
		{
			if ((object)this == Wildcard)
			{
				return "*";
			}
			if (base.Namespace.Length == 0)
			{
				return base.Name;
			}
			if ((object)base.Namespace == "*")
			{
				return "*:" + base.Name;
			}
			if (exclude)
			{
				return "{~" + base.Namespace + "}:" + base.Name;
			}
			return "{" + base.Namespace + "}:" + base.Name;
		}
	}
	internal struct XmlQueryCardinality
	{
		private int value;

		private static readonly XmlQueryCardinality[,] cardinalityProduct = new XmlQueryCardinality[8, 8]
		{
			{ None, Zero, None, Zero, None, Zero, None, Zero },
			{ Zero, Zero, Zero, Zero, Zero, Zero, Zero, Zero },
			{ None, Zero, One, ZeroOrOne, More, NotOne, OneOrMore, ZeroOrMore },
			{ Zero, Zero, ZeroOrOne, ZeroOrOne, NotOne, NotOne, ZeroOrMore, ZeroOrMore },
			{ None, Zero, More, NotOne, More, NotOne, More, NotOne },
			{ Zero, Zero, NotOne, NotOne, NotOne, NotOne, NotOne, NotOne },
			{ None, Zero, OneOrMore, ZeroOrMore, More, NotOne, OneOrMore, ZeroOrMore },
			{ Zero, Zero, ZeroOrMore, ZeroOrMore, NotOne, NotOne, ZeroOrMore, ZeroOrMore }
		};

		private static readonly XmlQueryCardinality[,] cardinalitySum = new XmlQueryCardinality[8, 8]
		{
			{ None, Zero, One, ZeroOrOne, More, NotOne, OneOrMore, ZeroOrMore },
			{ Zero, Zero, One, ZeroOrOne, More, NotOne, OneOrMore, ZeroOrMore },
			{ One, One, More, OneOrMore, More, OneOrMore, More, OneOrMore },
			{ ZeroOrOne, ZeroOrOne, OneOrMore, ZeroOrMore, More, ZeroOrMore, OneOrMore, ZeroOrMore },
			{ More, More, More, More, More, More, More, More },
			{ NotOne, NotOne, OneOrMore, ZeroOrMore, More, NotOne, OneOrMore, ZeroOrMore },
			{ OneOrMore, OneOrMore, More, OneOrMore, More, OneOrMore, More, OneOrMore },
			{ ZeroOrMore, ZeroOrMore, OneOrMore, ZeroOrMore, More, ZeroOrMore, OneOrMore, ZeroOrMore }
		};

		private static readonly string[] toString = new string[8] { "", "?", "", "?", "+", "*", "+", "*" };

		private static readonly string[] serialized = new string[8] { "None", "Zero", "One", "ZeroOrOne", "More", "NotOne", "OneOrMore", "ZeroOrMore" };

		public static XmlQueryCardinality None => new XmlQueryCardinality(0);

		public static XmlQueryCardinality Zero => new XmlQueryCardinality(1);

		public static XmlQueryCardinality One => new XmlQueryCardinality(2);

		public static XmlQueryCardinality ZeroOrOne => new XmlQueryCardinality(3);

		public static XmlQueryCardinality More => new XmlQueryCardinality(4);

		public static XmlQueryCardinality NotOne => new XmlQueryCardinality(5);

		public static XmlQueryCardinality OneOrMore => new XmlQueryCardinality(6);

		public static XmlQueryCardinality ZeroOrMore => new XmlQueryCardinality(7);

		private XmlQueryCardinality(int value)
		{
			this.value = value;
		}

		public bool Equals(XmlQueryCardinality other)
		{
			return value == other.value;
		}

		public static bool operator ==(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return left.value == right.value;
		}

		public static bool operator !=(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return left.value != right.value;
		}

		public override bool Equals(object other)
		{
			if (other is XmlQueryCardinality)
			{
				return Equals((XmlQueryCardinality)other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return value;
		}

		public static XmlQueryCardinality operator |(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return new XmlQueryCardinality(left.value | right.value);
		}

		public static XmlQueryCardinality operator &(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return new XmlQueryCardinality(left.value & right.value);
		}

		public static XmlQueryCardinality operator *(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return cardinalityProduct[left.value, right.value];
		}

		public static XmlQueryCardinality operator +(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return cardinalitySum[left.value, right.value];
		}

		public static bool operator <=(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return (left.value & ~right.value) == 0;
		}

		public static bool operator >=(XmlQueryCardinality left, XmlQueryCardinality right)
		{
			return (right.value & ~left.value) == 0;
		}

		public XmlQueryCardinality AtMost()
		{
			return new XmlQueryCardinality(value | (value >> 1) | (value >> 2));
		}

		public bool NeverSubset(XmlQueryCardinality other)
		{
			if (value != 0)
			{
				return (value & other.value) == 0;
			}
			return false;
		}

		public string ToString(string format)
		{
			if (format == "S")
			{
				return serialized[value];
			}
			return ToString();
		}

		public override string ToString()
		{
			return toString[value];
		}

		public XmlQueryCardinality(string s)
		{
			value = 0;
			for (int i = 0; i < serialized.Length; i++)
			{
				if (s == serialized[i])
				{
					value = i;
					break;
				}
			}
		}

		public void GetObjectData(BinaryWriter writer)
		{
			writer.Write((byte)value);
		}

		public XmlQueryCardinality(BinaryReader reader)
			: this(reader.ReadByte())
		{
		}
	}
	internal abstract class XmlQueryType : ListBase<XmlQueryType>
	{
		private enum TypeFlags
		{
			None = 0,
			IsNode = 1,
			IsAtomicValue = 2,
			IsNumeric = 4
		}

		private sealed class BitMatrix
		{
			private ulong[] bits;

			public bool this[int index1, int index2]
			{
				get
				{
					return (bits[index1] & (ulong)(1L << index2)) != 0;
				}
				set
				{
					if (value)
					{
						bits[index1] |= (ulong)(1L << index2);
					}
					else
					{
						bits[index1] &= (ulong)(~(1L << index2));
					}
				}
			}

			public bool this[XmlTypeCode index1, XmlTypeCode index2] => this[(int)index1, (int)index2];

			public BitMatrix(int count)
			{
				bits = new ulong[count];
			}
		}

		private static readonly BitMatrix TypeCodeDerivation;

		private int hashCode;

		private static readonly TypeFlags[] TypeCodeToFlags;

		private static readonly XmlTypeCode[] BaseTypeCodes;

		private static readonly string[] TypeNames;

		public abstract XmlTypeCode TypeCode { get; }

		public abstract XmlQualifiedNameTest NameTest { get; }

		public abstract XmlSchemaType SchemaType { get; }

		public abstract bool IsNillable { get; }

		public abstract XmlNodeKindFlags NodeKinds { get; }

		public abstract bool IsStrict { get; }

		public abstract XmlQueryCardinality Cardinality { get; }

		public abstract XmlQueryType Prime { get; }

		public abstract bool IsNotRtf { get; }

		public abstract bool IsDod { get; }

		public abstract XmlValueConverter ClrMapping { get; }

		public bool IsEmpty => Cardinality <= XmlQueryCardinality.Zero;

		public bool IsSingleton => Cardinality <= XmlQueryCardinality.One;

		public bool MaybeEmpty => XmlQueryCardinality.Zero <= Cardinality;

		public bool MaybeMany => XmlQueryCardinality.More <= Cardinality;

		public bool IsNode => (TypeCodeToFlags[(int)TypeCode] & TypeFlags.IsNode) != 0;

		public bool IsAtomicValue => (TypeCodeToFlags[(int)TypeCode] & TypeFlags.IsAtomicValue) != 0;

		public bool IsNumeric => (TypeCodeToFlags[(int)TypeCode] & TypeFlags.IsNumeric) != 0;

		static XmlQueryType()
		{
			TypeCodeToFlags = new TypeFlags[55]
			{
				(TypeFlags)7,
				TypeFlags.None,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsNode,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				(TypeFlags)6,
				TypeFlags.IsAtomicValue,
				TypeFlags.IsAtomicValue
			};
			BaseTypeCodes = new XmlTypeCode[55]
			{
				XmlTypeCode.None,
				XmlTypeCode.Item,
				XmlTypeCode.Item,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Node,
				XmlTypeCode.Item,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.AnyAtomicType,
				XmlTypeCode.String,
				XmlTypeCode.NormalizedString,
				XmlTypeCode.Token,
				XmlTypeCode.Token,
				XmlTypeCode.Token,
				XmlTypeCode.Name,
				XmlTypeCode.NCName,
				XmlTypeCode.NCName,
				XmlTypeCode.NCName,
				XmlTypeCode.Decimal,
				XmlTypeCode.Integer,
				XmlTypeCode.NonPositiveInteger,
				XmlTypeCode.Integer,
				XmlTypeCode.Long,
				XmlTypeCode.Int,
				XmlTypeCode.Short,
				XmlTypeCode.Integer,
				XmlTypeCode.NonNegativeInteger,
				XmlTypeCode.UnsignedLong,
				XmlTypeCode.UnsignedInt,
				XmlTypeCode.UnsignedShort,
				XmlTypeCode.NonNegativeInteger,
				XmlTypeCode.Duration,
				XmlTypeCode.Duration
			};
			TypeNames = new string[55]
			{
				"none", "item", "node", "document", "element", "attribute", "namespace", "processing-instruction", "comment", "text",
				"xdt:anyAtomicType", "xdt:untypedAtomic", "xs:string", "xs:boolean", "xs:decimal", "xs:float", "xs:double", "xs:duration", "xs:dateTime", "xs:time",
				"xs:date", "xs:gYearMonth", "xs:gYear", "xs:gMonthDay", "xs:gDay", "xs:gMonth", "xs:hexBinary", "xs:base64Binary", "xs:anyUri", "xs:QName",
				"xs:NOTATION", "xs:normalizedString", "xs:token", "xs:language", "xs:NMTOKEN", "xs:Name", "xs:NCName", "xs:ID", "xs:IDREF", "xs:ENTITY",
				"xs:integer", "xs:nonPositiveInteger", "xs:negativeInteger", "xs:long", "xs:int", "xs:short", "xs:byte", "xs:nonNegativeInteger", "xs:unsignedLong", "xs:unsignedInt",
				"xs:unsignedShort", "xs:unsignedByte", "xs:positiveInteger", "xdt:yearMonthDuration", "xdt:dayTimeDuration"
			};
			TypeCodeDerivation = new BitMatrix(BaseTypeCodes.Length);
			for (int i = 0; i < BaseTypeCodes.Length; i++)
			{
				int num = i;
				while (true)
				{
					TypeCodeDerivation[i, num] = true;
					if (BaseTypeCodes[num] == (XmlTypeCode)num)
					{
						break;
					}
					num = (int)BaseTypeCodes[num];
				}
			}
		}

		public bool IsSubtypeOf(XmlQueryType baseType)
		{
			if (!(Cardinality <= baseType.Cardinality) || (!IsDod && baseType.IsDod))
			{
				return false;
			}
			if (!IsDod && baseType.IsDod)
			{
				return false;
			}
			XmlQueryType prime = Prime;
			XmlQueryType prime2 = baseType.Prime;
			if ((object)prime == prime2)
			{
				return true;
			}
			if (prime.Count == 1 && prime2.Count == 1)
			{
				return prime.IsSubtypeOfItemType(prime2);
			}
			foreach (XmlQueryType item in prime)
			{
				bool flag = false;
				foreach (XmlQueryType item2 in prime2)
				{
					if (item.IsSubtypeOfItemType(item2))
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		public bool NeverSubtypeOf(XmlQueryType baseType)
		{
			if (Cardinality.NeverSubset(baseType.Cardinality))
			{
				return true;
			}
			if (MaybeEmpty && baseType.MaybeEmpty)
			{
				return false;
			}
			if (Count == 0)
			{
				return false;
			}
			using (IListEnumerator<XmlQueryType> listEnumerator = GetEnumerator())
			{
				while (listEnumerator.MoveNext())
				{
					XmlQueryType current = listEnumerator.Current;
					foreach (XmlQueryType item in baseType)
					{
						if (current.HasIntersectionItemType(item))
						{
							return false;
						}
					}
				}
			}
			return true;
		}

		public bool Equals(XmlQueryType that)
		{
			if (that == null)
			{
				return false;
			}
			if (Cardinality != that.Cardinality || IsDod != that.IsDod)
			{
				return false;
			}
			XmlQueryType prime = Prime;
			XmlQueryType prime2 = that.Prime;
			if ((object)prime == prime2)
			{
				return true;
			}
			if (prime.Count != prime2.Count)
			{
				return false;
			}
			if (prime.Count == 1)
			{
				if (prime.TypeCode == prime2.TypeCode && prime.NameTest == prime2.NameTest && prime.SchemaType == prime2.SchemaType && prime.IsStrict == prime2.IsStrict)
				{
					return prime.IsNotRtf == prime2.IsNotRtf;
				}
				return false;
			}
			using (IListEnumerator<XmlQueryType> listEnumerator = GetEnumerator())
			{
				while (listEnumerator.MoveNext())
				{
					XmlQueryType current = listEnumerator.Current;
					bool flag = false;
					foreach (XmlQueryType item in that)
					{
						if (current.TypeCode == item.TypeCode && current.NameTest == item.NameTest && current.SchemaType == item.SchemaType && current.IsStrict == item.IsStrict && current.IsNotRtf == item.IsNotRtf)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						return false;
					}
				}
			}
			return true;
		}

		public static bool operator ==(XmlQueryType left, XmlQueryType right)
		{
			return left?.Equals(right) ?? ((object)right == null);
		}

		public static bool operator !=(XmlQueryType left, XmlQueryType right)
		{
			if ((object)left == null)
			{
				return (object)right != null;
			}
			return !left.Equals(right);
		}

		public override bool Equals(object obj)
		{
			XmlQueryType xmlQueryType = obj as XmlQueryType;
			if (xmlQueryType == null)
			{
				return false;
			}
			return Equals(xmlQueryType);
		}

		public override int GetHashCode()
		{
			if (hashCode == 0)
			{
				int num = (int)TypeCode;
				XmlSchemaType schemaType = SchemaType;
				if (schemaType != null)
				{
					num += (num << 7) ^ schemaType.GetHashCode();
				}
				num += (int)((uint)(num << 7) ^ (uint)NodeKinds);
				num += (num << 7) ^ Cardinality.GetHashCode();
				num += (num << 7) ^ (IsStrict ? 1 : 0);
				num -= num >> 17;
				num -= num >> 11;
				num -= num >> 5;
				hashCode = ((num == 0) ? 1 : num);
			}
			return hashCode;
		}

		public override string ToString()
		{
			return ToString("G");
		}

		public string ToString(string format)
		{
			StringBuilder stringBuilder;
			if (format == "S")
			{
				stringBuilder = new StringBuilder();
				stringBuilder.Append(Cardinality.ToString(format));
				stringBuilder.Append(';');
				for (int i = 0; i < Count; i++)
				{
					if (i != 0)
					{
						stringBuilder.Append("|");
					}
					stringBuilder.Append(this[i].TypeCode.ToString());
				}
				stringBuilder.Append(';');
				stringBuilder.Append(IsStrict);
				return stringBuilder.ToString();
			}
			bool flag = format == "X";
			if (Cardinality == XmlQueryCardinality.None)
			{
				return "none";
			}
			if (Cardinality == XmlQueryCardinality.Zero)
			{
				return "empty";
			}
			stringBuilder = new StringBuilder();
			switch (Count)
			{
			case 0:
				stringBuilder.Append("none");
				break;
			case 1:
				stringBuilder.Append(this[0].ItemTypeToString(flag));
				break;
			default:
			{
				string[] array = new string[Count];
				for (int j = 0; j < Count; j++)
				{
					array[j] = this[j].ItemTypeToString(flag);
				}
				Array.Sort(array);
				stringBuilder = new StringBuilder();
				stringBuilder.Append('(');
				stringBuilder.Append(array[0]);
				for (int k = 1; k < array.Length; k++)
				{
					stringBuilder.Append(" | ");
					stringBuilder.Append(array[k]);
				}
				stringBuilder.Append(')');
				break;
			}
			}
			stringBuilder.Append(Cardinality.ToString());
			if (!flag && IsDod)
			{
				stringBuilder.Append('#');
			}
			return stringBuilder.ToString();
		}

		public abstract void GetObjectData(BinaryWriter writer);

		private bool IsSubtypeOfItemType(XmlQueryType baseType)
		{
			XmlSchemaType schemaType = baseType.SchemaType;
			if (TypeCode != baseType.TypeCode)
			{
				if (baseType.IsStrict)
				{
					return false;
				}
				XmlSchemaType builtInSimpleType = XmlSchemaType.GetBuiltInSimpleType(baseType.TypeCode);
				if (builtInSimpleType != null && schemaType != builtInSimpleType)
				{
					return false;
				}
				return TypeCodeDerivation[TypeCode, baseType.TypeCode];
			}
			if (baseType.IsStrict)
			{
				if (IsStrict)
				{
					return SchemaType == schemaType;
				}
				return false;
			}
			if ((IsNotRtf || !baseType.IsNotRtf) && NameTest.IsSubsetOf(baseType.NameTest) && (schemaType == XmlSchemaComplexType.AnyType || XmlSchemaType.IsDerivedFrom(SchemaType, schemaType, XmlSchemaDerivationMethod.Empty)))
			{
				if (IsNillable)
				{
					return baseType.IsNillable;
				}
				return true;
			}
			return false;
		}

		private bool HasIntersectionItemType(XmlQueryType other)
		{
			if (TypeCode == other.TypeCode && (NodeKinds & (XmlNodeKindFlags.Document | XmlNodeKindFlags.Element | XmlNodeKindFlags.Attribute)) != 0)
			{
				if (TypeCode == XmlTypeCode.Node)
				{
					return true;
				}
				if (!NameTest.HasIntersection(other.NameTest))
				{
					return false;
				}
				if (!XmlSchemaType.IsDerivedFrom(SchemaType, other.SchemaType, XmlSchemaDerivationMethod.Empty) && !XmlSchemaType.IsDerivedFrom(other.SchemaType, SchemaType, XmlSchemaDerivationMethod.Empty))
				{
					return false;
				}
				return true;
			}
			if (IsSubtypeOf(other) || other.IsSubtypeOf(this))
			{
				return true;
			}
			return false;
		}

		private string ItemTypeToString(bool isXQ)
		{
			string text;
			if (!IsNode)
			{
				text = ((SchemaType == XmlSchemaComplexType.AnyType) ? TypeNames[(int)TypeCode] : ((!SchemaType.QualifiedName.IsEmpty) ? QNameToString(SchemaType.QualifiedName) : ("<:" + TypeNames[(int)TypeCode])));
			}
			else
			{
				text = TypeNames[(int)TypeCode];
				XmlTypeCode typeCode = TypeCode;
				if (typeCode != XmlTypeCode.Document)
				{
					if ((uint)(typeCode - 4) <= 1u)
					{
						goto IL_0048;
					}
				}
				else
				{
					if (!isXQ)
					{
						goto IL_0048;
					}
					text = text + "{(element" + NameAndType(isXQ: true) + "?&text?&comment?&processing-instruction?)*}";
				}
			}
			goto IL_00b0;
			IL_00b0:
			if (!isXQ && IsStrict)
			{
				text += "=";
			}
			return text;
			IL_0048:
			text += NameAndType(isXQ);
			goto IL_00b0;
		}

		private string NameAndType(bool isXQ)
		{
			string text = NameTest.ToString();
			string text2 = "*";
			if (SchemaType.QualifiedName.IsEmpty)
			{
				text2 = "typeof(" + text + ")";
			}
			else if (isXQ || (SchemaType != XmlSchemaComplexType.AnyType && SchemaType != DatatypeImplementation.AnySimpleType))
			{
				text2 = QNameToString(SchemaType.QualifiedName);
			}
			if (IsNillable)
			{
				text2 += " nillable";
			}
			if (text == "*" && text2 == "*")
			{
				return "";
			}
			return "(" + text + ", " + text2 + ")";
		}

		private static string QNameToString(XmlQualifiedName name)
		{
			if (name.IsEmpty)
			{
				return "*";
			}
			if (name.Namespace.Length == 0)
			{
				return name.Name;
			}
			if (name.Namespace == "http://www.w3.org/2001/XMLSchema")
			{
				return "xs:" + name.Name;
			}
			if (name.Namespace == "http://www.w3.org/2003/11/xpath-datatypes")
			{
				return "xdt:" + name.Name;
			}
			return "{" + name.Namespace + "}" + name.Name;
		}
	}
	internal static class XmlQueryTypeFactory
	{
		private sealed class ItemType : XmlQueryType
		{
			public static readonly XmlQueryType UntypedDocument;

			public static readonly XmlQueryType UntypedElement;

			public static readonly XmlQueryType UntypedAttribute;

			public static readonly XmlQueryType NodeNotRtf;

			private static XmlQueryType[] BuiltInItemTypes;

			private static XmlQueryType[] BuiltInItemTypesStrict;

			private static XmlQueryType[] SpecialBuiltInItemTypes;

			private XmlTypeCode code;

			private XmlQualifiedNameTest nameTest;

			private XmlSchemaType schemaType;

			private bool isNillable;

			private XmlNodeKindFlags nodeKinds;

			private bool isStrict;

			private bool isNotRtf;

			public override XmlTypeCode TypeCode => code;

			public override XmlQualifiedNameTest NameTest => nameTest;

			public override XmlSchemaType SchemaType => schemaType;

			public override bool IsNillable => isNillable;

			public override XmlNodeKindFlags NodeKinds => nodeKinds;

			public override bool IsStrict => isStrict;

			public override bool IsNotRtf => isNotRtf;

			public override bool IsDod => false;

			public override XmlQueryCardinality Cardinality => XmlQueryCardinality.One;

			public override XmlQueryType Prime => this;

			public override XmlValueConverter ClrMapping
			{
				get
				{
					if (base.IsAtomicValue)
					{
						return SchemaType.ValueConverter;
					}
					if (base.IsNode)
					{
						return XmlNodeConverter.Node;
					}
					return XmlAnyConverter.Item;
				}
			}

			public override int Count => 1;

			public override XmlQueryType this[int index]
			{
				get
				{
					if (index != 0)
					{
						throw new IndexOutOfRangeException();
					}
					return this;
				}
				set
				{
					throw new NotSupportedException();
				}
			}

			static ItemType()
			{
				int num = 55;
				BuiltInItemTypes = new XmlQueryType[num];
				BuiltInItemTypesStrict = new XmlQueryType[num];
				for (int i = 0; i < num; i++)
				{
					XmlTypeCode typeCode = (XmlTypeCode)i;
					switch (i)
					{
					case 0:
						BuiltInItemTypes[i] = ChoiceType.None;
						BuiltInItemTypesStrict[i] = ChoiceType.None;
						break;
					case 1:
					case 2:
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.AnyType, isNillable: false, isStrict: false, isNotRtf: false);
						BuiltInItemTypesStrict[i] = BuiltInItemTypes[i];
						break;
					case 3:
					case 4:
					case 6:
					case 7:
					case 8:
					case 9:
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.AnyType, isNillable: false, isStrict: false, isNotRtf: true);
						BuiltInItemTypesStrict[i] = BuiltInItemTypes[i];
						break;
					case 5:
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, DatatypeImplementation.AnySimpleType, isNillable: false, isStrict: false, isNotRtf: true);
						BuiltInItemTypesStrict[i] = BuiltInItemTypes[i];
						break;
					case 10:
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, DatatypeImplementation.AnyAtomicType, isNillable: false, isStrict: false, isNotRtf: true);
						BuiltInItemTypesStrict[i] = BuiltInItemTypes[i];
						break;
					case 11:
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, DatatypeImplementation.UntypedAtomicType, isNillable: false, isStrict: true, isNotRtf: true);
						BuiltInItemTypesStrict[i] = BuiltInItemTypes[i];
						break;
					default:
					{
						XmlSchemaType builtInSimpleType = XmlSchemaType.GetBuiltInSimpleType(typeCode);
						BuiltInItemTypes[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, builtInSimpleType, isNillable: false, isStrict: false, isNotRtf: true);
						BuiltInItemTypesStrict[i] = new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, builtInSimpleType, isNillable: false, isStrict: true, isNotRtf: true);
						break;
					}
					}
				}
				UntypedDocument = new ItemType(XmlTypeCode.Document, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.UntypedAnyType, isNillable: false, isStrict: false, isNotRtf: true);
				UntypedElement = new ItemType(XmlTypeCode.Element, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.UntypedAnyType, isNillable: false, isStrict: false, isNotRtf: true);
				UntypedAttribute = new ItemType(XmlTypeCode.Attribute, XmlQualifiedNameTest.Wildcard, DatatypeImplementation.UntypedAtomicType, isNillable: false, isStrict: false, isNotRtf: true);
				NodeNotRtf = new ItemType(XmlTypeCode.Node, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.AnyType, isNillable: false, isStrict: false, isNotRtf: true);
				SpecialBuiltInItemTypes = new XmlQueryType[4] { UntypedDocument, UntypedElement, UntypedAttribute, NodeNotRtf };
			}

			public static XmlQueryType Create(XmlTypeCode code, bool isStrict)
			{
				if (isStrict)
				{
					return BuiltInItemTypesStrict[(int)code];
				}
				return BuiltInItemTypes[(int)code];
			}

			public static XmlQueryType Create(XmlSchemaSimpleType schemaType, bool isStrict)
			{
				XmlTypeCode typeCode = schemaType.Datatype.TypeCode;
				if (schemaType == XmlSchemaType.GetBuiltInSimpleType(typeCode))
				{
					return Create(typeCode, isStrict);
				}
				return new ItemType(typeCode, XmlQualifiedNameTest.Wildcard, schemaType, isNillable: false, isStrict, isNotRtf: true);
			}

			public static XmlQueryType Create(XmlTypeCode code, XmlQualifiedNameTest nameTest, XmlSchemaType contentType, bool isNillable)
			{
				switch (code)
				{
				case XmlTypeCode.Document:
				case XmlTypeCode.Element:
					if (nameTest.IsWildcard)
					{
						if (contentType == XmlSchemaComplexType.AnyType)
						{
							return Create(code, isStrict: false);
						}
						if (contentType == XmlSchemaComplexType.UntypedAnyType)
						{
							switch (code)
							{
							case XmlTypeCode.Element:
								return UntypedElement;
							case XmlTypeCode.Document:
								return UntypedDocument;
							}
						}
					}
					return new ItemType(code, nameTest, contentType, isNillable, isStrict: false, isNotRtf: true);
				case XmlTypeCode.Attribute:
					if (nameTest.IsWildcard)
					{
						if (contentType == DatatypeImplementation.AnySimpleType)
						{
							return Create(code, isStrict: false);
						}
						if (contentType == DatatypeImplementation.UntypedAtomicType)
						{
							return UntypedAttribute;
						}
					}
					return new ItemType(code, nameTest, contentType, isNillable, isStrict: false, isNotRtf: true);
				default:
					return Create(code, isStrict: false);
				}
			}

			private ItemType(XmlTypeCode code, XmlQualifiedNameTest nameTest, XmlSchemaType schemaType, bool isNillable, bool isStrict, bool isNotRtf)
			{
				this.code = code;
				this.nameTest = nameTest;
				this.schemaType = schemaType;
				this.isNillable = isNillable;
				this.isStrict = isStrict;
				this.isNotRtf = isNotRtf;
				switch (code)
				{
				case XmlTypeCode.Item:
					nodeKinds = XmlNodeKindFlags.Any;
					break;
				case XmlTypeCode.Node:
					nodeKinds = XmlNodeKindFlags.Any;
					break;
				case XmlTypeCode.Document:
					nodeKinds = XmlNodeKindFlags.Document;
					break;
				case XmlTypeCode.Element:
					nodeKinds = XmlNodeKindFlags.Element;
					break;
				case XmlTypeCode.Attribute:
					nodeKinds = XmlNodeKindFlags.Attribute;
					break;
				case XmlTypeCode.Namespace:
					nodeKinds = XmlNodeKindFlags.Namespace;
					break;
				case XmlTypeCode.ProcessingInstruction:
					nodeKinds = XmlNodeKindFlags.PI;
					break;
				case XmlTypeCode.Comment:
					nodeKinds = XmlNodeKindFlags.Comment;
					break;
				case XmlTypeCode.Text:
					nodeKinds = XmlNodeKindFlags.Text;
					break;
				default:
					nodeKinds = XmlNodeKindFlags.None;
					break;
				}
			}

			public override void GetObjectData(BinaryWriter writer)
			{
				sbyte b = (sbyte)code;
				for (int i = 0; i < SpecialBuiltInItemTypes.Length; i++)
				{
					if ((object)this == SpecialBuiltInItemTypes[i])
					{
						b = (sbyte)(~i);
						break;
					}
				}
				writer.Write(b);
				if (0 <= b)
				{
					writer.Write(isStrict);
				}
			}

			public static XmlQueryType Create(BinaryReader reader)
			{
				sbyte b = reader.ReadSByte();
				if (0 <= b)
				{
					return Create((XmlTypeCode)b, reader.ReadBoolean());
				}
				return SpecialBuiltInItemTypes[~b];
			}
		}

		private sealed class ChoiceType : XmlQueryType
		{
			public static readonly XmlQueryType None = new ChoiceType(new List<XmlQueryType>());

			private XmlTypeCode code;

			private XmlSchemaType schemaType;

			private XmlNodeKindFlags nodeKinds;

			private List<XmlQueryType> members;

			private static readonly XmlTypeCode[] NodeKindToTypeCode = new XmlTypeCode[8]
			{
				XmlTypeCode.None,
				XmlTypeCode.Document,
				XmlTypeCode.Element,
				XmlTypeCode.Attribute,
				XmlTypeCode.Text,
				XmlTypeCode.Comment,
				XmlTypeCode.ProcessingInstruction,
				XmlTypeCode.Namespace
			};

			public override XmlTypeCode TypeCode => code;

			public override XmlQualifiedNameTest NameTest => XmlQualifiedNameTest.Wildcard;

			public override XmlSchemaType SchemaType => schemaType;

			public override bool IsNillable => false;

			public override XmlNodeKindFlags NodeKinds => nodeKinds;

			public override bool IsStrict => members.Count == 0;

			public override bool IsNotRtf
			{
				get
				{
					for (int i = 0; i < members.Count; i++)
					{
						if (!members[i].IsNotRtf)
						{
							return false;
						}
					}
					return true;
				}
			}

			public override bool IsDod => false;

			public override XmlQueryCardinality Cardinality
			{
				get
				{
					if (TypeCode != 0)
					{
						return XmlQueryCardinality.One;
					}
					return XmlQueryCardinality.None;
				}
			}

			public override XmlQueryType Prime => this;

			public override XmlValueConverter ClrMapping
			{
				get
				{
					if (code == XmlTypeCode.None || code == XmlTypeCode.Item)
					{
						return XmlAnyConverter.Item;
					}
					if (base.IsAtomicValue)
					{
						return SchemaType.ValueConverter;
					}
					return XmlNodeConverter.Node;
				}
			}

			public override int Count => members.Count;

			public override XmlQueryType this[int index]
			{
				get
				{
					return members[index];
				}
				set
				{
					throw new NotSupportedException();
				}
			}

			public static XmlQueryType Create(XmlNodeKindFlags nodeKinds)
			{
				if (Bits.ExactlyOne((uint)nodeKinds))
				{
					return ItemType.Create(NodeKindToTypeCode[Bits.LeastPosition((uint)nodeKinds)], isStrict: false);
				}
				List<XmlQueryType> list = new List<XmlQueryType>();
				while (nodeKinds != 0)
				{
					list.Add(ItemType.Create(NodeKindToTypeCode[Bits.LeastPosition((uint)nodeKinds)], isStrict: false));
					nodeKinds = (XmlNodeKindFlags)Bits.ClearLeast((uint)nodeKinds);
				}
				return Create(list);
			}

			public static XmlQueryType Create(List<XmlQueryType> members)
			{
				if (members.Count == 0)
				{
					return None;
				}
				if (members.Count == 1)
				{
					return members[0];
				}
				return new ChoiceType(members);
			}

			private ChoiceType(List<XmlQueryType> members)
			{
				this.members = members;
				for (int i = 0; i < members.Count; i++)
				{
					XmlQueryType xmlQueryType = members[i];
					if (code == XmlTypeCode.None)
					{
						code = xmlQueryType.TypeCode;
						schemaType = xmlQueryType.SchemaType;
					}
					else if (base.IsNode && xmlQueryType.IsNode)
					{
						if (code == xmlQueryType.TypeCode)
						{
							if (code == XmlTypeCode.Element)
							{
								schemaType = XmlSchemaComplexType.AnyType;
							}
							else if (code == XmlTypeCode.Attribute)
							{
								schemaType = DatatypeImplementation.AnySimpleType;
							}
						}
						else
						{
							code = XmlTypeCode.Node;
							schemaType = null;
						}
					}
					else if (base.IsAtomicValue && xmlQueryType.IsAtomicValue)
					{
						code = XmlTypeCode.AnyAtomicType;
						schemaType = DatatypeImplementation.AnyAtomicType;
					}
					else
					{
						code = XmlTypeCode.Item;
						schemaType = null;
					}
					nodeKinds |= xmlQueryType.NodeKinds;
				}
			}

			public override void GetObjectData(BinaryWriter writer)
			{
				writer.Write(members.Count);
				for (int i = 0; i < members.Count; i++)
				{
					Serialize(writer, members[i]);
				}
			}

			public static XmlQueryType Create(BinaryReader reader)
			{
				int num = reader.ReadInt32();
				List<XmlQueryType> list = new List<XmlQueryType>(num);
				for (int i = 0; i < num; i++)
				{
					list.Add(Deserialize(reader));
				}
				return Create(list);
			}
		}

		private sealed class SequenceType : XmlQueryType
		{
			public static readonly XmlQueryType Zero = new SequenceType(ChoiceType.None, XmlQueryCardinality.Zero);

			private XmlQueryType prime;

			private XmlQueryCardinality card;

			private XmlValueConverter converter;

			public override XmlTypeCode TypeCode => prime.TypeCode;

			public override XmlQualifiedNameTest NameTest => prime.NameTest;

			public override XmlSchemaType SchemaType => prime.SchemaType;

			public override bool IsNillable => prime.IsNillable;

			public override XmlNodeKindFlags NodeKinds => prime.NodeKinds;

			public override bool IsStrict => prime.IsStrict;

			public override bool IsNotRtf => prime.IsNotRtf;

			public override bool IsDod => (object)this == NodeSDod;

			public override XmlQueryCardinality Cardinality => card;

			public override XmlQueryType Prime => prime;

			public override XmlValueConverter ClrMapping
			{
				get
				{
					if (converter == null)
					{
						converter = XmlListConverter.Create(prime.ClrMapping);
					}
					return converter;
				}
			}

			public override int Count => prime.Count;

			public override XmlQueryType this[int index]
			{
				get
				{
					return prime[index];
				}
				set
				{
					throw new NotSupportedException();
				}
			}

			public static XmlQueryType Create(XmlQueryType prime, XmlQueryCardinality card)
			{
				if (prime.TypeCode == XmlTypeCode.None)
				{
					if (!(XmlQueryCardinality.Zero <= card))
					{
						return None;
					}
					return Zero;
				}
				if (card == XmlQueryCardinality.None)
				{
					return None;
				}
				if (card == XmlQueryCardinality.Zero)
				{
					return Zero;
				}
				if (card == XmlQueryCardinality.One)
				{
					return prime;
				}
				return new SequenceType(prime, card);
			}

			private SequenceType(XmlQueryType prime, XmlQueryCardinality card)
			{
				this.prime = prime;
				this.card = card;
			}

			public override void GetObjectData(BinaryWriter writer)
			{
				writer.Write(IsDod);
				if (!IsDod)
				{
					Serialize(writer, prime);
					card.GetObjectData(writer);
				}
			}

			public static XmlQueryType Create(BinaryReader reader)
			{
				if (reader.ReadBoolean())
				{
					return NodeSDod;
				}
				XmlQueryType xmlQueryType = Deserialize(reader);
				XmlQueryCardinality xmlQueryCardinality = new XmlQueryCardinality(reader);
				return Create(xmlQueryType, xmlQueryCardinality);
			}
		}

		public static readonly XmlQueryType None = ChoiceType.None;

		public static readonly XmlQueryType Empty = SequenceType.Zero;

		public static readonly XmlQueryType Item = Type(XmlTypeCode.Item, isStrict: false);

		public static readonly XmlQueryType ItemS = PrimeProduct(Item, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Node = Type(XmlTypeCode.Node, isStrict: false);

		public static readonly XmlQueryType NodeS = PrimeProduct(Node, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Element = Type(XmlTypeCode.Element, isStrict: false);

		public static readonly XmlQueryType ElementS = PrimeProduct(Element, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Document = Type(XmlTypeCode.Document, isStrict: false);

		public static readonly XmlQueryType DocumentS = PrimeProduct(Document, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Attribute = Type(XmlTypeCode.Attribute, isStrict: false);

		public static readonly XmlQueryType AttributeQ = PrimeProduct(Attribute, XmlQueryCardinality.ZeroOrOne);

		public static readonly XmlQueryType AttributeS = PrimeProduct(Attribute, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Namespace = Type(XmlTypeCode.Namespace, isStrict: false);

		public static readonly XmlQueryType NamespaceS = PrimeProduct(Namespace, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Text = Type(XmlTypeCode.Text, isStrict: false);

		public static readonly XmlQueryType TextS = PrimeProduct(Text, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Comment = Type(XmlTypeCode.Comment, isStrict: false);

		public static readonly XmlQueryType CommentS = PrimeProduct(Comment, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType PI = Type(XmlTypeCode.ProcessingInstruction, isStrict: false);

		public static readonly XmlQueryType PIS = PrimeProduct(PI, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType DocumentOrElement = Choice(Document, Element);

		public static readonly XmlQueryType DocumentOrElementQ = PrimeProduct(DocumentOrElement, XmlQueryCardinality.ZeroOrOne);

		public static readonly XmlQueryType DocumentOrElementS = PrimeProduct(DocumentOrElement, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Content = Choice(Element, Comment, PI, Text);

		public static readonly XmlQueryType ContentS = PrimeProduct(Content, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType DocumentOrContent = Choice(Document, Content);

		public static readonly XmlQueryType DocumentOrContentS = PrimeProduct(DocumentOrContent, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType AttributeOrContent = Choice(Attribute, Content);

		public static readonly XmlQueryType AttributeOrContentS = PrimeProduct(AttributeOrContent, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType AnyAtomicType = Type(XmlTypeCode.AnyAtomicType, isStrict: false);

		public static readonly XmlQueryType AnyAtomicTypeS = PrimeProduct(AnyAtomicType, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType String = Type(XmlTypeCode.String, isStrict: false);

		public static readonly XmlQueryType StringX = Type(XmlTypeCode.String, isStrict: true);

		public static readonly XmlQueryType StringXS = PrimeProduct(StringX, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType Boolean = Type(XmlTypeCode.Boolean, isStrict: false);

		public static readonly XmlQueryType BooleanX = Type(XmlTypeCode.Boolean, isStrict: true);

		public static readonly XmlQueryType Int = Type(XmlTypeCode.Int, isStrict: false);

		public static readonly XmlQueryType IntX = Type(XmlTypeCode.Int, isStrict: true);

		public static readonly XmlQueryType IntXS = PrimeProduct(IntX, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType IntegerX = Type(XmlTypeCode.Integer, isStrict: true);

		public static readonly XmlQueryType LongX = Type(XmlTypeCode.Long, isStrict: true);

		public static readonly XmlQueryType DecimalX = Type(XmlTypeCode.Decimal, isStrict: true);

		public static readonly XmlQueryType FloatX = Type(XmlTypeCode.Float, isStrict: true);

		public static readonly XmlQueryType Double = Type(XmlTypeCode.Double, isStrict: false);

		public static readonly XmlQueryType DoubleX = Type(XmlTypeCode.Double, isStrict: true);

		public static readonly XmlQueryType DateTimeX = Type(XmlTypeCode.DateTime, isStrict: true);

		public static readonly XmlQueryType QNameX = Type(XmlTypeCode.QName, isStrict: true);

		public static readonly XmlQueryType UntypedDocument = ItemType.UntypedDocument;

		public static readonly XmlQueryType UntypedElement = ItemType.UntypedElement;

		public static readonly XmlQueryType UntypedAttribute = ItemType.UntypedAttribute;

		public static readonly XmlQueryType UntypedNode = Choice(UntypedDocument, UntypedElement, UntypedAttribute, Namespace, Text, Comment, PI);

		public static readonly XmlQueryType UntypedNodeS = PrimeProduct(UntypedNode, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType NodeNotRtf = ItemType.NodeNotRtf;

		public static readonly XmlQueryType NodeNotRtfQ = PrimeProduct(NodeNotRtf, XmlQueryCardinality.ZeroOrOne);

		public static readonly XmlQueryType NodeNotRtfS = PrimeProduct(NodeNotRtf, XmlQueryCardinality.ZeroOrMore);

		public static readonly XmlQueryType NodeSDod = PrimeProduct(NodeNotRtf, XmlQueryCardinality.ZeroOrMore);

		private static readonly XmlTypeCode[] NodeKindToTypeCode = new XmlTypeCode[10]
		{
			XmlTypeCode.Document,
			XmlTypeCode.Element,
			XmlTypeCode.Attribute,
			XmlTypeCode.Namespace,
			XmlTypeCode.Text,
			XmlTypeCode.Text,
			XmlTypeCode.Text,
			XmlTypeCode.ProcessingInstruction,
			XmlTypeCode.Comment,
			XmlTypeCode.Node
		};

		public static XmlQueryType Type(XmlTypeCode code, bool isStrict)
		{
			return ItemType.Create(code, isStrict);
		}

		public static XmlQueryType Type(XmlSchemaSimpleType schemaType, bool isStrict)
		{
			if (schemaType.Datatype.Variety == XmlSchemaDatatypeVariety.Atomic)
			{
				if (schemaType == DatatypeImplementation.AnySimpleType)
				{
					return AnyAtomicTypeS;
				}
				return ItemType.Create(schemaType, isStrict);
			}
			while (schemaType.DerivedBy == XmlSchemaDerivationMethod.Restriction)
			{
				schemaType = (XmlSchemaSimpleType)schemaType.BaseXmlSchemaType;
			}
			if (schemaType.DerivedBy == XmlSchemaDerivationMethod.List)
			{
				return PrimeProduct(Type(((XmlSchemaSimpleTypeList)schemaType.Content).BaseItemType, isStrict), XmlQueryCardinality.ZeroOrMore);
			}
			XmlSchemaSimpleType[] baseMemberTypes = ((XmlSchemaSimpleTypeUnion)schemaType.Content).BaseMemberTypes;
			XmlQueryType[] array = new XmlQueryType[baseMemberTypes.Length];
			for (int i = 0; i < baseMemberTypes.Length; i++)
			{
				array[i] = Type(baseMemberTypes[i], isStrict);
			}
			return Choice(array);
		}

		public static XmlQueryType Choice(XmlQueryType left, XmlQueryType right)
		{
			return SequenceType.Create(ChoiceType.Create(PrimeChoice(new List<XmlQueryType>(left), right)), left.Cardinality | right.Cardinality);
		}

		public static XmlQueryType Choice(params XmlQueryType[] types)
		{
			if (types.Length == 0)
			{
				return None;
			}
			if (types.Length == 1)
			{
				return types[0];
			}
			List<XmlQueryType> list = new List<XmlQueryType>(types[0]);
			XmlQueryCardinality cardinality = types[0].Cardinality;
			for (int i = 1; i < types.Length; i++)
			{
				PrimeChoice(list, types[i]);
				cardinality |= types[i].Cardinality;
			}
			return SequenceType.Create(ChoiceType.Create(list), cardinality);
		}

		public static XmlQueryType NodeChoice(XmlNodeKindFlags kinds)
		{
			return ChoiceType.Create(kinds);
		}

		public static XmlQueryType Sequence(XmlQueryType left, XmlQueryType right)
		{
			return SequenceType.Create(ChoiceType.Create(PrimeChoice(new List<XmlQueryType>(left), right)), left.Cardinality + right.Cardinality);
		}

		public static XmlQueryType PrimeProduct(XmlQueryType t, XmlQueryCardinality c)
		{
			if (t.Cardinality == c && !t.IsDod)
			{
				return t;
			}
			return SequenceType.Create(t.Prime, c);
		}

		public static XmlQueryType Product(XmlQueryType t, XmlQueryCardinality c)
		{
			return PrimeProduct(t, t.Cardinality * c);
		}

		public static XmlQueryType AtMost(XmlQueryType t, XmlQueryCardinality c)
		{
			return PrimeProduct(t, c.AtMost());
		}

		private static List<XmlQueryType> PrimeChoice(List<XmlQueryType> accumulator, IList<XmlQueryType> types)
		{
			foreach (XmlQueryType type in types)
			{
				AddItemToChoice(accumulator, type);
			}
			return accumulator;
		}

		private static void AddItemToChoice(List<XmlQueryType> accumulator, XmlQueryType itemType)
		{
			bool flag = true;
			for (int i = 0; i < accumulator.Count; i++)
			{
				if (itemType.IsSubtypeOf(accumulator[i]))
				{
					return;
				}
				if (accumulator[i].IsSubtypeOf(itemType))
				{
					if (flag)
					{
						flag = false;
						accumulator[i] = itemType;
					}
					else
					{
						accumulator.RemoveAt(i);
						i--;
					}
				}
			}
			if (flag)
			{
				accumulator.Add(itemType);
			}
		}

		public static XmlQueryType Type(XPathNodeType kind, XmlQualifiedNameTest nameTest, XmlSchemaType contentType, bool isNillable)
		{
			return ItemType.Create(NodeKindToTypeCode[(int)kind], nameTest, contentType, isNillable);
		}

		[Conditional("DEBUG")]
		public static void CheckSerializability(XmlQueryType type)
		{
			type.GetObjectData(new BinaryWriter(Stream.Null));
		}

		public static void Serialize(BinaryWriter writer, XmlQueryType type)
		{
			sbyte value = (sbyte)((!(type.GetType() == typeof(ItemType))) ? ((type.GetType() == typeof(ChoiceType)) ? 1 : ((!(type.GetType() == typeof(SequenceType))) ? (-1) : 2)) : 0);
			writer.Write(value);
			type.GetObjectData(writer);
		}

		public static XmlQueryType Deserialize(BinaryReader reader)
		{
			return reader.ReadByte() switch
			{
				0 => ItemType.Create(reader), 
				1 => ChoiceType.Create(reader), 
				2 => SequenceType.Create(reader), 
				_ => null, 
			};
		}
	}
	internal static class XPathConvert
	{
		private struct BigNumber
		{
			private uint u0;

			private uint u1;

			private uint u2;

			private int exp;

			private uint error;

			private static readonly BigNumber[] TenPowersPos = new BigNumber[46]
			{
				new BigNumber(0u, 0u, 2684354560u, 4, 0u),
				new BigNumber(0u, 0u, 3355443200u, 7, 0u),
				new BigNumber(0u, 0u, 4194304000u, 10, 0u),
				new BigNumber(0u, 0u, 2621440000u, 14, 0u),
				new BigNumber(0u, 0u, 3276800000u, 17, 0u),
				new BigNumber(0u, 0u, 4096000000u, 20, 0u),
				new BigNumber(0u, 0u, 2560000000u, 24, 0u),
				new BigNumber(0u, 0u, 3200000000u, 27, 0u),
				new BigNumber(0u, 0u, 4000000000u, 30, 0u),
				new BigNumber(0u, 0u, 2500000000u, 34, 0u),
				new BigNumber(0u, 0u, 3125000000u, 37, 0u),
				new BigNumber(0u, 0u, 3906250000u, 40, 0u),
				new BigNumber(0u, 0u, 2441406250u, 44, 0u),
				new BigNumber(0u, 2147483648u, 3051757812u, 47, 0u),
				new BigNumber(0u, 2684354560u, 3814697265u, 50, 0u),
				new BigNumber(0u, 67108864u, 2384185791u, 54, 0u),
				new BigNumber(0u, 3305111552u, 2980232238u, 57, 0u),
				new BigNumber(0u, 1983905792u, 3725290298u, 60, 0u),
				new BigNumber(0u, 2313682944u, 2328306436u, 64, 0u),
				new BigNumber(0u, 2892103680u, 2910383045u, 67, 0u),
				new BigNumber(0u, 393904128u, 3637978807u, 70, 0u),
				new BigNumber(0u, 1856802816u, 2273736754u, 74, 0u),
				new BigNumber(0u, 173519872u, 2842170943u, 77, 0u),
				new BigNumber(0u, 3438125312u, 3552713678u, 80, 0u),
				new BigNumber(0u, 1075086496u, 2220446049u, 84, 0u),
				new BigNumber(0u, 2417599944u, 2775557561u, 87, 0u),
				new BigNumber(0u, 4095741754u, 3469446951u, 90, 0u),
				new BigNumber(1073741824u, 4170451332u, 2168404344u, 94, 0u),
				new BigNumber(1342177280u, 918096869u, 2710505431u, 97, 0u),
				new BigNumber(2751463424u, 73879262u, 3388131789u, 100, 0u),
				new BigNumber(1291845632u, 1166090902u, 4235164736u, 103, 0u),
				new BigNumber(4028628992u, 728806813u, 2646977960u, 107, 0u),
				new BigNumber(1019177842u, 4291798741u, 3262652233u, 213, 1u),
				new BigNumber(3318737231u, 3315274914u, 4021529366u, 319, 1u),
				new BigNumber(3329176428u, 2162789599u, 2478458825u, 426, 1u),
				new BigNumber(1467717739u, 2145785770u, 3054936363u, 532, 1u),
				new BigNumber(2243682900u, 958879082u, 3765499789u, 638, 1u),
				new BigNumber(2193451889u, 3812411695u, 2320668415u, 745, 1u),
				new BigNumber(3720056860u, 2650398349u, 2860444667u, 851, 1u),
				new BigNumber(1937977068u, 1550462860u, 3525770265u, 957, 1u),
				new BigNumber(3869316483u, 4073513845u, 2172923689u, 1064, 1u),
				new BigNumber(1589582007u, 3683650258u, 2678335232u, 1170, 1u),
				new BigNumber(271056885u, 2935532055u, 3301303056u, 1276, 1u),
				new BigNumber(3051704177u, 3920665688u, 4069170183u, 1382, 1u),
				new BigNumber(2817170568u, 3958895571u, 2507819745u, 1489, 1u),
				new BigNumber(2113145460u, 127246946u, 3091126492u, 1595, 1u)
			};

			private static readonly BigNumber[] TenPowersNeg = new BigNumber[46]
			{
				new BigNumber(3435973837u, 3435973836u, 3435973836u, -3, 1u),
				new BigNumber(1030792151u, 1889785610u, 2748779069u, -6, 1u),
				new BigNumber(1683627180u, 2370821947u, 2199023255u, -9, 1u),
				new BigNumber(3552796947u, 3793315115u, 3518437208u, -13, 1u),
				new BigNumber(265257180u, 457671715u, 2814749767u, -16, 1u),
				new BigNumber(2789186122u, 2943117749u, 2251799813u, -19, 1u),
				new BigNumber(1026723958u, 3849994940u, 3602879701u, -23, 1u),
				new BigNumber(4257353003u, 2221002492u, 2882303761u, -26, 1u),
				new BigNumber(828902025u, 917808535u, 2305843009u, -29, 1u),
				new BigNumber(3044230158u, 3186480574u, 3689348814u, -33, 1u),
				new BigNumber(4153371045u, 3408177918u, 2951479051u, -36, 1u),
				new BigNumber(4181690295u, 1867548875u, 2361183241u, -39, 1u),
				new BigNumber(677750258u, 1270091283u, 3777893186u, -43, 1u),
				new BigNumber(1401193666u, 157079567u, 3022314549u, -46, 1u),
				new BigNumber(261961473u, 984657113u, 2417851639u, -49, 1u),
				new BigNumber(1278131816u, 3293438299u, 3868562622u, -53, 1u),
				new BigNumber(163511994u, 916763721u, 3094850098u, -56, 1u),
				new BigNumber(989803054u, 2451397895u, 2475880078u, -59, 1u),
				new BigNumber(724691428u, 3063243173u, 3961408125u, -63, 1u),
				new BigNumber(2297740061u, 2450594538u, 3169126500u, -66, 1u),
				new BigNumber(3556178967u, 1960475630u, 2535301200u, -69, 1u),
				new BigNumber(1394919051u, 3136761009u, 4056481920u, -73, 1u),
				new BigNumber(1974928700u, 2509408807u, 3245185536u, -76, 1u),
				new BigNumber(3297929878u, 1148533586u, 2596148429u, -79, 1u),
				new BigNumber(981720510u, 3555640657u, 4153837486u, -83, 1u),
				new BigNumber(2503363326u, 1985519066u, 3323069989u, -86, 1u),
				new BigNumber(2002690661u, 2447408712u, 2658455991u, -89, 1u),
				new BigNumber(2345311598u, 2197867021u, 4253529586u, -93, 1u),
				new BigNumber(158262360u, 899300158u, 3402823669u, -96, 1u),
				new BigNumber(2703590266u, 1578433585u, 2722258935u, -99, 1u),
				new BigNumber(2162872213u, 1262746868u, 2177807148u, -102, 1u),
				new BigNumber(1742608622u, 1161401530u, 3484491437u, -106, 1u),
				new BigNumber(1059297495u, 2772036005u, 2826955303u, -212, 1u),
				new BigNumber(299617026u, 4252324763u, 2293498615u, -318, 1u),
				new BigNumber(2893853687u, 1690100896u, 3721414268u, -425, 1u),
				new BigNumber(1508712807u, 3681788051u, 3019169939u, -531, 1u),
				new BigNumber(2070087331u, 1411632134u, 2449441655u, -637, 1u),
				new BigNumber(2767765334u, 1244745405u, 3974446316u, -744, 1u),
				new BigNumber(4203811158u, 1668946233u, 3224453925u, -850, 1u),
				new BigNumber(1323526137u, 2204812663u, 2615987810u, -956, 1u),
				new BigNumber(2300620953u, 1199716560u, 4244682903u, -1063, 1u),
				new BigNumber(9598332u, 1190350717u, 3443695891u, -1169, 1u),
				new BigNumber(2296094720u, 2971338839u, 2793858024u, -1275, 1u),
				new BigNumber(441364487u, 1073506470u, 2266646913u, -1381, 1u),
				new BigNumber(2227594191u, 3053929028u, 3677844889u, -1488, 1u),
				new BigNumber(1642812130u, 2030073654u, 2983822260u, -1594, 1u)
			};

			public uint Error => error;

			private bool IsZero
			{
				get
				{
					if (u2 == 0 && u1 == 0)
					{
						return u0 == 0;
					}
					return false;
				}
			}

			public BigNumber(uint u0, uint u1, uint u2, int exp, uint error)
			{
				this.u0 = u0;
				this.u1 = u1;
				this.u2 = u2;
				this.exp = exp;
				this.error = error;
			}

			public BigNumber(FloatingDecimal dec)
			{
				int num = 0;
				int exponent = dec.Exponent;
				int mantissaSize = dec.MantissaSize;
				u2 = (uint)(dec[num] << 28);
				u1 = 0u;
				u0 = 0u;
				exp = 4;
				error = 0u;
				exponent--;
				Normalize();
				while (++num < mantissaSize)
				{
					uint num2 = MulTenAdd(dec[num]);
					exponent--;
					if (num2 != 0)
					{
						Round(num2);
						if (num < mantissaSize - 1)
						{
							error++;
						}
						break;
					}
				}
				if (exponent != 0)
				{
					BigNumber[] array;
					if (exponent < 0)
					{
						array = TenPowersNeg;
						exponent = -exponent;
					}
					else
					{
						array = TenPowersPos;
					}
					int num3 = exponent & 0x1F;
					if (num3 > 0)
					{
						Mul(ref array[num3 - 1]);
					}
					num3 = (exponent >> 5) & 0xF;
					if (num3 > 0)
					{
						Mul(ref array[num3 + 30]);
					}
				}
			}

			private unsafe uint MulTenAdd(uint digit)
			{
				exp += 3;
				uint* ptr = stackalloc uint[5];
				for (int i = 0; i < 5; i++)
				{
					ptr[i] = 0u;
				}
				if (digit != 0)
				{
					int num = 3 - (exp >> 5);
					if (num < 0)
					{
						*ptr = 1u;
					}
					else
					{
						int num2 = exp & 0x1F;
						if (num2 < 4)
						{
							ptr[num + 1] = digit >> num2;
							if (num2 > 0)
							{
								ptr[num] = digit << 32 - num2;
							}
						}
						else
						{
							ptr[num] = digit << 32 - num2;
						}
					}
				}
				ptr[1] += AddU(ref *ptr, u0 << 30);
				ptr[2] += AddU(ref u0, (u0 >> 2) + (u1 << 30));
				if (ptr[1] != 0)
				{
					ptr[2] += AddU(ref u0, ptr[1]);
				}
				ptr[3] += AddU(ref u1, (u1 >> 2) + (u2 << 30));
				if (ptr[2] != 0)
				{
					ptr[3] += AddU(ref u1, ptr[2]);
				}
				ptr[4] = AddU(ref u2, (u2 >> 2) + ptr[3]);
				if (ptr[4] != 0)
				{
					*ptr = (*ptr >> 1) | (*ptr & 1u) | (u0 << 31);
					u0 = (u0 >> 1) | (u1 << 31);
					u1 = (u1 >> 1) | (u2 << 31);
					u2 = (u2 >> 1) | 0x80000000u;
					exp++;
				}
				return *ptr;
			}

			private void Round(uint uExtra)
			{
				if ((uExtra & 0x80000000u) == 0 || ((uExtra & 0x7FFFFFFF) == 0 && (u0 & 1) == 0))
				{
					if (uExtra != 0)
					{
						error++;
					}
					return;
				}
				error++;
				if (AddU(ref u0, 1u) != 0 && AddU(ref u1, 1u) != 0 && AddU(ref u2, 1u) != 0)
				{
					u2 = 2147483648u;
					exp++;
				}
			}

			private void Normalize()
			{
				if (u2 == 0)
				{
					if (u1 == 0)
					{
						if (u0 == 0)
						{
							exp = 0;
							return;
						}
						u2 = u0;
						u0 = 0u;
						exp -= 64;
					}
					else
					{
						u2 = u1;
						u1 = u0;
						u0 = 0u;
						exp -= 32;
					}
				}
				int num;
				if ((num = CbitZeroLeft(u2)) != 0)
				{
					int num2 = 32 - num;
					u2 = (u2 << num) | (u1 >> num2);
					u1 = (u1 << num) | (u0 >> num2);
					u0 <<= num;
					exp -= num;
				}
			}

			private void Mul(ref BigNumber numOp)
			{
				uint num = 0u;
				uint num2 = 0u;
				uint num3 = 0u;
				uint num4 = 0u;
				uint num5 = 0u;
				uint num6 = 0u;
				uint uHi;
				uint num7;
				uint num8;
				uint num9;
				if ((num7 = u0) != 0)
				{
					num8 = MulU(num7, numOp.u0, out uHi);
					num = num8;
					num2 = uHi;
					num8 = MulU(num7, numOp.u1, out uHi);
					num9 = AddU(ref num2, num8);
					AddU(ref num3, uHi + num9);
					num8 = MulU(num7, numOp.u2, out uHi);
					num9 = AddU(ref num3, num8);
					AddU(ref num4, uHi + num9);
				}
				if ((num7 = u1) != 0)
				{
					num8 = MulU(num7, numOp.u0, out uHi);
					num9 = AddU(ref num2, num8);
					if (AddU(ref num3, uHi + num9) != 0 && AddU(ref num4, 1u) != 0)
					{
						AddU(ref num5, 1u);
					}
					num8 = MulU(num7, numOp.u1, out uHi);
					num9 = AddU(ref num3, num8);
					if (AddU(ref num4, uHi + num9) != 0)
					{
						AddU(ref num5, 1u);
					}
					num8 = MulU(num7, numOp.u2, out uHi);
					num9 = AddU(ref num4, num8);
					AddU(ref num5, uHi + num9);
				}
				num7 = u2;
				num8 = MulU(num7, numOp.u0, out uHi);
				num9 = AddU(ref num3, num8);
				if (AddU(ref num4, uHi + num9) != 0 && AddU(ref num5, 1u) != 0)
				{
					AddU(ref num6, 1u);
				}
				num8 = MulU(num7, numOp.u1, out uHi);
				num9 = AddU(ref num4, num8);
				if (AddU(ref num5, uHi + num9) != 0)
				{
					AddU(ref num6, 1u);
				}
				num8 = MulU(num7, numOp.u2, out uHi);
				num9 = AddU(ref num5, num8);
				AddU(ref num6, uHi + num9);
				exp += numOp.exp;
				error += numOp.error;
				if ((num6 & 0x80000000u) == 0)
				{
					if ((num3 & 0x40000000u) != 0 && ((num3 & 0xBFFFFFFFu) != 0 || num2 != 0 || num != 0) && AddU(ref num3, 1073741824u) != 0 && AddU(ref num4, 1u) != 0 && AddU(ref num5, 1u) != 0)
					{
						AddU(ref num6, 1u);
						if ((num6 & 0x80000000u) != 0)
						{
							goto IL_0314;
						}
					}
					u2 = (num6 << 1) | (num5 >> 31);
					u1 = (num5 << 1) | (num4 >> 31);
					u0 = (num4 << 1) | (num3 >> 31);
					exp--;
					error <<= 1;
					if ((num3 & 0x7FFFFFFFu) != 0 || num2 != 0 || num != 0)
					{
						error++;
					}
					return;
				}
				if ((num3 & 0x80000000u) != 0 && ((num4 & (true ? 1u : 0u)) != 0 || (num3 & 0x7FFFFFFFu) != 0 || num2 != 0 || num != 0) && AddU(ref num4, 1u) != 0 && AddU(ref num5, 1u) != 0 && AddU(ref num6, 1u) != 0)
				{
					num6 = 2147483648u;
					exp++;
				}
				goto IL_0314;
				IL_0314:
				u2 = num6;
				u1 = num5;
				u0 = num4;
				if (num3 != 0 || num2 != 0 || num != 0)
				{
					error++;
				}
			}

			public static explicit operator double(BigNumber bn)
			{
				int num = bn.exp + 1022;
				if (num >= 2047)
				{
					return double.PositiveInfinity;
				}
				uint num2;
				uint num3;
				uint num4;
				if (num > 0)
				{
					num2 = (uint)(num << 20) | ((bn.u2 & 0x7FFFFFFF) >> 11);
					num3 = (bn.u2 << 21) | (bn.u1 >> 11);
					num4 = (bn.u1 << 21) | NotZero(bn.u0);
				}
				else if (num > -20)
				{
					int num5 = 12 - num;
					num2 = bn.u2 >> num5;
					num3 = (bn.u2 << 32 - num5) | (bn.u1 >> num5);
					num4 = (bn.u1 << 32 - num5) | NotZero(bn.u0);
				}
				else if (num == -20)
				{
					num2 = 0u;
					num3 = bn.u2;
					num4 = bn.u1 | ((bn.u0 != 0) ? 1u : 0u);
				}
				else if (num > -52)
				{
					int num6 = -num - 20;
					num2 = 0u;
					num3 = bn.u2 >> num6;
					num4 = (bn.u2 << 32 - num6) | NotZero(bn.u1) | NotZero(bn.u0);
				}
				else
				{
					if (num != -52)
					{
						return 0.0;
					}
					num2 = 0u;
					num3 = 0u;
					num4 = bn.u2 | NotZero(bn.u1) | NotZero(bn.u0);
				}
				if ((num4 & 0x80000000u) != 0 && ((num4 & 0x7FFFFFFFu) != 0 || (num3 & (true ? 1u : 0u)) != 0) && AddU(ref num3, 1u) != 0)
				{
					AddU(ref num2, 1u);
				}
				return BitConverter.Int64BitsToDouble((long)(((ulong)num2 << 32) | num3));
			}

			private uint UMod1()
			{
				if (exp <= 0)
				{
					return 0u;
				}
				uint result = u2 >> 32 - exp;
				u2 &= 2147483647u >> exp - 1;
				Normalize();
				return result;
			}

			public void MakeUpperBound()
			{
				uint num = error + 1 >> 1;
				if (num != 0 && AddU(ref u0, num) != 0 && AddU(ref u1, 1u) != 0 && AddU(ref u2, 1u) != 0)
				{
					u2 = 2147483648u;
					u0 = (u0 >> 1) + (u0 & 1);
					exp++;
				}
				error = 0u;
			}

			public void MakeLowerBound()
			{
				uint num = error + 1 >> 1;
				if (num != 0 && AddU(ref u0, 0 - num) == 0 && AddU(ref u1, uint.MaxValue) == 0)
				{
					AddU(ref u2, uint.MaxValue);
					if ((0x80000000u & u2) == 0)
					{
						Normalize();
					}
				}
				error = 0u;
			}

			public static bool DblToRgbFast(double dbl, byte[] mantissa, out int exponent, out int mantissaSize)
			{
				int num = 0;
				uint num2 = DblHi(dbl);
				uint num3 = DblLo(dbl);
				int num4 = (int)((num2 >> 20) & 0x7FF);
				BigNumber bigNumber = default(BigNumber);
				BigNumber bigNumber2;
				BigNumber bigNumber3;
				int num7;
				if (num4 > 0)
				{
					if (num4 >= 1023 && num4 <= 1075 && dbl == Math.Floor(dbl))
					{
						double num5 = dbl;
						int num6 = 0;
						if (num5 >= C10toN[num6 + 8])
						{
							num6 += 8;
						}
						if (num5 >= C10toN[num6 + 4])
						{
							num6 += 4;
						}
						if (num5 >= C10toN[num6 + 2])
						{
							num6 += 2;
						}
						if (num5 >= C10toN[num6 + 1])
						{
							num6++;
						}
						exponent = num6 + 1;
						num7 = 0;
						while (0.0 != num5)
						{
							byte b = (byte)(num5 / C10toN[num6]);
							num5 -= (double)(int)b * C10toN[num6];
							mantissa[num7++] = b;
							num6--;
						}
						mantissaSize = num7;
						goto IL_05a9;
					}
					bigNumber.u2 = 0x80000000u | ((num2 & 0xFFFFFF) << 11) | (num3 >> 21);
					bigNumber.u1 = num3 << 11;
					bigNumber.u0 = 0u;
					bigNumber.exp = num4 - 1022;
					bigNumber.error = 0u;
					bigNumber2 = bigNumber;
					bigNumber2.u1 |= 1024u;
					bigNumber3 = bigNumber;
					if (AddU(u2: (int.MinValue != (int)bigNumber3.u2 || bigNumber3.u1 != 0) ? 4294966272u : 4294966784u, u1: ref bigNumber3.u1) == 0)
					{
						AddU(ref bigNumber3.u2, uint.MaxValue);
						if ((0x80000000u & bigNumber3.u2) == 0)
						{
							bigNumber3.Normalize();
						}
					}
				}
				else
				{
					bigNumber.u2 = num2 & 0xFFFFFu;
					bigNumber.u1 = num3;
					bigNumber.u0 = 0u;
					bigNumber.exp = -1010;
					bigNumber.error = 0u;
					bigNumber2 = bigNumber;
					bigNumber2.u0 = 2147483648u;
					bigNumber3 = bigNumber2;
					if (AddU(ref bigNumber3.u1, uint.MaxValue) == 0)
					{
						AddU(ref bigNumber3.u2, uint.MaxValue);
					}
					bigNumber.Normalize();
					bigNumber2.Normalize();
					bigNumber3.Normalize();
				}
				if (bigNumber2.exp >= 32)
				{
					int num6 = (bigNumber2.exp - 25) * 15 / -TenPowersNeg[45].exp;
					if (num6 > 0)
					{
						BigNumber numOp = TenPowersNeg[30 + num6];
						bigNumber2.Mul(ref numOp);
						bigNumber3.Mul(ref numOp);
						num += num6 * 32;
					}
					if (bigNumber2.exp >= 32)
					{
						num6 = (bigNumber2.exp - 25) * 32 / -TenPowersNeg[31].exp;
						BigNumber numOp = TenPowersNeg[num6 - 1];
						bigNumber2.Mul(ref numOp);
						bigNumber3.Mul(ref numOp);
						num += num6;
					}
				}
				else if (bigNumber2.exp < 1)
				{
					int num6 = (25 - bigNumber2.exp) * 15 / TenPowersPos[45].exp;
					if (num6 > 0)
					{
						BigNumber numOp = TenPowersPos[30 + num6];
						bigNumber2.Mul(ref numOp);
						bigNumber3.Mul(ref numOp);
						num -= num6 * 32;
					}
					if (bigNumber2.exp < 1)
					{
						num6 = (25 - bigNumber2.exp) * 32 / TenPowersPos[31].exp;
						BigNumber numOp = TenPowersPos[num6 - 1];
						bigNumber2.Mul(ref numOp);
						bigNumber3.Mul(ref numOp);
						num -= num6;
					}
				}
				BigNumber bigNumber4 = bigNumber2;
				bigNumber2.MakeUpperBound();
				bigNumber4.MakeLowerBound();
				uint num9 = bigNumber2.UMod1();
				uint num10 = bigNumber4.UMod1();
				BigNumber bigNumber5 = bigNumber3;
				bigNumber5.MakeUpperBound();
				bigNumber3.MakeLowerBound();
				uint num11 = bigNumber5.UMod1();
				uint num12 = bigNumber3.UMod1();
				uint num13 = 1u;
				if (num9 >= 100000000)
				{
					num13 = 100000000u;
					num += 8;
				}
				else
				{
					if (num9 >= 10000)
					{
						num13 = 10000u;
						num += 4;
					}
					if (num9 >= 100 * num13)
					{
						num13 *= 100;
						num += 2;
					}
				}
				if (num9 >= 10 * num13)
				{
					num13 *= 10;
					num++;
				}
				num++;
				num7 = 0;
				while (true)
				{
					byte b = (byte)(num9 / num13);
					num9 %= num13;
					byte b2 = (byte)(num12 / num13);
					num12 %= num13;
					if (b == b2)
					{
						mantissa[num7++] = b;
						if (1 != num13)
						{
							num13 /= 10u;
							continue;
						}
						num13 = 10000000u;
						bigNumber2.Mul(ref TenPowersPos[7]);
						bigNumber2.MakeUpperBound();
						num9 = bigNumber2.UMod1();
						if (num9 < 100000000)
						{
							bigNumber4.Mul(ref TenPowersPos[7]);
							bigNumber4.MakeLowerBound();
							num10 = bigNumber4.UMod1();
							bigNumber5.Mul(ref TenPowersPos[7]);
							bigNumber5.MakeUpperBound();
							num11 = bigNumber5.UMod1();
							bigNumber3.Mul(ref TenPowersPos[7]);
							bigNumber3.MakeLowerBound();
							num12 = bigNumber3.UMod1();
							continue;
						}
					}
					else
					{
						byte b3 = (byte)(num11 / num13 % 10u);
						num11 %= num13;
						byte b4 = (byte)(num10 / num13 % 10u);
						num10 %= num13;
						if (b3 < b4)
						{
							if (b3 == 0 && num11 == 0 && bigNumber5.IsZero && (num3 & 1) == 0)
							{
								break;
							}
							if (b4 - b3 > 1)
							{
								mantissa[num7++] = (byte)((b4 + b3 + 1) / 2);
								break;
							}
							if (num10 != 0 || !bigNumber4.IsZero || (num3 & 1) == 0)
							{
								mantissa[num7++] = b4;
								break;
							}
						}
					}
					exponent = (mantissaSize = 0);
					return false;
				}
				exponent = num;
				mantissaSize = num7;
				goto IL_05a9;
				IL_05a9:
				return true;
			}

			public static void DblToRgbPrecise(double dbl, byte[] mantissa, out int exponent, out int mantissaSize)
			{
				BigInteger bigInteger = new BigInteger();
				BigInteger bigInteger2 = new BigInteger();
				BigInteger bigInteger3 = new BigInteger();
				BigInteger bigInteger4 = new BigInteger();
				BigInteger bigInteger5 = new BigInteger();
				uint num = DblHi(dbl);
				uint num2 = DblLo(dbl);
				bigInteger2.InitFromDigits(1u, 0u, 1);
				bigInteger3.InitFromDigits(1u, 0u, 1);
				int num3 = (int)(((num & 0x7FF00000) >> 20) - 1075);
				uint num4 = num & 0xFFFFFu;
				uint num5 = num2;
				int num6 = 2;
				bool flag = false;
				double num7;
				int num8;
				if (num3 == -1075)
				{
					if (num4 == 0)
					{
						num6 = 1;
					}
					num7 = BitConverter.Int64BitsToDouble(5760103923406864384L);
					num7 *= dbl;
					num8 = (int)(((DblHi(num7) & 0x7FF00000) >> 20) - 1279);
					num = DblHi(num7);
					num &= 0xFFFFFu;
					num |= 0x3FF00000u;
					num7 = BitConverter.Int64BitsToDouble((long)(((ulong)num << 32) | DblLo(num7)));
					num3++;
				}
				else
				{
					num &= 0xFFFFFu;
					num |= 0x3FF00000u;
					num7 = BitConverter.Int64BitsToDouble((long)(((ulong)num << 32) | num2));
					num8 = num3 + 52;
					if (num5 == 0 && num4 == 0 && num3 > -1074)
					{
						num4 = 2097152u;
						num3--;
						flag = true;
					}
					else
					{
						num4 |= 0x100000u;
					}
				}
				num7 = (num7 - 1.5) * 0.289529654602168 + 0.1760912590558 + (double)num8 * 0.301029995663981;
				int num9 = (int)num7;
				if (num7 < 0.0 && num7 != (double)num9)
				{
					num9--;
				}
				int num10;
				int num11;
				if (num3 >= 0)
				{
					num10 = num3;
					num11 = 0;
				}
				else
				{
					num10 = 0;
					num11 = -num3;
				}
				int num12;
				int num13;
				if (num9 >= 0)
				{
					num12 = 0;
					num13 = num9;
					num11 += num9;
				}
				else
				{
					num10 -= num9;
					num12 = -num9;
					num13 = 0;
				}
				if (num10 > 0 && num11 > 0)
				{
					num8 = ((num10 < num11) ? num10 : num11);
					num10 -= num8;
					num11 -= num8;
				}
				num10++;
				num11++;
				if (num12 > 0)
				{
					bigInteger3.MulPow5(num12);
					bigInteger.InitFromBigint(bigInteger3);
					if (1 == num6)
					{
						bigInteger.MulAdd(num5, 0u);
					}
					else
					{
						bigInteger.MulAdd(num4, 0u);
						bigInteger.ShiftLeft(32);
						if (num5 != 0)
						{
							bigInteger5.InitFromBigint(bigInteger3);
							bigInteger5.MulAdd(num5, 0u);
							bigInteger.Add(bigInteger5);
						}
					}
				}
				else
				{
					bigInteger.InitFromDigits(num5, num4, num6);
					if (num13 > 0)
					{
						bigInteger2.MulPow5(num13);
					}
				}
				num8 = CbitZeroLeft(bigInteger2[bigInteger2.Length - 1]);
				num8 = (num8 + 28 - num11) & 0x1F;
				num10 += num8;
				num11 += num8;
				bigInteger.ShiftLeft(num10);
				if (num10 > 1)
				{
					bigInteger3.ShiftLeft(num10 - 1);
				}
				bigInteger2.ShiftLeft(num11);
				BigInteger bigInteger6;
				if (flag)
				{
					bigInteger6 = bigInteger4;
					bigInteger6.InitFromBigint(bigInteger3);
					bigInteger3.ShiftLeft(1);
				}
				else
				{
					bigInteger6 = bigInteger3;
				}
				int num14 = 0;
				while (true)
				{
					byte b = (byte)bigInteger.DivRem(bigInteger2);
					if (num14 == 0 && b == 0)
					{
						num9--;
						goto IL_03c7;
					}
					num8 = bigInteger.CompareTo(bigInteger6);
					int num15;
					if (bigInteger2.CompareTo(bigInteger3) < 0)
					{
						num15 = 1;
					}
					else
					{
						bigInteger5.InitFromBigint(bigInteger2);
						bigInteger5.Subtract(bigInteger3);
						num15 = bigInteger.CompareTo(bigInteger5);
					}
					if (num15 == 0 && (num2 & 1) == 0)
					{
						if (b != 9)
						{
							if (num8 > 0)
							{
								b = (byte)(b + 1);
							}
							mantissa[num14++] = b;
							break;
						}
					}
					else
					{
						if (num8 < 0 || (num8 == 0 && (num2 & 1) == 0))
						{
							if (num15 > 0)
							{
								bigInteger.ShiftLeft(1);
								num15 = bigInteger.CompareTo(bigInteger2);
								if ((num15 > 0 || (num15 == 0 && ((uint)b & (true ? 1u : 0u)) != 0)) && b++ == 9)
								{
									goto IL_0412;
								}
							}
							mantissa[num14++] = b;
							break;
						}
						if (num15 <= 0)
						{
							mantissa[num14++] = b;
							goto IL_03c7;
						}
						if (b != 9)
						{
							mantissa[num14++] = (byte)(b + 1);
							break;
						}
					}
					goto IL_0412;
					IL_0412:
					while (true)
					{
						if (num14 > 0)
						{
							if (mantissa[--num14] != 9)
							{
								mantissa[num14++]++;
								break;
							}
							continue;
						}
						num9++;
						mantissa[num14++] = 1;
						break;
					}
					break;
					IL_03c7:
					bigInteger.MulAdd(10u, 0u);
					bigInteger3.MulAdd(10u, 0u);
					if (bigInteger6 != bigInteger3)
					{
						bigInteger6.MulAdd(10u, 0u);
					}
				}
				exponent = num9 + 1;
				mantissaSize = num14;
			}
		}

		private class BigInteger : IComparable
		{
			private const int InitCapacity = 30;

			private int capacity;

			private int length;

			private uint[] digits;

			public int Length => length;

			public uint this[int idx] => digits[idx];

			public BigInteger()
			{
				capacity = 30;
				length = 0;
				digits = new uint[30];
			}

			[Conditional("DEBUG")]
			private void AssertValidNoVal()
			{
			}

			[Conditional("DEBUG")]
			private void AssertValid()
			{
			}

			private void Ensure(int cu)
			{
				if (cu > capacity)
				{
					cu += cu;
					uint[] array = new uint[cu];
					digits.CopyTo(array, 0);
					digits = array;
					capacity = cu;
				}
			}

			public void InitFromRgu(uint[] rgu, int cu)
			{
				Ensure(cu);
				length = cu;
				for (int i = 0; i < cu; i++)
				{
					digits[i] = rgu[i];
				}
			}

			public void InitFromDigits(uint u0, uint u1, int cu)
			{
				length = cu;
				digits[0] = u0;
				digits[1] = u1;
			}

			public void InitFromBigint(BigInteger biSrc)
			{
				InitFromRgu(biSrc.digits, biSrc.length);
			}

			public void InitFromFloatingDecimal(FloatingDecimal dec)
			{
				int cu = (dec.MantissaSize + 8) / 9;
				int mantissaSize = dec.MantissaSize;
				Ensure(cu);
				length = 0;
				uint num = 0u;
				uint num2 = 1u;
				for (int i = 0; i < mantissaSize; i++)
				{
					if (1000000000 == num2)
					{
						MulAdd(num2, num);
						num2 = 1u;
						num = 0u;
					}
					num2 *= 10;
					num = num * 10 + dec[i];
				}
				MulAdd(num2, num);
			}

			public void MulAdd(uint uMul, uint uAdd)
			{
				for (int i = 0; i < length; i++)
				{
					uint uHi;
					uint u = MulU(digits[i], uMul, out uHi);
					if (uAdd != 0)
					{
						uHi += AddU(ref u, uAdd);
					}
					digits[i] = u;
					uAdd = uHi;
				}
				if (uAdd != 0)
				{
					Ensure(length + 1);
					digits[length++] = uAdd;
				}
			}

			public void MulPow5(int c5)
			{
				int num = (c5 + 12) / 13;
				if (length == 0 || c5 == 0)
				{
					return;
				}
				Ensure(length + num);
				while (c5 >= 13)
				{
					MulAdd(1220703125u, 0u);
					c5 -= 13;
				}
				if (c5 > 0)
				{
					uint num2 = 5u;
					while (--c5 > 0)
					{
						num2 *= 5;
					}
					MulAdd(num2, 0u);
				}
			}

			public void ShiftLeft(int cbit)
			{
				if (cbit == 0 || length == 0)
				{
					return;
				}
				int num = cbit >> 5;
				cbit &= 0x1F;
				uint num3;
				int num2;
				if (cbit > 0)
				{
					num2 = length - 1;
					num3 = digits[num2] >> 32 - cbit;
					while (true)
					{
						digits[num2] <<= cbit;
						if (num2 == 0)
						{
							break;
						}
						digits[num2] |= digits[num2 - 1] >> 32 - cbit;
						num2--;
					}
				}
				else
				{
					num3 = 0u;
				}
				if (num <= 0 && num3 == 0)
				{
					return;
				}
				num2 = length + ((num3 != 0) ? 1 : 0) + num;
				Ensure(num2);
				if (num > 0)
				{
					int num4 = length;
					while (num4-- != 0)
					{
						digits[num + num4] = digits[num4];
					}
					for (int i = 0; i < num; i++)
					{
						digits[i] = 0u;
					}
					length += num;
				}
				if (num3 != 0)
				{
					digits[length++] = num3;
				}
			}

			public void ShiftUsRight(int cu)
			{
				if (cu >= length)
				{
					length = 0;
				}
				else if (cu > 0)
				{
					for (int i = 0; i < length - cu; i++)
					{
						digits[i] = digits[cu + i];
					}
					length -= cu;
				}
			}

			public void ShiftRight(int cbit)
			{
				int num = cbit >> 5;
				cbit &= 0x1F;
				if (num > 0)
				{
					ShiftUsRight(num);
				}
				if (cbit == 0 || length == 0)
				{
					return;
				}
				int num2 = 0;
				while (true)
				{
					digits[num2] >>= cbit;
					if (++num2 >= length)
					{
						break;
					}
					digits[num2 - 1] |= digits[num2] << 32 - cbit;
				}
				if (digits[num2 - 1] == 0)
				{
					length--;
				}
			}

			public int CompareTo(object obj)
			{
				BigInteger bigInteger = (BigInteger)obj;
				if (length > bigInteger.length)
				{
					return 1;
				}
				if (length < bigInteger.length)
				{
					return -1;
				}
				if (length == 0)
				{
					return 0;
				}
				int num = length - 1;
				while (digits[num] == bigInteger.digits[num])
				{
					if (num == 0)
					{
						return 0;
					}
					num--;
				}
				if (digits[num] <= bigInteger.digits[num])
				{
					return -1;
				}
				return 1;
			}

			public void Add(BigInteger bi)
			{
				int num;
				int num2;
				if ((num = length) < (num2 = bi.length))
				{
					num = bi.length;
					num2 = length;
					Ensure(num + 1);
				}
				uint num3 = 0u;
				int i;
				for (i = 0; i < num2; i++)
				{
					if (num3 != 0)
					{
						num3 = AddU(ref digits[i], num3);
					}
					num3 += AddU(ref digits[i], bi.digits[i]);
				}
				if (length < bi.length)
				{
					for (; i < num; i++)
					{
						digits[i] = bi.digits[i];
						if (num3 != 0)
						{
							num3 = AddU(ref digits[i], num3);
						}
					}
					length = num;
				}
				else
				{
					while (num3 != 0 && i < num)
					{
						num3 = AddU(ref digits[i], num3);
						i++;
					}
				}
				if (num3 != 0)
				{
					Ensure(length + 1);
					digits[length++] = num3;
				}
			}

			public void Subtract(BigInteger bi)
			{
				if (length >= bi.length)
				{
					uint num = 1u;
					int i;
					for (i = 0; i < bi.length; i++)
					{
						uint num2 = bi.digits[i];
						if (num2 != 0 || num == 0)
						{
							num = AddU(ref digits[i], ~num2 + num);
						}
					}
					while (num == 0 && i < length)
					{
						num = AddU(ref digits[i], uint.MaxValue);
					}
					if (num != 0)
					{
						if (i == length)
						{
							while (--i >= 0 && digits[i] == 0)
							{
							}
							length = i + 1;
						}
						return;
					}
				}
				length = 0;
			}

			public uint DivRem(BigInteger bi)
			{
				int num = bi.length;
				if (length < num)
				{
					return 0u;
				}
				uint num2 = digits[num - 1] / (bi.digits[num - 1] + 1);
				switch (num2)
				{
				case 1u:
					Subtract(bi);
					break;
				default:
				{
					uint u = 0u;
					uint num3 = 1u;
					int i;
					for (i = 0; i < num; i++)
					{
						uint uHi;
						uint u2 = MulU(num2, bi.digits[i], out uHi);
						u = uHi + AddU(ref u2, u);
						if (u2 != 0 || num3 == 0)
						{
							num3 = AddU(ref digits[i], ~u2 + num3);
						}
					}
					while (--i >= 0 && digits[i] == 0)
					{
					}
					length = i + 1;
					break;
				}
				case 0u:
					break;
				}
				int num4;
				if (num2 < 9 && (num4 = CompareTo(bi)) >= 0)
				{
					num2++;
					if (num4 == 0)
					{
						length = 0;
					}
					else
					{
						Subtract(bi);
					}
				}
				return num2;
			}
		}

		private class FloatingDecimal
		{
			public const int MaxDigits = 50;

			private const int MaxExp10 = 310;

			private const int MinExp10 = -325;

			private int exponent;

			private int sign;

			private int mantissaSize;

			private byte[] mantissa = new byte[50];

			public int Exponent
			{
				get
				{
					return exponent;
				}
				set
				{
					exponent = value;
				}
			}

			public int Sign
			{
				get
				{
					return sign;
				}
				set
				{
					sign = value;
				}
			}

			public byte[] Mantissa => mantissa;

			public int MantissaSize
			{
				get
				{
					return mantissaSize;
				}
				set
				{
					mantissaSize = value;
				}
			}

			public byte this[int ib] => mantissa[ib];

			public FloatingDecimal()
			{
				exponent = 0;
				sign = 1;
				mantissaSize = 0;
			}

			public FloatingDecimal(double dbl)
			{
				InitFromDouble(dbl);
			}

			public static explicit operator double(FloatingDecimal dec)
			{
				int num = dec.mantissaSize;
				int num2 = dec.exponent - num;
				double num4;
				if (num <= 15 && num2 >= -22 && dec.exponent <= 37)
				{
					if (num <= 9)
					{
						uint num3 = 0u;
						for (int i = 0; i < num; i++)
						{
							num3 = num3 * 10 + dec[i];
						}
						num4 = num3;
					}
					else
					{
						num4 = 0.0;
						for (int j = 0; j < num; j++)
						{
							num4 = num4 * 10.0 + (double)(int)dec[j];
						}
					}
					if (num2 > 0)
					{
						if (num2 > 22)
						{
							num4 *= C10toN[num2 - 22];
							num4 *= C10toN[22];
						}
						else
						{
							num4 *= C10toN[num2];
						}
					}
					else if (num2 < 0)
					{
						num4 /= C10toN[-num2];
					}
				}
				else if (dec.exponent >= 310)
				{
					num4 = double.PositiveInfinity;
				}
				else if (dec.exponent <= -325)
				{
					num4 = 0.0;
				}
				else
				{
					BigNumber bigNumber = new BigNumber(dec);
					if (bigNumber.Error == 0)
					{
						num4 = (double)bigNumber;
					}
					else
					{
						BigNumber bigNumber2 = bigNumber;
						bigNumber2.MakeUpperBound();
						BigNumber bigNumber3 = bigNumber;
						bigNumber3.MakeLowerBound();
						num4 = (double)bigNumber2;
						double num5 = (double)bigNumber3;
						if (num4 != num5)
						{
							num4 = dec.AdjustDbl((double)bigNumber);
						}
					}
				}
				if (dec.sign >= 0)
				{
					return num4;
				}
				return 0.0 - num4;
			}

			private double AdjustDbl(double dbl)
			{
				BigInteger bigInteger = new BigInteger();
				BigInteger bigInteger2 = new BigInteger();
				bigInteger.InitFromFloatingDecimal(this);
				int num = exponent - mantissaSize;
				int num3;
				int num5;
				int num4;
				int num2;
				if (num >= 0)
				{
					num3 = (num2 = num);
					num5 = (num4 = 0);
				}
				else
				{
					num3 = (num2 = 0);
					num5 = (num4 = -num);
				}
				uint num6 = DblHi(dbl);
				uint num7 = DblLo(dbl);
				int num8 = (int)((num6 >> 20) & 0x7FF);
				num6 &= 0xFFFFFu;
				uint u = 1u;
				if (num8 != 0)
				{
					if (num6 == 0 && num7 == 0 && 1 != num8)
					{
						u = 2u;
						num6 = 2097152u;
						num8--;
					}
					else
					{
						num6 |= 0x100000u;
					}
					num8 -= 1076;
				}
				else
				{
					num8 = -1075;
				}
				num6 = (num6 << 1) | (num7 >> 31);
				num7 <<= 1;
				int cu = ((num7 != 0 || num6 != 0) ? ((num6 == 0) ? 1 : 2) : 0);
				bigInteger2.InitFromDigits(num7, num6, cu);
				if (num8 >= 0)
				{
					num4 += num8;
				}
				else
				{
					num2 += -num8;
				}
				if (num4 > num2)
				{
					num4 -= num2;
					num2 = 0;
					int num9 = 0;
					while (num4 >= 32 && bigInteger[num9] == 0)
					{
						num4 -= 32;
						num9++;
					}
					if (num9 > 0)
					{
						bigInteger.ShiftUsRight(num9);
					}
					uint num10 = bigInteger[0];
					for (num9 = 0; num9 < num4 && (num10 & (1L << num9)) == 0L; num9++)
					{
					}
					if (num9 > 0)
					{
						num4 -= num9;
						bigInteger.ShiftRight(num9);
					}
				}
				else
				{
					num2 -= num4;
					num4 = 0;
				}
				if (num5 > 0)
				{
					bigInteger2.MulPow5(num5);
				}
				else if (num3 > 0)
				{
					bigInteger.MulPow5(num3);
				}
				if (num4 > 0)
				{
					bigInteger2.ShiftLeft(num4);
				}
				else if (num2 > 0)
				{
					bigInteger.ShiftLeft(num2);
				}
				int num11 = bigInteger2.CompareTo(bigInteger);
				if (num11 == 0)
				{
					return dbl;
				}
				if (num11 > 0)
				{
					if (AddU(ref num7, uint.MaxValue) == 0)
					{
						AddU(ref num6, uint.MaxValue);
					}
					bigInteger2.InitFromDigits(num7, num6, 1 + ((num6 != 0) ? 1 : 0));
					if (num5 > 0)
					{
						bigInteger2.MulPow5(num5);
					}
					if (num4 > 0)
					{
						bigInteger2.ShiftLeft(num4);
					}
					num11 = bigInteger2.CompareTo(bigInteger);
					if (num11 > 0 || (num11 == 0 && (DblLo(dbl) & (true ? 1u : 0u)) != 0))
					{
						dbl = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(dbl) - 1);
					}
				}
				else
				{
					if (AddU(ref num7, u) != 0)
					{
						AddU(ref num6, 1u);
					}
					bigInteger2.InitFromDigits(num7, num6, 1 + ((num6 != 0) ? 1 : 0));
					if (num5 > 0)
					{
						bigInteger2.MulPow5(num5);
					}
					if (num4 > 0)
					{
						bigInteger2.ShiftLeft(num4);
					}
					num11 = bigInteger2.CompareTo(bigInteger);
					if (num11 < 0 || (num11 == 0 && (DblLo(dbl) & (true ? 1u : 0u)) != 0))
					{
						dbl = BitConverter.Int64BitsToDouble(BitConverter.DoubleToInt64Bits(dbl) + 1);
					}
				}
				return dbl;
			}

			private void InitFromDouble(double dbl)
			{
				if (0.0 == dbl || IsSpecial(dbl))
				{
					exponent = 0;
					sign = 1;
					mantissaSize = 0;
					return;
				}
				if (dbl < 0.0)
				{
					sign = -1;
					dbl = 0.0 - dbl;
				}
				else
				{
					sign = 1;
				}
				if (!BigNumber.DblToRgbFast(dbl, mantissa, out exponent, out mantissaSize))
				{
					BigNumber.DblToRgbPrecise(dbl, mantissa, out exponent, out mantissaSize);
				}
			}
		}

		public static readonly double[] C10toN = new double[23]
		{
			1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0, 100000000.0, 1000000000.0,
			10000000000.0, 100000000000.0, 1000000000000.0, 10000000000000.0, 100000000000000.0, 1E+15, 1E+16, 1E+17, 1E+18, 1E+19,
			1E+20, 1E+21, 1E+22
		};

		public static uint DblHi(double dbl)
		{
			return (uint)(BitConverter.DoubleToInt64Bits(dbl) >> 32);
		}

		public static uint DblLo(double dbl)
		{
			return (uint)BitConverter.DoubleToInt64Bits(dbl);
		}

		public static bool IsSpecial(double dbl)
		{
			return (~DblHi(dbl) & 0x7FF00000) == 0;
		}

		public static uint NotZero(uint u)
		{
			if (u == 0)
			{
				return 0u;
			}
			return 1u;
		}

		public static uint AddU(ref uint u1, uint u2)
		{
			u1 += u2;
			if (u1 >= u2)
			{
				return 0u;
			}
			return 1u;
		}

		public static uint MulU(uint u1, uint u2, out uint uHi)
		{
			ulong num = (ulong)u1 * (ulong)u2;
			uHi = (uint)(num >> 32);
			return (uint)num;
		}

		public static int CbitZeroLeft(uint u)
		{
			int num = 0;
			if ((u & 0xFFFF0000u) == 0)
			{
				num += 16;
				u <<= 16;
			}
			if ((u & 0xFF000000u) == 0)
			{
				num += 8;
				u <<= 8;
			}
			if ((u & 0xF0000000u) == 0)
			{
				num += 4;
				u <<= 4;
			}
			if ((u & 0xC0000000u) == 0)
			{
				num += 2;
				u <<= 2;
			}
			if ((u & 0x80000000u) == 0)
			{
				num++;
				u <<= 1;
			}
			return num;
		}

		public static bool IsInteger(double dbl, out int value)
		{
			if (!IsSpecial(dbl))
			{
				int num = (int)dbl;
				double num2 = num;
				if (dbl == num2)
				{
					value = num;
					return true;
				}
			}
			value = 0;
			return false;
		}

		private unsafe static string IntToString(int val)
		{
			char* ptr = stackalloc char[12];
			char* ptr2 = (ptr += 12);
			uint num = (uint)((val < 0) ? (-val) : val);
			while (num >= 10)
			{
				uint num2 = (uint)(1717986919L * (long)num >> 32) >> 2;
				*(--ptr2) = (char)(num - num2 * 10 + 48);
				num = num2;
			}
			*(--ptr2) = (char)(num + 48);
			if (val < 0)
			{
				*(--ptr2) = '-';
			}
			return new string(ptr2, 0, (int)(ptr - ptr2));
		}

		public unsafe static string DoubleToString(double dbl)
		{
			if (IsInteger(dbl, out var value))
			{
				return IntToString(value);
			}
			if (IsSpecial(dbl))
			{
				if (double.IsNaN(dbl))
				{
					return "NaN";
				}
				if (!(dbl < 0.0))
				{
					return "Infinity";
				}
				return "-Infinity";
			}
			FloatingDecimal floatingDecimal = new FloatingDecimal(dbl);
			int num = floatingDecimal.MantissaSize - floatingDecimal.Exponent;
			int num2;
			if (num > 0)
			{
				num2 = ((floatingDecimal.Exponent > 0) ? floatingDecimal.Exponent : 0);
			}
			else
			{
				num2 = floatingDecimal.Exponent;
				num = 0;
			}
			int num3 = num2 + num + 4;
			char* ptr = stackalloc char[num3];
			char* ptr2 = ptr;
			if (floatingDecimal.Sign < 0)
			{
				char* intPtr = ptr2;
				ptr2 = intPtr + 1;
				*intPtr = '-';
			}
			int num4 = floatingDecimal.MantissaSize;
			int num5 = 0;
			if (num2 != 0)
			{
				do
				{
					if (num4 != 0)
					{
						char* intPtr2 = ptr2;
						ptr2 = intPtr2 + 1;
						*intPtr2 = (char)(floatingDecimal[num5++] | 0x30u);
						num4--;
					}
					else
					{
						char* intPtr3 = ptr2;
						ptr2 = intPtr3 + 1;
						*intPtr3 = '0';
					}
				}
				while (--num2 != 0);
			}
			else
			{
				char* intPtr4 = ptr2;
				ptr2 = intPtr4 + 1;
				*intPtr4 = '0';
			}
			if (num != 0)
			{
				char* intPtr5 = ptr2;
				ptr2 = intPtr5 + 1;
				*intPtr5 = '.';
				while (num > num4)
				{
					char* intPtr6 = ptr2;
					ptr2 = intPtr6 + 1;
					*intPtr6 = '0';
					num--;
				}
				while (num4 != 0)
				{
					char* intPtr7 = ptr2;
					ptr2 = intPtr7 + 1;
					*intPtr7 = (char)(floatingDecimal[num5++] | 0x30u);
					num4--;
				}
			}
			return new string(ptr, 0, (int)(ptr2 - ptr));
		}

		private static bool IsAsciiDigit(char ch)
		{
			return (uint)(ch - 48) <= 9u;
		}

		private static bool IsWhitespace(char ch)
		{
			if (ch != ' ' && ch != '\t' && ch != '\n')
			{
				return ch == '\r';
			}
			return true;
		}

		private unsafe static char* SkipWhitespace(char* pch)
		{
			while (IsWhitespace(*pch))
			{
				pch++;
			}
			return pch;
		}

		public unsafe static double StringToDouble(string s)
		{
			fixed (char* ptr = s)
			{
				int num = 0;
				char* ptr2 = ptr;
				char* ptr3 = null;
				int num2 = 1;
				int num3 = 0;
				while (true)
				{
					char* intPtr = ptr2;
					ptr2 = intPtr + 1;
					char c = *intPtr;
					if (!IsAsciiDigit(c))
					{
						if (c != '-')
						{
							if (c == '.')
							{
								if (IsAsciiDigit(*ptr2))
								{
									goto IL_00b7;
								}
							}
							else if (IsWhitespace(c) && num2 > 0)
							{
								ptr2 = SkipWhitespace(ptr2);
								continue;
							}
						}
						else if (num2 >= 0)
						{
							num2 = -1;
							continue;
						}
						return double.NaN;
					}
					if (c == '0')
					{
						do
						{
							char* intPtr2 = ptr2;
							ptr2 = intPtr2 + 1;
							c = *intPtr2;
						}
						while (c == '0');
						if (!IsAsciiDigit(c))
						{
							goto IL_00b1;
						}
					}
					ptr3 = ptr2 - 1;
					do
					{
						char* intPtr3 = ptr2;
						ptr2 = intPtr3 + 1;
						c = *intPtr3;
					}
					while (IsAsciiDigit(c));
					num = (int)(ptr2 - ptr3) - 1;
					goto IL_00b1;
					IL_00b7:
					char* intPtr4 = ptr2;
					ptr2 = intPtr4 + 1;
					c = *intPtr4;
					if (ptr3 == null)
					{
						while (c == '0')
						{
							num3--;
							char* intPtr5 = ptr2;
							ptr2 = intPtr5 + 1;
							c = *intPtr5;
						}
						ptr3 = ptr2 - 1;
					}
					while (IsAsciiDigit(c))
					{
						num3--;
						num++;
						char* intPtr6 = ptr2;
						ptr2 = intPtr6 + 1;
						c = *intPtr6;
					}
					break;
					IL_00b1:
					if (c != '.')
					{
						break;
					}
					goto IL_00b7;
				}
				ptr2--;
				char* ptr4 = ptr + s.Length;
				if (ptr2 < ptr4 && SkipWhitespace(ptr2) < ptr4)
				{
					return double.NaN;
				}
				if (num == 0)
				{
					return 0.0;
				}
				if (num3 == 0 && num <= 9)
				{
					int num4 = *ptr3 & 0xF;
					while (--num != 0)
					{
						ptr3++;
						num4 = num4 * 10 + (*ptr3 & 0xF);
					}
					return (num2 < 0) ? (-num4) : num4;
				}
				if (num > 50)
				{
					ptr2 -= num - 50;
					num3 += num - 50;
					num = 50;
				}
				while (true)
				{
					if (*(--ptr2) == '0')
					{
						num--;
						num3++;
					}
					else if (*ptr2 != '.')
					{
						break;
					}
				}
				ptr2++;
				FloatingDecimal floatingDecimal = new FloatingDecimal();
				floatingDecimal.Exponent = num3 + num;
				floatingDecimal.Sign = num2;
				floatingDecimal.MantissaSize = num;
				fixed (byte* ptr5 = floatingDecimal.Mantissa)
				{
					byte* ptr6 = ptr5;
					for (; ptr3 < ptr2; ptr3++)
					{
						if (*ptr3 != '.')
						{
							*ptr6 = (byte)(*ptr3 & 0xFu);
							ptr6++;
						}
					}
				}
				return (double)floatingDecimal;
			}
		}
	}
	[Serializable]
	internal class XslTransformException : XsltException
	{
		protected XslTransformException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		public XslTransformException(Exception inner, string res, params string[] args)
			: base(CreateMessage(res, args), inner)
		{
		}

		public XslTransformException(string message)
			: base(CreateMessage(message, (string[])null), null)
		{
		}

		internal XslTransformException(string res, params string[] args)
			: this(null, res, args)
		{
		}

		internal static string CreateMessage(string res, params string[] args)
		{
			string text = null;
			try
			{
				text = System.Xml.Utils.Res.GetString(res, args);
			}
			catch (MissingManifestResourceException)
			{
			}
			if (text != null)
			{
				return text;
			}
			StringBuilder stringBuilder = new StringBuilder(res);
			if (args != null && args.Length != 0)
			{
				stringBuilder.Append('(');
				stringBuilder.Append(args[0]);
				for (int i = 1; i < args.Length; i++)
				{
					stringBuilder.Append(", ");
					stringBuilder.Append(args[i]);
				}
				stringBuilder.Append(')');
			}
			return stringBuilder.ToString();
		}

		internal virtual string FormatDetailedMessage()
		{
			return Message;
		}

		public override string ToString()
		{
			string text = GetType().FullName;
			string text2 = FormatDetailedMessage();
			if (text2 != null && text2.Length > 0)
			{
				text = text + ": " + text2;
			}
			if (base.InnerException != null)
			{
				text = text + " ---> " + base.InnerException.ToString() + Environment.NewLine + "   " + CreateMessage("Xml_EndOfInnerExceptionStack");
			}
			if (StackTrace != null)
			{
				text = text + Environment.NewLine + StackTrace;
			}
			return text;
		}
	}
	[Serializable]
	internal class XslLoadException : XslTransformException
	{
		private ISourceLineInfo lineInfo;

		public override string SourceUri
		{
			get
			{
				if (lineInfo == null)
				{
					return null;
				}
				return lineInfo.Uri;
			}
		}

		public override int LineNumber
		{
			get
			{
				if (lineInfo == null)
				{
					return 0;
				}
				return lineInfo.Start.Line;
			}
		}

		public override int LinePosition
		{
			get
			{
				if (lineInfo == null)
				{
					return 0;
				}
				return lineInfo.Start.Pos;
			}
		}

		protected XslLoadException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			if ((bool)info.GetValue("hasLineInfo", typeof(bool)))
			{
				string uriString = (string)info.GetValue("Uri", typeof(string));
				int startLine = (int)info.GetValue("StartLine", typeof(int));
				int startPos = (int)info.GetValue("StartPos", typeof(int));
				int endLine = (int)info.GetValue("EndLine", typeof(int));
				int endPos = (int)info.GetValue("EndPos", typeof(int));
				lineInfo = new SourceLineInfo(uriString, startLine, startPos, endLine, endPos);
			}
		}

		[SecurityPermission(SecurityAction.LinkDemand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("hasLineInfo", lineInfo != null);
			if (lineInfo != null)
			{
				info.AddValue("Uri", lineInfo.Uri);
				info.AddValue("StartLine", lineInfo.Start.Line);
				info.AddValue("StartPos", lineInfo.Start.Pos);
				info.AddValue("EndLine", lineInfo.End.Line);
				info.AddValue("EndPos", lineInfo.End.Pos);
			}
		}

		internal XslLoadException(string res, params string[] args)
			: base(null, res, args)
		{
		}

		internal XslLoadException(Exception inner, ISourceLineInfo lineInfo)
			: base(inner, "Xslt_CompileError2", (string[])null)
		{
			SetSourceLineInfo(lineInfo);
		}

		internal XslLoadException(CompilerError error)
			: base("Xml_UserException", error.ErrorText)
		{
			int line = error.Line;
			int num = error.Column;
			if (line == 0)
			{
				num = 0;
			}
			else if (num == 0)
			{
				num = 1;
			}
			SetSourceLineInfo(new SourceLineInfo(error.FileName, line, num, line, num));
		}

		internal void SetSourceLineInfo(ISourceLineInfo lineInfo)
		{
			this.lineInfo = lineInfo;
		}

		private static string AppendLineInfoMessage(string message, ISourceLineInfo lineInfo)
		{
			if (lineInfo != null)
			{
				string fileName = SourceLineInfo.GetFileName(lineInfo.Uri);
				string text = XslTransformException.CreateMessage("Xml_ErrorFilePosition", fileName, lineInfo.Start.Line.ToString(CultureInfo.InvariantCulture), lineInfo.Start.Pos.ToString(CultureInfo.InvariantCulture));
				if (text != null && text.Length > 0)
				{
					if (message.Length > 0 && !XmlCharType.Instance.IsWhiteSpace(message[message.Length - 1]))
					{
						message += " ";
					}
					message += text;
				}
			}
			return message;
		}

		internal static string CreateMessage(ISourceLineInfo lineInfo, string res, params string[] args)
		{
			return AppendLineInfoMessage(XslTransformException.CreateMessage(res, args), lineInfo);
		}

		internal override string FormatDetailedMessage()
		{
			return AppendLineInfoMessage(Message, lineInfo);
		}
	}
	internal abstract class ListBase<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection
	{
		public abstract int Count { get; }

		public abstract T this[int index] { get; set; }

		public virtual bool IsFixedSize => true;

		public virtual bool IsReadOnly => true;

		bool ICollection.IsSynchronized => IsReadOnly;

		object ICollection.SyncRoot => this;

		object IList.this[int index]
		{
			get
			{
				return this[index];
			}
			set
			{
				if (!IsCompatibleType(value.GetType()))
				{
					throw new ArgumentException(Res.GetString("Arg_IncompatibleParamType"), "value");
				}
				this[index] = (T)value;
			}
		}

		public virtual bool Contains(T value)
		{
			return IndexOf(value) != -1;
		}

		public virtual int IndexOf(T value)
		{
			for (int i = 0; i < Count; i++)
			{
				if (value.Equals(this[i]))
				{
					return i;
				}
			}
			return -1;
		}

		public virtual void CopyTo(T[] array, int index)
		{
			for (int i = 0; i < Count; i++)
			{
				array[index + i] = this[i];
			}
		}

		public virtual IListEnumerator<T> GetEnumerator()
		{
			return new IListEnumerator<T>(this);
		}

		public virtual void Add(T value)
		{
			Insert(Count, value);
		}

		public virtual void Insert(int index, T value)
		{
			throw new NotSupportedException();
		}

		public virtual bool Remove(T value)
		{
			int num = IndexOf(value);
			if (num >= 0)
			{
				RemoveAt(num);
				return true;
			}
			return false;
		}

		public virtual void RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		public virtual void Clear()
		{
			for (int num = Count - 1; num >= 0; num--)
			{
				RemoveAt(num);
			}
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return new IListEnumerator<T>(this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new IListEnumerator<T>(this);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			for (int i = 0; i < Count; i++)
			{
				array.SetValue(this[i], index);
			}
		}

		int IList.Add(object value)
		{
			if (!IsCompatibleType(value.GetType()))
			{
				throw new ArgumentException(Res.GetString("Arg_IncompatibleParamType"), "value");
			}
			Add((T)value);
			return Count - 1;
		}

		void IList.Clear()
		{
			Clear();
		}

		bool IList.Contains(object value)
		{
			if (!IsCompatibleType(value.GetType()))
			{
				return false;
			}
			return Contains((T)value);
		}

		int IList.IndexOf(object value)
		{
			if (!IsCompatibleType(value.GetType()))
			{
				return -1;
			}
			return IndexOf((T)value);
		}

		void IList.Insert(int index, object value)
		{
			if (!IsCompatibleType(value.GetType()))
			{
				throw new ArgumentException(Res.GetString("Arg_IncompatibleParamType"), "value");
			}
			Insert(index, (T)value);
		}

		void IList.Remove(object value)
		{
			if (IsCompatibleType(value.GetType()))
			{
				Remove((T)value);
			}
		}

		private static bool IsCompatibleType(object value)
		{
			if ((value == null && !typeof(T).IsValueType) || value is T)
			{
				return true;
			}
			return false;
		}
	}
	internal struct IListEnumerator<T> : IEnumerator<T>, IDisposable, IEnumerator
	{
		private IList<T> sequence;

		private int index;

		private T current;

		public T Current => current;

		object IEnumerator.Current
		{
			get
			{
				if (index == 0)
				{
					throw new InvalidOperationException(Res.GetString("Sch_EnumNotStarted", string.Empty));
				}
				if (index > sequence.Count)
				{
					throw new InvalidOperationException(Res.GetString("Sch_EnumFinished", string.Empty));
				}
				return current;
			}
		}

		public IListEnumerator(IList<T> sequence)
		{
			this.sequence = sequence;
			index = 0;
			current = default(T);
		}

		public void Dispose()
		{
		}

		public bool MoveNext()
		{
			if (index < sequence.Count)
			{
				current = sequence[index];
				index++;
				return true;
			}
			current = default(T);
			return false;
		}

		void IEnumerator.Reset()
		{
			index = 0;
			current = default(T);
		}
	}
	internal interface IErrorHelper
	{
		void ReportError(string res, params string[] args);

		void ReportWarning(string res, params string[] args);
	}
	[Flags]
	internal enum XslFlags
	{
		None = 0,
		String = 1,
		Number = 2,
		Boolean = 4,
		Node = 8,
		Nodeset = 0x10,
		Rtf = 0x20,
		TypeFilter = 0x3F,
		AnyType = 0x3F,
		Current = 0x100,
		Position = 0x200,
		Last = 0x400,
		FocusFilter = 0x700,
		FullFocus = 0x700,
		HasCalls = 0x1000,
		MayBeDefault = 0x2000,
		SideEffects = 0x4000,
		Stop = 0x8000
	}
}
namespace System.Xml.Xsl.XsltOld
{
	internal abstract class Action
	{
		internal const int Initialized = 0;

		internal const int Finished = -1;

		internal abstract void Execute(Processor processor, ActionFrame frame);

		internal virtual void ReplaceNamespaceAlias(Compiler compiler)
		{
		}

		internal virtual DbgData GetDbgData(ActionFrame frame)
		{
			return DbgData.Empty;
		}
	}
	internal class ActionFrame : IStackFrame
	{
		private class XPathSortArrayIterator : XPathArrayIterator
		{
			public override XPathNavigator Current => ((MS.Internal.Xml.XPath.SortKey)list[index - 1]).Node;

			public XPathSortArrayIterator(List<MS.Internal.Xml.XPath.SortKey> list)
				: base(list)
			{
			}

			public XPathSortArrayIterator(XPathSortArrayIterator it)
				: base(it)
			{
			}

			public override XPathNodeIterator Clone()
			{
				return new XPathSortArrayIterator(this);
			}
		}

		private int state;

		private int counter;

		private object[] variables;

		private Hashtable withParams;

		private Action action;

		private ActionFrame container;

		private int currentAction;

		private XPathNodeIterator nodeSet;

		private XPathNodeIterator newNodeSet;

		private PrefixQName calulatedName;

		private string storedOutput;

		internal PrefixQName CalulatedName
		{
			get
			{
				return calulatedName;
			}
			set
			{
				calulatedName = value;
			}
		}

		internal string StoredOutput
		{
			get
			{
				return storedOutput;
			}
			set
			{
				storedOutput = value;
			}
		}

		internal int State
		{
			get
			{
				return state;
			}
			set
			{
				state = value;
			}
		}

		internal int Counter
		{
			get
			{
				return counter;
			}
			set
			{
				counter = value;
			}
		}

		internal ActionFrame Container => container;

		internal XPathNavigator Node
		{
			get
			{
				if (nodeSet != null)
				{
					return nodeSet.Current;
				}
				return null;
			}
		}

		internal XPathNodeIterator NodeSet => nodeSet;

		internal XPathNodeIterator NewNodeSet => newNodeSet;

		XPathNavigator IStackFrame.Instruction
		{
			get
			{
				if (action == null)
				{
					return null;
				}
				return action.GetDbgData(this).StyleSheet;
			}
		}

		XPathNodeIterator IStackFrame.NodeSet => nodeSet.Clone();

		internal int IncrementCounter()
		{
			return ++counter;
		}

		internal void AllocateVariables(int count)
		{
			if (0 < count)
			{
				variables = new object[count];
			}
			else
			{
				variables = null;
			}
		}

		internal object GetVariable(int index)
		{
			return variables[index];
		}

		internal void SetVariable(int index, object value)
		{
			variables[index] = value;
		}

		internal void SetParameter(XmlQualifiedName name, object value)
		{
			if (withParams == null)
			{
				withParams = new Hashtable();
			}
			withParams[name] = value;
		}

		internal void ResetParams()
		{
			if (withParams != null)
			{
				withParams.Clear();
			}
		}

		internal object GetParameter(XmlQualifiedName name)
		{
			if (withParams != null)
			{
				return withParams[name];
			}
			return null;
		}

		internal void InitNodeSet(XPathNodeIterator nodeSet)
		{
			this.nodeSet = nodeSet;
		}

		internal void InitNewNodeSet(XPathNodeIterator nodeSet)
		{
			newNodeSet = nodeSet;
		}

		internal void SortNewNodeSet(Processor proc, ArrayList sortarray)
		{
			int count = sortarray.Count;
			XPathSortComparer xPathSortComparer = new XPathSortComparer(count);
			for (int i = 0; i < count; i++)
			{
				Sort sort = (Sort)sortarray[i];
				Query compiledQuery = proc.GetCompiledQuery(sort.select);
				xPathSortComparer.AddSort(compiledQuery, new XPathComparerHelper(sort.order, sort.caseOrder, sort.lang, sort.dataType));
			}
			List<MS.Internal.Xml.XPath.SortKey> list = new List<MS.Internal.Xml.XPath.SortKey>();
			while (NewNextNode(proc))
			{
				XPathNodeIterator xPathNodeIterator = nodeSet;
				nodeSet = newNodeSet;
				MS.Internal.Xml.XPath.SortKey sortKey = new MS.Internal.Xml.XPath.SortKey(count, list.Count, newNodeSet.Current.Clone());
				for (int j = 0; j < count; j++)
				{
					sortKey[j] = xPathSortComparer.Expression(j).Evaluate(newNodeSet);
				}
				list.Add(sortKey);
				nodeSet = xPathNodeIterator;
			}
			list.Sort(xPathSortComparer);
			newNodeSet = new XPathSortArrayIterator(list);
		}

		internal void Finished()
		{
			State = -1;
		}

		internal void Inherit(ActionFrame parent)
		{
			variables = parent.variables;
		}

		private void Init(Action action, ActionFrame container, XPathNodeIterator nodeSet)
		{
			state = 0;
			this.action = action;
			this.container = container;
			currentAction = 0;
			this.nodeSet = nodeSet;
			newNodeSet = null;
		}

		internal void Init(Action action, XPathNodeIterator nodeSet)
		{
			Init(action, null, nodeSet);
		}

		internal void Init(ActionFrame containerFrame, XPathNodeIterator nodeSet)
		{
			Init(containerFrame.GetAction(0), containerFrame, nodeSet);
		}

		internal void SetAction(Action action)
		{
			SetAction(action, 0);
		}

		internal void SetAction(Action action, int state)
		{
			this.action = action;
			this.state = state;
		}

		private Action GetAction(int actionIndex)
		{
			return ((ContainerAction)action).GetAction(actionIndex);
		}

		internal void Exit()
		{
			Finished();
			container = null;
		}

		internal bool Execute(Processor processor)
		{
			if (action == null)
			{
				return true;
			}
			action.Execute(processor, this);
			if (State == -1)
			{
				if (container != null)
				{
					currentAction++;
					action = container.GetAction(currentAction);
					State = 0;
				}
				else
				{
					action = null;
				}
				return action == null;
			}
			return false;
		}

		internal bool NextNode(Processor proc)
		{
			bool flag = nodeSet.MoveNext();
			if (flag && proc.Stylesheet.Whitespace)
			{
				XPathNodeType nodeType = nodeSet.Current.NodeType;
				if (nodeType == XPathNodeType.Whitespace)
				{
					XPathNavigator xPathNavigator = nodeSet.Current.Clone();
					bool flag2;
					do
					{
						xPathNavigator.MoveTo(nodeSet.Current);
						xPathNavigator.MoveToParent();
						flag2 = !proc.Stylesheet.PreserveWhiteSpace(proc, xPathNavigator) && (flag = nodeSet.MoveNext());
						nodeType = nodeSet.Current.NodeType;
					}
					while (flag2 && nodeType == XPathNodeType.Whitespace);
				}
			}
			return flag;
		}

		internal bool NewNextNode(Processor proc)
		{
			bool flag = newNodeSet.MoveNext();
			if (flag && proc.Stylesheet.Whitespace)
			{
				XPathNodeType nodeType = newNodeSet.Current.NodeType;
				if (nodeType == XPathNodeType.Whitespace)
				{
					XPathNavigator xPathNavigator = newNodeSet.Current.Clone();
					bool flag2;
					do
					{
						xPathNavigator.MoveTo(newNodeSet.Current);
						xPathNavigator.MoveToParent();
						flag2 = !proc.Stylesheet.PreserveWhiteSpace(proc, xPathNavigator) && (flag = newNodeSet.MoveNext());
						nodeType = newNodeSet.Current.NodeType;
					}
					while (flag2 && nodeType == XPathNodeType.Whitespace);
				}
			}
			return flag;
		}

		int IStackFrame.GetVariablesCount()
		{
			if (action == null)
			{
				return 0;
			}
			return action.GetDbgData(this).Variables.Length;
		}

		XPathNavigator IStackFrame.GetVariable(int varIndex)
		{
			return action.GetDbgData(this).Variables[varIndex].GetDbgData(null).StyleSheet;
		}

		object IStackFrame.GetVariableValue(int varIndex)
		{
			return GetVariable(action.GetDbgData(this).Variables[varIndex].VarKey);
		}
	}
	internal class ApplyImportsAction : CompiledAction
	{
		private XmlQualifiedName mode;

		private Stylesheet stylesheet;

		private const int TemplateProcessed = 2;

		internal override void Compile(Compiler compiler)
		{
			CheckEmpty(compiler);
			if (!compiler.CanHaveApplyImports)
			{
				throw XsltException.Create("Xslt_ApplyImports");
			}
			mode = compiler.CurrentMode;
			stylesheet = compiler.CompiledStylesheet;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				processor.PushTemplateLookup(frame.NodeSet, mode, stylesheet);
				frame.State = 2;
				break;
			case 2:
				frame.Finished();
				break;
			}
		}
	}
	internal class ApplyTemplatesAction : ContainerAction
	{
		private const int ProcessedChildren = 2;

		private const int ProcessNextNode = 3;

		private const int PositionAdvanced = 4;

		private const int TemplateProcessed = 5;

		private int selectKey = -1;

		private XmlQualifiedName mode;

		private static ApplyTemplatesAction s_BuiltInRule = new ApplyTemplatesAction();

		internal static ApplyTemplatesAction BuiltInRule()
		{
			return s_BuiltInRule;
		}

		internal static ApplyTemplatesAction BuiltInRule(XmlQualifiedName mode)
		{
			if (!(mode == null) && !mode.IsEmpty)
			{
				return new ApplyTemplatesAction(mode);
			}
			return BuiltInRule();
		}

		internal ApplyTemplatesAction()
		{
		}

		private ApplyTemplatesAction(XmlQualifiedName mode)
		{
			this.mode = mode;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CompileContent(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Select))
			{
				selectKey = compiler.AddQuery(value);
			}
			else
			{
				if (!Ref.Equal(localName, compiler.Atoms.Mode))
				{
					return false;
				}
				if (compiler.AllowBuiltInMode && value == "*")
				{
					mode = Compiler.BuiltInMode;
				}
				else
				{
					mode = compiler.CreateXPathQName(value);
				}
			}
			return true;
		}

		private void CompileContent(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (!compiler.Recurse())
			{
				return;
			}
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
				{
					compiler.PushNamespaceScope();
					string namespaceURI = input.NamespaceURI;
					string localName = input.LocalName;
					if (Ref.Equal(namespaceURI, input.Atoms.UriXsl))
					{
						if (Ref.Equal(localName, input.Atoms.Sort))
						{
							AddAction(compiler.CreateSortAction());
						}
						else
						{
							if (!Ref.Equal(localName, input.Atoms.WithParam))
							{
								throw compiler.UnexpectedKeyword();
							}
							WithParamAction withParamAction = compiler.CreateWithParamAction();
							CheckDuplicateParams(withParamAction.Name);
							AddAction(withParamAction);
						}
						compiler.PopScope();
						break;
					}
					throw compiler.UnexpectedKeyword();
				}
				default:
					throw XsltException.Create("Xslt_InvalidContents", "apply-templates");
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				processor.ResetParams();
				processor.InitSortArray();
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
					frame.State = 2;
					return;
				}
				goto case 2;
			case 2:
				if (selectKey == -1)
				{
					if (!frame.Node.HasChildren)
					{
						frame.Finished();
						return;
					}
					frame.InitNewNodeSet(frame.Node.SelectChildren(XPathNodeType.All));
				}
				else
				{
					frame.InitNewNodeSet(processor.StartQuery(frame.NodeSet, selectKey));
				}
				if (processor.SortArray.Count != 0)
				{
					frame.SortNewNodeSet(processor, processor.SortArray);
				}
				frame.State = 3;
				goto case 3;
			case 3:
				if (frame.NewNextNode(processor))
				{
					frame.State = 4;
					break;
				}
				frame.Finished();
				return;
			case 4:
				break;
			case 5:
				frame.State = 3;
				goto case 3;
			case 1:
				return;
			}
			processor.PushTemplateLookup(frame.NewNodeSet, mode, null);
			frame.State = 5;
		}
	}
	internal class AttributeAction : ContainerAction
	{
		private const int NameDone = 2;

		private Avt nameAvt;

		private Avt nsAvt;

		private InputScopeManager manager;

		private string name;

		private string nsUri;

		private PrefixQName qname;

		private static PrefixQName CreateAttributeQName(string name, string nsUri, InputScopeManager manager)
		{
			if (name == "xmlns")
			{
				return null;
			}
			if (nsUri == "http://www.w3.org/2000/xmlns/")
			{
				throw XsltException.Create("Xslt_ReservedNS", nsUri);
			}
			PrefixQName prefixQName = new PrefixQName();
			prefixQName.SetQName(name);
			prefixQName.Namespace = ((nsUri != null) ? nsUri : manager.ResolveXPathNamespace(prefixQName.Prefix));
			if (prefixQName.Prefix.StartsWith("xml", StringComparison.Ordinal))
			{
				if (prefixQName.Prefix.Length == 3)
				{
					if (!(prefixQName.Namespace == "http://www.w3.org/XML/1998/namespace") || (!(prefixQName.Name == "lang") && !(prefixQName.Name == "space")))
					{
						prefixQName.ClearPrefix();
					}
				}
				else if (prefixQName.Prefix == "xmlns")
				{
					if (prefixQName.Namespace == "http://www.w3.org/2000/xmlns/")
					{
						throw XsltException.Create("Xslt_InvalidPrefix", prefixQName.Prefix);
					}
					prefixQName.ClearPrefix();
				}
			}
			return prefixQName;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, nameAvt, "name");
			name = CompiledAction.PrecalculateAvt(ref nameAvt);
			nsUri = CompiledAction.PrecalculateAvt(ref nsAvt);
			if (nameAvt == null && nsAvt == null)
			{
				if (name != "xmlns")
				{
					qname = CreateAttributeQName(name, nsUri, compiler.CloneScopeManager());
				}
			}
			else
			{
				manager = compiler.CloneScopeManager();
			}
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Name))
			{
				nameAvt = Avt.CompileAvt(compiler, value);
			}
			else
			{
				if (!Ref.Equal(localName, compiler.Atoms.Namespace))
				{
					return false;
				}
				nsAvt = Avt.CompileAvt(compiler, value);
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (qname != null)
				{
					frame.CalulatedName = qname;
				}
				else
				{
					frame.CalulatedName = CreateAttributeQName((nameAvt == null) ? name : nameAvt.Evaluate(processor, frame), (nsAvt == null) ? nsUri : nsAvt.Evaluate(processor, frame), manager);
					if (frame.CalulatedName == null)
					{
						frame.Finished();
						break;
					}
				}
				goto case 2;
			case 2:
			{
				PrefixQName calulatedName = frame.CalulatedName;
				if (!processor.BeginEvent(XPathNodeType.Attribute, calulatedName.Prefix, calulatedName.Name, calulatedName.Namespace, empty: false))
				{
					frame.State = 2;
					break;
				}
				processor.PushActionFrame(frame);
				frame.State = 1;
				break;
			}
			case 1:
				if (!processor.EndEvent(XPathNodeType.Attribute))
				{
					frame.State = 1;
				}
				else
				{
					frame.Finished();
				}
				break;
			}
		}
	}
	internal class AttributeSetAction : ContainerAction
	{
		internal XmlQualifiedName name;

		internal XmlQualifiedName Name => name;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, name, "name");
			CompileContent(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Name))
			{
				name = compiler.CreateXPathQName(value);
			}
			else
			{
				if (!Ref.Equal(localName, compiler.Atoms.UseAttributeSets))
				{
					return false;
				}
				AddAction(compiler.CreateUseAttributeSetsAction());
			}
			return true;
		}

		private void CompileContent(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (!compiler.Recurse())
			{
				return;
			}
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
				{
					compiler.PushNamespaceScope();
					string namespaceURI = input.NamespaceURI;
					string localName = input.LocalName;
					if (Ref.Equal(namespaceURI, input.Atoms.UriXsl) && Ref.Equal(localName, input.Atoms.Attribute))
					{
						AddAction(compiler.CreateAttributeAction());
						compiler.PopScope();
						break;
					}
					throw compiler.UnexpectedKeyword();
				}
				default:
					throw XsltException.Create("Xslt_InvalidContents", "attribute-set");
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		internal void Merge(AttributeSetAction attributeAction)
		{
			int num = 0;
			Action action;
			while ((action = attributeAction.GetAction(num)) != null)
			{
				AddAction(action);
				num++;
			}
		}
	}
	internal sealed class Avt
	{
		private string constAvt;

		private TextEvent[] events;

		public bool IsConstant => events == null;

		private Avt(string constAvt)
		{
			this.constAvt = constAvt;
		}

		private Avt(ArrayList eventList)
		{
			events = new TextEvent[eventList.Count];
			for (int i = 0; i < eventList.Count; i++)
			{
				events[i] = (TextEvent)eventList[i];
			}
		}

		internal string Evaluate(Processor processor, ActionFrame frame)
		{
			if (IsConstant)
			{
				return constAvt;
			}
			StringBuilder sharedStringBuilder = processor.GetSharedStringBuilder();
			for (int i = 0; i < events.Length; i++)
			{
				sharedStringBuilder.Append(events[i].Evaluate(processor, frame));
			}
			processor.ReleaseSharedStringBuilder();
			return sharedStringBuilder.ToString();
		}

		internal static Avt CompileAvt(Compiler compiler, string avtText)
		{
			bool constant;
			ArrayList eventList = compiler.CompileAvt(avtText, out constant);
			if (!constant)
			{
				return new Avt(eventList);
			}
			return new Avt(avtText);
		}
	}
	internal sealed class AvtEvent : TextEvent
	{
		private int key;

		public AvtEvent(int key)
		{
			this.key = key;
		}

		public override bool Output(Processor processor, ActionFrame frame)
		{
			return processor.TextEvent(processor.EvaluateString(frame, key));
		}

		public override string Evaluate(Processor processor, ActionFrame frame)
		{
			return processor.EvaluateString(frame, key);
		}
	}
	internal class BeginEvent : Event
	{
		private XPathNodeType nodeType;

		private string namespaceUri;

		private string name;

		private string prefix;

		private bool empty;

		private object htmlProps;

		public BeginEvent(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			nodeType = input.NodeType;
			namespaceUri = input.NamespaceURI;
			name = input.LocalName;
			prefix = input.Prefix;
			empty = input.IsEmptyTag;
			if (nodeType == XPathNodeType.Element)
			{
				htmlProps = HtmlElementProps.GetProps(name);
			}
			else if (nodeType == XPathNodeType.Attribute)
			{
				htmlProps = HtmlAttributeProps.GetProps(name);
			}
		}

		public override void ReplaceNamespaceAlias(Compiler compiler)
		{
			if (nodeType == XPathNodeType.Attribute && namespaceUri.Length == 0)
			{
				return;
			}
			NamespaceInfo namespaceInfo = compiler.FindNamespaceAlias(namespaceUri);
			if (namespaceInfo != null)
			{
				namespaceUri = namespaceInfo.nameSpace;
				if (namespaceInfo.prefix != null)
				{
					prefix = namespaceInfo.prefix;
				}
			}
		}

		public override bool Output(Processor processor, ActionFrame frame)
		{
			return processor.BeginEvent(nodeType, prefix, name, namespaceUri, empty, htmlProps, search: false);
		}
	}
	internal class BuilderInfo
	{
		private string name;

		private string localName;

		private string namespaceURI;

		private string prefix;

		private XmlNodeType nodeType;

		private int depth;

		private bool isEmptyTag;

		internal string[] TextInfo = new string[4];

		internal int TextInfoCount;

		internal bool search;

		internal HtmlElementProps htmlProps;

		internal HtmlAttributeProps htmlAttrProps;

		internal string Name
		{
			get
			{
				if (name == null)
				{
					string text = Prefix;
					string text2 = LocalName;
					if (text != null && 0 < text.Length)
					{
						if (text2.Length > 0)
						{
							name = text + ":" + text2;
						}
						else
						{
							name = text;
						}
					}
					else
					{
						name = text2;
					}
				}
				return name;
			}
		}

		internal string LocalName
		{
			get
			{
				return localName;
			}
			set
			{
				localName = value;
			}
		}

		internal string NamespaceURI
		{
			get
			{
				return namespaceURI;
			}
			set
			{
				namespaceURI = value;
			}
		}

		internal string Prefix
		{
			get
			{
				return prefix;
			}
			set
			{
				prefix = value;
			}
		}

		internal string Value
		{
			get
			{
				switch (TextInfoCount)
				{
				case 0:
					return string.Empty;
				case 1:
					return TextInfo[0];
				default:
				{
					int num = 0;
					for (int i = 0; i < TextInfoCount; i++)
					{
						string text = TextInfo[i];
						if (text != null)
						{
							num += text.Length;
						}
					}
					StringBuilder stringBuilder = new StringBuilder(num);
					for (int j = 0; j < TextInfoCount; j++)
					{
						string text2 = TextInfo[j];
						if (text2 != null)
						{
							stringBuilder.Append(text2);
						}
					}
					return stringBuilder.ToString();
				}
				}
			}
			set
			{
				TextInfoCount = 0;
				ValueAppend(value, disableEscaping: false);
			}
		}

		internal XmlNodeType NodeType
		{
			get
			{
				return nodeType;
			}
			set
			{
				nodeType = value;
			}
		}

		internal int Depth
		{
			get
			{
				return depth;
			}
			set
			{
				depth = value;
			}
		}

		internal bool IsEmptyTag
		{
			get
			{
				return isEmptyTag;
			}
			set
			{
				isEmptyTag = value;
			}
		}

		internal BuilderInfo()
		{
			Initialize(string.Empty, string.Empty, string.Empty);
		}

		internal void Initialize(string prefix, string name, string nspace)
		{
			this.prefix = prefix;
			localName = name;
			namespaceURI = nspace;
			this.name = null;
			htmlProps = null;
			htmlAttrProps = null;
			TextInfoCount = 0;
		}

		internal void Initialize(BuilderInfo src)
		{
			prefix = src.Prefix;
			localName = src.LocalName;
			namespaceURI = src.NamespaceURI;
			name = null;
			depth = src.Depth;
			nodeType = src.NodeType;
			htmlProps = src.htmlProps;
			htmlAttrProps = src.htmlAttrProps;
			TextInfoCount = 0;
			EnsureTextInfoSize(src.TextInfoCount);
			src.TextInfo.CopyTo(TextInfo, 0);
			TextInfoCount = src.TextInfoCount;
		}

		private void EnsureTextInfoSize(int newSize)
		{
			if (TextInfo.Length < newSize)
			{
				string[] array = new string[newSize * 2];
				Array.Copy(TextInfo, array, TextInfoCount);
				TextInfo = array;
			}
		}

		internal BuilderInfo Clone()
		{
			BuilderInfo builderInfo = new BuilderInfo();
			builderInfo.Initialize(this);
			return builderInfo;
		}

		internal void ValueAppend(string s, bool disableEscaping)
		{
			if (s != null && s.Length != 0)
			{
				EnsureTextInfoSize(TextInfoCount + ((!disableEscaping) ? 1 : 2));
				if (disableEscaping)
				{
					TextInfo[TextInfoCount++] = null;
				}
				TextInfo[TextInfoCount++] = s;
			}
		}
	}
	internal class CallTemplateAction : ContainerAction
	{
		private const int ProcessedChildren = 2;

		private const int ProcessedTemplate = 3;

		private XmlQualifiedName name;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, name, "name");
			CompileContent(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Name))
			{
				name = compiler.CreateXPathQName(value);
				return true;
			}
			return false;
		}

		private void CompileContent(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (!compiler.Recurse())
			{
				return;
			}
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
				{
					compiler.PushNamespaceScope();
					string namespaceURI = input.NamespaceURI;
					string localName = input.LocalName;
					if (Ref.Equal(namespaceURI, input.Atoms.UriXsl) && Ref.Equal(localName, input.Atoms.WithParam))
					{
						WithParamAction withParamAction = compiler.CreateWithParamAction();
						CheckDuplicateParams(withParamAction.Name);
						AddAction(withParamAction);
						compiler.PopScope();
						break;
					}
					throw compiler.UnexpectedKeyword();
				}
				default:
					throw XsltException.Create("Xslt_InvalidContents", "call-template");
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				processor.ResetParams();
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
					frame.State = 2;
					break;
				}
				goto case 2;
			case 2:
			{
				TemplateAction templateAction = processor.Stylesheet.FindTemplate(name);
				if (templateAction != null)
				{
					frame.State = 3;
					processor.PushActionFrame(templateAction, frame.NodeSet);
					break;
				}
				throw XsltException.Create("Xslt_InvalidCallTemplate", name.ToString());
			}
			case 3:
				frame.Finished();
				break;
			case 1:
				break;
			}
		}
	}
	internal class ChooseAction : ContainerAction
	{
		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (compiler.Recurse())
			{
				CompileConditions(compiler);
				compiler.ToParent();
			}
		}

		private void CompileConditions(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			bool flag = false;
			bool flag2 = false;
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
				{
					compiler.PushNamespaceScope();
					string namespaceURI = input.NamespaceURI;
					string localName = input.LocalName;
					if (Ref.Equal(namespaceURI, input.Atoms.UriXsl))
					{
						IfAction ifAction = null;
						if (Ref.Equal(localName, input.Atoms.When))
						{
							if (flag2)
							{
								throw XsltException.Create("Xslt_WhenAfterOtherwise");
							}
							ifAction = compiler.CreateIfAction(IfAction.ConditionType.ConditionWhen);
							flag = true;
						}
						else
						{
							if (!Ref.Equal(localName, input.Atoms.Otherwise))
							{
								throw compiler.UnexpectedKeyword();
							}
							if (flag2)
							{
								throw XsltException.Create("Xslt_DupOtherwise");
							}
							ifAction = compiler.CreateIfAction(IfAction.ConditionType.ConditionOtherwise);
							flag2 = true;
						}
						AddAction(ifAction);
						compiler.PopScope();
						break;
					}
					throw compiler.UnexpectedKeyword();
				}
				default:
					throw XsltException.Create("Xslt_InvalidContents", "choose");
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			if (!flag)
			{
				throw XsltException.Create("Xslt_NoWhen");
			}
		}
	}
	internal class CommentAction : ContainerAction
	{
		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (processor.BeginEvent(XPathNodeType.Comment, string.Empty, string.Empty, string.Empty, empty: false))
				{
					processor.PushActionFrame(frame);
					frame.State = 1;
				}
				break;
			case 1:
				if (processor.EndEvent(XPathNodeType.Comment))
				{
					frame.Finished();
				}
				break;
			}
		}
	}
	internal abstract class CompiledAction : Action
	{
		internal abstract void Compile(Compiler compiler);

		internal virtual bool CompileAttribute(Compiler compiler)
		{
			return false;
		}

		public void CompileAttributes(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			string localName = input.LocalName;
			if (!input.MoveToFirstAttribute())
			{
				return;
			}
			do
			{
				if (input.NamespaceURI.Length != 0)
				{
					continue;
				}
				try
				{
					if (!CompileAttribute(compiler))
					{
						throw XsltException.Create("Xslt_InvalidAttribute", input.LocalName, localName);
					}
				}
				catch
				{
					if (!compiler.ForwardCompatibility)
					{
						throw;
					}
				}
			}
			while (input.MoveToNextAttribute());
			input.ToParent();
		}

		internal static string PrecalculateAvt(ref Avt avt)
		{
			string result = null;
			if (avt != null && avt.IsConstant)
			{
				result = avt.Evaluate(null, null);
				avt = null;
			}
			return result;
		}

		public void CheckEmpty(Compiler compiler)
		{
			string name = compiler.Input.Name;
			if (!compiler.Recurse())
			{
				return;
			}
			do
			{
				XPathNodeType nodeType = compiler.Input.NodeType;
				if (nodeType != XPathNodeType.Whitespace && nodeType != XPathNodeType.Comment && nodeType != XPathNodeType.ProcessingInstruction)
				{
					throw XsltException.Create("Xslt_NotEmptyContents", name);
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		public void CheckRequiredAttribute(Compiler compiler, object attrValue, string attrName)
		{
			CheckRequiredAttribute(compiler, attrValue != null, attrName);
		}

		public void CheckRequiredAttribute(Compiler compiler, bool attr, string attrName)
		{
			if (!attr)
			{
				throw XsltException.Create("Xslt_MissingAttribute", attrName);
			}
		}
	}
	internal class Sort
	{
		internal int select;

		internal string lang;

		internal XmlDataType dataType;

		internal XmlSortOrder order;

		internal XmlCaseOrder caseOrder;

		public Sort(int sortkey, string xmllang, XmlDataType datatype, XmlSortOrder xmlorder, XmlCaseOrder xmlcaseorder)
		{
			select = sortkey;
			lang = xmllang;
			dataType = datatype;
			order = xmlorder;
			caseOrder = xmlcaseorder;
		}
	}
	internal enum ScriptingLanguage
	{
		JScript,
		VisualBasic,
		CSharp
	}
	internal class Compiler
	{
		internal class ErrorXPathExpression : CompiledXpathExpr
		{
			private string baseUri;

			private int lineNumber;

			private int linePosition;

			public ErrorXPathExpression(string expression, string baseUri, int lineNumber, int linePosition)
				: base(null, expression, needContext: false)
			{
				this.baseUri = baseUri;
				this.lineNumber = lineNumber;
				this.linePosition = linePosition;
			}

			public override XPathExpression Clone()
			{
				return this;
			}

			public override void CheckErrors()
			{
				throw new XsltException("Xslt_InvalidXPath", new string[1] { Expression }, baseUri, linePosition, lineNumber, null);
			}
		}

		internal const int InvalidQueryKey = -1;

		internal const double RootPriority = 0.5;

		internal StringBuilder AvtStringBuilder = new StringBuilder();

		private int stylesheetid;

		private InputScope rootScope;

		private XmlResolver xmlResolver;

		private TemplateBaseAction currentTemplate;

		private XmlQualifiedName currentMode;

		private Hashtable globalNamespaceAliasTable;

		private Stack stylesheets;

		private HybridDictionary documentURIs = new HybridDictionary();

		private NavigatorInput input;

		private KeywordsTable atoms;

		private InputScopeManager scopeManager;

		internal Stylesheet stylesheet;

		internal Stylesheet rootStylesheet;

		private RootAction rootAction;

		private List<TheQuery> queryStore;

		private QueryBuilder queryBuilder = new QueryBuilder();

		private int rtfCount;

		public bool AllowBuiltInMode;

		public static XmlQualifiedName BuiltInMode = new XmlQualifiedName("*", string.Empty);

		private Hashtable[] _typeDeclsByLang = new Hashtable[3]
		{
			new Hashtable(),
			new Hashtable(),
			new Hashtable()
		};

		private ArrayList scriptFiles = new ArrayList();

		private static string[] _defaultNamespaces = new string[7] { "System", "System.Collections", "System.Text", "System.Text.RegularExpressions", "System.Xml", "System.Xml.Xsl", "System.Xml.XPath" };

		private static int scriptClassCounter = 0;

		internal KeywordsTable Atoms => atoms;

		internal int Stylesheetid
		{
			get
			{
				return stylesheetid;
			}
			set
			{
				stylesheetid = value;
			}
		}

		internal NavigatorInput Document => input;

		internal NavigatorInput Input => input;

		internal Stylesheet CompiledStylesheet => stylesheet;

		internal RootAction RootAction
		{
			get
			{
				return rootAction;
			}
			set
			{
				rootAction = value;
				currentTemplate = rootAction;
			}
		}

		internal List<TheQuery> QueryStore => queryStore;

		public virtual IXsltDebugger Debugger => null;

		internal bool ForwardCompatibility
		{
			get
			{
				return scopeManager.CurrentScope.ForwardCompatibility;
			}
			set
			{
				scopeManager.CurrentScope.ForwardCompatibility = value;
			}
		}

		internal bool CanHaveApplyImports
		{
			get
			{
				return scopeManager.CurrentScope.CanHaveApplyImports;
			}
			set
			{
				scopeManager.CurrentScope.CanHaveApplyImports = value;
			}
		}

		protected InputScopeManager ScopeManager => scopeManager;

		internal string DefaultNamespace => scopeManager.DefaultNamespace;

		internal XmlQualifiedName CurrentMode => currentMode;

		internal bool Advance()
		{
			return Document.Advance();
		}

		internal bool Recurse()
		{
			return Document.Recurse();
		}

		internal bool ToParent()
		{
			return Document.ToParent();
		}

		internal string GetUnicRtfId()
		{
			rtfCount++;
			return rtfCount.ToString(CultureInfo.InvariantCulture);
		}

		internal void Compile(NavigatorInput input, XmlResolver xmlResolver, Evidence evidence)
		{
			this.xmlResolver = xmlResolver;
			PushInputDocument(input);
			rootScope = scopeManager.PushScope();
			queryStore = new List<TheQuery>();
			try
			{
				rootStylesheet = new Stylesheet();
				PushStylesheet(rootStylesheet);
				try
				{
					CreateRootAction();
				}
				catch (XsltCompileException)
				{
					throw;
				}
				catch (Exception inner)
				{
					throw new XsltCompileException(inner, Input.BaseURI, Input.LineNumber, Input.LinePosition);
				}
				stylesheet.ProcessTemplates();
				rootAction.PorcessAttributeSets(rootStylesheet);
				stylesheet.SortWhiteSpace();
				CompileScript(evidence);
				if (evidence != null)
				{
					rootAction.permissions = SecurityManager.GetStandardSandbox(evidence);
				}
				if (globalNamespaceAliasTable != null)
				{
					stylesheet.ReplaceNamespaceAlias(this);
					rootAction.ReplaceNamespaceAlias(this);
				}
			}
			finally
			{
				PopInputDocument();
			}
		}

		internal void InsertExtensionNamespace(string value)
		{
			string[] array = ResolvePrefixes(value);
			if (array != null)
			{
				scopeManager.InsertExtensionNamespaces(array);
			}
		}

		internal void InsertExcludedNamespace(string value)
		{
			string[] array = ResolvePrefixes(value);
			if (array != null)
			{
				scopeManager.InsertExcludedNamespaces(array);
			}
		}

		internal void InsertExtensionNamespace()
		{
			InsertExtensionNamespace(Input.Navigator.GetAttribute(Input.Atoms.ExtensionElementPrefixes, Input.Atoms.UriXsl));
		}

		internal void InsertExcludedNamespace()
		{
			InsertExcludedNamespace(Input.Navigator.GetAttribute(Input.Atoms.ExcludeResultPrefixes, Input.Atoms.UriXsl));
		}

		internal bool IsExtensionNamespace(string nspace)
		{
			return scopeManager.IsExtensionNamespace(nspace);
		}

		internal bool IsExcludedNamespace(string nspace)
		{
			return scopeManager.IsExcludedNamespace(nspace);
		}

		internal void PushLiteralScope()
		{
			PushNamespaceScope();
			string attribute = Input.Navigator.GetAttribute(Atoms.Version, Atoms.UriXsl);
			if (attribute.Length != 0)
			{
				ForwardCompatibility = attribute != "1.0";
			}
		}

		internal void PushNamespaceScope()
		{
			scopeManager.PushScope();
			NavigatorInput navigatorInput = Input;
			if (navigatorInput.MoveToFirstNamespace())
			{
				do
				{
					scopeManager.PushNamespace(navigatorInput.LocalName, navigatorInput.Value);
				}
				while (navigatorInput.MoveToNextNamespace());
				navigatorInput.ToParent();
			}
		}

		internal virtual void PopScope()
		{
			currentTemplate.ReleaseVariableSlots(scopeManager.CurrentScope.GetVeriablesCount());
			scopeManager.PopScope();
		}

		internal InputScopeManager CloneScopeManager()
		{
			return scopeManager.Clone();
		}

		internal int InsertVariable(VariableAction variable)
		{
			InputScope inputScope = ((!variable.IsGlobal) ? scopeManager.VariableScope : rootScope);
			VariableAction variableAction = inputScope.ResolveVariable(variable.Name);
			if (variableAction != null)
			{
				if (!variableAction.IsGlobal)
				{
					throw XsltException.Create("Xslt_DupVarName", variable.NameStr);
				}
				if (variable.IsGlobal)
				{
					if (variable.Stylesheetid == variableAction.Stylesheetid)
					{
						throw XsltException.Create("Xslt_DupVarName", variable.NameStr);
					}
					if (variable.Stylesheetid < variableAction.Stylesheetid)
					{
						inputScope.InsertVariable(variable);
						return variableAction.VarKey;
					}
					return -1;
				}
			}
			inputScope.InsertVariable(variable);
			return currentTemplate.AllocateVariableSlot();
		}

		internal void AddNamespaceAlias(string StylesheetURI, NamespaceInfo AliasInfo)
		{
			if (globalNamespaceAliasTable == null)
			{
				globalNamespaceAliasTable = new Hashtable();
			}
			if (!(globalNamespaceAliasTable[StylesheetURI] is NamespaceInfo namespaceInfo) || AliasInfo.stylesheetId <= namespaceInfo.stylesheetId)
			{
				globalNamespaceAliasTable[StylesheetURI] = AliasInfo;
			}
		}

		internal bool IsNamespaceAlias(string StylesheetURI)
		{
			if (globalNamespaceAliasTable == null)
			{
				return false;
			}
			return globalNamespaceAliasTable.Contains(StylesheetURI);
		}

		internal NamespaceInfo FindNamespaceAlias(string StylesheetURI)
		{
			if (globalNamespaceAliasTable != null)
			{
				return (NamespaceInfo)globalNamespaceAliasTable[StylesheetURI];
			}
			return null;
		}

		internal string ResolveXmlNamespace(string prefix)
		{
			return scopeManager.ResolveXmlNamespace(prefix);
		}

		internal string ResolveXPathNamespace(string prefix)
		{
			return scopeManager.ResolveXPathNamespace(prefix);
		}

		internal void InsertKey(XmlQualifiedName name, int MatchKey, int UseKey)
		{
			rootAction.InsertKey(name, MatchKey, UseKey);
		}

		internal void AddDecimalFormat(XmlQualifiedName name, DecimalFormat formatinfo)
		{
			rootAction.AddDecimalFormat(name, formatinfo);
		}

		private string[] ResolvePrefixes(string tokens)
		{
			if (tokens == null || tokens.Length == 0)
			{
				return null;
			}
			string[] array = XmlConvert.SplitString(tokens);
			try
			{
				for (int i = 0; i < array.Length; i++)
				{
					string text = array[i];
					array[i] = scopeManager.ResolveXmlNamespace((text == "#default") ? string.Empty : text);
				}
				return array;
			}
			catch (XsltException)
			{
				if (!ForwardCompatibility)
				{
					throw;
				}
				return null;
			}
		}

		internal bool GetYesNo(string value)
		{
			if (value == "yes")
			{
				return true;
			}
			if (value == "no")
			{
				return false;
			}
			throw XsltException.Create("Xslt_InvalidAttrValue", Input.LocalName, value);
		}

		internal string GetSingleAttribute(string attributeAtom)
		{
			NavigatorInput navigatorInput = Input;
			string localName = navigatorInput.LocalName;
			string text = null;
			if (navigatorInput.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = navigatorInput.NamespaceURI;
					string localName2 = navigatorInput.LocalName;
					if (namespaceURI.Length == 0)
					{
						if (Ref.Equal(localName2, attributeAtom))
						{
							text = navigatorInput.Value;
						}
						else if (!ForwardCompatibility)
						{
							throw XsltException.Create("Xslt_InvalidAttribute", localName2, localName);
						}
					}
				}
				while (navigatorInput.MoveToNextAttribute());
				navigatorInput.ToParent();
			}
			if (text == null)
			{
				throw XsltException.Create("Xslt_MissingAttribute", attributeAtom);
			}
			return text;
		}

		internal XmlQualifiedName CreateXPathQName(string qname)
		{
			PrefixQName.ParseQualifiedName(qname, out var prefix, out var local);
			return new XmlQualifiedName(local, scopeManager.ResolveXPathNamespace(prefix));
		}

		internal XmlQualifiedName CreateXmlQName(string qname)
		{
			PrefixQName.ParseQualifiedName(qname, out var prefix, out var local);
			return new XmlQualifiedName(local, scopeManager.ResolveXmlNamespace(prefix));
		}

		internal static XPathDocument LoadDocument(XmlTextReaderImpl reader)
		{
			reader.EntityHandling = EntityHandling.ExpandEntities;
			reader.XmlValidatingReaderCompatibilityMode = true;
			try
			{
				return new XPathDocument(reader, XmlSpace.Preserve);
			}
			finally
			{
				reader.Close();
			}
		}

		private void AddDocumentURI(string href)
		{
			documentURIs.Add(href, null);
		}

		private void RemoveDocumentURI(string href)
		{
			documentURIs.Remove(href);
		}

		internal bool IsCircularReference(string href)
		{
			return documentURIs.Contains(href);
		}

		internal Uri ResolveUri(string relativeUri)
		{
			string baseURI = Input.BaseURI;
			Uri uri = xmlResolver.ResolveUri((baseURI.Length != 0) ? xmlResolver.ResolveUri(null, baseURI) : null, relativeUri);
			if (uri == null)
			{
				throw XsltException.Create("Xslt_CantResolve", relativeUri);
			}
			return uri;
		}

		internal NavigatorInput ResolveDocument(Uri absoluteUri)
		{
			object entity = xmlResolver.GetEntity(absoluteUri, null, null);
			string text = absoluteUri.ToString();
			if (entity is Stream)
			{
				XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl(text, (Stream)entity);
				xmlTextReaderImpl.XmlResolver = xmlResolver;
				return new NavigatorInput(LoadDocument(xmlTextReaderImpl).CreateNavigator(), text, rootScope);
			}
			if (entity is XPathNavigator)
			{
				return new NavigatorInput((XPathNavigator)entity, text, rootScope);
			}
			throw XsltException.Create("Xslt_CantResolve", text);
		}

		internal void PushInputDocument(NavigatorInput newInput)
		{
			string href = newInput.Href;
			AddDocumentURI(href);
			newInput.Next = input;
			input = newInput;
			atoms = input.Atoms;
			scopeManager = input.InputScopeManager;
		}

		internal void PopInputDocument()
		{
			NavigatorInput navigatorInput = input;
			input = navigatorInput.Next;
			navigatorInput.Next = null;
			if (input != null)
			{
				atoms = input.Atoms;
				scopeManager = input.InputScopeManager;
			}
			else
			{
				atoms = null;
				scopeManager = null;
			}
			RemoveDocumentURI(navigatorInput.Href);
			navigatorInput.Close();
		}

		internal void PushStylesheet(Stylesheet stylesheet)
		{
			if (stylesheets == null)
			{
				stylesheets = new Stack();
			}
			stylesheets.Push(stylesheet);
			this.stylesheet = stylesheet;
		}

		internal Stylesheet PopStylesheet()
		{
			Stylesheet result = (Stylesheet)stylesheets.Pop();
			stylesheet = (Stylesheet)stylesheets.Peek();
			return result;
		}

		internal void AddAttributeSet(AttributeSetAction attributeSet)
		{
			stylesheet.AddAttributeSet(attributeSet);
		}

		internal void AddTemplate(TemplateAction template)
		{
			stylesheet.AddTemplate(template);
		}

		internal void BeginTemplate(TemplateAction template)
		{
			currentTemplate = template;
			currentMode = template.Mode;
			CanHaveApplyImports = template.MatchKey != -1;
		}

		internal void EndTemplate()
		{
			currentTemplate = rootAction;
		}

		internal int AddQuery(string xpathQuery)
		{
			return AddQuery(xpathQuery, allowVar: true, allowKey: true, isPattern: false);
		}

		internal int AddQuery(string xpathQuery, bool allowVar, bool allowKey, bool isPattern)
		{
			CompiledXpathExpr compiledQuery;
			try
			{
				compiledQuery = new CompiledXpathExpr(isPattern ? queryBuilder.BuildPatternQuery(xpathQuery, allowVar, allowKey) : queryBuilder.Build(xpathQuery, allowVar, allowKey), xpathQuery, needContext: false);
			}
			catch (XPathException inner)
			{
				if (!ForwardCompatibility)
				{
					throw XsltException.Create("Xslt_InvalidXPath", new string[1] { xpathQuery }, inner);
				}
				compiledQuery = new ErrorXPathExpression(xpathQuery, Input.BaseURI, Input.LineNumber, Input.LinePosition);
			}
			queryStore.Add(new TheQuery(compiledQuery, scopeManager));
			return queryStore.Count - 1;
		}

		internal int AddStringQuery(string xpathQuery)
		{
			string xpathQuery2 = (XmlCharType.Instance.IsOnlyWhitespace(xpathQuery) ? xpathQuery : ("string(" + xpathQuery + ")"));
			return AddQuery(xpathQuery2);
		}

		internal int AddBooleanQuery(string xpathQuery)
		{
			string xpathQuery2 = (XmlCharType.Instance.IsOnlyWhitespace(xpathQuery) ? xpathQuery : ("boolean(" + xpathQuery + ")"));
			return AddQuery(xpathQuery2);
		}

		private static string GenerateUniqueClassName()
		{
			return "ScriptClass_" + Interlocked.Increment(ref scriptClassCounter);
		}

		internal void AddScript(string source, ScriptingLanguage lang, string ns, string fileName, int lineNumber)
		{
			ValidateExtensionNamespace(ns);
			for (ScriptingLanguage scriptingLanguage = ScriptingLanguage.JScript; scriptingLanguage <= ScriptingLanguage.CSharp; scriptingLanguage++)
			{
				Hashtable hashtable = _typeDeclsByLang[(int)scriptingLanguage];
				if (lang == scriptingLanguage)
				{
					CodeTypeDeclaration codeTypeDeclaration = (CodeTypeDeclaration)hashtable[ns];
					if (codeTypeDeclaration == null)
					{
						codeTypeDeclaration = new CodeTypeDeclaration(GenerateUniqueClassName());
						codeTypeDeclaration.TypeAttributes = TypeAttributes.Public;
						hashtable.Add(ns, codeTypeDeclaration);
					}
					CodeSnippetTypeMember codeSnippetTypeMember = new CodeSnippetTypeMember(source);
					if (lineNumber > 0)
					{
						codeSnippetTypeMember.LinePragma = new CodeLinePragma(fileName, lineNumber);
						scriptFiles.Add(fileName);
					}
					codeTypeDeclaration.Members.Add(codeSnippetTypeMember);
				}
				else if (hashtable.Contains(ns))
				{
					throw XsltException.Create("Xslt_ScriptMixedLanguages", ns);
				}
			}
		}

		private static void ValidateExtensionNamespace(string nsUri)
		{
			if (nsUri.Length == 0 || nsUri == "http://www.w3.org/1999/XSL/Transform")
			{
				throw XsltException.Create("Xslt_InvalidExtensionNamespace");
			}
			XmlConvert.ToUri(nsUri);
		}

		private void FixCompilerError(CompilerError e)
		{
			foreach (string scriptFile in scriptFiles)
			{
				if (e.FileName == scriptFile)
				{
					return;
				}
			}
			e.FileName = string.Empty;
		}

		private CodeDomProvider ChooseCodeDomProvider(ScriptingLanguage lang)
		{
			return lang switch
			{
				ScriptingLanguage.VisualBasic => new VBCodeProvider(), 
				ScriptingLanguage.JScript => (CodeDomProvider)Activator.CreateInstance(Type.GetType("Microsoft.JScript.JScriptCodeProvider, Microsoft.JScript, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"), BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null), 
				_ => new CSharpCodeProvider(), 
			};
		}

		private void CompileScript(Evidence evidence)
		{
			for (ScriptingLanguage scriptingLanguage = ScriptingLanguage.JScript; scriptingLanguage <= ScriptingLanguage.CSharp; scriptingLanguage++)
			{
				int num = (int)scriptingLanguage;
				if (_typeDeclsByLang[num].Count > 0)
				{
					CompileAssembly(scriptingLanguage, _typeDeclsByLang[num], scriptingLanguage.ToString(), evidence);
				}
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		private void CompileAssembly(ScriptingLanguage lang, Hashtable typeDecls, string nsName, Evidence evidence)
		{
			nsName = "Microsoft.Xslt.CompiledScripts." + nsName;
			CodeNamespace codeNamespace = new CodeNamespace(nsName);
			string[] defaultNamespaces = _defaultNamespaces;
			foreach (string nameSpace in defaultNamespaces)
			{
				codeNamespace.Imports.Add(new CodeNamespaceImport(nameSpace));
			}
			if (lang == ScriptingLanguage.VisualBasic)
			{
				codeNamespace.Imports.Add(new CodeNamespaceImport("Microsoft.VisualBasic"));
			}
			foreach (CodeTypeDeclaration value in typeDecls.Values)
			{
				codeNamespace.Types.Add(value);
			}
			CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
			codeCompileUnit.Namespaces.Add(codeNamespace);
			codeCompileUnit.UserData["AllowLateBound"] = true;
			codeCompileUnit.UserData["RequireVariableDeclaration"] = false;
			codeCompileUnit.AssemblyCustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(SecurityRulesAttribute)), new CodeAttributeArgument(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SecurityRuleSet)), "Level1"))));
			CompilerParameters compilerParameters = new CompilerParameters();
			try
			{
				new SecurityPermission(SecurityPermissionFlag.ControlEvidence).Assert();
				try
				{
					compilerParameters.GenerateInMemory = true;
					compilerParameters.Evidence = evidence;
					compilerParameters.ReferencedAssemblies.Add(typeof(XPathNavigator).Module.FullyQualifiedName);
					compilerParameters.ReferencedAssemblies.Add("system.dll");
					if (lang == ScriptingLanguage.VisualBasic)
					{
						compilerParameters.ReferencedAssemblies.Add("microsoft.visualbasic.dll");
					}
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
			}
			catch
			{
				throw;
			}
			CompilerResults compilerResults = ChooseCodeDomProvider(lang).CompileAssemblyFromDom(compilerParameters, codeCompileUnit);
			if (compilerResults.Errors.HasErrors)
			{
				StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
				foreach (CompilerError error in compilerResults.Errors)
				{
					FixCompilerError(error);
					stringWriter.WriteLine(error.ToString());
				}
				throw XsltException.Create("Xslt_ScriptCompileErrors", stringWriter.ToString());
			}
			Assembly compiledAssembly = compilerResults.CompiledAssembly;
			foreach (DictionaryEntry typeDecl in typeDecls)
			{
				string key = (string)typeDecl.Key;
				CodeTypeDeclaration codeTypeDeclaration = (CodeTypeDeclaration)typeDecl.Value;
				stylesheet.ScriptObjectTypes.Add(key, compiledAssembly.GetType(nsName + "." + codeTypeDeclaration.Name));
			}
		}

		public string GetNsAlias(ref string prefix)
		{
			if (prefix == "#default")
			{
				prefix = string.Empty;
				return DefaultNamespace;
			}
			if (!PrefixQName.ValidatePrefix(prefix))
			{
				throw XsltException.Create("Xslt_InvalidAttrValue", input.LocalName, prefix);
			}
			return ResolveXPathNamespace(prefix);
		}

		private static void getTextLex(string avt, ref int start, StringBuilder lex)
		{
			int length = avt.Length;
			int i;
			char c;
			for (i = start; i < length; lex.Append(c), i++)
			{
				c = avt[i];
				switch (c)
				{
				case '{':
					if (i + 1 < length && avt[i + 1] == '{')
					{
						i++;
						continue;
					}
					break;
				case '}':
					if (i + 1 < length && avt[i + 1] == '}')
					{
						i++;
						continue;
					}
					throw XsltException.Create("Xslt_SingleRightAvt", avt);
				default:
					continue;
				}
				break;
			}
			start = i;
		}

		private static void getXPathLex(string avt, ref int start, StringBuilder lex)
		{
			int length = avt.Length;
			int num = 0;
			for (int i = start + 1; i < length; i++)
			{
				char c = avt[i];
				switch (num)
				{
				case 0:
					switch (c)
					{
					case '{':
						throw XsltException.Create("Xslt_NestedAvt", avt);
					case '}':
						i++;
						if (i == start + 2)
						{
							throw XsltException.Create("Xslt_EmptyAvtExpr", avt);
						}
						lex.Append(avt, start + 1, i - start - 2);
						start = i;
						return;
					case '\'':
						num = 1;
						break;
					case '"':
						num = 2;
						break;
					}
					break;
				case 1:
					if (c == '\'')
					{
						num = 0;
					}
					break;
				case 2:
					if (c == '"')
					{
						num = 0;
					}
					break;
				}
			}
			throw XsltException.Create((num == 0) ? "Xslt_OpenBracesAvt" : "Xslt_OpenLiteralAvt", avt);
		}

		private static bool GetNextAvtLex(string avt, ref int start, StringBuilder lex, out bool isAvt)
		{
			isAvt = false;
			if (start == avt.Length)
			{
				return false;
			}
			lex.Length = 0;
			getTextLex(avt, ref start, lex);
			if (lex.Length == 0)
			{
				isAvt = true;
				getXPathLex(avt, ref start, lex);
			}
			return true;
		}

		internal ArrayList CompileAvt(string avtText, out bool constant)
		{
			ArrayList arrayList = new ArrayList();
			constant = true;
			int start = 0;
			bool isAvt;
			while (GetNextAvtLex(avtText, ref start, AvtStringBuilder, out isAvt))
			{
				string text = AvtStringBuilder.ToString();
				if (isAvt)
				{
					arrayList.Add(new AvtEvent(AddStringQuery(text)));
					constant = false;
				}
				else
				{
					arrayList.Add(new TextEvent(text));
				}
			}
			return arrayList;
		}

		internal ArrayList CompileAvt(string avtText)
		{
			bool constant;
			return CompileAvt(avtText, out constant);
		}

		public virtual ApplyImportsAction CreateApplyImportsAction()
		{
			ApplyImportsAction applyImportsAction = new ApplyImportsAction();
			applyImportsAction.Compile(this);
			return applyImportsAction;
		}

		public virtual ApplyTemplatesAction CreateApplyTemplatesAction()
		{
			ApplyTemplatesAction applyTemplatesAction = new ApplyTemplatesAction();
			applyTemplatesAction.Compile(this);
			return applyTemplatesAction;
		}

		public virtual AttributeAction CreateAttributeAction()
		{
			AttributeAction attributeAction = new AttributeAction();
			attributeAction.Compile(this);
			return attributeAction;
		}

		public virtual AttributeSetAction CreateAttributeSetAction()
		{
			AttributeSetAction attributeSetAction = new AttributeSetAction();
			attributeSetAction.Compile(this);
			return attributeSetAction;
		}

		public virtual CallTemplateAction CreateCallTemplateAction()
		{
			CallTemplateAction callTemplateAction = new CallTemplateAction();
			callTemplateAction.Compile(this);
			return callTemplateAction;
		}

		public virtual ChooseAction CreateChooseAction()
		{
			ChooseAction chooseAction = new ChooseAction();
			chooseAction.Compile(this);
			return chooseAction;
		}

		public virtual CommentAction CreateCommentAction()
		{
			CommentAction commentAction = new CommentAction();
			commentAction.Compile(this);
			return commentAction;
		}

		public virtual CopyAction CreateCopyAction()
		{
			CopyAction copyAction = new CopyAction();
			copyAction.Compile(this);
			return copyAction;
		}

		public virtual CopyOfAction CreateCopyOfAction()
		{
			CopyOfAction copyOfAction = new CopyOfAction();
			copyOfAction.Compile(this);
			return copyOfAction;
		}

		public virtual ElementAction CreateElementAction()
		{
			ElementAction elementAction = new ElementAction();
			elementAction.Compile(this);
			return elementAction;
		}

		public virtual ForEachAction CreateForEachAction()
		{
			ForEachAction forEachAction = new ForEachAction();
			forEachAction.Compile(this);
			return forEachAction;
		}

		public virtual IfAction CreateIfAction(IfAction.ConditionType type)
		{
			IfAction ifAction = new IfAction(type);
			ifAction.Compile(this);
			return ifAction;
		}

		public virtual MessageAction CreateMessageAction()
		{
			MessageAction messageAction = new MessageAction();
			messageAction.Compile(this);
			return messageAction;
		}

		public virtual NewInstructionAction CreateNewInstructionAction()
		{
			NewInstructionAction newInstructionAction = new NewInstructionAction();
			newInstructionAction.Compile(this);
			return newInstructionAction;
		}

		public virtual NumberAction CreateNumberAction()
		{
			NumberAction numberAction = new NumberAction();
			numberAction.Compile(this);
			return numberAction;
		}

		public virtual ProcessingInstructionAction CreateProcessingInstructionAction()
		{
			ProcessingInstructionAction processingInstructionAction = new ProcessingInstructionAction();
			processingInstructionAction.Compile(this);
			return processingInstructionAction;
		}

		public virtual void CreateRootAction()
		{
			RootAction = new RootAction();
			RootAction.Compile(this);
		}

		public virtual SortAction CreateSortAction()
		{
			SortAction sortAction = new SortAction();
			sortAction.Compile(this);
			return sortAction;
		}

		public virtual TemplateAction CreateTemplateAction()
		{
			TemplateAction templateAction = new TemplateAction();
			templateAction.Compile(this);
			return templateAction;
		}

		public virtual TemplateAction CreateSingleTemplateAction()
		{
			TemplateAction templateAction = new TemplateAction();
			templateAction.CompileSingle(this);
			return templateAction;
		}

		public virtual TextAction CreateTextAction()
		{
			TextAction textAction = new TextAction();
			textAction.Compile(this);
			return textAction;
		}

		public virtual UseAttributeSetsAction CreateUseAttributeSetsAction()
		{
			UseAttributeSetsAction useAttributeSetsAction = new UseAttributeSetsAction();
			useAttributeSetsAction.Compile(this);
			return useAttributeSetsAction;
		}

		public virtual ValueOfAction CreateValueOfAction()
		{
			ValueOfAction valueOfAction = new ValueOfAction();
			valueOfAction.Compile(this);
			return valueOfAction;
		}

		public virtual VariableAction CreateVariableAction(VariableType type)
		{
			VariableAction variableAction = new VariableAction(type);
			variableAction.Compile(this);
			if (variableAction.VarKey != -1)
			{
				return variableAction;
			}
			return null;
		}

		public virtual WithParamAction CreateWithParamAction()
		{
			WithParamAction withParamAction = new WithParamAction();
			withParamAction.Compile(this);
			return withParamAction;
		}

		public virtual BeginEvent CreateBeginEvent()
		{
			return new BeginEvent(this);
		}

		public virtual TextEvent CreateTextEvent()
		{
			return new TextEvent(this);
		}

		public XsltException UnexpectedKeyword()
		{
			XPathNavigator xPathNavigator = Input.Navigator.Clone();
			string name = xPathNavigator.Name;
			xPathNavigator.MoveToParent();
			string name2 = xPathNavigator.Name;
			return XsltException.Create("Xslt_UnexpectedKeyword", name, name2);
		}
	}
	internal class NamespaceInfo
	{
		internal string prefix;

		internal string nameSpace;

		internal int stylesheetId;

		internal NamespaceInfo(string prefix, string nameSpace, int stylesheetId)
		{
			this.prefix = prefix;
			this.nameSpace = nameSpace;
			this.stylesheetId = stylesheetId;
		}
	}
	internal class ContainerAction : CompiledAction
	{
		internal ArrayList containedActions;

		internal CopyCodeAction lastCopyCodeAction;

		private int maxid;

		protected const int ProcessingChildren = 1;

		internal override void Compile(Compiler compiler)
		{
			throw new NotImplementedException();
		}

		internal void CompileStylesheetAttributes(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			string localName = input.LocalName;
			string text = null;
			string text2 = null;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = input.NamespaceURI;
					string localName2 = input.LocalName;
					if (namespaceURI.Length != 0)
					{
						continue;
					}
					if (Ref.Equal(localName2, input.Atoms.Version))
					{
						text2 = input.Value;
						if (1.0 <= XmlConvert.ToXPathDouble(text2))
						{
							compiler.ForwardCompatibility = text2 != "1.0";
						}
						else if (!compiler.ForwardCompatibility)
						{
							throw XsltException.Create("Xslt_InvalidAttrValue", "version", text2);
						}
					}
					else if (Ref.Equal(localName2, input.Atoms.ExtensionElementPrefixes))
					{
						compiler.InsertExtensionNamespace(input.Value);
					}
					else if (Ref.Equal(localName2, input.Atoms.ExcludeResultPrefixes))
					{
						compiler.InsertExcludedNamespace(input.Value);
					}
					else if (!Ref.Equal(localName2, input.Atoms.Id))
					{
						text = localName2;
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			if (text2 == null)
			{
				throw XsltException.Create("Xslt_MissingAttribute", "version");
			}
			if (text != null && !compiler.ForwardCompatibility)
			{
				throw XsltException.Create("Xslt_InvalidAttribute", text, localName);
			}
		}

		internal void CompileSingleTemplate(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			string text = null;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = input.NamespaceURI;
					string localName = input.LocalName;
					if (Ref.Equal(namespaceURI, input.Atoms.UriXsl) && Ref.Equal(localName, input.Atoms.Version))
					{
						text = input.Value;
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			if (text == null)
			{
				if (Ref.Equal(input.LocalName, input.Atoms.Stylesheet) && input.NamespaceURI == "http://www.w3.org/TR/WD-xsl")
				{
					throw XsltException.Create("Xslt_WdXslNamespace");
				}
				throw XsltException.Create("Xslt_WrongStylesheetElement");
			}
			compiler.AddTemplate(compiler.CreateSingleTemplateAction());
		}

		protected void CompileDocument(Compiler compiler, bool inInclude)
		{
			NavigatorInput input = compiler.Input;
			while (input.NodeType != XPathNodeType.Element)
			{
				if (!compiler.Advance())
				{
					throw XsltException.Create("Xslt_WrongStylesheetElement");
				}
			}
			if (Ref.Equal(input.NamespaceURI, input.Atoms.UriXsl))
			{
				if (!Ref.Equal(input.LocalName, input.Atoms.Stylesheet) && !Ref.Equal(input.LocalName, input.Atoms.Transform))
				{
					throw XsltException.Create("Xslt_WrongStylesheetElement");
				}
				compiler.PushNamespaceScope();
				CompileStylesheetAttributes(compiler);
				CompileTopLevelElements(compiler);
				if (!inInclude)
				{
					CompileImports(compiler);
				}
			}
			else
			{
				compiler.PushLiteralScope();
				CompileSingleTemplate(compiler);
			}
			compiler.PopScope();
		}

		internal Stylesheet CompileImport(Compiler compiler, Uri uri, int id)
		{
			NavigatorInput navigatorInput = compiler.ResolveDocument(uri);
			compiler.PushInputDocument(navigatorInput);
			try
			{
				compiler.PushStylesheet(new Stylesheet());
				compiler.Stylesheetid = id;
				CompileDocument(compiler, inInclude: false);
			}
			catch (XsltCompileException)
			{
				throw;
			}
			catch (Exception inner)
			{
				throw new XsltCompileException(inner, navigatorInput.BaseURI, navigatorInput.LineNumber, navigatorInput.LinePosition);
			}
			finally
			{
				compiler.PopInputDocument();
			}
			return compiler.PopStylesheet();
		}

		private void CompileImports(Compiler compiler)
		{
			ArrayList imports = compiler.CompiledStylesheet.Imports;
			int stylesheetid = compiler.Stylesheetid;
			int num = imports.Count - 1;
			while (0 <= num)
			{
				Uri uri = imports[num] as Uri;
				imports[num] = CompileImport(compiler, uri, ++maxid);
				num--;
			}
			compiler.Stylesheetid = stylesheetid;
		}

		private void CompileInclude(Compiler compiler)
		{
			Uri uri = compiler.ResolveUri(compiler.GetSingleAttribute(compiler.Input.Atoms.Href));
			string text = uri.ToString();
			if (compiler.IsCircularReference(text))
			{
				throw XsltException.Create("Xslt_CircularInclude", text);
			}
			NavigatorInput navigatorInput = compiler.ResolveDocument(uri);
			compiler.PushInputDocument(navigatorInput);
			try
			{
				CompileDocument(compiler, inInclude: true);
			}
			catch (XsltCompileException)
			{
				throw;
			}
			catch (Exception inner)
			{
				throw new XsltCompileException(inner, navigatorInput.BaseURI, navigatorInput.LineNumber, navigatorInput.LinePosition);
			}
			finally
			{
				compiler.PopInputDocument();
			}
			CheckEmpty(compiler);
		}

		internal void CompileNamespaceAlias(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			string localName = input.LocalName;
			string text = null;
			string text2 = null;
			string text3 = null;
			string prefix = null;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = input.NamespaceURI;
					string localName2 = input.LocalName;
					if (namespaceURI.Length == 0)
					{
						if (Ref.Equal(localName2, input.Atoms.StylesheetPrefix))
						{
							text3 = input.Value;
							text = compiler.GetNsAlias(ref text3);
						}
						else if (Ref.Equal(localName2, input.Atoms.ResultPrefix))
						{
							prefix = input.Value;
							text2 = compiler.GetNsAlias(ref prefix);
						}
						else if (!compiler.ForwardCompatibility)
						{
							throw XsltException.Create("Xslt_InvalidAttribute", localName2, localName);
						}
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			CheckRequiredAttribute(compiler, text, "stylesheet-prefix");
			CheckRequiredAttribute(compiler, text2, "result-prefix");
			CheckEmpty(compiler);
			compiler.AddNamespaceAlias(text, new NamespaceInfo(prefix, text2, compiler.Stylesheetid));
		}

		internal void CompileKey(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			string localName = input.LocalName;
			int num = -1;
			int num2 = -1;
			XmlQualifiedName xmlQualifiedName = null;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					string namespaceURI = input.NamespaceURI;
					string localName2 = input.LocalName;
					string value = input.Value;
					if (namespaceURI.Length == 0)
					{
						if (Ref.Equal(localName2, input.Atoms.Name))
						{
							xmlQualifiedName = compiler.CreateXPathQName(value);
						}
						else if (Ref.Equal(localName2, input.Atoms.Match))
						{
							num = compiler.AddQuery(value, allowVar: false, allowKey: false, isPattern: true);
						}
						else if (Ref.Equal(localName2, input.Atoms.Use))
						{
							num2 = compiler.AddQuery(value, allowVar: false, allowKey: false, isPattern: false);
						}
						else if (!compiler.ForwardCompatibility)
						{
							throw XsltException.Create("Xslt_InvalidAttribute", localName2, localName);
						}
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			CheckRequiredAttribute(compiler, num != -1, "match");
			CheckRequiredAttribute(compiler, num2 != -1, "use");
			CheckRequiredAttribute(compiler, xmlQualifiedName != null, "name");
			compiler.InsertKey(xmlQualifiedName, num, num2);
		}

		protected void CompileDecimalFormat(Compiler compiler)
		{
			NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
			DecimalFormat decimalFormat = new DecimalFormat(numberFormatInfo, '#', '0', ';');
			XmlQualifiedName xmlQualifiedName = null;
			NavigatorInput input = compiler.Input;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					if (input.Prefix.Length != 0)
					{
						continue;
					}
					string localName = input.LocalName;
					string value = input.Value;
					if (Ref.Equal(localName, input.Atoms.Name))
					{
						xmlQualifiedName = compiler.CreateXPathQName(value);
					}
					else if (Ref.Equal(localName, input.Atoms.DecimalSeparator))
					{
						numberFormatInfo.NumberDecimalSeparator = value;
					}
					else if (Ref.Equal(localName, input.Atoms.GroupingSeparator))
					{
						numberFormatInfo.NumberGroupSeparator = value;
					}
					else if (Ref.Equal(localName, input.Atoms.Infinity))
					{
						numberFormatInfo.PositiveInfinitySymbol = value;
					}
					else if (Ref.Equal(localName, input.Atoms.MinusSign))
					{
						numberFormatInfo.NegativeSign = value;
					}
					else if (Ref.Equal(localName, input.Atoms.NaN))
					{
						numberFormatInfo.NaNSymbol = value;
					}
					else if (Ref.Equal(localName, input.Atoms.Percent))
					{
						numberFormatInfo.PercentSymbol = value;
					}
					else if (Ref.Equal(localName, input.Atoms.PerMille))
					{
						numberFormatInfo.PerMilleSymbol = value;
					}
					else if (Ref.Equal(localName, input.Atoms.Digit))
					{
						if (CheckAttribute(value.Length == 1, compiler))
						{
							decimalFormat.digit = value[0];
						}
					}
					else if (Ref.Equal(localName, input.Atoms.ZeroDigit))
					{
						if (CheckAttribute(value.Length == 1, compiler))
						{
							decimalFormat.zeroDigit = value[0];
						}
					}
					else if (Ref.Equal(localName, input.Atoms.PatternSeparator) && CheckAttribute(value.Length == 1, compiler))
					{
						decimalFormat.patternSeparator = value[0];
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			numberFormatInfo.NegativeInfinitySymbol = numberFormatInfo.NegativeSign + numberFormatInfo.PositiveInfinitySymbol;
			if (xmlQualifiedName == null)
			{
				xmlQualifiedName = new XmlQualifiedName();
			}
			compiler.AddDecimalFormat(xmlQualifiedName, decimalFormat);
			CheckEmpty(compiler);
		}

		internal bool CheckAttribute(bool valid, Compiler compiler)
		{
			if (!valid)
			{
				if (!compiler.ForwardCompatibility)
				{
					throw XsltException.Create("Xslt_InvalidAttrValue", compiler.Input.LocalName, compiler.Input.Value);
				}
				return false;
			}
			return true;
		}

		protected void CompileSpace(Compiler compiler, bool preserve)
		{
			string singleAttribute = compiler.GetSingleAttribute(compiler.Input.Atoms.Elements);
			string[] array = XmlConvert.SplitString(singleAttribute);
			for (int i = 0; i < array.Length; i++)
			{
				double priority = NameTest(array[i]);
				compiler.CompiledStylesheet.AddSpace(compiler, array[i], priority, preserve);
			}
			CheckEmpty(compiler);
		}

		private double NameTest(string name)
		{
			if (name == "*")
			{
				return -0.5;
			}
			int num = name.Length - 2;
			if (0 <= num && name[num] == ':' && name[num + 1] == '*')
			{
				if (!PrefixQName.ValidatePrefix(name.Substring(0, num)))
				{
					throw XsltException.Create("Xslt_InvalidAttrValue", "elements", name);
				}
				return -0.25;
			}
			PrefixQName.ParseQualifiedName(name, out var _, out var _);
			return 0.0;
		}

		protected void CompileTopLevelElements(Compiler compiler)
		{
			if (!compiler.Recurse())
			{
				return;
			}
			NavigatorInput input = compiler.Input;
			bool flag = false;
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
				{
					string localName = input.LocalName;
					string namespaceURI = input.NamespaceURI;
					if (Ref.Equal(namespaceURI, input.Atoms.UriXsl))
					{
						if (Ref.Equal(localName, input.Atoms.Import))
						{
							if (flag)
							{
								throw XsltException.Create("Xslt_NotFirstImport");
							}
							Uri uri = compiler.ResolveUri(compiler.GetSingleAttribute(compiler.Input.Atoms.Href));
							string text = uri.ToString();
							if (compiler.IsCircularReference(text))
							{
								throw XsltException.Create("Xslt_CircularInclude", text);
							}
							compiler.CompiledStylesheet.Imports.Add(uri);
							CheckEmpty(compiler);
							break;
						}
						if (Ref.Equal(localName, input.Atoms.Include))
						{
							flag = true;
							CompileInclude(compiler);
							break;
						}
						flag = true;
						compiler.PushNamespaceScope();
						if (Ref.Equal(localName, input.Atoms.StripSpace))
						{
							CompileSpace(compiler, preserve: false);
						}
						else if (Ref.Equal(localName, input.Atoms.PreserveSpace))
						{
							CompileSpace(compiler, preserve: true);
						}
						else if (Ref.Equal(localName, input.Atoms.Output))
						{
							CompileOutput(compiler);
						}
						else if (Ref.Equal(localName, input.Atoms.Key))
						{
							CompileKey(compiler);
						}
						else if (Ref.Equal(localName, input.Atoms.DecimalFormat))
						{
							CompileDecimalFormat(compiler);
						}
						else if (Ref.Equal(localName, input.Atoms.NamespaceAlias))
						{
							CompileNamespaceAlias(compiler);
						}
						else if (Ref.Equal(localName, input.Atoms.AttributeSet))
						{
							compiler.AddAttributeSet(compiler.CreateAttributeSetAction());
						}
						else if (Ref.Equal(localName, input.Atoms.Variable))
						{
							VariableAction variableAction = compiler.CreateVariableAction(VariableType.GlobalVariable);
							if (variableAction != null)
							{
								AddAction(variableAction);
							}
						}
						else if (Ref.Equal(localName, input.Atoms.Param))
						{
							VariableAction variableAction2 = compiler.CreateVariableAction(VariableType.GlobalParameter);
							if (variableAction2 != null)
							{
								AddAction(variableAction2);
							}
						}
						else if (Ref.Equal(localName, input.Atoms.Template))
						{
							compiler.AddTemplate(compiler.CreateTemplateAction());
						}
						else if (!compiler.ForwardCompatibility)
						{
							throw compiler.UnexpectedKeyword();
						}
						compiler.PopScope();
					}
					else if (namespaceURI == input.Atoms.UrnMsxsl && localName == input.Atoms.Script)
					{
						AddScript(compiler);
					}
					else if (namespaceURI.Length == 0)
					{
						throw XsltException.Create("Xslt_NullNsAtTopLevel", input.Name);
					}
					break;
				}
				default:
					throw XsltException.Create("Xslt_InvalidContents", "stylesheet");
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		protected void CompileTemplate(Compiler compiler)
		{
			do
			{
				CompileOnceTemplate(compiler);
			}
			while (compiler.Advance());
		}

		protected void CompileOnceTemplate(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (input.NodeType == XPathNodeType.Element)
			{
				string namespaceURI = input.NamespaceURI;
				if (Ref.Equal(namespaceURI, input.Atoms.UriXsl))
				{
					compiler.PushNamespaceScope();
					CompileInstruction(compiler);
					compiler.PopScope();
					return;
				}
				compiler.PushLiteralScope();
				compiler.InsertExtensionNamespace();
				if (compiler.IsExtensionNamespace(namespaceURI))
				{
					AddAction(compiler.CreateNewInstructionAction());
				}
				else
				{
					CompileLiteral(compiler);
				}
				compiler.PopScope();
			}
			else
			{
				CompileLiteral(compiler);
			}
		}

		private void CompileInstruction(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			CompiledAction compiledAction = null;
			string localName = input.LocalName;
			if (Ref.Equal(localName, input.Atoms.ApplyImports))
			{
				compiledAction = compiler.CreateApplyImportsAction();
			}
			else if (Ref.Equal(localName, input.Atoms.ApplyTemplates))
			{
				compiledAction = compiler.CreateApplyTemplatesAction();
			}
			else if (Ref.Equal(localName, input.Atoms.Attribute))
			{
				compiledAction = compiler.CreateAttributeAction();
			}
			else if (Ref.Equal(localName, input.Atoms.CallTemplate))
			{
				compiledAction = compiler.CreateCallTemplateAction();
			}
			else if (Ref.Equal(localName, input.Atoms.Choose))
			{
				compiledAction = compiler.CreateChooseAction();
			}
			else if (Ref.Equal(localName, input.Atoms.Comment))
			{
				compiledAction = compiler.CreateCommentAction();
			}
			else if (Ref.Equal(localName, input.Atoms.Copy))
			{
				compiledAction = compiler.CreateCopyAction();
			}
			else if (Ref.Equal(localName, input.Atoms.CopyOf))
			{
				compiledAction = compiler.CreateCopyOfAction();
			}
			else if (Ref.Equal(localName, input.Atoms.Element))
			{
				compiledAction = compiler.CreateElementAction();
			}
			else
			{
				if (Ref.Equal(localName, input.Atoms.Fallback))
				{
					return;
				}
				if (Ref.Equal(localName, input.Atoms.ForEach))
				{
					compiledAction = compiler.CreateForEachAction();
				}
				else if (Ref.Equal(localName, input.Atoms.If))
				{
					compiledAction = compiler.CreateIfAction(IfAction.ConditionType.ConditionIf);
				}
				else if (Ref.Equal(localName, input.Atoms.Message))
				{
					compiledAction = compiler.CreateMessageAction();
				}
				else if (Ref.Equal(localName, input.Atoms.Number))
				{
					compiledAction = compiler.CreateNumberAction();
				}
				else if (Ref.Equal(localName, input.Atoms.ProcessingInstruction))
				{
					compiledAction = compiler.CreateProcessingInstructionAction();
				}
				else if (Ref.Equal(localName, input.Atoms.Text))
				{
					compiledAction = compiler.CreateTextAction();
				}
				else if (Ref.Equal(localName, input.Atoms.ValueOf))
				{
					compiledAction = compiler.CreateValueOfAction();
				}
				else if (Ref.Equal(localName, input.Atoms.Variable))
				{
					compiledAction = compiler.CreateVariableAction(VariableType.LocalVariable);
				}
				else
				{
					if (!compiler.ForwardCompatibility)
					{
						throw compiler.UnexpectedKeyword();
					}
					compiledAction = compiler.CreateNewInstructionAction();
				}
			}
			AddAction(compiledAction);
		}

		private void CompileLiteral(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			switch (input.NodeType)
			{
			case XPathNodeType.Element:
				AddEvent(compiler.CreateBeginEvent());
				CompileLiteralAttributesAndNamespaces(compiler);
				if (compiler.Recurse())
				{
					CompileTemplate(compiler);
					compiler.ToParent();
				}
				AddEvent(new EndEvent(XPathNodeType.Element));
				break;
			case XPathNodeType.Text:
			case XPathNodeType.SignificantWhitespace:
				AddEvent(compiler.CreateTextEvent());
				break;
			case XPathNodeType.Attribute:
			case XPathNodeType.Namespace:
			case XPathNodeType.Whitespace:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
				break;
			}
		}

		private void CompileLiteralAttributesAndNamespaces(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (input.Navigator.MoveToAttribute("use-attribute-sets", input.Atoms.UriXsl))
			{
				AddAction(compiler.CreateUseAttributeSetsAction());
				input.Navigator.MoveToParent();
			}
			compiler.InsertExcludedNamespace();
			if (input.MoveToFirstNamespace())
			{
				do
				{
					string value = input.Value;
					if (!(value == "http://www.w3.org/1999/XSL/Transform") && !compiler.IsExcludedNamespace(value) && !compiler.IsExtensionNamespace(value) && !compiler.IsNamespaceAlias(value))
					{
						AddEvent(new NamespaceEvent(input));
					}
				}
				while (input.MoveToNextNamespace());
				input.ToParent();
			}
			if (!input.MoveToFirstAttribute())
			{
				return;
			}
			do
			{
				if (!Ref.Equal(input.NamespaceURI, input.Atoms.UriXsl))
				{
					AddEvent(compiler.CreateBeginEvent());
					AddEvents(compiler.CompileAvt(input.Value));
					AddEvent(new EndEvent(XPathNodeType.Attribute));
				}
			}
			while (input.MoveToNextAttribute());
			input.ToParent();
		}

		private void CompileOutput(Compiler compiler)
		{
			compiler.RootAction.Output.Compile(compiler);
		}

		internal void AddAction(Action action)
		{
			if (containedActions == null)
			{
				containedActions = new ArrayList();
			}
			containedActions.Add(action);
			lastCopyCodeAction = null;
		}

		private void EnsureCopyCodeAction()
		{
			if (lastCopyCodeAction == null)
			{
				CopyCodeAction action = new CopyCodeAction();
				AddAction(action);
				lastCopyCodeAction = action;
			}
		}

		protected void AddEvent(Event copyEvent)
		{
			EnsureCopyCodeAction();
			lastCopyCodeAction.AddEvent(copyEvent);
		}

		protected void AddEvents(ArrayList copyEvents)
		{
			EnsureCopyCodeAction();
			lastCopyCodeAction.AddEvents(copyEvents);
		}

		private void AddScript(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			ScriptingLanguage lang = ScriptingLanguage.JScript;
			string text = null;
			if (input.MoveToFirstAttribute())
			{
				do
				{
					if (input.LocalName == input.Atoms.Language)
					{
						string value = input.Value;
						if (string.Compare(value, "jscript", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(value, "javascript", StringComparison.OrdinalIgnoreCase) == 0)
						{
							lang = ScriptingLanguage.JScript;
							continue;
						}
						if (string.Compare(value, "c#", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(value, "csharp", StringComparison.OrdinalIgnoreCase) == 0)
						{
							lang = ScriptingLanguage.CSharp;
							continue;
						}
						if (string.Compare(value, "vb", StringComparison.OrdinalIgnoreCase) != 0 && string.Compare(value, "visualbasic", StringComparison.OrdinalIgnoreCase) != 0)
						{
							throw XsltException.Create("Xslt_ScriptInvalidLanguage", value);
						}
						lang = ScriptingLanguage.VisualBasic;
					}
					else if (input.LocalName == input.Atoms.ImplementsPrefix)
					{
						if (!PrefixQName.ValidatePrefix(input.Value))
						{
							throw XsltException.Create("Xslt_InvalidAttrValue", input.LocalName, input.Value);
						}
						text = compiler.ResolveXmlNamespace(input.Value);
					}
				}
				while (input.MoveToNextAttribute());
				input.ToParent();
			}
			if (text == null)
			{
				throw XsltException.Create("Xslt_MissingAttribute", input.Atoms.ImplementsPrefix);
			}
			if (!input.Recurse() || input.NodeType != XPathNodeType.Text)
			{
				throw XsltException.Create("Xslt_ScriptEmpty");
			}
			compiler.AddScript(input.Value, lang, text, input.BaseURI, input.LineNumber);
			input.ToParent();
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
					frame.State = 1;
				}
				else
				{
					frame.Finished();
				}
				break;
			case 1:
				frame.Finished();
				break;
			}
		}

		internal Action GetAction(int actionIndex)
		{
			if (containedActions != null && actionIndex < containedActions.Count)
			{
				return (Action)containedActions[actionIndex];
			}
			return null;
		}

		internal void CheckDuplicateParams(XmlQualifiedName name)
		{
			if (containedActions == null)
			{
				return;
			}
			foreach (CompiledAction containedAction in containedActions)
			{
				if (containedAction is WithParamAction withParamAction && withParamAction.Name == name)
				{
					throw XsltException.Create("Xslt_DuplicateWithParam", name.ToString());
				}
			}
		}

		internal override void ReplaceNamespaceAlias(Compiler compiler)
		{
			if (containedActions != null)
			{
				int count = containedActions.Count;
				for (int i = 0; i < containedActions.Count; i++)
				{
					((Action)containedActions[i]).ReplaceNamespaceAlias(compiler);
				}
			}
		}
	}
	internal class CopyAction : ContainerAction
	{
		private const int CopyText = 4;

		private const int NamespaceCopy = 5;

		private const int ContentsCopy = 6;

		private const int ProcessChildren = 7;

		private const int ChildrenOnly = 8;

		private string useAttributeSets;

		private bool empty;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
			if (containedActions == null)
			{
				empty = true;
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.UseAttributeSets))
			{
				useAttributeSets = value;
				AddAction(compiler.CreateUseAttributeSetsAction());
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			while (processor.CanContinue)
			{
				switch (frame.State)
				{
				default:
					return;
				case 0:
					if (Processor.IsRoot(frame.Node))
					{
						processor.PushActionFrame(frame);
						frame.State = 8;
						return;
					}
					if (processor.CopyBeginEvent(frame.Node, empty))
					{
						frame.State = 5;
						break;
					}
					return;
				case 5:
					frame.State = 6;
					if (frame.Node.NodeType == XPathNodeType.Element)
					{
						processor.PushActionFrame(CopyNamespacesAction.GetAction(), frame.NodeSet);
						return;
					}
					break;
				case 6:
					if (frame.Node.NodeType == XPathNodeType.Element && !empty)
					{
						processor.PushActionFrame(frame);
						frame.State = 7;
						return;
					}
					if (processor.CopyTextEvent(frame.Node))
					{
						frame.State = 7;
						break;
					}
					return;
				case 7:
					if (processor.CopyEndEvent(frame.Node))
					{
						frame.Finished();
					}
					return;
				case 8:
					frame.Finished();
					return;
				case 1:
				case 2:
				case 3:
				case 4:
					return;
				}
			}
		}
	}
	internal sealed class CopyAttributesAction : Action
	{
		private const int BeginEvent = 2;

		private const int TextEvent = 3;

		private const int EndEvent = 4;

		private const int Advance = 5;

		private static CopyAttributesAction s_Action = new CopyAttributesAction();

		internal static CopyAttributesAction GetAction()
		{
			return s_Action;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			while (processor.CanContinue)
			{
				switch (frame.State)
				{
				default:
					return;
				case 0:
					if (!frame.Node.HasAttributes || !frame.Node.MoveToFirstAttribute())
					{
						frame.Finished();
						return;
					}
					frame.State = 2;
					goto case 2;
				case 2:
					if (SendBeginEvent(processor, frame.Node))
					{
						frame.State = 3;
						break;
					}
					return;
				case 3:
					if (SendTextEvent(processor, frame.Node))
					{
						frame.State = 4;
						break;
					}
					return;
				case 4:
					if (SendEndEvent(processor, frame.Node))
					{
						frame.State = 5;
						break;
					}
					return;
				case 5:
					if (frame.Node.MoveToNextAttribute())
					{
						frame.State = 2;
						break;
					}
					frame.Node.MoveToParent();
					frame.Finished();
					return;
				case 1:
					return;
				}
			}
		}

		private static bool SendBeginEvent(Processor processor, XPathNavigator node)
		{
			return processor.BeginEvent(XPathNodeType.Attribute, node.Prefix, node.LocalName, node.NamespaceURI, empty: false);
		}

		private static bool SendTextEvent(Processor processor, XPathNavigator node)
		{
			return processor.TextEvent(node.Value);
		}

		private static bool SendEndEvent(Processor processor, XPathNavigator node)
		{
			return processor.EndEvent(XPathNodeType.Attribute);
		}
	}
	internal class CopyCodeAction : Action
	{
		private const int Outputting = 2;

		private ArrayList copyEvents;

		internal CopyCodeAction()
		{
			copyEvents = new ArrayList();
		}

		internal void AddEvent(Event copyEvent)
		{
			copyEvents.Add(copyEvent);
		}

		internal void AddEvents(ArrayList copyEvents)
		{
			this.copyEvents.AddRange(copyEvents);
		}

		internal override void ReplaceNamespaceAlias(Compiler compiler)
		{
			int count = copyEvents.Count;
			for (int i = 0; i < count; i++)
			{
				((Event)copyEvents[i]).ReplaceNamespaceAlias(compiler);
			}
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				frame.Counter = 0;
				frame.State = 2;
				break;
			case 2:
				break;
			}
			while (processor.CanContinue)
			{
				Event @event = (Event)copyEvents[frame.Counter];
				if (@event.Output(processor, frame))
				{
					if (frame.IncrementCounter() >= copyEvents.Count)
					{
						frame.Finished();
						break;
					}
					continue;
				}
				break;
			}
		}

		internal override DbgData GetDbgData(ActionFrame frame)
		{
			return ((Event)copyEvents[frame.Counter]).DbgData;
		}
	}
	internal sealed class CopyNamespacesAction : Action
	{
		private const int BeginEvent = 2;

		private const int TextEvent = 3;

		private const int EndEvent = 4;

		private const int Advance = 5;

		private static CopyNamespacesAction s_Action = new CopyNamespacesAction();

		internal static CopyNamespacesAction GetAction()
		{
			return s_Action;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			while (processor.CanContinue)
			{
				switch (frame.State)
				{
				default:
					return;
				case 0:
					if (!frame.Node.MoveToFirstNamespace(XPathNamespaceScope.ExcludeXml))
					{
						frame.Finished();
						return;
					}
					frame.State = 2;
					goto case 2;
				case 2:
					if (processor.BeginEvent(XPathNodeType.Namespace, null, frame.Node.LocalName, frame.Node.Value, empty: false))
					{
						frame.State = 4;
						break;
					}
					return;
				case 4:
					if (processor.EndEvent(XPathNodeType.Namespace))
					{
						frame.State = 5;
						break;
					}
					return;
				case 5:
					if (frame.Node.MoveToNextNamespace(XPathNamespaceScope.ExcludeXml))
					{
						frame.State = 2;
						break;
					}
					frame.Node.MoveToParent();
					frame.Finished();
					return;
				case 1:
				case 3:
					return;
				}
			}
		}
	}
	internal sealed class CopyNodeSetAction : Action
	{
		private const int BeginEvent = 2;

		private const int Contents = 3;

		private const int Namespaces = 4;

		private const int Attributes = 5;

		private const int Subtree = 6;

		private const int EndEvent = 7;

		private static CopyNodeSetAction s_Action = new CopyNodeSetAction();

		internal static CopyNodeSetAction GetAction()
		{
			return s_Action;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			while (processor.CanContinue)
			{
				switch (frame.State)
				{
				default:
					return;
				case 0:
					if (frame.NextNode(processor))
					{
						frame.State = 2;
						goto case 2;
					}
					frame.Finished();
					return;
				case 2:
					if (SendBeginEvent(processor, frame.Node))
					{
						frame.State = 3;
						continue;
					}
					return;
				case 3:
				{
					XPathNodeType nodeType = frame.Node.NodeType;
					if (nodeType == XPathNodeType.Element || nodeType == XPathNodeType.Root)
					{
						processor.PushActionFrame(CopyNamespacesAction.GetAction(), frame.NodeSet);
						frame.State = 4;
					}
					else if (SendTextEvent(processor, frame.Node))
					{
						frame.State = 7;
						continue;
					}
					return;
				}
				case 4:
					processor.PushActionFrame(CopyAttributesAction.GetAction(), frame.NodeSet);
					frame.State = 5;
					return;
				case 5:
					if (frame.Node.HasChildren)
					{
						processor.PushActionFrame(GetAction(), frame.Node.SelectChildren(XPathNodeType.All));
						frame.State = 6;
						return;
					}
					frame.State = 7;
					break;
				case 6:
					frame.State = 7;
					continue;
				case 7:
					break;
				case 1:
					return;
				}
				if (SendEndEvent(processor, frame.Node))
				{
					frame.State = 0;
					continue;
				}
				break;
			}
		}

		private static bool SendBeginEvent(Processor processor, XPathNavigator node)
		{
			return processor.CopyBeginEvent(node, node.IsEmptyElement);
		}

		private static bool SendTextEvent(Processor processor, XPathNavigator node)
		{
			return processor.CopyTextEvent(node);
		}

		private static bool SendEndEvent(Processor processor, XPathNavigator node)
		{
			return processor.CopyEndEvent(node);
		}
	}
	internal class CopyOfAction : CompiledAction
	{
		private const int ResultStored = 2;

		private const int NodeSetCopied = 3;

		private int selectKey = -1;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, selectKey != -1, "select");
			CheckEmpty(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Select))
			{
				selectKey = compiler.AddQuery(value);
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
			{
				Query valueQuery = processor.GetValueQuery(selectKey);
				object obj = valueQuery.Evaluate(frame.NodeSet);
				if (obj is XPathNodeIterator)
				{
					processor.PushActionFrame(CopyNodeSetAction.GetAction(), new XPathArrayIterator(valueQuery));
					frame.State = 3;
					break;
				}
				if (obj is XPathNavigator nav)
				{
					processor.PushActionFrame(CopyNodeSetAction.GetAction(), new XPathSingletonIterator(nav));
					frame.State = 3;
					break;
				}
				string text = XmlConvert.ToXPathString(obj);
				if (processor.TextEvent(text))
				{
					frame.Finished();
					break;
				}
				frame.StoredOutput = text;
				frame.State = 2;
				break;
			}
			case 2:
				processor.TextEvent(frame.StoredOutput);
				frame.Finished();
				break;
			case 3:
				frame.Finished();
				break;
			case 1:
				break;
			}
		}
	}
	internal class DbgData
	{
		private XPathNavigator styleSheet;

		private VariableAction[] variables;

		private static DbgData s_nullDbgData = new DbgData();

		public XPathNavigator StyleSheet => styleSheet;

		public VariableAction[] Variables => variables;

		public static DbgData Empty => s_nullDbgData;

		public DbgData(Compiler compiler)
		{
			DbgCompiler dbgCompiler = (DbgCompiler)compiler;
			styleSheet = dbgCompiler.Input.Navigator.Clone();
			variables = dbgCompiler.LocalVariables;
			dbgCompiler.Debugger.OnInstructionCompile(StyleSheet);
		}

		internal void ReplaceVariables(VariableAction[] vars)
		{
			variables = vars;
		}

		private DbgData()
		{
			styleSheet = null;
			variables = new VariableAction[0];
		}
	}
	internal class DbgCompiler : Compiler
	{
		private class ApplyImportsActionDbg : ApplyImportsAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class ApplyTemplatesActionDbg : ApplyTemplatesAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class AttributeActionDbg : AttributeAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class AttributeSetActionDbg : AttributeSetAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class CallTemplateActionDbg : CallTemplateAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class CommentActionDbg : CommentAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class CopyActionDbg : CopyAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class CopyOfActionDbg : CopyOfAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class ElementActionDbg : ElementAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class ForEachActionDbg : ForEachAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.PushDebuggerStack();
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
				if (frame.State == -1)
				{
					processor.PopDebuggerStack();
				}
			}
		}

		private class IfActionDbg : IfAction
		{
			private DbgData dbgData;

			internal IfActionDbg(ConditionType type)
				: base(type)
			{
			}

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class MessageActionDbg : MessageAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class NewInstructionActionDbg : NewInstructionAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class NumberActionDbg : NumberAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class ProcessingInstructionActionDbg : ProcessingInstructionAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class RootActionDbg : RootAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
				string builtInTemplatesUri = compiler.Debugger.GetBuiltInTemplatesUri();
				if (builtInTemplatesUri != null && builtInTemplatesUri.Length != 0)
				{
					compiler.AllowBuiltInMode = true;
					builtInSheet = compiler.RootAction.CompileImport(compiler, compiler.ResolveUri(builtInTemplatesUri), int.MaxValue);
					compiler.AllowBuiltInMode = false;
				}
				dbgData.ReplaceVariables(((DbgCompiler)compiler).GlobalVariables);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.PushDebuggerStack();
					processor.OnInstructionExecute();
					processor.PushDebuggerStack();
				}
				base.Execute(processor, frame);
				if (frame.State == -1)
				{
					processor.PopDebuggerStack();
					processor.PopDebuggerStack();
				}
			}
		}

		private class SortActionDbg : SortAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class TemplateActionDbg : TemplateAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.PushDebuggerStack();
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
				if (frame.State == -1)
				{
					processor.PopDebuggerStack();
				}
			}
		}

		private class TextActionDbg : TextAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class UseAttributeSetsActionDbg : UseAttributeSetsAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class ValueOfActionDbg : ValueOfAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class VariableActionDbg : VariableAction
		{
			private DbgData dbgData;

			internal VariableActionDbg(VariableType type)
				: base(type)
			{
			}

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
				((DbgCompiler)compiler).DefineVariable(this);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class WithParamActionDbg : WithParamAction
		{
			private DbgData dbgData;

			internal override DbgData GetDbgData(ActionFrame frame)
			{
				return dbgData;
			}

			internal override void Compile(Compiler compiler)
			{
				dbgData = new DbgData(compiler);
				base.Compile(compiler);
			}

			internal override void Execute(Processor processor, ActionFrame frame)
			{
				if (frame.State == 0)
				{
					processor.OnInstructionExecute();
				}
				base.Execute(processor, frame);
			}
		}

		private class BeginEventDbg : BeginEvent
		{
			private DbgData dbgData;

			internal override DbgData DbgData => dbgData;

			public BeginEventDbg(Compiler compiler)
				: base(compiler)
			{
				dbgData = new DbgData(compiler);
			}

			public override bool Output(Processor processor, ActionFrame frame)
			{
				OnInstructionExecute(processor);
				return base.Output(processor, frame);
			}
		}

		private class TextEventDbg : TextEvent
		{
			private DbgData dbgData;

			internal override DbgData DbgData => dbgData;

			public TextEventDbg(Compiler compiler)
				: base(compiler)
			{
				dbgData = new DbgData(compiler);
			}

			public override bool Output(Processor processor, ActionFrame frame)
			{
				OnInstructionExecute(processor);
				return base.Output(processor, frame);
			}
		}

		private IXsltDebugger debugger;

		private ArrayList globalVars = new ArrayList();

		private ArrayList localVars = new ArrayList();

		private VariableAction[] globalVarsCache;

		private VariableAction[] localVarsCache;

		public override IXsltDebugger Debugger => debugger;

		public virtual VariableAction[] GlobalVariables
		{
			get
			{
				if (globalVarsCache == null)
				{
					globalVarsCache = (VariableAction[])globalVars.ToArray(typeof(VariableAction));
				}
				return globalVarsCache;
			}
		}

		public virtual VariableAction[] LocalVariables
		{
			get
			{
				if (localVarsCache == null)
				{
					localVarsCache = (VariableAction[])localVars.ToArray(typeof(VariableAction));
				}
				return localVarsCache;
			}
		}

		public DbgCompiler(IXsltDebugger debugger)
		{
			this.debugger = debugger;
		}

		private void DefineVariable(VariableAction variable)
		{
			if (variable.IsGlobal)
			{
				for (int i = 0; i < globalVars.Count; i++)
				{
					VariableAction variableAction = (VariableAction)globalVars[i];
					if (variableAction.Name == variable.Name)
					{
						if (variable.Stylesheetid < variableAction.Stylesheetid)
						{
							globalVars[i] = variable;
							globalVarsCache = null;
						}
						return;
					}
				}
				globalVars.Add(variable);
				globalVarsCache = null;
			}
			else
			{
				localVars.Add(variable);
				localVarsCache = null;
			}
		}

		private void UnDefineVariables(int count)
		{
			if (count != 0)
			{
				localVars.RemoveRange(localVars.Count - count, count);
				localVarsCache = null;
			}
		}

		internal override void PopScope()
		{
			UnDefineVariables(base.ScopeManager.CurrentScope.GetVeriablesCount());
			base.PopScope();
		}

		public override ApplyImportsAction CreateApplyImportsAction()
		{
			ApplyImportsAction applyImportsAction = new ApplyImportsActionDbg();
			applyImportsAction.Compile(this);
			return applyImportsAction;
		}

		public override ApplyTemplatesAction CreateApplyTemplatesAction()
		{
			ApplyTemplatesAction applyTemplatesAction = new ApplyTemplatesActionDbg();
			applyTemplatesAction.Compile(this);
			return applyTemplatesAction;
		}

		public override AttributeAction CreateAttributeAction()
		{
			AttributeAction attributeAction = new AttributeActionDbg();
			attributeAction.Compile(this);
			return attributeAction;
		}

		public override AttributeSetAction CreateAttributeSetAction()
		{
			AttributeSetAction attributeSetAction = new AttributeSetActionDbg();
			attributeSetAction.Compile(this);
			return attributeSetAction;
		}

		public override CallTemplateAction CreateCallTemplateAction()
		{
			CallTemplateAction callTemplateAction = new CallTemplateActionDbg();
			callTemplateAction.Compile(this);
			return callTemplateAction;
		}

		public override ChooseAction CreateChooseAction()
		{
			ChooseAction chooseAction = new ChooseAction();
			chooseAction.Compile(this);
			return chooseAction;
		}

		public override CommentAction CreateCommentAction()
		{
			CommentAction commentAction = new CommentActionDbg();
			commentAction.Compile(this);
			return commentAction;
		}

		public override CopyAction CreateCopyAction()
		{
			CopyAction copyAction = new CopyActionDbg();
			copyAction.Compile(this);
			return copyAction;
		}

		public override CopyOfAction CreateCopyOfAction()
		{
			CopyOfAction copyOfAction = new CopyOfActionDbg();
			copyOfAction.Compile(this);
			return copyOfAction;
		}

		public override ElementAction CreateElementAction()
		{
			ElementAction elementAction = new ElementActionDbg();
			elementAction.Compile(this);
			return elementAction;
		}

		public override ForEachAction CreateForEachAction()
		{
			ForEachAction forEachAction = new ForEachActionDbg();
			forEachAction.Compile(this);
			return forEachAction;
		}

		public override IfAction CreateIfAction(IfAction.ConditionType type)
		{
			IfAction ifAction = new IfActionDbg(type);
			ifAction.Compile(this);
			return ifAction;
		}

		public override MessageAction CreateMessageAction()
		{
			MessageAction messageAction = new MessageActionDbg();
			messageAction.Compile(this);
			return messageAction;
		}

		public override NewInstructionAction CreateNewInstructionAction()
		{
			NewInstructionAction newInstructionAction = new NewInstructionActionDbg();
			newInstructionAction.Compile(this);
			return newInstructionAction;
		}

		public override NumberAction CreateNumberAction()
		{
			NumberAction numberAction = new NumberActionDbg();
			numberAction.Compile(this);
			return numberAction;
		}

		public override ProcessingInstructionAction CreateProcessingInstructionAction()
		{
			ProcessingInstructionAction processingInstructionAction = new ProcessingInstructionActionDbg();
			processingInstructionAction.Compile(this);
			return processingInstructionAction;
		}

		public override void CreateRootAction()
		{
			base.RootAction = new RootActionDbg();
			base.RootAction.Compile(this);
		}

		public override SortAction CreateSortAction()
		{
			SortAction sortAction = new SortActionDbg();
			sortAction.Compile(this);
			return sortAction;
		}

		public override TemplateAction CreateTemplateAction()
		{
			TemplateAction templateAction = new TemplateActionDbg();
			templateAction.Compile(this);
			return templateAction;
		}

		public override TemplateAction CreateSingleTemplateAction()
		{
			TemplateAction templateAction = new TemplateActionDbg();
			templateAction.CompileSingle(this);
			return templateAction;
		}

		public override TextAction CreateTextAction()
		{
			TextAction textAction = new TextActionDbg();
			textAction.Compile(this);
			return textAction;
		}

		public override UseAttributeSetsAction CreateUseAttributeSetsAction()
		{
			UseAttributeSetsAction useAttributeSetsAction = new UseAttributeSetsActionDbg();
			useAttributeSetsAction.Compile(this);
			return useAttributeSetsAction;
		}

		public override ValueOfAction CreateValueOfAction()
		{
			ValueOfAction valueOfAction = new ValueOfActionDbg();
			valueOfAction.Compile(this);
			return valueOfAction;
		}

		public override VariableAction CreateVariableAction(VariableType type)
		{
			VariableAction variableAction = new VariableActionDbg(type);
			variableAction.Compile(this);
			return variableAction;
		}

		public override WithParamAction CreateWithParamAction()
		{
			WithParamAction withParamAction = new WithParamActionDbg();
			withParamAction.Compile(this);
			return withParamAction;
		}

		public override BeginEvent CreateBeginEvent()
		{
			return new BeginEventDbg(this);
		}

		public override TextEvent CreateTextEvent()
		{
			return new TextEventDbg(this);
		}
	}
	internal class DocumentScope
	{
		protected NamespaceDecl scopes;

		internal NamespaceDecl Scopes => scopes;

		internal NamespaceDecl AddNamespace(string prefix, string uri, string prevDefaultNsUri)
		{
			scopes = new NamespaceDecl(prefix, uri, prevDefaultNsUri, scopes);
			return scopes;
		}

		internal string ResolveAtom(string prefix)
		{
			for (NamespaceDecl next = scopes; next != null; next = next.Next)
			{
				if (Ref.Equal(next.Prefix, prefix))
				{
					return next.Uri;
				}
			}
			return null;
		}

		internal string ResolveNonAtom(string prefix)
		{
			for (NamespaceDecl next = scopes; next != null; next = next.Next)
			{
				if (next.Prefix == prefix)
				{
					return next.Uri;
				}
			}
			return null;
		}
	}
	internal class ElementAction : ContainerAction
	{
		private const int NameDone = 2;

		private Avt nameAvt;

		private Avt nsAvt;

		private bool empty;

		private InputScopeManager manager;

		private string name;

		private string nsUri;

		private PrefixQName qname;

		internal ElementAction()
		{
		}

		private static PrefixQName CreateElementQName(string name, string nsUri, InputScopeManager manager)
		{
			if (nsUri == "http://www.w3.org/2000/xmlns/")
			{
				throw XsltException.Create("Xslt_ReservedNS", nsUri);
			}
			PrefixQName prefixQName = new PrefixQName();
			prefixQName.SetQName(name);
			if (nsUri == null)
			{
				prefixQName.Namespace = manager.ResolveXmlNamespace(prefixQName.Prefix);
			}
			else
			{
				prefixQName.Namespace = nsUri;
			}
			return prefixQName;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, nameAvt, "name");
			name = CompiledAction.PrecalculateAvt(ref nameAvt);
			nsUri = CompiledAction.PrecalculateAvt(ref nsAvt);
			if (nameAvt == null && nsAvt == null)
			{
				if (name != "xmlns")
				{
					qname = CreateElementQName(name, nsUri, compiler.CloneScopeManager());
				}
			}
			else
			{
				manager = compiler.CloneScopeManager();
			}
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
			empty = containedActions == null;
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Name))
			{
				nameAvt = Avt.CompileAvt(compiler, value);
			}
			else if (Ref.Equal(localName, compiler.Atoms.Namespace))
			{
				nsAvt = Avt.CompileAvt(compiler, value);
			}
			else
			{
				if (!Ref.Equal(localName, compiler.Atoms.UseAttributeSets))
				{
					return false;
				}
				AddAction(compiler.CreateUseAttributeSetsAction());
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				if (qname != null)
				{
					frame.CalulatedName = qname;
				}
				else
				{
					frame.CalulatedName = CreateElementQName((nameAvt == null) ? name : nameAvt.Evaluate(processor, frame), (nsAvt == null) ? nsUri : nsAvt.Evaluate(processor, frame), manager);
				}
				goto case 2;
			case 2:
			{
				PrefixQName calulatedName = frame.CalulatedName;
				if (!processor.BeginEvent(XPathNodeType.Element, calulatedName.Prefix, calulatedName.Name, calulatedName.Namespace, empty))
				{
					frame.State = 2;
					return;
				}
				if (!empty)
				{
					processor.PushActionFrame(frame);
					frame.State = 1;
					return;
				}
				break;
			}
			case 1:
				break;
			}
			if (!processor.EndEvent(XPathNodeType.Element))
			{
				frame.State = 1;
			}
			else
			{
				frame.Finished();
			}
		}
	}
	internal class EndEvent : Event
	{
		private XPathNodeType nodeType;

		internal EndEvent(XPathNodeType nodeType)
		{
			this.nodeType = nodeType;
		}

		public override bool Output(Processor processor, ActionFrame frame)
		{
			return processor.EndEvent(nodeType);
		}
	}
	internal abstract class Event
	{
		internal virtual DbgData DbgData => DbgData.Empty;

		public virtual void ReplaceNamespaceAlias(Compiler compiler)
		{
		}

		public abstract bool Output(Processor processor, ActionFrame frame);

		internal void OnInstructionExecute(Processor processor)
		{
			processor.OnInstructionExecute();
		}
	}
	internal class ForEachAction : ContainerAction
	{
		private const int ProcessedSort = 2;

		private const int ProcessNextNode = 3;

		private const int PositionAdvanced = 4;

		private const int ContentsProcessed = 5;

		private int selectKey = -1;

		private ContainerAction sortContainer;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, selectKey != -1, "select");
			compiler.CanHaveApplyImports = false;
			if (compiler.Recurse())
			{
				CompileSortElements(compiler);
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Select))
			{
				selectKey = compiler.AddQuery(value);
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				if (sortContainer != null)
				{
					processor.InitSortArray();
					processor.PushActionFrame(sortContainer, frame.NodeSet);
					frame.State = 2;
					return;
				}
				goto case 2;
			case 2:
				frame.InitNewNodeSet(processor.StartQuery(frame.NodeSet, selectKey));
				if (sortContainer != null)
				{
					frame.SortNewNodeSet(processor, processor.SortArray);
				}
				frame.State = 3;
				goto case 3;
			case 3:
				if (frame.NewNextNode(processor))
				{
					frame.State = 4;
					break;
				}
				frame.Finished();
				return;
			case 4:
				break;
			case 5:
				frame.State = 3;
				goto case 3;
			case 1:
				return;
			}
			processor.PushActionFrame(frame, frame.NewNodeSet);
			frame.State = 5;
		}

		protected void CompileSortElements(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
					if (Ref.Equal(input.NamespaceURI, input.Atoms.UriXsl) && Ref.Equal(input.LocalName, input.Atoms.Sort))
					{
						if (sortContainer == null)
						{
							sortContainer = new ContainerAction();
						}
						sortContainer.AddAction(compiler.CreateSortAction());
						break;
					}
					return;
				case XPathNodeType.Text:
					return;
				case XPathNodeType.SignificantWhitespace:
					AddEvent(compiler.CreateTextEvent());
					break;
				}
			}
			while (input.Advance());
		}
	}
	internal class HtmlElementProps
	{
		private bool empty;

		private bool abrParent;

		private bool uriParent;

		private bool noEntities;

		private bool blockWS;

		private bool head;

		private bool nameParent;

		private static Hashtable s_table = CreatePropsTable();

		public bool Empty => empty;

		public bool AbrParent => abrParent;

		public bool UriParent => uriParent;

		public bool NoEntities => noEntities;

		public bool BlockWS => blockWS;

		public bool Head => head;

		public bool NameParent => nameParent;

		public static HtmlElementProps Create(bool empty, bool abrParent, bool uriParent, bool noEntities, bool blockWS, bool head, bool nameParent)
		{
			HtmlElementProps htmlElementProps = new HtmlElementProps();
			htmlElementProps.empty = empty;
			htmlElementProps.abrParent = abrParent;
			htmlElementProps.uriParent = uriParent;
			htmlElementProps.noEntities = noEntities;
			htmlElementProps.blockWS = blockWS;
			htmlElementProps.head = head;
			htmlElementProps.nameParent = nameParent;
			return htmlElementProps;
		}

		public static HtmlElementProps GetProps(string name)
		{
			return (HtmlElementProps)s_table[name];
		}

		private static Hashtable CreatePropsTable()
		{
			bool flag = false;
			bool flag2 = true;
			Hashtable hashtable = new Hashtable(71, StringComparer.OrdinalIgnoreCase);
			hashtable.Add("a", Create(flag, flag, flag2, flag, flag, flag, flag2));
			hashtable.Add("address", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("applet", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("area", Create(flag2, flag2, flag2, flag, flag2, flag, flag));
			hashtable.Add("base", Create(flag2, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("basefont", Create(flag2, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("blockquote", Create(flag, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("body", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("br", Create(flag2, flag, flag, flag, flag, flag, flag));
			hashtable.Add("button", Create(flag, flag2, flag, flag, flag, flag, flag));
			hashtable.Add("caption", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("center", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("col", Create(flag2, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("colgroup", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("dd", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("del", Create(flag, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("dir", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("div", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("dl", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("dt", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("fieldset", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("font", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("form", Create(flag, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("frame", Create(flag2, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("frameset", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h1", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h2", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h3", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h4", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h5", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("h6", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("head", Create(flag, flag, flag2, flag, flag2, flag2, flag));
			hashtable.Add("hr", Create(flag2, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("html", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("iframe", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("img", Create(flag2, flag2, flag2, flag, flag, flag, flag));
			hashtable.Add("input", Create(flag2, flag2, flag2, flag, flag, flag, flag));
			hashtable.Add("ins", Create(flag, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("isindex", Create(flag2, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("legend", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("li", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("link", Create(flag2, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("map", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("menu", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("meta", Create(flag2, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("noframes", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("noscript", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("object", Create(flag, flag2, flag2, flag, flag, flag, flag));
			hashtable.Add("ol", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("optgroup", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("option", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("p", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("param", Create(flag2, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("pre", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("q", Create(flag, flag, flag2, flag, flag, flag, flag));
			hashtable.Add("s", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("script", Create(flag, flag2, flag2, flag2, flag, flag, flag));
			hashtable.Add("select", Create(flag, flag2, flag, flag, flag, flag, flag));
			hashtable.Add("strike", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("style", Create(flag, flag, flag, flag2, flag2, flag, flag));
			hashtable.Add("table", Create(flag, flag, flag2, flag, flag2, flag, flag));
			hashtable.Add("tbody", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("td", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("textarea", Create(flag, flag2, flag, flag, flag, flag, flag));
			hashtable.Add("tfoot", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("th", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("thead", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("title", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("tr", Create(flag, flag, flag, flag, flag2, flag, flag));
			hashtable.Add("ul", Create(flag, flag2, flag, flag, flag2, flag, flag));
			hashtable.Add("xmp", Create(flag, flag, flag, flag, flag, flag, flag));
			return hashtable;
		}
	}
	internal class HtmlAttributeProps
	{
		private bool abr;

		private bool uri;

		private bool name;

		private static Hashtable s_table = CreatePropsTable();

		public bool Abr => abr;

		public bool Uri => uri;

		public bool Name => name;

		public static HtmlAttributeProps Create(bool abr, bool uri, bool name)
		{
			HtmlAttributeProps htmlAttributeProps = new HtmlAttributeProps();
			htmlAttributeProps.abr = abr;
			htmlAttributeProps.uri = uri;
			htmlAttributeProps.name = name;
			return htmlAttributeProps;
		}

		public static HtmlAttributeProps GetProps(string name)
		{
			return (HtmlAttributeProps)s_table[name];
		}

		private static Hashtable CreatePropsTable()
		{
			bool flag = false;
			bool flag2 = true;
			Hashtable hashtable = new Hashtable(26, StringComparer.OrdinalIgnoreCase);
			hashtable.Add("action", Create(flag, flag2, flag));
			hashtable.Add("checked", Create(flag2, flag, flag));
			hashtable.Add("cite", Create(flag, flag2, flag));
			hashtable.Add("classid", Create(flag, flag2, flag));
			hashtable.Add("codebase", Create(flag, flag2, flag));
			hashtable.Add("compact", Create(flag2, flag, flag));
			hashtable.Add("data", Create(flag, flag2, flag));
			hashtable.Add("datasrc", Create(flag, flag2, flag));
			hashtable.Add("declare", Create(flag2, flag, flag));
			hashtable.Add("defer", Create(flag2, flag, flag));
			hashtable.Add("disabled", Create(flag2, flag, flag));
			hashtable.Add("for", Create(flag, flag2, flag));
			hashtable.Add("href", Create(flag, flag2, flag));
			hashtable.Add("ismap", Create(flag2, flag, flag));
			hashtable.Add("longdesc", Create(flag, flag2, flag));
			hashtable.Add("multiple", Create(flag2, flag, flag));
			hashtable.Add("name", Create(flag, flag, flag2));
			hashtable.Add("nohref", Create(flag2, flag, flag));
			hashtable.Add("noresize", Create(flag2, flag, flag));
			hashtable.Add("noshade", Create(flag2, flag, flag));
			hashtable.Add("nowrap", Create(flag2, flag, flag));
			hashtable.Add("profile", Create(flag, flag2, flag));
			hashtable.Add("readonly", Create(flag2, flag, flag));
			hashtable.Add("selected", Create(flag2, flag, flag));
			hashtable.Add("src", Create(flag, flag2, flag));
			hashtable.Add("usemap", Create(flag, flag2, flag));
			return hashtable;
		}
	}
	internal class IfAction : ContainerAction
	{
		internal enum ConditionType
		{
			ConditionIf,
			ConditionWhen,
			ConditionOtherwise
		}

		private ConditionType type;

		private int testKey = -1;

		internal IfAction(ConditionType type)
		{
			this.type = type;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (type != ConditionType.ConditionOtherwise)
			{
				CheckRequiredAttribute(compiler, testKey != -1, "test");
			}
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Test))
			{
				if (type == ConditionType.ConditionOtherwise)
				{
					return false;
				}
				testKey = compiler.AddBooleanQuery(value);
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if ((type == ConditionType.ConditionIf || type == ConditionType.ConditionWhen) && !processor.EvaluateBoolean(frame, testKey))
				{
					frame.Finished();
					break;
				}
				processor.PushActionFrame(frame);
				frame.State = 1;
				break;
			case 1:
				if (type == ConditionType.ConditionWhen || type == ConditionType.ConditionOtherwise)
				{
					frame.Exit();
				}
				frame.Finished();
				break;
			}
		}
	}
	internal class InputScope : DocumentScope
	{
		private InputScope parent;

		private bool forwardCompatibility;

		private bool canHaveApplyImports;

		private Hashtable variables;

		private Hashtable extensionNamespaces;

		private Hashtable excludedNamespaces;

		internal InputScope Parent => parent;

		internal Hashtable Variables => variables;

		internal bool ForwardCompatibility
		{
			get
			{
				return forwardCompatibility;
			}
			set
			{
				forwardCompatibility = value;
			}
		}

		internal bool CanHaveApplyImports
		{
			get
			{
				return canHaveApplyImports;
			}
			set
			{
				canHaveApplyImports = value;
			}
		}

		internal InputScope(InputScope parent)
		{
			Init(parent);
		}

		internal void Init(InputScope parent)
		{
			scopes = null;
			this.parent = parent;
			if (this.parent != null)
			{
				forwardCompatibility = this.parent.forwardCompatibility;
				canHaveApplyImports = this.parent.canHaveApplyImports;
			}
		}

		internal void InsertExtensionNamespace(string nspace)
		{
			if (extensionNamespaces == null)
			{
				extensionNamespaces = new Hashtable();
			}
			extensionNamespaces[nspace] = null;
		}

		internal bool IsExtensionNamespace(string nspace)
		{
			if (extensionNamespaces == null)
			{
				return false;
			}
			return extensionNamespaces.Contains(nspace);
		}

		internal void InsertExcludedNamespace(string nspace)
		{
			if (excludedNamespaces == null)
			{
				excludedNamespaces = new Hashtable();
			}
			excludedNamespaces[nspace] = null;
		}

		internal bool IsExcludedNamespace(string nspace)
		{
			if (excludedNamespaces == null)
			{
				return false;
			}
			return excludedNamespaces.Contains(nspace);
		}

		internal void InsertVariable(VariableAction variable)
		{
			if (variables == null)
			{
				variables = new Hashtable();
			}
			variables[variable.Name] = variable;
		}

		internal int GetVeriablesCount()
		{
			if (variables == null)
			{
				return 0;
			}
			return variables.Count;
		}

		public VariableAction ResolveVariable(XmlQualifiedName qname)
		{
			for (InputScope inputScope = this; inputScope != null; inputScope = inputScope.Parent)
			{
				if (inputScope.Variables != null)
				{
					VariableAction variableAction = (VariableAction)inputScope.Variables[qname];
					if (variableAction != null)
					{
						return variableAction;
					}
				}
			}
			return null;
		}

		public VariableAction ResolveGlobalVariable(XmlQualifiedName qname)
		{
			InputScope inputScope = null;
			for (InputScope inputScope2 = this; inputScope2 != null; inputScope2 = inputScope2.Parent)
			{
				inputScope = inputScope2;
			}
			return inputScope.ResolveVariable(qname);
		}
	}
	internal class InputScopeManager
	{
		private InputScope scopeStack;

		private string defaultNS = string.Empty;

		private XPathNavigator navigator;

		internal InputScope CurrentScope => scopeStack;

		internal InputScope VariableScope => scopeStack.Parent;

		public XPathNavigator Navigator => navigator;

		public string DefaultNamespace => defaultNS;

		public InputScopeManager(XPathNavigator navigator, InputScope rootScope)
		{
			this.navigator = navigator;
			scopeStack = rootScope;
		}

		internal InputScopeManager Clone()
		{
			InputScopeManager inputScopeManager = new InputScopeManager(navigator, null);
			inputScopeManager.scopeStack = scopeStack;
			inputScopeManager.defaultNS = defaultNS;
			return inputScopeManager;
		}

		internal InputScope PushScope()
		{
			scopeStack = new InputScope(scopeStack);
			return scopeStack;
		}

		internal void PopScope()
		{
			if (scopeStack != null)
			{
				for (NamespaceDecl namespaceDecl = scopeStack.Scopes; namespaceDecl != null; namespaceDecl = namespaceDecl.Next)
				{
					defaultNS = namespaceDecl.PrevDefaultNsUri;
				}
				scopeStack = scopeStack.Parent;
			}
		}

		internal void PushNamespace(string prefix, string nspace)
		{
			scopeStack.AddNamespace(prefix, nspace, defaultNS);
			if (prefix == null || prefix.Length == 0)
			{
				defaultNS = nspace;
			}
		}

		private string ResolveNonEmptyPrefix(string prefix)
		{
			if (prefix == "xml")
			{
				return "http://www.w3.org/XML/1998/namespace";
			}
			if (prefix == "xmlns")
			{
				return "http://www.w3.org/2000/xmlns/";
			}
			for (InputScope parent = scopeStack; parent != null; parent = parent.Parent)
			{
				string text = parent.ResolveNonAtom(prefix);
				if (text != null)
				{
					return text;
				}
			}
			throw XsltException.Create("Xslt_InvalidPrefix", prefix);
		}

		public string ResolveXmlNamespace(string prefix)
		{
			if (prefix.Length == 0)
			{
				return defaultNS;
			}
			return ResolveNonEmptyPrefix(prefix);
		}

		public string ResolveXPathNamespace(string prefix)
		{
			if (prefix.Length == 0)
			{
				return string.Empty;
			}
			return ResolveNonEmptyPrefix(prefix);
		}

		internal void InsertExtensionNamespaces(string[] nsList)
		{
			for (int i = 0; i < nsList.Length; i++)
			{
				scopeStack.InsertExtensionNamespace(nsList[i]);
			}
		}

		internal bool IsExtensionNamespace(string nspace)
		{
			for (InputScope parent = scopeStack; parent != null; parent = parent.Parent)
			{
				if (parent.IsExtensionNamespace(nspace))
				{
					return true;
				}
			}
			return false;
		}

		internal void InsertExcludedNamespaces(string[] nsList)
		{
			for (int i = 0; i < nsList.Length; i++)
			{
				scopeStack.InsertExcludedNamespace(nsList[i]);
			}
		}

		internal bool IsExcludedNamespace(string nspace)
		{
			for (InputScope parent = scopeStack; parent != null; parent = parent.Parent)
			{
				if (parent.IsExcludedNamespace(nspace))
				{
					return true;
				}
			}
			return false;
		}
	}
	internal class MessageAction : ContainerAction
	{
		private bool _Terminate;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Terminate))
			{
				_Terminate = compiler.GetYesNo(value);
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
			{
				TextOnlyOutput output = new TextOnlyOutput(processor, new StringWriter(CultureInfo.InvariantCulture));
				processor.PushOutput(output);
				processor.PushActionFrame(frame);
				frame.State = 1;
				break;
			}
			case 1:
			{
				TextOnlyOutput textOnlyOutput = processor.PopOutput() as TextOnlyOutput;
				Console.WriteLine(textOnlyOutput.Writer.ToString());
				if (_Terminate)
				{
					throw XsltException.Create("Xslt_Terminate", textOnlyOutput.Writer.ToString());
				}
				frame.Finished();
				break;
			}
			}
		}
	}
	internal class NamespaceDecl
	{
		private string prefix;

		private string nsUri;

		private string prevDefaultNsUri;

		private NamespaceDecl next;

		internal string Prefix => prefix;

		internal string Uri => nsUri;

		internal string PrevDefaultNsUri => prevDefaultNsUri;

		internal NamespaceDecl Next => next;

		internal NamespaceDecl(string prefix, string nsUri, string prevDefaultNsUri, NamespaceDecl next)
		{
			Init(prefix, nsUri, prevDefaultNsUri, next);
		}

		internal void Init(string prefix, string nsUri, string prevDefaultNsUri, NamespaceDecl next)
		{
			this.prefix = prefix;
			this.nsUri = nsUri;
			this.prevDefaultNsUri = prevDefaultNsUri;
			this.next = next;
		}
	}
	internal class NamespaceEvent : Event
	{
		private string namespaceUri;

		private string name;

		public NamespaceEvent(NavigatorInput input)
		{
			namespaceUri = input.Value;
			name = input.LocalName;
		}

		public override void ReplaceNamespaceAlias(Compiler compiler)
		{
			if (namespaceUri.Length == 0)
			{
				return;
			}
			NamespaceInfo namespaceInfo = compiler.FindNamespaceAlias(namespaceUri);
			if (namespaceInfo != null)
			{
				namespaceUri = namespaceInfo.nameSpace;
				if (namespaceInfo.prefix != null)
				{
					name = namespaceInfo.prefix;
				}
			}
		}

		public override bool Output(Processor processor, ActionFrame frame)
		{
			bool flag = processor.BeginEvent(XPathNodeType.Namespace, null, name, namespaceUri, empty: false);
			flag = processor.EndEvent(XPathNodeType.Namespace);
			return true;
		}
	}
	internal class NavigatorInput
	{
		private XPathNavigator _Navigator;

		private PositionInfo _PositionInfo;

		private InputScopeManager _Manager;

		private NavigatorInput _Next;

		private string _Href;

		private KeywordsTable _Atoms;

		internal NavigatorInput Next
		{
			get
			{
				return _Next;
			}
			set
			{
				_Next = value;
			}
		}

		internal string Href => _Href;

		internal KeywordsTable Atoms => _Atoms;

		internal XPathNavigator Navigator => _Navigator;

		internal InputScopeManager InputScopeManager => _Manager;

		internal int LineNumber => _PositionInfo.LineNumber;

		internal int LinePosition => _PositionInfo.LinePosition;

		internal XPathNodeType NodeType => _Navigator.NodeType;

		internal string Name => _Navigator.Name;

		internal string LocalName => _Navigator.LocalName;

		internal string NamespaceURI => _Navigator.NamespaceURI;

		internal string Prefix => _Navigator.Prefix;

		internal string Value => _Navigator.Value;

		internal bool IsEmptyTag => _Navigator.IsEmptyElement;

		internal string BaseURI => _Navigator.BaseURI;

		internal bool Advance()
		{
			return _Navigator.MoveToNext();
		}

		internal bool Recurse()
		{
			return _Navigator.MoveToFirstChild();
		}

		internal bool ToParent()
		{
			return _Navigator.MoveToParent();
		}

		internal void Close()
		{
			_Navigator = null;
			_PositionInfo = null;
		}

		internal bool MoveToFirstAttribute()
		{
			return _Navigator.MoveToFirstAttribute();
		}

		internal bool MoveToNextAttribute()
		{
			return _Navigator.MoveToNextAttribute();
		}

		internal bool MoveToFirstNamespace()
		{
			return _Navigator.MoveToFirstNamespace(XPathNamespaceScope.ExcludeXml);
		}

		internal bool MoveToNextNamespace()
		{
			return _Navigator.MoveToNextNamespace(XPathNamespaceScope.ExcludeXml);
		}

		internal NavigatorInput(XPathNavigator navigator, string baseUri, InputScope rootScope)
		{
			if (navigator == null)
			{
				throw new ArgumentNullException("navigator");
			}
			if (baseUri == null)
			{
				throw new ArgumentNullException("baseUri");
			}
			_Next = null;
			_Href = baseUri;
			_Atoms = new KeywordsTable(navigator.NameTable);
			_Navigator = navigator;
			_Manager = new InputScopeManager(_Navigator, rootScope);
			_PositionInfo = PositionInfo.GetPositionInfo(_Navigator);
			if (NodeType == XPathNodeType.Root)
			{
				_Navigator.MoveToFirstChild();
			}
		}

		internal NavigatorInput(XPathNavigator navigator)
			: this(navigator, navigator.BaseURI, null)
		{
		}

		[Conditional("DEBUG")]
		internal void AssertInput()
		{
		}
	}
	internal class NavigatorOutput : RecordOutput
	{
		private XPathDocument doc;

		private int documentIndex;

		private XmlRawWriter wr;

		internal XPathNavigator Navigator => ((IXPathNavigable)doc).CreateNavigator();

		internal NavigatorOutput(string baseUri)
		{
			doc = new XPathDocument();
			wr = doc.LoadFromWriter(XPathDocument.LoadFlags.AtomizeNames, baseUri);
		}

		public Processor.OutputResult RecordDone(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			documentIndex++;
			switch (mainNode.NodeType)
			{
			case XmlNodeType.Element:
			{
				wr.WriteStartElement(mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI);
				for (int i = 0; i < record.AttributeCount; i++)
				{
					documentIndex++;
					BuilderInfo builderInfo = (BuilderInfo)record.AttributeList[i];
					if (builderInfo.NamespaceURI == "http://www.w3.org/2000/xmlns/")
					{
						if (builderInfo.Prefix.Length == 0)
						{
							wr.WriteNamespaceDeclaration(string.Empty, builderInfo.Value);
						}
						else
						{
							wr.WriteNamespaceDeclaration(builderInfo.LocalName, builderInfo.Value);
						}
					}
					else
					{
						wr.WriteAttributeString(builderInfo.Prefix, builderInfo.LocalName, builderInfo.NamespaceURI, builderInfo.Value);
					}
				}
				wr.StartElementContent();
				if (mainNode.IsEmptyTag)
				{
					wr.WriteEndElement(mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI);
				}
				break;
			}
			case XmlNodeType.Text:
				wr.WriteString(mainNode.Value);
				break;
			case XmlNodeType.SignificantWhitespace:
				wr.WriteString(mainNode.Value);
				break;
			case XmlNodeType.ProcessingInstruction:
				wr.WriteProcessingInstruction(mainNode.LocalName, mainNode.Value);
				break;
			case XmlNodeType.Comment:
				wr.WriteComment(mainNode.Value);
				break;
			case XmlNodeType.EndElement:
				wr.WriteEndElement(mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI);
				break;
			}
			record.Reset();
			return Processor.OutputResult.Continue;
		}

		public void TheEnd()
		{
			wr.Close();
		}
	}
	internal class NewInstructionAction : ContainerAction
	{
		private string name;

		private string parent;

		private bool fallback;

		internal override void Compile(Compiler compiler)
		{
			XPathNavigator xPathNavigator = compiler.Input.Navigator.Clone();
			name = xPathNavigator.Name;
			xPathNavigator.MoveToParent();
			parent = xPathNavigator.Name;
			if (compiler.Recurse())
			{
				CompileSelectiveTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal void CompileSelectiveTemplate(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			do
			{
				if (Ref.Equal(input.NamespaceURI, input.Atoms.UriXsl) && Ref.Equal(input.LocalName, input.Atoms.Fallback))
				{
					fallback = true;
					if (compiler.Recurse())
					{
						CompileTemplate(compiler);
						compiler.ToParent();
					}
				}
			}
			while (compiler.Advance());
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				if (!fallback)
				{
					throw XsltException.Create("Xslt_UnknownExtensionElement", name);
				}
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
					frame.State = 1;
					return;
				}
				break;
			case 1:
				break;
			}
			frame.Finished();
		}
	}
	internal class NumberAction : ContainerAction
	{
		internal class FormatInfo
		{
			public bool isSeparator;

			public NumberingSequence numSequence;

			public int length;

			public string formatString;

			public FormatInfo(bool isSeparator, string formatString)
			{
				this.isSeparator = isSeparator;
				this.formatString = formatString;
			}

			public FormatInfo()
			{
			}
		}

		private class NumberingFormat : NumberFormatterBase
		{
			private NumberingSequence seq;

			private int cMinLen;

			private string separator;

			private int sizeGroup;

			internal NumberingFormat()
			{
			}

			internal void setNumberingType(NumberingSequence seq)
			{
				this.seq = seq;
			}

			internal void setMinLen(int cMinLen)
			{
				this.cMinLen = cMinLen;
			}

			internal void setGroupingSeparator(string separator)
			{
				this.separator = separator;
			}

			internal void setGroupingSize(int sizeGroup)
			{
				if (0 <= sizeGroup && sizeGroup <= 9)
				{
					this.sizeGroup = sizeGroup;
				}
			}

			internal string FormatItem(object value)
			{
				double num;
				if (value is int)
				{
					num = (int)value;
				}
				else
				{
					num = XmlConvert.ToXPathDouble(value);
					if (!(0.5 <= num) || double.IsPositiveInfinity(num))
					{
						return XmlConvert.ToXPathString(value);
					}
					num = XmlConvert.XPathRound(num);
				}
				switch (seq)
				{
				case NumberingSequence.FirstAlpha:
				case NumberingSequence.LCLetter:
					if (num <= 2147483647.0)
					{
						StringBuilder stringBuilder2 = new StringBuilder();
						NumberFormatterBase.ConvertToAlphabetic(stringBuilder2, num, (seq == NumberingSequence.FirstAlpha) ? 'A' : 'a', 26);
						return stringBuilder2.ToString();
					}
					break;
				case NumberingSequence.FirstSpecial:
				case NumberingSequence.LCRoman:
					if (num <= 32767.0)
					{
						StringBuilder stringBuilder = new StringBuilder();
						NumberFormatterBase.ConvertToRoman(stringBuilder, num, seq == NumberingSequence.FirstSpecial);
						return stringBuilder.ToString();
					}
					break;
				}
				return ConvertToArabic(num, cMinLen, sizeGroup, separator);
			}

			private static string ConvertToArabic(double val, int minLength, int groupSize, string groupSeparator)
			{
				string text;
				if (groupSize != 0 && groupSeparator != null)
				{
					NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
					numberFormatInfo.NumberGroupSizes = new int[1] { groupSize };
					numberFormatInfo.NumberGroupSeparator = groupSeparator;
					if (Math.Floor(val) == val)
					{
						numberFormatInfo.NumberDecimalDigits = 0;
					}
					text = val.ToString("N", numberFormatInfo);
				}
				else
				{
					text = Convert.ToString(val, CultureInfo.InvariantCulture);
				}
				if (text.Length >= minLength)
				{
					return text;
				}
				StringBuilder stringBuilder = new StringBuilder(minLength);
				stringBuilder.Append('0', minLength - text.Length);
				stringBuilder.Append(text);
				return stringBuilder.ToString();
			}
		}

		private const long msofnfcNil = 0L;

		private const long msofnfcTraditional = 1L;

		private const long msofnfcAlwaysFormat = 2L;

		private const int cchMaxFormat = 63;

		private const int cchMaxFormatDecimal = 11;

		private static FormatInfo DefaultFormat = new FormatInfo(isSeparator: false, "0");

		private static FormatInfo DefaultSeparator = new FormatInfo(isSeparator: true, ".");

		private const int OutputNumber = 2;

		private string level;

		private string countPattern;

		private int countKey = -1;

		private string from;

		private int fromKey = -1;

		private string value;

		private int valueKey = -1;

		private Avt formatAvt;

		private Avt langAvt;

		private Avt letterAvt;

		private Avt groupingSepAvt;

		private Avt groupingSizeAvt;

		private List<FormatInfo> formatTokens;

		private string lang;

		private string letter;

		private string groupingSep;

		private string groupingSize;

		private bool forwardCompatibility;

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string text = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Level))
			{
				if (text != "any" && text != "multiple" && text != "single")
				{
					throw XsltException.Create("Xslt_InvalidAttrValue", "level", text);
				}
				level = text;
			}
			else if (Ref.Equal(localName, compiler.Atoms.Count))
			{
				countPattern = text;
				countKey = compiler.AddQuery(text, allowVar: true, allowKey: true, isPattern: true);
			}
			else if (Ref.Equal(localName, compiler.Atoms.From))
			{
				from = text;
				fromKey = compiler.AddQuery(text, allowVar: true, allowKey: true, isPattern: true);
			}
			else if (Ref.Equal(localName, compiler.Atoms.Value))
			{
				value = text;
				valueKey = compiler.AddQuery(text);
			}
			else if (Ref.Equal(localName, compiler.Atoms.Format))
			{
				formatAvt = Avt.CompileAvt(compiler, text);
			}
			else if (Ref.Equal(localName, compiler.Atoms.Lang))
			{
				langAvt = Avt.CompileAvt(compiler, text);
			}
			else if (Ref.Equal(localName, compiler.Atoms.LetterValue))
			{
				letterAvt = Avt.CompileAvt(compiler, text);
			}
			else if (Ref.Equal(localName, compiler.Atoms.GroupingSeparator))
			{
				groupingSepAvt = Avt.CompileAvt(compiler, text);
			}
			else
			{
				if (!Ref.Equal(localName, compiler.Atoms.GroupingSize))
				{
					return false;
				}
				groupingSizeAvt = Avt.CompileAvt(compiler, text);
			}
			return true;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckEmpty(compiler);
			forwardCompatibility = compiler.ForwardCompatibility;
			formatTokens = ParseFormat(CompiledAction.PrecalculateAvt(ref formatAvt));
			letter = ParseLetter(CompiledAction.PrecalculateAvt(ref letterAvt));
			lang = CompiledAction.PrecalculateAvt(ref langAvt);
			groupingSep = CompiledAction.PrecalculateAvt(ref groupingSepAvt);
			if (groupingSep != null && groupingSep.Length > 1)
			{
				throw XsltException.Create("Xslt_CharAttribute", "grouping-separator");
			}
			groupingSize = CompiledAction.PrecalculateAvt(ref groupingSizeAvt);
		}

		private int numberAny(Processor processor, ActionFrame frame)
		{
			int num = 0;
			XPathNavigator xPathNavigator = frame.Node;
			if (xPathNavigator.NodeType == XPathNodeType.Attribute || xPathNavigator.NodeType == XPathNodeType.Namespace)
			{
				xPathNavigator = xPathNavigator.Clone();
				xPathNavigator.MoveToParent();
			}
			XPathNavigator xPathNavigator2 = xPathNavigator.Clone();
			if (fromKey != -1)
			{
				bool flag = false;
				do
				{
					if (processor.Matches(xPathNavigator2, fromKey))
					{
						flag = true;
						break;
					}
				}
				while (xPathNavigator2.MoveToParent());
				XPathNodeIterator xPathNodeIterator = xPathNavigator2.SelectDescendants(XPathNodeType.All, matchSelf: true);
				while (xPathNodeIterator.MoveNext())
				{
					if (processor.Matches(xPathNodeIterator.Current, fromKey))
					{
						flag = true;
						num = 0;
					}
					else if (MatchCountKey(processor, frame.Node, xPathNodeIterator.Current))
					{
						num++;
					}
					if (xPathNodeIterator.Current.IsSamePosition(xPathNavigator))
					{
						break;
					}
				}
				if (!flag)
				{
					num = 0;
				}
			}
			else
			{
				xPathNavigator2.MoveToRoot();
				XPathNodeIterator xPathNodeIterator2 = xPathNavigator2.SelectDescendants(XPathNodeType.All, matchSelf: true);
				while (xPathNodeIterator2.MoveNext())
				{
					if (MatchCountKey(processor, frame.Node, xPathNodeIterator2.Current))
					{
						num++;
					}
					if (xPathNodeIterator2.Current.IsSamePosition(xPathNavigator))
					{
						break;
					}
				}
			}
			return num;
		}

		private bool checkFrom(Processor processor, XPathNavigator nav)
		{
			if (fromKey == -1)
			{
				return true;
			}
			do
			{
				if (processor.Matches(nav, fromKey))
				{
					return true;
				}
			}
			while (nav.MoveToParent());
			return false;
		}

		private bool moveToCount(XPathNavigator nav, Processor processor, XPathNavigator contextNode)
		{
			do
			{
				if (fromKey != -1 && processor.Matches(nav, fromKey))
				{
					return false;
				}
				if (MatchCountKey(processor, contextNode, nav))
				{
					return true;
				}
			}
			while (nav.MoveToParent());
			return false;
		}

		private int numberCount(XPathNavigator nav, Processor processor, XPathNavigator contextNode)
		{
			XPathNavigator xPathNavigator = nav.Clone();
			int num = 1;
			if (xPathNavigator.MoveToParent())
			{
				xPathNavigator.MoveToFirstChild();
				while (!xPathNavigator.IsSamePosition(nav))
				{
					if (MatchCountKey(processor, contextNode, xPathNavigator))
					{
						num++;
					}
					if (!xPathNavigator.MoveToNext())
					{
						break;
					}
				}
			}
			return num;
		}

		private static object SimplifyValue(object value)
		{
			if (Type.GetTypeCode(value.GetType()) == TypeCode.Object)
			{
				if (value is XPathNodeIterator xPathNodeIterator)
				{
					if (xPathNodeIterator.MoveNext())
					{
						return xPathNodeIterator.Current.Value;
					}
					return string.Empty;
				}
				if (value is XPathNavigator xPathNavigator)
				{
					return xPathNavigator.Value;
				}
			}
			return value;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			ArrayList numberList = processor.NumberList;
			switch (frame.State)
			{
			default:
				return;
			case 0:
				numberList.Clear();
				if (valueKey != -1)
				{
					numberList.Add(SimplifyValue(processor.Evaluate(frame, valueKey)));
				}
				else if (level == "any")
				{
					int num = numberAny(processor, frame);
					if (num != 0)
					{
						numberList.Add(num);
					}
				}
				else
				{
					bool flag = level == "multiple";
					XPathNavigator node = frame.Node;
					XPathNavigator xPathNavigator = frame.Node.Clone();
					if (xPathNavigator.NodeType == XPathNodeType.Attribute || xPathNavigator.NodeType == XPathNodeType.Namespace)
					{
						xPathNavigator.MoveToParent();
					}
					while (moveToCount(xPathNavigator, processor, node))
					{
						numberList.Insert(0, numberCount(xPathNavigator, processor, node));
						if (!flag || !xPathNavigator.MoveToParent())
						{
							break;
						}
					}
					if (!checkFrom(processor, xPathNavigator))
					{
						numberList.Clear();
					}
				}
				frame.StoredOutput = Format(numberList, (formatAvt == null) ? formatTokens : ParseFormat(formatAvt.Evaluate(processor, frame)), (langAvt == null) ? lang : langAvt.Evaluate(processor, frame), (letterAvt == null) ? letter : ParseLetter(letterAvt.Evaluate(processor, frame)), (groupingSepAvt == null) ? groupingSep : groupingSepAvt.Evaluate(processor, frame), (groupingSizeAvt == null) ? groupingSize : groupingSizeAvt.Evaluate(processor, frame));
				break;
			case 2:
				break;
			}
			if (!processor.TextEvent(frame.StoredOutput))
			{
				frame.State = 2;
			}
			else
			{
				frame.Finished();
			}
		}

		private bool MatchCountKey(Processor processor, XPathNavigator contextNode, XPathNavigator nav)
		{
			if (countKey != -1)
			{
				return processor.Matches(nav, countKey);
			}
			if (contextNode.Name == nav.Name && BasicNodeType(contextNode.NodeType) == BasicNodeType(nav.NodeType))
			{
				return true;
			}
			return false;
		}

		private XPathNodeType BasicNodeType(XPathNodeType type)
		{
			if (type == XPathNodeType.SignificantWhitespace || type == XPathNodeType.Whitespace)
			{
				return XPathNodeType.Text;
			}
			return type;
		}

		private static string Format(ArrayList numberlist, List<FormatInfo> tokens, string lang, string letter, string groupingSep, string groupingSize)
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			if (tokens != null)
			{
				num = tokens.Count;
			}
			NumberingFormat numberingFormat = new NumberingFormat();
			if (groupingSize != null)
			{
				try
				{
					numberingFormat.setGroupingSize(Convert.ToInt32(groupingSize, CultureInfo.InvariantCulture));
				}
				catch (FormatException)
				{
				}
				catch (OverflowException)
				{
				}
			}
			if (groupingSep != null)
			{
				_ = groupingSep.Length;
				_ = 1;
				numberingFormat.setGroupingSeparator(groupingSep);
			}
			if (0 < num)
			{
				FormatInfo formatInfo = tokens[0];
				FormatInfo formatInfo2 = null;
				if (num % 2 == 1)
				{
					formatInfo2 = tokens[num - 1];
					num--;
				}
				FormatInfo formatInfo3 = ((2 < num) ? tokens[num - 2] : DefaultSeparator);
				FormatInfo formatInfo4 = ((0 < num) ? tokens[num - 1] : DefaultFormat);
				if (formatInfo != null)
				{
					stringBuilder.Append(formatInfo.formatString);
				}
				int count = numberlist.Count;
				for (int i = 0; i < count; i++)
				{
					int num2 = i * 2;
					bool flag = num2 < num;
					if (0 < i)
					{
						FormatInfo formatInfo5 = (flag ? tokens[num2] : formatInfo3);
						stringBuilder.Append(formatInfo5.formatString);
					}
					FormatInfo formatInfo6 = (flag ? tokens[num2 + 1] : formatInfo4);
					numberingFormat.setNumberingType(formatInfo6.numSequence);
					numberingFormat.setMinLen(formatInfo6.length);
					stringBuilder.Append(numberingFormat.FormatItem(numberlist[i]));
				}
				if (formatInfo2 != null)
				{
					stringBuilder.Append(formatInfo2.formatString);
				}
			}
			else
			{
				numberingFormat.setNumberingType(NumberingSequence.FirstDecimal);
				for (int j = 0; j < numberlist.Count; j++)
				{
					if (j != 0)
					{
						stringBuilder.Append(".");
					}
					stringBuilder.Append(numberingFormat.FormatItem(numberlist[j]));
				}
			}
			return stringBuilder.ToString();
		}

		private static void mapFormatToken(string wsToken, int startLen, int tokLen, out NumberingSequence seq, out int pminlen)
		{
			char c = wsToken[startLen];
			bool flag = false;
			pminlen = 1;
			seq = NumberingSequence.Nil;
			int num = c;
			if (num <= 2406)
			{
				if (num == 48 || num == 2406)
				{
					goto IL_0042;
				}
			}
			else if (num == 3664 || num == 51067 || num == 65296)
			{
				goto IL_0042;
			}
			goto IL_0071;
			IL_0042:
			do
			{
				pminlen++;
			}
			while (--tokLen > 0 && c == wsToken[++startLen]);
			if (wsToken[startLen] != (ushort)(c + 1))
			{
				flag = true;
			}
			goto IL_0071;
			IL_0071:
			if (!flag)
			{
				switch (wsToken[startLen])
				{
				case '1':
					seq = NumberingSequence.FirstDecimal;
					break;
				case 'A':
					seq = NumberingSequence.FirstAlpha;
					break;
				case 'I':
					seq = NumberingSequence.FirstSpecial;
					break;
				case 'a':
					seq = NumberingSequence.LCLetter;
					break;
				case 'i':
					seq = NumberingSequence.LCRoman;
					break;
				case 'А':
					seq = NumberingSequence.UCRus;
					break;
				case 'а':
					seq = NumberingSequence.LCRus;
					break;
				case 'א':
					seq = NumberingSequence.Hebrew;
					break;
				case 'أ':
					seq = NumberingSequence.ArabicScript;
					break;
				case 'अ':
					seq = NumberingSequence.Hindi2;
					break;
				case 'क':
					seq = NumberingSequence.Hindi1;
					break;
				case '१':
					seq = NumberingSequence.Hindi3;
					break;
				case 'ก':
					seq = NumberingSequence.Thai1;
					break;
				case '๑':
					seq = NumberingSequence.Thai2;
					break;
				case 'ア':
					seq = NumberingSequence.DAiueo;
					break;
				case 'イ':
					seq = NumberingSequence.DIroha;
					break;
				case 'ㄱ':
					seq = NumberingSequence.DChosung;
					break;
				case '一':
					seq = NumberingSequence.FEDecimal;
					break;
				case '壱':
					seq = NumberingSequence.DbNum3;
					break;
				case '壹':
					seq = NumberingSequence.ChnCmplx;
					break;
				case '子':
					seq = NumberingSequence.Zodiac2;
					break;
				case '가':
					seq = NumberingSequence.Ganada;
					break;
				case '일':
					seq = NumberingSequence.KorDbNum1;
					break;
				case '하':
					seq = NumberingSequence.KorDbNum3;
					break;
				case '１':
					seq = NumberingSequence.DArabic;
					break;
				case 'ｱ':
					seq = NumberingSequence.Aiueo;
					break;
				case 'ｲ':
					seq = NumberingSequence.Iroha;
					break;
				case '甲':
					if (tokLen > 1 && wsToken[startLen + 1] == '子')
					{
						seq = NumberingSequence.Zodiac3;
						tokLen--;
						startLen++;
					}
					else
					{
						seq = NumberingSequence.Zodiac1;
					}
					break;
				default:
					seq = NumberingSequence.FirstDecimal;
					break;
				}
			}
			if (flag)
			{
				seq = NumberingSequence.FirstDecimal;
				pminlen = 0;
			}
		}

		private static List<FormatInfo> ParseFormat(string formatString)
		{
			if (formatString == null || formatString.Length == 0)
			{
				return null;
			}
			int num = 0;
			bool flag = CharUtil.IsAlphaNumeric(formatString[num]);
			List<FormatInfo> list = new List<FormatInfo>();
			int num2 = 0;
			if (flag)
			{
				list.Add(null);
			}
			while (num <= formatString.Length)
			{
				bool flag2 = ((num < formatString.Length) ? CharUtil.IsAlphaNumeric(formatString[num]) : (!flag));
				if (flag != flag2)
				{
					FormatInfo formatInfo = new FormatInfo();
					if (flag)
					{
						mapFormatToken(formatString, num2, num - num2, out formatInfo.numSequence, out formatInfo.length);
					}
					else
					{
						formatInfo.isSeparator = true;
						formatInfo.formatString = formatString.Substring(num2, num - num2);
					}
					num2 = num;
					num++;
					list.Add(formatInfo);
					flag = flag2;
				}
				else
				{
					num++;
				}
			}
			return list;
		}

		private string ParseLetter(string letter)
		{
			switch (letter)
			{
			case null:
			case "traditional":
			case "alphabetic":
				return letter;
			default:
				if (!forwardCompatibility)
				{
					throw XsltException.Create("Xslt_InvalidAttrValue", "letter-value", letter);
				}
				return null;
			}
		}
	}
	internal class OutKeywords
	{
		private string _AtomEmpty;

		private string _AtomLang;

		private string _AtomSpace;

		private string _AtomXmlns;

		private string _AtomXml;

		private string _AtomXmlNamespace;

		private string _AtomXmlnsNamespace;

		internal string Empty => _AtomEmpty;

		internal string Lang => _AtomLang;

		internal string Space => _AtomSpace;

		internal string Xmlns => _AtomXmlns;

		internal string Xml => _AtomXml;

		internal string XmlNamespace => _AtomXmlNamespace;

		internal string XmlnsNamespace => _AtomXmlnsNamespace;

		internal OutKeywords(XmlNameTable nameTable)
		{
			_AtomEmpty = nameTable.Add(string.Empty);
			_AtomLang = nameTable.Add("lang");
			_AtomSpace = nameTable.Add("space");
			_AtomXmlns = nameTable.Add("xmlns");
			_AtomXml = nameTable.Add("xml");
			_AtomXmlNamespace = nameTable.Add("http://www.w3.org/XML/1998/namespace");
			_AtomXmlnsNamespace = nameTable.Add("http://www.w3.org/2000/xmlns/");
		}

		[Conditional("DEBUG")]
		private void CheckKeyword(string keyword)
		{
		}
	}
	internal class OutputScope : DocumentScope
	{
		private string name;

		private string nsUri;

		private string prefix;

		private XmlSpace space;

		private string lang;

		private bool mixed;

		private bool toCData;

		private HtmlElementProps htmlElementProps;

		internal string Name => name;

		internal string Namespace => nsUri;

		internal string Prefix
		{
			get
			{
				return prefix;
			}
			set
			{
				prefix = value;
			}
		}

		internal XmlSpace Space
		{
			get
			{
				return space;
			}
			set
			{
				space = value;
			}
		}

		internal string Lang
		{
			get
			{
				return lang;
			}
			set
			{
				lang = value;
			}
		}

		internal bool Mixed
		{
			get
			{
				return mixed;
			}
			set
			{
				mixed = value;
			}
		}

		internal bool ToCData
		{
			get
			{
				return toCData;
			}
			set
			{
				toCData = value;
			}
		}

		internal HtmlElementProps HtmlElementProps
		{
			get
			{
				return htmlElementProps;
			}
			set
			{
				htmlElementProps = value;
			}
		}

		internal OutputScope()
		{
			Init(string.Empty, string.Empty, string.Empty, XmlSpace.None, string.Empty, mixed: false);
		}

		internal void Init(string name, string nspace, string prefix, XmlSpace space, string lang, bool mixed)
		{
			scopes = null;
			this.name = name;
			nsUri = nspace;
			this.prefix = prefix;
			this.space = space;
			this.lang = lang;
			this.mixed = mixed;
			toCData = false;
			htmlElementProps = null;
		}

		internal bool FindPrefix(string urn, out string prefix)
		{
			for (NamespaceDecl next = scopes; next != null; next = next.Next)
			{
				if (Ref.Equal(next.Uri, urn) && next.Prefix != null && next.Prefix.Length > 0)
				{
					prefix = next.Prefix;
					return true;
				}
			}
			prefix = string.Empty;
			return false;
		}
	}
	internal class OutputScopeManager
	{
		private const int STACK_INCREMENT = 10;

		private HWStack elementScopesStack;

		private string defaultNS;

		private OutKeywords atoms;

		private XmlNameTable nameTable;

		private int prefixIndex;

		internal string DefaultNamespace => defaultNS;

		internal OutputScope CurrentElementScope => (OutputScope)elementScopesStack.Peek();

		internal XmlSpace XmlSpace => CurrentElementScope.Space;

		internal string XmlLang => CurrentElementScope.Lang;

		internal OutputScopeManager(XmlNameTable nameTable, OutKeywords atoms)
		{
			elementScopesStack = new HWStack(10);
			this.nameTable = nameTable;
			this.atoms = atoms;
			defaultNS = this.atoms.Empty;
			OutputScope outputScope = (OutputScope)elementScopesStack.Push();
			if (outputScope == null)
			{
				outputScope = new OutputScope();
				elementScopesStack.AddToTop(outputScope);
			}
			outputScope.Init(string.Empty, string.Empty, string.Empty, XmlSpace.None, string.Empty, mixed: false);
		}

		internal void PushNamespace(string prefix, string nspace)
		{
			CurrentElementScope.AddNamespace(prefix, nspace, defaultNS);
			if (prefix == null || prefix.Length == 0)
			{
				defaultNS = nspace;
			}
		}

		internal void PushScope(string name, string nspace, string prefix)
		{
			OutputScope currentElementScope = CurrentElementScope;
			OutputScope outputScope = (OutputScope)elementScopesStack.Push();
			if (outputScope == null)
			{
				outputScope = new OutputScope();
				elementScopesStack.AddToTop(outputScope);
			}
			outputScope.Init(name, nspace, prefix, currentElementScope.Space, currentElementScope.Lang, currentElementScope.Mixed);
		}

		internal void PopScope()
		{
			OutputScope outputScope = (OutputScope)elementScopesStack.Pop();
			for (NamespaceDecl namespaceDecl = outputScope.Scopes; namespaceDecl != null; namespaceDecl = namespaceDecl.Next)
			{
				defaultNS = namespaceDecl.PrevDefaultNsUri;
			}
		}

		internal string ResolveNamespace(string prefix)
		{
			bool thisScope;
			return ResolveNamespace(prefix, out thisScope);
		}

		internal string ResolveNamespace(string prefix, out bool thisScope)
		{
			thisScope = true;
			if (prefix == null || prefix.Length == 0)
			{
				return defaultNS;
			}
			if (Ref.Equal(prefix, atoms.Xml))
			{
				return atoms.XmlNamespace;
			}
			if (Ref.Equal(prefix, atoms.Xmlns))
			{
				return atoms.XmlnsNamespace;
			}
			for (int num = elementScopesStack.Length - 1; num >= 0; num--)
			{
				OutputScope outputScope = (OutputScope)elementScopesStack[num];
				string text = outputScope.ResolveAtom(prefix);
				if (text != null)
				{
					thisScope = num == elementScopesStack.Length - 1;
					return text;
				}
			}
			return null;
		}

		internal bool FindPrefix(string nspace, out string prefix)
		{
			int num = elementScopesStack.Length - 1;
			while (0 <= num)
			{
				OutputScope outputScope = (OutputScope)elementScopesStack[num];
				string prefix2 = null;
				if (outputScope.FindPrefix(nspace, out prefix2))
				{
					string text = ResolveNamespace(prefix2);
					if (text == null || !Ref.Equal(text, nspace))
					{
						break;
					}
					prefix = prefix2;
					return true;
				}
				num--;
			}
			prefix = null;
			return false;
		}

		internal string GeneratePrefix(string format)
		{
			string array;
			do
			{
				array = string.Format(CultureInfo.InvariantCulture, format, new object[1] { prefixIndex++ });
			}
			while (nameTable.Get(array) != null);
			return nameTable.Add(array);
		}
	}
	internal sealed class PrefixQName
	{
		public string Prefix;

		public string Name;

		public string Namespace;

		internal void ClearPrefix()
		{
			Prefix = string.Empty;
		}

		internal void SetQName(string qname)
		{
			ParseQualifiedName(qname, out Prefix, out Name);
		}

		public static void ParseQualifiedName(string qname, out string prefix, out string local)
		{
			prefix = string.Empty;
			local = string.Empty;
			int num = ValidateNames.ParseNCName(qname);
			if (num == 0)
			{
				throw XsltException.Create("Xslt_InvalidQName", qname);
			}
			local = qname.Substring(0, num);
			if (num >= qname.Length)
			{
				return;
			}
			if (qname[num] == ':')
			{
				int startIndex = ++num;
				prefix = local;
				int num2 = ValidateNames.ParseNCName(qname, num);
				num += num2;
				if (num2 == 0)
				{
					throw XsltException.Create("Xslt_InvalidQName", qname);
				}
				local = qname.Substring(startIndex, num2);
			}
			if (num < qname.Length)
			{
				throw XsltException.Create("Xslt_InvalidQName", qname);
			}
		}

		public static bool ValidatePrefix(string prefix)
		{
			if (prefix.Length == 0)
			{
				return false;
			}
			int num = ValidateNames.ParseNCName(prefix, 0);
			return num == prefix.Length;
		}
	}
	internal class ProcessingInstructionAction : ContainerAction
	{
		private const int NameEvaluated = 2;

		private const int NameReady = 3;

		private Avt nameAvt;

		private string name;

		private const char CharX = 'X';

		private const char Charx = 'x';

		private const char CharM = 'M';

		private const char Charm = 'm';

		private const char CharL = 'L';

		private const char Charl = 'l';

		internal ProcessingInstructionAction()
		{
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, nameAvt, "name");
			if (nameAvt.IsConstant)
			{
				name = nameAvt.Evaluate(null, null);
				nameAvt = null;
				if (!IsProcessingInstructionName(name))
				{
					name = null;
				}
			}
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Name))
			{
				nameAvt = Avt.CompileAvt(compiler, value);
				return true;
			}
			return false;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (nameAvt == null)
				{
					frame.StoredOutput = name;
					if (name == null)
					{
						frame.Finished();
						break;
					}
				}
				else
				{
					frame.StoredOutput = nameAvt.Evaluate(processor, frame);
					if (!IsProcessingInstructionName(frame.StoredOutput))
					{
						frame.Finished();
						break;
					}
				}
				goto case 3;
			case 3:
				if (!processor.BeginEvent(XPathNodeType.ProcessingInstruction, string.Empty, frame.StoredOutput, string.Empty, empty: false))
				{
					frame.State = 3;
					break;
				}
				processor.PushActionFrame(frame);
				frame.State = 1;
				break;
			case 1:
				if (!processor.EndEvent(XPathNodeType.ProcessingInstruction))
				{
					frame.State = 1;
				}
				else
				{
					frame.Finished();
				}
				break;
			default:
				frame.Finished();
				break;
			}
		}

		internal static bool IsProcessingInstructionName(string name)
		{
			if (name == null)
			{
				return false;
			}
			int length = name.Length;
			int i = 0;
			XmlCharType instance;
			for (instance = XmlCharType.Instance; i < length && instance.IsWhiteSpace(name[i]); i++)
			{
			}
			if (i >= length)
			{
				return false;
			}
			int num = ValidateNames.ParseNCName(name, i);
			if (num == 0)
			{
				return false;
			}
			for (i += num; i < length && instance.IsWhiteSpace(name[i]); i++)
			{
			}
			if (i < length)
			{
				return false;
			}
			if (length == 3 && (name[0] == 'X' || name[0] == 'x') && (name[1] == 'M' || name[1] == 'm') && (name[2] == 'L' || name[2] == 'l'))
			{
				return false;
			}
			return true;
		}
	}
	internal sealed class Processor : IXsltProcessor
	{
		internal enum ExecResult
		{
			Continue,
			Interrupt,
			Done
		}

		internal enum OutputResult
		{
			Continue,
			Interrupt,
			Overflow,
			Error,
			Ignore
		}

		internal class DebuggerFrame
		{
			internal ActionFrame actionFrame;

			internal XmlQualifiedName currentMode;
		}

		private const int StackIncrement = 10;

		private ExecResult execResult;

		private Stylesheet stylesheet;

		private RootAction rootAction;

		private Key[] keyList;

		private List<TheQuery> queryStore;

		public PermissionSet permissions;

		private XPathNavigator document;

		private HWStack actionStack;

		private HWStack debuggerStack;

		private StringBuilder sharedStringBuilder;

		private int ignoreLevel;

		private StateMachine xsm;

		private RecordBuilder builder;

		private XsltOutput output;

		private XmlNameTable nameTable = new NameTable();

		private XmlResolver resolver;

		private XsltArgumentList args;

		private Hashtable scriptExtensions;

		private ArrayList numberList;

		private TemplateLookupAction templateLookup = new TemplateLookupAction();

		private IXsltDebugger debugger;

		private Query[] queryList;

		private ArrayList sortArray;

		private Hashtable documentCache;

		private XsltCompileContext valueOfContext;

		private XsltCompileContext matchesContext;

		internal XPathNavigator Current => ((ActionFrame)actionStack.Peek())?.Node;

		internal ExecResult ExecutionResult
		{
			get
			{
				return execResult;
			}
			set
			{
				execResult = value;
			}
		}

		internal Stylesheet Stylesheet => stylesheet;

		internal XmlResolver Resolver => resolver;

		internal ArrayList SortArray => sortArray;

		internal Key[] KeyList => keyList;

		internal RootAction RootAction => rootAction;

		internal XPathNavigator Document => document;

		internal ArrayList NumberList
		{
			get
			{
				if (numberList == null)
				{
					numberList = new ArrayList();
				}
				return numberList;
			}
		}

		internal IXsltDebugger Debugger => debugger;

		internal HWStack ActionStack => actionStack;

		internal RecordBuilder Builder => builder;

		internal XsltOutput Output => output;

		internal XmlNameTable NameTable => nameTable;

		internal bool CanContinue => execResult == ExecResult.Continue;

		internal bool ExecutionDone => execResult == ExecResult.Done;

		int IXsltProcessor.StackDepth => debuggerStack.Length;

		internal XPathNavigator GetNavigator(Uri ruri)
		{
			XPathNavigator xPathNavigator = null;
			if (documentCache != null)
			{
				if (documentCache[ruri] is XPathNavigator xPathNavigator2)
				{
					return xPathNavigator2.Clone();
				}
			}
			else
			{
				documentCache = new Hashtable();
			}
			object entity = resolver.GetEntity(ruri, null, null);
			if (entity is Stream)
			{
				XmlTextReaderImpl xmlTextReaderImpl = new XmlTextReaderImpl(ruri.ToString(), (Stream)entity);
				xmlTextReaderImpl.XmlResolver = resolver;
				xPathNavigator = ((IXPathNavigable)Compiler.LoadDocument(xmlTextReaderImpl)).CreateNavigator();
			}
			else
			{
				if (!(entity is XPathNavigator))
				{
					throw XsltException.Create("Xslt_CantResolve", ruri.ToString());
				}
				xPathNavigator = (XPathNavigator)entity;
			}
			documentCache[ruri] = xPathNavigator.Clone();
			return xPathNavigator;
		}

		internal void AddSort(Sort sortinfo)
		{
			sortArray.Add(sortinfo);
		}

		internal void InitSortArray()
		{
			if (sortArray == null)
			{
				sortArray = new ArrayList();
			}
			else
			{
				sortArray.Clear();
			}
		}

		internal object GetGlobalParameter(XmlQualifiedName qname)
		{
			object obj = args.GetParam(qname.Name, qname.Namespace);
			if (obj == null)
			{
				return null;
			}
			if (!(obj is XPathNodeIterator) && !(obj is XPathNavigator) && !(obj is bool) && !(obj is double) && !(obj is string))
			{
				obj = ((!(obj is short) && !(obj is ushort) && !(obj is int) && !(obj is uint) && !(obj is long) && !(obj is ulong) && !(obj is float) && !(obj is decimal)) ? obj.ToString() : ((object)XmlConvert.ToXPathDouble(obj)));
			}
			return obj;
		}

		internal object GetExtensionObject(string nsUri)
		{
			return args.GetExtensionObject(nsUri);
		}

		internal object GetScriptObject(string nsUri)
		{
			return scriptExtensions[nsUri];
		}

		internal StringBuilder GetSharedStringBuilder()
		{
			if (sharedStringBuilder == null)
			{
				sharedStringBuilder = new StringBuilder();
			}
			else
			{
				sharedStringBuilder.Length = 0;
			}
			return sharedStringBuilder;
		}

		internal void ReleaseSharedStringBuilder()
		{
		}

		public Processor(XPathNavigator doc, XsltArgumentList args, XmlResolver resolver, Stylesheet stylesheet, List<TheQuery> queryStore, RootAction rootAction, IXsltDebugger debugger)
		{
			this.stylesheet = stylesheet;
			this.queryStore = queryStore;
			this.rootAction = rootAction;
			queryList = new Query[queryStore.Count];
			for (int i = 0; i < queryStore.Count; i++)
			{
				queryList[i] = Query.Clone(queryStore[i].CompiledQuery.QueryTree);
			}
			xsm = new StateMachine();
			document = doc;
			builder = null;
			actionStack = new HWStack(10);
			output = this.rootAction.Output;
			permissions = this.rootAction.permissions;
			this.resolver = resolver ?? XmlNullResolver.Singleton;
			this.args = args ?? new XsltArgumentList();
			this.debugger = debugger;
			if (this.debugger != null)
			{
				debuggerStack = new HWStack(10, 1000);
				templateLookup = new TemplateLookupActionDbg();
			}
			if (this.rootAction.KeyList != null)
			{
				keyList = new Key[this.rootAction.KeyList.Count];
				for (int j = 0; j < keyList.Length; j++)
				{
					keyList[j] = this.rootAction.KeyList[j].Clone();
				}
			}
			scriptExtensions = new Hashtable(this.stylesheet.ScriptObjectTypes.Count);
			foreach (DictionaryEntry scriptObjectType in this.stylesheet.ScriptObjectTypes)
			{
				string text = (string)scriptObjectType.Key;
				if (GetExtensionObject(text) != null)
				{
					throw XsltException.Create("Xslt_ScriptDub", text);
				}
				scriptExtensions.Add(text, Activator.CreateInstance((Type)scriptObjectType.Value, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null));
			}
			PushActionFrame(this.rootAction, null);
		}

		public ReaderOutput StartReader()
		{
			ReaderOutput result = new ReaderOutput(this);
			builder = new RecordBuilder(result, nameTable);
			return result;
		}

		public void Execute(Stream stream)
		{
			RecordOutput recordOutput = null;
			switch (output.Method)
			{
			case XsltOutput.OutputMethod.Text:
				recordOutput = new TextOnlyOutput(this, stream);
				break;
			case XsltOutput.OutputMethod.Xml:
			case XsltOutput.OutputMethod.Html:
			case XsltOutput.OutputMethod.Other:
			case XsltOutput.OutputMethod.Unknown:
				recordOutput = new TextOutput(this, stream);
				break;
			}
			builder = new RecordBuilder(recordOutput, nameTable);
			Execute();
		}

		public void Execute(TextWriter writer)
		{
			RecordOutput recordOutput = null;
			switch (output.Method)
			{
			case XsltOutput.OutputMethod.Text:
				recordOutput = new TextOnlyOutput(this, writer);
				break;
			case XsltOutput.OutputMethod.Xml:
			case XsltOutput.OutputMethod.Html:
			case XsltOutput.OutputMethod.Other:
			case XsltOutput.OutputMethod.Unknown:
				recordOutput = new TextOutput(this, writer);
				break;
			}
			builder = new RecordBuilder(recordOutput, nameTable);
			Execute();
		}

		public void Execute(XmlWriter writer)
		{
			builder = new RecordBuilder(new WriterOutput(this, writer), nameTable);
			Execute();
		}

		internal void Execute()
		{
			while (execResult == ExecResult.Continue)
			{
				ActionFrame actionFrame = (ActionFrame)actionStack.Peek();
				if (actionFrame == null)
				{
					builder.TheEnd();
					ExecutionResult = ExecResult.Done;
					break;
				}
				if (actionFrame.Execute(this))
				{
					actionStack.Pop();
				}
			}
			if (execResult == ExecResult.Interrupt)
			{
				execResult = ExecResult.Continue;
			}
		}

		internal ActionFrame PushNewFrame()
		{
			ActionFrame actionFrame = (ActionFrame)actionStack.Peek();
			ActionFrame actionFrame2 = (ActionFrame)actionStack.Push();
			if (actionFrame2 == null)
			{
				actionFrame2 = new ActionFrame();
				actionStack.AddToTop(actionFrame2);
			}
			if (actionFrame != null)
			{
				actionFrame2.Inherit(actionFrame);
			}
			return actionFrame2;
		}

		internal void PushActionFrame(Action action, XPathNodeIterator nodeSet)
		{
			ActionFrame actionFrame = PushNewFrame();
			actionFrame.Init(action, nodeSet);
		}

		internal void PushActionFrame(ActionFrame container)
		{
			PushActionFrame(container, container.NodeSet);
		}

		internal void PushActionFrame(ActionFrame container, XPathNodeIterator nodeSet)
		{
			ActionFrame actionFrame = PushNewFrame();
			actionFrame.Init(container, nodeSet);
		}

		internal void PushTemplateLookup(XPathNodeIterator nodeSet, XmlQualifiedName mode, Stylesheet importsOf)
		{
			templateLookup.Initialize(mode, importsOf);
			PushActionFrame(templateLookup, nodeSet);
		}

		internal string GetQueryExpression(int key)
		{
			return queryStore[key].CompiledQuery.Expression;
		}

		internal Query GetCompiledQuery(int key)
		{
			TheQuery theQuery = queryStore[key];
			theQuery.CompiledQuery.CheckErrors();
			Query query = Query.Clone(queryList[key]);
			query.SetXsltContext(new XsltCompileContext(theQuery._ScopeManager, this));
			return query;
		}

		internal Query GetValueQuery(int key)
		{
			return GetValueQuery(key, null);
		}

		internal Query GetValueQuery(int key, XsltCompileContext context)
		{
			TheQuery theQuery = queryStore[key];
			theQuery.CompiledQuery.CheckErrors();
			Query query = queryList[key];
			if (context == null)
			{
				context = new XsltCompileContext(theQuery._ScopeManager, this);
			}
			else
			{
				context.Reinitialize(theQuery._ScopeManager, this);
			}
			query.SetXsltContext(context);
			return query;
		}

		private XsltCompileContext GetValueOfContext()
		{
			if (valueOfContext == null)
			{
				valueOfContext = new XsltCompileContext();
			}
			return valueOfContext;
		}

		[Conditional("DEBUG")]
		private void RecycleValueOfContext()
		{
			if (valueOfContext != null)
			{
				valueOfContext.Recycle();
			}
		}

		private XsltCompileContext GetMatchesContext()
		{
			if (matchesContext == null)
			{
				matchesContext = new XsltCompileContext();
			}
			return matchesContext;
		}

		[Conditional("DEBUG")]
		private void RecycleMatchesContext()
		{
			if (matchesContext != null)
			{
				matchesContext.Recycle();
			}
		}

		internal string ValueOf(ActionFrame context, int key)
		{
			Query valueQuery = GetValueQuery(key, GetValueOfContext());
			object obj = valueQuery.Evaluate(context.NodeSet);
			if (obj is XPathNodeIterator)
			{
				XPathNavigator xPathNavigator = valueQuery.Advance();
				return (xPathNavigator != null) ? ValueOf(xPathNavigator) : string.Empty;
			}
			return XmlConvert.ToXPathString(obj);
		}

		internal string ValueOf(XPathNavigator n)
		{
			if (stylesheet.Whitespace && n.NodeType == XPathNodeType.Element)
			{
				StringBuilder stringBuilder = GetSharedStringBuilder();
				ElementValueWithoutWS(n, stringBuilder);
				ReleaseSharedStringBuilder();
				return stringBuilder.ToString();
			}
			return n.Value;
		}

		private void ElementValueWithoutWS(XPathNavigator nav, StringBuilder builder)
		{
			bool flag = Stylesheet.PreserveWhiteSpace(this, nav);
			if (!nav.MoveToFirstChild())
			{
				return;
			}
			do
			{
				switch (nav.NodeType)
				{
				case XPathNodeType.Text:
				case XPathNodeType.SignificantWhitespace:
					builder.Append(nav.Value);
					break;
				case XPathNodeType.Whitespace:
					if (flag)
					{
						builder.Append(nav.Value);
					}
					break;
				case XPathNodeType.Element:
					ElementValueWithoutWS(nav, builder);
					break;
				}
			}
			while (nav.MoveToNext());
			nav.MoveToParent();
		}

		internal XPathNodeIterator StartQuery(XPathNodeIterator context, int key)
		{
			Query compiledQuery = GetCompiledQuery(key);
			object obj = compiledQuery.Evaluate(context);
			if (obj is XPathNodeIterator)
			{
				return new XPathSelectionIterator(context.Current, compiledQuery);
			}
			throw XsltException.Create("XPath_NodeSetExpected");
		}

		internal object Evaluate(ActionFrame context, int key)
		{
			return GetValueQuery(key).Evaluate(context.NodeSet);
		}

		internal object RunQuery(ActionFrame context, int key)
		{
			Query compiledQuery = GetCompiledQuery(key);
			object obj = compiledQuery.Evaluate(context.NodeSet);
			if (obj is XPathNodeIterator nodeIterator)
			{
				return new XPathArrayIterator(nodeIterator);
			}
			return obj;
		}

		internal string EvaluateString(ActionFrame context, int key)
		{
			object obj = Evaluate(context, key);
			string text = null;
			if (obj != null)
			{
				text = XmlConvert.ToXPathString(obj);
			}
			if (text == null)
			{
				text = string.Empty;
			}
			return text;
		}

		internal bool EvaluateBoolean(ActionFrame context, int key)
		{
			object obj = Evaluate(context, key);
			if (obj != null)
			{
				if (!(obj is XPathNavigator xPathNavigator))
				{
					return Convert.ToBoolean(obj, CultureInfo.InvariantCulture);
				}
				return Convert.ToBoolean(xPathNavigator.Value, CultureInfo.InvariantCulture);
			}
			return false;
		}

		internal bool Matches(XPathNavigator context, int key)
		{
			Query valueQuery = GetValueQuery(key, GetMatchesContext());
			try
			{
				return valueQuery.MatchNode(context) != null;
			}
			catch (XPathException)
			{
				throw XsltException.Create("Xslt_InvalidPattern", GetQueryExpression(key));
			}
		}

		internal void ResetOutput()
		{
			builder.Reset();
		}

		internal bool BeginEvent(XPathNodeType nodeType, string prefix, string name, string nspace, bool empty)
		{
			return BeginEvent(nodeType, prefix, name, nspace, empty, null, search: true);
		}

		internal bool BeginEvent(XPathNodeType nodeType, string prefix, string name, string nspace, bool empty, object htmlProps, bool search)
		{
			int num = xsm.BeginOutlook(nodeType);
			if (ignoreLevel > 0 || num == 16)
			{
				ignoreLevel++;
				return true;
			}
			switch (builder.BeginEvent(num, nodeType, prefix, name, nspace, empty, htmlProps, search))
			{
			case OutputResult.Continue:
				xsm.Begin(nodeType);
				return true;
			case OutputResult.Interrupt:
				xsm.Begin(nodeType);
				ExecutionResult = ExecResult.Interrupt;
				return true;
			case OutputResult.Overflow:
				ExecutionResult = ExecResult.Interrupt;
				return false;
			case OutputResult.Error:
				ignoreLevel++;
				return true;
			case OutputResult.Ignore:
				return true;
			default:
				return true;
			}
		}

		internal bool TextEvent(string text)
		{
			return TextEvent(text, disableOutputEscaping: false);
		}

		internal bool TextEvent(string text, bool disableOutputEscaping)
		{
			if (ignoreLevel > 0)
			{
				return true;
			}
			int state = xsm.BeginOutlook(XPathNodeType.Text);
			switch (builder.TextEvent(state, text, disableOutputEscaping))
			{
			case OutputResult.Continue:
				xsm.Begin(XPathNodeType.Text);
				return true;
			case OutputResult.Interrupt:
				xsm.Begin(XPathNodeType.Text);
				ExecutionResult = ExecResult.Interrupt;
				return true;
			case OutputResult.Overflow:
				ExecutionResult = ExecResult.Interrupt;
				return false;
			case OutputResult.Error:
			case OutputResult.Ignore:
				return true;
			default:
				return true;
			}
		}

		internal bool EndEvent(XPathNodeType nodeType)
		{
			if (ignoreLevel > 0)
			{
				ignoreLevel--;
				return true;
			}
			int state = xsm.EndOutlook(nodeType);
			switch (builder.EndEvent(state, nodeType))
			{
			case OutputResult.Continue:
				xsm.End(nodeType);
				return true;
			case OutputResult.Interrupt:
				xsm.End(nodeType);
				ExecutionResult = ExecResult.Interrupt;
				return true;
			case OutputResult.Overflow:
				ExecutionResult = ExecResult.Interrupt;
				return false;
			default:
				return true;
			}
		}

		internal bool CopyBeginEvent(XPathNavigator node, bool emptyflag)
		{
			switch (node.NodeType)
			{
			case XPathNodeType.Element:
			case XPathNodeType.Attribute:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
				return BeginEvent(node.NodeType, node.Prefix, node.LocalName, node.NamespaceURI, emptyflag);
			case XPathNodeType.Namespace:
				return BeginEvent(XPathNodeType.Namespace, null, node.LocalName, node.Value, empty: false);
			default:
				return true;
			}
		}

		internal bool CopyTextEvent(XPathNavigator node)
		{
			switch (node.NodeType)
			{
			case XPathNodeType.Attribute:
			case XPathNodeType.Text:
			case XPathNodeType.SignificantWhitespace:
			case XPathNodeType.Whitespace:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
			{
				string value = node.Value;
				return TextEvent(value);
			}
			default:
				return true;
			}
		}

		internal bool CopyEndEvent(XPathNavigator node)
		{
			switch (node.NodeType)
			{
			case XPathNodeType.Element:
			case XPathNodeType.Attribute:
			case XPathNodeType.Namespace:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
				return EndEvent(node.NodeType);
			default:
				return true;
			}
		}

		internal static bool IsRoot(XPathNavigator navigator)
		{
			if (navigator.NodeType == XPathNodeType.Root)
			{
				return true;
			}
			if (navigator.NodeType == XPathNodeType.Element)
			{
				XPathNavigator xPathNavigator = navigator.Clone();
				xPathNavigator.MoveToRoot();
				return xPathNavigator.IsSamePosition(navigator);
			}
			return false;
		}

		internal void PushOutput(RecordOutput output)
		{
			builder.OutputState = xsm.State;
			RecordBuilder next = builder;
			builder = new RecordBuilder(output, nameTable);
			builder.Next = next;
			xsm.Reset();
		}

		internal RecordOutput PopOutput()
		{
			RecordBuilder recordBuilder = builder;
			builder = recordBuilder.Next;
			xsm.State = builder.OutputState;
			recordBuilder.TheEnd();
			return recordBuilder.Output;
		}

		internal bool SetDefaultOutput(XsltOutput.OutputMethod method)
		{
			if (Output.Method != method)
			{
				output = output.CreateDerivedOutput(method);
				return true;
			}
			return false;
		}

		internal object GetVariableValue(VariableAction variable)
		{
			int varKey = variable.VarKey;
			if (variable.IsGlobal)
			{
				ActionFrame actionFrame = (ActionFrame)actionStack[0];
				object variable2 = actionFrame.GetVariable(varKey);
				if (variable2 == VariableAction.BeingComputedMark)
				{
					throw XsltException.Create("Xslt_CircularReference", variable.NameStr);
				}
				if (variable2 != null)
				{
					return variable2;
				}
				int length = actionStack.Length;
				ActionFrame actionFrame2 = PushNewFrame();
				actionFrame2.Inherit(actionFrame);
				actionFrame2.Init(variable, actionFrame.NodeSet);
				do
				{
					if (((ActionFrame)actionStack.Peek()).Execute(this))
					{
						actionStack.Pop();
					}
				}
				while (length < actionStack.Length);
				return actionFrame.GetVariable(varKey);
			}
			return ((ActionFrame)actionStack.Peek()).GetVariable(varKey);
		}

		internal void SetParameter(XmlQualifiedName name, object value)
		{
			ActionFrame actionFrame = (ActionFrame)actionStack[actionStack.Length - 2];
			actionFrame.SetParameter(name, value);
		}

		internal void ResetParams()
		{
			ActionFrame actionFrame = (ActionFrame)actionStack[actionStack.Length - 1];
			actionFrame.ResetParams();
		}

		internal object GetParameter(XmlQualifiedName name)
		{
			ActionFrame actionFrame = (ActionFrame)actionStack[actionStack.Length - 3];
			return actionFrame.GetParameter(name);
		}

		internal void PushDebuggerStack()
		{
			DebuggerFrame debuggerFrame = (DebuggerFrame)debuggerStack.Push();
			if (debuggerFrame == null)
			{
				debuggerFrame = new DebuggerFrame();
				debuggerStack.AddToTop(debuggerFrame);
			}
			debuggerFrame.actionFrame = (ActionFrame)actionStack.Peek();
		}

		internal void PopDebuggerStack()
		{
			debuggerStack.Pop();
		}

		internal void OnInstructionExecute()
		{
			DebuggerFrame debuggerFrame = (DebuggerFrame)debuggerStack.Peek();
			debuggerFrame.actionFrame = (ActionFrame)actionStack.Peek();
			Debugger.OnInstructionExecute(this);
		}

		internal XmlQualifiedName GetPrevioseMode()
		{
			return ((DebuggerFrame)debuggerStack[debuggerStack.Length - 2]).currentMode;
		}

		internal void SetCurrentMode(XmlQualifiedName mode)
		{
			((DebuggerFrame)debuggerStack[debuggerStack.Length - 1]).currentMode = mode;
		}

		IStackFrame IXsltProcessor.GetStackFrame(int depth)
		{
			return ((DebuggerFrame)debuggerStack[depth]).actionFrame;
		}
	}
	internal class ReaderOutput : XmlReader, RecordOutput
	{
		private class XmlEncoder
		{
			private StringBuilder buffer;

			private XmlTextEncoder encoder;

			public char QuoteChar => '"';

			private void Init()
			{
				buffer = new StringBuilder();
				encoder = new XmlTextEncoder(new StringWriter(buffer, CultureInfo.InvariantCulture));
			}

			public string AtributeInnerXml(string value)
			{
				if (encoder == null)
				{
					Init();
				}
				buffer.Length = 0;
				encoder.StartAttribute(cacheAttrValue: false);
				encoder.Write(value);
				encoder.EndAttribute();
				return buffer.ToString();
			}

			public string AtributeOuterXml(string name, string value)
			{
				if (encoder == null)
				{
					Init();
				}
				buffer.Length = 0;
				buffer.Append(name);
				buffer.Append('=');
				buffer.Append(QuoteChar);
				encoder.StartAttribute(cacheAttrValue: false);
				encoder.Write(value);
				encoder.EndAttribute();
				buffer.Append(QuoteChar);
				return buffer.ToString();
			}
		}

		private Processor processor;

		private XmlNameTable nameTable;

		private RecordBuilder builder;

		private BuilderInfo mainNode;

		private ArrayList attributeList;

		private int attributeCount;

		private BuilderInfo attributeValue;

		private OutputScopeManager manager;

		private int currentIndex;

		private BuilderInfo currentInfo;

		private ReadState state;

		private bool haveRecord;

		private static BuilderInfo s_DefaultInfo = new BuilderInfo();

		private XmlEncoder encoder = new XmlEncoder();

		private XmlCharType xmlCharType = XmlCharType.Instance;

		public override XmlNodeType NodeType => currentInfo.NodeType;

		public override string Name
		{
			get
			{
				string prefix = Prefix;
				string localName = LocalName;
				if (prefix != null && prefix.Length > 0)
				{
					if (localName.Length > 0)
					{
						return nameTable.Add(prefix + ":" + localName);
					}
					return prefix;
				}
				return localName;
			}
		}

		public override string LocalName => currentInfo.LocalName;

		public override string NamespaceURI => currentInfo.NamespaceURI;

		public override string Prefix => currentInfo.Prefix;

		public override bool HasValue => XmlReader.HasValueInternal(NodeType);

		public override string Value => currentInfo.Value;

		public override int Depth => currentInfo.Depth;

		public override string BaseURI => string.Empty;

		public override bool IsEmptyElement => currentInfo.IsEmptyTag;

		public override char QuoteChar => encoder.QuoteChar;

		public override bool IsDefault => false;

		public override XmlSpace XmlSpace
		{
			get
			{
				if (manager == null)
				{
					return XmlSpace.None;
				}
				return manager.XmlSpace;
			}
		}

		public override string XmlLang
		{
			get
			{
				if (manager == null)
				{
					return string.Empty;
				}
				return manager.XmlLang;
			}
		}

		public override int AttributeCount => attributeCount;

		public override string this[int i] => GetAttribute(i);

		public override string this[string name] => GetAttribute(name);

		public override string this[string name, string namespaceURI] => GetAttribute(name, namespaceURI);

		public override bool EOF => state == ReadState.EndOfFile;

		public override ReadState ReadState => state;

		public override XmlNameTable NameTable => nameTable;

		internal ReaderOutput(Processor processor)
		{
			this.processor = processor;
			nameTable = processor.NameTable;
			Reset();
		}

		public override string GetAttribute(string name)
		{
			if (FindAttribute(name, out var attrIndex))
			{
				return ((BuilderInfo)attributeList[attrIndex]).Value;
			}
			return null;
		}

		public override string GetAttribute(string localName, string namespaceURI)
		{
			if (FindAttribute(localName, namespaceURI, out var attrIndex))
			{
				return ((BuilderInfo)attributeList[attrIndex]).Value;
			}
			return null;
		}

		public override string GetAttribute(int i)
		{
			BuilderInfo builderInfo = GetBuilderInfo(i);
			return builderInfo.Value;
		}

		public override bool MoveToAttribute(string name)
		{
			if (FindAttribute(name, out var attrIndex))
			{
				SetAttribute(attrIndex);
				return true;
			}
			return false;
		}

		public override bool MoveToAttribute(string localName, string namespaceURI)
		{
			if (FindAttribute(localName, namespaceURI, out var attrIndex))
			{
				SetAttribute(attrIndex);
				return true;
			}
			return false;
		}

		public override void MoveToAttribute(int i)
		{
			if (i < 0 || attributeCount <= i)
			{
				throw new ArgumentOutOfRangeException("i");
			}
			SetAttribute(i);
		}

		public override bool MoveToFirstAttribute()
		{
			if (attributeCount <= 0)
			{
				return false;
			}
			SetAttribute(0);
			return true;
		}

		public override bool MoveToNextAttribute()
		{
			if (currentIndex + 1 < attributeCount)
			{
				SetAttribute(currentIndex + 1);
				return true;
			}
			return false;
		}

		public override bool MoveToElement()
		{
			if (NodeType == XmlNodeType.Attribute || currentInfo == attributeValue)
			{
				SetMainNode();
				return true;
			}
			return false;
		}

		public override bool Read()
		{
			if (state != ReadState.Interactive)
			{
				if (state != 0)
				{
					return false;
				}
				state = ReadState.Interactive;
			}
			while (true)
			{
				if (haveRecord)
				{
					processor.ResetOutput();
					haveRecord = false;
				}
				processor.Execute();
				if (haveRecord)
				{
					switch (NodeType)
					{
					case XmlNodeType.Text:
						if (!xmlCharType.IsOnlyWhitespace(Value))
						{
							break;
						}
						currentInfo.NodeType = XmlNodeType.Whitespace;
						goto IL_007b;
					case XmlNodeType.Whitespace:
						goto IL_007b;
					}
				}
				else
				{
					state = ReadState.EndOfFile;
					Reset();
				}
				break;
				IL_007b:
				if (Value.Length != 0)
				{
					if (XmlSpace == XmlSpace.Preserve)
					{
						currentInfo.NodeType = XmlNodeType.SignificantWhitespace;
					}
					break;
				}
			}
			return haveRecord;
		}

		public override void Close()
		{
			processor = null;
			state = ReadState.Closed;
			Reset();
		}

		public override string ReadString()
		{
			string text = string.Empty;
			if (NodeType == XmlNodeType.Element || NodeType == XmlNodeType.Attribute || currentInfo == attributeValue)
			{
				if (mainNode.IsEmptyTag)
				{
					return text;
				}
				if (!Read())
				{
					throw new InvalidOperationException(System.Xml.Utils.Res.GetString("Xml_InvalidOperation"));
				}
			}
			StringBuilder stringBuilder = null;
			bool flag = true;
			while (true)
			{
				XmlNodeType nodeType = NodeType;
				if (nodeType != XmlNodeType.Text && (uint)(nodeType - 13) > 1u)
				{
					break;
				}
				if (flag)
				{
					text = Value;
					flag = false;
				}
				else
				{
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(text);
					}
					stringBuilder.Append(Value);
				}
				if (!Read())
				{
					throw new InvalidOperationException(System.Xml.Utils.Res.GetString("Xml_InvalidOperation"));
				}
			}
			if (stringBuilder != null)
			{
				return stringBuilder.ToString();
			}
			return text;
		}

		public override string ReadInnerXml()
		{
			if (ReadState == ReadState.Interactive)
			{
				if (NodeType == XmlNodeType.Element && !IsEmptyElement)
				{
					StringOutput stringOutput = new StringOutput(processor);
					stringOutput.OmitXmlDecl();
					int depth = Depth;
					Read();
					while (depth < Depth)
					{
						stringOutput.RecordDone(builder);
						Read();
					}
					Read();
					stringOutput.TheEnd();
					return stringOutput.Result;
				}
				if (NodeType == XmlNodeType.Attribute)
				{
					return encoder.AtributeInnerXml(Value);
				}
				Read();
			}
			return string.Empty;
		}

		public override string ReadOuterXml()
		{
			if (ReadState == ReadState.Interactive)
			{
				if (NodeType == XmlNodeType.Element)
				{
					StringOutput stringOutput = new StringOutput(processor);
					stringOutput.OmitXmlDecl();
					bool isEmptyElement = IsEmptyElement;
					int depth = Depth;
					stringOutput.RecordDone(builder);
					Read();
					while (depth < Depth)
					{
						stringOutput.RecordDone(builder);
						Read();
					}
					if (!isEmptyElement)
					{
						stringOutput.RecordDone(builder);
						Read();
					}
					stringOutput.TheEnd();
					return stringOutput.Result;
				}
				if (NodeType == XmlNodeType.Attribute)
				{
					return encoder.AtributeOuterXml(Name, Value);
				}
				Read();
			}
			return string.Empty;
		}

		public override string LookupNamespace(string prefix)
		{
			prefix = nameTable.Get(prefix);
			if (manager != null && prefix != null)
			{
				return manager.ResolveNamespace(prefix);
			}
			return null;
		}

		public override void ResolveEntity()
		{
			if (NodeType != XmlNodeType.EntityReference)
			{
				throw new InvalidOperationException(System.Xml.Utils.Res.GetString("Xml_InvalidOperation"));
			}
		}

		public override bool ReadAttributeValue()
		{
			if (ReadState != ReadState.Interactive || NodeType != XmlNodeType.Attribute)
			{
				return false;
			}
			if (attributeValue == null)
			{
				attributeValue = new BuilderInfo();
				attributeValue.NodeType = XmlNodeType.Text;
			}
			if (currentInfo == attributeValue)
			{
				return false;
			}
			attributeValue.Value = currentInfo.Value;
			attributeValue.Depth = currentInfo.Depth + 1;
			currentInfo = attributeValue;
			return true;
		}

		public Processor.OutputResult RecordDone(RecordBuilder record)
		{
			builder = record;
			mainNode = record.MainNode;
			attributeList = record.AttributeList;
			attributeCount = record.AttributeCount;
			manager = record.Manager;
			haveRecord = true;
			SetMainNode();
			return Processor.OutputResult.Interrupt;
		}

		public void TheEnd()
		{
		}

		private void SetMainNode()
		{
			currentIndex = -1;
			currentInfo = mainNode;
		}

		private void SetAttribute(int attrib)
		{
			currentIndex = attrib;
			currentInfo = (BuilderInfo)attributeList[attrib];
		}

		private BuilderInfo GetBuilderInfo(int attrib)
		{
			if (attrib < 0 || attributeCount <= attrib)
			{
				throw new ArgumentOutOfRangeException("attrib");
			}
			return (BuilderInfo)attributeList[attrib];
		}

		private bool FindAttribute(string localName, string namespaceURI, out int attrIndex)
		{
			if (namespaceURI == null)
			{
				namespaceURI = string.Empty;
			}
			if (localName == null)
			{
				localName = string.Empty;
			}
			for (int i = 0; i < attributeCount; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[i];
				if (builderInfo.NamespaceURI == namespaceURI && builderInfo.LocalName == localName)
				{
					attrIndex = i;
					return true;
				}
			}
			attrIndex = -1;
			return false;
		}

		private bool FindAttribute(string name, out int attrIndex)
		{
			if (name == null)
			{
				name = string.Empty;
			}
			for (int i = 0; i < attributeCount; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[i];
				if (builderInfo.Name == name)
				{
					attrIndex = i;
					return true;
				}
			}
			attrIndex = -1;
			return false;
		}

		private void Reset()
		{
			currentIndex = -1;
			currentInfo = s_DefaultInfo;
			mainNode = s_DefaultInfo;
			manager = null;
		}

		[Conditional("DEBUG")]
		private void CheckCurrentInfo()
		{
		}
	}
	internal sealed class RecordBuilder
	{
		private int outputState;

		private RecordBuilder next;

		private RecordOutput output;

		private XmlNameTable nameTable;

		private OutKeywords atoms;

		private OutputScopeManager scopeManager;

		private BuilderInfo mainNode = new BuilderInfo();

		private ArrayList attributeList = new ArrayList();

		private int attributeCount;

		private ArrayList namespaceList = new ArrayList();

		private int namespaceCount;

		private BuilderInfo dummy = new BuilderInfo();

		private BuilderInfo currentInfo;

		private bool popScope;

		private int recordState;

		private int recordDepth;

		private const int NoRecord = 0;

		private const int SomeRecord = 1;

		private const int HaveRecord = 2;

		private const char s_Minus = '-';

		private const string s_Space = " ";

		private const string s_SpaceMinus = " -";

		private const char s_Question = '?';

		private const char s_Greater = '>';

		private const string s_SpaceGreater = " >";

		private const string PrefixFormat = "xp_{0}";

		internal int OutputState
		{
			get
			{
				return outputState;
			}
			set
			{
				outputState = value;
			}
		}

		internal RecordBuilder Next
		{
			get
			{
				return next;
			}
			set
			{
				next = value;
			}
		}

		internal RecordOutput Output => output;

		internal BuilderInfo MainNode => mainNode;

		internal ArrayList AttributeList => attributeList;

		internal int AttributeCount => attributeCount;

		internal OutputScopeManager Manager => scopeManager;

		internal RecordBuilder(RecordOutput output, XmlNameTable nameTable)
		{
			this.output = output;
			this.nameTable = ((nameTable != null) ? nameTable : new NameTable());
			atoms = new OutKeywords(this.nameTable);
			scopeManager = new OutputScopeManager(this.nameTable, atoms);
		}

		private void ValueAppend(string s, bool disableOutputEscaping)
		{
			currentInfo.ValueAppend(s, disableOutputEscaping);
		}

		private bool CanOutput(int state)
		{
			if (recordState == 0 || (state & 0x2000) == 0)
			{
				return true;
			}
			recordState = 2;
			FinalizeRecord();
			SetEmptyFlag(state);
			return output.RecordDone(this) == Processor.OutputResult.Continue;
		}

		internal Processor.OutputResult BeginEvent(int state, XPathNodeType nodeType, string prefix, string name, string nspace, bool empty, object htmlProps, bool search)
		{
			if (!CanOutput(state))
			{
				return Processor.OutputResult.Overflow;
			}
			AdjustDepth(state);
			ResetRecord(state);
			PopElementScope();
			prefix = ((prefix != null) ? nameTable.Add(prefix) : atoms.Empty);
			name = ((name != null) ? nameTable.Add(name) : atoms.Empty);
			nspace = ((nspace != null) ? nameTable.Add(nspace) : atoms.Empty);
			switch (nodeType)
			{
			case XPathNodeType.Element:
				mainNode.htmlProps = htmlProps as HtmlElementProps;
				mainNode.search = search;
				BeginElement(prefix, name, nspace, empty);
				break;
			case XPathNodeType.Attribute:
				BeginAttribute(prefix, name, nspace, htmlProps, search);
				break;
			case XPathNodeType.Namespace:
				BeginNamespace(name, nspace);
				break;
			case XPathNodeType.ProcessingInstruction:
				if (!BeginProcessingInstruction(prefix, name, nspace))
				{
					return Processor.OutputResult.Error;
				}
				break;
			case XPathNodeType.Comment:
				BeginComment();
				break;
			}
			return CheckRecordBegin(state);
		}

		internal Processor.OutputResult TextEvent(int state, string text, bool disableOutputEscaping)
		{
			if (!CanOutput(state))
			{
				return Processor.OutputResult.Overflow;
			}
			AdjustDepth(state);
			ResetRecord(state);
			PopElementScope();
			if (((uint)state & 0x2000u) != 0)
			{
				currentInfo.Depth = recordDepth;
				currentInfo.NodeType = XmlNodeType.Text;
			}
			ValueAppend(text, disableOutputEscaping);
			return CheckRecordBegin(state);
		}

		internal Processor.OutputResult EndEvent(int state, XPathNodeType nodeType)
		{
			if (!CanOutput(state))
			{
				return Processor.OutputResult.Overflow;
			}
			AdjustDepth(state);
			PopElementScope();
			popScope = (state & 0x10000) != 0;
			if (((uint)state & 0x1000u) != 0 && mainNode.IsEmptyTag)
			{
				return Processor.OutputResult.Continue;
			}
			ResetRecord(state);
			if (((uint)state & 0x2000u) != 0 && nodeType == XPathNodeType.Element)
			{
				EndElement();
			}
			return CheckRecordEnd(state);
		}

		internal void Reset()
		{
			if (recordState == 2)
			{
				recordState = 0;
			}
		}

		internal void TheEnd()
		{
			if (recordState == 1)
			{
				recordState = 2;
				FinalizeRecord();
				output.RecordDone(this);
			}
			output.TheEnd();
		}

		private int FindAttribute(string name, string nspace, ref string prefix)
		{
			for (int i = 0; i < attributeCount; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[i];
				if (Ref.Equal(builderInfo.LocalName, name))
				{
					if (Ref.Equal(builderInfo.NamespaceURI, nspace))
					{
						return i;
					}
					if (Ref.Equal(builderInfo.Prefix, prefix))
					{
						prefix = string.Empty;
					}
				}
			}
			return -1;
		}

		private void BeginElement(string prefix, string name, string nspace, bool empty)
		{
			currentInfo.NodeType = XmlNodeType.Element;
			currentInfo.Prefix = prefix;
			currentInfo.LocalName = name;
			currentInfo.NamespaceURI = nspace;
			currentInfo.Depth = recordDepth;
			currentInfo.IsEmptyTag = empty;
			scopeManager.PushScope(name, nspace, prefix);
		}

		private void EndElement()
		{
			OutputScope currentElementScope = scopeManager.CurrentElementScope;
			currentInfo.NodeType = XmlNodeType.EndElement;
			currentInfo.Prefix = currentElementScope.Prefix;
			currentInfo.LocalName = currentElementScope.Name;
			currentInfo.NamespaceURI = currentElementScope.Namespace;
			currentInfo.Depth = recordDepth;
		}

		private int NewAttribute()
		{
			if (attributeCount >= attributeList.Count)
			{
				attributeList.Add(new BuilderInfo());
			}
			return attributeCount++;
		}

		private void BeginAttribute(string prefix, string name, string nspace, object htmlAttrProps, bool search)
		{
			int num = FindAttribute(name, nspace, ref prefix);
			if (num == -1)
			{
				num = NewAttribute();
			}
			BuilderInfo builderInfo = (BuilderInfo)attributeList[num];
			builderInfo.Initialize(prefix, name, nspace);
			builderInfo.Depth = recordDepth;
			builderInfo.NodeType = XmlNodeType.Attribute;
			builderInfo.htmlAttrProps = htmlAttrProps as HtmlAttributeProps;
			builderInfo.search = search;
			currentInfo = builderInfo;
		}

		private void BeginNamespace(string name, string nspace)
		{
			bool thisScope = false;
			if (Ref.Equal(name, atoms.Empty))
			{
				if (!Ref.Equal(nspace, scopeManager.DefaultNamespace) && !Ref.Equal(mainNode.NamespaceURI, atoms.Empty))
				{
					DeclareNamespace(nspace, name);
				}
			}
			else
			{
				string text = scopeManager.ResolveNamespace(name, out thisScope);
				if (text != null)
				{
					if (!Ref.Equal(nspace, text) && !thisScope)
					{
						DeclareNamespace(nspace, name);
					}
				}
				else
				{
					DeclareNamespace(nspace, name);
				}
			}
			currentInfo = dummy;
			currentInfo.NodeType = XmlNodeType.Attribute;
		}

		private bool BeginProcessingInstruction(string prefix, string name, string nspace)
		{
			currentInfo.NodeType = XmlNodeType.ProcessingInstruction;
			currentInfo.Prefix = prefix;
			currentInfo.LocalName = name;
			currentInfo.NamespaceURI = nspace;
			currentInfo.Depth = recordDepth;
			return true;
		}

		private void BeginComment()
		{
			currentInfo.NodeType = XmlNodeType.Comment;
			currentInfo.Depth = recordDepth;
		}

		private void AdjustDepth(int state)
		{
			switch (state & 0x300)
			{
			case 256:
				recordDepth++;
				break;
			case 512:
				recordDepth--;
				break;
			}
		}

		private void ResetRecord(int state)
		{
			if (((uint)state & 0x2000u) != 0)
			{
				attributeCount = 0;
				namespaceCount = 0;
				currentInfo = mainNode;
				currentInfo.Initialize(atoms.Empty, atoms.Empty, atoms.Empty);
				currentInfo.NodeType = XmlNodeType.None;
				currentInfo.IsEmptyTag = false;
				currentInfo.htmlProps = null;
				currentInfo.htmlAttrProps = null;
			}
		}

		private void PopElementScope()
		{
			if (popScope)
			{
				scopeManager.PopScope();
				popScope = false;
			}
		}

		private Processor.OutputResult CheckRecordBegin(int state)
		{
			if (((uint)state & 0x4000u) != 0)
			{
				recordState = 2;
				FinalizeRecord();
				SetEmptyFlag(state);
				return output.RecordDone(this);
			}
			recordState = 1;
			return Processor.OutputResult.Continue;
		}

		private Processor.OutputResult CheckRecordEnd(int state)
		{
			if (((uint)state & 0x4000u) != 0)
			{
				recordState = 2;
				FinalizeRecord();
				SetEmptyFlag(state);
				return output.RecordDone(this);
			}
			return Processor.OutputResult.Continue;
		}

		private void SetEmptyFlag(int state)
		{
			if (((uint)state & 0x400u) != 0)
			{
				mainNode.IsEmptyTag = false;
			}
		}

		private void AnalyzeSpaceLang()
		{
			for (int i = 0; i < attributeCount; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[i];
				if (Ref.Equal(builderInfo.Prefix, atoms.Xml))
				{
					OutputScope currentElementScope = scopeManager.CurrentElementScope;
					if (Ref.Equal(builderInfo.LocalName, atoms.Lang))
					{
						currentElementScope.Lang = builderInfo.Value;
					}
					else if (Ref.Equal(builderInfo.LocalName, atoms.Space))
					{
						currentElementScope.Space = TranslateXmlSpace(builderInfo.Value);
					}
				}
			}
		}

		private void FixupElement()
		{
			if (Ref.Equal(mainNode.NamespaceURI, atoms.Empty))
			{
				mainNode.Prefix = atoms.Empty;
			}
			if (Ref.Equal(mainNode.Prefix, atoms.Empty))
			{
				if (!Ref.Equal(mainNode.NamespaceURI, scopeManager.DefaultNamespace))
				{
					DeclareNamespace(mainNode.NamespaceURI, mainNode.Prefix);
				}
			}
			else
			{
				bool thisScope = false;
				string text = scopeManager.ResolveNamespace(mainNode.Prefix, out thisScope);
				if (text != null)
				{
					if (!Ref.Equal(mainNode.NamespaceURI, text))
					{
						if (thisScope)
						{
							mainNode.Prefix = GetPrefixForNamespace(mainNode.NamespaceURI);
						}
						else
						{
							DeclareNamespace(mainNode.NamespaceURI, mainNode.Prefix);
						}
					}
				}
				else
				{
					DeclareNamespace(mainNode.NamespaceURI, mainNode.Prefix);
				}
			}
			OutputScope currentElementScope = scopeManager.CurrentElementScope;
			currentElementScope.Prefix = mainNode.Prefix;
		}

		private void FixupAttributes(int attributeCount)
		{
			for (int i = 0; i < attributeCount; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[i];
				if (Ref.Equal(builderInfo.NamespaceURI, atoms.Empty))
				{
					builderInfo.Prefix = atoms.Empty;
					continue;
				}
				if (Ref.Equal(builderInfo.Prefix, atoms.Empty))
				{
					builderInfo.Prefix = GetPrefixForNamespace(builderInfo.NamespaceURI);
					continue;
				}
				bool thisScope = false;
				string text = scopeManager.ResolveNamespace(builderInfo.Prefix, out thisScope);
				if (text != null)
				{
					if (!Ref.Equal(builderInfo.NamespaceURI, text))
					{
						if (thisScope)
						{
							builderInfo.Prefix = GetPrefixForNamespace(builderInfo.NamespaceURI);
						}
						else
						{
							DeclareNamespace(builderInfo.NamespaceURI, builderInfo.Prefix);
						}
					}
				}
				else
				{
					DeclareNamespace(builderInfo.NamespaceURI, builderInfo.Prefix);
				}
			}
		}

		private void AppendNamespaces()
		{
			for (int num = namespaceCount - 1; num >= 0; num--)
			{
				BuilderInfo builderInfo = (BuilderInfo)attributeList[NewAttribute()];
				builderInfo.Initialize((BuilderInfo)namespaceList[num]);
			}
		}

		private void AnalyzeComment()
		{
			StringBuilder stringBuilder = null;
			string value = mainNode.Value;
			bool flag = false;
			int i = 0;
			int num = 0;
			for (; i < value.Length; i++)
			{
				char c = value[i];
				if (c == '-')
				{
					if (flag)
					{
						if (stringBuilder == null)
						{
							stringBuilder = new StringBuilder(value, num, i, 2 * value.Length);
						}
						else
						{
							stringBuilder.Append(value, num, i - num);
						}
						stringBuilder.Append(" -");
						num = i + 1;
					}
					flag = true;
				}
				else
				{
					flag = false;
				}
			}
			if (stringBuilder != null)
			{
				if (num < value.Length)
				{
					stringBuilder.Append(value, num, value.Length - num);
				}
				if (flag)
				{
					stringBuilder.Append(" ");
				}
				mainNode.Value = stringBuilder.ToString();
			}
			else if (flag)
			{
				mainNode.ValueAppend(" ", disableEscaping: false);
			}
		}

		private void AnalyzeProcessingInstruction()
		{
			StringBuilder stringBuilder = null;
			string value = mainNode.Value;
			bool flag = false;
			int i = 0;
			int num = 0;
			for (; i < value.Length; i++)
			{
				switch (value[i])
				{
				case '?':
					flag = true;
					break;
				case '>':
					if (flag)
					{
						if (stringBuilder == null)
						{
							stringBuilder = new StringBuilder(value, num, i, 2 * value.Length);
						}
						else
						{
							stringBuilder.Append(value, num, i - num);
						}
						stringBuilder.Append(" >");
						num = i + 1;
					}
					flag = false;
					break;
				default:
					flag = false;
					break;
				}
			}
			if (stringBuilder != null)
			{
				if (num < value.Length)
				{
					stringBuilder.Append(value, num, value.Length - num);
				}
				mainNode.Value = stringBuilder.ToString();
			}
		}

		private void FinalizeRecord()
		{
			switch (mainNode.NodeType)
			{
			case XmlNodeType.Element:
			{
				int num = attributeCount;
				FixupElement();
				FixupAttributes(num);
				AnalyzeSpaceLang();
				AppendNamespaces();
				break;
			}
			case XmlNodeType.Comment:
				AnalyzeComment();
				break;
			case XmlNodeType.ProcessingInstruction:
				AnalyzeProcessingInstruction();
				break;
			}
		}

		private int NewNamespace()
		{
			if (namespaceCount >= namespaceList.Count)
			{
				namespaceList.Add(new BuilderInfo());
			}
			return namespaceCount++;
		}

		private void DeclareNamespace(string nspace, string prefix)
		{
			int index = NewNamespace();
			BuilderInfo builderInfo = (BuilderInfo)namespaceList[index];
			if (prefix == atoms.Empty)
			{
				builderInfo.Initialize(atoms.Empty, atoms.Xmlns, atoms.XmlnsNamespace);
			}
			else
			{
				builderInfo.Initialize(atoms.Xmlns, prefix, atoms.XmlnsNamespace);
			}
			builderInfo.Depth = recordDepth;
			builderInfo.NodeType = XmlNodeType.Attribute;
			builderInfo.Value = nspace;
			scopeManager.PushNamespace(prefix, nspace);
		}

		private string DeclareNewNamespace(string nspace)
		{
			string text = scopeManager.GeneratePrefix("xp_{0}");
			DeclareNamespace(nspace, text);
			return text;
		}

		internal string GetPrefixForNamespace(string nspace)
		{
			string prefix = null;
			if (scopeManager.FindPrefix(nspace, out prefix))
			{
				return prefix;
			}
			return DeclareNewNamespace(nspace);
		}

		private static XmlSpace TranslateXmlSpace(string space)
		{
			if (space == "default")
			{
				return XmlSpace.Default;
			}
			if (space == "preserve")
			{
				return XmlSpace.Preserve;
			}
			return XmlSpace.None;
		}
	}
	internal interface RecordOutput
	{
		Processor.OutputResult RecordDone(RecordBuilder record);

		void TheEnd();
	}
	internal class Key
	{
		private XmlQualifiedName name;

		private int matchKey;

		private int useKey;

		private ArrayList keyNodes;

		public XmlQualifiedName Name => name;

		public int MatchKey => matchKey;

		public int UseKey => useKey;

		public Key(XmlQualifiedName name, int matchkey, int usekey)
		{
			this.name = name;
			matchKey = matchkey;
			useKey = usekey;
			keyNodes = null;
		}

		public void AddKey(XPathNavigator root, Hashtable table)
		{
			if (keyNodes == null)
			{
				keyNodes = new ArrayList();
			}
			keyNodes.Add(new DocumentKeyList(root, table));
		}

		public Hashtable GetKeys(XPathNavigator root)
		{
			if (keyNodes != null)
			{
				for (int i = 0; i < keyNodes.Count; i++)
				{
					if (((DocumentKeyList)keyNodes[i]).RootNav.IsSamePosition(root))
					{
						return ((DocumentKeyList)keyNodes[i]).KeyTable;
					}
				}
			}
			return null;
		}

		public Key Clone()
		{
			return new Key(name, matchKey, useKey);
		}
	}
	internal struct DocumentKeyList
	{
		private XPathNavigator rootNav;

		private Hashtable keyTable;

		public XPathNavigator RootNav => rootNav;

		public Hashtable KeyTable => keyTable;

		public DocumentKeyList(XPathNavigator rootNav, Hashtable keyTable)
		{
			this.rootNav = rootNav;
			this.keyTable = keyTable;
		}
	}
	internal class RootAction : TemplateBaseAction
	{
		private const int QueryInitialized = 2;

		private const int RootProcessed = 3;

		private Hashtable attributeSetTable = new Hashtable();

		private Hashtable decimalFormatTable = new Hashtable();

		private List<Key> keyList;

		private XsltOutput output;

		public Stylesheet builtInSheet;

		public PermissionSet permissions;

		internal XsltOutput Output
		{
			get
			{
				if (output == null)
				{
					output = new XsltOutput();
				}
				return output;
			}
		}

		internal List<Key> KeyList => keyList;

		internal override void Compile(Compiler compiler)
		{
			CompileDocument(compiler, inInclude: false);
		}

		internal void InsertKey(XmlQualifiedName name, int MatchKey, int UseKey)
		{
			if (keyList == null)
			{
				keyList = new List<Key>();
			}
			keyList.Add(new Key(name, MatchKey, UseKey));
		}

		internal AttributeSetAction GetAttributeSet(XmlQualifiedName name)
		{
			AttributeSetAction attributeSetAction = (AttributeSetAction)attributeSetTable[name];
			if (attributeSetAction == null)
			{
				throw XsltException.Create("Xslt_NoAttributeSet", name.ToString());
			}
			return attributeSetAction;
		}

		public void PorcessAttributeSets(Stylesheet rootStylesheet)
		{
			MirgeAttributeSets(rootStylesheet);
			foreach (AttributeSetAction value in attributeSetTable.Values)
			{
				if (value.containedActions != null)
				{
					value.containedActions.Reverse();
				}
			}
			CheckAttributeSets_RecurceInList(new Hashtable(), attributeSetTable.Keys);
		}

		private void MirgeAttributeSets(Stylesheet stylesheet)
		{
			if (stylesheet.AttributeSetTable != null)
			{
				foreach (AttributeSetAction value in stylesheet.AttributeSetTable.Values)
				{
					ArrayList arrayList = value.containedActions;
					AttributeSetAction attributeSetAction2 = (AttributeSetAction)attributeSetTable[value.Name];
					if (attributeSetAction2 == null)
					{
						attributeSetAction2 = new AttributeSetAction();
						attributeSetAction2.name = value.Name;
						attributeSetAction2.containedActions = new ArrayList();
						attributeSetTable[value.Name] = attributeSetAction2;
					}
					ArrayList arrayList2 = attributeSetAction2.containedActions;
					if (arrayList != null)
					{
						int num = arrayList.Count - 1;
						while (0 <= num)
						{
							arrayList2.Add(arrayList[num]);
							num--;
						}
					}
				}
			}
			foreach (Stylesheet import in stylesheet.Imports)
			{
				MirgeAttributeSets(import);
			}
		}

		private void CheckAttributeSets_RecurceInList(Hashtable markTable, ICollection setQNames)
		{
			foreach (XmlQualifiedName setQName in setQNames)
			{
				object obj = markTable[setQName];
				if (obj == "P")
				{
					throw XsltException.Create("Xslt_CircularAttributeSet", setQName.ToString());
				}
				if (obj != "D")
				{
					markTable[setQName] = "P";
					CheckAttributeSets_RecurceInContainer(markTable, GetAttributeSet(setQName));
					markTable[setQName] = "D";
				}
			}
		}

		private void CheckAttributeSets_RecurceInContainer(Hashtable markTable, ContainerAction container)
		{
			if (container.containedActions == null)
			{
				return;
			}
			foreach (Action containedAction in container.containedActions)
			{
				if (containedAction is UseAttributeSetsAction)
				{
					CheckAttributeSets_RecurceInList(markTable, ((UseAttributeSetsAction)containedAction).UsedSets);
				}
				else if (containedAction is ContainerAction)
				{
					CheckAttributeSets_RecurceInContainer(markTable, (ContainerAction)containedAction);
				}
			}
		}

		internal void AddDecimalFormat(XmlQualifiedName name, DecimalFormat formatinfo)
		{
			DecimalFormat decimalFormat = (DecimalFormat)decimalFormatTable[name];
			if (decimalFormat != null)
			{
				NumberFormatInfo info = decimalFormat.info;
				NumberFormatInfo info2 = formatinfo.info;
				if (info.NumberDecimalSeparator != info2.NumberDecimalSeparator || info.NumberGroupSeparator != info2.NumberGroupSeparator || info.PositiveInfinitySymbol != info2.PositiveInfinitySymbol || info.NegativeSign != info2.NegativeSign || info.NaNSymbol != info2.NaNSymbol || info.PercentSymbol != info2.PercentSymbol || info.PerMilleSymbol != info2.PerMilleSymbol || decimalFormat.zeroDigit != formatinfo.zeroDigit || decimalFormat.digit != formatinfo.digit || decimalFormat.patternSeparator != formatinfo.patternSeparator)
				{
					throw XsltException.Create("Xslt_DupDecimalFormat", name.ToString());
				}
			}
			decimalFormatTable[name] = formatinfo;
		}

		internal DecimalFormat GetDecimalFormat(XmlQualifiedName name)
		{
			return decimalFormatTable[name] as DecimalFormat;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
			{
				frame.AllocateVariables(variableCount);
				XPathNavigator xPathNavigator = processor.Document.Clone();
				xPathNavigator.MoveToRoot();
				frame.InitNodeSet(new XPathSingletonIterator(xPathNavigator));
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
				}
				frame.State = 2;
				break;
			}
			case 2:
				frame.NextNode(processor);
				if (processor.Debugger != null)
				{
					processor.PopDebuggerStack();
				}
				processor.PushTemplateLookup(frame.NodeSet, null, null);
				frame.State = 3;
				break;
			case 3:
				frame.Finished();
				break;
			case 1:
				break;
			}
		}
	}
	internal abstract class SequentialOutput : RecordOutput
	{
		private const char s_Colon = ':';

		private const char s_GreaterThan = '>';

		private const char s_LessThan = '<';

		private const char s_Space = ' ';

		private const char s_Quote = '"';

		private const char s_Semicolon = ';';

		private const char s_NewLine = '\n';

		private const char s_Return = '\r';

		private const char s_Ampersand = '&';

		private const string s_LessThanQuestion = "<?";

		private const string s_QuestionGreaterThan = "?>";

		private const string s_LessThanSlash = "</";

		private const string s_SlashGreaterThan = " />";

		private const string s_EqualQuote = "=\"";

		private const string s_DocType = "<!DOCTYPE ";

		private const string s_CommentBegin = "<!--";

		private const string s_CommentEnd = "-->";

		private const string s_CDataBegin = "<![CDATA[";

		private const string s_CDataEnd = "]]>";

		private const string s_VersionAll = " version=\"1.0\"";

		private const string s_Standalone = " standalone=\"";

		private const string s_EncodingStart = " encoding=\"";

		private const string s_Public = "PUBLIC ";

		private const string s_System = "SYSTEM ";

		private const string s_Html = "html";

		private const string s_QuoteSpace = "\" ";

		private const string s_CDataSplit = "]]]]><![CDATA[>";

		private const string s_EnLessThan = "&lt;";

		private const string s_EnGreaterThan = "&gt;";

		private const string s_EnAmpersand = "&amp;";

		private const string s_EnQuote = "&quot;";

		private const string s_EnNewLine = "&#xA;";

		private const string s_EnReturn = "&#xD;";

		private const string s_EndOfLine = "\r\n";

		private static char[] s_TextValueFind = new char[3] { '&', '>', '<' };

		private static string[] s_TextValueReplace = new string[3] { "&amp;", "&gt;", "&lt;" };

		private static char[] s_XmlAttributeValueFind = new char[6] { '&', '>', '<', '"', '\n', '\r' };

		private static string[] s_XmlAttributeValueReplace = new string[6] { "&amp;", "&gt;", "&lt;", "&quot;", "&#xA;", "&#xD;" };

		private Processor processor;

		protected Encoding encoding;

		private ArrayList outputCache;

		private bool firstLine = true;

		private bool secondRoot;

		private XsltOutput output;

		private bool isHtmlOutput;

		private bool isXmlOutput;

		private Hashtable cdataElements;

		private bool indentOutput;

		private bool outputDoctype;

		private bool outputXmlDecl;

		private bool omitXmlDeclCalled;

		private byte[] byteBuffer;

		private Encoding utf8Encoding;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		private void CacheOuptutProps(XsltOutput output)
		{
			this.output = output;
			isXmlOutput = this.output.Method == XsltOutput.OutputMethod.Xml;
			isHtmlOutput = this.output.Method == XsltOutput.OutputMethod.Html;
			cdataElements = this.output.CDataElements;
			indentOutput = this.output.Indent;
			outputDoctype = this.output.DoctypeSystem != null || (isHtmlOutput && this.output.DoctypePublic != null);
			outputXmlDecl = isXmlOutput && !this.output.OmitXmlDeclaration && !omitXmlDeclCalled;
		}

		internal SequentialOutput(Processor processor)
		{
			this.processor = processor;
			CacheOuptutProps(processor.Output);
		}

		public void OmitXmlDecl()
		{
			omitXmlDeclCalled = true;
			outputXmlDecl = false;
		}

		private void WriteStartElement(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			HtmlElementProps htmlElementProps = null;
			if (isHtmlOutput)
			{
				if (mainNode.Prefix.Length == 0)
				{
					htmlElementProps = mainNode.htmlProps;
					if (htmlElementProps == null && mainNode.search)
					{
						htmlElementProps = HtmlElementProps.GetProps(mainNode.LocalName);
					}
					record.Manager.CurrentElementScope.HtmlElementProps = htmlElementProps;
					mainNode.IsEmptyTag = false;
				}
			}
			else if (isXmlOutput && mainNode.Depth == 0)
			{
				if (secondRoot && (output.DoctypeSystem != null || output.Standalone))
				{
					throw XsltException.Create("Xslt_MultipleRoots");
				}
				secondRoot = true;
			}
			if (outputDoctype)
			{
				WriteDoctype(mainNode);
				outputDoctype = false;
			}
			if (cdataElements != null && cdataElements.Contains(new XmlQualifiedName(mainNode.LocalName, mainNode.NamespaceURI)) && isXmlOutput)
			{
				record.Manager.CurrentElementScope.ToCData = true;
			}
			Indent(record);
			Write('<');
			WriteName(mainNode.Prefix, mainNode.LocalName);
			WriteAttributes(record.AttributeList, record.AttributeCount, htmlElementProps);
			if (mainNode.IsEmptyTag)
			{
				Write(" />");
			}
			else
			{
				Write('>');
			}
			if (htmlElementProps != null && htmlElementProps.Head)
			{
				mainNode.Depth++;
				Indent(record);
				mainNode.Depth--;
				Write("<META http-equiv=\"Content-Type\" content=\"");
				Write(output.MediaType);
				Write("; charset=");
				Write(encoding.WebName);
				Write("\">");
			}
		}

		private void WriteTextNode(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			OutputScope currentElementScope = record.Manager.CurrentElementScope;
			currentElementScope.Mixed = true;
			if (currentElementScope.HtmlElementProps != null && currentElementScope.HtmlElementProps.NoEntities)
			{
				Write(mainNode.Value);
			}
			else if (currentElementScope.ToCData)
			{
				WriteCDataSection(mainNode.Value);
			}
			else
			{
				WriteTextNode(mainNode);
			}
		}

		private void WriteTextNode(BuilderInfo node)
		{
			for (int i = 0; i < node.TextInfoCount; i++)
			{
				string text = node.TextInfo[i];
				if (text == null)
				{
					i++;
					Write(node.TextInfo[i]);
				}
				else
				{
					WriteWithReplace(text, s_TextValueFind, s_TextValueReplace);
				}
			}
		}

		private void WriteCDataSection(string value)
		{
			Write("<![CDATA[");
			WriteCData(value);
			Write("]]>");
		}

		private void WriteDoctype(BuilderInfo mainNode)
		{
			Indent(0);
			Write("<!DOCTYPE ");
			if (isXmlOutput)
			{
				WriteName(mainNode.Prefix, mainNode.LocalName);
			}
			else
			{
				WriteName(string.Empty, "html");
			}
			Write(' ');
			if (output.DoctypePublic != null)
			{
				Write("PUBLIC ");
				Write('"');
				Write(output.DoctypePublic);
				Write("\" ");
			}
			else
			{
				Write("SYSTEM ");
			}
			if (output.DoctypeSystem != null)
			{
				Write('"');
				Write(output.DoctypeSystem);
				Write('"');
			}
			Write('>');
		}

		private void WriteXmlDeclaration()
		{
			outputXmlDecl = false;
			Indent(0);
			Write("<?");
			WriteName(string.Empty, "xml");
			Write(" version=\"1.0\"");
			if (encoding != null)
			{
				Write(" encoding=\"");
				Write(encoding.WebName);
				Write('"');
			}
			if (output.HasStandalone)
			{
				Write(" standalone=\"");
				Write(output.Standalone ? "yes" : "no");
				Write('"');
			}
			Write("?>");
		}

		private void WriteProcessingInstruction(RecordBuilder record)
		{
			Indent(record);
			WriteProcessingInstruction(record.MainNode);
		}

		private void WriteProcessingInstruction(BuilderInfo node)
		{
			Write("<?");
			WriteName(node.Prefix, node.LocalName);
			Write(' ');
			Write(node.Value);
			if (isHtmlOutput)
			{
				Write('>');
			}
			else
			{
				Write("?>");
			}
		}

		private void WriteEndElement(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			HtmlElementProps htmlElementProps = record.Manager.CurrentElementScope.HtmlElementProps;
			if (htmlElementProps == null || !htmlElementProps.Empty)
			{
				Indent(record);
				Write("</");
				WriteName(record.MainNode.Prefix, record.MainNode.LocalName);
				Write('>');
			}
		}

		public Processor.OutputResult RecordDone(RecordBuilder record)
		{
			if (output.Method == XsltOutput.OutputMethod.Unknown)
			{
				if (!DecideDefaultOutput(record.MainNode))
				{
					CacheRecord(record);
				}
				else
				{
					OutputCachedRecords();
					OutputRecord(record);
				}
			}
			else
			{
				OutputRecord(record);
			}
			record.Reset();
			return Processor.OutputResult.Continue;
		}

		public void TheEnd()
		{
			OutputCachedRecords();
			Close();
		}

		private bool DecideDefaultOutput(BuilderInfo node)
		{
			XsltOutput.OutputMethod defaultOutput = XsltOutput.OutputMethod.Xml;
			switch (node.NodeType)
			{
			case XmlNodeType.Element:
				if (node.NamespaceURI.Length == 0 && string.Compare("html", node.LocalName, StringComparison.OrdinalIgnoreCase) == 0)
				{
					defaultOutput = XsltOutput.OutputMethod.Html;
				}
				break;
			case XmlNodeType.Text:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				if (xmlCharType.IsOnlyWhitespace(node.Value))
				{
					return false;
				}
				defaultOutput = XsltOutput.OutputMethod.Xml;
				break;
			default:
				return false;
			}
			if (processor.SetDefaultOutput(defaultOutput))
			{
				CacheOuptutProps(processor.Output);
			}
			return true;
		}

		private void CacheRecord(RecordBuilder record)
		{
			if (outputCache == null)
			{
				outputCache = new ArrayList();
			}
			outputCache.Add(record.MainNode.Clone());
		}

		private void OutputCachedRecords()
		{
			if (outputCache != null)
			{
				for (int i = 0; i < outputCache.Count; i++)
				{
					BuilderInfo node = (BuilderInfo)outputCache[i];
					OutputRecord(node);
				}
				outputCache = null;
			}
		}

		private void OutputRecord(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			if (outputXmlDecl)
			{
				WriteXmlDeclaration();
			}
			switch (mainNode.NodeType)
			{
			case XmlNodeType.Element:
				WriteStartElement(record);
				break;
			case XmlNodeType.Text:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				WriteTextNode(record);
				break;
			case XmlNodeType.EntityReference:
				Write('&');
				WriteName(mainNode.Prefix, mainNode.LocalName);
				Write(';');
				break;
			case XmlNodeType.ProcessingInstruction:
				WriteProcessingInstruction(record);
				break;
			case XmlNodeType.Comment:
				Indent(record);
				Write("<!--");
				Write(mainNode.Value);
				Write("-->");
				break;
			case XmlNodeType.DocumentType:
				Write(mainNode.Value);
				break;
			case XmlNodeType.EndElement:
				WriteEndElement(record);
				break;
			case XmlNodeType.Attribute:
			case XmlNodeType.CDATA:
			case XmlNodeType.Entity:
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
			case XmlNodeType.Notation:
				break;
			}
		}

		private void OutputRecord(BuilderInfo node)
		{
			if (outputXmlDecl)
			{
				WriteXmlDeclaration();
			}
			Indent(0);
			switch (node.NodeType)
			{
			case XmlNodeType.Text:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				WriteTextNode(node);
				break;
			case XmlNodeType.EntityReference:
				Write('&');
				WriteName(node.Prefix, node.LocalName);
				Write(';');
				break;
			case XmlNodeType.ProcessingInstruction:
				WriteProcessingInstruction(node);
				break;
			case XmlNodeType.Comment:
				Write("<!--");
				Write(node.Value);
				Write("-->");
				break;
			case XmlNodeType.DocumentType:
				Write(node.Value);
				break;
			case XmlNodeType.Element:
			case XmlNodeType.Attribute:
			case XmlNodeType.CDATA:
			case XmlNodeType.Entity:
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
			case XmlNodeType.Notation:
			case XmlNodeType.EndElement:
				break;
			}
		}

		private void WriteName(string prefix, string name)
		{
			if (prefix != null && prefix.Length > 0)
			{
				Write(prefix);
				if (name == null || name.Length <= 0)
				{
					return;
				}
				Write(':');
			}
			Write(name);
		}

		private void WriteXmlAttributeValue(string value)
		{
			WriteWithReplace(value, s_XmlAttributeValueFind, s_XmlAttributeValueReplace);
		}

		private void WriteHtmlAttributeValue(string value)
		{
			int length = value.Length;
			int num = 0;
			while (num < length)
			{
				char c = value[num];
				num++;
				switch (c)
				{
				case '&':
					if (num != length && value[num] == '{')
					{
						Write(c);
					}
					else
					{
						Write("&amp;");
					}
					break;
				case '"':
					Write("&quot;");
					break;
				default:
					Write(c);
					break;
				}
			}
		}

		private void WriteHtmlUri(string value)
		{
			int length = value.Length;
			int num = 0;
			while (num < length)
			{
				char c = value[num];
				num++;
				switch (c)
				{
				case '&':
					if (num != length && value[num] == '{')
					{
						Write(c);
					}
					else
					{
						Write("&amp;");
					}
					continue;
				case '"':
					Write("&quot;");
					continue;
				case '\n':
					Write("&#xA;");
					continue;
				case '\r':
					Write("&#xD;");
					continue;
				}
				if ('\u007f' < c)
				{
					if (utf8Encoding == null)
					{
						utf8Encoding = Encoding.UTF8;
						byteBuffer = new byte[utf8Encoding.GetMaxByteCount(1)];
					}
					int bytes = utf8Encoding.GetBytes(value, num - 1, 1, byteBuffer, 0);
					for (int i = 0; i < bytes; i++)
					{
						Write("%");
						uint num2 = byteBuffer[i];
						Write(num2.ToString("X2", CultureInfo.InvariantCulture));
					}
				}
				else
				{
					Write(c);
				}
			}
		}

		private void WriteWithReplace(string value, char[] find, string[] replace)
		{
			int length = value.Length;
			int i;
			for (i = 0; i < length; i++)
			{
				int num = value.IndexOfAny(find, i);
				if (num == -1)
				{
					break;
				}
				for (; i < num; i++)
				{
					Write(value[i]);
				}
				char c = value[i];
				int num2 = find.Length - 1;
				while (0 <= num2)
				{
					if (find[num2] == c)
					{
						Write(replace[num2]);
						break;
					}
					num2--;
				}
			}
			if (i == 0)
			{
				Write(value);
				return;
			}
			for (; i < length; i++)
			{
				Write(value[i]);
			}
		}

		private void WriteCData(string value)
		{
			Write(value.Replace("]]>", "]]]]><![CDATA[>"));
		}

		private void WriteAttributes(ArrayList list, int count, HtmlElementProps htmlElementsProps)
		{
			for (int i = 0; i < count; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)list[i];
				string value = builderInfo.Value;
				bool flag = false;
				bool flag2 = false;
				if (htmlElementsProps != null && builderInfo.Prefix.Length == 0)
				{
					HtmlAttributeProps htmlAttributeProps = builderInfo.htmlAttrProps;
					if (htmlAttributeProps == null && builderInfo.search)
					{
						htmlAttributeProps = HtmlAttributeProps.GetProps(builderInfo.LocalName);
					}
					if (htmlAttributeProps != null)
					{
						flag = htmlElementsProps.AbrParent && htmlAttributeProps.Abr;
						flag2 = htmlElementsProps.UriParent && (htmlAttributeProps.Uri || (htmlElementsProps.NameParent && htmlAttributeProps.Name));
					}
				}
				Write(' ');
				WriteName(builderInfo.Prefix, builderInfo.LocalName);
				if (!flag || string.Compare(builderInfo.LocalName, value, StringComparison.OrdinalIgnoreCase) != 0)
				{
					Write("=\"");
					if (flag2)
					{
						WriteHtmlUri(value);
					}
					else if (isHtmlOutput)
					{
						WriteHtmlAttributeValue(value);
					}
					else
					{
						WriteXmlAttributeValue(value);
					}
					Write('"');
				}
			}
		}

		private void Indent(RecordBuilder record)
		{
			if (!record.Manager.CurrentElementScope.Mixed)
			{
				Indent(record.MainNode.Depth);
			}
		}

		private void Indent(int depth)
		{
			if (firstLine)
			{
				if (indentOutput)
				{
					firstLine = false;
				}
				return;
			}
			Write("\r\n");
			int num = 2 * depth;
			while (0 < num)
			{
				Write(" ");
				num--;
			}
		}

		internal abstract void Write(char outputChar);

		internal abstract void Write(string outputText);

		internal abstract void Close();
	}
	internal class SortAction : CompiledAction
	{
		private int selectKey = -1;

		private Avt langAvt;

		private Avt dataTypeAvt;

		private Avt orderAvt;

		private Avt caseOrderAvt;

		private string lang;

		private XmlDataType dataType = XmlDataType.Text;

		private XmlSortOrder order = XmlSortOrder.Ascending;

		private XmlCaseOrder caseOrder;

		private Sort sort;

		private bool forwardCompatibility;

		private InputScopeManager manager;

		private string ParseLang(string value)
		{
			if (value == null)
			{
				return null;
			}
			if (!XmlComplianceUtil.IsValidLanguageID(value.ToCharArray(), 0, value.Length) && (value.Length == 0 || CultureInfo.GetCultureInfo(value) == null))
			{
				if (forwardCompatibility)
				{
					return null;
				}
				throw XsltException.Create("Xslt_InvalidAttrValue", "lang", value);
			}
			return value;
		}

		private XmlDataType ParseDataType(string value, InputScopeManager manager)
		{
			if (value == null)
			{
				return XmlDataType.Text;
			}
			if (value == "text")
			{
				return XmlDataType.Text;
			}
			if (value == "number")
			{
				return XmlDataType.Number;
			}
			PrefixQName.ParseQualifiedName(value, out var prefix, out var _);
			manager.ResolveXmlNamespace(prefix);
			if (prefix.Length == 0 && !forwardCompatibility)
			{
				throw XsltException.Create("Xslt_InvalidAttrValue", "data-type", value);
			}
			return XmlDataType.Text;
		}

		private XmlSortOrder ParseOrder(string value)
		{
			if (value == null)
			{
				return XmlSortOrder.Ascending;
			}
			if (value == "ascending")
			{
				return XmlSortOrder.Ascending;
			}
			if (value == "descending")
			{
				return XmlSortOrder.Descending;
			}
			if (forwardCompatibility)
			{
				return XmlSortOrder.Ascending;
			}
			throw XsltException.Create("Xslt_InvalidAttrValue", "order", value);
		}

		private XmlCaseOrder ParseCaseOrder(string value)
		{
			if (value == null)
			{
				return XmlCaseOrder.None;
			}
			if (value == "upper-first")
			{
				return XmlCaseOrder.UpperFirst;
			}
			if (value == "lower-first")
			{
				return XmlCaseOrder.LowerFirst;
			}
			if (forwardCompatibility)
			{
				return XmlCaseOrder.None;
			}
			throw XsltException.Create("Xslt_InvalidAttrValue", "case-order", value);
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckEmpty(compiler);
			if (selectKey == -1)
			{
				selectKey = compiler.AddQuery(".");
			}
			forwardCompatibility = compiler.ForwardCompatibility;
			manager = compiler.CloneScopeManager();
			lang = ParseLang(CompiledAction.PrecalculateAvt(ref langAvt));
			dataType = ParseDataType(CompiledAction.PrecalculateAvt(ref dataTypeAvt), manager);
			order = ParseOrder(CompiledAction.PrecalculateAvt(ref orderAvt));
			caseOrder = ParseCaseOrder(CompiledAction.PrecalculateAvt(ref caseOrderAvt));
			if (langAvt == null && dataTypeAvt == null && orderAvt == null && caseOrderAvt == null)
			{
				sort = new Sort(selectKey, lang, dataType, order, caseOrder);
			}
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Select))
			{
				selectKey = compiler.AddQuery(value);
			}
			else if (Ref.Equal(localName, compiler.Atoms.Lang))
			{
				langAvt = Avt.CompileAvt(compiler, value);
			}
			else if (Ref.Equal(localName, compiler.Atoms.DataType))
			{
				dataTypeAvt = Avt.CompileAvt(compiler, value);
			}
			else if (Ref.Equal(localName, compiler.Atoms.Order))
			{
				orderAvt = Avt.CompileAvt(compiler, value);
			}
			else
			{
				if (!Ref.Equal(localName, compiler.Atoms.CaseOrder))
				{
					return false;
				}
				caseOrderAvt = Avt.CompileAvt(compiler, value);
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			processor.AddSort((sort != null) ? sort : new Sort(selectKey, (langAvt == null) ? lang : ParseLang(langAvt.Evaluate(processor, frame)), (dataTypeAvt == null) ? dataType : ParseDataType(dataTypeAvt.Evaluate(processor, frame), manager), (orderAvt == null) ? order : ParseOrder(orderAvt.Evaluate(processor, frame)), (caseOrderAvt == null) ? caseOrder : ParseCaseOrder(caseOrderAvt.Evaluate(processor, frame))));
			frame.Finished();
		}
	}
	internal class StateMachine
	{
		private const int Init = 0;

		private const int Elem = 1;

		private const int NsN = 2;

		private const int NsV = 3;

		private const int Ns = 4;

		private const int AttrN = 5;

		private const int AttrV = 6;

		private const int Attr = 7;

		private const int InElm = 8;

		private const int EndEm = 9;

		private const int InCmt = 10;

		private const int InPI = 11;

		private const int StateMask = 15;

		internal const int Error = 16;

		private const int Ignor = 32;

		private const int Assrt = 48;

		private const int U = 256;

		private const int D = 512;

		internal const int DepthMask = 768;

		internal const int DepthUp = 256;

		internal const int DepthDown = 512;

		private const int C = 1024;

		private const int H = 2048;

		private const int M = 4096;

		internal const int BeginChild = 1024;

		internal const int HadChild = 2048;

		internal const int EmptyTag = 4096;

		private const int B = 8192;

		private const int E = 16384;

		internal const int BeginRecord = 8192;

		internal const int EndRecord = 16384;

		private const int S = 32768;

		private const int P = 65536;

		internal const int PushScope = 32768;

		internal const int PopScope = 65536;

		private int _State;

		private static readonly int[][] s_BeginTransitions = new int[10][]
		{
			new int[12]
			{
				16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
				16, 16
			},
			new int[12]
			{
				40961, 42241, 16, 16, 41985, 16, 16, 41985, 40961, 106497,
				16, 16
			},
			new int[12]
			{
				16, 261, 16, 16, 5, 16, 16, 5, 16, 16,
				16, 16
			},
			new int[12]
			{
				16, 258, 16, 16, 2, 16, 16, 16, 16, 16,
				16, 16
			},
			new int[12]
			{
				8200, 9480, 259, 3, 9224, 262, 6, 9224, 8, 73736,
				10, 11
			},
			new int[12]
			{
				8200, 9480, 259, 3, 9224, 262, 6, 9224, 8, 73736,
				10, 11
			},
			new int[12]
			{
				8200, 9480, 259, 3, 9224, 262, 6, 9224, 8, 73736,
				10, 11
			},
			new int[12]
			{
				8203, 9483, 16, 16, 9227, 16, 16, 9227, 8203, 73739,
				16, 16
			},
			new int[12]
			{
				8202, 9482, 16, 16, 9226, 16, 16, 9226, 8202, 73738,
				16, 16
			},
			new int[12]
			{
				16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
				16, 16
			}
		};

		private static readonly int[][] s_EndTransitions = new int[10][]
		{
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 94217, 48, 48, 94729, 48, 48, 94729, 92681, 92681,
				48, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 7, 519, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 48, 4, 516, 48, 48, 48, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 16393
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				16393, 48
			},
			new int[12]
			{
				48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
				48, 48
			}
		};

		internal int State
		{
			get
			{
				return _State;
			}
			set
			{
				_State = value;
			}
		}

		internal StateMachine()
		{
			_State = 0;
		}

		internal void Reset()
		{
			_State = 0;
		}

		internal static int StateOnly(int state)
		{
			return state & 0xF;
		}

		internal int BeginOutlook(XPathNodeType nodeType)
		{
			return s_BeginTransitions[(int)nodeType][_State];
		}

		internal int Begin(XPathNodeType nodeType)
		{
			int num = s_BeginTransitions[(int)nodeType][_State];
			if (num != 16 && num != 32)
			{
				_State = num & 0xF;
			}
			return num;
		}

		internal int EndOutlook(XPathNodeType nodeType)
		{
			return s_EndTransitions[(int)nodeType][_State];
		}

		internal int End(XPathNodeType nodeType)
		{
			int num = s_EndTransitions[(int)nodeType][_State];
			if (num != 16 && num != 32)
			{
				_State = num & 0xF;
			}
			return num;
		}
	}
	internal class StringOutput : SequentialOutput
	{
		private StringBuilder builder;

		private string result;

		internal string Result => result;

		internal StringOutput(Processor processor)
			: base(processor)
		{
			builder = new StringBuilder();
		}

		internal override void Write(char outputChar)
		{
			builder.Append(outputChar);
		}

		internal override void Write(string outputText)
		{
			builder.Append(outputText);
		}

		internal override void Close()
		{
			result = builder.ToString();
		}
	}
	internal class Stylesheet
	{
		private class WhitespaceElement
		{
			private int key;

			private double priority;

			private bool preserveSpace;

			internal double Priority => priority;

			internal int Key => key;

			internal bool PreserveSpace => preserveSpace;

			internal WhitespaceElement(int Key, double priority, bool PreserveSpace)
			{
				key = Key;
				this.priority = priority;
				preserveSpace = PreserveSpace;
			}

			internal void ReplaceValue(bool PreserveSpace)
			{
				preserveSpace = PreserveSpace;
			}
		}

		private ArrayList imports = new ArrayList();

		private Hashtable modeManagers;

		private Hashtable templateNameTable = new Hashtable();

		private Hashtable attributeSetTable;

		private int templateCount;

		private Hashtable queryKeyTable;

		private ArrayList whitespaceList;

		private bool whitespace;

		private Hashtable scriptObjectTypes = new Hashtable();

		private TemplateManager templates;

		internal bool Whitespace => whitespace;

		internal ArrayList Imports => imports;

		internal Hashtable AttributeSetTable => attributeSetTable;

		internal Hashtable ScriptObjectTypes => scriptObjectTypes;

		internal void AddSpace(Compiler compiler, string query, double Priority, bool PreserveSpace)
		{
			WhitespaceElement whitespaceElement;
			if (queryKeyTable != null)
			{
				if (queryKeyTable.Contains(query))
				{
					whitespaceElement = (WhitespaceElement)queryKeyTable[query];
					whitespaceElement.ReplaceValue(PreserveSpace);
					return;
				}
			}
			else
			{
				queryKeyTable = new Hashtable();
				whitespaceList = new ArrayList();
			}
			int key = compiler.AddQuery(query);
			whitespaceElement = new WhitespaceElement(key, Priority, PreserveSpace);
			queryKeyTable[query] = whitespaceElement;
			whitespaceList.Add(whitespaceElement);
		}

		internal void SortWhiteSpace()
		{
			if (queryKeyTable != null)
			{
				for (int i = 0; i < whitespaceList.Count; i++)
				{
					for (int num = whitespaceList.Count - 1; num > i; num--)
					{
						WhitespaceElement whitespaceElement = (WhitespaceElement)whitespaceList[num - 1];
						WhitespaceElement whitespaceElement2 = (WhitespaceElement)whitespaceList[num];
						if (whitespaceElement2.Priority < whitespaceElement.Priority)
						{
							whitespaceList[num - 1] = whitespaceElement2;
							whitespaceList[num] = whitespaceElement;
						}
					}
				}
				whitespace = true;
			}
			if (imports == null)
			{
				return;
			}
			for (int num2 = imports.Count - 1; num2 >= 0; num2--)
			{
				Stylesheet stylesheet = (Stylesheet)imports[num2];
				if (stylesheet.Whitespace)
				{
					stylesheet.SortWhiteSpace();
					whitespace = true;
				}
			}
		}

		internal bool PreserveWhiteSpace(Processor proc, XPathNavigator node)
		{
			if (whitespaceList != null)
			{
				int num = whitespaceList.Count - 1;
				while (0 <= num)
				{
					WhitespaceElement whitespaceElement = (WhitespaceElement)whitespaceList[num];
					if (proc.Matches(node, whitespaceElement.Key))
					{
						return whitespaceElement.PreserveSpace;
					}
					num--;
				}
			}
			if (imports != null)
			{
				for (int num2 = imports.Count - 1; num2 >= 0; num2--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num2];
					if (!stylesheet.PreserveWhiteSpace(proc, node))
					{
						return false;
					}
				}
			}
			return true;
		}

		internal void AddAttributeSet(AttributeSetAction attributeSet)
		{
			if (attributeSetTable == null)
			{
				attributeSetTable = new Hashtable();
			}
			if (!attributeSetTable.ContainsKey(attributeSet.Name))
			{
				attributeSetTable[attributeSet.Name] = attributeSet;
			}
			else
			{
				((AttributeSetAction)attributeSetTable[attributeSet.Name]).Merge(attributeSet);
			}
		}

		internal void AddTemplate(TemplateAction template)
		{
			XmlQualifiedName xmlQualifiedName = template.Mode;
			if (template.Name != null)
			{
				if (templateNameTable.ContainsKey(template.Name))
				{
					throw XsltException.Create("Xslt_DupTemplateName", template.Name.ToString());
				}
				templateNameTable[template.Name] = template;
			}
			if (template.MatchKey == -1)
			{
				return;
			}
			if (modeManagers == null)
			{
				modeManagers = new Hashtable();
			}
			if (xmlQualifiedName == null)
			{
				xmlQualifiedName = XmlQualifiedName.Empty;
			}
			TemplateManager templateManager = (TemplateManager)modeManagers[xmlQualifiedName];
			if (templateManager == null)
			{
				templateManager = new TemplateManager(this, xmlQualifiedName);
				modeManagers[xmlQualifiedName] = templateManager;
				if (xmlQualifiedName.IsEmpty)
				{
					templates = templateManager;
				}
			}
			template.TemplateId = ++templateCount;
			templateManager.AddTemplate(template);
		}

		internal void ProcessTemplates()
		{
			if (modeManagers != null)
			{
				IDictionaryEnumerator enumerator = modeManagers.GetEnumerator();
				while (enumerator.MoveNext())
				{
					TemplateManager templateManager = (TemplateManager)enumerator.Value;
					templateManager.ProcessTemplates();
				}
			}
			if (imports != null)
			{
				for (int num = imports.Count - 1; num >= 0; num--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num];
					stylesheet.ProcessTemplates();
				}
			}
		}

		internal void ReplaceNamespaceAlias(Compiler compiler)
		{
			if (modeManagers != null)
			{
				IDictionaryEnumerator enumerator = modeManagers.GetEnumerator();
				while (enumerator.MoveNext())
				{
					TemplateManager templateManager = (TemplateManager)enumerator.Value;
					if (templateManager.templates != null)
					{
						for (int i = 0; i < templateManager.templates.Count; i++)
						{
							TemplateAction templateAction = (TemplateAction)templateManager.templates[i];
							templateAction.ReplaceNamespaceAlias(compiler);
						}
					}
				}
			}
			if (templateNameTable != null)
			{
				IDictionaryEnumerator enumerator2 = templateNameTable.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					TemplateAction templateAction2 = (TemplateAction)enumerator2.Value;
					templateAction2.ReplaceNamespaceAlias(compiler);
				}
			}
			if (imports != null)
			{
				for (int num = imports.Count - 1; num >= 0; num--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num];
					stylesheet.ReplaceNamespaceAlias(compiler);
				}
			}
		}

		internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator, XmlQualifiedName mode)
		{
			TemplateAction templateAction = null;
			if (modeManagers != null)
			{
				TemplateManager templateManager = (TemplateManager)modeManagers[mode];
				if (templateManager != null)
				{
					templateAction = templateManager.FindTemplate(processor, navigator);
				}
			}
			if (templateAction == null)
			{
				templateAction = FindTemplateImports(processor, navigator, mode);
			}
			return templateAction;
		}

		internal TemplateAction FindTemplateImports(Processor processor, XPathNavigator navigator, XmlQualifiedName mode)
		{
			TemplateAction templateAction = null;
			if (imports != null)
			{
				for (int num = imports.Count - 1; num >= 0; num--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num];
					templateAction = stylesheet.FindTemplate(processor, navigator, mode);
					if (templateAction != null)
					{
						return templateAction;
					}
				}
			}
			return templateAction;
		}

		internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator)
		{
			TemplateAction templateAction = null;
			if (templates != null)
			{
				templateAction = templates.FindTemplate(processor, navigator);
			}
			if (templateAction == null)
			{
				templateAction = FindTemplateImports(processor, navigator);
			}
			return templateAction;
		}

		internal TemplateAction FindTemplate(XmlQualifiedName name)
		{
			TemplateAction templateAction = null;
			if (templateNameTable != null)
			{
				templateAction = (TemplateAction)templateNameTable[name];
			}
			if (templateAction == null && imports != null)
			{
				for (int num = imports.Count - 1; num >= 0; num--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num];
					templateAction = stylesheet.FindTemplate(name);
					if (templateAction != null)
					{
						return templateAction;
					}
				}
			}
			return templateAction;
		}

		internal TemplateAction FindTemplateImports(Processor processor, XPathNavigator navigator)
		{
			TemplateAction templateAction = null;
			if (imports != null)
			{
				for (int num = imports.Count - 1; num >= 0; num--)
				{
					Stylesheet stylesheet = (Stylesheet)imports[num];
					templateAction = stylesheet.FindTemplate(processor, navigator);
					if (templateAction != null)
					{
						return templateAction;
					}
				}
			}
			return templateAction;
		}
	}
	internal class TemplateAction : TemplateBaseAction
	{
		private int matchKey = -1;

		private XmlQualifiedName name;

		private double priority = double.NaN;

		private XmlQualifiedName mode;

		private int templateId;

		private bool replaceNSAliasesDone;

		internal int MatchKey => matchKey;

		internal XmlQualifiedName Name => name;

		internal double Priority => priority;

		internal XmlQualifiedName Mode => mode;

		internal int TemplateId
		{
			get
			{
				return templateId;
			}
			set
			{
				templateId = value;
			}
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			if (matchKey == -1)
			{
				if (name == null)
				{
					throw XsltException.Create("Xslt_TemplateNoAttrib");
				}
				if (mode != null)
				{
					throw XsltException.Create("Xslt_InvalidModeAttribute");
				}
			}
			compiler.BeginTemplate(this);
			if (compiler.Recurse())
			{
				CompileParameters(compiler);
				CompileTemplate(compiler);
				compiler.ToParent();
			}
			compiler.EndTemplate();
			AnalyzePriority(compiler);
		}

		internal virtual void CompileSingle(Compiler compiler)
		{
			matchKey = compiler.AddQuery("/", allowVar: false, allowKey: true, isPattern: true);
			priority = 0.5;
			CompileOnceTemplate(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Match))
			{
				matchKey = compiler.AddQuery(value, allowVar: false, allowKey: true, isPattern: true);
			}
			else if (Ref.Equal(localName, compiler.Atoms.Name))
			{
				name = compiler.CreateXPathQName(value);
			}
			else if (Ref.Equal(localName, compiler.Atoms.Priority))
			{
				priority = XmlConvert.ToXPathDouble(value);
				if (double.IsNaN(priority) && !compiler.ForwardCompatibility)
				{
					throw XsltException.Create("Xslt_InvalidAttrValue", "priority", value);
				}
			}
			else
			{
				if (!Ref.Equal(localName, compiler.Atoms.Mode))
				{
					return false;
				}
				if (compiler.AllowBuiltInMode && value == "*")
				{
					mode = Compiler.BuiltInMode;
				}
				else
				{
					mode = compiler.CreateXPathQName(value);
				}
			}
			return true;
		}

		private void AnalyzePriority(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			if (double.IsNaN(priority) && matchKey != -1)
			{
				TheQuery theQuery = compiler.QueryStore[MatchKey];
				CompiledXpathExpr compiledQuery = theQuery.CompiledQuery;
				Query query;
				for (query = compiledQuery.QueryTree; query is UnionExpr unionExpr; query = unionExpr.qy1)
				{
					TemplateAction templateAction = CloneWithoutName();
					compiler.QueryStore.Add(new TheQuery(new CompiledXpathExpr(unionExpr.qy2, compiledQuery.Expression, needContext: false), theQuery._ScopeManager));
					templateAction.matchKey = compiler.QueryStore.Count - 1;
					templateAction.priority = unionExpr.qy2.XsltDefaultPriority;
					compiler.AddTemplate(templateAction);
				}
				if (compiledQuery.QueryTree != query)
				{
					compiler.QueryStore[MatchKey] = new TheQuery(new CompiledXpathExpr(query, compiledQuery.Expression, needContext: false), theQuery._ScopeManager);
				}
				priority = query.XsltDefaultPriority;
			}
		}

		protected void CompileParameters(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Element:
					if (Ref.Equal(input.NamespaceURI, input.Atoms.UriXsl) && Ref.Equal(input.LocalName, input.Atoms.Param))
					{
						compiler.PushNamespaceScope();
						AddAction(compiler.CreateVariableAction(VariableType.LocalParameter));
						compiler.PopScope();
						break;
					}
					return;
				case XPathNodeType.Text:
					return;
				case XPathNodeType.SignificantWhitespace:
					AddEvent(compiler.CreateTextEvent());
					break;
				}
			}
			while (input.Advance());
		}

		private TemplateAction CloneWithoutName()
		{
			TemplateAction templateAction = new TemplateAction();
			templateAction.containedActions = containedActions;
			templateAction.mode = mode;
			templateAction.variableCount = variableCount;
			templateAction.replaceNSAliasesDone = true;
			return templateAction;
		}

		internal override void ReplaceNamespaceAlias(Compiler compiler)
		{
			if (!replaceNSAliasesDone)
			{
				base.ReplaceNamespaceAlias(compiler);
				replaceNSAliasesDone = true;
			}
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (variableCount > 0)
				{
					frame.AllocateVariables(variableCount);
				}
				if (containedActions != null && containedActions.Count > 0)
				{
					processor.PushActionFrame(frame);
					frame.State = 1;
				}
				else
				{
					frame.Finished();
				}
				break;
			case 1:
				frame.Finished();
				break;
			}
		}
	}
	internal abstract class TemplateBaseAction : ContainerAction
	{
		protected int variableCount;

		private int variableFreeSlot;

		public int AllocateVariableSlot()
		{
			int result = variableFreeSlot;
			variableFreeSlot++;
			if (variableCount < variableFreeSlot)
			{
				variableCount = variableFreeSlot;
			}
			return result;
		}

		public void ReleaseVariableSlots(int n)
		{
		}
	}
	internal class TemplateLookupAction : Action
	{
		protected XmlQualifiedName mode;

		protected Stylesheet importsOf;

		internal void Initialize(XmlQualifiedName mode, Stylesheet importsOf)
		{
			this.mode = mode;
			this.importsOf = importsOf;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			Action action = null;
			action = ((!(mode != null)) ? ((importsOf == null) ? processor.Stylesheet.FindTemplate(processor, frame.Node) : importsOf.FindTemplateImports(processor, frame.Node)) : ((importsOf == null) ? processor.Stylesheet.FindTemplate(processor, frame.Node, mode) : importsOf.FindTemplateImports(processor, frame.Node, mode)));
			if (action == null)
			{
				action = BuiltInTemplate(frame.Node);
			}
			if (action != null)
			{
				frame.SetAction(action);
			}
			else
			{
				frame.Finished();
			}
		}

		internal Action BuiltInTemplate(XPathNavigator node)
		{
			Action result = null;
			switch (node.NodeType)
			{
			case XPathNodeType.Root:
			case XPathNodeType.Element:
				result = ApplyTemplatesAction.BuiltInRule(mode);
				break;
			case XPathNodeType.Attribute:
			case XPathNodeType.Text:
			case XPathNodeType.SignificantWhitespace:
			case XPathNodeType.Whitespace:
				result = ValueOfAction.BuiltInRule();
				break;
			}
			return result;
		}
	}
	internal class TemplateLookupActionDbg : TemplateLookupAction
	{
		internal override void Execute(Processor processor, ActionFrame frame)
		{
			Action action = null;
			if (mode == Compiler.BuiltInMode)
			{
				mode = processor.GetPrevioseMode();
			}
			processor.SetCurrentMode(mode);
			action = ((!(mode != null)) ? ((importsOf == null) ? processor.Stylesheet.FindTemplate(processor, frame.Node) : importsOf.FindTemplateImports(processor, frame.Node)) : ((importsOf == null) ? processor.Stylesheet.FindTemplate(processor, frame.Node, mode) : importsOf.FindTemplateImports(processor, frame.Node, mode)));
			if (action == null && processor.RootAction.builtInSheet != null)
			{
				action = processor.RootAction.builtInSheet.FindTemplate(processor, frame.Node, Compiler.BuiltInMode);
			}
			if (action == null)
			{
				action = BuiltInTemplate(frame.Node);
			}
			if (action != null)
			{
				frame.SetAction(action);
			}
			else
			{
				frame.Finished();
			}
		}
	}
	internal class TemplateManager
	{
		private class TemplateComparer : IComparer
		{
			public int Compare(object x, object y)
			{
				TemplateAction templateAction = (TemplateAction)x;
				TemplateAction templateAction2 = (TemplateAction)y;
				if (templateAction.Priority == templateAction2.Priority)
				{
					return templateAction.TemplateId - templateAction2.TemplateId;
				}
				if (!(templateAction.Priority > templateAction2.Priority))
				{
					return -1;
				}
				return 1;
			}
		}

		private XmlQualifiedName mode;

		internal ArrayList templates;

		private Stylesheet stylesheet;

		private static TemplateComparer s_TemplateComparer = new TemplateComparer();

		internal XmlQualifiedName Mode => mode;

		internal TemplateManager(Stylesheet stylesheet, XmlQualifiedName mode)
		{
			this.mode = mode;
			this.stylesheet = stylesheet;
		}

		internal void AddTemplate(TemplateAction template)
		{
			if (templates == null)
			{
				templates = new ArrayList();
			}
			templates.Add(template);
		}

		internal void ProcessTemplates()
		{
			if (templates != null)
			{
				templates.Sort(s_TemplateComparer);
			}
		}

		internal TemplateAction FindTemplate(Processor processor, XPathNavigator navigator)
		{
			if (templates == null)
			{
				return null;
			}
			for (int num = templates.Count - 1; num >= 0; num--)
			{
				TemplateAction templateAction = (TemplateAction)templates[num];
				int matchKey = templateAction.MatchKey;
				if (matchKey != -1 && processor.Matches(navigator, matchKey))
				{
					return templateAction;
				}
			}
			return null;
		}
	}
	internal class TextAction : CompiledAction
	{
		private bool disableOutputEscaping;

		private string text;

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CompileContent(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.DisableOutputEscaping))
			{
				disableOutputEscaping = compiler.GetYesNo(value);
				return true;
			}
			return false;
		}

		private void CompileContent(Compiler compiler)
		{
			if (!compiler.Recurse())
			{
				return;
			}
			NavigatorInput input = compiler.Input;
			text = string.Empty;
			do
			{
				switch (input.NodeType)
				{
				case XPathNodeType.Text:
				case XPathNodeType.SignificantWhitespace:
				case XPathNodeType.Whitespace:
					text += input.Value;
					break;
				default:
					throw compiler.UnexpectedKeyword();
				case XPathNodeType.ProcessingInstruction:
				case XPathNodeType.Comment:
					break;
				}
			}
			while (compiler.Advance());
			compiler.ToParent();
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			if (frame.State == 0 && processor.TextEvent(text, disableOutputEscaping))
			{
				frame.Finished();
			}
		}
	}
	internal class TextEvent : Event
	{
		private string text;

		protected TextEvent()
		{
		}

		public TextEvent(string text)
		{
			this.text = text;
		}

		public TextEvent(Compiler compiler)
		{
			NavigatorInput input = compiler.Input;
			text = input.Value;
		}

		public override bool Output(Processor processor, ActionFrame frame)
		{
			return processor.TextEvent(text);
		}

		public virtual string Evaluate(Processor processor, ActionFrame frame)
		{
			return text;
		}
	}
	internal class TextOnlyOutput : RecordOutput
	{
		private Processor processor;

		private TextWriter writer;

		internal XsltOutput Output => processor.Output;

		public TextWriter Writer => writer;

		internal TextOnlyOutput(Processor processor, Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
			this.processor = processor;
			writer = new StreamWriter(stream, Output.Encoding);
		}

		internal TextOnlyOutput(Processor processor, TextWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			this.processor = processor;
			this.writer = writer;
		}

		public Processor.OutputResult RecordDone(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			XmlNodeType nodeType = mainNode.NodeType;
			if (nodeType == XmlNodeType.Text || (uint)(nodeType - 13) <= 1u)
			{
				writer.Write(mainNode.Value);
			}
			record.Reset();
			return Processor.OutputResult.Continue;
		}

		public void TheEnd()
		{
			writer.Flush();
		}
	}
	internal class TextOutput : SequentialOutput
	{
		private TextWriter writer;

		internal TextOutput(Processor processor, Stream stream)
			: base(processor)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
			encoding = processor.Output.Encoding;
			writer = new StreamWriter(stream, encoding);
		}

		internal TextOutput(Processor processor, TextWriter writer)
			: base(processor)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			encoding = writer.Encoding;
			this.writer = writer;
		}

		internal override void Write(char outputChar)
		{
			writer.Write(outputChar);
		}

		internal override void Write(string outputText)
		{
			writer.Write(outputText);
		}

		internal override void Close()
		{
			writer.Flush();
			writer = null;
		}
	}
	internal sealed class TheQuery
	{
		internal InputScopeManager _ScopeManager;

		private CompiledXpathExpr _CompiledQuery;

		internal CompiledXpathExpr CompiledQuery => _CompiledQuery;

		internal TheQuery(CompiledXpathExpr compiledQuery, InputScopeManager manager)
		{
			_CompiledQuery = compiledQuery;
			_ScopeManager = manager.Clone();
		}
	}
	internal class UseAttributeSetsAction : CompiledAction
	{
		private XmlQualifiedName[] useAttributeSets;

		private string useString;

		private const int ProcessingSets = 2;

		internal XmlQualifiedName[] UsedSets => useAttributeSets;

		internal override void Compile(Compiler compiler)
		{
			useString = compiler.Input.Value;
			if (useString.Length == 0)
			{
				useAttributeSets = new XmlQualifiedName[0];
				return;
			}
			string[] array = XmlConvert.SplitString(useString);
			try
			{
				useAttributeSets = new XmlQualifiedName[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					useAttributeSets[i] = compiler.CreateXPathQName(array[i]);
				}
			}
			catch (XsltException)
			{
				if (!compiler.ForwardCompatibility)
				{
					throw;
				}
				useAttributeSets = new XmlQualifiedName[0];
			}
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			default:
				return;
			case 0:
				frame.Counter = 0;
				frame.State = 2;
				break;
			case 2:
				break;
			}
			if (frame.Counter < useAttributeSets.Length)
			{
				AttributeSetAction attributeSet = processor.RootAction.GetAttributeSet(useAttributeSets[frame.Counter]);
				frame.IncrementCounter();
				processor.PushActionFrame(attributeSet, frame.NodeSet);
			}
			else
			{
				frame.Finished();
			}
		}
	}
	internal class ValueOfAction : CompiledAction
	{
		private const int ResultStored = 2;

		private int selectKey = -1;

		private bool disableOutputEscaping;

		private static Action s_BuiltInRule = new BuiltInRuleTextAction();

		internal static Action BuiltInRule()
		{
			return s_BuiltInRule;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, selectKey != -1, "select");
			CheckEmpty(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Select))
			{
				selectKey = compiler.AddQuery(value);
			}
			else
			{
				if (!Ref.Equal(localName, compiler.Atoms.DisableOutputEscaping))
				{
					return false;
				}
				disableOutputEscaping = compiler.GetYesNo(value);
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
			{
				string text = processor.ValueOf(frame, selectKey);
				if (processor.TextEvent(text, disableOutputEscaping))
				{
					frame.Finished();
					break;
				}
				frame.StoredOutput = text;
				frame.State = 2;
				break;
			}
			case 2:
				processor.TextEvent(frame.StoredOutput);
				frame.Finished();
				break;
			}
		}
	}
	internal class BuiltInRuleTextAction : Action
	{
		private const int ResultStored = 2;

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
			{
				string text = processor.ValueOf(frame.NodeSet.Current);
				if (processor.TextEvent(text, disableOutputEscaping: false))
				{
					frame.Finished();
					break;
				}
				frame.StoredOutput = text;
				frame.State = 2;
				break;
			}
			case 2:
				processor.TextEvent(frame.StoredOutput);
				frame.Finished();
				break;
			}
		}
	}
	internal enum VariableType
	{
		GlobalVariable,
		GlobalParameter,
		LocalVariable,
		LocalParameter,
		WithParameter
	}
	internal class VariableAction : ContainerAction, IXsltContextVariable
	{
		public static object BeingComputedMark = new object();

		private const int ValueCalculated = 2;

		protected XmlQualifiedName name;

		protected string nameStr;

		protected string baseUri;

		protected int selectKey = -1;

		protected int stylesheetid;

		protected VariableType varType;

		private int varKey;

		internal int Stylesheetid => stylesheetid;

		internal XmlQualifiedName Name => name;

		internal string NameStr => nameStr;

		internal VariableType VarType => varType;

		internal int VarKey => varKey;

		internal bool IsGlobal
		{
			get
			{
				if (varType != 0)
				{
					return varType == VariableType.GlobalParameter;
				}
				return true;
			}
		}

		XPathResultType IXsltContextVariable.VariableType => XPathResultType.Any;

		bool IXsltContextVariable.IsLocal
		{
			get
			{
				if (varType != VariableType.LocalVariable)
				{
					return varType == VariableType.LocalParameter;
				}
				return true;
			}
		}

		bool IXsltContextVariable.IsParam
		{
			get
			{
				if (varType != VariableType.LocalParameter)
				{
					return varType == VariableType.GlobalParameter;
				}
				return true;
			}
		}

		internal VariableAction(VariableType type)
		{
			varType = type;
		}

		internal override void Compile(Compiler compiler)
		{
			stylesheetid = compiler.Stylesheetid;
			baseUri = compiler.Input.BaseURI;
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, name, "name");
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
				if (selectKey != -1 && containedActions != null)
				{
					throw XsltException.Create("Xslt_VariableCntSel2", nameStr);
				}
			}
			if (containedActions != null)
			{
				baseUri = baseUri + "#" + compiler.GetUnicRtfId();
			}
			else
			{
				baseUri = null;
			}
			varKey = compiler.InsertVariable(this);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Name))
			{
				nameStr = value;
				name = compiler.CreateXPathQName(nameStr);
			}
			else
			{
				if (!Ref.Equal(localName, compiler.Atoms.Select))
				{
					return false;
				}
				selectKey = compiler.AddQuery(value);
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			object obj = null;
			switch (frame.State)
			{
			default:
				return;
			case 0:
			{
				if (IsGlobal)
				{
					if (frame.GetVariable(varKey) != null)
					{
						frame.Finished();
						return;
					}
					frame.SetVariable(varKey, BeingComputedMark);
				}
				if (varType == VariableType.GlobalParameter)
				{
					obj = processor.GetGlobalParameter(name);
				}
				else if (varType == VariableType.LocalParameter)
				{
					obj = processor.GetParameter(name);
				}
				if (obj != null)
				{
					break;
				}
				if (selectKey != -1)
				{
					obj = processor.RunQuery(frame, selectKey);
					break;
				}
				if (containedActions == null)
				{
					obj = string.Empty;
					break;
				}
				NavigatorOutput output = new NavigatorOutput(baseUri);
				processor.PushOutput(output);
				processor.PushActionFrame(frame);
				frame.State = 1;
				return;
			}
			case 1:
			{
				RecordOutput recordOutput = processor.PopOutput();
				obj = ((NavigatorOutput)recordOutput).Navigator;
				break;
			}
			case 2:
				break;
			}
			frame.SetVariable(varKey, obj);
			frame.Finished();
		}

		object IXsltContextVariable.Evaluate(XsltContext xsltContext)
		{
			return ((XsltCompileContext)xsltContext).EvaluateVariable(this);
		}
	}
	internal class WithParamAction : VariableAction
	{
		internal WithParamAction()
			: base(VariableType.WithParameter)
		{
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckRequiredAttribute(compiler, name, "name");
			if (compiler.Recurse())
			{
				CompileTemplate(compiler);
				compiler.ToParent();
				if (selectKey != -1 && containedActions != null)
				{
					throw XsltException.Create("Xslt_VariableCntSel2", nameStr);
				}
			}
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
			switch (frame.State)
			{
			case 0:
				if (selectKey != -1)
				{
					object value = processor.RunQuery(frame, selectKey);
					processor.SetParameter(name, value);
					frame.Finished();
				}
				else if (containedActions == null)
				{
					processor.SetParameter(name, string.Empty);
					frame.Finished();
				}
				else
				{
					NavigatorOutput output = new NavigatorOutput(baseUri);
					processor.PushOutput(output);
					processor.PushActionFrame(frame);
					frame.State = 1;
				}
				break;
			case 1:
			{
				RecordOutput recordOutput = processor.PopOutput();
				processor.SetParameter(name, ((NavigatorOutput)recordOutput).Navigator);
				frame.Finished();
				break;
			}
			}
		}
	}
	internal class WriterOutput : RecordOutput
	{
		private XmlWriter writer;

		private Processor processor;

		internal WriterOutput(Processor processor, XmlWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			this.writer = writer;
			this.processor = processor;
		}

		public Processor.OutputResult RecordDone(RecordBuilder record)
		{
			BuilderInfo mainNode = record.MainNode;
			switch (mainNode.NodeType)
			{
			case XmlNodeType.Element:
				writer.WriteStartElement(mainNode.Prefix, mainNode.LocalName, mainNode.NamespaceURI);
				WriteAttributes(record.AttributeList, record.AttributeCount);
				if (mainNode.IsEmptyTag)
				{
					writer.WriteEndElement();
				}
				break;
			case XmlNodeType.Text:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				writer.WriteString(mainNode.Value);
				break;
			case XmlNodeType.CDATA:
				writer.WriteCData(mainNode.Value);
				break;
			case XmlNodeType.EntityReference:
				writer.WriteEntityRef(mainNode.LocalName);
				break;
			case XmlNodeType.ProcessingInstruction:
				writer.WriteProcessingInstruction(mainNode.LocalName, mainNode.Value);
				break;
			case XmlNodeType.Comment:
				writer.WriteComment(mainNode.Value);
				break;
			case XmlNodeType.DocumentType:
				writer.WriteRaw(mainNode.Value);
				break;
			case XmlNodeType.EndElement:
				writer.WriteFullEndElement();
				break;
			}
			record.Reset();
			return Processor.OutputResult.Continue;
		}

		public void TheEnd()
		{
			writer.Flush();
			writer = null;
		}

		private void WriteAttributes(ArrayList list, int count)
		{
			for (int i = 0; i < count; i++)
			{
				BuilderInfo builderInfo = (BuilderInfo)list[i];
				writer.WriteAttributeString(builderInfo.Prefix, builderInfo.LocalName, builderInfo.NamespaceURI, builderInfo.Value);
			}
		}
	}
	internal class XsltCompileContext : XsltContext
	{
		private abstract class XsltFunctionImpl : IXsltContextFunction
		{
			private int minargs;

			private int maxargs;

			private XPathResultType returnType;

			private XPathResultType[] argTypes;

			public int Minargs => minargs;

			public int Maxargs => maxargs;

			public XPathResultType ReturnType => returnType;

			public XPathResultType[] ArgTypes => argTypes;

			public XsltFunctionImpl()
			{
			}

			public XsltFunctionImpl(int minArgs, int maxArgs, XPathResultType returnType, XPathResultType[] argTypes)
			{
				Init(minArgs, maxArgs, returnType, argTypes);
			}

			protected void Init(int minArgs, int maxArgs, XPathResultType returnType, XPathResultType[] argTypes)
			{
				minargs = minArgs;
				maxargs = maxArgs;
				this.returnType = returnType;
				this.argTypes = argTypes;
			}

			public abstract object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext);

			public static XPathNodeIterator ToIterator(object argument)
			{
				if (!(argument is XPathNodeIterator result))
				{
					throw XsltException.Create("Xslt_NoNodeSetConversion");
				}
				return result;
			}

			public static XPathNavigator ToNavigator(object argument)
			{
				if (!(argument is XPathNavigator result))
				{
					throw XsltException.Create("Xslt_NoNavigatorConversion");
				}
				return result;
			}

			private static string IteratorToString(XPathNodeIterator it)
			{
				if (it.MoveNext())
				{
					return it.Current.Value;
				}
				return string.Empty;
			}

			public static string ToString(object argument)
			{
				if (argument is XPathNodeIterator it)
				{
					return IteratorToString(it);
				}
				return XmlConvert.ToXPathString(argument);
			}

			public static bool ToBoolean(object argument)
			{
				if (argument is XPathNodeIterator it)
				{
					return Convert.ToBoolean(IteratorToString(it), CultureInfo.InvariantCulture);
				}
				if (argument is XPathNavigator xPathNavigator)
				{
					return Convert.ToBoolean(xPathNavigator.ToString(), CultureInfo.InvariantCulture);
				}
				return Convert.ToBoolean(argument, CultureInfo.InvariantCulture);
			}

			public static double ToNumber(object argument)
			{
				if (argument is XPathNodeIterator it)
				{
					return XmlConvert.ToXPathDouble(IteratorToString(it));
				}
				if (argument is XPathNavigator xPathNavigator)
				{
					return XmlConvert.ToXPathDouble(xPathNavigator.ToString());
				}
				return XmlConvert.ToXPathDouble(argument);
			}

			private static object ToNumeric(object argument, TypeCode typeCode)
			{
				return Convert.ChangeType(ToNumber(argument), typeCode, CultureInfo.InvariantCulture);
			}

			public static object ConvertToXPathType(object val, XPathResultType xt, TypeCode typeCode)
			{
				switch (xt)
				{
				case XPathResultType.String:
					if (typeCode == TypeCode.String)
					{
						return ToString(val);
					}
					return ToNavigator(val);
				case XPathResultType.Number:
					return ToNumeric(val, typeCode);
				case XPathResultType.Boolean:
					return ToBoolean(val);
				case XPathResultType.NodeSet:
					return ToIterator(val);
				case XPathResultType.Any:
				case XPathResultType.Error:
					return val;
				default:
					return val;
				}
			}
		}

		private class FuncCurrent : XsltFunctionImpl
		{
			public FuncCurrent()
				: base(0, 0, XPathResultType.NodeSet, new XPathResultType[0])
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				return ((XsltCompileContext)xsltContext).Current();
			}
		}

		private class FuncUnEntityUri : XsltFunctionImpl
		{
			public FuncUnEntityUri()
				: base(1, 1, XPathResultType.String, new XPathResultType[1] { XPathResultType.String })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				throw XsltException.Create("Xslt_UnsuppFunction", "unparsed-entity-uri");
			}
		}

		private class FuncGenerateId : XsltFunctionImpl
		{
			public FuncGenerateId()
				: base(0, 1, XPathResultType.String, new XPathResultType[1] { XPathResultType.NodeSet })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				if (args.Length != 0)
				{
					XPathNodeIterator xPathNodeIterator = XsltFunctionImpl.ToIterator(args[0]);
					if (xPathNodeIterator.MoveNext())
					{
						return xPathNodeIterator.Current.UniqueId;
					}
					return string.Empty;
				}
				return docContext.UniqueId;
			}
		}

		private class FuncSystemProp : XsltFunctionImpl
		{
			public FuncSystemProp()
				: base(1, 1, XPathResultType.String, new XPathResultType[1] { XPathResultType.String })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				return ((XsltCompileContext)xsltContext).SystemProperty(XsltFunctionImpl.ToString(args[0]));
			}
		}

		private class FuncElementAvailable : XsltFunctionImpl
		{
			public FuncElementAvailable()
				: base(1, 1, XPathResultType.Boolean, new XPathResultType[1] { XPathResultType.String })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				return ((XsltCompileContext)xsltContext).ElementAvailable(XsltFunctionImpl.ToString(args[0]));
			}
		}

		private class FuncFunctionAvailable : XsltFunctionImpl
		{
			public FuncFunctionAvailable()
				: base(1, 1, XPathResultType.Boolean, new XPathResultType[1] { XPathResultType.String })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				return ((XsltCompileContext)xsltContext).FunctionAvailable(XsltFunctionImpl.ToString(args[0]));
			}
		}

		private class FuncDocument : XsltFunctionImpl
		{
			public FuncDocument()
				: base(1, 2, XPathResultType.NodeSet, new XPathResultType[2]
				{
					XPathResultType.Any,
					XPathResultType.NodeSet
				})
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				string baseUri = null;
				if (args.Length == 2)
				{
					XPathNodeIterator xPathNodeIterator = XsltFunctionImpl.ToIterator(args[1]);
					baseUri = ((!xPathNodeIterator.MoveNext()) ? string.Empty : xPathNodeIterator.Current.BaseURI);
				}
				try
				{
					return ((XsltCompileContext)xsltContext).Document(args[0], baseUri);
				}
				catch (Exception e)
				{
					if (!XmlException.IsCatchableException(e))
					{
						throw;
					}
					return XPathEmptyIterator.Instance;
				}
			}
		}

		private class FuncKey : XsltFunctionImpl
		{
			public FuncKey()
				: base(2, 2, XPathResultType.NodeSet, new XPathResultType[2]
				{
					XPathResultType.String,
					XPathResultType.Any
				})
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				XsltCompileContext xsltCompileContext = (XsltCompileContext)xsltContext;
				PrefixQName.ParseQualifiedName(XsltFunctionImpl.ToString(args[0]), out var prefix, out var local);
				string ns = xsltContext.LookupNamespace(prefix);
				XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(local, ns);
				XPathNavigator xPathNavigator = docContext.Clone();
				xPathNavigator.MoveToRoot();
				ArrayList arrayList = null;
				Key[] keyList = xsltCompileContext.processor.KeyList;
				foreach (Key key in keyList)
				{
					if (!(key.Name == xmlQualifiedName))
					{
						continue;
					}
					Hashtable hashtable = key.GetKeys(xPathNavigator);
					if (hashtable == null)
					{
						hashtable = xsltCompileContext.BuildKeyTable(key, xPathNavigator);
						key.AddKey(xPathNavigator, hashtable);
					}
					if (args[1] is XPathNodeIterator xPathNodeIterator)
					{
						XPathNodeIterator xPathNodeIterator2 = xPathNodeIterator.Clone();
						while (xPathNodeIterator2.MoveNext())
						{
							arrayList = AddToList(arrayList, (ArrayList)hashtable[xPathNodeIterator2.Current.Value]);
						}
					}
					else
					{
						arrayList = AddToList(arrayList, (ArrayList)hashtable[XsltFunctionImpl.ToString(args[1])]);
					}
				}
				if (arrayList == null)
				{
					return XPathEmptyIterator.Instance;
				}
				if (arrayList[0] is XPathNavigator)
				{
					return new XPathArrayIterator(arrayList);
				}
				return new XPathMultyIterator(arrayList);
			}

			private static ArrayList AddToList(ArrayList resultCollection, ArrayList newList)
			{
				if (newList == null)
				{
					return resultCollection;
				}
				if (resultCollection == null)
				{
					return newList;
				}
				if (!(resultCollection[0] is ArrayList))
				{
					ArrayList value = resultCollection;
					resultCollection = new ArrayList();
					resultCollection.Add(value);
				}
				resultCollection.Add(newList);
				return resultCollection;
			}
		}

		private class FuncFormatNumber : XsltFunctionImpl
		{
			public FuncFormatNumber()
				: base(2, 3, XPathResultType.String, new XPathResultType[3]
				{
					XPathResultType.Number,
					XPathResultType.String,
					XPathResultType.String
				})
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				DecimalFormat decimalFormat = ((XsltCompileContext)xsltContext).ResolveFormatName((args.Length == 3) ? XsltFunctionImpl.ToString(args[2]) : null);
				return DecimalFormatter.Format(XsltFunctionImpl.ToNumber(args[0]), XsltFunctionImpl.ToString(args[1]), decimalFormat);
			}
		}

		private class FuncNodeSet : XsltFunctionImpl
		{
			public FuncNodeSet()
				: base(1, 1, XPathResultType.NodeSet, new XPathResultType[1] { XPathResultType.String })
			{
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				return new XPathSingletonIterator(XsltFunctionImpl.ToNavigator(args[0]));
			}
		}

		private class FuncExtension : XsltFunctionImpl
		{
			private object extension;

			private MethodInfo method;

			private TypeCode[] typeCodes;

			private PermissionSet permissions;

			public FuncExtension(object extension, MethodInfo method, PermissionSet permissions)
			{
				this.extension = extension;
				this.method = method;
				this.permissions = permissions;
				XPathResultType xPathType = GetXPathType(method.ReturnType);
				ParameterInfo[] parameters = method.GetParameters();
				int num = parameters.Length;
				int maxArgs = parameters.Length;
				typeCodes = new TypeCode[parameters.Length];
				XPathResultType[] array = new XPathResultType[parameters.Length];
				bool flag = true;
				int num2 = parameters.Length - 1;
				while (0 <= num2)
				{
					typeCodes[num2] = Type.GetTypeCode(parameters[num2].ParameterType);
					array[num2] = GetXPathType(parameters[num2].ParameterType);
					if (flag)
					{
						if (parameters[num2].IsOptional)
						{
							num--;
						}
						else
						{
							flag = false;
						}
					}
					num2--;
				}
				Init(num, maxArgs, xPathType, array);
			}

			public override object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
			{
				int num = args.Length - 1;
				while (0 <= num)
				{
					args[num] = XsltFunctionImpl.ConvertToXPathType(args[num], base.ArgTypes[num], typeCodes[num]);
					num--;
				}
				if (permissions != null)
				{
					permissions.PermitOnly();
				}
				return method.Invoke(extension, args);
			}
		}

		private InputScopeManager manager;

		private Processor processor;

		private static Hashtable s_FunctionTable = CreateFunctionTable();

		private static IXsltContextFunction s_FuncNodeSet = new FuncNodeSet();

		private const string f_NodeSet = "node-set";

		private const BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;

		public override string DefaultNamespace => string.Empty;

		public override bool Whitespace => processor.Stylesheet.Whitespace;

		internal XsltCompileContext(InputScopeManager manager, Processor processor)
			: base(dummy: false)
		{
			this.manager = manager;
			this.processor = processor;
		}

		internal XsltCompileContext()
			: base(dummy: false)
		{
		}

		internal void Recycle()
		{
			manager = null;
			processor = null;
		}

		internal void Reinitialize(InputScopeManager manager, Processor processor)
		{
			this.manager = manager;
			this.processor = processor;
		}

		public override int CompareDocument(string baseUri, string nextbaseUri)
		{
			return string.Compare(baseUri, nextbaseUri, StringComparison.Ordinal);
		}

		public override string LookupNamespace(string prefix)
		{
			return manager.ResolveXPathNamespace(prefix);
		}

		public override IXsltContextVariable ResolveVariable(string prefix, string name)
		{
			string ns = LookupNamespace(prefix);
			XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(name, ns);
			IXsltContextVariable xsltContextVariable = manager.VariableScope.ResolveVariable(xmlQualifiedName);
			if (xsltContextVariable == null)
			{
				throw XsltException.Create("Xslt_InvalidVariable", xmlQualifiedName.ToString());
			}
			return xsltContextVariable;
		}

		internal object EvaluateVariable(VariableAction variable)
		{
			object variableValue = processor.GetVariableValue(variable);
			if (variableValue == null && !variable.IsGlobal)
			{
				VariableAction variableAction = manager.VariableScope.ResolveGlobalVariable(variable.Name);
				if (variableAction != null)
				{
					variableValue = processor.GetVariableValue(variableAction);
				}
			}
			if (variableValue == null)
			{
				throw XsltException.Create("Xslt_InvalidVariable", variable.Name.ToString());
			}
			return variableValue;
		}

		public override bool PreserveWhitespace(XPathNavigator node)
		{
			node = node.Clone();
			node.MoveToParent();
			return processor.Stylesheet.PreserveWhiteSpace(processor, node);
		}

		private MethodInfo FindBestMethod(MethodInfo[] methods, bool ignoreCase, bool publicOnly, string name, XPathResultType[] argTypes)
		{
			int num = methods.Length;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (string.Compare(name, methods[i].Name, ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal) == 0 && (!publicOnly || methods[i].GetBaseDefinition().IsPublic))
				{
					methods[num2++] = methods[i];
				}
			}
			num = num2;
			if (num == 0)
			{
				return null;
			}
			if (argTypes == null)
			{
				return methods[0];
			}
			num2 = 0;
			for (int j = 0; j < num; j++)
			{
				if (methods[j].GetParameters().Length == argTypes.Length)
				{
					methods[num2++] = methods[j];
				}
			}
			num = num2;
			if (num <= 1)
			{
				return methods[0];
			}
			num2 = 0;
			for (int k = 0; k < num; k++)
			{
				bool flag = true;
				ParameterInfo[] parameters = methods[k].GetParameters();
				for (int l = 0; l < parameters.Length; l++)
				{
					XPathResultType xPathResultType = argTypes[l];
					if (xPathResultType != XPathResultType.Any)
					{
						XPathResultType xPathType = GetXPathType(parameters[l].ParameterType);
						if (xPathType != xPathResultType && xPathType != XPathResultType.Any)
						{
							flag = false;
							break;
						}
					}
				}
				if (flag)
				{
					methods[num2++] = methods[k];
				}
			}
			num = num2;
			return methods[0];
		}

		private IXsltContextFunction GetExtentionMethod(string ns, string name, XPathResultType[] argTypes, out object extension)
		{
			FuncExtension result = null;
			extension = processor.GetScriptObject(ns);
			if (extension != null)
			{
				MethodInfo methodInfo = FindBestMethod(extension.GetType().GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic), ignoreCase: true, publicOnly: false, name, argTypes);
				if (methodInfo != null)
				{
					result = new FuncExtension(extension, methodInfo, null);
				}
				return result;
			}
			extension = processor.GetExtensionObject(ns);
			if (extension != null)
			{
				MethodInfo methodInfo2 = FindBestMethod(extension.GetType().GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic), ignoreCase: false, publicOnly: true, name, argTypes);
				if (methodInfo2 != null)
				{
					result = new FuncExtension(extension, methodInfo2, processor.permissions);
				}
				return result;
			}
			return null;
		}

		public override IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes)
		{
			IXsltContextFunction xsltContextFunction = null;
			if (prefix.Length == 0)
			{
				xsltContextFunction = s_FunctionTable[name] as IXsltContextFunction;
			}
			else
			{
				string text = LookupNamespace(prefix);
				if (text == "urn:schemas-microsoft-com:xslt" && name == "node-set")
				{
					xsltContextFunction = s_FuncNodeSet;
				}
				else
				{
					xsltContextFunction = GetExtentionMethod(text, name, argTypes, out var extension);
					if (extension == null)
					{
						throw XsltException.Create("Xslt_ScriptInvalidPrefix", prefix);
					}
				}
			}
			if (xsltContextFunction == null)
			{
				throw XsltException.Create("Xslt_UnknownXsltFunction", name);
			}
			if (argTypes.Length < xsltContextFunction.Minargs || xsltContextFunction.Maxargs < argTypes.Length)
			{
				throw XsltException.Create("Xslt_WrongNumberArgs", name, argTypes.Length.ToString(CultureInfo.InvariantCulture));
			}
			return xsltContextFunction;
		}

		private Uri ComposeUri(string thisUri, string baseUri)
		{
			XmlResolver resolver = processor.Resolver;
			Uri baseUri2 = null;
			if (baseUri.Length != 0)
			{
				baseUri2 = resolver.ResolveUri(null, baseUri);
			}
			return resolver.ResolveUri(baseUri2, thisUri);
		}

		private XPathNodeIterator Document(object arg0, string baseUri)
		{
			if (processor.permissions != null)
			{
				processor.permissions.PermitOnly();
			}
			if (arg0 is XPathNodeIterator xPathNodeIterator)
			{
				ArrayList arrayList = new ArrayList();
				Hashtable hashtable = new Hashtable();
				while (xPathNodeIterator.MoveNext())
				{
					Uri uri = ComposeUri(xPathNodeIterator.Current.Value, baseUri ?? xPathNodeIterator.Current.BaseURI);
					if (!hashtable.ContainsKey(uri))
					{
						hashtable.Add(uri, null);
						arrayList.Add(processor.GetNavigator(uri));
					}
				}
				return new XPathArrayIterator(arrayList);
			}
			return new XPathSingletonIterator(processor.GetNavigator(ComposeUri(XmlConvert.ToXPathString(arg0), baseUri ?? manager.Navigator.BaseURI)));
		}

		private Hashtable BuildKeyTable(Key key, XPathNavigator root)
		{
			Hashtable hashtable = new Hashtable();
			string queryExpression = processor.GetQueryExpression(key.MatchKey);
			Query compiledQuery = processor.GetCompiledQuery(key.MatchKey);
			Query compiledQuery2 = processor.GetCompiledQuery(key.UseKey);
			XPathNodeIterator xPathNodeIterator = root.SelectDescendants(XPathNodeType.All, matchSelf: false);
			while (xPathNodeIterator.MoveNext())
			{
				XPathNavigator current = xPathNodeIterator.Current;
				EvaluateKey(current, compiledQuery, queryExpression, compiledQuery2, hashtable);
				if (current.MoveToFirstAttribute())
				{
					do
					{
						EvaluateKey(current, compiledQuery, queryExpression, compiledQuery2, hashtable);
					}
					while (current.MoveToNextAttribute());
					current.MoveToParent();
				}
			}
			return hashtable;
		}

		private static void AddKeyValue(Hashtable keyTable, string key, XPathNavigator value, bool checkDuplicates)
		{
			ArrayList arrayList = (ArrayList)keyTable[key];
			if (arrayList == null)
			{
				arrayList = new ArrayList();
				keyTable.Add(key, arrayList);
			}
			else if (checkDuplicates && value.ComparePosition((XPathNavigator)arrayList[arrayList.Count - 1]) == XmlNodeOrder.Same)
			{
				return;
			}
			arrayList.Add(value.Clone());
		}

		private static void EvaluateKey(XPathNavigator node, Query matchExpr, string matchStr, Query useExpr, Hashtable keyTable)
		{
			try
			{
				if (matchExpr.MatchNode(node) == null)
				{
					return;
				}
			}
			catch (XPathException)
			{
				throw XsltException.Create("Xslt_InvalidPattern", matchStr);
			}
			object obj = useExpr.Evaluate(new XPathSingletonIterator(node, moved: true));
			if (obj is XPathNodeIterator xPathNodeIterator)
			{
				bool checkDuplicates = false;
				while (xPathNodeIterator.MoveNext())
				{
					AddKeyValue(keyTable, xPathNodeIterator.Current.Value, node, checkDuplicates);
					checkDuplicates = true;
				}
			}
			else
			{
				string key = XmlConvert.ToXPathString(obj);
				AddKeyValue(keyTable, key, node, checkDuplicates: false);
			}
		}

		private DecimalFormat ResolveFormatName(string formatName)
		{
			string ns = string.Empty;
			string local = string.Empty;
			if (formatName != null)
			{
				PrefixQName.ParseQualifiedName(formatName, out var prefix, out local);
				ns = LookupNamespace(prefix);
			}
			DecimalFormat decimalFormat = processor.RootAction.GetDecimalFormat(new XmlQualifiedName(local, ns));
			if (decimalFormat == null)
			{
				if (formatName != null)
				{
					throw XsltException.Create("Xslt_NoDecimalFormat", formatName);
				}
				decimalFormat = new DecimalFormat(new NumberFormatInfo(), '#', '0', ';');
			}
			return decimalFormat;
		}

		private bool ElementAvailable(string qname)
		{
			PrefixQName.ParseQualifiedName(qname, out var prefix, out var local);
			string text = manager.ResolveXmlNamespace(prefix);
			if (text == "http://www.w3.org/1999/XSL/Transform")
			{
				switch (local)
				{
				default:
					return local == "variable";
				case "apply-imports":
				case "apply-templates":
				case "attribute":
				case "call-template":
				case "choose":
				case "comment":
				case "copy":
				case "copy-of":
				case "element":
				case "fallback":
				case "for-each":
				case "if":
				case "message":
				case "number":
				case "processing-instruction":
				case "text":
				case "value-of":
					return true;
				}
			}
			return false;
		}

		private bool FunctionAvailable(string qname)
		{
			PrefixQName.ParseQualifiedName(qname, out var prefix, out var local);
			string text = LookupNamespace(prefix);
			if (text == "urn:schemas-microsoft-com:xslt")
			{
				return local == "node-set";
			}
			if (text.Length == 0)
			{
				switch (local)
				{
				default:
					if (s_FunctionTable[local] != null)
					{
						return local != "unparsed-entity-uri";
					}
					return false;
				case "last":
				case "position":
				case "name":
				case "namespace-uri":
				case "local-name":
				case "count":
				case "id":
				case "string":
				case "concat":
				case "starts-with":
				case "contains":
				case "substring-before":
				case "substring-after":
				case "substring":
				case "string-length":
				case "normalize-space":
				case "translate":
				case "boolean":
				case "not":
				case "true":
				case "false":
				case "lang":
				case "number":
				case "sum":
				case "floor":
				case "ceiling":
				case "round":
					return true;
				}
			}
			object extension;
			return GetExtentionMethod(text, local, null, out extension) != null;
		}

		private XPathNodeIterator Current()
		{
			XPathNavigator current = processor.Current;
			if (current != null)
			{
				return new XPathSingletonIterator(current.Clone());
			}
			return XPathEmptyIterator.Instance;
		}

		private string SystemProperty(string qname)
		{
			string result = string.Empty;
			PrefixQName.ParseQualifiedName(qname, out var prefix, out var local);
			string text = LookupNamespace(prefix);
			if (text == "http://www.w3.org/1999/XSL/Transform")
			{
				switch (local)
				{
				case "version":
					result = "1";
					break;
				case "vendor":
					result = "Microsoft";
					break;
				case "vendor-url":
					result = "http://www.microsoft.com";
					break;
				}
				return result;
			}
			if (text == null && prefix != null)
			{
				throw XsltException.Create("Xslt_InvalidPrefix", prefix);
			}
			return string.Empty;
		}

		public static XPathResultType GetXPathType(Type type)
		{
			switch (Type.GetTypeCode(type))
			{
			case TypeCode.String:
				return XPathResultType.String;
			case TypeCode.Boolean:
				return XPathResultType.Boolean;
			case TypeCode.Object:
				if (typeof(XPathNavigator).IsAssignableFrom(type) || typeof(IXPathNavigable).IsAssignableFrom(type))
				{
					return XPathResultType.String;
				}
				if (typeof(XPathNodeIterator).IsAssignableFrom(type))
				{
					return XPathResultType.NodeSet;
				}
				return XPathResultType.Any;
			case TypeCode.DateTime:
				return XPathResultType.Error;
			default:
				return XPathResultType.Number;
			}
		}

		private static Hashtable CreateFunctionTable()
		{
			Hashtable hashtable = new Hashtable(10);
			hashtable["current"] = new FuncCurrent();
			hashtable["unparsed-entity-uri"] = new FuncUnEntityUri();
			hashtable["generate-id"] = new FuncGenerateId();
			hashtable["system-property"] = new FuncSystemProp();
			hashtable["element-available"] = new FuncElementAvailable();
			hashtable["function-available"] = new FuncFunctionAvailable();
			hashtable["document"] = new FuncDocument();
			hashtable["key"] = new FuncKey();
			hashtable["format-number"] = new FuncFormatNumber();
			return hashtable;
		}
	}
	internal class XsltOutput : CompiledAction
	{
		internal enum OutputMethod
		{
			Xml,
			Html,
			Text,
			Other,
			Unknown
		}

		private OutputMethod method = OutputMethod.Unknown;

		private int methodSId = int.MaxValue;

		private Encoding encoding = Encoding.UTF8;

		private int encodingSId = int.MaxValue;

		private string version;

		private int versionSId = int.MaxValue;

		private bool omitXmlDecl;

		private int omitXmlDeclSId = int.MaxValue;

		private bool standalone;

		private int standaloneSId = int.MaxValue;

		private string doctypePublic;

		private int doctypePublicSId = int.MaxValue;

		private string doctypeSystem;

		private int doctypeSystemSId = int.MaxValue;

		private bool indent;

		private int indentSId = int.MaxValue;

		private string mediaType = "text/html";

		private int mediaTypeSId = int.MaxValue;

		private Hashtable cdataElements;

		internal OutputMethod Method => method;

		internal bool OmitXmlDeclaration => omitXmlDecl;

		internal bool HasStandalone => standaloneSId != int.MaxValue;

		internal bool Standalone => standalone;

		internal string DoctypePublic => doctypePublic;

		internal string DoctypeSystem => doctypeSystem;

		internal Hashtable CDataElements => cdataElements;

		internal bool Indent => indent;

		internal Encoding Encoding => encoding;

		internal string MediaType => mediaType;

		internal XsltOutput CreateDerivedOutput(OutputMethod method)
		{
			XsltOutput xsltOutput = (XsltOutput)MemberwiseClone();
			xsltOutput.method = method;
			if (method == OutputMethod.Html && indentSId == int.MaxValue)
			{
				xsltOutput.indent = true;
			}
			return xsltOutput;
		}

		internal override void Compile(Compiler compiler)
		{
			CompileAttributes(compiler);
			CheckEmpty(compiler);
		}

		internal override bool CompileAttribute(Compiler compiler)
		{
			string localName = compiler.Input.LocalName;
			string value = compiler.Input.Value;
			if (Ref.Equal(localName, compiler.Atoms.Method))
			{
				if (compiler.Stylesheetid <= methodSId)
				{
					method = ParseOutputMethod(value, compiler);
					methodSId = compiler.Stylesheetid;
					if (indentSId == int.MaxValue)
					{
						indent = method == OutputMethod.Html;
					}
				}
			}
			else if (Ref.Equal(localName, compiler.Atoms.Version))
			{
				if (compiler.Stylesheetid <= versionSId)
				{
					version = value;
					versionSId = compiler.Stylesheetid;
				}
			}
			else if (Ref.Equal(localName, compiler.Atoms.Encoding))
			{
				if (compiler.Stylesheetid <= encodingSId)
				{
					try
					{
						encoding = Encoding.GetEncoding(value);
						encodingSId = compiler.Stylesheetid;
					}
					catch (NotSupportedException)
					{
					}
					catch (ArgumentException)
					{
					}
				}
			}
			else if (Ref.Equal(localName, compiler.Atoms.OmitXmlDeclaration))
			{
				if (compiler.Stylesheetid <= omitXmlDeclSId)
				{
					omitXmlDecl = compiler.GetYesNo(value);
					omitXmlDeclSId = compiler.Stylesheetid;
				}
			}
			else if (Ref.Equal(localName, compiler.Atoms.Standalone))
			{
				if (compiler.Stylesheetid <= standaloneSId)
				{
					standalone = compiler.GetYesNo(value);
					standaloneSId = compiler.Stylesheetid;
				}
			}
			else if (Ref.Equal(localName, compiler.Atoms.DocTypePublic))
			{
				if (compiler.Stylesheetid <= doctypePublicSId)
				{
					doctypePublic = value;
					doctypePublicSId = compiler.Stylesheetid;
				}
			}
			else if (Ref.Equal(localName, compiler.Atoms.DocTypeSystem))
			{
				if (compiler.Stylesheetid <= doctypeSystemSId)
				{
					doctypeSystem = value;
					doctypeSystemSId = compiler.Stylesheetid;
				}
			}
			else if (Ref.Equal(localName, compiler.Atoms.Indent))
			{
				if (compiler.Stylesheetid <= indentSId)
				{
					indent = compiler.GetYesNo(value);
					indentSId = compiler.Stylesheetid;
				}
			}
			else if (Ref.Equal(localName, compiler.Atoms.MediaType))
			{
				if (compiler.Stylesheetid <= mediaTypeSId)
				{
					mediaType = value;
					mediaTypeSId = compiler.Stylesheetid;
				}
			}
			else
			{
				if (!Ref.Equal(localName, compiler.Atoms.CDataSectionElements))
				{
					return false;
				}
				string[] array = XmlConvert.SplitString(value);
				if (cdataElements == null)
				{
					cdataElements = new Hashtable(array.Length);
				}
				for (int i = 0; i < array.Length; i++)
				{
					XmlQualifiedName xmlQualifiedName = compiler.CreateXmlQName(array[i]);
					cdataElements[xmlQualifiedName] = xmlQualifiedName;
				}
			}
			return true;
		}

		internal override void Execute(Processor processor, ActionFrame frame)
		{
		}

		private static OutputMethod ParseOutputMethod(string value, Compiler compiler)
		{
			XmlQualifiedName xmlQualifiedName = compiler.CreateXPathQName(value);
			if (xmlQualifiedName.Namespace.Length != 0)
			{
				return OutputMethod.Other;
			}
			switch (xmlQualifiedName.Name)
			{
			case "xml":
				return OutputMethod.Xml;
			case "html":
				return OutputMethod.Html;
			case "text":
				return OutputMethod.Text;
			default:
				if (compiler.ForwardCompatibility)
				{
					return OutputMethod.Unknown;
				}
				throw XsltException.Create("Xslt_InvalidAttrValue", "method", value);
			}
		}
	}
}
namespace System.Xml.Xsl.XsltOld.Debugger
{
	internal interface IStackFrame
	{
		XPathNavigator Instruction { get; }

		XPathNodeIterator NodeSet { get; }

		int GetVariablesCount();

		XPathNavigator GetVariable(int varIndex);

		object GetVariableValue(int varIndex);
	}
	internal interface IXsltProcessor
	{
		int StackDepth { get; }

		IStackFrame GetStackFrame(int depth);
	}
	internal interface IXsltDebugger
	{
		string GetBuiltInTemplatesUri();

		void OnInstructionCompile(XPathNavigator styleSheetNavigator);

		void OnInstructionExecute(IXsltProcessor xsltProcessor);
	}
}
namespace System.Xml.Xsl.Xslt
{
	internal enum XslVersion
	{
		Version10 = 0,
		ForwardsCompatible = 1,
		Current = 0
	}
	internal class RootLevel : StylesheetLevel
	{
		public RootLevel(Stylesheet principal)
		{
			Imports = new Stylesheet[1] { principal };
		}
	}
	internal class Compiler
	{
		private class CompilerErrorComparer : IComparer<CompilerError>
		{
			private Dictionary<string, int> moduleOrder;

			public CompilerErrorComparer(Dictionary<string, int> moduleOrder)
			{
				this.moduleOrder = moduleOrder;
			}

			public int Compare(CompilerError x, CompilerError y)
			{
				if (x == y)
				{
					return 0;
				}
				if (x == null)
				{
					return -1;
				}
				if (y == null)
				{
					return 1;
				}
				int num = moduleOrder[x.FileName].CompareTo(moduleOrder[y.FileName]);
				if (num != 0)
				{
					return num;
				}
				num = x.Line.CompareTo(y.Line);
				if (num != 0)
				{
					return num;
				}
				num = x.Column.CompareTo(y.Column);
				if (num != 0)
				{
					return num;
				}
				num = x.IsWarning.CompareTo(y.IsWarning);
				if (num != 0)
				{
					return num;
				}
				num = string.CompareOrdinal(x.ErrorNumber, y.ErrorNumber);
				if (num != 0)
				{
					return num;
				}
				return string.CompareOrdinal(x.ErrorText, y.ErrorText);
			}
		}

		public XsltSettings Settings;

		public bool IsDebug;

		public string ScriptAssemblyPath;

		public int Version;

		public string inputTypeAnnotations;

		public CompilerResults CompilerResults;

		public int CurrentPrecedence;

		public XslNode StartApplyTemplates;

		public RootLevel Root;

		public Scripts Scripts;

		public Output Output = new Output();

		public List<VarPar> ExternalPars = new List<VarPar>();

		public List<VarPar> GlobalVars = new List<VarPar>();

		public List<WhitespaceRule> WhitespaceRules = new List<WhitespaceRule>();

		public DecimalFormats DecimalFormats = new DecimalFormats();

		public Keys Keys = new Keys();

		public List<ProtoTemplate> AllTemplates = new List<ProtoTemplate>();

		public Dictionary<QilName, VarPar> AllGlobalVarPars = new Dictionary<QilName, VarPar>();

		public Dictionary<QilName, Template> NamedTemplates = new Dictionary<QilName, Template>();

		public Dictionary<QilName, AttributeSet> AttributeSets = new Dictionary<QilName, AttributeSet>();

		public Dictionary<string, NsAlias> NsAliases = new Dictionary<string, NsAlias>();

		private Dictionary<string, int> moduleOrder = new Dictionary<string, int>();

		public readonly string PhantomNCName = "error";

		private int phantomNsCounter;

		private int savedErrorCount = -1;

		private int ErrorCount
		{
			get
			{
				return CompilerResults.Errors.Count;
			}
			set
			{
				for (int num = ErrorCount - 1; num >= value; num--)
				{
					CompilerResults.Errors.RemoveAt(num);
				}
			}
		}

		public Compiler(XsltSettings settings, bool debug, string scriptAssemblyPath)
		{
			TempFileCollection tempFiles = settings.TempFiles ?? new TempFileCollection();
			Settings = settings;
			IsDebug = settings.IncludeDebugInformation || debug;
			ScriptAssemblyPath = scriptAssemblyPath;
			CompilerResults = new CompilerResults(tempFiles);
			Scripts = new Scripts(this);
		}

		public CompilerResults Compile(object stylesheet, XmlResolver xmlResolver, out QilExpression qil)
		{
			new XsltLoader().Load(this, stylesheet, xmlResolver);
			qil = QilGenerator.CompileStylesheet(this);
			SortErrors();
			return CompilerResults;
		}

		public Stylesheet CreateStylesheet()
		{
			Stylesheet stylesheet = new Stylesheet(this, CurrentPrecedence);
			if (CurrentPrecedence-- == 0)
			{
				Root = new RootLevel(stylesheet);
			}
			return stylesheet;
		}

		public void AddModule(string baseUri)
		{
			if (!moduleOrder.ContainsKey(baseUri))
			{
				moduleOrder[baseUri] = moduleOrder.Count;
			}
		}

		public void ApplyNsAliases(ref string prefix, ref string nsUri)
		{
			if (NsAliases.TryGetValue(nsUri, out var value))
			{
				nsUri = value.ResultNsUri;
				prefix = value.ResultPrefix;
			}
		}

		public bool SetNsAlias(string ssheetNsUri, string resultNsUri, string resultPrefix, int importPrecedence)
		{
			if (NsAliases.TryGetValue(ssheetNsUri, out var value) && (importPrecedence < value.ImportPrecedence || resultNsUri == value.ResultNsUri))
			{
				return false;
			}
			NsAliases[ssheetNsUri] = new NsAlias(resultNsUri, resultPrefix, importPrecedence);
			return value != null;
		}

		private void MergeWhitespaceRules(Stylesheet sheet)
		{
			for (int i = 0; i <= 2; i++)
			{
				sheet.WhitespaceRules[i].Reverse();
				WhitespaceRules.AddRange(sheet.WhitespaceRules[i]);
			}
			sheet.WhitespaceRules = null;
		}

		private void MergeAttributeSets(Stylesheet sheet)
		{
			foreach (QilName key in sheet.AttributeSets.Keys)
			{
				if (!AttributeSets.TryGetValue(key, out var value))
				{
					AttributeSets[key] = sheet.AttributeSets[key];
				}
				else
				{
					value.MergeContent(sheet.AttributeSets[key]);
				}
			}
			sheet.AttributeSets = null;
		}

		private void MergeGlobalVarPars(Stylesheet sheet)
		{
			foreach (VarPar globalVarPar in sheet.GlobalVarPars)
			{
				if (!AllGlobalVarPars.ContainsKey(globalVarPar.Name))
				{
					if (globalVarPar.NodeType == XslNodeType.Variable)
					{
						GlobalVars.Add(globalVarPar);
					}
					else
					{
						ExternalPars.Add(globalVarPar);
					}
					AllGlobalVarPars[globalVarPar.Name] = globalVarPar;
				}
			}
			sheet.GlobalVarPars = null;
		}

		public void MergeWithStylesheet(Stylesheet sheet)
		{
			MergeWhitespaceRules(sheet);
			MergeAttributeSets(sheet);
			MergeGlobalVarPars(sheet);
		}

		public static string ConstructQName(string prefix, string localName)
		{
			if (prefix.Length == 0)
			{
				return localName;
			}
			return prefix + ":" + localName;
		}

		public bool ParseQName(string qname, out string prefix, out string localName, IErrorHelper errorHelper)
		{
			try
			{
				ValidateNames.ParseQNameThrow(qname, out prefix, out localName);
				return true;
			}
			catch (XmlException ex)
			{
				errorHelper.ReportError(ex.Message, (string[])null);
				prefix = PhantomNCName;
				localName = PhantomNCName;
				return false;
			}
		}

		public bool ParseNameTest(string nameTest, out string prefix, out string localName, IErrorHelper errorHelper)
		{
			try
			{
				ValidateNames.ParseNameTestThrow(nameTest, out prefix, out localName);
				return true;
			}
			catch (XmlException ex)
			{
				errorHelper.ReportError(ex.Message, (string[])null);
				prefix = PhantomNCName;
				localName = PhantomNCName;
				return false;
			}
		}

		public void ValidatePiName(string name, IErrorHelper errorHelper)
		{
			try
			{
				ValidateNames.ValidateNameThrow(string.Empty, name, string.Empty, XPathNodeType.ProcessingInstruction, ValidateNames.Flags.AllExceptPrefixMapping);
			}
			catch (XmlException ex)
			{
				errorHelper.ReportError(ex.Message, (string[])null);
			}
		}

		public string CreatePhantomNamespace()
		{
			return "\0namespace" + phantomNsCounter++;
		}

		public bool IsPhantomNamespace(string namespaceName)
		{
			if (namespaceName.Length > 0)
			{
				return namespaceName[0] == '\0';
			}
			return false;
		}

		public bool IsPhantomName(QilName qname)
		{
			string namespaceUri = qname.NamespaceUri;
			if (namespaceUri.Length > 0)
			{
				return namespaceUri[0] == '\0';
			}
			return false;
		}

		public void EnterForwardsCompatible()
		{
			savedErrorCount = ErrorCount;
		}

		public bool ExitForwardsCompatible(bool fwdCompat)
		{
			if (fwdCompat && ErrorCount > savedErrorCount)
			{
				ErrorCount = savedErrorCount;
				return false;
			}
			return true;
		}

		public CompilerError CreateError(ISourceLineInfo lineInfo, string res, params string[] args)
		{
			AddModule(lineInfo.Uri);
			return new CompilerError(lineInfo.Uri, lineInfo.Start.Line, lineInfo.Start.Pos, string.Empty, XslTransformException.CreateMessage(res, args));
		}

		public void ReportError(ISourceLineInfo lineInfo, string res, params string[] args)
		{
			CompilerError value = CreateError(lineInfo, res, args);
			CompilerResults.Errors.Add(value);
		}

		public void ReportWarning(ISourceLineInfo lineInfo, string res, params string[] args)
		{
			int num = 1;
			if (0 > Settings.WarningLevel || Settings.WarningLevel >= num)
			{
				CompilerError compilerError = CreateError(lineInfo, res, args);
				if (Settings.TreatWarningsAsErrors)
				{
					compilerError.ErrorText = XslTransformException.CreateMessage("Xslt_WarningAsError", compilerError.ErrorText);
					CompilerResults.Errors.Add(compilerError);
				}
				else
				{
					compilerError.IsWarning = true;
					CompilerResults.Errors.Add(compilerError);
				}
			}
		}

		private void SortErrors()
		{
			CompilerErrorCollection errors = CompilerResults.Errors;
			if (errors.Count > 1)
			{
				CompilerError[] array = new CompilerError[errors.Count];
				errors.CopyTo(array, 0);
				Array.Sort(array, new CompilerErrorComparer(moduleOrder));
				errors.Clear();
				errors.AddRange(array);
			}
		}
	}
	internal class Output
	{
		public XmlWriterSettings Settings;

		public string Version;

		public string Encoding;

		public XmlQualifiedName Method;

		public const int NeverDeclaredPrec = int.MinValue;

		public int MethodPrec = int.MinValue;

		public int VersionPrec = int.MinValue;

		public int EncodingPrec = int.MinValue;

		public int OmitXmlDeclarationPrec = int.MinValue;

		public int StandalonePrec = int.MinValue;

		public int DocTypePublicPrec = int.MinValue;

		public int DocTypeSystemPrec = int.MinValue;

		public int IndentPrec = int.MinValue;

		public int MediaTypePrec = int.MinValue;

		public Output()
		{
			Settings = new XmlWriterSettings();
			Settings.OutputMethod = XmlOutputMethod.AutoDetect;
			Settings.AutoXmlDeclaration = true;
			Settings.ConformanceLevel = ConformanceLevel.Auto;
			Settings.MergeCDataSections = true;
		}
	}
	internal class DecimalFormats : KeyedCollection<XmlQualifiedName, DecimalFormatDecl>
	{
		protected override XmlQualifiedName GetKeyForItem(DecimalFormatDecl format)
		{
			return format.Name;
		}
	}
	internal class DecimalFormatDecl
	{
		public readonly XmlQualifiedName Name;

		public readonly string InfinitySymbol;

		public readonly string NanSymbol;

		public readonly char[] Characters;

		public static DecimalFormatDecl Default = new DecimalFormatDecl(new XmlQualifiedName(), "Infinity", "NaN", ".,%‰0#;-");

		public DecimalFormatDecl(XmlQualifiedName name, string infinitySymbol, string nanSymbol, string characters)
		{
			Name = name;
			InfinitySymbol = infinitySymbol;
			NanSymbol = nanSymbol;
			Characters = characters.ToCharArray();
		}
	}
	internal class NsAlias
	{
		public readonly string ResultNsUri;

		public readonly string ResultPrefix;

		public readonly int ImportPrecedence;

		public NsAlias(string resultNsUri, string resultPrefix, int importPrecedence)
		{
			ResultNsUri = resultNsUri;
			ResultPrefix = resultPrefix;
			ImportPrecedence = importPrecedence;
		}
	}
	internal sealed class CompilerScopeManager<V>
	{
		public enum ScopeFlags
		{
			BackwardCompatibility = 1,
			ForwardCompatibility = 2,
			CanHaveApplyImports = 4,
			NsDecl = 16,
			NsExcl = 32,
			Variable = 64,
			CompatibilityFlags = 3,
			InheritedFlags = 7,
			ExclusiveFlags = 112
		}

		public struct ScopeRecord
		{
			public int scopeCount;

			public ScopeFlags flags;

			public string ncName;

			public string nsUri;

			public V value;

			public bool IsVariable => (flags & ScopeFlags.Variable) != 0;

			public bool IsNamespace => (flags & ScopeFlags.NsDecl) != 0;
		}

		internal struct NamespaceEnumerator
		{
			private CompilerScopeManager<V> scope;

			private int lastRecord;

			private int currentRecord;

			public ScopeRecord Current => scope.records[currentRecord];

			public NamespaceEnumerator(CompilerScopeManager<V> scope)
			{
				this.scope = scope;
				lastRecord = scope.lastRecord;
				currentRecord = lastRecord + 1;
			}

			public void Reset()
			{
				currentRecord = lastRecord + 1;
			}

			public bool MoveNext()
			{
				while (0 < --currentRecord)
				{
					if (scope.records[currentRecord].IsNamespace && scope.LookupNamespace(scope.records[currentRecord].ncName, lastRecord, currentRecord + 1) == null)
					{
						return true;
					}
				}
				return false;
			}
		}

		private const int LastPredefRecord = 0;

		private ScopeRecord[] records = new ScopeRecord[32];

		private int lastRecord;

		private int lastScopes;

		public bool ForwardCompatibility
		{
			get
			{
				return (records[lastRecord].flags & ScopeFlags.ForwardCompatibility) != 0;
			}
			set
			{
				SetFlag(ScopeFlags.ForwardCompatibility, value);
			}
		}

		public bool BackwardCompatibility
		{
			get
			{
				return (records[lastRecord].flags & ScopeFlags.BackwardCompatibility) != 0;
			}
			set
			{
				SetFlag(ScopeFlags.BackwardCompatibility, value);
			}
		}

		public bool CanHaveApplyImports
		{
			get
			{
				return (records[lastRecord].flags & ScopeFlags.CanHaveApplyImports) != 0;
			}
			set
			{
				SetFlag(ScopeFlags.CanHaveApplyImports, value);
			}
		}

		public CompilerScopeManager()
		{
			records[0].flags = ScopeFlags.NsDecl;
			records[0].ncName = "xml";
			records[0].nsUri = "http://www.w3.org/XML/1998/namespace";
		}

		public CompilerScopeManager(KeywordsTable atoms)
		{
			records[0].flags = ScopeFlags.NsDecl;
			records[0].ncName = atoms.Xml;
			records[0].nsUri = atoms.UriXml;
		}

		public void EnterScope()
		{
			lastScopes++;
		}

		public void ExitScope()
		{
			if (0 < lastScopes)
			{
				lastScopes--;
				return;
			}
			while (records[--lastRecord].scopeCount == 0)
			{
			}
			lastScopes = records[lastRecord].scopeCount;
			lastScopes--;
		}

		[Conditional("DEBUG")]
		public void CheckEmpty()
		{
			ExitScope();
		}

		public bool EnterScope(NsDecl nsDecl)
		{
			lastScopes++;
			bool result = false;
			bool flag = false;
			while (nsDecl != null)
			{
				if (nsDecl.NsUri == null)
				{
					flag = true;
				}
				else if (nsDecl.Prefix == null)
				{
					AddExNamespace(nsDecl.NsUri);
				}
				else
				{
					result = true;
					AddNsDeclaration(nsDecl.Prefix, nsDecl.NsUri);
				}
				nsDecl = nsDecl.Prev;
			}
			if (flag)
			{
				AddExNamespace(null);
			}
			return result;
		}

		private void AddRecord()
		{
			records[lastRecord].scopeCount = lastScopes;
			if (++lastRecord == records.Length)
			{
				ScopeRecord[] destinationArray = new ScopeRecord[lastRecord * 2];
				Array.Copy(records, 0, destinationArray, 0, lastRecord);
				records = destinationArray;
			}
			lastScopes = 0;
		}

		private void AddRecord(ScopeFlags flag, string ncName, string uri, V value)
		{
			ScopeFlags scopeFlags = records[lastRecord].flags;
			if (lastScopes != 0 || (scopeFlags & ScopeFlags.ExclusiveFlags) != 0)
			{
				AddRecord();
				scopeFlags &= ScopeFlags.InheritedFlags;
			}
			records[lastRecord].flags = scopeFlags | flag;
			records[lastRecord].ncName = ncName;
			records[lastRecord].nsUri = uri;
			records[lastRecord].value = value;
		}

		private void SetFlag(ScopeFlags flag, bool value)
		{
			ScopeFlags scopeFlags = records[lastRecord].flags;
			if ((scopeFlags & flag) != 0 == value)
			{
				return;
			}
			if (lastScopes != 0)
			{
				AddRecord();
				scopeFlags &= ScopeFlags.InheritedFlags;
			}
			if (flag == ScopeFlags.CanHaveApplyImports)
			{
				scopeFlags ^= flag;
			}
			else
			{
				scopeFlags &= (ScopeFlags)(-4);
				if (value)
				{
					scopeFlags |= flag;
				}
			}
			records[lastRecord].flags = scopeFlags;
		}

		public void AddVariable(QilName varName, V value)
		{
			AddRecord(ScopeFlags.Variable, varName.LocalName, varName.NamespaceUri, value);
		}

		private string LookupNamespace(string prefix, int from, int to)
		{
			int num = from;
			while (to <= num)
			{
				string prefix2;
				string nsUri;
				ScopeFlags name = GetName(ref records[num], out prefix2, out nsUri);
				if ((name & ScopeFlags.NsDecl) != 0 && prefix2 == prefix)
				{
					return nsUri;
				}
				num--;
			}
			return null;
		}

		public string LookupNamespace(string prefix)
		{
			return LookupNamespace(prefix, lastRecord, 0);
		}

		private static ScopeFlags GetName(ref ScopeRecord re, out string prefix, out string nsUri)
		{
			prefix = re.ncName;
			nsUri = re.nsUri;
			return re.flags;
		}

		public void AddNsDeclaration(string prefix, string nsUri)
		{
			AddRecord(ScopeFlags.NsDecl, prefix, nsUri, default(V));
		}

		public void AddExNamespace(string nsUri)
		{
			AddRecord(ScopeFlags.NsExcl, null, nsUri, default(V));
		}

		public bool IsExNamespace(string nsUri)
		{
			int num = 0;
			int num2 = lastRecord;
			while (0 <= num2)
			{
				string prefix;
				string nsUri2;
				ScopeFlags name = GetName(ref records[num2], out prefix, out nsUri2);
				if ((name & ScopeFlags.NsExcl) != 0)
				{
					if (nsUri2 == nsUri)
					{
						return true;
					}
					if (nsUri2 == null)
					{
						num = num2;
					}
				}
				else if (num != 0 && (name & ScopeFlags.NsDecl) != 0 && nsUri2 == nsUri)
				{
					bool flag = false;
					for (int i = num2 + 1; i < num; i++)
					{
						string prefix2;
						string nsUri3;
						ScopeFlags name2 = GetName(ref records[i], out prefix2, out nsUri3);
						if ((name & ScopeFlags.NsDecl) != 0 && prefix2 == prefix)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						return true;
					}
				}
				num2--;
			}
			return false;
		}

		private int SearchVariable(string localName, string uri)
		{
			int num = lastRecord;
			while (0 <= num)
			{
				string prefix;
				string nsUri;
				ScopeFlags name = GetName(ref records[num], out prefix, out nsUri);
				if ((name & ScopeFlags.Variable) != 0 && prefix == localName && nsUri == uri)
				{
					return num;
				}
				num--;
			}
			return -1;
		}

		public V LookupVariable(string localName, string uri)
		{
			int num = SearchVariable(localName, uri);
			if (num >= 0)
			{
				return records[num].value;
			}
			return default(V);
		}

		public bool IsLocalVariable(string localName, string uri)
		{
			int num = SearchVariable(localName, uri);
			while (0 <= --num)
			{
				if (records[num].scopeCount != 0)
				{
					return true;
				}
			}
			return false;
		}

		internal IEnumerable<ScopeRecord> GetActiveRecords()
		{
			int currentRecord = lastRecord + 1;
			while (true)
			{
				int num = currentRecord - 1;
				currentRecord = num;
				if (0 < num)
				{
					if (!records[currentRecord].IsNamespace || LookupNamespace(records[currentRecord].ncName, lastRecord, currentRecord + 1) == null)
					{
						yield return records[currentRecord];
					}
					continue;
				}
				break;
			}
		}

		public NamespaceEnumerator GetEnumerator()
		{
			return new NamespaceEnumerator(this);
		}
	}
	internal enum SingletonFocusType
	{
		None,
		InitialDocumentNode,
		InitialContextNode,
		Iterator
	}
	internal struct SingletonFocus : IFocus
	{
		private XPathQilFactory f;

		private SingletonFocusType focusType;

		private QilIterator current;

		public SingletonFocus(XPathQilFactory f)
		{
			this.f = f;
			focusType = SingletonFocusType.None;
			current = null;
		}

		public void SetFocus(SingletonFocusType focusType)
		{
			this.focusType = focusType;
		}

		public void SetFocus(QilIterator current)
		{
			if (current != null)
			{
				focusType = SingletonFocusType.Iterator;
				this.current = current;
			}
			else
			{
				focusType = SingletonFocusType.None;
				this.current = null;
			}
		}

		[Conditional("DEBUG")]
		private void CheckFocus()
		{
		}

		public QilNode GetCurrent()
		{
			return focusType switch
			{
				SingletonFocusType.InitialDocumentNode => f.Root(f.XmlContext()), 
				SingletonFocusType.InitialContextNode => f.XmlContext(), 
				_ => current, 
			};
		}

		public QilNode GetPosition()
		{
			return f.Double(1.0);
		}

		public QilNode GetLast()
		{
			return f.Double(1.0);
		}
	}
	internal struct FunctionFocus : IFocus
	{
		private bool isSet;

		private QilParameter current;

		private QilParameter position;

		private QilParameter last;

		public bool IsFocusSet => isSet;

		public void StartFocus(IList<QilNode> args, XslFlags flags)
		{
			int num = 0;
			if ((flags & XslFlags.Current) != 0)
			{
				current = (QilParameter)args[num++];
			}
			if ((flags & XslFlags.Position) != 0)
			{
				position = (QilParameter)args[num++];
			}
			if ((flags & XslFlags.Last) != 0)
			{
				last = (QilParameter)args[num++];
			}
			isSet = true;
		}

		public void StopFocus()
		{
			isSet = false;
			current = (position = (last = null));
		}

		public QilNode GetCurrent()
		{
			return current;
		}

		public QilNode GetPosition()
		{
			return position;
		}

		public QilNode GetLast()
		{
			return last;
		}
	}
	internal struct LoopFocus : IFocus
	{
		private XPathQilFactory f;

		private QilIterator current;

		private QilIterator cached;

		private QilIterator last;

		public bool IsFocusSet => current != null;

		public LoopFocus(XPathQilFactory f)
		{
			this.f = f;
			current = (cached = (last = null));
		}

		public void SetFocus(QilIterator current)
		{
			this.current = current;
			cached = (last = null);
		}

		public QilNode GetCurrent()
		{
			return current;
		}

		public QilNode GetPosition()
		{
			return f.XsltConvert(f.PositionOf(current), XmlQueryTypeFactory.DoubleX);
		}

		public QilNode GetLast()
		{
			if (last == null)
			{
				last = f.Let(f.Double(0.0));
			}
			return last;
		}

		public void EnsureCache()
		{
			if (cached == null)
			{
				cached = f.Let(current.Binding);
				current.Binding = cached;
			}
		}

		public void Sort(QilNode sortKeys)
		{
			if (sortKeys != null)
			{
				EnsureCache();
				current = f.For(f.Sort(current, sortKeys));
			}
		}

		public QilLoop ConstructLoop(QilNode body)
		{
			if (last != null)
			{
				EnsureCache();
				last.Binding = f.XsltConvert(f.Length(cached), XmlQueryTypeFactory.DoubleX);
			}
			QilLoop qilLoop = f.BaseFactory.Loop(current, body);
			if (last != null)
			{
				qilLoop = f.BaseFactory.Loop(last, qilLoop);
			}
			if (cached != null)
			{
				qilLoop = f.BaseFactory.Loop(cached, qilLoop);
			}
			return qilLoop;
		}
	}
	internal class InvokeGenerator : QilCloneVisitor
	{
		private bool debug;

		private Stack<QilIterator> iterStack;

		private QilList formalArgs;

		private QilList invokeArgs;

		private int curArg;

		private XsltQilFactory fac;

		public InvokeGenerator(XsltQilFactory f, bool debug)
			: base(f.BaseFactory)
		{
			this.debug = debug;
			fac = f;
			iterStack = new Stack<QilIterator>();
		}

		public QilNode GenerateInvoke(QilFunction func, IList<XslNode> actualArgs)
		{
			iterStack.Clear();
			formalArgs = func.Arguments;
			invokeArgs = fac.ActualParameterList();
			for (curArg = 0; curArg < formalArgs.Count; curArg++)
			{
				QilParameter qilParameter = (QilParameter)formalArgs[curArg];
				QilNode qilNode = FindActualArg(qilParameter, actualArgs);
				if (qilNode == null)
				{
					qilNode = ((!debug) ? Clone(qilParameter.DefaultValue) : ((!(qilParameter.Name.NamespaceUri == "urn:schemas-microsoft-com:xslt-debug")) ? fac.DefaultValueMarker() : Clone(qilParameter.DefaultValue)));
				}
				XmlQueryType xmlType = qilParameter.XmlType;
				XmlQueryType xmlType2 = qilNode.XmlType;
				if (!xmlType2.IsSubtypeOf(xmlType))
				{
					qilNode = fac.TypeAssert(qilNode, xmlType);
				}
				invokeArgs.Add(qilNode);
			}
			QilNode qilNode2 = fac.Invoke(func, invokeArgs);
			while (iterStack.Count != 0)
			{
				qilNode2 = fac.Loop(iterStack.Pop(), qilNode2);
			}
			return qilNode2;
		}

		private QilNode FindActualArg(QilParameter formalArg, IList<XslNode> actualArgs)
		{
			QilName name = formalArg.Name;
			foreach (XslNode actualArg in actualArgs)
			{
				if (actualArg.Name.Equals(name))
				{
					return ((VarPar)actualArg).Value;
				}
			}
			return null;
		}

		protected override QilNode VisitReference(QilNode n)
		{
			QilNode qilNode = FindClonedReference(n);
			if (qilNode != null)
			{
				return qilNode;
			}
			for (int i = 0; i < curArg; i++)
			{
				if (n == formalArgs[i])
				{
					if (invokeArgs[i] is QilLiteral)
					{
						return invokeArgs[i].ShallowClone(fac.BaseFactory);
					}
					if (!(invokeArgs[i] is QilIterator))
					{
						QilIterator qilIterator = fac.BaseFactory.Let(invokeArgs[i]);
						iterStack.Push(qilIterator);
						invokeArgs[i] = qilIterator;
					}
					return invokeArgs[i];
				}
			}
			return n;
		}

		protected override QilNode VisitFunction(QilFunction n)
		{
			return n;
		}
	}
	internal class KeyMatchBuilder : XPathBuilder, XPathPatternParser.IPatternBuilder, IXPathBuilder<QilNode>
	{
		internal class PathConvertor : QilReplaceVisitor
		{
			private new XPathQilFactory f;

			private QilNode fixup;

			public PathConvertor(XPathQilFactory f)
				: base(f.BaseFactory)
			{
				this.f = f;
			}

			public QilNode ConvertReletive2Absolute(QilNode node, QilNode fixup)
			{
				QilDepthChecker.Check(node);
				this.fixup = fixup;
				return Visit(node);
			}

			protected override QilNode Visit(QilNode n)
			{
				if (n.NodeType == QilNodeType.Union || n.NodeType == QilNodeType.DocOrderDistinct || n.NodeType == QilNodeType.Filter || n.NodeType == QilNodeType.Loop)
				{
					return base.Visit(n);
				}
				return n;
			}

			protected override QilNode VisitLoop(QilLoop n)
			{
				if (n.Variable.Binding.NodeType == QilNodeType.Root || n.Variable.Binding.NodeType == QilNodeType.Deref)
				{
					return n;
				}
				if (n.Variable.Binding.NodeType == QilNodeType.Content)
				{
					QilUnary qilUnary = (QilUnary)n.Variable.Binding;
					QilIterator variable = (QilIterator)(qilUnary.Child = f.For(f.DescendantOrSelf(f.Root(fixup))));
					n.Variable.Binding = f.Loop(variable, qilUnary);
					return n;
				}
				n.Variable.Binding = Visit(n.Variable.Binding);
				return n;
			}

			protected override QilNode VisitFilter(QilLoop n)
			{
				return VisitLoop(n);
			}
		}

		private int depth;

		private PathConvertor convertor;

		public KeyMatchBuilder(IXPathEnvironment env)
			: base(env)
		{
			convertor = new PathConvertor(env.Factory);
		}

		public override void StartBuild()
		{
			if (depth == 0)
			{
				base.StartBuild();
			}
			depth++;
		}

		public override QilNode EndBuild(QilNode result)
		{
			depth--;
			if (result == null)
			{
				return base.EndBuild(result);
			}
			if (depth == 0)
			{
				result = convertor.ConvertReletive2Absolute(result, fixupCurrent);
				result = base.EndBuild(result);
			}
			return result;
		}

		public virtual IXPathBuilder<QilNode> GetPredicateBuilder(QilNode ctx)
		{
			return this;
		}
	}
	internal class KeywordsTable
	{
		public XmlNameTable NameTable;

		public string AnalyzeString;

		public string ApplyImports;

		public string ApplyTemplates;

		public string Assembly;

		public string Attribute;

		public string AttributeSet;

		public string CallTemplate;

		public string CaseOrder;

		public string CDataSectionElements;

		public string Character;

		public string CharacterMap;

		public string Choose;

		public string Comment;

		public string Copy;

		public string CopyOf;

		public string Count;

		public string DataType;

		public string DecimalFormat;

		public string DecimalSeparator;

		public string DefaultCollation;

		public string DefaultValidation;

		public string Digit;

		public string DisableOutputEscaping;

		public string DocTypePublic;

		public string DocTypeSystem;

		public string Document;

		public string Element;

		public string Elements;

		public string Encoding;

		public string ExcludeResultPrefixes;

		public string ExtensionElementPrefixes;

		public string Fallback;

		public string ForEach;

		public string ForEachGroup;

		public string Format;

		public string From;

		public string Function;

		public string GroupingSeparator;

		public string GroupingSize;

		public string Href;

		public string Id;

		public string If;

		public string ImplementsPrefix;

		public string Import;

		public string ImportSchema;

		public string Include;

		public string Indent;

		public string Infinity;

		public string Key;

		public string Lang;

		public string Language;

		public string LetterValue;

		public string Level;

		public string Match;

		public string MatchingSubstring;

		public string MediaType;

		public string Message;

		public string Method;

		public string MinusSign;

		public string Mode;

		public string Name;

		public string Namespace;

		public string NamespaceAlias;

		public string NaN;

		public string NextMatch;

		public string NonMatchingSubstring;

		public string Number;

		public string OmitXmlDeclaration;

		public string Order;

		public string Otherwise;

		public string Output;

		public string OutputCharacter;

		public string OutputVersion;

		public string Param;

		public string PatternSeparator;

		public string Percent;

		public string PerformSort;

		public string PerMille;

		public string PreserveSpace;

		public string Priority;

		public string ProcessingInstruction;

		public string Required;

		public string ResultDocument;

		public string ResultPrefix;

		public string Script;

		public string Select;

		public string Separator;

		public string Sequence;

		public string Sort;

		public string Space;

		public string Standalone;

		public string StripSpace;

		public string Stylesheet;

		public string StylesheetPrefix;

		public string Template;

		public string Terminate;

		public string Test;

		public string Text;

		public string Transform;

		public string UrnMsxsl;

		public string UriXml;

		public string UriXsl;

		public string UriWdXsl;

		public string Use;

		public string UseAttributeSets;

		public string UseWhen;

		public string Using;

		public string Value;

		public string ValueOf;

		public string Variable;

		public string Version;

		public string When;

		public string WithParam;

		public string Xml;

		public string Xmlns;

		public string XPathDefaultNamespace;

		public string ZeroDigit;

		public KeywordsTable(XmlNameTable nt)
		{
			NameTable = nt;
			AnalyzeString = nt.Add("analyze-string");
			ApplyImports = nt.Add("apply-imports");
			ApplyTemplates = nt.Add("apply-templates");
			Assembly = nt.Add("assembly");
			Attribute = nt.Add("attribute");
			AttributeSet = nt.Add("attribute-set");
			CallTemplate = nt.Add("call-template");
			CaseOrder = nt.Add("case-order");
			CDataSectionElements = nt.Add("cdata-section-elements");
			Character = nt.Add("character");
			CharacterMap = nt.Add("character-map");
			Choose = nt.Add("choose");
			Comment = nt.Add("comment");
			Copy = nt.Add("copy");
			CopyOf = nt.Add("copy-of");
			Count = nt.Add("count");
			DataType = nt.Add("data-type");
			DecimalFormat = nt.Add("decimal-format");
			DecimalSeparator = nt.Add("decimal-separator");
			DefaultCollation = nt.Add("default-collation");
			DefaultValidation = nt.Add("default-validation");
			Digit = nt.Add("digit");
			DisableOutputEscaping = nt.Add("disable-output-escaping");
			DocTypePublic = nt.Add("doctype-public");
			DocTypeSystem = nt.Add("doctype-system");
			Document = nt.Add("document");
			Element = nt.Add("element");
			Elements = nt.Add("elements");
			Encoding = nt.Add("encoding");
			ExcludeResultPrefixes = nt.Add("exclude-result-prefixes");
			ExtensionElementPrefixes = nt.Add("extension-element-prefixes");
			Fallback = nt.Add("fallback");
			ForEach = nt.Add("for-each");
			ForEachGroup = nt.Add("for-each-group");
			Format = nt.Add("format");
			From = nt.Add("from");
			Function = nt.Add("function");
			GroupingSeparator = nt.Add("grouping-separator");
			GroupingSize = nt.Add("grouping-size");
			Href = nt.Add("href");
			Id = nt.Add("id");
			If = nt.Add("if");
			ImplementsPrefix = nt.Add("implements-prefix");
			Import = nt.Add("import");
			ImportSchema = nt.Add("import-schema");
			Include = nt.Add("include");
			Indent = nt.Add("indent");
			Infinity = nt.Add("infinity");
			Key = nt.Add("key");
			Lang = nt.Add("lang");
			Language = nt.Add("language");
			LetterValue = nt.Add("letter-value");
			Level = nt.Add("level");
			Match = nt.Add("match");
			MatchingSubstring = nt.Add("matching-substring");
			MediaType = nt.Add("media-type");
			Message = nt.Add("message");
			Method = nt.Add("method");
			MinusSign = nt.Add("minus-sign");
			Mode = nt.Add("mode");
			Name = nt.Add("name");
			Namespace = nt.Add("namespace");
			NamespaceAlias = nt.Add("namespace-alias");
			NaN = nt.Add("NaN");
			NextMatch = nt.Add("next-match");
			NonMatchingSubstring = nt.Add("non-matching-substring");
			Number = nt.Add("number");
			OmitXmlDeclaration = nt.Add("omit-xml-declaration");
			Otherwise = nt.Add("otherwise");
			Order = nt.Add("order");
			Output = nt.Add("output");
			OutputCharacter = nt.Add("output-character");
			OutputVersion = nt.Add("output-version");
			Param = nt.Add("param");
			PatternSeparator = nt.Add("pattern-separator");
			Percent = nt.Add("percent");
			PerformSort = nt.Add("perform-sort");
			PerMille = nt.Add("per-mille");
			PreserveSpace = nt.Add("preserve-space");
			Priority = nt.Add("priority");
			ProcessingInstruction = nt.Add("processing-instruction");
			Required = nt.Add("required");
			ResultDocument = nt.Add("result-document");
			ResultPrefix = nt.Add("result-prefix");
			Script = nt.Add("script");
			Select = nt.Add("select");
			Separator = nt.Add("separator");
			Sequence = nt.Add("sequence");
			Sort = nt.Add("sort");
			Space = nt.Add("space");
			Standalone = nt.Add("standalone");
			StripSpace = nt.Add("strip-space");
			Stylesheet = nt.Add("stylesheet");
			StylesheetPrefix = nt.Add("stylesheet-prefix");
			Template = nt.Add("template");
			Terminate = nt.Add("terminate");
			Test = nt.Add("test");
			Text = nt.Add("text");
			Transform = nt.Add("transform");
			UrnMsxsl = nt.Add("urn:schemas-microsoft-com:xslt");
			UriXml = nt.Add("http://www.w3.org/XML/1998/namespace");
			UriXsl = nt.Add("http://www.w3.org/1999/XSL/Transform");
			UriWdXsl = nt.Add("http://www.w3.org/TR/WD-xsl");
			Use = nt.Add("use");
			UseAttributeSets = nt.Add("use-attribute-sets");
			UseWhen = nt.Add("use-when");
			Using = nt.Add("using");
			Value = nt.Add("value");
			ValueOf = nt.Add("value-of");
			Variable = nt.Add("variable");
			Version = nt.Add("version");
			When = nt.Add("when");
			WithParam = nt.Add("with-param");
			Xml = nt.Add("xml");
			Xmlns = nt.Add("xmlns");
			XPathDefaultNamespace = nt.Add("xpath-default-namespace");
			ZeroDigit = nt.Add("zero-digit");
		}
	}
	internal class TemplateMatch
	{
		internal class TemplateMatchComparer : IComparer<TemplateMatch>
		{
			public int Compare(TemplateMatch x, TemplateMatch y)
			{
				if (!(x.priority > y.priority))
				{
					if (!(x.priority < y.priority))
					{
						return x.template.OrderNumber - y.template.OrderNumber;
					}
					return -1;
				}
				return 1;
			}
		}

		public static readonly TemplateMatchComparer Comparer = new TemplateMatchComparer();

		private Template template;

		private double priority;

		private XmlNodeKindFlags nodeKind;

		private QilName qname;

		private QilIterator iterator;

		private QilNode condition;

		public XmlNodeKindFlags NodeKind => nodeKind;

		public QilName QName => qname;

		public QilIterator Iterator => iterator;

		public QilNode Condition => condition;

		public QilFunction TemplateFunction => template.Function;

		public TemplateMatch(Template template, QilLoop filter)
		{
			this.template = template;
			priority = (double.IsNaN(template.Priority) ? XPathPatternBuilder.GetPriority(filter) : template.Priority);
			iterator = filter.Variable;
			condition = filter.Body;
			XPathPatternBuilder.CleanAnnotation(filter);
			NipOffTypeNameCheck();
		}

		private void NipOffTypeNameCheck()
		{
			QilBinary[] array = new QilBinary[4];
			int num = -1;
			QilNode left = condition;
			nodeKind = XmlNodeKindFlags.None;
			qname = null;
			while (left.NodeType == QilNodeType.And)
			{
				left = (array[++num & 3] = (QilBinary)left).Left;
			}
			if (left.NodeType != QilNodeType.IsType)
			{
				return;
			}
			QilBinary qilBinary = (QilBinary)left;
			if (qilBinary.Left != iterator || qilBinary.Right.NodeType != QilNodeType.LiteralType)
			{
				return;
			}
			XmlNodeKindFlags nodeKinds = qilBinary.Right.XmlType.NodeKinds;
			if (!Bits.ExactlyOne((uint)nodeKinds))
			{
				return;
			}
			QilNode qilNode = qilBinary;
			nodeKind = nodeKinds;
			QilBinary qilBinary2 = array[num & 3];
			if (qilBinary2 != null && qilBinary2.Right.NodeType == QilNodeType.Eq)
			{
				QilBinary qilBinary3 = (QilBinary)qilBinary2.Right;
				if (qilBinary3.Left.NodeType == QilNodeType.NameOf && ((QilUnary)qilBinary3.Left).Child == iterator && qilBinary3.Right.NodeType == QilNodeType.LiteralQName)
				{
					qilNode = qilBinary2;
					qname = (QilName)((QilLiteral)qilBinary3.Right).Value;
					num--;
				}
			}
			QilBinary qilBinary4 = array[num & 3];
			QilBinary qilBinary5 = array[--num & 3];
			if (qilBinary5 != null)
			{
				qilBinary5.Left = qilBinary4.Right;
			}
			else if (qilBinary4 != null)
			{
				condition = qilBinary4.Right;
			}
			else
			{
				condition = null;
			}
		}
	}
	internal struct Pattern
	{
		public readonly TemplateMatch Match;

		public readonly int Priority;

		public Pattern(TemplateMatch match, int priority)
		{
			Match = match;
			Priority = priority;
		}
	}
	internal class PatternBag
	{
		public Dictionary<QilName, List<Pattern>> FixedNamePatterns = new Dictionary<QilName, List<Pattern>>();

		public List<QilName> FixedNamePatternsNames = new List<QilName>();

		public List<Pattern> NonFixedNamePatterns = new List<Pattern>();

		public void Clear()
		{
			FixedNamePatterns.Clear();
			FixedNamePatternsNames.Clear();
			NonFixedNamePatterns.Clear();
		}

		public void Add(Pattern pattern)
		{
			QilName qName = pattern.Match.QName;
			List<Pattern> value;
			if (qName == null)
			{
				value = NonFixedNamePatterns;
			}
			else if (!FixedNamePatterns.TryGetValue(qName, out value))
			{
				FixedNamePatternsNames.Add(qName);
				List<Pattern> list2 = (FixedNamePatterns[qName] = new List<Pattern>());
				value = list2;
			}
			value.Add(pattern);
		}
	}
	internal class MatcherBuilder
	{
		private XPathQilFactory f;

		private ReferenceReplacer refReplacer;

		private InvokeGenerator invkGen;

		private const int NoMatch = -1;

		private int priority = -1;

		private PatternBag elementPatterns = new PatternBag();

		private PatternBag attributePatterns = new PatternBag();

		private List<Pattern> textPatterns = new List<Pattern>();

		private List<Pattern> documentPatterns = new List<Pattern>();

		private List<Pattern> commentPatterns = new List<Pattern>();

		private PatternBag piPatterns = new PatternBag();

		private List<Pattern> heterogenousPatterns = new List<Pattern>();

		private List<List<TemplateMatch>> allMatches = new List<List<TemplateMatch>>();

		public MatcherBuilder(XPathQilFactory f, ReferenceReplacer refReplacer, InvokeGenerator invkGen)
		{
			this.f = f;
			this.refReplacer = refReplacer;
			this.invkGen = invkGen;
		}

		private void Clear()
		{
			priority = -1;
			elementPatterns.Clear();
			attributePatterns.Clear();
			textPatterns.Clear();
			documentPatterns.Clear();
			commentPatterns.Clear();
			piPatterns.Clear();
			heterogenousPatterns.Clear();
			allMatches.Clear();
		}

		private void AddPatterns(List<TemplateMatch> matches)
		{
			foreach (TemplateMatch match in matches)
			{
				Pattern pattern = new Pattern(match, ++priority);
				switch (match.NodeKind)
				{
				case XmlNodeKindFlags.Element:
					elementPatterns.Add(pattern);
					break;
				case XmlNodeKindFlags.Attribute:
					attributePatterns.Add(pattern);
					break;
				case XmlNodeKindFlags.Text:
					textPatterns.Add(pattern);
					break;
				case XmlNodeKindFlags.Document:
					documentPatterns.Add(pattern);
					break;
				case XmlNodeKindFlags.Comment:
					commentPatterns.Add(pattern);
					break;
				case XmlNodeKindFlags.PI:
					piPatterns.Add(pattern);
					break;
				default:
					heterogenousPatterns.Add(pattern);
					break;
				}
			}
		}

		private void CollectPatternsInternal(Stylesheet sheet, QilName mode)
		{
			Stylesheet[] imports = sheet.Imports;
			foreach (Stylesheet sheet2 in imports)
			{
				CollectPatternsInternal(sheet2, mode);
			}
			if (sheet.TemplateMatches.TryGetValue(mode, out var value))
			{
				AddPatterns(value);
				allMatches.Add(value);
			}
		}

		public void CollectPatterns(StylesheetLevel sheet, QilName mode)
		{
			Clear();
			Stylesheet[] imports = sheet.Imports;
			foreach (Stylesheet sheet2 in imports)
			{
				CollectPatternsInternal(sheet2, mode);
			}
		}

		private QilNode MatchPattern(QilIterator it, TemplateMatch match)
		{
			QilNode condition = match.Condition;
			if (condition == null)
			{
				return f.True();
			}
			condition = condition.DeepClone(f.BaseFactory);
			return refReplacer.Replace(condition, match.Iterator, it);
		}

		private QilNode MatchPatterns(QilIterator it, List<Pattern> patternList)
		{
			QilNode qilNode = f.Int32(-1);
			foreach (Pattern pattern in patternList)
			{
				qilNode = f.Conditional(MatchPattern(it, pattern.Match), f.Int32(pattern.Priority), qilNode);
			}
			return qilNode;
		}

		private QilNode MatchPatterns(QilIterator it, XmlQueryType xt, List<Pattern> patternList, QilNode otherwise)
		{
			if (patternList.Count == 0)
			{
				return otherwise;
			}
			return f.Conditional(f.IsType(it, xt), MatchPatterns(it, patternList), otherwise);
		}

		private bool IsNoMatch(QilNode matcher)
		{
			if (matcher.NodeType == QilNodeType.LiteralInt32)
			{
				return true;
			}
			return false;
		}

		private QilNode MatchPatternsWhosePriorityGreater(QilIterator it, List<Pattern> patternList, QilNode matcher)
		{
			if (patternList.Count == 0)
			{
				return matcher;
			}
			if (IsNoMatch(matcher))
			{
				return MatchPatterns(it, patternList);
			}
			QilIterator qilIterator = f.Let(matcher);
			QilNode qilNode = f.Int32(-1);
			int num = -1;
			foreach (Pattern pattern in patternList)
			{
				if (pattern.Priority > num + 1)
				{
					qilNode = f.Conditional(f.Gt(qilIterator, f.Int32(num)), qilIterator, qilNode);
				}
				qilNode = f.Conditional(MatchPattern(it, pattern.Match), f.Int32(pattern.Priority), qilNode);
				num = pattern.Priority;
			}
			if (num != priority)
			{
				qilNode = f.Conditional(f.Gt(qilIterator, f.Int32(num)), qilIterator, qilNode);
			}
			return f.Loop(qilIterator, qilNode);
		}

		private QilNode MatchPatterns(QilIterator it, XmlQueryType xt, PatternBag patternBag, QilNode otherwise)
		{
			if (patternBag.FixedNamePatternsNames.Count == 0)
			{
				return MatchPatterns(it, xt, patternBag.NonFixedNamePatterns, otherwise);
			}
			QilNode qilNode = f.Int32(-1);
			foreach (QilName fixedNamePatternsName in patternBag.FixedNamePatternsNames)
			{
				qilNode = f.Conditional(f.Eq(f.NameOf(it), fixedNamePatternsName.ShallowClone(f.BaseFactory)), MatchPatterns(it, patternBag.FixedNamePatterns[fixedNamePatternsName]), qilNode);
			}
			qilNode = MatchPatternsWhosePriorityGreater(it, patternBag.NonFixedNamePatterns, qilNode);
			return f.Conditional(f.IsType(it, xt), qilNode, otherwise);
		}

		public QilNode BuildMatcher(QilIterator it, IList<XslNode> actualArgs, QilNode otherwise)
		{
			QilNode otherwise2 = f.Int32(-1);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.PI, piPatterns, otherwise2);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.Comment, commentPatterns, otherwise2);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.Document, documentPatterns, otherwise2);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.Text, textPatterns, otherwise2);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.Attribute, attributePatterns, otherwise2);
			otherwise2 = MatchPatterns(it, XmlQueryTypeFactory.Element, elementPatterns, otherwise2);
			otherwise2 = MatchPatternsWhosePriorityGreater(it, heterogenousPatterns, otherwise2);
			if (IsNoMatch(otherwise2))
			{
				return otherwise;
			}
			QilNode[] array = new QilNode[priority + 2];
			int num = -1;
			foreach (List<TemplateMatch> allMatch in allMatches)
			{
				foreach (TemplateMatch item in allMatch)
				{
					array[++num] = invkGen.GenerateInvoke(item.TemplateFunction, actualArgs);
				}
			}
			array[++num] = otherwise;
			return f.Choice(otherwise2, f.BranchList(array));
		}
	}
	internal class OutputScopeManager
	{
		public struct ScopeReord
		{
			public int scopeCount;

			public string prefix;

			public string nsUri;
		}

		private ScopeReord[] records = new ScopeReord[32];

		private int lastRecord;

		private int lastScopes;

		public OutputScopeManager()
		{
			Reset();
		}

		public void Reset()
		{
			records[0].prefix = null;
			records[0].nsUri = null;
			PushScope();
		}

		public void PushScope()
		{
			lastScopes++;
		}

		public void PopScope()
		{
			if (0 < lastScopes)
			{
				lastScopes--;
				return;
			}
			while (records[--lastRecord].scopeCount == 0)
			{
			}
			lastScopes = records[lastRecord].scopeCount;
			lastScopes--;
		}

		public void AddNamespace(string prefix, string uri)
		{
			AddRecord(prefix, uri);
		}

		private void AddRecord(string prefix, string uri)
		{
			records[lastRecord].scopeCount = lastScopes;
			lastRecord++;
			if (lastRecord == records.Length)
			{
				ScopeReord[] destinationArray = new ScopeReord[lastRecord * 2];
				Array.Copy(records, 0, destinationArray, 0, lastRecord);
				records = destinationArray;
			}
			lastScopes = 0;
			records[lastRecord].prefix = prefix;
			records[lastRecord].nsUri = uri;
		}

		public void InvalidateAllPrefixes()
		{
			if (records[lastRecord].prefix != null)
			{
				AddRecord(null, null);
			}
		}

		public void InvalidateNonDefaultPrefixes()
		{
			string text = LookupNamespace(string.Empty);
			if (text == null)
			{
				InvalidateAllPrefixes();
			}
			else if (records[lastRecord].prefix.Length != 0 || records[lastRecord - 1].prefix != null)
			{
				AddRecord(null, null);
				AddRecord(string.Empty, text);
			}
		}

		public string LookupNamespace(string prefix)
		{
			int num = lastRecord;
			while (records[num].prefix != null)
			{
				if (records[num].prefix == prefix)
				{
					return records[num].nsUri;
				}
				num--;
			}
			return null;
		}
	}
	internal class ReferenceReplacer : QilReplaceVisitor
	{
		private QilReference lookFor;

		private QilReference replaceBy;

		public ReferenceReplacer(QilFactory f)
			: base(f)
		{
		}

		public QilNode Replace(QilNode expr, QilReference lookFor, QilReference replaceBy)
		{
			QilDepthChecker.Check(expr);
			this.lookFor = lookFor;
			this.replaceBy = replaceBy;
			return VisitAssumeReference(expr);
		}

		protected override QilNode VisitReference(QilNode n)
		{
			if (n != lookFor)
			{
				return n;
			}
			return replaceBy;
		}
	}
	internal class QilGenerator : IErrorHelper, IXPathEnvironment, IFocus
	{
		private class VariableHelper
		{
			private Stack<QilIterator> vars = new Stack<QilIterator>();

			private XPathQilFactory f;

			public VariableHelper(XPathQilFactory f)
			{
				this.f = f;
			}

			public int StartVariables()
			{
				return vars.Count;
			}

			public void AddVariable(QilIterator let)
			{
				vars.Push(let);
			}

			public QilNode FinishVariables(QilNode node, int varScope)
			{
				int num = vars.Count - varScope;
				while (num-- != 0)
				{
					node = f.Loop(vars.Pop(), node);
				}
				return node;
			}

			[Conditional("DEBUG")]
			public void CheckEmpty()
			{
			}
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct ThrowErrorHelper : IErrorHelper
		{
			public void ReportError(string res, params string[] args)
			{
				throw new XslLoadException("Xml_UserException", res);
			}

			public void ReportWarning(string res, params string[] args)
			{
			}
		}

		public enum FuncId
		{
			Current,
			Document,
			Key,
			FormatNumber,
			UnparsedEntityUri,
			GenerateId,
			SystemProperty,
			ElementAvailable,
			FunctionAvailable
		}

		private CompilerScopeManager<QilIterator> scope;

		private OutputScopeManager outputScope;

		private HybridDictionary prefixesInUse;

		private XsltQilFactory f;

		private XPathBuilder xpathBuilder;

		private XPathParser<QilNode> xpathParser;

		private XPathPatternBuilder ptrnBuilder;

		private XPathPatternParser ptrnParser;

		private ReferenceReplacer refReplacer;

		private KeyMatchBuilder keyMatchBuilder;

		private InvokeGenerator invkGen;

		private MatcherBuilder matcherBuilder;

		private QilStrConcatenator strConcat;

		private VariableHelper varHelper;

		private Compiler compiler;

		private QilList functions;

		private QilFunction generalKey;

		private bool formatNumberDynamicUsed;

		private QilList extPars;

		private QilList gloVars;

		private QilList nsVars;

		private XmlQueryType elementOrDocumentType;

		private XmlQueryType textOrAttributeType;

		private XslNode lastScope;

		private XslVersion xslVersion;

		private QilName nameCurrent;

		private QilName namePosition;

		private QilName nameLast;

		private QilName nameNamespaces;

		private QilName nameInit;

		private SingletonFocus singlFocus;

		private FunctionFocus funcFocus;

		private LoopFocus curLoop;

		private int formatterCnt;

		private readonly StringBuilder unescapedText = new StringBuilder();

		private static readonly char[] curlyBraces = new char[2] { '{', '}' };

		private const XmlNodeKindFlags InvalidatingNodes = XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Namespace;

		private bool allowVariables = true;

		private bool allowCurrent = true;

		private bool allowKey = true;

		private static readonly XmlTypeCode[] argFnDocument = new XmlTypeCode[2]
		{
			XmlTypeCode.Item,
			XmlTypeCode.Node
		};

		private static readonly XmlTypeCode[] argFnKey = new XmlTypeCode[2]
		{
			XmlTypeCode.String,
			XmlTypeCode.Item
		};

		private static readonly XmlTypeCode[] argFnFormatNumber = new XmlTypeCode[3]
		{
			XmlTypeCode.Double,
			XmlTypeCode.String,
			XmlTypeCode.String
		};

		public static Dictionary<string, XPathBuilder.FunctionInfo<FuncId>> FunctionTable = CreateFunctionTable();

		private bool IsDebug => compiler.IsDebug;

		private bool EvaluateFuncCalls => !IsDebug;

		private bool InferXPathTypes => !IsDebug;

		XPathQilFactory IXPathEnvironment.Factory => f;

		public static QilExpression CompileStylesheet(Compiler compiler)
		{
			return new QilGenerator(compiler.IsDebug).Compile(compiler);
		}

		private QilGenerator(bool debug)
		{
			scope = new CompilerScopeManager<QilIterator>();
			outputScope = new OutputScopeManager();
			prefixesInUse = new HybridDictionary();
			f = new XsltQilFactory(new QilFactory(), debug);
			xpathBuilder = new XPathBuilder(this);
			xpathParser = new XPathParser<QilNode>();
			ptrnBuilder = new XPathPatternBuilder(this);
			ptrnParser = new XPathPatternParser();
			refReplacer = new ReferenceReplacer(f.BaseFactory);
			invkGen = new InvokeGenerator(f, debug);
			matcherBuilder = new MatcherBuilder(f, refReplacer, invkGen);
			singlFocus = new SingletonFocus(f);
			funcFocus = default(FunctionFocus);
			curLoop = new LoopFocus(f);
			strConcat = new QilStrConcatenator(f);
			varHelper = new VariableHelper(f);
			elementOrDocumentType = XmlQueryTypeFactory.DocumentOrElement;
			textOrAttributeType = XmlQueryTypeFactory.NodeChoice(XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Text);
			nameCurrent = f.QName("current", "urn:schemas-microsoft-com:xslt-debug");
			namePosition = f.QName("position", "urn:schemas-microsoft-com:xslt-debug");
			nameLast = f.QName("last", "urn:schemas-microsoft-com:xslt-debug");
			nameNamespaces = f.QName("namespaces", "urn:schemas-microsoft-com:xslt-debug");
			nameInit = f.QName("init", "urn:schemas-microsoft-com:xslt-debug");
			formatterCnt = 0;
		}

		private QilExpression Compile(Compiler compiler)
		{
			this.compiler = compiler;
			functions = f.FunctionList();
			extPars = f.GlobalParameterList();
			gloVars = f.GlobalVariableList();
			nsVars = f.GlobalVariableList();
			compiler.Scripts.CompileScripts();
			new XslAstRewriter().Rewrite(compiler);
			if (!IsDebug)
			{
				new XslAstAnalyzer().Analyze(compiler);
			}
			CreateGlobalVarPars();
			try
			{
				CompileKeys();
				CompileAndSortMatches(compiler.Root.Imports[0]);
				PrecompileProtoTemplatesHeaders();
				CompileGlobalVariables();
				foreach (ProtoTemplate allTemplate in compiler.AllTemplates)
				{
					CompileProtoTemplate(allTemplate);
				}
			}
			catch (XslLoadException ex)
			{
				ex.SetSourceLineInfo(lastScope.SourceLine);
				throw;
			}
			catch (Exception ex2)
			{
				if (!XmlException.IsCatchableException(ex2))
				{
					throw;
				}
				throw new XslLoadException(ex2, lastScope.SourceLine);
			}
			CompileInitializationCode();
			QilNode root = CompileRootExpression(compiler.StartApplyTemplates);
			foreach (ProtoTemplate allTemplate2 in compiler.AllTemplates)
			{
				foreach (QilParameter argument in allTemplate2.Function.Arguments)
				{
					if (!IsDebug || argument.Name.Equals(nameNamespaces))
					{
						argument.DefaultValue = null;
					}
				}
			}
			Dictionary<string, Type> scriptClasses = compiler.Scripts.ScriptClasses;
			List<EarlyBoundInfo> list = new List<EarlyBoundInfo>(scriptClasses.Count);
			foreach (KeyValuePair<string, Type> item in scriptClasses)
			{
				if (item.Value != null)
				{
					list.Add(new EarlyBoundInfo(item.Key, item.Value));
				}
			}
			QilExpression qilExpression = f.QilExpression(root, f.BaseFactory);
			qilExpression.EarlyBoundTypes = list;
			qilExpression.FunctionList = functions;
			qilExpression.GlobalParameterList = extPars;
			qilExpression.GlobalVariableList = gloVars;
			qilExpression.WhitespaceRules = compiler.WhitespaceRules;
			qilExpression.IsDebug = IsDebug;
			qilExpression.DefaultWriterSettings = compiler.Output.Settings;
			QilDepthChecker.Check(qilExpression);
			return qilExpression;
		}

		private QilNode InvokeOnCurrentNodeChanged()
		{
			QilIterator qilIterator;
			return f.Loop(qilIterator = f.Let(f.InvokeOnCurrentNodeChanged(curLoop.GetCurrent())), f.Sequence());
		}

		[Conditional("DEBUG")]
		private void CheckSingletonFocus()
		{
		}

		private void CompileInitializationCode()
		{
			QilNode qilNode = f.Int32(0);
			if (formatNumberDynamicUsed || IsDebug)
			{
				bool flag = false;
				foreach (DecimalFormatDecl decimalFormat in compiler.DecimalFormats)
				{
					qilNode = f.Add(qilNode, f.InvokeRegisterDecimalFormat(decimalFormat));
					flag |= decimalFormat.Name == DecimalFormatDecl.Default.Name;
				}
				if (!flag)
				{
					qilNode = f.Add(qilNode, f.InvokeRegisterDecimalFormat(DecimalFormatDecl.Default));
				}
			}
			foreach (string key in compiler.Scripts.ScriptClasses.Keys)
			{
				qilNode = f.Add(qilNode, f.InvokeCheckScriptNamespace(key));
			}
			if (qilNode.NodeType == QilNodeType.Add)
			{
				QilFunction qilFunction = f.Function(f.FormalParameterList(), qilNode, f.True());
				qilFunction.DebugName = "Init";
				functions.Add(qilFunction);
				QilNode qilNode2 = f.Invoke(qilFunction, f.ActualParameterList());
				if (IsDebug)
				{
					qilNode2 = f.TypeAssert(qilNode2, XmlQueryTypeFactory.ItemS);
				}
				QilIterator qilIterator = f.Let(qilNode2);
				qilIterator.DebugName = nameInit.ToString();
				gloVars.Insert(0, qilIterator);
			}
		}

		private QilNode CompileRootExpression(XslNode applyTmpls)
		{
			singlFocus.SetFocus(SingletonFocusType.InitialContextNode);
			QilNode child = GenerateApply(compiler.Root, applyTmpls);
			singlFocus.SetFocus(null);
			return f.DocumentCtor(child);
		}

		private QilList EnterScope(XslNode node)
		{
			lastScope = node;
			xslVersion = node.XslVersion;
			if (scope.EnterScope(node.Namespaces))
			{
				return BuildDebuggerNamespaces();
			}
			return null;
		}

		private void ExitScope()
		{
			scope.ExitScope();
		}

		private QilList BuildDebuggerNamespaces()
		{
			if (IsDebug)
			{
				QilList qilList = f.BaseFactory.Sequence();
				CompilerScopeManager<QilIterator>.NamespaceEnumerator enumerator = scope.GetEnumerator();
				while (enumerator.MoveNext())
				{
					CompilerScopeManager<QilIterator>.ScopeRecord current = enumerator.Current;
					qilList.Add(f.NamespaceDecl(f.String(current.ncName), f.String(current.nsUri)));
				}
				return qilList;
			}
			return null;
		}

		private QilNode GetCurrentNode()
		{
			if (curLoop.IsFocusSet)
			{
				return curLoop.GetCurrent();
			}
			if (funcFocus.IsFocusSet)
			{
				return funcFocus.GetCurrent();
			}
			return singlFocus.GetCurrent();
		}

		private QilNode GetCurrentPosition()
		{
			if (curLoop.IsFocusSet)
			{
				return curLoop.GetPosition();
			}
			if (funcFocus.IsFocusSet)
			{
				return funcFocus.GetPosition();
			}
			return singlFocus.GetPosition();
		}

		private QilNode GetLastPosition()
		{
			if (curLoop.IsFocusSet)
			{
				return curLoop.GetLast();
			}
			if (funcFocus.IsFocusSet)
			{
				return funcFocus.GetLast();
			}
			return singlFocus.GetLast();
		}

		private XmlQueryType ChooseBestType(VarPar var)
		{
			if (IsDebug || !InferXPathTypes)
			{
				return XmlQueryTypeFactory.ItemS;
			}
			return (var.Flags & XslFlags.TypeFilter) switch
			{
				XslFlags.String => XmlQueryTypeFactory.StringX, 
				XslFlags.Number => XmlQueryTypeFactory.DoubleX, 
				XslFlags.Boolean => XmlQueryTypeFactory.BooleanX, 
				XslFlags.Node => XmlQueryTypeFactory.NodeNotRtf, 
				XslFlags.Nodeset => XmlQueryTypeFactory.NodeNotRtfS, 
				XslFlags.Rtf => XmlQueryTypeFactory.Node, 
				XslFlags.Node | XslFlags.Rtf => XmlQueryTypeFactory.Node, 
				XslFlags.Node | XslFlags.Nodeset => XmlQueryTypeFactory.NodeNotRtfS, 
				XslFlags.Nodeset | XslFlags.Rtf => XmlQueryTypeFactory.NodeS, 
				XslFlags.Node | XslFlags.Nodeset | XslFlags.Rtf => XmlQueryTypeFactory.NodeS, 
				_ => XmlQueryTypeFactory.ItemS, 
			};
		}

		private QilIterator GetNsVar(QilList nsList)
		{
			foreach (QilIterator nsVar in nsVars)
			{
				QilList qilList = (QilList)nsVar.Binding;
				if (qilList.Count != nsList.Count)
				{
					continue;
				}
				bool flag = true;
				for (int i = 0; i < nsList.Count; i++)
				{
					if (((QilLiteral)((QilBinary)nsList[i]).Right).Value != ((QilLiteral)((QilBinary)qilList[i]).Right).Value || ((QilLiteral)((QilBinary)nsList[i]).Left).Value != ((QilLiteral)((QilBinary)qilList[i]).Left).Value)
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					return nsVar;
				}
			}
			QilIterator qilIterator2 = f.Let(nsList);
			qilIterator2.DebugName = f.QName("ns" + nsVars.Count, "urn:schemas-microsoft-com:xslt-debug").ToString();
			gloVars.Add(qilIterator2);
			nsVars.Add(qilIterator2);
			return qilIterator2;
		}

		private void PrecompileProtoTemplatesHeaders()
		{
			List<VarPar> list = null;
			Dictionary<VarPar, Template> dictionary = null;
			Dictionary<VarPar, QilFunction> dictionary2 = null;
			foreach (ProtoTemplate allTemplate in compiler.AllTemplates)
			{
				QilList qilList = f.FormalParameterList();
				XslFlags xslFlags = ((!IsDebug) ? allTemplate.Flags : XslFlags.FocusFilter);
				QilList qilList2 = EnterScope(allTemplate);
				if ((xslFlags & XslFlags.Current) != 0)
				{
					qilList.Add(CreateXslParam(CloneName(nameCurrent), XmlQueryTypeFactory.NodeNotRtf));
				}
				if ((xslFlags & XslFlags.Position) != 0)
				{
					qilList.Add(CreateXslParam(CloneName(namePosition), XmlQueryTypeFactory.DoubleX));
				}
				if ((xslFlags & XslFlags.Last) != 0)
				{
					qilList.Add(CreateXslParam(CloneName(nameLast), XmlQueryTypeFactory.DoubleX));
				}
				if (IsDebug && qilList2 != null)
				{
					QilParameter qilParameter = CreateXslParam(CloneName(nameNamespaces), XmlQueryTypeFactory.NamespaceS);
					qilParameter.DefaultValue = GetNsVar(qilList2);
					qilList.Add(qilParameter);
				}
				if (allTemplate is Template template)
				{
					funcFocus.StartFocus(qilList, xslFlags);
					for (int i = 0; i < allTemplate.Content.Count; i++)
					{
						XslNode xslNode = allTemplate.Content[i];
						if (xslNode.NodeType == XslNodeType.Text)
						{
							continue;
						}
						if (xslNode.NodeType != XslNodeType.Param)
						{
							break;
						}
						VarPar varPar = (VarPar)xslNode;
						EnterScope(varPar);
						if (scope.IsLocalVariable(varPar.Name.LocalName, varPar.Name.NamespaceUri))
						{
							ReportError("Xslt_DupLocalVariable", varPar.Name.QualifiedName);
						}
						QilParameter qilParameter2 = CreateXslParam(varPar.Name, ChooseBestType(varPar));
						if (IsDebug)
						{
							qilParameter2.Annotation = varPar;
						}
						else if ((varPar.DefValueFlags & XslFlags.HasCalls) == 0)
						{
							qilParameter2.DefaultValue = CompileVarParValue(varPar);
						}
						else
						{
							QilList qilList3 = f.FormalParameterList();
							QilList qilList4 = f.ActualParameterList();
							for (int j = 0; j < qilList.Count; j++)
							{
								QilParameter qilParameter3 = f.Parameter(qilList[j].XmlType);
								qilParameter3.DebugName = ((QilParameter)qilList[j]).DebugName;
								qilParameter3.Name = CloneName(((QilParameter)qilList[j]).Name);
								SetLineInfo(qilParameter3, qilList[j].SourceLine);
								qilList3.Add(qilParameter3);
								qilList4.Add(qilList[j]);
							}
							varPar.Flags |= template.Flags & XslFlags.FocusFilter;
							QilFunction qilFunction = f.Function(qilList3, f.Boolean((varPar.DefValueFlags & XslFlags.SideEffects) != 0), ChooseBestType(varPar));
							qilFunction.SourceLine = SourceLineInfo.NoSource;
							qilFunction.DebugName = "<xsl:param name=\"" + varPar.Name.QualifiedName + "\">";
							qilParameter2.DefaultValue = f.Invoke(qilFunction, qilList4);
							if (list == null)
							{
								list = new List<VarPar>();
								dictionary = new Dictionary<VarPar, Template>();
								dictionary2 = new Dictionary<VarPar, QilFunction>();
							}
							list.Add(varPar);
							dictionary.Add(varPar, template);
							dictionary2.Add(varPar, qilFunction);
						}
						SetLineInfo(qilParameter2, varPar.SourceLine);
						ExitScope();
						scope.AddVariable(varPar.Name, qilParameter2);
						qilList.Add(qilParameter2);
					}
					funcFocus.StopFocus();
				}
				ExitScope();
				allTemplate.Function = f.Function(qilList, f.Boolean((allTemplate.Flags & XslFlags.SideEffects) != 0), (allTemplate is AttributeSet) ? XmlQueryTypeFactory.AttributeS : XmlQueryTypeFactory.NodeNotRtfS);
				allTemplate.Function.DebugName = allTemplate.GetDebugName();
				SetLineInfo(allTemplate.Function, allTemplate.SourceLine ?? SourceLineInfo.NoSource);
				functions.Add(allTemplate.Function);
			}
			if (list == null)
			{
				return;
			}
			foreach (VarPar item in list)
			{
				Template node = dictionary[item];
				QilFunction qilFunction2 = dictionary2[item];
				funcFocus.StartFocus(qilFunction2.Arguments, item.Flags);
				EnterScope(node);
				EnterScope(item);
				foreach (QilParameter argument in qilFunction2.Arguments)
				{
					scope.AddVariable(argument.Name, argument);
				}
				qilFunction2.Definition = CompileVarParValue(item);
				SetLineInfo(qilFunction2.Definition, item.SourceLine);
				ExitScope();
				ExitScope();
				funcFocus.StopFocus();
				functions.Add(qilFunction2);
			}
		}

		private QilParameter CreateXslParam(QilName name, XmlQueryType xt)
		{
			QilParameter qilParameter = f.Parameter(xt);
			qilParameter.DebugName = name.ToString();
			qilParameter.Name = name;
			return qilParameter;
		}

		private void CompileProtoTemplate(ProtoTemplate tmpl)
		{
			EnterScope(tmpl);
			funcFocus.StartFocus(tmpl.Function.Arguments, (!IsDebug) ? tmpl.Flags : XslFlags.FocusFilter);
			foreach (QilParameter argument in tmpl.Function.Arguments)
			{
				if (argument.Name.NamespaceUri != "urn:schemas-microsoft-com:xslt-debug")
				{
					if (IsDebug)
					{
						VarPar node = (VarPar)argument.Annotation;
						QilList nsList = EnterScope(node);
						argument.DefaultValue = CompileVarParValue(node);
						ExitScope();
						argument.DefaultValue = SetDebugNs(argument.DefaultValue, nsList);
					}
					scope.AddVariable(argument.Name, argument);
				}
			}
			tmpl.Function.Definition = CompileInstructions(tmpl.Content);
			funcFocus.StopFocus();
			ExitScope();
		}

		private QilList InstructionList()
		{
			return f.BaseFactory.Sequence();
		}

		private QilNode CompileInstructions(IList<XslNode> instructions)
		{
			return CompileInstructions(instructions, 0, InstructionList());
		}

		private QilNode CompileInstructions(IList<XslNode> instructions, int from)
		{
			return CompileInstructions(instructions, from, InstructionList());
		}

		private QilNode CompileInstructions(IList<XslNode> instructions, QilList content)
		{
			return CompileInstructions(instructions, 0, content);
		}

		private QilNode CompileInstructions(IList<XslNode> instructions, int from, QilList content)
		{
			for (int i = from; i < instructions.Count; i++)
			{
				XslNode xslNode = instructions[i];
				XslNodeType nodeType = xslNode.NodeType;
				if (nodeType == XslNodeType.Param)
				{
					continue;
				}
				QilList nsList = EnterScope(xslNode);
				QilNode qilNode = nodeType switch
				{
					XslNodeType.ApplyImports => CompileApplyImports(xslNode), 
					XslNodeType.ApplyTemplates => CompileApplyTemplates((XslNodeEx)xslNode), 
					XslNodeType.Attribute => CompileAttribute((NodeCtor)xslNode), 
					XslNodeType.CallTemplate => CompileCallTemplate((XslNodeEx)xslNode), 
					XslNodeType.Choose => CompileChoose(xslNode), 
					XslNodeType.Comment => CompileComment(xslNode), 
					XslNodeType.Copy => CompileCopy(xslNode), 
					XslNodeType.CopyOf => CompileCopyOf(xslNode), 
					XslNodeType.Element => CompileElement((NodeCtor)xslNode), 
					XslNodeType.Error => CompileError(xslNode), 
					XslNodeType.ForEach => CompileForEach((XslNodeEx)xslNode), 
					XslNodeType.If => CompileIf(xslNode), 
					XslNodeType.List => CompileList(xslNode), 
					XslNodeType.LiteralAttribute => CompileLiteralAttribute(xslNode), 
					XslNodeType.LiteralElement => CompileLiteralElement(xslNode), 
					XslNodeType.Message => CompileMessage(xslNode), 
					XslNodeType.Nop => CompileNop(xslNode), 
					XslNodeType.Number => CompileNumber((Number)xslNode), 
					XslNodeType.PI => CompilePI(xslNode), 
					XslNodeType.Text => CompileText((Text)xslNode), 
					XslNodeType.UseAttributeSet => CompileUseAttributeSet(xslNode), 
					XslNodeType.ValueOf => CompileValueOf(xslNode), 
					XslNodeType.ValueOfDoe => CompileValueOfDoe(xslNode), 
					XslNodeType.Variable => CompileVariable(xslNode), 
					_ => null, 
				};
				ExitScope();
				if (qilNode.NodeType != QilNodeType.Sequence || qilNode.Count != 0)
				{
					if (nodeType != XslNodeType.LiteralAttribute && nodeType != XslNodeType.UseAttributeSet)
					{
						SetLineInfoCheck(qilNode, xslNode.SourceLine);
					}
					qilNode = SetDebugNs(qilNode, nsList);
					if (nodeType == XslNodeType.Variable)
					{
						QilIterator qilIterator = f.Let(qilNode);
						qilIterator.DebugName = xslNode.Name.ToString();
						scope.AddVariable(xslNode.Name, qilIterator);
						qilNode = f.Loop(qilIterator, CompileInstructions(instructions, i + 1));
						i = instructions.Count;
					}
					content.Add(qilNode);
				}
			}
			if (!IsDebug && content.Count == 1)
			{
				return content[0];
			}
			return content;
		}

		private QilNode CompileList(XslNode node)
		{
			return CompileInstructions(node.Content);
		}

		private QilNode CompileNop(XslNode node)
		{
			return f.Nop(f.Sequence());
		}

		private void AddNsDecl(QilList content, string prefix, string nsUri)
		{
			if (!(outputScope.LookupNamespace(prefix) == nsUri))
			{
				outputScope.AddNamespace(prefix, nsUri);
				content.Add(f.NamespaceDecl(f.String(prefix), f.String(nsUri)));
			}
		}

		private QilNode CompileLiteralElement(XslNode node)
		{
			bool flag = true;
			while (true)
			{
				prefixesInUse.Clear();
				QilName name = node.Name;
				string prefix = name.Prefix;
				string nsUri = name.NamespaceUri;
				compiler.ApplyNsAliases(ref prefix, ref nsUri);
				if (flag)
				{
					prefixesInUse.Add(prefix, nsUri);
				}
				else
				{
					prefix = name.Prefix;
				}
				outputScope.PushScope();
				QilList content = InstructionList();
				CompilerScopeManager<QilIterator>.NamespaceEnumerator enumerator = scope.GetEnumerator();
				while (true)
				{
					if (enumerator.MoveNext())
					{
						CompilerScopeManager<QilIterator>.ScopeRecord current = enumerator.Current;
						string prefix2 = current.ncName;
						string nsUri2 = current.nsUri;
						if (!(nsUri2 != "http://www.w3.org/1999/XSL/Transform") || scope.IsExNamespace(nsUri2))
						{
							continue;
						}
						compiler.ApplyNsAliases(ref prefix2, ref nsUri2);
						if (flag)
						{
							if (prefixesInUse.Contains(prefix2))
							{
								if ((string)prefixesInUse[prefix2] != nsUri2)
								{
									break;
								}
							}
							else
							{
								prefixesInUse.Add(prefix2, nsUri2);
							}
						}
						else
						{
							prefix2 = current.ncName;
						}
						AddNsDecl(content, prefix2, nsUri2);
						continue;
					}
					QilNode content2 = CompileInstructions(node.Content, content);
					outputScope.PopScope();
					name.Prefix = prefix;
					name.NamespaceUri = nsUri;
					return f.ElementCtor(name, content2);
				}
				outputScope.PopScope();
				flag = false;
			}
		}

		private QilNode CompileElement(NodeCtor node)
		{
			QilNode qilNode = CompileStringAvt(node.NsAvt);
			QilNode qilNode2 = CompileStringAvt(node.NameAvt);
			QilNode name;
			if (qilNode2.NodeType != QilNodeType.LiteralString || (qilNode != null && qilNode.NodeType != QilNodeType.LiteralString))
			{
				name = ((qilNode == null) ? ResolveQNameDynamic(ignoreDefaultNs: false, qilNode2) : f.StrParseQName(qilNode2, qilNode));
			}
			else
			{
				string qname = (QilLiteral)qilNode2;
				string prefix;
				string localName;
				bool flag = compiler.ParseQName(qname, out prefix, out localName, this);
				string uri = ((qilNode != null) ? ((string)(QilLiteral)qilNode) : (flag ? ResolvePrefix(ignoreDefaultNs: false, prefix) : compiler.CreatePhantomNamespace()));
				name = f.QName(localName, uri, prefix);
			}
			outputScope.PushScope();
			outputScope.InvalidateAllPrefixes();
			QilNode content = CompileInstructions(node.Content);
			outputScope.PopScope();
			return f.ElementCtor(name, content);
		}

		private QilNode CompileLiteralAttribute(XslNode node)
		{
			QilName name = node.Name;
			string prefix = name.Prefix;
			string nsUri = name.NamespaceUri;
			if (prefix.Length != 0)
			{
				compiler.ApplyNsAliases(ref prefix, ref nsUri);
			}
			name.Prefix = prefix;
			name.NamespaceUri = nsUri;
			return f.AttributeCtor(name, CompileTextAvt(node.Select));
		}

		private QilNode CompileAttribute(NodeCtor node)
		{
			QilNode qilNode = CompileStringAvt(node.NsAvt);
			QilNode qilNode2 = CompileStringAvt(node.NameAvt);
			bool flag = false;
			QilNode name;
			if (qilNode2.NodeType != QilNodeType.LiteralString || (qilNode != null && qilNode.NodeType != QilNodeType.LiteralString))
			{
				name = ((qilNode == null) ? ResolveQNameDynamic(ignoreDefaultNs: true, qilNode2) : f.StrParseQName(qilNode2, qilNode));
			}
			else
			{
				string text = (QilLiteral)qilNode2;
				string prefix;
				string localName;
				bool flag2 = compiler.ParseQName(text, out prefix, out localName, this);
				string text2;
				if (qilNode == null)
				{
					text2 = (flag2 ? ResolvePrefix(ignoreDefaultNs: true, prefix) : compiler.CreatePhantomNamespace());
				}
				else
				{
					text2 = (QilLiteral)qilNode;
					flag = true;
				}
				if (text == "xmlns" || (localName == "xmlns" && text2.Length == 0))
				{
					ReportError("Xslt_XmlnsAttr", "name", text);
				}
				name = f.QName(localName, text2, prefix);
			}
			if (flag)
			{
				outputScope.InvalidateNonDefaultPrefixes();
			}
			return f.AttributeCtor(name, CompileInstructions(node.Content));
		}

		private QilNode ExtractText(string source, ref int pos)
		{
			int num = pos;
			unescapedText.Length = 0;
			int i;
			for (i = pos; i < source.Length; i++)
			{
				char c = source[i];
				if (c != '{' && c != '}')
				{
					continue;
				}
				if (i + 1 < source.Length && source[i + 1] == c)
				{
					i++;
					unescapedText.Append(source, num, i - num);
					num = i + 1;
					continue;
				}
				if (c == '{')
				{
					break;
				}
				pos = source.Length;
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportError("Xslt_SingleRightBraceInAvt", source);
					return null;
				}
				return f.Error(lastScope.SourceLine, "Xslt_SingleRightBraceInAvt", source);
			}
			pos = i;
			if (unescapedText.Length == 0)
			{
				if (i <= num)
				{
					return null;
				}
				return f.String(source.Substring(num, i - num));
			}
			unescapedText.Append(source, num, i - num);
			return f.String(unescapedText.ToString());
		}

		private QilNode CompileAvt(string source)
		{
			QilList qilList = f.BaseFactory.Sequence();
			int pos = 0;
			while (pos < source.Length)
			{
				QilNode qilNode = ExtractText(source, ref pos);
				if (qilNode != null)
				{
					qilList.Add(qilNode);
				}
				if (pos < source.Length)
				{
					pos++;
					QilNode n = CompileXPathExpressionWithinAvt(source, ref pos);
					qilList.Add(f.ConvertToString(n));
				}
			}
			if (qilList.Count == 1)
			{
				return qilList[0];
			}
			return qilList;
		}

		private QilNode CompileStringAvt(string avt)
		{
			if (avt == null)
			{
				return null;
			}
			if (avt.IndexOfAny(curlyBraces) == -1)
			{
				return f.String(avt);
			}
			return f.StrConcat(CompileAvt(avt));
		}

		private QilNode CompileTextAvt(string avt)
		{
			if (avt.IndexOfAny(curlyBraces) == -1)
			{
				return f.TextCtor(f.String(avt));
			}
			QilNode qilNode = CompileAvt(avt);
			if (qilNode.NodeType == QilNodeType.Sequence)
			{
				QilList qilList = InstructionList();
				{
					foreach (QilNode item in qilNode)
					{
						qilList.Add(f.TextCtor(item));
					}
					return qilList;
				}
			}
			return f.TextCtor(qilNode);
		}

		private QilNode CompileText(Text node)
		{
			if (node.Hints == SerializationHints.None)
			{
				return f.TextCtor(f.String(node.Select));
			}
			return f.RawTextCtor(f.String(node.Select));
		}

		private QilNode CompilePI(XslNode node)
		{
			QilNode qilNode = CompileStringAvt(node.Select);
			if (qilNode.NodeType == QilNodeType.LiteralString)
			{
				string name = (QilLiteral)qilNode;
				compiler.ValidatePiName(name, this);
			}
			return f.PICtor(qilNode, CompileInstructions(node.Content));
		}

		private QilNode CompileComment(XslNode node)
		{
			return f.CommentCtor(CompileInstructions(node.Content));
		}

		private QilNode CompileError(XslNode node)
		{
			return f.Error(f.String(node.Select));
		}

		private QilNode WrapLoopBody(ISourceLineInfo before, QilNode expr, ISourceLineInfo after)
		{
			if (IsDebug)
			{
				return f.Sequence(SetLineInfo(InvokeOnCurrentNodeChanged(), before), expr, SetLineInfo(f.Nop(f.Sequence()), after));
			}
			return expr;
		}

		private QilNode CompileForEach(XslNodeEx node)
		{
			IList<XslNode> content = node.Content;
			LoopFocus parentLoop = curLoop;
			QilIterator focus = f.For(CompileNodeSetExpression(node.Select));
			curLoop.SetFocus(focus);
			int varScope = varHelper.StartVariables();
			curLoop.Sort(CompileSorts(content, ref parentLoop));
			QilNode expr = CompileInstructions(content);
			expr = WrapLoopBody(node.ElemNameLi, expr, node.EndTagLi);
			expr = AddCurrentPositionLast(expr);
			expr = curLoop.ConstructLoop(expr);
			expr = varHelper.FinishVariables(expr, varScope);
			curLoop = parentLoop;
			return expr;
		}

		private QilNode CompileApplyTemplates(XslNodeEx node)
		{
			IList<XslNode> content = node.Content;
			int varScope = varHelper.StartVariables();
			QilIterator qilIterator = f.Let(CompileNodeSetExpression(node.Select));
			varHelper.AddVariable(qilIterator);
			for (int i = 0; i < content.Count; i++)
			{
				if (content[i] is VarPar varPar)
				{
					CompileWithParam(varPar);
					QilNode value = varPar.Value;
					if (IsDebug || (!(value is QilIterator) && !(value is QilLiteral)))
					{
						QilIterator qilIterator2 = f.Let(value);
						qilIterator2.DebugName = f.QName("with-param " + varPar.Name.QualifiedName, "urn:schemas-microsoft-com:xslt-debug").ToString();
						varHelper.AddVariable(qilIterator2);
						varPar.Value = qilIterator2;
					}
				}
			}
			LoopFocus parentLoop = curLoop;
			QilIterator focus = f.For(qilIterator);
			curLoop.SetFocus(focus);
			curLoop.Sort(CompileSorts(content, ref parentLoop));
			QilNode expr = GenerateApply(compiler.Root, node);
			expr = WrapLoopBody(node.ElemNameLi, expr, node.EndTagLi);
			expr = AddCurrentPositionLast(expr);
			expr = curLoop.ConstructLoop(expr);
			curLoop = parentLoop;
			return varHelper.FinishVariables(expr, varScope);
		}

		private QilNode CompileApplyImports(XslNode node)
		{
			return GenerateApply((StylesheetLevel)node.Arg, node);
		}

		private QilNode CompileCallTemplate(XslNodeEx node)
		{
			int varScope = varHelper.StartVariables();
			IList<XslNode> content = node.Content;
			foreach (VarPar item in content)
			{
				CompileWithParam(item);
				if (IsDebug)
				{
					QilNode value = item.Value;
					QilIterator qilIterator = f.Let(value);
					qilIterator.DebugName = f.QName("with-param " + item.Name.QualifiedName, "urn:schemas-microsoft-com:xslt-debug").ToString();
					varHelper.AddVariable(qilIterator);
					item.Value = qilIterator;
				}
			}
			QilNode qilNode;
			if (compiler.NamedTemplates.TryGetValue(node.Name, out var value2))
			{
				qilNode = invkGen.GenerateInvoke(value2.Function, AddRemoveImplicitArgs(node.Content, value2.Flags));
			}
			else
			{
				if (!compiler.IsPhantomName(node.Name))
				{
					compiler.ReportError(node.SourceLine, "Xslt_InvalidCallTemplate", node.Name.QualifiedName);
				}
				qilNode = f.Sequence();
			}
			if (content.Count > 0)
			{
				qilNode = SetLineInfo(qilNode, node.ElemNameLi);
			}
			qilNode = varHelper.FinishVariables(qilNode, varScope);
			if (IsDebug)
			{
				return f.Nop(qilNode);
			}
			return qilNode;
		}

		private QilNode CompileUseAttributeSet(XslNode node)
		{
			outputScope.InvalidateAllPrefixes();
			if (compiler.AttributeSets.TryGetValue(node.Name, out var value))
			{
				return invkGen.GenerateInvoke(value.Function, AddRemoveImplicitArgs(node.Content, value.Flags));
			}
			if (!compiler.IsPhantomName(node.Name))
			{
				compiler.ReportError(node.SourceLine, "Xslt_NoAttributeSet", node.Name.QualifiedName);
			}
			return f.Sequence();
		}

		private QilNode CompileCopy(XslNode copy)
		{
			QilNode currentNode = GetCurrentNode();
			if ((currentNode.XmlType.NodeKinds & (XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Namespace)) != 0)
			{
				outputScope.InvalidateAllPrefixes();
			}
			if (currentNode.XmlType.NodeKinds == XmlNodeKindFlags.Element)
			{
				QilList qilList = InstructionList();
				qilList.Add(f.XPathNamespace(currentNode));
				outputScope.PushScope();
				outputScope.InvalidateAllPrefixes();
				QilNode content = CompileInstructions(copy.Content, qilList);
				outputScope.PopScope();
				return f.ElementCtor(f.NameOf(currentNode), content);
			}
			if (currentNode.XmlType.NodeKinds == XmlNodeKindFlags.Document)
			{
				return CompileInstructions(copy.Content);
			}
			if ((currentNode.XmlType.NodeKinds & (XmlNodeKindFlags.Document | XmlNodeKindFlags.Element)) == 0)
			{
				return currentNode;
			}
			return f.XsltCopy(currentNode, CompileInstructions(copy.Content));
		}

		private QilNode CompileCopyOf(XslNode node)
		{
			QilNode qilNode = CompileXPathExpression(node.Select);
			if (qilNode.XmlType.IsNode)
			{
				if ((qilNode.XmlType.NodeKinds & (XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Namespace)) != 0)
				{
					outputScope.InvalidateAllPrefixes();
				}
				if (qilNode.XmlType.IsNotRtf && (qilNode.XmlType.NodeKinds & XmlNodeKindFlags.Document) == 0)
				{
					return qilNode;
				}
				if (qilNode.XmlType.IsSingleton)
				{
					return f.XsltCopyOf(qilNode);
				}
				QilIterator expr;
				return f.Loop(expr = f.For(qilNode), f.XsltCopyOf(expr));
			}
			if (qilNode.XmlType.IsAtomicValue)
			{
				return f.TextCtor(f.ConvertToString(qilNode));
			}
			outputScope.InvalidateAllPrefixes();
			QilIterator expr2;
			return f.Loop(expr2 = f.For(qilNode), f.Conditional(f.IsType(expr2, XmlQueryTypeFactory.Node), f.XsltCopyOf(f.TypeAssert(expr2, XmlQueryTypeFactory.Node)), f.TextCtor(f.XsltConvert(expr2, XmlQueryTypeFactory.StringX))));
		}

		private QilNode CompileValueOf(XslNode valueOf)
		{
			return f.TextCtor(f.ConvertToString(CompileXPathExpression(valueOf.Select)));
		}

		private QilNode CompileValueOfDoe(XslNode valueOf)
		{
			return f.RawTextCtor(f.ConvertToString(CompileXPathExpression(valueOf.Select)));
		}

		private QilNode CompileWhen(XslNode whenNode, QilNode otherwise)
		{
			return f.Conditional(f.ConvertToBoolean(CompileXPathExpression(whenNode.Select)), CompileInstructions(whenNode.Content), otherwise);
		}

		private QilNode CompileIf(XslNode ifNode)
		{
			return CompileWhen(ifNode, InstructionList());
		}

		private QilNode CompileChoose(XslNode node)
		{
			IList<XslNode> content = node.Content;
			QilNode qilNode = null;
			int num = content.Count - 1;
			while (0 <= num)
			{
				XslNode xslNode = content[num];
				QilList nsList = EnterScope(xslNode);
				qilNode = ((xslNode.NodeType != XslNodeType.Otherwise) ? CompileWhen(xslNode, qilNode ?? InstructionList()) : CompileInstructions(xslNode.Content));
				ExitScope();
				SetLineInfoCheck(qilNode, xslNode.SourceLine);
				qilNode = SetDebugNs(qilNode, nsList);
				num--;
			}
			if (qilNode == null)
			{
				return f.Sequence();
			}
			if (!IsDebug)
			{
				return qilNode;
			}
			return f.Sequence(qilNode);
		}

		private QilNode CompileMessage(XslNode node)
		{
			string uri = lastScope.SourceLine.Uri;
			QilNode n = f.RtfCtor(CompileInstructions(node.Content), f.String(uri));
			n = f.InvokeOuterXml(n);
			if (!(bool)node.Arg)
			{
				return f.Warning(n);
			}
			QilIterator text;
			return f.Loop(text = f.Let(n), f.Sequence(f.Warning(text), f.Error(text)));
		}

		private QilNode CompileVariable(XslNode node)
		{
			if (scope.IsLocalVariable(node.Name.LocalName, node.Name.NamespaceUri))
			{
				ReportError("Xslt_DupLocalVariable", node.Name.QualifiedName);
			}
			return CompileVarParValue(node);
		}

		private QilNode CompileVarParValue(XslNode node)
		{
			string uri = lastScope.SourceLine.Uri;
			IList<XslNode> content = node.Content;
			string select = node.Select;
			QilNode qilNode;
			if (select != null)
			{
				QilList qilList = InstructionList();
				qilList.Add(CompileXPathExpression(select));
				qilNode = CompileInstructions(content, qilList);
			}
			else if (content.Count != 0)
			{
				outputScope.PushScope();
				outputScope.InvalidateAllPrefixes();
				qilNode = f.RtfCtor(CompileInstructions(content), f.String(uri));
				outputScope.PopScope();
			}
			else
			{
				qilNode = f.String(string.Empty);
			}
			if (IsDebug)
			{
				qilNode = f.TypeAssert(qilNode, XmlQueryTypeFactory.ItemS);
			}
			return qilNode;
		}

		private void CompileWithParam(VarPar withParam)
		{
			QilList nsList = EnterScope(withParam);
			QilNode n = CompileVarParValue(withParam);
			ExitScope();
			SetLineInfo(n, withParam.SourceLine);
			n = (withParam.Value = SetDebugNs(n, nsList));
		}

		private QilNode CompileSorts(IList<XslNode> content, ref LoopFocus parentLoop)
		{
			QilList qilList = f.BaseFactory.SortKeyList();
			int num = 0;
			while (num < content.Count)
			{
				if (content[num] is Sort sort)
				{
					CompileSort(sort, qilList, ref parentLoop);
					content.RemoveAt(num);
				}
				else
				{
					num++;
				}
			}
			if (qilList.Count == 0)
			{
				return null;
			}
			return qilList;
		}

		private QilNode CompileLangAttribute(string attValue, bool fwdCompat)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode != null)
			{
				if (qilNode.NodeType == QilNodeType.LiteralString)
				{
					string lang = (QilLiteral)qilNode;
					int num = XsltLibrary.LangToLcidInternal(lang, fwdCompat, this);
					if (num == 127)
					{
						qilNode = null;
					}
				}
				else
				{
					QilIterator qilIterator;
					qilNode = f.Loop(qilIterator = f.Let(qilNode), f.Conditional(f.Eq(f.InvokeLangToLcid(qilIterator, fwdCompat), f.Int32(127)), f.String(string.Empty), qilIterator));
				}
			}
			return qilNode;
		}

		private QilNode CompileLangAttributeToLcid(string attValue, bool fwdCompat)
		{
			return CompileLangToLcid(CompileStringAvt(attValue), fwdCompat);
		}

		private QilNode CompileLangToLcid(QilNode lang, bool fwdCompat)
		{
			if (lang == null)
			{
				return f.Double(127.0);
			}
			if (lang.NodeType == QilNodeType.LiteralString)
			{
				return f.Double(XsltLibrary.LangToLcidInternal((QilLiteral)lang, fwdCompat, this));
			}
			return f.XsltConvert(f.InvokeLangToLcid(lang, fwdCompat), XmlQueryTypeFactory.DoubleX);
		}

		private void CompileDataTypeAttribute(string attValue, bool fwdCompat, ref QilNode select, out QilNode select2)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode != null)
			{
				if (qilNode.NodeType != QilNodeType.LiteralString)
				{
					QilIterator qilIterator;
					QilIterator qilIterator2;
					qilNode = f.Loop(qilIterator = f.Let(qilNode), f.Conditional(f.Eq(qilIterator, f.String("number")), f.False(), f.Conditional(f.Eq(qilIterator, f.String("text")), f.True(), fwdCompat ? f.True() : f.Loop(qilIterator2 = f.Let(ResolveQNameDynamic(ignoreDefaultNs: true, qilIterator)), f.Error(lastScope.SourceLine, "Xslt_BistateAttribute", "data-type", "text", "number")))));
					QilIterator qilIterator3 = f.Let(qilNode);
					varHelper.AddVariable(qilIterator3);
					select2 = select.DeepClone(f.BaseFactory);
					select = f.Conditional(qilIterator3, f.ConvertToString(select), f.String(string.Empty));
					select2 = f.Conditional(qilIterator3, f.Double(0.0), f.ConvertToNumber(select2));
					return;
				}
				string text = (QilLiteral)qilNode;
				if (text == "number")
				{
					select = f.ConvertToNumber(select);
					select2 = null;
					return;
				}
				if (!(text == "text") && !fwdCompat)
				{
					string prefix;
					string localName;
					string text2 = (compiler.ParseQName(text, out prefix, out localName, this) ? ResolvePrefix(ignoreDefaultNs: true, prefix) : compiler.CreatePhantomNamespace());
					_ = text2.Length;
					ReportError("Xslt_BistateAttribute", "data-type", "text", "number");
				}
			}
			select = f.ConvertToString(select);
			select2 = null;
		}

		private QilNode CompileOrderAttribute(string attName, string attValue, string value0, string value1, bool fwdCompat)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode != null)
			{
				if (qilNode.NodeType == QilNodeType.LiteralString)
				{
					string text = (QilLiteral)qilNode;
					if (text == value1)
					{
						qilNode = f.String("1");
					}
					else
					{
						if (text != value0 && !fwdCompat)
						{
							ReportError("Xslt_BistateAttribute", attName, value0, value1);
						}
						qilNode = f.String("0");
					}
				}
				else
				{
					QilIterator left;
					qilNode = f.Loop(left = f.Let(qilNode), f.Conditional(f.Eq(left, f.String(value1)), f.String("1"), fwdCompat ? f.String("0") : f.Conditional(f.Eq(left, f.String(value0)), f.String("0"), f.Error(lastScope.SourceLine, "Xslt_BistateAttribute", attName, value0, value1))));
				}
			}
			return qilNode;
		}

		private void CompileSort(Sort sort, QilList keyList, ref LoopFocus parentLoop)
		{
			EnterScope(sort);
			bool forwardsCompatible = sort.ForwardsCompatible;
			QilNode select = CompileXPathExpression(sort.Select);
			QilNode value;
			QilNode select2;
			QilNode qilNode;
			QilNode qilNode2;
			if (sort.Lang != null || sort.DataType != null || sort.Order != null || sort.CaseOrder != null)
			{
				LoopFocus loopFocus = curLoop;
				curLoop = parentLoop;
				value = CompileLangAttribute(sort.Lang, forwardsCompatible);
				CompileDataTypeAttribute(sort.DataType, forwardsCompatible, ref select, out select2);
				qilNode = CompileOrderAttribute("order", sort.Order, "ascending", "descending", forwardsCompatible);
				qilNode2 = CompileOrderAttribute("case-order", sort.CaseOrder, "lower-first", "upper-first", forwardsCompatible);
				curLoop = loopFocus;
			}
			else
			{
				select = f.ConvertToString(select);
				select2 = (value = (qilNode = (qilNode2 = null)));
			}
			strConcat.Reset();
			strConcat.Append("http://collations.microsoft.com");
			strConcat.Append('/');
			strConcat.Append(value);
			char value2 = '?';
			if (qilNode != null)
			{
				strConcat.Append(value2);
				strConcat.Append("descendingOrder=");
				strConcat.Append(qilNode);
				value2 = '&';
			}
			if (qilNode2 != null)
			{
				strConcat.Append(value2);
				strConcat.Append("upperFirst=");
				strConcat.Append(qilNode2);
				value2 = '&';
			}
			QilNode qilNode3 = strConcat.ToQil();
			QilSortKey node = f.SortKey(select, qilNode3);
			keyList.Add(node);
			if (select2 != null)
			{
				node = f.SortKey(select2, qilNode3.DeepClone(f.BaseFactory));
				keyList.Add(node);
			}
			ExitScope();
		}

		private QilNode MatchPattern(QilNode pattern, QilIterator testNode)
		{
			if (pattern.NodeType == QilNodeType.Error)
			{
				return pattern;
			}
			QilList qilList;
			if (pattern.NodeType == QilNodeType.Sequence)
			{
				qilList = (QilList)pattern;
			}
			else
			{
				qilList = f.BaseFactory.Sequence();
				qilList.Add(pattern);
			}
			QilNode qilNode = f.False();
			int num = qilList.Count - 1;
			while (0 <= num)
			{
				QilLoop qilLoop = (QilLoop)qilList[num];
				qilNode = f.Or(refReplacer.Replace(qilLoop.Body, qilLoop.Variable, testNode), qilNode);
				num--;
			}
			return qilNode;
		}

		private QilNode MatchCountPattern(QilNode countPattern, QilIterator testNode)
		{
			if (countPattern != null)
			{
				return MatchPattern(countPattern, testNode);
			}
			QilNode currentNode = GetCurrentNode();
			XmlNodeKindFlags nodeKinds = currentNode.XmlType.NodeKinds;
			if ((nodeKinds & (nodeKinds - 1)) != 0)
			{
				return f.InvokeIsSameNodeSort(testNode, currentNode);
			}
			QilNode left;
			switch (nodeKinds)
			{
			case XmlNodeKindFlags.Document:
				return f.IsType(testNode, XmlQueryTypeFactory.Document);
			case XmlNodeKindFlags.Element:
				left = f.IsType(testNode, XmlQueryTypeFactory.Element);
				break;
			case XmlNodeKindFlags.Attribute:
				left = f.IsType(testNode, XmlQueryTypeFactory.Attribute);
				break;
			case XmlNodeKindFlags.Text:
				return f.IsType(testNode, XmlQueryTypeFactory.Text);
			case XmlNodeKindFlags.Comment:
				return f.IsType(testNode, XmlQueryTypeFactory.Comment);
			case XmlNodeKindFlags.PI:
				return f.And(f.IsType(testNode, XmlQueryTypeFactory.PI), f.Eq(f.LocalNameOf(testNode), f.LocalNameOf(currentNode)));
			case XmlNodeKindFlags.Namespace:
				return f.And(f.IsType(testNode, XmlQueryTypeFactory.Namespace), f.Eq(f.LocalNameOf(testNode), f.LocalNameOf(currentNode)));
			default:
				return f.False();
			}
			return f.And(left, f.And(f.Eq(f.LocalNameOf(testNode), f.LocalNameOf(currentNode)), f.Eq(f.NamespaceUriOf(testNode), f.NamespaceUriOf(GetCurrentNode()))));
		}

		private QilNode PlaceMarker(QilNode countPattern, QilNode fromPattern, bool multiple)
		{
			QilNode countPattern2 = countPattern?.DeepClone(f.BaseFactory);
			QilIterator testNode;
			QilNode qilNode = f.Filter(testNode = f.For(f.AncestorOrSelf(GetCurrentNode())), MatchCountPattern(countPattern, testNode));
			QilNode qilNode2 = ((!multiple) ? f.Filter(testNode = f.For(qilNode), f.Eq(f.PositionOf(testNode), f.Int32(1))) : f.DocOrderDistinct(qilNode));
			QilNode binding;
			QilIterator right;
			if (fromPattern == null)
			{
				binding = qilNode2;
			}
			else
			{
				QilNode binding2 = f.Filter(testNode = f.For(f.AncestorOrSelf(GetCurrentNode())), MatchPattern(fromPattern, testNode));
				QilNode binding3 = f.Filter(testNode = f.For(binding2), f.Eq(f.PositionOf(testNode), f.Int32(1)));
				binding = f.Loop(testNode = f.For(binding3), f.Filter(right = f.For(qilNode2), f.Before(testNode, right)));
			}
			return f.Loop(right = f.For(binding), f.Add(f.Int32(1), f.Length(f.Filter(testNode = f.For(f.PrecedingSibling(right)), MatchCountPattern(countPattern2, testNode)))));
		}

		private QilNode PlaceMarkerAny(QilNode countPattern, QilNode fromPattern)
		{
			QilNode child;
			QilIterator testNode2;
			if (fromPattern == null)
			{
				QilNode binding = f.NodeRange(f.Root(GetCurrentNode()), GetCurrentNode());
				QilIterator testNode;
				child = f.Filter(testNode = f.For(binding), MatchCountPattern(countPattern, testNode));
			}
			else
			{
				QilIterator testNode;
				QilNode binding2 = f.Filter(testNode = f.For(f.Preceding(GetCurrentNode())), MatchPattern(fromPattern, testNode));
				QilNode binding3 = f.Filter(testNode = f.For(binding2), f.Eq(f.PositionOf(testNode), f.Int32(1)));
				QilIterator right;
				child = f.Loop(testNode = f.For(binding3), f.Filter(right = f.For(f.Filter(testNode2 = f.For(f.NodeRange(testNode, GetCurrentNode())), MatchCountPattern(countPattern, testNode2))), f.Not(f.Is(testNode, right))));
			}
			return f.Loop(testNode2 = f.Let(f.Length(child)), f.Conditional(f.Eq(testNode2, f.Int32(0)), f.Sequence(), testNode2));
		}

		private QilNode CompileLetterValueAttribute(string attValue, bool fwdCompat)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode != null)
			{
				if (qilNode.NodeType == QilNodeType.LiteralString)
				{
					string text = (QilLiteral)qilNode;
					if (text != "alphabetic" && text != "traditional")
					{
						if (fwdCompat)
						{
							return f.String("default");
						}
						ReportError("Xslt_BistateAttribute", "letter-value", "alphabetic", "traditional");
					}
					return qilNode;
				}
				QilIterator qilIterator = f.Let(qilNode);
				return f.Loop(qilIterator, f.Conditional(f.Or(f.Eq(qilIterator, f.String("alphabetic")), f.Eq(qilIterator, f.String("traditional"))), qilIterator, fwdCompat ? f.String("default") : f.Error(lastScope.SourceLine, "Xslt_BistateAttribute", "letter-value", "alphabetic", "traditional")));
			}
			return f.String("default");
		}

		private QilNode CompileGroupingSeparatorAttribute(string attValue, bool fwdCompat)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode == null)
			{
				qilNode = f.String(string.Empty);
			}
			else if (qilNode.NodeType == QilNodeType.LiteralString)
			{
				string text = (QilLiteral)qilNode;
				if (text.Length != 1)
				{
					if (!fwdCompat)
					{
						ReportError("Xslt_CharAttribute", "grouping-separator");
					}
					qilNode = f.String(string.Empty);
				}
			}
			else
			{
				QilIterator qilIterator = f.Let(qilNode);
				qilNode = f.Loop(qilIterator, f.Conditional(f.Eq(f.StrLength(qilIterator), f.Int32(1)), qilIterator, fwdCompat ? f.String(string.Empty) : f.Error(lastScope.SourceLine, "Xslt_CharAttribute", "grouping-separator")));
			}
			return qilNode;
		}

		private QilNode CompileGroupingSizeAttribute(string attValue, bool fwdCompat)
		{
			QilNode qilNode = CompileStringAvt(attValue);
			if (qilNode == null)
			{
				return f.Double(0.0);
			}
			if (qilNode.NodeType == QilNodeType.LiteralString)
			{
				string s = (QilLiteral)qilNode;
				double num = XsltFunctions.Round(XPathConvert.StringToDouble(s));
				if (0.0 <= num && num <= 2147483647.0)
				{
					return f.Double(num);
				}
				return f.Double(0.0);
			}
			QilIterator qilIterator = f.Let(f.ConvertToNumber(qilNode));
			return f.Loop(qilIterator, f.Conditional(f.And(f.Lt(f.Double(0.0), qilIterator), f.Lt(qilIterator, f.Double(2147483647.0))), qilIterator, f.Double(0.0)));
		}

		private QilNode CompileNumber(Number num)
		{
			QilNode value;
			if (num.Value != null)
			{
				value = f.ConvertToNumber(CompileXPathExpression(num.Value));
			}
			else
			{
				QilNode countPattern = ((num.Count != null) ? CompileNumberPattern(num.Count) : null);
				QilNode fromPattern = ((num.From != null) ? CompileNumberPattern(num.From) : null);
				value = num.Level switch
				{
					NumberLevel.Single => PlaceMarker(countPattern, fromPattern, multiple: false), 
					NumberLevel.Multiple => PlaceMarker(countPattern, fromPattern, multiple: true), 
					_ => PlaceMarkerAny(countPattern, fromPattern), 
				};
			}
			bool forwardsCompatible = num.ForwardsCompatible;
			return f.TextCtor(f.InvokeNumberFormat(value, CompileStringAvt(num.Format), CompileLangAttributeToLcid(num.Lang, forwardsCompatible), CompileLetterValueAttribute(num.LetterValue, forwardsCompatible), CompileGroupingSeparatorAttribute(num.GroupingSeparator, forwardsCompatible), CompileGroupingSizeAttribute(num.GroupingSize, forwardsCompatible)));
		}

		private void CompileAndSortMatches(Stylesheet sheet)
		{
			foreach (Template template in sheet.Templates)
			{
				if (template.Match == null)
				{
					continue;
				}
				EnterScope(template);
				QilNode qilNode = CompileMatchPattern(template.Match);
				if (qilNode.NodeType == QilNodeType.Sequence)
				{
					QilList qilList = (QilList)qilNode;
					for (int i = 0; i < qilList.Count; i++)
					{
						sheet.AddTemplateMatch(template, (QilLoop)qilList[i]);
					}
				}
				else
				{
					sheet.AddTemplateMatch(template, (QilLoop)qilNode);
				}
				ExitScope();
			}
			sheet.SortTemplateMatches();
			Stylesheet[] imports = sheet.Imports;
			foreach (Stylesheet sheet2 in imports)
			{
				CompileAndSortMatches(sheet2);
			}
		}

		private void CompileKeys()
		{
			for (int i = 0; i < compiler.Keys.Count; i++)
			{
				foreach (Key item in compiler.Keys[i])
				{
					EnterScope(item);
					QilParameter qilParameter = f.Parameter(XmlQueryTypeFactory.NodeNotRtf);
					singlFocus.SetFocus(qilParameter);
					QilIterator qilIterator = f.For(f.OptimizeBarrier(CompileKeyMatch(item.Match)));
					singlFocus.SetFocus(qilIterator);
					QilIterator qilIterator2 = f.For(CompileKeyUse(item));
					qilIterator2 = f.For(f.OptimizeBarrier(f.Loop(qilIterator2, f.ConvertToString(qilIterator2))));
					QilParameter qilParameter2 = f.Parameter(XmlQueryTypeFactory.StringX);
					QilFunction qilFunction = f.Function(f.FormalParameterList(qilParameter, qilParameter2), f.Filter(qilIterator, f.Not(f.IsEmpty(f.Filter(qilIterator2, f.Eq(qilIterator2, qilParameter2))))), f.False());
					qilFunction.DebugName = item.GetDebugName();
					SetLineInfo(qilFunction, item.SourceLine);
					item.Function = qilFunction;
					functions.Add(qilFunction);
					ExitScope();
				}
			}
			singlFocus.SetFocus(null);
		}

		private void CreateGlobalVarPars()
		{
			foreach (VarPar externalPar in compiler.ExternalPars)
			{
				CreateGlobalVarPar(externalPar);
			}
			foreach (VarPar globalVar in compiler.GlobalVars)
			{
				CreateGlobalVarPar(globalVar);
			}
		}

		private void CreateGlobalVarPar(VarPar varPar)
		{
			XmlQueryType t = ChooseBestType(varPar);
			QilIterator qilIterator = ((varPar.NodeType != XslNodeType.Variable) ? f.Parameter(null, varPar.Name, t) : f.Let(f.Unknown(t)));
			qilIterator.DebugName = varPar.Name.ToString();
			varPar.Value = qilIterator;
			SetLineInfo(qilIterator, varPar.SourceLine);
			scope.AddVariable(varPar.Name, qilIterator);
		}

		private void CompileGlobalVariables()
		{
			singlFocus.SetFocus(SingletonFocusType.InitialDocumentNode);
			foreach (VarPar externalPar in compiler.ExternalPars)
			{
				extPars.Add(CompileGlobalVarPar(externalPar));
			}
			foreach (VarPar globalVar in compiler.GlobalVars)
			{
				gloVars.Add(CompileGlobalVarPar(globalVar));
			}
			singlFocus.SetFocus(null);
		}

		private QilIterator CompileGlobalVarPar(VarPar varPar)
		{
			QilIterator qilIterator = (QilIterator)varPar.Value;
			QilList nsList = EnterScope(varPar);
			QilNode qilNode = CompileVarParValue(varPar);
			SetLineInfo(qilNode, qilIterator.SourceLine);
			qilNode = AddCurrentPositionLast(qilNode);
			qilNode = SetDebugNs(qilNode, nsList);
			qilIterator.SourceLine = SourceLineInfo.NoSource;
			qilIterator.Binding = qilNode;
			ExitScope();
			return qilIterator;
		}

		private void ReportErrorInXPath(XslLoadException e)
		{
			string text = ((e is XPathCompileException ex) ? ex.FormatDetailedMessage() : e.Message);
			compiler.ReportError(lastScope.SourceLine, "Xml_UserException", text);
		}

		private QilNode PhantomXPathExpression()
		{
			return f.TypeAssert(f.Sequence(), XmlQueryTypeFactory.ItemS);
		}

		private QilNode PhantomKeyMatch()
		{
			return f.TypeAssert(f.Sequence(), XmlQueryTypeFactory.NodeNotRtfS);
		}

		private QilNode CompileXPathExpression(string expr)
		{
			SetEnvironmentFlags(allowVariables: true, allowCurrent: true, allowKey: true);
			QilNode qilNode;
			if (expr == null)
			{
				qilNode = PhantomXPathExpression();
			}
			else
			{
				try
				{
					System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(expr);
					qilNode = xpathParser.Parse(scanner, xpathBuilder, LexKind.Eof);
				}
				catch (XslLoadException ex)
				{
					if (xslVersion != XslVersion.ForwardsCompatible)
					{
						ReportErrorInXPath(ex);
					}
					qilNode = f.Error(f.String(ex.Message));
				}
			}
			if (qilNode is QilIterator)
			{
				qilNode = f.Nop(qilNode);
			}
			return qilNode;
		}

		private QilNode CompileNodeSetExpression(string expr)
		{
			QilNode qilNode = f.TryEnsureNodeSet(CompileXPathExpression(expr));
			if (qilNode == null)
			{
				XPathCompileException ex = new XPathCompileException(expr, 0, expr.Length, "XPath_NodeSetExpected", (string[])null);
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportErrorInXPath(ex);
				}
				qilNode = f.Error(f.String(ex.Message));
			}
			return qilNode;
		}

		private QilNode CompileXPathExpressionWithinAvt(string expr, ref int pos)
		{
			int num = pos;
			SetEnvironmentFlags(allowVariables: true, allowCurrent: true, allowKey: true);
			QilNode qilNode;
			try
			{
				System.Xml.Xsl.XPath.XPathScanner xPathScanner = new System.Xml.Xsl.XPath.XPathScanner(expr, pos);
				qilNode = xpathParser.Parse(xPathScanner, xpathBuilder, LexKind.RBrace);
				pos = xPathScanner.LexStart + 1;
			}
			catch (XslLoadException ex)
			{
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportErrorInXPath(ex);
				}
				qilNode = f.Error(f.String(ex.Message));
				pos = expr.Length;
			}
			if (qilNode is QilIterator)
			{
				qilNode = f.Nop(qilNode);
			}
			return qilNode;
		}

		private QilNode CompileMatchPattern(string pttrn)
		{
			SetEnvironmentFlags(allowVariables: false, allowCurrent: false, allowKey: true);
			try
			{
				System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(pttrn);
				return ptrnParser.Parse(scanner, ptrnBuilder);
			}
			catch (XslLoadException ex)
			{
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportErrorInXPath(ex);
				}
				QilNode qilNode = f.Loop(f.For(ptrnBuilder.FixupNode), f.Error(f.String(ex.Message)));
				XPathPatternBuilder.SetPriority(qilNode, 0.5);
				return qilNode;
			}
		}

		private QilNode CompileNumberPattern(string pttrn)
		{
			SetEnvironmentFlags(allowVariables: true, allowCurrent: false, allowKey: true);
			try
			{
				System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(pttrn);
				return ptrnParser.Parse(scanner, ptrnBuilder);
			}
			catch (XslLoadException ex)
			{
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportErrorInXPath(ex);
				}
				return f.Error(f.String(ex.Message));
			}
		}

		private QilNode CompileKeyMatch(string pttrn)
		{
			if (keyMatchBuilder == null)
			{
				keyMatchBuilder = new KeyMatchBuilder(this);
			}
			SetEnvironmentFlags(allowVariables: false, allowCurrent: false, allowKey: false);
			if (pttrn == null)
			{
				return PhantomKeyMatch();
			}
			try
			{
				System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(pttrn);
				return ptrnParser.Parse(scanner, keyMatchBuilder);
			}
			catch (XslLoadException ex)
			{
				if (xslVersion != XslVersion.ForwardsCompatible)
				{
					ReportErrorInXPath(ex);
				}
				return f.Error(f.String(ex.Message));
			}
		}

		private QilNode CompileKeyUse(Key key)
		{
			string use = key.Use;
			SetEnvironmentFlags(allowVariables: false, allowCurrent: true, allowKey: false);
			QilNode qilNode;
			if (use == null)
			{
				qilNode = f.Error(f.String(XslLoadException.CreateMessage(key.SourceLine, "Xslt_MissingAttribute", "use")));
			}
			else
			{
				try
				{
					System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(use);
					qilNode = xpathParser.Parse(scanner, xpathBuilder, LexKind.Eof);
				}
				catch (XslLoadException ex)
				{
					if (xslVersion != XslVersion.ForwardsCompatible)
					{
						ReportErrorInXPath(ex);
					}
					qilNode = f.Error(f.String(ex.Message));
				}
			}
			if (qilNode is QilIterator)
			{
				qilNode = f.Nop(qilNode);
			}
			return qilNode;
		}

		private QilNode ResolveQNameDynamic(bool ignoreDefaultNs, QilNode qilName)
		{
			QilList qilList = f.BaseFactory.Sequence();
			if (ignoreDefaultNs)
			{
				qilList.Add(f.NamespaceDecl(f.String(string.Empty), f.String(string.Empty)));
			}
			CompilerScopeManager<QilIterator>.NamespaceEnumerator enumerator = scope.GetEnumerator();
			while (enumerator.MoveNext())
			{
				CompilerScopeManager<QilIterator>.ScopeRecord current = enumerator.Current;
				string ncName = current.ncName;
				string nsUri = current.nsUri;
				if (!ignoreDefaultNs || ncName.Length != 0)
				{
					qilList.Add(f.NamespaceDecl(f.String(ncName), f.String(nsUri)));
				}
			}
			return f.StrParseQName(qilName, qilList);
		}

		private QilNode GenerateApply(StylesheetLevel sheet, XslNode node)
		{
			if (compiler.Settings.CheckOnly)
			{
				return f.Sequence();
			}
			return InvokeApplyFunction(sheet, node.Name, node.Content);
		}

		private void SetArg(IList<XslNode> args, int pos, QilName name, QilNode value)
		{
			VarPar varPar;
			if (args.Count <= pos || args[pos].Name != name)
			{
				varPar = AstFactory.WithParam(name);
				args.Insert(pos, varPar);
			}
			else
			{
				varPar = (VarPar)args[pos];
			}
			varPar.Value = value;
		}

		private IList<XslNode> AddRemoveImplicitArgs(IList<XslNode> args, XslFlags flags)
		{
			if (IsDebug)
			{
				flags = XslFlags.FocusFilter;
			}
			if ((flags & XslFlags.FocusFilter) != 0)
			{
				if (args == null || args.IsReadOnly)
				{
					args = new List<XslNode>(3);
				}
				int num = 0;
				if ((flags & XslFlags.Current) != 0)
				{
					SetArg(args, num++, nameCurrent, GetCurrentNode());
				}
				if ((flags & XslFlags.Position) != 0)
				{
					SetArg(args, num++, namePosition, GetCurrentPosition());
				}
				if ((flags & XslFlags.Last) != 0)
				{
					SetArg(args, num++, nameLast, GetLastPosition());
				}
			}
			return args;
		}

		private bool FillupInvokeArgs(IList<QilNode> formalArgs, IList<XslNode> actualArgs, QilList invokeArgs)
		{
			if (actualArgs.Count != formalArgs.Count)
			{
				return false;
			}
			invokeArgs.Clear();
			for (int i = 0; i < formalArgs.Count; i++)
			{
				QilName name = ((QilParameter)formalArgs[i]).Name;
				XmlQueryType xmlType = formalArgs[i].XmlType;
				QilNode qilNode = null;
				for (int j = 0; j < actualArgs.Count; j++)
				{
					VarPar varPar = (VarPar)actualArgs[j];
					if (name.Equals(varPar.Name))
					{
						QilNode value = varPar.Value;
						XmlQueryType xmlType2 = value.XmlType;
						if (xmlType2 != xmlType && (!xmlType2.IsNode || !xmlType.IsNode || !xmlType2.IsSubtypeOf(xmlType)))
						{
							return false;
						}
						qilNode = value;
						break;
					}
				}
				if (qilNode == null)
				{
					return false;
				}
				invokeArgs.Add(qilNode);
			}
			return true;
		}

		private QilNode InvokeApplyFunction(StylesheetLevel sheet, QilName mode, IList<XslNode> actualArgs)
		{
			if (!sheet.ModeFlags.TryGetValue(mode, out var value))
			{
				value = XslFlags.None;
			}
			value |= XslFlags.Current;
			actualArgs = AddRemoveImplicitArgs(actualArgs, value);
			QilList qilList = f.ActualParameterList();
			QilFunction qilFunction = null;
			if (!sheet.ApplyFunctions.TryGetValue(mode, out var value2))
			{
				List<QilFunction> list2 = (sheet.ApplyFunctions[mode] = new List<QilFunction>());
				value2 = list2;
			}
			foreach (QilFunction item in value2)
			{
				if (FillupInvokeArgs(item.Arguments, actualArgs, qilList))
				{
					qilFunction = item;
					break;
				}
			}
			if (qilFunction == null)
			{
				qilList.Clear();
				QilList qilList2 = f.FormalParameterList();
				for (int i = 0; i < actualArgs.Count; i++)
				{
					VarPar varPar = (VarPar)actualArgs[i];
					qilList.Add(varPar.Value);
					QilParameter qilParameter = f.Parameter((i == 0) ? XmlQueryTypeFactory.NodeNotRtf : varPar.Value.XmlType);
					qilParameter.Name = CloneName(varPar.Name);
					qilList2.Add(qilParameter);
					varPar.Value = qilParameter;
				}
				qilFunction = f.Function(qilList2, f.Boolean((value & XslFlags.SideEffects) != 0), XmlQueryTypeFactory.NodeNotRtfS);
				string text = ((mode.LocalName.Length == 0) ? string.Empty : (" mode=\"" + mode.QualifiedName + "\""));
				qilFunction.DebugName = ((sheet is RootLevel) ? "<xsl:apply-templates" : "<xsl:apply-imports") + text + ">";
				value2.Add(qilFunction);
				functions.Add(qilFunction);
				QilIterator qilIterator = (QilIterator)qilList2[0];
				QilIterator qilIterator2 = f.For(f.Content(qilIterator));
				QilNode qilNode = f.Filter(qilIterator2, f.IsType(qilIterator2, XmlQueryTypeFactory.Content));
				qilNode.XmlType = XmlQueryTypeFactory.ContentS;
				LoopFocus loopFocus = curLoop;
				curLoop.SetFocus(f.For(qilNode));
				QilNode qilNode2 = InvokeApplyFunction(compiler.Root, mode, null);
				if (IsDebug)
				{
					qilNode2 = f.Sequence(InvokeOnCurrentNodeChanged(), qilNode2);
				}
				QilLoop center = curLoop.ConstructLoop(qilNode2);
				curLoop = loopFocus;
				QilTernary otherwise = f.BaseFactory.Conditional(f.IsType(qilIterator, elementOrDocumentType), center, f.Conditional(f.IsType(qilIterator, textOrAttributeType), f.TextCtor(f.XPathNodeValue(qilIterator)), f.Sequence()));
				matcherBuilder.CollectPatterns(sheet, mode);
				qilFunction.Definition = matcherBuilder.BuildMatcher(qilIterator, actualArgs, otherwise);
			}
			return f.Invoke(qilFunction, qilList);
		}

		public void ReportError(string res, params string[] args)
		{
			compiler.ReportError(lastScope.SourceLine, res, args);
		}

		public void ReportWarning(string res, params string[] args)
		{
			compiler.ReportWarning(lastScope.SourceLine, res, args);
		}

		[Conditional("DEBUG")]
		private void VerifyXPathQName(QilName qname)
		{
		}

		private string ResolvePrefix(bool ignoreDefaultNs, string prefix)
		{
			if (ignoreDefaultNs && prefix.Length == 0)
			{
				return string.Empty;
			}
			string text = scope.LookupNamespace(prefix);
			if (text == null)
			{
				if (prefix.Length == 0)
				{
					text = string.Empty;
				}
				else
				{
					ReportError("Xslt_InvalidPrefix", prefix);
					text = compiler.CreatePhantomNamespace();
				}
			}
			return text;
		}

		private void SetLineInfoCheck(QilNode n, ISourceLineInfo lineInfo)
		{
			if (n.SourceLine == null)
			{
				SetLineInfo(n, lineInfo);
			}
		}

		private static QilNode SetLineInfo(QilNode n, ISourceLineInfo lineInfo)
		{
			if (lineInfo != null && 0 < lineInfo.Start.Line && lineInfo.Start.LessOrEqual(lineInfo.End))
			{
				n.SourceLine = lineInfo;
			}
			return n;
		}

		private QilNode AddDebugVariable(QilName name, QilNode value, QilNode content)
		{
			QilIterator qilIterator = f.Let(value);
			qilIterator.DebugName = name.ToString();
			return f.Loop(qilIterator, content);
		}

		private QilNode SetDebugNs(QilNode n, QilList nsList)
		{
			if (n != null && nsList != null)
			{
				QilNode qilNode = GetNsVar(nsList);
				if (qilNode.XmlType.Cardinality == XmlQueryCardinality.One)
				{
					qilNode = f.TypeAssert(qilNode, XmlQueryTypeFactory.NamespaceS);
				}
				n = AddDebugVariable(CloneName(nameNamespaces), qilNode, n);
			}
			return n;
		}

		private QilNode AddCurrentPositionLast(QilNode content)
		{
			if (IsDebug)
			{
				content = AddDebugVariable(CloneName(nameLast), GetLastPosition(), content);
				content = AddDebugVariable(CloneName(namePosition), GetCurrentPosition(), content);
				content = AddDebugVariable(CloneName(nameCurrent), GetCurrentNode(), content);
			}
			return content;
		}

		private QilName CloneName(QilName name)
		{
			return (QilName)name.ShallowClone(f.BaseFactory);
		}

		private void SetEnvironmentFlags(bool allowVariables, bool allowCurrent, bool allowKey)
		{
			this.allowVariables = allowVariables;
			this.allowCurrent = allowCurrent;
			this.allowKey = allowKey;
		}

		QilNode IFocus.GetCurrent()
		{
			return GetCurrentNode();
		}

		QilNode IFocus.GetPosition()
		{
			return GetCurrentPosition();
		}

		QilNode IFocus.GetLast()
		{
			return GetLastPosition();
		}

		string IXPathEnvironment.ResolvePrefix(string prefix)
		{
			return ResolvePrefixThrow(ignoreDefaultNs: true, prefix);
		}

		QilNode IXPathEnvironment.ResolveVariable(string prefix, string name)
		{
			if (!allowVariables)
			{
				throw new XslLoadException("Xslt_VariablesNotAllowed");
			}
			string uri = ResolvePrefixThrow(ignoreDefaultNs: true, prefix);
			QilNode qilNode = scope.LookupVariable(name, uri);
			if (qilNode == null)
			{
				throw new XslLoadException("Xslt_InvalidVariable", Compiler.ConstructQName(prefix, name));
			}
			XmlQueryType xmlType = qilNode.XmlType;
			if (qilNode.NodeType == QilNodeType.Parameter && xmlType.IsNode && xmlType.IsNotRtf && xmlType.MaybeMany && !xmlType.IsDod)
			{
				qilNode = f.TypeAssert(qilNode, XmlQueryTypeFactory.NodeSDod);
			}
			return qilNode;
		}

		QilNode IXPathEnvironment.ResolveFunction(string prefix, string name, IList<QilNode> args, IFocus env)
		{
			if (prefix.Length == 0)
			{
				if (FunctionTable.TryGetValue(name, out var value))
				{
					value.CastArguments(args, name, f);
					switch (value.id)
					{
					case FuncId.Current:
						if (!allowCurrent)
						{
							throw new XslLoadException("Xslt_CurrentNotAllowed");
						}
						return ((IFocus)this).GetCurrent();
					case FuncId.Key:
						if (!allowKey)
						{
							throw new XslLoadException("Xslt_KeyNotAllowed");
						}
						return CompileFnKey(args[0], args[1], env);
					case FuncId.Document:
						return CompileFnDocument(args[0], (args.Count > 1) ? args[1] : null);
					case FuncId.FormatNumber:
						return CompileFormatNumber(args[0], args[1], (args.Count > 2) ? args[2] : null);
					case FuncId.UnparsedEntityUri:
						return CompileUnparsedEntityUri(args[0]);
					case FuncId.GenerateId:
						return CompileGenerateId((args.Count > 0) ? args[0] : env.GetCurrent());
					case FuncId.SystemProperty:
						return CompileSystemProperty(args[0]);
					case FuncId.ElementAvailable:
						return CompileElementAvailable(args[0]);
					case FuncId.FunctionAvailable:
						return CompileFunctionAvailable(args[0]);
					default:
						return null;
					}
				}
				throw new XslLoadException("Xslt_UnknownXsltFunction", Compiler.ConstructQName(prefix, name));
			}
			string text = ResolvePrefixThrow(ignoreDefaultNs: true, prefix);
			if (text == "urn:schemas-microsoft-com:xslt")
			{
				switch (name)
				{
				case "node-set":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return CompileMsNodeSet(args[0]);
				case "string-compare":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(2, 4, name, args.Count);
					return f.InvokeMsStringCompare(f.ConvertToString(args[0]), f.ConvertToString(args[1]), (2 < args.Count) ? f.ConvertToString(args[2]) : f.String(string.Empty), (3 < args.Count) ? f.ConvertToString(args[3]) : f.String(string.Empty));
				case "utc":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return f.InvokeMsUtc(f.ConvertToString(args[0]));
				case "format-date":
				case "format-time":
				{
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 3, name, args.Count);
					bool flag = xslVersion == XslVersion.ForwardsCompatible;
					return f.InvokeMsFormatDateTime(f.ConvertToString(args[0]), (1 < args.Count) ? f.ConvertToString(args[1]) : f.String(string.Empty), (2 < args.Count) ? f.ConvertToString(args[2]) : f.String(string.Empty), f.Boolean(name == "format-date"));
				}
				case "local-name":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return f.InvokeMsLocalName(f.ConvertToString(args[0]));
				case "namespace-uri":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return f.InvokeMsNamespaceUri(f.ConvertToString(args[0]), env.GetCurrent());
				case "number":
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return f.InvokeMsNumber(args[0]);
				}
			}
			if (text == "http://exslt.org/common")
			{
				if (name == "node-set")
				{
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return CompileMsNodeSet(args[0]);
				}
				if (name == "object-type")
				{
					XPathBuilder.FunctionInfo<FuncId>.CheckArity(1, 1, name, args.Count);
					return EXslObjectType(args[0]);
				}
			}
			for (int i = 0; i < args.Count; i++)
			{
				args[i] = f.SafeDocOrderDistinct(args[i]);
			}
			if (compiler.Settings.EnableScript)
			{
				XmlExtensionFunction xmlExtensionFunction = compiler.Scripts.ResolveFunction(name, text, args.Count, this);
				if (xmlExtensionFunction != null)
				{
					return GenerateScriptCall(f.QName(name, text, prefix), xmlExtensionFunction, args);
				}
			}
			else if (compiler.Scripts.ScriptClasses.ContainsKey(text))
			{
				ReportWarning("Xslt_ScriptsProhibited");
				return f.Error(lastScope.SourceLine, "Xslt_ScriptsProhibited");
			}
			return f.XsltInvokeLateBound(f.QName(name, text, prefix), args);
		}

		private QilNode GenerateScriptCall(QilName name, XmlExtensionFunction scrFunc, IList<QilNode> args)
		{
			for (int i = 0; i < args.Count; i++)
			{
				XmlQueryType xmlArgumentType = scrFunc.GetXmlArgumentType(i);
				switch (xmlArgumentType.TypeCode)
				{
				case XmlTypeCode.Boolean:
					args[i] = f.ConvertToBoolean(args[i]);
					break;
				case XmlTypeCode.Double:
					args[i] = f.ConvertToNumber(args[i]);
					break;
				case XmlTypeCode.String:
					args[i] = f.ConvertToString(args[i]);
					break;
				case XmlTypeCode.Node:
					args[i] = (xmlArgumentType.IsSingleton ? f.ConvertToNode(args[i]) : f.ConvertToNodeSet(args[i]));
					break;
				}
			}
			return f.XsltInvokeEarlyBound(name, scrFunc.Method, scrFunc.XmlReturnType, args);
		}

		private string ResolvePrefixThrow(bool ignoreDefaultNs, string prefix)
		{
			if (ignoreDefaultNs && prefix.Length == 0)
			{
				return string.Empty;
			}
			string text = scope.LookupNamespace(prefix);
			if (text == null)
			{
				if (prefix.Length != 0)
				{
					throw new XslLoadException("Xslt_InvalidPrefix", prefix);
				}
				text = string.Empty;
			}
			return text;
		}

		private static Dictionary<string, XPathBuilder.FunctionInfo<FuncId>> CreateFunctionTable()
		{
			Dictionary<string, XPathBuilder.FunctionInfo<FuncId>> dictionary = new Dictionary<string, XPathBuilder.FunctionInfo<FuncId>>(16);
			dictionary.Add("current", new XPathBuilder.FunctionInfo<FuncId>(FuncId.Current, 0, 0, null));
			dictionary.Add("document", new XPathBuilder.FunctionInfo<FuncId>(FuncId.Document, 1, 2, argFnDocument));
			dictionary.Add("key", new XPathBuilder.FunctionInfo<FuncId>(FuncId.Key, 2, 2, argFnKey));
			dictionary.Add("format-number", new XPathBuilder.FunctionInfo<FuncId>(FuncId.FormatNumber, 2, 3, argFnFormatNumber));
			dictionary.Add("unparsed-entity-uri", new XPathBuilder.FunctionInfo<FuncId>(FuncId.UnparsedEntityUri, 1, 1, XPathBuilder.argString));
			dictionary.Add("generate-id", new XPathBuilder.FunctionInfo<FuncId>(FuncId.GenerateId, 0, 1, XPathBuilder.argNodeSet));
			dictionary.Add("system-property", new XPathBuilder.FunctionInfo<FuncId>(FuncId.SystemProperty, 1, 1, XPathBuilder.argString));
			dictionary.Add("element-available", new XPathBuilder.FunctionInfo<FuncId>(FuncId.ElementAvailable, 1, 1, XPathBuilder.argString));
			dictionary.Add("function-available", new XPathBuilder.FunctionInfo<FuncId>(FuncId.FunctionAvailable, 1, 1, XPathBuilder.argString));
			return dictionary;
		}

		public static bool IsFunctionAvailable(string localName, string nsUri)
		{
			if (XPathBuilder.IsFunctionAvailable(localName, nsUri))
			{
				return true;
			}
			if (nsUri.Length == 0)
			{
				if (FunctionTable.ContainsKey(localName))
				{
					return localName != "unparsed-entity-uri";
				}
				return false;
			}
			if (nsUri == "urn:schemas-microsoft-com:xslt")
			{
				switch (localName)
				{
				default:
					return localName == "utc";
				case "node-set":
				case "format-date":
				case "format-time":
				case "local-name":
				case "namespace-uri":
				case "number":
				case "string-compare":
					return true;
				}
			}
			if (nsUri == "http://exslt.org/common")
			{
				if (!(localName == "node-set"))
				{
					return localName == "object-type";
				}
				return true;
			}
			return false;
		}

		public static bool IsElementAvailable(XmlQualifiedName name)
		{
			if (name.Namespace == "http://www.w3.org/1999/XSL/Transform")
			{
				string name2 = name.Name;
				switch (name2)
				{
				default:
					return name2 == "variable";
				case "apply-imports":
				case "apply-templates":
				case "attribute":
				case "call-template":
				case "choose":
				case "comment":
				case "copy":
				case "copy-of":
				case "element":
				case "fallback":
				case "for-each":
				case "if":
				case "message":
				case "number":
				case "processing-instruction":
				case "text":
				case "value-of":
					return true;
				}
			}
			return false;
		}

		private QilNode CompileFnKey(QilNode name, QilNode keys, IFocus env)
		{
			QilIterator name2;
			QilIterator expr;
			QilIterator n;
			QilNode collection = (keys.XmlType.IsNode ? ((!keys.XmlType.IsSingleton) ? f.Loop(n = f.For(keys), CompileSingleKey(name, f.ConvertToString(n), env)) : CompileSingleKey(name, f.ConvertToString(keys), env)) : ((!keys.XmlType.IsAtomicValue) ? f.Loop(name2 = f.Let(name), f.Loop(expr = f.Let(keys), f.Conditional(f.Not(f.IsType(expr, XmlQueryTypeFactory.AnyAtomicType)), f.Loop(n = f.For(f.TypeAssert(expr, XmlQueryTypeFactory.NodeS)), CompileSingleKey(name2, f.ConvertToString(n), env)), CompileSingleKey(name2, f.XsltConvert(expr, XmlQueryTypeFactory.StringX), env)))) : CompileSingleKey(name, f.ConvertToString(keys), env)));
			return f.DocOrderDistinct(collection);
		}

		private QilNode CompileSingleKey(QilNode name, QilNode key, IFocus env)
		{
			if (name.NodeType == QilNodeType.LiteralString)
			{
				string text = (QilLiteral)name;
				compiler.ParseQName(text, out var prefix, out var localName, default(ThrowErrorHelper));
				string uri = ResolvePrefixThrow(ignoreDefaultNs: true, prefix);
				QilName key2 = f.QName(localName, uri, prefix);
				if (!compiler.Keys.Contains(key2))
				{
					throw new XslLoadException("Xslt_UndefinedKey", text);
				}
				return CompileSingleKey(compiler.Keys[key2], key, env);
			}
			if (generalKey == null)
			{
				generalKey = CreateGeneralKeyFunction();
			}
			QilIterator qilIterator = f.Let(name);
			QilNode qilNode = ResolveQNameDynamic(ignoreDefaultNs: true, qilIterator);
			QilNode body = f.Invoke(generalKey, f.ActualParameterList(qilIterator, qilNode, key, env.GetCurrent()));
			return f.Loop(qilIterator, body);
		}

		private QilNode CompileSingleKey(List<Key> defList, QilNode key, IFocus env)
		{
			if (defList.Count == 1)
			{
				return f.Invoke(defList[0].Function, f.ActualParameterList(env.GetCurrent(), key));
			}
			QilIterator qilIterator = f.Let(key);
			QilNode qilNode = f.Sequence();
			foreach (Key def in defList)
			{
				qilNode.Add(f.Invoke(def.Function, f.ActualParameterList(env.GetCurrent(), qilIterator)));
			}
			return f.Loop(qilIterator, qilNode);
		}

		private QilNode CompileSingleKey(List<Key> defList, QilIterator key, QilIterator context)
		{
			QilList qilList = f.BaseFactory.Sequence();
			QilNode qilNode = null;
			foreach (Key def in defList)
			{
				qilNode = f.Invoke(def.Function, f.ActualParameterList(context, key));
				qilList.Add(qilNode);
			}
			if (defList.Count != 1)
			{
				return qilList;
			}
			return qilNode;
		}

		private QilFunction CreateGeneralKeyFunction()
		{
			QilIterator qilIterator = f.Parameter(XmlQueryTypeFactory.StringX);
			QilIterator qilIterator2 = f.Parameter(XmlQueryTypeFactory.QNameX);
			QilIterator qilIterator3 = f.Parameter(XmlQueryTypeFactory.StringX);
			QilIterator qilIterator4 = f.Parameter(XmlQueryTypeFactory.NodeNotRtf);
			QilNode qilNode = f.Error("Xslt_UndefinedKey", qilIterator);
			for (int i = 0; i < compiler.Keys.Count; i++)
			{
				qilNode = f.Conditional(f.Eq(qilIterator2, compiler.Keys[i][0].Name.DeepClone(f.BaseFactory)), CompileSingleKey(compiler.Keys[i], qilIterator3, qilIterator4), qilNode);
			}
			QilFunction qilFunction = f.Function(f.FormalParameterList(qilIterator, qilIterator2, qilIterator3, qilIterator4), qilNode, f.False());
			qilFunction.DebugName = "key";
			functions.Add(qilFunction);
			return qilFunction;
		}

		private QilNode CompileFnDocument(QilNode uris, QilNode baseNode)
		{
			if (!compiler.Settings.EnableDocumentFunction)
			{
				ReportWarning("Xslt_DocumentFuncProhibited");
				return f.Error(lastScope.SourceLine, "Xslt_DocumentFuncProhibited");
			}
			QilIterator qilIterator;
			if (uris.XmlType.IsNode)
			{
				return f.DocOrderDistinct(f.Loop(qilIterator = f.For(uris), CompileSingleDocument(f.ConvertToString(qilIterator), baseNode ?? qilIterator)));
			}
			if (uris.XmlType.IsAtomicValue)
			{
				return CompileSingleDocument(f.ConvertToString(uris), baseNode);
			}
			QilIterator qilIterator2 = f.Let(uris);
			QilIterator qilIterator3 = ((baseNode != null) ? f.Let(baseNode) : null);
			QilNode qilNode = f.Conditional(f.Not(f.IsType(qilIterator2, XmlQueryTypeFactory.AnyAtomicType)), f.DocOrderDistinct(f.Loop(qilIterator = f.For(f.TypeAssert(qilIterator2, XmlQueryTypeFactory.NodeS)), CompileSingleDocument(f.ConvertToString(qilIterator), qilIterator3 ?? qilIterator))), CompileSingleDocument(f.XsltConvert(qilIterator2, XmlQueryTypeFactory.StringX), qilIterator3));
			qilNode = ((baseNode != null) ? f.Loop(qilIterator3, qilNode) : qilNode);
			return f.Loop(qilIterator2, qilNode);
		}

		private QilNode CompileSingleDocument(QilNode uri, QilNode baseNode)
		{
			QilIterator n;
			QilNode baseUri = ((baseNode == null) ? f.String(lastScope.SourceLine.Uri) : ((!baseNode.XmlType.IsSingleton) ? f.StrConcat(f.Loop(n = f.FirstNode(baseNode), f.InvokeBaseUri(n))) : f.InvokeBaseUri(baseNode)));
			return f.DataSource(uri, baseUri);
		}

		private QilNode CompileFormatNumber(QilNode value, QilNode formatPicture, QilNode formatName)
		{
			XmlQualifiedName xmlQualifiedName;
			if (formatName != null)
			{
				xmlQualifiedName = ((formatName.NodeType != QilNodeType.LiteralString) ? null : ResolveQNameThrow(ignoreDefaultNs: true, formatName));
			}
			else
			{
				xmlQualifiedName = new XmlQualifiedName();
				formatName = f.String(string.Empty);
			}
			if (xmlQualifiedName != null)
			{
				DecimalFormatDecl format;
				if (compiler.DecimalFormats.Contains(xmlQualifiedName))
				{
					format = compiler.DecimalFormats[xmlQualifiedName];
				}
				else
				{
					if (xmlQualifiedName != DecimalFormatDecl.Default.Name)
					{
						throw new XslLoadException("Xslt_NoDecimalFormat", (QilLiteral)formatName);
					}
					format = DecimalFormatDecl.Default;
				}
				if (formatPicture.NodeType == QilNodeType.LiteralString)
				{
					QilIterator qilIterator = f.Let(f.InvokeRegisterDecimalFormatter(formatPicture, format));
					qilIterator.DebugName = f.QName("formatter" + formatterCnt++, "urn:schemas-microsoft-com:xslt-debug").ToString();
					gloVars.Add(qilIterator);
					return f.InvokeFormatNumberStatic(value, qilIterator);
				}
				formatNumberDynamicUsed = true;
				QilNode decimalFormatName = f.QName(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
				return f.InvokeFormatNumberDynamic(value, formatPicture, decimalFormatName, formatName);
			}
			formatNumberDynamicUsed = true;
			QilIterator qilIterator2 = f.Let(formatName);
			QilNode decimalFormatName2 = ResolveQNameDynamic(ignoreDefaultNs: true, qilIterator2);
			return f.Loop(qilIterator2, f.InvokeFormatNumberDynamic(value, formatPicture, decimalFormatName2, qilIterator2));
		}

		private QilNode CompileUnparsedEntityUri(QilNode n)
		{
			return f.Error(lastScope.SourceLine, "Xslt_UnsupportedXsltFunction", "unparsed-entity-uri");
		}

		private QilNode CompileGenerateId(QilNode n)
		{
			if (n.XmlType.IsSingleton)
			{
				return f.XsltGenerateId(n);
			}
			QilIterator expr;
			return f.StrConcat(f.Loop(expr = f.FirstNode(n), f.XsltGenerateId(expr)));
		}

		private XmlQualifiedName ResolveQNameThrow(bool ignoreDefaultNs, QilNode qilName)
		{
			string qname = (QilLiteral)qilName;
			compiler.ParseQName(qname, out var prefix, out var localName, default(ThrowErrorHelper));
			string ns = ResolvePrefixThrow(ignoreDefaultNs, prefix);
			return new XmlQualifiedName(localName, ns);
		}

		private QilNode CompileSystemProperty(QilNode name)
		{
			if (name.NodeType == QilNodeType.LiteralString)
			{
				XmlQualifiedName xmlQualifiedName = ResolveQNameThrow(ignoreDefaultNs: true, name);
				if (EvaluateFuncCalls)
				{
					XPathItem xPathItem = XsltFunctions.SystemProperty(xmlQualifiedName);
					if (xPathItem.ValueType == XsltConvert.StringType)
					{
						return f.String(xPathItem.Value);
					}
					return f.Double(xPathItem.ValueAsDouble);
				}
				name = f.QName(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
			}
			else
			{
				name = ResolveQNameDynamic(ignoreDefaultNs: true, name);
			}
			return f.InvokeSystemProperty(name);
		}

		private QilNode CompileElementAvailable(QilNode name)
		{
			if (name.NodeType == QilNodeType.LiteralString)
			{
				XmlQualifiedName xmlQualifiedName = ResolveQNameThrow(ignoreDefaultNs: false, name);
				if (EvaluateFuncCalls)
				{
					return f.Boolean(IsElementAvailable(xmlQualifiedName));
				}
				name = f.QName(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
			}
			else
			{
				name = ResolveQNameDynamic(ignoreDefaultNs: false, name);
			}
			return f.InvokeElementAvailable(name);
		}

		private QilNode CompileFunctionAvailable(QilNode name)
		{
			if (name.NodeType == QilNodeType.LiteralString)
			{
				XmlQualifiedName xmlQualifiedName = ResolveQNameThrow(ignoreDefaultNs: true, name);
				if (EvaluateFuncCalls && (xmlQualifiedName.Namespace.Length == 0 || xmlQualifiedName.Namespace == "http://www.w3.org/1999/XSL/Transform"))
				{
					return f.Boolean(IsFunctionAvailable(xmlQualifiedName.Name, xmlQualifiedName.Namespace));
				}
				name = f.QName(xmlQualifiedName.Name, xmlQualifiedName.Namespace);
			}
			else
			{
				name = ResolveQNameDynamic(ignoreDefaultNs: true, name);
			}
			return f.InvokeFunctionAvailable(name);
		}

		private QilNode CompileMsNodeSet(QilNode n)
		{
			if (n.XmlType.IsNode && n.XmlType.IsNotRtf)
			{
				return n;
			}
			return f.XsltConvert(n, XmlQueryTypeFactory.NodeSDod);
		}

		private QilNode EXslObjectType(QilNode n)
		{
			if (EvaluateFuncCalls)
			{
				switch (n.XmlType.TypeCode)
				{
				case XmlTypeCode.Boolean:
					return f.String("boolean");
				case XmlTypeCode.Double:
					return f.String("number");
				case XmlTypeCode.String:
					return f.String("string");
				}
				if (n.XmlType.IsNode && n.XmlType.IsNotRtf)
				{
					return f.String("node-set");
				}
			}
			return f.InvokeEXslObjectType(n);
		}
	}
	internal class QilStrConcatenator
	{
		private XPathQilFactory f;

		private StringBuilder builder;

		private QilList concat;

		private bool inUse;

		public QilStrConcatenator(XPathQilFactory f)
		{
			this.f = f;
			builder = new StringBuilder();
		}

		public void Reset()
		{
			inUse = true;
			builder.Length = 0;
			concat = null;
		}

		private void FlushBuilder()
		{
			if (concat == null)
			{
				concat = f.BaseFactory.Sequence();
			}
			if (builder.Length != 0)
			{
				concat.Add(f.String(builder.ToString()));
				builder.Length = 0;
			}
		}

		public void Append(string value)
		{
			builder.Append(value);
		}

		public void Append(char value)
		{
			builder.Append(value);
		}

		public void Append(QilNode value)
		{
			if (value != null)
			{
				if (value.NodeType == QilNodeType.LiteralString)
				{
					builder.Append((string)(QilLiteral)value);
					return;
				}
				FlushBuilder();
				concat.Add(value);
			}
		}

		public QilNode ToQil()
		{
			inUse = false;
			if (concat == null)
			{
				return f.String(builder.ToString());
			}
			FlushBuilder();
			return f.StrConcat(concat);
		}
	}
	internal class ScriptClass
	{
		public string ns;

		public CompilerInfo compilerInfo;

		public StringCollection refAssemblies;

		public StringCollection nsImports;

		public CodeTypeDeclaration typeDecl;

		public bool refAssembliesByHref;

		public Dictionary<string, string> scriptUris;

		public string endUri;

		public Location endLoc;

		private static long scriptClassCounter;

		public ISourceLineInfo EndLineInfo => new SourceLineInfo(endUri, endLoc, endLoc);

		public ScriptClass(string ns, CompilerInfo compilerInfo)
		{
			this.ns = ns;
			this.compilerInfo = compilerInfo;
			refAssemblies = new StringCollection();
			nsImports = new StringCollection();
			typeDecl = new CodeTypeDeclaration(GenerateUniqueClassName());
			refAssembliesByHref = false;
			scriptUris = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
		}

		private static string GenerateUniqueClassName()
		{
			return "Script" + Interlocked.Increment(ref scriptClassCounter);
		}

		public void AddScriptBlock(string source, string uriString, int lineNumber, Location end)
		{
			CodeSnippetTypeMember codeSnippetTypeMember = new CodeSnippetTypeMember(source);
			string fileName = SourceLineInfo.GetFileName(uriString);
			if (lineNumber > 0)
			{
				codeSnippetTypeMember.LinePragma = new CodeLinePragma(fileName, lineNumber);
				scriptUris[fileName] = uriString;
			}
			typeDecl.Members.Add(codeSnippetTypeMember);
			endUri = uriString;
			endLoc = end;
		}
	}
	internal class Scripts
	{
		private const string ScriptClassesNamespace = "System.Xml.Xsl.CompiledQuery";

		private Compiler compiler;

		private List<ScriptClass> scriptClasses = new List<ScriptClass>();

		private Dictionary<string, Type> nsToType = new Dictionary<string, Type>();

		private XmlExtensionFunctionTable extFuncs = new XmlExtensionFunctionTable();

		private static readonly string[] defaultNamespaces = new string[7] { "System", "System.Collections", "System.Text", "System.Text.RegularExpressions", "System.Xml", "System.Xml.Xsl", "System.Xml.XPath" };

		private int assemblyCounter;

		public Dictionary<string, Type> ScriptClasses => nsToType;

		public Scripts(Compiler compiler)
		{
			this.compiler = compiler;
		}

		public XmlExtensionFunction ResolveFunction(string name, string ns, int numArgs, IErrorHelper errorHelper)
		{
			if (nsToType.TryGetValue(ns, out var value))
			{
				try
				{
					return extFuncs.Bind(name, ns, numArgs, value, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
				}
				catch (XslTransformException ex)
				{
					errorHelper.ReportError(ex.Message);
				}
			}
			return null;
		}

		public ScriptClass GetScriptClass(string ns, string language, IErrorHelper errorHelper)
		{
			CompilerInfo compilerInfo;
			try
			{
				compilerInfo = CodeDomProvider.GetCompilerInfo(language);
			}
			catch (ConfigurationException)
			{
				errorHelper.ReportError("Xslt_ScriptInvalidLanguage", language);
				return null;
			}
			foreach (ScriptClass scriptClass2 in scriptClasses)
			{
				if (ns == scriptClass2.ns)
				{
					if (compilerInfo != scriptClass2.compilerInfo)
					{
						errorHelper.ReportError("Xslt_ScriptMixedLanguages", ns);
						return null;
					}
					return scriptClass2;
				}
			}
			ScriptClass scriptClass = new ScriptClass(ns, compilerInfo);
			scriptClass.typeDecl.TypeAttributes = TypeAttributes.Public;
			scriptClasses.Add(scriptClass);
			return scriptClass;
		}

		public void CompileScripts()
		{
			List<ScriptClass> list = new List<ScriptClass>();
			for (int i = 0; i < scriptClasses.Count; i++)
			{
				if (scriptClasses[i] == null)
				{
					continue;
				}
				CompilerInfo compilerInfo = scriptClasses[i].compilerInfo;
				list.Clear();
				for (int j = i; j < scriptClasses.Count; j++)
				{
					if (scriptClasses[j] != null && scriptClasses[j].compilerInfo == compilerInfo)
					{
						list.Add(scriptClasses[j]);
						scriptClasses[j] = null;
					}
				}
				Assembly assembly = CompileAssembly(list);
				if (!(assembly != null))
				{
					continue;
				}
				foreach (ScriptClass item in list)
				{
					Type type = assembly.GetType("System.Xml.Xsl.CompiledQuery" + Type.Delimiter + item.typeDecl.Name);
					if (type != null)
					{
						nsToType.Add(item.ns, type);
					}
				}
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		private Assembly CompileAssembly(List<ScriptClass> scriptsForLang)
		{
			TempFileCollection tempFiles = compiler.CompilerResults.TempFiles;
			CompilerErrorCollection errors = compiler.CompilerResults.Errors;
			ScriptClass scriptClass = scriptsForLang[scriptsForLang.Count - 1];
			bool flag = false;
			CodeDomProvider codeDomProvider;
			try
			{
				codeDomProvider = scriptClass.compilerInfo.CreateProvider();
			}
			catch (ConfigurationException ex)
			{
				errors.Add(compiler.CreateError(scriptClass.EndLineInfo, "Xslt_ScriptCompileException", ex.Message));
				return null;
			}
			flag = codeDomProvider is VBCodeProvider;
			CodeCompileUnit[] array = new CodeCompileUnit[scriptsForLang.Count];
			CompilerParameters compilerParameters = scriptClass.compilerInfo.CreateDefaultCompilerParameters();
			compilerParameters.ReferencedAssemblies.Add(typeof(Res).Assembly.Location);
			compilerParameters.ReferencedAssemblies.Add("System.dll");
			if (flag)
			{
				compilerParameters.ReferencedAssemblies.Add("Microsoft.VisualBasic.dll");
			}
			bool flag2 = false;
			for (int i = 0; i < scriptsForLang.Count; i++)
			{
				ScriptClass scriptClass2 = scriptsForLang[i];
				CodeNamespace codeNamespace = new CodeNamespace("System.Xml.Xsl.CompiledQuery");
				string[] array2 = defaultNamespaces;
				foreach (string nameSpace in array2)
				{
					codeNamespace.Imports.Add(new CodeNamespaceImport(nameSpace));
				}
				if (flag)
				{
					codeNamespace.Imports.Add(new CodeNamespaceImport("Microsoft.VisualBasic"));
				}
				StringEnumerator enumerator = scriptClass2.nsImports.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						string current = enumerator.Current;
						codeNamespace.Imports.Add(new CodeNamespaceImport(current));
					}
				}
				finally
				{
					if (enumerator is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
				codeNamespace.Types.Add(scriptClass2.typeDecl);
				CodeCompileUnit codeCompileUnit = new CodeCompileUnit();
				codeCompileUnit.Namespaces.Add(codeNamespace);
				if (flag)
				{
					codeCompileUnit.UserData["AllowLateBound"] = true;
					codeCompileUnit.UserData["RequireVariableDeclaration"] = false;
				}
				if (i == 0)
				{
					codeCompileUnit.AssemblyCustomAttributes.Add(new CodeAttributeDeclaration("System.Security.SecurityTransparentAttribute"));
					codeCompileUnit.AssemblyCustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(SecurityRulesAttribute)), new CodeAttributeArgument(new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(SecurityRuleSet)), "Level1"))));
				}
				array[i] = codeCompileUnit;
				StringEnumerator enumerator2 = scriptClass2.refAssemblies.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						string current2 = enumerator2.Current;
						compilerParameters.ReferencedAssemblies.Add(current2);
					}
				}
				finally
				{
					if (enumerator2 is IDisposable disposable2)
					{
						disposable2.Dispose();
					}
				}
				flag2 |= scriptClass2.refAssembliesByHref;
			}
			XsltSettings settings = compiler.Settings;
			compilerParameters.WarningLevel = ((settings.WarningLevel >= 0) ? settings.WarningLevel : compilerParameters.WarningLevel);
			compilerParameters.TreatWarningsAsErrors = settings.TreatWarningsAsErrors;
			compilerParameters.IncludeDebugInformation = compiler.IsDebug;
			string text = compiler.ScriptAssemblyPath;
			if (text != null && scriptsForLang.Count < scriptClasses.Count)
			{
				text = Path.ChangeExtension(text, "." + GetLanguageName(scriptClass.compilerInfo) + Path.GetExtension(text));
			}
			compilerParameters.OutputAssembly = text;
			string tempDir = ((settings.TempFiles != null) ? settings.TempFiles.TempDir : null);
			compilerParameters.TempFiles = new TempFileCollection(tempDir);
			bool keepFiles = compiler.IsDebug && text == null && !settings.CheckOnly;
			compilerParameters.TempFiles.KeepFiles = keepFiles;
			compilerParameters.GenerateInMemory = (text == null && !compiler.IsDebug && !flag2) || settings.CheckOnly;
			CompilerResults compilerResults;
			try
			{
				compilerResults = codeDomProvider.CompileAssemblyFromDom(compilerParameters, array);
			}
			catch (ExternalException ex2)
			{
				compilerResults = new CompilerResults(compilerParameters.TempFiles);
				compilerResults.Errors.Add(compiler.CreateError(scriptClass.EndLineInfo, "Xslt_ScriptCompileException", ex2.Message));
			}
			if (!settings.CheckOnly)
			{
				foreach (string tempFile in compilerResults.TempFiles)
				{
					tempFiles.AddFile(tempFile, tempFiles.KeepFiles);
				}
			}
			foreach (CompilerError error in compilerResults.Errors)
			{
				FixErrorPosition(error, scriptsForLang);
				compiler.AddModule(error.FileName);
			}
			errors.AddRange(compilerResults.Errors);
			if (!compilerResults.Errors.HasErrors)
			{
				return compilerResults.CompiledAssembly;
			}
			return null;
		}

		private string GetLanguageName(CompilerInfo compilerInfo)
		{
			Regex regex = new Regex("^[0-9a-zA-Z]+$");
			string[] languages = compilerInfo.GetLanguages();
			foreach (string text in languages)
			{
				if (regex.IsMatch(text))
				{
					return text;
				}
			}
			return "script" + (++assemblyCounter).ToString(CultureInfo.InvariantCulture);
		}

		private static void FixErrorPosition(CompilerError error, List<ScriptClass> scriptsForLang)
		{
			string fileName = error.FileName;
			foreach (ScriptClass item in scriptsForLang)
			{
				if (item.scriptUris.TryGetValue(fileName, out var value))
				{
					error.FileName = value;
					return;
				}
			}
			ScriptClass scriptClass = scriptsForLang[scriptsForLang.Count - 1];
			fileName = Path.GetFileNameWithoutExtension(fileName);
			int num;
			if ((num = fileName.LastIndexOf('.')) >= 0 && int.TryParse(fileName.Substring(num + 1), NumberStyles.None, NumberFormatInfo.InvariantInfo, out var result) && (uint)result < scriptsForLang.Count)
			{
				scriptClass = scriptsForLang[result];
			}
			error.FileName = scriptClass.endUri;
			error.Line = scriptClass.endLoc.Line;
			error.Column = scriptClass.endLoc.Pos;
		}
	}
	internal class StylesheetLevel
	{
		public Stylesheet[] Imports;

		public Dictionary<QilName, XslFlags> ModeFlags = new Dictionary<QilName, XslFlags>();

		public Dictionary<QilName, List<QilFunction>> ApplyFunctions = new Dictionary<QilName, List<QilFunction>>();
	}
	internal class Stylesheet : StylesheetLevel
	{
		private Compiler compiler;

		public List<Uri> ImportHrefs = new List<Uri>();

		public List<XslNode> GlobalVarPars = new List<XslNode>();

		public Dictionary<QilName, AttributeSet> AttributeSets = new Dictionary<QilName, AttributeSet>();

		private int importPrecedence;

		private int orderNumber;

		public List<WhitespaceRule>[] WhitespaceRules = new List<WhitespaceRule>[3];

		public List<Template> Templates = new List<Template>();

		public Dictionary<QilName, List<TemplateMatch>> TemplateMatches = new Dictionary<QilName, List<TemplateMatch>>();

		public int ImportPrecedence => importPrecedence;

		public void AddTemplateMatch(Template template, QilLoop filter)
		{
			if (!TemplateMatches.TryGetValue(template.Mode, out var value))
			{
				List<TemplateMatch> list2 = (TemplateMatches[template.Mode] = new List<TemplateMatch>());
				value = list2;
			}
			value.Add(new TemplateMatch(template, filter));
		}

		public void SortTemplateMatches()
		{
			foreach (QilName key in TemplateMatches.Keys)
			{
				TemplateMatches[key].Sort(TemplateMatch.Comparer);
			}
		}

		public Stylesheet(Compiler compiler, int importPrecedence)
		{
			this.compiler = compiler;
			this.importPrecedence = importPrecedence;
			WhitespaceRules[0] = new List<WhitespaceRule>();
			WhitespaceRules[1] = new List<WhitespaceRule>();
			WhitespaceRules[2] = new List<WhitespaceRule>();
		}

		public void AddWhitespaceRule(int index, WhitespaceRule rule)
		{
			WhitespaceRules[index].Add(rule);
		}

		public bool AddVarPar(VarPar var)
		{
			foreach (XslNode globalVarPar in GlobalVarPars)
			{
				if (globalVarPar.Name.Equals(var.Name))
				{
					return compiler.AllGlobalVarPars.ContainsKey(var.Name);
				}
			}
			GlobalVarPars.Add(var);
			return true;
		}

		public bool AddTemplate(Template template)
		{
			template.ImportPrecedence = importPrecedence;
			template.OrderNumber = orderNumber++;
			compiler.AllTemplates.Add(template);
			if (template.Name != null)
			{
				if (!compiler.NamedTemplates.TryGetValue(template.Name, out var value))
				{
					compiler.NamedTemplates[template.Name] = template;
				}
				else if (value.ImportPrecedence == template.ImportPrecedence)
				{
					return false;
				}
			}
			if (template.Match != null)
			{
				Templates.Add(template);
			}
			return true;
		}
	}
	internal class XPathPatternBuilder : XPathPatternParser.IPatternBuilder, IXPathBuilder<QilNode>
	{
		private class Annotation
		{
			public double Priority;

			public QilLoop Parent;
		}

		private class XPathPredicateEnvironment : IXPathEnvironment, IFocus
		{
			private readonly IXPathEnvironment baseEnvironment;

			private readonly XPathQilFactory f;

			public readonly XPathBuilder.FixupVisitor fixupVisitor;

			private readonly QilNode fixupCurrent;

			private readonly QilNode fixupPosition;

			private readonly QilNode fixupLast;

			public int numFixupCurrent;

			public int numFixupPosition;

			public int numFixupLast;

			public XPathQilFactory Factory => f;

			public XPathPredicateEnvironment(IXPathEnvironment baseEnvironment)
			{
				this.baseEnvironment = baseEnvironment;
				f = baseEnvironment.Factory;
				fixupCurrent = f.Unknown(XmlQueryTypeFactory.NodeNotRtf);
				fixupPosition = f.Unknown(XmlQueryTypeFactory.DoubleX);
				fixupLast = f.Unknown(XmlQueryTypeFactory.DoubleX);
				fixupVisitor = new XPathBuilder.FixupVisitor(f, fixupCurrent, fixupPosition, fixupLast);
			}

			public QilNode ResolveVariable(string prefix, string name)
			{
				return baseEnvironment.ResolveVariable(prefix, name);
			}

			public QilNode ResolveFunction(string prefix, string name, IList<QilNode> args, IFocus env)
			{
				return baseEnvironment.ResolveFunction(prefix, name, args, env);
			}

			public string ResolvePrefix(string prefix)
			{
				return baseEnvironment.ResolvePrefix(prefix);
			}

			public QilNode GetCurrent()
			{
				numFixupCurrent++;
				return fixupCurrent;
			}

			public QilNode GetPosition()
			{
				numFixupPosition++;
				return fixupPosition;
			}

			public QilNode GetLast()
			{
				numFixupLast++;
				return fixupLast;
			}
		}

		private class XsltFunctionFocus : IFocus
		{
			private QilIterator current;

			public XsltFunctionFocus(QilIterator current)
			{
				this.current = current;
			}

			public QilNode GetCurrent()
			{
				return current;
			}

			public QilNode GetPosition()
			{
				return null;
			}

			public QilNode GetLast()
			{
				return null;
			}
		}

		private XPathPredicateEnvironment predicateEnvironment;

		private XPathBuilder predicateBuilder;

		private bool inTheBuild;

		private XPathQilFactory f;

		private QilNode fixupNode;

		private IXPathEnvironment environment;

		public QilNode FixupNode => fixupNode;

		public XPathPatternBuilder(IXPathEnvironment environment)
		{
			this.environment = environment;
			f = environment.Factory;
			predicateEnvironment = new XPathPredicateEnvironment(environment);
			predicateBuilder = new XPathBuilder(predicateEnvironment);
			fixupNode = f.Unknown(XmlQueryTypeFactory.NodeNotRtfS);
		}

		public virtual void StartBuild()
		{
			inTheBuild = true;
		}

		[Conditional("DEBUG")]
		public void AssertFilter(QilLoop filter)
		{
		}

		private void FixupFilterBinding(QilLoop filter, QilNode newBinding)
		{
			filter.Variable.Binding = newBinding;
		}

		public virtual QilNode EndBuild(QilNode result)
		{
			inTheBuild = false;
			return result;
		}

		public QilNode Operator(XPathOperator op, QilNode left, QilNode right)
		{
			if (left.NodeType == QilNodeType.Sequence)
			{
				((QilList)left).Add(right);
				return left;
			}
			return f.Sequence(left, right);
		}

		private static QilLoop BuildAxisFilter(QilPatternFactory f, QilIterator itr, XPathAxis xpathAxis, XPathNodeType nodeType, string name, string nsUri)
		{
			QilNode right = ((name != null && nsUri != null) ? f.Eq(f.NameOf(itr), f.QName(name, nsUri)) : ((nsUri != null) ? f.Eq(f.NamespaceUriOf(itr), f.String(nsUri)) : ((name != null) ? f.Eq(f.LocalNameOf(itr), f.String(name)) : f.True())));
			XmlNodeKindFlags xmlNodeKindFlags = XPathBuilder.AxisTypeMask(itr.XmlType.NodeKinds, nodeType, xpathAxis);
			QilNode left = ((xmlNodeKindFlags == XmlNodeKindFlags.None) ? f.False() : ((xmlNodeKindFlags == itr.XmlType.NodeKinds) ? f.True() : f.IsType(itr, XmlQueryTypeFactory.NodeChoice(xmlNodeKindFlags))));
			QilLoop qilLoop = f.BaseFactory.Filter(itr, f.And(left, right));
			qilLoop.XmlType = XmlQueryTypeFactory.PrimeProduct(XmlQueryTypeFactory.NodeChoice(xmlNodeKindFlags), qilLoop.XmlType.Cardinality);
			return qilLoop;
		}

		public QilNode Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name)
		{
			QilLoop qilLoop;
			double priority;
			switch (xpathAxis)
			{
			case XPathAxis.DescendantOrSelf:
				return f.Nop(fixupNode);
			case XPathAxis.Root:
			{
				QilIterator expr;
				qilLoop = f.BaseFactory.Filter(expr = f.For(fixupNode), f.IsType(expr, XmlQueryTypeFactory.Document));
				priority = 0.5;
				break;
			}
			default:
			{
				string nsUri = ((prefix == null) ? null : environment.ResolvePrefix(prefix));
				qilLoop = BuildAxisFilter(f, f.For(fixupNode), xpathAxis, nodeType, name, nsUri);
				switch (nodeType)
				{
				case XPathNodeType.Element:
				case XPathNodeType.Attribute:
					priority = ((name == null) ? ((prefix == null) ? (-0.5) : (-0.25)) : 0.0);
					break;
				case XPathNodeType.ProcessingInstruction:
					priority = ((name != null) ? 0.0 : (-0.5));
					break;
				default:
					priority = -0.5;
					break;
				}
				break;
			}
			}
			SetPriority(qilLoop, priority);
			SetLastParent(qilLoop, qilLoop);
			return qilLoop;
		}

		public QilNode JoinStep(QilNode left, QilNode right)
		{
			if (left.NodeType == QilNodeType.Nop)
			{
				QilUnary qilUnary = (QilUnary)left;
				qilUnary.Child = right;
				return qilUnary;
			}
			CleanAnnotation(left);
			QilLoop qilLoop = (QilLoop)left;
			bool flag = false;
			if (right.NodeType == QilNodeType.Nop)
			{
				flag = true;
				QilUnary qilUnary2 = (QilUnary)right;
				right = qilUnary2.Child;
			}
			QilLoop lastParent = GetLastParent(right);
			FixupFilterBinding(qilLoop, flag ? f.Ancestor(lastParent.Variable) : f.Parent(lastParent.Variable));
			lastParent.Body = f.And(lastParent.Body, f.Not(f.IsEmpty(qilLoop)));
			SetPriority(right, 0.5);
			SetLastParent(right, qilLoop);
			return right;
		}

		QilNode IXPathBuilder<QilNode>.Predicate(QilNode node, QilNode condition, bool isReverseStep)
		{
			return null;
		}

		public QilNode BuildPredicates(QilNode nodeset, List<QilNode> predicates)
		{
			List<QilNode> list = new List<QilNode>(predicates.Count);
			foreach (QilNode predicate in predicates)
			{
				list.Add(XPathBuilder.PredicateToBoolean(predicate, f, predicateEnvironment));
			}
			QilLoop qilLoop = (QilLoop)nodeset;
			QilIterator variable = qilLoop.Variable;
			if (predicateEnvironment.numFixupLast == 0 && predicateEnvironment.numFixupPosition == 0)
			{
				foreach (QilNode item in list)
				{
					qilLoop.Body = f.And(qilLoop.Body, item);
				}
				qilLoop.Body = predicateEnvironment.fixupVisitor.Fixup(qilLoop.Body, variable, null);
			}
			else
			{
				QilIterator qilIterator = f.For(f.Parent(variable));
				QilNode binding = f.Content(qilIterator);
				QilLoop qilLoop2 = (QilLoop)nodeset.DeepClone(f.BaseFactory);
				qilLoop2.Variable.Binding = binding;
				qilLoop2 = (QilLoop)f.Loop(qilIterator, qilLoop2);
				QilNode qilNode = qilLoop2;
				foreach (QilNode item2 in list)
				{
					qilNode = XPathBuilder.BuildOnePredicate(qilNode, item2, isReverseStep: false, f, predicateEnvironment.fixupVisitor, ref predicateEnvironment.numFixupCurrent, ref predicateEnvironment.numFixupPosition, ref predicateEnvironment.numFixupLast);
				}
				QilIterator qilIterator2 = f.For(qilNode);
				QilNode set = f.Filter(qilIterator2, f.Is(qilIterator2, variable));
				qilLoop.Body = f.Not(f.IsEmpty(set));
				qilLoop.Body = f.And(f.IsType(variable, qilLoop.XmlType), qilLoop.Body);
			}
			SetPriority(nodeset, 0.5);
			return nodeset;
		}

		public QilNode Function(string prefix, string name, IList<QilNode> args)
		{
			QilIterator qilIterator = f.For(fixupNode);
			QilNode binding = ((!(name == "id")) ? environment.ResolveFunction(prefix, name, args, new XsltFunctionFocus(qilIterator)) : f.Id(qilIterator, args[0]));
			QilIterator left;
			QilLoop qilLoop = f.BaseFactory.Filter(qilIterator, f.Not(f.IsEmpty(f.Filter(left = f.For(binding), f.Is(left, qilIterator)))));
			SetPriority(qilLoop, 0.5);
			SetLastParent(qilLoop, qilLoop);
			return qilLoop;
		}

		public QilNode String(string value)
		{
			return f.String(value);
		}

		public QilNode Number(double value)
		{
			return UnexpectedToken("Literal number");
		}

		public QilNode Variable(string prefix, string name)
		{
			return UnexpectedToken("Variable");
		}

		private QilNode UnexpectedToken(string tokenName)
		{
			string message = string.Format(CultureInfo.InvariantCulture, "Internal Error: {0} is not allowed in XSLT pattern outside of predicate.", new object[1] { tokenName });
			throw new Exception(message);
		}

		public static void SetPriority(QilNode node, double priority)
		{
			Annotation annotation = ((Annotation)node.Annotation) ?? new Annotation();
			annotation.Priority = priority;
			node.Annotation = annotation;
		}

		public static double GetPriority(QilNode node)
		{
			return ((Annotation)node.Annotation).Priority;
		}

		private static void SetLastParent(QilNode node, QilLoop parent)
		{
			Annotation annotation = ((Annotation)node.Annotation) ?? new Annotation();
			annotation.Parent = parent;
			node.Annotation = annotation;
		}

		private static QilLoop GetLastParent(QilNode node)
		{
			return ((Annotation)node.Annotation).Parent;
		}

		public static void CleanAnnotation(QilNode node)
		{
			node.Annotation = null;
		}

		public IXPathBuilder<QilNode> GetPredicateBuilder(QilNode ctx)
		{
			QilLoop qilLoop = (QilLoop)ctx;
			return predicateBuilder;
		}
	}
	internal class XPathPatternParser
	{
		public interface IPatternBuilder : IXPathBuilder<QilNode>
		{
			IXPathBuilder<QilNode> GetPredicateBuilder(QilNode context);
		}

		private System.Xml.Xsl.XPath.XPathScanner scanner;

		private IPatternBuilder ptrnBuilder;

		private XPathParser<QilNode> predicateParser = new XPathParser<QilNode>();

		private const int MaxParseRelativePathDepth = 1024;

		private int parseRelativePath;

		public QilNode Parse(System.Xml.Xsl.XPath.XPathScanner scanner, IPatternBuilder ptrnBuilder)
		{
			QilNode result = null;
			ptrnBuilder.StartBuild();
			try
			{
				this.scanner = scanner;
				this.ptrnBuilder = ptrnBuilder;
				result = ParsePattern();
				this.scanner.CheckToken(LexKind.Eof);
			}
			finally
			{
				result = ptrnBuilder.EndBuild(result);
			}
			return result;
		}

		private QilNode ParsePattern()
		{
			QilNode qilNode = ParseLocationPathPattern();
			while (scanner.Kind == LexKind.Union)
			{
				scanner.NextLex();
				qilNode = ptrnBuilder.Operator(XPathOperator.Union, qilNode, ParseLocationPathPattern());
			}
			return qilNode;
		}

		private QilNode ParseLocationPathPattern()
		{
			switch (scanner.Kind)
			{
			case LexKind.Slash:
			{
				scanner.NextLex();
				QilNode qilNode = ptrnBuilder.Axis(XPathAxis.Root, XPathNodeType.All, null, null);
				if (XPathParser<QilNode>.IsStep(scanner.Kind))
				{
					qilNode = ptrnBuilder.JoinStep(qilNode, ParseRelativePathPattern());
				}
				return qilNode;
			}
			case LexKind.SlashSlash:
				scanner.NextLex();
				return ptrnBuilder.JoinStep(ptrnBuilder.Axis(XPathAxis.Root, XPathNodeType.All, null, null), ptrnBuilder.JoinStep(ptrnBuilder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativePathPattern()));
			case LexKind.Name:
				if (scanner.CanBeFunction && scanner.Prefix.Length == 0 && (scanner.Name == "id" || scanner.Name == "key"))
				{
					QilNode qilNode = ParseIdKeyPattern();
					switch (scanner.Kind)
					{
					case LexKind.Slash:
						scanner.NextLex();
						qilNode = ptrnBuilder.JoinStep(qilNode, ParseRelativePathPattern());
						break;
					case LexKind.SlashSlash:
						scanner.NextLex();
						qilNode = ptrnBuilder.JoinStep(qilNode, ptrnBuilder.JoinStep(ptrnBuilder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativePathPattern()));
						break;
					}
					return qilNode;
				}
				break;
			}
			return ParseRelativePathPattern();
		}

		private QilNode ParseIdKeyPattern()
		{
			List<QilNode> list = new List<QilNode>(2);
			if (scanner.Name == "id")
			{
				scanner.NextLex();
				scanner.PassToken(LexKind.LParens);
				scanner.CheckToken(LexKind.String);
				list.Add(ptrnBuilder.String(scanner.StringValue));
				scanner.NextLex();
				scanner.PassToken(LexKind.RParens);
				return ptrnBuilder.Function("", "id", list);
			}
			scanner.NextLex();
			scanner.PassToken(LexKind.LParens);
			scanner.CheckToken(LexKind.String);
			list.Add(ptrnBuilder.String(scanner.StringValue));
			scanner.NextLex();
			scanner.PassToken(LexKind.Comma);
			scanner.CheckToken(LexKind.String);
			list.Add(ptrnBuilder.String(scanner.StringValue));
			scanner.NextLex();
			scanner.PassToken(LexKind.RParens);
			return ptrnBuilder.Function("", "key", list);
		}

		private QilNode ParseRelativePathPattern()
		{
			if (++parseRelativePath > 1024 && XsltConfigSection.LimitXPathComplexity)
			{
				throw scanner.CreateException("Xslt_InputTooComplex");
			}
			QilNode qilNode = ParseStepPattern();
			if (scanner.Kind == LexKind.Slash)
			{
				scanner.NextLex();
				qilNode = ptrnBuilder.JoinStep(qilNode, ParseRelativePathPattern());
			}
			else if (scanner.Kind == LexKind.SlashSlash)
			{
				scanner.NextLex();
				qilNode = ptrnBuilder.JoinStep(qilNode, ptrnBuilder.JoinStep(ptrnBuilder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativePathPattern()));
			}
			parseRelativePath--;
			return qilNode;
		}

		private QilNode ParseStepPattern()
		{
			XPathAxis xPathAxis;
			switch (scanner.Kind)
			{
			case LexKind.DotDot:
			case LexKind.Dot:
				throw scanner.CreateException("XPath_InvalidAxisInPattern");
			case LexKind.At:
				xPathAxis = XPathAxis.Attribute;
				scanner.NextLex();
				break;
			case LexKind.Axis:
				xPathAxis = scanner.Axis;
				if (xPathAxis != XPathAxis.Child && xPathAxis != XPathAxis.Attribute)
				{
					throw scanner.CreateException("XPath_InvalidAxisInPattern");
				}
				scanner.NextLex();
				scanner.NextLex();
				break;
			case LexKind.Name:
			case LexKind.Star:
				xPathAxis = XPathAxis.Child;
				break;
			default:
				throw scanner.CreateException("XPath_UnexpectedToken", scanner.RawValue);
			}
			XPathParser<QilNode>.InternalParseNodeTest(scanner, xPathAxis, out var nodeType, out var nodePrefix, out var nodeName);
			QilNode qilNode = ptrnBuilder.Axis(xPathAxis, nodeType, nodePrefix, nodeName);
			if (ptrnBuilder is XPathPatternBuilder xPathPatternBuilder)
			{
				List<QilNode> list = new List<QilNode>();
				while (scanner.Kind == LexKind.LBracket)
				{
					list.Add(ParsePredicate(qilNode));
				}
				if (list.Count > 0)
				{
					qilNode = xPathPatternBuilder.BuildPredicates(qilNode, list);
				}
			}
			else
			{
				while (scanner.Kind == LexKind.LBracket)
				{
					qilNode = ptrnBuilder.Predicate(qilNode, ParsePredicate(qilNode), reverseStep: false);
				}
			}
			return qilNode;
		}

		private QilNode ParsePredicate(QilNode context)
		{
			scanner.NextLex();
			QilNode result = predicateParser.Parse(scanner, ptrnBuilder.GetPredicateBuilder(context), LexKind.RBracket);
			scanner.NextLex();
			return result;
		}
	}
	internal enum XslNodeType
	{
		Unknown,
		ApplyImports,
		ApplyTemplates,
		Attribute,
		AttributeSet,
		CallTemplate,
		Choose,
		Comment,
		Copy,
		CopyOf,
		Element,
		Error,
		ForEach,
		If,
		Key,
		List,
		LiteralAttribute,
		LiteralElement,
		Message,
		Nop,
		Number,
		Otherwise,
		Param,
		PI,
		Sort,
		Template,
		Text,
		UseAttributeSet,
		ValueOf,
		ValueOfDoe,
		Variable,
		WithParam
	}
	internal class NsDecl
	{
		public readonly NsDecl Prev;

		public readonly string Prefix;

		public readonly string NsUri;

		public NsDecl(NsDecl prev, string prefix, string nsUri)
		{
			Prev = prev;
			Prefix = prefix;
			NsUri = nsUri;
		}
	}
	internal class XslNode
	{
		public readonly XslNodeType NodeType;

		public ISourceLineInfo SourceLine;

		public NsDecl Namespaces;

		public readonly QilName Name;

		public readonly object Arg;

		public readonly XslVersion XslVersion;

		public XslFlags Flags;

		private List<XslNode> content;

		private static readonly IList<XslNode> EmptyList = new List<XslNode>().AsReadOnly();

		public string Select => (string)Arg;

		public bool ForwardsCompatible => XslVersion == XslVersion.ForwardsCompatible;

		public IList<XslNode> Content
		{
			get
			{
				IList<XslNode> list = content;
				return list ?? EmptyList;
			}
		}

		internal string TraceName => null;

		public XslNode(XslNodeType nodeType, QilName name, object arg, XslVersion xslVer)
		{
			NodeType = nodeType;
			Name = name;
			Arg = arg;
			XslVersion = xslVer;
		}

		public XslNode(XslNodeType nodeType)
		{
			NodeType = nodeType;
			XslVersion = XslVersion.Version10;
		}

		public void SetContent(List<XslNode> content)
		{
			this.content = content;
		}

		public void AddContent(XslNode node)
		{
			if (content == null)
			{
				content = new List<XslNode>();
			}
			content.Add(node);
		}

		public void InsertContent(IEnumerable<XslNode> collection)
		{
			if (content == null)
			{
				content = new List<XslNode>(collection);
			}
			else
			{
				content.InsertRange(0, collection);
			}
		}
	}
	internal abstract class ProtoTemplate : XslNode
	{
		public QilFunction Function;

		public ProtoTemplate(XslNodeType nt, QilName name, XslVersion xslVer)
			: base(nt, name, null, xslVer)
		{
		}

		public abstract string GetDebugName();
	}
	internal enum CycleCheck
	{
		NotStarted,
		Processing,
		Completed
	}
	internal class AttributeSet : ProtoTemplate
	{
		public CycleCheck CycleCheck;

		public AttributeSet(QilName name, XslVersion xslVer)
			: base(XslNodeType.AttributeSet, name, xslVer)
		{
		}

		public override string GetDebugName()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("<xsl:attribute-set name=\"");
			stringBuilder.Append(Name.QualifiedName);
			stringBuilder.Append("\">");
			return stringBuilder.ToString();
		}

		public new void AddContent(XslNode node)
		{
			base.AddContent(node);
		}

		public void MergeContent(AttributeSet other)
		{
			InsertContent(other.Content);
		}
	}
	internal class Template : ProtoTemplate
	{
		public readonly string Match;

		public readonly QilName Mode;

		public readonly double Priority;

		public int ImportPrecedence;

		public int OrderNumber;

		public Template(QilName name, string match, QilName mode, double priority, XslVersion xslVer)
			: base(XslNodeType.Template, name, xslVer)
		{
			Match = match;
			Mode = mode;
			Priority = priority;
		}

		public override string GetDebugName()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("<xsl:template");
			if (Match != null)
			{
				stringBuilder.Append(" match=\"");
				stringBuilder.Append(Match);
				stringBuilder.Append('"');
			}
			if (Name != null)
			{
				stringBuilder.Append(" name=\"");
				stringBuilder.Append(Name.QualifiedName);
				stringBuilder.Append('"');
			}
			if (!double.IsNaN(Priority))
			{
				stringBuilder.Append(" priority=\"");
				stringBuilder.Append(Priority.ToString(CultureInfo.InvariantCulture));
				stringBuilder.Append('"');
			}
			if (Mode.LocalName.Length != 0)
			{
				stringBuilder.Append(" mode=\"");
				stringBuilder.Append(Mode.QualifiedName);
				stringBuilder.Append('"');
			}
			stringBuilder.Append('>');
			return stringBuilder.ToString();
		}
	}
	internal class VarPar : XslNode
	{
		public XslFlags DefValueFlags;

		public QilNode Value;

		public VarPar(XslNodeType nt, QilName name, string select, XslVersion xslVer)
			: base(nt, name, select, xslVer)
		{
		}
	}
	internal class Sort : XslNode
	{
		public readonly string Lang;

		public readonly string DataType;

		public readonly string Order;

		public readonly string CaseOrder;

		public Sort(string select, string lang, string dataType, string order, string caseOrder, XslVersion xslVer)
			: base(XslNodeType.Sort, null, select, xslVer)
		{
			Lang = lang;
			DataType = dataType;
			Order = order;
			CaseOrder = caseOrder;
		}
	}
	internal class Keys : KeyedCollection<QilName, List<Key>>
	{
		protected override QilName GetKeyForItem(List<Key> list)
		{
			return list[0].Name;
		}
	}
	internal class Key : XslNode
	{
		public readonly string Match;

		public readonly string Use;

		public QilFunction Function;

		public Key(QilName name, string match, string use, XslVersion xslVer)
			: base(XslNodeType.Key, name, null, xslVer)
		{
			Match = match;
			Use = use;
		}

		public string GetDebugName()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("<xsl:key name=\"");
			stringBuilder.Append(Name.QualifiedName);
			stringBuilder.Append('"');
			if (Match != null)
			{
				stringBuilder.Append(" match=\"");
				stringBuilder.Append(Match);
				stringBuilder.Append('"');
			}
			if (Use != null)
			{
				stringBuilder.Append(" use=\"");
				stringBuilder.Append(Use);
				stringBuilder.Append('"');
			}
			stringBuilder.Append('>');
			return stringBuilder.ToString();
		}
	}
	internal enum NumberLevel
	{
		Single,
		Multiple,
		Any
	}
	internal class Number : XslNode
	{
		public readonly NumberLevel Level;

		public readonly string Count;

		public readonly string From;

		public readonly string Value;

		public readonly string Format;

		public readonly string Lang;

		public readonly string LetterValue;

		public readonly string GroupingSeparator;

		public readonly string GroupingSize;

		public Number(NumberLevel level, string count, string from, string value, string format, string lang, string letterValue, string groupingSeparator, string groupingSize, XslVersion xslVer)
			: base(XslNodeType.Number, null, null, xslVer)
		{
			Level = level;
			Count = count;
			From = from;
			Value = value;
			Format = format;
			Lang = lang;
			LetterValue = letterValue;
			GroupingSeparator = groupingSeparator;
			GroupingSize = groupingSize;
		}
	}
	internal class NodeCtor : XslNode
	{
		public readonly string NameAvt;

		public readonly string NsAvt;

		public NodeCtor(XslNodeType nt, string nameAvt, string nsAvt, XslVersion xslVer)
			: base(nt, null, null, xslVer)
		{
			NameAvt = nameAvt;
			NsAvt = nsAvt;
		}
	}
	internal class Text : XslNode
	{
		public readonly SerializationHints Hints;

		public Text(string data, SerializationHints hints, XslVersion xslVer)
			: base(XslNodeType.Text, null, data, xslVer)
		{
			Hints = hints;
		}
	}
	internal class XslNodeEx : XslNode
	{
		public readonly ISourceLineInfo ElemNameLi;

		public readonly ISourceLineInfo EndTagLi;

		public XslNodeEx(XslNodeType t, QilName name, object arg, XsltInput.ContextInfo ctxInfo, XslVersion xslVer)
			: base(t, name, arg, xslVer)
		{
			ElemNameLi = ctxInfo.elemNameLi;
			EndTagLi = ctxInfo.endTagLi;
		}

		public XslNodeEx(XslNodeType t, QilName name, object arg, XslVersion xslVer)
			: base(t, name, arg, xslVer)
		{
		}
	}
	internal static class AstFactory
	{
		private static QilFactory f = new QilFactory();

		public static XslNode XslNode(XslNodeType nodeType, QilName name, string arg, XslVersion xslVer)
		{
			return new XslNode(nodeType, name, arg, xslVer);
		}

		public static XslNode ApplyImports(QilName mode, Stylesheet sheet, XslVersion xslVer)
		{
			return new XslNode(XslNodeType.ApplyImports, mode, sheet, xslVer);
		}

		public static XslNodeEx ApplyTemplates(QilName mode, string select, XsltInput.ContextInfo ctxInfo, XslVersion xslVer)
		{
			return new XslNodeEx(XslNodeType.ApplyTemplates, mode, select, ctxInfo, xslVer);
		}

		public static XslNodeEx ApplyTemplates(QilName mode)
		{
			return new XslNodeEx(XslNodeType.ApplyTemplates, mode, null, XslVersion.Version10);
		}

		public static NodeCtor Attribute(string nameAvt, string nsAvt, XslVersion xslVer)
		{
			return new NodeCtor(XslNodeType.Attribute, nameAvt, nsAvt, xslVer);
		}

		public static AttributeSet AttributeSet(QilName name)
		{
			return new AttributeSet(name, XslVersion.Version10);
		}

		public static XslNodeEx CallTemplate(QilName name, XsltInput.ContextInfo ctxInfo)
		{
			return new XslNodeEx(XslNodeType.CallTemplate, name, null, ctxInfo, XslVersion.Version10);
		}

		public static XslNode Choose()
		{
			return new XslNode(XslNodeType.Choose);
		}

		public static XslNode Comment()
		{
			return new XslNode(XslNodeType.Comment);
		}

		public static XslNode Copy()
		{
			return new XslNode(XslNodeType.Copy);
		}

		public static XslNode CopyOf(string select, XslVersion xslVer)
		{
			return new XslNode(XslNodeType.CopyOf, null, select, xslVer);
		}

		public static NodeCtor Element(string nameAvt, string nsAvt, XslVersion xslVer)
		{
			return new NodeCtor(XslNodeType.Element, nameAvt, nsAvt, xslVer);
		}

		public static XslNode Error(string message)
		{
			return new XslNode(XslNodeType.Error, null, message, XslVersion.Version10);
		}

		public static XslNodeEx ForEach(string select, XsltInput.ContextInfo ctxInfo, XslVersion xslVer)
		{
			return new XslNodeEx(XslNodeType.ForEach, null, select, ctxInfo, xslVer);
		}

		public static XslNode If(string test, XslVersion xslVer)
		{
			return new XslNode(XslNodeType.If, null, test, xslVer);
		}

		public static Key Key(QilName name, string match, string use, XslVersion xslVer)
		{
			return new Key(name, match, use, xslVer);
		}

		public static XslNode List()
		{
			return new XslNode(XslNodeType.List);
		}

		public static XslNode LiteralAttribute(QilName name, string value, XslVersion xslVer)
		{
			return new XslNode(XslNodeType.LiteralAttribute, name, value, xslVer);
		}

		public static XslNode LiteralElement(QilName name)
		{
			return new XslNode(XslNodeType.LiteralElement, name, null, XslVersion.Version10);
		}

		public static XslNode Message(bool term)
		{
			return new XslNode(XslNodeType.Message, null, term, XslVersion.Version10);
		}

		public static XslNode Nop()
		{
			return new XslNode(XslNodeType.Nop);
		}

		public static Number Number(NumberLevel level, string count, string from, string value, string format, string lang, string letterValue, string groupingSeparator, string groupingSize, XslVersion xslVer)
		{
			return new Number(level, count, from, value, format, lang, letterValue, groupingSeparator, groupingSize, xslVer);
		}

		public static XslNode Otherwise()
		{
			return new XslNode(XslNodeType.Otherwise);
		}

		public static XslNode PI(string name, XslVersion xslVer)
		{
			return new XslNode(XslNodeType.PI, null, name, xslVer);
		}

		public static Sort Sort(string select, string lang, string dataType, string order, string caseOrder, XslVersion xslVer)
		{
			return new Sort(select, lang, dataType, order, caseOrder, xslVer);
		}

		public static Template Template(QilName name, string match, QilName mode, double priority, XslVersion xslVer)
		{
			return new Template(name, match, mode, priority, xslVer);
		}

		public static XslNode Text(string data)
		{
			return new Text(data, SerializationHints.None, XslVersion.Version10);
		}

		public static XslNode Text(string data, SerializationHints hints)
		{
			return new Text(data, hints, XslVersion.Version10);
		}

		public static XslNode UseAttributeSet(QilName name)
		{
			return new XslNode(XslNodeType.UseAttributeSet, name, null, XslVersion.Version10);
		}

		public static VarPar VarPar(XslNodeType nt, QilName name, string select, XslVersion xslVer)
		{
			return new VarPar(nt, name, select, xslVer);
		}

		public static VarPar WithParam(QilName name)
		{
			return VarPar(XslNodeType.WithParam, name, null, XslVersion.Version10);
		}

		public static QilName QName(string local, string uri, string prefix)
		{
			return f.LiteralQName(local, uri, prefix);
		}

		public static QilName QName(string local)
		{
			return f.LiteralQName(local);
		}
	}
	internal class XslAstAnalyzer : XslVisitor<XslFlags>
	{
		internal class Graph<V> : Dictionary<V, List<V>> where V : XslNode
		{
			private static IList<V> empty = new List<V>().AsReadOnly();

			public IEnumerable<V> GetAdjList(V v)
			{
				if (TryGetValue(v, out var value) && value != null)
				{
					return value;
				}
				return empty;
			}

			public void AddEdge(V v1, V v2)
			{
				if (v1 != v2)
				{
					if (!TryGetValue(v1, out var value) || value == null)
					{
						List<V> list2 = (base[v1] = new List<V>());
						value = list2;
					}
					value.Add(v2);
					if (!TryGetValue(v2, out value))
					{
						base[v2] = null;
					}
				}
			}

			public void PropagateFlag(XslFlags flag)
			{
				foreach (V key in base.Keys)
				{
					key.Flags &= ~XslFlags.Stop;
				}
				foreach (V key2 in base.Keys)
				{
					if ((key2.Flags & XslFlags.Stop) == 0 && (key2.Flags & flag) != 0)
					{
						DepthFirstSearch(key2, flag);
					}
				}
			}

			private void DepthFirstSearch(V v, XslFlags flag)
			{
				v.Flags |= flag | XslFlags.Stop;
				foreach (V adj in GetAdjList(v))
				{
					if ((adj.Flags & XslFlags.Stop) == 0)
					{
						DepthFirstSearch(adj, flag);
					}
				}
			}
		}

		internal struct ModeName
		{
			public QilName Mode;

			public QilName Name;

			public ModeName(QilName mode, QilName name)
			{
				Mode = mode;
				Name = name;
			}

			public override int GetHashCode()
			{
				return Mode.GetHashCode() ^ Name.GetHashCode();
			}
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		internal struct NullErrorHelper : IErrorHelper
		{
			public void ReportError(string res, params string[] args)
			{
			}

			public void ReportWarning(string res, params string[] args)
			{
			}
		}

		internal class XPathAnalyzer : IXPathBuilder<XslFlags>
		{
			private XPathParser<XslFlags> xpathParser = new XPathParser<XslFlags>();

			private CompilerScopeManager<VarPar> scope;

			private Compiler compiler;

			private bool xsltCurrentNeeded;

			private VarPar typeDonor;

			private static XslFlags[] OperatorType = new XslFlags[16]
			{
				XslFlags.TypeFilter,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Nodeset
			};

			private static XslFlags[] XPathFunctionFlags = new XslFlags[27]
			{
				XslFlags.Number | XslFlags.Last,
				XslFlags.Number | XslFlags.Position,
				XslFlags.Number,
				XslFlags.String,
				XslFlags.String,
				XslFlags.String,
				XslFlags.String,
				XslFlags.Number,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.Nodeset | XslFlags.Current,
				XslFlags.String,
				XslFlags.Boolean,
				XslFlags.Boolean,
				XslFlags.String,
				XslFlags.String,
				XslFlags.String,
				XslFlags.Number,
				XslFlags.String,
				XslFlags.String,
				XslFlags.Boolean | XslFlags.Current,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number,
				XslFlags.Number
			};

			private static XslFlags[] XsltFunctionFlags = new XslFlags[9]
			{
				XslFlags.Node,
				XslFlags.Nodeset,
				XslFlags.Nodeset | XslFlags.Current,
				XslFlags.String,
				XslFlags.String,
				XslFlags.String,
				XslFlags.String | XslFlags.Number,
				XslFlags.Boolean,
				XslFlags.Boolean
			};

			public VarPar TypeDonor => typeDonor;

			public XPathAnalyzer(Compiler compiler, CompilerScopeManager<VarPar> scope)
			{
				this.compiler = compiler;
				this.scope = scope;
			}

			public XslFlags Analyze(string xpathExpr)
			{
				typeDonor = null;
				if (xpathExpr == null)
				{
					return XslFlags.None;
				}
				try
				{
					xsltCurrentNeeded = false;
					System.Xml.Xsl.XPath.XPathScanner scanner = new System.Xml.Xsl.XPath.XPathScanner(xpathExpr);
					XslFlags xslFlags = xpathParser.Parse(scanner, this, LexKind.Eof);
					if (xsltCurrentNeeded)
					{
						xslFlags |= XslFlags.Current;
					}
					return xslFlags;
				}
				catch (XslLoadException)
				{
					return XslFlags.TypeFilter | XslFlags.FocusFilter;
				}
			}

			public XslFlags AnalyzeAvt(string source)
			{
				typeDonor = null;
				if (source == null)
				{
					return XslFlags.None;
				}
				try
				{
					xsltCurrentNeeded = false;
					XslFlags xslFlags = XslFlags.None;
					int num = 0;
					while (num < source.Length)
					{
						num = source.IndexOf('{', num);
						if (num == -1)
						{
							break;
						}
						num++;
						if (num < source.Length && source[num] == '{')
						{
							num++;
						}
						else if (num < source.Length)
						{
							System.Xml.Xsl.XPath.XPathScanner xPathScanner = new System.Xml.Xsl.XPath.XPathScanner(source, num);
							xslFlags |= xpathParser.Parse(xPathScanner, this, LexKind.RBrace);
							num = xPathScanner.LexStart + 1;
						}
					}
					if (xsltCurrentNeeded)
					{
						xslFlags |= XslFlags.Current;
					}
					return xslFlags & ~XslFlags.TypeFilter;
				}
				catch (XslLoadException)
				{
					return XslFlags.FocusFilter;
				}
			}

			private VarPar ResolveVariable(string prefix, string name)
			{
				string text = ResolvePrefix(prefix);
				if (text == null)
				{
					return null;
				}
				return scope.LookupVariable(name, text);
			}

			private string ResolvePrefix(string prefix)
			{
				if (prefix.Length == 0)
				{
					return string.Empty;
				}
				return scope.LookupNamespace(prefix);
			}

			public virtual void StartBuild()
			{
			}

			public virtual XslFlags EndBuild(XslFlags result)
			{
				return result;
			}

			public virtual XslFlags String(string value)
			{
				typeDonor = null;
				return XslFlags.String;
			}

			public virtual XslFlags Number(double value)
			{
				typeDonor = null;
				return XslFlags.Number;
			}

			public virtual XslFlags Operator(XPathOperator op, XslFlags left, XslFlags right)
			{
				typeDonor = null;
				XslFlags xslFlags = (left | right) & ~XslFlags.TypeFilter;
				return xslFlags | OperatorType[(int)op];
			}

			public virtual XslFlags Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name)
			{
				typeDonor = null;
				if (xpathAxis == XPathAxis.Self && nodeType == XPathNodeType.All && prefix == null && name == null)
				{
					return XslFlags.Node | XslFlags.Current;
				}
				return XslFlags.Nodeset | XslFlags.Current;
			}

			public virtual XslFlags JoinStep(XslFlags left, XslFlags right)
			{
				typeDonor = null;
				return (left & ~XslFlags.TypeFilter) | XslFlags.Nodeset;
			}

			public virtual XslFlags Predicate(XslFlags nodeset, XslFlags predicate, bool isReverseStep)
			{
				typeDonor = null;
				return (nodeset & ~XslFlags.TypeFilter) | XslFlags.Nodeset | (predicate & XslFlags.SideEffects);
			}

			public virtual XslFlags Variable(string prefix, string name)
			{
				typeDonor = ResolveVariable(prefix, name);
				if (typeDonor == null)
				{
					return XslFlags.TypeFilter;
				}
				return XslFlags.None;
			}

			public virtual XslFlags Function(string prefix, string name, IList<XslFlags> args)
			{
				typeDonor = null;
				XslFlags xslFlags = XslFlags.None;
				foreach (XslFlags arg in args)
				{
					xslFlags |= arg;
				}
				XslFlags xslFlags2 = XslFlags.None;
				if (prefix.Length == 0)
				{
					XPathBuilder.FunctionInfo<QilGenerator.FuncId> value2;
					if (XPathBuilder.FunctionTable.TryGetValue(name, out var value))
					{
						XPathBuilder.FuncId id = value.id;
						xslFlags2 = XPathFunctionFlags[(int)id];
						if (args.Count == 0 && (id == XPathBuilder.FuncId.LocalName || id == XPathBuilder.FuncId.NamespaceUri || id == XPathBuilder.FuncId.Name || id == XPathBuilder.FuncId.String || id == XPathBuilder.FuncId.Number || id == XPathBuilder.FuncId.StringLength || id == XPathBuilder.FuncId.Normalize))
						{
							xslFlags2 |= XslFlags.Current;
						}
					}
					else if (QilGenerator.FunctionTable.TryGetValue(name, out value2))
					{
						QilGenerator.FuncId id2 = value2.id;
						xslFlags2 = XsltFunctionFlags[(int)id2];
						switch (id2)
						{
						case QilGenerator.FuncId.Current:
							xsltCurrentNeeded = true;
							break;
						case QilGenerator.FuncId.GenerateId:
							if (args.Count == 0)
							{
								xslFlags2 |= XslFlags.Current;
							}
							break;
						}
					}
				}
				else
				{
					string text = ResolvePrefix(prefix);
					if (text == "urn:schemas-microsoft-com:xslt")
					{
						switch (name)
						{
						case "node-set":
							xslFlags2 = XslFlags.Nodeset;
							break;
						case "string-compare":
							xslFlags2 = XslFlags.Number;
							break;
						case "utc":
							xslFlags2 = XslFlags.String;
							break;
						case "format-date":
							xslFlags2 = XslFlags.String;
							break;
						case "format-time":
							xslFlags2 = XslFlags.String;
							break;
						case "local-name":
							xslFlags2 = XslFlags.String;
							break;
						case "namespace-uri":
							xslFlags2 = XslFlags.String | XslFlags.Current;
							break;
						case "number":
							xslFlags2 = XslFlags.Number;
							break;
						}
					}
					else if (text == "http://exslt.org/common")
					{
						if (!(name == "node-set"))
						{
							if (name == "object-type")
							{
								xslFlags2 = XslFlags.String;
							}
						}
						else
						{
							xslFlags2 = XslFlags.Nodeset;
						}
					}
					if (xslFlags2 == XslFlags.None)
					{
						xslFlags2 = XslFlags.TypeFilter;
						if (compiler.Settings.EnableScript && text != null)
						{
							XmlExtensionFunction xmlExtensionFunction = compiler.Scripts.ResolveFunction(name, text, args.Count, default(NullErrorHelper));
							if (xmlExtensionFunction != null)
							{
								XmlQueryType xmlReturnType = xmlExtensionFunction.XmlReturnType;
								if (xmlReturnType == XmlQueryTypeFactory.StringX)
								{
									xslFlags2 = XslFlags.String;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.DoubleX)
								{
									xslFlags2 = XslFlags.Number;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.BooleanX)
								{
									xslFlags2 = XslFlags.Boolean;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.NodeNotRtf)
								{
									xslFlags2 = XslFlags.Node;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.NodeSDod)
								{
									xslFlags2 = XslFlags.Nodeset;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.ItemS)
								{
									xslFlags2 = XslFlags.TypeFilter;
								}
								else if (xmlReturnType == XmlQueryTypeFactory.Empty)
								{
									xslFlags2 = XslFlags.Nodeset;
								}
							}
						}
						xslFlags2 |= XslFlags.SideEffects;
					}
				}
				return (xslFlags & ~XslFlags.TypeFilter) | xslFlags2;
			}
		}

		private CompilerScopeManager<VarPar> scope;

		private Compiler compiler;

		private int forEachDepth;

		private XPathAnalyzer xpathAnalyzer;

		private ProtoTemplate currentTemplate;

		private VarPar typeDonor;

		private Graph<ProtoTemplate> revCall0Graph = new Graph<ProtoTemplate>();

		private Graph<ProtoTemplate> revCall1Graph = new Graph<ProtoTemplate>();

		private Dictionary<Template, Stylesheet> fwdApplyImportsGraph = new Dictionary<Template, Stylesheet>();

		private Dictionary<QilName, List<ProtoTemplate>> revApplyTemplatesGraph = new Dictionary<QilName, List<ProtoTemplate>>();

		private Graph<VarPar> dataFlow = new Graph<VarPar>();

		private Dictionary<ModeName, VarPar> applyTemplatesParams = new Dictionary<ModeName, VarPar>();

		public XslFlags Analyze(Compiler compiler)
		{
			this.compiler = compiler;
			scope = new CompilerScopeManager<VarPar>();
			xpathAnalyzer = new XPathAnalyzer(compiler, scope);
			foreach (VarPar externalPar in compiler.ExternalPars)
			{
				scope.AddVariable(externalPar.Name, externalPar);
			}
			foreach (VarPar globalVar in compiler.GlobalVars)
			{
				scope.AddVariable(globalVar.Name, globalVar);
			}
			foreach (VarPar externalPar2 in compiler.ExternalPars)
			{
				Visit(externalPar2);
				externalPar2.Flags |= XslFlags.TypeFilter;
			}
			foreach (VarPar globalVar2 in compiler.GlobalVars)
			{
				Visit(globalVar2);
			}
			XslFlags xslFlags = XslFlags.None;
			foreach (ProtoTemplate allTemplate in compiler.AllTemplates)
			{
				xslFlags |= Visit(currentTemplate = allTemplate);
			}
			foreach (ProtoTemplate allTemplate2 in compiler.AllTemplates)
			{
				foreach (XslNode item in allTemplate2.Content)
				{
					if (item.NodeType != XslNodeType.Text)
					{
						if (item.NodeType != XslNodeType.Param)
						{
							break;
						}
						VarPar varPar = (VarPar)item;
						if ((varPar.Flags & XslFlags.MayBeDefault) != 0)
						{
							varPar.Flags |= varPar.DefValueFlags;
						}
					}
				}
			}
			for (int num = 32; num != 0; num >>= 1)
			{
				dataFlow.PropagateFlag((XslFlags)num);
			}
			dataFlow = null;
			foreach (KeyValuePair<Template, Stylesheet> item2 in fwdApplyImportsGraph)
			{
				Stylesheet[] imports = item2.Value.Imports;
				foreach (Stylesheet sheet in imports)
				{
					AddImportDependencies(sheet, item2.Key);
				}
			}
			fwdApplyImportsGraph = null;
			if ((xslFlags & XslFlags.Current) != 0)
			{
				revCall0Graph.PropagateFlag(XslFlags.Current);
			}
			if ((xslFlags & XslFlags.Position) != 0)
			{
				revCall0Graph.PropagateFlag(XslFlags.Position);
			}
			if ((xslFlags & XslFlags.Last) != 0)
			{
				revCall0Graph.PropagateFlag(XslFlags.Last);
			}
			if ((xslFlags & XslFlags.SideEffects) != 0)
			{
				PropagateSideEffectsFlag();
			}
			revCall0Graph = null;
			revCall1Graph = null;
			revApplyTemplatesGraph = null;
			FillModeFlags(compiler.Root.ModeFlags, compiler.Root.Imports[0]);
			TraceResults();
			return xslFlags;
		}

		private void AddImportDependencies(Stylesheet sheet, Template focusDonor)
		{
			foreach (Template template in sheet.Templates)
			{
				if (template.Mode.Equals(focusDonor.Mode))
				{
					revCall0Graph.AddEdge(template, focusDonor);
				}
			}
			Stylesheet[] imports = sheet.Imports;
			foreach (Stylesheet sheet2 in imports)
			{
				AddImportDependencies(sheet2, focusDonor);
			}
		}

		private void FillModeFlags(Dictionary<QilName, XslFlags> parentModeFlags, Stylesheet sheet)
		{
			Stylesheet[] imports = sheet.Imports;
			foreach (Stylesheet sheet2 in imports)
			{
				FillModeFlags(sheet.ModeFlags, sheet2);
			}
			foreach (KeyValuePair<QilName, XslFlags> modeFlag in sheet.ModeFlags)
			{
				if (!parentModeFlags.TryGetValue(modeFlag.Key, out var value))
				{
					value = XslFlags.None;
				}
				parentModeFlags[modeFlag.Key] = value | modeFlag.Value;
			}
			foreach (Template template in sheet.Templates)
			{
				XslFlags xslFlags = template.Flags & (XslFlags.FocusFilter | XslFlags.SideEffects);
				if (xslFlags != 0)
				{
					if (!parentModeFlags.TryGetValue(template.Mode, out var value2))
					{
						value2 = XslFlags.None;
					}
					parentModeFlags[template.Mode] = value2 | xslFlags;
				}
			}
		}

		private void TraceResults()
		{
		}

		protected override XslFlags Visit(XslNode node)
		{
			scope.EnterScope(node.Namespaces);
			XslFlags result = base.Visit(node);
			scope.ExitScope();
			if (currentTemplate != null && (node.NodeType == XslNodeType.Variable || node.NodeType == XslNodeType.Param))
			{
				scope.AddVariable(node.Name, (VarPar)node);
			}
			return result;
		}

		protected override XslFlags VisitChildren(XslNode node)
		{
			XslFlags xslFlags = XslFlags.None;
			foreach (XslNode item in node.Content)
			{
				xslFlags |= Visit(item);
			}
			return xslFlags;
		}

		protected override XslFlags VisitAttributeSet(AttributeSet node)
		{
			node.Flags = VisitChildren(node);
			return node.Flags;
		}

		protected override XslFlags VisitTemplate(Template node)
		{
			node.Flags = VisitChildren(node);
			return node.Flags;
		}

		protected override XslFlags VisitApplyImports(XslNode node)
		{
			fwdApplyImportsGraph[(Template)currentTemplate] = (Stylesheet)node.Arg;
			return XslFlags.Rtf | XslFlags.Current | XslFlags.HasCalls;
		}

		protected override XslFlags VisitApplyTemplates(XslNode node)
		{
			XslFlags xslFlags = ProcessExpr(node.Select);
			foreach (XslNode item in node.Content)
			{
				xslFlags |= Visit(item);
				if (item.NodeType == XslNodeType.WithParam)
				{
					ModeName key = new ModeName(node.Name, item.Name);
					if (!applyTemplatesParams.TryGetValue(key, out var value))
					{
						VarPar varPar2 = (applyTemplatesParams[key] = AstFactory.WithParam(item.Name));
						value = varPar2;
					}
					if (typeDonor != null)
					{
						dataFlow.AddEdge(typeDonor, value);
					}
					else
					{
						value.Flags |= item.Flags & XslFlags.TypeFilter;
					}
				}
			}
			if (currentTemplate != null)
			{
				AddApplyTemplatesEdge(node.Name, currentTemplate);
			}
			return XslFlags.Rtf | XslFlags.HasCalls | xslFlags;
		}

		protected override XslFlags VisitAttribute(NodeCtor node)
		{
			return XslFlags.Rtf | ProcessAvt(node.NameAvt) | ProcessAvt(node.NsAvt) | VisitChildren(node);
		}

		protected override XslFlags VisitCallTemplate(XslNode node)
		{
			XslFlags xslFlags = XslFlags.None;
			if (compiler.NamedTemplates.TryGetValue(node.Name, out var value) && currentTemplate != null)
			{
				if (forEachDepth == 0)
				{
					revCall0Graph.AddEdge(value, currentTemplate);
				}
				else
				{
					revCall1Graph.AddEdge(value, currentTemplate);
				}
			}
			VarPar[] array = new VarPar[node.Content.Count];
			int num = 0;
			foreach (XslNode item in node.Content)
			{
				xslFlags |= Visit(item);
				array[num++] = typeDonor;
			}
			if (value != null)
			{
				foreach (XslNode item2 in value.Content)
				{
					if (item2.NodeType == XslNodeType.Text)
					{
						continue;
					}
					if (item2.NodeType != XslNodeType.Param)
					{
						break;
					}
					VarPar varPar = (VarPar)item2;
					VarPar varPar2 = null;
					num = 0;
					foreach (XslNode item3 in node.Content)
					{
						if (item3.Name.Equals(varPar.Name))
						{
							varPar2 = (VarPar)item3;
							typeDonor = array[num];
							break;
						}
						num++;
					}
					if (varPar2 != null)
					{
						if (typeDonor != null)
						{
							dataFlow.AddEdge(typeDonor, varPar);
						}
						else
						{
							varPar.Flags |= varPar2.Flags & XslFlags.TypeFilter;
						}
					}
					else
					{
						varPar.Flags |= XslFlags.MayBeDefault;
					}
				}
			}
			return XslFlags.Rtf | XslFlags.HasCalls | xslFlags;
		}

		protected override XslFlags VisitComment(XslNode node)
		{
			return XslFlags.Rtf | VisitChildren(node);
		}

		protected override XslFlags VisitCopy(XslNode node)
		{
			return XslFlags.Rtf | XslFlags.Current | VisitChildren(node);
		}

		protected override XslFlags VisitCopyOf(XslNode node)
		{
			return XslFlags.Rtf | ProcessExpr(node.Select);
		}

		protected override XslFlags VisitElement(NodeCtor node)
		{
			return XslFlags.Rtf | ProcessAvt(node.NameAvt) | ProcessAvt(node.NsAvt) | VisitChildren(node);
		}

		protected override XslFlags VisitError(XslNode node)
		{
			return (VisitChildren(node) & ~XslFlags.TypeFilter) | XslFlags.SideEffects;
		}

		protected override XslFlags VisitForEach(XslNode node)
		{
			XslFlags xslFlags = ProcessExpr(node.Select);
			forEachDepth++;
			foreach (XslNode item in node.Content)
			{
				xslFlags = ((item.NodeType != XslNodeType.Sort) ? (xslFlags | (Visit(item) & ~XslFlags.FocusFilter)) : (xslFlags | Visit(item)));
			}
			forEachDepth--;
			return xslFlags;
		}

		protected override XslFlags VisitIf(XslNode node)
		{
			return ProcessExpr(node.Select) | VisitChildren(node);
		}

		protected override XslFlags VisitLiteralAttribute(XslNode node)
		{
			return XslFlags.Rtf | ProcessAvt(node.Select) | VisitChildren(node);
		}

		protected override XslFlags VisitLiteralElement(XslNode node)
		{
			return XslFlags.Rtf | VisitChildren(node);
		}

		protected override XslFlags VisitMessage(XslNode node)
		{
			return (VisitChildren(node) & ~XslFlags.TypeFilter) | XslFlags.SideEffects;
		}

		protected override XslFlags VisitNumber(Number node)
		{
			return XslFlags.Rtf | ProcessPattern(node.Count) | ProcessPattern(node.From) | ((node.Value != null) ? ProcessExpr(node.Value) : XslFlags.Current) | ProcessAvt(node.Format) | ProcessAvt(node.Lang) | ProcessAvt(node.LetterValue) | ProcessAvt(node.GroupingSeparator) | ProcessAvt(node.GroupingSize);
		}

		protected override XslFlags VisitPI(XslNode node)
		{
			return XslFlags.Rtf | ProcessAvt(node.Select) | VisitChildren(node);
		}

		protected override XslFlags VisitSort(Sort node)
		{
			return (ProcessExpr(node.Select) & ~XslFlags.FocusFilter) | ProcessAvt(node.Lang) | ProcessAvt(node.DataType) | ProcessAvt(node.Order) | ProcessAvt(node.CaseOrder);
		}

		protected override XslFlags VisitText(Text node)
		{
			return XslFlags.Rtf | VisitChildren(node);
		}

		protected override XslFlags VisitUseAttributeSet(XslNode node)
		{
			if (compiler.AttributeSets.TryGetValue(node.Name, out var value) && currentTemplate != null)
			{
				if (forEachDepth == 0)
				{
					revCall0Graph.AddEdge(value, currentTemplate);
				}
				else
				{
					revCall1Graph.AddEdge(value, currentTemplate);
				}
			}
			return XslFlags.Rtf | XslFlags.HasCalls;
		}

		protected override XslFlags VisitValueOf(XslNode node)
		{
			return XslFlags.Rtf | ProcessExpr(node.Select);
		}

		protected override XslFlags VisitValueOfDoe(XslNode node)
		{
			return XslFlags.Rtf | ProcessExpr(node.Select);
		}

		protected override XslFlags VisitParam(VarPar node)
		{
			if (currentTemplate is Template template && template.Match != null)
			{
				node.Flags |= XslFlags.MayBeDefault;
				ModeName key = new ModeName(template.Mode, node.Name);
				if (!applyTemplatesParams.TryGetValue(key, out var value))
				{
					VarPar varPar2 = (applyTemplatesParams[key] = AstFactory.WithParam(node.Name));
					value = varPar2;
				}
				dataFlow.AddEdge(value, node);
			}
			node.DefValueFlags = ProcessVarPar(node);
			return node.DefValueFlags & ~XslFlags.TypeFilter;
		}

		protected override XslFlags VisitVariable(VarPar node)
		{
			node.Flags = ProcessVarPar(node);
			return node.Flags & ~XslFlags.TypeFilter;
		}

		protected override XslFlags VisitWithParam(VarPar node)
		{
			node.Flags = ProcessVarPar(node);
			return node.Flags & ~XslFlags.TypeFilter;
		}

		private XslFlags ProcessVarPar(VarPar node)
		{
			XslFlags result;
			if (node.Select != null)
			{
				if (node.Content.Count != 0)
				{
					result = xpathAnalyzer.Analyze(node.Select) | VisitChildren(node) | XslFlags.TypeFilter;
					typeDonor = null;
				}
				else
				{
					result = xpathAnalyzer.Analyze(node.Select);
					typeDonor = xpathAnalyzer.TypeDonor;
					if (typeDonor != null && node.NodeType != XslNodeType.WithParam)
					{
						dataFlow.AddEdge(typeDonor, node);
					}
				}
			}
			else if (node.Content.Count != 0)
			{
				result = XslFlags.Rtf | VisitChildren(node);
				typeDonor = null;
			}
			else
			{
				result = XslFlags.String;
				typeDonor = null;
			}
			return result;
		}

		private XslFlags ProcessExpr(string expr)
		{
			return xpathAnalyzer.Analyze(expr) & ~XslFlags.TypeFilter;
		}

		private XslFlags ProcessAvt(string avt)
		{
			return xpathAnalyzer.AnalyzeAvt(avt) & ~XslFlags.TypeFilter;
		}

		private XslFlags ProcessPattern(string pattern)
		{
			return xpathAnalyzer.Analyze(pattern) & ~XslFlags.TypeFilter & ~XslFlags.FocusFilter;
		}

		private void AddApplyTemplatesEdge(QilName mode, ProtoTemplate dependentTemplate)
		{
			if (!revApplyTemplatesGraph.TryGetValue(mode, out var value))
			{
				value = new List<ProtoTemplate>();
				revApplyTemplatesGraph.Add(mode, value);
			}
			else if (value[value.Count - 1] == dependentTemplate)
			{
				return;
			}
			value.Add(dependentTemplate);
		}

		private void PropagateSideEffectsFlag()
		{
			foreach (ProtoTemplate key in revCall0Graph.Keys)
			{
				key.Flags &= ~XslFlags.Stop;
			}
			foreach (ProtoTemplate key2 in revCall1Graph.Keys)
			{
				key2.Flags &= ~XslFlags.Stop;
			}
			foreach (ProtoTemplate key3 in revCall0Graph.Keys)
			{
				if ((key3.Flags & XslFlags.Stop) == 0 && (key3.Flags & XslFlags.SideEffects) != 0)
				{
					DepthFirstSearch(key3);
				}
			}
			foreach (ProtoTemplate key4 in revCall1Graph.Keys)
			{
				if ((key4.Flags & XslFlags.Stop) == 0 && (key4.Flags & XslFlags.SideEffects) != 0)
				{
					DepthFirstSearch(key4);
				}
			}
		}

		private void DepthFirstSearch(ProtoTemplate t)
		{
			t.Flags |= XslFlags.SideEffects | XslFlags.Stop;
			foreach (ProtoTemplate adj in revCall0Graph.GetAdjList(t))
			{
				if ((adj.Flags & XslFlags.Stop) == 0)
				{
					DepthFirstSearch(adj);
				}
			}
			foreach (ProtoTemplate adj2 in revCall1Graph.GetAdjList(t))
			{
				if ((adj2.Flags & XslFlags.Stop) == 0)
				{
					DepthFirstSearch(adj2);
				}
			}
			if (!(t is Template template) || !revApplyTemplatesGraph.TryGetValue(template.Mode, out var value))
			{
				return;
			}
			revApplyTemplatesGraph.Remove(template.Mode);
			foreach (ProtoTemplate item in value)
			{
				if ((item.Flags & XslFlags.Stop) == 0)
				{
					DepthFirstSearch(item);
				}
			}
		}
	}
	internal sealed class XslAstRewriter
	{
		private static readonly QilName nullMode = AstFactory.QName(string.Empty);

		private CompilerScopeManager<VarPar> scope;

		private Stack<Template> newTemplates;

		private Compiler compiler;

		private const int FixedNodeCost = 1;

		private const int IteratorNodeCost = 2;

		private const int CallTemplateCost = 1;

		private const int RewriteThreshold = 100;

		private const int NodesWithSelect = -247451132;

		private const int ParentsOfCallTemplate = -1025034872;

		public void Rewrite(Compiler compiler)
		{
			this.compiler = compiler;
			scope = new CompilerScopeManager<VarPar>();
			newTemplates = new Stack<Template>();
			foreach (ProtoTemplate allTemplate in compiler.AllTemplates)
			{
				scope.EnterScope();
				CheckNodeCost(allTemplate);
			}
			while (newTemplates.Count > 0)
			{
				Template template = newTemplates.Pop();
				compiler.AllTemplates.Add(template);
				compiler.NamedTemplates.Add(template.Name, template);
				scope.EnterScope();
				CheckNodeCost(template);
			}
		}

		private static int NodeCostForXPath(string xpath)
		{
			int num = 0;
			if (xpath != null)
			{
				num = 2;
				for (int i = 2; i < xpath.Length; i += 2)
				{
					if (xpath[i] == '/' || xpath[i - 1] == '/')
					{
						num += 2;
					}
				}
			}
			return num;
		}

		private static bool NodeTypeTest(XslNodeType nodetype, int flags)
		{
			return ((flags >> (int)nodetype) & 1) != 0;
		}

		private int CheckNodeCost(XslNode node)
		{
			scope.EnterScope(node.Namespaces);
			bool flag = false;
			int num = 1;
			if (NodeTypeTest(node.NodeType, -247451132))
			{
				num += NodeCostForXPath(node.Select);
			}
			IList<XslNode> content = node.Content;
			int num2 = content.Count - 1;
			for (int i = 0; i <= num2; i++)
			{
				XslNode xslNode = content[i];
				int num3 = CheckNodeCost(xslNode);
				num += num3;
				if (flag && num > 100)
				{
					if (i < num2 || num3 > 1)
					{
						Refactor(node, i);
						num -= num3;
						num++;
					}
					break;
				}
				if (xslNode.NodeType == XslNodeType.Variable || xslNode.NodeType == XslNodeType.Param)
				{
					scope.AddVariable(xslNode.Name, (VarPar)xslNode);
					if (xslNode.NodeType == XslNodeType.Param)
					{
						num -= num3;
					}
				}
				else if (!flag)
				{
					flag = NodeTypeTest(node.NodeType, -1025034872);
				}
			}
			scope.ExitScope();
			return num;
		}

		private void Refactor(XslNode parent, int split)
		{
			List<XslNode> list = (List<XslNode>)parent.Content;
			XslNode xslNode = list[split];
			QilName name = AstFactory.QName("generated", compiler.CreatePhantomNamespace(), "compiler");
			XsltInput.ContextInfo contextInfo = new XsltInput.ContextInfo(xslNode.SourceLine);
			XslNodeEx xslNodeEx = AstFactory.CallTemplate(name, contextInfo);
			XsltLoader.SetInfo(xslNodeEx, null, contextInfo);
			Template template = AstFactory.Template(name, null, XsltLoader.nullMode, double.NaN, xslNode.XslVersion);
			XsltLoader.SetInfo(template, null, contextInfo);
			newTemplates.Push(template);
			template.SetContent(new List<XslNode>(list.Count - split + 8));
			foreach (CompilerScopeManager<VarPar>.ScopeRecord activeRecord in scope.GetActiveRecords())
			{
				if (!activeRecord.IsVariable)
				{
					template.Namespaces = new NsDecl(template.Namespaces, activeRecord.ncName, activeRecord.nsUri);
					continue;
				}
				VarPar value = activeRecord.value;
				if (!compiler.IsPhantomNamespace(value.Name.NamespaceUri))
				{
					QilName qilName = AstFactory.QName(value.Name.LocalName, value.Name.NamespaceUri, value.Name.Prefix);
					VarPar varPar = AstFactory.VarPar(XslNodeType.WithParam, qilName, "$" + qilName.QualifiedName, XslVersion.Version10);
					XsltLoader.SetInfo(varPar, null, contextInfo);
					varPar.Namespaces = value.Namespaces;
					xslNodeEx.AddContent(varPar);
					VarPar varPar2 = AstFactory.VarPar(XslNodeType.Param, qilName, null, XslVersion.Version10);
					XsltLoader.SetInfo(varPar2, null, contextInfo);
					varPar2.Namespaces = value.Namespaces;
					template.AddContent(varPar2);
				}
			}
			for (int i = split; i < list.Count; i++)
			{
				template.AddContent(list[i]);
			}
			list[split] = xslNodeEx;
			list.RemoveRange(split + 1, list.Count - split - 1);
		}
	}
	internal class XsltInput : IErrorHelper
	{
		public struct DelayedQName
		{
			private string prefix;

			private string localName;

			public DelayedQName(ref Record rec)
			{
				prefix = rec.prefix;
				localName = rec.localName;
			}

			public static implicit operator string(DelayedQName qn)
			{
				if (qn.prefix.Length != 0)
				{
					return qn.prefix + ":" + qn.localName;
				}
				return qn.localName;
			}
		}

		public struct XsltAttribute
		{
			public string name;

			public int flags;

			public XsltAttribute(string name, int flags)
			{
				this.name = name;
				this.flags = flags;
			}
		}

		internal class ContextInfo
		{
			internal class EmptyElementEndTag : ISourceLineInfo
			{
				private ISourceLineInfo elementTagLi;

				public string Uri => elementTagLi.Uri;

				public bool IsNoSource => elementTagLi.IsNoSource;

				public Location Start => new Location(elementTagLi.End.Line, elementTagLi.End.Pos - 2);

				public Location End => elementTagLi.End;

				public EmptyElementEndTag(ISourceLineInfo elementTagLi)
				{
					this.elementTagLi = elementTagLi;
				}
			}

			public NsDecl nsList;

			public ISourceLineInfo lineInfo;

			public ISourceLineInfo elemNameLi;

			public ISourceLineInfo endTagLi;

			private int elemNameLength;

			internal ContextInfo(ISourceLineInfo lineinfo)
			{
				elemNameLi = lineinfo;
				endTagLi = lineinfo;
				lineInfo = lineinfo;
			}

			public ContextInfo(XsltInput input)
			{
				elemNameLength = input.QualifiedName.Length;
			}

			public void AddNamespace(string prefix, string nsUri)
			{
				nsList = new NsDecl(nsList, prefix, nsUri);
			}

			public void SaveExtendedLineInfo(XsltInput input)
			{
				if (lineInfo.Start.Line == 0)
				{
					elemNameLi = (endTagLi = null);
					return;
				}
				elemNameLi = new SourceLineInfo(lineInfo.Uri, lineInfo.Start.Line, lineInfo.Start.Pos + 1, lineInfo.Start.Line, lineInfo.Start.Pos + 1 + elemNameLength);
				if (!input.IsEmptyElement)
				{
					endTagLi = input.BuildLineInfo();
				}
				else
				{
					endTagLi = new EmptyElementEndTag(lineInfo);
				}
			}
		}

		internal struct Record
		{
			public string localName;

			public string nsUri;

			public string prefix;

			public string value;

			public string baseUri;

			public Location start;

			public Location valueStart;

			public Location end;

			public string QualifiedName
			{
				get
				{
					if (prefix.Length != 0)
					{
						return prefix + ":" + localName;
					}
					return localName;
				}
			}
		}

		private const int InitRecordsSize = 22;

		private XmlReader reader;

		private IXmlLineInfo readerLineInfo;

		private bool topLevelReader;

		private CompilerScopeManager<VarPar> scopeManager;

		private KeywordsTable atoms;

		private Compiler compiler;

		private bool reatomize;

		private XmlNodeType nodeType;

		private Record[] records = new Record[22];

		private int currentRecord;

		private bool isEmptyElement;

		private int lastTextNode;

		private int numAttributes;

		private ContextInfo ctxInfo;

		private bool attributesRead;

		private StringConcat strConcat;

		private XsltAttribute[] attributes;

		private int[] xsltAttributeNumber = new int[21];

		private static XsltAttribute[] noAttributes = new XsltAttribute[0];

		public XmlNodeType NodeType
		{
			get
			{
				if (nodeType != XmlNodeType.Element || 0 >= currentRecord)
				{
					return nodeType;
				}
				return XmlNodeType.Attribute;
			}
		}

		public string LocalName => records[currentRecord].localName;

		public string NamespaceUri => records[currentRecord].nsUri;

		public string Prefix => records[currentRecord].prefix;

		public string Value => records[currentRecord].value;

		public string BaseUri => records[currentRecord].baseUri;

		public string QualifiedName => records[currentRecord].QualifiedName;

		public bool IsEmptyElement => isEmptyElement;

		public string Uri => records[currentRecord].baseUri;

		public Location Start => records[currentRecord].start;

		public Location End => records[currentRecord].end;

		public DelayedQName ElementName => new DelayedQName(ref records[0]);

		public bool CanHaveApplyImports
		{
			get
			{
				return scopeManager.CanHaveApplyImports;
			}
			set
			{
				scopeManager.CanHaveApplyImports = value;
			}
		}

		public bool ForwardCompatibility => scopeManager.ForwardCompatibility;

		public bool BackwardCompatibility => scopeManager.BackwardCompatibility;

		public XslVersion XslVersion
		{
			get
			{
				if (!scopeManager.ForwardCompatibility)
				{
					return XslVersion.Version10;
				}
				return XslVersion.ForwardsCompatible;
			}
		}

		public XsltInput(XmlReader reader, Compiler compiler, KeywordsTable atoms)
		{
			EnsureExpandEntities(reader);
			IXmlLineInfo xmlLineInfo = reader as IXmlLineInfo;
			this.atoms = atoms;
			this.reader = reader;
			reatomize = reader.NameTable != atoms.NameTable;
			readerLineInfo = ((xmlLineInfo != null && xmlLineInfo.HasLineInfo()) ? xmlLineInfo : null);
			topLevelReader = reader.ReadState == ReadState.Initial;
			scopeManager = new CompilerScopeManager<VarPar>(atoms);
			this.compiler = compiler;
			nodeType = XmlNodeType.Document;
		}

		private static void EnsureExpandEntities(XmlReader reader)
		{
			if (reader is XmlTextReader xmlTextReader && xmlTextReader.EntityHandling != EntityHandling.ExpandEntities)
			{
				xmlTextReader.EntityHandling = EntityHandling.ExpandEntities;
			}
		}

		private void ExtendRecordBuffer(int position)
		{
			if (records.Length <= position)
			{
				int num = records.Length * 2;
				if (num <= position)
				{
					num = position + 1;
				}
				Record[] destinationArray = new Record[num];
				Array.Copy(records, destinationArray, records.Length);
				records = destinationArray;
			}
		}

		public bool FindStylesheetElement()
		{
			if (!topLevelReader && reader.ReadState != ReadState.Interactive)
			{
				return false;
			}
			IDictionary<string, string> dictionary = null;
			if (reader.ReadState == ReadState.Interactive && reader is IXmlNamespaceResolver xmlNamespaceResolver)
			{
				dictionary = xmlNamespaceResolver.GetNamespacesInScope(XmlNamespaceScope.ExcludeXml);
			}
			while (MoveToNextSibling() && nodeType == XmlNodeType.Whitespace)
			{
			}
			if (nodeType == XmlNodeType.Element)
			{
				if (dictionary != null)
				{
					foreach (KeyValuePair<string, string> item in dictionary)
					{
						if (scopeManager.LookupNamespace(item.Key) == null)
						{
							string nsUri = atoms.NameTable.Add(item.Value);
							scopeManager.AddNsDeclaration(item.Key, nsUri);
							ctxInfo.AddNamespace(item.Key, nsUri);
						}
					}
				}
				return true;
			}
			return false;
		}

		public void Finish()
		{
			if (topLevelReader)
			{
				while (reader.ReadState == ReadState.Interactive)
				{
					reader.Skip();
				}
			}
		}

		private void FillupRecord(ref Record rec)
		{
			rec.localName = reader.LocalName;
			rec.nsUri = reader.NamespaceURI;
			rec.prefix = reader.Prefix;
			rec.value = reader.Value;
			rec.baseUri = reader.BaseURI;
			if (reatomize)
			{
				rec.localName = atoms.NameTable.Add(rec.localName);
				rec.nsUri = atoms.NameTable.Add(rec.nsUri);
				rec.prefix = atoms.NameTable.Add(rec.prefix);
			}
			if (readerLineInfo != null)
			{
				rec.start = new Location(readerLineInfo.LineNumber, readerLineInfo.LinePosition - PositionAdjustment(reader.NodeType));
			}
		}

		private void SetRecordEnd(ref Record rec)
		{
			if (readerLineInfo != null)
			{
				rec.end = new Location(readerLineInfo.LineNumber, readerLineInfo.LinePosition - PositionAdjustment(reader.NodeType));
				if (reader.BaseURI != rec.baseUri || rec.end.LessOrEqual(rec.start))
				{
					rec.end = new Location(rec.start.Line, int.MaxValue);
				}
			}
		}

		private void FillupTextRecord(ref Record rec)
		{
			rec.localName = string.Empty;
			rec.nsUri = string.Empty;
			rec.prefix = string.Empty;
			rec.value = reader.Value;
			rec.baseUri = reader.BaseURI;
			if (readerLineInfo == null)
			{
				return;
			}
			bool flag = reader.NodeType == XmlNodeType.CDATA;
			int num = readerLineInfo.LineNumber;
			int num2 = readerLineInfo.LinePosition;
			rec.start = new Location(num, num2 - (flag ? 9 : 0));
			char c = ' ';
			string value = rec.value;
			char c2;
			for (int i = 0; i < value.Length; c = c2, i++)
			{
				c2 = value[i];
				if (c2 != '\n')
				{
					if (c2 != '\r')
					{
						num2++;
						continue;
					}
				}
				else if (c == '\r')
				{
					continue;
				}
				num++;
				num2 = 1;
			}
			rec.end = new Location(num, num2 + (flag ? 3 : 0));
		}

		private void FillupCharacterEntityRecord(ref Record rec)
		{
			string localName = reader.LocalName;
			rec.localName = string.Empty;
			rec.nsUri = string.Empty;
			rec.prefix = string.Empty;
			rec.baseUri = reader.BaseURI;
			if (readerLineInfo != null)
			{
				rec.start = new Location(readerLineInfo.LineNumber, readerLineInfo.LinePosition - 1);
			}
			reader.ResolveEntity();
			reader.Read();
			rec.value = reader.Value;
			reader.Read();
			if (readerLineInfo != null)
			{
				int lineNumber = readerLineInfo.LineNumber;
				int linePosition = readerLineInfo.LinePosition;
				rec.end = new Location(readerLineInfo.LineNumber, readerLineInfo.LinePosition + 1);
			}
		}

		private bool ReadAttribute(ref Record rec)
		{
			FillupRecord(ref rec);
			if (Ref.Equal(rec.prefix, atoms.Xmlns))
			{
				string nsUri = atoms.NameTable.Add(reader.Value);
				if (!Ref.Equal(rec.localName, atoms.Xml))
				{
					scopeManager.AddNsDeclaration(rec.localName, nsUri);
					ctxInfo.AddNamespace(rec.localName, nsUri);
				}
				return false;
			}
			if (rec.prefix.Length == 0 && Ref.Equal(rec.localName, atoms.Xmlns))
			{
				string nsUri2 = atoms.NameTable.Add(reader.Value);
				scopeManager.AddNsDeclaration(string.Empty, nsUri2);
				ctxInfo.AddNamespace(string.Empty, nsUri2);
				return false;
			}
			if (!reader.ReadAttributeValue())
			{
				rec.value = string.Empty;
				SetRecordEnd(ref rec);
				return true;
			}
			if (readerLineInfo != null)
			{
				int num = ((reader.NodeType == XmlNodeType.EntityReference) ? (-2) : (-1));
				rec.valueStart = new Location(readerLineInfo.LineNumber, readerLineInfo.LinePosition + num);
				if (reader.BaseURI != rec.baseUri || rec.valueStart.LessOrEqual(rec.start))
				{
					int num2 = ((rec.prefix.Length != 0) ? (rec.prefix.Length + 1) : 0) + rec.localName.Length;
					rec.end = new Location(rec.start.Line, rec.start.Pos + num2 + 1);
				}
			}
			string text = string.Empty;
			strConcat.Clear();
			do
			{
				switch (reader.NodeType)
				{
				case XmlNodeType.EntityReference:
					reader.ResolveEntity();
					break;
				default:
					text = reader.Value;
					strConcat.Concat(text);
					break;
				case XmlNodeType.EndEntity:
					break;
				}
			}
			while (reader.ReadAttributeValue());
			rec.value = strConcat.GetResult();
			if (readerLineInfo != null)
			{
				int num3 = ((reader.NodeType == XmlNodeType.EndEntity) ? 1 : text.Length) + 1;
				rec.end = new Location(readerLineInfo.LineNumber, readerLineInfo.LinePosition + num3);
				if (reader.BaseURI != rec.baseUri || rec.end.LessOrEqual(rec.valueStart))
				{
					rec.end = new Location(rec.start.Line, int.MaxValue);
				}
			}
			return true;
		}

		public bool MoveToFirstChild()
		{
			if (IsEmptyElement)
			{
				return false;
			}
			return ReadNextSibling();
		}

		public bool MoveToNextSibling()
		{
			if (nodeType == XmlNodeType.Element || nodeType == XmlNodeType.EndElement)
			{
				scopeManager.ExitScope();
			}
			return ReadNextSibling();
		}

		public void SkipNode()
		{
			if (nodeType == XmlNodeType.Element && MoveToFirstChild())
			{
				do
				{
					SkipNode();
				}
				while (MoveToNextSibling());
			}
		}

		private int ReadTextNodes()
		{
			bool flag = reader.XmlSpace == XmlSpace.Preserve;
			bool flag2 = true;
			int num = 0;
			while (true)
			{
				XmlNodeType xmlNodeType = reader.NodeType;
				if (xmlNodeType <= XmlNodeType.EntityReference)
				{
					if ((uint)(xmlNodeType - 3) > 1u)
					{
						if (xmlNodeType != XmlNodeType.EntityReference)
						{
							break;
						}
						string localName = reader.LocalName;
						if (localName.Length > 0)
						{
							if (localName[0] != '#')
							{
								switch (localName)
								{
								case "lt":
								case "gt":
								case "quot":
								case "apos":
									break;
								default:
									goto IL_0139;
								}
							}
							ExtendRecordBuffer(num);
							FillupCharacterEntityRecord(ref records[num]);
							if (flag2 && !XmlCharType.Instance.IsOnlyWhitespace(records[num].value))
							{
								flag2 = false;
							}
							num++;
							continue;
						}
						goto IL_0139;
					}
					if (flag2 && !XmlCharType.Instance.IsOnlyWhitespace(reader.Value))
					{
						flag2 = false;
					}
				}
				else if ((uint)(xmlNodeType - 13) > 1u)
				{
					if (xmlNodeType != XmlNodeType.EndEntity)
					{
						break;
					}
					reader.Read();
					continue;
				}
				ExtendRecordBuffer(num);
				FillupTextRecord(ref records[num]);
				reader.Read();
				num++;
				continue;
				IL_0139:
				reader.ResolveEntity();
				reader.Read();
			}
			nodeType = ((!flag2) ? XmlNodeType.Text : (flag ? XmlNodeType.SignificantWhitespace : XmlNodeType.Whitespace));
			return num;
		}

		private bool ReadNextSibling()
		{
			if (currentRecord < lastTextNode)
			{
				currentRecord++;
				if (currentRecord == lastTextNode)
				{
					lastTextNode = 0;
				}
				return true;
			}
			currentRecord = 0;
			while (!reader.EOF)
			{
				switch (reader.NodeType)
				{
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
				case XmlNodeType.EntityReference:
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
				{
					int num = ReadTextNodes();
					if (num != 0)
					{
						lastTextNode = num - 1;
						return true;
					}
					break;
				}
				case XmlNodeType.Element:
					scopeManager.EnterScope();
					numAttributes = ReadElement();
					return true;
				case XmlNodeType.EndElement:
					nodeType = XmlNodeType.EndElement;
					isEmptyElement = false;
					FillupRecord(ref records[0]);
					reader.Read();
					SetRecordEnd(ref records[0]);
					return false;
				default:
					reader.Read();
					break;
				}
			}
			return false;
		}

		private int ReadElement()
		{
			attributesRead = false;
			FillupRecord(ref records[0]);
			nodeType = XmlNodeType.Element;
			isEmptyElement = reader.IsEmptyElement;
			ctxInfo = new ContextInfo(this);
			int num = 1;
			if (reader.MoveToFirstAttribute())
			{
				do
				{
					ExtendRecordBuffer(num);
					if (ReadAttribute(ref records[num]))
					{
						num++;
					}
				}
				while (reader.MoveToNextAttribute());
				reader.MoveToElement();
			}
			reader.Read();
			SetRecordEnd(ref records[0]);
			ctxInfo.lineInfo = BuildLineInfo();
			attributes = null;
			return num - 1;
		}

		public void MoveToElement()
		{
			currentRecord = 0;
		}

		private bool MoveToAttributeBase(int attNum)
		{
			if (0 < attNum && attNum <= numAttributes)
			{
				currentRecord = attNum;
				return true;
			}
			currentRecord = 0;
			return false;
		}

		public bool MoveToLiteralAttribute(int attNum)
		{
			if (0 < attNum && attNum <= numAttributes)
			{
				currentRecord = attNum;
				return true;
			}
			currentRecord = 0;
			return false;
		}

		public bool MoveToXsltAttribute(int attNum, string attName)
		{
			currentRecord = xsltAttributeNumber[attNum];
			return currentRecord != 0;
		}

		public bool IsRequiredAttribute(int attNum)
		{
			return (attributes[attNum].flags & ((compiler.Version == 2) ? XsltLoader.V2Req : XsltLoader.V1Req)) != 0;
		}

		public bool AttributeExists(int attNum, string attName)
		{
			return xsltAttributeNumber[attNum] != 0;
		}

		public bool IsNs(string ns)
		{
			return Ref.Equal(ns, NamespaceUri);
		}

		public bool IsKeyword(string kwd)
		{
			return Ref.Equal(kwd, LocalName);
		}

		public bool IsXsltNamespace()
		{
			return IsNs(atoms.UriXsl);
		}

		public bool IsNullNamespace()
		{
			return IsNs(string.Empty);
		}

		public bool IsXsltAttribute(string kwd)
		{
			if (IsKeyword(kwd))
			{
				return IsNullNamespace();
			}
			return false;
		}

		public bool IsXsltKeyword(string kwd)
		{
			if (IsKeyword(kwd))
			{
				return IsXsltNamespace();
			}
			return false;
		}

		public bool IsExtensionNamespace(string uri)
		{
			return scopeManager.IsExNamespace(uri);
		}

		private void SetVersion(int attVersion)
		{
			MoveToLiteralAttribute(attVersion);
			double num = XPathConvert.StringToDouble(Value);
			if (double.IsNaN(num))
			{
				ReportError("Xslt_InvalidAttrValue", atoms.Version, Value);
				num = 1.0;
			}
			SetVersion(num);
		}

		private void SetVersion(double version)
		{
			if (compiler.Version == 0)
			{
				compiler.Version = 1;
			}
			if (compiler.Version == 1)
			{
				scopeManager.BackwardCompatibility = false;
				scopeManager.ForwardCompatibility = version != 1.0;
			}
			else
			{
				scopeManager.BackwardCompatibility = version < 2.0;
				scopeManager.ForwardCompatibility = 2.0 < version;
			}
		}

		public ContextInfo GetAttributes()
		{
			return GetAttributes(noAttributes);
		}

		public ContextInfo GetAttributes(XsltAttribute[] attributes)
		{
			this.attributes = attributes;
			records[0].value = null;
			int attExPrefixes = 0;
			int attExPrefixes2 = 0;
			int xPathDefaultNamespace = 0;
			int defaultCollation = 0;
			int num = 0;
			bool flag = IsXsltNamespace() && IsKeyword(atoms.Output);
			bool flag2 = IsXsltNamespace() && (IsKeyword(atoms.Stylesheet) || IsKeyword(atoms.Transform));
			bool flag3 = compiler.Version == 2;
			for (int i = 0; i < attributes.Length; i++)
			{
				xsltAttributeNumber[i] = 0;
			}
			compiler.EnterForwardsCompatible();
			if (flag2 || (flag3 && !flag))
			{
				for (int j = 1; MoveToAttributeBase(j); j++)
				{
					if (IsNullNamespace() && IsKeyword(atoms.Version))
					{
						SetVersion(j);
						break;
					}
				}
			}
			if (compiler.Version == 0)
			{
				SetVersion(1.0);
			}
			flag3 = compiler.Version == 2;
			int num2 = (flag3 ? (XsltLoader.V2Opt | XsltLoader.V2Req) : (XsltLoader.V1Opt | XsltLoader.V1Req));
			for (int k = 1; MoveToAttributeBase(k); k++)
			{
				if (IsNullNamespace())
				{
					string localName = LocalName;
					int l;
					for (l = 0; l < attributes.Length; l++)
					{
						if (Ref.Equal(localName, attributes[l].name) && (attributes[l].flags & num2) != 0)
						{
							xsltAttributeNumber[l] = k;
							break;
						}
					}
					if (l == attributes.Length)
					{
						if (Ref.Equal(localName, atoms.ExcludeResultPrefixes) && (flag2 || flag3))
						{
							attExPrefixes2 = k;
							continue;
						}
						if (Ref.Equal(localName, atoms.ExtensionElementPrefixes) && (flag2 || flag3))
						{
							attExPrefixes = k;
							continue;
						}
						if (Ref.Equal(localName, atoms.XPathDefaultNamespace) && flag3)
						{
							xPathDefaultNamespace = k;
							continue;
						}
						if (Ref.Equal(localName, atoms.DefaultCollation) && flag3)
						{
							defaultCollation = k;
							continue;
						}
						if (Ref.Equal(localName, atoms.UseWhen) && flag3)
						{
							num = k;
							continue;
						}
						ReportError("Xslt_InvalidAttribute", QualifiedName, records[0].QualifiedName);
					}
				}
				else if (IsXsltNamespace())
				{
					ReportError("Xslt_InvalidAttribute", QualifiedName, records[0].QualifiedName);
				}
			}
			attributesRead = true;
			compiler.ExitForwardsCompatible(ForwardCompatibility);
			InsertExNamespaces(attExPrefixes, ctxInfo, extensions: true);
			InsertExNamespaces(attExPrefixes2, ctxInfo, extensions: false);
			SetXPathDefaultNamespace(xPathDefaultNamespace);
			SetDefaultCollation(defaultCollation);
			if (num != 0)
			{
				ReportNYI(atoms.UseWhen);
			}
			MoveToElement();
			for (int m = 0; m < attributes.Length; m++)
			{
				if (xsltAttributeNumber[m] == 0)
				{
					int flags = attributes[m].flags;
					if ((compiler.Version == 2 && (flags & XsltLoader.V2Req) != 0) || (compiler.Version == 1 && (flags & XsltLoader.V1Req) != 0 && (!ForwardCompatibility || (flags & XsltLoader.V2Req) != 0)))
					{
						ReportError("Xslt_MissingAttribute", attributes[m].name);
					}
				}
			}
			return ctxInfo;
		}

		public ContextInfo GetLiteralAttributes(bool asStylesheet)
		{
			int num = 0;
			int attExPrefixes = 0;
			int attExPrefixes2 = 0;
			int xPathDefaultNamespace = 0;
			int defaultCollation = 0;
			int num2 = 0;
			for (int i = 1; MoveToLiteralAttribute(i); i++)
			{
				if (IsXsltNamespace())
				{
					string localName = LocalName;
					if (Ref.Equal(localName, atoms.Version))
					{
						num = i;
					}
					else if (Ref.Equal(localName, atoms.ExtensionElementPrefixes))
					{
						attExPrefixes = i;
					}
					else if (Ref.Equal(localName, atoms.ExcludeResultPrefixes))
					{
						attExPrefixes2 = i;
					}
					else if (Ref.Equal(localName, atoms.XPathDefaultNamespace))
					{
						xPathDefaultNamespace = i;
					}
					else if (Ref.Equal(localName, atoms.DefaultCollation))
					{
						defaultCollation = i;
					}
					else if (Ref.Equal(localName, atoms.UseWhen))
					{
						num2 = i;
					}
				}
			}
			attributesRead = true;
			MoveToElement();
			if (num != 0)
			{
				SetVersion(num);
			}
			else if (asStylesheet)
			{
				ReportError((Ref.Equal(NamespaceUri, atoms.UriWdXsl) && Ref.Equal(LocalName, atoms.Stylesheet)) ? "Xslt_WdXslNamespace" : "Xslt_WrongStylesheetElement");
				SetVersion(1.0);
			}
			InsertExNamespaces(attExPrefixes, ctxInfo, extensions: true);
			if (!IsExtensionNamespace(records[0].nsUri))
			{
				if (compiler.Version == 2)
				{
					SetXPathDefaultNamespace(xPathDefaultNamespace);
					SetDefaultCollation(defaultCollation);
					if (num2 != 0)
					{
						ReportNYI(atoms.UseWhen);
					}
				}
				InsertExNamespaces(attExPrefixes2, ctxInfo, extensions: false);
			}
			return ctxInfo;
		}

		public void GetVersionAttribute()
		{
			if (compiler.Version == 2)
			{
				for (int i = 1; MoveToAttributeBase(i); i++)
				{
					if (IsNullNamespace() && IsKeyword(atoms.Version))
					{
						SetVersion(i);
						break;
					}
				}
			}
			attributesRead = true;
		}

		private void InsertExNamespaces(int attExPrefixes, ContextInfo ctxInfo, bool extensions)
		{
			if (!MoveToLiteralAttribute(attExPrefixes))
			{
				return;
			}
			string value = Value;
			if (value.Length == 0)
			{
				return;
			}
			if (!extensions && compiler.Version != 1 && value == "#all")
			{
				ctxInfo.nsList = new NsDecl(ctxInfo.nsList, null, null);
				return;
			}
			compiler.EnterForwardsCompatible();
			string[] array = XmlConvert.SplitString(value);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == "#default")
				{
					array[i] = LookupXmlNamespace(string.Empty);
					if (array[i].Length == 0 && compiler.Version != 1 && !BackwardCompatibility)
					{
						ReportError("Xslt_ExcludeDefault");
					}
				}
				else
				{
					array[i] = LookupXmlNamespace(array[i]);
				}
			}
			if (!compiler.ExitForwardsCompatible(ForwardCompatibility))
			{
				return;
			}
			for (int j = 0; j < array.Length; j++)
			{
				if (array[j] != null)
				{
					ctxInfo.nsList = new NsDecl(ctxInfo.nsList, null, array[j]);
					if (extensions)
					{
						scopeManager.AddExNamespace(array[j]);
					}
				}
			}
		}

		private void SetXPathDefaultNamespace(int attNamespace)
		{
			if (MoveToLiteralAttribute(attNamespace) && Value.Length != 0)
			{
				ReportNYI(atoms.XPathDefaultNamespace);
			}
		}

		private void SetDefaultCollation(int attCollation)
		{
			if (MoveToLiteralAttribute(attCollation))
			{
				string[] array = XmlConvert.SplitString(Value);
				int i;
				for (i = 0; i < array.Length && XmlCollation.Create(array[i], throwOnError: false) == null; i++)
				{
				}
				if (i == array.Length)
				{
					ReportErrorFC("Xslt_CollationSyntax");
				}
				else if (array[i] != "http://www.w3.org/2004/10/xpath-functions/collation/codepoint")
				{
					ReportNYI(atoms.DefaultCollation);
				}
			}
		}

		private static int PositionAdjustment(XmlNodeType nt)
		{
			return nt switch
			{
				XmlNodeType.Element => 1, 
				XmlNodeType.CDATA => 9, 
				XmlNodeType.ProcessingInstruction => 2, 
				XmlNodeType.Comment => 4, 
				XmlNodeType.EndElement => 2, 
				XmlNodeType.EntityReference => 1, 
				_ => 0, 
			};
		}

		public ISourceLineInfo BuildLineInfo()
		{
			return new SourceLineInfo(Uri, Start, End);
		}

		public ISourceLineInfo BuildNameLineInfo()
		{
			if (readerLineInfo == null)
			{
				return BuildLineInfo();
			}
			if (LocalName == null)
			{
				FillupRecord(ref records[currentRecord]);
			}
			Location start = Start;
			int line = start.Line;
			int num = start.Pos + PositionAdjustment(NodeType);
			return new SourceLineInfo(Uri, new Location(line, num), new Location(line, num + QualifiedName.Length));
		}

		public ISourceLineInfo BuildReaderLineInfo()
		{
			Location location = ((readerLineInfo == null) ? new Location(0, 0) : new Location(readerLineInfo.LineNumber, readerLineInfo.LinePosition));
			return new SourceLineInfo(reader.BaseURI, location, location);
		}

		public string LookupXmlNamespace(string prefix)
		{
			string text = scopeManager.LookupNamespace(prefix);
			if (text != null)
			{
				return text;
			}
			if (prefix.Length == 0)
			{
				return string.Empty;
			}
			ReportError("Xslt_InvalidPrefix", prefix);
			return null;
		}

		public void ReportError(string res, params string[] args)
		{
			compiler.ReportError(BuildNameLineInfo(), res, args);
		}

		public void ReportErrorFC(string res, params string[] args)
		{
			if (!ForwardCompatibility)
			{
				compiler.ReportError(BuildNameLineInfo(), res, args);
			}
		}

		public void ReportWarning(string res, params string[] args)
		{
			compiler.ReportWarning(BuildNameLineInfo(), res, args);
		}

		private void ReportNYI(string arg)
		{
			ReportErrorFC("Xslt_NotYetImplemented", arg);
		}
	}
	internal class XsltLoader : IErrorHelper
	{
		private enum InstructionFlags
		{
			None = 0,
			AllowParam = 1,
			AllowSort = 2,
			AllowFallback = 4
		}

		private Compiler compiler;

		private XmlResolver xmlResolver;

		private QueryReaderSettings readerSettings;

		private KeywordsTable atoms;

		private XsltInput input;

		private Stylesheet curStylesheet;

		private Template curTemplate;

		private object curFunction;

		internal static QilName nullMode = AstFactory.QName(string.Empty);

		public static int V1Opt = 1;

		public static int V1Req = 2;

		public static int V2Opt = 4;

		public static int V2Req = 8;

		private HybridDictionary documentUriInUse = new HybridDictionary();

		private XsltInput.XsltAttribute[] stylesheetAttributes = new XsltInput.XsltAttribute[4]
		{
			new XsltInput.XsltAttribute("version", V1Req | V2Req),
			new XsltInput.XsltAttribute("id", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("default-validation", V2Opt),
			new XsltInput.XsltAttribute("input-type-annotations", V2Opt)
		};

		private XsltInput.XsltAttribute[] importIncludeAttributes = new XsltInput.XsltAttribute[1]
		{
			new XsltInput.XsltAttribute("href", V1Req | V2Req)
		};

		private XsltInput.XsltAttribute[] loadStripSpaceAttributes = new XsltInput.XsltAttribute[1]
		{
			new XsltInput.XsltAttribute("elements", V1Req | V2Req)
		};

		private XsltInput.XsltAttribute[] outputAttributes = new XsltInput.XsltAttribute[17]
		{
			new XsltInput.XsltAttribute("name", V2Opt),
			new XsltInput.XsltAttribute("method", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("byte-order-mark", V2Opt),
			new XsltInput.XsltAttribute("cdata-section-elements", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("doctype-public", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("doctype-system", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("encoding", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("escape-uri-attributes", V2Opt),
			new XsltInput.XsltAttribute("include-content-type", V2Opt),
			new XsltInput.XsltAttribute("indent", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("media-type", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("normalization-form", V2Opt),
			new XsltInput.XsltAttribute("omit-xml-declaration", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("standalone", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("undeclare-prefixes", V2Opt),
			new XsltInput.XsltAttribute("use-character-maps", V2Opt),
			new XsltInput.XsltAttribute("version", V1Opt | V2Opt)
		};

		private XsltInput.XsltAttribute[] keyAttributes = new XsltInput.XsltAttribute[4]
		{
			new XsltInput.XsltAttribute("name", V1Req | V2Req),
			new XsltInput.XsltAttribute("match", V1Req | V2Req),
			new XsltInput.XsltAttribute("use", V1Req | V2Opt),
			new XsltInput.XsltAttribute("collation", V2Opt)
		};

		private XsltInput.XsltAttribute[] decimalFormatAttributes = new XsltInput.XsltAttribute[11]
		{
			new XsltInput.XsltAttribute("name", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("infinity", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("NaN", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("decimal-separator", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("grouping-separator", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("percent", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("per-mille", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("zero-digit", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("digit", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("pattern-separator", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("minus-sign", V1Opt | V2Opt)
		};

		private XsltInput.XsltAttribute[] namespaceAliasAttributes = new XsltInput.XsltAttribute[2]
		{
			new XsltInput.XsltAttribute("stylesheet-prefix", V1Req | V2Req),
			new XsltInput.XsltAttribute("result-prefix", V1Req | V2Req)
		};

		private XsltInput.XsltAttribute[] attributeSetAttributes = new XsltInput.XsltAttribute[2]
		{
			new XsltInput.XsltAttribute("name", V1Req | V2Req),
			new XsltInput.XsltAttribute("use-attribute-sets", V1Opt | V2Opt)
		};

		private XsltInput.XsltAttribute[] templateAttributes = new XsltInput.XsltAttribute[5]
		{
			new XsltInput.XsltAttribute("match", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("name", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("priority", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("mode", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("as", V2Opt)
		};

		private XsltInput.XsltAttribute[] scriptAttributes = new XsltInput.XsltAttribute[2]
		{
			new XsltInput.XsltAttribute("implements-prefix", V1Req | V2Req),
			new XsltInput.XsltAttribute("language", V1Opt | V2Opt)
		};

		private XsltInput.XsltAttribute[] assemblyAttributes = new XsltInput.XsltAttribute[2]
		{
			new XsltInput.XsltAttribute("name", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("href", V1Opt | V2Opt)
		};

		private XsltInput.XsltAttribute[] usingAttributes = new XsltInput.XsltAttribute[1]
		{
			new XsltInput.XsltAttribute("namespace", V1Req | V2Req)
		};

		private const int MAX_LOADINSTRUCTIONS_DEPTH = 1024;

		private int loadInstructionsDepth;

		private XsltInput.XsltAttribute[] applyTemplatesAttributes = new XsltInput.XsltAttribute[2]
		{
			new XsltInput.XsltAttribute("select", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("mode", V1Opt | V2Opt)
		};

		private XsltInput.XsltAttribute[] callTemplateAttributes = new XsltInput.XsltAttribute[1]
		{
			new XsltInput.XsltAttribute("name", V1Req | V2Req)
		};

		private XsltInput.XsltAttribute[] copyAttributes = new XsltInput.XsltAttribute[5]
		{
			new XsltInput.XsltAttribute("copy-namespaces", V2Opt),
			new XsltInput.XsltAttribute("inherit-namespaces", V2Opt),
			new XsltInput.XsltAttribute("use-attribute-sets", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("type", V2Opt),
			new XsltInput.XsltAttribute("validation", V2Opt)
		};

		private XsltInput.XsltAttribute[] copyOfAttributes = new XsltInput.XsltAttribute[4]
		{
			new XsltInput.XsltAttribute("select", V1Req | V2Req),
			new XsltInput.XsltAttribute("copy-namespaces", V2Opt),
			new XsltInput.XsltAttribute("type", V2Opt),
			new XsltInput.XsltAttribute("validation", V2Opt)
		};

		private XsltInput.XsltAttribute[] ifAttributes = new XsltInput.XsltAttribute[1]
		{
			new XsltInput.XsltAttribute("test", V1Req | V2Req)
		};

		private XsltInput.XsltAttribute[] forEachAttributes = new XsltInput.XsltAttribute[1]
		{
			new XsltInput.XsltAttribute("select", V1Req | V2Req)
		};

		private XsltInput.XsltAttribute[] messageAttributes = new XsltInput.XsltAttribute[2]
		{
			new XsltInput.XsltAttribute("select", V2Opt),
			new XsltInput.XsltAttribute("terminate", V1Opt | V2Opt)
		};

		private XsltInput.XsltAttribute[] numberAttributes = new XsltInput.XsltAttribute[11]
		{
			new XsltInput.XsltAttribute("value", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("select", V2Opt),
			new XsltInput.XsltAttribute("level", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("count", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("from", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("format", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("lang", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("letter-value", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("ordinal", V2Opt),
			new XsltInput.XsltAttribute("grouping-separator", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("grouping-size", V1Opt | V2Opt)
		};

		private XsltInput.XsltAttribute[] valueOfAttributes = new XsltInput.XsltAttribute[3]
		{
			new XsltInput.XsltAttribute("select", V1Req | V2Opt),
			new XsltInput.XsltAttribute("separator", V2Opt),
			new XsltInput.XsltAttribute("disable-output-escaping", V1Opt | V2Opt)
		};

		private XsltInput.XsltAttribute[] variableAttributes = new XsltInput.XsltAttribute[5]
		{
			new XsltInput.XsltAttribute("name", V1Req | V2Req),
			new XsltInput.XsltAttribute("select", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("as", V2Opt),
			new XsltInput.XsltAttribute("required", 0),
			new XsltInput.XsltAttribute("tunnel", 0)
		};

		private XsltInput.XsltAttribute[] paramAttributes = new XsltInput.XsltAttribute[5]
		{
			new XsltInput.XsltAttribute("name", V1Req | V2Req),
			new XsltInput.XsltAttribute("select", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("as", V2Opt),
			new XsltInput.XsltAttribute("required", V2Opt),
			new XsltInput.XsltAttribute("tunnel", V2Opt)
		};

		private XsltInput.XsltAttribute[] withParamAttributes = new XsltInput.XsltAttribute[5]
		{
			new XsltInput.XsltAttribute("name", V1Req | V2Req),
			new XsltInput.XsltAttribute("select", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("as", V2Opt),
			new XsltInput.XsltAttribute("required", 0),
			new XsltInput.XsltAttribute("tunnel", V2Opt)
		};

		private XsltInput.XsltAttribute[] commentAttributes = new XsltInput.XsltAttribute[1]
		{
			new XsltInput.XsltAttribute("select", V2Opt)
		};

		private XsltInput.XsltAttribute[] processingInstructionAttributes = new XsltInput.XsltAttribute[2]
		{
			new XsltInput.XsltAttribute("name", V1Req | V2Req),
			new XsltInput.XsltAttribute("select", V2Opt)
		};

		private XsltInput.XsltAttribute[] textAttributes = new XsltInput.XsltAttribute[1]
		{
			new XsltInput.XsltAttribute("disable-output-escaping", V1Opt | V2Opt)
		};

		private XsltInput.XsltAttribute[] elementAttributes = new XsltInput.XsltAttribute[6]
		{
			new XsltInput.XsltAttribute("name", V1Req | V2Req),
			new XsltInput.XsltAttribute("namespace", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("inherit-namespaces", V2Opt),
			new XsltInput.XsltAttribute("use-attribute-sets", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("type", V2Opt),
			new XsltInput.XsltAttribute("validation", V2Opt)
		};

		private XsltInput.XsltAttribute[] attributeAttributes = new XsltInput.XsltAttribute[6]
		{
			new XsltInput.XsltAttribute("name", V1Req | V2Req),
			new XsltInput.XsltAttribute("namespace", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("select", V2Opt),
			new XsltInput.XsltAttribute("separator", V2Opt),
			new XsltInput.XsltAttribute("type", V2Opt),
			new XsltInput.XsltAttribute("validation", V2Opt)
		};

		private XsltInput.XsltAttribute[] sortAttributes = new XsltInput.XsltAttribute[7]
		{
			new XsltInput.XsltAttribute("select", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("lang", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("order", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("collation", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("stable", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("case-order", V1Opt | V2Opt),
			new XsltInput.XsltAttribute("data-type", V1Opt | V2Opt)
		};

		private bool V1 => compiler.Version == 1;

		public void Load(Compiler compiler, object stylesheet, XmlResolver xmlResolver)
		{
			this.compiler = compiler;
			this.xmlResolver = xmlResolver ?? XmlNullResolver.Singleton;
			if (stylesheet is XmlReader reader)
			{
				readerSettings = new QueryReaderSettings(reader);
				Load(reader);
			}
			else if (stylesheet is string text)
			{
				XmlResolver xmlResolver2 = xmlResolver;
				if (xmlResolver == null || xmlResolver == XmlNullResolver.Singleton)
				{
					xmlResolver2 = new XmlUrlResolver();
				}
				Uri uri = xmlResolver2.ResolveUri(null, text);
				if (uri == null)
				{
					throw new XslLoadException("Xslt_CantResolve", text);
				}
				readerSettings = new QueryReaderSettings(new NameTable());
				XmlReader reader2;
				using (reader2 = CreateReader(uri, xmlResolver2))
				{
					Load(reader2);
				}
			}
			else if (stylesheet is IXPathNavigable iXPathNavigable)
			{
				XmlReader reader2 = XPathNavigatorReader.Create(iXPathNavigable.CreateNavigator());
				readerSettings = new QueryReaderSettings(reader2.NameTable);
				Load(reader2);
			}
			compiler.StartApplyTemplates = AstFactory.ApplyTemplates(nullMode);
			ProcessOutputSettings();
			foreach (AttributeSet value in compiler.AttributeSets.Values)
			{
				CheckAttributeSetsDfs(value);
			}
		}

		private void Load(XmlReader reader)
		{
			atoms = new KeywordsTable(reader.NameTable);
			AtomizeAttributes();
			LoadStylesheet(reader, include: false);
		}

		private void AtomizeAttributes(XsltInput.XsltAttribute[] attributes)
		{
			for (int i = 0; i < attributes.Length; i++)
			{
				attributes[i].name = atoms.NameTable.Add(attributes[i].name);
			}
		}

		private void AtomizeAttributes()
		{
			AtomizeAttributes(stylesheetAttributes);
			AtomizeAttributes(importIncludeAttributes);
			AtomizeAttributes(loadStripSpaceAttributes);
			AtomizeAttributes(outputAttributes);
			AtomizeAttributes(keyAttributes);
			AtomizeAttributes(decimalFormatAttributes);
			AtomizeAttributes(namespaceAliasAttributes);
			AtomizeAttributes(attributeSetAttributes);
			AtomizeAttributes(templateAttributes);
			AtomizeAttributes(scriptAttributes);
			AtomizeAttributes(assemblyAttributes);
			AtomizeAttributes(usingAttributes);
			AtomizeAttributes(applyTemplatesAttributes);
			AtomizeAttributes(callTemplateAttributes);
			AtomizeAttributes(copyAttributes);
			AtomizeAttributes(copyOfAttributes);
			AtomizeAttributes(ifAttributes);
			AtomizeAttributes(forEachAttributes);
			AtomizeAttributes(messageAttributes);
			AtomizeAttributes(numberAttributes);
			AtomizeAttributes(valueOfAttributes);
			AtomizeAttributes(variableAttributes);
			AtomizeAttributes(paramAttributes);
			AtomizeAttributes(withParamAttributes);
			AtomizeAttributes(commentAttributes);
			AtomizeAttributes(processingInstructionAttributes);
			AtomizeAttributes(textAttributes);
			AtomizeAttributes(elementAttributes);
			AtomizeAttributes(attributeAttributes);
			AtomizeAttributes(sortAttributes);
		}

		private Uri ResolveUri(string relativeUri, string baseUri)
		{
			Uri baseUri2 = ((baseUri.Length != 0) ? xmlResolver.ResolveUri(null, baseUri) : null);
			Uri uri = xmlResolver.ResolveUri(baseUri2, relativeUri);
			if (uri == null)
			{
				throw new XslLoadException("Xslt_CantResolve", relativeUri);
			}
			return uri;
		}

		private XmlReader CreateReader(Uri uri, XmlResolver xmlResolver)
		{
			object entity = xmlResolver.GetEntity(uri, null, null);
			if (entity is Stream stream)
			{
				return readerSettings.CreateReader(stream, uri.ToString());
			}
			if (entity is XmlReader result)
			{
				return result;
			}
			if (entity is IXPathNavigable iXPathNavigable)
			{
				return XPathNavigatorReader.Create(iXPathNavigable.CreateNavigator());
			}
			throw new XslLoadException("Xslt_CannotLoadStylesheet", uri.ToString(), (entity == null) ? "null" : entity.GetType().ToString());
		}

		private Stylesheet LoadStylesheet(Uri uri, bool include)
		{
			using XmlReader reader = CreateReader(uri, xmlResolver);
			return LoadStylesheet(reader, include);
		}

		private Stylesheet LoadStylesheet(XmlReader reader, bool include)
		{
			string baseURI = reader.BaseURI;
			documentUriInUse.Add(baseURI, null);
			compiler.AddModule(baseURI);
			Stylesheet stylesheet = curStylesheet;
			XsltInput xsltInput = input;
			Stylesheet result = (include ? curStylesheet : compiler.CreateStylesheet());
			input = new XsltInput(reader, compiler, atoms);
			curStylesheet = result;
			try
			{
				LoadDocument();
				if (!include)
				{
					compiler.MergeWithStylesheet(curStylesheet);
					List<Uri> importHrefs = curStylesheet.ImportHrefs;
					curStylesheet.Imports = new Stylesheet[importHrefs.Count];
					int num = importHrefs.Count;
					while (0 <= --num)
					{
						curStylesheet.Imports[num] = LoadStylesheet(importHrefs[num], include: false);
					}
					return result;
				}
				return result;
			}
			catch (XslLoadException)
			{
				throw;
			}
			catch (Exception ex2)
			{
				if (!XmlException.IsCatchableException(ex2))
				{
					throw;
				}
				ISourceLineInfo sourceLineInfo;
				if (!(ex2 is XmlException ex3) || ex3.SourceUri == null)
				{
					sourceLineInfo = input.BuildReaderLineInfo();
				}
				else
				{
					ISourceLineInfo sourceLineInfo2 = new SourceLineInfo(ex3.SourceUri, ex3.LineNumber, ex3.LinePosition, ex3.LineNumber, ex3.LinePosition);
					sourceLineInfo = sourceLineInfo2;
				}
				ISourceLineInfo lineInfo = sourceLineInfo;
				throw new XslLoadException(ex2, lineInfo);
			}
			finally
			{
				documentUriInUse.Remove(baseURI);
				input = xsltInput;
				curStylesheet = stylesheet;
			}
		}

		private void LoadDocument()
		{
			if (!input.FindStylesheetElement())
			{
				ReportError("Xslt_WrongStylesheetElement");
				return;
			}
			if (input.IsXsltNamespace())
			{
				if (input.IsKeyword(atoms.Stylesheet) || input.IsKeyword(atoms.Transform))
				{
					LoadRealStylesheet();
				}
				else
				{
					ReportError("Xslt_WrongStylesheetElement");
					input.SkipNode();
				}
			}
			else
			{
				LoadSimplifiedStylesheet();
			}
			input.Finish();
		}

		private void LoadSimplifiedStylesheet()
		{
			curTemplate = AstFactory.Template(null, "/", nullMode, double.NaN, input.XslVersion);
			input.CanHaveApplyImports = true;
			XslNode xslNode = LoadLiteralResultElement(asStylesheet: true);
			if (xslNode != null)
			{
				SetLineInfo(curTemplate, xslNode.SourceLine);
				List<XslNode> list = new List<XslNode>();
				list.Add(xslNode);
				SetContent(curTemplate, list);
				curStylesheet.AddTemplate(curTemplate);
			}
			curTemplate = null;
		}

		private void LoadRealStylesheet()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(stylesheetAttributes);
			ParseValidationAttribute(2, defVal: true);
			ParseInputTypeAnnotationsAttribute(3);
			XsltInput.DelayedQName elementName = input.ElementName;
			if (!input.MoveToFirstChild())
			{
				return;
			}
			bool flag = true;
			do
			{
				bool flag2 = false;
				switch (input.NodeType)
				{
				case XmlNodeType.Element:
					if (input.IsXsltNamespace())
					{
						if (input.IsKeyword(atoms.Import))
						{
							if (!flag)
							{
								ReportError("Xslt_NotAtTop", input.QualifiedName, elementName);
								input.SkipNode();
							}
							else
							{
								flag2 = true;
								LoadImport();
							}
						}
						else if (input.IsKeyword(atoms.Include))
						{
							LoadInclude();
						}
						else if (input.IsKeyword(atoms.StripSpace))
						{
							LoadStripSpace(attributes.nsList);
						}
						else if (input.IsKeyword(atoms.PreserveSpace))
						{
							LoadPreserveSpace(attributes.nsList);
						}
						else if (input.IsKeyword(atoms.Output))
						{
							LoadOutput();
						}
						else if (input.IsKeyword(atoms.Key))
						{
							LoadKey(attributes.nsList);
						}
						else if (input.IsKeyword(atoms.DecimalFormat))
						{
							LoadDecimalFormat(attributes.nsList);
						}
						else if (input.IsKeyword(atoms.NamespaceAlias))
						{
							LoadNamespaceAlias(attributes.nsList);
						}
						else if (input.IsKeyword(atoms.AttributeSet))
						{
							LoadAttributeSet(attributes.nsList);
						}
						else if (input.IsKeyword(atoms.Variable))
						{
							LoadGlobalVariableOrParameter(attributes.nsList, XslNodeType.Variable);
						}
						else if (input.IsKeyword(atoms.Param))
						{
							LoadGlobalVariableOrParameter(attributes.nsList, XslNodeType.Param);
						}
						else if (input.IsKeyword(atoms.Template))
						{
							LoadTemplate(attributes.nsList);
						}
						else
						{
							input.GetVersionAttribute();
							if (!input.ForwardCompatibility)
							{
								ReportError("Xslt_UnexpectedElement", input.QualifiedName, elementName);
							}
							input.SkipNode();
						}
					}
					else if (input.IsNs(atoms.UrnMsxsl) && input.IsKeyword(atoms.Script))
					{
						LoadMsScript(attributes.nsList);
					}
					else
					{
						if (input.IsNullNamespace())
						{
							ReportError("Xslt_NullNsAtTopLevel", input.LocalName);
						}
						input.SkipNode();
					}
					flag = flag2;
					break;
				default:
					ReportError("Xslt_TextNodesNotAllowed", elementName);
					break;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					break;
				}
			}
			while (input.MoveToNextSibling());
		}

		private void LoadImport()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(importIncludeAttributes);
			if (input.MoveToXsltAttribute(0, "href"))
			{
				Uri uri = ResolveUri(input.Value, input.BaseUri);
				if (documentUriInUse.Contains(uri.ToString()))
				{
					ReportError("Xslt_CircularInclude", input.Value);
				}
				else
				{
					curStylesheet.ImportHrefs.Add(uri);
				}
			}
			CheckNoContent();
		}

		private void LoadInclude()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(importIncludeAttributes);
			if (input.MoveToXsltAttribute(0, "href"))
			{
				Uri uri = ResolveUri(input.Value, input.BaseUri);
				if (documentUriInUse.Contains(uri.ToString()))
				{
					ReportError("Xslt_CircularInclude", input.Value);
				}
				else
				{
					LoadStylesheet(uri, include: true);
				}
			}
			CheckNoContent();
		}

		private void LoadStripSpace(NsDecl stylesheetNsList)
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(loadStripSpaceAttributes);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			if (input.MoveToXsltAttribute(0, atoms.Elements))
			{
				ParseWhitespaceRules(input.Value, preserveSpace: false);
			}
			CheckNoContent();
		}

		private void LoadPreserveSpace(NsDecl stylesheetNsList)
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(loadStripSpaceAttributes);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			if (input.MoveToXsltAttribute(0, atoms.Elements))
			{
				ParseWhitespaceRules(input.Value, preserveSpace: true);
			}
			CheckNoContent();
		}

		private void LoadOutput()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(outputAttributes);
			Output output = compiler.Output;
			XmlWriterSettings settings = output.Settings;
			int currentPrecedence = compiler.CurrentPrecedence;
			QilName qilName = ParseQNameAttribute(0);
			if (qilName != null)
			{
				ReportNYI("xsl:output/@name");
			}
			if (input.MoveToXsltAttribute(1, "method") && output.MethodPrec <= currentPrecedence)
			{
				compiler.EnterForwardsCompatible();
				XmlOutputMethod method;
				XmlQualifiedName xmlQualifiedName = ParseOutputMethod(input.Value, out method);
				if (compiler.ExitForwardsCompatible(input.ForwardCompatibility) && xmlQualifiedName != null)
				{
					if (currentPrecedence == output.MethodPrec && !output.Method.Equals(xmlQualifiedName))
					{
						ReportWarning("Xslt_AttributeRedefinition", "method");
					}
					settings.OutputMethod = method;
					output.Method = xmlQualifiedName;
					output.MethodPrec = currentPrecedence;
				}
			}
			TriState triState = ParseYesNoAttribute(2, "byte-order-mark");
			if (triState != TriState.Unknown)
			{
				ReportNYI("xsl:output/@byte-order-mark");
			}
			if (input.MoveToXsltAttribute(3, "cdata-section-elements"))
			{
				compiler.EnterForwardsCompatible();
				string[] array = XmlConvert.SplitString(input.Value);
				List<XmlQualifiedName> list = new List<XmlQualifiedName>();
				for (int i = 0; i < array.Length; i++)
				{
					list.Add(ResolveQName(ignoreDefaultNs: false, array[i]));
				}
				if (compiler.ExitForwardsCompatible(input.ForwardCompatibility))
				{
					settings.CDataSectionElements.AddRange(list);
				}
			}
			if (input.MoveToXsltAttribute(4, "doctype-public") && output.DocTypePublicPrec <= currentPrecedence)
			{
				if (currentPrecedence == output.DocTypePublicPrec && settings.DocTypePublic != input.Value)
				{
					ReportWarning("Xslt_AttributeRedefinition", "doctype-public");
				}
				settings.DocTypePublic = input.Value;
				output.DocTypePublicPrec = currentPrecedence;
			}
			if (input.MoveToXsltAttribute(5, "doctype-system") && output.DocTypeSystemPrec <= currentPrecedence)
			{
				if (currentPrecedence == output.DocTypeSystemPrec && settings.DocTypeSystem != input.Value)
				{
					ReportWarning("Xslt_AttributeRedefinition", "doctype-system");
				}
				settings.DocTypeSystem = input.Value;
				output.DocTypeSystemPrec = currentPrecedence;
			}
			if (input.MoveToXsltAttribute(6, "encoding") && output.EncodingPrec <= currentPrecedence)
			{
				try
				{
					Encoding encoding = Encoding.GetEncoding(input.Value);
					if (currentPrecedence == output.EncodingPrec && output.Encoding != input.Value)
					{
						ReportWarning("Xslt_AttributeRedefinition", "encoding");
					}
					settings.Encoding = encoding;
					output.Encoding = input.Value;
					output.EncodingPrec = currentPrecedence;
				}
				catch (ArgumentException)
				{
					if (!input.ForwardCompatibility)
					{
						ReportWarning("Xslt_InvalidEncoding", input.Value);
					}
				}
			}
			if (ParseYesNoAttribute(7, "escape-uri-attributes") == TriState.False)
			{
				ReportNYI("xsl:output/@escape-uri-attributes == flase()");
			}
			if (ParseYesNoAttribute(8, "include-content-type") == TriState.False)
			{
				ReportNYI("xsl:output/@include-content-type == flase()");
			}
			TriState triState2 = ParseYesNoAttribute(9, "indent");
			if (triState2 != TriState.Unknown && output.IndentPrec <= currentPrecedence)
			{
				bool flag = triState2 == TriState.True;
				if (currentPrecedence == output.IndentPrec && settings.Indent != flag)
				{
					ReportWarning("Xslt_AttributeRedefinition", "indent");
				}
				settings.Indent = flag;
				output.IndentPrec = currentPrecedence;
			}
			if (input.MoveToXsltAttribute(10, "media-type") && output.MediaTypePrec <= currentPrecedence)
			{
				if (currentPrecedence == output.MediaTypePrec && settings.MediaType != input.Value)
				{
					ReportWarning("Xslt_AttributeRedefinition", "media-type");
				}
				settings.MediaType = input.Value;
				output.MediaTypePrec = currentPrecedence;
			}
			if (input.MoveToXsltAttribute(11, "normalization-form"))
			{
				ReportNYI("xsl:output/@normalization-form");
			}
			triState2 = ParseYesNoAttribute(12, "omit-xml-declaration");
			if (triState2 != TriState.Unknown && output.OmitXmlDeclarationPrec <= currentPrecedence)
			{
				bool flag2 = triState2 == TriState.True;
				if (currentPrecedence == output.OmitXmlDeclarationPrec && settings.OmitXmlDeclaration != flag2)
				{
					ReportWarning("Xslt_AttributeRedefinition", "omit-xml-declaration");
				}
				settings.OmitXmlDeclaration = flag2;
				output.OmitXmlDeclarationPrec = currentPrecedence;
			}
			triState2 = ParseYesNoAttribute(13, "standalone");
			if (triState2 != TriState.Unknown && output.StandalonePrec <= currentPrecedence)
			{
				XmlStandalone xmlStandalone = ((triState2 == TriState.True) ? XmlStandalone.Yes : XmlStandalone.No);
				if (currentPrecedence == output.StandalonePrec && settings.Standalone != xmlStandalone)
				{
					ReportWarning("Xslt_AttributeRedefinition", "standalone");
				}
				settings.Standalone = xmlStandalone;
				output.StandalonePrec = currentPrecedence;
			}
			if (ParseYesNoAttribute(14, "undeclare-prefixes") == TriState.True)
			{
				ReportNYI("xsl:output/@undeclare-prefixes == true()");
			}
			List<QilName> list2 = ParseUseCharacterMaps(15);
			if (list2.Count != 0)
			{
				ReportNYI("xsl:output/@use-character-maps");
			}
			if (input.MoveToXsltAttribute(16, "version") && output.VersionPrec <= currentPrecedence)
			{
				if (currentPrecedence == output.VersionPrec && output.Version != input.Value)
				{
					ReportWarning("Xslt_AttributeRedefinition", "version");
				}
				output.Version = input.Value;
				output.VersionPrec = currentPrecedence;
			}
			CheckNoContent();
		}

		private void ProcessOutputSettings()
		{
			Output output = compiler.Output;
			XmlWriterSettings settings = output.Settings;
			if (settings.OutputMethod == XmlOutputMethod.Html && output.IndentPrec == int.MinValue)
			{
				settings.Indent = true;
			}
			if (output.MediaTypePrec == int.MinValue)
			{
				settings.MediaType = ((settings.OutputMethod == XmlOutputMethod.Xml) ? "text/xml" : ((settings.OutputMethod == XmlOutputMethod.Html) ? "text/html" : ((settings.OutputMethod == XmlOutputMethod.Text) ? "text/plain" : null)));
			}
		}

		private void CheckUseAttrubuteSetInList(IList<XslNode> list)
		{
			foreach (XslNode item in list)
			{
				switch (item.NodeType)
				{
				case XslNodeType.UseAttributeSet:
				{
					if (compiler.AttributeSets.TryGetValue(item.Name, out var value))
					{
						CheckAttributeSetsDfs(value);
					}
					break;
				}
				case XslNodeType.List:
					CheckUseAttrubuteSetInList(item.Content);
					break;
				}
			}
		}

		private void CheckAttributeSetsDfs(AttributeSet attSet)
		{
			switch (attSet.CycleCheck)
			{
			case CycleCheck.NotStarted:
				attSet.CycleCheck = CycleCheck.Processing;
				CheckUseAttrubuteSetInList(attSet.Content);
				attSet.CycleCheck = CycleCheck.Completed;
				break;
			default:
				compiler.ReportError(attSet.Content[0].SourceLine, "Xslt_CircularAttributeSet", attSet.Name.QualifiedName);
				break;
			case CycleCheck.Completed:
				break;
			}
		}

		private void LoadKey(NsDecl stylesheetNsList)
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(keyAttributes);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			QilName qilName = ParseQNameAttribute(0);
			string match = ParseStringAttribute(1, "match");
			string text = ParseStringAttribute(2, "use");
			string text2 = ParseCollationAttribute(3);
			input.MoveToElement();
			List<XslNode> list = null;
			if (V1)
			{
				if (text == null)
				{
					input.SkipNode();
				}
				else
				{
					CheckNoContent();
				}
			}
			else
			{
				list = LoadInstructions();
				if (list.Count != 0)
				{
					list = LoadEndTag(list);
				}
				if (text == null == (list.Count == 0))
				{
					ReportError("Xslt_KeyCntUse");
				}
				else if (text == null)
				{
					ReportNYI("xsl:key[count(@use) = 0]");
				}
			}
			Key item = (Key)SetInfo(AstFactory.Key(qilName, match, text, input.XslVersion), null, attributes);
			if (compiler.Keys.Contains(qilName))
			{
				compiler.Keys[qilName].Add(item);
				return;
			}
			List<Key> list2 = new List<Key>();
			list2.Add(item);
			compiler.Keys.Add(list2);
		}

		private void LoadDecimalFormat(NsDecl stylesheetNsList)
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(decimalFormatAttributes);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			XmlQualifiedName xmlQualifiedName;
			if (input.MoveToXsltAttribute(0, "name"))
			{
				compiler.EnterForwardsCompatible();
				xmlQualifiedName = ResolveQName(ignoreDefaultNs: true, input.Value);
				if (!compiler.ExitForwardsCompatible(input.ForwardCompatibility))
				{
					xmlQualifiedName = new XmlQualifiedName();
				}
			}
			else
			{
				xmlQualifiedName = new XmlQualifiedName();
			}
			string text = DecimalFormatDecl.Default.InfinitySymbol;
			if (input.MoveToXsltAttribute(1, "infinity"))
			{
				text = input.Value;
			}
			string text2 = DecimalFormatDecl.Default.NanSymbol;
			if (input.MoveToXsltAttribute(2, "NaN"))
			{
				text2 = input.Value;
			}
			char[] characters = DecimalFormatDecl.Default.Characters;
			char[] array = new char[8];
			for (int i = 0; i < 8; i++)
			{
				array[i] = ParseCharAttribute(3 + i, decimalFormatAttributes[3 + i].name, characters[i]);
			}
			for (int j = 0; j < 7; j++)
			{
				for (int k = j + 1; k < 7; k++)
				{
					if (array[j] == array[k])
					{
						bool flag = input.MoveToXsltAttribute(3 + k, decimalFormatAttributes[3 + k].name) || input.MoveToXsltAttribute(3 + j, decimalFormatAttributes[3 + j].name);
						ReportError("Xslt_DecimalFormatSignsNotDistinct", decimalFormatAttributes[3 + j].name, decimalFormatAttributes[3 + k].name);
						break;
					}
				}
			}
			if (compiler.DecimalFormats.Contains(xmlQualifiedName))
			{
				DecimalFormatDecl decimalFormatDecl = compiler.DecimalFormats[xmlQualifiedName];
				input.MoveToXsltAttribute(1, "infinity");
				CheckError(text != decimalFormatDecl.InfinitySymbol, "Xslt_DecimalFormatRedefined", "infinity", text);
				input.MoveToXsltAttribute(2, "NaN");
				CheckError(text2 != decimalFormatDecl.NanSymbol, "Xslt_DecimalFormatRedefined", "NaN", text2);
				for (int l = 0; l < 8; l++)
				{
					input.MoveToXsltAttribute(3 + l, decimalFormatAttributes[3 + l].name);
					CheckError(array[l] != decimalFormatDecl.Characters[l], "Xslt_DecimalFormatRedefined", decimalFormatAttributes[3 + l].name, char.ToString(array[l]));
				}
			}
			else
			{
				DecimalFormatDecl item = new DecimalFormatDecl(xmlQualifiedName, text, text2, new string(array));
				compiler.DecimalFormats.Add(item);
			}
			CheckNoContent();
		}

		private void LoadNamespaceAlias(NsDecl stylesheetNsList)
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(namespaceAliasAttributes);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			string text = null;
			string text2 = null;
			string text3 = null;
			if (input.MoveToXsltAttribute(0, "stylesheet-prefix"))
			{
				if (input.Value.Length == 0)
				{
					ReportError("Xslt_EmptyNsAlias", "stylesheet-prefix");
				}
				else
				{
					text = input.LookupXmlNamespace((input.Value == "#default") ? string.Empty : input.Value);
				}
			}
			if (input.MoveToXsltAttribute(1, "result-prefix"))
			{
				if (input.Value.Length == 0)
				{
					ReportError("Xslt_EmptyNsAlias", "result-prefix");
				}
				else
				{
					text2 = ((input.Value == "#default") ? string.Empty : input.Value);
					text3 = input.LookupXmlNamespace(text2);
				}
			}
			CheckNoContent();
			if (text != null && text3 != null && compiler.SetNsAlias(text, text3, text2, curStylesheet.ImportPrecedence))
			{
				input.MoveToElement();
				ReportWarning("Xslt_DupNsAlias", text);
			}
		}

		private void LoadAttributeSet(NsDecl stylesheetNsList)
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(attributeSetAttributes);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			QilName qilName = ParseQNameAttribute(0);
			if (!curStylesheet.AttributeSets.TryGetValue(qilName, out var value))
			{
				value = AstFactory.AttributeSet(qilName);
				curStylesheet.AttributeSets[qilName] = value;
				if (!compiler.AttributeSets.ContainsKey(qilName))
				{
					compiler.AllTemplates.Add(value);
				}
			}
			List<XslNode> list = new List<XslNode>();
			if (input.MoveToXsltAttribute(1, "use-attribute-sets"))
			{
				AddUseAttributeSets(list);
			}
			XsltInput.DelayedQName elementName = input.ElementName;
			if (input.MoveToFirstChild())
			{
				do
				{
					switch (input.NodeType)
					{
					case XmlNodeType.Element:
						if (input.IsXsltKeyword(atoms.Attribute))
						{
							AddInstruction(list, XslAttribute());
							break;
						}
						ReportError("Xslt_UnexpectedElement", input.QualifiedName, elementName);
						input.SkipNode();
						break;
					default:
						ReportError("Xslt_TextNodesNotAllowed", elementName);
						break;
					case XmlNodeType.Whitespace:
					case XmlNodeType.SignificantWhitespace:
						break;
					}
				}
				while (input.MoveToNextSibling());
			}
			value.AddContent(SetInfo(AstFactory.List(), LoadEndTag(list), attributes));
		}

		private void LoadGlobalVariableOrParameter(NsDecl stylesheetNsList, XslNodeType nodeType)
		{
			VarPar varPar = XslVarPar();
			varPar.Namespaces = MergeNamespaces(varPar.Namespaces, stylesheetNsList);
			CheckError(!curStylesheet.AddVarPar(varPar), "Xslt_DupGlobalVariable", varPar.Name.QualifiedName);
		}

		private void LoadTemplate(NsDecl stylesheetNsList)
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(templateAttributes);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			string text = ParseStringAttribute(0, "match");
			QilName name = ParseQNameAttribute(1);
			double num = double.NaN;
			if (input.MoveToXsltAttribute(2, "priority"))
			{
				num = XPathConvert.StringToDouble(input.Value);
				if (double.IsNaN(num) && !input.ForwardCompatibility)
				{
					ReportError("Xslt_InvalidAttrValue", "priority", input.Value);
				}
			}
			QilName mode = (V1 ? ParseModeAttribute(3) : ParseModeListAttribute(3));
			if (text == null)
			{
				CheckError(!input.AttributeExists(1, "name"), "Xslt_BothMatchNameAbsent");
				CheckError(input.AttributeExists(3, "mode"), "Xslt_ModeWithoutMatch");
				mode = nullMode;
				if (input.AttributeExists(2, "priority"))
				{
					if (V1)
					{
						ReportWarning("Xslt_PriorityWithoutMatch");
					}
					else
					{
						ReportError("Xslt_PriorityWithoutMatch");
					}
				}
			}
			if (input.MoveToXsltAttribute(4, "as"))
			{
				ReportNYI("xsl:template/@as");
			}
			curTemplate = AstFactory.Template(name, text, mode, num, input.XslVersion);
			input.CanHaveApplyImports = text != null;
			SetInfo(curTemplate, LoadEndTag(LoadInstructions(InstructionFlags.AllowParam)), attributes);
			if (!curStylesheet.AddTemplate(curTemplate))
			{
				ReportError("Xslt_DupTemplateName", curTemplate.Name.QualifiedName);
			}
			curTemplate = null;
		}

		private void LoadMsScript(NsDecl stylesheetNsList)
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(scriptAttributes);
			attributes.nsList = MergeNamespaces(attributes.nsList, stylesheetNsList);
			string text = null;
			if (input.MoveToXsltAttribute(0, "implements-prefix"))
			{
				if (input.Value.Length == 0)
				{
					ReportError("Xslt_EmptyAttrValue", "implements-prefix", input.Value);
				}
				else
				{
					text = input.LookupXmlNamespace(input.Value);
					if (text == "http://www.w3.org/1999/XSL/Transform")
					{
						ReportError("Xslt_ScriptXsltNamespace");
						text = null;
					}
				}
			}
			if (text == null)
			{
				text = compiler.CreatePhantomNamespace();
			}
			string text2 = ParseStringAttribute(1, "language");
			if (text2 == null)
			{
				text2 = "jscript";
			}
			if (!compiler.Settings.EnableScript)
			{
				compiler.Scripts.ScriptClasses[text] = null;
				input.SkipNode();
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			string uri = input.Uri;
			int lineNumber = 0;
			int num = 0;
			ScriptClass scriptClass = compiler.Scripts.GetScriptClass(text, text2, this);
			if (scriptClass == null)
			{
				input.SkipNode();
				return;
			}
			XsltInput.DelayedQName elementName = input.ElementName;
			if (input.MoveToFirstChild())
			{
				do
				{
					XmlNodeType nodeType = input.NodeType;
					if (nodeType != XmlNodeType.Element)
					{
						if (nodeType == XmlNodeType.Text || stringBuilder.Length != 0)
						{
							int line = input.Start.Line;
							int line2 = input.End.Line;
							if (stringBuilder.Length == 0)
							{
								lineNumber = line;
							}
							else if (num < line)
							{
								stringBuilder.Append('\n', line - num);
							}
							stringBuilder.Append(input.Value);
							num = line2;
						}
					}
					else if (input.IsNs(atoms.UrnMsxsl) && (input.IsKeyword(atoms.Assembly) || input.IsKeyword(atoms.Using)))
					{
						if (stringBuilder.Length != 0)
						{
							ReportError("Xslt_ScriptNotAtTop", input.QualifiedName);
							input.SkipNode();
						}
						else if (input.IsKeyword(atoms.Assembly))
						{
							LoadMsAssembly(scriptClass);
						}
						else if (input.IsKeyword(atoms.Using))
						{
							LoadMsUsing(scriptClass);
						}
					}
					else
					{
						ReportError("Xslt_UnexpectedElement", input.QualifiedName, elementName);
						input.SkipNode();
					}
				}
				while (input.MoveToNextSibling());
			}
			if (stringBuilder.Length == 0)
			{
				lineNumber = input.Start.Line;
			}
			scriptClass.AddScriptBlock(stringBuilder.ToString(), uri, lineNumber, input.Start);
		}

		private void LoadMsAssembly(ScriptClass scriptClass)
		{
			input.GetAttributes(assemblyAttributes);
			string text = ParseStringAttribute(0, "name");
			string text2 = ParseStringAttribute(1, "href");
			if (text != null == (text2 != null))
			{
				ReportError("Xslt_AssemblyNameHref");
			}
			else
			{
				string text3 = null;
				if (text != null)
				{
					try
					{
						text3 = Assembly.Load(text).Location;
					}
					catch
					{
						AssemblyName assemblyName = new AssemblyName(text);
						byte[] publicKeyToken = assemblyName.GetPublicKeyToken();
						if ((publicKeyToken != null && publicKeyToken.Length != 0) || !(assemblyName.Version == null))
						{
							throw;
						}
						text3 = assemblyName.Name + ".dll";
					}
				}
				else
				{
					text3 = Assembly.LoadFrom(ResolveUri(text2, input.BaseUri).ToString()).Location;
					scriptClass.refAssembliesByHref = true;
				}
				if (text3 != null)
				{
					scriptClass.refAssemblies.Add(text3);
				}
			}
			CheckNoContent();
		}

		private void LoadMsUsing(ScriptClass scriptClass)
		{
			input.GetAttributes(usingAttributes);
			if (input.MoveToXsltAttribute(0, "namespace"))
			{
				scriptClass.nsImports.Add(input.Value);
			}
			CheckNoContent();
		}

		private List<XslNode> LoadInstructions()
		{
			return LoadInstructions(new List<XslNode>(), InstructionFlags.None);
		}

		private List<XslNode> LoadInstructions(InstructionFlags flags)
		{
			return LoadInstructions(new List<XslNode>(), flags);
		}

		private List<XslNode> LoadInstructions(List<XslNode> content)
		{
			return LoadInstructions(content, InstructionFlags.None);
		}

		private List<XslNode> LoadInstructions(List<XslNode> content, InstructionFlags flags)
		{
			if (++loadInstructionsDepth > 1024 && XsltConfigSection.LimitXPathComplexity)
			{
				throw XsltException.Create("Xslt_InputTooComplex");
			}
			XsltInput.DelayedQName elementName = input.ElementName;
			if (input.MoveToFirstChild())
			{
				bool flag = true;
				int num = 0;
				do
				{
					XmlNodeType nodeType = input.NodeType;
					XslNode instruction;
					if (nodeType != XmlNodeType.Element)
					{
						if (nodeType == XmlNodeType.Whitespace)
						{
							continue;
						}
						if (nodeType != XmlNodeType.SignificantWhitespace)
						{
							flag = false;
						}
						instruction = SetLineInfo(AstFactory.Text(input.Value), input.BuildLineInfo());
					}
					else
					{
						string namespaceUri = input.NamespaceUri;
						string localName = input.LocalName;
						if (namespaceUri == atoms.UriXsl)
						{
							InstructionFlags instructionFlags = (Ref.Equal(localName, atoms.Param) ? InstructionFlags.AllowParam : (Ref.Equal(localName, atoms.Sort) ? InstructionFlags.AllowSort : InstructionFlags.None));
							if (instructionFlags != 0)
							{
								string text = (((flags & instructionFlags) == 0) ? "Xslt_UnexpectedElement" : ((!flag) ? "Xslt_NotAtTop" : null));
								if (text != null)
								{
									ReportError(text, input.QualifiedName, elementName);
									flag = false;
									input.SkipNode();
									continue;
								}
							}
							else
							{
								flag = false;
							}
							instruction = (Ref.Equal(localName, atoms.ApplyImports) ? XslApplyImports() : (Ref.Equal(localName, atoms.ApplyTemplates) ? XslApplyTemplates() : (Ref.Equal(localName, atoms.CallTemplate) ? XslCallTemplate() : (Ref.Equal(localName, atoms.Copy) ? XslCopy() : (Ref.Equal(localName, atoms.CopyOf) ? XslCopyOf() : (Ref.Equal(localName, atoms.Fallback) ? XslFallback() : (Ref.Equal(localName, atoms.If) ? XslIf() : (Ref.Equal(localName, atoms.Choose) ? XslChoose() : (Ref.Equal(localName, atoms.ForEach) ? XslForEach() : (Ref.Equal(localName, atoms.Message) ? XslMessage() : (Ref.Equal(localName, atoms.Number) ? XslNumber() : (Ref.Equal(localName, atoms.ValueOf) ? XslValueOf() : (Ref.Equal(localName, atoms.Comment) ? XslComment() : (Ref.Equal(localName, atoms.ProcessingInstruction) ? XslProcessingInstruction() : (Ref.Equal(localName, atoms.Text) ? XslText() : (Ref.Equal(localName, atoms.Element) ? XslElement() : (Ref.Equal(localName, atoms.Attribute) ? XslAttribute() : (Ref.Equal(localName, atoms.Variable) ? XslVarPar() : (Ref.Equal(localName, atoms.Param) ? XslVarPar() : (Ref.Equal(localName, atoms.Sort) ? XslSort(num++) : LoadUnknownXsltInstruction(elementName)))))))))))))))))))));
						}
						else
						{
							flag = false;
							instruction = LoadLiteralResultElement(asStylesheet: false);
						}
					}
					AddInstruction(content, instruction);
				}
				while (input.MoveToNextSibling());
			}
			loadInstructionsDepth--;
			return content;
		}

		private List<XslNode> LoadWithParams(InstructionFlags flags)
		{
			XsltInput.DelayedQName elementName = input.ElementName;
			List<XslNode> list = new List<XslNode>();
			if (input.MoveToFirstChild())
			{
				int num = 0;
				do
				{
					switch (input.NodeType)
					{
					case XmlNodeType.Element:
						if (input.IsXsltKeyword(atoms.WithParam))
						{
							XslNode xslNode = XslVarPar();
							CheckWithParam(list, xslNode);
							AddInstruction(list, xslNode);
						}
						else if (flags == InstructionFlags.AllowSort && input.IsXsltKeyword(atoms.Sort))
						{
							AddInstruction(list, XslSort(num++));
						}
						else if (flags == InstructionFlags.AllowFallback && input.IsXsltKeyword(atoms.Fallback))
						{
							XslFallback();
						}
						else
						{
							ReportError("Xslt_UnexpectedElement", input.QualifiedName, elementName);
							input.SkipNode();
						}
						break;
					default:
						ReportError("Xslt_TextNodesNotAllowed", elementName);
						break;
					case XmlNodeType.Whitespace:
					case XmlNodeType.SignificantWhitespace:
						break;
					}
				}
				while (input.MoveToNextSibling());
			}
			return list;
		}

		private XslNode XslApplyImports()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes();
			if (!input.CanHaveApplyImports)
			{
				ReportError("Xslt_InvalidApplyImports");
				input.SkipNode();
				return null;
			}
			List<XslNode> list = LoadWithParams(InstructionFlags.None);
			attributes.SaveExtendedLineInfo(input);
			if (V1)
			{
				if (list.Count != 0)
				{
					ISourceLineInfo sourceLine = list[0].SourceLine;
					if (input.ForwardCompatibility)
					{
						return SetInfo(AstFactory.Error(XslLoadException.CreateMessage(sourceLine, "Xslt_NotEmptyContents", atoms.ApplyImports)), null, attributes);
					}
					compiler.ReportError(sourceLine, "Xslt_NotEmptyContents", atoms.ApplyImports);
				}
				list = null;
			}
			else
			{
				if (list.Count != 0)
				{
					ReportNYI("xsl:apply-imports/xsl:with-param");
				}
				list = null;
			}
			return SetInfo(AstFactory.ApplyImports(curTemplate.Mode, curStylesheet, input.XslVersion), list, attributes);
		}

		private XslNode XslApplyTemplates()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(applyTemplatesAttributes);
			string text = ParseStringAttribute(0, "select");
			if (text == null)
			{
				text = "node()";
			}
			QilName mode = ParseModeAttribute(1);
			List<XslNode> content = LoadWithParams(InstructionFlags.AllowSort);
			attributes.SaveExtendedLineInfo(input);
			return SetInfo(AstFactory.ApplyTemplates(mode, text, attributes, input.XslVersion), content, attributes);
		}

		private XslNode XslCallTemplate()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(callTemplateAttributes);
			QilName name = ParseQNameAttribute(0);
			List<XslNode> content = LoadWithParams(InstructionFlags.None);
			attributes.SaveExtendedLineInfo(input);
			return SetInfo(AstFactory.CallTemplate(name, attributes), content, attributes);
		}

		private XslNode XslCopy()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(copyAttributes);
			bool flag = ParseYesNoAttribute(0, "copy-namespaces") != TriState.False;
			bool flag2 = ParseYesNoAttribute(1, "inherit-namespaces") != TriState.False;
			if (!flag)
			{
				ReportNYI("xsl:copy[@copy-namespaces    = 'no']");
			}
			if (!flag2)
			{
				ReportNYI("xsl:copy[@inherit-namespaces = 'no']");
			}
			List<XslNode> list = new List<XslNode>();
			if (input.MoveToXsltAttribute(2, "use-attribute-sets"))
			{
				AddUseAttributeSets(list);
			}
			ParseTypeAttribute(3);
			ParseValidationAttribute(4, defVal: false);
			return SetInfo(AstFactory.Copy(), LoadEndTag(LoadInstructions(list)), attributes);
		}

		private XslNode XslCopyOf()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(copyOfAttributes);
			string select = ParseStringAttribute(0, "select");
			if (ParseYesNoAttribute(1, "copy-namespaces") == TriState.False)
			{
				ReportNYI("xsl:copy-of[@copy-namespaces    = 'no']");
			}
			ParseTypeAttribute(2);
			ParseValidationAttribute(3, defVal: false);
			CheckNoContent();
			return SetInfo(AstFactory.CopyOf(select, input.XslVersion), null, attributes);
		}

		private XslNode XslFallback()
		{
			input.GetAttributes();
			input.SkipNode();
			return null;
		}

		private XslNode XslIf()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(ifAttributes);
			string test = ParseStringAttribute(0, "test");
			return SetInfo(AstFactory.If(test, input.XslVersion), LoadInstructions(), attributes);
		}

		private XslNode XslChoose()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes();
			List<XslNode> content = new List<XslNode>();
			bool flag = false;
			bool flag2 = false;
			XsltInput.DelayedQName elementName = input.ElementName;
			if (input.MoveToFirstChild())
			{
				do
				{
					switch (input.NodeType)
					{
					case XmlNodeType.Element:
					{
						XslNode xslNode = null;
						if (Ref.Equal(input.NamespaceUri, atoms.UriXsl))
						{
							if (Ref.Equal(input.LocalName, atoms.When))
							{
								if (flag)
								{
									ReportError("Xslt_WhenAfterOtherwise");
									input.SkipNode();
									break;
								}
								flag2 = true;
								xslNode = XslIf();
							}
							else if (Ref.Equal(input.LocalName, atoms.Otherwise))
							{
								if (flag)
								{
									ReportError("Xslt_DupOtherwise");
									input.SkipNode();
									break;
								}
								flag = true;
								xslNode = XslOtherwise();
							}
						}
						if (xslNode == null)
						{
							ReportError("Xslt_UnexpectedElement", input.QualifiedName, elementName);
							input.SkipNode();
						}
						else
						{
							AddInstruction(content, xslNode);
						}
						break;
					}
					default:
						ReportError("Xslt_TextNodesNotAllowed", elementName);
						break;
					case XmlNodeType.Whitespace:
					case XmlNodeType.SignificantWhitespace:
						break;
					}
				}
				while (input.MoveToNextSibling());
			}
			CheckError(!flag2, "Xslt_NoWhen");
			return SetInfo(AstFactory.Choose(), content, attributes);
		}

		private XslNode XslOtherwise()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes();
			return SetInfo(AstFactory.Otherwise(), LoadInstructions(), attributes);
		}

		private XslNode XslForEach()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(forEachAttributes);
			string select = ParseStringAttribute(0, "select");
			input.CanHaveApplyImports = false;
			List<XslNode> content = LoadInstructions(InstructionFlags.AllowSort);
			attributes.SaveExtendedLineInfo(input);
			return SetInfo(AstFactory.ForEach(select, attributes, input.XslVersion), content, attributes);
		}

		private XslNode XslMessage()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(messageAttributes);
			string text = ParseStringAttribute(0, "select");
			bool term = ParseYesNoAttribute(1, "terminate") == TriState.True;
			List<XslNode> list = LoadInstructions();
			if (list.Count != 0)
			{
				list = LoadEndTag(list);
			}
			if (text != null)
			{
				list.Insert(0, AstFactory.CopyOf(text, input.XslVersion));
			}
			return SetInfo(AstFactory.Message(term), list, attributes);
		}

		private XslNode XslNumber()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(numberAttributes);
			string value = ParseStringAttribute(0, "value");
			string text = ParseStringAttribute(1, "select");
			if (text != null)
			{
				ReportNYI("xsl:number/@select");
			}
			NumberLevel level = NumberLevel.Single;
			if (input.MoveToXsltAttribute(2, "level"))
			{
				switch (input.Value)
				{
				case "single":
					level = NumberLevel.Single;
					break;
				case "multiple":
					level = NumberLevel.Multiple;
					break;
				case "any":
					level = NumberLevel.Any;
					break;
				default:
					if (!input.ForwardCompatibility)
					{
						ReportError("Xslt_InvalidAttrValue", "level", input.Value);
					}
					break;
				}
			}
			string count = ParseStringAttribute(3, "count");
			string from = ParseStringAttribute(4, "from");
			string text2 = ParseStringAttribute(5, "format");
			string lang = ParseStringAttribute(6, "lang");
			string letterValue = ParseStringAttribute(7, "letter-value");
			string value2 = ParseStringAttribute(8, "ordinal");
			if (!string.IsNullOrEmpty(value2))
			{
				ReportNYI("xsl:number/@ordinal");
			}
			string groupingSeparator = ParseStringAttribute(9, "grouping-separator");
			string groupingSize = ParseStringAttribute(10, "grouping-size");
			if (text2 == null)
			{
				text2 = "1";
			}
			CheckNoContent();
			return SetInfo(AstFactory.Number(level, count, from, value, text2, lang, letterValue, groupingSeparator, groupingSize, input.XslVersion), null, attributes);
		}

		private XslNode XslValueOf()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(valueOfAttributes);
			string text = ParseStringAttribute(0, "select");
			string text2 = ParseStringAttribute(1, "separator");
			bool flag = ParseYesNoAttribute(2, "disable-output-escaping") == TriState.True;
			if (text2 == null)
			{
				if (!input.BackwardCompatibility)
				{
					text2 = ((text != null) ? " " : string.Empty);
				}
			}
			else
			{
				ReportNYI("xsl:value-of/@separator");
			}
			List<XslNode> list = null;
			if (V1)
			{
				if (text == null)
				{
					input.SkipNode();
					return SetInfo(AstFactory.Error(XslLoadException.CreateMessage(attributes.lineInfo, "Xslt_MissingAttribute", "select")), null, attributes);
				}
				CheckNoContent();
			}
			else
			{
				list = LoadContent(text != null);
				CheckError(text == null && list.Count == 0, "Xslt_NoSelectNoContent", input.ElementName);
				if (list.Count != 0)
				{
					ReportNYI("xsl:value-of/*");
					list = null;
				}
			}
			return SetInfo(AstFactory.XslNode(flag ? XslNodeType.ValueOfDoe : XslNodeType.ValueOf, null, text, input.XslVersion), null, attributes);
		}

		private VarPar XslVarPar()
		{
			string localName = input.LocalName;
			XslNodeType xslNodeType = (Ref.Equal(localName, atoms.Variable) ? XslNodeType.Variable : (Ref.Equal(localName, atoms.Param) ? XslNodeType.Param : (Ref.Equal(localName, atoms.WithParam) ? XslNodeType.WithParam : XslNodeType.Unknown)));
			bool flag = Ref.Equal(localName, atoms.Param);
			XsltInput.ContextInfo attributes = input.GetAttributes(xslNodeType switch
			{
				XslNodeType.Param => paramAttributes, 
				XslNodeType.Variable => variableAttributes, 
				_ => withParamAttributes, 
			});
			QilName qilName = ParseQNameAttribute(0);
			string text = ParseStringAttribute(1, "select");
			string text2 = ParseStringAttribute(2, "as");
			TriState triState = ParseYesNoAttribute(3, "required");
			if (xslNodeType == XslNodeType.Param && curFunction != null)
			{
				if (!input.ForwardCompatibility)
				{
					CheckError(triState != TriState.Unknown, "Xslt_RequiredOnFunction", qilName.ToString());
				}
				triState = TriState.True;
			}
			else if (triState == TriState.True)
			{
				ReportNYI("xsl:param/@required == true()");
			}
			if (text2 != null)
			{
				ReportNYI("xsl:param/@as");
			}
			TriState triState2 = ParseYesNoAttribute(4, "tunnel");
			if (triState2 != TriState.Unknown)
			{
				if (xslNodeType == XslNodeType.Param && curTemplate == null)
				{
					if (!input.ForwardCompatibility)
					{
						ReportError("Xslt_NonTemplateTunnel", qilName.ToString());
					}
				}
				else if (triState2 == TriState.True)
				{
					ReportNYI("xsl:param/@tunnel == true()");
				}
			}
			List<XslNode> list = LoadContent(text != null);
			CheckError(triState == TriState.True && (text != null || list.Count != 0), "Xslt_RequiredAndSelect", qilName.ToString());
			VarPar varPar = AstFactory.VarPar(xslNodeType, qilName, text, input.XslVersion);
			SetInfo(varPar, list, attributes);
			return varPar;
		}

		private XslNode XslComment()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(commentAttributes);
			string text = ParseStringAttribute(0, "select");
			if (text != null)
			{
				ReportNYI("xsl:comment/@select");
			}
			return SetInfo(AstFactory.Comment(), LoadContent(text != null), attributes);
		}

		private List<XslNode> LoadContent(bool hasSelect)
		{
			XsltInput.DelayedQName elementName = input.ElementName;
			List<XslNode> list = LoadInstructions();
			CheckError(hasSelect && list.Count != 0, "Xslt_ElementCntSel", elementName);
			if (list.Count != 0)
			{
				list = LoadEndTag(list);
			}
			return list;
		}

		private XslNode XslProcessingInstruction()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(processingInstructionAttributes);
			string name = ParseNCNameAttribute(0);
			string text = ParseStringAttribute(1, "select");
			if (text != null)
			{
				ReportNYI("xsl:processing-instruction/@select");
			}
			return SetInfo(AstFactory.PI(name, input.XslVersion), LoadContent(text != null), attributes);
		}

		private XslNode XslText()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(textAttributes);
			SerializationHints hints = ((ParseYesNoAttribute(0, "disable-output-escaping") == TriState.True) ? SerializationHints.DisableOutputEscaping : SerializationHints.None);
			List<XslNode> list = new List<XslNode>();
			XsltInput.DelayedQName elementName = input.ElementName;
			if (input.MoveToFirstChild())
			{
				do
				{
					XmlNodeType nodeType = input.NodeType;
					if (nodeType == XmlNodeType.Text || (uint)(nodeType - 13) <= 1u)
					{
						list.Add(AstFactory.Text(input.Value, hints));
						continue;
					}
					ReportError("Xslt_UnexpectedElement", input.QualifiedName, elementName);
					input.SkipNode();
				}
				while (input.MoveToNextSibling());
			}
			return SetInfo(AstFactory.List(), list, attributes);
		}

		private XslNode XslElement()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(elementAttributes);
			string nameAvt = ParseNCNameAttribute(0);
			string text = ParseStringAttribute(1, "namespace");
			CheckError(text == "http://www.w3.org/2000/xmlns/", "Xslt_ReservedNS", text);
			if (ParseYesNoAttribute(2, "inherit-namespaces") == TriState.False)
			{
				ReportNYI("xsl:copy[@inherit-namespaces = 'no']");
			}
			ParseTypeAttribute(4);
			ParseValidationAttribute(5, defVal: false);
			List<XslNode> list = new List<XslNode>();
			if (input.MoveToXsltAttribute(3, "use-attribute-sets"))
			{
				AddUseAttributeSets(list);
			}
			return SetInfo(AstFactory.Element(nameAvt, text, input.XslVersion), LoadEndTag(LoadInstructions(list)), attributes);
		}

		private XslNode XslAttribute()
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(attributeAttributes);
			string nameAvt = ParseNCNameAttribute(0);
			string text = ParseStringAttribute(1, "namespace");
			CheckError(text == "http://www.w3.org/2000/xmlns/", "Xslt_ReservedNS", text);
			string text2 = ParseStringAttribute(2, "select");
			if (text2 != null)
			{
				ReportNYI("xsl:attribute/@select");
			}
			string text3 = ParseStringAttribute(3, "separator");
			if (text3 != null)
			{
				ReportNYI("xsl:attribute/@separator");
			}
			text3 = ((text3 != null) ? text3 : ((text2 != null) ? " " : string.Empty));
			ParseTypeAttribute(4);
			ParseValidationAttribute(5, defVal: false);
			return SetInfo(AstFactory.Attribute(nameAvt, text, input.XslVersion), LoadContent(text2 != null), attributes);
		}

		private XslNode XslSort(int sortNumber)
		{
			XsltInput.ContextInfo attributes = input.GetAttributes(sortAttributes);
			string text = ParseStringAttribute(0, "select");
			string lang = ParseStringAttribute(1, "lang");
			string order = ParseStringAttribute(2, "order");
			string text2 = ParseCollationAttribute(3);
			TriState triState = ParseYesNoAttribute(4, "stable");
			string caseOrder = ParseStringAttribute(5, "case-order");
			string dataType = ParseStringAttribute(6, "data-type");
			if (triState != TriState.Unknown)
			{
				CheckError(sortNumber != 0, "Xslt_SortStable");
			}
			List<XslNode> list = null;
			if (V1)
			{
				CheckNoContent();
			}
			else
			{
				list = LoadContent(text != null);
				if (list.Count != 0)
				{
					ReportNYI("xsl:sort/*");
					list = null;
				}
			}
			if (text == null)
			{
				text = ".";
			}
			return SetInfo(AstFactory.Sort(text, lang, dataType, order, caseOrder, input.XslVersion), null, attributes);
		}

		private XslNode LoadLiteralResultElement(bool asStylesheet)
		{
			string prefix = input.Prefix;
			string localName = input.LocalName;
			string namespaceUri = input.NamespaceUri;
			XsltInput.ContextInfo literalAttributes = input.GetLiteralAttributes(asStylesheet);
			if (input.IsExtensionNamespace(namespaceUri))
			{
				return SetInfo(AstFactory.List(), LoadFallbacks(localName), literalAttributes);
			}
			List<XslNode> list = new List<XslNode>();
			for (int i = 1; input.MoveToLiteralAttribute(i); i++)
			{
				if (input.IsXsltNamespace() && input.IsKeyword(atoms.UseAttributeSets))
				{
					AddUseAttributeSets(list);
				}
			}
			for (int j = 1; input.MoveToLiteralAttribute(j); j++)
			{
				if (!input.IsXsltNamespace())
				{
					XslNode node = AstFactory.LiteralAttribute(AstFactory.QName(input.LocalName, input.NamespaceUri, input.Prefix), input.Value, input.XslVersion);
					AddInstruction(list, SetLineInfo(node, literalAttributes.lineInfo));
				}
			}
			list = LoadEndTag(LoadInstructions(list));
			return SetInfo(AstFactory.LiteralElement(AstFactory.QName(localName, namespaceUri, prefix)), list, literalAttributes);
		}

		private void CheckWithParam(List<XslNode> content, XslNode withParam)
		{
			foreach (XslNode item in content)
			{
				if (item.NodeType == XslNodeType.WithParam && item.Name.Equals(withParam.Name))
				{
					ReportError("Xslt_DuplicateWithParam", withParam.Name.QualifiedName);
					break;
				}
			}
		}

		private static void AddInstruction(List<XslNode> content, XslNode instruction)
		{
			if (instruction != null)
			{
				content.Add(instruction);
			}
		}

		private List<XslNode> LoadEndTag(List<XslNode> content)
		{
			if (compiler.IsDebug && !input.IsEmptyElement)
			{
				AddInstruction(content, SetLineInfo(AstFactory.Nop(), input.BuildLineInfo()));
			}
			return content;
		}

		private XslNode LoadUnknownXsltInstruction(string parentName)
		{
			input.GetVersionAttribute();
			if (!input.ForwardCompatibility)
			{
				ReportError("Xslt_UnexpectedElement", input.QualifiedName, parentName);
				input.SkipNode();
				return null;
			}
			XsltInput.ContextInfo attributes = input.GetAttributes();
			List<XslNode> content = LoadFallbacks(input.LocalName);
			return SetInfo(AstFactory.List(), content, attributes);
		}

		private List<XslNode> LoadFallbacks(string instrName)
		{
			input.MoveToElement();
			ISourceLineInfo lineInfo = input.BuildNameLineInfo();
			List<XslNode> list = new List<XslNode>();
			if (input.MoveToFirstChild())
			{
				do
				{
					if (input.IsXsltKeyword(atoms.Fallback))
					{
						XsltInput.ContextInfo attributes = input.GetAttributes();
						list.Add(SetInfo(AstFactory.List(), LoadInstructions(), attributes));
					}
					else
					{
						input.SkipNode();
					}
				}
				while (input.MoveToNextSibling());
			}
			if (list.Count == 0)
			{
				list.Add(AstFactory.Error(XslLoadException.CreateMessage(lineInfo, "Xslt_UnknownExtensionElement", instrName)));
			}
			return list;
		}

		private QilName ParseModeAttribute(int attNum)
		{
			if (!input.MoveToXsltAttribute(attNum, "mode"))
			{
				return nullMode;
			}
			compiler.EnterForwardsCompatible();
			string value = input.Value;
			QilName result;
			if (!V1 && value == "#default")
			{
				result = nullMode;
			}
			else if (!V1 && value == "#current")
			{
				ReportNYI("xsl:apply-templates[@mode='#current']");
				result = nullMode;
			}
			else if (!V1 && value == "#all")
			{
				ReportError("Xslt_ModeListAll");
				result = nullMode;
			}
			else
			{
				result = CreateXPathQName(value);
			}
			if (!compiler.ExitForwardsCompatible(input.ForwardCompatibility))
			{
				result = nullMode;
			}
			return result;
		}

		private QilName ParseModeListAttribute(int attNum)
		{
			if (!input.MoveToXsltAttribute(attNum, "mode"))
			{
				return nullMode;
			}
			string value = input.Value;
			if (value == "#all")
			{
				ReportNYI("xsl:template[@mode='#all']");
				return nullMode;
			}
			string[] array = XmlConvert.SplitString(value);
			List<QilName> list = new List<QilName>(array.Length);
			compiler.EnterForwardsCompatible();
			if (array.Length == 0)
			{
				ReportError("Xslt_ModeListEmpty");
			}
			else
			{
				string[] array2 = array;
				foreach (string text in array2)
				{
					QilName qilName;
					bool flag;
					switch (text)
					{
					case "#default":
						qilName = nullMode;
						goto IL_00e8;
					case "#current":
						ReportNYI("xsl:apply-templates[@mode='#current']");
						break;
					case "#all":
						ReportError("Xslt_ModeListAll");
						break;
					default:
						{
							qilName = CreateXPathQName(text);
							goto IL_00e8;
						}
						IL_00e8:
						flag = false;
						foreach (QilName item in list)
						{
							flag |= item.Equals(qilName);
						}
						if (flag)
						{
							ReportError("Xslt_ModeListDup", text);
						}
						else
						{
							list.Add(qilName);
						}
						continue;
					}
					break;
				}
			}
			if (!compiler.ExitForwardsCompatible(input.ForwardCompatibility))
			{
				list.Clear();
				list.Add(nullMode);
			}
			if (1 < list.Count)
			{
				ReportNYI("Multipe modes");
				return nullMode;
			}
			if (list.Count == 0)
			{
				return nullMode;
			}
			return list[0];
		}

		private string ParseCollationAttribute(int attNum)
		{
			if (input.MoveToXsltAttribute(attNum, "collation"))
			{
				ReportNYI("@collation");
			}
			return null;
		}

		private bool ResolveQName(bool ignoreDefaultNs, string qname, out string localName, out string namespaceName, out string prefix)
		{
			if (qname == null)
			{
				prefix = compiler.PhantomNCName;
				localName = compiler.PhantomNCName;
				namespaceName = compiler.CreatePhantomNamespace();
				return false;
			}
			if (!compiler.ParseQName(qname, out prefix, out localName, this))
			{
				namespaceName = compiler.CreatePhantomNamespace();
				return false;
			}
			if (ignoreDefaultNs && prefix.Length == 0)
			{
				namespaceName = string.Empty;
			}
			else
			{
				namespaceName = input.LookupXmlNamespace(prefix);
				if (namespaceName == null)
				{
					namespaceName = compiler.CreatePhantomNamespace();
					return false;
				}
			}
			return true;
		}

		private QilName ParseQNameAttribute(int attNum)
		{
			bool flag = input.IsRequiredAttribute(attNum);
			QilName qilName = null;
			if (!flag)
			{
				compiler.EnterForwardsCompatible();
			}
			if (input.MoveToXsltAttribute(attNum, "name") && ResolveQName(ignoreDefaultNs: true, input.Value, out var localName, out var namespaceName, out var prefix))
			{
				qilName = AstFactory.QName(localName, namespaceName, prefix);
			}
			if (!flag)
			{
				compiler.ExitForwardsCompatible(input.ForwardCompatibility);
			}
			if (qilName == null && flag)
			{
				qilName = AstFactory.QName(compiler.PhantomNCName, compiler.CreatePhantomNamespace(), compiler.PhantomNCName);
			}
			return qilName;
		}

		private string ParseNCNameAttribute(int attNum)
		{
			if (input.MoveToXsltAttribute(attNum, "name"))
			{
				return input.Value;
			}
			return compiler.PhantomNCName;
		}

		private QilName CreateXPathQName(string qname)
		{
			ResolveQName(ignoreDefaultNs: true, qname, out var localName, out var namespaceName, out var prefix);
			return AstFactory.QName(localName, namespaceName, prefix);
		}

		private XmlQualifiedName ResolveQName(bool ignoreDefaultNs, string qname)
		{
			ResolveQName(ignoreDefaultNs, qname, out var localName, out var namespaceName, out var _);
			return new XmlQualifiedName(localName, namespaceName);
		}

		private void ParseWhitespaceRules(string elements, bool preserveSpace)
		{
			if (elements == null || elements.Length == 0)
			{
				return;
			}
			string[] array = XmlConvert.SplitString(elements);
			for (int i = 0; i < array.Length; i++)
			{
				string text;
				if (!compiler.ParseNameTest(array[i], out var prefix, out var localName, this))
				{
					text = compiler.CreatePhantomNamespace();
				}
				else if (prefix == null || prefix.Length == 0)
				{
					text = prefix;
				}
				else
				{
					text = input.LookupXmlNamespace(prefix);
					if (text == null)
					{
						text = compiler.CreatePhantomNamespace();
					}
				}
				int index = ((localName == null) ? 1 : 0) + ((text == null) ? 1 : 0);
				curStylesheet.AddWhitespaceRule(index, new WhitespaceRule(localName, text, preserveSpace));
			}
		}

		private XmlQualifiedName ParseOutputMethod(string attValue, out XmlOutputMethod method)
		{
			ResolveQName(ignoreDefaultNs: true, attValue, out var localName, out var namespaceName, out var prefix);
			method = XmlOutputMethod.AutoDetect;
			if (compiler.IsPhantomNamespace(namespaceName))
			{
				return null;
			}
			if (prefix.Length == 0)
			{
				switch (localName)
				{
				case "xml":
					method = XmlOutputMethod.Xml;
					break;
				case "html":
					method = XmlOutputMethod.Html;
					break;
				case "text":
					method = XmlOutputMethod.Text;
					break;
				default:
					ReportError("Xslt_InvalidAttrValue", "method", attValue);
					return null;
				}
			}
			else if (!input.ForwardCompatibility)
			{
				ReportWarning("Xslt_InvalidMethod", attValue);
			}
			return new XmlQualifiedName(localName, namespaceName);
		}

		private void AddUseAttributeSets(List<XslNode> list)
		{
			compiler.EnterForwardsCompatible();
			string[] array = XmlConvert.SplitString(input.Value);
			foreach (string qname in array)
			{
				AddInstruction(list, SetLineInfo(AstFactory.UseAttributeSet(CreateXPathQName(qname)), input.BuildLineInfo()));
			}
			if (!compiler.ExitForwardsCompatible(input.ForwardCompatibility))
			{
				list.Clear();
			}
		}

		private List<QilName> ParseUseCharacterMaps(int attNum)
		{
			List<QilName> list = new List<QilName>();
			if (input.MoveToXsltAttribute(attNum, "use-character-maps"))
			{
				compiler.EnterForwardsCompatible();
				string[] array = XmlConvert.SplitString(input.Value);
				foreach (string qname in array)
				{
					list.Add(CreateXPathQName(qname));
				}
				if (!compiler.ExitForwardsCompatible(input.ForwardCompatibility))
				{
					list.Clear();
				}
			}
			return list;
		}

		private string ParseStringAttribute(int attNum, string attName)
		{
			if (input.MoveToXsltAttribute(attNum, attName))
			{
				return input.Value;
			}
			return null;
		}

		private char ParseCharAttribute(int attNum, string attName, char defVal)
		{
			if (input.MoveToXsltAttribute(attNum, attName))
			{
				if (input.Value.Length == 1)
				{
					return input.Value[0];
				}
				if (input.IsRequiredAttribute(attNum) || !input.ForwardCompatibility)
				{
					ReportError("Xslt_CharAttribute", attName);
				}
			}
			return defVal;
		}

		private TriState ParseYesNoAttribute(int attNum, string attName)
		{
			if (input.MoveToXsltAttribute(attNum, attName))
			{
				string value = input.Value;
				if (value == "yes")
				{
					return TriState.True;
				}
				if (value == "no")
				{
					return TriState.False;
				}
				if (!input.ForwardCompatibility)
				{
					ReportError("Xslt_BistateAttribute", attName, "yes", "no");
				}
			}
			return TriState.Unknown;
		}

		private void ParseTypeAttribute(int attNum)
		{
			if (input.MoveToXsltAttribute(attNum, "type"))
			{
				CheckError(true, "Xslt_SchemaAttribute", "type");
			}
		}

		private void ParseValidationAttribute(int attNum, bool defVal)
		{
			string text = (defVal ? atoms.DefaultValidation : "validation");
			if (!input.MoveToXsltAttribute(attNum, text))
			{
				return;
			}
			string value = input.Value;
			switch (value)
			{
			case "strict":
				if (defVal)
				{
					goto default;
				}
				goto case "preserve";
			default:
				if (!(value == "lax") || defVal)
				{
					break;
				}
				goto case "preserve";
			case "preserve":
				ReportError("Xslt_SchemaAttributeValue", text, value);
				return;
			}
			if (!input.ForwardCompatibility)
			{
				ReportError("Xslt_InvalidAttrValue", text, value);
			}
		}

		private void ParseInputTypeAnnotationsAttribute(int attNum)
		{
			if (!input.MoveToXsltAttribute(attNum, "input-type-annotations"))
			{
				return;
			}
			string value = input.Value;
			switch (value)
			{
			case "strip":
			case "preserve":
				if (compiler.inputTypeAnnotations == null)
				{
					compiler.inputTypeAnnotations = value;
				}
				else
				{
					CheckError(compiler.inputTypeAnnotations != value, "Xslt_InputTypeAnnotations");
				}
				return;
			}
			if (!input.ForwardCompatibility)
			{
				ReportError("Xslt_InvalidAttrValue", "input-type-annotations", value);
			}
		}

		private void CheckNoContent()
		{
			input.MoveToElement();
			XsltInput.DelayedQName elementName = input.ElementName;
			ISourceLineInfo sourceLineInfo = SkipEmptyContent();
			if (sourceLineInfo != null)
			{
				compiler.ReportError(sourceLineInfo, "Xslt_NotEmptyContents", elementName);
			}
		}

		private ISourceLineInfo SkipEmptyContent()
		{
			ISourceLineInfo sourceLineInfo = null;
			if (input.MoveToFirstChild())
			{
				do
				{
					if (input.NodeType != XmlNodeType.Whitespace)
					{
						if (sourceLineInfo == null)
						{
							sourceLineInfo = input.BuildNameLineInfo();
						}
						input.SkipNode();
					}
				}
				while (input.MoveToNextSibling());
			}
			return sourceLineInfo;
		}

		private static XslNode SetLineInfo(XslNode node, ISourceLineInfo lineInfo)
		{
			node.SourceLine = lineInfo;
			return node;
		}

		private static void SetContent(XslNode node, List<XslNode> content)
		{
			if (content != null && content.Count == 0)
			{
				content = null;
			}
			node.SetContent(content);
		}

		internal static XslNode SetInfo(XslNode to, List<XslNode> content, XsltInput.ContextInfo info)
		{
			to.Namespaces = info.nsList;
			SetContent(to, content);
			SetLineInfo(to, info.lineInfo);
			return to;
		}

		private static NsDecl MergeNamespaces(NsDecl thisList, NsDecl parentList)
		{
			if (parentList == null)
			{
				return thisList;
			}
			if (thisList == null)
			{
				return parentList;
			}
			while (parentList != null)
			{
				bool flag = false;
				for (NsDecl nsDecl = thisList; nsDecl != null; nsDecl = nsDecl.Prev)
				{
					if (Ref.Equal(nsDecl.Prefix, parentList.Prefix) && (nsDecl.Prefix != null || nsDecl.NsUri == parentList.NsUri))
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					thisList = new NsDecl(thisList, parentList.Prefix, parentList.NsUri);
				}
				parentList = parentList.Prev;
			}
			return thisList;
		}

		public void ReportError(string res, params string[] args)
		{
			compiler.ReportError(input.BuildNameLineInfo(), res, args);
		}

		public void ReportWarning(string res, params string[] args)
		{
			compiler.ReportWarning(input.BuildNameLineInfo(), res, args);
		}

		private void ReportNYI(string arg)
		{
			if (!input.ForwardCompatibility)
			{
				ReportError("Xslt_NotYetImplemented", arg);
			}
		}

		public void CheckError(bool cond, string res, params string[] args)
		{
			if (cond)
			{
				compiler.ReportError(input.BuildNameLineInfo(), res, args);
			}
		}
	}
	internal class XsltQilFactory : XPathQilFactory
	{
		public XsltQilFactory(QilFactory f, bool debug)
			: base(f, debug)
		{
		}

		[Conditional("DEBUG")]
		public void CheckXsltType(QilNode n)
		{
			XmlQueryType xmlType = n.XmlType;
			XmlTypeCode typeCode = xmlType.TypeCode;
			if (typeCode <= XmlTypeCode.Boolean)
			{
				if ((uint)typeCode > 1u)
				{
					_ = typeCode - 12;
					_ = 1;
				}
			}
			else if (typeCode != XmlTypeCode.Double)
			{
				_ = 29;
			}
		}

		[Conditional("DEBUG")]
		public void CheckQName(QilNode n)
		{
		}

		public QilNode DefaultValueMarker()
		{
			return QName("default-value", "urn:schemas-microsoft-com:xslt-debug");
		}

		public QilNode IsDefaultValueMarker(QilNode n)
		{
			return IsType(n, XmlQueryTypeFactory.QNameX);
		}

		public QilNode InvokeIsSameNodeSort(QilNode n1, QilNode n2)
		{
			return XsltInvokeEarlyBound(QName("is-same-node-sort"), XsltMethods.IsSameNodeSort, XmlQueryTypeFactory.BooleanX, new QilNode[2] { n1, n2 });
		}

		public QilNode InvokeSystemProperty(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("system-property"), XsltMethods.SystemProperty, XmlQueryTypeFactory.Choice(XmlQueryTypeFactory.DoubleX, XmlQueryTypeFactory.StringX), new QilNode[1] { n });
		}

		public QilNode InvokeElementAvailable(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("element-available"), XsltMethods.ElementAvailable, XmlQueryTypeFactory.BooleanX, new QilNode[1] { n });
		}

		public QilNode InvokeCheckScriptNamespace(string nsUri)
		{
			return XsltInvokeEarlyBound(QName("register-script-namespace"), XsltMethods.CheckScriptNamespace, XmlQueryTypeFactory.IntX, new QilNode[1] { String(nsUri) });
		}

		public QilNode InvokeFunctionAvailable(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("function-available"), XsltMethods.FunctionAvailable, XmlQueryTypeFactory.BooleanX, new QilNode[1] { n });
		}

		public QilNode InvokeBaseUri(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("base-uri"), XsltMethods.BaseUri, XmlQueryTypeFactory.StringX, new QilNode[1] { n });
		}

		public QilNode InvokeOnCurrentNodeChanged(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("on-current-node-changed"), XsltMethods.OnCurrentNodeChanged, XmlQueryTypeFactory.IntX, new QilNode[1] { n });
		}

		public QilNode InvokeLangToLcid(QilNode n, bool fwdCompat)
		{
			return XsltInvokeEarlyBound(QName("lang-to-lcid"), XsltMethods.LangToLcid, XmlQueryTypeFactory.IntX, new QilNode[2]
			{
				n,
				Boolean(fwdCompat)
			});
		}

		public QilNode InvokeNumberFormat(QilNode value, QilNode format, QilNode lang, QilNode letterValue, QilNode groupingSeparator, QilNode groupingSize)
		{
			return XsltInvokeEarlyBound(QName("number-format"), XsltMethods.NumberFormat, XmlQueryTypeFactory.StringX, new QilNode[6] { value, format, lang, letterValue, groupingSeparator, groupingSize });
		}

		public QilNode InvokeRegisterDecimalFormat(DecimalFormatDecl format)
		{
			return XsltInvokeEarlyBound(QName("register-decimal-format"), XsltMethods.RegisterDecimalFormat, XmlQueryTypeFactory.IntX, new QilNode[4]
			{
				QName(format.Name.Name, format.Name.Namespace),
				String(format.InfinitySymbol),
				String(format.NanSymbol),
				String(new string(format.Characters))
			});
		}

		public QilNode InvokeRegisterDecimalFormatter(QilNode formatPicture, DecimalFormatDecl format)
		{
			return XsltInvokeEarlyBound(QName("register-decimal-formatter"), XsltMethods.RegisterDecimalFormatter, XmlQueryTypeFactory.DoubleX, new QilNode[4]
			{
				formatPicture,
				String(format.InfinitySymbol),
				String(format.NanSymbol),
				String(new string(format.Characters))
			});
		}

		public QilNode InvokeFormatNumberStatic(QilNode value, QilNode decimalFormatIndex)
		{
			return XsltInvokeEarlyBound(QName("format-number-static"), XsltMethods.FormatNumberStatic, XmlQueryTypeFactory.StringX, new QilNode[2] { value, decimalFormatIndex });
		}

		public QilNode InvokeFormatNumberDynamic(QilNode value, QilNode formatPicture, QilNode decimalFormatName, QilNode errorMessageName)
		{
			return XsltInvokeEarlyBound(QName("format-number-dynamic"), XsltMethods.FormatNumberDynamic, XmlQueryTypeFactory.StringX, new QilNode[4] { value, formatPicture, decimalFormatName, errorMessageName });
		}

		public QilNode InvokeOuterXml(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("outer-xml"), XsltMethods.OuterXml, XmlQueryTypeFactory.StringX, new QilNode[1] { n });
		}

		public QilNode InvokeMsFormatDateTime(QilNode datetime, QilNode format, QilNode lang, QilNode isDate)
		{
			return XsltInvokeEarlyBound(QName("ms:format-date-time"), XsltMethods.MSFormatDateTime, XmlQueryTypeFactory.StringX, new QilNode[4] { datetime, format, lang, isDate });
		}

		public QilNode InvokeMsStringCompare(QilNode x, QilNode y, QilNode lang, QilNode options)
		{
			return XsltInvokeEarlyBound(QName("ms:string-compare"), XsltMethods.MSStringCompare, XmlQueryTypeFactory.DoubleX, new QilNode[4] { x, y, lang, options });
		}

		public QilNode InvokeMsUtc(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("ms:utc"), XsltMethods.MSUtc, XmlQueryTypeFactory.StringX, new QilNode[1] { n });
		}

		public QilNode InvokeMsNumber(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("ms:number"), XsltMethods.MSNumber, XmlQueryTypeFactory.DoubleX, new QilNode[1] { n });
		}

		public QilNode InvokeMsLocalName(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("ms:local-name"), XsltMethods.MSLocalName, XmlQueryTypeFactory.StringX, new QilNode[1] { n });
		}

		public QilNode InvokeMsNamespaceUri(QilNode n, QilNode currentNode)
		{
			return XsltInvokeEarlyBound(QName("ms:namespace-uri"), XsltMethods.MSNamespaceUri, XmlQueryTypeFactory.StringX, new QilNode[2] { n, currentNode });
		}

		public QilNode InvokeEXslObjectType(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("exsl:object-type"), XsltMethods.EXslObjectType, XmlQueryTypeFactory.StringX, new QilNode[1] { n });
		}
	}
	internal abstract class XslVisitor<T>
	{
		protected virtual T Visit(XslNode node)
		{
			return node.NodeType switch
			{
				XslNodeType.ApplyImports => VisitApplyImports(node), 
				XslNodeType.ApplyTemplates => VisitApplyTemplates(node), 
				XslNodeType.Attribute => VisitAttribute((NodeCtor)node), 
				XslNodeType.AttributeSet => VisitAttributeSet((AttributeSet)node), 
				XslNodeType.CallTemplate => VisitCallTemplate(node), 
				XslNodeType.Choose => VisitChoose(node), 
				XslNodeType.Comment => VisitComment(node), 
				XslNodeType.Copy => VisitCopy(node), 
				XslNodeType.CopyOf => VisitCopyOf(node), 
				XslNodeType.Element => VisitElement((NodeCtor)node), 
				XslNodeType.Error => VisitError(node), 
				XslNodeType.ForEach => VisitForEach(node), 
				XslNodeType.If => VisitIf(node), 
				XslNodeType.Key => VisitKey((Key)node), 
				XslNodeType.List => VisitList(node), 
				XslNodeType.LiteralAttribute => VisitLiteralAttribute(node), 
				XslNodeType.LiteralElement => VisitLiteralElement(node), 
				XslNodeType.Message => VisitMessage(node), 
				XslNodeType.Nop => VisitNop(node), 
				XslNodeType.Number => VisitNumber((Number)node), 
				XslNodeType.Otherwise => VisitOtherwise(node), 
				XslNodeType.Param => VisitParam((VarPar)node), 
				XslNodeType.PI => VisitPI(node), 
				XslNodeType.Sort => VisitSort((Sort)node), 
				XslNodeType.Template => VisitTemplate((Template)node), 
				XslNodeType.Text => VisitText((Text)node), 
				XslNodeType.UseAttributeSet => VisitUseAttributeSet(node), 
				XslNodeType.ValueOf => VisitValueOf(node), 
				XslNodeType.ValueOfDoe => VisitValueOfDoe(node), 
				XslNodeType.Variable => VisitVariable((VarPar)node), 
				XslNodeType.WithParam => VisitWithParam((VarPar)node), 
				_ => VisitUnknown(node), 
			};
		}

		protected virtual T VisitApplyImports(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitApplyTemplates(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitAttribute(NodeCtor node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitAttributeSet(AttributeSet node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitCallTemplate(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitChoose(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitComment(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitCopy(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitCopyOf(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitElement(NodeCtor node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitError(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitForEach(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitIf(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitKey(Key node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitList(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitLiteralAttribute(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitLiteralElement(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitMessage(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitNop(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitNumber(Number node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitOtherwise(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitParam(VarPar node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitPI(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitSort(Sort node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitTemplate(Template node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitText(Text node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitUseAttributeSet(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitValueOf(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitValueOfDoe(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitVariable(VarPar node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitWithParam(VarPar node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitUnknown(XslNode node)
		{
			return VisitChildren(node);
		}

		protected virtual T VisitChildren(XslNode node)
		{
			foreach (XslNode item in node.Content)
			{
				Visit(item);
			}
			return default(T);
		}
	}
}
namespace System.Xml.Xsl.XPath
{
	internal interface IXPathBuilder<Node>
	{
		void StartBuild();

		Node EndBuild(Node result);

		Node String(string value);

		Node Number(double value);

		Node Operator(XPathOperator op, Node left, Node right);

		Node Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name);

		Node JoinStep(Node left, Node right);

		Node Predicate(Node node, Node condition, bool reverseStep);

		Node Variable(string prefix, string name);

		Node Function(string prefix, string name, IList<Node> args);
	}
	internal interface IFocus
	{
		QilNode GetCurrent();

		QilNode GetPosition();

		QilNode GetLast();
	}
	internal interface IXPathEnvironment : IFocus
	{
		XPathQilFactory Factory { get; }

		QilNode ResolveVariable(string prefix, string name);

		QilNode ResolveFunction(string prefix, string name, IList<QilNode> args, IFocus env);

		string ResolvePrefix(string prefix);
	}
	internal enum XPathAxis
	{
		Unknown,
		Ancestor,
		AncestorOrSelf,
		Attribute,
		Child,
		Descendant,
		DescendantOrSelf,
		Following,
		FollowingSibling,
		Namespace,
		Parent,
		Preceding,
		PrecedingSibling,
		Self,
		Root
	}
	internal class XPathBuilder : IXPathBuilder<QilNode>, IXPathEnvironment, IFocus
	{
		private enum XPathOperatorGroup
		{
			Unknown,
			Logical,
			Equality,
			Relational,
			Arithmetic,
			Negate,
			Union
		}

		internal enum FuncId
		{
			Last,
			Position,
			Count,
			LocalName,
			NamespaceUri,
			Name,
			String,
			Number,
			Boolean,
			True,
			False,
			Not,
			Id,
			Concat,
			StartsWith,
			Contains,
			SubstringBefore,
			SubstringAfter,
			Substring,
			StringLength,
			Normalize,
			Translate,
			Lang,
			Sum,
			Floor,
			Ceiling,
			Round
		}

		internal class FixupVisitor : QilReplaceVisitor
		{
			private new QilPatternFactory f;

			private QilNode fixupCurrent;

			private QilNode fixupPosition;

			private QilNode fixupLast;

			private QilIterator current;

			private QilNode last;

			private bool justCount;

			private IXPathEnvironment environment;

			public int numCurrent;

			public int numPosition;

			public int numLast;

			public FixupVisitor(QilPatternFactory f, QilNode fixupCurrent, QilNode fixupPosition, QilNode fixupLast)
				: base(f.BaseFactory)
			{
				this.f = f;
				this.fixupCurrent = fixupCurrent;
				this.fixupPosition = fixupPosition;
				this.fixupLast = fixupLast;
			}

			public QilNode Fixup(QilNode inExpr, QilIterator current, QilNode last)
			{
				QilDepthChecker.Check(inExpr);
				this.current = current;
				this.last = last;
				justCount = false;
				environment = null;
				numCurrent = (numPosition = (numLast = 0));
				inExpr = VisitAssumeReference(inExpr);
				return inExpr;
			}

			public QilNode Fixup(QilNode inExpr, IXPathEnvironment environment)
			{
				QilDepthChecker.Check(inExpr);
				justCount = false;
				current = null;
				this.environment = environment;
				numCurrent = (numPosition = (numLast = 0));
				inExpr = VisitAssumeReference(inExpr);
				return inExpr;
			}

			public int CountUnfixedLast(QilNode inExpr)
			{
				justCount = true;
				numCurrent = (numPosition = (numLast = 0));
				VisitAssumeReference(inExpr);
				return numLast;
			}

			protected override QilNode VisitUnknown(QilNode unknown)
			{
				if (unknown == fixupCurrent)
				{
					numCurrent++;
					if (!justCount)
					{
						if (environment != null)
						{
							unknown = environment.GetCurrent();
						}
						else if (current != null)
						{
							unknown = current;
						}
					}
				}
				else if (unknown == fixupPosition)
				{
					numPosition++;
					if (!justCount)
					{
						if (environment != null)
						{
							unknown = environment.GetPosition();
						}
						else if (current != null)
						{
							unknown = f.XsltConvert(f.PositionOf(current), XmlQueryTypeFactory.DoubleX);
						}
					}
				}
				else if (unknown == fixupLast)
				{
					numLast++;
					if (!justCount)
					{
						if (environment != null)
						{
							unknown = environment.GetLast();
						}
						else if (current != null)
						{
							unknown = last;
						}
					}
				}
				return unknown;
			}
		}

		internal class FunctionInfo<T>
		{
			public T id;

			public int minArgs;

			public int maxArgs;

			public XmlTypeCode[] argTypes;

			public const int Infinity = int.MaxValue;

			public FunctionInfo(T id, int minArgs, int maxArgs, XmlTypeCode[] argTypes)
			{
				this.id = id;
				this.minArgs = minArgs;
				this.maxArgs = maxArgs;
				this.argTypes = argTypes;
			}

			public static void CheckArity(int minArgs, int maxArgs, string name, int numArgs)
			{
				if (minArgs <= numArgs && numArgs <= maxArgs)
				{
					return;
				}
				string resId = ((minArgs == maxArgs) ? "XPath_NArgsExpected" : ((maxArgs == minArgs + 1) ? "XPath_NOrMArgsExpected" : ((numArgs >= minArgs) ? "XPath_AtMostMArgsExpected" : "XPath_AtLeastNArgsExpected")));
				throw new XPathCompileException(resId, name, minArgs.ToString(CultureInfo.InvariantCulture), maxArgs.ToString(CultureInfo.InvariantCulture));
			}

			public void CastArguments(IList<QilNode> args, string name, XPathQilFactory f)
			{
				CheckArity(minArgs, maxArgs, name, args.Count);
				if (maxArgs == int.MaxValue)
				{
					for (int i = 0; i < args.Count; i++)
					{
						args[i] = f.ConvertToType(XmlTypeCode.String, args[i]);
					}
					return;
				}
				for (int j = 0; j < args.Count; j++)
				{
					if (argTypes[j] == XmlTypeCode.Node && f.CannotBeNodeSet(args[j]))
					{
						throw new XPathCompileException("XPath_NodeSetArgumentExpected", name, (j + 1).ToString(CultureInfo.InvariantCulture));
					}
					args[j] = f.ConvertToType(argTypes[j], args[j]);
				}
			}
		}

		private XPathQilFactory f;

		private IXPathEnvironment environment;

		private bool inTheBuild;

		protected QilNode fixupCurrent;

		protected QilNode fixupPosition;

		protected QilNode fixupLast;

		protected int numFixupCurrent;

		protected int numFixupPosition;

		protected int numFixupLast;

		private FixupVisitor fixupVisitor;

		private static XmlNodeKindFlags[] XPathNodeType2QilXmlNodeKind = new XmlNodeKindFlags[10]
		{
			XmlNodeKindFlags.Document,
			XmlNodeKindFlags.Element,
			XmlNodeKindFlags.Attribute,
			XmlNodeKindFlags.Namespace,
			XmlNodeKindFlags.Text,
			XmlNodeKindFlags.Text,
			XmlNodeKindFlags.Text,
			XmlNodeKindFlags.PI,
			XmlNodeKindFlags.Comment,
			XmlNodeKindFlags.Any
		};

		private static XPathOperatorGroup[] OperatorGroup = new XPathOperatorGroup[16]
		{
			XPathOperatorGroup.Unknown,
			XPathOperatorGroup.Logical,
			XPathOperatorGroup.Logical,
			XPathOperatorGroup.Equality,
			XPathOperatorGroup.Equality,
			XPathOperatorGroup.Relational,
			XPathOperatorGroup.Relational,
			XPathOperatorGroup.Relational,
			XPathOperatorGroup.Relational,
			XPathOperatorGroup.Arithmetic,
			XPathOperatorGroup.Arithmetic,
			XPathOperatorGroup.Arithmetic,
			XPathOperatorGroup.Arithmetic,
			XPathOperatorGroup.Arithmetic,
			XPathOperatorGroup.Negate,
			XPathOperatorGroup.Union
		};

		private static QilNodeType[] QilOperator = new QilNodeType[16]
		{
			QilNodeType.Unknown,
			QilNodeType.Or,
			QilNodeType.And,
			QilNodeType.Eq,
			QilNodeType.Ne,
			QilNodeType.Lt,
			QilNodeType.Le,
			QilNodeType.Gt,
			QilNodeType.Ge,
			QilNodeType.Add,
			QilNodeType.Subtract,
			QilNodeType.Multiply,
			QilNodeType.Divide,
			QilNodeType.Modulo,
			QilNodeType.Negate,
			QilNodeType.Sequence
		};

		private static XmlNodeKindFlags[] XPathAxisMask = new XmlNodeKindFlags[15]
		{
			XmlNodeKindFlags.None,
			XmlNodeKindFlags.Document | XmlNodeKindFlags.Element,
			XmlNodeKindFlags.Any,
			XmlNodeKindFlags.Attribute,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Any,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Namespace,
			XmlNodeKindFlags.Document | XmlNodeKindFlags.Element,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Content,
			XmlNodeKindFlags.Any,
			XmlNodeKindFlags.Document
		};

		public static readonly XmlTypeCode[] argAny = new XmlTypeCode[1] { XmlTypeCode.Item };

		public static readonly XmlTypeCode[] argNodeSet = new XmlTypeCode[1] { XmlTypeCode.Node };

		public static readonly XmlTypeCode[] argBoolean = new XmlTypeCode[1] { XmlTypeCode.Boolean };

		public static readonly XmlTypeCode[] argDouble = new XmlTypeCode[1] { XmlTypeCode.Double };

		public static readonly XmlTypeCode[] argString = new XmlTypeCode[1] { XmlTypeCode.String };

		public static readonly XmlTypeCode[] argString2 = new XmlTypeCode[2]
		{
			XmlTypeCode.String,
			XmlTypeCode.String
		};

		public static readonly XmlTypeCode[] argString3 = new XmlTypeCode[3]
		{
			XmlTypeCode.String,
			XmlTypeCode.String,
			XmlTypeCode.String
		};

		public static readonly XmlTypeCode[] argFnSubstr = new XmlTypeCode[3]
		{
			XmlTypeCode.String,
			XmlTypeCode.Double,
			XmlTypeCode.Double
		};

		public static Dictionary<string, FunctionInfo<FuncId>> FunctionTable = CreateFunctionTable();

		XPathQilFactory IXPathEnvironment.Factory => f;

		QilNode IFocus.GetCurrent()
		{
			return GetCurrentNode();
		}

		QilNode IFocus.GetPosition()
		{
			return GetCurrentPosition();
		}

		QilNode IFocus.GetLast()
		{
			return GetLastPosition();
		}

		QilNode IXPathEnvironment.ResolveVariable(string prefix, string name)
		{
			return Variable(prefix, name);
		}

		QilNode IXPathEnvironment.ResolveFunction(string prefix, string name, IList<QilNode> args, IFocus env)
		{
			return null;
		}

		string IXPathEnvironment.ResolvePrefix(string prefix)
		{
			return environment.ResolvePrefix(prefix);
		}

		public XPathBuilder(IXPathEnvironment environment)
		{
			this.environment = environment;
			f = this.environment.Factory;
			fixupCurrent = f.Unknown(XmlQueryTypeFactory.NodeNotRtf);
			fixupPosition = f.Unknown(XmlQueryTypeFactory.DoubleX);
			fixupLast = f.Unknown(XmlQueryTypeFactory.DoubleX);
			fixupVisitor = new FixupVisitor(f, fixupCurrent, fixupPosition, fixupLast);
		}

		public virtual void StartBuild()
		{
			inTheBuild = true;
			numFixupCurrent = (numFixupPosition = (numFixupLast = 0));
		}

		public virtual QilNode EndBuild(QilNode result)
		{
			if (result == null)
			{
				inTheBuild = false;
				return result;
			}
			if (result.XmlType.MaybeMany && result.XmlType.IsNode && result.XmlType.IsNotRtf)
			{
				result = f.DocOrderDistinct(result);
			}
			result = fixupVisitor.Fixup(result, environment);
			numFixupCurrent -= fixupVisitor.numCurrent;
			numFixupPosition -= fixupVisitor.numPosition;
			numFixupLast -= fixupVisitor.numLast;
			inTheBuild = false;
			return result;
		}

		private QilNode GetCurrentNode()
		{
			numFixupCurrent++;
			return fixupCurrent;
		}

		private QilNode GetCurrentPosition()
		{
			numFixupPosition++;
			return fixupPosition;
		}

		private QilNode GetLastPosition()
		{
			numFixupLast++;
			return fixupLast;
		}

		public virtual QilNode String(string value)
		{
			return f.String(value);
		}

		public virtual QilNode Number(double value)
		{
			return f.Double(value);
		}

		public virtual QilNode Operator(XPathOperator op, QilNode left, QilNode right)
		{
			return OperatorGroup[(int)op] switch
			{
				XPathOperatorGroup.Logical => LogicalOperator(op, left, right), 
				XPathOperatorGroup.Equality => EqualityOperator(op, left, right), 
				XPathOperatorGroup.Relational => RelationalOperator(op, left, right), 
				XPathOperatorGroup.Arithmetic => ArithmeticOperator(op, left, right), 
				XPathOperatorGroup.Negate => NegateOperator(op, left, right), 
				XPathOperatorGroup.Union => UnionOperator(op, left, right), 
				_ => null, 
			};
		}

		private QilNode LogicalOperator(XPathOperator op, QilNode left, QilNode right)
		{
			left = f.ConvertToBoolean(left);
			right = f.ConvertToBoolean(right);
			if (op != XPathOperator.Or)
			{
				return f.And(left, right);
			}
			return f.Or(left, right);
		}

		private QilNode CompareValues(XPathOperator op, QilNode left, QilNode right, XmlTypeCode compType)
		{
			left = f.ConvertToType(compType, left);
			right = f.ConvertToType(compType, right);
			return op switch
			{
				XPathOperator.Eq => f.Eq(left, right), 
				XPathOperator.Ne => f.Ne(left, right), 
				XPathOperator.Lt => f.Lt(left, right), 
				XPathOperator.Le => f.Le(left, right), 
				XPathOperator.Gt => f.Gt(left, right), 
				XPathOperator.Ge => f.Ge(left, right), 
				_ => null, 
			};
		}

		private QilNode CompareNodeSetAndValue(XPathOperator op, QilNode nodeset, QilNode val, XmlTypeCode compType)
		{
			if (compType == XmlTypeCode.Boolean || nodeset.XmlType.IsSingleton)
			{
				return CompareValues(op, nodeset, val, compType);
			}
			QilIterator qilIterator = f.For(nodeset);
			return f.Not(f.IsEmpty(f.Filter(qilIterator, CompareValues(op, f.XPathNodeValue(qilIterator), val, compType))));
		}

		private static XPathOperator InvertOp(XPathOperator op)
		{
			return op switch
			{
				XPathOperator.Ge => XPathOperator.Le, 
				XPathOperator.Gt => XPathOperator.Lt, 
				XPathOperator.Le => XPathOperator.Ge, 
				XPathOperator.Lt => XPathOperator.Gt, 
				_ => op, 
			};
		}

		private QilNode CompareNodeSetAndNodeSet(XPathOperator op, QilNode left, QilNode right, XmlTypeCode compType)
		{
			if (right.XmlType.IsSingleton)
			{
				return CompareNodeSetAndValue(op, left, right, compType);
			}
			if (left.XmlType.IsSingleton)
			{
				op = InvertOp(op);
				return CompareNodeSetAndValue(op, right, left, compType);
			}
			QilIterator qilIterator = f.For(left);
			QilIterator qilIterator2 = f.For(right);
			return f.Not(f.IsEmpty(f.Loop(qilIterator, f.Filter(qilIterator2, CompareValues(op, f.XPathNodeValue(qilIterator), f.XPathNodeValue(qilIterator2), compType)))));
		}

		private QilNode EqualityOperator(XPathOperator op, QilNode left, QilNode right)
		{
			XmlQueryType xmlType = left.XmlType;
			XmlQueryType xmlType2 = right.XmlType;
			if (f.IsAnyType(left) || f.IsAnyType(right))
			{
				return f.InvokeEqualityOperator(QilOperator[(int)op], left, right);
			}
			if (xmlType.IsNode && xmlType2.IsNode)
			{
				return CompareNodeSetAndNodeSet(op, left, right, XmlTypeCode.String);
			}
			if (xmlType.IsNode)
			{
				return CompareNodeSetAndValue(op, left, right, xmlType2.TypeCode);
			}
			if (xmlType2.IsNode)
			{
				return CompareNodeSetAndValue(op, right, left, xmlType.TypeCode);
			}
			XmlTypeCode compType = ((xmlType.TypeCode == XmlTypeCode.Boolean || xmlType2.TypeCode == XmlTypeCode.Boolean) ? XmlTypeCode.Boolean : ((xmlType.TypeCode == XmlTypeCode.Double || xmlType2.TypeCode == XmlTypeCode.Double) ? XmlTypeCode.Double : XmlTypeCode.String));
			return CompareValues(op, left, right, compType);
		}

		private QilNode RelationalOperator(XPathOperator op, QilNode left, QilNode right)
		{
			XmlQueryType xmlType = left.XmlType;
			XmlQueryType xmlType2 = right.XmlType;
			if (f.IsAnyType(left) || f.IsAnyType(right))
			{
				return f.InvokeRelationalOperator(QilOperator[(int)op], left, right);
			}
			if (xmlType.IsNode && xmlType2.IsNode)
			{
				return CompareNodeSetAndNodeSet(op, left, right, XmlTypeCode.Double);
			}
			if (xmlType.IsNode)
			{
				XmlTypeCode compType = ((xmlType2.TypeCode == XmlTypeCode.Boolean) ? XmlTypeCode.Boolean : XmlTypeCode.Double);
				return CompareNodeSetAndValue(op, left, right, compType);
			}
			if (xmlType2.IsNode)
			{
				XmlTypeCode compType2 = ((xmlType.TypeCode == XmlTypeCode.Boolean) ? XmlTypeCode.Boolean : XmlTypeCode.Double);
				op = InvertOp(op);
				return CompareNodeSetAndValue(op, right, left, compType2);
			}
			return CompareValues(op, left, right, XmlTypeCode.Double);
		}

		private QilNode NegateOperator(XPathOperator op, QilNode left, QilNode right)
		{
			return f.Negate(f.ConvertToNumber(left));
		}

		private QilNode ArithmeticOperator(XPathOperator op, QilNode left, QilNode right)
		{
			left = f.ConvertToNumber(left);
			right = f.ConvertToNumber(right);
			return op switch
			{
				XPathOperator.Plus => f.Add(left, right), 
				XPathOperator.Minus => f.Subtract(left, right), 
				XPathOperator.Multiply => f.Multiply(left, right), 
				XPathOperator.Divide => f.Divide(left, right), 
				XPathOperator.Modulo => f.Modulo(left, right), 
				_ => null, 
			};
		}

		private QilNode UnionOperator(XPathOperator op, QilNode left, QilNode right)
		{
			if (left == null)
			{
				return f.EnsureNodeSet(right);
			}
			left = f.EnsureNodeSet(left);
			right = f.EnsureNodeSet(right);
			if (left.NodeType == QilNodeType.Sequence)
			{
				((QilList)left).Add(right);
				return left;
			}
			return f.Union(left, right);
		}

		public static XmlNodeKindFlags AxisTypeMask(XmlNodeKindFlags inputTypeMask, XPathNodeType nodeType, XPathAxis xpathAxis)
		{
			return inputTypeMask & XPathNodeType2QilXmlNodeKind[(int)nodeType] & XPathAxisMask[(int)xpathAxis];
		}

		private QilNode BuildAxisFilter(QilNode qilAxis, XPathAxis xpathAxis, XPathNodeType nodeType, string name, string nsUri)
		{
			XmlNodeKindFlags nodeKinds = qilAxis.XmlType.NodeKinds;
			XmlNodeKindFlags xmlNodeKindFlags = AxisTypeMask(nodeKinds, nodeType, xpathAxis);
			if (xmlNodeKindFlags == XmlNodeKindFlags.None)
			{
				return f.Sequence();
			}
			QilIterator expr;
			if (xmlNodeKindFlags != nodeKinds)
			{
				qilAxis = f.Filter(expr = f.For(qilAxis), f.IsType(expr, XmlQueryTypeFactory.NodeChoice(xmlNodeKindFlags)));
				qilAxis.XmlType = XmlQueryTypeFactory.PrimeProduct(XmlQueryTypeFactory.NodeChoice(xmlNodeKindFlags), qilAxis.XmlType.Cardinality);
				if (qilAxis.NodeType == QilNodeType.Filter)
				{
					QilLoop qilLoop = (QilLoop)qilAxis;
					qilLoop.Body = f.And(qilLoop.Body, (name != null && nsUri != null) ? f.Eq(f.NameOf(expr), f.QName(name, nsUri)) : ((nsUri != null) ? f.Eq(f.NamespaceUriOf(expr), f.String(nsUri)) : ((name != null) ? f.Eq(f.LocalNameOf(expr), f.String(name)) : f.True())));
					return qilLoop;
				}
			}
			return f.Filter(expr = f.For(qilAxis), (name != null && nsUri != null) ? f.Eq(f.NameOf(expr), f.QName(name, nsUri)) : ((nsUri != null) ? f.Eq(f.NamespaceUriOf(expr), f.String(nsUri)) : ((name != null) ? f.Eq(f.LocalNameOf(expr), f.String(name)) : f.True())));
		}

		private QilNode BuildAxis(XPathAxis xpathAxis, XPathNodeType nodeType, string nsUri, string name)
		{
			QilNode currentNode = GetCurrentNode();
			QilNode qilAxis;
			switch (xpathAxis)
			{
			case XPathAxis.Ancestor:
				qilAxis = f.Ancestor(currentNode);
				break;
			case XPathAxis.AncestorOrSelf:
				qilAxis = f.AncestorOrSelf(currentNode);
				break;
			case XPathAxis.Attribute:
				qilAxis = f.Content(currentNode);
				break;
			case XPathAxis.Child:
				qilAxis = f.Content(currentNode);
				break;
			case XPathAxis.Descendant:
				qilAxis = f.Descendant(currentNode);
				break;
			case XPathAxis.DescendantOrSelf:
				qilAxis = f.DescendantOrSelf(currentNode);
				break;
			case XPathAxis.Following:
				qilAxis = f.XPathFollowing(currentNode);
				break;
			case XPathAxis.FollowingSibling:
				qilAxis = f.FollowingSibling(currentNode);
				break;
			case XPathAxis.Namespace:
				qilAxis = f.XPathNamespace(currentNode);
				break;
			case XPathAxis.Parent:
				qilAxis = f.Parent(currentNode);
				break;
			case XPathAxis.Preceding:
				qilAxis = f.XPathPreceding(currentNode);
				break;
			case XPathAxis.PrecedingSibling:
				qilAxis = f.PrecedingSibling(currentNode);
				break;
			case XPathAxis.Self:
				qilAxis = currentNode;
				break;
			case XPathAxis.Root:
				return f.Root(currentNode);
			default:
				qilAxis = null;
				break;
			}
			QilNode qilNode = BuildAxisFilter(qilAxis, xpathAxis, nodeType, name, nsUri);
			if (xpathAxis == XPathAxis.Ancestor || xpathAxis == XPathAxis.Preceding || xpathAxis == XPathAxis.AncestorOrSelf || xpathAxis == XPathAxis.PrecedingSibling)
			{
				qilNode = f.BaseFactory.DocOrderDistinct(qilNode);
			}
			return qilNode;
		}

		public virtual QilNode Axis(XPathAxis xpathAxis, XPathNodeType nodeType, string prefix, string name)
		{
			string nsUri = ((prefix == null) ? null : environment.ResolvePrefix(prefix));
			return BuildAxis(xpathAxis, nodeType, nsUri, name);
		}

		public virtual QilNode JoinStep(QilNode left, QilNode right)
		{
			QilIterator qilIterator = f.For(f.EnsureNodeSet(left));
			right = fixupVisitor.Fixup(right, qilIterator, null);
			numFixupCurrent -= fixupVisitor.numCurrent;
			numFixupPosition -= fixupVisitor.numPosition;
			numFixupLast -= fixupVisitor.numLast;
			return f.DocOrderDistinct(f.Loop(qilIterator, right));
		}

		public virtual QilNode Predicate(QilNode nodeset, QilNode predicate, bool isReverseStep)
		{
			if (isReverseStep)
			{
				nodeset = ((QilUnary)nodeset).Child;
			}
			predicate = PredicateToBoolean(predicate, f, this);
			return BuildOnePredicate(nodeset, predicate, isReverseStep, f, fixupVisitor, ref numFixupCurrent, ref numFixupPosition, ref numFixupLast);
		}

		public static QilNode PredicateToBoolean(QilNode predicate, XPathQilFactory f, IXPathEnvironment env)
		{
			QilIterator qilIterator;
			predicate = (f.IsAnyType(predicate) ? f.Loop(qilIterator = f.Let(predicate), f.Conditional(f.IsType(qilIterator, XmlQueryTypeFactory.Double), f.Eq(env.GetPosition(), f.TypeAssert(qilIterator, XmlQueryTypeFactory.DoubleX)), f.ConvertToBoolean(qilIterator))) : ((predicate.XmlType.TypeCode != XmlTypeCode.Double) ? f.ConvertToBoolean(predicate) : f.Eq(env.GetPosition(), predicate)));
			return predicate;
		}

		public static QilNode BuildOnePredicate(QilNode nodeset, QilNode predicate, bool isReverseStep, XPathQilFactory f, FixupVisitor fixupVisitor, ref int numFixupCurrent, ref int numFixupPosition, ref int numFixupLast)
		{
			nodeset = f.EnsureNodeSet(nodeset);
			QilNode qilNode;
			if (numFixupLast != 0 && fixupVisitor.CountUnfixedLast(predicate) != 0)
			{
				QilIterator qilIterator = f.Let(nodeset);
				QilIterator qilIterator2 = f.Let(f.XsltConvert(f.Length(qilIterator), XmlQueryTypeFactory.DoubleX));
				QilIterator qilIterator3 = f.For(qilIterator);
				predicate = fixupVisitor.Fixup(predicate, qilIterator3, qilIterator2);
				numFixupCurrent -= fixupVisitor.numCurrent;
				numFixupPosition -= fixupVisitor.numPosition;
				numFixupLast -= fixupVisitor.numLast;
				qilNode = f.Loop(qilIterator, f.Loop(qilIterator2, f.Filter(qilIterator3, predicate)));
			}
			else
			{
				QilIterator qilIterator4 = f.For(nodeset);
				predicate = fixupVisitor.Fixup(predicate, qilIterator4, null);
				numFixupCurrent -= fixupVisitor.numCurrent;
				numFixupPosition -= fixupVisitor.numPosition;
				numFixupLast -= fixupVisitor.numLast;
				qilNode = f.Filter(qilIterator4, predicate);
			}
			if (isReverseStep)
			{
				qilNode = f.DocOrderDistinct(qilNode);
			}
			return qilNode;
		}

		public virtual QilNode Variable(string prefix, string name)
		{
			return environment.ResolveVariable(prefix, name);
		}

		public virtual QilNode Function(string prefix, string name, IList<QilNode> args)
		{
			if (prefix.Length == 0 && FunctionTable.TryGetValue(name, out var value))
			{
				value.CastArguments(args, name, f);
				switch (value.id)
				{
				case FuncId.Not:
					return f.Not(args[0]);
				case FuncId.Last:
					return GetLastPosition();
				case FuncId.Position:
					return GetCurrentPosition();
				case FuncId.Count:
					return f.XsltConvert(f.Length(f.DocOrderDistinct(args[0])), XmlQueryTypeFactory.DoubleX);
				case FuncId.LocalName:
					if (args.Count != 0)
					{
						return LocalNameOfFirstNode(args[0]);
					}
					return f.LocalNameOf(GetCurrentNode());
				case FuncId.NamespaceUri:
					if (args.Count != 0)
					{
						return NamespaceOfFirstNode(args[0]);
					}
					return f.NamespaceUriOf(GetCurrentNode());
				case FuncId.Name:
					if (args.Count != 0)
					{
						return NameOfFirstNode(args[0]);
					}
					return NameOf(GetCurrentNode());
				case FuncId.String:
					if (args.Count != 0)
					{
						return f.ConvertToString(args[0]);
					}
					return f.XPathNodeValue(GetCurrentNode());
				case FuncId.Number:
					if (args.Count != 0)
					{
						return f.ConvertToNumber(args[0]);
					}
					return f.XsltConvert(f.XPathNodeValue(GetCurrentNode()), XmlQueryTypeFactory.DoubleX);
				case FuncId.Boolean:
					return f.ConvertToBoolean(args[0]);
				case FuncId.True:
					return f.True();
				case FuncId.False:
					return f.False();
				case FuncId.Id:
					return f.DocOrderDistinct(f.Id(GetCurrentNode(), args[0]));
				case FuncId.Concat:
					return f.StrConcat(args);
				case FuncId.StartsWith:
					return f.InvokeStartsWith(args[0], args[1]);
				case FuncId.Contains:
					return f.InvokeContains(args[0], args[1]);
				case FuncId.SubstringBefore:
					return f.InvokeSubstringBefore(args[0], args[1]);
				case FuncId.SubstringAfter:
					return f.InvokeSubstringAfter(args[0], args[1]);
				case FuncId.Substring:
					if (args.Count != 2)
					{
						return f.InvokeSubstring(args[0], args[1], args[2]);
					}
					return f.InvokeSubstring(args[0], args[1]);
				case FuncId.StringLength:
					return f.XsltConvert(f.StrLength((args.Count == 0) ? f.XPathNodeValue(GetCurrentNode()) : args[0]), XmlQueryTypeFactory.DoubleX);
				case FuncId.Normalize:
					return f.InvokeNormalizeSpace((args.Count == 0) ? f.XPathNodeValue(GetCurrentNode()) : args[0]);
				case FuncId.Translate:
					return f.InvokeTranslate(args[0], args[1], args[2]);
				case FuncId.Lang:
					return f.InvokeLang(args[0], GetCurrentNode());
				case FuncId.Sum:
					return Sum(f.DocOrderDistinct(args[0]));
				case FuncId.Floor:
					return f.InvokeFloor(args[0]);
				case FuncId.Ceiling:
					return f.InvokeCeiling(args[0]);
				case FuncId.Round:
					return f.InvokeRound(args[0]);
				default:
					return null;
				}
			}
			return environment.ResolveFunction(prefix, name, args, this);
		}

		private QilNode LocalNameOfFirstNode(QilNode arg)
		{
			if (arg.XmlType.IsSingleton)
			{
				return f.LocalNameOf(arg);
			}
			QilIterator expr;
			return f.StrConcat(f.Loop(expr = f.FirstNode(arg), f.LocalNameOf(expr)));
		}

		private QilNode NamespaceOfFirstNode(QilNode arg)
		{
			if (arg.XmlType.IsSingleton)
			{
				return f.NamespaceUriOf(arg);
			}
			QilIterator expr;
			return f.StrConcat(f.Loop(expr = f.FirstNode(arg), f.NamespaceUriOf(expr)));
		}

		private QilNode NameOf(QilNode arg)
		{
			QilIterator qilIterator;
			QilIterator qilIterator2;
			if (arg is QilIterator)
			{
				return f.Loop(qilIterator = f.Let(f.PrefixOf(arg)), f.Loop(qilIterator2 = f.Let(f.LocalNameOf(arg)), f.Conditional(f.Eq(f.StrLength(qilIterator), f.Int32(0)), qilIterator2, f.StrConcat(qilIterator, f.String(":"), qilIterator2))));
			}
			QilIterator qilIterator3 = f.Let(arg);
			return f.Loop(qilIterator3, NameOf(qilIterator3));
		}

		private QilNode NameOfFirstNode(QilNode arg)
		{
			if (arg.XmlType.IsSingleton)
			{
				return NameOf(arg);
			}
			QilIterator arg2;
			return f.StrConcat(f.Loop(arg2 = f.FirstNode(arg), NameOf(arg2)));
		}

		private QilNode Sum(QilNode arg)
		{
			QilIterator n;
			return f.Sum(f.Sequence(f.Double(0.0), f.Loop(n = f.For(arg), f.ConvertToNumber(n))));
		}

		private static Dictionary<string, FunctionInfo<FuncId>> CreateFunctionTable()
		{
			Dictionary<string, FunctionInfo<FuncId>> dictionary = new Dictionary<string, FunctionInfo<FuncId>>(36);
			dictionary.Add("last", new FunctionInfo<FuncId>(FuncId.Last, 0, 0, null));
			dictionary.Add("position", new FunctionInfo<FuncId>(FuncId.Position, 0, 0, null));
			dictionary.Add("name", new FunctionInfo<FuncId>(FuncId.Name, 0, 1, argNodeSet));
			dictionary.Add("namespace-uri", new FunctionInfo<FuncId>(FuncId.NamespaceUri, 0, 1, argNodeSet));
			dictionary.Add("local-name", new FunctionInfo<FuncId>(FuncId.LocalName, 0, 1, argNodeSet));
			dictionary.Add("count", new FunctionInfo<FuncId>(FuncId.Count, 1, 1, argNodeSet));
			dictionary.Add("id", new FunctionInfo<FuncId>(FuncId.Id, 1, 1, argAny));
			dictionary.Add("string", new FunctionInfo<FuncId>(FuncId.String, 0, 1, argAny));
			dictionary.Add("concat", new FunctionInfo<FuncId>(FuncId.Concat, 2, int.MaxValue, null));
			dictionary.Add("starts-with", new FunctionInfo<FuncId>(FuncId.StartsWith, 2, 2, argString2));
			dictionary.Add("contains", new FunctionInfo<FuncId>(FuncId.Contains, 2, 2, argString2));
			dictionary.Add("substring-before", new FunctionInfo<FuncId>(FuncId.SubstringBefore, 2, 2, argString2));
			dictionary.Add("substring-after", new FunctionInfo<FuncId>(FuncId.SubstringAfter, 2, 2, argString2));
			dictionary.Add("substring", new FunctionInfo<FuncId>(FuncId.Substring, 2, 3, argFnSubstr));
			dictionary.Add("string-length", new FunctionInfo<FuncId>(FuncId.StringLength, 0, 1, argString));
			dictionary.Add("normalize-space", new FunctionInfo<FuncId>(FuncId.Normalize, 0, 1, argString));
			dictionary.Add("translate", new FunctionInfo<FuncId>(FuncId.Translate, 3, 3, argString3));
			dictionary.Add("boolean", new FunctionInfo<FuncId>(FuncId.Boolean, 1, 1, argAny));
			dictionary.Add("not", new FunctionInfo<FuncId>(FuncId.Not, 1, 1, argBoolean));
			dictionary.Add("true", new FunctionInfo<FuncId>(FuncId.True, 0, 0, null));
			dictionary.Add("false", new FunctionInfo<FuncId>(FuncId.False, 0, 0, null));
			dictionary.Add("lang", new FunctionInfo<FuncId>(FuncId.Lang, 1, 1, argString));
			dictionary.Add("number", new FunctionInfo<FuncId>(FuncId.Number, 0, 1, argAny));
			dictionary.Add("sum", new FunctionInfo<FuncId>(FuncId.Sum, 1, 1, argNodeSet));
			dictionary.Add("floor", new FunctionInfo<FuncId>(FuncId.Floor, 1, 1, argDouble));
			dictionary.Add("ceiling", new FunctionInfo<FuncId>(FuncId.Ceiling, 1, 1, argDouble));
			dictionary.Add("round", new FunctionInfo<FuncId>(FuncId.Round, 1, 1, argDouble));
			return dictionary;
		}

		public static bool IsFunctionAvailable(string localName, string nsUri)
		{
			if (nsUri.Length != 0)
			{
				return false;
			}
			return FunctionTable.ContainsKey(localName);
		}
	}
	[Serializable]
	internal class XPathCompileException : XslLoadException
	{
		private enum TrimType
		{
			Left,
			Right,
			Middle
		}

		public string queryString;

		public int startChar;

		public int endChar;

		protected XPathCompileException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			queryString = (string)info.GetValue("QueryString", typeof(string));
			startChar = (int)info.GetValue("StartChar", typeof(int));
			endChar = (int)info.GetValue("EndChar", typeof(int));
		}

		[SecurityPermission(SecurityAction.LinkDemand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("QueryString", queryString);
			info.AddValue("StartChar", startChar);
			info.AddValue("EndChar", endChar);
		}

		internal XPathCompileException(string queryString, int startChar, int endChar, string resId, params string[] args)
			: base(resId, args)
		{
			this.queryString = queryString;
			this.startChar = startChar;
			this.endChar = endChar;
		}

		internal XPathCompileException(string resId, params string[] args)
			: base(resId, args)
		{
		}

		private static void AppendTrimmed(StringBuilder sb, string value, int startIndex, int count, TrimType trimType)
		{
			if (count <= 32)
			{
				sb.Append(value, startIndex, count);
				return;
			}
			switch (trimType)
			{
			case TrimType.Left:
				sb.Append("...");
				sb.Append(value, startIndex + count - 32, 32);
				break;
			case TrimType.Right:
				sb.Append(value, startIndex, 32);
				sb.Append("...");
				break;
			case TrimType.Middle:
				sb.Append(value, startIndex, 16);
				sb.Append("...");
				sb.Append(value, startIndex + count - 16, 16);
				break;
			}
		}

		internal string MarkOutError()
		{
			if (queryString == null || queryString.Trim(' ').Length == 0)
			{
				return null;
			}
			int num = endChar - startChar;
			StringBuilder stringBuilder = new StringBuilder();
			AppendTrimmed(stringBuilder, queryString, 0, startChar, TrimType.Left);
			if (num > 0)
			{
				stringBuilder.Append(" -->");
				AppendTrimmed(stringBuilder, queryString, startChar, num, TrimType.Middle);
			}
			stringBuilder.Append("<-- ");
			AppendTrimmed(stringBuilder, queryString, endChar, queryString.Length - endChar, TrimType.Right);
			return stringBuilder.ToString();
		}

		internal override string FormatDetailedMessage()
		{
			string text = Message;
			string text2 = MarkOutError();
			if (text2 != null && text2.Length > 0)
			{
				if (text.Length > 0)
				{
					text += Environment.NewLine;
				}
				text += text2;
			}
			return text;
		}
	}
	internal enum XPathOperator
	{
		Unknown = 0,
		Or = 1,
		And = 2,
		Eq = 3,
		Ne = 4,
		Lt = 5,
		Le = 6,
		Gt = 7,
		Ge = 8,
		Plus = 9,
		Minus = 10,
		Multiply = 11,
		Divide = 12,
		Modulo = 13,
		UnaryMinus = 14,
		Union = 15,
		LastXPath1Operator = 15,
		UnaryPlus = 16,
		Idiv = 17,
		Is = 18,
		After = 19,
		Before = 20,
		Range = 21,
		Except = 22,
		Intersect = 23,
		ValEq = 24,
		ValNe = 25,
		ValLt = 26,
		ValLe = 27,
		ValGt = 28,
		ValGe = 29
	}
	internal class XPathParser<Node>
	{
		private XPathScanner scanner;

		private IXPathBuilder<Node> builder;

		private Stack<int> posInfo = new Stack<int>();

		private const int MaxParseRelativePathDepth = 1024;

		private int parseRelativePath;

		private const int MaxParseSubExprDepth = 1024;

		private int parseSubExprDepth;

		private static int[] XPathOperatorPrecedence = new int[16]
		{
			0, 1, 2, 3, 3, 4, 4, 4, 4, 5,
			5, 6, 6, 6, 7, 8
		};

		public Node Parse(XPathScanner scanner, IXPathBuilder<Node> builder, LexKind endLex)
		{
			Node result = default(Node);
			this.scanner = scanner;
			this.builder = builder;
			posInfo.Clear();
			try
			{
				builder.StartBuild();
				result = ParseExpr();
				scanner.CheckToken(endLex);
			}
			catch (XPathCompileException ex)
			{
				if (ex.queryString == null)
				{
					ex.queryString = scanner.Source;
					PopPosInfo(out ex.startChar, out ex.endChar);
				}
				throw;
			}
			finally
			{
				result = builder.EndBuild(result);
			}
			return result;
		}

		internal static bool IsStep(LexKind lexKind)
		{
			if (lexKind != LexKind.Dot && lexKind != LexKind.DotDot && lexKind != LexKind.At && lexKind != LexKind.Axis && lexKind != LexKind.Star)
			{
				return lexKind == LexKind.Name;
			}
			return true;
		}

		private Node ParseLocationPath()
		{
			if (scanner.Kind == LexKind.Slash)
			{
				scanner.NextLex();
				Node val = builder.Axis(XPathAxis.Root, XPathNodeType.All, null, null);
				if (IsStep(scanner.Kind))
				{
					val = builder.JoinStep(val, ParseRelativeLocationPath());
				}
				return val;
			}
			if (scanner.Kind == LexKind.SlashSlash)
			{
				scanner.NextLex();
				return builder.JoinStep(builder.Axis(XPathAxis.Root, XPathNodeType.All, null, null), builder.JoinStep(builder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativeLocationPath()));
			}
			return ParseRelativeLocationPath();
		}

		private Node ParseRelativeLocationPath()
		{
			if (++parseRelativePath > 1024 && XsltConfigSection.LimitXPathComplexity)
			{
				throw scanner.CreateException("Xslt_InputTooComplex");
			}
			Node val = ParseStep();
			if (scanner.Kind == LexKind.Slash)
			{
				scanner.NextLex();
				val = builder.JoinStep(val, ParseRelativeLocationPath());
			}
			else if (scanner.Kind == LexKind.SlashSlash)
			{
				scanner.NextLex();
				val = builder.JoinStep(val, builder.JoinStep(builder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativeLocationPath()));
			}
			parseRelativePath--;
			return val;
		}

		private Node ParseStep()
		{
			Node val;
			if (LexKind.Dot == scanner.Kind)
			{
				scanner.NextLex();
				val = builder.Axis(XPathAxis.Self, XPathNodeType.All, null, null);
				if (LexKind.LBracket == scanner.Kind)
				{
					throw scanner.CreateException("XPath_PredicateAfterDot");
				}
			}
			else if (LexKind.DotDot == scanner.Kind)
			{
				scanner.NextLex();
				val = builder.Axis(XPathAxis.Parent, XPathNodeType.All, null, null);
				if (LexKind.LBracket == scanner.Kind)
				{
					throw scanner.CreateException("XPath_PredicateAfterDotDot");
				}
			}
			else
			{
				XPathAxis axis;
				switch (scanner.Kind)
				{
				case LexKind.Axis:
					axis = scanner.Axis;
					scanner.NextLex();
					scanner.NextLex();
					break;
				case LexKind.At:
					axis = XPathAxis.Attribute;
					scanner.NextLex();
					break;
				case LexKind.Name:
				case LexKind.Star:
					axis = XPathAxis.Child;
					break;
				default:
					throw scanner.CreateException("XPath_UnexpectedToken", scanner.RawValue);
				}
				val = ParseNodeTest(axis);
				while (LexKind.LBracket == scanner.Kind)
				{
					val = builder.Predicate(val, ParsePredicate(), IsReverseAxis(axis));
				}
			}
			return val;
		}

		private static bool IsReverseAxis(XPathAxis axis)
		{
			if (axis != XPathAxis.Ancestor && axis != XPathAxis.Preceding && axis != XPathAxis.AncestorOrSelf)
			{
				return axis == XPathAxis.PrecedingSibling;
			}
			return true;
		}

		private Node ParseNodeTest(XPathAxis axis)
		{
			int lexStart = scanner.LexStart;
			InternalParseNodeTest(scanner, axis, out var nodeType, out var nodePrefix, out var nodeName);
			PushPosInfo(lexStart, scanner.PrevLexEnd);
			Node result = builder.Axis(axis, nodeType, nodePrefix, nodeName);
			PopPosInfo();
			return result;
		}

		private static bool IsNodeType(XPathScanner scanner)
		{
			if (scanner.Prefix.Length == 0)
			{
				if (!(scanner.Name == "node") && !(scanner.Name == "text") && !(scanner.Name == "processing-instruction"))
				{
					return scanner.Name == "comment";
				}
				return true;
			}
			return false;
		}

		private static XPathNodeType PrincipalNodeType(XPathAxis axis)
		{
			return axis switch
			{
				XPathAxis.Namespace => XPathNodeType.Namespace, 
				XPathAxis.Attribute => XPathNodeType.Attribute, 
				_ => XPathNodeType.Element, 
			};
		}

		internal static void InternalParseNodeTest(XPathScanner scanner, XPathAxis axis, out XPathNodeType nodeType, out string nodePrefix, out string nodeName)
		{
			switch (scanner.Kind)
			{
			case LexKind.Name:
				if (scanner.CanBeFunction && IsNodeType(scanner))
				{
					nodePrefix = null;
					nodeName = null;
					switch (scanner.Name)
					{
					case "comment":
						nodeType = XPathNodeType.Comment;
						break;
					case "text":
						nodeType = XPathNodeType.Text;
						break;
					case "node":
						nodeType = XPathNodeType.All;
						break;
					default:
						nodeType = XPathNodeType.ProcessingInstruction;
						break;
					}
					scanner.NextLex();
					scanner.PassToken(LexKind.LParens);
					if (nodeType == XPathNodeType.ProcessingInstruction && scanner.Kind != LexKind.RParens)
					{
						scanner.CheckToken(LexKind.String);
						nodePrefix = string.Empty;
						nodeName = scanner.StringValue;
						scanner.NextLex();
					}
					scanner.PassToken(LexKind.RParens);
				}
				else
				{
					nodePrefix = scanner.Prefix;
					nodeName = scanner.Name;
					nodeType = PrincipalNodeType(axis);
					scanner.NextLex();
					if (nodeName == "*")
					{
						nodeName = null;
					}
				}
				break;
			case LexKind.Star:
				nodePrefix = null;
				nodeName = null;
				nodeType = PrincipalNodeType(axis);
				scanner.NextLex();
				break;
			default:
				throw scanner.CreateException("XPath_NodeTestExpected", scanner.RawValue);
			}
		}

		private Node ParsePredicate()
		{
			scanner.PassToken(LexKind.LBracket);
			Node result = ParseExpr();
			scanner.PassToken(LexKind.RBracket);
			return result;
		}

		private Node ParseExpr()
		{
			return ParseSubExpr(0);
		}

		private Node ParseSubExpr(int callerPrec)
		{
			if (++parseSubExprDepth > 1024 && XsltConfigSection.LimitXPathComplexity)
			{
				throw scanner.CreateException("Xslt_InputTooComplex");
			}
			Node val;
			if (scanner.Kind == LexKind.Minus)
			{
				XPathOperator xPathOperator = XPathOperator.UnaryMinus;
				int callerPrec2 = XPathOperatorPrecedence[(int)xPathOperator];
				scanner.NextLex();
				val = builder.Operator(xPathOperator, ParseSubExpr(callerPrec2), default(Node));
			}
			else
			{
				val = ParseUnionExpr();
			}
			while (true)
			{
				XPathOperator xPathOperator = (XPathOperator)((scanner.Kind <= LexKind.Union) ? scanner.Kind : LexKind.Unknown);
				int num = XPathOperatorPrecedence[(int)xPathOperator];
				if (num <= callerPrec)
				{
					break;
				}
				scanner.NextLex();
				val = builder.Operator(xPathOperator, val, ParseSubExpr(num));
			}
			parseSubExprDepth--;
			return val;
		}

		private Node ParseUnionExpr()
		{
			int lexStart = scanner.LexStart;
			Node val = ParsePathExpr();
			if (scanner.Kind == LexKind.Union)
			{
				PushPosInfo(lexStart, scanner.PrevLexEnd);
				val = builder.Operator(XPathOperator.Union, default(Node), val);
				PopPosInfo();
				while (scanner.Kind == LexKind.Union)
				{
					scanner.NextLex();
					lexStart = scanner.LexStart;
					Node right = ParsePathExpr();
					PushPosInfo(lexStart, scanner.PrevLexEnd);
					val = builder.Operator(XPathOperator.Union, val, right);
					PopPosInfo();
				}
			}
			return val;
		}

		private Node ParsePathExpr()
		{
			if (IsPrimaryExpr())
			{
				int lexStart = scanner.LexStart;
				Node val = ParseFilterExpr();
				int prevLexEnd = scanner.PrevLexEnd;
				if (scanner.Kind == LexKind.Slash)
				{
					scanner.NextLex();
					PushPosInfo(lexStart, prevLexEnd);
					val = builder.JoinStep(val, ParseRelativeLocationPath());
					PopPosInfo();
				}
				else if (scanner.Kind == LexKind.SlashSlash)
				{
					scanner.NextLex();
					PushPosInfo(lexStart, prevLexEnd);
					val = builder.JoinStep(val, builder.JoinStep(builder.Axis(XPathAxis.DescendantOrSelf, XPathNodeType.All, null, null), ParseRelativeLocationPath()));
					PopPosInfo();
				}
				return val;
			}
			return ParseLocationPath();
		}

		private Node ParseFilterExpr()
		{
			int lexStart = scanner.LexStart;
			Node val = ParsePrimaryExpr();
			int prevLexEnd = scanner.PrevLexEnd;
			while (scanner.Kind == LexKind.LBracket)
			{
				PushPosInfo(lexStart, prevLexEnd);
				val = builder.Predicate(val, ParsePredicate(), reverseStep: false);
				PopPosInfo();
			}
			return val;
		}

		private bool IsPrimaryExpr()
		{
			if (scanner.Kind != LexKind.String && scanner.Kind != LexKind.Number && scanner.Kind != LexKind.Dollar && scanner.Kind != LexKind.LParens)
			{
				if (scanner.Kind == LexKind.Name && scanner.CanBeFunction)
				{
					return !IsNodeType(scanner);
				}
				return false;
			}
			return true;
		}

		private Node ParsePrimaryExpr()
		{
			Node result;
			switch (scanner.Kind)
			{
			case LexKind.String:
				result = builder.String(scanner.StringValue);
				scanner.NextLex();
				break;
			case LexKind.Number:
				result = builder.Number(XPathConvert.StringToDouble(scanner.RawValue));
				scanner.NextLex();
				break;
			case LexKind.Dollar:
			{
				int lexStart = scanner.LexStart;
				scanner.NextLex();
				scanner.CheckToken(LexKind.Name);
				PushPosInfo(lexStart, scanner.LexStart + scanner.LexSize);
				result = builder.Variable(scanner.Prefix, scanner.Name);
				PopPosInfo();
				scanner.NextLex();
				break;
			}
			case LexKind.LParens:
				scanner.NextLex();
				result = ParseExpr();
				scanner.PassToken(LexKind.RParens);
				break;
			default:
				result = ParseFunctionCall();
				break;
			}
			return result;
		}

		private Node ParseFunctionCall()
		{
			List<Node> list = new List<Node>();
			string name = scanner.Name;
			string prefix = scanner.Prefix;
			int lexStart = scanner.LexStart;
			scanner.PassToken(LexKind.Name);
			scanner.PassToken(LexKind.LParens);
			if (scanner.Kind != LexKind.RParens)
			{
				while (true)
				{
					list.Add(ParseExpr());
					if (scanner.Kind != LexKind.Comma)
					{
						break;
					}
					scanner.NextLex();
				}
				scanner.CheckToken(LexKind.RParens);
			}
			scanner.NextLex();
			PushPosInfo(lexStart, scanner.PrevLexEnd);
			Node result = builder.Function(prefix, name, list);
			PopPosInfo();
			return result;
		}

		private void PushPosInfo(int startChar, int endChar)
		{
			posInfo.Push(startChar);
			posInfo.Push(endChar);
		}

		private void PopPosInfo()
		{
			posInfo.Pop();
			posInfo.Pop();
		}

		private void PopPosInfo(out int startChar, out int endChar)
		{
			endChar = posInfo.Pop();
			startChar = posInfo.Pop();
		}
	}
	internal class XPathQilFactory : QilPatternFactory
	{
		public XPathQilFactory(QilFactory f, bool debug)
			: base(f, debug)
		{
		}

		public QilNode Error(string res, QilNode args)
		{
			return Error(InvokeFormatMessage(String(res), args));
		}

		public QilNode Error(ISourceLineInfo lineInfo, string res, params string[] args)
		{
			return Error(String(XslLoadException.CreateMessage(lineInfo, res, args)));
		}

		public QilIterator FirstNode(QilNode n)
		{
			QilIterator qilIterator = For(DocOrderDistinct(n));
			return For(Filter(qilIterator, Eq(PositionOf(qilIterator), Int32(1))));
		}

		public bool IsAnyType(QilNode n)
		{
			XmlQueryType xmlType = n.XmlType;
			return !xmlType.IsStrict && !xmlType.IsNode;
		}

		[Conditional("DEBUG")]
		public void CheckAny(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckNode(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckNodeSet(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckNodeNotRtf(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckString(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckStringS(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckDouble(QilNode n)
		{
		}

		[Conditional("DEBUG")]
		public void CheckBool(QilNode n)
		{
		}

		public bool CannotBeNodeSet(QilNode n)
		{
			XmlQueryType xmlType = n.XmlType;
			if (xmlType.IsAtomicValue && !xmlType.IsEmpty)
			{
				return !(n is QilIterator);
			}
			return false;
		}

		public QilNode SafeDocOrderDistinct(QilNode n)
		{
			XmlQueryType xmlType = n.XmlType;
			if (xmlType.MaybeMany)
			{
				if (xmlType.IsNode && xmlType.IsNotRtf)
				{
					return DocOrderDistinct(n);
				}
				QilIterator qilIterator;
				if (!xmlType.IsAtomicValue)
				{
					return Loop(qilIterator = Let(n), Conditional(Gt(Length(qilIterator), Int32(1)), DocOrderDistinct(TypeAssert(qilIterator, XmlQueryTypeFactory.NodeNotRtfS)), qilIterator));
				}
			}
			return n;
		}

		public QilNode InvokeFormatMessage(QilNode res, QilNode args)
		{
			return XsltInvokeEarlyBound(QName("format-message"), XsltMethods.FormatMessage, XmlQueryTypeFactory.StringX, new QilNode[2] { res, args });
		}

		public QilNode InvokeEqualityOperator(QilNodeType op, QilNode left, QilNode right)
		{
			left = TypeAssert(left, XmlQueryTypeFactory.ItemS);
			right = TypeAssert(right, XmlQueryTypeFactory.ItemS);
			double val = ((op != QilNodeType.Eq) ? 1.0 : 0.0);
			return XsltInvokeEarlyBound(QName("EqualityOperator"), XsltMethods.EqualityOperator, XmlQueryTypeFactory.BooleanX, new QilNode[3]
			{
				Double(val),
				left,
				right
			});
		}

		public QilNode InvokeRelationalOperator(QilNodeType op, QilNode left, QilNode right)
		{
			left = TypeAssert(left, XmlQueryTypeFactory.ItemS);
			right = TypeAssert(right, XmlQueryTypeFactory.ItemS);
			double val = op switch
			{
				QilNodeType.Lt => 2.0, 
				QilNodeType.Le => 3.0, 
				QilNodeType.Gt => 4.0, 
				_ => 5.0, 
			};
			return XsltInvokeEarlyBound(QName("RelationalOperator"), XsltMethods.RelationalOperator, XmlQueryTypeFactory.BooleanX, new QilNode[3]
			{
				Double(val),
				left,
				right
			});
		}

		[Conditional("DEBUG")]
		private void ExpectAny(QilNode n)
		{
		}

		public QilNode ConvertToType(XmlTypeCode requiredType, QilNode n)
		{
			return requiredType switch
			{
				XmlTypeCode.String => ConvertToString(n), 
				XmlTypeCode.Double => ConvertToNumber(n), 
				XmlTypeCode.Boolean => ConvertToBoolean(n), 
				XmlTypeCode.Node => EnsureNodeSet(n), 
				XmlTypeCode.Item => n, 
				_ => null, 
			};
		}

		public QilNode ConvertToString(QilNode n)
		{
			switch (n.XmlType.TypeCode)
			{
			case XmlTypeCode.Boolean:
				if (n.NodeType != QilNodeType.True)
				{
					if (n.NodeType != QilNodeType.False)
					{
						return Conditional(n, String("true"), String("false"));
					}
					return String("false");
				}
				return String("true");
			case XmlTypeCode.Double:
				if (n.NodeType != QilNodeType.LiteralDouble)
				{
					return XsltConvert(n, XmlQueryTypeFactory.StringX);
				}
				return String(XPathConvert.DoubleToString((QilLiteral)n));
			case XmlTypeCode.String:
				return n;
			default:
				if (n.XmlType.IsNode)
				{
					return XPathNodeValue(SafeDocOrderDistinct(n));
				}
				return XsltConvert(n, XmlQueryTypeFactory.StringX);
			}
		}

		public QilNode ConvertToBoolean(QilNode n)
		{
			switch (n.XmlType.TypeCode)
			{
			case XmlTypeCode.Boolean:
				return n;
			case XmlTypeCode.Double:
			{
				QilIterator qilIterator;
				if (n.NodeType != QilNodeType.LiteralDouble)
				{
					return Loop(qilIterator = Let(n), Or(Lt(qilIterator, Double(0.0)), Lt(Double(0.0), qilIterator)));
				}
				return Boolean((double)(QilLiteral)n < 0.0 || 0.0 < (double)(QilLiteral)n);
			}
			case XmlTypeCode.String:
				if (n.NodeType != QilNodeType.LiteralString)
				{
					return Ne(StrLength(n), Int32(0));
				}
				return Boolean(((string)(QilLiteral)n).Length != 0);
			default:
				if (n.XmlType.IsNode)
				{
					return Not(IsEmpty(n));
				}
				return XsltConvert(n, XmlQueryTypeFactory.BooleanX);
			}
		}

		public QilNode ConvertToNumber(QilNode n)
		{
			switch (n.XmlType.TypeCode)
			{
			case XmlTypeCode.Boolean:
				if (n.NodeType != QilNodeType.True)
				{
					if (n.NodeType != QilNodeType.False)
					{
						return Conditional(n, Double(1.0), Double(0.0));
					}
					return Double(0.0);
				}
				return Double(1.0);
			case XmlTypeCode.Double:
				return n;
			case XmlTypeCode.String:
				return XsltConvert(n, XmlQueryTypeFactory.DoubleX);
			default:
				if (n.XmlType.IsNode)
				{
					return XsltConvert(XPathNodeValue(SafeDocOrderDistinct(n)), XmlQueryTypeFactory.DoubleX);
				}
				return XsltConvert(n, XmlQueryTypeFactory.DoubleX);
			}
		}

		public QilNode ConvertToNode(QilNode n)
		{
			if (n.XmlType.IsNode && n.XmlType.IsNotRtf && n.XmlType.IsSingleton)
			{
				return n;
			}
			return XsltConvert(n, XmlQueryTypeFactory.NodeNotRtf);
		}

		public QilNode ConvertToNodeSet(QilNode n)
		{
			if (n.XmlType.IsNode && n.XmlType.IsNotRtf)
			{
				return n;
			}
			return XsltConvert(n, XmlQueryTypeFactory.NodeNotRtfS);
		}

		public QilNode TryEnsureNodeSet(QilNode n)
		{
			if (n.XmlType.IsNode && n.XmlType.IsNotRtf)
			{
				return n;
			}
			if (CannotBeNodeSet(n))
			{
				return null;
			}
			return InvokeEnsureNodeSet(n);
		}

		public QilNode EnsureNodeSet(QilNode n)
		{
			QilNode qilNode = TryEnsureNodeSet(n);
			if (qilNode == null)
			{
				throw new XPathCompileException("XPath_NodeSetExpected");
			}
			return qilNode;
		}

		public QilNode InvokeEnsureNodeSet(QilNode n)
		{
			return XsltInvokeEarlyBound(QName("ensure-node-set"), XsltMethods.EnsureNodeSet, XmlQueryTypeFactory.NodeSDod, new QilNode[1] { n });
		}

		public QilNode Id(QilNode context, QilNode id)
		{
			if (id.XmlType.IsSingleton)
			{
				return Deref(context, ConvertToString(id));
			}
			QilIterator n;
			return Loop(n = For(id), Deref(context, ConvertToString(n)));
		}

		public QilNode InvokeStartsWith(QilNode str1, QilNode str2)
		{
			return XsltInvokeEarlyBound(QName("starts-with"), XsltMethods.StartsWith, XmlQueryTypeFactory.BooleanX, new QilNode[2] { str1, str2 });
		}

		public QilNode InvokeContains(QilNode str1, QilNode str2)
		{
			return XsltInvokeEarlyBound(QName("contains"), XsltMethods.Contains, XmlQueryTypeFactory.BooleanX, new QilNode[2] { str1, str2 });
		}

		public QilNode InvokeSubstringBefore(QilNode str1, QilNode str2)
		{
			return XsltInvokeEarlyBound(QName("substring-before"), XsltMethods.SubstringBefore, XmlQueryTypeFactory.StringX, new QilNode[2] { str1, str2 });
		}

		public QilNode InvokeSubstringAfter(QilNode str1, QilNode str2)
		{
			return XsltInvokeEarlyBound(QName("substring-after"), XsltMethods.SubstringAfter, XmlQueryTypeFactory.StringX, new QilNode[2] { str1, str2 });
		}

		public QilNode InvokeSubstring(QilNode str, QilNode start)
		{
			return XsltInvokeEarlyBound(QName("substring"), XsltMethods.Substring2, XmlQueryTypeFactory.StringX, new QilNode[2] { str, start });
		}

		public QilNode InvokeSubstring(QilNode str, QilNode start, QilNode length)
		{
			return XsltInvokeEarlyBound(QName("substring"), XsltMethods.Substring3, XmlQueryTypeFactory.StringX, new QilNode[3] { str, start, length });
		}

		public QilNode InvokeNormalizeSpace(QilNode str)
		{
			return XsltInvokeEarlyBound(QName("normalize-space"), XsltMethods.NormalizeSpace, XmlQueryTypeFactory.StringX, new QilNode[1] { str });
		}

		public QilNode InvokeTranslate(QilNode str1, QilNode str2, QilNode str3)
		{
			return XsltInvokeEarlyBound(QName("translate"), XsltMethods.Translate, XmlQueryTypeFactory.StringX, new QilNode[3] { str1, str2, str3 });
		}

		public QilNode InvokeLang(QilNode lang, QilNode context)
		{
			return XsltInvokeEarlyBound(QName("lang"), XsltMethods.Lang, XmlQueryTypeFactory.BooleanX, new QilNode[2] { lang, context });
		}

		public QilNode InvokeFloor(QilNode value)
		{
			return XsltInvokeEarlyBound(QName("floor"), XsltMethods.Floor, XmlQueryTypeFactory.DoubleX, new QilNode[1] { value });
		}

		public QilNode InvokeCeiling(QilNode value)
		{
			return XsltInvokeEarlyBound(QName("ceiling"), XsltMethods.Ceiling, XmlQueryTypeFactory.DoubleX, new QilNode[1] { value });
		}

		public QilNode InvokeRound(QilNode value)
		{
			return XsltInvokeEarlyBound(QName("round"), XsltMethods.Round, XmlQueryTypeFactory.DoubleX, new QilNode[1] { value });
		}
	}
	internal enum LexKind
	{
		Unknown = 0,
		Or = 1,
		And = 2,
		Eq = 3,
		Ne = 4,
		Lt = 5,
		Le = 6,
		Gt = 7,
		Ge = 8,
		Plus = 9,
		Minus = 10,
		Multiply = 11,
		Divide = 12,
		Modulo = 13,
		UnaryMinus = 14,
		Union = 15,
		LastOperator = 15,
		DotDot = 16,
		ColonColon = 17,
		SlashSlash = 18,
		Number = 19,
		Axis = 20,
		Name = 21,
		String = 22,
		Eof = 23,
		FirstStringable = 21,
		LastNonChar = 23,
		LParens = 40,
		RParens = 41,
		LBracket = 91,
		RBracket = 93,
		Dot = 46,
		At = 64,
		Comma = 44,
		Star = 42,
		Slash = 47,
		Dollar = 36,
		RBrace = 125
	}
	internal sealed class XPathScanner
	{
		private string xpathExpr;

		private int curIndex;

		private char curChar;

		private LexKind kind;

		private string name;

		private string prefix;

		private string stringValue;

		private bool canBeFunction;

		private int lexStart;

		private int prevLexEnd;

		private LexKind prevKind;

		private XPathAxis axis;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		public string Source => xpathExpr;

		public LexKind Kind => kind;

		public int LexStart => lexStart;

		public int LexSize => curIndex - lexStart;

		public int PrevLexEnd => prevLexEnd;

		public string Name => name;

		public string Prefix => prefix;

		public string RawValue
		{
			get
			{
				if (kind == LexKind.Eof)
				{
					return LexKindToString(kind);
				}
				return xpathExpr.Substring(lexStart, curIndex - lexStart);
			}
		}

		public string StringValue => stringValue;

		public bool CanBeFunction => canBeFunction;

		public XPathAxis Axis => axis;

		public XPathScanner(string xpathExpr)
			: this(xpathExpr, 0)
		{
		}

		public XPathScanner(string xpathExpr, int startFrom)
		{
			this.xpathExpr = xpathExpr;
			kind = LexKind.Unknown;
			SetSourceIndex(startFrom);
			NextLex();
		}

		private void SetSourceIndex(int index)
		{
			curIndex = index - 1;
			NextChar();
		}

		private void NextChar()
		{
			curIndex++;
			if (curIndex < xpathExpr.Length)
			{
				curChar = xpathExpr[curIndex];
			}
			else
			{
				curChar = '\0';
			}
		}

		private void SkipSpace()
		{
			while (xmlCharType.IsWhiteSpace(curChar))
			{
				NextChar();
			}
		}

		private static bool IsAsciiDigit(char ch)
		{
			return (uint)(ch - 48) <= 9u;
		}

		public void NextLex()
		{
			prevLexEnd = curIndex;
			prevKind = kind;
			SkipSpace();
			lexStart = curIndex;
			switch (curChar)
			{
			case '\0':
				kind = LexKind.Eof;
				return;
			case '$':
			case '(':
			case ')':
			case ',':
			case '@':
			case '[':
			case ']':
			case '}':
				kind = (LexKind)curChar;
				NextChar();
				return;
			case '.':
				NextChar();
				if (curChar == '.')
				{
					kind = LexKind.DotDot;
					NextChar();
					return;
				}
				if (IsAsciiDigit(curChar))
				{
					SetSourceIndex(lexStart);
					goto case '0';
				}
				kind = LexKind.Dot;
				return;
			case ':':
				NextChar();
				if (curChar == ':')
				{
					kind = LexKind.ColonColon;
					NextChar();
				}
				else
				{
					kind = LexKind.Unknown;
				}
				return;
			case '*':
				kind = LexKind.Star;
				NextChar();
				CheckOperator(star: true);
				return;
			case '/':
				NextChar();
				if (curChar == '/')
				{
					kind = LexKind.SlashSlash;
					NextChar();
				}
				else
				{
					kind = LexKind.Slash;
				}
				return;
			case '|':
				kind = LexKind.Union;
				NextChar();
				return;
			case '+':
				kind = LexKind.Plus;
				NextChar();
				return;
			case '-':
				kind = LexKind.Minus;
				NextChar();
				return;
			case '=':
				kind = LexKind.Eq;
				NextChar();
				return;
			case '!':
				NextChar();
				if (curChar == '=')
				{
					kind = LexKind.Ne;
					NextChar();
				}
				else
				{
					kind = LexKind.Unknown;
				}
				return;
			case '<':
				NextChar();
				if (curChar == '=')
				{
					kind = LexKind.Le;
					NextChar();
				}
				else
				{
					kind = LexKind.Lt;
				}
				return;
			case '>':
				NextChar();
				if (curChar == '=')
				{
					kind = LexKind.Ge;
					NextChar();
				}
				else
				{
					kind = LexKind.Gt;
				}
				return;
			case '"':
			case '\'':
				kind = LexKind.String;
				ScanString();
				return;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				kind = LexKind.Number;
				ScanNumber();
				return;
			}
			if (xmlCharType.IsStartNCNameSingleChar(curChar))
			{
				kind = LexKind.Name;
				name = ScanNCName();
				prefix = string.Empty;
				canBeFunction = false;
				axis = XPathAxis.Unknown;
				bool flag = false;
				int sourceIndex = curIndex;
				if (curChar == ':')
				{
					NextChar();
					if (curChar == ':')
					{
						NextChar();
						flag = true;
						SetSourceIndex(sourceIndex);
					}
					else if (curChar == '*')
					{
						NextChar();
						prefix = name;
						name = "*";
					}
					else if (xmlCharType.IsStartNCNameSingleChar(curChar))
					{
						prefix = name;
						name = ScanNCName();
						sourceIndex = curIndex;
						SkipSpace();
						canBeFunction = curChar == '(';
						SetSourceIndex(sourceIndex);
					}
					else
					{
						SetSourceIndex(sourceIndex);
					}
				}
				else
				{
					SkipSpace();
					if (curChar == ':')
					{
						NextChar();
						if (curChar == ':')
						{
							NextChar();
							flag = true;
						}
						SetSourceIndex(sourceIndex);
					}
					else
					{
						canBeFunction = curChar == '(';
					}
				}
				if (!CheckOperator(star: false) && flag)
				{
					axis = CheckAxis();
				}
			}
			else
			{
				kind = LexKind.Unknown;
				NextChar();
			}
		}

		private bool CheckOperator(bool star)
		{
			LexKind lexKind;
			if (star)
			{
				lexKind = LexKind.Multiply;
			}
			else
			{
				if (prefix.Length != 0 || name.Length > 3)
				{
					return false;
				}
				switch (name)
				{
				case "or":
					lexKind = LexKind.Or;
					break;
				case "and":
					lexKind = LexKind.And;
					break;
				case "div":
					lexKind = LexKind.Divide;
					break;
				case "mod":
					lexKind = LexKind.Modulo;
					break;
				default:
					return false;
				}
			}
			if (prevKind <= LexKind.Union)
			{
				return false;
			}
			switch (prevKind)
			{
			case LexKind.ColonColon:
			case LexKind.SlashSlash:
			case LexKind.Dollar:
			case LexKind.LParens:
			case LexKind.Comma:
			case LexKind.Slash:
			case LexKind.At:
			case LexKind.LBracket:
				return false;
			default:
				kind = lexKind;
				return true;
			}
		}

		private XPathAxis CheckAxis()
		{
			kind = LexKind.Axis;
			switch (name)
			{
			case "ancestor":
				return XPathAxis.Ancestor;
			case "ancestor-or-self":
				return XPathAxis.AncestorOrSelf;
			case "attribute":
				return XPathAxis.Attribute;
			case "child":
				return XPathAxis.Child;
			case "descendant":
				return XPathAxis.Descendant;
			case "descendant-or-self":
				return XPathAxis.DescendantOrSelf;
			case "following":
				return XPathAxis.Following;
			case "following-sibling":
				return XPathAxis.FollowingSibling;
			case "namespace":
				return XPathAxis.Namespace;
			case "parent":
				return XPathAxis.Parent;
			case "preceding":
				return XPathAxis.Preceding;
			case "preceding-sibling":
				return XPathAxis.PrecedingSibling;
			case "self":
				return XPathAxis.Self;
			default:
				kind = LexKind.Name;
				return XPathAxis.Unknown;
			}
		}

		private void ScanNumber()
		{
			while (IsAsciiDigit(curChar))
			{
				NextChar();
			}
			if (curChar == '.')
			{
				NextChar();
				while (IsAsciiDigit(curChar))
				{
					NextChar();
				}
			}
			if ((curChar & -33) == 69)
			{
				NextChar();
				if (curChar == '+' || curChar == '-')
				{
					NextChar();
				}
				while (IsAsciiDigit(curChar))
				{
					NextChar();
				}
				throw CreateException("XPath_ScientificNotation");
			}
		}

		private void ScanString()
		{
			int num = curIndex + 1;
			int num2 = xpathExpr.IndexOf(curChar, num);
			if (num2 < 0)
			{
				SetSourceIndex(xpathExpr.Length);
				throw CreateException("XPath_UnclosedString");
			}
			stringValue = xpathExpr.Substring(num, num2 - num);
			SetSourceIndex(num2 + 1);
		}

		private string ScanNCName()
		{
			int num = curIndex;
			while (xmlCharType.IsNCNameSingleChar(curChar))
			{
				NextChar();
			}
			return xpathExpr.Substring(num, curIndex - num);
		}

		public void PassToken(LexKind t)
		{
			CheckToken(t);
			NextLex();
		}

		public void CheckToken(LexKind t)
		{
			if (kind != t)
			{
				if (t == LexKind.Eof)
				{
					throw CreateException("XPath_EofExpected", RawValue);
				}
				throw CreateException("XPath_TokenExpected", LexKindToString(t), RawValue);
			}
		}

		private string LexKindToString(LexKind t)
		{
			if (LexKind.Eof < t)
			{
				return new string((char)t, 1);
			}
			return t switch
			{
				LexKind.Name => "<name>", 
				LexKind.String => "<string literal>", 
				LexKind.Eof => "<eof>", 
				_ => string.Empty, 
			};
		}

		public XPathCompileException CreateException(string resId, params string[] args)
		{
			return new XPathCompileException(xpathExpr, lexStart, curIndex, resId, args);
		}
	}
}
namespace System.Xml.Xsl.Runtime
{
	/// <summary>Iterates over all child content nodes of the current node.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct ContentIterator
	{
		private XPathNavigator navCurrent;

		private bool needFirst;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.ContentIterator" />.</summary>
		/// <param name="context">The node from which you start traversing the child content nodes.</param>
		public void Create(XPathNavigator context)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			needFirst = true;
		}

		/// <summary>Positions the iterator on the next child content node.</summary>
		/// <returns>
		///   <see langword="true" /> if the next child content node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (needFirst)
			{
				needFirst = !navCurrent.MoveToFirstChild();
				return !needFirst;
			}
			return navCurrent.MoveToNext();
		}
	}
	/// <summary>Iterates over all child elements with a matching name.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct ElementContentIterator
	{
		private string localName;

		private string ns;

		private XPathNavigator navCurrent;

		private bool needFirst;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.ElementContentIterator" />.</summary>
		/// <param name="context">The node from which you start traversing child elements.</param>
		/// <param name="localName">The local name.</param>
		/// <param name="ns">The namespace.</param>
		public void Create(XPathNavigator context, string localName, string ns)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			this.localName = localName;
			this.ns = ns;
			needFirst = true;
		}

		/// <summary>Positions the iterator on the next child element with a matching name.</summary>
		/// <returns>
		///   <see langword="true" /> if the iterator was set to the next child element with the matching name; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (needFirst)
			{
				needFirst = !navCurrent.MoveToChild(localName, ns);
				return !needFirst;
			}
			return navCurrent.MoveToNext(localName, ns);
		}
	}
	/// <summary>Iterates over all child content nodes with a matching node kind.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct NodeKindContentIterator
	{
		private XPathNodeType nodeType;

		private XPathNavigator navCurrent;

		private bool needFirst;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.NodeKindContentIterator" />.</summary>
		/// <param name="context">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		/// <param name="nodeType">
		///   <see cref="T:System.Xml.XPath.XPathNodeType" /> object.</param>
		public void Create(XPathNavigator context, XPathNodeType nodeType)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			this.nodeType = nodeType;
			needFirst = true;
		}

		/// <summary>Positions the iterator on the next child content node with a matching node kind.</summary>
		/// <returns>
		///   <see langword="true" /> if the next child content node with a matching node kind exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (needFirst)
			{
				needFirst = !navCurrent.MoveToChild(nodeType);
				return !needFirst;
			}
			return navCurrent.MoveToNext(nodeType);
		}
	}
	/// <summary>Iterates over all the attributes.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct AttributeIterator
	{
		private XPathNavigator navCurrent;

		private bool needFirst;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.AttributeIterator" />.</summary>
		/// <param name="context">The node from which you start traversing the attribute nodes.</param>
		public void Create(XPathNavigator context)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			needFirst = true;
		}

		/// <summary>Positions the iterator on the next attribute node.</summary>
		/// <returns>
		///   <see langword="true" /> if the next attribute node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (needFirst)
			{
				needFirst = !navCurrent.MoveToFirstAttribute();
				return !needFirst;
			}
			return navCurrent.MoveToNextAttribute();
		}
	}
	/// <summary>Iterate over all namespace nodes.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct NamespaceIterator
	{
		private XPathNavigator navCurrent;

		private XmlNavigatorStack navStack;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.NamespaceIterator" />.</summary>
		/// <param name="context">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> that identifies the <see cref="T:System.Xml.Xsl.XsltContext" />.</param>
		public void Create(XPathNavigator context)
		{
			navStack.Reset();
			if (!context.MoveToFirstNamespace(XPathNamespaceScope.All))
			{
				return;
			}
			do
			{
				if (context.LocalName.Length != 0 || context.Value.Length != 0)
				{
					navStack.Push(context.Clone());
				}
			}
			while (context.MoveToNextNamespace(XPathNamespaceScope.All));
			context.MoveToParent();
		}

		/// <summary>Positions the iterator on the next namespace node.</summary>
		/// <returns>
		///   <see langword="true" /> if the next namespace node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (navStack.IsEmpty)
			{
				return false;
			}
			navCurrent = navStack.Pop();
			return true;
		}
	}
	/// <summary>Iterates over all attributes and child content nodes.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct AttributeContentIterator
	{
		private XPathNavigator navCurrent;

		private bool needFirst;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.AttributeContentIterator" />.</summary>
		/// <param name="context">The node from which you start traversing attribute and child content nodes.</param>
		public void Create(XPathNavigator context)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			needFirst = true;
		}

		/// <summary>Positions the iterator on the next attribute or child content node.</summary>
		/// <returns>
		///   <see langword="true" /> if the next attribute or child content node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (needFirst)
			{
				needFirst = !XmlNavNeverFilter.MoveToFirstAttributeContent(navCurrent);
				return !needFirst;
			}
			return XmlNavNeverFilter.MoveToNextAttributeContent(navCurrent);
		}
	}
	/// <summary>Iterates over child content nodes or following sibling nodes. Maintains the nodes in document order.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct ContentMergeIterator
	{
		private enum IteratorState
		{
			NeedCurrent,
			HaveCurrentNeedNext,
			HaveCurrentNoNext,
			HaveCurrentHaveNext
		}

		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XPathNavigator navNext;

		private XmlNavigatorStack navStack;

		private IteratorState state;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.ContentMergeIterator" />. Merges multiple sets of content nodes in document order and removes duplicates.</summary>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class, which enables you to filter nodes based on name.</param>
		public void Create(XmlNavigatorFilter filter)
		{
			this.filter = filter;
			navStack.Reset();
			state = IteratorState.NeedCurrent;
		}

		/// <summary>Positions the iterator on the next content or sibling node.</summary>
		/// <param name="input">The input nodes.</param>
		/// <returns>Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.NoMoreNodes" /> if there are no more content or sibling nodes. Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.NeedInputNode" /> if the next input node must be fetched first. Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.HaveCurrentNode" /> if the <see cref="P:System.Xml.Xsl.Runtime.ContentMergeIterator.Current" /> property was set to the next node while iterating through the nodes.</returns>
		public IteratorResult MoveNext(XPathNavigator input)
		{
			return MoveNext(input, isContent: true);
		}

		internal IteratorResult MoveNext(XPathNavigator input, bool isContent)
		{
			switch (state)
			{
			case IteratorState.NeedCurrent:
				if (input == null)
				{
					return IteratorResult.NoMoreNodes;
				}
				navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
				if (isContent ? filter.MoveToContent(navCurrent) : filter.MoveToFollowingSibling(navCurrent))
				{
					state = IteratorState.HaveCurrentNeedNext;
				}
				return IteratorResult.NeedInputNode;
			case IteratorState.HaveCurrentNeedNext:
				if (input == null)
				{
					state = IteratorState.HaveCurrentNoNext;
					return IteratorResult.HaveCurrentNode;
				}
				navNext = XmlQueryRuntime.SyncToNavigator(navNext, input);
				if (isContent ? filter.MoveToContent(navNext) : filter.MoveToFollowingSibling(navNext))
				{
					state = IteratorState.HaveCurrentHaveNext;
					return DocOrderMerge();
				}
				return IteratorResult.NeedInputNode;
			case IteratorState.HaveCurrentNoNext:
			case IteratorState.HaveCurrentHaveNext:
				if (isContent ? (!filter.MoveToNextContent(navCurrent)) : (!filter.MoveToFollowingSibling(navCurrent)))
				{
					if (navStack.IsEmpty)
					{
						if (state == IteratorState.HaveCurrentNoNext)
						{
							return IteratorResult.NoMoreNodes;
						}
						navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, navNext);
						state = IteratorState.HaveCurrentNeedNext;
						return IteratorResult.NeedInputNode;
					}
					navCurrent = navStack.Pop();
				}
				if (state == IteratorState.HaveCurrentNoNext)
				{
					return IteratorResult.HaveCurrentNode;
				}
				return DocOrderMerge();
			default:
				return IteratorResult.NoMoreNodes;
			}
		}

		private IteratorResult DocOrderMerge()
		{
			switch (navCurrent.ComparePosition(navNext))
			{
			case XmlNodeOrder.Before:
			case XmlNodeOrder.Unknown:
				return IteratorResult.HaveCurrentNode;
			case XmlNodeOrder.After:
				navStack.Push(navCurrent);
				navCurrent = navNext;
				navNext = null;
				break;
			}
			state = IteratorState.HaveCurrentNeedNext;
			return IteratorResult.NeedInputNode;
		}
	}
	internal class DecimalFormat
	{
		public NumberFormatInfo info;

		public char digit;

		public char zeroDigit;

		public char patternSeparator;

		internal DecimalFormat(NumberFormatInfo info, char digit, char zeroDigit, char patternSeparator)
		{
			this.info = info;
			this.digit = digit;
			this.zeroDigit = zeroDigit;
			this.patternSeparator = patternSeparator;
		}
	}
	internal class DecimalFormatter
	{
		private NumberFormatInfo posFormatInfo;

		private NumberFormatInfo negFormatInfo;

		private string posFormat;

		private string negFormat;

		private char zeroDigit;

		private const string ClrSpecialChars = "0#.,%‰Ee\\'\";";

		private const char EscChar = '\a';

		public DecimalFormatter(string formatPicture, DecimalFormat decimalFormat)
		{
			if (formatPicture.Length == 0)
			{
				throw XsltException.Create("Xslt_InvalidFormat");
			}
			zeroDigit = decimalFormat.zeroDigit;
			posFormatInfo = (NumberFormatInfo)decimalFormat.info.Clone();
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			bool flag6 = false;
			char c = posFormatInfo.NumberDecimalSeparator[0];
			char c2 = posFormatInfo.NumberGroupSeparator[0];
			char c3 = posFormatInfo.PercentSymbol[0];
			char c4 = posFormatInfo.PerMilleSymbol[0];
			int num = 0;
			int num2 = 0;
			int num3 = -1;
			int num4 = -1;
			for (int i = 0; i < formatPicture.Length; i++)
			{
				char c5 = formatPicture[i];
				if (c5 == decimalFormat.digit)
				{
					if (flag3 && flag)
					{
						throw XsltException.Create("Xslt_InvalidFormat1", formatPicture);
					}
					num4 = stringBuilder.Length;
					flag4 = (flag6 = true);
					stringBuilder.Append('#');
				}
				else if (c5 == decimalFormat.zeroDigit)
				{
					if (flag4 && !flag)
					{
						throw XsltException.Create("Xslt_InvalidFormat2", formatPicture);
					}
					num4 = stringBuilder.Length;
					flag3 = (flag6 = true);
					stringBuilder.Append('0');
				}
				else if (c5 == decimalFormat.patternSeparator)
				{
					if (!flag6)
					{
						throw XsltException.Create("Xslt_InvalidFormat8");
					}
					if (flag2)
					{
						throw XsltException.Create("Xslt_InvalidFormat3", formatPicture);
					}
					flag2 = true;
					if (num3 < 0)
					{
						num3 = num4 + 1;
					}
					num2 = RemoveTrailingComma(stringBuilder, num, num3);
					if (num2 > 9)
					{
						num2 = 0;
					}
					posFormatInfo.NumberGroupSizes = new int[1] { num2 };
					if (!flag5)
					{
						posFormatInfo.NumberDecimalDigits = 0;
					}
					posFormat = stringBuilder.ToString();
					stringBuilder.Length = 0;
					num3 = -1;
					num4 = -1;
					num = 0;
					flag4 = (flag3 = (flag6 = false));
					flag5 = false;
					flag = true;
					negFormatInfo = (NumberFormatInfo)decimalFormat.info.Clone();
					negFormatInfo.NegativeSign = string.Empty;
				}
				else if (c5 == c)
				{
					if (flag5)
					{
						throw XsltException.Create("Xslt_InvalidFormat5", formatPicture);
					}
					num3 = stringBuilder.Length;
					flag5 = true;
					flag4 = (flag3 = (flag = false));
					stringBuilder.Append('.');
				}
				else if (c5 == c2)
				{
					num = stringBuilder.Length;
					num4 = num;
					stringBuilder.Append(',');
				}
				else if (c5 == c3)
				{
					stringBuilder.Append('%');
				}
				else if (c5 == c4)
				{
					stringBuilder.Append('‰');
				}
				else if (c5 == '\'')
				{
					int num5 = formatPicture.IndexOf('\'', i + 1);
					if (num5 < 0)
					{
						num5 = formatPicture.Length - 1;
					}
					stringBuilder.Append(formatPicture, i, num5 - i + 1);
					i = num5;
				}
				else
				{
					if ((('0' <= c5 && c5 <= '9') || c5 == '\a') && decimalFormat.zeroDigit != '0')
					{
						stringBuilder.Append('\a');
					}
					if ("0#.,%‰Ee\\'\";".IndexOf(c5) >= 0)
					{
						stringBuilder.Append('\\');
					}
					stringBuilder.Append(c5);
				}
			}
			if (!flag6)
			{
				throw XsltException.Create("Xslt_InvalidFormat8");
			}
			NumberFormatInfo numberFormatInfo = (flag2 ? negFormatInfo : posFormatInfo);
			if (num3 < 0)
			{
				num3 = num4 + 1;
			}
			num2 = RemoveTrailingComma(stringBuilder, num, num3);
			if (num2 > 9)
			{
				num2 = 0;
			}
			numberFormatInfo.NumberGroupSizes = new int[1] { num2 };
			if (!flag5)
			{
				numberFormatInfo.NumberDecimalDigits = 0;
			}
			if (flag2)
			{
				negFormat = stringBuilder.ToString();
			}
			else
			{
				posFormat = stringBuilder.ToString();
			}
		}

		private static int RemoveTrailingComma(StringBuilder builder, int commaIndex, int decimalIndex)
		{
			if (commaIndex > 0 && commaIndex == decimalIndex - 1)
			{
				builder.Remove(decimalIndex - 1, 1);
			}
			else if (decimalIndex > commaIndex)
			{
				return decimalIndex - commaIndex - 1;
			}
			return 0;
		}

		public string Format(double value)
		{
			NumberFormatInfo numberFormatInfo;
			string text;
			if (value < 0.0 && negFormatInfo != null)
			{
				numberFormatInfo = negFormatInfo;
				text = negFormat;
			}
			else
			{
				numberFormatInfo = posFormatInfo;
				text = posFormat;
			}
			string text2 = value.ToString(text, numberFormatInfo);
			if (zeroDigit != '0')
			{
				StringBuilder stringBuilder = new StringBuilder(text2.Length);
				int num = zeroDigit - 48;
				for (int i = 0; i < text2.Length; i++)
				{
					char c = text2[i];
					switch (c)
					{
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						c = (char)(c + (ushort)num);
						break;
					case '\a':
						c = text2[++i];
						break;
					}
					stringBuilder.Append(c);
				}
				text2 = stringBuilder.ToString();
			}
			return text2;
		}

		public static string Format(double value, string formatPicture, DecimalFormat decimalFormat)
		{
			return new DecimalFormatter(formatPicture, decimalFormat).Format(value);
		}
	}
	internal class DocumentOrderComparer : IComparer<XPathNavigator>
	{
		private List<XPathNavigator> roots;

		public int Compare(XPathNavigator navThis, XPathNavigator navThat)
		{
			switch (navThis.ComparePosition(navThat))
			{
			case XmlNodeOrder.Before:
				return -1;
			case XmlNodeOrder.Same:
				return 0;
			case XmlNodeOrder.After:
				return 1;
			default:
				if (roots == null)
				{
					roots = new List<XPathNavigator>();
				}
				if (GetDocumentIndex(navThis) >= GetDocumentIndex(navThat))
				{
					return 1;
				}
				return -1;
			}
		}

		public int GetDocumentIndex(XPathNavigator nav)
		{
			if (roots == null)
			{
				roots = new List<XPathNavigator>();
			}
			XPathNavigator xPathNavigator = nav.Clone();
			xPathNavigator.MoveToRoot();
			for (int i = 0; i < roots.Count; i++)
			{
				if (xPathNavigator.IsSamePosition(roots[i]))
				{
					return i;
				}
			}
			roots.Add(xPathNavigator);
			return roots.Count - 1;
		}
	}
	/// <summary>Merges several doc-order-distinct sequences into a single doc-order-distinct sequence.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DodSequenceMerge
	{
		private IList<XPathNavigator> firstSequence;

		private List<IEnumerator<XPathNavigator>> sequencesToMerge;

		private int nodeCount;

		private XmlQueryRuntime runtime;

		/// <summary>Initializes this instance of <see cref="T:System.Xml.Xsl.Runtime.DodSequenceMerge" /> .</summary>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class, which provides methods and properties to support the XSLT processor.</param>
		public void Create(XmlQueryRuntime runtime)
		{
			firstSequence = null;
			sequencesToMerge = null;
			nodeCount = 0;
			this.runtime = runtime;
		}

		/// <summary>Adds a new sequence to the list of sequences to merge.</summary>
		/// <param name="sequence">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		public void AddSequence(IList<XPathNavigator> sequence)
		{
			if (sequence.Count == 0)
			{
				return;
			}
			if (firstSequence == null)
			{
				firstSequence = sequence;
				return;
			}
			if (sequencesToMerge == null)
			{
				sequencesToMerge = new List<IEnumerator<XPathNavigator>>();
				MoveAndInsertSequence(firstSequence.GetEnumerator());
				nodeCount = firstSequence.Count;
			}
			MoveAndInsertSequence(sequence.GetEnumerator());
			nodeCount += sequence.Count;
		}

		/// <summary>Returns the fully-merged sequence.</summary>
		/// <returns>The fully-merged sequence.</returns>
		public IList<XPathNavigator> MergeSequences()
		{
			if (firstSequence == null)
			{
				return XmlQueryNodeSequence.Empty;
			}
			if (sequencesToMerge == null || sequencesToMerge.Count <= 1)
			{
				return firstSequence;
			}
			XmlQueryNodeSequence xmlQueryNodeSequence = new XmlQueryNodeSequence(nodeCount);
			while (sequencesToMerge.Count != 1)
			{
				IEnumerator<XPathNavigator> enumerator = sequencesToMerge[sequencesToMerge.Count - 1];
				sequencesToMerge.RemoveAt(sequencesToMerge.Count - 1);
				xmlQueryNodeSequence.Add(enumerator.Current);
				MoveAndInsertSequence(enumerator);
			}
			do
			{
				xmlQueryNodeSequence.Add(sequencesToMerge[0].Current);
			}
			while (sequencesToMerge[0].MoveNext());
			return xmlQueryNodeSequence;
		}

		private void MoveAndInsertSequence(IEnumerator<XPathNavigator> sequence)
		{
			if (sequence.MoveNext())
			{
				InsertSequence(sequence);
			}
		}

		private void InsertSequence(IEnumerator<XPathNavigator> sequence)
		{
			for (int num = sequencesToMerge.Count - 1; num >= 0; num--)
			{
				switch (runtime.ComparePosition(sequence.Current, sequencesToMerge[num].Current))
				{
				case -1:
					sequencesToMerge.Insert(num + 1, sequence);
					return;
				case 0:
					if (!sequence.MoveNext())
					{
						return;
					}
					break;
				}
			}
			sequencesToMerge.Insert(0, sequence);
		}
	}
	internal sealed class EarlyBoundInfo
	{
		private string namespaceUri;

		private ConstructorInfo constrInfo;

		public string NamespaceUri => namespaceUri;

		public Type EarlyBoundType => constrInfo.DeclaringType;

		public EarlyBoundInfo(string namespaceUri, Type ebType)
		{
			this.namespaceUri = namespaceUri;
			constrInfo = ebType.GetConstructor(Type.EmptyTypes);
		}

		public object CreateObject()
		{
			return constrInfo.Invoke(new object[0]);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is EarlyBoundInfo earlyBoundInfo))
			{
				return false;
			}
			if (namespaceUri == earlyBoundInfo.namespaceUri)
			{
				return constrInfo == earlyBoundInfo.constrInfo;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return namespaceUri.GetHashCode();
		}
	}
	internal static class CharUtil
	{
		public static bool IsAlphaNumeric(char ch)
		{
			int unicodeCategory = (int)char.GetUnicodeCategory(ch);
			if (unicodeCategory > 4)
			{
				if (unicodeCategory <= 10)
				{
					return unicodeCategory >= 8;
				}
				return false;
			}
			return true;
		}

		public static bool IsDecimalDigitOne(char ch)
		{
			int unicodeCategory = (int)char.GetUnicodeCategory(ch = (char)(ch - 1));
			if (unicodeCategory == 8)
			{
				return char.GetNumericValue(ch) == 0.0;
			}
			return false;
		}
	}
	internal enum NumberingSequence
	{
		Nil = -1,
		FirstDecimal = 0,
		Arabic = 0,
		DArabic = 1,
		Hindi3 = 2,
		Thai2 = 3,
		FEDecimal = 4,
		KorDbNum1 = 5,
		LastNum = 5,
		FirstAlpha = 6,
		UCLetter = 6,
		LCLetter = 7,
		UCRus = 8,
		LCRus = 9,
		Thai1 = 10,
		Hindi1 = 11,
		Hindi2 = 12,
		Aiueo = 13,
		DAiueo = 14,
		Iroha = 15,
		DIroha = 16,
		DChosung = 17,
		Ganada = 18,
		ArabicScript = 19,
		LastAlpha = 19,
		FirstSpecial = 20,
		UCRoman = 20,
		LCRoman = 21,
		Hebrew = 22,
		DbNum3 = 23,
		ChnCmplx = 24,
		KorDbNum3 = 25,
		Zodiac1 = 26,
		Zodiac2 = 27,
		Zodiac3 = 28,
		LastSpecial = 28
	}
	internal class NumberFormatterBase
	{
		protected const int MaxAlphabeticValue = int.MaxValue;

		private const int MaxAlphabeticLength = 7;

		protected const int MaxRomanValue = 32767;

		private const string RomanDigitsUC = "IIVIXXLXCCDCM";

		private const string RomanDigitsLC = "iivixxlxccdcm";

		private static readonly int[] RomanDigitValue = new int[13]
		{
			1, 4, 5, 9, 10, 40, 50, 90, 100, 400,
			500, 900, 1000
		};

		private const string hiraganaAiueo = "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん";

		private const string hiraganaIroha = "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす";

		private const string katakanaAiueo = "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン";

		private const string katakanaIroha = "イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセスン";

		private const string katakanaAiueoHw = "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜｦﾝ";

		private const string katakanaIrohaHw = "ｲﾛﾊﾆﾎﾍﾄﾁﾘﾇﾙｦﾜｶﾖﾀﾚｿﾂﾈﾅﾗﾑｳヰﾉｵｸﾔﾏｹﾌｺｴﾃｱｻｷﾕﾒﾐｼヱﾋﾓｾｽﾝ";

		private const string cjkIdeographic = "〇一二三四五六七八九";

		public static void ConvertToAlphabetic(StringBuilder sb, double val, char firstChar, int totalChars)
		{
			char[] array = new char[7];
			int num = 7;
			int num2 = (int)val;
			while (num2 > totalChars)
			{
				int num3 = --num2 / totalChars;
				array[--num] = (char)(firstChar + (num2 - num3 * totalChars));
				num2 = num3;
			}
			array[--num] = (char)(firstChar + --num2);
			sb.Append(array, num, 7 - num);
		}

		public static void ConvertToRoman(StringBuilder sb, double val, bool upperCase)
		{
			int num = (int)val;
			string value = (upperCase ? "IIVIXXLXCCDCM" : "iivixxlxccdcm");
			int num2 = RomanDigitValue.Length;
			while (num2-- != 0)
			{
				while (num >= RomanDigitValue[num2])
				{
					num -= RomanDigitValue[num2];
					sb.Append(value, num2, 1 + (num2 & 1));
				}
			}
		}
	}
	internal abstract class RtfNavigator : XPathNavigator
	{
		public override XPathNodeType NodeType => XPathNodeType.Root;

		public override string LocalName => string.Empty;

		public override string NamespaceURI => string.Empty;

		public override string Name => string.Empty;

		public override string Prefix => string.Empty;

		public override bool IsEmptyElement => false;

		public override XmlNameTable NameTable
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public abstract void CopyToWriter(XmlWriter writer);

		public abstract XPathNavigator ToNavigator();

		public override bool MoveToFirstAttribute()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToNextAttribute()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope)
		{
			throw new NotSupportedException();
		}

		public override bool MoveToNextNamespace(XPathNamespaceScope namespaceScope)
		{
			throw new NotSupportedException();
		}

		public override bool MoveToNext()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToPrevious()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToFirstChild()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToParent()
		{
			throw new NotSupportedException();
		}

		public override bool MoveToId(string id)
		{
			throw new NotSupportedException();
		}

		public override bool IsSamePosition(XPathNavigator other)
		{
			throw new NotSupportedException();
		}
	}
	internal sealed class RtfTreeNavigator : RtfNavigator
	{
		private XmlEventCache events;

		private NavigatorConstructor constr;

		private XmlNameTable nameTable;

		public override string Value => events.EventsToString();

		public override string BaseURI => events.BaseUri;

		public RtfTreeNavigator(XmlEventCache events, XmlNameTable nameTable)
		{
			this.events = events;
			constr = new NavigatorConstructor();
			this.nameTable = nameTable;
		}

		public RtfTreeNavigator(RtfTreeNavigator that)
		{
			events = that.events;
			constr = that.constr;
			nameTable = that.nameTable;
		}

		public override void CopyToWriter(XmlWriter writer)
		{
			events.EventsToWriter(writer);
		}

		public override XPathNavigator ToNavigator()
		{
			return constr.GetNavigator(events, nameTable);
		}

		public override XPathNavigator Clone()
		{
			return new RtfTreeNavigator(this);
		}

		public override bool MoveTo(XPathNavigator other)
		{
			if (other is RtfTreeNavigator rtfTreeNavigator)
			{
				events = rtfTreeNavigator.events;
				constr = rtfTreeNavigator.constr;
				nameTable = rtfTreeNavigator.nameTable;
				return true;
			}
			return false;
		}
	}
	internal sealed class RtfTextNavigator : RtfNavigator
	{
		private string text;

		private string baseUri;

		private NavigatorConstructor constr;

		public override string Value => text;

		public override string BaseURI => baseUri;

		public RtfTextNavigator(string text, string baseUri)
		{
			this.text = text;
			this.baseUri = baseUri;
			constr = new NavigatorConstructor();
		}

		public RtfTextNavigator(RtfTextNavigator that)
		{
			text = that.text;
			baseUri = that.baseUri;
			constr = that.constr;
		}

		public override void CopyToWriter(XmlWriter writer)
		{
			writer.WriteString(Value);
		}

		public override XPathNavigator ToNavigator()
		{
			return constr.GetNavigator(text, baseUri, new NameTable());
		}

		public override XPathNavigator Clone()
		{
			return new RtfTextNavigator(this);
		}

		public override bool MoveTo(XPathNavigator other)
		{
			if (other is RtfTextNavigator rtfTextNavigator)
			{
				text = rtfTextNavigator.text;
				baseUri = rtfTextNavigator.baseUri;
				constr = rtfTextNavigator.constr;
				return true;
			}
			return false;
		}
	}
	internal sealed class NavigatorConstructor
	{
		private object cache;

		public XPathNavigator GetNavigator(XmlEventCache events, XmlNameTable nameTable)
		{
			if (cache == null)
			{
				XPathDocument xPathDocument = new XPathDocument(nameTable);
				XmlRawWriter xmlRawWriter = xPathDocument.LoadFromWriter(XPathDocument.LoadFlags.AtomizeNames | ((!events.HasRootNode) ? XPathDocument.LoadFlags.Fragment : XPathDocument.LoadFlags.None), events.BaseUri);
				events.EventsToWriter(xmlRawWriter);
				xmlRawWriter.Close();
				cache = xPathDocument;
			}
			return ((XPathDocument)cache).CreateNavigator();
		}

		public XPathNavigator GetNavigator(string text, string baseUri, XmlNameTable nameTable)
		{
			if (cache == null)
			{
				XPathDocument xPathDocument = new XPathDocument(nameTable);
				XmlRawWriter xmlRawWriter = xPathDocument.LoadFromWriter(XPathDocument.LoadFlags.AtomizeNames, baseUri);
				xmlRawWriter.WriteString(text);
				xmlRawWriter.Close();
				cache = xPathDocument;
			}
			return ((XPathDocument)cache).CreateNavigator();
		}
	}
	/// <summary>Sets iterators for combinations of elements by <see langword="Union" />, <see langword="Intersection" />, or <see langword="Difference" />, which use containment to control two nested iterators. This will return one of the enumeration values from <see cref="M:System.Xml.Xsl.Runtime.IdIterator.MoveNext" />.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public enum SetIteratorResult
	{
		/// <summary>Iteration is complete; there are no more nodes.</summary>
		NoMoreNodes,
		/// <summary>Initialize right-nested iterator.</summary>
		InitRightIterator,
		/// <summary>The next node needs to be fetched from the left-nested iterator.</summary>
		NeedLeftNode,
		/// <summary>The next node needs to be fetched from the right-nested iterator.</summary>
		NeedRightNode,
		/// <summary>This iterator's <see cref="P:System.Xml.XPath.XPathNodeIterator.Current" /> property is set to the next node in the iteration.</summary>
		HaveCurrentNode
	}
	/// <summary>Manages two sets of nodes that are already in document order with no duplicates, and returns the union of these sets in document order with no duplicates.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct UnionIterator
	{
		private enum IteratorState
		{
			InitLeft,
			NeedLeft,
			NeedRight,
			LeftIsCurrent,
			RightIsCurrent
		}

		private XmlQueryRuntime runtime;

		private XPathNavigator navCurr;

		private XPathNavigator navOther;

		private IteratorState state;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurr;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.UnionIterator" /> class.</summary>
		/// <param name="runtime">The <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> object.</param>
		public void Create(XmlQueryRuntime runtime)
		{
			this.runtime = runtime;
			state = IteratorState.InitLeft;
		}

		/// <summary>Positions this iterator to the next node in the union.</summary>
		/// <param name="nestedNavigator">The <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		/// <returns>The <see cref="T:System.Xml.Xsl.Runtime.SetIteratorResult" />.</returns>
		public SetIteratorResult MoveNext(XPathNavigator nestedNavigator)
		{
			switch (state)
			{
			case IteratorState.InitLeft:
				navOther = nestedNavigator;
				state = IteratorState.NeedRight;
				return SetIteratorResult.InitRightIterator;
			case IteratorState.NeedLeft:
				navCurr = nestedNavigator;
				state = IteratorState.LeftIsCurrent;
				break;
			case IteratorState.NeedRight:
				navCurr = nestedNavigator;
				state = IteratorState.RightIsCurrent;
				break;
			case IteratorState.LeftIsCurrent:
				state = IteratorState.NeedLeft;
				return SetIteratorResult.NeedLeftNode;
			case IteratorState.RightIsCurrent:
				state = IteratorState.NeedRight;
				return SetIteratorResult.NeedRightNode;
			}
			if (navCurr == null)
			{
				if (navOther == null)
				{
					return SetIteratorResult.NoMoreNodes;
				}
				Swap();
			}
			else if (navOther != null)
			{
				int num = runtime.ComparePosition(navOther, navCurr);
				if (num == 0)
				{
					if (state == IteratorState.LeftIsCurrent)
					{
						state = IteratorState.NeedLeft;
						return SetIteratorResult.NeedLeftNode;
					}
					state = IteratorState.NeedRight;
					return SetIteratorResult.NeedRightNode;
				}
				if (num < 0)
				{
					Swap();
				}
			}
			return SetIteratorResult.HaveCurrentNode;
		}

		private void Swap()
		{
			XPathNavigator xPathNavigator = navCurr;
			navCurr = navOther;
			navOther = xPathNavigator;
			if (state == IteratorState.LeftIsCurrent)
			{
				state = IteratorState.RightIsCurrent;
			}
			else
			{
				state = IteratorState.LeftIsCurrent;
			}
		}
	}
	/// <summary>Represents the position of the iterator to the next node in the intersection of two sets of nodes.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct IntersectIterator
	{
		private enum IteratorState
		{
			InitLeft,
			NeedLeft,
			NeedRight,
			NeedLeftAndRight,
			HaveCurrent
		}

		private XmlQueryRuntime runtime;

		private XPathNavigator navLeft;

		private XPathNavigator navRight;

		private IteratorState state;

		/// <summary>Gets or sets the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navLeft;

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.IntersectIterator" /> class.</summary>
		/// <param name="runtime">The <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> object.</param>
		public void Create(XmlQueryRuntime runtime)
		{
			this.runtime = runtime;
			state = IteratorState.InitLeft;
		}

		/// <summary>Positions the iterator to the next node in the union.</summary>
		/// <param name="nestedNavigator">The <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		/// <returns>The <see cref="T:System.Xml.Xsl.Runtime.SetIteratorResult" />.</returns>
		public SetIteratorResult MoveNext(XPathNavigator nestedNavigator)
		{
			switch (state)
			{
			case IteratorState.InitLeft:
				navLeft = nestedNavigator;
				state = IteratorState.NeedRight;
				return SetIteratorResult.InitRightIterator;
			case IteratorState.NeedLeft:
				navLeft = nestedNavigator;
				break;
			case IteratorState.NeedRight:
				navRight = nestedNavigator;
				break;
			case IteratorState.NeedLeftAndRight:
				navLeft = nestedNavigator;
				state = IteratorState.NeedRight;
				return SetIteratorResult.NeedRightNode;
			case IteratorState.HaveCurrent:
				state = IteratorState.NeedLeftAndRight;
				return SetIteratorResult.NeedLeftNode;
			}
			if (navLeft == null || navRight == null)
			{
				return SetIteratorResult.NoMoreNodes;
			}
			int num = runtime.ComparePosition(navLeft, navRight);
			if (num < 0)
			{
				state = IteratorState.NeedLeft;
				return SetIteratorResult.NeedLeftNode;
			}
			if (num > 0)
			{
				state = IteratorState.NeedRight;
				return SetIteratorResult.NeedRightNode;
			}
			state = IteratorState.HaveCurrent;
			return SetIteratorResult.HaveCurrentNode;
		}
	}
	/// <summary>Represents the position of the iterator to the next node in the difference between two sets of nodes.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DifferenceIterator
	{
		private enum IteratorState
		{
			InitLeft,
			NeedLeft,
			NeedRight,
			NeedLeftAndRight,
			HaveCurrent
		}

		private XmlQueryRuntime runtime;

		private XPathNavigator navLeft;

		private XPathNavigator navRight;

		private IteratorState state;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navLeft;

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.DifferenceIterator" /> class.</summary>
		/// <param name="runtime">The <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> object.</param>
		public void Create(XmlQueryRuntime runtime)
		{
			this.runtime = runtime;
			state = IteratorState.InitLeft;
		}

		/// <summary>Positions this iterator to the next node in the union.</summary>
		/// <param name="nestedNavigator">The <see cref="T:System.Xml.XPath.XPathNavigator" /> object that identifies the current node.</param>
		/// <returns>The <see cref="T:System.Xml.Xsl.Runtime.SetIteratorResult" />.</returns>
		public SetIteratorResult MoveNext(XPathNavigator nestedNavigator)
		{
			switch (state)
			{
			case IteratorState.InitLeft:
				navLeft = nestedNavigator;
				state = IteratorState.NeedRight;
				return SetIteratorResult.InitRightIterator;
			case IteratorState.NeedLeft:
				navLeft = nestedNavigator;
				break;
			case IteratorState.NeedRight:
				navRight = nestedNavigator;
				break;
			case IteratorState.NeedLeftAndRight:
				navLeft = nestedNavigator;
				state = IteratorState.NeedRight;
				return SetIteratorResult.NeedRightNode;
			case IteratorState.HaveCurrent:
				state = IteratorState.NeedLeft;
				return SetIteratorResult.NeedLeftNode;
			}
			if (navLeft == null)
			{
				return SetIteratorResult.NoMoreNodes;
			}
			if (navRight != null)
			{
				int num = runtime.ComparePosition(navLeft, navRight);
				if (num == 0)
				{
					state = IteratorState.NeedLeftAndRight;
					return SetIteratorResult.NeedLeftNode;
				}
				if (num > 0)
				{
					state = IteratorState.NeedRight;
					return SetIteratorResult.NeedRightNode;
				}
			}
			state = IteratorState.HaveCurrent;
			return SetIteratorResult.HaveCurrentNode;
		}
	}
	/// <summary>Iterates over all following sibling content nodes.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct FollowingSiblingIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.FollowingSiblingIterator" />.</summary>
		/// <param name="context">The node from which you start traversing the child content nodes.</param>
		/// <param name="filter">Enables you to filter nodes based on the name.</param>
		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			this.filter = filter;
		}

		/// <summary>Positions the iterator on the next sibling content node.</summary>
		/// <returns>
		///   <see langword="true" /> if the next sibling content node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			return filter.MoveToFollowingSibling(navCurrent);
		}
	}
	/// <summary>Iterates over child nodes byfollowing the sibling nodes.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct FollowingSiblingMergeIterator
	{
		private ContentMergeIterator wrapped;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => wrapped.Current;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.FollowingSiblingMergeIterator" />.</summary>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class, which enables you to filter nodes based on the name.</param>
		public void Create(XmlNavigatorFilter filter)
		{
			wrapped.Create(filter);
		}

		/// <summary>Position this iterator to the next content or sibling node.</summary>
		/// <param name="navigator">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		/// <returns>Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.NoMoreNodes" /> if there are no more content or sibling nodes. Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.NeedInputNode" /> if the next input node needs to be fetched first. Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.HaveCurrentNode" /> if, while iterating through the nodes, the <see cref="P:System.Xml.Xsl.Runtime.FollowingSiblingMergeIterator.Current" /> property was set to the next node.</returns>
		public IteratorResult MoveNext(XPathNavigator navigator)
		{
			return wrapped.MoveNext(navigator, isContent: false);
		}
	}
	/// <summary>Iterates over all preceding sibling nodes according to the <see cref="N:System.Xml.XPath" /> preceding sibling axis rules and returns nodes in reverse document order.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct PrecedingSiblingIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.PrecedingSiblingIterator" />.</summary>
		/// <param name="context">The node from which you start traversing the nodes.</param>
		/// <param name="filter">Enables you to filter nodes based on the name.</param>
		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			this.filter = filter;
		}

		/// <summary>Positions the iterator on the next preceding sibling node in the reverse document order.</summary>
		/// <returns>
		///   <see langword="true" /> if the next preceding sibling node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			return filter.MoveToPreviousSibling(navCurrent);
		}
	}
	/// <summary>Iterates over all preceding sibling content nodes in document order.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct PrecedingSiblingDocOrderIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XPathNavigator navEnd;

		private bool needFirst;

		private bool useCompPos;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.PrecedingSiblingDocOrderIterator" />.</summary>
		/// <param name="context">The node from which you start traversing the nodes.</param>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class, which enables you to filter nodes based on the name. For more information, see <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" />.</param>
		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			this.filter = filter;
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			navEnd = XmlQueryRuntime.SyncToNavigator(navEnd, context);
			needFirst = true;
			useCompPos = this.filter.IsFiltered(context);
		}

		/// <summary>Positions the iterator on the next preceding sibling node.</summary>
		/// <returns>
		///   <see langword="true" /> if the next preceding sibling node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (needFirst)
			{
				if (!navCurrent.MoveToParent())
				{
					return false;
				}
				if (!filter.MoveToContent(navCurrent))
				{
					return false;
				}
				needFirst = false;
			}
			else if (!filter.MoveToFollowingSibling(navCurrent))
			{
				return false;
			}
			if (useCompPos)
			{
				return navCurrent.ComparePosition(navEnd) == XmlNodeOrder.Before;
			}
			if (navCurrent.IsSamePosition(navEnd))
			{
				useCompPos = true;
				return false;
			}
			return true;
		}
	}
	/// <summary>Concatenates strings when the number of strings is not known beforehand.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct StringConcat
	{
		private string s1;

		private string s2;

		private string s3;

		private string s4;

		private string delimiter;

		private List<string> strList;

		private int idxStr;

		/// <summary>Gets or sets the string that delimits concatenated strings.</summary>
		/// <returns>The string delimiter.</returns>
		public string Delimiter
		{
			get
			{
				return delimiter;
			}
			set
			{
				delimiter = value;
			}
		}

		internal int Count => idxStr;

		/// <summary>Clears the result string.</summary>
		public void Clear()
		{
			idxStr = 0;
			delimiter = null;
		}

		/// <summary>Concatenates a new string to the result.</summary>
		/// <param name="value">A <see langword="string" /> value to be concatenated to the result.</param>
		public void Concat(string value)
		{
			if (delimiter != null && idxStr != 0)
			{
				ConcatNoDelimiter(delimiter);
			}
			ConcatNoDelimiter(value);
		}

		/// <summary>Gets the result string.</summary>
		/// <returns>A <see langword="string" /> value that contains the result.</returns>
		public string GetResult()
		{
			return idxStr switch
			{
				0 => string.Empty, 
				1 => s1, 
				2 => s1 + s2, 
				3 => s1 + s2 + s3, 
				4 => s1 + s2 + s3 + s4, 
				_ => string.Concat(strList.ToArray()), 
			};
		}

		internal void ConcatNoDelimiter(string s)
		{
			switch (idxStr)
			{
			case 0:
				s1 = s;
				break;
			case 1:
				s2 = s;
				break;
			case 2:
				s3 = s;
				break;
			case 3:
				s4 = s;
				break;
			case 4:
			{
				int capacity = ((strList == null) ? 8 : strList.Count);
				List<string> list = (strList = new List<string>(capacity));
				list.Add(s1);
				list.Add(s2);
				list.Add(s3);
				list.Add(s4);
				goto default;
			}
			default:
				strList.Add(s);
				break;
			}
			idxStr++;
		}
	}
	/// <summary>Iterates over all descendant nodes according to the <see cref="N:System.Xml.XPath" /> descendant axis rules.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DescendantIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XPathNavigator navEnd;

		private bool hasFirst;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.DescendantIterator" />.</summary>
		/// <param name="input">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> that identifies the node from which you start traversing descendants.</param>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class, which enables you to filter nodes based on the name. For more information, see <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" />.</param>
		/// <param name="orSelf">
		///   <see cref="T:System.Boolean" /> that indicates whether the current node is returned as part of the iteration or filtered out.</param>
		public void Create(XPathNavigator input, XmlNavigatorFilter filter, bool orSelf)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
			this.filter = filter;
			if (input.NodeType == XPathNodeType.Root)
			{
				navEnd = null;
			}
			else
			{
				navEnd = XmlQueryRuntime.SyncToNavigator(navEnd, input);
				navEnd.MoveToNonDescendant();
			}
			hasFirst = orSelf && !this.filter.IsFiltered(navCurrent);
		}

		/// <summary>Positions the iterator on the next descendant node.</summary>
		/// <returns>
		///   <see langword="true" /> if the next descendant node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (hasFirst)
			{
				hasFirst = false;
				return true;
			}
			return filter.MoveToFollowing(navCurrent, navEnd);
		}
	}
	/// <summary>Iterate over all descendant content nodes according to XPath descendant axis rules. Eliminates duplicates by not querying over nodes that are contained in the subtree of the previous node.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DescendantMergeIterator
	{
		private enum IteratorState
		{
			NoPrevious,
			NeedCurrent,
			NeedDescendant
		}

		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XPathNavigator navRoot;

		private XPathNavigator navEnd;

		private IteratorState state;

		private bool orSelf;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.DescendantMergeIterator" />. Merges multiple sets of descendant nodes in document order and removes duplicates.</summary>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class that enables you to filter nodes based on the name. For more information, see <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" />.</param>
		/// <param name="orSelf">
		///   <see cref="T:System.Boolean" /> that indicates whether the current node is returned as part of the iteration or filtered out.</param>
		public void Create(XmlNavigatorFilter filter, bool orSelf)
		{
			this.filter = filter;
			state = IteratorState.NoPrevious;
			this.orSelf = orSelf;
		}

		/// <summary>Position this iterator to the next descendant node.</summary>
		/// <param name="input">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object that identifies the input node.</param>
		/// <returns>Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.NoMoreNodes" /> if there are no more descendant nodes. Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.NeedInputNode" /> if the next input node needs to be fetched first. Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.HaveCurrentNode" /> if while iterating through the nodes the <see cref="P:System.Xml.Xsl.Runtime.DescendantMergeIterator.Current" /> property was set to the next node.</returns>
		public IteratorResult MoveNext(XPathNavigator input)
		{
			if (state != IteratorState.NeedDescendant)
			{
				if (input == null)
				{
					return IteratorResult.NoMoreNodes;
				}
				if (state != 0 && navRoot.IsDescendant(input))
				{
					return IteratorResult.NeedInputNode;
				}
				navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
				navRoot = XmlQueryRuntime.SyncToNavigator(navRoot, input);
				navEnd = XmlQueryRuntime.SyncToNavigator(navEnd, input);
				navEnd.MoveToNonDescendant();
				state = IteratorState.NeedDescendant;
				if (orSelf && !filter.IsFiltered(input))
				{
					return IteratorResult.HaveCurrentNode;
				}
			}
			if (filter.MoveToFollowing(navCurrent, navEnd))
			{
				return IteratorResult.HaveCurrentNode;
			}
			state = IteratorState.NeedCurrent;
			return IteratorResult.NeedInputNode;
		}
	}
	/// <summary>Iterates over the matching parent node according to the <see cref="N:System.Xml.XPath" />, parent axis rules.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct ParentIterator
	{
		private XPathNavigator navCurrent;

		private bool haveCurrent;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.ParentIterator" />.</summary>
		/// <param name="context">The node from which you start traversing the nodes.</param>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class, which enables you to filter nodes based on the name.</param>
		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			haveCurrent = navCurrent.MoveToParent() && !filter.IsFiltered(navCurrent);
		}

		/// <summary>Positions the iterator on the next matching parent node.</summary>
		/// <returns>
		///   <see langword="true" /> if the next matching parent node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (haveCurrent)
			{
				haveCurrent = false;
				return true;
			}
			return false;
		}
	}
	/// <summary>Iterates over all ancestor nodes according to the <see cref="N:System.Xml.XPath" /> ancestor axis rules, and returns the nodes in reverse document order.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct AncestorIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private bool haveCurrent;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.AncestorIterator" />.</summary>
		/// <param name="context">The node from which you start traversing ancestors.</param>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class, which enables you to filter nodes based on the name. For more information, see <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" />.</param>
		/// <param name="orSelf">
		///   <see langword="true" /> if you want the <paramref name="context" /> node to be returned as a part of the iteration and not filtered out.</param>
		public void Create(XPathNavigator context, XmlNavigatorFilter filter, bool orSelf)
		{
			this.filter = filter;
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			haveCurrent = orSelf && !this.filter.IsFiltered(navCurrent);
		}

		/// <summary>Positions the iterator on the next ancestor node.</summary>
		/// <returns>
		///   <see langword="true" /> if the next ancestor node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (haveCurrent)
			{
				haveCurrent = false;
				return true;
			}
			while (navCurrent.MoveToParent())
			{
				if (!filter.IsFiltered(navCurrent))
				{
					return true;
				}
			}
			return false;
		}
	}
	/// <summary>Iterates over all ancestor nodes according to the <see cref="N:System.Xml.XPath" /> ancestor axis rules, and returns the nodes in document order without duplicates.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct AncestorDocOrderIterator
	{
		private XmlNavigatorStack stack;

		private XPathNavigator navCurrent;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.AncestorDocOrderIterator" />.</summary>
		/// <param name="context">The node from which you start traversing ancestors.</param>
		/// <param name="filter">Enables you to filter nodes based on the name.</param>
		/// <param name="orSelf">
		///   <see langword="true" /> if you want the <paramref name="context" /> node to be returned as a part of the iteration, instead of being filtered out.</param>
		public void Create(XPathNavigator context, XmlNavigatorFilter filter, bool orSelf)
		{
			AncestorIterator ancestorIterator = default(AncestorIterator);
			ancestorIterator.Create(context, filter, orSelf);
			stack.Reset();
			while (ancestorIterator.MoveNext())
			{
				stack.Push(ancestorIterator.Current.Clone());
			}
		}

		/// <summary>Positions the iterator on the next ancestor node in document order.</summary>
		/// <returns>
		///   <see langword="true" /> if the iterator was set to the next ancestor node in document order; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (stack.IsEmpty)
			{
				return false;
			}
			navCurrent = stack.Pop();
			return true;
		}
	}
	/// <summary>Iterates over all following nodes according to the XPath following-axis rules.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XPathFollowingIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private bool needFirst;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.XPathFollowingIterator" />. The <see cref="T:System.Xml.Xsl.Runtime.XPathFollowingIterator" /> does not contain duplicates.</summary>
		/// <param name="input">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		/// <param name="filter">
		///   <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> object.</param>
		public void Create(XPathNavigator input, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
			this.filter = filter;
			needFirst = true;
		}

		/// <summary>Positions the iterator to the next following node.</summary>
		/// <returns>
		///   <see langword="true" /> if the iterator was set to the next following node; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (needFirst)
			{
				if (!MoveFirst(filter, navCurrent))
				{
					return false;
				}
				needFirst = false;
				return true;
			}
			return filter.MoveToFollowing(navCurrent, null);
		}

		internal static bool MoveFirst(XmlNavigatorFilter filter, XPathNavigator nav)
		{
			if (nav.NodeType == XPathNodeType.Attribute || nav.NodeType == XPathNodeType.Namespace)
			{
				if (!nav.MoveToParent())
				{
					return false;
				}
				if (!filter.MoveToFollowing(nav, null))
				{
					return false;
				}
			}
			else
			{
				if (!nav.MoveToNonDescendant())
				{
					return false;
				}
				if (filter.IsFiltered(nav) && !filter.MoveToFollowing(nav, null))
				{
					return false;
				}
			}
			return true;
		}
	}
	/// <summary>Iterates over all following nodes according to the XPath following axis rules.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XPathFollowingMergeIterator
	{
		private enum IteratorState
		{
			NeedCandidateCurrent,
			HaveCandidateCurrent,
			HaveCurrentNeedNext,
			HaveCurrentHaveNext,
			HaveCurrentNoNext
		}

		private XmlNavigatorFilter filter;

		private IteratorState state;

		private XPathNavigator navCurrent;

		private XPathNavigator navNext;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.XPathFollowingMergeIterator" />.</summary>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class, which enables you to filter nodes based on name.</param>
		public void Create(XmlNavigatorFilter filter)
		{
			this.filter = filter;
			state = IteratorState.NeedCandidateCurrent;
		}

		/// <summary>Moves the iterator to the next following node.</summary>
		/// <param name="input">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		/// <returns>Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.NoMoreNodes" /> if there are no more following nodes. Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.NeedInputNode" /> if the next input node must be fetched first. Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.HaveCurrentNode" /> if the <see cref="P:System.Xml.Xsl.Runtime.XPathFollowingMergeIterator.Current" /> property was set to the next node while iterating through the nodes.</returns>
		public IteratorResult MoveNext(XPathNavigator input)
		{
			switch (state)
			{
			case IteratorState.NeedCandidateCurrent:
				if (input == null)
				{
					return IteratorResult.NoMoreNodes;
				}
				navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
				state = IteratorState.HaveCandidateCurrent;
				return IteratorResult.NeedInputNode;
			case IteratorState.HaveCandidateCurrent:
				if (input == null)
				{
					state = IteratorState.HaveCurrentNoNext;
					return MoveFirst();
				}
				if (navCurrent.IsDescendant(input))
				{
					goto case IteratorState.NeedCandidateCurrent;
				}
				state = IteratorState.HaveCurrentNeedNext;
				goto case IteratorState.HaveCurrentNeedNext;
			case IteratorState.HaveCurrentNeedNext:
				if (input == null)
				{
					state = IteratorState.HaveCurrentNoNext;
					return MoveFirst();
				}
				if (navCurrent.ComparePosition(input) != XmlNodeOrder.Unknown)
				{
					return IteratorResult.NeedInputNode;
				}
				navNext = XmlQueryRuntime.SyncToNavigator(navNext, input);
				state = IteratorState.HaveCurrentHaveNext;
				return MoveFirst();
			default:
				if (!filter.MoveToFollowing(navCurrent, null))
				{
					return MoveFailed();
				}
				return IteratorResult.HaveCurrentNode;
			}
		}

		private IteratorResult MoveFailed()
		{
			if (state == IteratorState.HaveCurrentNoNext)
			{
				state = IteratorState.NeedCandidateCurrent;
				return IteratorResult.NoMoreNodes;
			}
			state = IteratorState.HaveCandidateCurrent;
			XPathNavigator xPathNavigator = navCurrent;
			navCurrent = navNext;
			navNext = xPathNavigator;
			return IteratorResult.NeedInputNode;
		}

		private IteratorResult MoveFirst()
		{
			if (!XPathFollowingIterator.MoveFirst(filter, navCurrent))
			{
				return MoveFailed();
			}
			return IteratorResult.HaveCurrentNode;
		}
	}
	/// <summary>Iterates over all the content-typed nodes which precede the starting node in document order. Returns nodes in reverse document order.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct PrecedingIterator
	{
		private XmlNavigatorStack stack;

		private XPathNavigator navCurrent;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.PrecedingIterator" />. The <see cref="T:System.Xml.Xsl.Runtime.PrecedingIterator" /> does not contain duplicates.</summary>
		/// <param name="context">The node from which you start traversing the nodes.</param>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class, which enables you to filter nodes based on the name.</param>
		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			navCurrent.MoveToRoot();
			stack.Reset();
			if (!navCurrent.IsSamePosition(context))
			{
				if (!filter.IsFiltered(navCurrent))
				{
					stack.Push(navCurrent.Clone());
				}
				while (filter.MoveToFollowing(navCurrent, context))
				{
					stack.Push(navCurrent.Clone());
				}
			}
		}

		/// <summary>Positions the iterator on the next preceding node in reverse document order.</summary>
		/// <returns>
		///   <see langword="true" /> if the next preceding node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (stack.IsEmpty)
			{
				return false;
			}
			navCurrent = stack.Pop();
			return true;
		}
	}
	/// <summary>Iterates over all preceding nodes according to the XPath preceding axis rules, and returns nodes in reverse document order without duplicates.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XPathPrecedingIterator
	{
		private XmlNavigatorStack stack;

		private XPathNavigator navCurrent;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.XPathPrecedingIterator" />.</summary>
		/// <param name="context">The node from which you start traversing ancestors.</param>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class, which enables you to filter nodes based on the name. For more information, see <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" />.</param>
		public void Create(XPathNavigator context, XmlNavigatorFilter filter)
		{
			XPathPrecedingDocOrderIterator xPathPrecedingDocOrderIterator = default(XPathPrecedingDocOrderIterator);
			xPathPrecedingDocOrderIterator.Create(context, filter);
			stack.Reset();
			while (xPathPrecedingDocOrderIterator.MoveNext())
			{
				stack.Push(xPathPrecedingDocOrderIterator.Current.Clone());
			}
		}

		/// <summary>Positions the iterator on the next preceding node in reverse document order.</summary>
		/// <returns>
		///   <see langword="true" /> if the iterator was set to the next preceding node; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (stack.IsEmpty)
			{
				return false;
			}
			navCurrent = stack.Pop();
			return true;
		}
	}
	/// <summary>Iterates over all preceding nodes according to the XPath preceding axis rules, and returns nodes in document order without duplicates.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XPathPrecedingDocOrderIterator
	{
		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XmlNavigatorStack navStack;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.XPathPrecedingDocOrderIterator" />.</summary>
		/// <param name="input">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		/// <param name="filter">
		///   <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> object.</param>
		public void Create(XPathNavigator input, XmlNavigatorFilter filter)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
			this.filter = filter;
			PushAncestors();
		}

		/// <summary>Positions the iterator on the next preceding node.</summary>
		/// <returns>
		///   <see langword="true" /> if the iterator was set to the next preceding node; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			if (!navStack.IsEmpty)
			{
				do
				{
					if (filter.MoveToFollowing(navCurrent, navStack.Peek()))
					{
						return true;
					}
					navCurrent.MoveTo(navStack.Pop());
				}
				while (!navStack.IsEmpty);
			}
			return false;
		}

		private void PushAncestors()
		{
			navStack.Reset();
			do
			{
				navStack.Push(navCurrent.Clone());
			}
			while (navCurrent.MoveToParent());
			navStack.Pop();
		}
	}
	/// <summary>Iterates over all preceding nodes according to the XPath preceding axis rules, except that nodes are always returned in document order. Merges multiple sets of preceding nodes in document order and removes duplicates.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XPathPrecedingMergeIterator
	{
		private enum IteratorState
		{
			NeedCandidateCurrent,
			HaveCandidateCurrent,
			HaveCurrentHaveNext,
			HaveCurrentNoNext
		}

		private XmlNavigatorFilter filter;

		private IteratorState state;

		private XPathNavigator navCurrent;

		private XPathNavigator navNext;

		private XmlNavigatorStack navStack;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.XPathPrecedingMergeIterator" />.</summary>
		/// <param name="filter">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class, which enables you to filter nodes based on the name.</param>
		public void Create(XmlNavigatorFilter filter)
		{
			this.filter = filter;
			state = IteratorState.NeedCandidateCurrent;
		}

		/// <summary>Positions this iterator to the next preceding node in document order.</summary>
		/// <param name="input">The input node.</param>
		/// <returns>Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.NoMoreNodes" /> if there are no more preceding nodes. Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.NeedInputNode" /> if the next input node must be fetched first. Returns <see cref="F:System.Xml.Xsl.Runtime.IteratorResult.HaveCurrentNode" /> if the <see cref="P:System.Xml.Xsl.Runtime.XPathPrecedingMergeIterator.Current" /> property was set to the next node while iterating through the nodes.</returns>
		public IteratorResult MoveNext(XPathNavigator input)
		{
			switch (state)
			{
			case IteratorState.NeedCandidateCurrent:
				if (input == null)
				{
					return IteratorResult.NoMoreNodes;
				}
				navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
				state = IteratorState.HaveCandidateCurrent;
				return IteratorResult.NeedInputNode;
			case IteratorState.HaveCandidateCurrent:
				if (input == null)
				{
					state = IteratorState.HaveCurrentNoNext;
				}
				else
				{
					if (navCurrent.ComparePosition(input) != XmlNodeOrder.Unknown)
					{
						navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, input);
						return IteratorResult.NeedInputNode;
					}
					navNext = XmlQueryRuntime.SyncToNavigator(navNext, input);
					state = IteratorState.HaveCurrentHaveNext;
				}
				PushAncestors();
				break;
			}
			if (!navStack.IsEmpty)
			{
				do
				{
					if (filter.MoveToFollowing(navCurrent, navStack.Peek()))
					{
						return IteratorResult.HaveCurrentNode;
					}
					navCurrent.MoveTo(navStack.Pop());
				}
				while (!navStack.IsEmpty);
			}
			if (state == IteratorState.HaveCurrentNoNext)
			{
				state = IteratorState.NeedCandidateCurrent;
				return IteratorResult.NoMoreNodes;
			}
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, navNext);
			state = IteratorState.HaveCandidateCurrent;
			return IteratorResult.HaveCurrentNode;
		}

		private void PushAncestors()
		{
			navStack.Reset();
			do
			{
				navStack.Push(navCurrent.Clone());
			}
			while (navCurrent.MoveToParent());
			navStack.Pop();
		}
	}
	/// <summary>Iterates over the singleton node if the starting node is the same node as the ending node. Iterates to the end of the document if the starting node is after the ending node or is in a different document.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct NodeRangeIterator
	{
		private enum IteratorState
		{
			HaveCurrent,
			NeedCurrent,
			HaveCurrentNoNext,
			NoNext
		}

		private XmlNavigatorFilter filter;

		private XPathNavigator navCurrent;

		private XPathNavigator navEnd;

		private IteratorState state;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.NodeRangeIterator" />.</summary>
		/// <param name="start">Node at which iteration begins.</param>
		/// <param name="filter">Test expression that determines whether a node is to be filtered out.</param>
		/// <param name="end">Node at which iteration ends.</param>
		public void Create(XPathNavigator start, XmlNavigatorFilter filter, XPathNavigator end)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, start);
			navEnd = XmlQueryRuntime.SyncToNavigator(navEnd, end);
			this.filter = filter;
			if (start.IsSamePosition(end))
			{
				state = ((!filter.IsFiltered(start)) ? IteratorState.HaveCurrentNoNext : IteratorState.NoNext);
			}
			else
			{
				state = (filter.IsFiltered(start) ? IteratorState.NeedCurrent : IteratorState.HaveCurrent);
			}
		}

		/// <summary>Positions the iterator on the next node.</summary>
		/// <returns>
		///   <see langword="true" /> if the next node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			switch (state)
			{
			case IteratorState.HaveCurrent:
				state = IteratorState.NeedCurrent;
				return true;
			case IteratorState.NeedCurrent:
				if (!filter.MoveToFollowing(navCurrent, navEnd))
				{
					if (filter.IsFiltered(navEnd))
					{
						state = IteratorState.NoNext;
						return false;
					}
					navCurrent.MoveTo(navEnd);
					state = IteratorState.NoNext;
				}
				return true;
			case IteratorState.HaveCurrentNoNext:
				state = IteratorState.NoNext;
				return true;
			default:
				return false;
			}
		}
	}
	internal class WhitespaceRuleLookup
	{
		private class InternalWhitespaceRule : WhitespaceRule
		{
			private int priority;

			private int hashCode;

			public int Priority => priority;

			public InternalWhitespaceRule()
			{
			}

			public InternalWhitespaceRule(string localName, string namespaceName, bool preserveSpace, int priority)
			{
				Init(localName, namespaceName, preserveSpace, priority);
			}

			public void Init(string localName, string namespaceName, bool preserveSpace, int priority)
			{
				Init(localName, namespaceName, preserveSpace);
				this.priority = priority;
				if (localName != null && namespaceName != null)
				{
					hashCode = localName.GetHashCode();
				}
			}

			public void Atomize(XmlNameTable nameTable)
			{
				if (base.LocalName != null)
				{
					base.LocalName = nameTable.Add(base.LocalName);
				}
				if (base.NamespaceName != null)
				{
					base.NamespaceName = nameTable.Add(base.NamespaceName);
				}
			}

			public override int GetHashCode()
			{
				return hashCode;
			}

			public override bool Equals(object obj)
			{
				InternalWhitespaceRule internalWhitespaceRule = obj as InternalWhitespaceRule;
				if (base.LocalName == internalWhitespaceRule.LocalName)
				{
					return base.NamespaceName == internalWhitespaceRule.NamespaceName;
				}
				return false;
			}
		}

		private Hashtable qnames;

		private ArrayList wildcards;

		private InternalWhitespaceRule ruleTemp;

		private XmlNameTable nameTable;

		public WhitespaceRuleLookup()
		{
			qnames = new Hashtable();
			wildcards = new ArrayList();
		}

		public WhitespaceRuleLookup(IList<WhitespaceRule> rules)
			: this()
		{
			for (int num = rules.Count - 1; num >= 0; num--)
			{
				WhitespaceRule whitespaceRule = rules[num];
				InternalWhitespaceRule internalWhitespaceRule = new InternalWhitespaceRule(whitespaceRule.LocalName, whitespaceRule.NamespaceName, whitespaceRule.PreserveSpace, -num);
				if (whitespaceRule.LocalName == null || whitespaceRule.NamespaceName == null)
				{
					wildcards.Add(internalWhitespaceRule);
				}
				else
				{
					qnames[internalWhitespaceRule] = internalWhitespaceRule;
				}
			}
			ruleTemp = new InternalWhitespaceRule();
		}

		public void Atomize(XmlNameTable nameTable)
		{
			if (nameTable == this.nameTable)
			{
				return;
			}
			this.nameTable = nameTable;
			foreach (InternalWhitespaceRule value in qnames.Values)
			{
				value.Atomize(nameTable);
			}
			foreach (InternalWhitespaceRule wildcard in wildcards)
			{
				wildcard.Atomize(nameTable);
			}
		}

		public bool ShouldStripSpace(string localName, string namespaceName)
		{
			ruleTemp.Init(localName, namespaceName, preserveSpace: false, 0);
			InternalWhitespaceRule internalWhitespaceRule = qnames[ruleTemp] as InternalWhitespaceRule;
			int count = wildcards.Count;
			while (count-- != 0)
			{
				InternalWhitespaceRule internalWhitespaceRule2 = wildcards[count] as InternalWhitespaceRule;
				if (internalWhitespaceRule != null)
				{
					if (internalWhitespaceRule.Priority > internalWhitespaceRule2.Priority)
					{
						return !internalWhitespaceRule.PreserveSpace;
					}
					if (internalWhitespaceRule.PreserveSpace == internalWhitespaceRule2.PreserveSpace)
					{
						continue;
					}
				}
				if ((internalWhitespaceRule2.LocalName == null || (object)internalWhitespaceRule2.LocalName == localName) && (internalWhitespaceRule2.NamespaceName == null || (object)internalWhitespaceRule2.NamespaceName == namespaceName))
				{
					return !internalWhitespaceRule2.PreserveSpace;
				}
			}
			if (internalWhitespaceRule != null)
			{
				return !internalWhitespaceRule.PreserveSpace;
			}
			return false;
		}
	}
	internal class WhitespaceRuleReader : XmlWrappingReader
	{
		private WhitespaceRuleLookup wsRules;

		private BitStack stkStrip;

		private bool shouldStrip;

		private bool preserveAdjacent;

		private string val;

		private XmlCharType xmlCharType = XmlCharType.Instance;

		public override string Value
		{
			get
			{
				if (val != null)
				{
					return val;
				}
				return base.Value;
			}
		}

		public static XmlReader CreateReader(XmlReader baseReader, WhitespaceRuleLookup wsRules)
		{
			if (wsRules == null)
			{
				return baseReader;
			}
			XmlReaderSettings settings = baseReader.Settings;
			if (settings != null)
			{
				if (settings.IgnoreWhitespace)
				{
					return baseReader;
				}
			}
			else
			{
				if (baseReader is XmlTextReader xmlTextReader && xmlTextReader.WhitespaceHandling == WhitespaceHandling.None)
				{
					return baseReader;
				}
				if (baseReader is XmlTextReaderImpl xmlTextReaderImpl && xmlTextReaderImpl.WhitespaceHandling == WhitespaceHandling.None)
				{
					return baseReader;
				}
			}
			return new WhitespaceRuleReader(baseReader, wsRules);
		}

		private WhitespaceRuleReader(XmlReader baseReader, WhitespaceRuleLookup wsRules)
			: base(baseReader)
		{
			val = null;
			stkStrip = new BitStack();
			shouldStrip = false;
			preserveAdjacent = false;
			this.wsRules = wsRules;
			this.wsRules.Atomize(baseReader.NameTable);
		}

		public override bool Read()
		{
			XmlCharType instance = XmlCharType.Instance;
			string text = null;
			val = null;
			while (base.Read())
			{
				switch (base.NodeType)
				{
				case XmlNodeType.Element:
					if (!base.IsEmptyElement)
					{
						stkStrip.PushBit(shouldStrip);
						shouldStrip = wsRules.ShouldStripSpace(base.LocalName, base.NamespaceURI) && base.XmlSpace != XmlSpace.Preserve;
					}
					break;
				case XmlNodeType.EndElement:
					shouldStrip = stkStrip.PopBit();
					break;
				case XmlNodeType.Text:
				case XmlNodeType.CDATA:
					if (preserveAdjacent)
					{
						return true;
					}
					if (!shouldStrip)
					{
						break;
					}
					if (!instance.IsOnlyWhitespace(base.Value))
					{
						if (text != null)
						{
							val = text + base.Value;
						}
						preserveAdjacent = true;
						return true;
					}
					goto case XmlNodeType.Whitespace;
				case XmlNodeType.Whitespace:
				case XmlNodeType.SignificantWhitespace:
					if (preserveAdjacent)
					{
						return true;
					}
					if (shouldStrip)
					{
						text = ((text != null) ? (text + base.Value) : base.Value);
						continue;
					}
					break;
				case XmlNodeType.EndEntity:
					continue;
				}
				preserveAdjacent = false;
				return true;
			}
			return false;
		}
	}
	/// <summary>Computes aggregates over a sequence of Int32 values.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct Int32Aggregator
	{
		private int result;

		private int cnt;

		/// <summary>Returns the sum of a sequence of Int32 values.</summary>
		/// <returns>An <see langword="Int32" /> value that contains the sum of a sequence of <see langword="Int32" /> values.</returns>
		public int SumResult => result;

		/// <summary>Returns the average result of a sequence of Int32 values.</summary>
		/// <returns>An <see langword="Int32" /> value that contains the average result of a sequence of <see langword="Int32" /> values.</returns>
		public int AverageResult => result / cnt;

		/// <summary>Returns the smallest value in a sequence of Int32 values.</summary>
		/// <returns>An <see langword="Int32" /> value that contains the minimum value in a sequence of <see langword="Int32" /> values.</returns>
		public int MinimumResult => result;

		/// <summary>Returns the largest value in a sequence of <see langword="Int32" /> values.</summary>
		/// <returns>An <see langword="Int32" /> value that contains the maximum value in a sequence of <see langword="Int32" /> values.</returns>
		public int MaximumResult => result;

		/// <summary>Returns a Boolean value that indicates if the sequence is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if the sequence is empty, otherwise returns <see langword="false" />.</returns>
		public bool IsEmpty => cnt == 0;

		/// <summary>Initializes a sequence of <see langword="Int32" /> values.</summary>
		public void Create()
		{
			cnt = 0;
		}

		/// <summary>Adds an <see langword="Int32" /> value to the existing result.</summary>
		/// <param name="value">A value of type <see langword="Int32" />.</param>
		public void Sum(int value)
		{
			if (cnt == 0)
			{
				result = value;
				cnt = 1;
			}
			else
			{
				result += value;
			}
		}

		/// <summary>Finds the average of a sequence of Int32 values.</summary>
		/// <param name="value">A value of type <see langword="Int32" /> that identifies a group of items to average, such as a column in a table.</param>
		public void Average(int value)
		{
			if (cnt == 0)
			{
				result = value;
			}
			else
			{
				result += value;
			}
			cnt++;
		}

		/// <summary>Assigns the <paramref name="value" /> parameter to the existing result if the <paramref name="value" /> parameter is less than the existing result.</summary>
		/// <param name="value">A value of type <see langword="Int32" /></param>
		public void Minimum(int value)
		{
			if (cnt == 0 || value < result)
			{
				result = value;
			}
			cnt = 1;
		}

		/// <summary>Assigns the <paramref name="value" /> parameter to the existing result if the <paramref name="value" /> parameter is greater than the existing result.</summary>
		/// <param name="value">A value of type <see langword="Int32" />.</param>
		public void Maximum(int value)
		{
			if (cnt == 0 || value > result)
			{
				result = value;
			}
			cnt = 1;
		}
	}
	/// <summary>Computes aggregates over a sequence of <see langword="Int64" /> values.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct Int64Aggregator
	{
		private long result;

		private int cnt;

		/// <summary>Returns an <see langword="Int64" /> value that contains the sum of a sequence of <see langword="Int64" /> values.</summary>
		/// <returns>An <see langword="Int64" /> value that contains the sum of a sequence of <see langword="Int64" /> values.</returns>
		public long SumResult => result;

		/// <summary>Returns an <see langword="Int64" /> value that contains the average of a sequence of <see langword="Int64" /> values.</summary>
		/// <returns>An <see langword="Int64" /> value that contains the average of a sequence of <see langword="Int64" /> values.</returns>
		public long AverageResult => result / cnt;

		/// <summary>Gest the smallest <see langword="Int64" /> value.</summary>
		/// <returns>The smallest <see langword="Int64" /> value.</returns>
		public long MinimumResult => result;

		/// <summary>Gets the largest <see langword="Int64" /> value.</summary>
		/// <returns>The largest <see langword="Int64" /> value.</returns>
		public long MaximumResult => result;

		/// <summary>Returns a Boolean value that indicates whether the sequence of <see langword="Int64" /> values is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if the sequence of <see langword="Int64" /> values is empty; otherwise, <see langword="false" />.</returns>
		public bool IsEmpty => cnt == 0;

		/// <summary>Initializes a sequence of <see langword="Int64" /> values.</summary>
		public void Create()
		{
			cnt = 0;
		}

		/// <summary>Adds an <see langword="Int64" /> value to the existing result.</summary>
		/// <param name="value">A value of type <see langword="Int64" />.</param>
		public void Sum(long value)
		{
			if (cnt == 0)
			{
				result = value;
				cnt = 1;
			}
			else
			{
				result += value;
			}
		}

		/// <summary>Finds an average of a sequence of <see langword="Int64" /> values.</summary>
		/// <param name="value">A value of type <see langword="Int64" />.</param>
		public void Average(long value)
		{
			if (cnt == 0)
			{
				result = value;
			}
			else
			{
				result += value;
			}
			cnt++;
		}

		/// <summary>Assigns the <paramref name="value" /> parameter to the existing result if the <paramref name="value" /> parameter is less than the existing result.</summary>
		/// <param name="value">A value of type <see langword="Int64" />.</param>
		public void Minimum(long value)
		{
			if (cnt == 0 || value < result)
			{
				result = value;
			}
			cnt = 1;
		}

		/// <summary>Assigns the <paramref name="value" /> parameter to the existing result if the <paramref name="value" /> parameter is greater than the existing result.</summary>
		/// <param name="value">A value of type <see langword="Int64" />.</param>
		public void Maximum(long value)
		{
			if (cnt == 0 || value > result)
			{
				result = value;
			}
			cnt = 1;
		}
	}
	/// <summary>Computes aggregates over a sequence of <see langword="Decimal" /> values.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DecimalAggregator
	{
		private decimal result;

		private int cnt;

		/// <summary>Gets the sum of the sequence of <see langword="Decimal" /> values.</summary>
		/// <returns>The sum of the sequence of <see langword="Decimal" /> values.</returns>
		public decimal SumResult => result;

		/// <summary>Gets an average of the sequence of <see langword="Decimal" /> values.</summary>
		/// <returns>The average of the sequence of <see langword="Decimal" /> values.</returns>
		public decimal AverageResult => result / (decimal)cnt;

		/// <summary>Gets the smallest value among the sequence of <see langword="Decimal" /> values.</summary>
		/// <returns>The smallest value among the sequence of <see langword="Decimal" /> values.</returns>
		public decimal MinimumResult => result;

		/// <summary>Gets the largest value among the sequence of <see langword="Decimal" /> values.</summary>
		/// <returns>The largest value among the sequence of <see langword="Decimal" /> values.</returns>
		public decimal MaximumResult => result;

		/// <summary>Gets a value indicating whether the <see cref="T:System.Xml.Xsl.Runtime.DecimalAggregator" /> contains a result.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Xml.Xsl.Runtime.DecimalAggregator" /> contains a result; otherwise, <see langword="false" />.</returns>
		public bool IsEmpty => cnt == 0;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.DecimalAggregator" />.</summary>
		public void Create()
		{
			cnt = 0;
		}

		/// <summary>Adds a <see langword="Decimal" /> value to the existing result.</summary>
		/// <param name="value">The <see langword="Decimal" /> value.</param>
		public void Sum(decimal value)
		{
			if (cnt == 0)
			{
				result = value;
				cnt = 1;
			}
			else
			{
				result += value;
			}
		}

		/// <summary>Averages <see langword="Decimal" /> values.</summary>
		/// <param name="value">The <see langword="Decimal" /> value.</param>
		public void Average(decimal value)
		{
			if (cnt == 0)
			{
				result = value;
			}
			else
			{
				result += value;
			}
			cnt++;
		}

		/// <summary>Assigns the <paramref name="value" /> parameter to the existing result if the <paramref name="value" /> parameter is less than the existing result.</summary>
		/// <param name="value">The <see langword="Decimal" /> value.</param>
		public void Minimum(decimal value)
		{
			if (cnt == 0 || value < result)
			{
				result = value;
			}
			cnt = 1;
		}

		/// <summary>Assigns the <paramref name="value" /> parameter to the existing result if the <paramref name="value" /> parameter is greater than the existing result.</summary>
		/// <param name="value">The <see langword="Decimal" /> value.</param>
		public void Maximum(decimal value)
		{
			if (cnt == 0 || value > result)
			{
				result = value;
			}
			cnt = 1;
		}
	}
	/// <summary>Computes aggregates over a sequence of <see langword="double" /> values.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct DoubleAggregator
	{
		private double result;

		private int cnt;

		/// <summary>Returns the sum of a sequence of <see langword="double" /> values.</summary>
		/// <returns>The sum of all results.</returns>
		public double SumResult => result;

		/// <summary>Computes the average value over a sequence of <see langword="double" /> values.</summary>
		/// <returns>The average result.</returns>
		public double AverageResult => result / (double)cnt;

		/// <summary>Returns the minimum value of a sequence of <see langword="double" /> values.</summary>
		/// <returns>The minimum result.</returns>
		public double MinimumResult => result;

		/// <summary>Returns the maximum value of a sequence of <see langword="double" /> values.</summary>
		/// <returns>The maximum result.</returns>
		public double MaximumResult => result;

		/// <summary>Determines whether a sequence of <see langword="double" /> values is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if the result is empty; otherwise, <see langword="false" />.</returns>
		public bool IsEmpty => cnt == 0;

		/// <summary>Initializes a sequence of <see langword="double" /> values.</summary>
		public void Create()
		{
			cnt = 0;
		}

		/// <summary>Adds a <see langword="Double" /> value to the existing result.</summary>
		/// <param name="value">A value of type <see langword="double" />.</param>
		public void Sum(double value)
		{
			if (cnt == 0)
			{
				result = value;
				cnt = 1;
			}
			else
			{
				result += value;
			}
		}

		/// <summary>Returns the average of a sequence of <see langword="double" /> values.</summary>
		/// <param name="value">A value of type <see langword="double" />.</param>
		public void Average(double value)
		{
			if (cnt == 0)
			{
				result = value;
			}
			else
			{
				result += value;
			}
			cnt++;
		}

		/// <summary>Assigns the <paramref name="value" /> parameter to the existing result if the <paramref name="value" /> parameter is less than the existing result.</summary>
		/// <param name="value">A value of type <see langword="double" />.</param>
		public void Minimum(double value)
		{
			if (cnt == 0 || value < result || double.IsNaN(value))
			{
				result = value;
			}
			cnt = 1;
		}

		/// <summary>Assigns the <paramref name="value" /> parameter to the existing result if the <paramref name="value" /> parameter is greater than the existing result.</summary>
		/// <param name="value">A value of type <see langword="double" />.</param>
		public void Maximum(double value)
		{
			if (cnt == 0 || value > result || double.IsNaN(value))
			{
				result = value;
			}
			cnt = 1;
		}
	}
	internal sealed class XmlAttributeCache : XmlRawWriter, IRemovableWriter
	{
		private struct AttrNameVal
		{
			private string localName;

			private string prefix;

			private string namespaceName;

			private string text;

			private XmlAtomicValue value;

			private int hashCode;

			private int nextNameIndex;

			public string LocalName => localName;

			public string Prefix => prefix;

			public string Namespace => namespaceName;

			public string Text => text;

			public XmlAtomicValue Value => value;

			public int NextNameIndex
			{
				get
				{
					return nextNameIndex;
				}
				set
				{
					nextNameIndex = value;
				}
			}

			public void Init(string prefix, string localName, string ns, int hashCode)
			{
				this.localName = localName;
				this.prefix = prefix;
				namespaceName = ns;
				this.hashCode = hashCode;
				nextNameIndex = 0;
			}

			public void Init(string text)
			{
				this.text = text;
				value = null;
			}

			public void Init(XmlAtomicValue value)
			{
				text = null;
				this.value = value;
			}

			public bool IsDuplicate(string localName, string ns, int hashCode)
			{
				if (this.localName != null && this.hashCode == hashCode && this.localName.Equals(localName) && namespaceName.Equals(ns))
				{
					this.localName = null;
					return true;
				}
				return false;
			}
		}

		private XmlRawWriter wrapped;

		private OnRemoveWriter onRemove;

		private AttrNameVal[] arrAttrs;

		private int numEntries;

		private int idxLastName;

		private int hashCodeUnion;

		private const int DefaultCacheSize = 32;

		public int Count => numEntries;

		public OnRemoveWriter OnRemoveWriterEvent
		{
			get
			{
				return onRemove;
			}
			set
			{
				onRemove = value;
			}
		}

		public void Init(XmlRawWriter wrapped)
		{
			SetWrappedWriter(wrapped);
			numEntries = 0;
			idxLastName = 0;
			hashCodeUnion = 0;
		}

		private void SetWrappedWriter(XmlRawWriter writer)
		{
			if (writer is IRemovableWriter removableWriter)
			{
				removableWriter.OnRemoveWriterEvent = SetWrappedWriter;
			}
			wrapped = writer;
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			int num = 0;
			int num2 = 1 << (localName[0] & 0x1F);
			if ((hashCodeUnion & num2) != 0)
			{
				while (!arrAttrs[num].IsDuplicate(localName, ns, num2))
				{
					num = arrAttrs[num].NextNameIndex;
					if (num == 0)
					{
						break;
					}
				}
			}
			else
			{
				hashCodeUnion |= num2;
			}
			EnsureAttributeCache();
			if (numEntries != 0)
			{
				arrAttrs[idxLastName].NextNameIndex = numEntries;
			}
			idxLastName = numEntries++;
			arrAttrs[idxLastName].Init(prefix, localName, ns, num2);
		}

		public override void WriteEndAttribute()
		{
		}

		internal override void WriteNamespaceDeclaration(string prefix, string ns)
		{
			FlushAttributes();
			wrapped.WriteNamespaceDeclaration(prefix, ns);
		}

		public override void WriteString(string text)
		{
			EnsureAttributeCache();
			arrAttrs[numEntries++].Init(text);
		}

		public override void WriteValue(object value)
		{
			EnsureAttributeCache();
			arrAttrs[numEntries++].Init((XmlAtomicValue)value);
		}

		public override void WriteValue(string value)
		{
			WriteValue(value);
		}

		internal override void StartElementContent()
		{
			FlushAttributes();
			wrapped.StartElementContent();
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
		}

		public override void WriteComment(string text)
		{
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
		}

		public override void WriteEntityRef(string name)
		{
		}

		public override void Close()
		{
			wrapped.Close();
		}

		public override void Flush()
		{
			wrapped.Flush();
		}

		private void FlushAttributes()
		{
			int num = 0;
			while (num != numEntries)
			{
				int nextNameIndex = arrAttrs[num].NextNameIndex;
				if (nextNameIndex == 0)
				{
					nextNameIndex = numEntries;
				}
				string localName = arrAttrs[num].LocalName;
				if (localName != null)
				{
					string prefix = arrAttrs[num].Prefix;
					string @namespace = arrAttrs[num].Namespace;
					wrapped.WriteStartAttribute(prefix, localName, @namespace);
					while (++num != nextNameIndex)
					{
						string text = arrAttrs[num].Text;
						if (text != null)
						{
							wrapped.WriteString(text);
						}
						else
						{
							wrapped.WriteValue(arrAttrs[num].Value);
						}
					}
					wrapped.WriteEndAttribute();
				}
				else
				{
					num = nextNameIndex;
				}
			}
			if (onRemove != null)
			{
				onRemove(wrapped);
			}
		}

		private void EnsureAttributeCache()
		{
			if (arrAttrs == null)
			{
				arrAttrs = new AttrNameVal[32];
			}
			else if (numEntries >= arrAttrs.Length)
			{
				AttrNameVal[] destinationArray = new AttrNameVal[numEntries * 2];
				Array.Copy(arrAttrs, destinationArray, numEntries);
				arrAttrs = destinationArray;
			}
		}
	}
	/// <summary>Constructs a collation that uses the specified culture and compare options.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlCollation
	{
		private struct Options
		{
			public const int FlagUpperFirst = 4096;

			public const int FlagEmptyGreatest = 8192;

			public const int FlagDescendingOrder = 16384;

			private const int Mask = 28672;

			private int value;

			public bool UpperFirst
			{
				get
				{
					return GetFlag(4096);
				}
				set
				{
					SetFlag(4096, value);
				}
			}

			public bool EmptyGreatest => GetFlag(8192);

			public bool DescendingOrder => GetFlag(16384);

			public bool IgnoreCase => GetFlag(1);

			public bool Ordinal => GetFlag(1073741824);

			public CompareOptions CompareOptions
			{
				get
				{
					return (CompareOptions)(value & -28673);
				}
				set
				{
					this.value = (this.value & 0x7000) | (int)value;
				}
			}

			public Options(int value)
			{
				this.value = value;
			}

			public bool GetFlag(int flag)
			{
				return (value & flag) != 0;
			}

			public void SetFlag(int flag, bool value)
			{
				if (value)
				{
					this.value |= flag;
				}
				else
				{
					this.value &= ~flag;
				}
			}

			public static implicit operator int(Options options)
			{
				return options.value;
			}
		}

		private const int deDE = 1031;

		private const int huHU = 1038;

		private const int jaJP = 1041;

		private const int kaGE = 1079;

		private const int koKR = 1042;

		private const int zhTW = 1028;

		private const int zhCN = 2052;

		private const int zhHK = 3076;

		private const int zhSG = 4100;

		private const int zhMO = 5124;

		private const int zhTWbopo = 197636;

		private const int deDEphon = 66567;

		private const int huHUtech = 66574;

		private const int kaGEmode = 66615;

		private CultureInfo cultInfo;

		private Options options;

		private CompareOptions compops;

		private static XmlCollation cp = new XmlCollation(CultureInfo.InvariantCulture, new Options(1073741824));

		private const int LOCALE_CURRENT = -1;

		internal static XmlCollation CodePointCollation => cp;

		internal bool UpperFirst => options.UpperFirst;

		internal bool EmptyGreatest => options.EmptyGreatest;

		internal bool DescendingOrder => options.DescendingOrder;

		internal CultureInfo Culture
		{
			get
			{
				if (cultInfo == null)
				{
					return CultureInfo.CurrentCulture;
				}
				return cultInfo;
			}
		}

		private XmlCollation(CultureInfo cultureInfo, Options options)
		{
			cultInfo = cultureInfo;
			this.options = options;
			compops = options.CompareOptions;
		}

		internal static XmlCollation Create(string collationLiteral)
		{
			return Create(collationLiteral, throwOnError: true);
		}

		internal static XmlCollation Create(string collationLiteral, bool throwOnError)
		{
			if (collationLiteral == "http://www.w3.org/2004/10/xpath-functions/collation/codepoint")
			{
				return CodePointCollation;
			}
			CultureInfo cultureInfo = null;
			Options options = default(Options);
			Uri result;
			if (throwOnError)
			{
				result = new Uri(collationLiteral);
			}
			else if (!Uri.TryCreate(collationLiteral, UriKind.Absolute, out result))
			{
				return null;
			}
			string leftPart = result.GetLeftPart(UriPartial.Authority);
			if (leftPart == "http://collations.microsoft.com")
			{
				string text = result.LocalPath.Substring(1);
				if (text.Length != 0)
				{
					try
					{
						cultureInfo = new CultureInfo(text);
					}
					catch (ArgumentException)
					{
						if (!throwOnError)
						{
							return null;
						}
						throw new XslTransformException("Coll_UnsupportedLanguage", text);
					}
				}
			}
			else
			{
				if (!result.IsBaseOf(new Uri("http://www.w3.org/2004/10/xpath-functions/collation/codepoint")))
				{
					if (!throwOnError)
					{
						return null;
					}
					throw new XslTransformException("Coll_Unsupported", collationLiteral);
				}
				options.CompareOptions = CompareOptions.Ordinal;
			}
			string query = result.Query;
			string text2 = null;
			if (query.Length != 0)
			{
				string[] array = query.Substring(1).Split('&');
				foreach (string text3 in array)
				{
					string[] array2 = text3.Split('=');
					if (array2.Length != 2)
					{
						if (!throwOnError)
						{
							return null;
						}
						throw new XslTransformException("Coll_BadOptFormat", text3);
					}
					string text4 = array2[0].ToUpper(CultureInfo.InvariantCulture);
					string text5 = array2[1].ToUpper(CultureInfo.InvariantCulture);
					if (text4 == "SORT")
					{
						text2 = text5;
						continue;
					}
					int flag;
					switch (text4)
					{
					case "IGNORECASE":
						flag = 1;
						break;
					case "IGNORENONSPACE":
						flag = 2;
						break;
					case "IGNORESYMBOLS":
						flag = 4;
						break;
					case "IGNOREKANATYPE":
						flag = 8;
						break;
					case "IGNOREWIDTH":
						flag = 16;
						break;
					case "UPPERFIRST":
						flag = 4096;
						break;
					case "EMPTYGREATEST":
						flag = 8192;
						break;
					case "DESCENDINGORDER":
						flag = 16384;
						break;
					default:
						if (!throwOnError)
						{
							return null;
						}
						throw new XslTransformException("Coll_UnsupportedOpt", array2[0]);
					}
					switch (text5)
					{
					case "0":
					case "FALSE":
						options.SetFlag(flag, value: false);
						continue;
					case "1":
					case "TRUE":
						options.SetFlag(flag, value: true);
						continue;
					}
					if (!throwOnError)
					{
						return null;
					}
					throw new XslTransformException("Coll_UnsupportedOptVal", array2[0], array2[1]);
				}
			}
			if (options.UpperFirst && options.IgnoreCase)
			{
				options.UpperFirst = false;
			}
			if (options.Ordinal)
			{
				options.CompareOptions = CompareOptions.Ordinal;
				options.UpperFirst = false;
			}
			if (text2 != null && cultureInfo != null)
			{
				int langID = GetLangID(cultureInfo.LCID);
				switch (text2)
				{
				case "bopo":
					if (langID == 1028)
					{
						cultureInfo = new CultureInfo(197636);
					}
					break;
				case "strk":
					if (langID == 2052 || langID == 3076 || langID == 4100 || langID == 5124)
					{
						cultureInfo = new CultureInfo(MakeLCID(cultureInfo.LCID, 2));
					}
					break;
				case "uni":
					if (langID == 1041 || langID == 1042)
					{
						cultureInfo = new CultureInfo(MakeLCID(cultureInfo.LCID, 1));
					}
					break;
				case "phn":
					if (langID == 1031)
					{
						cultureInfo = new CultureInfo(66567);
					}
					break;
				case "tech":
					if (langID == 1038)
					{
						cultureInfo = new CultureInfo(66574);
					}
					break;
				case "mod":
					if (langID == 1079)
					{
						cultureInfo = new CultureInfo(66615);
					}
					break;
				default:
					if (!throwOnError)
					{
						return null;
					}
					throw new XslTransformException("Coll_UnsupportedSortOpt", text2);
				case "pron":
				case "dict":
				case "trad":
					break;
				}
			}
			return new XmlCollation(cultureInfo, options);
		}

		/// <summary>Returns <see langword="true" /> if this XML extension function has the same values as another XML extension function.</summary>
		/// <param name="obj">
		///   <see cref="T:System.Object" /> with which to determine equality.</param>
		/// <returns>
		///   <see langword="true" /> if this XML extension function has the same values as another XML extension function; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (this == obj)
			{
				return true;
			}
			if (obj is XmlCollation xmlCollation && (int)options == (int)xmlCollation.options)
			{
				return object.Equals(cultInfo, xmlCollation.cultInfo);
			}
			return false;
		}

		/// <summary>Returns the object's hash code.</summary>
		/// <returns>The object's hash code.</returns>
		public override int GetHashCode()
		{
			int num = options;
			if (cultInfo != null)
			{
				num ^= cultInfo.GetHashCode();
			}
			return num;
		}

		internal void GetObjectData(BinaryWriter writer)
		{
			writer.Write((cultInfo != null) ? cultInfo.LCID : (-1));
			writer.Write(options);
		}

		internal XmlCollation(BinaryReader reader)
		{
			int num = reader.ReadInt32();
			cultInfo = ((num != -1) ? new CultureInfo(num) : null);
			options = new Options(reader.ReadInt32());
			compops = options.CompareOptions;
		}

		internal XmlSortKey CreateSortKey(string s)
		{
			System.Globalization.SortKey sortKey = Culture.CompareInfo.GetSortKey(s, compops);
			if (!UpperFirst)
			{
				return new XmlStringSortKey(sortKey, DescendingOrder);
			}
			byte[] keyData = sortKey.KeyData;
			if (UpperFirst && keyData.Length != 0)
			{
				int i;
				for (i = 0; keyData[i] != 1; i++)
				{
				}
				do
				{
					i++;
				}
				while (keyData[i] != 1);
				do
				{
					i++;
					keyData[i] ^= byte.MaxValue;
				}
				while (keyData[i] != 254);
			}
			return new XmlStringSortKey(keyData, DescendingOrder);
		}

		private static int MakeLCID(int langid, int sortid)
		{
			return (langid & 0xFFFF) | ((sortid & 0xF) << 16);
		}

		private static int GetLangID(int lcid)
		{
			return lcid & 0xFFFF;
		}
	}
	internal class XmlExtensionFunctionTable
	{
		private Dictionary<XmlExtensionFunction, XmlExtensionFunction> table;

		private XmlExtensionFunction funcCached;

		public XmlExtensionFunctionTable()
		{
			table = new Dictionary<XmlExtensionFunction, XmlExtensionFunction>();
		}

		public XmlExtensionFunction Bind(string name, string namespaceUri, int numArgs, Type objectType, BindingFlags flags)
		{
			if (funcCached == null)
			{
				funcCached = new XmlExtensionFunction();
			}
			funcCached.Init(name, namespaceUri, numArgs, objectType, flags);
			if (!table.TryGetValue(funcCached, out var value))
			{
				value = funcCached;
				funcCached = null;
				value.Bind();
				table.Add(value, value);
			}
			return value;
		}
	}
	internal class XmlExtensionFunction
	{
		private string namespaceUri;

		private string name;

		private int numArgs;

		private Type objectType;

		private BindingFlags flags;

		private int hashCode;

		private MethodInfo meth;

		private Type[] argClrTypes;

		private Type retClrType;

		private XmlQueryType[] argXmlTypes;

		private XmlQueryType retXmlType;

		public MethodInfo Method => meth;

		public Type ClrReturnType => retClrType;

		public XmlQueryType XmlReturnType => retXmlType;

		public XmlExtensionFunction()
		{
		}

		public XmlExtensionFunction(string name, string namespaceUri, MethodInfo meth)
		{
			this.name = name;
			this.namespaceUri = namespaceUri;
			Bind(meth);
		}

		public XmlExtensionFunction(string name, string namespaceUri, int numArgs, Type objectType, BindingFlags flags)
		{
			Init(name, namespaceUri, numArgs, objectType, flags);
		}

		public void Init(string name, string namespaceUri, int numArgs, Type objectType, BindingFlags flags)
		{
			this.name = name;
			this.namespaceUri = namespaceUri;
			this.numArgs = numArgs;
			this.objectType = objectType;
			this.flags = flags;
			meth = null;
			argClrTypes = null;
			retClrType = null;
			argXmlTypes = null;
			retXmlType = null;
			hashCode = namespaceUri.GetHashCode() ^ name.GetHashCode() ^ ((int)flags << 16) ^ numArgs;
		}

		public Type GetClrArgumentType(int index)
		{
			return argClrTypes[index];
		}

		public XmlQueryType GetXmlArgumentType(int index)
		{
			return argXmlTypes[index];
		}

		public bool CanBind()
		{
			MethodInfo[] methods = objectType.GetMethods(flags);
			StringComparison comparisonType = (((flags & BindingFlags.IgnoreCase) != 0) ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
			MethodInfo[] array = methods;
			foreach (MethodInfo methodInfo in array)
			{
				if (methodInfo.Name.Equals(name, comparisonType) && (numArgs == -1 || methodInfo.GetParameters().Length == numArgs) && !methodInfo.IsGenericMethodDefinition)
				{
					return true;
				}
			}
			return false;
		}

		public void Bind()
		{
			MethodInfo[] methods = objectType.GetMethods(flags);
			MethodInfo methodInfo = null;
			StringComparison comparisonType = (((flags & BindingFlags.IgnoreCase) != 0) ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
			MethodInfo[] array = methods;
			foreach (MethodInfo methodInfo2 in array)
			{
				if (methodInfo2.Name.Equals(name, comparisonType) && (numArgs == -1 || methodInfo2.GetParameters().Length == numArgs))
				{
					if (methodInfo != null)
					{
						throw new XslTransformException("XmlIl_AmbiguousExtensionMethod", namespaceUri, name, numArgs.ToString(CultureInfo.InvariantCulture));
					}
					methodInfo = methodInfo2;
				}
			}
			if (methodInfo == null)
			{
				methods = objectType.GetMethods(flags | BindingFlags.NonPublic);
				MethodInfo[] array2 = methods;
				foreach (MethodInfo methodInfo3 in array2)
				{
					if (methodInfo3.Name.Equals(name, comparisonType) && methodInfo3.GetParameters().Length == numArgs)
					{
						throw new XslTransformException("XmlIl_NonPublicExtensionMethod", namespaceUri, name);
					}
				}
				throw new XslTransformException("XmlIl_NoExtensionMethod", namespaceUri, name, numArgs.ToString(CultureInfo.InvariantCulture));
			}
			if (methodInfo.IsGenericMethodDefinition)
			{
				throw new XslTransformException("XmlIl_GenericExtensionMethod", namespaceUri, name);
			}
			Bind(methodInfo);
		}

		private void Bind(MethodInfo meth)
		{
			ParameterInfo[] parameters = meth.GetParameters();
			this.meth = meth;
			argClrTypes = new Type[parameters.Length];
			for (int i = 0; i < parameters.Length; i++)
			{
				argClrTypes[i] = GetClrType(parameters[i].ParameterType);
			}
			retClrType = GetClrType(this.meth.ReturnType);
			argXmlTypes = new XmlQueryType[parameters.Length];
			for (int i = 0; i < parameters.Length; i++)
			{
				argXmlTypes[i] = InferXmlType(argClrTypes[i]);
				if (namespaceUri.Length == 0)
				{
					if ((object)argXmlTypes[i] == XmlQueryTypeFactory.NodeNotRtf)
					{
						argXmlTypes[i] = XmlQueryTypeFactory.Node;
					}
					else if ((object)argXmlTypes[i] == XmlQueryTypeFactory.NodeSDod)
					{
						argXmlTypes[i] = XmlQueryTypeFactory.NodeS;
					}
				}
				else if ((object)argXmlTypes[i] == XmlQueryTypeFactory.NodeSDod)
				{
					argXmlTypes[i] = XmlQueryTypeFactory.NodeNotRtfS;
				}
			}
			retXmlType = InferXmlType(retClrType);
		}

		public object Invoke(object extObj, object[] args)
		{
			try
			{
				return meth.Invoke(extObj, flags, null, args, CultureInfo.InvariantCulture);
			}
			catch (TargetInvocationException ex)
			{
				throw new XslTransformException(ex.InnerException, "XmlIl_ExtensionError", name);
			}
			catch (Exception ex2)
			{
				if (!XmlException.IsCatchableException(ex2))
				{
					throw;
				}
				throw new XslTransformException(ex2, "XmlIl_ExtensionError", name);
			}
		}

		public override bool Equals(object other)
		{
			XmlExtensionFunction xmlExtensionFunction = other as XmlExtensionFunction;
			if (hashCode == xmlExtensionFunction.hashCode && name == xmlExtensionFunction.name && namespaceUri == xmlExtensionFunction.namespaceUri && numArgs == xmlExtensionFunction.numArgs && objectType == xmlExtensionFunction.objectType)
			{
				return flags == xmlExtensionFunction.flags;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return hashCode;
		}

		private Type GetClrType(Type clrType)
		{
			if (clrType.IsEnum)
			{
				return Enum.GetUnderlyingType(clrType);
			}
			if (clrType.IsByRef)
			{
				throw new XslTransformException("XmlIl_ByRefType", namespaceUri, name);
			}
			return clrType;
		}

		private XmlQueryType InferXmlType(Type clrType)
		{
			return XsltConvert.InferXsltType(clrType);
		}
	}
	/// <summary>Manages nodes from an input document, indexed by key value(s). This class is used as a cache of nodes indexed by <c>xsl:key</c> instructions and allows fast access to these nodes.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlILIndex
	{
		private Dictionary<string, XmlQueryNodeSequence> table;

		internal XmlILIndex()
		{
			table = new Dictionary<string, XmlQueryNodeSequence>();
		}

		/// <summary>Adds a node that is indexed by the specified key value.</summary>
		/// <param name="key">The specified key.</param>
		/// <param name="navigator">An instance of <see cref="T:System.Xml.XPath.XPathNavigator" />.</param>
		public void Add(string key, XPathNavigator navigator)
		{
			if (!table.TryGetValue(key, out var value))
			{
				value = new XmlQueryNodeSequence();
				value.AddClone(navigator);
				table.Add(key, value);
			}
			else if (!navigator.IsSamePosition(value[value.Count - 1]))
			{
				value.AddClone(navigator);
			}
		}

		/// <summary>Looks up a sequence of nodes that are indexed by the specified key value.</summary>
		/// <param name="key">The specified key.</param>
		/// <returns>A sequence of nodes that are indexed by the specified key value.</returns>
		public XmlQueryNodeSequence Lookup(string key)
		{
			if (!table.TryGetValue(key, out var value))
			{
				return new XmlQueryNodeSequence();
			}
			return value;
		}
	}
	/// <summary>Represents an internal class that provides static helper methods that get a value converter from <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> to convert among several physical common language runtime (CLR) representations for the same logical XML type.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static class XmlILStorageConverter
	{
		/// <summary>Converts a string value to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">A value of type <see langword="String" /> to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="String" /> value.</returns>
		public static XmlAtomicValue StringToAtomicValue(string value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts a decimal value to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">A value of type <see langword="Decimal" /> to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="Decimal" /> value.</returns>
		public static XmlAtomicValue DecimalToAtomicValue(decimal value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts an <see langword="Int64" /> value to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">A value of type <see langword="Int64" /> to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="Int64" /> value.</returns>
		public static XmlAtomicValue Int64ToAtomicValue(long value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts an <see langword="Int32" /> value to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">A value of type <see langword="Int32" /> to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="Int32" /> value.</returns>
		public static XmlAtomicValue Int32ToAtomicValue(int value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts a Boolean value to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">The <see langword="Boolean" /> value to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="Boolean" /> value.</returns>
		public static XmlAtomicValue BooleanToAtomicValue(bool value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts a <see langword="Double" /> value to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">A value of type <see langword="Double" /> to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="Double" /> value.</returns>
		public static XmlAtomicValue DoubleToAtomicValue(double value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts a <see langword="Single" /> value to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">A value of type <see langword="Single" /> to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="Single" /> value.</returns>
		public static XmlAtomicValue SingleToAtomicValue(float value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts a <see langword="DateTime" /> value to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">A value of type <see langword="DateTime" /> to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="DateTime" /> value.</returns>
		public static XmlAtomicValue DateTimeToAtomicValue(DateTime value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts an <see cref="T:System.Xml.XmlQualifiedName" /> value to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">An instance of the <see cref="T:System.Xml.XmlQualifiedName" /> class to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="XmlQualifiedName" /> value.</returns>
		public static XmlAtomicValue XmlQualifiedNameToAtomicValue(XmlQualifiedName value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts a <see cref="T:System.TimeSpan" /> value to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">A value of type <see cref="T:System.TimeSpan" /> to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="TimeSpan" /> value.</returns>
		public static XmlAtomicValue TimeSpanToAtomicValue(TimeSpan value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts an array of bytes to an <see cref="T:System.Xml.Schema.XmlAtomicValue" />.</summary>
		/// <param name="value">An array of <see langword="Byte" /> to convert.</param>
		/// <param name="index">A value of type <see langword="Int32" /> that provides the index of the item to convert.</param>
		/// <param name="runtime">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryRuntime" /> class.</param>
		/// <returns>The <see cref="T:System.Xml.Schema.XmlAtomicValue" /> object for the <see langword="Byte" /> array.</returns>
		public static XmlAtomicValue BytesToAtomicValue(byte[] value, int index, XmlQueryRuntime runtime)
		{
			return new XmlAtomicValue(runtime.GetXmlType(index).SchemaType, value);
		}

		/// <summary>Converts a sequence of <see cref="T:System.Xml.XPath.XPathNavigator" /> objects or values to a list or sequence of <see cref="T:System.Xml.XPath.XPathItem" /> objects.</summary>
		/// <param name="listNavigators">A sequence of <see cref="T:System.Xml.XPath.XPathNavigator" /> instances.</param>
		/// <returns>A generic list of type <see cref="T:System.Xml.XPath.XPathItem" />.</returns>
		public static IList<XPathItem> NavigatorsToItems(IList<XPathNavigator> listNavigators)
		{
			if (listNavigators is IList<XPathItem> result)
			{
				return result;
			}
			return new XmlQueryNodeSequence(listNavigators);
		}

		/// <summary>Converts a list or sequence of <see cref="T:System.Xml.XPath.XPathItem" /> objects to a sequence of <see cref="T:System.Xml.XPath.XPathNavigator" /> objects or values.</summary>
		/// <param name="listItems">A sequence of <see cref="T:System.Xml.XPath.XPathItem" /> instances.</param>
		/// <returns>A generic list of type <see cref="T:System.Xml.XPath.XPathNavigator" />.</returns>
		public static IList<XPathNavigator> ItemsToNavigators(IList<XPathItem> listItems)
		{
			if (listItems is IList<XPathNavigator> result)
			{
				return result;
			}
			XmlQueryNodeSequence xmlQueryNodeSequence = new XmlQueryNodeSequence(listItems.Count);
			for (int i = 0; i < listItems.Count; i++)
			{
				xmlQueryNodeSequence.Add((XPathNavigator)listItems[i]);
			}
			return xmlQueryNodeSequence;
		}
	}
	/// <summary>Iterators that use containment to control a nested iterator return one of the values in this enumeration.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public enum IteratorResult
	{
		/// <summary>Iteration is complete; there are no more nodes</summary>
		NoMoreNodes,
		/// <summary>The next node must be fetched from the contained iterator before iteration can continue.</summary>
		NeedInputNode,
		/// <summary>Iteration is complete; there are no more nodes.</summary>
		HaveCurrentNode
	}
	/// <summary>Tokenizes a string that contains IDREF values and dereferences the values in order to get a list of ID elements.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct IdIterator
	{
		private XPathNavigator navCurrent;

		private string[] idrefs;

		private int idx;

		/// <summary>Returns the current result navigator.</summary>
		/// <returns>The current result navigator.</returns>
		public XPathNavigator Current => navCurrent;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.IdIterator" />.</summary>
		/// <param name="context">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object that contains context.</param>
		/// <param name="value">String to contain the value of the iterator.</param>
		public void Create(XPathNavigator context, string value)
		{
			navCurrent = XmlQueryRuntime.SyncToNavigator(navCurrent, context);
			idrefs = XmlConvert.SplitString(value);
			idx = -1;
		}

		/// <summary>Positions the iterator on the next ID element.</summary>
		/// <returns>
		///   <see langword="true" /> if the next node exists; otherwise, <see langword="false" />.</returns>
		public bool MoveNext()
		{
			do
			{
				idx++;
				if (idx >= idrefs.Length)
				{
					return false;
				}
			}
			while (!navCurrent.MoveToId(idrefs[idx]));
			return true;
		}
	}
	/// <summary>
	///   <see langword="XmlNavigatorFilter" /> provides a flexible filtering abstraction over <see cref="T:System.Xml.XPath.XPathNavigator" />. Callers do not know what type of filtering will occur; they simply call <see cref="M:System.Xml.Xsl.Runtime.XmlNavigatorFilter.MoveToContent(System.Xml.XPath.XPathNavigator)" /> or <see cref="M:System.Xml.Xsl.Runtime.XmlNavigatorFilter.MoveToFollowingSibling(System.Xml.XPath.XPathNavigator)" />. The filter implementation invokes the appropriate operation on the <see cref="T:System.Xml.XPath.XPathNavigator" /> in order to skip over filtered nodes.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public abstract class XmlNavigatorFilter
	{
		/// <summary>Repositions the navigator to the first matching content node or attribute and skips over filtered nodes. If there are no matching nodes, the navigator does not move and the method returns false.</summary>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <returns>
		///   <see langword="true" /> if the navigator is repositioned on a child element with a matching name, otherwise, <see langword="false" />.</returns>
		public abstract bool MoveToContent(XPathNavigator navigator);

		/// <summary>Repositions the navigator to the next matching content node or attribute and skips over filtered nodes. If there are no matching nodes, the navigator does not move and the method returns false.</summary>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <returns>
		///   <see langword="true" /> if the navigator is repositioned on the next element child with a matching name, otherwise, <see langword="false" />.</returns>
		public abstract bool MoveToNextContent(XPathNavigator navigator);

		/// <summary>Repositions the navigator to the sibling matching content node or descendent and skips over filtered nodes. If there are no matching nodes, the navigator does not move and the method returns false.</summary>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <returns>
		///   <see langword="true" /> if the navigator is repositioned on the next element sibling with a matching name, otherwise, <see langword="false" />.</returns>
		public abstract bool MoveToFollowingSibling(XPathNavigator navigator);

		/// <summary>Repositions the navigator to the previous matching sibling node and skips over filtered nodes. If there are no matching nodes, the navigator does not move and the method returns false.</summary>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <returns>
		///   <see langword="true" /> if the navigator is repositioned on the previous element sibling with a matching name, otherwise, <see langword="false" />.</returns>
		public abstract bool MoveToPreviousSibling(XPathNavigator navigator);

		/// <summary>Repositions the navigator to the following matching content node or attribute and skips over filtered nodes. If there are no matching nodes, the navigator does not move and the method returns false.</summary>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class that identifies the beginning of the range over which navigation can move.</param>
		/// <param name="navigatorEnd">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class that identifies the end of the range over which navigation can move.</param>
		/// <returns>
		///   <see langword="true" /> if the navigator is repositioned on the next element with a matching name, otherwise, <see langword="false" />.</returns>
		public abstract bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navigatorEnd);

		/// <summary>Return <see langword="true" /> if the navigator's current node matches the filter condition.</summary>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <returns>
		///   <see langword="true" /> if the current node matches the condition; otherwise, <see langword="false" />.</returns>
		public abstract bool IsFiltered(XPathNavigator navigator);

		/// <summary>Provides a flexible filtering abstraction over <see cref="T:System.Xml.XPath.XPathNavigator" />.</summary>
		protected XmlNavigatorFilter()
		{
		}
	}
	internal class XmlNavNameFilter : XmlNavigatorFilter
	{
		private string localName;

		private string namespaceUri;

		public static XmlNavigatorFilter Create(string localName, string namespaceUri)
		{
			return new XmlNavNameFilter(localName, namespaceUri);
		}

		private XmlNavNameFilter(string localName, string namespaceUri)
		{
			this.localName = localName;
			this.namespaceUri = namespaceUri;
		}

		public override bool MoveToContent(XPathNavigator navigator)
		{
			return navigator.MoveToChild(localName, namespaceUri);
		}

		public override bool MoveToNextContent(XPathNavigator navigator)
		{
			return navigator.MoveToNext(localName, namespaceUri);
		}

		public override bool MoveToFollowingSibling(XPathNavigator navigator)
		{
			return navigator.MoveToNext(localName, namespaceUri);
		}

		public override bool MoveToPreviousSibling(XPathNavigator navigator)
		{
			return navigator.MoveToPrevious(localName, namespaceUri);
		}

		public override bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd)
		{
			return navigator.MoveToFollowing(localName, namespaceUri, navEnd);
		}

		public override bool IsFiltered(XPathNavigator navigator)
		{
			if (!(navigator.LocalName != localName))
			{
				return navigator.NamespaceURI != namespaceUri;
			}
			return true;
		}
	}
	internal class XmlNavTypeFilter : XmlNavigatorFilter
	{
		private static XmlNavigatorFilter[] TypeFilters;

		private XPathNodeType nodeType;

		private int mask;

		static XmlNavTypeFilter()
		{
			TypeFilters = new XmlNavigatorFilter[9];
			TypeFilters[1] = new XmlNavTypeFilter(XPathNodeType.Element);
			TypeFilters[4] = new XmlNavTypeFilter(XPathNodeType.Text);
			TypeFilters[7] = new XmlNavTypeFilter(XPathNodeType.ProcessingInstruction);
			TypeFilters[8] = new XmlNavTypeFilter(XPathNodeType.Comment);
		}

		public static XmlNavigatorFilter Create(XPathNodeType nodeType)
		{
			return TypeFilters[(int)nodeType];
		}

		private XmlNavTypeFilter(XPathNodeType nodeType)
		{
			this.nodeType = nodeType;
			mask = XPathNavigator.GetContentKindMask(nodeType);
		}

		public override bool MoveToContent(XPathNavigator navigator)
		{
			return navigator.MoveToChild(nodeType);
		}

		public override bool MoveToNextContent(XPathNavigator navigator)
		{
			return navigator.MoveToNext(nodeType);
		}

		public override bool MoveToFollowingSibling(XPathNavigator navigator)
		{
			return navigator.MoveToNext(nodeType);
		}

		public override bool MoveToPreviousSibling(XPathNavigator navigator)
		{
			return navigator.MoveToPrevious(nodeType);
		}

		public override bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd)
		{
			return navigator.MoveToFollowing(nodeType, navEnd);
		}

		public override bool IsFiltered(XPathNavigator navigator)
		{
			return ((1 << (int)navigator.NodeType) & mask) == 0;
		}
	}
	internal class XmlNavAttrFilter : XmlNavigatorFilter
	{
		private static XmlNavigatorFilter Singleton = new XmlNavAttrFilter();

		public static XmlNavigatorFilter Create()
		{
			return Singleton;
		}

		private XmlNavAttrFilter()
		{
		}

		public override bool MoveToContent(XPathNavigator navigator)
		{
			return navigator.MoveToFirstChild();
		}

		public override bool MoveToNextContent(XPathNavigator navigator)
		{
			return navigator.MoveToNext();
		}

		public override bool MoveToFollowingSibling(XPathNavigator navigator)
		{
			return navigator.MoveToNext();
		}

		public override bool MoveToPreviousSibling(XPathNavigator navigator)
		{
			return navigator.MoveToPrevious();
		}

		public override bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd)
		{
			return navigator.MoveToFollowing(XPathNodeType.All, navEnd);
		}

		public override bool IsFiltered(XPathNavigator navigator)
		{
			return navigator.NodeType == XPathNodeType.Attribute;
		}
	}
	internal class XmlNavNeverFilter : XmlNavigatorFilter
	{
		private static XmlNavigatorFilter Singleton = new XmlNavNeverFilter();

		public static XmlNavigatorFilter Create()
		{
			return Singleton;
		}

		private XmlNavNeverFilter()
		{
		}

		public override bool MoveToContent(XPathNavigator navigator)
		{
			return MoveToFirstAttributeContent(navigator);
		}

		public override bool MoveToNextContent(XPathNavigator navigator)
		{
			return MoveToNextAttributeContent(navigator);
		}

		public override bool MoveToFollowingSibling(XPathNavigator navigator)
		{
			return navigator.MoveToNext();
		}

		public override bool MoveToPreviousSibling(XPathNavigator navigator)
		{
			return navigator.MoveToPrevious();
		}

		public override bool MoveToFollowing(XPathNavigator navigator, XPathNavigator navEnd)
		{
			return navigator.MoveToFollowing(XPathNodeType.All, navEnd);
		}

		public override bool IsFiltered(XPathNavigator navigator)
		{
			return false;
		}

		public static bool MoveToFirstAttributeContent(XPathNavigator navigator)
		{
			if (!navigator.MoveToFirstAttribute())
			{
				return navigator.MoveToFirstChild();
			}
			return true;
		}

		public static bool MoveToNextAttributeContent(XPathNavigator navigator)
		{
			if (navigator.NodeType == XPathNodeType.Attribute)
			{
				if (!navigator.MoveToNextAttribute())
				{
					navigator.MoveToParent();
					if (!navigator.MoveToFirstChild())
					{
						navigator.MoveToFirstAttribute();
						while (navigator.MoveToNextAttribute())
						{
						}
						return false;
					}
				}
				return true;
			}
			return navigator.MoveToNext();
		}
	}
	internal struct XmlNavigatorStack
	{
		private XPathNavigator[] stkNav;

		private int sp;

		private const int InitialStackSize = 8;

		public bool IsEmpty => sp == 0;

		public void Push(XPathNavigator nav)
		{
			if (stkNav == null)
			{
				stkNav = new XPathNavigator[8];
			}
			else if (sp >= stkNav.Length)
			{
				XPathNavigator[] sourceArray = stkNav;
				stkNav = new XPathNavigator[2 * sp];
				Array.Copy(sourceArray, stkNav, sp);
			}
			stkNav[sp++] = nav;
		}

		public XPathNavigator Pop()
		{
			return stkNav[--sp];
		}

		public XPathNavigator Peek()
		{
			return stkNav[sp - 1];
		}

		public void Reset()
		{
			sp = 0;
		}
	}
	/// <summary>The context of a query consists of all user-provided information that influences the operation of the query.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlQueryContext
	{
		private XmlQueryRuntime runtime;

		private XPathNavigator defaultDataSource;

		private XmlResolver dataSources;

		private Hashtable dataSourceCache;

		private XsltArgumentList argList;

		private XmlExtensionFunctionTable extFuncsLate;

		private WhitespaceRuleLookup wsRules;

		private QueryReaderSettings readerSettings;

		/// <summary>Gets the <see cref="T:System.Xml.XmlNameTable" /> instance.</summary>
		/// <returns>An instance of the <see cref="T:System.Xml.XmlNameTable" />.</returns>
		public XmlNameTable QueryNameTable => readerSettings.NameTable;

		/// <summary>Returns the name table used by the default data source, or null if there is no default data source.</summary>
		/// <returns>An instance of the <see cref="T:System.Xml.XmlNameTable" /> class.</returns>
		public XmlNameTable DefaultNameTable
		{
			get
			{
				if (defaultDataSource == null)
				{
					return null;
				}
				return defaultDataSource.NameTable;
			}
		}

		/// <summary>Returns the document that is queried by default if no data source is explicitly selected in the query.</summary>
		/// <returns>An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</returns>
		public XPathNavigator DefaultDataSource
		{
			get
			{
				if (defaultDataSource == null)
				{
					throw new XslTransformException("XmlIl_NoDefaultDocument", string.Empty);
				}
				return defaultDataSource;
			}
		}

		internal XmlQueryContext(XmlQueryRuntime runtime, object defaultDataSource, XmlResolver dataSources, XsltArgumentList argList, WhitespaceRuleLookup wsRules)
		{
			this.runtime = runtime;
			this.dataSources = dataSources;
			dataSourceCache = new Hashtable();
			this.argList = argList;
			this.wsRules = wsRules;
			if (defaultDataSource is XmlReader)
			{
				readerSettings = new QueryReaderSettings((XmlReader)defaultDataSource);
			}
			else
			{
				readerSettings = new QueryReaderSettings(new NameTable());
			}
			if (defaultDataSource is string)
			{
				this.defaultDataSource = GetDataSource(defaultDataSource as string, null);
				if (this.defaultDataSource == null)
				{
					throw new XslTransformException("XmlIl_UnknownDocument", defaultDataSource as string);
				}
			}
			else if (defaultDataSource != null)
			{
				this.defaultDataSource = ConstructDocument(defaultDataSource, null, null);
			}
		}

		/// <summary>Gets the data source specified by the <paramref name="uriRelative" /> and <paramref name="uriBase" /> from the <c>T:System.Xml.XmlResolver</c> that the user provided.</summary>
		/// <param name="uriRelative">A value of type <see langword="string" />.</param>
		/// <param name="uriBase">A value of type <see langword="string" />.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</returns>
		public XPathNavigator GetDataSource(string uriRelative, string uriBase)
		{
			XPathNavigator xPathNavigator = null;
			try
			{
				Uri baseUri = ((uriBase != null) ? dataSources.ResolveUri(null, uriBase) : null);
				Uri uri = dataSources.ResolveUri(baseUri, uriRelative);
				if (uri != null)
				{
					xPathNavigator = dataSourceCache[uri] as XPathNavigator;
				}
				if (xPathNavigator == null)
				{
					object entity = dataSources.GetEntity(uri, null, null);
					if (entity != null)
					{
						xPathNavigator = ConstructDocument(entity, uriRelative, uri);
						dataSourceCache.Add(uri, xPathNavigator);
						return xPathNavigator;
					}
					return xPathNavigator;
				}
				return xPathNavigator;
			}
			catch (XslTransformException)
			{
				throw;
			}
			catch (Exception ex2)
			{
				if (!XmlException.IsCatchableException(ex2))
				{
					throw;
				}
				throw new XslTransformException(ex2, "XmlIl_DocumentLoadError", uriRelative);
			}
		}

		private XPathNavigator ConstructDocument(object dataSource, string uriRelative, Uri uriResolved)
		{
			if (dataSource is Stream stream)
			{
				XmlReader xmlReader = readerSettings.CreateReader(stream, (uriResolved != null) ? uriResolved.ToString() : null);
				try
				{
					return new XPathDocument(WhitespaceRuleReader.CreateReader(xmlReader, wsRules), XmlSpace.Preserve).CreateNavigator();
				}
				finally
				{
					xmlReader.Close();
				}
			}
			if (dataSource is XmlReader)
			{
				return new XPathDocument(WhitespaceRuleReader.CreateReader(dataSource as XmlReader, wsRules), XmlSpace.Preserve).CreateNavigator();
			}
			if (dataSource is IXPathNavigable)
			{
				if (wsRules != null)
				{
					throw new XslTransformException("XmlIl_CantStripNav", string.Empty);
				}
				return (dataSource as IXPathNavigable).CreateNavigator();
			}
			throw new XslTransformException("XmlIl_CantResolveEntity", uriRelative, dataSource.GetType().ToString());
		}

		/// <summary>Gets a named parameter from the external argument list.</summary>
		/// <param name="localName">A value of type <see langword="string" />.</param>
		/// <param name="namespaceUri">A value of type <see langword="string" />.</param>
		/// <returns>
		///   <see langword="null" /> if no argument list was provided, or if there is no parameter by that name; otherwise, a named parameter from the external argument list.</returns>
		public object GetParameter(string localName, string namespaceUri)
		{
			if (argList == null)
			{
				return null;
			}
			return argList.GetParam(localName, namespaceUri);
		}

		/// <summary>Returns the extension object that is mapped to the specified namespace, or null if no object is mapped.</summary>
		/// <param name="namespaceUri">A value of type <see langword="string" />.</param>
		/// <returns>An extension object.</returns>
		public object GetLateBoundObject(string namespaceUri)
		{
			if (argList == null)
			{
				return null;
			}
			return argList.GetExtensionObject(namespaceUri);
		}

		/// <summary>Returns true if the late-bound object identified by <paramref name="namespaceUri" /> contains a method that matches <paramref name="name" />.</summary>
		/// <param name="name">A value of type <see langword="string" />.</param>
		/// <param name="namespaceUri">A value of type <see langword="string" />.</param>
		/// <returns>
		///   <see langword="true" /> if the late bound object matches name; otherwise, <see langword="false" />.</returns>
		public bool LateBoundFunctionExists(string name, string namespaceUri)
		{
			if (argList == null)
			{
				return false;
			}
			object extensionObject = argList.GetExtensionObject(namespaceUri);
			if (extensionObject == null)
			{
				return false;
			}
			return new XmlExtensionFunction(name, namespaceUri, -1, extensionObject.GetType(), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public).CanBind();
		}

		/// <summary>Gets a late-bound extension object from the external argument list.</summary>
		/// <param name="name">A value of type <see langword="string" />.</param>
		/// <param name="namespaceUri">A value of type <see langword="string" />.</param>
		/// <param name="args">A sequence of <see cref="T:System.Xml.XPath.XPathItem" /> instances.</param>
		/// <returns>A generic list of type <see cref="T:System.Xml.XPath.XPathItem" />.</returns>
		public IList<XPathItem> InvokeXsltLateBoundFunction(string name, string namespaceUri, IList<XPathItem>[] args)
		{
			object obj = ((argList != null) ? argList.GetExtensionObject(namespaceUri) : null);
			if (obj == null)
			{
				throw new XslTransformException("XmlIl_UnknownExtObj", namespaceUri);
			}
			if (extFuncsLate == null)
			{
				extFuncsLate = new XmlExtensionFunctionTable();
			}
			XmlExtensionFunction xmlExtensionFunction = extFuncsLate.Bind(name, namespaceUri, args.Length, obj.GetType(), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);
			object[] array = new object[args.Length];
			for (int i = 0; i < args.Length; i++)
			{
				XmlQueryType xmlArgumentType = xmlExtensionFunction.GetXmlArgumentType(i);
				switch (xmlArgumentType.TypeCode)
				{
				case XmlTypeCode.Boolean:
					array[i] = XsltConvert.ToBoolean(args[i]);
					break;
				case XmlTypeCode.Double:
					array[i] = XsltConvert.ToDouble(args[i]);
					break;
				case XmlTypeCode.String:
					array[i] = XsltConvert.ToString(args[i]);
					break;
				case XmlTypeCode.Node:
					if (xmlArgumentType.IsSingleton)
					{
						array[i] = XsltConvert.ToNode(args[i]);
					}
					else
					{
						array[i] = XsltConvert.ToNodeSet(args[i]);
					}
					break;
				case XmlTypeCode.Item:
					array[i] = args[i];
					break;
				}
				Type clrArgumentType = xmlExtensionFunction.GetClrArgumentType(i);
				if (xmlArgumentType.TypeCode == XmlTypeCode.Item || !clrArgumentType.IsAssignableFrom(array[i].GetType()))
				{
					array[i] = runtime.ChangeTypeXsltArgument(xmlArgumentType, array[i], clrArgumentType);
				}
			}
			object obj2 = xmlExtensionFunction.Invoke(obj, array);
			if (obj2 == null && xmlExtensionFunction.ClrReturnType == XsltConvert.VoidType)
			{
				return XmlQueryNodeSequence.Empty;
			}
			return (IList<XPathItem>)runtime.ChangeTypeXsltResult(XmlQueryTypeFactory.ItemS, obj2);
		}

		/// <summary>Raises an <see cref="E:System.Xml.Xsl.XsltArgumentList.XsltMessageEncountered" /> event.</summary>
		/// <param name="message">A value of type <see langword="string" />.</param>
		public void OnXsltMessageEncountered(string message)
		{
			XsltMessageEncounteredEventHandler xsltMessageEncounteredEventHandler = ((argList != null) ? argList.xsltMessageEncountered : null);
			if (xsltMessageEncounteredEventHandler != null)
			{
				xsltMessageEncounteredEventHandler(this, new XmlILQueryEventArgs(message));
			}
			else
			{
				Console.WriteLine(message);
			}
		}
	}
	internal class XmlILQueryEventArgs : XsltMessageEncounteredEventArgs
	{
		private string message;

		public override string Message => message;

		public XmlILQueryEventArgs(string message)
		{
			this.message = message;
		}
	}
	internal enum XmlState
	{
		WithinSequence,
		EnumAttrs,
		WithinContent,
		WithinAttr,
		WithinNmsp,
		WithinComment,
		WithinPI
	}
	/// <summary>Represents an <see cref="T:System.Xml.XmlWriter" /> that provides additional functionality that is required for outputting the results of XSLT transformations.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlQueryOutput : XmlWriter
	{
		private XmlRawWriter xwrt;

		private XmlQueryRuntime runtime;

		private XmlAttributeCache attrCache;

		private int depth;

		private XmlState xstate;

		private XmlSequenceWriter seqwrt;

		private XmlNamespaceManager nsmgr;

		private int cntNmsp;

		private Dictionary<string, string> conflictPrefixes;

		private int prefixIndex;

		private string piTarget;

		private StringConcat nodeText;

		private Stack<string> stkNames;

		private XPathNodeType rootType;

		private Dictionary<string, string> usedPrefixes = new Dictionary<string, string>();

		internal XmlSequenceWriter SequenceWriter => seqwrt;

		internal XmlRawWriter Writer
		{
			get
			{
				return xwrt;
			}
			set
			{
				if (value is IRemovableWriter removableWriter)
				{
					removableWriter.OnRemoveWriterEvent = SetWrappedWriter;
				}
				xwrt = value;
			}
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <returns>A <see cref="T:System.Xml.WriteState" /> object.</returns>
		public override WriteState WriteState
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <returns>The <see cref="T:System.Xml.XmlSpace" /> object.</returns>
		public override XmlSpace XmlSpace
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <returns>A string that contains the language identifier.</returns>
		public override string XmlLang
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		internal XmlQueryOutput(XmlQueryRuntime runtime, XmlSequenceWriter seqwrt)
		{
			this.runtime = runtime;
			this.seqwrt = seqwrt;
			xstate = XmlState.WithinSequence;
		}

		internal XmlQueryOutput(XmlQueryRuntime runtime, XmlEventCache xwrt)
		{
			this.runtime = runtime;
			this.xwrt = xwrt;
			xstate = XmlState.WithinContent;
			depth = 1;
			rootType = XPathNodeType.Root;
		}

		private void SetWrappedWriter(XmlRawWriter writer)
		{
			if (Writer is XmlAttributeCache)
			{
				attrCache = (XmlAttributeCache)Writer;
			}
			Writer = writer;
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		public override void WriteStartDocument()
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <param name="standalone">Boolean that indicates whether to write the XML declaration with the version number that appears at the beginning of the document.</param>
		public override void WriteStartDocument(bool standalone)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		public override void WriteEndDocument()
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />. Should never be called.</summary>
		/// <param name="name">String that contains document name.</param>
		/// <param name="pubid">String that contains publication id.</param>
		/// <param name="sysid">String that contains system id.</param>
		/// <param name="subset">String that contains subset name.</param>
		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			throw new NotSupportedException();
		}

		/// <summary>Writes start element after checks that ensure well-formedness.</summary>
		/// <param name="prefix">String that contains the namespace prefix.</param>
		/// <param name="localName">String that contains the local name of the element.</param>
		/// <param name="ns">String that contains the namespace name.</param>
		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			ConstructWithinContent(XPathNodeType.Element);
			WriteStartElementUnchecked(prefix, localName, ns);
			WriteNamespaceDeclarationUnchecked(prefix, ns);
			if (attrCache == null)
			{
				attrCache = new XmlAttributeCache();
			}
			attrCache.Init(Writer);
			Writer = attrCache;
			attrCache = null;
			PushElementNames(prefix, localName, ns);
		}

		/// <summary>Checks the element for well-formedness and writes the end of the element.</summary>
		public override void WriteEndElement()
		{
			if (xstate == XmlState.EnumAttrs)
			{
				StartElementContentUnchecked();
			}
			PopElementNames(out var prefix, out var localName, out var ns);
			WriteEndElementUnchecked(prefix, localName, ns);
			if (depth == 0)
			{
				EndTree();
			}
		}

		/// <summary>Checks the element for well-formedness before writing the end of the element.</summary>
		public override void WriteFullEndElement()
		{
			WriteEndElement();
		}

		/// <summary>Checks the attribute for well-formedness before writing the start of the attribute.</summary>
		/// <param name="prefix">String that contains prefix of attribute.</param>
		/// <param name="localName">String that contains local name of attribute.</param>
		/// <param name="ns">String that contains namespace of attribute.</param>
		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			if (prefix.Length == 5 && prefix == "xmlns")
			{
				WriteStartNamespace(localName);
				return;
			}
			ConstructInEnumAttrs(XPathNodeType.Attribute);
			if (ns.Length != 0 && depth != 0)
			{
				prefix = CheckAttributePrefix(prefix, ns);
			}
			WriteStartAttributeUnchecked(prefix, localName, ns);
		}

		/// <summary>Checks the attribute for well-formedness and writes the end of the attribute.</summary>
		public override void WriteEndAttribute()
		{
			if (xstate == XmlState.WithinNmsp)
			{
				WriteEndNamespace();
				return;
			}
			WriteEndAttributeUnchecked();
			if (depth == 0)
			{
				EndTree();
			}
		}

		/// <summary>Writes the comment. The method does not verify well-formedness. Other methods called by this one do the necessary checks.</summary>
		/// <param name="text">String that contains the comment to write.</param>
		public override void WriteComment(string text)
		{
			WriteStartComment();
			WriteCommentString(text);
			WriteEndComment();
		}

		/// <summary>Writes the processing instruction. No checks for well-formedness are done by this method; the called methods do checks if needed.</summary>
		/// <param name="target">String that contains target of instruction.</param>
		/// <param name="text">String that contains text of instruction.</param>
		public override void WriteProcessingInstruction(string target, string text)
		{
			WriteStartProcessingInstruction(target);
			WriteProcessingInstructionString(text);
			WriteEndProcessingInstruction();
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <param name="name">String that contains name of entity.</param>
		public override void WriteEntityRef(string name)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <param name="ch">
		///   <see cref="T:System.Char" /> that contains a character to write.</param>
		public override void WriteCharEntity(char ch)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <param name="lowChar">
		///   <see cref="T:System.Char" /> of the low character.</param>
		/// <param name="highChar">
		///   <see cref="T:System.Char" /> of the high character.</param>
		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <param name="ws">String that contains the white space to write.</param>
		public override void WriteWhitespace(string ws)
		{
			throw new NotSupportedException();
		}

		/// <summary>Checks the string for well-formedness and writes text.</summary>
		/// <param name="text">String that contains text to write.</param>
		public override void WriteString(string text)
		{
			WriteString(text, disableOutputEscaping: false);
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <param name="buffer">
		///   <see cref="T:System.Char" /> array of buffer that contains data to write.</param>
		/// <param name="index">
		///   <see cref="T:System.Int32" /> that contains start index.</param>
		/// <param name="count">
		///   <see cref="T:System.Int32" /> that contains count of characters to write.</param>
		public override void WriteChars(char[] buffer, int index, int count)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <param name="buffer">
		///   <see cref="T:System.Char" /> buffer array to be written.</param>
		/// <param name="index">
		///   <see cref="T:System.Int32" /> that contains start index.</param>
		/// <param name="count">
		///   <see cref="T:System.Int32" /> that contains count characters to write.</param>
		public override void WriteRaw(char[] buffer, int index, int count)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <param name="data">String that contains raw data.</param>
		public override void WriteRaw(string data)
		{
			WriteString(data, disableOutputEscaping: true);
		}

		/// <summary>Empty implementation that does nothing.</summary>
		/// <param name="text">String that contains data to write.</param>
		public override void WriteCData(string text)
		{
			WriteString(text, disableOutputEscaping: false);
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <param name="buffer">
		///   <see cref="T:System.Byte" /> buffer object that contains data to write.</param>
		/// <param name="index">
		///   <see cref="T:System.Int32" /> that contains start index.</param>
		/// <param name="count">
		///   <see cref="T:System.Int32" /> that contains count bytes.</param>
		public override void WriteBase64(byte[] buffer, int index, int count)
		{
			throw new NotSupportedException();
		}

		/// <summary>This method is implemented as empty and does nothing.</summary>
		public override void Close()
		{
		}

		/// <summary>This method is implemented as empty and does nothing.</summary>
		public override void Flush()
		{
		}

		/// <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
		/// <param name="ns">String that contains namespace name.</param>
		/// <returns>A string that contains the prefix.</returns>
		public override string LookupPrefix(string ns)
		{
			throw new NotSupportedException();
		}

		/// <summary>Starts the construction of a new tree.</summary>
		/// <param name="rootType">
		///   <see cref="T:System.Xml.XPath.XPathNodeType" /> object.</param>
		public void StartTree(XPathNodeType rootType)
		{
			Writer = seqwrt.StartTree(rootType, nsmgr, runtime.NameTable);
			this.rootType = rootType;
			xstate = ((rootType == XPathNodeType.Attribute || rootType == XPathNodeType.Namespace) ? XmlState.EnumAttrs : XmlState.WithinContent);
		}

		/// <summary>Writes the end of the tree.</summary>
		public void EndTree()
		{
			seqwrt.EndTree();
			xstate = XmlState.WithinSequence;
			Writer = null;
		}

		/// <summary>Writes an element with a name that is computed from a <c>prefix:localName</c> tag name and a set of prefix mappings.</summary>
		/// <param name="prefix">String that contains the namespace prefix.</param>
		/// <param name="localName">String that contains the local name of the start element.</param>
		/// <param name="ns">String that contains the namespace name.</param>
		public void WriteStartElementUnchecked(string prefix, string localName, string ns)
		{
			if (nsmgr != null)
			{
				nsmgr.PushScope();
			}
			Writer.WriteStartElement(prefix, localName, ns);
			usedPrefixes.Clear();
			usedPrefixes[prefix] = ns;
			xstate = XmlState.EnumAttrs;
			depth++;
		}

		/// <summary>Writes the start of an element. There is an assumption of well-formedness, so no additional checks are performed.</summary>
		/// <param name="localName">String that contains the local name of the start element.</param>
		public void WriteStartElementUnchecked(string localName)
		{
			WriteStartElementUnchecked(string.Empty, localName, string.Empty);
		}

		/// <summary>Called after an element's attributes have been enumerated, but before any children have been enumerated. Well-formedness is assumed, so no additional checks are performed.</summary>
		public void StartElementContentUnchecked()
		{
			if (cntNmsp != 0)
			{
				WriteCachedNamespaces();
			}
			Writer.StartElementContent();
			xstate = XmlState.WithinContent;
		}

		/// <summary>Writes the end of the element with prefix, local name, and namespace. No checks are performed.</summary>
		/// <param name="prefix">String that contains element prefix.</param>
		/// <param name="localName">String that contains local name of element.</param>
		/// <param name="ns">String that contains namespace name.</param>
		public void WriteEndElementUnchecked(string prefix, string localName, string ns)
		{
			Writer.WriteEndElement(prefix, localName, ns);
			xstate = XmlState.WithinContent;
			depth--;
			if (nsmgr != null)
			{
				nsmgr.PopScope();
			}
		}

		/// <summary>Writes the end of the element with local name. Well-formedness is assumed, so no additional checks are performed.</summary>
		/// <param name="localName">String that contains local name of element.</param>
		public void WriteEndElementUnchecked(string localName)
		{
			WriteEndElementUnchecked(string.Empty, localName, string.Empty);
		}

		/// <summary>Writes the start of the attribute with prefix, local name and ns without checks for well-formedness.</summary>
		/// <param name="prefix">String that contains the prefix of the namespace.</param>
		/// <param name="localName">String that contains the local name of the attribute.</param>
		/// <param name="ns">String that contains the namespace.</param>
		public void WriteStartAttributeUnchecked(string prefix, string localName, string ns)
		{
			Writer.WriteStartAttribute(prefix, localName, ns);
			xstate = XmlState.WithinAttr;
			depth++;
		}

		/// <summary>Writes the start of the attribute with local name.</summary>
		/// <param name="localName">String that contains the local name of the attribute.</param>
		public void WriteStartAttributeUnchecked(string localName)
		{
			WriteStartAttributeUnchecked(string.Empty, localName, string.Empty);
		}

		/// <summary>Writes the end of the attribute. There is an assumption of well-formedness, so no additional checks are performed.</summary>
		public void WriteEndAttributeUnchecked()
		{
			Writer.WriteEndAttribute();
			xstate = XmlState.EnumAttrs;
			depth--;
		}

		/// <summary>Adds a new namespace declaration <c>- xmlns:prefix="ns"</c> - to the set of in-scope declarations. This method does not perform any additional checks.</summary>
		/// <param name="prefix">String that contains namespace prefix.</param>
		/// <param name="ns">String that contains namespace name.</param>
		public void WriteNamespaceDeclarationUnchecked(string prefix, string ns)
		{
			if (depth == 0)
			{
				Writer.WriteNamespaceDeclaration(prefix, ns);
				return;
			}
			if (nsmgr == null)
			{
				if (ns.Length == 0 && prefix.Length == 0)
				{
					return;
				}
				nsmgr = new XmlNamespaceManager(runtime.NameTable);
				nsmgr.PushScope();
			}
			if (nsmgr.LookupNamespace(prefix) != ns)
			{
				AddNamespace(prefix, ns);
			}
			usedPrefixes[prefix] = ns;
		}

		/// <summary>Writes text. Well-formedness is assumed, so no checks are performed.</summary>
		/// <param name="text">String that contains text to write.</param>
		public void WriteStringUnchecked(string text)
		{
			Writer.WriteString(text);
		}

		/// <summary>Writes a text block without escaping special characters.</summary>
		/// <param name="text">String that contains text to write.</param>
		public void WriteRawUnchecked(string text)
		{
			Writer.WriteRaw(text);
		}

		/// <summary>Checks the root of the tree for well-formedness and writes the root of the tree.</summary>
		public void WriteStartRoot()
		{
			if (xstate != 0)
			{
				ThrowInvalidStateError(XPathNodeType.Root);
			}
			StartTree(XPathNodeType.Root);
			depth++;
		}

		/// <summary>Writes the end of the root of the tree and resets the state.</summary>
		public void WriteEndRoot()
		{
			depth--;
			EndTree();
		}

		/// <summary>Writes the local name with an empty prefix and namespace.</summary>
		/// <param name="localName">String that contains the local name.</param>
		public void WriteStartElementLocalName(string localName)
		{
			WriteStartElement(string.Empty, localName, string.Empty);
		}

		/// <summary>Writes the start of the attribute with an empty prefix, namespace, and null schema type.</summary>
		/// <param name="localName">String that contains local name.</param>
		public void WriteStartAttributeLocalName(string localName)
		{
			WriteStartAttribute(string.Empty, localName, string.Empty);
		}

		/// <summary>Writes an element with a name that is computed from a <c>prefix:localName</c> tag name and a set of prefix mappings.</summary>
		/// <param name="tagName">String that contains the tag name.</param>
		/// <param name="prefixMappingsIndex">
		///   <see cref="T:System.Int32" /> that contains the index.</param>
		public void WriteStartElementComputed(string tagName, int prefixMappingsIndex)
		{
			WriteStartComputed(XPathNodeType.Element, tagName, prefixMappingsIndex);
		}

		/// <summary>Writes an element with a name that is computed from a <c>prefix:localName</c> tag name and a set of prefix mappings.</summary>
		/// <param name="tagName">String that contains the tag name.</param>
		/// <param name="ns">String that contains the namespace name.</param>
		public void WriteStartElementComputed(string tagName, string ns)
		{
			WriteStartComputed(XPathNodeType.Element, tagName, ns);
		}

		/// <summary>Writes an element with a name that is computed from a <c>prefix:localName</c> tag name and a set of prefix mappings.</summary>
		/// <param name="navigator">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		public void WriteStartElementComputed(XPathNavigator navigator)
		{
			WriteStartComputed(XPathNodeType.Element, navigator);
		}

		/// <summary>Writes an element with a name that is computed from a <c>prefix:localName</c> tag name and a set of prefix mappings.</summary>
		/// <param name="name">
		///   <see cref="T:System.Xml.XmlQualifiedName" /> that contains the name.</param>
		public void WriteStartElementComputed(XmlQualifiedName name)
		{
			WriteStartComputed(XPathNodeType.Element, name);
		}

		/// <summary>Writes an attribute with a name that is computed from a <c>prefix:localName</c> tag name and a set of prefix mappings.</summary>
		/// <param name="tagName">String that contains tag name.</param>
		/// <param name="prefixMappingsIndex">
		///   <see cref="T:System.Int32" /> that contains prefix mapping index.</param>
		public void WriteStartAttributeComputed(string tagName, int prefixMappingsIndex)
		{
			WriteStartComputed(XPathNodeType.Attribute, tagName, prefixMappingsIndex);
		}

		/// <summary>Writes an attribute with a name that is computed from a "prefix:localName" tag name and a set of prefix mappings.</summary>
		/// <param name="tagName">String that contains tag name of attribute.</param>
		/// <param name="ns">String that contains namespace of attribute.</param>
		public void WriteStartAttributeComputed(string tagName, string ns)
		{
			WriteStartComputed(XPathNodeType.Attribute, tagName, ns);
		}

		/// <summary>Writes an attribute with a name that is computed from a <c>prefix:localName</c> tag name and a set of prefix mappings.</summary>
		/// <param name="navigator">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		public void WriteStartAttributeComputed(XPathNavigator navigator)
		{
			WriteStartComputed(XPathNodeType.Attribute, navigator);
		}

		/// <summary>Writes an attribute with a name that is computed from a <c>prefix:localName</c> tag name and a set of prefix mappings.</summary>
		/// <param name="name">String that contains name of attribute.</param>
		public void WriteStartAttributeComputed(XmlQualifiedName name)
		{
			WriteStartComputed(XPathNodeType.Attribute, name);
		}

		/// <summary>Checks the namespace declaration for well-formedness and writes the namespace declaration.</summary>
		/// <param name="prefix">String that contains namespace prefix.</param>
		/// <param name="ns">String that contains namespace name.</param>
		public void WriteNamespaceDeclaration(string prefix, string ns)
		{
			ConstructInEnumAttrs(XPathNodeType.Namespace);
			if (nsmgr == null)
			{
				WriteNamespaceDeclarationUnchecked(prefix, ns);
			}
			else
			{
				string text = nsmgr.LookupNamespace(prefix);
				if (ns != text)
				{
					if (text != null && usedPrefixes.ContainsKey(prefix))
					{
						throw new XslTransformException("XmlIl_NmspConflict", (prefix.Length == 0) ? "" : ":", prefix, ns, text);
					}
					AddNamespace(prefix, ns);
				}
			}
			if (depth == 0)
			{
				EndTree();
			}
			usedPrefixes[prefix] = ns;
		}

		/// <summary>Checks for well-formedness and writes the start of the namespace.</summary>
		/// <param name="prefix">String that contains the namespace prefix.</param>
		public void WriteStartNamespace(string prefix)
		{
			ConstructInEnumAttrs(XPathNodeType.Namespace);
			piTarget = prefix;
			nodeText.Clear();
			xstate = XmlState.WithinNmsp;
			depth++;
		}

		/// <summary>Caches the namespace's text.</summary>
		/// <param name="text">String that contains fully qualified namespace.</param>
		public void WriteNamespaceString(string text)
		{
			nodeText.ConcatNoDelimiter(text);
		}

		/// <summary>Checks the namespace for well-formedness and writes the namespace.</summary>
		public void WriteEndNamespace()
		{
			xstate = XmlState.EnumAttrs;
			depth--;
			WriteNamespaceDeclaration(piTarget, nodeText.GetResult());
			if (depth == 0)
			{
				EndTree();
			}
		}

		/// <summary>Checks the start of the comment for well-formedness and writes the start of the comment.</summary>
		public void WriteStartComment()
		{
			ConstructWithinContent(XPathNodeType.Comment);
			nodeText.Clear();
			xstate = XmlState.WithinComment;
			depth++;
		}

		/// <summary>Cache the comment's string.</summary>
		/// <param name="text">String that contains the comment to write.</param>
		public void WriteCommentString(string text)
		{
			nodeText.ConcatNoDelimiter(text);
		}

		/// <summary>Checks the comment for well-formedness and writes the end of the comment.</summary>
		public void WriteEndComment()
		{
			Writer.WriteComment(nodeText.GetResult());
			xstate = XmlState.WithinContent;
			depth--;
			if (depth == 0)
			{
				EndTree();
			}
		}

		/// <summary>Checks the comment for well-formedness and writes the start of the processing instruction.</summary>
		/// <param name="target">String that contains the name of the target of the processing instruction.</param>
		public void WriteStartProcessingInstruction(string target)
		{
			ConstructWithinContent(XPathNodeType.ProcessingInstruction);
			ValidateNames.ValidateNameThrow("", target, "", XPathNodeType.ProcessingInstruction, ValidateNames.Flags.AllExceptPrefixMapping);
			piTarget = target;
			nodeText.Clear();
			xstate = XmlState.WithinPI;
			depth++;
		}

		/// <summary>Caches the processing instruction's text.</summary>
		/// <param name="text">String that contains instruction.</param>
		public void WriteProcessingInstructionString(string text)
		{
			nodeText.ConcatNoDelimiter(text);
		}

		/// <summary>Checks the processing instruction for well-formedness and writes the processing instruction.</summary>
		public void WriteEndProcessingInstruction()
		{
			Writer.WriteProcessingInstruction(piTarget, nodeText.GetResult());
			xstate = XmlState.WithinContent;
			depth--;
			if (depth == 0)
			{
				EndTree();
			}
		}

		/// <summary>Write an item to output.  If currently constructing an Xml tree, then the item is always copied. At the top-level, the item's identity is preserved unless it is an atomic value.</summary>
		/// <param name="item">
		///   <see cref="T:System.Xml.XPath.XPathItem" /> object to write.</param>
		public void WriteItem(XPathItem item)
		{
			if (item.IsNode)
			{
				XPathNavigator xPathNavigator = (XPathNavigator)item;
				if (xstate == XmlState.WithinSequence)
				{
					seqwrt.WriteItem(xPathNavigator);
				}
				else
				{
					CopyNode(xPathNavigator);
				}
			}
			else
			{
				seqwrt.WriteItem(item);
			}
		}

		/// <summary>Copies a node by value to output according to the following Xslt rules: identity is never preserved, if the item is an Rtf, preserve serialization hints when copying, and if the item is a root node, copy the children of the root.</summary>
		/// <param name="navigator">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		public void XsltCopyOf(XPathNavigator navigator)
		{
			if (navigator is RtfNavigator rtfNavigator)
			{
				rtfNavigator.CopyToWriter(this);
			}
			else if (navigator.NodeType == XPathNodeType.Root)
			{
				if (navigator.MoveToFirstChild())
				{
					do
					{
						CopyNode(navigator);
					}
					while (navigator.MoveToNext());
					navigator.MoveToParent();
				}
			}
			else
			{
				CopyNode(navigator);
			}
		}

		/// <summary>Begins the shallow copy of the navigator's current node to output.</summary>
		/// <param name="navigator">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		/// <returns>
		///   <see langword="true" /> if <see langword="EndCopy" /> should be called to complete the copy operation; otherwise, <see langword="false" />.</returns>
		public bool StartCopy(XPathNavigator navigator)
		{
			if (navigator.NodeType == XPathNodeType.Root)
			{
				return true;
			}
			if (StartCopy(navigator, callChk: true))
			{
				CopyNamespaces(navigator, XPathNamespaceScope.ExcludeXml);
				return true;
			}
			return false;
		}

		/// <summary>Ends the shallow copy of the navigator's current node. This method should only be called for element and document nodes.</summary>
		/// <param name="navigator">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object.</param>
		public void EndCopy(XPathNavigator navigator)
		{
			if (navigator.NodeType == XPathNodeType.Element)
			{
				WriteEndElement();
			}
		}

		private void AddNamespace(string prefix, string ns)
		{
			nsmgr.AddNamespace(prefix, ns);
			cntNmsp++;
			usedPrefixes[prefix] = ns;
		}

		private void WriteString(string text, bool disableOutputEscaping)
		{
			switch (xstate)
			{
			case XmlState.WithinSequence:
				StartTree(XPathNodeType.Text);
				goto case XmlState.WithinContent;
			case XmlState.WithinContent:
				if (disableOutputEscaping)
				{
					WriteRawUnchecked(text);
				}
				else
				{
					WriteStringUnchecked(text);
				}
				break;
			case XmlState.EnumAttrs:
				StartElementContentUnchecked();
				goto case XmlState.WithinContent;
			case XmlState.WithinAttr:
				WriteStringUnchecked(text);
				break;
			case XmlState.WithinNmsp:
				WriteNamespaceString(text);
				break;
			case XmlState.WithinComment:
				WriteCommentString(text);
				break;
			case XmlState.WithinPI:
				WriteProcessingInstructionString(text);
				break;
			}
			if (depth == 0)
			{
				EndTree();
			}
		}

		private void CopyNode(XPathNavigator navigator)
		{
			int num = depth;
			while (true)
			{
				if (StartCopy(navigator, depth == num))
				{
					XPathNodeType nodeType = navigator.NodeType;
					if (navigator.MoveToFirstAttribute())
					{
						do
						{
							StartCopy(navigator, callChk: false);
						}
						while (navigator.MoveToNextAttribute());
						navigator.MoveToParent();
					}
					CopyNamespaces(navigator, (depth - 1 == num) ? XPathNamespaceScope.ExcludeXml : XPathNamespaceScope.Local);
					StartElementContentUnchecked();
					if (navigator.MoveToFirstChild())
					{
						continue;
					}
					EndCopy(navigator, depth - 1 == num);
				}
				while (true)
				{
					if (depth == num)
					{
						return;
					}
					if (navigator.MoveToNext())
					{
						break;
					}
					navigator.MoveToParent();
					EndCopy(navigator, depth - 1 == num);
				}
			}
		}

		private bool StartCopy(XPathNavigator navigator, bool callChk)
		{
			bool result = false;
			switch (navigator.NodeType)
			{
			case XPathNodeType.Element:
				if (callChk)
				{
					WriteStartElement(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
				}
				else
				{
					WriteStartElementUnchecked(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
				}
				result = true;
				break;
			case XPathNodeType.Attribute:
				if (callChk)
				{
					WriteStartAttribute(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
				}
				else
				{
					WriteStartAttributeUnchecked(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
				}
				WriteString(navigator.Value);
				if (callChk)
				{
					WriteEndAttribute();
				}
				else
				{
					WriteEndAttributeUnchecked();
				}
				break;
			case XPathNodeType.Namespace:
				if (callChk)
				{
					if (Writer is XmlAttributeCache xmlAttributeCache && xmlAttributeCache.Count != 0)
					{
						throw new XslTransformException("XmlIl_NmspAfterAttr", string.Empty);
					}
					WriteNamespaceDeclaration(navigator.LocalName, navigator.Value);
				}
				else
				{
					WriteNamespaceDeclarationUnchecked(navigator.LocalName, navigator.Value);
				}
				break;
			case XPathNodeType.Text:
			case XPathNodeType.SignificantWhitespace:
			case XPathNodeType.Whitespace:
				if (callChk)
				{
					WriteString(navigator.Value, disableOutputEscaping: false);
				}
				else
				{
					WriteStringUnchecked(navigator.Value);
				}
				break;
			case XPathNodeType.Root:
				ThrowInvalidStateError(XPathNodeType.Root);
				break;
			case XPathNodeType.Comment:
				WriteStartComment();
				WriteCommentString(navigator.Value);
				WriteEndComment();
				break;
			case XPathNodeType.ProcessingInstruction:
				WriteStartProcessingInstruction(navigator.LocalName);
				WriteProcessingInstructionString(navigator.Value);
				WriteEndProcessingInstruction();
				break;
			}
			return result;
		}

		private void EndCopy(XPathNavigator navigator, bool callChk)
		{
			if (callChk)
			{
				WriteEndElement();
			}
			else
			{
				WriteEndElementUnchecked(navigator.Prefix, navigator.LocalName, navigator.NamespaceURI);
			}
		}

		private void CopyNamespaces(XPathNavigator navigator, XPathNamespaceScope nsScope)
		{
			if (navigator.NamespaceURI.Length == 0)
			{
				WriteNamespaceDeclarationUnchecked(string.Empty, string.Empty);
			}
			if (navigator.MoveToFirstNamespace(nsScope))
			{
				CopyNamespacesHelper(navigator, nsScope);
				navigator.MoveToParent();
			}
		}

		private void CopyNamespacesHelper(XPathNavigator navigator, XPathNamespaceScope nsScope)
		{
			string localName = navigator.LocalName;
			string value = navigator.Value;
			if (navigator.MoveToNextNamespace(nsScope))
			{
				CopyNamespacesHelper(navigator, nsScope);
			}
			WriteNamespaceDeclarationUnchecked(localName, value);
		}

		private void ConstructWithinContent(XPathNodeType rootType)
		{
			switch (xstate)
			{
			case XmlState.WithinSequence:
				StartTree(rootType);
				xstate = XmlState.WithinContent;
				break;
			case XmlState.EnumAttrs:
				StartElementContentUnchecked();
				break;
			default:
				ThrowInvalidStateError(rootType);
				break;
			case XmlState.WithinContent:
				break;
			}
		}

		private void ConstructInEnumAttrs(XPathNodeType rootType)
		{
			switch (xstate)
			{
			case XmlState.WithinSequence:
				StartTree(rootType);
				xstate = XmlState.EnumAttrs;
				break;
			default:
				ThrowInvalidStateError(rootType);
				break;
			case XmlState.EnumAttrs:
				break;
			}
		}

		private void WriteCachedNamespaces()
		{
			while (cntNmsp != 0)
			{
				cntNmsp--;
				nsmgr.GetNamespaceDeclaration(cntNmsp, out var prefix, out var uri);
				Writer.WriteNamespaceDeclaration(prefix, uri);
			}
		}

		private XPathNodeType XmlStateToNodeType(XmlState xstate)
		{
			return xstate switch
			{
				XmlState.EnumAttrs => XPathNodeType.Element, 
				XmlState.WithinContent => XPathNodeType.Element, 
				XmlState.WithinAttr => XPathNodeType.Attribute, 
				XmlState.WithinComment => XPathNodeType.Comment, 
				XmlState.WithinPI => XPathNodeType.ProcessingInstruction, 
				_ => XPathNodeType.Element, 
			};
		}

		private string CheckAttributePrefix(string prefix, string ns)
		{
			if (nsmgr == null)
			{
				WriteNamespaceDeclarationUnchecked(prefix, ns);
			}
			else
			{
				while (true)
				{
					string text = nsmgr.LookupNamespace(prefix);
					if (!(text != ns))
					{
						break;
					}
					if (text != null)
					{
						prefix = RemapPrefix(prefix, ns, isElemPrefix: false);
						continue;
					}
					AddNamespace(prefix, ns);
					break;
				}
			}
			return prefix;
		}

		private string RemapPrefix(string prefix, string ns, bool isElemPrefix)
		{
			if (conflictPrefixes == null)
			{
				conflictPrefixes = new Dictionary<string, string>(16);
			}
			if (nsmgr == null)
			{
				nsmgr = new XmlNamespaceManager(runtime.NameTable);
				nsmgr.PushScope();
			}
			string value = nsmgr.LookupPrefix(ns);
			if ((value == null || (!isElemPrefix && value.Length == 0)) && (!conflictPrefixes.TryGetValue(ns, out value) || !(value != prefix) || (!isElemPrefix && value.Length == 0)))
			{
				value = "xp_" + prefixIndex++.ToString(CultureInfo.InvariantCulture);
			}
			conflictPrefixes[ns] = value;
			return value;
		}

		private void WriteStartComputed(XPathNodeType nodeType, string tagName, int prefixMappingsIndex)
		{
			runtime.ParseTagName(tagName, prefixMappingsIndex, out var prefix, out var localName, out var ns);
			prefix = EnsureValidName(prefix, localName, ns, nodeType);
			if (nodeType == XPathNodeType.Element)
			{
				WriteStartElement(prefix, localName, ns);
			}
			else
			{
				WriteStartAttribute(prefix, localName, ns);
			}
		}

		private void WriteStartComputed(XPathNodeType nodeType, string tagName, string ns)
		{
			ValidateNames.ParseQNameThrow(tagName, out var prefix, out var localName);
			prefix = EnsureValidName(prefix, localName, ns, nodeType);
			if (nodeType == XPathNodeType.Element)
			{
				WriteStartElement(prefix, localName, ns);
			}
			else
			{
				WriteStartAttribute(prefix, localName, ns);
			}
		}

		private void WriteStartComputed(XPathNodeType nodeType, XPathNavigator navigator)
		{
			string prefix = navigator.Prefix;
			string localName = navigator.LocalName;
			string namespaceURI = navigator.NamespaceURI;
			if (navigator.NodeType != nodeType)
			{
				prefix = EnsureValidName(prefix, localName, namespaceURI, nodeType);
			}
			if (nodeType == XPathNodeType.Element)
			{
				WriteStartElement(prefix, localName, namespaceURI);
			}
			else
			{
				WriteStartAttribute(prefix, localName, namespaceURI);
			}
		}

		private void WriteStartComputed(XPathNodeType nodeType, XmlQualifiedName name)
		{
			string prefix = ((name.Namespace.Length != 0) ? RemapPrefix(string.Empty, name.Namespace, nodeType == XPathNodeType.Element) : string.Empty);
			prefix = EnsureValidName(prefix, name.Name, name.Namespace, nodeType);
			if (nodeType == XPathNodeType.Element)
			{
				WriteStartElement(prefix, name.Name, name.Namespace);
			}
			else
			{
				WriteStartAttribute(prefix, name.Name, name.Namespace);
			}
		}

		private string EnsureValidName(string prefix, string localName, string ns, XPathNodeType nodeType)
		{
			if (!ValidateNames.ValidateName(prefix, localName, ns, nodeType, ValidateNames.Flags.AllExceptNCNames))
			{
				prefix = ((ns.Length != 0) ? RemapPrefix(string.Empty, ns, nodeType == XPathNodeType.Element) : string.Empty);
				ValidateNames.ValidateNameThrow(prefix, localName, ns, nodeType, ValidateNames.Flags.AllExceptNCNames);
			}
			return prefix;
		}

		private void PushElementNames(string prefix, string localName, string ns)
		{
			if (stkNames == null)
			{
				stkNames = new Stack<string>(15);
			}
			stkNames.Push(prefix);
			stkNames.Push(localName);
			stkNames.Push(ns);
		}

		private void PopElementNames(out string prefix, out string localName, out string ns)
		{
			ns = stkNames.Pop();
			localName = stkNames.Pop();
			prefix = stkNames.Pop();
		}

		private void ThrowInvalidStateError(XPathNodeType constructorType)
		{
			switch (constructorType)
			{
			case XPathNodeType.Root:
			case XPathNodeType.Element:
			case XPathNodeType.Text:
			case XPathNodeType.ProcessingInstruction:
			case XPathNodeType.Comment:
				throw new XslTransformException("XmlIl_BadXmlState", constructorType.ToString(), XmlStateToNodeType(xstate).ToString());
			case XPathNodeType.Attribute:
			case XPathNodeType.Namespace:
				if (depth == 1)
				{
					throw new XslTransformException("XmlIl_BadXmlState", constructorType.ToString(), rootType.ToString());
				}
				if (xstate == XmlState.WithinContent)
				{
					throw new XslTransformException("XmlIl_BadXmlStateAttr", string.Empty);
				}
				goto case XPathNodeType.Root;
			default:
				throw new XslTransformException("XmlIl_BadXmlState", "Unknown", XmlStateToNodeType(xstate).ToString());
			}
		}
	}
	/// <summary>Provides methods and properties to support the XSLT processor.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlQueryRuntime
	{
		private XmlQueryContext ctxt;

		private XsltLibrary xsltLib;

		private EarlyBoundInfo[] earlyInfo;

		private object[] earlyObjects;

		private string[] globalNames;

		private object[] globalValues;

		private XmlNameTable nameTableQuery;

		private string[] atomizedNames;

		private XmlNavigatorFilter[] filters;

		private StringPair[][] prefixMappingsList;

		private XmlQueryType[] types;

		private XmlCollation[] collations;

		private DocumentOrderComparer docOrderCmp;

		private ArrayList[] indexes;

		private XmlQueryOutput output;

		private Stack<XmlQueryOutput> stkOutput;

		internal const BindingFlags EarlyBoundFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public;

		internal const BindingFlags LateBoundFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public;

		/// <summary>Returns the object that manages external user context information, such as data sources, parameters, extension objects, and so on.</summary>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryContext" /> class.</returns>
		public XmlQueryContext ExternalContext => ctxt;

		/// <summary>Returns the object that manages the state. The state object is required to implement various XSLT functions.</summary>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XsltLibrary" /> class.</returns>
		public XsltLibrary XsltFunctions
		{
			get
			{
				if (xsltLib == null)
				{
					xsltLib = new XsltLibrary(this);
				}
				return xsltLib;
			}
		}

		/// <summary>Returns the name table used to atomize all names used by the query.</summary>
		/// <returns>An instance of the <see cref="T:System.Xml.XmlNameTable" /> class.</returns>
		public XmlNameTable NameTable => nameTableQuery;

		internal XmlQueryType[] XmlTypes => types;

		/// <summary>Gets the output writer object.</summary>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryOutput" /> class.</returns>
		public XmlQueryOutput Output => output;

		internal XmlQueryRuntime(XmlQueryStaticData data, object defaultDataSource, XmlResolver dataSources, XsltArgumentList argList, XmlSequenceWriter seqWrt)
		{
			string[] names = data.Names;
			Int32Pair[] array = data.Filters;
			WhitespaceRuleLookup wsRules = ((data.WhitespaceRules != null && data.WhitespaceRules.Count != 0) ? new WhitespaceRuleLookup(data.WhitespaceRules) : null);
			ctxt = new XmlQueryContext(this, defaultDataSource, dataSources, argList, wsRules);
			xsltLib = null;
			earlyInfo = data.EarlyBound;
			earlyObjects = ((earlyInfo != null) ? new object[earlyInfo.Length] : null);
			globalNames = data.GlobalNames;
			globalValues = ((globalNames != null) ? new object[globalNames.Length] : null);
			nameTableQuery = ctxt.QueryNameTable;
			atomizedNames = null;
			if (names != null)
			{
				XmlNameTable defaultNameTable = ctxt.DefaultNameTable;
				atomizedNames = new string[names.Length];
				if (defaultNameTable != nameTableQuery && defaultNameTable != null)
				{
					for (int i = 0; i < names.Length; i++)
					{
						string text = defaultNameTable.Get(names[i]);
						atomizedNames[i] = nameTableQuery.Add(text ?? names[i]);
					}
				}
				else
				{
					for (int i = 0; i < names.Length; i++)
					{
						atomizedNames[i] = nameTableQuery.Add(names[i]);
					}
				}
			}
			filters = null;
			if (array != null)
			{
				filters = new XmlNavigatorFilter[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					filters[i] = XmlNavNameFilter.Create(atomizedNames[array[i].Left], atomizedNames[array[i].Right]);
				}
			}
			prefixMappingsList = data.PrefixMappingsList;
			types = data.Types;
			collations = data.Collations;
			docOrderCmp = new DocumentOrderComparer();
			indexes = null;
			stkOutput = new Stack<XmlQueryOutput>(16);
			output = new XmlQueryOutput(this, seqWrt);
		}

		/// <summary>Returns an array containing the names of all the global variables and parameters used in this query.</summary>
		/// <returns>An array of <see langword="string" /> values.</returns>
		public string[] DebugGetGlobalNames()
		{
			return globalNames;
		}

		/// <summary>Gets the value of a global value that has the specified name.</summary>
		/// <param name="name">A value of type <see langword="string" />.</param>
		/// <returns>A sequence of <see cref="T:System.Xml.XPath.XPathItem" /> instances, or <see langword="null" /> if there is no global value that has the specified name.</returns>
		public IList DebugGetGlobalValue(string name)
		{
			for (int i = 0; i < globalNames.Length; i++)
			{
				if (globalNames[i] == name)
				{
					return (IList)globalValues[i];
				}
			}
			return null;
		}

		/// <summary>Sets the value of a global value that has the specified name.</summary>
		/// <param name="name">A value of type <see langword="string" />.</param>
		/// <param name="value">A value of type <see langword="object" />.</param>
		public void DebugSetGlobalValue(string name, object value)
		{
			for (int i = 0; i < globalNames.Length; i++)
			{
				if (globalNames[i] == name)
				{
					globalValues[i] = (IList<XPathItem>)XmlAnyListConverter.ItemList.ChangeType(value, typeof(XPathItem[]), null);
					break;
				}
			}
		}

		/// <summary>Converts a sequence to its appropriate XSLT type.</summary>
		/// <param name="seq">An instance of the <see cref="T:System.Collections.IList" /> class.</param>
		/// <returns>A value of type <see langword="object" />.</returns>
		public object DebugGetXsltValue(IList seq)
		{
			if (seq != null && seq.Count == 1)
			{
				XPathItem xPathItem = seq[0] as XPathItem;
				if (xPathItem != null && !xPathItem.IsNode)
				{
					return xPathItem.TypedValue;
				}
				if (xPathItem is RtfNavigator)
				{
					return ((RtfNavigator)xPathItem).ToNavigator();
				}
			}
			return seq;
		}

		/// <summary>Gets the specifiied early-bound extension object. If this object does not yet exist, creates an instance using the corresponding <see cref="T:System.Reflection.ConstructorInfo" />.</summary>
		/// <param name="index">A value of type <see langword="int" />.</param>
		/// <returns>A value of type <see langword="object" />.</returns>
		public object GetEarlyBoundObject(int index)
		{
			object obj = earlyObjects[index];
			if (obj == null)
			{
				obj = earlyInfo[index].CreateObject();
				earlyObjects[index] = obj;
			}
			return obj;
		}

		/// <summary>Determines whether the specified early-bound object contains a method with the specified name.</summary>
		/// <param name="name">The method name to look for.</param>
		/// <param name="namespaceUri">Identifies the early-bound object.</param>
		/// <returns>
		///   <see langword="true" /> if the early-bound object identified by <paramref name="namespaceUri" /> contains a method that matches <paramref name="name" />; otherwise, <see langword="false" />.</returns>
		public bool EarlyBoundFunctionExists(string name, string namespaceUri)
		{
			if (earlyInfo == null)
			{
				return false;
			}
			for (int i = 0; i < earlyInfo.Length; i++)
			{
				if (namespaceUri == earlyInfo[i].NamespaceUri)
				{
					return new XmlExtensionFunction(name, namespaceUri, -1, earlyInfo[i].EarlyBoundType, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public).CanBind();
				}
			}
			return false;
		}

		/// <summary>Returns true if the specified global value has already been computed.</summary>
		/// <param name="index">A value of type <see langword="int" />.</param>
		/// <returns>
		///   <see langword="true" /> if the value has been computed; otherwise, <see langword="false" />.</returns>
		public bool IsGlobalComputed(int index)
		{
			return globalValues[index] != null;
		}

		/// <summary>Returns the value that is bound to the specified global variable. If the value has not yet been computed, computes it and stores it in the global variable.</summary>
		/// <param name="index">A value of type <see langword="int" />.</param>
		/// <returns>The value that is bound to the specified global variable.</returns>
		public object GetGlobalValue(int index)
		{
			return globalValues[index];
		}

		/// <summary>Returns the value that is bound to the specified global variable or parameter.</summary>
		/// <param name="index">A value of type <see langword="int" />.</param>
		/// <param name="value">A value of type <see langword="object" />.</param>
		public void SetGlobalValue(int index, object value)
		{
			globalValues[index] = value;
		}

		/// <summary>Gets the atomized name at the specified index in the array of names.</summary>
		/// <param name="index">A value of type <see langword="int" />.</param>
		/// <returns>A value of type <see langword="string" />.</returns>
		public string GetAtomizedName(int index)
		{
			return atomizedNames[index];
		}

		/// <summary>Gets the name filter at the specified index in the array of filters.</summary>
		/// <param name="index">A value of type <see langword="int" />.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class.</returns>
		public XmlNavigatorFilter GetNameFilter(int index)
		{
			return filters[index];
		}

		/// <summary>Gets a filter that filters nodes of the specified type.</summary>
		/// <param name="nodeType">An instance of the <see cref="T:System.Xml.XPath.XPathNodeType" /> class.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlNavigatorFilter" /> class.</returns>
		public XmlNavigatorFilter GetTypeFilter(XPathNodeType nodeType)
		{
			return nodeType switch
			{
				XPathNodeType.All => XmlNavNeverFilter.Create(), 
				XPathNodeType.Attribute => XmlNavAttrFilter.Create(), 
				_ => XmlNavTypeFilter.Create(nodeType), 
			};
		}

		/// <summary>Parses the specified tag name and resolves the resulting prefix. If the prefix cannot be resolved, an error is thrown.</summary>
		/// <param name="tagName">The tag name.</param>
		/// <param name="indexPrefixMappings">The index.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.XmlQualifiedName" /> class.</returns>
		public XmlQualifiedName ParseTagName(string tagName, int indexPrefixMappings)
		{
			ParseTagName(tagName, indexPrefixMappings, out var _, out var localName, out var ns);
			return new XmlQualifiedName(localName, ns);
		}

		/// <summary>Parses the specified tag name. Returns an <see cref="T:System.Xml.XmlQualifiedName" /> that consists of the parsed local name and the specified namespace.</summary>
		/// <param name="tagName">The tag name.</param>
		/// <param name="ns">The namespace.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.XmlQualifiedName" /> class.</returns>
		public XmlQualifiedName ParseTagName(string tagName, string ns)
		{
			ValidateNames.ParseQNameThrow(tagName, out var _, out var localName);
			return new XmlQualifiedName(localName, ns);
		}

		internal void ParseTagName(string tagName, int idxPrefixMappings, out string prefix, out string localName, out string ns)
		{
			ValidateNames.ParseQNameThrow(tagName, out prefix, out localName);
			ns = null;
			StringPair[] array = prefixMappingsList[idxPrefixMappings];
			for (int i = 0; i < array.Length; i++)
			{
				StringPair stringPair = array[i];
				if (prefix == stringPair.Left)
				{
					ns = stringPair.Right;
					break;
				}
			}
			if (ns != null)
			{
				return;
			}
			if (prefix.Length == 0)
			{
				ns = "";
				return;
			}
			if (prefix.Equals("xml"))
			{
				ns = "http://www.w3.org/XML/1998/namespace";
				return;
			}
			if (prefix.Equals("xmlns"))
			{
				ns = "http://www.w3.org/2000/xmlns/";
				return;
			}
			throw new XslTransformException("Xslt_InvalidPrefix", prefix);
		}

		/// <summary>Compares the <see cref="P:System.Xml.XPath.XPathNavigator.LocalName" /> and <see cref="P:System.Xml.XPath.XPathNavigator.NamespaceURI" /> properties of two <see cref="T:System.Xml.XPath.XPathNavigator" /> instances to check if they are equal.</summary>
		/// <param name="n1">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <param name="n2">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <returns>
		///   <see langword="true" /> if the names are equal; otherwise, <see langword="false" />.</returns>
		public bool IsQNameEqual(XPathNavigator n1, XPathNavigator n2)
		{
			if (n1.NameTable == n2.NameTable)
			{
				if ((object)n1.LocalName == n2.LocalName)
				{
					return (object)n1.NamespaceURI == n2.NamespaceURI;
				}
				return false;
			}
			if (n1.LocalName == n2.LocalName)
			{
				return n1.NamespaceURI == n2.NamespaceURI;
			}
			return false;
		}

		/// <summary>Determines whether the <see cref="P:System.Xml.XPath.XPathNavigator.LocalName" /> and <see cref="P:System.Xml.XPath.XPathNavigator.NamespaceURI" /> properties of the specified <see cref="T:System.Xml.XPath.XPathNavigator" /> are equal to the names specified in the parameters.</summary>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <param name="indexLocalName">A value of type <see langword="int" />.</param>
		/// <param name="indexNamespaceUri">A value of type <see langword="int" />.</param>
		/// <returns>
		///   <see langword="true" /> if the names are equal; otherwise, <see langword="false" />.</returns>
		public bool IsQNameEqual(XPathNavigator navigator, int indexLocalName, int indexNamespaceUri)
		{
			if (navigator.NameTable == nameTableQuery)
			{
				if ((object)GetAtomizedName(indexLocalName) == navigator.LocalName)
				{
					return (object)GetAtomizedName(indexNamespaceUri) == navigator.NamespaceURI;
				}
				return false;
			}
			if (GetAtomizedName(indexLocalName) == navigator.LocalName)
			{
				return GetAtomizedName(indexNamespaceUri) == navigator.NamespaceURI;
			}
			return false;
		}

		internal XmlQueryType GetXmlType(int idxType)
		{
			return types[idxType];
		}

		/// <summary>Converts a value from the CLR type of the <paramref name="value" /> parameter to CLR <paramref name="destinationType" /> by using V1 XSLT rules. Converts any result tree fragment values to nodes.</summary>
		/// <param name="indexType">A value of type <see langword="Int32" />.</param>
		/// <param name="value">A value of type <see langword="object" />.</param>
		/// <param name="destinationType">A value of type <see langword="Type" />.</param>
		/// <returns>A value of type <see langword="object" />.</returns>
		public object ChangeTypeXsltArgument(int indexType, object value, Type destinationType)
		{
			return ChangeTypeXsltArgument(GetXmlType(indexType), value, destinationType);
		}

		internal object ChangeTypeXsltArgument(XmlQueryType xmlType, object value, Type destinationType)
		{
			switch (xmlType.TypeCode)
			{
			case XmlTypeCode.String:
				if (destinationType == XsltConvert.DateTimeType)
				{
					value = XsltConvert.ToDateTime((string)value);
				}
				break;
			case XmlTypeCode.Double:
				if (destinationType != XsltConvert.DoubleType)
				{
					value = Convert.ChangeType(value, destinationType, CultureInfo.InvariantCulture);
				}
				break;
			case XmlTypeCode.Node:
				if (destinationType == XsltConvert.XPathNodeIteratorType)
				{
					value = new XPathArrayIterator((IList)value);
				}
				else if (destinationType == XsltConvert.XPathNavigatorArrayType)
				{
					IList<XPathNavigator> list2 = (IList<XPathNavigator>)value;
					XPathNavigator[] array = new XPathNavigator[list2.Count];
					for (int i = 0; i < list2.Count; i++)
					{
						array[i] = list2[i];
					}
					value = array;
				}
				break;
			case XmlTypeCode.Item:
			{
				if (destinationType != XsltConvert.ObjectType)
				{
					throw new XslTransformException("Xslt_UnsupportedClrType", destinationType.Name);
				}
				IList<XPathItem> list = (IList<XPathItem>)value;
				if (list.Count == 1)
				{
					XPathItem xPathItem = list[0];
					value = ((!xPathItem.IsNode) ? xPathItem.TypedValue : ((!(xPathItem is RtfNavigator rtfNavigator)) ? ((ICloneable)new XPathArrayIterator((IList)value)) : ((ICloneable)rtfNavigator.ToNavigator())));
				}
				else
				{
					value = new XPathArrayIterator((IList)value);
				}
				break;
			}
			}
			return value;
		}

		/// <summary>Converts from the CLR type of the <paramref name="value" /> parameter to the default CLR type by which intermediate language generation represents the XML type, based on the conversion rules of the XML type.</summary>
		/// <param name="indexType">A value of type <see langword="int" />.</param>
		/// <param name="value">A value of type <see langword="object" />.</param>
		/// <returns>A value of type <see langword="object" />.</returns>
		public object ChangeTypeXsltResult(int indexType, object value)
		{
			return ChangeTypeXsltResult(GetXmlType(indexType), value);
		}

		internal object ChangeTypeXsltResult(XmlQueryType xmlType, object value)
		{
			if (value == null)
			{
				throw new XslTransformException("Xslt_ItemNull", string.Empty);
			}
			switch (xmlType.TypeCode)
			{
			case XmlTypeCode.String:
				if (value.GetType() == XsltConvert.DateTimeType)
				{
					value = XsltConvert.ToString((DateTime)value);
				}
				break;
			case XmlTypeCode.Double:
				if (value.GetType() != XsltConvert.DoubleType)
				{
					value = ((IConvertible)value).ToDouble(null);
				}
				break;
			case XmlTypeCode.Node:
				if (xmlType.IsSingleton)
				{
					break;
				}
				if (value is XPathArrayIterator xPathArrayIterator && xPathArrayIterator.AsList is XmlQueryNodeSequence)
				{
					value = xPathArrayIterator.AsList as XmlQueryNodeSequence;
				}
				else
				{
					XmlQueryNodeSequence xmlQueryNodeSequence = new XmlQueryNodeSequence();
					if (value is IList list)
					{
						for (int i = 0; i < list.Count; i++)
						{
							xmlQueryNodeSequence.Add(EnsureNavigator(list[i]));
						}
					}
					else
					{
						foreach (object item in (IEnumerable)value)
						{
							xmlQueryNodeSequence.Add(EnsureNavigator(item));
						}
					}
					value = xmlQueryNodeSequence;
				}
				value = ((XmlQueryNodeSequence)value).DocOrderDistinct(docOrderCmp);
				break;
			case XmlTypeCode.Item:
			{
				Type type = value.GetType();
				switch (XsltConvert.InferXsltType(type).TypeCode)
				{
				case XmlTypeCode.Boolean:
					value = new XmlQueryItemSequence(new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean), value));
					break;
				case XmlTypeCode.Double:
					value = new XmlQueryItemSequence(new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double), ((IConvertible)value).ToDouble(null)));
					break;
				case XmlTypeCode.String:
					value = ((!(type == XsltConvert.DateTimeType)) ? new XmlQueryItemSequence(new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), value)) : new XmlQueryItemSequence(new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), XsltConvert.ToString((DateTime)value))));
					break;
				case XmlTypeCode.Node:
					value = ChangeTypeXsltResult(XmlQueryTypeFactory.NodeS, value);
					break;
				case XmlTypeCode.Item:
					if (value is XPathNodeIterator)
					{
						value = ChangeTypeXsltResult(XmlQueryTypeFactory.NodeS, value);
						break;
					}
					if (!(value is IXPathNavigable iXPathNavigable))
					{
						throw new XslTransformException("Xslt_UnsupportedClrType", type.Name);
					}
					value = ((!(value is XPathNavigator)) ? new XmlQueryNodeSequence(iXPathNavigable.CreateNavigator()) : new XmlQueryNodeSequence((XPathNavigator)value));
					break;
				}
				break;
			}
			}
			return value;
		}

		private static XPathNavigator EnsureNavigator(object value)
		{
			if (!(value is XPathNavigator result))
			{
				throw new XslTransformException("Xslt_ItemNull", string.Empty);
			}
			return result;
		}

		/// <summary>Returns <see langword="true" /> if the type of every item in the specified sequence matches the XML type that the specified index identifies.</summary>
		/// <param name="seq">An <see cref="T:System.Collections.Generic.IList`1" /> of <see cref="T:System.Xml.XPath.XPathItem" /> objects.</param>
		/// <param name="indexType">The index.</param>
		/// <returns>
		///   <see langword="true" /> if the type of <paramref name="seq" /> is a subtype of the <paramref name="indexType" />; otherwise, <see langword="false" />.</returns>
		public bool MatchesXmlType(IList<XPathItem> seq, int indexType)
		{
			XmlQueryType xmlType = GetXmlType(indexType);
			if (!(seq.Count switch
			{
				0 => XmlQueryCardinality.Zero, 
				1 => XmlQueryCardinality.One, 
				_ => XmlQueryCardinality.More, 
			} <= xmlType.Cardinality))
			{
				return false;
			}
			xmlType = xmlType.Prime;
			for (int i = 0; i < seq.Count; i++)
			{
				if (!CreateXmlType(seq[0]).IsSubtypeOf(xmlType))
				{
					return false;
				}
			}
			return true;
		}

		/// <summary>Returns <see langword="true" /> if the type of the specified <see cref="T:System.Xml.XPath.XPathItem" /> object matches the specified XML type.</summary>
		/// <param name="item">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <param name="indexType">The index in the array of XML types.</param>
		/// <returns>
		///   <see langword="true" /> if the type of the specified <see cref="T:System.Xml.XPath.XPathItem" /> matches the specified XML type; otherwise, <see langword="false" />.</returns>
		public bool MatchesXmlType(XPathItem item, int indexType)
		{
			return CreateXmlType(item).IsSubtypeOf(GetXmlType(indexType));
		}

		/// <summary>Determines whether the type of the specified sequence is a subtype of the specified singleton type.</summary>
		/// <param name="seq">A sequence of <see cref="T:System.Xml.XPath.XPathItem" /> instances.</param>
		/// <param name="code">A singleton type.</param>
		/// <returns>
		///   <see langword="true" /> if the type of <paramref name="seq" /> is a subtype the type specified by <paramref name="code" />; otherwise, <see langword="false" />.</returns>
		public bool MatchesXmlType(IList<XPathItem> seq, XmlTypeCode code)
		{
			if (seq.Count != 1)
			{
				return false;
			}
			return MatchesXmlType(seq[0], code);
		}

		/// <summary>Returns <see langword="true" /> if the type of the <see cref="T:System.Xml.XPath.XPathItem" /> object is a subtype of a type identified by the specified <see cref="T:System.Xml.Schema.XmlTypeCode" />.</summary>
		/// <param name="item">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <param name="code">An instance of the <see cref="T:System.Xml.Schema.XmlTypeCode" /> class.</param>
		/// <returns>
		///   <see langword="true" /> if the type of the <see cref="T:System.Xml.XPath.XPathItem" /> object is a subtype of a type identified by the specified <see cref="T:System.Xml.Schema.XmlTypeCode" />; otherwise, <see langword="false" />.</returns>
		public bool MatchesXmlType(XPathItem item, XmlTypeCode code)
		{
			if (code > XmlTypeCode.AnyAtomicType)
			{
				if (!item.IsNode)
				{
					return item.XmlType.TypeCode == code;
				}
				return false;
			}
			switch (code)
			{
			case XmlTypeCode.AnyAtomicType:
				return !item.IsNode;
			case XmlTypeCode.Node:
				return item.IsNode;
			case XmlTypeCode.Item:
				return true;
			default:
				if (!item.IsNode)
				{
					return false;
				}
				return ((XPathNavigator)item).NodeType switch
				{
					XPathNodeType.Root => code == XmlTypeCode.Document, 
					XPathNodeType.Element => code == XmlTypeCode.Element, 
					XPathNodeType.Attribute => code == XmlTypeCode.Attribute, 
					XPathNodeType.Namespace => code == XmlTypeCode.Namespace, 
					XPathNodeType.Text => code == XmlTypeCode.Text, 
					XPathNodeType.SignificantWhitespace => code == XmlTypeCode.Text, 
					XPathNodeType.Whitespace => code == XmlTypeCode.Text, 
					XPathNodeType.ProcessingInstruction => code == XmlTypeCode.ProcessingInstruction, 
					XPathNodeType.Comment => code == XmlTypeCode.Comment, 
					_ => false, 
				};
			}
		}

		private XmlQueryType CreateXmlType(XPathItem item)
		{
			if (item.IsNode)
			{
				if (item is RtfNavigator)
				{
					return XmlQueryTypeFactory.Node;
				}
				XPathNavigator xPathNavigator = (XPathNavigator)item;
				switch (xPathNavigator.NodeType)
				{
				case XPathNodeType.Root:
				case XPathNodeType.Element:
					if (xPathNavigator.XmlType == null)
					{
						return XmlQueryTypeFactory.Type(xPathNavigator.NodeType, XmlQualifiedNameTest.New(xPathNavigator.LocalName, xPathNavigator.NamespaceURI), XmlSchemaComplexType.UntypedAnyType, isNillable: false);
					}
					return XmlQueryTypeFactory.Type(xPathNavigator.NodeType, XmlQualifiedNameTest.New(xPathNavigator.LocalName, xPathNavigator.NamespaceURI), xPathNavigator.XmlType, xPathNavigator.SchemaInfo.SchemaElement.IsNillable);
				case XPathNodeType.Attribute:
					if (xPathNavigator.XmlType == null)
					{
						return XmlQueryTypeFactory.Type(xPathNavigator.NodeType, XmlQualifiedNameTest.New(xPathNavigator.LocalName, xPathNavigator.NamespaceURI), DatatypeImplementation.UntypedAtomicType, isNillable: false);
					}
					return XmlQueryTypeFactory.Type(xPathNavigator.NodeType, XmlQualifiedNameTest.New(xPathNavigator.LocalName, xPathNavigator.NamespaceURI), xPathNavigator.XmlType, isNillable: false);
				default:
					return XmlQueryTypeFactory.Type(xPathNavigator.NodeType, XmlQualifiedNameTest.Wildcard, XmlSchemaComplexType.AnyType, isNillable: false);
				}
			}
			return XmlQueryTypeFactory.Type((XmlSchemaSimpleType)item.XmlType, isStrict: true);
		}

		/// <summary>Gets a collation that was statically created.</summary>
		/// <param name="index">A value of type <see langword="int" />.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlCollation" /> class.</returns>
		public XmlCollation GetCollation(int index)
		{
			return collations[index];
		}

		/// <summary>Creates a collation from a string.</summary>
		/// <param name="collation">A value of type <see langword="string" />.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlCollation" /> class.</returns>
		public XmlCollation CreateCollation(string collation)
		{
			return XmlCollation.Create(collation);
		}

		/// <summary>Compares the relative positions of two navigators.</summary>
		/// <param name="navigatorThis">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <param name="navigatorThat">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <returns>-1 if <paramref name="navigatorThis" /> is before <paramref name="navigatorThat" />; 1 if <paramref name="navigatorThis" /> is after <paramref name="navigatorThat" />; 0 if both navigators are positioned at the same node.</returns>
		public int ComparePosition(XPathNavigator navigatorThis, XPathNavigator navigatorThat)
		{
			return docOrderCmp.Compare(navigatorThis, navigatorThat);
		}

		/// <summary>Gets distinct sorted nodes from the specified sequence.</summary>
		/// <param name="seq">A sequence of <see cref="T:System.Xml.XPath.XPathNavigator" /> instances.</param>
		/// <returns>An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Xml.XPath.XPathNavigator" /> objects.</returns>
		public IList<XPathNavigator> DocOrderDistinct(IList<XPathNavigator> seq)
		{
			if (seq.Count <= 1)
			{
				return seq;
			}
			XmlQueryNodeSequence xmlQueryNodeSequence = (XmlQueryNodeSequence)seq;
			if (xmlQueryNodeSequence == null)
			{
				xmlQueryNodeSequence = new XmlQueryNodeSequence(seq);
			}
			return xmlQueryNodeSequence.DocOrderDistinct(docOrderCmp);
		}

		/// <summary>Generate a unique string identifier for the specified node.</summary>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <returns>A value of type <see langword="string" />.</returns>
		public string GenerateId(XPathNavigator navigator)
		{
			return "ID" + docOrderCmp.GetDocumentIndex(navigator).ToString(CultureInfo.InvariantCulture) + navigator.UniqueId;
		}

		/// <summary>Returns the index with the specified ID if it has already been created over the specified document, and returns <see langword="true" />. Otherwise, creates a new, empty index and returns <see langword="false" />.</summary>
		/// <param name="context">The context document.</param>
		/// <param name="indexId">The index ID to look for.</param>
		/// <param name="index">The returned index.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlILIndex" /> class.</returns>
		public bool FindIndex(XPathNavigator context, int indexId, out XmlILIndex index)
		{
			XPathNavigator xPathNavigator = context.Clone();
			xPathNavigator.MoveToRoot();
			if (indexes != null && indexId < indexes.Length)
			{
				ArrayList arrayList = indexes[indexId];
				if (arrayList != null)
				{
					for (int i = 0; i < arrayList.Count; i += 2)
					{
						if (((XPathNavigator)arrayList[i]).IsSamePosition(xPathNavigator))
						{
							index = (XmlILIndex)arrayList[i + 1];
							return true;
						}
					}
				}
			}
			index = new XmlILIndex();
			return false;
		}

		/// <summary>Adds a newly built index over the specified context document to the existing collection of indexes.</summary>
		/// <param name="context">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <param name="indexId">A value of type <see langword="int" />.</param>
		/// <param name="index">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlILIndex" /> class.</param>
		public void AddNewIndex(XPathNavigator context, int indexId, XmlILIndex index)
		{
			XPathNavigator xPathNavigator = context.Clone();
			xPathNavigator.MoveToRoot();
			if (indexes == null)
			{
				indexes = new ArrayList[indexId + 4];
			}
			else if (indexId >= indexes.Length)
			{
				ArrayList[] destinationArray = new ArrayList[indexId + 4];
				Array.Copy(indexes, 0, destinationArray, 0, indexes.Length);
				indexes = destinationArray;
			}
			ArrayList arrayList = indexes[indexId];
			if (arrayList == null)
			{
				arrayList = new ArrayList();
				indexes[indexId] = arrayList;
			}
			arrayList.Add(xPathNavigator);
			arrayList.Add(index);
		}

		/// <summary>Starts constructing a nested sequence of items. Returns a new <see cref="T:System.Xml.Xsl.Runtime.XmlQueryOutput" /> that will be used to construct this new sequence.</summary>
		/// <param name="output">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryOutput" /> class.</param>
		public void StartSequenceConstruction(out XmlQueryOutput output)
		{
			stkOutput.Push(this.output);
			output = (this.output = new XmlQueryOutput(this, new XmlCachedSequenceWriter()));
		}

		/// <summary>Finishes constructing a nested sequence of items.</summary>
		/// <param name="output">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryOutput" /> class.</param>
		/// <returns>A sequence of instances of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</returns>
		public IList<XPathItem> EndSequenceConstruction(out XmlQueryOutput output)
		{
			IList<XPathItem> resultSequence = ((XmlCachedSequenceWriter)this.output.SequenceWriter).ResultSequence;
			output = (this.output = stkOutput.Pop());
			return resultSequence;
		}

		/// <summary>Starts constructing an RTF and returns a new <see cref="T:System.Xml.Xsl.Runtime.XmlQueryOutput" /> object that will be used to construct this RTF.</summary>
		/// <param name="baseUri">A value of type <see langword="string" />.</param>
		/// <param name="output">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryOutput" /> class.</param>
		public void StartRtfConstruction(string baseUri, out XmlQueryOutput output)
		{
			stkOutput.Push(this.output);
			output = (this.output = new XmlQueryOutput(this, new XmlEventCache(baseUri, hasRootNode: true)));
		}

		/// <summary>Finishes constructing an RTF.</summary>
		/// <param name="output">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryOutput" /> class.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</returns>
		public XPathNavigator EndRtfConstruction(out XmlQueryOutput output)
		{
			XmlEventCache xmlEventCache = (XmlEventCache)this.output.Writer;
			output = (this.output = stkOutput.Pop());
			xmlEventCache.EndEvents();
			return new RtfTreeNavigator(xmlEventCache, nameTableQuery);
		}

		/// <summary>Constructs a new <see cref="T:System.Xml.XPath.XPathNavigator" /> from the specified text.</summary>
		/// <param name="text">A value of type <see langword="string" />.</param>
		/// <param name="baseUri">A value of type <see langword="string" />.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</returns>
		public XPathNavigator TextRtfConstruction(string text, string baseUri)
		{
			return new RtfTextNavigator(text, baseUri);
		}

		/// <summary>Reports query execution information to the event handler.</summary>
		/// <param name="message">A value of type <see langword="string" />.</param>
		public void SendMessage(string message)
		{
			ctxt.OnXsltMessageEncountered(message);
		}

		/// <summary>Throws an XML exception that has the specified message text.</summary>
		/// <param name="text">A value of type <see langword="string" />.</param>
		public void ThrowException(string text)
		{
			throw new XslTransformException(text);
		}

		internal static XPathNavigator SyncToNavigator(XPathNavigator navigatorThis, XPathNavigator navigatorThat)
		{
			if (navigatorThis == null || !navigatorThis.MoveTo(navigatorThat))
			{
				return navigatorThat.Clone();
			}
			return navigatorThis;
		}

		/// <summary>Used for debugging in Visual Studio. Called after the current node has changed.</summary>
		/// <param name="currentNode">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object that identifies the node.</param>
		/// <returns>An integer that indicates the status of the change. Used for internal testing only.</returns>
		public static int OnCurrentNodeChanged(XPathNavigator currentNode)
		{
			if (currentNode is IXmlLineInfo xmlLineInfo && (currentNode.NodeType != XPathNodeType.Namespace || !IsInheritedNamespace(currentNode)))
			{
				OnCurrentNodeChanged2(currentNode.BaseURI, xmlLineInfo.LineNumber, xmlLineInfo.LinePosition);
			}
			return 0;
		}

		private static bool IsInheritedNamespace(XPathNavigator node)
		{
			XPathNavigator xPathNavigator = node.Clone();
			if (xPathNavigator.MoveToParent() && xPathNavigator.MoveToFirstNamespace(XPathNamespaceScope.Local))
			{
				do
				{
					if ((object)xPathNavigator.LocalName == node.LocalName)
					{
						return false;
					}
				}
				while (xPathNavigator.MoveToNextNamespace(XPathNamespaceScope.Local));
			}
			return true;
		}

		private static void OnCurrentNodeChanged2(string baseUri, int lineNumber, int linePosition)
		{
		}
	}
	/// <summary>A sequence of XML values that dynamically expands and allows random access to items.</summary>
	/// <typeparam name="T">The type of this <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" />.</typeparam>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public class XmlQuerySequence<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection
	{
		/// <summary>Creates a new instance of <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" />.</summary>
		public static readonly XmlQuerySequence<T> Empty = new XmlQuerySequence<T>();

		private static readonly Type XPathItemType = typeof(XPathItem);

		private T[] items;

		private int size;

		private const int DefaultCacheSize = 16;

		/// <summary>Returns the number of items in the sequence.</summary>
		/// <returns>A value of type <see langword="int" />.</returns>
		public int Count => size;

		/// <summary>Returns <see langword="false" />. The <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> is not thread-safe.</summary>
		/// <returns>
		///   <see langword="false" />
		/// </returns>
		bool ICollection.IsSynchronized => false;

		/// <summary>Returns this instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> class. This instance can be used to synchronize access.</summary>
		/// <returns>This instance of <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" />.</returns>
		object ICollection.SyncRoot => this;

		/// <summary>If the <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> is read-only, this property returns <see langword="true" />.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> is read-only; otherwise, <see langword="false" />.</returns>
		bool ICollection<T>.IsReadOnly => true;

		/// <summary>Returns <see langword="true" /> to indicate items cannot be added, removed, or modified.</summary>
		/// <returns>Always returns <see langword="true" />.</returns>
		bool IList.IsFixedSize => true;

		/// <summary>Gets a value indicating whether the <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> is read-only. Always <see langword="true" />.</summary>
		/// <returns>Always returns <see langword="true" /> to indicate <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> is read-only.</returns>
		bool IList.IsReadOnly => true;

		/// <summary>Returns the item at the specified index.</summary>
		/// <param name="index">The specified index.</param>
		/// <returns>An item at the specified index.</returns>
		object IList.this[int index]
		{
			get
			{
				if (index >= size)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				return items[index];
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		/// <summary>Returns the item at the specified index.</summary>
		/// <param name="index">A value of type <see langword="int" />.</param>
		/// <returns>The item at the specified index.</returns>
		public T this[int index]
		{
			get
			{
				if (index >= size)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				return items[index];
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		/// <summary>Clears and reuses the specified <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> if it is available. If the <paramref name="seq" /> parameter is <see langword="null" />, creates a new <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" />.</summary>
		/// <param name="seq">An <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> instance to be reused.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> class.</returns>
		public static XmlQuerySequence<T> CreateOrReuse(XmlQuerySequence<T> seq)
		{
			if (seq != null)
			{
				seq.Clear();
				return seq;
			}
			return new XmlQuerySequence<T>();
		}

		/// <summary>Clears and reuses the specified <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> it is available. If the <paramref name="seq" /> parameter is <see langword="null" />, creates a new <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> and adds <paramref name="item" /> to the collection.</summary>
		/// <param name="seq">An <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> instance to be reused.</param>
		/// <param name="item">An item to add.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> class.</returns>
		public static XmlQuerySequence<T> CreateOrReuse(XmlQuerySequence<T> seq, T item)
		{
			if (seq != null)
			{
				seq.Clear();
				seq.Add(item);
				return seq;
			}
			return new XmlQuerySequence<T>(item);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> class.</summary>
		public XmlQuerySequence()
		{
			items = new T[16];
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> class.</summary>
		/// <param name="capacity">The size of this collection.</param>
		public XmlQuerySequence(int capacity)
		{
			items = new T[capacity];
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> class.</summary>
		/// <param name="array">An array of <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> instances.</param>
		/// <param name="size">The size of the array.</param>
		public XmlQuerySequence(T[] array, int size)
		{
			items = array;
			this.size = size;
		}

		/// <summary>Constructs a singleton <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> that has <paramref name="value" /> as its only element.</summary>
		/// <param name="value">The only value in this <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" />.</param>
		public XmlQuerySequence(T value)
		{
			items = new T[1];
			items[0] = value;
			size = 1;
		}

		/// <summary>Returns an enumerator that can be used to iterate through the query sequence collection.</summary>
		/// <returns>An enumerator that can be used to iterate through the query sequence collection.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return new IListEnumerator<T>(this);
		}

		/// <summary>Returns <see cref="T:System.Collections.Generic.IEnumerator`1" />.</summary>
		/// <returns>An instance of the <see cref="T:System.Collections.Generic.IEnumerator`1" /> class.</returns>
		public IEnumerator<T> GetEnumerator()
		{
			return new IListEnumerator<T>(this);
		}

		/// <summary>Copies the contents of this sequence to the specified array, starting at the specified index in the target array.</summary>
		/// <param name="array">The specified array.</param>
		/// <param name="index">The specified index.</param>
		void ICollection.CopyTo(Array array, int index)
		{
			if (size != 0)
			{
				Array.Copy(items, 0, array, index, size);
			}
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		/// <param name="value">The sequence value.</param>
		void ICollection<T>.Add(T value)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		void ICollection<T>.Clear()
		{
			throw new NotSupportedException();
		}

		/// <summary>Returns <see langword="true" /> if the specified value is in the sequence.</summary>
		/// <param name="value">The value to find in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
		/// <returns>
		///   <see langword="true" /> if the specified value is in the sequence; otherwise, <see langword="false" />.</returns>
		public bool Contains(T value)
		{
			return IndexOf(value) != -1;
		}

		/// <summary>Copies the contents of this sequence to the specified array, starting at the specified index in the array.</summary>
		/// <param name="array">The array to copy the content of the <see cref="T:System.Collections.Generic.ICollection`1" /> to.</param>
		/// <param name="index">A value of type <see langword="int" />.</param>
		public void CopyTo(T[] array, int index)
		{
			for (int i = 0; i < Count; i++)
			{
				array[index + i] = this[i];
			}
		}

		/// <summary>Removes the specified item from the collection.</summary>
		/// <param name="value">The item to be removed.</param>
		/// <returns>
		///   <see langword="true" /> if the item was removed; otherwise, <see langword="false" />.</returns>
		bool ICollection<T>.Remove(T value)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		/// <param name="value">The sequence value.</param>
		/// <returns>The index of the item added.</returns>
		int IList.Add(object value)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		void IList.Clear()
		{
			throw new NotSupportedException();
		}

		/// <summary>Returns <see langword="true" /> if the specified value is in the sequence.</summary>
		/// <param name="value">The specified value.</param>
		/// <returns>
		///   <see langword="true" /> if the specified value is in the sequence; otherwise, <see langword="false" />.</returns>
		bool IList.Contains(object value)
		{
			return Contains((T)value);
		}

		/// <summary>Returns the index of the specified value in the sequence.</summary>
		/// <param name="value">The specified value.</param>
		/// <returns>The index of the specified value in the sequence.</returns>
		int IList.IndexOf(object value)
		{
			return IndexOf((T)value);
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		/// <param name="index">The specified index.</param>
		/// <param name="value">The specified value.</param>
		void IList.Insert(int index, object value)
		{
			throw new NotSupportedException();
		}

		/// <summary>Not implemented. Throws the <see cref="T:System.NotSupportedException" /> exception.</summary>
		/// <param name="value">The specified value.</param>
		void IList.Remove(object value)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		/// <param name="index">The specified index.</param>
		void IList.RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>Returns the index of the specified value in the sequence.</summary>
		/// <param name="value">The value for which to get the index.</param>
		/// <returns>The index.</returns>
		public int IndexOf(T value)
		{
			int num = Array.IndexOf(items, value);
			if (num >= size)
			{
				return -1;
			}
			return num;
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		/// <param name="index">The sequence index.</param>
		/// <param name="value">The sequence value.</param>
		void IList<T>.Insert(int index, T value)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		/// <param name="index">The sequence index.</param>
		void IList<T>.RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		public void Clear()
		{
			size = 0;
			OnItemsChanged();
		}

		/// <summary>Throws a <see cref="T:System.NotSupportedException" /> exception in all cases.</summary>
		/// <param name="value">An object to add to the collection.</param>
		public void Add(T value)
		{
			EnsureCache();
			items[size++] = value;
			OnItemsChanged();
		}

		/// <summary>Sort the items in the cache using the keys contained in the specified array.</summary>
		/// <param name="keys">A value of type <see langword="array" />.</param>
		public void SortByKeys(Array keys)
		{
			if (size > 1)
			{
				Array.Sort(keys, items, 0, size);
				OnItemsChanged();
			}
		}

		private void EnsureCache()
		{
			if (size >= items.Length)
			{
				T[] array = new T[size * 2];
				CopyTo(array, 0);
				items = array;
			}
		}

		/// <summary>Called when one or more items in the cache have been added or removed. This method can also be called from the <see cref="M:System.Xml.Xsl.Runtime.XmlQuerySequence`1.SortByKeys(System.Array)" /> method.</summary>
		protected virtual void OnItemsChanged()
		{
		}
	}
	/// <summary>A sequence of XML items that dynamically expands and allows random access to items.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlQueryItemSequence : XmlQuerySequence<XPathItem>
	{
		/// <summary>Returns a properly initialized, empty <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" />.</summary>
		public new static readonly XmlQueryItemSequence Empty = new XmlQueryItemSequence();

		/// <summary>Clears and reuses an <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" /> object if it is available. If the <paramref name="seq" /> parameter is null, creates a new <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" />.</summary>
		/// <param name="seq">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" /> class.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" /> class.</returns>
		public static XmlQueryItemSequence CreateOrReuse(XmlQueryItemSequence seq)
		{
			if (seq != null)
			{
				seq.Clear();
				return seq;
			}
			return new XmlQueryItemSequence();
		}

		/// <summary>Clears and reuses an <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" /> object if it is available. If the <paramref name="seq" /> parameter is null, creates a new <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" />. This method then adds a new item to reused or new sequence.</summary>
		/// <param name="seq">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" /> class.</param>
		/// <param name="item">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" /> class.</returns>
		public static XmlQueryItemSequence CreateOrReuse(XmlQueryItemSequence seq, XPathItem item)
		{
			if (seq != null)
			{
				seq.Clear();
				seq.Add(item);
				return seq;
			}
			return new XmlQueryItemSequence(item);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" /> class.</summary>
		public XmlQueryItemSequence()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" /> class.</summary>
		/// <param name="capacity">A value of type <see langword="Int32" />.</param>
		public XmlQueryItemSequence(int capacity)
			: base(capacity)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryItemSequence" /> class.</summary>
		/// <param name="item">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		public XmlQueryItemSequence(XPathItem item)
			: base(1)
		{
			AddClone(item);
		}

		/// <summary>Adds an item to the sequence. If the item is a navigator, this method clones it before adding it to the sequence.</summary>
		/// <param name="item">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		public void AddClone(XPathItem item)
		{
			if (item.IsNode)
			{
				Add(((XPathNavigator)item).Clone());
			}
			else
			{
				Add(item);
			}
		}
	}
	/// <summary>A sequence of XML nodes that dynamically expands and allows random access to items.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XmlQueryNodeSequence : XmlQuerySequence<XPathNavigator>, IList<XPathItem>, ICollection<XPathItem>, IEnumerable<XPathItem>, IEnumerable
	{
		/// <summary>Gets an empty <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> that is properly initialized.</summary>
		public new static readonly XmlQueryNodeSequence Empty = new XmlQueryNodeSequence();

		private XmlQueryNodeSequence docOrderDistinct;

		/// <summary>If this property is true, the nodes in this cache are in document order with no duplicates.</summary>
		/// <returns>
		///   <see langword="true" /> if the nodes are distinct, otherwise return <see langword="false" />.</returns>
		public bool IsDocOrderDistinct
		{
			get
			{
				if (docOrderDistinct != this)
				{
					return base.Count <= 1;
				}
				return true;
			}
			set
			{
				docOrderDistinct = (value ? this : null);
			}
		}

		/// <summary>Specifies that items cannot be added, removed, or modified through the <see cref="T:System.Collections.Generic.ICollection`1" /> interface.</summary>
		/// <returns>
		///   <see langword="true" /> if the collection is read only; otherwise, <see langword="false" />.</returns>
		bool ICollection<XPathItem>.IsReadOnly => true;

		/// <summary>Returns the item at the specified index.</summary>
		/// <param name="index">A value of type <see langword="Int32" />.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</returns>
		XPathItem IList<XPathItem>.this[int index]
		{
			get
			{
				if (index >= base.Count)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				return base[index];
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		/// <summary>Clears and reuses the specified <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> if it is available. If the <paramref name="seq" /> parameter is <see langword="null" />, creates a new <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" />.</summary>
		/// <param name="seq">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> class.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> class.</returns>
		public static XmlQueryNodeSequence CreateOrReuse(XmlQueryNodeSequence seq)
		{
			if (seq != null)
			{
				seq.Clear();
				return seq;
			}
			return new XmlQueryNodeSequence();
		}

		/// <summary>Clears and reuses the specified <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> if it is available. If the <paramref name="seq" /> parameter is <see langword="null" />, creates a new <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> and adds <paramref name="navigator" /> to the sequence.</summary>
		/// <param name="seq">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> class.</param>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> class.</returns>
		public static XmlQueryNodeSequence CreateOrReuse(XmlQueryNodeSequence seq, XPathNavigator navigator)
		{
			if (seq != null)
			{
				seq.Clear();
				seq.Add(navigator);
				return seq;
			}
			return new XmlQueryNodeSequence(navigator);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> class.</summary>
		public XmlQueryNodeSequence()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> class.</summary>
		/// <param name="capacity">A value of type <see langword="Int32" />.</param>
		public XmlQueryNodeSequence(int capacity)
			: base(capacity)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> class.</summary>
		/// <param name="list">A sequence of <see cref="T:System.Xml.XPath.XPathNavigator" /> instances.</param>
		public XmlQueryNodeSequence(IList<XPathNavigator> list)
			: base(list.Count)
		{
			for (int i = 0; i < list.Count; i++)
			{
				AddClone(list[i]);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> class.</summary>
		/// <param name="array">An array of instances of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		/// <param name="size">A value of type <see langword="int" />.</param>
		public XmlQueryNodeSequence(XPathNavigator[] array, int size)
			: base(array, size)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> class.</summary>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		public XmlQueryNodeSequence(XPathNavigator navigator)
			: base(1)
		{
			AddClone(navigator);
		}

		/// <summary>Returns a sequence that contains all the distinct nodes in this cache, sorted in document order.</summary>
		/// <param name="comparer">A sequence of <see cref="T:System.Xml.XPath.XPathNavigator" /> instances.</param>
		/// <returns>A sequence of <see cref="T:System.Xml.Xsl.Runtime.XmlQueryNodeSequence" /> class instances.</returns>
		public XmlQueryNodeSequence DocOrderDistinct(IComparer<XPathNavigator> comparer)
		{
			if (docOrderDistinct != null)
			{
				return docOrderDistinct;
			}
			if (base.Count <= 1)
			{
				return this;
			}
			XPathNavigator[] array = new XPathNavigator[base.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = base[i];
			}
			Array.Sort(array, 0, base.Count, comparer);
			int num = 0;
			for (int i = 1; i < array.Length; i++)
			{
				if (!array[num].IsSamePosition(array[i]))
				{
					num++;
					if (num != i)
					{
						array[num] = array[i];
					}
				}
			}
			docOrderDistinct = new XmlQueryNodeSequence(array, num + 1);
			docOrderDistinct.docOrderDistinct = docOrderDistinct;
			return docOrderDistinct;
		}

		/// <summary>Clone the navigator and then adds a node to the sequence.</summary>
		/// <param name="navigator">An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</param>
		public void AddClone(XPathNavigator navigator)
		{
			Add(navigator.Clone());
		}

		protected override void OnItemsChanged()
		{
			docOrderDistinct = null;
		}

		/// <summary>Returns the <see cref="T:System.Collections.Generic.IEnumerator`1" /> of <see cref="T:System.Xml.XPath.XPathItem" /> implementation.</summary>
		/// <returns>The IEnumerator&lt;XPathItem&gt; implementation.</returns>
		IEnumerator<XPathItem> IEnumerable<XPathItem>.GetEnumerator()
		{
			return new IListEnumerator<XPathItem>(this);
		}

		/// <summary>Throws the <see cref="T:System.NotSupportedException" /> exception.</summary>
		/// <param name="value">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		void ICollection<XPathItem>.Add(XPathItem value)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws the <see cref="T:System.NotSupportedException" /> exception.</summary>
		void ICollection<XPathItem>.Clear()
		{
			throw new NotSupportedException();
		}

		/// <summary>Returns true if the specified value is in the sequence.</summary>
		/// <param name="value">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <returns>
		///   <see langword="true" /> if the value is in the sequence; otherwise, <see langword="false" />.</returns>
		bool ICollection<XPathItem>.Contains(XPathItem value)
		{
			return IndexOf((XPathNavigator)value) != -1;
		}

		/// <summary>Copies the contents of this sequence to the specified array, starting at the specified index in the target array.</summary>
		/// <param name="array">An array of <see cref="T:System.Xml.XPath.XPathItem" /> instances.</param>
		/// <param name="index">A value of type <see langword="int" />.</param>
		void ICollection<XPathItem>.CopyTo(XPathItem[] array, int index)
		{
			for (int i = 0; i < base.Count; i++)
			{
				array[index + i] = base[i];
			}
		}

		/// <summary>Throws the <see cref="T:System.NotSupportedException" /> exception.</summary>
		/// <param name="value">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <returns>
		///   <see langword="true" /> if the item is removed; otherwise, <see langword="false" />.</returns>
		bool ICollection<XPathItem>.Remove(XPathItem value)
		{
			throw new NotSupportedException();
		}

		/// <summary>Returns the index of the specified value in the sequence.</summary>
		/// <param name="value">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <returns>The index of the specified value in the sequence.</returns>
		int IList<XPathItem>.IndexOf(XPathItem value)
		{
			return IndexOf((XPathNavigator)value);
		}

		/// <summary>Throws the <see cref="T:System.NotSupportedException" /> exception.</summary>
		/// <param name="index">A value of type <see langword="int" />.</param>
		/// <param name="value">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		void IList<XPathItem>.Insert(int index, XPathItem value)
		{
			throw new NotSupportedException();
		}

		/// <summary>Throws the <see cref="T:System.NotSupportedException" /> exception.</summary>
		/// <param name="index">A value of type <see langword="int" />.</param>
		void IList<XPathItem>.RemoveAt(int index)
		{
			throw new NotSupportedException();
		}
	}
	internal class XmlQueryStaticData
	{
		public const string DataFieldName = "staticData";

		public const string TypesFieldName = "ebTypes";

		private const int CurrentFormatVersion = 0;

		private XmlWriterSettings defaultWriterSettings;

		private IList<WhitespaceRule> whitespaceRules;

		private string[] names;

		private StringPair[][] prefixMappingsList;

		private Int32Pair[] filters;

		private XmlQueryType[] types;

		private XmlCollation[] collations;

		private string[] globalNames;

		private EarlyBoundInfo[] earlyBound;

		public XmlWriterSettings DefaultWriterSettings => defaultWriterSettings;

		public IList<WhitespaceRule> WhitespaceRules => whitespaceRules;

		public string[] Names => names;

		public StringPair[][] PrefixMappingsList => prefixMappingsList;

		public Int32Pair[] Filters => filters;

		public XmlQueryType[] Types => types;

		public XmlCollation[] Collations => collations;

		public string[] GlobalNames => globalNames;

		public EarlyBoundInfo[] EarlyBound => earlyBound;

		public XmlQueryStaticData(XmlWriterSettings defaultWriterSettings, IList<WhitespaceRule> whitespaceRules, StaticDataManager staticData)
		{
			this.defaultWriterSettings = defaultWriterSettings;
			this.whitespaceRules = whitespaceRules;
			names = staticData.Names;
			prefixMappingsList = staticData.PrefixMappingsList;
			filters = staticData.NameFilters;
			types = staticData.XmlTypes;
			collations = staticData.Collations;
			globalNames = staticData.GlobalNames;
			earlyBound = staticData.EarlyBound;
		}

		public XmlQueryStaticData(byte[] data, Type[] ebTypes)
		{
			MemoryStream input = new MemoryStream(data, writable: false);
			XmlQueryDataReader xmlQueryDataReader = new XmlQueryDataReader(input);
			int num = xmlQueryDataReader.ReadInt32Encoded();
			if ((num & -256) > 0)
			{
				throw new NotSupportedException();
			}
			defaultWriterSettings = new XmlWriterSettings(xmlQueryDataReader);
			int num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				whitespaceRules = new WhitespaceRule[num2];
				for (int i = 0; i < num2; i++)
				{
					whitespaceRules[i] = new WhitespaceRule(xmlQueryDataReader);
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				names = new string[num2];
				for (int j = 0; j < num2; j++)
				{
					names[j] = xmlQueryDataReader.ReadString();
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				prefixMappingsList = new StringPair[num2][];
				for (int k = 0; k < num2; k++)
				{
					int num3 = xmlQueryDataReader.ReadInt32();
					prefixMappingsList[k] = new StringPair[num3];
					for (int l = 0; l < num3; l++)
					{
						prefixMappingsList[k][l] = new StringPair(xmlQueryDataReader.ReadString(), xmlQueryDataReader.ReadString());
					}
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				filters = new Int32Pair[num2];
				for (int m = 0; m < num2; m++)
				{
					filters[m] = new Int32Pair(xmlQueryDataReader.ReadInt32Encoded(), xmlQueryDataReader.ReadInt32Encoded());
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				types = new XmlQueryType[num2];
				for (int n = 0; n < num2; n++)
				{
					types[n] = XmlQueryTypeFactory.Deserialize(xmlQueryDataReader);
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				collations = new XmlCollation[num2];
				for (int num4 = 0; num4 < num2; num4++)
				{
					collations[num4] = new XmlCollation(xmlQueryDataReader);
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				globalNames = new string[num2];
				for (int num5 = 0; num5 < num2; num5++)
				{
					globalNames[num5] = xmlQueryDataReader.ReadString();
				}
			}
			num2 = xmlQueryDataReader.ReadInt32();
			if (num2 != 0)
			{
				earlyBound = new EarlyBoundInfo[num2];
				for (int num6 = 0; num6 < num2; num6++)
				{
					earlyBound[num6] = new EarlyBoundInfo(xmlQueryDataReader.ReadString(), ebTypes[num6]);
				}
			}
			xmlQueryDataReader.Close();
		}

		public void GetObjectData(out byte[] data, out Type[] ebTypes)
		{
			MemoryStream memoryStream = new MemoryStream(4096);
			XmlQueryDataWriter xmlQueryDataWriter = new XmlQueryDataWriter(memoryStream);
			xmlQueryDataWriter.WriteInt32Encoded(0);
			defaultWriterSettings.GetObjectData(xmlQueryDataWriter);
			if (whitespaceRules == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(whitespaceRules.Count);
				foreach (WhitespaceRule whitespaceRule in whitespaceRules)
				{
					whitespaceRule.GetObjectData(xmlQueryDataWriter);
				}
			}
			if (names == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(names.Length);
				string[] array = names;
				foreach (string value in array)
				{
					xmlQueryDataWriter.Write(value);
				}
			}
			if (prefixMappingsList == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(prefixMappingsList.Length);
				StringPair[][] array2 = prefixMappingsList;
				foreach (StringPair[] array3 in array2)
				{
					xmlQueryDataWriter.Write(array3.Length);
					StringPair[] array4 = array3;
					for (int k = 0; k < array4.Length; k++)
					{
						StringPair stringPair = array4[k];
						xmlQueryDataWriter.Write(stringPair.Left);
						xmlQueryDataWriter.Write(stringPair.Right);
					}
				}
			}
			if (filters == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(filters.Length);
				Int32Pair[] array5 = filters;
				for (int l = 0; l < array5.Length; l++)
				{
					Int32Pair int32Pair = array5[l];
					xmlQueryDataWriter.WriteInt32Encoded(int32Pair.Left);
					xmlQueryDataWriter.WriteInt32Encoded(int32Pair.Right);
				}
			}
			if (types == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(types.Length);
				XmlQueryType[] array6 = types;
				foreach (XmlQueryType type in array6)
				{
					XmlQueryTypeFactory.Serialize(xmlQueryDataWriter, type);
				}
			}
			if (collations == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(collations.Length);
				XmlCollation[] array7 = collations;
				foreach (XmlCollation xmlCollation in array7)
				{
					xmlCollation.GetObjectData(xmlQueryDataWriter);
				}
			}
			if (globalNames == null)
			{
				xmlQueryDataWriter.Write(0);
			}
			else
			{
				xmlQueryDataWriter.Write(globalNames.Length);
				string[] array8 = globalNames;
				foreach (string value2 in array8)
				{
					xmlQueryDataWriter.Write(value2);
				}
			}
			if (earlyBound == null)
			{
				xmlQueryDataWriter.Write(0);
				ebTypes = null;
			}
			else
			{
				xmlQueryDataWriter.Write(earlyBound.Length);
				ebTypes = new Type[earlyBound.Length];
				int num2 = 0;
				EarlyBoundInfo[] array9 = earlyBound;
				foreach (EarlyBoundInfo earlyBoundInfo in array9)
				{
					xmlQueryDataWriter.Write(earlyBoundInfo.NamespaceUri);
					ebTypes[num2++] = earlyBoundInfo.EarlyBoundType;
				}
			}
			xmlQueryDataWriter.Close();
			data = memoryStream.ToArray();
		}
	}
	internal class XmlQueryDataReader : BinaryReader
	{
		public XmlQueryDataReader(Stream input)
			: base(input)
		{
		}

		public int ReadInt32Encoded()
		{
			return Read7BitEncodedInt();
		}

		public string ReadStringQ()
		{
			if (!ReadBoolean())
			{
				return null;
			}
			return ReadString();
		}

		public sbyte ReadSByte(sbyte minValue, sbyte maxValue)
		{
			sbyte b = ReadSByte();
			if (b < minValue)
			{
				throw new ArgumentOutOfRangeException("minValue");
			}
			if (maxValue < b)
			{
				throw new ArgumentOutOfRangeException("maxValue");
			}
			return b;
		}
	}
	internal class XmlQueryDataWriter : BinaryWriter
	{
		public XmlQueryDataWriter(Stream output)
			: base(output)
		{
		}

		public void WriteInt32Encoded(int value)
		{
			Write7BitEncodedInt(value);
		}

		public void WriteStringQ(string value)
		{
			Write(value != null);
			if (value != null)
			{
				Write(value);
			}
		}
	}
	internal sealed class XmlRawWriterWrapper : XmlRawWriter
	{
		private XmlWriter wrapped;

		public override XmlWriterSettings Settings => wrapped.Settings;

		public XmlRawWriterWrapper(XmlWriter writer)
		{
			wrapped = writer;
		}

		public override void WriteDocType(string name, string pubid, string sysid, string subset)
		{
			wrapped.WriteDocType(name, pubid, sysid, subset);
		}

		public override void WriteStartElement(string prefix, string localName, string ns)
		{
			wrapped.WriteStartElement(prefix, localName, ns);
		}

		public override void WriteStartAttribute(string prefix, string localName, string ns)
		{
			wrapped.WriteStartAttribute(prefix, localName, ns);
		}

		public override void WriteEndAttribute()
		{
			wrapped.WriteEndAttribute();
		}

		public override void WriteCData(string text)
		{
			wrapped.WriteCData(text);
		}

		public override void WriteComment(string text)
		{
			wrapped.WriteComment(text);
		}

		public override void WriteProcessingInstruction(string name, string text)
		{
			wrapped.WriteProcessingInstruction(name, text);
		}

		public override void WriteWhitespace(string ws)
		{
			wrapped.WriteWhitespace(ws);
		}

		public override void WriteString(string text)
		{
			wrapped.WriteString(text);
		}

		public override void WriteChars(char[] buffer, int index, int count)
		{
			wrapped.WriteChars(buffer, index, count);
		}

		public override void WriteRaw(char[] buffer, int index, int count)
		{
			wrapped.WriteRaw(buffer, index, count);
		}

		public override void WriteRaw(string data)
		{
			wrapped.WriteRaw(data);
		}

		public override void WriteEntityRef(string name)
		{
			wrapped.WriteEntityRef(name);
		}

		public override void WriteCharEntity(char ch)
		{
			wrapped.WriteCharEntity(ch);
		}

		public override void WriteSurrogateCharEntity(char lowChar, char highChar)
		{
			wrapped.WriteSurrogateCharEntity(lowChar, highChar);
		}

		public override void Close()
		{
			wrapped.Close();
		}

		public override void Flush()
		{
			wrapped.Flush();
		}

		public override void WriteValue(object value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(string value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(bool value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(DateTime value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(float value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(decimal value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(double value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(int value)
		{
			wrapped.WriteValue(value);
		}

		public override void WriteValue(long value)
		{
			wrapped.WriteValue(value);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (disposing)
				{
					((IDisposable)wrapped).Dispose();
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		internal override void WriteXmlDeclaration(XmlStandalone standalone)
		{
		}

		internal override void WriteXmlDeclaration(string xmldecl)
		{
		}

		internal override void StartElementContent()
		{
		}

		internal override void WriteEndElement(string prefix, string localName, string ns)
		{
			wrapped.WriteEndElement();
		}

		internal override void WriteFullEndElement(string prefix, string localName, string ns)
		{
			wrapped.WriteFullEndElement();
		}

		internal override void WriteNamespaceDeclaration(string prefix, string ns)
		{
			if (prefix.Length == 0)
			{
				wrapped.WriteAttributeString(string.Empty, "xmlns", "http://www.w3.org/2000/xmlns/", ns);
			}
			else
			{
				wrapped.WriteAttributeString("xmlns", prefix, "http://www.w3.org/2000/xmlns/", ns);
			}
		}
	}
	internal abstract class XmlSequenceWriter
	{
		public abstract XmlRawWriter StartTree(XPathNodeType rootType, IXmlNamespaceResolver nsResolver, XmlNameTable nameTable);

		public abstract void EndTree();

		public abstract void WriteItem(XPathItem item);
	}
	internal class XmlCachedSequenceWriter : XmlSequenceWriter
	{
		private XmlQueryItemSequence seqTyped;

		private XPathDocument doc;

		private XmlRawWriter writer;

		public XmlQueryItemSequence ResultSequence => seqTyped;

		public XmlCachedSequenceWriter()
		{
			seqTyped = new XmlQueryItemSequence();
		}

		public override XmlRawWriter StartTree(XPathNodeType rootType, IXmlNamespaceResolver nsResolver, XmlNameTable nameTable)
		{
			doc = new XPathDocument(nameTable);
			writer = doc.LoadFromWriter(XPathDocument.LoadFlags.AtomizeNames | ((rootType != 0) ? XPathDocument.LoadFlags.Fragment : XPathDocument.LoadFlags.None), string.Empty);
			writer.NamespaceResolver = nsResolver;
			return writer;
		}

		public override void EndTree()
		{
			writer.Close();
			seqTyped.Add(doc.CreateNavigator());
		}

		public override void WriteItem(XPathItem item)
		{
			seqTyped.AddClone(item);
		}
	}
	internal class XmlMergeSequenceWriter : XmlSequenceWriter
	{
		private XmlRawWriter xwrt;

		private bool lastItemWasAtomic;

		public XmlMergeSequenceWriter(XmlRawWriter xwrt)
		{
			this.xwrt = xwrt;
			lastItemWasAtomic = false;
		}

		public override XmlRawWriter StartTree(XPathNodeType rootType, IXmlNamespaceResolver nsResolver, XmlNameTable nameTable)
		{
			if (rootType == XPathNodeType.Attribute || rootType == XPathNodeType.Namespace)
			{
				throw new XslTransformException("XmlIl_TopLevelAttrNmsp", string.Empty);
			}
			xwrt.NamespaceResolver = nsResolver;
			return xwrt;
		}

		public override void EndTree()
		{
			lastItemWasAtomic = false;
		}

		public override void WriteItem(XPathItem item)
		{
			if (item.IsNode)
			{
				XPathNavigator xPathNavigator = item as XPathNavigator;
				if (xPathNavigator.NodeType == XPathNodeType.Attribute || xPathNavigator.NodeType == XPathNodeType.Namespace)
				{
					throw new XslTransformException("XmlIl_TopLevelAttrNmsp", string.Empty);
				}
				CopyNode(xPathNavigator);
				lastItemWasAtomic = false;
			}
			else
			{
				WriteString(item.Value);
			}
		}

		private void WriteString(string value)
		{
			if (lastItemWasAtomic)
			{
				xwrt.WriteWhitespace(" ");
			}
			else
			{
				lastItemWasAtomic = true;
			}
			xwrt.WriteString(value);
		}

		private void CopyNode(XPathNavigator nav)
		{
			int num = 0;
			while (true)
			{
				if (CopyShallowNode(nav))
				{
					XPathNodeType nodeType = nav.NodeType;
					if (nodeType == XPathNodeType.Element)
					{
						if (nav.MoveToFirstAttribute())
						{
							do
							{
								CopyShallowNode(nav);
							}
							while (nav.MoveToNextAttribute());
							nav.MoveToParent();
						}
						XPathNamespaceScope xPathNamespaceScope = ((num == 0) ? XPathNamespaceScope.ExcludeXml : XPathNamespaceScope.Local);
						if (nav.MoveToFirstNamespace(xPathNamespaceScope))
						{
							CopyNamespaces(nav, xPathNamespaceScope);
							nav.MoveToParent();
						}
						xwrt.StartElementContent();
					}
					if (nav.MoveToFirstChild())
					{
						num++;
						continue;
					}
					if (nav.NodeType == XPathNodeType.Element)
					{
						xwrt.WriteEndElement(nav.Prefix, nav.LocalName, nav.NamespaceURI);
					}
				}
				while (true)
				{
					if (num == 0)
					{
						return;
					}
					if (nav.MoveToNext())
					{
						break;
					}
					num--;
					nav.MoveToParent();
					if (nav.NodeType == XPathNodeType.Element)
					{
						xwrt.WriteFullEndElement(nav.Prefix, nav.LocalName, nav.NamespaceURI);
					}
				}
			}
		}

		private bool CopyShallowNode(XPathNavigator nav)
		{
			bool result = false;
			switch (nav.NodeType)
			{
			case XPathNodeType.Element:
				xwrt.WriteStartElement(nav.Prefix, nav.LocalName, nav.NamespaceURI);
				result = true;
				break;
			case XPathNodeType.Attribute:
				xwrt.WriteStartAttribute(nav.Prefix, nav.LocalName, nav.NamespaceURI);
				xwrt.WriteString(nav.Value);
				xwrt.WriteEndAttribute();
				break;
			case XPathNodeType.Text:
				xwrt.WriteString(nav.Value);
				break;
			case XPathNodeType.SignificantWhitespace:
			case XPathNodeType.Whitespace:
				xwrt.WriteWhitespace(nav.Value);
				break;
			case XPathNodeType.Root:
				result = true;
				break;
			case XPathNodeType.Comment:
				xwrt.WriteComment(nav.Value);
				break;
			case XPathNodeType.ProcessingInstruction:
				xwrt.WriteProcessingInstruction(nav.LocalName, nav.Value);
				break;
			case XPathNodeType.Namespace:
				xwrt.WriteNamespaceDeclaration(nav.LocalName, nav.Value);
				break;
			}
			return result;
		}

		private void CopyNamespaces(XPathNavigator nav, XPathNamespaceScope nsScope)
		{
			string localName = nav.LocalName;
			string value = nav.Value;
			if (nav.MoveToNextNamespace(nsScope))
			{
				CopyNamespaces(nav, nsScope);
			}
			xwrt.WriteNamespaceDeclaration(localName, value);
		}
	}
	internal abstract class XmlSortKey : IComparable
	{
		private int priority;

		private XmlSortKey nextKey;

		public int Priority
		{
			set
			{
				for (XmlSortKey xmlSortKey = this; xmlSortKey != null; xmlSortKey = xmlSortKey.nextKey)
				{
					xmlSortKey.priority = value;
				}
			}
		}

		public XmlSortKey AddSortKey(XmlSortKey sortKey)
		{
			if (nextKey != null)
			{
				nextKey.AddSortKey(sortKey);
			}
			else
			{
				nextKey = sortKey;
			}
			return this;
		}

		protected int BreakSortingTie(XmlSortKey that)
		{
			if (nextKey != null)
			{
				return nextKey.CompareTo(that.nextKey);
			}
			if (priority >= that.priority)
			{
				return 1;
			}
			return -1;
		}

		protected int CompareToEmpty(object obj)
		{
			XmlEmptySortKey xmlEmptySortKey = obj as XmlEmptySortKey;
			if (!xmlEmptySortKey.IsEmptyGreatest)
			{
				return 1;
			}
			return -1;
		}

		public abstract int CompareTo(object that);
	}
	internal class XmlEmptySortKey : XmlSortKey
	{
		private bool isEmptyGreatest;

		public bool IsEmptyGreatest => isEmptyGreatest;

		public XmlEmptySortKey(XmlCollation collation)
		{
			isEmptyGreatest = collation.EmptyGreatest != collation.DescendingOrder;
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlEmptySortKey that))
			{
				return -(obj as XmlSortKey).CompareTo(this);
			}
			return BreakSortingTie(that);
		}
	}
	internal class XmlDecimalSortKey : XmlSortKey
	{
		private decimal decVal;

		public XmlDecimalSortKey(decimal value, XmlCollation collation)
		{
			decVal = (collation.DescendingOrder ? (-value) : value);
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlDecimalSortKey xmlDecimalSortKey))
			{
				return CompareToEmpty(obj);
			}
			int num = decimal.Compare(decVal, xmlDecimalSortKey.decVal);
			if (num == 0)
			{
				return BreakSortingTie(xmlDecimalSortKey);
			}
			return num;
		}
	}
	internal class XmlIntegerSortKey : XmlSortKey
	{
		private long longVal;

		public XmlIntegerSortKey(long value, XmlCollation collation)
		{
			longVal = (collation.DescendingOrder ? (~value) : value);
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlIntegerSortKey xmlIntegerSortKey))
			{
				return CompareToEmpty(obj);
			}
			if (longVal == xmlIntegerSortKey.longVal)
			{
				return BreakSortingTie(xmlIntegerSortKey);
			}
			if (longVal >= xmlIntegerSortKey.longVal)
			{
				return 1;
			}
			return -1;
		}
	}
	internal class XmlIntSortKey : XmlSortKey
	{
		private int intVal;

		public XmlIntSortKey(int value, XmlCollation collation)
		{
			intVal = (collation.DescendingOrder ? (~value) : value);
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlIntSortKey xmlIntSortKey))
			{
				return CompareToEmpty(obj);
			}
			if (intVal == xmlIntSortKey.intVal)
			{
				return BreakSortingTie(xmlIntSortKey);
			}
			if (intVal >= xmlIntSortKey.intVal)
			{
				return 1;
			}
			return -1;
		}
	}
	internal class XmlStringSortKey : XmlSortKey
	{
		private System.Globalization.SortKey sortKey;

		private byte[] sortKeyBytes;

		private bool descendingOrder;

		public XmlStringSortKey(System.Globalization.SortKey sortKey, bool descendingOrder)
		{
			this.sortKey = sortKey;
			this.descendingOrder = descendingOrder;
		}

		public XmlStringSortKey(byte[] sortKey, bool descendingOrder)
		{
			sortKeyBytes = sortKey;
			this.descendingOrder = descendingOrder;
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlStringSortKey xmlStringSortKey))
			{
				return CompareToEmpty(obj);
			}
			int num;
			if (sortKey != null)
			{
				num = System.Globalization.SortKey.Compare(sortKey, xmlStringSortKey.sortKey);
			}
			else
			{
				int num2 = ((sortKeyBytes.Length < xmlStringSortKey.sortKeyBytes.Length) ? sortKeyBytes.Length : xmlStringSortKey.sortKeyBytes.Length);
				int num3 = 0;
				while (true)
				{
					if (num3 < num2)
					{
						if (sortKeyBytes[num3] < xmlStringSortKey.sortKeyBytes[num3])
						{
							num = -1;
							break;
						}
						if (sortKeyBytes[num3] > xmlStringSortKey.sortKeyBytes[num3])
						{
							num = 1;
							break;
						}
						num3++;
						continue;
					}
					num = ((sortKeyBytes.Length >= xmlStringSortKey.sortKeyBytes.Length) ? ((sortKeyBytes.Length > xmlStringSortKey.sortKeyBytes.Length) ? 1 : 0) : (-1));
					break;
				}
			}
			if (num == 0)
			{
				return BreakSortingTie(xmlStringSortKey);
			}
			if (!descendingOrder)
			{
				return num;
			}
			return -num;
		}
	}
	internal class XmlDoubleSortKey : XmlSortKey
	{
		private double dblVal;

		private bool isNaN;

		public XmlDoubleSortKey(double value, XmlCollation collation)
		{
			if (double.IsNaN(value))
			{
				isNaN = true;
				dblVal = ((collation.EmptyGreatest != collation.DescendingOrder) ? double.PositiveInfinity : double.NegativeInfinity);
			}
			else
			{
				dblVal = (collation.DescendingOrder ? (0.0 - value) : value);
			}
		}

		public override int CompareTo(object obj)
		{
			if (!(obj is XmlDoubleSortKey xmlDoubleSortKey))
			{
				if (isNaN)
				{
					return BreakSortingTie(obj as XmlSortKey);
				}
				return CompareToEmpty(obj);
			}
			if (dblVal == xmlDoubleSortKey.dblVal)
			{
				if (isNaN)
				{
					if (xmlDoubleSortKey.isNaN)
					{
						return BreakSortingTie(xmlDoubleSortKey);
					}
					if (dblVal != double.NegativeInfinity)
					{
						return 1;
					}
					return -1;
				}
				if (xmlDoubleSortKey.isNaN)
				{
					if (xmlDoubleSortKey.dblVal != double.NegativeInfinity)
					{
						return -1;
					}
					return 1;
				}
				return BreakSortingTie(xmlDoubleSortKey);
			}
			if (!(dblVal < xmlDoubleSortKey.dblVal))
			{
				return 1;
			}
			return -1;
		}
	}
	internal class XmlDateTimeSortKey : XmlIntegerSortKey
	{
		public XmlDateTimeSortKey(DateTime value, XmlCollation collation)
			: base(value.Ticks, collation)
		{
		}
	}
	/// <summary>Accumulates a list of sort keys and stores them in an array.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public struct XmlSortKeyAccumulator
	{
		private XmlSortKey[] keys;

		private int pos;

		private const int DefaultSortKeyCount = 64;

		/// <summary>Gets an array of sort keys that was constructed by the internal <see cref="T:System.Xml.Xsl.Runtime.XmlSortKeyAccumulator" /> class.</summary>
		/// <returns>An array of sort keys.</returns>
		public Array Keys => keys;

		/// <summary>Initializes the <see cref="T:System.Xml.Xsl.Runtime.XmlSortKeyAccumulator" />.</summary>
		public void Create()
		{
			if (keys == null)
			{
				keys = new XmlSortKey[64];
			}
			pos = 0;
			keys[0] = null;
		}

		/// <summary>Creates a new <see cref="T:System.String" /> sort key and appends it to the current run of sort keys.</summary>
		/// <param name="collation">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlCollation" /> class.</param>
		/// <param name="value">A value of type <see langword="string" />.</param>
		public void AddStringSortKey(XmlCollation collation, string value)
		{
			AppendSortKey(collation.CreateSortKey(value));
		}

		/// <summary>Creates a new <see cref="T:System.Decimal" /> sort key and appends it to the current run of sort keys.</summary>
		/// <param name="collation">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlCollation" /> class.</param>
		/// <param name="value">A <see langword="decimal" /> value.</param>
		public void AddDecimalSortKey(XmlCollation collation, decimal value)
		{
			AppendSortKey(new XmlDecimalSortKey(value, collation));
		}

		/// <summary>Creates a new <see cref="T:System.Int64" /> sort key and appends it to the current run of sort keys.</summary>
		/// <param name="collation">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlCollation" /> class.</param>
		/// <param name="value">A value of type <see langword="Int64" />.</param>
		public void AddIntegerSortKey(XmlCollation collation, long value)
		{
			AppendSortKey(new XmlIntegerSortKey(value, collation));
		}

		/// <summary>Creates a new <see cref="T:System.Int32" /> sort key and appends it to the current run of sort keys.</summary>
		/// <param name="collation">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlCollation" /> class.</param>
		/// <param name="value">A value of type <see langword="Int32" />.</param>
		public void AddIntSortKey(XmlCollation collation, int value)
		{
			AppendSortKey(new XmlIntSortKey(value, collation));
		}

		/// <summary>Creates a new <see cref="T:System.Double" /> sort key and appends it to the current run of sort keys.</summary>
		/// <param name="collation">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlCollation" /> class.</param>
		/// <param name="value">A <see langword="double" /> value.</param>
		public void AddDoubleSortKey(XmlCollation collation, double value)
		{
			AppendSortKey(new XmlDoubleSortKey(value, collation));
		}

		/// <summary>Creates a new <see cref="T:System.DateTime" /> sort key and appends it to the current run of sort keys.</summary>
		/// <param name="collation">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlCollation" /> class.</param>
		/// <param name="value">A <see langword="DateTime" /> value.</param>
		public void AddDateTimeSortKey(XmlCollation collation, DateTime value)
		{
			AppendSortKey(new XmlDateTimeSortKey(value, collation));
		}

		/// <summary>Creates a new empty sort key and appends it to the current run of sort keys.</summary>
		/// <param name="collation">An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlCollation" /> class.</param>
		public void AddEmptySortKey(XmlCollation collation)
		{
			AppendSortKey(new XmlEmptySortKey(collation));
		}

		/// <summary>Finishes creating the current run of sort keys and begins a new run.</summary>
		public void FinishSortKeys()
		{
			pos++;
			if (pos >= keys.Length)
			{
				XmlSortKey[] destinationArray = new XmlSortKey[pos * 2];
				Array.Copy(keys, 0, destinationArray, 0, keys.Length);
				keys = destinationArray;
			}
			keys[pos] = null;
		}

		private void AppendSortKey(XmlSortKey key)
		{
			key.Priority = pos;
			if (keys[pos] == null)
			{
				keys[pos] = key;
			}
			else
			{
				keys[pos].AddSortKey(key);
			}
		}
	}
	internal class TokenInfo
	{
		public char startChar;

		public int startIdx;

		public string formatString;

		public int length;

		private TokenInfo()
		{
		}

		[Conditional("DEBUG")]
		public void AssertSeparator(bool isSeparator)
		{
		}

		public static TokenInfo CreateSeparator(string formatString, int startIdx, int tokLen)
		{
			TokenInfo tokenInfo = new TokenInfo();
			tokenInfo.startIdx = startIdx;
			tokenInfo.formatString = formatString;
			tokenInfo.length = tokLen;
			return tokenInfo;
		}

		public static TokenInfo CreateFormat(string formatString, int startIdx, int tokLen)
		{
			TokenInfo tokenInfo = new TokenInfo();
			tokenInfo.formatString = null;
			tokenInfo.length = 1;
			bool flag = false;
			char c = formatString[startIdx];
			switch (c)
			{
			default:
				if (CharUtil.IsDecimalDigitOne(c))
				{
					break;
				}
				if (CharUtil.IsDecimalDigitOne((char)(c + 1)))
				{
					int num = startIdx;
					do
					{
						tokenInfo.length++;
					}
					while (--tokLen > 0 && c == formatString[++num]);
					if (formatString[num] == (c = (char)(c + 1)))
					{
						break;
					}
				}
				flag = true;
				break;
			case '1':
			case 'A':
			case 'I':
			case 'a':
			case 'i':
				break;
			}
			if (tokLen != 1)
			{
				flag = true;
			}
			if (flag)
			{
				tokenInfo.startChar = '1';
				tokenInfo.length = 1;
			}
			else
			{
				tokenInfo.startChar = c;
			}
			return tokenInfo;
		}
	}
	internal class NumberFormatter : NumberFormatterBase
	{
		private string formatString;

		private int lang;

		private string letterValue;

		private string groupingSeparator;

		private int groupingSize;

		private List<TokenInfo> tokens;

		public const char DefaultStartChar = '1';

		private static readonly TokenInfo DefaultFormat = TokenInfo.CreateFormat("0", 0, 1);

		private static readonly TokenInfo DefaultSeparator = TokenInfo.CreateSeparator(".", 0, 1);

		public NumberFormatter(string formatString, int lang, string letterValue, string groupingSeparator, int groupingSize)
		{
			this.formatString = formatString;
			this.lang = lang;
			this.letterValue = letterValue;
			this.groupingSeparator = groupingSeparator;
			this.groupingSize = ((groupingSeparator.Length > 0) ? groupingSize : 0);
			if (formatString == "1" || formatString.Length == 0)
			{
				return;
			}
			tokens = new List<TokenInfo>();
			int num = 0;
			bool flag = CharUtil.IsAlphaNumeric(formatString[num]);
			if (flag)
			{
				tokens.Add(null);
			}
			for (int i = 0; i <= formatString.Length; i++)
			{
				if (i == formatString.Length || flag != CharUtil.IsAlphaNumeric(formatString[i]))
				{
					if (flag)
					{
						tokens.Add(TokenInfo.CreateFormat(formatString, num, i - num));
					}
					else
					{
						tokens.Add(TokenInfo.CreateSeparator(formatString, num, i - num));
					}
					num = i;
					flag = !flag;
				}
			}
		}

		public string FormatSequence(IList<XPathItem> val)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (val.Count == 1 && val[0].ValueType == typeof(double))
			{
				double valueAsDouble = val[0].ValueAsDouble;
				if (!(0.5 <= valueAsDouble) || !(valueAsDouble < double.PositiveInfinity))
				{
					return XPathConvert.DoubleToString(valueAsDouble);
				}
			}
			if (tokens == null)
			{
				for (int i = 0; i < val.Count; i++)
				{
					if (i > 0)
					{
						stringBuilder.Append('.');
					}
					FormatItem(stringBuilder, val[i], '1', 1);
				}
			}
			else
			{
				int num = tokens.Count;
				TokenInfo tokenInfo = tokens[0];
				TokenInfo tokenInfo2 = ((num % 2 != 0) ? tokens[--num] : null);
				TokenInfo tokenInfo3 = ((2 < num) ? tokens[num - 2] : DefaultSeparator);
				TokenInfo tokenInfo4 = ((0 < num) ? tokens[num - 1] : DefaultFormat);
				if (tokenInfo != null)
				{
					stringBuilder.Append(tokenInfo.formatString, tokenInfo.startIdx, tokenInfo.length);
				}
				int count = val.Count;
				for (int j = 0; j < count; j++)
				{
					int num2 = j * 2;
					bool flag = num2 < num;
					if (j > 0)
					{
						TokenInfo tokenInfo5 = (flag ? tokens[num2] : tokenInfo3);
						stringBuilder.Append(tokenInfo5.formatString, tokenInfo5.startIdx, tokenInfo5.length);
					}
					TokenInfo tokenInfo6 = (flag ? tokens[num2 + 1] : tokenInfo4);
					FormatItem(stringBuilder, val[j], tokenInfo6.startChar, tokenInfo6.length);
				}
				if (tokenInfo2 != null)
				{
					stringBuilder.Append(tokenInfo2.formatString, tokenInfo2.startIdx, tokenInfo2.length);
				}
			}
			return stringBuilder.ToString();
		}

		private void FormatItem(StringBuilder sb, XPathItem item, char startChar, int length)
		{
			double num = ((!(item.ValueType == typeof(int))) ? XsltFunctions.Round(item.ValueAsDouble) : ((double)item.ValueAsInt));
			char zero = '0';
			switch (startChar)
			{
			case 'A':
			case 'a':
				if (num <= 2147483647.0)
				{
					NumberFormatterBase.ConvertToAlphabetic(sb, num, startChar, 26);
					return;
				}
				break;
			case 'I':
			case 'i':
				if (num <= 32767.0)
				{
					NumberFormatterBase.ConvertToRoman(sb, num, startChar == 'I');
					return;
				}
				break;
			default:
				zero = (char)(startChar - 1);
				break;
			case '1':
				break;
			}
			sb.Append(ConvertToDecimal(num, length, zero, groupingSeparator, groupingSize));
		}

		private unsafe static string ConvertToDecimal(double val, int minLen, char zero, string groupSeparator, int groupSize)
		{
			string text = XPathConvert.DoubleToString(val);
			int num = zero - 48;
			int length = text.Length;
			int num2 = Math.Max(length, minLen);
			char* ptr;
			char c;
			checked
			{
				if (groupSize != 0)
				{
					num2 += unchecked(checked(num2 - 1) / groupSize);
				}
				if (num2 == length && num == 0)
				{
					return text;
				}
				if (groupSize == 0 && num == 0)
				{
					return text.PadLeft(num2, zero);
				}
				ptr = stackalloc char[num2];
				c = ((groupSeparator.Length > 0) ? groupSeparator[0] : ' ');
			}
			fixed (char* ptr2 = text)
			{
				char* ptr3 = ptr2 + length - 1;
				char* ptr4 = ptr + num2 - 1;
				int num3 = groupSize;
				while (true)
				{
					char* intPtr = ptr4;
					ptr4 = intPtr - 1;
					int num4;
					if (ptr3 < ptr2)
					{
						num4 = zero;
					}
					else
					{
						char* intPtr2 = ptr3;
						ptr3 = intPtr2 - 1;
						num4 = (ushort)(*intPtr2 + num);
					}
					*intPtr = (char)num4;
					if (ptr4 < ptr)
					{
						break;
					}
					if (--num3 == 0)
					{
						char* intPtr3 = ptr4;
						ptr4 = intPtr3 - 1;
						*intPtr3 = c;
						num3 = groupSize;
					}
				}
			}
			return new string(ptr, 0, num2);
		}
	}
	/// <summary>Contains conversion routines used by XSLT.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static class XsltConvert
	{
		internal static readonly Type BooleanType = typeof(bool);

		internal static readonly Type ByteArrayType = typeof(byte[]);

		internal static readonly Type ByteType = typeof(byte);

		internal static readonly Type DateTimeType = typeof(DateTime);

		internal static readonly Type DecimalType = typeof(decimal);

		internal static readonly Type DoubleType = typeof(double);

		internal static readonly Type ICollectionType = typeof(ICollection);

		internal static readonly Type IEnumerableType = typeof(IEnumerable);

		internal static readonly Type IListType = typeof(IList);

		internal static readonly Type Int16Type = typeof(short);

		internal static readonly Type Int32Type = typeof(int);

		internal static readonly Type Int64Type = typeof(long);

		internal static readonly Type IXPathNavigableType = typeof(IXPathNavigable);

		internal static readonly Type ObjectType = typeof(object);

		internal static readonly Type SByteType = typeof(sbyte);

		internal static readonly Type SingleType = typeof(float);

		internal static readonly Type StringType = typeof(string);

		internal static readonly Type TimeSpanType = typeof(TimeSpan);

		internal static readonly Type UInt16Type = typeof(ushort);

		internal static readonly Type UInt32Type = typeof(uint);

		internal static readonly Type UInt64Type = typeof(ulong);

		internal static readonly Type UriType = typeof(Uri);

		internal static readonly Type VoidType = typeof(void);

		internal static readonly Type XmlAtomicValueType = typeof(XmlAtomicValue);

		internal static readonly Type XmlQualifiedNameType = typeof(XmlQualifiedName);

		internal static readonly Type XPathItemType = typeof(XPathItem);

		internal static readonly Type XPathNavigatorArrayType = typeof(XPathNavigator[]);

		internal static readonly Type XPathNavigatorType = typeof(XPathNavigator);

		internal static readonly Type XPathNodeIteratorType = typeof(XPathNodeIterator);

		/// <summary>Converts the specified value to Boolean.</summary>
		/// <param name="item">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <returns>A value of type <see langword="bool" />.</returns>
		public static bool ToBoolean(XPathItem item)
		{
			if (item.IsNode)
			{
				return true;
			}
			Type valueType = item.ValueType;
			if (valueType == StringType)
			{
				return item.Value.Length != 0;
			}
			if (valueType == DoubleType)
			{
				double valueAsDouble = item.ValueAsDouble;
				if (!(valueAsDouble < 0.0))
				{
					return 0.0 < valueAsDouble;
				}
				return true;
			}
			return item.ValueAsBoolean;
		}

		/// <summary>Converts a specified value to Boolean.</summary>
		/// <param name="listItems">A sequence of <see cref="T:System.Xml.XPath.XPathItem" /> instances.</param>
		/// <returns>A value of type <see langword="bool" />.</returns>
		public static bool ToBoolean(IList<XPathItem> listItems)
		{
			if (listItems.Count == 0)
			{
				return false;
			}
			return ToBoolean(listItems[0]);
		}

		/// <summary>Converts a specified value to <see langword="double" />.</summary>
		/// <param name="value">A value of type <see langword="string" />.</param>
		/// <returns>A value of type <see langword="double" />.</returns>
		public static double ToDouble(string value)
		{
			return XPathConvert.StringToDouble(value);
		}

		/// <summary>Converts a specified value to <see langword="double" />.</summary>
		/// <param name="item">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <returns>A value of type <see langword="double" />.</returns>
		public static double ToDouble(XPathItem item)
		{
			if (item.IsNode)
			{
				return XPathConvert.StringToDouble(item.Value);
			}
			Type valueType = item.ValueType;
			if (valueType == StringType)
			{
				return XPathConvert.StringToDouble(item.Value);
			}
			if (valueType == DoubleType)
			{
				return item.ValueAsDouble;
			}
			if (!item.ValueAsBoolean)
			{
				return 0.0;
			}
			return 1.0;
		}

		/// <summary>Converts a specified value to <see langword="double" />.</summary>
		/// <param name="listItems">A sequence of <see cref="T:System.Xml.XPath.XPathItem" /> instances.</param>
		/// <returns>A value of type <see langword="double" />.</returns>
		public static double ToDouble(IList<XPathItem> listItems)
		{
			if (listItems.Count == 0)
			{
				return double.NaN;
			}
			return ToDouble(listItems[0]);
		}

		/// <summary>Converts the specified value to a node.</summary>
		/// <param name="item">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</returns>
		public static XPathNavigator ToNode(XPathItem item)
		{
			if (!item.IsNode)
			{
				XPathDocument xPathDocument = new XPathDocument();
				XmlRawWriter xmlRawWriter = xPathDocument.LoadFromWriter(XPathDocument.LoadFlags.AtomizeNames, string.Empty);
				xmlRawWriter.WriteString(ToString(item));
				xmlRawWriter.Close();
				return xPathDocument.CreateNavigator();
			}
			if (item is RtfNavigator rtfNavigator)
			{
				return rtfNavigator.ToNavigator();
			}
			return (XPathNavigator)item;
		}

		/// <summary>Converts a specified value to a node.</summary>
		/// <param name="listItems">A sequence of <see cref="T:System.Xml.XPath.XPathItem" /> instances.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.XPath.XPathNavigator" /> class.</returns>
		public static XPathNavigator ToNode(IList<XPathItem> listItems)
		{
			if (listItems.Count == 1)
			{
				return ToNode(listItems[0]);
			}
			throw new XslTransformException("Xslt_NodeSetNotNode", string.Empty);
		}

		/// <summary>Converts the specified value to a node.</summary>
		/// <param name="item">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <returns>An instance of the <see cref="T:System.Xml.Xsl.Runtime.XmlQuerySequence`1" /> class.</returns>
		public static IList<XPathNavigator> ToNodeSet(XPathItem item)
		{
			return new XmlQueryNodeSequence(ToNode(item));
		}

		/// <summary>Converts the items to a sequence of nodes.</summary>
		/// <param name="listItems">A sequence of <see cref="T:System.Xml.XPath.XPathItem" /> instances.</param>
		/// <returns>A sequence of <see cref="T:System.Xml.XPath.XPathNavigator" /> instances.</returns>
		public static IList<XPathNavigator> ToNodeSet(IList<XPathItem> listItems)
		{
			if (listItems.Count == 1)
			{
				return new XmlQueryNodeSequence(ToNode(listItems[0]));
			}
			return XmlILStorageConverter.ItemsToNavigators(listItems);
		}

		/// <summary>Converts the specified value to a string.</summary>
		/// <param name="value">A value of type <see langword="double" />.</param>
		/// <returns>A value of type <see langword="string" />.</returns>
		public static string ToString(double value)
		{
			return XPathConvert.DoubleToString(value);
		}

		/// <summary>Converts the specified value to a string.</summary>
		/// <param name="item">An instance of the <see cref="T:System.Xml.XPath.XPathItem" /> class.</param>
		/// <returns>A value of type <see langword="string" />.</returns>
		public static string ToString(XPathItem item)
		{
			if (!item.IsNode && item.ValueType == DoubleType)
			{
				return XPathConvert.DoubleToString(item.ValueAsDouble);
			}
			return item.Value;
		}

		/// <summary>Converts the items to a string.</summary>
		/// <param name="listItems">A sequence of <see cref="T:System.Xml.XPath.XPathItem" /> instances.</param>
		/// <returns>A value of type <see langword="string" />.</returns>
		public static string ToString(IList<XPathItem> listItems)
		{
			if (listItems.Count == 0)
			{
				return string.Empty;
			}
			return ToString(listItems[0]);
		}

		/// <summary>Converts the specified value to a string.</summary>
		/// <param name="value">A value of type <see langword="DateTime" />.</param>
		/// <returns>A value of type <see langword="string" />.</returns>
		public static string ToString(DateTime value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.DateTime).ToString();
		}

		/// <summary>Converts the specified value to <see langword="double" />.</summary>
		/// <param name="value">A value of type <see langword="decimal" />.</param>
		/// <returns>A value of type <see langword="double" />.</returns>
		public static double ToDouble(decimal value)
		{
			return (double)value;
		}

		/// <summary>Converts the specified value to <see langword="double" />.</summary>
		/// <param name="value">A value of type <see langword="int" />.</param>
		/// <returns>A value of type <see langword="double" />.</returns>
		public static double ToDouble(int value)
		{
			return value;
		}

		/// <summary>Converts the specified value to <see langword="double" />.</summary>
		/// <param name="value">A value of type <see langword="Int64" />.</param>
		/// <returns>A value of type <see langword="double" />.</returns>
		public static double ToDouble(long value)
		{
			return value;
		}

		/// <summary>Converts a specified value to <see langword="decimal" />.</summary>
		/// <param name="value">A value of type <see langword="double" />.</param>
		/// <returns>A value of type <see langword="decimal" />.</returns>
		public static decimal ToDecimal(double value)
		{
			return (decimal)value;
		}

		/// <summary>Converts the specified value to <see langword="int" />.</summary>
		/// <param name="value">A value of type <see langword="double" />.</param>
		/// <returns>A value of type <see langword="int" />.</returns>
		public static int ToInt(double value)
		{
			return checked((int)value);
		}

		/// <summary>Converts the specified value to <see langword="long" />.</summary>
		/// <param name="value">A value of type <see langword="double" />.</param>
		/// <returns>A value of type <see langword="long" />.</returns>
		public static long ToLong(double value)
		{
			return checked((long)value);
		}

		/// <summary>Converts a specified value to a <see langword="DateTime" /> value.</summary>
		/// <param name="value">A <see langword="string" /> value.</param>
		/// <returns>A value of type <see langword="DateTime" />.</returns>
		public static DateTime ToDateTime(string value)
		{
			return new XsdDateTime(value, XsdDateTimeFlags.AllXsd);
		}

		internal static XmlAtomicValue ConvertToType(XmlAtomicValue value, XmlQueryType destinationType)
		{
			switch (destinationType.TypeCode)
			{
			case XmlTypeCode.Boolean:
			{
				XmlTypeCode typeCode = value.XmlType.TypeCode;
				if ((uint)(typeCode - 12) <= 1u || typeCode == XmlTypeCode.Double)
				{
					return new XmlAtomicValue(destinationType.SchemaType, ToBoolean(value));
				}
				break;
			}
			case XmlTypeCode.DateTime:
				if (value.XmlType.TypeCode == XmlTypeCode.String)
				{
					return new XmlAtomicValue(destinationType.SchemaType, ToDateTime(value.Value));
				}
				break;
			case XmlTypeCode.Decimal:
				if (value.XmlType.TypeCode == XmlTypeCode.Double)
				{
					return new XmlAtomicValue(destinationType.SchemaType, ToDecimal(value.ValueAsDouble));
				}
				break;
			case XmlTypeCode.Double:
				switch (value.XmlType.TypeCode)
				{
				case XmlTypeCode.String:
				case XmlTypeCode.Boolean:
				case XmlTypeCode.Double:
					return new XmlAtomicValue(destinationType.SchemaType, ToDouble(value));
				case XmlTypeCode.Decimal:
					return new XmlAtomicValue(destinationType.SchemaType, ToDouble((decimal)value.ValueAs(DecimalType, null)));
				case XmlTypeCode.Long:
				case XmlTypeCode.Int:
					return new XmlAtomicValue(destinationType.SchemaType, ToDouble(value.ValueAsLong));
				}
				break;
			case XmlTypeCode.Long:
			case XmlTypeCode.Int:
				if (value.XmlType.TypeCode == XmlTypeCode.Double)
				{
					return new XmlAtomicValue(destinationType.SchemaType, ToLong(value.ValueAsDouble));
				}
				break;
			case XmlTypeCode.String:
				switch (value.XmlType.TypeCode)
				{
				case XmlTypeCode.String:
				case XmlTypeCode.Boolean:
				case XmlTypeCode.Double:
					return new XmlAtomicValue(destinationType.SchemaType, ToString(value));
				case XmlTypeCode.DateTime:
					return new XmlAtomicValue(destinationType.SchemaType, ToString(value.ValueAsDateTime));
				}
				break;
			}
			return value;
		}

		/// <summary>Ensures that the specified sequence of objects is not a result tree fragment and that it can be converted to a node set.</summary>
		/// <param name="listItems">A sequence of <see cref="T:System.Xml.XPath.XPathItem" /> instances.</param>
		/// <returns>A sequence of <see cref="T:System.Xml.XPath.XPathNavigator" /> instances.</returns>
		public static IList<XPathNavigator> EnsureNodeSet(IList<XPathItem> listItems)
		{
			if (listItems.Count == 1)
			{
				XPathItem xPathItem = listItems[0];
				if (!xPathItem.IsNode)
				{
					throw new XslTransformException("XPath_NodeSetExpected", string.Empty);
				}
				if (xPathItem is RtfNavigator)
				{
					throw new XslTransformException("XPath_RtfInPathExpr", string.Empty);
				}
			}
			return XmlILStorageConverter.ItemsToNavigators(listItems);
		}

		internal static XmlQueryType InferXsltType(Type clrType)
		{
			if (clrType == BooleanType)
			{
				return XmlQueryTypeFactory.BooleanX;
			}
			if (clrType == ByteType)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == DecimalType)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == DateTimeType)
			{
				return XmlQueryTypeFactory.StringX;
			}
			if (clrType == DoubleType)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == Int16Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == Int32Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == Int64Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == IXPathNavigableType)
			{
				return XmlQueryTypeFactory.NodeNotRtf;
			}
			if (clrType == SByteType)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == SingleType)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == StringType)
			{
				return XmlQueryTypeFactory.StringX;
			}
			if (clrType == UInt16Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == UInt32Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == UInt64Type)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == XPathNavigatorArrayType)
			{
				return XmlQueryTypeFactory.NodeSDod;
			}
			if (clrType == XPathNavigatorType)
			{
				return XmlQueryTypeFactory.NodeNotRtf;
			}
			if (clrType == XPathNodeIteratorType)
			{
				return XmlQueryTypeFactory.NodeSDod;
			}
			if (clrType.IsEnum)
			{
				return XmlQueryTypeFactory.DoubleX;
			}
			if (clrType == VoidType)
			{
				return XmlQueryTypeFactory.Empty;
			}
			return XmlQueryTypeFactory.ItemS;
		}
	}
	/// <summary>XSLT and XPath functions.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static class XsltFunctions
	{
		private struct SystemTime
		{
			[MarshalAs(UnmanagedType.U2)]
			public ushort Year;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Month;

			[MarshalAs(UnmanagedType.U2)]
			public ushort DayOfWeek;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Day;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Hour;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Minute;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Second;

			[MarshalAs(UnmanagedType.U2)]
			public ushort Milliseconds;

			public SystemTime(DateTime dateTime)
			{
				Year = (ushort)dateTime.Year;
				Month = (ushort)dateTime.Month;
				DayOfWeek = (ushort)dateTime.DayOfWeek;
				Day = (ushort)dateTime.Day;
				Hour = (ushort)dateTime.Hour;
				Minute = (ushort)dateTime.Minute;
				Second = (ushort)dateTime.Second;
				Milliseconds = (ushort)dateTime.Millisecond;
			}
		}

		private static readonly CompareInfo compareInfo = CultureInfo.InvariantCulture.CompareInfo;

		/// <summary>Implements <see langword="starts-with" /> XPath function according to the W3C specification.</summary>
		/// <param name="s1">A string, the beginning of which is compared to <paramref name="s2" />.</param>
		/// <param name="s2">The string to compare to the beginning of <paramref name="s1" />.</param>
		/// <returns>
		///   <see langword="true" /> if the first argument string starts with the second argument string; otherwise, <see langword="false" />.</returns>
		public static bool StartsWith(string s1, string s2)
		{
			if (s1.Length >= s2.Length)
			{
				return string.CompareOrdinal(s1, 0, s2, 0, s2.Length) == 0;
			}
			return false;
		}

		/// <summary>Implements <see langword="contains" /> XPath function according to the W3C specification.</summary>
		/// <param name="s1">The string in which to locate <paramref name="s2" />.</param>
		/// <param name="s2">The string to locate in s1.</param>
		/// <returns>
		///   <see langword="true" /> if the first argument string contains the second argument string; otherwise, <see langword="false" />.</returns>
		public static bool Contains(string s1, string s2)
		{
			return compareInfo.IndexOf(s1, s2, CompareOptions.Ordinal) >= 0;
		}

		/// <summary>Implements <see langword="substring-before" /> XPath function according to the W3C specification.</summary>
		/// <param name="s1">The string in which to locate s2.</param>
		/// <param name="s2">The string to locate in <paramref name="s1" />.</param>
		/// <returns>The characters in s1 that occur before s2, or the empty string if s1 does not contain s2.</returns>
		public static string SubstringBefore(string s1, string s2)
		{
			if (s2.Length == 0)
			{
				return s2;
			}
			int num = compareInfo.IndexOf(s1, s2, CompareOptions.Ordinal);
			if (num >= 1)
			{
				return s1.Substring(0, num);
			}
			return string.Empty;
		}

		/// <summary>Implements <see langword="substring-after" /> XPath function according to the W3C specification.</summary>
		/// <param name="s1">The string in which to locate s2.</param>
		/// <param name="s2">The string to locate in <paramref name="s1" />.</param>
		/// <returns>The characters in s1 that occur after s2, or the empty string if s1 does not contain s2.</returns>
		public static string SubstringAfter(string s1, string s2)
		{
			if (s2.Length == 0)
			{
				return s1;
			}
			int num = compareInfo.IndexOf(s1, s2, CompareOptions.Ordinal);
			if (num >= 0)
			{
				return s1.Substring(num + s2.Length);
			}
			return string.Empty;
		}

		/// <summary>Implements <see langword="substring" /> XPath function according to the W3C specification.</summary>
		/// <param name="value">The string from which to retrieve the substring.</param>
		/// <param name="startIndex">The starting character position of a substring in <paramref name="value" />.</param>
		/// <returns>The substring of the first argument starting at the position specified in the second argument</returns>
		public static string Substring(string value, double startIndex)
		{
			startIndex = Round(startIndex);
			if (startIndex <= 0.0)
			{
				return value;
			}
			if (startIndex <= (double)value.Length)
			{
				return value.Substring((int)startIndex - 1);
			}
			return string.Empty;
		}

		/// <summary>Implements <see langword="substring" /> XPath function according to the W3C specification.</summary>
		/// <param name="value">The string from which to retrieve the substring.</param>
		/// <param name="startIndex">The starting character position of a substring in <paramref name="value" />.</param>
		/// <param name="length">The number of characters in the substring.</param>
		/// <returns>The substring of the first argument, starting at the position specified in the second argument, with the length specified in the third argument.</returns>
		public static string Substring(string value, double startIndex, double length)
		{
			startIndex = Round(startIndex) - 1.0;
			if (startIndex >= (double)value.Length)
			{
				return string.Empty;
			}
			double num = startIndex + Round(length);
			startIndex = ((startIndex <= 0.0) ? 0.0 : startIndex);
			if (startIndex < num)
			{
				if (num > (double)value.Length)
				{
					num = value.Length;
				}
				return value.Substring((int)startIndex, (int)(num - startIndex));
			}
			return string.Empty;
		}

		/// <summary>Removes leading and trailing spaces from the specified string and returns the result. Implements <see langword="normalize-space" /> function from the W3C XPath standard.</summary>
		/// <param name="value">The specified string.</param>
		/// <returns>A normalized string.</returns>
		public static string NormalizeSpace(string value)
		{
			XmlCharType instance = XmlCharType.Instance;
			StringBuilder stringBuilder = null;
			int num = 0;
			int num2 = 0;
			int i;
			for (i = 0; i < value.Length; i++)
			{
				if (!instance.IsWhiteSpace(value[i]))
				{
					continue;
				}
				if (i == num)
				{
					num++;
				}
				else if (value[i] != ' ' || num2 == i)
				{
					if (stringBuilder == null)
					{
						stringBuilder = new StringBuilder(value.Length);
					}
					else
					{
						stringBuilder.Append(' ');
					}
					if (num2 == i)
					{
						stringBuilder.Append(value, num, i - num - 1);
					}
					else
					{
						stringBuilder.Append(value, num, i - num);
					}
					num = i + 1;
				}
				else
				{
					num2 = i + 1;
				}
			}
			if (stringBuilder == null)
			{
				if (num == i)
				{
					return string.Empty;
				}
				if (num == 0 && num2 != i)
				{
					return value;
				}
				stringBuilder = new StringBuilder(value.Length);
			}
			else if (i != num)
			{
				stringBuilder.Append(' ');
			}
			if (num2 == i)
			{
				stringBuilder.Append(value, num, i - num - 1);
			}
			else
			{
				stringBuilder.Append(value, num, i - num);
			}
			return stringBuilder.ToString();
		}

		/// <summary>Implements <see langword="translate" /> XPath function according to the W3C specification.</summary>
		/// <param name="arg">The original string.</param>
		/// <param name="mapString">The substring in <paramref name="arg" /> that should be replaced with <paramref name="transString" />.</param>
		/// <param name="transString">The string to replace <paramref name="mapString" /> with.</param>
		/// <returns>The translated value as <see cref="T:System.String" />.</returns>
		public static string Translate(string arg, string mapString, string transString)
		{
			if (mapString.Length == 0)
			{
				return arg;
			}
			StringBuilder stringBuilder = new StringBuilder(arg.Length);
			for (int i = 0; i < arg.Length; i++)
			{
				int num = mapString.IndexOf(arg[i]);
				if (num < 0)
				{
					stringBuilder.Append(arg[i]);
				}
				else if (num < transString.Length)
				{
					stringBuilder.Append(transString[num]);
				}
			}
			return stringBuilder.ToString();
		}

		/// <summary>Implements the <see langword="lang" /> function according to the W3C XPath specification.</summary>
		/// <param name="value">The specified string.</param>
		/// <param name="context">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object that contains context.</param>
		/// <returns>
		///   <see cref="T:System.Boolean" />.</returns>
		public static bool Lang(string value, XPathNavigator context)
		{
			string xmlLang = context.XmlLang;
			if (!xmlLang.StartsWith(value, StringComparison.OrdinalIgnoreCase))
			{
				return false;
			}
			if (xmlLang.Length != value.Length)
			{
				return xmlLang[value.Length] == '-';
			}
			return true;
		}

		/// <summary>Rounds value by using XPath rounding rules. Rounds towards positive infinity. Values between -0.5 and -0.0 are rounded to -0.0 (negative zero).</summary>
		/// <param name="value">
		///   <see cref="T:System.Double" /> number to round.</param>
		/// <returns>The rounded number as <see cref="T:System.Double" />.</returns>
		public static double Round(double value)
		{
			double num = Math.Round(value);
			if (value - num != 0.5)
			{
				return num;
			}
			return num + 1.0;
		}

		/// <summary>Implements <see langword="system-property" /> XSLT function according to the W3C specification.</summary>
		/// <param name="name">The name of the system property.</param>
		/// <returns>The value of the system property specified by the <paramref name="name" />.</returns>
		public static XPathItem SystemProperty(XmlQualifiedName name)
		{
			if (name.Namespace == "http://www.w3.org/1999/XSL/Transform")
			{
				switch (name.Name)
				{
				case "version":
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Double), 1.0);
				case "vendor":
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), "Microsoft");
				case "vendor-url":
					return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), "http://www.microsoft.com");
				}
			}
			else if (name.Namespace == "urn:schemas-microsoft-com:xslt" && name.Name == "version")
			{
				return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), typeof(XsltLibrary).Assembly.ImageRuntimeVersion);
			}
			return new XmlAtomicValue(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), string.Empty);
		}

		/// <summary>Returns the value of the base URI of the node of the node passed in by the <paramref name="navigator" /> parameter. Implements <see langword="baseUri" /> XPath function according to the W3C specification.</summary>
		/// <param name="navigator">The <see cref="T:System.Xml.XPath.XPathNavigator" /> instance that contains the node to be identified by URI.</param>
		/// <returns>The base URI as <see cref="T:System.String" />.</returns>
		public static string BaseUri(XPathNavigator navigator)
		{
			return navigator.BaseURI;
		}

		/// <summary>Gets the markup representing the opening and closing tags of the node and all child nodes of the node identified by the <see cref="T:System.Xml.XPath.XPathNavigator" /> argument.</summary>
		/// <param name="navigator">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> that identifies the node.</param>
		/// <returns>A string that contains the opening and closing tags of the node and all child nodes of the node that is identified by the <paramref name="navigator" /> parameter.</returns>
		public static string OuterXml(XPathNavigator navigator)
		{
			if (!(navigator is RtfNavigator rtfNavigator))
			{
				return navigator.OuterXml;
			}
			StringBuilder stringBuilder = new StringBuilder();
			XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
			xmlWriterSettings.OmitXmlDeclaration = true;
			xmlWriterSettings.ConformanceLevel = ConformanceLevel.Fragment;
			xmlWriterSettings.CheckCharacters = false;
			XmlWriter xmlWriter = XmlWriter.Create(stringBuilder, xmlWriterSettings);
			rtfNavigator.CopyToWriter(xmlWriter);
			xmlWriter.Close();
			return stringBuilder.ToString();
		}

		/// <summary>Implements exsl:object-type.</summary>
		/// <param name="value">The <see cref="T:System.Xml.XPath.XPathItem" /> of which to determine type.</param>
		/// <returns>Object type as <see cref="T:System.String" />.</returns>
		public static string EXslObjectType(IList<XPathItem> value)
		{
			if (value.Count != 1)
			{
				return "node-set";
			}
			XPathItem xPathItem = value[0];
			if (xPathItem is RtfNavigator)
			{
				return "RTF";
			}
			if (xPathItem.IsNode)
			{
				return "node-set";
			}
			object typedValue = xPathItem.TypedValue;
			if (typedValue is string)
			{
				return "string";
			}
			if (typedValue is double)
			{
				return "number";
			}
			if (typedValue is bool)
			{
				return "boolean";
			}
			return "external";
		}

		/// <summary>Implements <see langword="ms:number" />Microsoft XPath extension function.</summary>
		/// <param name="value">
		///   <see cref="T:System.Collections.Generic.List`1" /> of <see cref="T:System.Xml.XPath.XPathItem" />.</param>
		/// <returns>
		///   <see cref="T:System.Double" />.</returns>
		public static double MSNumber(IList<XPathItem> value)
		{
			if (value.Count == 0)
			{
				return double.NaN;
			}
			XPathItem xPathItem = value[0];
			string value2;
			if (xPathItem.IsNode)
			{
				value2 = xPathItem.Value;
			}
			else
			{
				Type valueType = xPathItem.ValueType;
				if (!(valueType == XsltConvert.StringType))
				{
					if (valueType == XsltConvert.DoubleType)
					{
						return xPathItem.ValueAsDouble;
					}
					if (!xPathItem.ValueAsBoolean)
					{
						return 0.0;
					}
					return 1.0;
				}
				value2 = xPathItem.Value;
			}
			if (XmlConvert.TryToDouble(value2, out var result) != null)
			{
				return double.NaN;
			}
			return result;
		}

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto)]
		private static extern int GetDateFormat(int locale, uint dwFlags, ref SystemTime sysTime, string format, StringBuilder sb, int sbSize);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto)]
		private static extern int GetTimeFormat(int locale, uint dwFlags, ref SystemTime sysTime, string format, StringBuilder sb, int sbSize);

		/// <summary>Implements the <see langword="ms:format-date" /> and <see langword="ms-format-time" />Microsoft XPath extension functions.</summary>
		/// <param name="dateTime">String that contains date/time data.</param>
		/// <param name="format">String that contains format.</param>
		/// <param name="lang">String that contains language.</param>
		/// <param name="isDate">Boolean value that indicates whether date/time contains a date.</param>
		/// <returns>String that contains formatted date and time.</returns>
		public static string MSFormatDateTime(string dateTime, string format, string lang, bool isDate)
		{
			try
			{
				int lCID = GetCultureInfo(lang).LCID;
				if (!XsdDateTime.TryParse(dateTime, XsdDateTimeFlags.AllXsd | XsdDateTimeFlags.XdrDateTime | XsdDateTimeFlags.XdrTimeNoTz, out var result))
				{
					return string.Empty;
				}
				SystemTime sysTime = new SystemTime(result.ToZulu());
				StringBuilder stringBuilder = new StringBuilder(format.Length + 16);
				if (format.Length == 0)
				{
					format = null;
				}
				if (isDate)
				{
					if (GetDateFormat(lCID, 0u, ref sysTime, format, stringBuilder, stringBuilder.Capacity) == 0)
					{
						int dateFormat = GetDateFormat(lCID, 0u, ref sysTime, format, stringBuilder, 0);
						if (dateFormat != 0)
						{
							stringBuilder = new StringBuilder(dateFormat);
							dateFormat = GetDateFormat(lCID, 0u, ref sysTime, format, stringBuilder, stringBuilder.Capacity);
						}
					}
				}
				else if (GetTimeFormat(lCID, 0u, ref sysTime, format, stringBuilder, stringBuilder.Capacity) == 0)
				{
					int timeFormat = GetTimeFormat(lCID, 0u, ref sysTime, format, stringBuilder, 0);
					if (timeFormat != 0)
					{
						stringBuilder = new StringBuilder(timeFormat);
						timeFormat = GetTimeFormat(lCID, 0u, ref sysTime, format, stringBuilder, stringBuilder.Capacity);
					}
				}
				return stringBuilder.ToString();
			}
			catch (ArgumentException)
			{
				return string.Empty;
			}
		}

		/// <summary>Implements <see langword="ms:string-compare" />Microsoft XPath extension function.</summary>
		/// <param name="s1">The first string to compare.</param>
		/// <param name="s2">The second string to compare.</param>
		/// <param name="lang">The language. Optional</param>
		/// <param name="options">Specifies whether the comparison is case-sensitive.</param>
		/// <returns>If <paramref name="s1" /> &lt; <paramref name="s2" /> the method returns -1. If <paramref name="s1" /> == <paramref name="s2" /> the method returns 0. If <paramref name="s1" /> &gt; <paramref name="s2" /> the method returns 1.</returns>
		public static double MSStringCompare(string s1, string s2, string lang, string options)
		{
			CultureInfo cultureInfo = GetCultureInfo(lang);
			CompareOptions compareOptions = CompareOptions.None;
			bool flag = false;
			for (int i = 0; i < options.Length; i++)
			{
				switch (options[i])
				{
				case 'i':
					compareOptions = CompareOptions.IgnoreCase | CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth;
					break;
				case 'u':
					flag = true;
					break;
				default:
					flag = true;
					compareOptions = CompareOptions.IgnoreCase;
					break;
				}
			}
			if (flag)
			{
				if (compareOptions != 0)
				{
					throw new XslTransformException("Xslt_InvalidCompareOption", options);
				}
				compareOptions = CompareOptions.IgnoreCase;
			}
			int num = cultureInfo.CompareInfo.Compare(s1, s2, compareOptions);
			if (flag && num == 0)
			{
				num = -cultureInfo.CompareInfo.Compare(s1, s2, CompareOptions.None);
			}
			return num;
		}

		/// <summary>Implements the <see langword="ms:utc" />Microsoft XPath extension function.</summary>
		/// <param name="dateTime">String that contains date/time data.</param>
		/// <returns>A string that contains date/time information. If a string cannot be interpreted as a valid XSD date/time-related format, it returns an empty string.</returns>
		public static string MSUtc(string dateTime)
		{
			XsdDateTime result;
			DateTime dt;
			try
			{
				if (!XsdDateTime.TryParse(dateTime, XsdDateTimeFlags.AllXsd | XsdDateTimeFlags.XdrDateTime | XsdDateTimeFlags.XdrTimeNoTz, out result))
				{
					return string.Empty;
				}
				dt = result.ToZulu();
			}
			catch (ArgumentException)
			{
				return string.Empty;
			}
			char[] array = "----------T00:00:00.000".ToCharArray();
			switch (result.TypeCode)
			{
			case XmlTypeCode.DateTime:
				PrintDate(array, dt);
				PrintTime(array, dt);
				break;
			case XmlTypeCode.Time:
				PrintTime(array, dt);
				break;
			case XmlTypeCode.Date:
				PrintDate(array, dt);
				break;
			case XmlTypeCode.GYearMonth:
				PrintYear(array, dt.Year);
				ShortToCharArray(array, 5, dt.Month);
				break;
			case XmlTypeCode.GYear:
				PrintYear(array, dt.Year);
				break;
			case XmlTypeCode.GMonthDay:
				ShortToCharArray(array, 5, dt.Month);
				ShortToCharArray(array, 8, dt.Day);
				break;
			case XmlTypeCode.GDay:
				ShortToCharArray(array, 8, dt.Day);
				break;
			case XmlTypeCode.GMonth:
				ShortToCharArray(array, 5, dt.Month);
				break;
			}
			return new string(array);
		}

		/// <summary>Implements the <see langword="ms:local-name" />Microsoft XPath extension function.</summary>
		/// <param name="name">The name.</param>
		/// <returns>Name as <see cref="T:System.String" />.</returns>
		public static string MSLocalName(string name)
		{
			int colonOffset;
			int num = ValidateNames.ParseQName(name, 0, out colonOffset);
			if (num != name.Length)
			{
				return string.Empty;
			}
			if (colonOffset == 0)
			{
				return name;
			}
			return name.Substring(colonOffset + 1);
		}

		/// <summary>Implements the <see langword="ms:namespace-uri" />Microsoft XPath extension function.</summary>
		/// <param name="name">The name.</param>
		/// <param name="currentNode">The <see cref="T:System.Xml.XPath.XPathNavigator" /> instance.</param>
		/// <returns>Namespace URI as <see cref="T:System.String" />.</returns>
		public static string MSNamespaceUri(string name, XPathNavigator currentNode)
		{
			int colonOffset;
			int num = ValidateNames.ParseQName(name, 0, out colonOffset);
			if (num != name.Length)
			{
				return string.Empty;
			}
			string text = name.Substring(0, colonOffset);
			if (text == "xmlns")
			{
				return string.Empty;
			}
			string text2 = currentNode.LookupNamespace(text);
			if (text2 != null)
			{
				return text2;
			}
			if (text == "xml")
			{
				return "http://www.w3.org/XML/1998/namespace";
			}
			return string.Empty;
		}

		private static CultureInfo GetCultureInfo(string lang)
		{
			if (lang.Length == 0)
			{
				return CultureInfo.CurrentCulture;
			}
			try
			{
				return new CultureInfo(lang);
			}
			catch (ArgumentException)
			{
				throw new XslTransformException("Xslt_InvalidLanguage", lang);
			}
		}

		private static void PrintDate(char[] text, DateTime dt)
		{
			PrintYear(text, dt.Year);
			ShortToCharArray(text, 5, dt.Month);
			ShortToCharArray(text, 8, dt.Day);
		}

		private static void PrintTime(char[] text, DateTime dt)
		{
			ShortToCharArray(text, 11, dt.Hour);
			ShortToCharArray(text, 14, dt.Minute);
			ShortToCharArray(text, 17, dt.Second);
			PrintMsec(text, dt.Millisecond);
		}

		private static void PrintYear(char[] text, int value)
		{
			text[0] = (char)(value / 1000 % 10 + 48);
			text[1] = (char)(value / 100 % 10 + 48);
			text[2] = (char)(value / 10 % 10 + 48);
			text[3] = (char)(value / 1 % 10 + 48);
		}

		private static void PrintMsec(char[] text, int value)
		{
			if (value != 0)
			{
				text[20] = (char)(value / 100 % 10 + 48);
				text[21] = (char)(value / 10 % 10 + 48);
				text[22] = (char)(value / 1 % 10 + 48);
			}
		}

		private static void ShortToCharArray(char[] text, int start, int value)
		{
			text[start] = (char)(value / 10 + 48);
			text[start + 1] = (char)(value % 10 + 48);
		}
	}
	internal static class XsltMethods
	{
		public static readonly MethodInfo FormatMessage = GetMethod(typeof(XsltLibrary), "FormatMessage");

		public static readonly MethodInfo EnsureNodeSet = GetMethod(typeof(XsltConvert), "EnsureNodeSet", typeof(IList<XPathItem>));

		public static readonly MethodInfo EqualityOperator = GetMethod(typeof(XsltLibrary), "EqualityOperator");

		public static readonly MethodInfo RelationalOperator = GetMethod(typeof(XsltLibrary), "RelationalOperator");

		public static readonly MethodInfo StartsWith = GetMethod(typeof(XsltFunctions), "StartsWith");

		public static readonly MethodInfo Contains = GetMethod(typeof(XsltFunctions), "Contains");

		public static readonly MethodInfo SubstringBefore = GetMethod(typeof(XsltFunctions), "SubstringBefore");

		public static readonly MethodInfo SubstringAfter = GetMethod(typeof(XsltFunctions), "SubstringAfter");

		public static readonly MethodInfo Substring2 = GetMethod(typeof(XsltFunctions), "Substring", typeof(string), typeof(double));

		public static readonly MethodInfo Substring3 = GetMethod(typeof(XsltFunctions), "Substring", typeof(string), typeof(double), typeof(double));

		public static readonly MethodInfo NormalizeSpace = GetMethod(typeof(XsltFunctions), "NormalizeSpace");

		public static readonly MethodInfo Translate = GetMethod(typeof(XsltFunctions), "Translate");

		public static readonly MethodInfo Lang = GetMethod(typeof(XsltFunctions), "Lang");

		public static readonly MethodInfo Floor = GetMethod(typeof(Math), "Floor", typeof(double));

		public static readonly MethodInfo Ceiling = GetMethod(typeof(Math), "Ceiling", typeof(double));

		public static readonly MethodInfo Round = GetMethod(typeof(XsltFunctions), "Round");

		public static readonly MethodInfo SystemProperty = GetMethod(typeof(XsltFunctions), "SystemProperty");

		public static readonly MethodInfo BaseUri = GetMethod(typeof(XsltFunctions), "BaseUri");

		public static readonly MethodInfo OuterXml = GetMethod(typeof(XsltFunctions), "OuterXml");

		public static readonly MethodInfo OnCurrentNodeChanged = GetMethod(typeof(XmlQueryRuntime), "OnCurrentNodeChanged");

		public static readonly MethodInfo MSFormatDateTime = GetMethod(typeof(XsltFunctions), "MSFormatDateTime");

		public static readonly MethodInfo MSStringCompare = GetMethod(typeof(XsltFunctions), "MSStringCompare");

		public static readonly MethodInfo MSUtc = GetMethod(typeof(XsltFunctions), "MSUtc");

		public static readonly MethodInfo MSNumber = GetMethod(typeof(XsltFunctions), "MSNumber");

		public static readonly MethodInfo MSLocalName = GetMethod(typeof(XsltFunctions), "MSLocalName");

		public static readonly MethodInfo MSNamespaceUri = GetMethod(typeof(XsltFunctions), "MSNamespaceUri");

		public static readonly MethodInfo EXslObjectType = GetMethod(typeof(XsltFunctions), "EXslObjectType");

		public static readonly MethodInfo CheckScriptNamespace = GetMethod(typeof(XsltLibrary), "CheckScriptNamespace");

		public static readonly MethodInfo FunctionAvailable = GetMethod(typeof(XsltLibrary), "FunctionAvailable");

		public static readonly MethodInfo ElementAvailable = GetMethod(typeof(XsltLibrary), "ElementAvailable");

		public static readonly MethodInfo RegisterDecimalFormat = GetMethod(typeof(XsltLibrary), "RegisterDecimalFormat");

		public static readonly MethodInfo RegisterDecimalFormatter = GetMethod(typeof(XsltLibrary), "RegisterDecimalFormatter");

		public static readonly MethodInfo FormatNumberStatic = GetMethod(typeof(XsltLibrary), "FormatNumberStatic");

		public static readonly MethodInfo FormatNumberDynamic = GetMethod(typeof(XsltLibrary), "FormatNumberDynamic");

		public static readonly MethodInfo IsSameNodeSort = GetMethod(typeof(XsltLibrary), "IsSameNodeSort");

		public static readonly MethodInfo LangToLcid = GetMethod(typeof(XsltLibrary), "LangToLcid");

		public static readonly MethodInfo NumberFormat = GetMethod(typeof(XsltLibrary), "NumberFormat");

		public static MethodInfo GetMethod(Type className, string methName)
		{
			return className.GetMethod(methName);
		}

		public static MethodInfo GetMethod(Type className, string methName, params Type[] args)
		{
			return className.GetMethod(methName, args);
		}
	}
	/// <summary>Implements different <see langword="XPath" /> and <see langword="XSLT" /> functions.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public sealed class XsltLibrary
	{
		internal enum ComparisonOperator
		{
			Eq,
			Ne,
			Lt,
			Le,
			Gt,
			Ge
		}

		private XmlQueryRuntime runtime;

		private HybridDictionary functionsAvail;

		private Dictionary<XmlQualifiedName, DecimalFormat> decimalFormats;

		private List<DecimalFormatter> decimalFormatters;

		internal const int InvariantCultureLcid = 127;

		internal XsltLibrary(XmlQueryRuntime runtime)
		{
			this.runtime = runtime;
		}

		/// <summary>Formats an exception message composed of a format string supplied by the <paramref name="res" /> parameter and arguments contained by the <paramref name="args" /> parameter.</summary>
		/// <param name="res">A string that contains the message resource.</param>
		/// <param name="args">A list of strings that represent arguments to the method.</param>
		/// <returns>A string that contains the formatted exception message.</returns>
		public string FormatMessage(string res, IList<string> args)
		{
			string[] array = new string[args.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = args[i];
			}
			return XslTransformException.CreateMessage(res, array);
		}

		/// <summary>Checks that the extension and script namespaces do not clash.</summary>
		/// <param name="nsUri">The namespace URI.</param>
		/// <returns>An integer used for internal infrastructure only.</returns>
		public int CheckScriptNamespace(string nsUri)
		{
			if (runtime.ExternalContext.GetLateBoundObject(nsUri) != null)
			{
				throw new XslTransformException("Xslt_ScriptAndExtensionClash", nsUri);
			}
			return 0;
		}

		/// <summary>Evaluates the argument to a string that is an XML qualified name. This method implements the <c>element-available</c> function specified by W3C XSL Transformations (XSLT).</summary>
		/// <param name="name">The XML qualified name.</param>
		/// <returns>
		///   <see langword="true" /> if the expanded name is the name of an instruction. If the <see langword="expanded name" /> has a namespace URI equal to the XSLT namespace URI, then it refers to an element defined by XSLT. Otherwise, the expanded-name refers to an extension element. If the <see langword="expanded name" /> has a null namespace URI, the element-available function will return <see langword="false" />.</returns>
		public bool ElementAvailable(XmlQualifiedName name)
		{
			return QilGenerator.IsElementAvailable(name);
		}

		/// <summary>Implements the function-available() XSLT function.</summary>
		/// <param name="name">
		///   <see cref="T:System.Xml.XmlQualifiedName" /> name object.</param>
		/// <returns>
		///   <see langword="true" /> if the function identified by <paramref name="name" /> is available; otherwise, <see langword="false" />.</returns>
		public bool FunctionAvailable(XmlQualifiedName name)
		{
			if (functionsAvail == null)
			{
				functionsAvail = new HybridDictionary();
			}
			else
			{
				object obj = functionsAvail[name];
				if (obj != null)
				{
					return (bool)obj;
				}
			}
			bool flag = FunctionAvailableHelper(name);
			functionsAvail[name] = flag;
			return flag;
		}

		private bool FunctionAvailableHelper(XmlQualifiedName name)
		{
			if (QilGenerator.IsFunctionAvailable(name.Name, name.Namespace))
			{
				return true;
			}
			if (name.Namespace.Length == 0 || name.Namespace == "http://www.w3.org/1999/XSL/Transform")
			{
				return false;
			}
			if (runtime.ExternalContext.LateBoundFunctionExists(name.Name, name.Namespace))
			{
				return true;
			}
			return runtime.EarlyBoundFunctionExists(name.Name, name.Namespace);
		}

		/// <summary>Registers a decimal-format with the given expanded name. For more information, see the number formatting section in the W3C Recommendation.</summary>
		/// <param name="name">
		///   <see cref="T:System.Xml.XmlQualifiedName" /> object that contains name.</param>
		/// <param name="infinitySymbol">String containing infinity symbol.</param>
		/// <param name="nanSymbol">String containing NaN symbol.</param>
		/// <param name="characters">String containing characters to format.</param>
		/// <returns>In the current implementation the return value is always 0.</returns>
		public int RegisterDecimalFormat(XmlQualifiedName name, string infinitySymbol, string nanSymbol, string characters)
		{
			if (decimalFormats == null)
			{
				decimalFormats = new Dictionary<XmlQualifiedName, DecimalFormat>();
			}
			decimalFormats.Add(name, CreateDecimalFormat(infinitySymbol, nanSymbol, characters));
			return 0;
		}

		private DecimalFormat CreateDecimalFormat(string infinitySymbol, string nanSymbol, string characters)
		{
			NumberFormatInfo numberFormatInfo = new NumberFormatInfo();
			numberFormatInfo.NumberDecimalSeparator = char.ToString(characters[0]);
			numberFormatInfo.NumberGroupSeparator = char.ToString(characters[1]);
			numberFormatInfo.PositiveInfinitySymbol = infinitySymbol;
			numberFormatInfo.NegativeSign = char.ToString(characters[7]);
			numberFormatInfo.NaNSymbol = nanSymbol;
			numberFormatInfo.PercentSymbol = char.ToString(characters[2]);
			numberFormatInfo.PerMilleSymbol = char.ToString(characters[3]);
			numberFormatInfo.NegativeInfinitySymbol = numberFormatInfo.NegativeSign + numberFormatInfo.PositiveInfinitySymbol;
			return new DecimalFormat(numberFormatInfo, characters[5], characters[4], characters[6]);
		}

		/// <summary>Registers a decimal formatter object and returns a unique index assigned to it. The decimal formatter object is used by the format-number() XSLT function. For more information, see the number formatting section in the W3C Recommendation.</summary>
		/// <param name="formatPicture">String that contains the format picture.</param>
		/// <param name="infinitySymbol">String that contains the infinity symbol.</param>
		/// <param name="nanSymbol">String that contains the NaN symbol.</param>
		/// <param name="characters">String that contains characters to format.</param>
		/// <returns>A unique index assigned to a decimal formatter object.</returns>
		public double RegisterDecimalFormatter(string formatPicture, string infinitySymbol, string nanSymbol, string characters)
		{
			if (decimalFormatters == null)
			{
				decimalFormatters = new List<DecimalFormatter>();
			}
			decimalFormatters.Add(new DecimalFormatter(formatPicture, CreateDecimalFormat(infinitySymbol, nanSymbol, characters)));
			return decimalFormatters.Count - 1;
		}

		/// <summary>Implements the format-number() XSLT function. For more information, see the number formatting section in the W3C Recommendation.</summary>
		/// <param name="value">The value to format.</param>
		/// <param name="decimalFormatterIndex">The formatter index.</param>
		/// <returns>A string that indicates the format. For more information, see the number formatting section in the W3C Recommendation.</returns>
		public string FormatNumberStatic(double value, double decimalFormatterIndex)
		{
			int index = (int)decimalFormatterIndex;
			return decimalFormatters[index].Format(value);
		}

		/// <summary>Implements the format-number() XSLT function. For more information, see the number formatting section in the W3C Recommendation.</summary>
		/// <param name="value">The value to format.</param>
		/// <param name="formatPicture">The format picture.</param>
		/// <param name="decimalFormatName">The format name.</param>
		/// <param name="errorMessageName">The error message name.</param>
		/// <returns>A string that indicates the number format. For more information, see the number formatting section in the W3C Recommendation.</returns>
		public string FormatNumberDynamic(double value, string formatPicture, XmlQualifiedName decimalFormatName, string errorMessageName)
		{
			if (decimalFormats == null || !decimalFormats.TryGetValue(decimalFormatName, out var value2))
			{
				throw new XslTransformException("Xslt_NoDecimalFormat", errorMessageName);
			}
			DecimalFormatter decimalFormatter = new DecimalFormatter(formatPicture, value2);
			return decimalFormatter.Format(value);
		}

		/// <summary>Gets a string that indicates the number format.</summary>
		/// <param name="value">
		///   <see cref="T:System.Collections.Generic.IList`1" /> of strings that represent arguments to the method.</param>
		/// <param name="formatString">The format string.</param>
		/// <param name="lang">The language.</param>
		/// <param name="letterValue">The letter value.</param>
		/// <param name="groupingSeparator">The grouping separator.</param>
		/// <param name="groupingSize">The grouping size.</param>
		/// <returns>A string that indicates the number format.</returns>
		public string NumberFormat(IList<XPathItem> value, string formatString, double lang, string letterValue, string groupingSeparator, double groupingSize)
		{
			NumberFormatter numberFormatter = new NumberFormatter(formatString, (int)lang, letterValue, groupingSeparator, (int)groupingSize);
			return numberFormatter.FormatSequence(value);
		}

		/// <summary>Converts the language identifier (as specified in the <see langword="xml:lang" /> attribute) to the culture identifier (LCID).</summary>
		/// <param name="lang">String that indicates language.</param>
		/// <param name="forwardCompatibility">
		///   <see langword="true" /> to indicate language is forward compatible; otherwise, <see langword="false" />.</param>
		/// <returns>A string that contains the culture identifier.</returns>
		public int LangToLcid(string lang, bool forwardCompatibility)
		{
			return LangToLcidInternal(lang, forwardCompatibility, null);
		}

		internal static int LangToLcidInternal(string lang, bool forwardCompatibility, IErrorHelper errorHelper)
		{
			int result = 127;
			if (lang != null)
			{
				if (lang.Length != 0)
				{
					try
					{
						result = new CultureInfo(lang).LCID;
						return result;
					}
					catch (ArgumentException)
					{
						if (!forwardCompatibility)
						{
							if (errorHelper != null)
							{
								errorHelper.ReportError("Xslt_InvalidLanguage", lang);
								return result;
							}
							throw new XslTransformException("Xslt_InvalidLanguage", lang);
						}
						return result;
					}
				}
				if (!forwardCompatibility)
				{
					if (errorHelper == null)
					{
						throw new XslTransformException("Xslt_InvalidAttrValue", "lang", lang);
					}
					errorHelper.ReportError("Xslt_InvalidAttrValue", "lang", lang);
				}
			}
			return result;
		}

		private static TypeCode GetTypeCode(XPathItem item)
		{
			Type valueType = item.ValueType;
			if (valueType == XsltConvert.StringType)
			{
				return TypeCode.String;
			}
			if (valueType == XsltConvert.DoubleType)
			{
				return TypeCode.Double;
			}
			return TypeCode.Boolean;
		}

		private static TypeCode WeakestTypeCode(TypeCode typeCode1, TypeCode typeCode2)
		{
			if (typeCode1 >= typeCode2)
			{
				return typeCode2;
			}
			return typeCode1;
		}

		private static bool CompareNumbers(ComparisonOperator op, double left, double right)
		{
			return op switch
			{
				ComparisonOperator.Eq => left == right, 
				ComparisonOperator.Ne => left != right, 
				ComparisonOperator.Lt => left < right, 
				ComparisonOperator.Le => left <= right, 
				ComparisonOperator.Gt => left > right, 
				_ => left >= right, 
			};
		}

		private static bool CompareValues(ComparisonOperator op, XPathItem left, XPathItem right, TypeCode compType)
		{
			return compType switch
			{
				TypeCode.Double => CompareNumbers(op, XsltConvert.ToDouble(left), XsltConvert.ToDouble(right)), 
				TypeCode.String => XsltConvert.ToString(left) == XsltConvert.ToString(right) == (op == ComparisonOperator.Eq), 
				_ => XsltConvert.ToBoolean(left) == XsltConvert.ToBoolean(right) == (op == ComparisonOperator.Eq), 
			};
		}

		private static bool CompareNodeSetAndValue(ComparisonOperator op, IList<XPathNavigator> nodeset, XPathItem val, TypeCode compType)
		{
			if (compType == TypeCode.Boolean)
			{
				return CompareNumbers(op, (nodeset.Count != 0) ? 1 : 0, XsltConvert.ToBoolean(val) ? 1 : 0);
			}
			int count = nodeset.Count;
			for (int i = 0; i < count; i++)
			{
				if (CompareValues(op, nodeset[i], val, compType))
				{
					return true;
				}
			}
			return false;
		}

		private static bool CompareNodeSetAndNodeSet(ComparisonOperator op, IList<XPathNavigator> left, IList<XPathNavigator> right, TypeCode compType)
		{
			int count = left.Count;
			int count2 = right.Count;
			for (int i = 0; i < count; i++)
			{
				for (int j = 0; j < count2; j++)
				{
					if (CompareValues(op, left[i], right[j], compType))
					{
						return true;
					}
				}
			}
			return false;
		}

		/// <summary>Determines equality between collections of type <see cref="T:System.Xml.XPath.XPathItem" />.</summary>
		/// <param name="opCode">The operation to be performed.</param>
		/// <param name="left">
		///   <see cref="T:System.Collections.Generic.IList`1" /> of type <see cref="T:System.Xml.XPath.XPathItem" />.</param>
		/// <param name="right">
		///   <see cref="T:System.Collections.Generic.IList`1" /> of type <see cref="T:System.Xml.XPath.XPathItem" />.</param>
		/// <returns>
		///   <see langword="true" /> if the collections are equal; otherwise, <see langword="false" />.</returns>
		public bool EqualityOperator(double opCode, IList<XPathItem> left, IList<XPathItem> right)
		{
			ComparisonOperator op = (ComparisonOperator)opCode;
			if (IsNodeSetOrRtf(left))
			{
				if (IsNodeSetOrRtf(right))
				{
					return CompareNodeSetAndNodeSet(op, ToNodeSetOrRtf(left), ToNodeSetOrRtf(right), TypeCode.String);
				}
				XPathItem xPathItem = right[0];
				return CompareNodeSetAndValue(op, ToNodeSetOrRtf(left), xPathItem, GetTypeCode(xPathItem));
			}
			if (IsNodeSetOrRtf(right))
			{
				XPathItem xPathItem2 = left[0];
				return CompareNodeSetAndValue(op, ToNodeSetOrRtf(right), xPathItem2, GetTypeCode(xPathItem2));
			}
			XPathItem xPathItem3 = left[0];
			XPathItem xPathItem4 = right[0];
			return CompareValues(op, xPathItem3, xPathItem4, WeakestTypeCode(GetTypeCode(xPathItem3), GetTypeCode(xPathItem4)));
		}

		private static ComparisonOperator InvertOperator(ComparisonOperator op)
		{
			return op switch
			{
				ComparisonOperator.Lt => ComparisonOperator.Gt, 
				ComparisonOperator.Le => ComparisonOperator.Ge, 
				ComparisonOperator.Gt => ComparisonOperator.Lt, 
				ComparisonOperator.Ge => ComparisonOperator.Le, 
				_ => op, 
			};
		}

		/// <summary>Evaluates whether the <paramref name="left" /> expression is greater than or equal to, or less than or equal to, the <paramref name="right" /> expression based on the <paramref name="opCode" /> passed.</summary>
		/// <param name="opCode">Specifies how to perform the evaluation of two expressions:  
		///  If opCode is equal to 2, evaluates the XPath expression "left &lt; right".  
		///  If opCode is equal to 3, evaluates the XPath expression "left &lt;= right".  
		///  If opCode is equal to 4, evaluates the XPath expression "left &gt; right".  
		///  If opCode is equal to 5, evaluates the XPath expression "left &gt;= right"</param>
		/// <param name="left">Expression to evaluate.</param>
		/// <param name="right">Expression to evaluate.</param>
		/// <returns>A Boolean value that is true if the left expression is greater than or equal to the right expression.</returns>
		public bool RelationalOperator(double opCode, IList<XPathItem> left, IList<XPathItem> right)
		{
			ComparisonOperator op = (ComparisonOperator)opCode;
			if (IsNodeSetOrRtf(left))
			{
				if (IsNodeSetOrRtf(right))
				{
					return CompareNodeSetAndNodeSet(op, ToNodeSetOrRtf(left), ToNodeSetOrRtf(right), TypeCode.Double);
				}
				XPathItem xPathItem = right[0];
				return CompareNodeSetAndValue(op, ToNodeSetOrRtf(left), xPathItem, WeakestTypeCode(GetTypeCode(xPathItem), TypeCode.Double));
			}
			if (IsNodeSetOrRtf(right))
			{
				XPathItem xPathItem2 = left[0];
				op = InvertOperator(op);
				return CompareNodeSetAndValue(op, ToNodeSetOrRtf(right), xPathItem2, WeakestTypeCode(GetTypeCode(xPathItem2), TypeCode.Double));
			}
			XPathItem left2 = left[0];
			XPathItem right2 = right[0];
			return CompareValues(op, left2, right2, TypeCode.Double);
		}

		/// <summary>Determines whether two nodes have the same node type and, if nodes of that node type have expanded-names, the same expanded names.</summary>
		/// <param name="nav1">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object to compare.</param>
		/// <param name="nav2">
		///   <see cref="T:System.Xml.XPath.XPathNavigator" /> object to compare.</param>
		/// <returns>A Boolean value that is <see langword="true" /> if two nodes have the same node type and, if nodes of that node type have expanded names, the same expanded names.</returns>
		public bool IsSameNodeSort(XPathNavigator nav1, XPathNavigator nav2)
		{
			XPathNodeType nodeType = nav1.NodeType;
			XPathNodeType nodeType2 = nav2.NodeType;
			if (XPathNodeType.Text <= nodeType && nodeType <= XPathNodeType.Whitespace)
			{
				if (XPathNodeType.Text <= nodeType2)
				{
					return nodeType2 <= XPathNodeType.Whitespace;
				}
				return false;
			}
			if (nodeType == nodeType2 && Ref.Equal(nav1.LocalName, nav2.LocalName))
			{
				return Ref.Equal(nav1.NamespaceURI, nav2.NamespaceURI);
			}
			return false;
		}

		[Conditional("DEBUG")]
		internal static void CheckXsltValue(XPathItem item)
		{
		}

		[Conditional("DEBUG")]
		internal static void CheckXsltValue(IList<XPathItem> val)
		{
			if (val.Count == 1)
			{
				XsltFunctions.EXslObjectType(val);
				return;
			}
			int count = val.Count;
			for (int i = 0; i < count && val[i].IsNode; i++)
			{
				if (i == 1)
				{
					i += Math.Max(count - 4, 0);
				}
			}
		}

		private static bool IsNodeSetOrRtf(IList<XPathItem> val)
		{
			if (val.Count == 1)
			{
				return val[0].IsNode;
			}
			return true;
		}

		private static IList<XPathNavigator> ToNodeSetOrRtf(IList<XPathItem> val)
		{
			return XmlILStorageConverter.ItemsToNavigators(val);
		}
	}
}
namespace System.Xml.Xsl.Qil
{
	internal class QilBinary : QilNode
	{
		private QilNode left;

		private QilNode right;

		public override int Count => 2;

		public override QilNode this[int index]
		{
			get
			{
				return index switch
				{
					0 => left, 
					1 => right, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					left = value;
					break;
				case 1:
					right = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public QilNode Left
		{
			get
			{
				return left;
			}
			set
			{
				left = value;
			}
		}

		public QilNode Right
		{
			get
			{
				return right;
			}
			set
			{
				right = value;
			}
		}

		public QilBinary(QilNodeType nodeType, QilNode left, QilNode right)
			: base(nodeType)
		{
			this.left = left;
			this.right = right;
		}
	}
	internal class QilChoice : QilBinary
	{
		public QilNode Expression
		{
			get
			{
				return base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilList Branches
		{
			get
			{
				return (QilList)base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilChoice(QilNodeType nodeType, QilNode expression, QilNode branches)
			: base(nodeType, expression, branches)
		{
		}
	}
	internal class QilCloneVisitor : QilScopedVisitor
	{
		private QilFactory fac;

		private SubstitutionList subs;

		public QilCloneVisitor(QilFactory fac)
			: this(fac, new SubstitutionList())
		{
		}

		public QilCloneVisitor(QilFactory fac, SubstitutionList subs)
		{
			this.fac = fac;
			this.subs = subs;
		}

		public QilNode Clone(QilNode node)
		{
			QilDepthChecker.Check(node);
			return VisitAssumeReference(node);
		}

		protected override QilNode Visit(QilNode oldNode)
		{
			QilNode qilNode = null;
			if (oldNode == null)
			{
				return null;
			}
			if (oldNode is QilReference)
			{
				qilNode = FindClonedReference(oldNode);
			}
			if (qilNode == null)
			{
				qilNode = oldNode.ShallowClone(fac);
			}
			return base.Visit(qilNode);
		}

		protected override QilNode VisitChildren(QilNode parent)
		{
			for (int i = 0; i < parent.Count; i++)
			{
				QilNode qilNode = parent[i];
				if (IsReference(parent, i))
				{
					parent[i] = VisitReference(qilNode);
					if (parent[i] == null)
					{
						parent[i] = qilNode;
					}
				}
				else
				{
					parent[i] = Visit(qilNode);
				}
			}
			return parent;
		}

		protected override QilNode VisitReference(QilNode oldNode)
		{
			QilNode qilNode = FindClonedReference(oldNode);
			return base.VisitReference((qilNode == null) ? oldNode : qilNode);
		}

		protected override void BeginScope(QilNode node)
		{
			subs.AddSubstitutionPair(node, node.ShallowClone(fac));
		}

		protected override void EndScope(QilNode node)
		{
			subs.RemoveLastSubstitutionPair();
		}

		protected QilNode FindClonedReference(QilNode node)
		{
			return subs.FindReplacement(node);
		}
	}
	internal class QilDataSource : QilBinary
	{
		public QilNode Name
		{
			get
			{
				return base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilNode BaseUri
		{
			get
			{
				return base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilDataSource(QilNodeType nodeType, QilNode name, QilNode baseUri)
			: base(nodeType, name, baseUri)
		{
		}
	}
	internal class QilExpression : QilNode
	{
		private QilFactory factory;

		private QilNode isDebug;

		private QilNode defWSet;

		private QilNode wsRules;

		private QilNode gloVars;

		private QilNode gloParams;

		private QilNode earlBnd;

		private QilNode funList;

		private QilNode rootNod;

		public override int Count => 8;

		public override QilNode this[int index]
		{
			get
			{
				return index switch
				{
					0 => isDebug, 
					1 => defWSet, 
					2 => wsRules, 
					3 => gloParams, 
					4 => gloVars, 
					5 => earlBnd, 
					6 => funList, 
					7 => rootNod, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					isDebug = value;
					break;
				case 1:
					defWSet = value;
					break;
				case 2:
					wsRules = value;
					break;
				case 3:
					gloParams = value;
					break;
				case 4:
					gloVars = value;
					break;
				case 5:
					earlBnd = value;
					break;
				case 6:
					funList = value;
					break;
				case 7:
					rootNod = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public QilFactory Factory
		{
			get
			{
				return factory;
			}
			set
			{
				factory = value;
			}
		}

		public bool IsDebug
		{
			get
			{
				return isDebug.NodeType == QilNodeType.True;
			}
			set
			{
				isDebug = (value ? factory.True() : factory.False());
			}
		}

		public XmlWriterSettings DefaultWriterSettings
		{
			get
			{
				return (XmlWriterSettings)((QilLiteral)defWSet).Value;
			}
			set
			{
				value.ReadOnly = true;
				((QilLiteral)defWSet).Value = value;
			}
		}

		public IList<WhitespaceRule> WhitespaceRules
		{
			get
			{
				return (IList<WhitespaceRule>)((QilLiteral)wsRules).Value;
			}
			set
			{
				((QilLiteral)wsRules).Value = value;
			}
		}

		public QilList GlobalParameterList
		{
			get
			{
				return (QilList)gloParams;
			}
			set
			{
				gloParams = value;
			}
		}

		public QilList GlobalVariableList
		{
			get
			{
				return (QilList)gloVars;
			}
			set
			{
				gloVars = value;
			}
		}

		public IList<EarlyBoundInfo> EarlyBoundTypes
		{
			get
			{
				return (IList<EarlyBoundInfo>)((QilLiteral)earlBnd).Value;
			}
			set
			{
				((QilLiteral)earlBnd).Value = value;
			}
		}

		public QilList FunctionList
		{
			get
			{
				return (QilList)funList;
			}
			set
			{
				funList = value;
			}
		}

		public QilNode Root
		{
			get
			{
				return rootNod;
			}
			set
			{
				rootNod = value;
			}
		}

		public QilExpression(QilNodeType nodeType, QilNode root)
			: this(nodeType, root, new QilFactory())
		{
		}

		public QilExpression(QilNodeType nodeType, QilNode root, QilFactory factory)
			: base(nodeType)
		{
			this.factory = factory;
			isDebug = factory.False();
			defWSet = factory.LiteralObject(new XmlWriterSettings
			{
				ConformanceLevel = ConformanceLevel.Auto
			});
			wsRules = factory.LiteralObject(new List<WhitespaceRule>());
			gloVars = factory.GlobalVariableList();
			gloParams = factory.GlobalParameterList();
			earlBnd = factory.LiteralObject(new List<EarlyBoundInfo>());
			funList = factory.FunctionList();
			rootNod = root;
		}
	}
	internal sealed class QilFactory
	{
		private QilTypeChecker typeCheck;

		public QilTypeChecker TypeChecker => typeCheck;

		public QilFactory()
		{
			typeCheck = new QilTypeChecker();
		}

		public QilExpression QilExpression(QilNode root, QilFactory factory)
		{
			QilExpression qilExpression = new QilExpression(QilNodeType.QilExpression, root, factory);
			qilExpression.XmlType = typeCheck.CheckQilExpression(qilExpression);
			return qilExpression;
		}

		public QilList FunctionList(IList<QilNode> values)
		{
			QilList qilList = FunctionList();
			qilList.Add(values);
			return qilList;
		}

		public QilList GlobalVariableList(IList<QilNode> values)
		{
			QilList qilList = GlobalVariableList();
			qilList.Add(values);
			return qilList;
		}

		public QilList GlobalParameterList(IList<QilNode> values)
		{
			QilList qilList = GlobalParameterList();
			qilList.Add(values);
			return qilList;
		}

		public QilList ActualParameterList(IList<QilNode> values)
		{
			QilList qilList = ActualParameterList();
			qilList.Add(values);
			return qilList;
		}

		public QilList FormalParameterList(IList<QilNode> values)
		{
			QilList qilList = FormalParameterList();
			qilList.Add(values);
			return qilList;
		}

		public QilList SortKeyList(IList<QilNode> values)
		{
			QilList qilList = SortKeyList();
			qilList.Add(values);
			return qilList;
		}

		public QilList BranchList(IList<QilNode> values)
		{
			QilList qilList = BranchList();
			qilList.Add(values);
			return qilList;
		}

		public QilList Sequence(IList<QilNode> values)
		{
			QilList qilList = Sequence();
			qilList.Add(values);
			return qilList;
		}

		public QilParameter Parameter(XmlQueryType xmlType)
		{
			return Parameter(null, null, xmlType);
		}

		public QilStrConcat StrConcat(QilNode values)
		{
			return StrConcat(LiteralString(""), values);
		}

		public QilName LiteralQName(string local)
		{
			return LiteralQName(local, string.Empty, string.Empty);
		}

		public QilTargetType TypeAssert(QilNode expr, XmlQueryType xmlType)
		{
			return TypeAssert(expr, (QilNode)LiteralType(xmlType));
		}

		public QilTargetType IsType(QilNode expr, XmlQueryType xmlType)
		{
			return IsType(expr, (QilNode)LiteralType(xmlType));
		}

		public QilTargetType XsltConvert(QilNode expr, XmlQueryType xmlType)
		{
			return XsltConvert(expr, (QilNode)LiteralType(xmlType));
		}

		public QilFunction Function(QilNode arguments, QilNode sideEffects, XmlQueryType xmlType)
		{
			return Function(arguments, Unknown(xmlType), sideEffects, xmlType);
		}

		public QilExpression QilExpression(QilNode root)
		{
			QilExpression qilExpression = new QilExpression(QilNodeType.QilExpression, root);
			qilExpression.XmlType = typeCheck.CheckQilExpression(qilExpression);
			return qilExpression;
		}

		public QilList FunctionList()
		{
			QilList qilList = new QilList(QilNodeType.FunctionList);
			qilList.XmlType = typeCheck.CheckFunctionList(qilList);
			return qilList;
		}

		public QilList GlobalVariableList()
		{
			QilList qilList = new QilList(QilNodeType.GlobalVariableList);
			qilList.XmlType = typeCheck.CheckGlobalVariableList(qilList);
			return qilList;
		}

		public QilList GlobalParameterList()
		{
			QilList qilList = new QilList(QilNodeType.GlobalParameterList);
			qilList.XmlType = typeCheck.CheckGlobalParameterList(qilList);
			return qilList;
		}

		public QilList ActualParameterList()
		{
			QilList qilList = new QilList(QilNodeType.ActualParameterList);
			qilList.XmlType = typeCheck.CheckActualParameterList(qilList);
			return qilList;
		}

		public QilList FormalParameterList()
		{
			QilList qilList = new QilList(QilNodeType.FormalParameterList);
			qilList.XmlType = typeCheck.CheckFormalParameterList(qilList);
			return qilList;
		}

		public QilList SortKeyList()
		{
			QilList qilList = new QilList(QilNodeType.SortKeyList);
			qilList.XmlType = typeCheck.CheckSortKeyList(qilList);
			return qilList;
		}

		public QilList BranchList()
		{
			QilList qilList = new QilList(QilNodeType.BranchList);
			qilList.XmlType = typeCheck.CheckBranchList(qilList);
			return qilList;
		}

		public QilUnary OptimizeBarrier(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.OptimizeBarrier, child);
			qilUnary.XmlType = typeCheck.CheckOptimizeBarrier(qilUnary);
			return qilUnary;
		}

		public QilNode Unknown(XmlQueryType xmlType)
		{
			QilNode qilNode = new QilNode(QilNodeType.Unknown, xmlType);
			qilNode.XmlType = typeCheck.CheckUnknown(qilNode);
			return qilNode;
		}

		public QilDataSource DataSource(QilNode name, QilNode baseUri)
		{
			QilDataSource qilDataSource = new QilDataSource(QilNodeType.DataSource, name, baseUri);
			qilDataSource.XmlType = typeCheck.CheckDataSource(qilDataSource);
			return qilDataSource;
		}

		public QilUnary Nop(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Nop, child);
			qilUnary.XmlType = typeCheck.CheckNop(qilUnary);
			return qilUnary;
		}

		public QilUnary Error(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Error, child);
			qilUnary.XmlType = typeCheck.CheckError(qilUnary);
			return qilUnary;
		}

		public QilUnary Warning(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Warning, child);
			qilUnary.XmlType = typeCheck.CheckWarning(qilUnary);
			return qilUnary;
		}

		public QilIterator For(QilNode binding)
		{
			QilIterator qilIterator = new QilIterator(QilNodeType.For, binding);
			qilIterator.XmlType = typeCheck.CheckFor(qilIterator);
			return qilIterator;
		}

		public QilIterator Let(QilNode binding)
		{
			QilIterator qilIterator = new QilIterator(QilNodeType.Let, binding);
			qilIterator.XmlType = typeCheck.CheckLet(qilIterator);
			return qilIterator;
		}

		public QilParameter Parameter(QilNode defaultValue, QilNode name, XmlQueryType xmlType)
		{
			QilParameter qilParameter = new QilParameter(QilNodeType.Parameter, defaultValue, name, xmlType);
			qilParameter.XmlType = typeCheck.CheckParameter(qilParameter);
			return qilParameter;
		}

		public QilUnary PositionOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.PositionOf, child);
			qilUnary.XmlType = typeCheck.CheckPositionOf(qilUnary);
			return qilUnary;
		}

		public QilNode True()
		{
			QilNode qilNode = new QilNode(QilNodeType.True);
			qilNode.XmlType = typeCheck.CheckTrue(qilNode);
			return qilNode;
		}

		public QilNode False()
		{
			QilNode qilNode = new QilNode(QilNodeType.False);
			qilNode.XmlType = typeCheck.CheckFalse(qilNode);
			return qilNode;
		}

		public QilLiteral LiteralString(string value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralString, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralString(qilLiteral);
			return qilLiteral;
		}

		public QilLiteral LiteralInt32(int value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralInt32, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralInt32(qilLiteral);
			return qilLiteral;
		}

		public QilLiteral LiteralInt64(long value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralInt64, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralInt64(qilLiteral);
			return qilLiteral;
		}

		public QilLiteral LiteralDouble(double value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralDouble, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralDouble(qilLiteral);
			return qilLiteral;
		}

		public QilLiteral LiteralDecimal(decimal value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralDecimal, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralDecimal(qilLiteral);
			return qilLiteral;
		}

		public QilName LiteralQName(string localName, string namespaceUri, string prefix)
		{
			QilName qilName = new QilName(QilNodeType.LiteralQName, localName, namespaceUri, prefix);
			qilName.XmlType = typeCheck.CheckLiteralQName(qilName);
			return qilName;
		}

		public QilLiteral LiteralType(XmlQueryType value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralType, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralType(qilLiteral);
			return qilLiteral;
		}

		public QilLiteral LiteralObject(object value)
		{
			QilLiteral qilLiteral = new QilLiteral(QilNodeType.LiteralObject, value);
			qilLiteral.XmlType = typeCheck.CheckLiteralObject(qilLiteral);
			return qilLiteral;
		}

		public QilBinary And(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.And, left, right);
			qilBinary.XmlType = typeCheck.CheckAnd(qilBinary);
			return qilBinary;
		}

		public QilBinary Or(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Or, left, right);
			qilBinary.XmlType = typeCheck.CheckOr(qilBinary);
			return qilBinary;
		}

		public QilUnary Not(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Not, child);
			qilUnary.XmlType = typeCheck.CheckNot(qilUnary);
			return qilUnary;
		}

		public QilTernary Conditional(QilNode left, QilNode center, QilNode right)
		{
			QilTernary qilTernary = new QilTernary(QilNodeType.Conditional, left, center, right);
			qilTernary.XmlType = typeCheck.CheckConditional(qilTernary);
			return qilTernary;
		}

		public QilChoice Choice(QilNode expression, QilNode branches)
		{
			QilChoice qilChoice = new QilChoice(QilNodeType.Choice, expression, branches);
			qilChoice.XmlType = typeCheck.CheckChoice(qilChoice);
			return qilChoice;
		}

		public QilUnary Length(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Length, child);
			qilUnary.XmlType = typeCheck.CheckLength(qilUnary);
			return qilUnary;
		}

		public QilList Sequence()
		{
			QilList qilList = new QilList(QilNodeType.Sequence);
			qilList.XmlType = typeCheck.CheckSequence(qilList);
			return qilList;
		}

		public QilBinary Union(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Union, left, right);
			qilBinary.XmlType = typeCheck.CheckUnion(qilBinary);
			return qilBinary;
		}

		public QilBinary Intersection(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Intersection, left, right);
			qilBinary.XmlType = typeCheck.CheckIntersection(qilBinary);
			return qilBinary;
		}

		public QilBinary Difference(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Difference, left, right);
			qilBinary.XmlType = typeCheck.CheckDifference(qilBinary);
			return qilBinary;
		}

		public QilUnary Average(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Average, child);
			qilUnary.XmlType = typeCheck.CheckAverage(qilUnary);
			return qilUnary;
		}

		public QilUnary Sum(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Sum, child);
			qilUnary.XmlType = typeCheck.CheckSum(qilUnary);
			return qilUnary;
		}

		public QilUnary Minimum(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Minimum, child);
			qilUnary.XmlType = typeCheck.CheckMinimum(qilUnary);
			return qilUnary;
		}

		public QilUnary Maximum(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Maximum, child);
			qilUnary.XmlType = typeCheck.CheckMaximum(qilUnary);
			return qilUnary;
		}

		public QilUnary Negate(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Negate, child);
			qilUnary.XmlType = typeCheck.CheckNegate(qilUnary);
			return qilUnary;
		}

		public QilBinary Add(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Add, left, right);
			qilBinary.XmlType = typeCheck.CheckAdd(qilBinary);
			return qilBinary;
		}

		public QilBinary Subtract(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Subtract, left, right);
			qilBinary.XmlType = typeCheck.CheckSubtract(qilBinary);
			return qilBinary;
		}

		public QilBinary Multiply(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Multiply, left, right);
			qilBinary.XmlType = typeCheck.CheckMultiply(qilBinary);
			return qilBinary;
		}

		public QilBinary Divide(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Divide, left, right);
			qilBinary.XmlType = typeCheck.CheckDivide(qilBinary);
			return qilBinary;
		}

		public QilBinary Modulo(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Modulo, left, right);
			qilBinary.XmlType = typeCheck.CheckModulo(qilBinary);
			return qilBinary;
		}

		public QilUnary StrLength(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.StrLength, child);
			qilUnary.XmlType = typeCheck.CheckStrLength(qilUnary);
			return qilUnary;
		}

		public QilStrConcat StrConcat(QilNode delimiter, QilNode values)
		{
			QilStrConcat qilStrConcat = new QilStrConcat(QilNodeType.StrConcat, delimiter, values);
			qilStrConcat.XmlType = typeCheck.CheckStrConcat(qilStrConcat);
			return qilStrConcat;
		}

		public QilBinary StrParseQName(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.StrParseQName, left, right);
			qilBinary.XmlType = typeCheck.CheckStrParseQName(qilBinary);
			return qilBinary;
		}

		public QilBinary Ne(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Ne, left, right);
			qilBinary.XmlType = typeCheck.CheckNe(qilBinary);
			return qilBinary;
		}

		public QilBinary Eq(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Eq, left, right);
			qilBinary.XmlType = typeCheck.CheckEq(qilBinary);
			return qilBinary;
		}

		public QilBinary Gt(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Gt, left, right);
			qilBinary.XmlType = typeCheck.CheckGt(qilBinary);
			return qilBinary;
		}

		public QilBinary Ge(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Ge, left, right);
			qilBinary.XmlType = typeCheck.CheckGe(qilBinary);
			return qilBinary;
		}

		public QilBinary Lt(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Lt, left, right);
			qilBinary.XmlType = typeCheck.CheckLt(qilBinary);
			return qilBinary;
		}

		public QilBinary Le(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Le, left, right);
			qilBinary.XmlType = typeCheck.CheckLe(qilBinary);
			return qilBinary;
		}

		public QilBinary Is(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Is, left, right);
			qilBinary.XmlType = typeCheck.CheckIs(qilBinary);
			return qilBinary;
		}

		public QilBinary After(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.After, left, right);
			qilBinary.XmlType = typeCheck.CheckAfter(qilBinary);
			return qilBinary;
		}

		public QilBinary Before(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Before, left, right);
			qilBinary.XmlType = typeCheck.CheckBefore(qilBinary);
			return qilBinary;
		}

		public QilLoop Loop(QilNode variable, QilNode body)
		{
			QilLoop qilLoop = new QilLoop(QilNodeType.Loop, variable, body);
			qilLoop.XmlType = typeCheck.CheckLoop(qilLoop);
			return qilLoop;
		}

		public QilLoop Filter(QilNode variable, QilNode body)
		{
			QilLoop qilLoop = new QilLoop(QilNodeType.Filter, variable, body);
			qilLoop.XmlType = typeCheck.CheckFilter(qilLoop);
			return qilLoop;
		}

		public QilLoop Sort(QilNode variable, QilNode body)
		{
			QilLoop qilLoop = new QilLoop(QilNodeType.Sort, variable, body);
			qilLoop.XmlType = typeCheck.CheckSort(qilLoop);
			return qilLoop;
		}

		public QilSortKey SortKey(QilNode key, QilNode collation)
		{
			QilSortKey qilSortKey = new QilSortKey(QilNodeType.SortKey, key, collation);
			qilSortKey.XmlType = typeCheck.CheckSortKey(qilSortKey);
			return qilSortKey;
		}

		public QilUnary DocOrderDistinct(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.DocOrderDistinct, child);
			qilUnary.XmlType = typeCheck.CheckDocOrderDistinct(qilUnary);
			return qilUnary;
		}

		public QilFunction Function(QilNode arguments, QilNode definition, QilNode sideEffects, XmlQueryType xmlType)
		{
			QilFunction qilFunction = new QilFunction(QilNodeType.Function, arguments, definition, sideEffects, xmlType);
			qilFunction.XmlType = typeCheck.CheckFunction(qilFunction);
			return qilFunction;
		}

		public QilInvoke Invoke(QilNode function, QilNode arguments)
		{
			QilInvoke qilInvoke = new QilInvoke(QilNodeType.Invoke, function, arguments);
			qilInvoke.XmlType = typeCheck.CheckInvoke(qilInvoke);
			return qilInvoke;
		}

		public QilUnary Content(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Content, child);
			qilUnary.XmlType = typeCheck.CheckContent(qilUnary);
			return qilUnary;
		}

		public QilBinary Attribute(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Attribute, left, right);
			qilBinary.XmlType = typeCheck.CheckAttribute(qilBinary);
			return qilBinary;
		}

		public QilUnary Parent(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Parent, child);
			qilUnary.XmlType = typeCheck.CheckParent(qilUnary);
			return qilUnary;
		}

		public QilUnary Root(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Root, child);
			qilUnary.XmlType = typeCheck.CheckRoot(qilUnary);
			return qilUnary;
		}

		public QilNode XmlContext()
		{
			QilNode qilNode = new QilNode(QilNodeType.XmlContext);
			qilNode.XmlType = typeCheck.CheckXmlContext(qilNode);
			return qilNode;
		}

		public QilUnary Descendant(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Descendant, child);
			qilUnary.XmlType = typeCheck.CheckDescendant(qilUnary);
			return qilUnary;
		}

		public QilUnary DescendantOrSelf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.DescendantOrSelf, child);
			qilUnary.XmlType = typeCheck.CheckDescendantOrSelf(qilUnary);
			return qilUnary;
		}

		public QilUnary Ancestor(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Ancestor, child);
			qilUnary.XmlType = typeCheck.CheckAncestor(qilUnary);
			return qilUnary;
		}

		public QilUnary AncestorOrSelf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.AncestorOrSelf, child);
			qilUnary.XmlType = typeCheck.CheckAncestorOrSelf(qilUnary);
			return qilUnary;
		}

		public QilUnary Preceding(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.Preceding, child);
			qilUnary.XmlType = typeCheck.CheckPreceding(qilUnary);
			return qilUnary;
		}

		public QilUnary FollowingSibling(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.FollowingSibling, child);
			qilUnary.XmlType = typeCheck.CheckFollowingSibling(qilUnary);
			return qilUnary;
		}

		public QilUnary PrecedingSibling(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.PrecedingSibling, child);
			qilUnary.XmlType = typeCheck.CheckPrecedingSibling(qilUnary);
			return qilUnary;
		}

		public QilBinary NodeRange(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.NodeRange, left, right);
			qilBinary.XmlType = typeCheck.CheckNodeRange(qilBinary);
			return qilBinary;
		}

		public QilBinary Deref(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.Deref, left, right);
			qilBinary.XmlType = typeCheck.CheckDeref(qilBinary);
			return qilBinary;
		}

		public QilBinary ElementCtor(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.ElementCtor, left, right);
			qilBinary.XmlType = typeCheck.CheckElementCtor(qilBinary);
			return qilBinary;
		}

		public QilBinary AttributeCtor(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.AttributeCtor, left, right);
			qilBinary.XmlType = typeCheck.CheckAttributeCtor(qilBinary);
			return qilBinary;
		}

		public QilUnary CommentCtor(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.CommentCtor, child);
			qilUnary.XmlType = typeCheck.CheckCommentCtor(qilUnary);
			return qilUnary;
		}

		public QilBinary PICtor(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.PICtor, left, right);
			qilBinary.XmlType = typeCheck.CheckPICtor(qilBinary);
			return qilBinary;
		}

		public QilUnary TextCtor(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.TextCtor, child);
			qilUnary.XmlType = typeCheck.CheckTextCtor(qilUnary);
			return qilUnary;
		}

		public QilUnary RawTextCtor(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.RawTextCtor, child);
			qilUnary.XmlType = typeCheck.CheckRawTextCtor(qilUnary);
			return qilUnary;
		}

		public QilUnary DocumentCtor(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.DocumentCtor, child);
			qilUnary.XmlType = typeCheck.CheckDocumentCtor(qilUnary);
			return qilUnary;
		}

		public QilBinary NamespaceDecl(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.NamespaceDecl, left, right);
			qilBinary.XmlType = typeCheck.CheckNamespaceDecl(qilBinary);
			return qilBinary;
		}

		public QilBinary RtfCtor(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.RtfCtor, left, right);
			qilBinary.XmlType = typeCheck.CheckRtfCtor(qilBinary);
			return qilBinary;
		}

		public QilUnary NameOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.NameOf, child);
			qilUnary.XmlType = typeCheck.CheckNameOf(qilUnary);
			return qilUnary;
		}

		public QilUnary LocalNameOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.LocalNameOf, child);
			qilUnary.XmlType = typeCheck.CheckLocalNameOf(qilUnary);
			return qilUnary;
		}

		public QilUnary NamespaceUriOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.NamespaceUriOf, child);
			qilUnary.XmlType = typeCheck.CheckNamespaceUriOf(qilUnary);
			return qilUnary;
		}

		public QilUnary PrefixOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.PrefixOf, child);
			qilUnary.XmlType = typeCheck.CheckPrefixOf(qilUnary);
			return qilUnary;
		}

		public QilTargetType TypeAssert(QilNode source, QilNode targetType)
		{
			QilTargetType qilTargetType = new QilTargetType(QilNodeType.TypeAssert, source, targetType);
			qilTargetType.XmlType = typeCheck.CheckTypeAssert(qilTargetType);
			return qilTargetType;
		}

		public QilTargetType IsType(QilNode source, QilNode targetType)
		{
			QilTargetType qilTargetType = new QilTargetType(QilNodeType.IsType, source, targetType);
			qilTargetType.XmlType = typeCheck.CheckIsType(qilTargetType);
			return qilTargetType;
		}

		public QilUnary IsEmpty(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.IsEmpty, child);
			qilUnary.XmlType = typeCheck.CheckIsEmpty(qilUnary);
			return qilUnary;
		}

		public QilUnary XPathNodeValue(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XPathNodeValue, child);
			qilUnary.XmlType = typeCheck.CheckXPathNodeValue(qilUnary);
			return qilUnary;
		}

		public QilUnary XPathFollowing(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XPathFollowing, child);
			qilUnary.XmlType = typeCheck.CheckXPathFollowing(qilUnary);
			return qilUnary;
		}

		public QilUnary XPathPreceding(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XPathPreceding, child);
			qilUnary.XmlType = typeCheck.CheckXPathPreceding(qilUnary);
			return qilUnary;
		}

		public QilUnary XPathNamespace(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XPathNamespace, child);
			qilUnary.XmlType = typeCheck.CheckXPathNamespace(qilUnary);
			return qilUnary;
		}

		public QilUnary XsltGenerateId(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XsltGenerateId, child);
			qilUnary.XmlType = typeCheck.CheckXsltGenerateId(qilUnary);
			return qilUnary;
		}

		public QilInvokeLateBound XsltInvokeLateBound(QilNode name, QilNode arguments)
		{
			QilInvokeLateBound qilInvokeLateBound = new QilInvokeLateBound(QilNodeType.XsltInvokeLateBound, name, arguments);
			qilInvokeLateBound.XmlType = typeCheck.CheckXsltInvokeLateBound(qilInvokeLateBound);
			return qilInvokeLateBound;
		}

		public QilInvokeEarlyBound XsltInvokeEarlyBound(QilNode name, QilNode clrMethod, QilNode arguments, XmlQueryType xmlType)
		{
			QilInvokeEarlyBound qilInvokeEarlyBound = new QilInvokeEarlyBound(QilNodeType.XsltInvokeEarlyBound, name, clrMethod, arguments, xmlType);
			qilInvokeEarlyBound.XmlType = typeCheck.CheckXsltInvokeEarlyBound(qilInvokeEarlyBound);
			return qilInvokeEarlyBound;
		}

		public QilBinary XsltCopy(QilNode left, QilNode right)
		{
			QilBinary qilBinary = new QilBinary(QilNodeType.XsltCopy, left, right);
			qilBinary.XmlType = typeCheck.CheckXsltCopy(qilBinary);
			return qilBinary;
		}

		public QilUnary XsltCopyOf(QilNode child)
		{
			QilUnary qilUnary = new QilUnary(QilNodeType.XsltCopyOf, child);
			qilUnary.XmlType = typeCheck.CheckXsltCopyOf(qilUnary);
			return qilUnary;
		}

		public QilTargetType XsltConvert(QilNode source, QilNode targetType)
		{
			QilTargetType qilTargetType = new QilTargetType(QilNodeType.XsltConvert, source, targetType);
			qilTargetType.XmlType = typeCheck.CheckXsltConvert(qilTargetType);
			return qilTargetType;
		}

		[Conditional("QIL_TRACE_NODE_CREATION")]
		public void TraceNode(QilNode n)
		{
		}
	}
	internal class QilFunction : QilReference
	{
		private QilNode arguments;

		private QilNode definition;

		private QilNode sideEffects;

		public override int Count => 3;

		public override QilNode this[int index]
		{
			get
			{
				return index switch
				{
					0 => arguments, 
					1 => definition, 
					2 => sideEffects, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					arguments = value;
					break;
				case 1:
					definition = value;
					break;
				case 2:
					sideEffects = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public QilList Arguments
		{
			get
			{
				return (QilList)arguments;
			}
			set
			{
				arguments = value;
			}
		}

		public QilNode Definition
		{
			get
			{
				return definition;
			}
			set
			{
				definition = value;
			}
		}

		public bool MaybeSideEffects
		{
			get
			{
				return sideEffects.NodeType == QilNodeType.True;
			}
			set
			{
				sideEffects.NodeType = (value ? QilNodeType.True : QilNodeType.False);
			}
		}

		public QilFunction(QilNodeType nodeType, QilNode arguments, QilNode definition, QilNode sideEffects, XmlQueryType resultType)
			: base(nodeType)
		{
			this.arguments = arguments;
			this.definition = definition;
			this.sideEffects = sideEffects;
			xmlType = resultType;
		}
	}
	internal class QilInvoke : QilBinary
	{
		public QilFunction Function
		{
			get
			{
				return (QilFunction)base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilList Arguments
		{
			get
			{
				return (QilList)base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilInvoke(QilNodeType nodeType, QilNode function, QilNode arguments)
			: base(nodeType, function, arguments)
		{
		}
	}
	internal class QilInvokeEarlyBound : QilTernary
	{
		public QilName Name
		{
			get
			{
				return (QilName)base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public MethodInfo ClrMethod
		{
			get
			{
				return (MethodInfo)((QilLiteral)base.Center).Value;
			}
			set
			{
				((QilLiteral)base.Center).Value = value;
			}
		}

		public QilList Arguments
		{
			get
			{
				return (QilList)base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilInvokeEarlyBound(QilNodeType nodeType, QilNode name, QilNode method, QilNode arguments, XmlQueryType resultType)
			: base(nodeType, name, method, arguments)
		{
			xmlType = resultType;
		}
	}
	internal class QilInvokeLateBound : QilBinary
	{
		public QilName Name
		{
			get
			{
				return (QilName)base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilList Arguments
		{
			get
			{
				return (QilList)base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilInvokeLateBound(QilNodeType nodeType, QilNode name, QilNode arguments)
			: base(nodeType, name, arguments)
		{
		}
	}
	internal class QilIterator : QilReference
	{
		private QilNode binding;

		public override int Count => 1;

		public override QilNode this[int index]
		{
			get
			{
				if (index != 0)
				{
					throw new IndexOutOfRangeException();
				}
				return binding;
			}
			set
			{
				if (index != 0)
				{
					throw new IndexOutOfRangeException();
				}
				binding = value;
			}
		}

		public QilNode Binding
		{
			get
			{
				return binding;
			}
			set
			{
				binding = value;
			}
		}

		public QilIterator(QilNodeType nodeType, QilNode binding)
			: base(nodeType)
		{
			Binding = binding;
		}
	}
	internal class QilList : QilNode
	{
		private int count;

		private QilNode[] members;

		public override XmlQueryType XmlType
		{
			get
			{
				if (xmlType == null)
				{
					XmlQueryType left = XmlQueryTypeFactory.Empty;
					if (count > 0)
					{
						if (nodeType == QilNodeType.Sequence)
						{
							for (int i = 0; i < count; i++)
							{
								left = XmlQueryTypeFactory.Sequence(left, members[i].XmlType);
							}
						}
						else if (nodeType == QilNodeType.BranchList)
						{
							left = members[0].XmlType;
							for (int j = 1; j < count; j++)
							{
								left = XmlQueryTypeFactory.Choice(left, members[j].XmlType);
							}
						}
					}
					xmlType = left;
				}
				return xmlType;
			}
		}

		public override int Count => count;

		public override QilNode this[int index]
		{
			get
			{
				if (index >= 0 && index < count)
				{
					return members[index];
				}
				throw new IndexOutOfRangeException();
			}
			set
			{
				if (index >= 0 && index < count)
				{
					members[index] = value;
					xmlType = null;
					return;
				}
				throw new IndexOutOfRangeException();
			}
		}

		public QilList(QilNodeType nodeType)
			: base(nodeType)
		{
			members = new QilNode[4];
			xmlType = null;
		}

		public override QilNode ShallowClone(QilFactory f)
		{
			QilList qilList = (QilList)MemberwiseClone();
			qilList.members = (QilNode[])members.Clone();
			return qilList;
		}

		public override void Insert(int index, QilNode node)
		{
			if (index < 0 || index > count)
			{
				throw new IndexOutOfRangeException();
			}
			if (count == members.Length)
			{
				QilNode[] destinationArray = new QilNode[count * 2];
				Array.Copy(members, destinationArray, count);
				members = destinationArray;
			}
			if (index < count)
			{
				Array.Copy(members, index, members, index + 1, count - index);
			}
			count++;
			members[index] = node;
			xmlType = null;
		}

		public override void RemoveAt(int index)
		{
			if (index < 0 || index >= count)
			{
				throw new IndexOutOfRangeException();
			}
			count--;
			if (index < count)
			{
				Array.Copy(members, index + 1, members, index, count - index);
			}
			members[count] = null;
			xmlType = null;
		}
	}
	internal class QilLiteral : QilNode
	{
		private object value;

		public object Value
		{
			get
			{
				return value;
			}
			set
			{
				this.value = value;
			}
		}

		public QilLiteral(QilNodeType nodeType, object value)
			: base(nodeType)
		{
			Value = value;
		}

		public static implicit operator string(QilLiteral literal)
		{
			return (string)literal.value;
		}

		public static implicit operator int(QilLiteral literal)
		{
			return (int)literal.value;
		}

		public static implicit operator long(QilLiteral literal)
		{
			return (long)literal.value;
		}

		public static implicit operator double(QilLiteral literal)
		{
			return (double)literal.value;
		}

		public static implicit operator decimal(QilLiteral literal)
		{
			return (decimal)literal.value;
		}

		public static implicit operator XmlQueryType(QilLiteral literal)
		{
			return (XmlQueryType)literal.value;
		}
	}
	internal class QilLoop : QilBinary
	{
		public QilIterator Variable
		{
			get
			{
				return (QilIterator)base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilNode Body
		{
			get
			{
				return base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilLoop(QilNodeType nodeType, QilNode variable, QilNode body)
			: base(nodeType, variable, body)
		{
		}
	}
	internal class QilName : QilLiteral
	{
		private string local;

		private string uri;

		private string prefix;

		public string LocalName
		{
			get
			{
				return local;
			}
			set
			{
				local = value;
			}
		}

		public string NamespaceUri
		{
			get
			{
				return uri;
			}
			set
			{
				uri = value;
			}
		}

		public string Prefix
		{
			get
			{
				return prefix;
			}
			set
			{
				prefix = value;
			}
		}

		public string QualifiedName
		{
			get
			{
				if (prefix.Length == 0)
				{
					return local;
				}
				return prefix + ":" + local;
			}
		}

		public QilName(QilNodeType nodeType, string local, string uri, string prefix)
			: base(nodeType, null)
		{
			LocalName = local;
			NamespaceUri = uri;
			Prefix = prefix;
			base.Value = this;
		}

		public override int GetHashCode()
		{
			return local.GetHashCode();
		}

		public override bool Equals(object other)
		{
			QilName qilName = other as QilName;
			if (qilName == null)
			{
				return false;
			}
			if (local == qilName.local)
			{
				return uri == qilName.uri;
			}
			return false;
		}

		public static bool operator ==(QilName a, QilName b)
		{
			if ((object)a == b)
			{
				return true;
			}
			if ((object)a == null || (object)b == null)
			{
				return false;
			}
			if (a.local == b.local)
			{
				return a.uri == b.uri;
			}
			return false;
		}

		public static bool operator !=(QilName a, QilName b)
		{
			return !(a == b);
		}

		public override string ToString()
		{
			if (prefix.Length == 0)
			{
				if (uri.Length == 0)
				{
					return local;
				}
				return "{" + uri + "}" + local;
			}
			return "{" + uri + "}" + prefix + ":" + local;
		}
	}
	internal class QilNode : IList<QilNode>, ICollection<QilNode>, IEnumerable<QilNode>, IEnumerable
	{
		protected QilNodeType nodeType;

		protected XmlQueryType xmlType;

		protected ISourceLineInfo sourceLine;

		protected object annotation;

		public QilNodeType NodeType
		{
			get
			{
				return nodeType;
			}
			set
			{
				nodeType = value;
			}
		}

		public virtual XmlQueryType XmlType
		{
			get
			{
				return xmlType;
			}
			set
			{
				xmlType = value;
			}
		}

		public ISourceLineInfo SourceLine
		{
			get
			{
				return sourceLine;
			}
			set
			{
				sourceLine = value;
			}
		}

		public object Annotation
		{
			get
			{
				return annotation;
			}
			set
			{
				annotation = value;
			}
		}

		public virtual int Count => 0;

		public virtual QilNode this[int index]
		{
			get
			{
				throw new IndexOutOfRangeException();
			}
			set
			{
				throw new IndexOutOfRangeException();
			}
		}

		public virtual bool IsReadOnly => false;

		public QilNode(QilNodeType nodeType)
		{
			this.nodeType = nodeType;
		}

		public QilNode(QilNodeType nodeType, XmlQueryType xmlType)
		{
			this.nodeType = nodeType;
			this.xmlType = xmlType;
		}

		public virtual QilNode DeepClone(QilFactory f)
		{
			return new QilCloneVisitor(f).Clone(this);
		}

		public virtual QilNode ShallowClone(QilFactory f)
		{
			return (QilNode)MemberwiseClone();
		}

		public virtual void Insert(int index, QilNode node)
		{
			throw new NotSupportedException();
		}

		public virtual void RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		public IEnumerator<QilNode> GetEnumerator()
		{
			return new IListEnumerator<QilNode>(this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new IListEnumerator<QilNode>(this);
		}

		public virtual void Add(QilNode node)
		{
			Insert(Count, node);
		}

		public virtual void Add(IList<QilNode> list)
		{
			for (int i = 0; i < list.Count; i++)
			{
				Insert(Count, list[i]);
			}
		}

		public virtual void Clear()
		{
			for (int num = Count - 1; num >= 0; num--)
			{
				RemoveAt(num);
			}
		}

		public virtual bool Contains(QilNode node)
		{
			return IndexOf(node) != -1;
		}

		public virtual void CopyTo(QilNode[] array, int index)
		{
			for (int i = 0; i < Count; i++)
			{
				array[index + i] = this[i];
			}
		}

		public virtual bool Remove(QilNode node)
		{
			int num = IndexOf(node);
			if (num >= 0)
			{
				RemoveAt(num);
				return true;
			}
			return false;
		}

		public virtual int IndexOf(QilNode node)
		{
			for (int i = 0; i < Count; i++)
			{
				if (node.Equals(this[i]))
				{
					return i;
				}
			}
			return -1;
		}
	}
	internal enum QilNodeType
	{
		QilExpression,
		FunctionList,
		GlobalVariableList,
		GlobalParameterList,
		ActualParameterList,
		FormalParameterList,
		SortKeyList,
		BranchList,
		OptimizeBarrier,
		Unknown,
		DataSource,
		Nop,
		Error,
		Warning,
		For,
		Let,
		Parameter,
		PositionOf,
		True,
		False,
		LiteralString,
		LiteralInt32,
		LiteralInt64,
		LiteralDouble,
		LiteralDecimal,
		LiteralQName,
		LiteralType,
		LiteralObject,
		And,
		Or,
		Not,
		Conditional,
		Choice,
		Length,
		Sequence,
		Union,
		Intersection,
		Difference,
		Average,
		Sum,
		Minimum,
		Maximum,
		Negate,
		Add,
		Subtract,
		Multiply,
		Divide,
		Modulo,
		StrLength,
		StrConcat,
		StrParseQName,
		Ne,
		Eq,
		Gt,
		Ge,
		Lt,
		Le,
		Is,
		After,
		Before,
		Loop,
		Filter,
		Sort,
		SortKey,
		DocOrderDistinct,
		Function,
		Invoke,
		Content,
		Attribute,
		Parent,
		Root,
		XmlContext,
		Descendant,
		DescendantOrSelf,
		Ancestor,
		AncestorOrSelf,
		Preceding,
		FollowingSibling,
		PrecedingSibling,
		NodeRange,
		Deref,
		ElementCtor,
		AttributeCtor,
		CommentCtor,
		PICtor,
		TextCtor,
		RawTextCtor,
		DocumentCtor,
		NamespaceDecl,
		RtfCtor,
		NameOf,
		LocalNameOf,
		NamespaceUriOf,
		PrefixOf,
		TypeAssert,
		IsType,
		IsEmpty,
		XPathNodeValue,
		XPathFollowing,
		XPathPreceding,
		XPathNamespace,
		XsltGenerateId,
		XsltInvokeLateBound,
		XsltInvokeEarlyBound,
		XsltCopy,
		XsltCopyOf,
		XsltConvert
	}
	internal class QilParameter : QilIterator
	{
		private QilNode name;

		public override int Count => 2;

		public override QilNode this[int index]
		{
			get
			{
				return index switch
				{
					0 => base.Binding, 
					1 => name, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					base.Binding = value;
					break;
				case 1:
					name = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public QilNode DefaultValue
		{
			get
			{
				return base.Binding;
			}
			set
			{
				base.Binding = value;
			}
		}

		public QilName Name
		{
			get
			{
				return (QilName)name;
			}
			set
			{
				name = value;
			}
		}

		public QilParameter(QilNodeType nodeType, QilNode defaultValue, QilNode name, XmlQueryType xmlType)
			: base(nodeType, defaultValue)
		{
			this.name = name;
			base.xmlType = xmlType;
		}
	}
	internal class QilPatternFactory
	{
		private bool debug;

		private QilFactory f;

		public QilFactory BaseFactory => f;

		public bool IsDebug => debug;

		public QilPatternFactory(QilFactory f, bool debug)
		{
			this.f = f;
			this.debug = debug;
		}

		public QilLiteral String(string val)
		{
			return f.LiteralString(val);
		}

		public QilLiteral Int32(int val)
		{
			return f.LiteralInt32(val);
		}

		public QilLiteral Double(double val)
		{
			return f.LiteralDouble(val);
		}

		public QilName QName(string local, string uri, string prefix)
		{
			return f.LiteralQName(local, uri, prefix);
		}

		public QilName QName(string local, string uri)
		{
			return f.LiteralQName(local, uri, string.Empty);
		}

		public QilName QName(string local)
		{
			return f.LiteralQName(local, string.Empty, string.Empty);
		}

		public QilNode Unknown(XmlQueryType t)
		{
			return f.Unknown(t);
		}

		public QilExpression QilExpression(QilNode root, QilFactory factory)
		{
			return f.QilExpression(root, factory);
		}

		public QilList FunctionList()
		{
			return f.FunctionList();
		}

		public QilList GlobalVariableList()
		{
			return f.GlobalVariableList();
		}

		public QilList GlobalParameterList()
		{
			return f.GlobalParameterList();
		}

		public QilList ActualParameterList()
		{
			return f.ActualParameterList();
		}

		public QilList ActualParameterList(QilNode arg1)
		{
			QilList qilList = f.ActualParameterList();
			qilList.Add(arg1);
			return qilList;
		}

		public QilList ActualParameterList(QilNode arg1, QilNode arg2)
		{
			QilList qilList = f.ActualParameterList();
			qilList.Add(arg1);
			qilList.Add(arg2);
			return qilList;
		}

		public QilList ActualParameterList(params QilNode[] args)
		{
			return f.ActualParameterList(args);
		}

		public QilList FormalParameterList()
		{
			return f.FormalParameterList();
		}

		public QilList FormalParameterList(QilNode arg1)
		{
			QilList qilList = f.FormalParameterList();
			qilList.Add(arg1);
			return qilList;
		}

		public QilList FormalParameterList(QilNode arg1, QilNode arg2)
		{
			QilList qilList = f.FormalParameterList();
			qilList.Add(arg1);
			qilList.Add(arg2);
			return qilList;
		}

		public QilList FormalParameterList(params QilNode[] args)
		{
			return f.FormalParameterList(args);
		}

		public QilList SortKeyList()
		{
			return f.SortKeyList();
		}

		public QilList SortKeyList(QilSortKey key)
		{
			QilList qilList = f.SortKeyList();
			qilList.Add(key);
			return qilList;
		}

		public QilList BranchList(params QilNode[] args)
		{
			return f.BranchList(args);
		}

		public QilNode OptimizeBarrier(QilNode child)
		{
			return f.OptimizeBarrier(child);
		}

		public QilNode DataSource(QilNode name, QilNode baseUri)
		{
			return f.DataSource(name, baseUri);
		}

		public QilNode Nop(QilNode child)
		{
			return f.Nop(child);
		}

		public QilNode Error(QilNode text)
		{
			return f.Error(text);
		}

		public QilNode Warning(QilNode text)
		{
			return f.Warning(text);
		}

		public QilIterator For(QilNode binding)
		{
			return f.For(binding);
		}

		public QilIterator Let(QilNode binding)
		{
			return f.Let(binding);
		}

		public QilParameter Parameter(XmlQueryType t)
		{
			return f.Parameter(t);
		}

		public QilParameter Parameter(QilNode defaultValue, QilName name, XmlQueryType t)
		{
			return f.Parameter(defaultValue, name, t);
		}

		public QilNode PositionOf(QilIterator expr)
		{
			return f.PositionOf(expr);
		}

		public QilNode True()
		{
			return f.True();
		}

		public QilNode False()
		{
			return f.False();
		}

		public QilNode Boolean(bool b)
		{
			if (!b)
			{
				return False();
			}
			return True();
		}

		private static void CheckLogicArg(QilNode arg)
		{
		}

		public QilNode And(QilNode left, QilNode right)
		{
			CheckLogicArg(left);
			CheckLogicArg(right);
			if (!debug)
			{
				if (left.NodeType == QilNodeType.True || right.NodeType == QilNodeType.False)
				{
					return right;
				}
				if (left.NodeType == QilNodeType.False || right.NodeType == QilNodeType.True)
				{
					return left;
				}
			}
			return f.And(left, right);
		}

		public QilNode Or(QilNode left, QilNode right)
		{
			CheckLogicArg(left);
			CheckLogicArg(right);
			if (!debug)
			{
				if (left.NodeType == QilNodeType.True || right.NodeType == QilNodeType.False)
				{
					return left;
				}
				if (left.NodeType == QilNodeType.False || right.NodeType == QilNodeType.True)
				{
					return right;
				}
			}
			return f.Or(left, right);
		}

		public QilNode Not(QilNode child)
		{
			if (!debug)
			{
				switch (child.NodeType)
				{
				case QilNodeType.True:
					return f.False();
				case QilNodeType.False:
					return f.True();
				case QilNodeType.Not:
					return ((QilUnary)child).Child;
				}
			}
			return f.Not(child);
		}

		public QilNode Conditional(QilNode condition, QilNode trueBranch, QilNode falseBranch)
		{
			if (!debug)
			{
				switch (condition.NodeType)
				{
				case QilNodeType.True:
					return trueBranch;
				case QilNodeType.False:
					return falseBranch;
				case QilNodeType.Not:
					return Conditional(((QilUnary)condition).Child, falseBranch, trueBranch);
				}
			}
			return f.Conditional(condition, trueBranch, falseBranch);
		}

		public QilNode Choice(QilNode expr, QilList branches)
		{
			if (!debug)
			{
				switch (branches.Count)
				{
				case 1:
					return f.Loop(f.Let(expr), branches[0]);
				case 2:
					return f.Conditional(f.Eq(expr, f.LiteralInt32(0)), branches[0], branches[1]);
				}
			}
			return f.Choice(expr, branches);
		}

		public QilNode Length(QilNode child)
		{
			return f.Length(child);
		}

		public QilNode Sequence()
		{
			return f.Sequence();
		}

		public QilNode Sequence(QilNode child)
		{
			if (!debug)
			{
				return child;
			}
			QilList qilList = f.Sequence();
			qilList.Add(child);
			return qilList;
		}

		public QilNode Sequence(QilNode child1, QilNode child2)
		{
			QilList qilList = f.Sequence();
			qilList.Add(child1);
			qilList.Add(child2);
			return qilList;
		}

		public QilNode Sequence(params QilNode[] args)
		{
			if (!debug)
			{
				switch (args.Length)
				{
				case 0:
					return f.Sequence();
				case 1:
					return args[0];
				}
			}
			QilList qilList = f.Sequence();
			foreach (QilNode node in args)
			{
				qilList.Add(node);
			}
			return qilList;
		}

		public QilNode Union(QilNode left, QilNode right)
		{
			return f.Union(left, right);
		}

		public QilNode Sum(QilNode collection)
		{
			return f.Sum(collection);
		}

		public QilNode Negate(QilNode child)
		{
			return f.Negate(child);
		}

		public QilNode Add(QilNode left, QilNode right)
		{
			return f.Add(left, right);
		}

		public QilNode Subtract(QilNode left, QilNode right)
		{
			return f.Subtract(left, right);
		}

		public QilNode Multiply(QilNode left, QilNode right)
		{
			return f.Multiply(left, right);
		}

		public QilNode Divide(QilNode left, QilNode right)
		{
			return f.Divide(left, right);
		}

		public QilNode Modulo(QilNode left, QilNode right)
		{
			return f.Modulo(left, right);
		}

		public QilNode StrLength(QilNode str)
		{
			return f.StrLength(str);
		}

		public QilNode StrConcat(QilNode values)
		{
			if (!debug && values.XmlType.IsSingleton)
			{
				return values;
			}
			return f.StrConcat(values);
		}

		public QilNode StrConcat(params QilNode[] args)
		{
			return StrConcat((IList<QilNode>)args);
		}

		public QilNode StrConcat(IList<QilNode> args)
		{
			if (!debug)
			{
				switch (args.Count)
				{
				case 0:
					return f.LiteralString(string.Empty);
				case 1:
					return StrConcat(args[0]);
				}
			}
			return StrConcat(f.Sequence(args));
		}

		public QilNode StrParseQName(QilNode str, QilNode ns)
		{
			return f.StrParseQName(str, ns);
		}

		public QilNode Ne(QilNode left, QilNode right)
		{
			return f.Ne(left, right);
		}

		public QilNode Eq(QilNode left, QilNode right)
		{
			return f.Eq(left, right);
		}

		public QilNode Gt(QilNode left, QilNode right)
		{
			return f.Gt(left, right);
		}

		public QilNode Ge(QilNode left, QilNode right)
		{
			return f.Ge(left, right);
		}

		public QilNode Lt(QilNode left, QilNode right)
		{
			return f.Lt(left, right);
		}

		public QilNode Le(QilNode left, QilNode right)
		{
			return f.Le(left, right);
		}

		public QilNode Is(QilNode left, QilNode right)
		{
			return f.Is(left, right);
		}

		public QilNode After(QilNode left, QilNode right)
		{
			return f.After(left, right);
		}

		public QilNode Before(QilNode left, QilNode right)
		{
			return f.Before(left, right);
		}

		public QilNode Loop(QilIterator variable, QilNode body)
		{
			if (!debug && body == variable.Binding)
			{
				return body;
			}
			return f.Loop(variable, body);
		}

		public QilNode Filter(QilIterator variable, QilNode expr)
		{
			if (!debug && expr.NodeType == QilNodeType.True)
			{
				return variable.Binding;
			}
			return f.Filter(variable, expr);
		}

		public QilNode Sort(QilIterator iter, QilNode keys)
		{
			return f.Sort(iter, keys);
		}

		public QilSortKey SortKey(QilNode key, QilNode collation)
		{
			return f.SortKey(key, collation);
		}

		public QilNode DocOrderDistinct(QilNode collection)
		{
			if (collection.NodeType == QilNodeType.DocOrderDistinct)
			{
				return collection;
			}
			return f.DocOrderDistinct(collection);
		}

		public QilFunction Function(QilList args, QilNode sideEffects, XmlQueryType resultType)
		{
			return f.Function(args, sideEffects, resultType);
		}

		public QilFunction Function(QilList args, QilNode defn, QilNode sideEffects)
		{
			return f.Function(args, defn, sideEffects, defn.XmlType);
		}

		public QilNode Invoke(QilFunction func, QilList args)
		{
			return f.Invoke(func, args);
		}

		public QilNode Content(QilNode context)
		{
			return f.Content(context);
		}

		public QilNode Parent(QilNode context)
		{
			return f.Parent(context);
		}

		public QilNode Root(QilNode context)
		{
			return f.Root(context);
		}

		public QilNode XmlContext()
		{
			return f.XmlContext();
		}

		public QilNode Descendant(QilNode expr)
		{
			return f.Descendant(expr);
		}

		public QilNode DescendantOrSelf(QilNode context)
		{
			return f.DescendantOrSelf(context);
		}

		public QilNode Ancestor(QilNode expr)
		{
			return f.Ancestor(expr);
		}

		public QilNode AncestorOrSelf(QilNode expr)
		{
			return f.AncestorOrSelf(expr);
		}

		public QilNode Preceding(QilNode expr)
		{
			return f.Preceding(expr);
		}

		public QilNode FollowingSibling(QilNode expr)
		{
			return f.FollowingSibling(expr);
		}

		public QilNode PrecedingSibling(QilNode expr)
		{
			return f.PrecedingSibling(expr);
		}

		public QilNode NodeRange(QilNode left, QilNode right)
		{
			return f.NodeRange(left, right);
		}

		public QilBinary Deref(QilNode context, QilNode id)
		{
			return f.Deref(context, id);
		}

		public QilNode ElementCtor(QilNode name, QilNode content)
		{
			return f.ElementCtor(name, content);
		}

		public QilNode AttributeCtor(QilNode name, QilNode val)
		{
			return f.AttributeCtor(name, val);
		}

		public QilNode CommentCtor(QilNode content)
		{
			return f.CommentCtor(content);
		}

		public QilNode PICtor(QilNode name, QilNode content)
		{
			return f.PICtor(name, content);
		}

		public QilNode TextCtor(QilNode content)
		{
			return f.TextCtor(content);
		}

		public QilNode RawTextCtor(QilNode content)
		{
			return f.RawTextCtor(content);
		}

		public QilNode DocumentCtor(QilNode child)
		{
			return f.DocumentCtor(child);
		}

		public QilNode NamespaceDecl(QilNode prefix, QilNode uri)
		{
			return f.NamespaceDecl(prefix, uri);
		}

		public QilNode RtfCtor(QilNode content, QilNode baseUri)
		{
			return f.RtfCtor(content, baseUri);
		}

		public QilNode NameOf(QilNode expr)
		{
			return f.NameOf(expr);
		}

		public QilNode LocalNameOf(QilNode expr)
		{
			return f.LocalNameOf(expr);
		}

		public QilNode NamespaceUriOf(QilNode expr)
		{
			return f.NamespaceUriOf(expr);
		}

		public QilNode PrefixOf(QilNode expr)
		{
			return f.PrefixOf(expr);
		}

		public QilNode TypeAssert(QilNode expr, XmlQueryType t)
		{
			return f.TypeAssert(expr, t);
		}

		public QilNode IsType(QilNode expr, XmlQueryType t)
		{
			return f.IsType(expr, t);
		}

		public QilNode IsEmpty(QilNode set)
		{
			return f.IsEmpty(set);
		}

		public QilNode XPathNodeValue(QilNode expr)
		{
			return f.XPathNodeValue(expr);
		}

		public QilNode XPathFollowing(QilNode expr)
		{
			return f.XPathFollowing(expr);
		}

		public QilNode XPathNamespace(QilNode expr)
		{
			return f.XPathNamespace(expr);
		}

		public QilNode XPathPreceding(QilNode expr)
		{
			return f.XPathPreceding(expr);
		}

		public QilNode XsltGenerateId(QilNode expr)
		{
			return f.XsltGenerateId(expr);
		}

		public QilNode XsltInvokeEarlyBound(QilNode name, MethodInfo d, XmlQueryType t, IList<QilNode> args)
		{
			QilList qilList = f.ActualParameterList();
			qilList.Add(args);
			return f.XsltInvokeEarlyBound(name, f.LiteralObject(d), qilList, t);
		}

		public QilNode XsltInvokeLateBound(QilNode name, IList<QilNode> args)
		{
			QilList qilList = f.ActualParameterList();
			qilList.Add(args);
			return f.XsltInvokeLateBound(name, qilList);
		}

		public QilNode XsltCopy(QilNode expr, QilNode content)
		{
			return f.XsltCopy(expr, content);
		}

		public QilNode XsltCopyOf(QilNode expr)
		{
			return f.XsltCopyOf(expr);
		}

		public QilNode XsltConvert(QilNode expr, XmlQueryType t)
		{
			return f.XsltConvert(expr, t);
		}
	}
	internal abstract class QilPatternVisitor : QilReplaceVisitor
	{
		internal sealed class QilPatterns
		{
			private BitArray bits;

			private QilPatterns(QilPatterns toCopy)
			{
				bits = new BitArray(toCopy.bits);
			}

			public QilPatterns(int szBits, bool allSet)
			{
				bits = new BitArray(szBits, allSet);
			}

			public QilPatterns Clone()
			{
				return new QilPatterns(this);
			}

			public void ClearAll()
			{
				bits.SetAll(value: false);
			}

			public void Add(int i)
			{
				bits.Set(i, value: true);
			}

			public bool IsSet(int i)
			{
				return bits[i];
			}
		}

		private QilPatterns patterns;

		private int replacementCnt;

		private int lastReplacement;

		private int threshold = int.MaxValue;

		public QilPatterns Patterns
		{
			get
			{
				return patterns;
			}
			set
			{
				patterns = value;
			}
		}

		public int Threshold
		{
			get
			{
				return threshold;
			}
			set
			{
				threshold = value;
			}
		}

		public int ReplacementCount => replacementCnt;

		public int LastReplacement => lastReplacement;

		public bool Matching => ReplacementCount < Threshold;

		public QilPatternVisitor(QilPatterns patterns, QilFactory f)
			: base(f)
		{
			Patterns = patterns;
		}

		protected virtual bool AllowReplace(int pattern, QilNode original)
		{
			if (Matching)
			{
				replacementCnt++;
				lastReplacement = pattern;
				return true;
			}
			return false;
		}

		protected virtual QilNode Replace(int pattern, QilNode original, QilNode replacement)
		{
			replacement.SourceLine = original.SourceLine;
			return replacement;
		}

		protected virtual QilNode NoReplace(QilNode node)
		{
			return node;
		}

		protected override QilNode Visit(QilNode node)
		{
			if (node == null)
			{
				return VisitNull();
			}
			node = VisitChildren(node);
			return base.Visit(node);
		}

		protected override QilNode VisitQilExpression(QilExpression n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFunctionList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitGlobalVariableList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitGlobalParameterList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitActualParameterList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFormalParameterList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSortKeyList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitBranchList(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitOptimizeBarrier(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitUnknown(QilNode n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDataSource(QilDataSource n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNop(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitError(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitWarning(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFor(QilIterator n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitForReference(QilIterator n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLet(QilIterator n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLetReference(QilIterator n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitParameter(QilParameter n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitParameterReference(QilParameter n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitPositionOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitTrue(QilNode n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFalse(QilNode n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralString(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralInt32(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralInt64(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralDouble(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralDecimal(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralQName(QilName n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralType(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLiteralObject(QilLiteral n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAnd(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitOr(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNot(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitConditional(QilTernary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitChoice(QilChoice n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLength(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSequence(QilList n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitUnion(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitIntersection(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDifference(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAverage(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSum(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitMinimum(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitMaximum(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNegate(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAdd(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSubtract(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitMultiply(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDivide(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitModulo(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitStrLength(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitStrConcat(QilStrConcat n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitStrParseQName(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNe(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitEq(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitGt(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitGe(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLt(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLe(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitIs(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAfter(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitBefore(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLoop(QilLoop n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFilter(QilLoop n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSort(QilLoop n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitSortKey(QilSortKey n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDocOrderDistinct(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFunction(QilFunction n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFunctionReference(QilFunction n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitInvoke(QilInvoke n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitContent(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAttribute(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitParent(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitRoot(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXmlContext(QilNode n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDescendant(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDescendantOrSelf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAncestor(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAncestorOrSelf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitPreceding(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitFollowingSibling(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitPrecedingSibling(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNodeRange(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDeref(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitElementCtor(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitAttributeCtor(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitCommentCtor(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitPICtor(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitTextCtor(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitRawTextCtor(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitDocumentCtor(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNamespaceDecl(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitRtfCtor(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNameOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitLocalNameOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitNamespaceUriOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitPrefixOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitTypeAssert(QilTargetType n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitIsType(QilTargetType n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitIsEmpty(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXPathNodeValue(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXPathFollowing(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXPathPreceding(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXPathNamespace(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltGenerateId(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltInvokeLateBound(QilInvokeLateBound n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltInvokeEarlyBound(QilInvokeEarlyBound n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltCopy(QilBinary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltCopyOf(QilUnary n)
		{
			return NoReplace(n);
		}

		protected override QilNode VisitXsltConvert(QilTargetType n)
		{
			return NoReplace(n);
		}
	}
	internal class QilReference : QilNode
	{
		private const int MaxDebugNameLength = 1000;

		private string debugName;

		public string DebugName
		{
			get
			{
				return debugName;
			}
			set
			{
				if (value.Length > 1000)
				{
					value = value.Substring(0, 1000);
				}
				debugName = value;
			}
		}

		public QilReference(QilNodeType nodeType)
			: base(nodeType)
		{
		}
	}
	internal abstract class QilReplaceVisitor : QilVisitor
	{
		protected QilFactory f;

		public QilReplaceVisitor(QilFactory f)
		{
			this.f = f;
		}

		protected override QilNode VisitChildren(QilNode parent)
		{
			XmlQueryType xmlType = parent.XmlType;
			bool flag = false;
			for (int i = 0; i < parent.Count; i++)
			{
				QilNode qilNode = parent[i];
				XmlQueryType xmlQueryType = qilNode?.XmlType;
				QilNode qilNode2 = ((!IsReference(parent, i)) ? Visit(qilNode) : VisitReference(qilNode));
				if (qilNode != qilNode2 || (qilNode2 != null && (object)xmlQueryType != qilNode2.XmlType))
				{
					flag = true;
					parent[i] = qilNode2;
				}
			}
			if (flag)
			{
				RecalculateType(parent, xmlType);
			}
			return parent;
		}

		protected virtual void RecalculateType(QilNode node, XmlQueryType oldType)
		{
			XmlQueryType xmlQueryType2 = (node.XmlType = f.TypeChecker.Check(node));
		}
	}
	internal class QilScopedVisitor : QilVisitor
	{
		protected virtual void BeginScope(QilNode node)
		{
		}

		protected virtual void EndScope(QilNode node)
		{
		}

		protected virtual void BeforeVisit(QilNode node)
		{
			switch (node.NodeType)
			{
			case QilNodeType.QilExpression:
			{
				QilExpression qilExpression = (QilExpression)node;
				foreach (QilNode globalParameter in qilExpression.GlobalParameterList)
				{
					BeginScope(globalParameter);
				}
				foreach (QilNode globalVariable in qilExpression.GlobalVariableList)
				{
					BeginScope(globalVariable);
				}
				{
					foreach (QilNode function in qilExpression.FunctionList)
					{
						BeginScope(function);
					}
					break;
				}
			}
			case QilNodeType.Function:
			{
				foreach (QilNode argument in ((QilFunction)node).Arguments)
				{
					BeginScope(argument);
				}
				break;
			}
			case QilNodeType.Loop:
			case QilNodeType.Filter:
			case QilNodeType.Sort:
				BeginScope(((QilLoop)node).Variable);
				break;
			}
		}

		protected virtual void AfterVisit(QilNode node)
		{
			switch (node.NodeType)
			{
			case QilNodeType.QilExpression:
			{
				QilExpression qilExpression = (QilExpression)node;
				foreach (QilNode function in qilExpression.FunctionList)
				{
					EndScope(function);
				}
				foreach (QilNode globalVariable in qilExpression.GlobalVariableList)
				{
					EndScope(globalVariable);
				}
				{
					foreach (QilNode globalParameter in qilExpression.GlobalParameterList)
					{
						EndScope(globalParameter);
					}
					break;
				}
			}
			case QilNodeType.Function:
			{
				foreach (QilNode argument in ((QilFunction)node).Arguments)
				{
					EndScope(argument);
				}
				break;
			}
			case QilNodeType.Loop:
			case QilNodeType.Filter:
			case QilNodeType.Sort:
				EndScope(((QilLoop)node).Variable);
				break;
			}
		}

		protected override QilNode Visit(QilNode n)
		{
			BeforeVisit(n);
			QilNode result = base.Visit(n);
			AfterVisit(n);
			return result;
		}
	}
	internal class QilSortKey : QilBinary
	{
		public QilNode Key
		{
			get
			{
				return base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilNode Collation
		{
			get
			{
				return base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilSortKey(QilNodeType nodeType, QilNode key, QilNode collation)
			: base(nodeType, key, collation)
		{
		}
	}
	internal class QilStrConcat : QilBinary
	{
		public QilNode Delimiter
		{
			get
			{
				return base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public QilNode Values
		{
			get
			{
				return base.Right;
			}
			set
			{
				base.Right = value;
			}
		}

		public QilStrConcat(QilNodeType nodeType, QilNode delimiter, QilNode values)
			: base(nodeType, delimiter, values)
		{
		}
	}
	internal class QilTargetType : QilBinary
	{
		public QilNode Source
		{
			get
			{
				return base.Left;
			}
			set
			{
				base.Left = value;
			}
		}

		public XmlQueryType TargetType
		{
			get
			{
				return (XmlQueryType)((QilLiteral)base.Right).Value;
			}
			set
			{
				((QilLiteral)base.Right).Value = value;
			}
		}

		public QilTargetType(QilNodeType nodeType, QilNode expr, QilNode targetType)
			: base(nodeType, expr, targetType)
		{
		}
	}
	internal class QilTernary : QilNode
	{
		private QilNode left;

		private QilNode center;

		private QilNode right;

		public override int Count => 3;

		public override QilNode this[int index]
		{
			get
			{
				return index switch
				{
					0 => left, 
					1 => center, 
					2 => right, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					left = value;
					break;
				case 1:
					center = value;
					break;
				case 2:
					right = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public QilNode Left
		{
			get
			{
				return left;
			}
			set
			{
				left = value;
			}
		}

		public QilNode Center
		{
			get
			{
				return center;
			}
			set
			{
				center = value;
			}
		}

		public QilNode Right
		{
			get
			{
				return right;
			}
			set
			{
				right = value;
			}
		}

		public QilTernary(QilNodeType nodeType, QilNode left, QilNode center, QilNode right)
			: base(nodeType)
		{
			this.left = left;
			this.center = center;
			this.right = right;
		}
	}
	internal class QilTypeChecker
	{
		public XmlQueryType Check(QilNode n)
		{
			return n.NodeType switch
			{
				QilNodeType.QilExpression => CheckQilExpression((QilExpression)n), 
				QilNodeType.FunctionList => CheckFunctionList((QilList)n), 
				QilNodeType.GlobalVariableList => CheckGlobalVariableList((QilList)n), 
				QilNodeType.GlobalParameterList => CheckGlobalParameterList((QilList)n), 
				QilNodeType.ActualParameterList => CheckActualParameterList((QilList)n), 
				QilNodeType.FormalParameterList => CheckFormalParameterList((QilList)n), 
				QilNodeType.SortKeyList => CheckSortKeyList((QilList)n), 
				QilNodeType.BranchList => CheckBranchList((QilList)n), 
				QilNodeType.OptimizeBarrier => CheckOptimizeBarrier((QilUnary)n), 
				QilNodeType.Unknown => CheckUnknown(n), 
				QilNodeType.DataSource => CheckDataSource((QilDataSource)n), 
				QilNodeType.Nop => CheckNop((QilUnary)n), 
				QilNodeType.Error => CheckError((QilUnary)n), 
				QilNodeType.Warning => CheckWarning((QilUnary)n), 
				QilNodeType.For => CheckFor((QilIterator)n), 
				QilNodeType.Let => CheckLet((QilIterator)n), 
				QilNodeType.Parameter => CheckParameter((QilParameter)n), 
				QilNodeType.PositionOf => CheckPositionOf((QilUnary)n), 
				QilNodeType.True => CheckTrue(n), 
				QilNodeType.False => CheckFalse(n), 
				QilNodeType.LiteralString => CheckLiteralString((QilLiteral)n), 
				QilNodeType.LiteralInt32 => CheckLiteralInt32((QilLiteral)n), 
				QilNodeType.LiteralInt64 => CheckLiteralInt64((QilLiteral)n), 
				QilNodeType.LiteralDouble => CheckLiteralDouble((QilLiteral)n), 
				QilNodeType.LiteralDecimal => CheckLiteralDecimal((QilLiteral)n), 
				QilNodeType.LiteralQName => CheckLiteralQName((QilName)n), 
				QilNodeType.LiteralType => CheckLiteralType((QilLiteral)n), 
				QilNodeType.LiteralObject => CheckLiteralObject((QilLiteral)n), 
				QilNodeType.And => CheckAnd((QilBinary)n), 
				QilNodeType.Or => CheckOr((QilBinary)n), 
				QilNodeType.Not => CheckNot((QilUnary)n), 
				QilNodeType.Conditional => CheckConditional((QilTernary)n), 
				QilNodeType.Choice => CheckChoice((QilChoice)n), 
				QilNodeType.Length => CheckLength((QilUnary)n), 
				QilNodeType.Sequence => CheckSequence((QilList)n), 
				QilNodeType.Union => CheckUnion((QilBinary)n), 
				QilNodeType.Intersection => CheckIntersection((QilBinary)n), 
				QilNodeType.Difference => CheckDifference((QilBinary)n), 
				QilNodeType.Average => CheckAverage((QilUnary)n), 
				QilNodeType.Sum => CheckSum((QilUnary)n), 
				QilNodeType.Minimum => CheckMinimum((QilUnary)n), 
				QilNodeType.Maximum => CheckMaximum((QilUnary)n), 
				QilNodeType.Negate => CheckNegate((QilUnary)n), 
				QilNodeType.Add => CheckAdd((QilBinary)n), 
				QilNodeType.Subtract => CheckSubtract((QilBinary)n), 
				QilNodeType.Multiply => CheckMultiply((QilBinary)n), 
				QilNodeType.Divide => CheckDivide((QilBinary)n), 
				QilNodeType.Modulo => CheckModulo((QilBinary)n), 
				QilNodeType.StrLength => CheckStrLength((QilUnary)n), 
				QilNodeType.StrConcat => CheckStrConcat((QilStrConcat)n), 
				QilNodeType.StrParseQName => CheckStrParseQName((QilBinary)n), 
				QilNodeType.Ne => CheckNe((QilBinary)n), 
				QilNodeType.Eq => CheckEq((QilBinary)n), 
				QilNodeType.Gt => CheckGt((QilBinary)n), 
				QilNodeType.Ge => CheckGe((QilBinary)n), 
				QilNodeType.Lt => CheckLt((QilBinary)n), 
				QilNodeType.Le => CheckLe((QilBinary)n), 
				QilNodeType.Is => CheckIs((QilBinary)n), 
				QilNodeType.After => CheckAfter((QilBinary)n), 
				QilNodeType.Before => CheckBefore((QilBinary)n), 
				QilNodeType.Loop => CheckLoop((QilLoop)n), 
				QilNodeType.Filter => CheckFilter((QilLoop)n), 
				QilNodeType.Sort => CheckSort((QilLoop)n), 
				QilNodeType.SortKey => CheckSortKey((QilSortKey)n), 
				QilNodeType.DocOrderDistinct => CheckDocOrderDistinct((QilUnary)n), 
				QilNodeType.Function => CheckFunction((QilFunction)n), 
				QilNodeType.Invoke => CheckInvoke((QilInvoke)n), 
				QilNodeType.Content => CheckContent((QilUnary)n), 
				QilNodeType.Attribute => CheckAttribute((QilBinary)n), 
				QilNodeType.Parent => CheckParent((QilUnary)n), 
				QilNodeType.Root => CheckRoot((QilUnary)n), 
				QilNodeType.XmlContext => CheckXmlContext(n), 
				QilNodeType.Descendant => CheckDescendant((QilUnary)n), 
				QilNodeType.DescendantOrSelf => CheckDescendantOrSelf((QilUnary)n), 
				QilNodeType.Ancestor => CheckAncestor((QilUnary)n), 
				QilNodeType.AncestorOrSelf => CheckAncestorOrSelf((QilUnary)n), 
				QilNodeType.Preceding => CheckPreceding((QilUnary)n), 
				QilNodeType.FollowingSibling => CheckFollowingSibling((QilUnary)n), 
				QilNodeType.PrecedingSibling => CheckPrecedingSibling((QilUnary)n), 
				QilNodeType.NodeRange => CheckNodeRange((QilBinary)n), 
				QilNodeType.Deref => CheckDeref((QilBinary)n), 
				QilNodeType.ElementCtor => CheckElementCtor((QilBinary)n), 
				QilNodeType.AttributeCtor => CheckAttributeCtor((QilBinary)n), 
				QilNodeType.CommentCtor => CheckCommentCtor((QilUnary)n), 
				QilNodeType.PICtor => CheckPICtor((QilBinary)n), 
				QilNodeType.TextCtor => CheckTextCtor((QilUnary)n), 
				QilNodeType.RawTextCtor => CheckRawTextCtor((QilUnary)n), 
				QilNodeType.DocumentCtor => CheckDocumentCtor((QilUnary)n), 
				QilNodeType.NamespaceDecl => CheckNamespaceDecl((QilBinary)n), 
				QilNodeType.RtfCtor => CheckRtfCtor((QilBinary)n), 
				QilNodeType.NameOf => CheckNameOf((QilUnary)n), 
				QilNodeType.LocalNameOf => CheckLocalNameOf((QilUnary)n), 
				QilNodeType.NamespaceUriOf => CheckNamespaceUriOf((QilUnary)n), 
				QilNodeType.PrefixOf => CheckPrefixOf((QilUnary)n), 
				QilNodeType.TypeAssert => CheckTypeAssert((QilTargetType)n), 
				QilNodeType.IsType => CheckIsType((QilTargetType)n), 
				QilNodeType.IsEmpty => CheckIsEmpty((QilUnary)n), 
				QilNodeType.XPathNodeValue => CheckXPathNodeValue((QilUnary)n), 
				QilNodeType.XPathFollowing => CheckXPathFollowing((QilUnary)n), 
				QilNodeType.XPathPreceding => CheckXPathPreceding((QilUnary)n), 
				QilNodeType.XPathNamespace => CheckXPathNamespace((QilUnary)n), 
				QilNodeType.XsltGenerateId => CheckXsltGenerateId((QilUnary)n), 
				QilNodeType.XsltInvokeLateBound => CheckXsltInvokeLateBound((QilInvokeLateBound)n), 
				QilNodeType.XsltInvokeEarlyBound => CheckXsltInvokeEarlyBound((QilInvokeEarlyBound)n), 
				QilNodeType.XsltCopy => CheckXsltCopy((QilBinary)n), 
				QilNodeType.XsltCopyOf => CheckXsltCopyOf((QilUnary)n), 
				QilNodeType.XsltConvert => CheckXsltConvert((QilTargetType)n), 
				_ => CheckUnknown(n), 
			};
		}

		public XmlQueryType CheckQilExpression(QilExpression node)
		{
			return XmlQueryTypeFactory.ItemS;
		}

		public XmlQueryType CheckFunctionList(QilList node)
		{
			foreach (QilNode item in node)
			{
			}
			return node.XmlType;
		}

		public XmlQueryType CheckGlobalVariableList(QilList node)
		{
			foreach (QilNode item in node)
			{
			}
			return node.XmlType;
		}

		public XmlQueryType CheckGlobalParameterList(QilList node)
		{
			foreach (QilNode item in node)
			{
			}
			return node.XmlType;
		}

		public XmlQueryType CheckActualParameterList(QilList node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckFormalParameterList(QilList node)
		{
			foreach (QilNode item in node)
			{
			}
			return node.XmlType;
		}

		public XmlQueryType CheckSortKeyList(QilList node)
		{
			foreach (QilNode item in node)
			{
			}
			return node.XmlType;
		}

		public XmlQueryType CheckBranchList(QilList node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckOptimizeBarrier(QilUnary node)
		{
			return node.Child.XmlType;
		}

		public XmlQueryType CheckUnknown(QilNode node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckDataSource(QilDataSource node)
		{
			return XmlQueryTypeFactory.NodeNotRtfQ;
		}

		public XmlQueryType CheckNop(QilUnary node)
		{
			return node.Child.XmlType;
		}

		public XmlQueryType CheckError(QilUnary node)
		{
			return XmlQueryTypeFactory.None;
		}

		public XmlQueryType CheckWarning(QilUnary node)
		{
			return XmlQueryTypeFactory.Empty;
		}

		public XmlQueryType CheckFor(QilIterator node)
		{
			return node.Binding.XmlType.Prime;
		}

		public XmlQueryType CheckLet(QilIterator node)
		{
			return node.Binding.XmlType;
		}

		public XmlQueryType CheckParameter(QilParameter node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckPositionOf(QilUnary node)
		{
			return XmlQueryTypeFactory.IntX;
		}

		public XmlQueryType CheckTrue(QilNode node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckFalse(QilNode node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckLiteralString(QilLiteral node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckLiteralInt32(QilLiteral node)
		{
			return XmlQueryTypeFactory.IntX;
		}

		public XmlQueryType CheckLiteralInt64(QilLiteral node)
		{
			return XmlQueryTypeFactory.IntegerX;
		}

		public XmlQueryType CheckLiteralDouble(QilLiteral node)
		{
			return XmlQueryTypeFactory.DoubleX;
		}

		public XmlQueryType CheckLiteralDecimal(QilLiteral node)
		{
			return XmlQueryTypeFactory.DecimalX;
		}

		public XmlQueryType CheckLiteralQName(QilName node)
		{
			return XmlQueryTypeFactory.QNameX;
		}

		public XmlQueryType CheckLiteralType(QilLiteral node)
		{
			return node;
		}

		public XmlQueryType CheckLiteralObject(QilLiteral node)
		{
			return XmlQueryTypeFactory.ItemS;
		}

		public XmlQueryType CheckAnd(QilBinary node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckOr(QilBinary node)
		{
			return CheckAnd(node);
		}

		public XmlQueryType CheckNot(QilUnary node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckConditional(QilTernary node)
		{
			return XmlQueryTypeFactory.Choice(node.Center.XmlType, node.Right.XmlType);
		}

		public XmlQueryType CheckChoice(QilChoice node)
		{
			return node.Branches.XmlType;
		}

		public XmlQueryType CheckLength(QilUnary node)
		{
			return XmlQueryTypeFactory.IntX;
		}

		public XmlQueryType CheckSequence(QilList node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckUnion(QilBinary node)
		{
			return DistinctType(XmlQueryTypeFactory.Sequence(node.Left.XmlType, node.Right.XmlType));
		}

		public XmlQueryType CheckIntersection(QilBinary node)
		{
			return CheckUnion(node);
		}

		public XmlQueryType CheckDifference(QilBinary node)
		{
			return XmlQueryTypeFactory.AtMost(node.Left.XmlType, node.Left.XmlType.Cardinality);
		}

		public XmlQueryType CheckAverage(QilUnary node)
		{
			XmlQueryType xmlType = node.Child.XmlType;
			return XmlQueryTypeFactory.PrimeProduct(xmlType, xmlType.MaybeEmpty ? XmlQueryCardinality.ZeroOrOne : XmlQueryCardinality.One);
		}

		public XmlQueryType CheckSum(QilUnary node)
		{
			return CheckAverage(node);
		}

		public XmlQueryType CheckMinimum(QilUnary node)
		{
			return CheckAverage(node);
		}

		public XmlQueryType CheckMaximum(QilUnary node)
		{
			return CheckAverage(node);
		}

		public XmlQueryType CheckNegate(QilUnary node)
		{
			return node.Child.XmlType;
		}

		public XmlQueryType CheckAdd(QilBinary node)
		{
			if (node.Left.XmlType.TypeCode != 0)
			{
				return node.Left.XmlType;
			}
			return node.Right.XmlType;
		}

		public XmlQueryType CheckSubtract(QilBinary node)
		{
			return CheckAdd(node);
		}

		public XmlQueryType CheckMultiply(QilBinary node)
		{
			return CheckAdd(node);
		}

		public XmlQueryType CheckDivide(QilBinary node)
		{
			return CheckAdd(node);
		}

		public XmlQueryType CheckModulo(QilBinary node)
		{
			return CheckAdd(node);
		}

		public XmlQueryType CheckStrLength(QilUnary node)
		{
			return XmlQueryTypeFactory.IntX;
		}

		public XmlQueryType CheckStrConcat(QilStrConcat node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckStrParseQName(QilBinary node)
		{
			return XmlQueryTypeFactory.QNameX;
		}

		public XmlQueryType CheckNe(QilBinary node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckEq(QilBinary node)
		{
			return CheckNe(node);
		}

		public XmlQueryType CheckGt(QilBinary node)
		{
			return CheckNe(node);
		}

		public XmlQueryType CheckGe(QilBinary node)
		{
			return CheckNe(node);
		}

		public XmlQueryType CheckLt(QilBinary node)
		{
			return CheckNe(node);
		}

		public XmlQueryType CheckLe(QilBinary node)
		{
			return CheckNe(node);
		}

		public XmlQueryType CheckIs(QilBinary node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckAfter(QilBinary node)
		{
			return CheckIs(node);
		}

		public XmlQueryType CheckBefore(QilBinary node)
		{
			return CheckIs(node);
		}

		public XmlQueryType CheckLoop(QilLoop node)
		{
			XmlQueryType xmlType = node.Body.XmlType;
			XmlQueryCardinality xmlQueryCardinality = ((node.Variable.NodeType == QilNodeType.Let) ? XmlQueryCardinality.One : node.Variable.Binding.XmlType.Cardinality);
			return XmlQueryTypeFactory.PrimeProduct(xmlType, xmlQueryCardinality * xmlType.Cardinality);
		}

		public XmlQueryType CheckFilter(QilLoop node)
		{
			XmlQueryType xmlQueryType = FindFilterType(node.Variable, node.Body);
			if (xmlQueryType != null)
			{
				return xmlQueryType;
			}
			return XmlQueryTypeFactory.AtMost(node.Variable.Binding.XmlType, node.Variable.Binding.XmlType.Cardinality);
		}

		public XmlQueryType CheckSort(QilLoop node)
		{
			XmlQueryType xmlType = node.Variable.Binding.XmlType;
			return XmlQueryTypeFactory.PrimeProduct(xmlType, xmlType.Cardinality);
		}

		public XmlQueryType CheckSortKey(QilSortKey node)
		{
			return node.Key.XmlType;
		}

		public XmlQueryType CheckDocOrderDistinct(QilUnary node)
		{
			return DistinctType(node.Child.XmlType);
		}

		public XmlQueryType CheckFunction(QilFunction node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckInvoke(QilInvoke node)
		{
			return node.Function.XmlType;
		}

		public XmlQueryType CheckContent(QilUnary node)
		{
			return XmlQueryTypeFactory.AttributeOrContentS;
		}

		public XmlQueryType CheckAttribute(QilBinary node)
		{
			return XmlQueryTypeFactory.AttributeQ;
		}

		public XmlQueryType CheckParent(QilUnary node)
		{
			return XmlQueryTypeFactory.DocumentOrElementQ;
		}

		public XmlQueryType CheckRoot(QilUnary node)
		{
			return XmlQueryTypeFactory.NodeNotRtf;
		}

		public XmlQueryType CheckXmlContext(QilNode node)
		{
			return XmlQueryTypeFactory.NodeNotRtf;
		}

		public XmlQueryType CheckDescendant(QilUnary node)
		{
			return XmlQueryTypeFactory.ContentS;
		}

		public XmlQueryType CheckDescendantOrSelf(QilUnary node)
		{
			return XmlQueryTypeFactory.Choice(node.Child.XmlType, XmlQueryTypeFactory.ContentS);
		}

		public XmlQueryType CheckAncestor(QilUnary node)
		{
			return XmlQueryTypeFactory.DocumentOrElementS;
		}

		public XmlQueryType CheckAncestorOrSelf(QilUnary node)
		{
			return XmlQueryTypeFactory.Choice(node.Child.XmlType, XmlQueryTypeFactory.DocumentOrElementS);
		}

		public XmlQueryType CheckPreceding(QilUnary node)
		{
			return XmlQueryTypeFactory.DocumentOrContentS;
		}

		public XmlQueryType CheckFollowingSibling(QilUnary node)
		{
			return XmlQueryTypeFactory.ContentS;
		}

		public XmlQueryType CheckPrecedingSibling(QilUnary node)
		{
			return XmlQueryTypeFactory.ContentS;
		}

		public XmlQueryType CheckNodeRange(QilBinary node)
		{
			return XmlQueryTypeFactory.Choice(node.Left.XmlType, XmlQueryTypeFactory.ContentS, node.Right.XmlType);
		}

		public XmlQueryType CheckDeref(QilBinary node)
		{
			return XmlQueryTypeFactory.ElementS;
		}

		public XmlQueryType CheckElementCtor(QilBinary node)
		{
			return XmlQueryTypeFactory.UntypedElement;
		}

		public XmlQueryType CheckAttributeCtor(QilBinary node)
		{
			return XmlQueryTypeFactory.UntypedAttribute;
		}

		public XmlQueryType CheckCommentCtor(QilUnary node)
		{
			return XmlQueryTypeFactory.Comment;
		}

		public XmlQueryType CheckPICtor(QilBinary node)
		{
			return XmlQueryTypeFactory.PI;
		}

		public XmlQueryType CheckTextCtor(QilUnary node)
		{
			return XmlQueryTypeFactory.Text;
		}

		public XmlQueryType CheckRawTextCtor(QilUnary node)
		{
			return XmlQueryTypeFactory.Text;
		}

		public XmlQueryType CheckDocumentCtor(QilUnary node)
		{
			return XmlQueryTypeFactory.UntypedDocument;
		}

		public XmlQueryType CheckNamespaceDecl(QilBinary node)
		{
			return XmlQueryTypeFactory.Namespace;
		}

		public XmlQueryType CheckRtfCtor(QilBinary node)
		{
			return XmlQueryTypeFactory.Node;
		}

		public XmlQueryType CheckNameOf(QilUnary node)
		{
			return XmlQueryTypeFactory.QNameX;
		}

		public XmlQueryType CheckLocalNameOf(QilUnary node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckNamespaceUriOf(QilUnary node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckPrefixOf(QilUnary node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckDeepCopy(QilUnary node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckTypeAssert(QilTargetType node)
		{
			return node.TargetType;
		}

		public XmlQueryType CheckIsType(QilTargetType node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckIsEmpty(QilUnary node)
		{
			return XmlQueryTypeFactory.BooleanX;
		}

		public XmlQueryType CheckXPathNodeValue(QilUnary node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckXPathFollowing(QilUnary node)
		{
			return XmlQueryTypeFactory.ContentS;
		}

		public XmlQueryType CheckXPathPreceding(QilUnary node)
		{
			return XmlQueryTypeFactory.ContentS;
		}

		public XmlQueryType CheckXPathNamespace(QilUnary node)
		{
			return XmlQueryTypeFactory.NamespaceS;
		}

		public XmlQueryType CheckXsltGenerateId(QilUnary node)
		{
			return XmlQueryTypeFactory.StringX;
		}

		public XmlQueryType CheckXsltInvokeLateBound(QilInvokeLateBound node)
		{
			return XmlQueryTypeFactory.ItemS;
		}

		public XmlQueryType CheckXsltInvokeEarlyBound(QilInvokeEarlyBound node)
		{
			return node.XmlType;
		}

		public XmlQueryType CheckXsltCopy(QilBinary node)
		{
			return XmlQueryTypeFactory.Choice(node.Left.XmlType, node.Right.XmlType);
		}

		public XmlQueryType CheckXsltCopyOf(QilUnary node)
		{
			if ((node.Child.XmlType.NodeKinds & XmlNodeKindFlags.Document) != 0)
			{
				return XmlQueryTypeFactory.NodeNotRtfS;
			}
			return node.Child.XmlType;
		}

		public XmlQueryType CheckXsltConvert(QilTargetType node)
		{
			return node.TargetType;
		}

		[Conditional("DEBUG")]
		private void Check(bool value, QilNode node, string message)
		{
		}

		[Conditional("DEBUG")]
		private void CheckLiteralValue(QilNode node, Type clrTypeValue)
		{
			Type type = ((QilLiteral)node).Value.GetType();
		}

		[Conditional("DEBUG")]
		private void CheckClass(QilNode node, Type clrTypeClass)
		{
		}

		[Conditional("DEBUG")]
		private void CheckClassAndNodeType(QilNode node, Type clrTypeClass, QilNodeType nodeType)
		{
		}

		[Conditional("DEBUG")]
		private void CheckXmlType(QilNode node, XmlQueryType xmlType)
		{
		}

		[Conditional("DEBUG")]
		private void CheckNumericX(QilNode node)
		{
		}

		[Conditional("DEBUG")]
		private void CheckNumericXS(QilNode node)
		{
		}

		[Conditional("DEBUG")]
		private void CheckAtomicX(QilNode node)
		{
		}

		[Conditional("DEBUG")]
		private void CheckNotDisjoint(QilBinary node)
		{
		}

		private XmlQueryType DistinctType(XmlQueryType type)
		{
			if (type.Cardinality == XmlQueryCardinality.More)
			{
				return XmlQueryTypeFactory.PrimeProduct(type, XmlQueryCardinality.OneOrMore);
			}
			if (type.Cardinality == XmlQueryCardinality.NotOne)
			{
				return XmlQueryTypeFactory.PrimeProduct(type, XmlQueryCardinality.ZeroOrMore);
			}
			return type;
		}

		private XmlQueryType FindFilterType(QilIterator variable, QilNode body)
		{
			if (body.XmlType.TypeCode == XmlTypeCode.None)
			{
				return XmlQueryTypeFactory.None;
			}
			switch (body.NodeType)
			{
			case QilNodeType.False:
				return XmlQueryTypeFactory.Empty;
			case QilNodeType.IsType:
				if (((QilTargetType)body).Source == variable)
				{
					return XmlQueryTypeFactory.AtMost(((QilTargetType)body).TargetType, variable.Binding.XmlType.Cardinality);
				}
				break;
			case QilNodeType.And:
			{
				XmlQueryType xmlQueryType = FindFilterType(variable, ((QilBinary)body).Left);
				if (xmlQueryType != null)
				{
					return xmlQueryType;
				}
				return FindFilterType(variable, ((QilBinary)body).Right);
			}
			case QilNodeType.Eq:
			{
				QilBinary qilBinary = (QilBinary)body;
				if (qilBinary.Left.NodeType == QilNodeType.PositionOf && ((QilUnary)qilBinary.Left).Child == variable)
				{
					return XmlQueryTypeFactory.AtMost(variable.Binding.XmlType, XmlQueryCardinality.ZeroOrOne);
				}
				break;
			}
			}
			return null;
		}
	}
	internal class QilUnary : QilNode
	{
		private QilNode child;

		public override int Count => 1;

		public override QilNode this[int index]
		{
			get
			{
				if (index != 0)
				{
					throw new IndexOutOfRangeException();
				}
				return child;
			}
			set
			{
				if (index != 0)
				{
					throw new IndexOutOfRangeException();
				}
				child = value;
			}
		}

		public QilNode Child
		{
			get
			{
				return child;
			}
			set
			{
				child = value;
			}
		}

		public QilUnary(QilNodeType nodeType, QilNode child)
			: base(nodeType)
		{
			this.child = child;
		}
	}
	internal class QilValidationVisitor : QilScopedVisitor
	{
		private SubstitutionList subs = new SubstitutionList();

		private QilTypeChecker typeCheck = new QilTypeChecker();

		[Conditional("DEBUG")]
		public static void Validate(QilNode node)
		{
			new QilValidationVisitor().VisitAssumeReference(node);
		}

		protected QilValidationVisitor()
		{
		}

		[Conditional("DEBUG")]
		internal static void SetError(QilNode n, string message)
		{
			message = System.Xml.Utils.Res.GetString("Qil_Validation", message);
			if (n.Annotation is string text)
			{
				message = text + "\n" + message;
			}
			n.Annotation = message;
		}
	}
	internal abstract class QilVisitor
	{
		protected virtual QilNode VisitAssumeReference(QilNode expr)
		{
			if (expr is QilReference)
			{
				return VisitReference(expr);
			}
			return Visit(expr);
		}

		protected virtual QilNode VisitChildren(QilNode parent)
		{
			for (int i = 0; i < parent.Count; i++)
			{
				if (IsReference(parent, i))
				{
					VisitReference(parent[i]);
				}
				else
				{
					Visit(parent[i]);
				}
			}
			return parent;
		}

		protected virtual bool IsReference(QilNode parent, int childNum)
		{
			QilNode qilNode = parent[childNum];
			if (qilNode != null)
			{
				switch (qilNode.NodeType)
				{
				case QilNodeType.For:
				case QilNodeType.Let:
				case QilNodeType.Parameter:
					switch (parent.NodeType)
					{
					case QilNodeType.Loop:
					case QilNodeType.Filter:
					case QilNodeType.Sort:
						return childNum == 1;
					case QilNodeType.GlobalVariableList:
					case QilNodeType.GlobalParameterList:
					case QilNodeType.FormalParameterList:
						return false;
					default:
						return true;
					}
				case QilNodeType.Function:
					return parent.NodeType == QilNodeType.Invoke;
				}
			}
			return false;
		}

		protected virtual QilNode Visit(QilNode n)
		{
			if (n == null)
			{
				return VisitNull();
			}
			return n.NodeType switch
			{
				QilNodeType.QilExpression => VisitQilExpression((QilExpression)n), 
				QilNodeType.FunctionList => VisitFunctionList((QilList)n), 
				QilNodeType.GlobalVariableList => VisitGlobalVariableList((QilList)n), 
				QilNodeType.GlobalParameterList => VisitGlobalParameterList((QilList)n), 
				QilNodeType.ActualParameterList => VisitActualParameterList((QilList)n), 
				QilNodeType.FormalParameterList => VisitFormalParameterList((QilList)n), 
				QilNodeType.SortKeyList => VisitSortKeyList((QilList)n), 
				QilNodeType.BranchList => VisitBranchList((QilList)n), 
				QilNodeType.OptimizeBarrier => VisitOptimizeBarrier((QilUnary)n), 
				QilNodeType.Unknown => VisitUnknown(n), 
				QilNodeType.DataSource => VisitDataSource((QilDataSource)n), 
				QilNodeType.Nop => VisitNop((QilUnary)n), 
				QilNodeType.Error => VisitError((QilUnary)n), 
				QilNodeType.Warning => VisitWarning((QilUnary)n), 
				QilNodeType.For => VisitFor((QilIterator)n), 
				QilNodeType.Let => VisitLet((QilIterator)n), 
				QilNodeType.Parameter => VisitParameter((QilParameter)n), 
				QilNodeType.PositionOf => VisitPositionOf((QilUnary)n), 
				QilNodeType.True => VisitTrue(n), 
				QilNodeType.False => VisitFalse(n), 
				QilNodeType.LiteralString => VisitLiteralString((QilLiteral)n), 
				QilNodeType.LiteralInt32 => VisitLiteralInt32((QilLiteral)n), 
				QilNodeType.LiteralInt64 => VisitLiteralInt64((QilLiteral)n), 
				QilNodeType.LiteralDouble => VisitLiteralDouble((QilLiteral)n), 
				QilNodeType.LiteralDecimal => VisitLiteralDecimal((QilLiteral)n), 
				QilNodeType.LiteralQName => VisitLiteralQName((QilName)n), 
				QilNodeType.LiteralType => VisitLiteralType((QilLiteral)n), 
				QilNodeType.LiteralObject => VisitLiteralObject((QilLiteral)n), 
				QilNodeType.And => VisitAnd((QilBinary)n), 
				QilNodeType.Or => VisitOr((QilBinary)n), 
				QilNodeType.Not => VisitNot((QilUnary)n), 
				QilNodeType.Conditional => VisitConditional((QilTernary)n), 
				QilNodeType.Choice => VisitChoice((QilChoice)n), 
				QilNodeType.Length => VisitLength((QilUnary)n), 
				QilNodeType.Sequence => VisitSequence((QilList)n), 
				QilNodeType.Union => VisitUnion((QilBinary)n), 
				QilNodeType.Intersection => VisitIntersection((QilBinary)n), 
				QilNodeType.Difference => VisitDifference((QilBinary)n), 
				QilNodeType.Average => VisitAverage((QilUnary)n), 
				QilNodeType.Sum => VisitSum((QilUnary)n), 
				QilNodeType.Minimum => VisitMinimum((QilUnary)n), 
				QilNodeType.Maximum => VisitMaximum((QilUnary)n), 
				QilNodeType.Negate => VisitNegate((QilUnary)n), 
				QilNodeType.Add => VisitAdd((QilBinary)n), 
				QilNodeType.Subtract => VisitSubtract((QilBinary)n), 
				QilNodeType.Multiply => VisitMultiply((QilBinary)n), 
				QilNodeType.Divide => VisitDivide((QilBinary)n), 
				QilNodeType.Modulo => VisitModulo((QilBinary)n), 
				QilNodeType.StrLength => VisitStrLength((QilUnary)n), 
				QilNodeType.StrConcat => VisitStrConcat((QilStrConcat)n), 
				QilNodeType.StrParseQName => VisitStrParseQName((QilBinary)n), 
				QilNodeType.Ne => VisitNe((QilBinary)n), 
				QilNodeType.Eq => VisitEq((QilBinary)n), 
				QilNodeType.Gt => VisitGt((QilBinary)n), 
				QilNodeType.Ge => VisitGe((QilBinary)n), 
				QilNodeType.Lt => VisitLt((QilBinary)n), 
				QilNodeType.Le => VisitLe((QilBinary)n), 
				QilNodeType.Is => VisitIs((QilBinary)n), 
				QilNodeType.After => VisitAfter((QilBinary)n), 
				QilNodeType.Before => VisitBefore((QilBinary)n), 
				QilNodeType.Loop => VisitLoop((QilLoop)n), 
				QilNodeType.Filter => VisitFilter((QilLoop)n), 
				QilNodeType.Sort => VisitSort((QilLoop)n), 
				QilNodeType.SortKey => VisitSortKey((QilSortKey)n), 
				QilNodeType.DocOrderDistinct => VisitDocOrderDistinct((QilUnary)n), 
				QilNodeType.Function => VisitFunction((QilFunction)n), 
				QilNodeType.Invoke => VisitInvoke((QilInvoke)n), 
				QilNodeType.Content => VisitContent((QilUnary)n), 
				QilNodeType.Attribute => VisitAttribute((QilBinary)n), 
				QilNodeType.Parent => VisitParent((QilUnary)n), 
				QilNodeType.Root => VisitRoot((QilUnary)n), 
				QilNodeType.XmlContext => VisitXmlContext(n), 
				QilNodeType.Descendant => VisitDescendant((QilUnary)n), 
				QilNodeType.DescendantOrSelf => VisitDescendantOrSelf((QilUnary)n), 
				QilNodeType.Ancestor => VisitAncestor((QilUnary)n), 
				QilNodeType.AncestorOrSelf => VisitAncestorOrSelf((QilUnary)n), 
				QilNodeType.Preceding => VisitPreceding((QilUnary)n), 
				QilNodeType.FollowingSibling => VisitFollowingSibling((QilUnary)n), 
				QilNodeType.PrecedingSibling => VisitPrecedingSibling((QilUnary)n), 
				QilNodeType.NodeRange => VisitNodeRange((QilBinary)n), 
				QilNodeType.Deref => VisitDeref((QilBinary)n), 
				QilNodeType.ElementCtor => VisitElementCtor((QilBinary)n), 
				QilNodeType.AttributeCtor => VisitAttributeCtor((QilBinary)n), 
				QilNodeType.CommentCtor => VisitCommentCtor((QilUnary)n), 
				QilNodeType.PICtor => VisitPICtor((QilBinary)n), 
				QilNodeType.TextCtor => VisitTextCtor((QilUnary)n), 
				QilNodeType.RawTextCtor => VisitRawTextCtor((QilUnary)n), 
				QilNodeType.DocumentCtor => VisitDocumentCtor((QilUnary)n), 
				QilNodeType.NamespaceDecl => VisitNamespaceDecl((QilBinary)n), 
				QilNodeType.RtfCtor => VisitRtfCtor((QilBinary)n), 
				QilNodeType.NameOf => VisitNameOf((QilUnary)n), 
				QilNodeType.LocalNameOf => VisitLocalNameOf((QilUnary)n), 
				QilNodeType.NamespaceUriOf => VisitNamespaceUriOf((QilUnary)n), 
				QilNodeType.PrefixOf => VisitPrefixOf((QilUnary)n), 
				QilNodeType.TypeAssert => VisitTypeAssert((QilTargetType)n), 
				QilNodeType.IsType => VisitIsType((QilTargetType)n), 
				QilNodeType.IsEmpty => VisitIsEmpty((QilUnary)n), 
				QilNodeType.XPathNodeValue => VisitXPathNodeValue((QilUnary)n), 
				QilNodeType.XPathFollowing => VisitXPathFollowing((QilUnary)n), 
				QilNodeType.XPathPreceding => VisitXPathPreceding((QilUnary)n), 
				QilNodeType.XPathNamespace => VisitXPathNamespace((QilUnary)n), 
				QilNodeType.XsltGenerateId => VisitXsltGenerateId((QilUnary)n), 
				QilNodeType.XsltInvokeLateBound => VisitXsltInvokeLateBound((QilInvokeLateBound)n), 
				QilNodeType.XsltInvokeEarlyBound => VisitXsltInvokeEarlyBound((QilInvokeEarlyBound)n), 
				QilNodeType.XsltCopy => VisitXsltCopy((QilBinary)n), 
				QilNodeType.XsltCopyOf => VisitXsltCopyOf((QilUnary)n), 
				QilNodeType.XsltConvert => VisitXsltConvert((QilTargetType)n), 
				_ => VisitUnknown(n), 
			};
		}

		protected virtual QilNode VisitReference(QilNode n)
		{
			if (n == null)
			{
				return VisitNull();
			}
			return n.NodeType switch
			{
				QilNodeType.For => VisitForReference((QilIterator)n), 
				QilNodeType.Let => VisitLetReference((QilIterator)n), 
				QilNodeType.Parameter => VisitParameterReference((QilParameter)n), 
				QilNodeType.Function => VisitFunctionReference((QilFunction)n), 
				_ => VisitUnknown(n), 
			};
		}

		protected virtual QilNode VisitNull()
		{
			return null;
		}

		protected virtual QilNode VisitQilExpression(QilExpression n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFunctionList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitGlobalVariableList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitGlobalParameterList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitActualParameterList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFormalParameterList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSortKeyList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitBranchList(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitOptimizeBarrier(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitUnknown(QilNode n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDataSource(QilDataSource n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNop(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitError(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitWarning(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFor(QilIterator n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitForReference(QilIterator n)
		{
			return n;
		}

		protected virtual QilNode VisitLet(QilIterator n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLetReference(QilIterator n)
		{
			return n;
		}

		protected virtual QilNode VisitParameter(QilParameter n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitParameterReference(QilParameter n)
		{
			return n;
		}

		protected virtual QilNode VisitPositionOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitTrue(QilNode n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFalse(QilNode n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralString(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralInt32(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralInt64(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralDouble(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralDecimal(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralQName(QilName n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralType(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLiteralObject(QilLiteral n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAnd(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitOr(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNot(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitConditional(QilTernary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitChoice(QilChoice n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLength(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSequence(QilList n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitUnion(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitIntersection(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDifference(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAverage(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSum(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitMinimum(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitMaximum(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNegate(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAdd(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSubtract(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitMultiply(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDivide(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitModulo(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitStrLength(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitStrConcat(QilStrConcat n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitStrParseQName(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNe(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitEq(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitGt(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitGe(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLt(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLe(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitIs(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAfter(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitBefore(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLoop(QilLoop n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFilter(QilLoop n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSort(QilLoop n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitSortKey(QilSortKey n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDocOrderDistinct(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFunction(QilFunction n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFunctionReference(QilFunction n)
		{
			return n;
		}

		protected virtual QilNode VisitInvoke(QilInvoke n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitContent(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAttribute(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitParent(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitRoot(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXmlContext(QilNode n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDescendant(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDescendantOrSelf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAncestor(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAncestorOrSelf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitPreceding(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitFollowingSibling(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitPrecedingSibling(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNodeRange(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDeref(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitElementCtor(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitAttributeCtor(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitCommentCtor(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitPICtor(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitTextCtor(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitRawTextCtor(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitDocumentCtor(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNamespaceDecl(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitRtfCtor(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNameOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitLocalNameOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitNamespaceUriOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitPrefixOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitTypeAssert(QilTargetType n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitIsType(QilTargetType n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitIsEmpty(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXPathNodeValue(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXPathFollowing(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXPathPreceding(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXPathNamespace(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltGenerateId(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltInvokeLateBound(QilInvokeLateBound n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltInvokeEarlyBound(QilInvokeEarlyBound n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltCopy(QilBinary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltCopyOf(QilUnary n)
		{
			return VisitChildren(n);
		}

		protected virtual QilNode VisitXsltConvert(QilTargetType n)
		{
			return VisitChildren(n);
		}
	}
	internal class QilDepthChecker
	{
		private const int MAX_QIL_DEPTH = 800;

		private Dictionary<QilNode, bool> visitedRef = new Dictionary<QilNode, bool>();

		public static void Check(QilNode input)
		{
			if (XsltConfigSection.LimitXPathComplexity)
			{
				new QilDepthChecker().Check(input, 0);
			}
		}

		private void Check(QilNode input, int depth)
		{
			if (depth > 800)
			{
				throw XsltException.Create("Xslt_InputTooComplex");
			}
			if (input is QilReference)
			{
				if (visitedRef.ContainsKey(input))
				{
					return;
				}
				visitedRef[input] = true;
			}
			int depth2 = depth + 1;
			for (int i = 0; i < input.Count; i++)
			{
				QilNode qilNode = input[i];
				if (qilNode != null)
				{
					Check(qilNode, depth2);
				}
			}
		}
	}
	internal sealed class QilXmlReader
	{
		private class ReaderAnnotation
		{
			public string Id;

			public QilName Name;

			public XmlQueryType XmlType;

			public string ClrNamespace;
		}

		private static Regex lineInfoRegex;

		private static Regex typeInfoRegex;

		private static Dictionary<string, MethodInfo> nameToFactoryMethod;

		private QilFactory f;

		private XmlReader r;

		private Stack<QilList> stk;

		private bool inFwdDecls;

		private Dictionary<string, QilNode> scope;

		private Dictionary<string, QilNode> fwdDecls;

		static QilXmlReader()
		{
			lineInfoRegex = new Regex("\\[(\\d+),(\\d+) -- (\\d+),(\\d+)\\]");
			typeInfoRegex = new Regex("(\\w+);([\\w|\\|]+);(\\w+)");
			nameToFactoryMethod = new Dictionary<string, MethodInfo>();
			MethodInfo[] methods = typeof(QilFactory).GetMethods(BindingFlags.Instance | BindingFlags.Public);
			foreach (MethodInfo methodInfo in methods)
			{
				ParameterInfo[] parameters = methodInfo.GetParameters();
				int j;
				for (j = 0; j < parameters.Length && !(parameters[j].ParameterType != typeof(QilNode)); j++)
				{
				}
				if (j == parameters.Length && (!nameToFactoryMethod.ContainsKey(methodInfo.Name) || nameToFactoryMethod[methodInfo.Name].GetParameters().Length < parameters.Length))
				{
					nameToFactoryMethod[methodInfo.Name] = methodInfo;
				}
			}
		}

		public QilXmlReader(XmlReader r)
		{
			this.r = r;
			f = new QilFactory();
		}

		public QilExpression Read()
		{
			stk = new Stack<QilList>();
			inFwdDecls = false;
			scope = new Dictionary<string, QilNode>();
			fwdDecls = new Dictionary<string, QilNode>();
			stk.Push(f.Sequence());
			while (r.Read())
			{
				switch (r.NodeType)
				{
				case XmlNodeType.Element:
				{
					bool isEmptyElement = r.IsEmptyElement;
					if (StartElement() && isEmptyElement)
					{
						EndElement();
					}
					break;
				}
				case XmlNodeType.EndElement:
					EndElement();
					break;
				}
			}
			return (QilExpression)stk.Peek()[0];
		}

		private bool StartElement()
		{
			ReaderAnnotation readerAnnotation = new ReaderAnnotation();
			string localName = r.LocalName;
			QilNode qilNode;
			switch (r.LocalName)
			{
			case "LiteralString":
				qilNode = f.LiteralString(ReadText());
				break;
			case "LiteralInt32":
				qilNode = f.LiteralInt32(int.Parse(ReadText(), CultureInfo.InvariantCulture));
				break;
			case "LiteralInt64":
				qilNode = f.LiteralInt64(long.Parse(ReadText(), CultureInfo.InvariantCulture));
				break;
			case "LiteralDouble":
				qilNode = f.LiteralDouble(double.Parse(ReadText(), CultureInfo.InvariantCulture));
				break;
			case "LiteralDecimal":
				qilNode = f.LiteralDecimal(decimal.Parse(ReadText(), CultureInfo.InvariantCulture));
				break;
			case "LiteralType":
				qilNode = f.LiteralType(ParseType(ReadText()));
				break;
			case "LiteralQName":
				qilNode = ParseName(r.GetAttribute("name"));
				break;
			case "For":
			case "Let":
			case "Parameter":
			case "Function":
			case "RefTo":
				readerAnnotation.Id = r.GetAttribute("id");
				readerAnnotation.Name = ParseName(r.GetAttribute("name"));
				goto default;
			case "XsltInvokeEarlyBound":
				readerAnnotation.ClrNamespace = r.GetAttribute("clrNamespace");
				goto default;
			case "ForwardDecls":
				inFwdDecls = true;
				goto default;
			default:
				qilNode = f.Sequence();
				break;
			}
			readerAnnotation.XmlType = ParseType(r.GetAttribute("xmlType"));
			qilNode.SourceLine = ParseLineInfo(r.GetAttribute("lineInfo"));
			qilNode.Annotation = readerAnnotation;
			if (qilNode is QilList)
			{
				stk.Push((QilList)qilNode);
				return true;
			}
			stk.Peek().Add(qilNode);
			return false;
		}

		private void EndElement()
		{
			MethodInfo methodInfo = null;
			QilList qilList = stk.Pop();
			ReaderAnnotation readerAnnotation = (ReaderAnnotation)qilList.Annotation;
			string localName = r.LocalName;
			QilNode qilNode;
			switch (r.LocalName)
			{
			case "QilExpression":
			{
				QilExpression qilExpression = f.QilExpression(qilList[qilList.Count - 1]);
				for (int k = 0; k < qilList.Count - 1; k++)
				{
					switch (qilList[k].NodeType)
					{
					case QilNodeType.True:
					case QilNodeType.False:
						qilExpression.IsDebug = qilList[k].NodeType == QilNodeType.True;
						break;
					case QilNodeType.FunctionList:
						qilExpression.FunctionList = (QilList)qilList[k];
						break;
					case QilNodeType.GlobalVariableList:
						qilExpression.GlobalVariableList = (QilList)qilList[k];
						break;
					case QilNodeType.GlobalParameterList:
						qilExpression.GlobalParameterList = (QilList)qilList[k];
						break;
					}
				}
				qilNode = qilExpression;
				break;
			}
			case "ForwardDecls":
				inFwdDecls = false;
				return;
			case "Parameter":
			case "Let":
			case "For":
			case "Function":
			{
				string id2 = readerAnnotation.Id;
				QilName name = readerAnnotation.Name;
				qilNode = r.LocalName switch
				{
					"Parameter" => (!inFwdDecls && qilList.Count != 0) ? f.Parameter(qilList[0], name, readerAnnotation.XmlType) : f.Parameter(null, name, readerAnnotation.XmlType), 
					"Let" => (!inFwdDecls) ? f.Let(qilList[0]) : f.Let(f.Unknown(readerAnnotation.XmlType)), 
					"For" => f.For(qilList[0]), 
					_ => (!inFwdDecls) ? f.Function(qilList[0], qilList[1], qilList[2], (readerAnnotation.XmlType != null) ? readerAnnotation.XmlType : qilList[1].XmlType) : f.Function(qilList[0], qilList[1], readerAnnotation.XmlType), 
				};
				if (name != null)
				{
					((QilReference)qilNode).DebugName = name.ToString();
				}
				if (inFwdDecls)
				{
					fwdDecls[id2] = qilNode;
					scope[id2] = qilNode;
				}
				else if (fwdDecls.ContainsKey(id2))
				{
					qilNode = fwdDecls[id2];
					fwdDecls.Remove(id2);
					if (qilList.Count > 0)
					{
						qilNode[0] = qilList[0];
					}
					if (qilList.Count > 1)
					{
						qilNode[1] = qilList[1];
					}
				}
				else
				{
					scope[id2] = qilNode;
				}
				qilNode.Annotation = readerAnnotation;
				break;
			}
			case "RefTo":
			{
				string id = readerAnnotation.Id;
				stk.Peek().Add(scope[id]);
				return;
			}
			case "Sequence":
				qilNode = f.Sequence(qilList);
				break;
			case "FunctionList":
				qilNode = f.FunctionList(qilList);
				break;
			case "GlobalVariableList":
				qilNode = f.GlobalVariableList(qilList);
				break;
			case "GlobalParameterList":
				qilNode = f.GlobalParameterList(qilList);
				break;
			case "ActualParameterList":
				qilNode = f.ActualParameterList(qilList);
				break;
			case "FormalParameterList":
				qilNode = f.FormalParameterList(qilList);
				break;
			case "SortKeyList":
				qilNode = f.SortKeyList(qilList);
				break;
			case "BranchList":
				qilNode = f.BranchList(qilList);
				break;
			case "XsltInvokeEarlyBound":
			{
				MethodInfo value = null;
				QilName qilName = (QilName)qilList[0];
				Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
				foreach (Assembly assembly in assemblies)
				{
					Type type = assembly.GetType(readerAnnotation.ClrNamespace);
					if (type != null)
					{
						value = type.GetMethod(qilName.LocalName);
						break;
					}
				}
				qilNode = f.XsltInvokeEarlyBound(qilName, f.LiteralObject(value), qilList[1], readerAnnotation.XmlType);
				break;
			}
			default:
			{
				methodInfo = nameToFactoryMethod[r.LocalName];
				object[] array = new object[qilList.Count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = qilList[i];
				}
				qilNode = (QilNode)methodInfo.Invoke(f, array);
				break;
			}
			}
			qilNode.SourceLine = qilList.SourceLine;
			stk.Peek().Add(qilNode);
		}

		private string ReadText()
		{
			string text = string.Empty;
			if (!r.IsEmptyElement)
			{
				while (r.Read())
				{
					XmlNodeType nodeType = r.NodeType;
					if (nodeType != XmlNodeType.Text && (uint)(nodeType - 13) > 1u)
					{
						break;
					}
					text += r.Value;
				}
			}
			return text;
		}

		private ISourceLineInfo ParseLineInfo(string s)
		{
			if (s != null && s.Length > 0)
			{
				Match match = lineInfoRegex.Match(s);
				return new SourceLineInfo("", int.Parse(match.Groups[1].Value, CultureInfo.InvariantCulture), int.Parse(match.Groups[2].Value, CultureInfo.InvariantCulture), int.Parse(match.Groups[3].Value, CultureInfo.InvariantCulture), int.Parse(match.Groups[4].Value, CultureInfo.InvariantCulture));
			}
			return null;
		}

		private XmlQueryType ParseType(string s)
		{
			if (s != null && s.Length > 0)
			{
				Match match = typeInfoRegex.Match(s);
				XmlQueryCardinality c = new XmlQueryCardinality(match.Groups[1].Value);
				bool isStrict = bool.Parse(match.Groups[3].Value);
				string[] array = match.Groups[2].Value.Split('|');
				XmlQueryType[] array2 = new XmlQueryType[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array2[i] = XmlQueryTypeFactory.Type((XmlTypeCode)Enum.Parse(typeof(XmlTypeCode), array[i]), isStrict);
				}
				return XmlQueryTypeFactory.Product(XmlQueryTypeFactory.Choice(array2), c);
			}
			return null;
		}

		private QilName ParseName(string name)
		{
			if (name != null && name.Length > 0)
			{
				int num = name.LastIndexOf('}');
				string namespaceUri;
				if (num != -1 && name[0] == '{')
				{
					namespaceUri = name.Substring(1, num - 1);
					name = name.Substring(num + 1);
				}
				else
				{
					namespaceUri = string.Empty;
				}
				ValidateNames.ParseQNameThrow(name, out var prefix, out var localName);
				return f.LiteralQName(localName, namespaceUri, prefix);
			}
			return null;
		}
	}
	internal interface IQilAnnotation
	{
		string Name { get; }
	}
	internal class QilXmlWriter : QilScopedVisitor
	{
		[Flags]
		public enum Options
		{
			None = 0,
			Annotations = 1,
			TypeInfo = 2,
			RoundTripTypeInfo = 4,
			LineInfo = 8,
			NodeIdentity = 0x10,
			NodeLocation = 0x20
		}

		internal class ForwardRefFinder : QilVisitor
		{
			private List<QilNode> fwdrefs = new List<QilNode>();

			private List<QilNode> backrefs = new List<QilNode>();

			public IList<QilNode> Find(QilExpression qil)
			{
				Visit(qil);
				return fwdrefs;
			}

			protected override QilNode Visit(QilNode node)
			{
				if (node is QilIterator || node is QilFunction)
				{
					backrefs.Add(node);
				}
				return base.Visit(node);
			}

			protected override QilNode VisitReference(QilNode node)
			{
				if (!backrefs.Contains(node) && !fwdrefs.Contains(node))
				{
					fwdrefs.Add(node);
				}
				return node;
			}
		}

		private sealed class NameGenerator
		{
			private class NameAnnotation : ListBase<object>
			{
				public string Name;

				public object PriorAnnotation;

				public override int Count => 1;

				public override object this[int index]
				{
					get
					{
						if (index == 0)
						{
							return PriorAnnotation;
						}
						throw new IndexOutOfRangeException();
					}
					set
					{
						throw new NotSupportedException();
					}
				}

				public NameAnnotation(string s, object a)
				{
					Name = s;
					PriorAnnotation = a;
				}
			}

			private StringBuilder name;

			private int len;

			private int zero;

			private char start;

			private char end;

			public NameGenerator()
			{
				string text = "$";
				len = (zero = text.Length);
				start = 'a';
				end = 'z';
				name = new StringBuilder(text, len + 2);
				name.Append(start);
			}

			public string NextName()
			{
				string result = name.ToString();
				char c = name[len];
				if (c != end)
				{
					c = (name[len] = (char)(c + 1));
				}
				else
				{
					name[len] = start;
					int num = len;
					while (num-- > zero && name[num] == end)
					{
						name[num] = start;
					}
					if (num < zero)
					{
						len++;
						name.Append(start);
					}
					else
					{
						name[num]++;
					}
				}
				return result;
			}

			public string NameOf(QilNode n)
			{
				string text = null;
				object annotation = n.Annotation;
				if (!(annotation is NameAnnotation nameAnnotation))
				{
					text = NextName();
					n.Annotation = new NameAnnotation(text, annotation);
				}
				else
				{
					text = nameAnnotation.Name;
				}
				return text;
			}

			public void ClearName(QilNode n)
			{
				if (n.Annotation is NameAnnotation)
				{
					n.Annotation = ((NameAnnotation)n.Annotation).PriorAnnotation;
				}
			}
		}

		protected XmlWriter writer;

		protected Options options;

		private NameGenerator ngen;

		public QilXmlWriter(XmlWriter writer)
			: this(writer, Options.Annotations | Options.TypeInfo | Options.LineInfo | Options.NodeIdentity | Options.NodeLocation)
		{
		}

		public QilXmlWriter(XmlWriter writer, Options options)
		{
			this.writer = writer;
			ngen = new NameGenerator();
			this.options = options;
		}

		public void ToXml(QilNode node)
		{
			VisitAssumeReference(node);
		}

		protected virtual void WriteAnnotations(object ann)
		{
			string text = null;
			string text2 = null;
			if (ann == null)
			{
				return;
			}
			if (ann is string)
			{
				text = ann as string;
			}
			else if (ann is IQilAnnotation)
			{
				IQilAnnotation qilAnnotation = ann as IQilAnnotation;
				text2 = qilAnnotation.Name;
				text = ann.ToString();
			}
			else if (ann is IList<object>)
			{
				IList<object> list = (IList<object>)ann;
				{
					foreach (object item in list)
					{
						WriteAnnotations(item);
					}
					return;
				}
			}
			if (text != null && text.Length != 0)
			{
				writer.WriteComment((text2 != null && text2.Length != 0) ? (text2 + ": " + text) : text);
			}
		}

		protected virtual void WriteLineInfo(QilNode node)
		{
			writer.WriteAttributeString("lineInfo", string.Format(CultureInfo.InvariantCulture, "[{0},{1} -- {2},{3}]", node.SourceLine.Start.Line, node.SourceLine.Start.Pos, node.SourceLine.End.Line, node.SourceLine.End.Pos));
		}

		protected virtual void WriteXmlType(QilNode node)
		{
			writer.WriteAttributeString("xmlType", node.XmlType.ToString(((options & Options.RoundTripTypeInfo) != 0) ? "S" : "G"));
		}

		protected override QilNode VisitChildren(QilNode node)
		{
			if (node is QilLiteral)
			{
				writer.WriteValue(Convert.ToString(((QilLiteral)node).Value, CultureInfo.InvariantCulture));
				return node;
			}
			if (node is QilReference)
			{
				QilReference qilReference = (QilReference)node;
				writer.WriteAttributeString("id", ngen.NameOf(node));
				if (qilReference.DebugName != null)
				{
					writer.WriteAttributeString("name", qilReference.DebugName.ToString());
				}
				if (node.NodeType == QilNodeType.Parameter)
				{
					QilParameter qilParameter = (QilParameter)node;
					if (qilParameter.DefaultValue != null)
					{
						VisitAssumeReference(qilParameter.DefaultValue);
					}
					return node;
				}
			}
			return base.VisitChildren(node);
		}

		protected override QilNode VisitReference(QilNode node)
		{
			QilReference qilReference = (QilReference)node;
			string text = ngen.NameOf(node);
			if (text == null)
			{
				text = "OUT-OF-SCOPE REFERENCE";
			}
			writer.WriteStartElement("RefTo");
			writer.WriteAttributeString("id", text);
			if (qilReference.DebugName != null)
			{
				writer.WriteAttributeString("name", qilReference.DebugName.ToString());
			}
			writer.WriteEndElement();
			return node;
		}

		protected override QilNode VisitQilExpression(QilExpression qil)
		{
			IList<QilNode> list = new ForwardRefFinder().Find(qil);
			if (list != null && list.Count > 0)
			{
				writer.WriteStartElement("ForwardDecls");
				foreach (QilNode item in list)
				{
					writer.WriteStartElement(Enum.GetName(typeof(QilNodeType), item.NodeType));
					writer.WriteAttributeString("id", ngen.NameOf(item));
					WriteXmlType(item);
					if (item.NodeType == QilNodeType.Function)
					{
						Visit(item[0]);
						Visit(item[2]);
					}
					writer.WriteEndElement();
				}
				writer.WriteEndElement();
			}
			return VisitChildren(qil);
		}

		protected override QilNode VisitLiteralType(QilLiteral value)
		{
			writer.WriteString(((XmlQueryType)value).ToString(((options & Options.TypeInfo) != 0) ? "G" : "S"));
			return value;
		}

		protected override QilNode VisitLiteralQName(QilName value)
		{
			writer.WriteAttributeString("name", value.ToString());
			return value;
		}

		protected override void BeginScope(QilNode node)
		{
			ngen.NameOf(node);
		}

		protected override void EndScope(QilNode node)
		{
			ngen.ClearName(node);
		}

		protected override void BeforeVisit(QilNode node)
		{
			base.BeforeVisit(node);
			if ((options & Options.Annotations) != 0)
			{
				WriteAnnotations(node.Annotation);
			}
			writer.WriteStartElement("", Enum.GetName(typeof(QilNodeType), node.NodeType), "");
			if ((options & (Options.TypeInfo | Options.RoundTripTypeInfo)) != 0)
			{
				WriteXmlType(node);
			}
			if ((options & Options.LineInfo) != 0 && node.SourceLine != null)
			{
				WriteLineInfo(node);
			}
		}

		protected override void AfterVisit(QilNode node)
		{
			writer.WriteEndElement();
			base.AfterVisit(node);
		}
	}
	internal enum SerializationHints
	{
		None,
		CData,
		DisableOutputEscaping
	}
	internal sealed class SubstitutionList
	{
		private ArrayList s;

		public SubstitutionList()
		{
			s = new ArrayList(4);
		}

		public void AddSubstitutionPair(QilNode find, QilNode replace)
		{
			s.Add(find);
			s.Add(replace);
		}

		public void RemoveLastSubstitutionPair()
		{
			s.RemoveRange(s.Count - 2, 2);
		}

		public void RemoveLastNSubstitutionPairs(int n)
		{
			if (n > 0)
			{
				n *= 2;
				s.RemoveRange(s.Count - n, n);
			}
		}

		public QilNode FindReplacement(QilNode n)
		{
			for (int num = s.Count - 2; num >= 0; num -= 2)
			{
				if (s[num] == n)
				{
					return (QilNode)s[num + 1];
				}
			}
			return null;
		}
	}
	internal class WhitespaceRule
	{
		private string localName;

		private string namespaceName;

		private bool preserveSpace;

		public string LocalName
		{
			get
			{
				return localName;
			}
			set
			{
				localName = value;
			}
		}

		public string NamespaceName
		{
			get
			{
				return namespaceName;
			}
			set
			{
				namespaceName = value;
			}
		}

		public bool PreserveSpace => preserveSpace;

		protected WhitespaceRule()
		{
		}

		public WhitespaceRule(string localName, string namespaceName, bool preserveSpace)
		{
			Init(localName, namespaceName, preserveSpace);
		}

		protected void Init(string localName, string namespaceName, bool preserveSpace)
		{
			this.localName = localName;
			this.namespaceName = namespaceName;
			this.preserveSpace = preserveSpace;
		}

		public void GetObjectData(XmlQueryDataWriter writer)
		{
			writer.WriteStringQ(localName);
			writer.WriteStringQ(namespaceName);
			writer.Write(preserveSpace);
		}

		public WhitespaceRule(XmlQueryDataReader reader)
		{
			localName = reader.ReadStringQ();
			namespaceName = reader.ReadStringQ();
			preserveSpace = reader.ReadBoolean();
		}
	}
}
namespace System.Xml.Xsl.IlGen
{
	internal class XmlILStorageMethods
	{
		public MethodInfo AggAvg;

		public MethodInfo AggAvgResult;

		public MethodInfo AggCreate;

		public MethodInfo AggIsEmpty;

		public MethodInfo AggMax;

		public MethodInfo AggMaxResult;

		public MethodInfo AggMin;

		public MethodInfo AggMinResult;

		public MethodInfo AggSum;

		public MethodInfo AggSumResult;

		public Type SeqType;

		public FieldInfo SeqEmpty;

		public MethodInfo SeqReuse;

		public MethodInfo SeqReuseSgl;

		public MethodInfo SeqAdd;

		public MethodInfo SeqSortByKeys;

		public Type IListType;

		public MethodInfo IListCount;

		public MethodInfo IListItem;

		public MethodInfo ValueAs;

		public MethodInfo ToAtomicValue;

		public XmlILStorageMethods(Type storageType)
		{
			if (storageType == typeof(int) || storageType == typeof(long) || storageType == typeof(decimal) || storageType == typeof(double))
			{
				Type type = Type.GetType("System.Xml.Xsl.Runtime." + storageType.Name + "Aggregator");
				AggAvg = XmlILMethods.GetMethod(type, "Average");
				AggAvgResult = XmlILMethods.GetMethod(type, "get_AverageResult");
				AggCreate = XmlILMethods.GetMethod(type, "Create");
				AggIsEmpty = XmlILMethods.GetMethod(type, "get_IsEmpty");
				AggMax = XmlILMethods.GetMethod(type, "Maximum");
				AggMaxResult = XmlILMethods.GetMethod(type, "get_MaximumResult");
				AggMin = XmlILMethods.GetMethod(type, "Minimum");
				AggMinResult = XmlILMethods.GetMethod(type, "get_MinimumResult");
				AggSum = XmlILMethods.GetMethod(type, "Sum");
				AggSumResult = XmlILMethods.GetMethod(type, "get_SumResult");
			}
			if (storageType == typeof(XPathNavigator))
			{
				SeqType = typeof(XmlQueryNodeSequence);
				SeqAdd = XmlILMethods.GetMethod(SeqType, "AddClone");
			}
			else if (storageType == typeof(XPathItem))
			{
				SeqType = typeof(XmlQueryItemSequence);
				SeqAdd = XmlILMethods.GetMethod(SeqType, "AddClone");
			}
			else
			{
				SeqType = typeof(XmlQuerySequence<>).MakeGenericType(storageType);
				SeqAdd = XmlILMethods.GetMethod(SeqType, "Add");
			}
			SeqEmpty = SeqType.GetField("Empty");
			SeqReuse = XmlILMethods.GetMethod(SeqType, "CreateOrReuse", SeqType);
			SeqReuseSgl = XmlILMethods.GetMethod(SeqType, "CreateOrReuse", SeqType, storageType);
			SeqSortByKeys = XmlILMethods.GetMethod(SeqType, "SortByKeys");
			IListType = typeof(IList<>).MakeGenericType(storageType);
			IListItem = XmlILMethods.GetMethod(IListType, "get_Item");
			IListCount = XmlILMethods.GetMethod(typeof(ICollection<>).MakeGenericType(storageType), "get_Count");
			if (storageType == typeof(string))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_Value");
			}
			else if (storageType == typeof(int))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_ValueAsInt");
			}
			else if (storageType == typeof(long))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_ValueAsLong");
			}
			else if (storageType == typeof(DateTime))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_ValueAsDateTime");
			}
			else if (storageType == typeof(double))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_ValueAsDouble");
			}
			else if (storageType == typeof(bool))
			{
				ValueAs = XmlILMethods.GetMethod(typeof(XPathItem), "get_ValueAsBoolean");
			}
			if (storageType == typeof(byte[]))
			{
				ToAtomicValue = XmlILMethods.GetMethod(typeof(XmlILStorageConverter), "BytesToAtomicValue");
			}
			else if (storageType != typeof(XPathItem) && storageType != typeof(XPathNavigator))
			{
				ToAtomicValue = XmlILMethods.GetMethod(typeof(XmlILStorageConverter), storageType.Name + "ToAtomicValue");
			}
		}
	}
	internal static class XmlILConstructors
	{
		public static readonly ConstructorInfo DecFromParts = GetConstructor(typeof(decimal), typeof(int), typeof(int), typeof(int), typeof(bool), typeof(byte));

		public static readonly ConstructorInfo DecFromInt32 = GetConstructor(typeof(decimal), typeof(int));

		public static readonly ConstructorInfo DecFromInt64 = GetConstructor(typeof(decimal), typeof(long));

		public static readonly ConstructorInfo Debuggable = GetConstructor(typeof(DebuggableAttribute), typeof(DebuggableAttribute.DebuggingModes));

		public static readonly ConstructorInfo NonUserCode = GetConstructor(typeof(DebuggerNonUserCodeAttribute));

		public static readonly ConstructorInfo QName = GetConstructor(typeof(XmlQualifiedName), typeof(string), typeof(string));

		public static readonly ConstructorInfo StepThrough = GetConstructor(typeof(DebuggerStepThroughAttribute));

		public static readonly ConstructorInfo Transparent = GetConstructor(typeof(SecurityTransparentAttribute));

		private static ConstructorInfo GetConstructor(Type className)
		{
			return className.GetConstructor(new Type[0]);
		}

		private static ConstructorInfo GetConstructor(Type className, params Type[] args)
		{
			return className.GetConstructor(args);
		}
	}
	internal static class XmlILMethods
	{
		public static readonly MethodInfo AncCreate;

		public static readonly MethodInfo AncNext;

		public static readonly MethodInfo AncDOCreate;

		public static readonly MethodInfo AncDONext;

		public static readonly MethodInfo AttrContentCreate;

		public static readonly MethodInfo AttrContentNext;

		public static readonly MethodInfo AttrCreate;

		public static readonly MethodInfo AttrNext;

		public static readonly MethodInfo ContentCreate;

		public static readonly MethodInfo ContentNext;

		public static readonly MethodInfo ContentMergeCreate;

		public static readonly MethodInfo ContentMergeNext;

		public static readonly MethodInfo DescCreate;

		public static readonly MethodInfo DescNext;

		public static readonly MethodInfo DescMergeCreate;

		public static readonly MethodInfo DescMergeNext;

		public static readonly MethodInfo DiffCreate;

		public static readonly MethodInfo DiffNext;

		public static readonly MethodInfo DodMergeCreate;

		public static readonly MethodInfo DodMergeAdd;

		public static readonly MethodInfo DodMergeSeq;

		public static readonly MethodInfo ElemContentCreate;

		public static readonly MethodInfo ElemContentNext;

		public static readonly MethodInfo FollSibCreate;

		public static readonly MethodInfo FollSibNext;

		public static readonly MethodInfo FollSibMergeCreate;

		public static readonly MethodInfo FollSibMergeNext;

		public static readonly MethodInfo IdCreate;

		public static readonly MethodInfo IdNext;

		public static readonly MethodInfo InterCreate;

		public static readonly MethodInfo InterNext;

		public static readonly MethodInfo KindContentCreate;

		public static readonly MethodInfo KindContentNext;

		public static readonly MethodInfo NmspCreate;

		public static readonly MethodInfo NmspNext;

		public static readonly MethodInfo NodeRangeCreate;

		public static readonly MethodInfo NodeRangeNext;

		public static readonly MethodInfo ParentCreate;

		public static readonly MethodInfo ParentNext;

		public static readonly MethodInfo PrecCreate;

		public static readonly MethodInfo PrecNext;

		public static readonly MethodInfo PreSibCreate;

		public static readonly MethodInfo PreSibNext;

		public static readonly MethodInfo PreSibDOCreate;

		public static readonly MethodInfo PreSibDONext;

		public static readonly MethodInfo SortKeyCreate;

		public static readonly MethodInfo SortKeyDateTime;

		public static readonly MethodInfo SortKeyDecimal;

		public static readonly MethodInfo SortKeyDouble;

		public static readonly MethodInfo SortKeyEmpty;

		public static readonly MethodInfo SortKeyFinish;

		public static readonly MethodInfo SortKeyInt;

		public static readonly MethodInfo SortKeyInteger;

		public static readonly MethodInfo SortKeyKeys;

		public static readonly MethodInfo SortKeyString;

		public static readonly MethodInfo UnionCreate;

		public static readonly MethodInfo UnionNext;

		public static readonly MethodInfo XPFollCreate;

		public static readonly MethodInfo XPFollNext;

		public static readonly MethodInfo XPFollMergeCreate;

		public static readonly MethodInfo XPFollMergeNext;

		public static readonly MethodInfo XPPrecCreate;

		public static readonly MethodInfo XPPrecNext;

		public static readonly MethodInfo XPPrecDOCreate;

		public static readonly MethodInfo XPPrecDONext;

		public static readonly MethodInfo XPPrecMergeCreate;

		public static readonly MethodInfo XPPrecMergeNext;

		public static readonly MethodInfo AddNewIndex;

		public static readonly MethodInfo ChangeTypeXsltArg;

		public static readonly MethodInfo ChangeTypeXsltResult;

		public static readonly MethodInfo CompPos;

		public static readonly MethodInfo Context;

		public static readonly MethodInfo CreateCollation;

		public static readonly MethodInfo DocOrder;

		public static readonly MethodInfo EndRtfConstr;

		public static readonly MethodInfo EndSeqConstr;

		public static readonly MethodInfo FindIndex;

		public static readonly MethodInfo GenId;

		public static readonly MethodInfo GetAtomizedName;

		public static readonly MethodInfo GetCollation;

		public static readonly MethodInfo GetEarly;

		public static readonly MethodInfo GetNameFilter;

		public static readonly MethodInfo GetOutput;

		public static readonly MethodInfo GetGlobalValue;

		public static readonly MethodInfo GetTypeFilter;

		public static readonly MethodInfo GlobalComputed;

		public static readonly MethodInfo ItemMatchesCode;

		public static readonly MethodInfo ItemMatchesType;

		public static readonly MethodInfo QNameEqualLit;

		public static readonly MethodInfo QNameEqualNav;

		public static readonly MethodInfo RtfConstr;

		public static readonly MethodInfo SendMessage;

		public static readonly MethodInfo SeqMatchesCode;

		public static readonly MethodInfo SeqMatchesType;

		public static readonly MethodInfo SetGlobalValue;

		public static readonly MethodInfo StartRtfConstr;

		public static readonly MethodInfo StartSeqConstr;

		public static readonly MethodInfo TagAndMappings;

		public static readonly MethodInfo TagAndNamespace;

		public static readonly MethodInfo ThrowException;

		public static readonly MethodInfo XsltLib;

		public static readonly MethodInfo GetDataSource;

		public static readonly MethodInfo GetDefaultDataSource;

		public static readonly MethodInfo GetParam;

		public static readonly MethodInfo InvokeXsltLate;

		public static readonly MethodInfo IndexAdd;

		public static readonly MethodInfo IndexLookup;

		public static readonly MethodInfo ItemIsNode;

		public static readonly MethodInfo Value;

		public static readonly MethodInfo ValueAsAny;

		public static readonly MethodInfo NavClone;

		public static readonly MethodInfo NavLocalName;

		public static readonly MethodInfo NavMoveAttr;

		public static readonly MethodInfo NavMoveId;

		public static readonly MethodInfo NavMoveParent;

		public static readonly MethodInfo NavMoveRoot;

		public static readonly MethodInfo NavMoveTo;

		public static readonly MethodInfo NavNmsp;

		public static readonly MethodInfo NavPrefix;

		public static readonly MethodInfo NavSamePos;

		public static readonly MethodInfo NavType;

		public static readonly MethodInfo StartElemLitName;

		public static readonly MethodInfo StartElemLocName;

		public static readonly MethodInfo EndElemStackName;

		public static readonly MethodInfo StartAttrLitName;

		public static readonly MethodInfo StartAttrLocName;

		public static readonly MethodInfo EndAttr;

		public static readonly MethodInfo Text;

		public static readonly MethodInfo NoEntText;

		public static readonly MethodInfo StartTree;

		public static readonly MethodInfo EndTree;

		public static readonly MethodInfo StartElemLitNameUn;

		public static readonly MethodInfo StartElemLocNameUn;

		public static readonly MethodInfo StartContentUn;

		public static readonly MethodInfo EndElemLitNameUn;

		public static readonly MethodInfo EndElemLocNameUn;

		public static readonly MethodInfo StartAttrLitNameUn;

		public static readonly MethodInfo StartAttrLocNameUn;

		public static readonly MethodInfo EndAttrUn;

		public static readonly MethodInfo NamespaceDeclUn;

		public static readonly MethodInfo TextUn;

		public static readonly MethodInfo NoEntTextUn;

		public static readonly MethodInfo StartRoot;

		public static readonly MethodInfo EndRoot;

		public static readonly MethodInfo StartElemCopyName;

		public static readonly MethodInfo StartElemMapName;

		public static readonly MethodInfo StartElemNmspName;

		public static readonly MethodInfo StartElemQName;

		public static readonly MethodInfo StartAttrCopyName;

		public static readonly MethodInfo StartAttrMapName;

		public static readonly MethodInfo StartAttrNmspName;

		public static readonly MethodInfo StartAttrQName;

		public static readonly MethodInfo NamespaceDecl;

		public static readonly MethodInfo StartComment;

		public static readonly MethodInfo CommentText;

		public static readonly MethodInfo EndComment;

		public static readonly MethodInfo StartPI;

		public static readonly MethodInfo PIText;

		public static readonly MethodInfo EndPI;

		public static readonly MethodInfo WriteItem;

		public static readonly MethodInfo CopyOf;

		public static readonly MethodInfo StartCopy;

		public static readonly MethodInfo EndCopy;

		public static readonly MethodInfo DecAdd;

		public static readonly MethodInfo DecCmp;

		public static readonly MethodInfo DecEq;

		public static readonly MethodInfo DecSub;

		public static readonly MethodInfo DecMul;

		public static readonly MethodInfo DecDiv;

		public static readonly MethodInfo DecRem;

		public static readonly MethodInfo DecNeg;

		public static readonly MethodInfo QNameEq;

		public static readonly MethodInfo StrEq;

		public static readonly MethodInfo StrCat2;

		public static readonly MethodInfo StrCat3;

		public static readonly MethodInfo StrCat4;

		public static readonly MethodInfo StrCmp;

		public static readonly MethodInfo StrLen;

		public static readonly MethodInfo DblToDec;

		public static readonly MethodInfo DblToInt;

		public static readonly MethodInfo DblToLng;

		public static readonly MethodInfo DblToStr;

		public static readonly MethodInfo DecToDbl;

		public static readonly MethodInfo DTToStr;

		public static readonly MethodInfo IntToDbl;

		public static readonly MethodInfo LngToDbl;

		public static readonly MethodInfo StrToDbl;

		public static readonly MethodInfo StrToDT;

		public static readonly MethodInfo ItemToBool;

		public static readonly MethodInfo ItemToDbl;

		public static readonly MethodInfo ItemToStr;

		public static readonly MethodInfo ItemToNode;

		public static readonly MethodInfo ItemToNodes;

		public static readonly MethodInfo ItemsToBool;

		public static readonly MethodInfo ItemsToDbl;

		public static readonly MethodInfo ItemsToNode;

		public static readonly MethodInfo ItemsToNodes;

		public static readonly MethodInfo ItemsToStr;

		public static readonly MethodInfo StrCatCat;

		public static readonly MethodInfo StrCatClear;

		public static readonly MethodInfo StrCatResult;

		public static readonly MethodInfo StrCatDelim;

		public static readonly MethodInfo NavsToItems;

		public static readonly MethodInfo ItemsToNavs;

		public static readonly MethodInfo SetDod;

		public static readonly MethodInfo GetTypeFromHandle;

		public static readonly MethodInfo InitializeArray;

		public static readonly Dictionary<Type, XmlILStorageMethods> StorageMethods;

		static XmlILMethods()
		{
			AncCreate = GetMethod(typeof(AncestorIterator), "Create");
			AncNext = GetMethod(typeof(AncestorIterator), "MoveNext");
			AncDOCreate = GetMethod(typeof(AncestorDocOrderIterator), "Create");
			AncDONext = GetMethod(typeof(AncestorDocOrderIterator), "MoveNext");
			AttrContentCreate = GetMethod(typeof(AttributeContentIterator), "Create");
			AttrContentNext = GetMethod(typeof(AttributeContentIterator), "MoveNext");
			AttrCreate = GetMethod(typeof(AttributeIterator), "Create");
			AttrNext = GetMethod(typeof(AttributeIterator), "MoveNext");
			ContentCreate = GetMethod(typeof(ContentIterator), "Create");
			ContentNext = GetMethod(typeof(ContentIterator), "MoveNext");
			ContentMergeCreate = GetMethod(typeof(ContentMergeIterator), "Create");
			ContentMergeNext = GetMethod(typeof(ContentMergeIterator), "MoveNext");
			DescCreate = GetMethod(typeof(DescendantIterator), "Create");
			DescNext = GetMethod(typeof(DescendantIterator), "MoveNext");
			DescMergeCreate = GetMethod(typeof(DescendantMergeIterator), "Create");
			DescMergeNext = GetMethod(typeof(DescendantMergeIterator), "MoveNext");
			DiffCreate = GetMethod(typeof(DifferenceIterator), "Create");
			DiffNext = GetMethod(typeof(DifferenceIterator), "MoveNext");
			DodMergeCreate = GetMethod(typeof(DodSequenceMerge), "Create");
			DodMergeAdd = GetMethod(typeof(DodSequenceMerge), "AddSequence");
			DodMergeSeq = GetMethod(typeof(DodSequenceMerge), "MergeSequences");
			ElemContentCreate = GetMethod(typeof(ElementContentIterator), "Create");
			ElemContentNext = GetMethod(typeof(ElementContentIterator), "MoveNext");
			FollSibCreate = GetMethod(typeof(FollowingSiblingIterator), "Create");
			FollSibNext = GetMethod(typeof(FollowingSiblingIterator), "MoveNext");
			FollSibMergeCreate = GetMethod(typeof(FollowingSiblingMergeIterator), "Create");
			FollSibMergeNext = GetMethod(typeof(FollowingSiblingMergeIterator), "MoveNext");
			IdCreate = GetMethod(typeof(IdIterator), "Create");
			IdNext = GetMethod(typeof(IdIterator), "MoveNext");
			InterCreate = GetMethod(typeof(IntersectIterator), "Create");
			InterNext = GetMethod(typeof(IntersectIterator), "MoveNext");
			KindContentCreate = GetMethod(typeof(NodeKindContentIterator), "Create");
			KindContentNext = GetMethod(typeof(NodeKindContentIterator), "MoveNext");
			NmspCreate = GetMethod(typeof(NamespaceIterator), "Create");
			NmspNext = GetMethod(typeof(NamespaceIterator), "MoveNext");
			NodeRangeCreate = GetMethod(typeof(NodeRangeIterator), "Create");
			NodeRangeNext = GetMethod(typeof(NodeRangeIterator), "MoveNext");
			ParentCreate = GetMethod(typeof(ParentIterator), "Create");
			ParentNext = GetMethod(typeof(ParentIterator), "MoveNext");
			PrecCreate = GetMethod(typeof(PrecedingIterator), "Create");
			PrecNext = GetMethod(typeof(PrecedingIterator), "MoveNext");
			PreSibCreate = GetMethod(typeof(PrecedingSiblingIterator), "Create");
			PreSibNext = GetMethod(typeof(PrecedingSiblingIterator), "MoveNext");
			PreSibDOCreate = GetMethod(typeof(PrecedingSiblingDocOrderIterator), "Create");
			PreSibDONext = GetMethod(typeof(PrecedingSiblingDocOrderIterator), "MoveNext");
			SortKeyCreate = GetMethod(typeof(XmlSortKeyAccumulator), "Create");
			SortKeyDateTime = GetMethod(typeof(XmlSortKeyAccumulator), "AddDateTimeSortKey");
			SortKeyDecimal = GetMethod(typeof(XmlSortKeyAccumulator), "AddDecimalSortKey");
			SortKeyDouble = GetMethod(typeof(XmlSortKeyAccumulator), "AddDoubleSortKey");
			SortKeyEmpty = GetMethod(typeof(XmlSortKeyAccumulator), "AddEmptySortKey");
			SortKeyFinish = GetMethod(typeof(XmlSortKeyAccumulator), "FinishSortKeys");
			SortKeyInt = GetMethod(typeof(XmlSortKeyAccumulator), "AddIntSortKey");
			SortKeyInteger = GetMethod(typeof(XmlSortKeyAccumulator), "AddIntegerSortKey");
			SortKeyKeys = GetMethod(typeof(XmlSortKeyAccumulator), "get_Keys");
			SortKeyString = GetMethod(typeof(XmlSortKeyAccumulator), "AddStringSortKey");
			UnionCreate = GetMethod(typeof(UnionIterator), "Create");
			UnionNext = GetMethod(typeof(UnionIterator), "MoveNext");
			XPFollCreate = GetMethod(typeof(XPathFollowingIterator), "Create");
			XPFollNext = GetMethod(typeof(XPathFollowingIterator), "MoveNext");
			XPFollMergeCreate = GetMethod(typeof(XPathFollowingMergeIterator), "Create");
			XPFollMergeNext = GetMethod(typeof(XPathFollowingMergeIterator), "MoveNext");
			XPPrecCreate = GetMethod(typeof(XPathPrecedingIterator), "Create");
			XPPrecNext = GetMethod(typeof(XPathPrecedingIterator), "MoveNext");
			XPPrecDOCreate = GetMethod(typeof(XPathPrecedingDocOrderIterator), "Create");
			XPPrecDONext = GetMethod(typeof(XPathPrecedingDocOrderIterator), "MoveNext");
			XPPrecMergeCreate = GetMethod(typeof(XPathPrecedingMergeIterator), "Create");
			XPPrecMergeNext = GetMethod(typeof(XPathPrecedingMergeIterator), "MoveNext");
			AddNewIndex = GetMethod(typeof(XmlQueryRuntime), "AddNewIndex");
			ChangeTypeXsltArg = GetMethod(typeof(XmlQueryRuntime), "ChangeTypeXsltArgument", typeof(int), typeof(object), typeof(Type));
			ChangeTypeXsltResult = GetMethod(typeof(XmlQueryRuntime), "ChangeTypeXsltResult");
			CompPos = GetMethod(typeof(XmlQueryRuntime), "ComparePosition");
			Context = GetMethod(typeof(XmlQueryRuntime), "get_ExternalContext");
			CreateCollation = GetMethod(typeof(XmlQueryRuntime), "CreateCollation");
			DocOrder = GetMethod(typeof(XmlQueryRuntime), "DocOrderDistinct");
			EndRtfConstr = GetMethod(typeof(XmlQueryRuntime), "EndRtfConstruction");
			EndSeqConstr = GetMethod(typeof(XmlQueryRuntime), "EndSequenceConstruction");
			FindIndex = GetMethod(typeof(XmlQueryRuntime), "FindIndex");
			GenId = GetMethod(typeof(XmlQueryRuntime), "GenerateId");
			GetAtomizedName = GetMethod(typeof(XmlQueryRuntime), "GetAtomizedName");
			GetCollation = GetMethod(typeof(XmlQueryRuntime), "GetCollation");
			GetEarly = GetMethod(typeof(XmlQueryRuntime), "GetEarlyBoundObject");
			GetNameFilter = GetMethod(typeof(XmlQueryRuntime), "GetNameFilter");
			GetOutput = GetMethod(typeof(XmlQueryRuntime), "get_Output");
			GetGlobalValue = GetMethod(typeof(XmlQueryRuntime), "GetGlobalValue");
			GetTypeFilter = GetMethod(typeof(XmlQueryRuntime), "GetTypeFilter");
			GlobalComputed = GetMethod(typeof(XmlQueryRuntime), "IsGlobalComputed");
			ItemMatchesCode = GetMethod(typeof(XmlQueryRuntime), "MatchesXmlType", typeof(XPathItem), typeof(XmlTypeCode));
			ItemMatchesType = GetMethod(typeof(XmlQueryRuntime), "MatchesXmlType", typeof(XPathItem), typeof(int));
			QNameEqualLit = GetMethod(typeof(XmlQueryRuntime), "IsQNameEqual", typeof(XPathNavigator), typeof(int), typeof(int));
			QNameEqualNav = GetMethod(typeof(XmlQueryRuntime), "IsQNameEqual", typeof(XPathNavigator), typeof(XPathNavigator));
			RtfConstr = GetMethod(typeof(XmlQueryRuntime), "TextRtfConstruction");
			SendMessage = GetMethod(typeof(XmlQueryRuntime), "SendMessage");
			SeqMatchesCode = GetMethod(typeof(XmlQueryRuntime), "MatchesXmlType", typeof(IList<XPathItem>), typeof(XmlTypeCode));
			SeqMatchesType = GetMethod(typeof(XmlQueryRuntime), "MatchesXmlType", typeof(IList<XPathItem>), typeof(int));
			SetGlobalValue = GetMethod(typeof(XmlQueryRuntime), "SetGlobalValue");
			StartRtfConstr = GetMethod(typeof(XmlQueryRuntime), "StartRtfConstruction");
			StartSeqConstr = GetMethod(typeof(XmlQueryRuntime), "StartSequenceConstruction");
			TagAndMappings = GetMethod(typeof(XmlQueryRuntime), "ParseTagName", typeof(string), typeof(int));
			TagAndNamespace = GetMethod(typeof(XmlQueryRuntime), "ParseTagName", typeof(string), typeof(string));
			ThrowException = GetMethod(typeof(XmlQueryRuntime), "ThrowException");
			XsltLib = GetMethod(typeof(XmlQueryRuntime), "get_XsltFunctions");
			GetDataSource = GetMethod(typeof(XmlQueryContext), "GetDataSource");
			GetDefaultDataSource = GetMethod(typeof(XmlQueryContext), "get_DefaultDataSource");
			GetParam = GetMethod(typeof(XmlQueryContext), "GetParameter");
			InvokeXsltLate = GetMethod(typeof(XmlQueryContext), "InvokeXsltLateBoundFunction");
			IndexAdd = GetMethod(typeof(XmlILIndex), "Add");
			IndexLookup = GetMethod(typeof(XmlILIndex), "Lookup");
			ItemIsNode = GetMethod(typeof(XPathItem), "get_IsNode");
			Value = GetMethod(typeof(XPathItem), "get_Value");
			ValueAsAny = GetMethod(typeof(XPathItem), "ValueAs", typeof(Type), typeof(IXmlNamespaceResolver));
			NavClone = GetMethod(typeof(XPathNavigator), "Clone");
			NavLocalName = GetMethod(typeof(XPathNavigator), "get_LocalName");
			NavMoveAttr = GetMethod(typeof(XPathNavigator), "MoveToAttribute", typeof(string), typeof(string));
			NavMoveId = GetMethod(typeof(XPathNavigator), "MoveToId");
			NavMoveParent = GetMethod(typeof(XPathNavigator), "MoveToParent");
			NavMoveRoot = GetMethod(typeof(XPathNavigator), "MoveToRoot");
			NavMoveTo = GetMethod(typeof(XPathNavigator), "MoveTo");
			NavNmsp = GetMethod(typeof(XPathNavigator), "get_NamespaceURI");
			NavPrefix = GetMethod(typeof(XPathNavigator), "get_Prefix");
			NavSamePos = GetMethod(typeof(XPathNavigator), "IsSamePosition");
			NavType = GetMethod(typeof(XPathNavigator), "get_NodeType");
			StartElemLitName = GetMethod(typeof(XmlQueryOutput), "WriteStartElement", typeof(string), typeof(string), typeof(string));
			StartElemLocName = GetMethod(typeof(XmlQueryOutput), "WriteStartElementLocalName", typeof(string));
			EndElemStackName = GetMethod(typeof(XmlQueryOutput), "WriteEndElement");
			StartAttrLitName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttribute", typeof(string), typeof(string), typeof(string));
			StartAttrLocName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeLocalName", typeof(string));
			EndAttr = GetMethod(typeof(XmlQueryOutput), "WriteEndAttribute");
			Text = GetMethod(typeof(XmlQueryOutput), "WriteString");
			NoEntText = GetMethod(typeof(XmlQueryOutput), "WriteRaw", typeof(string));
			StartTree = GetMethod(typeof(XmlQueryOutput), "StartTree");
			EndTree = GetMethod(typeof(XmlQueryOutput), "EndTree");
			StartElemLitNameUn = GetMethod(typeof(XmlQueryOutput), "WriteStartElementUnchecked", typeof(string), typeof(string), typeof(string));
			StartElemLocNameUn = GetMethod(typeof(XmlQueryOutput), "WriteStartElementUnchecked", typeof(string));
			StartContentUn = GetMethod(typeof(XmlQueryOutput), "StartElementContentUnchecked");
			EndElemLitNameUn = GetMethod(typeof(XmlQueryOutput), "WriteEndElementUnchecked", typeof(string), typeof(string), typeof(string));
			EndElemLocNameUn = GetMethod(typeof(XmlQueryOutput), "WriteEndElementUnchecked", typeof(string));
			StartAttrLitNameUn = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeUnchecked", typeof(string), typeof(string), typeof(string));
			StartAttrLocNameUn = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeUnchecked", typeof(string));
			EndAttrUn = GetMethod(typeof(XmlQueryOutput), "WriteEndAttributeUnchecked");
			NamespaceDeclUn = GetMethod(typeof(XmlQueryOutput), "WriteNamespaceDeclarationUnchecked");
			TextUn = GetMethod(typeof(XmlQueryOutput), "WriteStringUnchecked");
			NoEntTextUn = GetMethod(typeof(XmlQueryOutput), "WriteRawUnchecked");
			StartRoot = GetMethod(typeof(XmlQueryOutput), "WriteStartRoot");
			EndRoot = GetMethod(typeof(XmlQueryOutput), "WriteEndRoot");
			StartElemCopyName = GetMethod(typeof(XmlQueryOutput), "WriteStartElementComputed", typeof(XPathNavigator));
			StartElemMapName = GetMethod(typeof(XmlQueryOutput), "WriteStartElementComputed", typeof(string), typeof(int));
			StartElemNmspName = GetMethod(typeof(XmlQueryOutput), "WriteStartElementComputed", typeof(string), typeof(string));
			StartElemQName = GetMethod(typeof(XmlQueryOutput), "WriteStartElementComputed", typeof(XmlQualifiedName));
			StartAttrCopyName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeComputed", typeof(XPathNavigator));
			StartAttrMapName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeComputed", typeof(string), typeof(int));
			StartAttrNmspName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeComputed", typeof(string), typeof(string));
			StartAttrQName = GetMethod(typeof(XmlQueryOutput), "WriteStartAttributeComputed", typeof(XmlQualifiedName));
			NamespaceDecl = GetMethod(typeof(XmlQueryOutput), "WriteNamespaceDeclaration");
			StartComment = GetMethod(typeof(XmlQueryOutput), "WriteStartComment");
			CommentText = GetMethod(typeof(XmlQueryOutput), "WriteCommentString");
			EndComment = GetMethod(typeof(XmlQueryOutput), "WriteEndComment");
			StartPI = GetMethod(typeof(XmlQueryOutput), "WriteStartProcessingInstruction");
			PIText = GetMethod(typeof(XmlQueryOutput), "WriteProcessingInstructionString");
			EndPI = GetMethod(typeof(XmlQueryOutput), "WriteEndProcessingInstruction");
			WriteItem = GetMethod(typeof(XmlQueryOutput), "WriteItem");
			CopyOf = GetMethod(typeof(XmlQueryOutput), "XsltCopyOf");
			StartCopy = GetMethod(typeof(XmlQueryOutput), "StartCopy");
			EndCopy = GetMethod(typeof(XmlQueryOutput), "EndCopy");
			DecAdd = GetMethod(typeof(decimal), "Add");
			DecCmp = GetMethod(typeof(decimal), "Compare", typeof(decimal), typeof(decimal));
			DecEq = GetMethod(typeof(decimal), "Equals", typeof(decimal), typeof(decimal));
			DecSub = GetMethod(typeof(decimal), "Subtract");
			DecMul = GetMethod(typeof(decimal), "Multiply");
			DecDiv = GetMethod(typeof(decimal), "Divide");
			DecRem = GetMethod(typeof(decimal), "Remainder");
			DecNeg = GetMethod(typeof(decimal), "Negate");
			QNameEq = GetMethod(typeof(XmlQualifiedName), "Equals");
			StrEq = GetMethod(typeof(string), "Equals", typeof(string), typeof(string));
			StrCat2 = GetMethod(typeof(string), "Concat", typeof(string), typeof(string));
			StrCat3 = GetMethod(typeof(string), "Concat", typeof(string), typeof(string), typeof(string));
			StrCat4 = GetMethod(typeof(string), "Concat", typeof(string), typeof(string), typeof(string), typeof(string));
			StrCmp = GetMethod(typeof(string), "CompareOrdinal", typeof(string), typeof(string));
			StrLen = GetMethod(typeof(string), "get_Length");
			DblToDec = GetMethod(typeof(XsltConvert), "ToDecimal", typeof(double));
			DblToInt = GetMethod(typeof(XsltConvert), "ToInt", typeof(double));
			DblToLng = GetMethod(typeof(XsltConvert), "ToLong", typeof(double));
			DblToStr = GetMethod(typeof(XsltConvert), "ToString", typeof(double));
			DecToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(decimal));
			DTToStr = GetMethod(typeof(XsltConvert), "ToString", typeof(DateTime));
			IntToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(int));
			LngToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(long));
			StrToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(string));
			StrToDT = GetMethod(typeof(XsltConvert), "ToDateTime", typeof(string));
			ItemToBool = GetMethod(typeof(XsltConvert), "ToBoolean", typeof(XPathItem));
			ItemToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(XPathItem));
			ItemToStr = GetMethod(typeof(XsltConvert), "ToString", typeof(XPathItem));
			ItemToNode = GetMethod(typeof(XsltConvert), "ToNode", typeof(XPathItem));
			ItemToNodes = GetMethod(typeof(XsltConvert), "ToNodeSet", typeof(XPathItem));
			ItemsToBool = GetMethod(typeof(XsltConvert), "ToBoolean", typeof(IList<XPathItem>));
			ItemsToDbl = GetMethod(typeof(XsltConvert), "ToDouble", typeof(IList<XPathItem>));
			ItemsToNode = GetMethod(typeof(XsltConvert), "ToNode", typeof(IList<XPathItem>));
			ItemsToNodes = GetMethod(typeof(XsltConvert), "ToNodeSet", typeof(IList<XPathItem>));
			ItemsToStr = GetMethod(typeof(XsltConvert), "ToString", typeof(IList<XPathItem>));
			StrCatCat = GetMethod(typeof(StringConcat), "Concat");
			StrCatClear = GetMethod(typeof(StringConcat), "Clear");
			StrCatResult = GetMethod(typeof(StringConcat), "GetResult");
			StrCatDelim = GetMethod(typeof(StringConcat), "set_Delimiter");
			NavsToItems = GetMethod(typeof(XmlILStorageConverter), "NavigatorsToItems");
			ItemsToNavs = GetMethod(typeof(XmlILStorageConverter), "ItemsToNavigators");
			SetDod = GetMethod(typeof(XmlQueryNodeSequence), "set_IsDocOrderDistinct");
			GetTypeFromHandle = GetMethod(typeof(Type), "GetTypeFromHandle");
			InitializeArray = GetMethod(typeof(RuntimeHelpers), "InitializeArray");
			StorageMethods = new Dictionary<Type, XmlILStorageMethods>();
			StorageMethods[typeof(string)] = new XmlILStorageMethods(typeof(string));
			StorageMethods[typeof(bool)] = new XmlILStorageMethods(typeof(bool));
			StorageMethods[typeof(int)] = new XmlILStorageMethods(typeof(int));
			StorageMethods[typeof(long)] = new XmlILStorageMethods(typeof(long));
			StorageMethods[typeof(decimal)] = new XmlILStorageMethods(typeof(decimal));
			StorageMethods[typeof(double)] = new XmlILStorageMethods(typeof(double));
			StorageMethods[typeof(float)] = new XmlILStorageMethods(typeof(float));
			StorageMethods[typeof(DateTime)] = new XmlILStorageMethods(typeof(DateTime));
			StorageMethods[typeof(byte[])] = new XmlILStorageMethods(typeof(byte[]));
			StorageMethods[typeof(XmlQualifiedName)] = new XmlILStorageMethods(typeof(XmlQualifiedName));
			StorageMethods[typeof(TimeSpan)] = new XmlILStorageMethods(typeof(TimeSpan));
			StorageMethods[typeof(XPathItem)] = new XmlILStorageMethods(typeof(XPathItem));
			StorageMethods[typeof(XPathNavigator)] = new XmlILStorageMethods(typeof(XPathNavigator));
		}

		public static MethodInfo GetMethod(Type className, string methName)
		{
			return className.GetMethod(methName);
		}

		public static MethodInfo GetMethod(Type className, string methName, params Type[] args)
		{
			return className.GetMethod(methName, args);
		}
	}
	internal enum GenerateNameType
	{
		LiteralLocalName,
		LiteralName,
		CopiedName,
		TagNameAndMappings,
		TagNameAndNamespace,
		QName,
		StackName
	}
	internal class GenerateHelper
	{
		private MethodBase methInfo;

		private ILGenerator ilgen;

		private LocalBuilder locXOut;

		private XmlILModule module;

		private bool isDebug;

		private bool initWriters;

		private StaticDataManager staticData;

		private ISourceLineInfo lastSourceInfo;

		private MethodInfo methSyncToNav;

		private string lastUriString;

		private string lastFileName;

		public StaticDataManager StaticData => staticData;

		public GenerateHelper(XmlILModule module, bool isDebug)
		{
			this.isDebug = isDebug;
			this.module = module;
			staticData = new StaticDataManager();
		}

		public void MethodBegin(MethodBase methInfo, ISourceLineInfo sourceInfo, bool initWriters)
		{
			this.methInfo = methInfo;
			ilgen = XmlILModule.DefineMethodBody(methInfo);
			lastSourceInfo = null;
			if (isDebug)
			{
				DebugStartScope();
				if (sourceInfo != null)
				{
					MarkSequencePoint(sourceInfo);
					Emit(OpCodes.Nop);
				}
			}
			else if (module.EmitSymbols && sourceInfo != null)
			{
				MarkSequencePoint(sourceInfo);
				lastSourceInfo = null;
			}
			this.initWriters = false;
			if (initWriters)
			{
				EnsureWriter();
				LoadQueryRuntime();
				Call(XmlILMethods.GetOutput);
				Emit(OpCodes.Stloc, locXOut);
			}
		}

		public void MethodEnd()
		{
			Emit(OpCodes.Ret);
			if (isDebug)
			{
				DebugEndScope();
			}
		}

		public void CallSyncToNavigator()
		{
			if (methSyncToNav == null)
			{
				methSyncToNav = module.FindMethod("SyncToNavigator");
			}
			Call(methSyncToNav);
		}

		public void LoadInteger(int intVal)
		{
			if (intVal >= -1 && intVal < 9)
			{
				OpCode opcode;
				switch (intVal)
				{
				default:
					return;
				case -1:
					opcode = OpCodes.Ldc_I4_M1;
					break;
				case 0:
					opcode = OpCodes.Ldc_I4_0;
					break;
				case 1:
					opcode = OpCodes.Ldc_I4_1;
					break;
				case 2:
					opcode = OpCodes.Ldc_I4_2;
					break;
				case 3:
					opcode = OpCodes.Ldc_I4_3;
					break;
				case 4:
					opcode = OpCodes.Ldc_I4_4;
					break;
				case 5:
					opcode = OpCodes.Ldc_I4_5;
					break;
				case 6:
					opcode = OpCodes.Ldc_I4_6;
					break;
				case 7:
					opcode = OpCodes.Ldc_I4_7;
					break;
				case 8:
					opcode = OpCodes.Ldc_I4_8;
					break;
				}
				Emit(opcode);
			}
			else if (intVal >= -128 && intVal <= 127)
			{
				Emit(OpCodes.Ldc_I4_S, (sbyte)intVal);
			}
			else
			{
				Emit(OpCodes.Ldc_I4, intVal);
			}
		}

		public void LoadBoolean(bool boolVal)
		{
			Emit(boolVal ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
		}

		public void LoadType(Type clrTyp)
		{
			Emit(OpCodes.Ldtoken, clrTyp);
			Call(XmlILMethods.GetTypeFromHandle);
		}

		public LocalBuilder DeclareLocal(string name, Type type)
		{
			return ilgen.DeclareLocal(type);
		}

		public void LoadQueryRuntime()
		{
			Emit(OpCodes.Ldarg_0);
		}

		public void LoadQueryContext()
		{
			Emit(OpCodes.Ldarg_0);
			Call(XmlILMethods.Context);
		}

		public void LoadXsltLibrary()
		{
			Emit(OpCodes.Ldarg_0);
			Call(XmlILMethods.XsltLib);
		}

		public void LoadQueryOutput()
		{
			Emit(OpCodes.Ldloc, locXOut);
		}

		public void LoadParameter(int paramPos)
		{
			switch (paramPos)
			{
			case 0:
				Emit(OpCodes.Ldarg_0);
				return;
			case 1:
				Emit(OpCodes.Ldarg_1);
				return;
			case 2:
				Emit(OpCodes.Ldarg_2);
				return;
			case 3:
				Emit(OpCodes.Ldarg_3);
				return;
			}
			if (paramPos <= 255)
			{
				Emit(OpCodes.Ldarg_S, (byte)paramPos);
				return;
			}
			if (paramPos <= 65535)
			{
				Emit(OpCodes.Ldarg, paramPos);
				return;
			}
			throw new XslTransformException("XmlIl_TooManyParameters");
		}

		public void SetParameter(object paramId)
		{
			int num = (int)paramId;
			if (num <= 255)
			{
				Emit(OpCodes.Starg_S, (byte)num);
				return;
			}
			if (num <= 65535)
			{
				Emit(OpCodes.Starg, num);
				return;
			}
			throw new XslTransformException("XmlIl_TooManyParameters");
		}

		public void BranchAndMark(Label lblBranch, Label lblMark)
		{
			if (!lblBranch.Equals(lblMark))
			{
				EmitUnconditionalBranch(OpCodes.Br, lblBranch);
			}
			MarkLabel(lblMark);
		}

		public void TestAndBranch(int i4, Label lblBranch, OpCode opcodeBranch)
		{
			if (i4 != 0)
			{
				goto IL_007f;
			}
			if (opcodeBranch.Value == OpCodes.Beq.Value)
			{
				opcodeBranch = OpCodes.Brfalse;
			}
			else if (opcodeBranch.Value == OpCodes.Beq_S.Value)
			{
				opcodeBranch = OpCodes.Brfalse_S;
			}
			else if (opcodeBranch.Value == OpCodes.Bne_Un.Value)
			{
				opcodeBranch = OpCodes.Brtrue;
			}
			else
			{
				if (opcodeBranch.Value != OpCodes.Bne_Un_S.Value)
				{
					goto IL_007f;
				}
				opcodeBranch = OpCodes.Brtrue_S;
			}
			goto IL_0086;
			IL_007f:
			LoadInteger(i4);
			goto IL_0086;
			IL_0086:
			Emit(opcodeBranch, lblBranch);
		}

		public void ConvBranchToBool(Label lblBranch, bool isTrueBranch)
		{
			Label label = DefineLabel();
			Emit(isTrueBranch ? OpCodes.Ldc_I4_0 : OpCodes.Ldc_I4_1);
			EmitUnconditionalBranch(OpCodes.Br_S, label);
			MarkLabel(lblBranch);
			Emit(isTrueBranch ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
			MarkLabel(label);
		}

		public void TailCall(MethodInfo meth)
		{
			Emit(OpCodes.Tailcall);
			Call(meth);
			Emit(OpCodes.Ret);
		}

		[Conditional("DEBUG")]
		private void TraceCall(OpCode opcode, MethodInfo meth)
		{
		}

		public void Call(MethodInfo meth)
		{
			OpCode opcode = ((meth.IsVirtual || meth.IsAbstract) ? OpCodes.Callvirt : OpCodes.Call);
			ilgen.Emit(opcode, meth);
			if (lastSourceInfo != null)
			{
				MarkSequencePoint(SourceLineInfo.NoSource);
			}
		}

		public void CallToken(MethodInfo meth)
		{
			MethodBuilder methodBuilder = methInfo as MethodBuilder;
			if (methodBuilder != null)
			{
				OpCode opcode = ((meth.IsVirtual || meth.IsAbstract) ? OpCodes.Callvirt : OpCodes.Call);
				ilgen.Emit(opcode, ((ModuleBuilder)methodBuilder.GetModule()).GetMethodToken(meth).Token);
				if (lastSourceInfo != null)
				{
					MarkSequencePoint(SourceLineInfo.NoSource);
				}
			}
			else
			{
				Call(meth);
			}
		}

		public void Construct(ConstructorInfo constr)
		{
			Emit(OpCodes.Newobj, constr);
		}

		public void CallConcatStrings(int cStrings)
		{
			switch (cStrings)
			{
			case 0:
				Emit(OpCodes.Ldstr, "");
				break;
			case 2:
				Call(XmlILMethods.StrCat2);
				break;
			case 3:
				Call(XmlILMethods.StrCat3);
				break;
			case 4:
				Call(XmlILMethods.StrCat4);
				break;
			case 1:
				break;
			}
		}

		public void TreatAs(Type clrTypeSrc, Type clrTypeDst)
		{
			if (!(clrTypeSrc == clrTypeDst))
			{
				if (clrTypeSrc.IsValueType)
				{
					Emit(OpCodes.Box, clrTypeSrc);
				}
				else if (clrTypeDst.IsValueType)
				{
					Emit(OpCodes.Unbox, clrTypeDst);
					Emit(OpCodes.Ldobj, clrTypeDst);
				}
				else if (clrTypeDst != typeof(object))
				{
					Emit(OpCodes.Castclass, clrTypeDst);
				}
			}
		}

		public void ConstructLiteralDecimal(decimal dec)
		{
			if (dec >= -2147483648m && dec <= 2147483647m && decimal.Truncate(dec) == dec)
			{
				LoadInteger((int)dec);
				Construct(XmlILConstructors.DecFromInt32);
				return;
			}
			int[] bits = decimal.GetBits(dec);
			LoadInteger(bits[0]);
			LoadInteger(bits[1]);
			LoadInteger(bits[2]);
			LoadBoolean(bits[3] < 0);
			LoadInteger(bits[3] >> 16);
			Construct(XmlILConstructors.DecFromParts);
		}

		public void ConstructLiteralQName(string localName, string namespaceName)
		{
			Emit(OpCodes.Ldstr, localName);
			Emit(OpCodes.Ldstr, namespaceName);
			Construct(XmlILConstructors.QName);
		}

		public void CallArithmeticOp(QilNodeType opType, XmlTypeCode code)
		{
			MethodInfo meth = null;
			switch (code)
			{
			case XmlTypeCode.Float:
			case XmlTypeCode.Double:
			case XmlTypeCode.Integer:
			case XmlTypeCode.Int:
				switch (opType)
				{
				case QilNodeType.Add:
					Emit(OpCodes.Add);
					break;
				case QilNodeType.Subtract:
					Emit(OpCodes.Sub);
					break;
				case QilNodeType.Multiply:
					Emit(OpCodes.Mul);
					break;
				case QilNodeType.Divide:
					Emit(OpCodes.Div);
					break;
				case QilNodeType.Modulo:
					Emit(OpCodes.Rem);
					break;
				case QilNodeType.Negate:
					Emit(OpCodes.Neg);
					break;
				}
				break;
			case XmlTypeCode.Decimal:
				switch (opType)
				{
				case QilNodeType.Add:
					meth = XmlILMethods.DecAdd;
					break;
				case QilNodeType.Subtract:
					meth = XmlILMethods.DecSub;
					break;
				case QilNodeType.Multiply:
					meth = XmlILMethods.DecMul;
					break;
				case QilNodeType.Divide:
					meth = XmlILMethods.DecDiv;
					break;
				case QilNodeType.Modulo:
					meth = XmlILMethods.DecRem;
					break;
				case QilNodeType.Negate:
					meth = XmlILMethods.DecNeg;
					break;
				}
				Call(meth);
				break;
			}
		}

		public void CallCompareEquals(XmlTypeCode code)
		{
			MethodInfo meth = null;
			switch (code)
			{
			case XmlTypeCode.String:
				meth = XmlILMethods.StrEq;
				break;
			case XmlTypeCode.QName:
				meth = XmlILMethods.QNameEq;
				break;
			case XmlTypeCode.Decimal:
				meth = XmlILMethods.DecEq;
				break;
			}
			Call(meth);
		}

		public void CallCompare(XmlTypeCode code)
		{
			MethodInfo meth = null;
			switch (code)
			{
			case XmlTypeCode.String:
				meth = XmlILMethods.StrCmp;
				break;
			case XmlTypeCode.Decimal:
				meth = XmlILMethods.DecCmp;
				break;
			}
			Call(meth);
		}

		public void CallStartRtfConstruction(string baseUri)
		{
			EnsureWriter();
			LoadQueryRuntime();
			Emit(OpCodes.Ldstr, baseUri);
			Emit(OpCodes.Ldloca, locXOut);
			Call(XmlILMethods.StartRtfConstr);
		}

		public void CallEndRtfConstruction()
		{
			LoadQueryRuntime();
			Emit(OpCodes.Ldloca, locXOut);
			Call(XmlILMethods.EndRtfConstr);
		}

		public void CallStartSequenceConstruction()
		{
			EnsureWriter();
			LoadQueryRuntime();
			Emit(OpCodes.Ldloca, locXOut);
			Call(XmlILMethods.StartSeqConstr);
		}

		public void CallEndSequenceConstruction()
		{
			LoadQueryRuntime();
			Emit(OpCodes.Ldloca, locXOut);
			Call(XmlILMethods.EndSeqConstr);
		}

		public void CallGetEarlyBoundObject(int idxObj, Type clrType)
		{
			LoadQueryRuntime();
			LoadInteger(idxObj);
			Call(XmlILMethods.GetEarly);
			TreatAs(typeof(object), clrType);
		}

		public void CallGetAtomizedName(int idxName)
		{
			LoadQueryRuntime();
			LoadInteger(idxName);
			Call(XmlILMethods.GetAtomizedName);
		}

		public void CallGetNameFilter(int idxFilter)
		{
			LoadQueryRuntime();
			LoadInteger(idxFilter);
			Call(XmlILMethods.GetNameFilter);
		}

		public void CallGetTypeFilter(XPathNodeType nodeType)
		{
			LoadQueryRuntime();
			LoadInteger((int)nodeType);
			Call(XmlILMethods.GetTypeFilter);
		}

		public void CallParseTagName(GenerateNameType nameType)
		{
			if (nameType == GenerateNameType.TagNameAndMappings)
			{
				Call(XmlILMethods.TagAndMappings);
			}
			else
			{
				Call(XmlILMethods.TagAndNamespace);
			}
		}

		public void CallGetGlobalValue(int idxValue, Type clrType)
		{
			LoadQueryRuntime();
			LoadInteger(idxValue);
			Call(XmlILMethods.GetGlobalValue);
			TreatAs(typeof(object), clrType);
		}

		public void CallSetGlobalValue(Type clrType)
		{
			TreatAs(clrType, typeof(object));
			Call(XmlILMethods.SetGlobalValue);
		}

		public void CallGetCollation(int idxName)
		{
			LoadQueryRuntime();
			LoadInteger(idxName);
			Call(XmlILMethods.GetCollation);
		}

		private void EnsureWriter()
		{
			if (!initWriters)
			{
				locXOut = DeclareLocal("$$$xwrtChk", typeof(XmlQueryOutput));
				initWriters = true;
			}
		}

		public void CallGetParameter(string localName, string namespaceUri)
		{
			LoadQueryContext();
			Emit(OpCodes.Ldstr, localName);
			Emit(OpCodes.Ldstr, namespaceUri);
			Call(XmlILMethods.GetParam);
		}

		public void CallStartTree(XPathNodeType rootType)
		{
			LoadQueryOutput();
			LoadInteger((int)rootType);
			Call(XmlILMethods.StartTree);
		}

		public void CallEndTree()
		{
			LoadQueryOutput();
			Call(XmlILMethods.EndTree);
		}

		public void CallWriteStartRoot()
		{
			LoadQueryOutput();
			Call(XmlILMethods.StartRoot);
		}

		public void CallWriteEndRoot()
		{
			LoadQueryOutput();
			Call(XmlILMethods.EndRoot);
		}

		public void CallWriteStartElement(GenerateNameType nameType, bool callChk)
		{
			MethodInfo meth = null;
			if (callChk)
			{
				switch (nameType)
				{
				case GenerateNameType.LiteralLocalName:
					meth = XmlILMethods.StartElemLocName;
					break;
				case GenerateNameType.LiteralName:
					meth = XmlILMethods.StartElemLitName;
					break;
				case GenerateNameType.CopiedName:
					meth = XmlILMethods.StartElemCopyName;
					break;
				case GenerateNameType.TagNameAndMappings:
					meth = XmlILMethods.StartElemMapName;
					break;
				case GenerateNameType.TagNameAndNamespace:
					meth = XmlILMethods.StartElemNmspName;
					break;
				case GenerateNameType.QName:
					meth = XmlILMethods.StartElemQName;
					break;
				}
			}
			else
			{
				switch (nameType)
				{
				case GenerateNameType.LiteralLocalName:
					meth = XmlILMethods.StartElemLocNameUn;
					break;
				case GenerateNameType.LiteralName:
					meth = XmlILMethods.StartElemLitNameUn;
					break;
				}
			}
			Call(meth);
		}

		public void CallWriteEndElement(GenerateNameType nameType, bool callChk)
		{
			MethodInfo meth = null;
			if (callChk)
			{
				meth = XmlILMethods.EndElemStackName;
			}
			else
			{
				switch (nameType)
				{
				case GenerateNameType.LiteralLocalName:
					meth = XmlILMethods.EndElemLocNameUn;
					break;
				case GenerateNameType.LiteralName:
					meth = XmlILMethods.EndElemLitNameUn;
					break;
				}
			}
			Call(meth);
		}

		public void CallStartElementContent()
		{
			LoadQueryOutput();
			Call(XmlILMethods.StartContentUn);
		}

		public void CallWriteStartAttribute(GenerateNameType nameType, bool callChk)
		{
			MethodInfo meth = null;
			if (callChk)
			{
				switch (nameType)
				{
				case GenerateNameType.LiteralLocalName:
					meth = XmlILMethods.StartAttrLocName;
					break;
				case GenerateNameType.LiteralName:
					meth = XmlILMethods.StartAttrLitName;
					break;
				case GenerateNameType.CopiedName:
					meth = XmlILMethods.StartAttrCopyName;
					break;
				case GenerateNameType.TagNameAndMappings:
					meth = XmlILMethods.StartAttrMapName;
					break;
				case GenerateNameType.TagNameAndNamespace:
					meth = XmlILMethods.StartAttrNmspName;
					break;
				case GenerateNameType.QName:
					meth = XmlILMethods.StartAttrQName;
					break;
				}
			}
			else
			{
				switch (nameType)
				{
				case GenerateNameType.LiteralLocalName:
					meth = XmlILMethods.StartAttrLocNameUn;
					break;
				case GenerateNameType.LiteralName:
					meth = XmlILMethods.StartAttrLitNameUn;
					break;
				}
			}
			Call(meth);
		}

		public void CallWriteEndAttribute(bool callChk)
		{
			LoadQueryOutput();
			if (callChk)
			{
				Call(XmlILMethods.EndAttr);
			}
			else
			{
				Call(XmlILMethods.EndAttrUn);
			}
		}

		public void CallWriteNamespaceDecl(bool callChk)
		{
			if (callChk)
			{
				Call(XmlILMethods.NamespaceDecl);
			}
			else
			{
				Call(XmlILMethods.NamespaceDeclUn);
			}
		}

		public void CallWriteString(bool disableOutputEscaping, bool callChk)
		{
			if (callChk)
			{
				if (disableOutputEscaping)
				{
					Call(XmlILMethods.NoEntText);
				}
				else
				{
					Call(XmlILMethods.Text);
				}
			}
			else if (disableOutputEscaping)
			{
				Call(XmlILMethods.NoEntTextUn);
			}
			else
			{
				Call(XmlILMethods.TextUn);
			}
		}

		public void CallWriteStartPI()
		{
			Call(XmlILMethods.StartPI);
		}

		public void CallWriteEndPI()
		{
			LoadQueryOutput();
			Call(XmlILMethods.EndPI);
		}

		public void CallWriteStartComment()
		{
			LoadQueryOutput();
			Call(XmlILMethods.StartComment);
		}

		public void CallWriteEndComment()
		{
			LoadQueryOutput();
			Call(XmlILMethods.EndComment);
		}

		public void CallCacheCount(Type itemStorageType)
		{
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[itemStorageType];
			Call(xmlILStorageMethods.IListCount);
		}

		public void CallCacheItem(Type itemStorageType)
		{
			Call(XmlILMethods.StorageMethods[itemStorageType].IListItem);
		}

		public void CallValueAs(Type clrType)
		{
			MethodInfo valueAs = XmlILMethods.StorageMethods[clrType].ValueAs;
			if (valueAs == null)
			{
				LoadType(clrType);
				Emit(OpCodes.Ldnull);
				Call(XmlILMethods.ValueAsAny);
				TreatAs(typeof(object), clrType);
			}
			else
			{
				Call(valueAs);
			}
		}

		public void AddSortKey(XmlQueryType keyType)
		{
			MethodInfo meth = null;
			if (keyType == null)
			{
				meth = XmlILMethods.SortKeyEmpty;
			}
			else
			{
				switch (keyType.TypeCode)
				{
				case XmlTypeCode.String:
					meth = XmlILMethods.SortKeyString;
					break;
				case XmlTypeCode.Decimal:
					meth = XmlILMethods.SortKeyDecimal;
					break;
				case XmlTypeCode.Integer:
					meth = XmlILMethods.SortKeyInteger;
					break;
				case XmlTypeCode.Int:
					meth = XmlILMethods.SortKeyInt;
					break;
				case XmlTypeCode.Boolean:
					meth = XmlILMethods.SortKeyInt;
					break;
				case XmlTypeCode.Double:
					meth = XmlILMethods.SortKeyDouble;
					break;
				case XmlTypeCode.DateTime:
					meth = XmlILMethods.SortKeyDateTime;
					break;
				case XmlTypeCode.None:
					Emit(OpCodes.Pop);
					meth = XmlILMethods.SortKeyEmpty;
					break;
				case XmlTypeCode.AnyAtomicType:
					return;
				}
			}
			Call(meth);
		}

		public void DebugStartScope()
		{
			ilgen.BeginScope();
		}

		public void DebugEndScope()
		{
			ilgen.EndScope();
		}

		public void DebugSequencePoint(ISourceLineInfo sourceInfo)
		{
			Emit(OpCodes.Nop);
			MarkSequencePoint(sourceInfo);
		}

		private string GetFileName(ISourceLineInfo sourceInfo)
		{
			string uri = sourceInfo.Uri;
			if ((object)uri == lastUriString)
			{
				return lastFileName;
			}
			lastUriString = uri;
			lastFileName = SourceLineInfo.GetFileName(uri);
			return lastFileName;
		}

		private void MarkSequencePoint(ISourceLineInfo sourceInfo)
		{
			if (!sourceInfo.IsNoSource || lastSourceInfo == null || !lastSourceInfo.IsNoSource)
			{
				string fileName = GetFileName(sourceInfo);
				ISymbolDocumentWriter document = module.AddSourceDocument(fileName);
				ilgen.MarkSequencePoint(document, sourceInfo.Start.Line, sourceInfo.Start.Pos, sourceInfo.End.Line, sourceInfo.End.Pos);
				lastSourceInfo = sourceInfo;
			}
		}

		public Label DefineLabel()
		{
			return ilgen.DefineLabel();
		}

		public void MarkLabel(Label lbl)
		{
			if (lastSourceInfo != null && !lastSourceInfo.IsNoSource)
			{
				DebugSequencePoint(SourceLineInfo.NoSource);
			}
			ilgen.MarkLabel(lbl);
		}

		public void Emit(OpCode opcode)
		{
			ilgen.Emit(opcode);
		}

		public void Emit(OpCode opcode, byte byteVal)
		{
			ilgen.Emit(opcode, byteVal);
		}

		public void Emit(OpCode opcode, ConstructorInfo constrInfo)
		{
			ilgen.Emit(opcode, constrInfo);
		}

		public void Emit(OpCode opcode, double dblVal)
		{
			ilgen.Emit(opcode, dblVal);
		}

		public void Emit(OpCode opcode, float fltVal)
		{
			ilgen.Emit(opcode, fltVal);
		}

		public void Emit(OpCode opcode, FieldInfo fldInfo)
		{
			ilgen.Emit(opcode, fldInfo);
		}

		public void Emit(OpCode opcode, short shrtVal)
		{
			ilgen.Emit(opcode, shrtVal);
		}

		public void Emit(OpCode opcode, int intVal)
		{
			ilgen.Emit(opcode, intVal);
		}

		public void Emit(OpCode opcode, long longVal)
		{
			ilgen.Emit(opcode, longVal);
		}

		public void Emit(OpCode opcode, Label lblVal)
		{
			ilgen.Emit(opcode, lblVal);
		}

		public void Emit(OpCode opcode, Label[] arrLabels)
		{
			ilgen.Emit(opcode, arrLabels);
		}

		public void Emit(OpCode opcode, LocalBuilder locBldr)
		{
			ilgen.Emit(opcode, locBldr);
		}

		public void Emit(OpCode opcode, MethodInfo methInfo)
		{
			ilgen.Emit(opcode, methInfo);
		}

		public void Emit(OpCode opcode, sbyte sbyteVal)
		{
			ilgen.Emit(opcode, sbyteVal);
		}

		public void Emit(OpCode opcode, string strVal)
		{
			ilgen.Emit(opcode, strVal);
		}

		public void Emit(OpCode opcode, Type typVal)
		{
			ilgen.Emit(opcode, typVal);
		}

		public void EmitUnconditionalBranch(OpCode opcode, Label lblTarget)
		{
			if (!opcode.Equals(OpCodes.Br) && !opcode.Equals(OpCodes.Br_S))
			{
				Emit(OpCodes.Ldc_I4_1);
			}
			ilgen.Emit(opcode, lblTarget);
			if (lastSourceInfo != null && (opcode.Equals(OpCodes.Br) || opcode.Equals(OpCodes.Br_S)))
			{
				MarkSequencePoint(SourceLineInfo.NoSource);
			}
		}
	}
	internal enum ItemLocation
	{
		None,
		Stack,
		Parameter,
		Local,
		Current,
		Global
	}
	internal enum BranchingContext
	{
		None,
		OnTrue,
		OnFalse
	}
	internal struct StorageDescriptor
	{
		private ItemLocation location;

		private object locationObject;

		private Type itemStorageType;

		private bool isCached;

		public ItemLocation Location => location;

		public int ParameterLocation => (int)locationObject;

		public LocalBuilder LocalLocation => locationObject as LocalBuilder;

		public LocalBuilder CurrentLocation => locationObject as LocalBuilder;

		public MethodInfo GlobalLocation => locationObject as MethodInfo;

		public bool IsCached => isCached;

		public Type ItemStorageType => itemStorageType;

		public static StorageDescriptor None()
		{
			return default(StorageDescriptor);
		}

		public static StorageDescriptor Stack(Type itemStorageType, bool isCached)
		{
			StorageDescriptor result = default(StorageDescriptor);
			result.location = ItemLocation.Stack;
			result.itemStorageType = itemStorageType;
			result.isCached = isCached;
			return result;
		}

		public static StorageDescriptor Parameter(int paramIndex, Type itemStorageType, bool isCached)
		{
			StorageDescriptor result = default(StorageDescriptor);
			result.location = ItemLocation.Parameter;
			result.locationObject = paramIndex;
			result.itemStorageType = itemStorageType;
			result.isCached = isCached;
			return result;
		}

		public static StorageDescriptor Local(LocalBuilder loc, Type itemStorageType, bool isCached)
		{
			StorageDescriptor result = default(StorageDescriptor);
			result.location = ItemLocation.Local;
			result.locationObject = loc;
			result.itemStorageType = itemStorageType;
			result.isCached = isCached;
			return result;
		}

		public static StorageDescriptor Current(LocalBuilder locIter, Type itemStorageType)
		{
			StorageDescriptor result = default(StorageDescriptor);
			result.location = ItemLocation.Current;
			result.locationObject = locIter;
			result.itemStorageType = itemStorageType;
			return result;
		}

		public static StorageDescriptor Global(MethodInfo methGlobal, Type itemStorageType, bool isCached)
		{
			StorageDescriptor result = default(StorageDescriptor);
			result.location = ItemLocation.Global;
			result.locationObject = methGlobal;
			result.itemStorageType = itemStorageType;
			result.isCached = isCached;
			return result;
		}

		public StorageDescriptor ToStack()
		{
			return Stack(itemStorageType, isCached);
		}

		public StorageDescriptor ToLocal(LocalBuilder loc)
		{
			return Local(loc, itemStorageType, isCached);
		}

		public StorageDescriptor ToStorageType(Type itemStorageType)
		{
			StorageDescriptor result = this;
			result.itemStorageType = itemStorageType;
			return result;
		}
	}
	internal class IteratorDescriptor
	{
		private GenerateHelper helper;

		private IteratorDescriptor iterParent;

		private Label lblNext;

		private bool hasNext;

		private LocalBuilder locPos;

		private BranchingContext brctxt;

		private Label lblBranch;

		private StorageDescriptor storage;

		public IteratorDescriptor ParentIterator => iterParent;

		public bool HasLabelNext => hasNext;

		public LocalBuilder LocalPosition
		{
			get
			{
				return locPos;
			}
			set
			{
				locPos = value;
			}
		}

		public bool IsBranching => brctxt != BranchingContext.None;

		public Label LabelBranch => lblBranch;

		public BranchingContext CurrentBranchingContext => brctxt;

		public StorageDescriptor Storage
		{
			get
			{
				return storage;
			}
			set
			{
				storage = value;
			}
		}

		public IteratorDescriptor(GenerateHelper helper)
		{
			Init(null, helper);
		}

		public IteratorDescriptor(IteratorDescriptor iterParent)
		{
			Init(iterParent, iterParent.helper);
		}

		private void Init(IteratorDescriptor iterParent, GenerateHelper helper)
		{
			this.helper = helper;
			this.iterParent = iterParent;
		}

		public Label GetLabelNext()
		{
			return lblNext;
		}

		public void SetIterator(Label lblNext, StorageDescriptor storage)
		{
			this.lblNext = lblNext;
			hasNext = true;
			this.storage = storage;
		}

		public void SetIterator(IteratorDescriptor iterInfo)
		{
			if (iterInfo.HasLabelNext)
			{
				lblNext = iterInfo.GetLabelNext();
				hasNext = true;
			}
			storage = iterInfo.Storage;
		}

		public void LoopToEnd(Label lblOnEnd)
		{
			if (hasNext)
			{
				helper.BranchAndMark(lblNext, lblOnEnd);
				hasNext = false;
			}
			storage = StorageDescriptor.None();
		}

		public void CacheCount()
		{
			PushValue();
			helper.CallCacheCount(storage.ItemStorageType);
		}

		public void EnsureNoCache()
		{
			if (storage.IsCached)
			{
				if (!HasLabelNext)
				{
					EnsureStack();
					helper.LoadInteger(0);
					helper.CallCacheItem(storage.ItemStorageType);
					storage = StorageDescriptor.Stack(storage.ItemStorageType, isCached: false);
					return;
				}
				LocalBuilder locBldr = helper.DeclareLocal("$$$idx", typeof(int));
				EnsureNoStack("$$$cache");
				helper.LoadInteger(-1);
				helper.Emit(OpCodes.Stloc, locBldr);
				Label lbl = helper.DefineLabel();
				helper.MarkLabel(lbl);
				helper.Emit(OpCodes.Ldloc, locBldr);
				helper.LoadInteger(1);
				helper.Emit(OpCodes.Add);
				helper.Emit(OpCodes.Stloc, locBldr);
				helper.Emit(OpCodes.Ldloc, locBldr);
				CacheCount();
				helper.Emit(OpCodes.Bge, GetLabelNext());
				PushValue();
				helper.Emit(OpCodes.Ldloc, locBldr);
				helper.CallCacheItem(storage.ItemStorageType);
				SetIterator(lbl, StorageDescriptor.Stack(storage.ItemStorageType, isCached: false));
			}
		}

		public void SetBranching(BranchingContext brctxt, Label lblBranch)
		{
			this.brctxt = brctxt;
			this.lblBranch = lblBranch;
		}

		public void PushValue()
		{
			switch (storage.Location)
			{
			case ItemLocation.Stack:
				helper.Emit(OpCodes.Dup);
				break;
			case ItemLocation.Parameter:
				helper.LoadParameter(storage.ParameterLocation);
				break;
			case ItemLocation.Local:
				helper.Emit(OpCodes.Ldloc, storage.LocalLocation);
				break;
			case ItemLocation.Current:
				helper.Emit(OpCodes.Ldloca, storage.CurrentLocation);
				helper.Call(storage.CurrentLocation.LocalType.GetMethod("get_Current"));
				break;
			}
		}

		public void EnsureStack()
		{
			switch (storage.Location)
			{
			case ItemLocation.Stack:
				return;
			case ItemLocation.Parameter:
			case ItemLocation.Local:
			case ItemLocation.Current:
				PushValue();
				break;
			case ItemLocation.Global:
				helper.LoadQueryRuntime();
				helper.Call(storage.GlobalLocation);
				break;
			}
			storage = storage.ToStack();
		}

		public void EnsureNoStack(string locName)
		{
			if (storage.Location == ItemLocation.Stack)
			{
				EnsureLocal(locName);
			}
		}

		public void EnsureLocal(string locName)
		{
			if (storage.Location != ItemLocation.Local)
			{
				if (storage.IsCached)
				{
					EnsureLocal(helper.DeclareLocal(locName, typeof(IList<>).MakeGenericType(storage.ItemStorageType)));
				}
				else
				{
					EnsureLocal(helper.DeclareLocal(locName, storage.ItemStorageType));
				}
			}
		}

		public void EnsureLocal(LocalBuilder bldr)
		{
			if (storage.LocalLocation != bldr)
			{
				EnsureStack();
				helper.Emit(OpCodes.Stloc, bldr);
				storage = storage.ToLocal(bldr);
			}
		}

		public void DiscardStack()
		{
			if (storage.Location == ItemLocation.Stack)
			{
				helper.Emit(OpCodes.Pop);
				storage = StorageDescriptor.None();
			}
		}

		public void EnsureStackNoCache()
		{
			EnsureNoCache();
			EnsureStack();
		}

		public void EnsureNoStackNoCache(string locName)
		{
			EnsureNoCache();
			EnsureNoStack(locName);
		}

		public void EnsureLocalNoCache(string locName)
		{
			EnsureNoCache();
			EnsureLocal(locName);
		}

		public void EnsureLocalNoCache(LocalBuilder bldr)
		{
			EnsureNoCache();
			EnsureLocal(bldr);
		}

		public void EnsureItemStorageType(XmlQueryType xmlType, Type storageTypeDest)
		{
			if (!(storage.ItemStorageType == storageTypeDest))
			{
				if (!storage.IsCached)
				{
					goto IL_0087;
				}
				if (storage.ItemStorageType == typeof(XPathNavigator))
				{
					EnsureStack();
					helper.Call(XmlILMethods.NavsToItems);
				}
				else
				{
					if (!(storageTypeDest == typeof(XPathNavigator)))
					{
						goto IL_0087;
					}
					EnsureStack();
					helper.Call(XmlILMethods.ItemsToNavs);
				}
			}
			goto IL_014d;
			IL_014d:
			storage = storage.ToStorageType(storageTypeDest);
			return;
			IL_0087:
			EnsureStackNoCache();
			if (storage.ItemStorageType == typeof(XPathItem))
			{
				if (storageTypeDest == typeof(XPathNavigator))
				{
					helper.Emit(OpCodes.Castclass, typeof(XPathNavigator));
				}
				else
				{
					helper.CallValueAs(storageTypeDest);
				}
			}
			else if (!(storage.ItemStorageType == typeof(XPathNavigator)))
			{
				helper.LoadInteger(helper.StaticData.DeclareXmlType(xmlType));
				helper.LoadQueryRuntime();
				helper.Call(XmlILMethods.StorageMethods[storage.ItemStorageType].ToAtomicValue);
			}
			goto IL_014d;
		}
	}
	internal enum OptimizerPatternName
	{
		None,
		DodReverse,
		EqualityIndex,
		FilterAttributeKind,
		FilterContentKind,
		FilterElements,
		IsDocOrderDistinct,
		IsPositional,
		JoinAndDod,
		MaxPosition,
		SameDepth,
		Step,
		SingleTextRtf,
		Axis,
		MaybeSideEffects,
		TailCall,
		DodMerge,
		IsReferenced
	}
	internal enum OptimizerPatternArgument
	{
		StepNode = 0,
		StepInput = 1,
		ElementQName = 2,
		KindTestType = 2,
		IndexedNodes = 0,
		KeyExpression = 1,
		DodStep = 2,
		MaxPosition = 2,
		RtfText = 2
	}
	internal class OptimizerPatterns : IQilAnnotation
	{
		private static readonly int PatternCount = Enum.GetValues(typeof(OptimizerPatternName)).Length;

		private int patterns;

		private bool isReadOnly;

		private object arg0;

		private object arg1;

		private object arg2;

		private static volatile OptimizerPatterns ZeroOrOneDefault;

		private static volatile OptimizerPatterns MaybeManyDefault;

		private static volatile OptimizerPatterns DodDefault;

		public virtual string Name => "Patterns";

		public static OptimizerPatterns Read(QilNode nd)
		{
			OptimizerPatterns optimizerPatterns = ((nd.Annotation is XmlILAnnotation xmlILAnnotation) ? xmlILAnnotation.Patterns : null);
			if (optimizerPatterns == null)
			{
				if (!nd.XmlType.MaybeMany)
				{
					if (ZeroOrOneDefault == null)
					{
						optimizerPatterns = new OptimizerPatterns();
						optimizerPatterns.AddPattern(OptimizerPatternName.IsDocOrderDistinct);
						optimizerPatterns.AddPattern(OptimizerPatternName.SameDepth);
						optimizerPatterns.isReadOnly = true;
						ZeroOrOneDefault = optimizerPatterns;
					}
					else
					{
						optimizerPatterns = ZeroOrOneDefault;
					}
				}
				else if (nd.XmlType.IsDod)
				{
					if (DodDefault == null)
					{
						optimizerPatterns = new OptimizerPatterns();
						optimizerPatterns.AddPattern(OptimizerPatternName.IsDocOrderDistinct);
						optimizerPatterns.isReadOnly = true;
						DodDefault = optimizerPatterns;
					}
					else
					{
						optimizerPatterns = DodDefault;
					}
				}
				else if (MaybeManyDefault == null)
				{
					optimizerPatterns = new OptimizerPatterns();
					optimizerPatterns.isReadOnly = true;
					MaybeManyDefault = optimizerPatterns;
				}
				else
				{
					optimizerPatterns = MaybeManyDefault;
				}
			}
			return optimizerPatterns;
		}

		public static OptimizerPatterns Write(QilNode nd)
		{
			XmlILAnnotation xmlILAnnotation = XmlILAnnotation.Write(nd);
			OptimizerPatterns optimizerPatterns = xmlILAnnotation.Patterns;
			if (optimizerPatterns == null || optimizerPatterns.isReadOnly)
			{
				optimizerPatterns = (xmlILAnnotation.Patterns = new OptimizerPatterns());
				if (!nd.XmlType.MaybeMany)
				{
					optimizerPatterns.AddPattern(OptimizerPatternName.IsDocOrderDistinct);
					optimizerPatterns.AddPattern(OptimizerPatternName.SameDepth);
				}
				else if (nd.XmlType.IsDod)
				{
					optimizerPatterns.AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				}
			}
			return optimizerPatterns;
		}

		public static void Inherit(QilNode ndSrc, QilNode ndDst, OptimizerPatternName pattern)
		{
			OptimizerPatterns optimizerPatterns = Read(ndSrc);
			if (optimizerPatterns.MatchesPattern(pattern))
			{
				OptimizerPatterns optimizerPatterns2 = Write(ndDst);
				optimizerPatterns2.AddPattern(pattern);
				switch (pattern)
				{
				case OptimizerPatternName.Step:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepNode, optimizerPatterns.GetArgument(OptimizerPatternArgument.StepNode));
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepInput, optimizerPatterns.GetArgument(OptimizerPatternArgument.StepInput));
					break;
				case OptimizerPatternName.FilterElements:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.ElementQName, optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					break;
				case OptimizerPatternName.FilterContentKind:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.ElementQName, optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					break;
				case OptimizerPatternName.EqualityIndex:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepNode, optimizerPatterns.GetArgument(OptimizerPatternArgument.StepNode));
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepInput, optimizerPatterns.GetArgument(OptimizerPatternArgument.StepInput));
					break;
				case OptimizerPatternName.DodReverse:
				case OptimizerPatternName.JoinAndDod:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.ElementQName, optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					break;
				case OptimizerPatternName.MaxPosition:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.ElementQName, optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					break;
				case OptimizerPatternName.SingleTextRtf:
					optimizerPatterns2.AddArgument(OptimizerPatternArgument.ElementQName, optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					break;
				case OptimizerPatternName.FilterAttributeKind:
				case OptimizerPatternName.IsDocOrderDistinct:
				case OptimizerPatternName.IsPositional:
				case OptimizerPatternName.SameDepth:
					break;
				}
			}
		}

		public void AddArgument(OptimizerPatternArgument argId, object arg)
		{
			switch (argId)
			{
			case OptimizerPatternArgument.StepNode:
				arg0 = arg;
				break;
			case OptimizerPatternArgument.StepInput:
				arg1 = arg;
				break;
			case OptimizerPatternArgument.ElementQName:
				arg2 = arg;
				break;
			}
		}

		public object GetArgument(OptimizerPatternArgument argNum)
		{
			object result = null;
			switch (argNum)
			{
			case OptimizerPatternArgument.StepNode:
				result = arg0;
				break;
			case OptimizerPatternArgument.StepInput:
				result = arg1;
				break;
			case OptimizerPatternArgument.ElementQName:
				result = arg2;
				break;
			}
			return result;
		}

		public void AddPattern(OptimizerPatternName pattern)
		{
			patterns |= 1 << (int)pattern;
		}

		public bool MatchesPattern(OptimizerPatternName pattern)
		{
			return (patterns & (1 << (int)pattern)) != 0;
		}

		public override string ToString()
		{
			string text = "";
			for (int i = 0; i < PatternCount; i++)
			{
				if (MatchesPattern((OptimizerPatternName)i))
				{
					if (text.Length != 0)
					{
						text += ", ";
					}
					string text2 = text;
					OptimizerPatternName optimizerPatternName = (OptimizerPatternName)i;
					text = text2 + optimizerPatternName;
				}
			}
			return text;
		}
	}
	internal class UniqueList<T>
	{
		private Dictionary<T, int> lookup = new Dictionary<T, int>();

		private List<T> list = new List<T>();

		public int Add(T value)
		{
			int num;
			if (!lookup.ContainsKey(value))
			{
				num = list.Count;
				lookup.Add(value, num);
				list.Add(value);
			}
			else
			{
				num = lookup[value];
			}
			return num;
		}

		public T[] ToArray()
		{
			return list.ToArray();
		}
	}
	internal class StaticDataManager
	{
		private UniqueList<string> uniqueNames;

		private UniqueList<Int32Pair> uniqueFilters;

		private List<StringPair[]> prefixMappingsList;

		private List<string> globalNames;

		private UniqueList<EarlyBoundInfo> earlyInfo;

		private UniqueList<XmlQueryType> uniqueXmlTypes;

		private UniqueList<XmlCollation> uniqueCollations;

		public string[] Names
		{
			get
			{
				if (uniqueNames == null)
				{
					return null;
				}
				return uniqueNames.ToArray();
			}
		}

		public Int32Pair[] NameFilters
		{
			get
			{
				if (uniqueFilters == null)
				{
					return null;
				}
				return uniqueFilters.ToArray();
			}
		}

		public StringPair[][] PrefixMappingsList
		{
			get
			{
				if (prefixMappingsList == null)
				{
					return null;
				}
				return prefixMappingsList.ToArray();
			}
		}

		public string[] GlobalNames
		{
			get
			{
				if (globalNames == null)
				{
					return null;
				}
				return globalNames.ToArray();
			}
		}

		public EarlyBoundInfo[] EarlyBound
		{
			get
			{
				if (earlyInfo != null)
				{
					return earlyInfo.ToArray();
				}
				return null;
			}
		}

		public XmlQueryType[] XmlTypes
		{
			get
			{
				if (uniqueXmlTypes == null)
				{
					return null;
				}
				return uniqueXmlTypes.ToArray();
			}
		}

		public XmlCollation[] Collations
		{
			get
			{
				if (uniqueCollations == null)
				{
					return null;
				}
				return uniqueCollations.ToArray();
			}
		}

		public int DeclareName(string name)
		{
			if (uniqueNames == null)
			{
				uniqueNames = new UniqueList<string>();
			}
			return uniqueNames.Add(name);
		}

		public int DeclareNameFilter(string locName, string nsUri)
		{
			if (uniqueFilters == null)
			{
				uniqueFilters = new UniqueList<Int32Pair>();
			}
			return uniqueFilters.Add(new Int32Pair(DeclareName(locName), DeclareName(nsUri)));
		}

		public int DeclarePrefixMappings(IList<QilNode> list)
		{
			StringPair[] array = new StringPair[list.Count];
			for (int i = 0; i < list.Count; i++)
			{
				QilBinary qilBinary = (QilBinary)list[i];
				array[i] = new StringPair((QilLiteral)qilBinary.Left, (QilLiteral)qilBinary.Right);
			}
			if (prefixMappingsList == null)
			{
				prefixMappingsList = new List<StringPair[]>();
			}
			prefixMappingsList.Add(array);
			return prefixMappingsList.Count - 1;
		}

		public int DeclareGlobalValue(string name)
		{
			if (globalNames == null)
			{
				globalNames = new List<string>();
			}
			int count = globalNames.Count;
			globalNames.Add(name);
			return count;
		}

		public int DeclareEarlyBound(string namespaceUri, Type ebType)
		{
			if (earlyInfo == null)
			{
				earlyInfo = new UniqueList<EarlyBoundInfo>();
			}
			return earlyInfo.Add(new EarlyBoundInfo(namespaceUri, ebType));
		}

		public int DeclareXmlType(XmlQueryType type)
		{
			if (uniqueXmlTypes == null)
			{
				uniqueXmlTypes = new UniqueList<XmlQueryType>();
			}
			return uniqueXmlTypes.Add(type);
		}

		public int DeclareCollation(string collation)
		{
			if (uniqueCollations == null)
			{
				uniqueCollations = new UniqueList<XmlCollation>();
			}
			return uniqueCollations.Add(XmlCollation.Create(collation));
		}
	}
	internal static class TailCallAnalyzer
	{
		public static void Analyze(QilExpression qil)
		{
			foreach (QilFunction function in qil.FunctionList)
			{
				if (XmlILConstructInfo.Read(function).ConstructMethod == XmlILConstructMethod.Writer)
				{
					AnalyzeDefinition(function.Definition);
				}
			}
		}

		private static void AnalyzeDefinition(QilNode nd)
		{
			switch (nd.NodeType)
			{
			case QilNodeType.Invoke:
				if (XmlILConstructInfo.Read(nd).ConstructMethod == XmlILConstructMethod.Writer)
				{
					OptimizerPatterns.Write(nd).AddPattern(OptimizerPatternName.TailCall);
				}
				break;
			case QilNodeType.Loop:
			{
				QilLoop qilLoop = (QilLoop)nd;
				if (qilLoop.Variable.NodeType == QilNodeType.Let || !qilLoop.Variable.Binding.XmlType.MaybeMany)
				{
					AnalyzeDefinition(qilLoop.Body);
				}
				break;
			}
			case QilNodeType.Sequence:
			{
				QilList qilList = (QilList)nd;
				if (qilList.Count > 0)
				{
					AnalyzeDefinition(qilList[qilList.Count - 1]);
				}
				break;
			}
			case QilNodeType.Choice:
			{
				QilChoice qilChoice = (QilChoice)nd;
				for (int i = 0; i < qilChoice.Branches.Count; i++)
				{
					AnalyzeDefinition(qilChoice.Branches[i]);
				}
				break;
			}
			case QilNodeType.Conditional:
			{
				QilTernary qilTernary = (QilTernary)nd;
				AnalyzeDefinition(qilTernary.Center);
				AnalyzeDefinition(qilTernary.Right);
				break;
			}
			case QilNodeType.Nop:
				AnalyzeDefinition(((QilUnary)nd).Child);
				break;
			}
		}
	}
	internal class XmlILAnnotation : ListBase<object>
	{
		private object annPrev;

		private MethodInfo funcMethod;

		private int argPos;

		private IteratorDescriptor iterInfo;

		private XmlILConstructInfo constrInfo;

		private OptimizerPatterns optPatt;

		public MethodInfo FunctionBinding
		{
			get
			{
				return funcMethod;
			}
			set
			{
				funcMethod = value;
			}
		}

		public int ArgumentPosition
		{
			get
			{
				return argPos;
			}
			set
			{
				argPos = value;
			}
		}

		public IteratorDescriptor CachedIteratorDescriptor
		{
			get
			{
				return iterInfo;
			}
			set
			{
				iterInfo = value;
			}
		}

		public XmlILConstructInfo ConstructInfo
		{
			get
			{
				return constrInfo;
			}
			set
			{
				constrInfo = value;
			}
		}

		public OptimizerPatterns Patterns
		{
			get
			{
				return optPatt;
			}
			set
			{
				optPatt = value;
			}
		}

		public override int Count
		{
			get
			{
				if (annPrev == null)
				{
					return 2;
				}
				return 3;
			}
		}

		public override object this[int index]
		{
			get
			{
				if (annPrev != null)
				{
					if (index == 0)
					{
						return annPrev;
					}
					index--;
				}
				return index switch
				{
					0 => constrInfo, 
					1 => optPatt, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public static XmlILAnnotation Write(QilNode nd)
		{
			XmlILAnnotation xmlILAnnotation = nd.Annotation as XmlILAnnotation;
			if (xmlILAnnotation == null)
			{
				xmlILAnnotation = (XmlILAnnotation)(nd.Annotation = new XmlILAnnotation(nd.Annotation));
			}
			return xmlILAnnotation;
		}

		private XmlILAnnotation(object annPrev)
		{
			this.annPrev = annPrev;
		}
	}
	internal enum PossibleXmlStates
	{
		None,
		WithinSequence,
		EnumAttrs,
		WithinContent,
		WithinAttr,
		WithinComment,
		WithinPI,
		Any
	}
	internal enum XmlILConstructMethod
	{
		Iterator,
		Writer,
		WriterThenIterator,
		IteratorThenWriter
	}
	internal class XmlILConstructInfo : IQilAnnotation
	{
		private QilNodeType nodeType;

		private PossibleXmlStates xstatesInitial;

		private PossibleXmlStates xstatesFinal;

		private PossibleXmlStates xstatesBeginLoop;

		private PossibleXmlStates xstatesEndLoop;

		private bool isNmspInScope;

		private bool mightHaveNmsp;

		private bool mightHaveAttrs;

		private bool mightHaveDupAttrs;

		private bool mightHaveNmspAfterAttrs;

		private XmlILConstructMethod constrMeth;

		private XmlILConstructInfo parentInfo;

		private ArrayList callersInfo;

		private bool isReadOnly;

		private static volatile XmlILConstructInfo Default;

		public PossibleXmlStates InitialStates
		{
			get
			{
				return xstatesInitial;
			}
			set
			{
				xstatesInitial = value;
			}
		}

		public PossibleXmlStates FinalStates
		{
			get
			{
				return xstatesFinal;
			}
			set
			{
				xstatesFinal = value;
			}
		}

		public PossibleXmlStates BeginLoopStates
		{
			set
			{
				xstatesBeginLoop = value;
			}
		}

		public PossibleXmlStates EndLoopStates
		{
			set
			{
				xstatesEndLoop = value;
			}
		}

		public XmlILConstructMethod ConstructMethod
		{
			get
			{
				return constrMeth;
			}
			set
			{
				constrMeth = value;
			}
		}

		public bool PushToWriterFirst
		{
			get
			{
				if (constrMeth != XmlILConstructMethod.Writer)
				{
					return constrMeth == XmlILConstructMethod.WriterThenIterator;
				}
				return true;
			}
			set
			{
				switch (constrMeth)
				{
				case XmlILConstructMethod.Iterator:
					constrMeth = XmlILConstructMethod.WriterThenIterator;
					break;
				case XmlILConstructMethod.IteratorThenWriter:
					constrMeth = XmlILConstructMethod.Writer;
					break;
				}
			}
		}

		public bool PushToWriterLast
		{
			get
			{
				if (constrMeth != XmlILConstructMethod.Writer)
				{
					return constrMeth == XmlILConstructMethod.IteratorThenWriter;
				}
				return true;
			}
			set
			{
				switch (constrMeth)
				{
				case XmlILConstructMethod.Iterator:
					constrMeth = XmlILConstructMethod.IteratorThenWriter;
					break;
				case XmlILConstructMethod.WriterThenIterator:
					constrMeth = XmlILConstructMethod.Writer;
					break;
				}
			}
		}

		public bool PullFromIteratorFirst
		{
			get
			{
				if (constrMeth != XmlILConstructMethod.IteratorThenWriter)
				{
					return constrMeth == XmlILConstructMethod.Iterator;
				}
				return true;
			}
			set
			{
				switch (constrMeth)
				{
				case XmlILConstructMethod.Writer:
					constrMeth = XmlILConstructMethod.IteratorThenWriter;
					break;
				case XmlILConstructMethod.WriterThenIterator:
					constrMeth = XmlILConstructMethod.Iterator;
					break;
				}
			}
		}

		public XmlILConstructInfo ParentInfo
		{
			set
			{
				parentInfo = value;
			}
		}

		public XmlILConstructInfo ParentElementInfo
		{
			get
			{
				if (parentInfo != null && parentInfo.nodeType == QilNodeType.ElementCtor)
				{
					return parentInfo;
				}
				return null;
			}
		}

		public bool IsNamespaceInScope
		{
			get
			{
				return isNmspInScope;
			}
			set
			{
				isNmspInScope = value;
			}
		}

		public bool MightHaveNamespaces
		{
			get
			{
				return mightHaveNmsp;
			}
			set
			{
				mightHaveNmsp = value;
			}
		}

		public bool MightHaveNamespacesAfterAttributes
		{
			get
			{
				return mightHaveNmspAfterAttrs;
			}
			set
			{
				mightHaveNmspAfterAttrs = value;
			}
		}

		public bool MightHaveAttributes
		{
			get
			{
				return mightHaveAttrs;
			}
			set
			{
				mightHaveAttrs = value;
			}
		}

		public bool MightHaveDuplicateAttributes
		{
			get
			{
				return mightHaveDupAttrs;
			}
			set
			{
				mightHaveDupAttrs = value;
			}
		}

		public ArrayList CallersInfo
		{
			get
			{
				if (callersInfo == null)
				{
					callersInfo = new ArrayList();
				}
				return callersInfo;
			}
		}

		public virtual string Name => "ConstructInfo";

		public static XmlILConstructInfo Read(QilNode nd)
		{
			XmlILConstructInfo xmlILConstructInfo = ((nd.Annotation is XmlILAnnotation xmlILAnnotation) ? xmlILAnnotation.ConstructInfo : null);
			if (xmlILConstructInfo == null)
			{
				if (Default == null)
				{
					xmlILConstructInfo = new XmlILConstructInfo(QilNodeType.Unknown);
					xmlILConstructInfo.isReadOnly = true;
					Default = xmlILConstructInfo;
				}
				else
				{
					xmlILConstructInfo = Default;
				}
			}
			return xmlILConstructInfo;
		}

		public static XmlILConstructInfo Write(QilNode nd)
		{
			XmlILAnnotation xmlILAnnotation = XmlILAnnotation.Write(nd);
			XmlILConstructInfo xmlILConstructInfo = xmlILAnnotation.ConstructInfo;
			if (xmlILConstructInfo == null || xmlILConstructInfo.isReadOnly)
			{
				xmlILConstructInfo = (xmlILAnnotation.ConstructInfo = new XmlILConstructInfo(nd.NodeType));
			}
			return xmlILConstructInfo;
		}

		private XmlILConstructInfo(QilNodeType nodeType)
		{
			this.nodeType = nodeType;
			xstatesInitial = (xstatesFinal = PossibleXmlStates.Any);
			xstatesBeginLoop = (xstatesEndLoop = PossibleXmlStates.None);
			isNmspInScope = false;
			mightHaveNmsp = true;
			mightHaveAttrs = true;
			mightHaveDupAttrs = true;
			mightHaveNmspAfterAttrs = true;
			constrMeth = XmlILConstructMethod.Iterator;
			parentInfo = null;
		}

		public override string ToString()
		{
			string text = "";
			if (constrMeth != 0)
			{
				text += constrMeth;
				text = text + ", " + xstatesInitial;
				if (xstatesBeginLoop != 0)
				{
					text = text + " => " + xstatesBeginLoop.ToString() + " => " + xstatesEndLoop;
				}
				text = text + " => " + xstatesFinal;
				if (!MightHaveAttributes)
				{
					text += ", NoAttrs";
				}
				if (!MightHaveDuplicateAttributes)
				{
					text += ", NoDupAttrs";
				}
				if (!MightHaveNamespaces)
				{
					text += ", NoNmsp";
				}
				if (!MightHaveNamespacesAfterAttributes)
				{
					text += ", NoNmspAfterAttrs";
				}
			}
			return text;
		}
	}
	internal class XmlILStateAnalyzer
	{
		protected XmlILConstructInfo parentInfo;

		protected QilFactory fac;

		protected PossibleXmlStates xstates;

		protected bool withinElem;

		public XmlILStateAnalyzer(QilFactory fac)
		{
			this.fac = fac;
		}

		public virtual QilNode Analyze(QilNode ndConstr, QilNode ndContent)
		{
			if (ndConstr == null)
			{
				parentInfo = null;
				xstates = PossibleXmlStates.WithinSequence;
				withinElem = false;
				ndContent = AnalyzeContent(ndContent);
			}
			else
			{
				parentInfo = XmlILConstructInfo.Write(ndConstr);
				if (ndConstr.NodeType == QilNodeType.Function)
				{
					parentInfo.ConstructMethod = XmlILConstructMethod.Writer;
					PossibleXmlStates possibleXmlStates = PossibleXmlStates.None;
					foreach (XmlILConstructInfo item in parentInfo.CallersInfo)
					{
						if (possibleXmlStates == PossibleXmlStates.None)
						{
							possibleXmlStates = item.InitialStates;
						}
						else if (possibleXmlStates != item.InitialStates)
						{
							possibleXmlStates = PossibleXmlStates.Any;
						}
						item.PushToWriterFirst = true;
					}
					parentInfo.InitialStates = possibleXmlStates;
				}
				else
				{
					if (ndConstr.NodeType != QilNodeType.Choice)
					{
						PossibleXmlStates possibleXmlStates4 = (parentInfo.InitialStates = (parentInfo.FinalStates = PossibleXmlStates.WithinSequence));
					}
					if (ndConstr.NodeType != QilNodeType.RtfCtor)
					{
						parentInfo.ConstructMethod = XmlILConstructMethod.WriterThenIterator;
					}
				}
				withinElem = ndConstr.NodeType == QilNodeType.ElementCtor;
				switch (ndConstr.NodeType)
				{
				case QilNodeType.DocumentCtor:
					xstates = PossibleXmlStates.WithinContent;
					break;
				case QilNodeType.ElementCtor:
					xstates = PossibleXmlStates.EnumAttrs;
					break;
				case QilNodeType.AttributeCtor:
					xstates = PossibleXmlStates.WithinAttr;
					break;
				case QilNodeType.CommentCtor:
					xstates = PossibleXmlStates.WithinComment;
					break;
				case QilNodeType.PICtor:
					xstates = PossibleXmlStates.WithinPI;
					break;
				case QilNodeType.XsltCopy:
					xstates = PossibleXmlStates.Any;
					break;
				case QilNodeType.Function:
					xstates = parentInfo.InitialStates;
					break;
				case QilNodeType.RtfCtor:
					xstates = PossibleXmlStates.WithinContent;
					break;
				case QilNodeType.Choice:
					xstates = PossibleXmlStates.Any;
					break;
				}
				if (ndContent != null)
				{
					ndContent = AnalyzeContent(ndContent);
				}
				if (ndConstr.NodeType == QilNodeType.Choice)
				{
					AnalyzeChoice(ndConstr as QilChoice, parentInfo);
				}
				if (ndConstr.NodeType == QilNodeType.Function)
				{
					parentInfo.FinalStates = xstates;
				}
			}
			return ndContent;
		}

		protected virtual QilNode AnalyzeContent(QilNode nd)
		{
			QilNodeType nodeType = nd.NodeType;
			if ((uint)(nodeType - 14) <= 2u)
			{
				nd = fac.Nop(nd);
			}
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Write(nd);
			xmlILConstructInfo.ParentInfo = parentInfo;
			xmlILConstructInfo.PushToWriterLast = true;
			xmlILConstructInfo.InitialStates = xstates;
			switch (nd.NodeType)
			{
			case QilNodeType.Loop:
				AnalyzeLoop(nd as QilLoop, xmlILConstructInfo);
				break;
			case QilNodeType.Sequence:
				AnalyzeSequence(nd as QilList, xmlILConstructInfo);
				break;
			case QilNodeType.Conditional:
				AnalyzeConditional(nd as QilTernary, xmlILConstructInfo);
				break;
			case QilNodeType.Choice:
				AnalyzeChoice(nd as QilChoice, xmlILConstructInfo);
				break;
			case QilNodeType.Error:
			case QilNodeType.Warning:
				xmlILConstructInfo.ConstructMethod = XmlILConstructMethod.Writer;
				break;
			case QilNodeType.Nop:
			{
				QilNode child = (nd as QilUnary).Child;
				QilNodeType nodeType2 = child.NodeType;
				if ((uint)(nodeType2 - 14) <= 2u)
				{
					AnalyzeCopy(nd, xmlILConstructInfo);
					break;
				}
				xmlILConstructInfo.ConstructMethod = XmlILConstructMethod.Writer;
				AnalyzeContent(child);
				break;
			}
			default:
				AnalyzeCopy(nd, xmlILConstructInfo);
				break;
			}
			xmlILConstructInfo.FinalStates = xstates;
			return nd;
		}

		protected virtual void AnalyzeLoop(QilLoop ndLoop, XmlILConstructInfo info)
		{
			XmlQueryType xmlType = ndLoop.XmlType;
			info.ConstructMethod = XmlILConstructMethod.Writer;
			if (!xmlType.IsSingleton)
			{
				StartLoop(xmlType, info);
			}
			ndLoop.Body = AnalyzeContent(ndLoop.Body);
			if (!xmlType.IsSingleton)
			{
				EndLoop(xmlType, info);
			}
		}

		protected virtual void AnalyzeSequence(QilList ndSeq, XmlILConstructInfo info)
		{
			info.ConstructMethod = XmlILConstructMethod.Writer;
			for (int i = 0; i < ndSeq.Count; i++)
			{
				ndSeq[i] = AnalyzeContent(ndSeq[i]);
			}
		}

		protected virtual void AnalyzeConditional(QilTernary ndCond, XmlILConstructInfo info)
		{
			info.ConstructMethod = XmlILConstructMethod.Writer;
			ndCond.Center = AnalyzeContent(ndCond.Center);
			PossibleXmlStates possibleXmlStates = xstates;
			xstates = info.InitialStates;
			ndCond.Right = AnalyzeContent(ndCond.Right);
			if (possibleXmlStates != xstates)
			{
				xstates = PossibleXmlStates.Any;
			}
		}

		protected virtual void AnalyzeChoice(QilChoice ndChoice, XmlILConstructInfo info)
		{
			int num = ndChoice.Branches.Count - 1;
			ndChoice.Branches[num] = AnalyzeContent(ndChoice.Branches[num]);
			PossibleXmlStates possibleXmlStates = xstates;
			while (--num >= 0)
			{
				xstates = info.InitialStates;
				ndChoice.Branches[num] = AnalyzeContent(ndChoice.Branches[num]);
				if (possibleXmlStates != xstates)
				{
					possibleXmlStates = PossibleXmlStates.Any;
				}
			}
			xstates = possibleXmlStates;
		}

		protected virtual void AnalyzeCopy(QilNode ndCopy, XmlILConstructInfo info)
		{
			XmlQueryType xmlType = ndCopy.XmlType;
			if (!xmlType.IsSingleton)
			{
				StartLoop(xmlType, info);
			}
			if (MaybeContent(xmlType))
			{
				if (MaybeAttrNmsp(xmlType))
				{
					if (xstates == PossibleXmlStates.EnumAttrs)
					{
						xstates = PossibleXmlStates.Any;
					}
				}
				else if (xstates == PossibleXmlStates.EnumAttrs || withinElem)
				{
					xstates = PossibleXmlStates.WithinContent;
				}
			}
			if (!xmlType.IsSingleton)
			{
				EndLoop(xmlType, info);
			}
		}

		private void StartLoop(XmlQueryType typ, XmlILConstructInfo info)
		{
			info.BeginLoopStates = xstates;
			if (typ.MaybeMany && xstates == PossibleXmlStates.EnumAttrs && MaybeContent(typ))
			{
				info.BeginLoopStates = (xstates = PossibleXmlStates.Any);
			}
		}

		private void EndLoop(XmlQueryType typ, XmlILConstructInfo info)
		{
			info.EndLoopStates = xstates;
			if (typ.MaybeEmpty && info.InitialStates != xstates)
			{
				xstates = PossibleXmlStates.Any;
			}
		}

		private bool MaybeAttrNmsp(XmlQueryType typ)
		{
			return (typ.NodeKinds & (XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Namespace)) != 0;
		}

		private bool MaybeContent(XmlQueryType typ)
		{
			if (typ.IsNode)
			{
				return (typ.NodeKinds & ~(XmlNodeKindFlags.Attribute | XmlNodeKindFlags.Namespace)) != 0;
			}
			return true;
		}
	}
	internal class XmlILElementAnalyzer : XmlILStateAnalyzer
	{
		private NameTable attrNames = new NameTable();

		private ArrayList dupAttrs = new ArrayList();

		public XmlILElementAnalyzer(QilFactory fac)
			: base(fac)
		{
		}

		public override QilNode Analyze(QilNode ndElem, QilNode ndContent)
		{
			parentInfo = XmlILConstructInfo.Write(ndElem);
			parentInfo.MightHaveNamespacesAfterAttributes = false;
			parentInfo.MightHaveAttributes = false;
			parentInfo.MightHaveDuplicateAttributes = false;
			parentInfo.MightHaveNamespaces = !parentInfo.IsNamespaceInScope;
			dupAttrs.Clear();
			return base.Analyze(ndElem, ndContent);
		}

		protected override void AnalyzeLoop(QilLoop ndLoop, XmlILConstructInfo info)
		{
			if (ndLoop.XmlType.MaybeMany)
			{
				CheckAttributeNamespaceConstruct(ndLoop.XmlType);
			}
			base.AnalyzeLoop(ndLoop, info);
		}

		protected override void AnalyzeCopy(QilNode ndCopy, XmlILConstructInfo info)
		{
			if (ndCopy.NodeType == QilNodeType.AttributeCtor)
			{
				AnalyzeAttributeCtor(ndCopy as QilBinary, info);
			}
			else
			{
				CheckAttributeNamespaceConstruct(ndCopy.XmlType);
			}
			base.AnalyzeCopy(ndCopy, info);
		}

		private void AnalyzeAttributeCtor(QilBinary ndAttr, XmlILConstructInfo info)
		{
			if (ndAttr.Left.NodeType == QilNodeType.LiteralQName)
			{
				QilName qilName = ndAttr.Left as QilName;
				parentInfo.MightHaveAttributes = true;
				if (!parentInfo.MightHaveDuplicateAttributes)
				{
					XmlQualifiedName xmlQualifiedName = new XmlQualifiedName(attrNames.Add(qilName.LocalName), attrNames.Add(qilName.NamespaceUri));
					int i;
					for (i = 0; i < dupAttrs.Count; i++)
					{
						XmlQualifiedName xmlQualifiedName2 = (XmlQualifiedName)dupAttrs[i];
						if ((object)xmlQualifiedName2.Name == xmlQualifiedName.Name && (object)xmlQualifiedName2.Namespace == xmlQualifiedName.Namespace)
						{
							parentInfo.MightHaveDuplicateAttributes = true;
						}
					}
					if (i >= dupAttrs.Count)
					{
						dupAttrs.Add(xmlQualifiedName);
					}
				}
				if (!info.IsNamespaceInScope)
				{
					parentInfo.MightHaveNamespaces = true;
				}
			}
			else
			{
				CheckAttributeNamespaceConstruct(ndAttr.XmlType);
			}
		}

		private void CheckAttributeNamespaceConstruct(XmlQueryType typ)
		{
			if ((typ.NodeKinds & XmlNodeKindFlags.Attribute) != 0)
			{
				parentInfo.MightHaveAttributes = true;
				parentInfo.MightHaveDuplicateAttributes = true;
				parentInfo.MightHaveNamespaces = true;
			}
			if ((typ.NodeKinds & XmlNodeKindFlags.Namespace) != 0)
			{
				parentInfo.MightHaveNamespaces = true;
				if (parentInfo.MightHaveAttributes)
				{
					parentInfo.MightHaveNamespacesAfterAttributes = true;
				}
			}
		}
	}
	internal class XmlILNamespaceAnalyzer
	{
		private XmlNamespaceManager nsmgr = new XmlNamespaceManager(new NameTable());

		private bool addInScopeNmsp;

		private int cntNmsp;

		public void Analyze(QilNode nd, bool defaultNmspInScope)
		{
			addInScopeNmsp = false;
			cntNmsp = 0;
			if (defaultNmspInScope)
			{
				nsmgr.PushScope();
				nsmgr.AddNamespace(string.Empty, string.Empty);
				cntNmsp++;
			}
			AnalyzeContent(nd);
			if (defaultNmspInScope)
			{
				nsmgr.PopScope();
			}
		}

		private void AnalyzeContent(QilNode nd)
		{
			switch (nd.NodeType)
			{
			case QilNodeType.Loop:
				addInScopeNmsp = false;
				AnalyzeContent((nd as QilLoop).Body);
				break;
			case QilNodeType.Sequence:
			{
				foreach (QilNode item in nd)
				{
					AnalyzeContent(item);
				}
				break;
			}
			case QilNodeType.Conditional:
				addInScopeNmsp = false;
				AnalyzeContent((nd as QilTernary).Center);
				AnalyzeContent((nd as QilTernary).Right);
				break;
			case QilNodeType.Choice:
			{
				addInScopeNmsp = false;
				QilList branches = (nd as QilChoice).Branches;
				for (int i = 0; i < branches.Count; i++)
				{
					AnalyzeContent(branches[i]);
				}
				break;
			}
			case QilNodeType.ElementCtor:
			{
				addInScopeNmsp = true;
				nsmgr.PushScope();
				int num = cntNmsp;
				if (CheckNamespaceInScope(nd as QilBinary))
				{
					AnalyzeContent((nd as QilBinary).Right);
				}
				nsmgr.PopScope();
				addInScopeNmsp = false;
				cntNmsp = num;
				break;
			}
			case QilNodeType.AttributeCtor:
				addInScopeNmsp = false;
				CheckNamespaceInScope(nd as QilBinary);
				break;
			case QilNodeType.NamespaceDecl:
				CheckNamespaceInScope(nd as QilBinary);
				break;
			case QilNodeType.Nop:
				AnalyzeContent((nd as QilUnary).Child);
				break;
			default:
				addInScopeNmsp = false;
				break;
			}
		}

		private bool CheckNamespaceInScope(QilBinary nd)
		{
			QilNodeType nodeType = nd.NodeType;
			XPathNodeType nodeKind;
			string text;
			string text2;
			if ((uint)(nodeType - 81) <= 1u)
			{
				QilName qilName = nd.Left as QilName;
				if (!(qilName != null))
				{
					return false;
				}
				text = qilName.Prefix;
				text2 = qilName.NamespaceUri;
				nodeKind = ((nd.NodeType == QilNodeType.ElementCtor) ? XPathNodeType.Element : XPathNodeType.Attribute);
			}
			else
			{
				text = (QilLiteral)nd.Left;
				text2 = (QilLiteral)nd.Right;
				nodeKind = XPathNodeType.Namespace;
			}
			if ((nd.NodeType == QilNodeType.AttributeCtor && text2.Length == 0) || (text == "xml" && text2 == "http://www.w3.org/XML/1998/namespace"))
			{
				XmlILConstructInfo.Write(nd).IsNamespaceInScope = true;
				return true;
			}
			if (!ValidateNames.ValidateName(text, string.Empty, text2, nodeKind, ValidateNames.Flags.CheckPrefixMapping))
			{
				return false;
			}
			text = nsmgr.NameTable.Add(text);
			text2 = nsmgr.NameTable.Add(text2);
			for (int i = 0; i < cntNmsp; i++)
			{
				nsmgr.GetNamespaceDeclaration(i, out var prefix, out var uri);
				if ((object)text == prefix)
				{
					if ((object)text2 == uri)
					{
						XmlILConstructInfo.Write(nd).IsNamespaceInScope = true;
					}
					break;
				}
			}
			if (addInScopeNmsp)
			{
				nsmgr.AddNamespace(text, text2);
				cntNmsp++;
			}
			return true;
		}
	}
	internal enum XmlILMethodAttributes
	{
		None,
		NonUser,
		Raw
	}
	internal class XmlILModule
	{
		public static readonly PermissionSet CreateModulePermissionSet;

		private static long AssemblyId;

		private static ModuleBuilder LREModule;

		private TypeBuilder typeBldr;

		private Hashtable methods;

		private Hashtable urlToSymWriter;

		private string modFile;

		private bool persistAsm;

		private bool useLRE;

		private bool emitSymbols;

		private static readonly Guid LanguageGuid;

		private static readonly Guid VendorGuid;

		private const string RuntimeName = "{urn:schemas-microsoft-com:xslt-debug}runtime";

		public bool EmitSymbols => emitSymbols;

		static XmlILModule()
		{
			LanguageGuid = new Guid(1177373246u, 45655, 19182, 151, 205, 89, 24, 199, 83, 23, 88);
			VendorGuid = new Guid(2571847108u, 59113, 4562, 144, 63, 0, 192, 79, 163, 2, 161);
			CreateModulePermissionSet = new PermissionSet(PermissionState.None);
			CreateModulePermissionSet.AddPermission(new ReflectionPermission(ReflectionPermissionFlag.MemberAccess));
			CreateModulePermissionSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode | SecurityPermissionFlag.ControlEvidence));
			AssemblyId = 0L;
			AssemblyName name = CreateAssemblyName();
			AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run);
			try
			{
				CreateModulePermissionSet.Assert();
				assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(XmlILConstructors.Transparent, new object[0]));
				LREModule = assemblyBuilder.DefineDynamicModule("System.Xml.Xsl.CompiledQuery", emitSymbolInfo: false);
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
		}

		public XmlILModule(TypeBuilder typeBldr)
		{
			this.typeBldr = typeBldr;
			emitSymbols = ((ModuleBuilder)this.typeBldr.Module).GetSymWriter() != null;
			useLRE = false;
			persistAsm = false;
			methods = new Hashtable();
			if (emitSymbols)
			{
				urlToSymWriter = new Hashtable();
			}
		}

		public XmlILModule(bool useLRE, bool emitSymbols)
		{
			this.useLRE = useLRE;
			this.emitSymbols = emitSymbols;
			persistAsm = false;
			methods = new Hashtable();
			if (!useLRE)
			{
				AssemblyName name = CreateAssemblyName();
				AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(name, (!persistAsm) ? AssemblyBuilderAccess.Run : AssemblyBuilderAccess.RunAndSave);
				assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(XmlILConstructors.Transparent, new object[0]));
				if (emitSymbols)
				{
					urlToSymWriter = new Hashtable();
					DebuggableAttribute.DebuggingModes debuggingModes = DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints;
					assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(XmlILConstructors.Debuggable, new object[1] { debuggingModes }));
				}
				typeBldr = ((!persistAsm) ? assemblyBuilder.DefineDynamicModule("System.Xml.Xsl.CompiledQuery", emitSymbols) : assemblyBuilder.DefineDynamicModule("System.Xml.Xsl.CompiledQuery", modFile + ".dll", emitSymbols)).DefineType("System.Xml.Xsl.CompiledQuery.Query", TypeAttributes.Public);
			}
		}

		public MethodInfo DefineMethod(string name, Type returnType, Type[] paramTypes, string[] paramNames, XmlILMethodAttributes xmlAttrs)
		{
			int num = 1;
			string text = name;
			bool flag = (xmlAttrs & XmlILMethodAttributes.Raw) != 0;
			while (methods[name] != null)
			{
				num++;
				name = text + " (" + num + ")";
			}
			if (!flag)
			{
				Type[] array = new Type[paramTypes.Length + 1];
				array[0] = typeof(XmlQueryRuntime);
				Array.Copy(paramTypes, 0, array, 1, paramTypes.Length);
				paramTypes = array;
			}
			MethodInfo methodInfo;
			if (!useLRE)
			{
				MethodBuilder methodBuilder = typeBldr.DefineMethod(name, MethodAttributes.Private | MethodAttributes.Static, returnType, paramTypes);
				if (emitSymbols && (xmlAttrs & XmlILMethodAttributes.NonUser) != 0)
				{
					methodBuilder.SetCustomAttribute(new CustomAttributeBuilder(XmlILConstructors.StepThrough, new object[0]));
					methodBuilder.SetCustomAttribute(new CustomAttributeBuilder(XmlILConstructors.NonUserCode, new object[0]));
				}
				if (!flag)
				{
					methodBuilder.DefineParameter(1, ParameterAttributes.None, "{urn:schemas-microsoft-com:xslt-debug}runtime");
				}
				for (int i = 0; i < paramNames.Length; i++)
				{
					if (paramNames[i] != null && paramNames[i].Length != 0)
					{
						methodBuilder.DefineParameter(i + (flag ? 1 : 2), ParameterAttributes.None, paramNames[i]);
					}
				}
				methodInfo = methodBuilder;
			}
			else
			{
				DynamicMethod dynamicMethod = new DynamicMethod(name, returnType, paramTypes, LREModule);
				dynamicMethod.InitLocals = true;
				if (!flag)
				{
					dynamicMethod.DefineParameter(1, ParameterAttributes.None, "{urn:schemas-microsoft-com:xslt-debug}runtime");
				}
				for (int j = 0; j < paramNames.Length; j++)
				{
					if (paramNames[j] != null && paramNames[j].Length != 0)
					{
						dynamicMethod.DefineParameter(j + (flag ? 1 : 2), ParameterAttributes.None, paramNames[j]);
					}
				}
				methodInfo = dynamicMethod;
			}
			methods[name] = methodInfo;
			return methodInfo;
		}

		public static ILGenerator DefineMethodBody(MethodBase methInfo)
		{
			DynamicMethod dynamicMethod = methInfo as DynamicMethod;
			if (dynamicMethod != null)
			{
				return dynamicMethod.GetILGenerator();
			}
			MethodBuilder methodBuilder = methInfo as MethodBuilder;
			if (methodBuilder != null)
			{
				return methodBuilder.GetILGenerator();
			}
			return ((ConstructorBuilder)methInfo).GetILGenerator();
		}

		public MethodInfo FindMethod(string name)
		{
			return (MethodInfo)methods[name];
		}

		public FieldInfo DefineInitializedData(string name, byte[] data)
		{
			return typeBldr.DefineInitializedData(name, data, FieldAttributes.Private | FieldAttributes.Static);
		}

		public FieldInfo DefineField(string fieldName, Type type)
		{
			return typeBldr.DefineField(fieldName, type, FieldAttributes.Private | FieldAttributes.Static);
		}

		public ConstructorInfo DefineTypeInitializer()
		{
			return typeBldr.DefineTypeInitializer();
		}

		public ISymbolDocumentWriter AddSourceDocument(string fileName)
		{
			ISymbolDocumentWriter symbolDocumentWriter = urlToSymWriter[fileName] as ISymbolDocumentWriter;
			if (symbolDocumentWriter == null)
			{
				symbolDocumentWriter = ((ModuleBuilder)typeBldr.Module).DefineDocument(fileName, LanguageGuid, VendorGuid, Guid.Empty);
				urlToSymWriter.Add(fileName, symbolDocumentWriter);
			}
			return symbolDocumentWriter;
		}

		public void BakeMethods()
		{
			if (useLRE)
			{
				return;
			}
			Type type = typeBldr.CreateType();
			if (persistAsm)
			{
				((AssemblyBuilder)typeBldr.Module.Assembly).Save(modFile + ".dll");
			}
			Hashtable hashtable = new Hashtable(methods.Count);
			foreach (string key in methods.Keys)
			{
				hashtable[key] = type.GetMethod(key, BindingFlags.Static | BindingFlags.NonPublic);
			}
			methods = hashtable;
			typeBldr = null;
			urlToSymWriter = null;
		}

		public Delegate CreateDelegate(string name, Type typDelegate)
		{
			if (!useLRE)
			{
				return Delegate.CreateDelegate(typDelegate, (MethodInfo)methods[name]);
			}
			return ((DynamicMethod)methods[name]).CreateDelegate(typDelegate);
		}

		private static AssemblyName CreateAssemblyName()
		{
			Interlocked.Increment(ref AssemblyId);
			AssemblyName assemblyName = new AssemblyName();
			assemblyName.Name = "System.Xml.Xsl.CompiledQuery." + AssemblyId;
			return assemblyName;
		}
	}
	internal enum XmlILOptimization
	{
		None,
		EliminateLiteralVariables,
		TailCall,
		AnnotateAncestor,
		AnnotateAncestorSelf,
		AnnotateAttribute,
		AnnotateAttrNmspLoop,
		AnnotateBarrier,
		AnnotateConstruction,
		AnnotateContent,
		AnnotateContentLoop,
		AnnotateDescendant,
		AnnotateDescendantLoop,
		AnnotateDescendantSelf,
		AnnotateDifference,
		AnnotateDod,
		AnnotateDodMerge,
		AnnotateDodReverse,
		AnnotateFilter,
		AnnotateFilterAttributeKind,
		AnnotateFilterContentKind,
		AnnotateFilterElements,
		AnnotateFollowingSibling,
		AnnotateIndex1,
		AnnotateIndex2,
		AnnotateIntersect,
		AnnotateInvoke,
		AnnotateJoinAndDod,
		AnnotateLet,
		AnnotateMaxLengthEq,
		AnnotateMaxLengthGe,
		AnnotateMaxLengthGt,
		AnnotateMaxLengthLe,
		AnnotateMaxLengthLt,
		AnnotateMaxLengthNe,
		AnnotateMaxPositionEq,
		AnnotateMaxPositionLe,
		AnnotateMaxPositionLt,
		AnnotateNamespace,
		AnnotateNodeRange,
		AnnotateParent,
		AnnotatePositionalIterator,
		AnnotatePreceding,
		AnnotatePrecedingSibling,
		AnnotateRoot,
		AnnotateRootLoop,
		AnnotateSingleTextRtf,
		AnnotateSingletonLoop,
		AnnotateTrackCallers,
		AnnotateUnion,
		AnnotateUnionContent,
		AnnotateXPathFollowing,
		AnnotateXPathPreceding,
		CommuteDodFilter,
		CommuteFilterLoop,
		EliminateAdd,
		EliminateAfter,
		EliminateAnd,
		EliminateAverage,
		EliminateBefore,
		EliminateConditional,
		EliminateDifference,
		EliminateDivide,
		EliminateDod,
		EliminateEq,
		EliminateFilter,
		EliminateGe,
		EliminateGt,
		EliminateIntersection,
		EliminateIs,
		EliminateIsEmpty,
		EliminateIsType,
		EliminateIterator,
		EliminateIteratorUsedAtMostOnce,
		EliminateLe,
		EliminateLength,
		EliminateLoop,
		EliminateLt,
		EliminateMaximum,
		EliminateMinimum,
		EliminateModulo,
		EliminateMultiply,
		EliminateNamespaceDecl,
		EliminateNe,
		EliminateNegate,
		EliminateNop,
		EliminateNot,
		EliminateOr,
		EliminatePositionOf,
		EliminateReturnDod,
		EliminateSequence,
		EliminateSort,
		EliminateStrConcat,
		EliminateStrConcatSingle,
		EliminateStrLength,
		EliminateSubtract,
		EliminateSum,
		EliminateTypeAssert,
		EliminateTypeAssertOptional,
		EliminateUnion,
		EliminateUnusedGlobals,
		EliminateXsltConvert,
		FoldConditionalNot,
		FoldNamedDescendants,
		FoldNone,
		FoldXsltConvertLiteral,
		IntroduceDod,
		IntroducePrecedingDod,
		NormalizeAddEq,
		NormalizeAddLiteral,
		NormalizeAttribute,
		NormalizeConditionalText,
		NormalizeDifference,
		NormalizeEqLiteral,
		NormalizeGeLiteral,
		NormalizeGtLiteral,
		NormalizeIdEq,
		NormalizeIdNe,
		NormalizeIntersect,
		NormalizeInvokeEmpty,
		NormalizeLeLiteral,
		NormalizeLengthGt,
		NormalizeLengthNe,
		NormalizeLoopConditional,
		NormalizeLoopInvariant,
		NormalizeLoopLoop,
		NormalizeLoopText,
		NormalizeLtLiteral,
		NormalizeMuenchian,
		NormalizeMultiplyLiteral,
		NormalizeNeLiteral,
		NormalizeNestedSequences,
		NormalizeSingletonLet,
		NormalizeSortXsltConvert,
		NormalizeUnion,
		NormalizeXsltConvertEq,
		NormalizeXsltConvertGe,
		NormalizeXsltConvertGt,
		NormalizeXsltConvertLe,
		NormalizeXsltConvertLt,
		NormalizeXsltConvertNe,
		Last_
	}
	internal class XmlILOptimizerVisitor : QilPatternVisitor
	{
		private class NodeCounter : QilVisitor
		{
			protected QilNode target;

			protected int cnt;

			public int Count(QilNode expr, QilNode target)
			{
				cnt = 0;
				this.target = target;
				Visit(expr);
				return cnt;
			}

			protected override QilNode Visit(QilNode n)
			{
				if (n == null)
				{
					return null;
				}
				if (n == target)
				{
					cnt++;
				}
				return VisitChildren(n);
			}

			protected override QilNode VisitReference(QilNode n)
			{
				if (n == target)
				{
					cnt++;
				}
				return n;
			}
		}

		private class NodeFinder : QilVisitor
		{
			protected bool result;

			protected QilNode target;

			protected QilNode parent;

			public bool Find(QilNode expr, QilNode target)
			{
				result = false;
				this.target = target;
				parent = null;
				VisitAssumeReference(expr);
				return result;
			}

			protected override QilNode Visit(QilNode expr)
			{
				if (!result)
				{
					if (expr == target)
					{
						result = OnFound(expr);
					}
					if (!result)
					{
						QilNode qilNode = parent;
						parent = expr;
						VisitChildren(expr);
						parent = qilNode;
					}
				}
				return expr;
			}

			protected override QilNode VisitReference(QilNode expr)
			{
				if (expr == target)
				{
					result = OnFound(expr);
				}
				return expr;
			}

			protected virtual bool OnFound(QilNode expr)
			{
				return true;
			}
		}

		private class PositionOfFinder : NodeFinder
		{
			protected override bool OnFound(QilNode expr)
			{
				if (parent != null)
				{
					return parent.NodeType == QilNodeType.PositionOf;
				}
				return false;
			}
		}

		private class EqualityIndexVisitor : QilVisitor
		{
			protected bool result;

			protected QilNode ctxt;

			protected QilNode key;

			public bool Scan(QilNode expr, QilNode ctxt, QilNode key)
			{
				result = true;
				this.ctxt = ctxt;
				this.key = key;
				Visit(expr);
				return result;
			}

			protected override QilNode VisitReference(QilNode expr)
			{
				if (result && (expr == key || expr == ctxt))
				{
					result = false;
					return expr;
				}
				return expr;
			}

			protected override QilNode VisitRoot(QilUnary root)
			{
				if (root.Child == ctxt)
				{
					return root;
				}
				return VisitChildren(root);
			}
		}

		private static readonly QilPatterns PatternsNoOpt;

		private static readonly QilPatterns PatternsOpt;

		private QilExpression qil;

		private XmlILElementAnalyzer elemAnalyzer;

		private XmlILStateAnalyzer contentAnalyzer;

		private XmlILNamespaceAnalyzer nmspAnalyzer;

		private NodeCounter nodeCounter = new NodeCounter();

		private SubstitutionList subs = new SubstitutionList();

		private bool this[XmlILOptimization ann] => base.Patterns.IsSet((int)ann);

		static XmlILOptimizerVisitor()
		{
			PatternsOpt = new QilPatterns(141, allSet: true);
			PatternsNoOpt = new QilPatterns(141, allSet: false);
			PatternsNoOpt.Add(104);
			PatternsNoOpt.Add(88);
			PatternsNoOpt.Add(97);
			PatternsNoOpt.Add(71);
			PatternsNoOpt.Add(70);
			PatternsNoOpt.Add(58);
			PatternsNoOpt.Add(96);
			PatternsNoOpt.Add(79);
			PatternsNoOpt.Add(78);
			PatternsNoOpt.Add(91);
			PatternsNoOpt.Add(93);
			PatternsNoOpt.Add(134);
			PatternsNoOpt.Add(118);
			PatternsNoOpt.Add(112);
			PatternsNoOpt.Add(41);
			PatternsNoOpt.Add(48);
			PatternsNoOpt.Add(15);
			PatternsNoOpt.Add(8);
			PatternsNoOpt.Add(23);
			PatternsNoOpt.Add(24);
			PatternsNoOpt.Add(7);
			PatternsNoOpt.Add(18);
		}

		public XmlILOptimizerVisitor(QilExpression qil, bool optimize)
			: base(optimize ? PatternsOpt : PatternsNoOpt, qil.Factory)
		{
			this.qil = qil;
			elemAnalyzer = new XmlILElementAnalyzer(qil.Factory);
			contentAnalyzer = new XmlILStateAnalyzer(qil.Factory);
			nmspAnalyzer = new XmlILNamespaceAnalyzer();
		}

		public QilExpression Optimize()
		{
			QilExpression result = (QilExpression)Visit(qil);
			if (this[XmlILOptimization.TailCall])
			{
				TailCallAnalyzer.Analyze(result);
			}
			return result;
		}

		protected override QilNode Visit(QilNode nd)
		{
			if (nd != null && this[XmlILOptimization.EliminateNamespaceDecl])
			{
				switch (nd.NodeType)
				{
				case QilNodeType.QilExpression:
					nmspAnalyzer.Analyze(((QilExpression)nd).Root, defaultNmspInScope: true);
					break;
				case QilNodeType.ElementCtor:
					if (!XmlILConstructInfo.Read(nd).IsNamespaceInScope)
					{
						nmspAnalyzer.Analyze(nd, defaultNmspInScope: false);
					}
					break;
				case QilNodeType.DocumentCtor:
					nmspAnalyzer.Analyze(nd, defaultNmspInScope: true);
					break;
				}
			}
			return base.Visit(nd);
		}

		protected override QilNode VisitReference(QilNode oldNode)
		{
			QilNode qilNode = subs.FindReplacement(oldNode);
			if (qilNode == null)
			{
				qilNode = oldNode;
			}
			if (this[XmlILOptimization.EliminateLiteralVariables] && qilNode != null && (qilNode.NodeType == QilNodeType.Let || qilNode.NodeType == QilNodeType.For))
			{
				QilNode binding = ((QilIterator)oldNode).Binding;
				if (IsLiteral(binding))
				{
					return Replace(XmlILOptimization.EliminateLiteralVariables, qilNode, binding.ShallowClone(f));
				}
			}
			if (this[XmlILOptimization.EliminateUnusedGlobals] && IsGlobalValue(qilNode))
			{
				OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.IsReferenced);
			}
			return base.VisitReference(qilNode);
		}

		protected bool AllowReplace(XmlILOptimization pattern, QilNode original)
		{
			return base.AllowReplace((int)pattern, original);
		}

		protected QilNode Replace(XmlILOptimization pattern, QilNode original, QilNode replacement)
		{
			return base.Replace((int)pattern, original, replacement);
		}

		protected override QilNode NoReplace(QilNode node)
		{
			if (node != null)
			{
				QilNodeType nodeType = node.NodeType;
				if (nodeType <= QilNodeType.Invoke)
				{
					if ((uint)(nodeType - 12) <= 1u || (nodeType == QilNodeType.Invoke && ((QilInvoke)node).Function.MaybeSideEffects))
					{
						goto IL_002c;
					}
				}
				else if (nodeType == QilNodeType.XsltInvokeLateBound || (nodeType == QilNodeType.XsltInvokeEarlyBound && ((QilInvokeEarlyBound)node).Name.NamespaceUri.Length != 0))
				{
					goto IL_002c;
				}
				int num = 0;
				while (num < node.Count)
				{
					if (node[num] == null || !OptimizerPatterns.Read(node[num]).MatchesPattern(OptimizerPatternName.MaybeSideEffects))
					{
						num++;
						continue;
					}
					goto IL_002c;
				}
			}
			goto IL_0095;
			IL_0095:
			return node;
			IL_002c:
			OptimizerPatterns.Write(node).AddPattern(OptimizerPatternName.MaybeSideEffects);
			goto IL_0095;
		}

		protected override void RecalculateType(QilNode node, XmlQueryType oldType)
		{
			if (node.NodeType != QilNodeType.Let || !qil.GlobalVariableList.Contains(node))
			{
				base.RecalculateType(node, oldType);
			}
		}

		protected override QilNode VisitQilExpression(QilExpression local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.EliminateUnusedGlobals] && AllowReplace(XmlILOptimization.EliminateUnusedGlobals, local0))
			{
				EliminateUnusedGlobals(local0.GlobalVariableList);
				EliminateUnusedGlobals(local0.GlobalParameterList);
				EliminateUnusedGlobals(local0.FunctionList);
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				foreach (QilFunction function in local0.FunctionList)
				{
					if (IsConstructedExpression(function.Definition))
					{
						function.Definition = contentAnalyzer.Analyze(function, function.Definition);
					}
				}
				local0.Root = contentAnalyzer.Analyze(null, local0.Root);
				XmlILConstructInfo.Write(local0.Root).PushToWriterLast = true;
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitOptimizeBarrier(QilUnary local0)
		{
			QilNode ndSrc = local0[0];
			if (this[XmlILOptimization.AnnotateBarrier] && AllowReplace(XmlILOptimization.AnnotateBarrier, local0))
			{
				OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDataSource(QilDataSource local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNop(QilUnary local0)
		{
			QilNode replacement = local0[0];
			if (this[XmlILOptimization.EliminateNop] && AllowReplace(XmlILOptimization.EliminateNop, local0))
			{
				return Replace(XmlILOptimization.EliminateNop, local0, replacement);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitError(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitWarning(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLet(QilIterator local0)
		{
			QilNode ndSrc = local0[0];
			if (local0.XmlType.IsSingleton && !IsGlobalVariable(local0) && this[XmlILOptimization.NormalizeSingletonLet] && AllowReplace(XmlILOptimization.NormalizeSingletonLet, local0))
			{
				local0.NodeType = QilNodeType.For;
				VisitFor(local0);
			}
			if (this[XmlILOptimization.AnnotateLet] && AllowReplace(XmlILOptimization.AnnotateLet, local0))
			{
				OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.Step);
				OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitPositionOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.EliminatePositionOf] && qilNode.NodeType != QilNodeType.For && AllowReplace(XmlILOptimization.EliminatePositionOf, local0))
			{
				return Replace(XmlILOptimization.EliminatePositionOf, local0, VisitLiteralInt32(f.LiteralInt32(1)));
			}
			if (this[XmlILOptimization.EliminatePositionOf] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode2 = qilNode[0];
				if (qilNode2.XmlType.IsSingleton && AllowReplace(XmlILOptimization.EliminatePositionOf, local0))
				{
					return Replace(XmlILOptimization.EliminatePositionOf, local0, VisitLiteralInt32(f.LiteralInt32(1)));
				}
			}
			if (this[XmlILOptimization.AnnotatePositionalIterator] && AllowReplace(XmlILOptimization.AnnotatePositionalIterator, local0))
			{
				OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.IsPositional);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAnd(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateAnd] && qilNode.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateAnd, local0))
			{
				return Replace(XmlILOptimization.EliminateAnd, local0, qilNode2);
			}
			if (this[XmlILOptimization.EliminateAnd] && qilNode.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateAnd, local0))
			{
				return Replace(XmlILOptimization.EliminateAnd, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateAnd] && qilNode2.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateAnd, local0))
			{
				return Replace(XmlILOptimization.EliminateAnd, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateAnd] && qilNode2.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateAnd, local0))
			{
				return Replace(XmlILOptimization.EliminateAnd, local0, qilNode2);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitOr(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateOr] && qilNode.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateOr, local0))
			{
				return Replace(XmlILOptimization.EliminateOr, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateOr] && qilNode.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateOr, local0))
			{
				return Replace(XmlILOptimization.EliminateOr, local0, qilNode2);
			}
			if (this[XmlILOptimization.EliminateOr] && qilNode2.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateOr, local0))
			{
				return Replace(XmlILOptimization.EliminateOr, local0, qilNode2);
			}
			if (this[XmlILOptimization.EliminateOr] && qilNode2.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateOr, local0))
			{
				return Replace(XmlILOptimization.EliminateOr, local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNot(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateNot] && qilNode.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateNot, local0))
			{
				return Replace(XmlILOptimization.EliminateNot, local0, VisitFalse(f.False()));
			}
			if (this[XmlILOptimization.EliminateNot] && qilNode.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateNot, local0))
			{
				return Replace(XmlILOptimization.EliminateNot, local0, VisitTrue(f.True()));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitConditional(QilTernary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			QilNode qilNode3 = local0[2];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateConditional] && qilNode.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateConditional, local0))
			{
				return Replace(XmlILOptimization.EliminateConditional, local0, qilNode2);
			}
			if (this[XmlILOptimization.EliminateConditional] && qilNode.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateConditional, local0))
			{
				return Replace(XmlILOptimization.EliminateConditional, local0, qilNode3);
			}
			if (this[XmlILOptimization.EliminateConditional] && qilNode2.NodeType == QilNodeType.True && qilNode3.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateConditional, local0))
			{
				return Replace(XmlILOptimization.EliminateConditional, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateConditional] && qilNode2.NodeType == QilNodeType.False && qilNode3.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateConditional, local0))
			{
				return Replace(XmlILOptimization.EliminateConditional, local0, VisitNot(f.Not(qilNode)));
			}
			if (this[XmlILOptimization.FoldConditionalNot] && qilNode.NodeType == QilNodeType.Not)
			{
				QilNode left = qilNode[0];
				if (AllowReplace(XmlILOptimization.FoldConditionalNot, local0))
				{
					return Replace(XmlILOptimization.FoldConditionalNot, local0, VisitConditional(f.Conditional(left, qilNode3, qilNode2)));
				}
			}
			if (this[XmlILOptimization.NormalizeConditionalText] && qilNode2.NodeType == QilNodeType.TextCtor)
			{
				QilNode center = qilNode2[0];
				if (qilNode3.NodeType == QilNodeType.TextCtor)
				{
					QilNode right = qilNode3[0];
					if (AllowReplace(XmlILOptimization.NormalizeConditionalText, local0))
					{
						return Replace(XmlILOptimization.NormalizeConditionalText, local0, VisitTextCtor(f.TextCtor(VisitConditional(f.Conditional(qilNode, center, right)))));
					}
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitChoice(QilChoice local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				contentAnalyzer.Analyze(local0, null);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLength(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateLength] && qilNode.NodeType == QilNodeType.Sequence && qilNode.Count == 0 && AllowReplace(XmlILOptimization.EliminateLength, local0))
			{
				return Replace(XmlILOptimization.EliminateLength, local0, VisitLiteralInt32(f.LiteralInt32(0)));
			}
			if (this[XmlILOptimization.EliminateLength] && qilNode.XmlType.IsSingleton && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && AllowReplace(XmlILOptimization.EliminateLength, local0))
			{
				return Replace(XmlILOptimization.EliminateLength, local0, VisitLiteralInt32(f.LiteralInt32(1)));
			}
			if (this[XmlILOptimization.IntroducePrecedingDod] && !IsDocOrderDistinct(qilNode) && (IsStepPattern(qilNode, QilNodeType.XPathPreceding) || IsStepPattern(qilNode, QilNodeType.PrecedingSibling)) && AllowReplace(XmlILOptimization.IntroducePrecedingDod, local0))
			{
				return Replace(XmlILOptimization.IntroducePrecedingDod, local0, VisitLength(f.Length(VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)))));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitSequence(QilList local0)
		{
			if (local0.Count == 1 && this[XmlILOptimization.EliminateSequence] && AllowReplace(XmlILOptimization.EliminateSequence, local0))
			{
				return Replace(XmlILOptimization.EliminateSequence, local0, local0[0]);
			}
			if (HasNestedSequence(local0) && this[XmlILOptimization.NormalizeNestedSequences] && AllowReplace(XmlILOptimization.NormalizeNestedSequences, local0))
			{
				QilNode qilNode = VisitSequence(f.Sequence());
				foreach (QilNode item in local0)
				{
					if (item.NodeType == QilNodeType.Sequence)
					{
						qilNode.Add((IList<QilNode>)item);
					}
					else
					{
						qilNode.Add(item);
					}
				}
				qilNode = VisitSequence((QilList)qilNode);
				return Replace(XmlILOptimization.NormalizeNestedSequences, local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitUnion(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateUnion] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateUnion, local0))
			{
				return Replace(XmlILOptimization.EliminateUnion, local0, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)));
			}
			if (this[XmlILOptimization.EliminateUnion] && qilNode.NodeType == QilNodeType.Sequence && qilNode.Count == 0 && AllowReplace(XmlILOptimization.EliminateUnion, local0))
			{
				return Replace(XmlILOptimization.EliminateUnion, local0, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateUnion] && qilNode2.NodeType == QilNodeType.Sequence && qilNode2.Count == 0 && AllowReplace(XmlILOptimization.EliminateUnion, local0))
			{
				return Replace(XmlILOptimization.EliminateUnion, local0, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)));
			}
			if (this[XmlILOptimization.EliminateUnion] && qilNode.NodeType == QilNodeType.XmlContext && qilNode2.NodeType == QilNodeType.XmlContext && AllowReplace(XmlILOptimization.EliminateUnion, local0))
			{
				return Replace(XmlILOptimization.EliminateUnion, local0, qilNode);
			}
			if (this[XmlILOptimization.NormalizeUnion] && (!IsDocOrderDistinct(qilNode) || !IsDocOrderDistinct(qilNode2)) && AllowReplace(XmlILOptimization.NormalizeUnion, local0))
			{
				return Replace(XmlILOptimization.NormalizeUnion, local0, VisitUnion(f.Union(VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)), VisitDocOrderDistinct(f.DocOrderDistinct(qilNode2)))));
			}
			if (this[XmlILOptimization.AnnotateUnion] && AllowReplace(XmlILOptimization.AnnotateUnion, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			if (this[XmlILOptimization.AnnotateUnionContent] && (IsStepPattern(qilNode, QilNodeType.Content) || IsStepPattern(qilNode, QilNodeType.Union)) && (IsStepPattern(qilNode2, QilNodeType.Content) || IsStepPattern(qilNode2, QilNodeType.Union)) && OptimizerPatterns.Read(qilNode).GetArgument(OptimizerPatternArgument.StepInput) == OptimizerPatterns.Read(qilNode2).GetArgument(OptimizerPatternArgument.StepInput) && AllowReplace(XmlILOptimization.AnnotateUnionContent, local0))
			{
				AddStepPattern(local0, (QilNode)OptimizerPatterns.Read(qilNode).GetArgument(OptimizerPatternArgument.StepInput));
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitIntersection(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateIntersection] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateIntersection, local0))
			{
				return Replace(XmlILOptimization.EliminateIntersection, local0, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)));
			}
			if (this[XmlILOptimization.EliminateIntersection] && qilNode.NodeType == QilNodeType.Sequence && qilNode.Count == 0 && AllowReplace(XmlILOptimization.EliminateIntersection, local0))
			{
				return Replace(XmlILOptimization.EliminateIntersection, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateIntersection] && qilNode2.NodeType == QilNodeType.Sequence && qilNode2.Count == 0 && AllowReplace(XmlILOptimization.EliminateIntersection, local0))
			{
				return Replace(XmlILOptimization.EliminateIntersection, local0, qilNode2);
			}
			if (this[XmlILOptimization.EliminateIntersection] && qilNode.NodeType == QilNodeType.XmlContext && qilNode2.NodeType == QilNodeType.XmlContext && AllowReplace(XmlILOptimization.EliminateIntersection, local0))
			{
				return Replace(XmlILOptimization.EliminateIntersection, local0, qilNode);
			}
			if (this[XmlILOptimization.NormalizeIntersect] && (!IsDocOrderDistinct(qilNode) || !IsDocOrderDistinct(qilNode2)) && AllowReplace(XmlILOptimization.NormalizeIntersect, local0))
			{
				return Replace(XmlILOptimization.NormalizeIntersect, local0, VisitIntersection(f.Intersection(VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)), VisitDocOrderDistinct(f.DocOrderDistinct(qilNode2)))));
			}
			if (this[XmlILOptimization.AnnotateIntersect] && AllowReplace(XmlILOptimization.AnnotateIntersect, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDifference(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateDifference] && qilNode.NodeType == QilNodeType.Sequence && qilNode.Count == 0 && AllowReplace(XmlILOptimization.EliminateDifference, local0))
			{
				return Replace(XmlILOptimization.EliminateDifference, local0, qilNode);
			}
			if (this[XmlILOptimization.EliminateDifference] && qilNode2.NodeType == QilNodeType.Sequence && qilNode2.Count == 0 && AllowReplace(XmlILOptimization.EliminateDifference, local0))
			{
				return Replace(XmlILOptimization.EliminateDifference, local0, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)));
			}
			if (this[XmlILOptimization.EliminateDifference] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateDifference, local0))
			{
				return Replace(XmlILOptimization.EliminateDifference, local0, VisitSequence(f.Sequence()));
			}
			if (this[XmlILOptimization.EliminateDifference] && qilNode.NodeType == QilNodeType.XmlContext && qilNode2.NodeType == QilNodeType.XmlContext && AllowReplace(XmlILOptimization.EliminateDifference, local0))
			{
				return Replace(XmlILOptimization.EliminateDifference, local0, VisitSequence(f.Sequence()));
			}
			if (this[XmlILOptimization.NormalizeDifference] && (!IsDocOrderDistinct(qilNode) || !IsDocOrderDistinct(qilNode2)) && AllowReplace(XmlILOptimization.NormalizeDifference, local0))
			{
				return Replace(XmlILOptimization.NormalizeDifference, local0, VisitDifference(f.Difference(VisitDocOrderDistinct(f.DocOrderDistinct(qilNode)), VisitDocOrderDistinct(f.DocOrderDistinct(qilNode2)))));
			}
			if (this[XmlILOptimization.AnnotateDifference] && AllowReplace(XmlILOptimization.AnnotateDifference, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAverage(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateAverage] && qilNode.XmlType.Cardinality == XmlQueryCardinality.Zero && AllowReplace(XmlILOptimization.EliminateAverage, local0))
			{
				return Replace(XmlILOptimization.EliminateAverage, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitSum(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateSum] && qilNode.XmlType.Cardinality == XmlQueryCardinality.Zero && AllowReplace(XmlILOptimization.EliminateSum, local0))
			{
				return Replace(XmlILOptimization.EliminateSum, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitMinimum(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateMinimum] && qilNode.XmlType.Cardinality == XmlQueryCardinality.Zero && AllowReplace(XmlILOptimization.EliminateMinimum, local0))
			{
				return Replace(XmlILOptimization.EliminateMinimum, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitMaximum(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateMaximum] && qilNode.XmlType.Cardinality == XmlQueryCardinality.Zero && AllowReplace(XmlILOptimization.EliminateMaximum, local0))
			{
				return Replace(XmlILOptimization.EliminateMaximum, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNegate(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateNegate] && qilNode.NodeType == QilNodeType.LiteralDecimal)
			{
				decimal num = (decimal)((QilLiteral)qilNode).Value;
				if (AllowReplace(XmlILOptimization.EliminateNegate, local0))
				{
					return Replace(XmlILOptimization.EliminateNegate, local0, VisitLiteralDecimal(f.LiteralDecimal(-num)));
				}
			}
			if (this[XmlILOptimization.EliminateNegate] && qilNode.NodeType == QilNodeType.LiteralDouble)
			{
				double num2 = (double)((QilLiteral)qilNode).Value;
				if (AllowReplace(XmlILOptimization.EliminateNegate, local0))
				{
					return Replace(XmlILOptimization.EliminateNegate, local0, VisitLiteralDouble(f.LiteralDouble(0.0 - num2)));
				}
			}
			if (this[XmlILOptimization.EliminateNegate] && qilNode.NodeType == QilNodeType.LiteralInt32)
			{
				int num3 = (int)((QilLiteral)qilNode).Value;
				if (AllowReplace(XmlILOptimization.EliminateNegate, local0))
				{
					return Replace(XmlILOptimization.EliminateNegate, local0, VisitLiteralInt32(f.LiteralInt32(-num3)));
				}
			}
			if (this[XmlILOptimization.EliminateNegate] && qilNode.NodeType == QilNodeType.LiteralInt64)
			{
				long num4 = (long)((QilLiteral)qilNode).Value;
				if (AllowReplace(XmlILOptimization.EliminateNegate, local0))
				{
					return Replace(XmlILOptimization.EliminateNegate, local0, VisitLiteralInt64(f.LiteralInt64(-num4)));
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAdd(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateAdd] && IsLiteral(qilNode) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Add, (QilLiteral)qilNode, (QilLiteral)qilNode2) && AllowReplace(XmlILOptimization.EliminateAdd, local0))
			{
				return Replace(XmlILOptimization.EliminateAdd, local0, FoldArithmetic(QilNodeType.Add, (QilLiteral)qilNode, (QilLiteral)qilNode2));
			}
			if (this[XmlILOptimization.NormalizeAddLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeAddLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeAddLiteral, local0, VisitAdd(f.Add(qilNode2, qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitSubtract(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateSubtract] && IsLiteral(qilNode) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Subtract, (QilLiteral)qilNode, (QilLiteral)qilNode2) && AllowReplace(XmlILOptimization.EliminateSubtract, local0))
			{
				return Replace(XmlILOptimization.EliminateSubtract, local0, FoldArithmetic(QilNodeType.Subtract, (QilLiteral)qilNode, (QilLiteral)qilNode2));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitMultiply(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateMultiply] && IsLiteral(qilNode) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Multiply, (QilLiteral)qilNode, (QilLiteral)qilNode2) && AllowReplace(XmlILOptimization.EliminateMultiply, local0))
			{
				return Replace(XmlILOptimization.EliminateMultiply, local0, FoldArithmetic(QilNodeType.Multiply, (QilLiteral)qilNode, (QilLiteral)qilNode2));
			}
			if (this[XmlILOptimization.NormalizeMultiplyLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeMultiplyLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeMultiplyLiteral, local0, VisitMultiply(f.Multiply(qilNode2, qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDivide(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateDivide] && IsLiteral(qilNode) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Divide, (QilLiteral)qilNode, (QilLiteral)qilNode2) && AllowReplace(XmlILOptimization.EliminateDivide, local0))
			{
				return Replace(XmlILOptimization.EliminateDivide, local0, FoldArithmetic(QilNodeType.Divide, (QilLiteral)qilNode, (QilLiteral)qilNode2));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitModulo(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateModulo] && IsLiteral(qilNode) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Modulo, (QilLiteral)qilNode, (QilLiteral)qilNode2) && AllowReplace(XmlILOptimization.EliminateModulo, local0))
			{
				return Replace(XmlILOptimization.EliminateModulo, local0, FoldArithmetic(QilNodeType.Modulo, (QilLiteral)qilNode, (QilLiteral)qilNode2));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitStrLength(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateStrLength] && qilNode.NodeType == QilNodeType.LiteralString)
			{
				string text = (string)((QilLiteral)qilNode).Value;
				if (AllowReplace(XmlILOptimization.EliminateStrLength, local0))
				{
					return Replace(XmlILOptimization.EliminateStrLength, local0, VisitLiteralInt32(f.LiteralInt32(text.Length)));
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitStrConcat(QilStrConcat local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (qilNode2.XmlType.IsSingleton && this[XmlILOptimization.EliminateStrConcatSingle] && AllowReplace(XmlILOptimization.EliminateStrConcatSingle, local0))
			{
				return Replace(XmlILOptimization.EliminateStrConcatSingle, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateStrConcat] && qilNode.NodeType == QilNodeType.LiteralString)
			{
				string delimiter = (string)((QilLiteral)qilNode).Value;
				if (qilNode2.NodeType == QilNodeType.Sequence && AreLiteralArgs(qilNode2) && AllowReplace(XmlILOptimization.EliminateStrConcat, local0))
				{
					StringConcat stringConcat = default(StringConcat);
					stringConcat.Delimiter = delimiter;
					foreach (QilLiteral item in qilNode2)
					{
						stringConcat.Concat(item);
					}
					return Replace(XmlILOptimization.EliminateStrConcat, local0, VisitLiteralString(f.LiteralString(stringConcat.GetResult())));
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitStrParseQName(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNe(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateNe] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateNe, local0))
			{
				return Replace(XmlILOptimization.EliminateNe, local0, FoldComparison(QilNodeType.Ne, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeNeLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeNeLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeNeLiteral, local0, VisitNe(f.Ne(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertNe] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertNe, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertNe, local0, VisitNe(f.Ne(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeIdNe] && qilNode.NodeType == QilNodeType.XsltGenerateId)
			{
				QilNode qilNode5 = qilNode[0];
				if (qilNode5.XmlType.IsSingleton && qilNode2.NodeType == QilNodeType.XsltGenerateId)
				{
					QilNode qilNode6 = qilNode2[0];
					if (qilNode6.XmlType.IsSingleton && AllowReplace(XmlILOptimization.NormalizeIdNe, local0))
					{
						return Replace(XmlILOptimization.NormalizeIdNe, local0, VisitNot(f.Not(VisitIs(f.Is(qilNode5, qilNode6)))));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeLengthNe] && qilNode.NodeType == QilNodeType.Length)
			{
				QilNode child = qilNode[0];
				if (qilNode2.NodeType == QilNodeType.LiteralInt32 && (int)((QilLiteral)qilNode2).Value == 0 && AllowReplace(XmlILOptimization.NormalizeLengthNe, local0))
				{
					return Replace(XmlILOptimization.NormalizeLengthNe, local0, VisitNot(f.Not(VisitIsEmpty(f.IsEmpty(child)))));
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthNe] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthNe, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitEq(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateEq] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateEq, local0))
			{
				return Replace(XmlILOptimization.EliminateEq, local0, FoldComparison(QilNodeType.Eq, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeEqLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeEqLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeEqLiteral, local0, VisitEq(f.Eq(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertEq] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertEq, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertEq, local0, VisitEq(f.Eq(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeAddEq] && qilNode.NodeType == QilNodeType.Add)
			{
				QilNode left = qilNode[0];
				QilNode qilNode5 = qilNode[1];
				if (IsLiteral(qilNode5) && IsLiteral(qilNode2) && CanFoldArithmetic(QilNodeType.Subtract, (QilLiteral)qilNode2, (QilLiteral)qilNode5) && AllowReplace(XmlILOptimization.NormalizeAddEq, local0))
				{
					return Replace(XmlILOptimization.NormalizeAddEq, local0, VisitEq(f.Eq(left, FoldArithmetic(QilNodeType.Subtract, (QilLiteral)qilNode2, (QilLiteral)qilNode5))));
				}
			}
			if (this[XmlILOptimization.NormalizeIdEq] && qilNode.NodeType == QilNodeType.XsltGenerateId)
			{
				QilNode qilNode6 = qilNode[0];
				if (qilNode6.XmlType.IsSingleton && qilNode2.NodeType == QilNodeType.XsltGenerateId)
				{
					QilNode qilNode7 = qilNode2[0];
					if (qilNode7.XmlType.IsSingleton && AllowReplace(XmlILOptimization.NormalizeIdEq, local0))
					{
						return Replace(XmlILOptimization.NormalizeIdEq, local0, VisitIs(f.Is(qilNode6, qilNode7)));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeIdEq] && qilNode.NodeType == QilNodeType.XsltGenerateId)
			{
				QilNode qilNode8 = qilNode[0];
				if (qilNode8.XmlType.IsSingleton && qilNode2.NodeType == QilNodeType.StrConcat)
				{
					QilNode qilNode9 = qilNode2[1];
					if (qilNode9.NodeType == QilNodeType.Loop)
					{
						QilNode qilNode10 = qilNode9[0];
						QilNode qilNode11 = qilNode9[1];
						if (qilNode10.NodeType == QilNodeType.For)
						{
							QilNode qilNode12 = qilNode10[0];
							if (!qilNode12.XmlType.MaybeMany && qilNode11.NodeType == QilNodeType.XsltGenerateId)
							{
								QilNode qilNode13 = qilNode11[0];
								if (qilNode13 == qilNode10 && AllowReplace(XmlILOptimization.NormalizeIdEq, local0))
								{
									QilNode qilNode14 = VisitFor(f.For(qilNode12));
									return Replace(XmlILOptimization.NormalizeIdEq, local0, VisitNot(f.Not(VisitIsEmpty(f.IsEmpty(VisitFilter(f.Filter(qilNode14, VisitIs(f.Is(qilNode8, qilNode14)))))))));
								}
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.NormalizeIdEq] && qilNode.NodeType == QilNodeType.StrConcat)
			{
				QilNode qilNode15 = qilNode[1];
				if (qilNode15.NodeType == QilNodeType.Loop)
				{
					QilNode qilNode16 = qilNode15[0];
					QilNode qilNode17 = qilNode15[1];
					if (qilNode16.NodeType == QilNodeType.For)
					{
						QilNode qilNode18 = qilNode16[0];
						if (!qilNode18.XmlType.MaybeMany && qilNode17.NodeType == QilNodeType.XsltGenerateId)
						{
							QilNode qilNode19 = qilNode17[0];
							if (qilNode19 == qilNode16 && qilNode2.NodeType == QilNodeType.XsltGenerateId)
							{
								QilNode qilNode20 = qilNode2[0];
								if (qilNode20.XmlType.IsSingleton && AllowReplace(XmlILOptimization.NormalizeIdEq, local0))
								{
									QilNode qilNode21 = VisitFor(f.For(qilNode18));
									return Replace(XmlILOptimization.NormalizeIdEq, local0, VisitNot(f.Not(VisitIsEmpty(f.IsEmpty(VisitFilter(f.Filter(qilNode21, VisitIs(f.Is(qilNode20, qilNode21)))))))));
								}
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.NormalizeMuenchian] && qilNode.NodeType == QilNodeType.Length)
			{
				QilNode qilNode22 = qilNode[0];
				if (qilNode22.NodeType == QilNodeType.Union)
				{
					QilNode qilNode23 = qilNode22[0];
					QilNode qilNode24 = qilNode22[1];
					if (qilNode23.XmlType.IsSingleton && !qilNode24.XmlType.MaybeMany && qilNode2.NodeType == QilNodeType.LiteralInt32)
					{
						int num = (int)((QilLiteral)qilNode2).Value;
						if (num == 1 && AllowReplace(XmlILOptimization.NormalizeMuenchian, local0))
						{
							QilNode qilNode25 = VisitFor(f.For(qilNode24));
							return Replace(XmlILOptimization.NormalizeMuenchian, local0, VisitIsEmpty(f.IsEmpty(VisitFilter(f.Filter(qilNode25, VisitNot(f.Not(VisitIs(f.Is(qilNode23, qilNode25)))))))));
						}
					}
				}
			}
			if (this[XmlILOptimization.NormalizeMuenchian] && qilNode.NodeType == QilNodeType.Length)
			{
				QilNode qilNode26 = qilNode[0];
				if (qilNode26.NodeType == QilNodeType.Union)
				{
					QilNode qilNode27 = qilNode26[0];
					QilNode qilNode28 = qilNode26[1];
					if (!qilNode27.XmlType.MaybeMany && qilNode28.XmlType.IsSingleton && qilNode2.NodeType == QilNodeType.LiteralInt32)
					{
						int num2 = (int)((QilLiteral)qilNode2).Value;
						if (num2 == 1 && AllowReplace(XmlILOptimization.NormalizeMuenchian, local0))
						{
							QilNode qilNode29 = VisitFor(f.For(qilNode27));
							return Replace(XmlILOptimization.NormalizeMuenchian, local0, VisitIsEmpty(f.IsEmpty(VisitFilter(f.Filter(qilNode29, VisitNot(f.Not(VisitIs(f.Is(qilNode29, qilNode28)))))))));
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthEq] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num3 = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthEq, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num3);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitGt(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateGt] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateGt, local0))
			{
				return Replace(XmlILOptimization.EliminateGt, local0, FoldComparison(QilNodeType.Gt, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeGtLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeGtLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeGtLiteral, local0, VisitLt(f.Lt(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertGt] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertGt, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertGt, local0, VisitGt(f.Gt(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeLengthGt] && qilNode.NodeType == QilNodeType.Length)
			{
				QilNode child = qilNode[0];
				if (qilNode2.NodeType == QilNodeType.LiteralInt32 && (int)((QilLiteral)qilNode2).Value == 0 && AllowReplace(XmlILOptimization.NormalizeLengthGt, local0))
				{
					return Replace(XmlILOptimization.NormalizeLengthGt, local0, VisitNot(f.Not(VisitIsEmpty(f.IsEmpty(child)))));
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthGt] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthGt, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitGe(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateGe] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateGe, local0))
			{
				return Replace(XmlILOptimization.EliminateGe, local0, FoldComparison(QilNodeType.Ge, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeGeLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeGeLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeGeLiteral, local0, VisitLe(f.Le(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertGe] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertGe, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertGe, local0, VisitGe(f.Ge(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthGe] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthGe, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLt(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateLt] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateLt, local0))
			{
				return Replace(XmlILOptimization.EliminateLt, local0, FoldComparison(QilNodeType.Lt, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeLtLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeLtLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeLtLiteral, local0, VisitGt(f.Gt(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertLt] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertLt, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertLt, local0, VisitLt(f.Lt(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthLt] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthLt, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLe(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateLe] && IsLiteral(qilNode) && IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.EliminateLe, local0))
			{
				return Replace(XmlILOptimization.EliminateLe, local0, FoldComparison(QilNodeType.Le, qilNode, qilNode2));
			}
			if (this[XmlILOptimization.NormalizeLeLiteral] && IsLiteral(qilNode) && !IsLiteral(qilNode2) && AllowReplace(XmlILOptimization.NormalizeLeLiteral, local0))
			{
				return Replace(XmlILOptimization.NormalizeLeLiteral, local0, VisitGe(f.Ge(qilNode2, qilNode)));
			}
			if (this[XmlILOptimization.NormalizeXsltConvertLe] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode3 = qilNode[0];
				QilNode qilNode4 = qilNode[1];
				if (qilNode4.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType typ = (XmlQueryType)((QilLiteral)qilNode4).Value;
					if (IsPrimitiveNumeric(qilNode3.XmlType) && IsPrimitiveNumeric(typ) && IsLiteral(qilNode2) && CanFoldXsltConvertNonLossy(qilNode2, qilNode3.XmlType) && AllowReplace(XmlILOptimization.NormalizeXsltConvertLe, local0))
					{
						return Replace(XmlILOptimization.NormalizeXsltConvertLe, local0, VisitLe(f.Le(qilNode3, FoldXsltConvert(qilNode2, qilNode3.XmlType))));
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxLengthLe] && qilNode.NodeType == QilNodeType.Length && qilNode2.NodeType == QilNodeType.LiteralInt32)
			{
				int num = (int)((QilLiteral)qilNode2).Value;
				if (AllowReplace(XmlILOptimization.AnnotateMaxLengthLe, local0))
				{
					OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
					OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitIs(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateIs] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateIs, local0))
			{
				return Replace(XmlILOptimization.EliminateIs, local0, VisitTrue(f.True()));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAfter(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateAfter] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateAfter, local0))
			{
				return Replace(XmlILOptimization.EliminateAfter, local0, VisitFalse(f.False()));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitBefore(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.EliminateBefore] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateBefore, local0))
			{
				return Replace(XmlILOptimization.EliminateBefore, local0, VisitFalse(f.False()));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLoop(QilLoop local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode[0])));
			}
			if (this[XmlILOptimization.EliminateIterator] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode3 = qilNode[0];
				if (qilNode3.NodeType == QilNodeType.For && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.IsPositional) && AllowReplace(XmlILOptimization.EliminateIterator, local0))
				{
					return Replace(XmlILOptimization.EliminateIterator, local0, Subs(qilNode2, qilNode, qilNode3));
				}
			}
			if (this[XmlILOptimization.EliminateLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode4 = qilNode[0];
				if (qilNode4.NodeType == QilNodeType.Sequence && qilNode4.Count == 0 && AllowReplace(XmlILOptimization.EliminateLoop, local0))
				{
					return Replace(XmlILOptimization.EliminateLoop, local0, VisitSequence(f.Sequence()));
				}
			}
			if (this[XmlILOptimization.EliminateLoop] && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.Sequence && qilNode2.Count == 0 && AllowReplace(XmlILOptimization.EliminateLoop, local0))
			{
				return Replace(XmlILOptimization.EliminateLoop, local0, VisitSequence(f.Sequence()));
			}
			if (this[XmlILOptimization.EliminateLoop] && qilNode2 == qilNode && AllowReplace(XmlILOptimization.EliminateLoop, local0))
			{
				return Replace(XmlILOptimization.EliminateLoop, local0, qilNode[0]);
			}
			if (this[XmlILOptimization.NormalizeLoopText] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode5 = qilNode[0];
				if (qilNode5.XmlType.IsSingleton && qilNode2.NodeType == QilNodeType.TextCtor)
				{
					QilNode body = qilNode2[0];
					if (AllowReplace(XmlILOptimization.NormalizeLoopText, local0))
					{
						return Replace(XmlILOptimization.NormalizeLoopText, local0, VisitTextCtor(f.TextCtor(VisitLoop(f.Loop(qilNode, body)))));
					}
				}
			}
			if (this[XmlILOptimization.EliminateIteratorUsedAtMostOnce] && (qilNode.NodeType == QilNodeType.Let || qilNode[0].XmlType.IsSingleton) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && nodeCounter.Count(qilNode2, qilNode) <= 1 && AllowReplace(XmlILOptimization.EliminateIteratorUsedAtMostOnce, local0))
			{
				return Replace(XmlILOptimization.EliminateIteratorUsedAtMostOnce, local0, Subs(qilNode2, qilNode, qilNode[0]));
			}
			if (this[XmlILOptimization.NormalizeLoopConditional] && qilNode2.NodeType == QilNodeType.Conditional)
			{
				QilNode child = qilNode2[0];
				QilNode qilNode6 = qilNode2[1];
				QilNode qilNode7 = qilNode2[2];
				if (qilNode6.NodeType == QilNodeType.Sequence && qilNode6.Count == 0 && qilNode7 == qilNode && AllowReplace(XmlILOptimization.NormalizeLoopConditional, local0))
				{
					return Replace(XmlILOptimization.NormalizeLoopConditional, local0, VisitFilter(f.Filter(qilNode, VisitNot(f.Not(child)))));
				}
			}
			if (this[XmlILOptimization.NormalizeLoopConditional] && qilNode2.NodeType == QilNodeType.Conditional)
			{
				QilNode body2 = qilNode2[0];
				QilNode qilNode8 = qilNode2[1];
				QilNode qilNode9 = qilNode2[2];
				if (qilNode8 == qilNode && qilNode9.NodeType == QilNodeType.Sequence && qilNode9.Count == 0 && AllowReplace(XmlILOptimization.NormalizeLoopConditional, local0))
				{
					return Replace(XmlILOptimization.NormalizeLoopConditional, local0, VisitFilter(f.Filter(qilNode, body2)));
				}
			}
			if (this[XmlILOptimization.NormalizeLoopConditional] && qilNode.NodeType == QilNodeType.For && qilNode2.NodeType == QilNodeType.Conditional)
			{
				QilNode child2 = qilNode2[0];
				QilNode qilNode10 = qilNode2[1];
				QilNode expr = qilNode2[2];
				if (qilNode10.NodeType == QilNodeType.Sequence && qilNode10.Count == 0 && NonPositional(expr, qilNode) && AllowReplace(XmlILOptimization.NormalizeLoopConditional, local0))
				{
					QilNode qilNode11 = VisitFor(f.For(VisitFilter(f.Filter(qilNode, VisitNot(f.Not(child2))))));
					return Replace(XmlILOptimization.NormalizeLoopConditional, local0, VisitLoop(f.Loop(qilNode11, Subs(expr, qilNode, qilNode11))));
				}
			}
			if (this[XmlILOptimization.NormalizeLoopConditional] && qilNode.NodeType == QilNodeType.For && qilNode2.NodeType == QilNodeType.Conditional)
			{
				QilNode body3 = qilNode2[0];
				QilNode expr2 = qilNode2[1];
				QilNode qilNode12 = qilNode2[2];
				if (NonPositional(expr2, qilNode) && qilNode12.NodeType == QilNodeType.Sequence && qilNode12.Count == 0 && AllowReplace(XmlILOptimization.NormalizeLoopConditional, local0))
				{
					QilNode qilNode13 = VisitFor(f.For(VisitFilter(f.Filter(qilNode, body3))));
					return Replace(XmlILOptimization.NormalizeLoopConditional, local0, VisitLoop(f.Loop(qilNode13, Subs(expr2, qilNode, qilNode13))));
				}
			}
			if (this[XmlILOptimization.NormalizeLoopLoop] && qilNode2.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode14 = qilNode2[0];
				QilNode expr3 = qilNode2[1];
				if (qilNode14.NodeType == QilNodeType.For)
				{
					QilNode body4 = qilNode14[0];
					if (!DependsOn(expr3, qilNode) && NonPositional(expr3, qilNode14) && AllowReplace(XmlILOptimization.NormalizeLoopLoop, local0))
					{
						QilNode qilNode15 = VisitFor(f.For(VisitLoop(f.Loop(qilNode, body4))));
						return Replace(XmlILOptimization.NormalizeLoopLoop, local0, VisitLoop(f.Loop(qilNode15, Subs(expr3, qilNode14, qilNode15))));
					}
				}
			}
			if (this[XmlILOptimization.AnnotateSingletonLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode16 = qilNode[0];
				if (!qilNode16.XmlType.MaybeMany && AllowReplace(XmlILOptimization.AnnotateSingletonLoop, local0))
				{
					OptimizerPatterns.Inherit(qilNode2, local0, OptimizerPatternName.IsDocOrderDistinct);
					OptimizerPatterns.Inherit(qilNode2, local0, OptimizerPatternName.SameDepth);
				}
			}
			if (this[XmlILOptimization.AnnotateRootLoop] && IsStepPattern(qilNode2, QilNodeType.Root) && AllowReplace(XmlILOptimization.AnnotateRootLoop, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			if (this[XmlILOptimization.AnnotateContentLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode17 = qilNode[0];
				if (OptimizerPatterns.Read(qilNode17).MatchesPattern(OptimizerPatternName.SameDepth) && (IsStepPattern(qilNode2, QilNodeType.Content) || IsStepPattern(qilNode2, QilNodeType.Union)) && qilNode == OptimizerPatterns.Read(qilNode2).GetArgument(OptimizerPatternArgument.StepInput) && AllowReplace(XmlILOptimization.AnnotateContentLoop, local0))
				{
					OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
					OptimizerPatterns.Inherit(qilNode17, local0, OptimizerPatternName.IsDocOrderDistinct);
				}
			}
			if (this[XmlILOptimization.AnnotateAttrNmspLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode ndSrc = qilNode[0];
				if ((IsStepPattern(qilNode2, QilNodeType.Attribute) || IsStepPattern(qilNode2, QilNodeType.XPathNamespace) || OptimizerPatterns.Read(qilNode2).MatchesPattern(OptimizerPatternName.FilterAttributeKind)) && qilNode == OptimizerPatterns.Read(qilNode2).GetArgument(OptimizerPatternArgument.StepInput) && AllowReplace(XmlILOptimization.AnnotateAttrNmspLoop, local0))
				{
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.SameDepth);
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.IsDocOrderDistinct);
				}
			}
			if (this[XmlILOptimization.AnnotateDescendantLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode18 = qilNode[0];
				if (OptimizerPatterns.Read(qilNode18).MatchesPattern(OptimizerPatternName.SameDepth) && (IsStepPattern(qilNode2, QilNodeType.Descendant) || IsStepPattern(qilNode2, QilNodeType.DescendantOrSelf)) && qilNode == OptimizerPatterns.Read(qilNode2).GetArgument(OptimizerPatternArgument.StepInput) && AllowReplace(XmlILOptimization.AnnotateDescendantLoop, local0))
				{
					OptimizerPatterns.Inherit(qilNode18, local0, OptimizerPatternName.IsDocOrderDistinct);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitFilter(QilLoop local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode[0])));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitLoop(f.Loop(qilNode, qilNode2)));
			}
			if (this[XmlILOptimization.EliminateFilter] && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.False && AllowReplace(XmlILOptimization.EliminateFilter, local0))
			{
				return Replace(XmlILOptimization.EliminateFilter, local0, VisitSequence(f.Sequence()));
			}
			if (this[XmlILOptimization.EliminateFilter] && qilNode2.NodeType == QilNodeType.True && AllowReplace(XmlILOptimization.EliminateFilter, local0))
			{
				return Replace(XmlILOptimization.EliminateFilter, local0, qilNode[0]);
			}
			if (this[XmlILOptimization.NormalizeAttribute] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode3 = qilNode[0];
				if (qilNode3.NodeType == QilNodeType.Content)
				{
					QilNode left = qilNode3[0];
					if (qilNode2.NodeType == QilNodeType.And)
					{
						QilNode qilNode4 = qilNode2[0];
						QilNode qilNode5 = qilNode2[1];
						if (qilNode4.NodeType == QilNodeType.IsType)
						{
							QilNode qilNode6 = qilNode4[0];
							QilNode qilNode7 = qilNode4[1];
							if (qilNode6 == qilNode && qilNode7.NodeType == QilNodeType.LiteralType)
							{
								XmlQueryType xmlQueryType = (XmlQueryType)((QilLiteral)qilNode7).Value;
								if (xmlQueryType == XmlQueryTypeFactory.Attribute && qilNode5.NodeType == QilNodeType.Eq)
								{
									QilNode qilNode8 = qilNode5[0];
									QilNode qilNode9 = qilNode5[1];
									if (qilNode8.NodeType == QilNodeType.NameOf)
									{
										QilNode qilNode10 = qilNode8[0];
										if (qilNode10 == qilNode && qilNode9.NodeType == QilNodeType.LiteralQName && AllowReplace(XmlILOptimization.NormalizeAttribute, local0))
										{
											return Replace(XmlILOptimization.NormalizeAttribute, local0, VisitAttribute(f.Attribute(left, qilNode9)));
										}
									}
								}
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.CommuteFilterLoop] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode11 = qilNode[0];
				if (qilNode11.NodeType == QilNodeType.Loop)
				{
					QilNode variable = qilNode11[0];
					QilNode binding = qilNode11[1];
					if (NonPositional(qilNode2, qilNode) && !IsDocOrderDistinct(qilNode11) && AllowReplace(XmlILOptimization.CommuteFilterLoop, local0))
					{
						QilNode qilNode12 = VisitFor(f.For(binding));
						return Replace(XmlILOptimization.CommuteFilterLoop, local0, VisitLoop(f.Loop(variable, VisitFilter(f.Filter(qilNode12, Subs(qilNode2, qilNode, qilNode12))))));
					}
				}
			}
			if (this[XmlILOptimization.NormalizeLoopInvariant] && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode[0].NodeType != QilNodeType.OptimizeBarrier && !DependsOn(qilNode2, qilNode) && !OptimizerPatterns.Read(qilNode2).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && AllowReplace(XmlILOptimization.NormalizeLoopInvariant, local0))
			{
				return Replace(XmlILOptimization.NormalizeLoopInvariant, local0, VisitConditional(f.Conditional(qilNode2, qilNode[0], VisitSequence(f.Sequence()))));
			}
			if (this[XmlILOptimization.AnnotateMaxPositionEq] && qilNode2.NodeType == QilNodeType.Eq)
			{
				QilNode qilNode13 = qilNode2[0];
				QilNode qilNode14 = qilNode2[1];
				if (qilNode13.NodeType == QilNodeType.PositionOf)
				{
					QilNode qilNode15 = qilNode13[0];
					if (qilNode15 == qilNode && qilNode14.NodeType == QilNodeType.LiteralInt32)
					{
						int num = (int)((QilLiteral)qilNode14).Value;
						if (AllowReplace(XmlILOptimization.AnnotateMaxPositionEq, local0))
						{
							OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
							OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num);
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxPositionLe] && qilNode2.NodeType == QilNodeType.Le)
			{
				QilNode qilNode16 = qilNode2[0];
				QilNode qilNode17 = qilNode2[1];
				if (qilNode16.NodeType == QilNodeType.PositionOf)
				{
					QilNode qilNode18 = qilNode16[0];
					if (qilNode18 == qilNode && qilNode17.NodeType == QilNodeType.LiteralInt32)
					{
						int num2 = (int)((QilLiteral)qilNode17).Value;
						if (AllowReplace(XmlILOptimization.AnnotateMaxPositionLe, local0))
						{
							OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
							OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num2);
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateMaxPositionLt] && qilNode2.NodeType == QilNodeType.Lt)
			{
				QilNode qilNode19 = qilNode2[0];
				QilNode qilNode20 = qilNode2[1];
				if (qilNode19.NodeType == QilNodeType.PositionOf)
				{
					QilNode qilNode21 = qilNode19[0];
					if (qilNode21 == qilNode && qilNode20.NodeType == QilNodeType.LiteralInt32)
					{
						int num3 = (int)((QilLiteral)qilNode20).Value;
						if (AllowReplace(XmlILOptimization.AnnotateMaxPositionLt, local0))
						{
							OptimizerPatterns.Write(qilNode).AddPattern(OptimizerPatternName.MaxPosition);
							OptimizerPatterns.Write(qilNode).AddArgument(OptimizerPatternArgument.ElementQName, num3 - 1);
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateFilter] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode ndSrc = qilNode[0];
				if (AllowReplace(XmlILOptimization.AnnotateFilter, local0))
				{
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.Step);
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.IsDocOrderDistinct);
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.SameDepth);
				}
			}
			if (this[XmlILOptimization.AnnotateFilterElements] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode nd = qilNode[0];
				if (OptimizerPatterns.Read(nd).MatchesPattern(OptimizerPatternName.Axis) && qilNode2.NodeType == QilNodeType.And)
				{
					QilNode qilNode22 = qilNode2[0];
					QilNode qilNode23 = qilNode2[1];
					if (qilNode22.NodeType == QilNodeType.IsType)
					{
						QilNode qilNode24 = qilNode22[0];
						QilNode qilNode25 = qilNode22[1];
						if (qilNode24 == qilNode && qilNode25.NodeType == QilNodeType.LiteralType)
						{
							XmlQueryType xmlQueryType2 = (XmlQueryType)((QilLiteral)qilNode25).Value;
							if (xmlQueryType2 == XmlQueryTypeFactory.Element && qilNode23.NodeType == QilNodeType.Eq)
							{
								QilNode qilNode26 = qilNode23[0];
								QilNode qilNode27 = qilNode23[1];
								if (qilNode26.NodeType == QilNodeType.NameOf)
								{
									QilNode qilNode28 = qilNode26[0];
									if (qilNode28 == qilNode && qilNode27.NodeType == QilNodeType.LiteralQName && AllowReplace(XmlILOptimization.AnnotateFilterElements, local0))
									{
										OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.FilterElements);
										OptimizerPatterns.Write(local0).AddArgument(OptimizerPatternArgument.ElementQName, qilNode27);
									}
								}
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateFilterContentKind] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode nd2 = qilNode[0];
				if (OptimizerPatterns.Read(nd2).MatchesPattern(OptimizerPatternName.Axis) && qilNode2.NodeType == QilNodeType.IsType)
				{
					QilNode qilNode29 = qilNode2[0];
					QilNode qilNode30 = qilNode2[1];
					if (qilNode29 == qilNode && qilNode30.NodeType == QilNodeType.LiteralType)
					{
						XmlQueryType xmlQueryType3 = (XmlQueryType)((QilLiteral)qilNode30).Value;
						if (MatchesContentTest(xmlQueryType3) && AllowReplace(XmlILOptimization.AnnotateFilterContentKind, local0))
						{
							OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.FilterContentKind);
							OptimizerPatterns.Write(local0).AddArgument(OptimizerPatternArgument.ElementQName, xmlQueryType3);
						}
					}
				}
			}
			if (this[XmlILOptimization.AnnotateFilterAttributeKind] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode31 = qilNode[0];
				if (qilNode31.NodeType == QilNodeType.Content && qilNode2.NodeType == QilNodeType.IsType)
				{
					QilNode qilNode32 = qilNode2[0];
					QilNode qilNode33 = qilNode2[1];
					if (qilNode32 == qilNode && qilNode33.NodeType == QilNodeType.LiteralType)
					{
						XmlQueryType xmlQueryType4 = (XmlQueryType)((QilLiteral)qilNode33).Value;
						if (xmlQueryType4 == XmlQueryTypeFactory.Attribute && AllowReplace(XmlILOptimization.AnnotateFilterAttributeKind, local0))
						{
							OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.FilterAttributeKind);
						}
					}
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitSort(QilLoop local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode[0])));
			}
			if (this[XmlILOptimization.EliminateSort] && qilNode.NodeType == QilNodeType.For)
			{
				QilNode qilNode3 = qilNode[0];
				if (qilNode3.XmlType.IsSingleton && AllowReplace(XmlILOptimization.EliminateSort, local0))
				{
					return Replace(XmlILOptimization.EliminateSort, local0, VisitNop(f.Nop(qilNode3)));
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitSortKey(QilSortKey local0)
		{
			QilNode qilNode = local0[0];
			QilNode collation = local0[1];
			if (this[XmlILOptimization.NormalizeSortXsltConvert] && qilNode.NodeType == QilNodeType.XsltConvert)
			{
				QilNode qilNode2 = qilNode[0];
				QilNode qilNode3 = qilNode[1];
				if (qilNode3.NodeType == QilNodeType.LiteralType)
				{
					XmlQueryType xmlQueryType = (XmlQueryType)((QilLiteral)qilNode3).Value;
					if (qilNode2.XmlType == XmlQueryTypeFactory.IntX && xmlQueryType == XmlQueryTypeFactory.DoubleX && AllowReplace(XmlILOptimization.NormalizeSortXsltConvert, local0))
					{
						return Replace(XmlILOptimization.NormalizeSortXsltConvert, local0, VisitSortKey(f.SortKey(qilNode2, collation)));
					}
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDocOrderDistinct(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateDod] && IsDocOrderDistinct(qilNode) && AllowReplace(XmlILOptimization.EliminateDod, local0))
			{
				return Replace(XmlILOptimization.EliminateDod, local0, qilNode);
			}
			if (this[XmlILOptimization.FoldNamedDescendants] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode2 = qilNode[0];
				QilNode qilNode3 = qilNode[1];
				if (qilNode2.NodeType == QilNodeType.For)
				{
					QilNode qilNode4 = qilNode2[0];
					if (qilNode4.NodeType == QilNodeType.Loop)
					{
						QilNode variable = qilNode4[0];
						QilNode qilNode5 = qilNode4[1];
						if (qilNode5.NodeType == QilNodeType.DescendantOrSelf)
						{
							QilNode child = qilNode5[0];
							if (qilNode3.NodeType == QilNodeType.Filter)
							{
								QilNode refOld = qilNode3[0];
								QilNode expr = qilNode3[1];
								if ((OptimizerPatterns.Read(qilNode3).MatchesPattern(OptimizerPatternName.FilterElements) || OptimizerPatterns.Read(qilNode3).MatchesPattern(OptimizerPatternName.FilterContentKind)) && IsStepPattern(qilNode3, QilNodeType.Content) && AllowReplace(XmlILOptimization.FoldNamedDescendants, local0))
								{
									QilNode qilNode6 = VisitFor(f.For(VisitDescendant(f.Descendant(child))));
									return Replace(XmlILOptimization.FoldNamedDescendants, local0, VisitDocOrderDistinct(f.DocOrderDistinct(VisitLoop(f.Loop(variable, VisitFilter(f.Filter(qilNode6, Subs(expr, refOld, qilNode6))))))));
								}
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.FoldNamedDescendants] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode7 = qilNode[0];
				QilNode qilNode8 = qilNode[1];
				if (qilNode7.NodeType == QilNodeType.For)
				{
					QilNode qilNode9 = qilNode7[0];
					if (qilNode9.NodeType == QilNodeType.DescendantOrSelf)
					{
						QilNode child2 = qilNode9[0];
						if (qilNode8.NodeType == QilNodeType.Filter)
						{
							QilNode refOld2 = qilNode8[0];
							QilNode expr2 = qilNode8[1];
							if ((OptimizerPatterns.Read(qilNode8).MatchesPattern(OptimizerPatternName.FilterElements) || OptimizerPatterns.Read(qilNode8).MatchesPattern(OptimizerPatternName.FilterContentKind)) && IsStepPattern(qilNode8, QilNodeType.Content) && AllowReplace(XmlILOptimization.FoldNamedDescendants, local0))
							{
								QilNode qilNode10 = VisitFor(f.For(VisitDescendant(f.Descendant(child2))));
								return Replace(XmlILOptimization.FoldNamedDescendants, local0, VisitFilter(f.Filter(qilNode10, Subs(expr2, refOld2, qilNode10))));
							}
						}
					}
				}
			}
			if (this[XmlILOptimization.CommuteDodFilter] && qilNode.NodeType == QilNodeType.Filter)
			{
				QilNode qilNode11 = qilNode[0];
				QilNode expr3 = qilNode[1];
				if (qilNode11.NodeType == QilNodeType.For)
				{
					QilNode child3 = qilNode11[0];
					if (!OptimizerPatterns.Read(qilNode11).MatchesPattern(OptimizerPatternName.IsPositional) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterElements) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterContentKind) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterAttributeKind) && AllowReplace(XmlILOptimization.CommuteDodFilter, local0))
					{
						QilNode qilNode12 = VisitFor(f.For(VisitDocOrderDistinct(f.DocOrderDistinct(child3))));
						return Replace(XmlILOptimization.CommuteDodFilter, local0, VisitFilter(f.Filter(qilNode12, Subs(expr3, qilNode11, qilNode12))));
					}
				}
			}
			if (this[XmlILOptimization.CommuteDodFilter] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode13 = qilNode[0];
				QilNode qilNode14 = qilNode[1];
				if (qilNode14.NodeType == QilNodeType.Filter)
				{
					QilNode qilNode15 = qilNode14[0];
					QilNode expr4 = qilNode14[1];
					if (qilNode15.NodeType == QilNodeType.For)
					{
						QilNode body = qilNode15[0];
						if (!OptimizerPatterns.Read(qilNode15).MatchesPattern(OptimizerPatternName.IsPositional) && !DependsOn(expr4, qilNode13) && !OptimizerPatterns.Read(qilNode14).MatchesPattern(OptimizerPatternName.FilterElements) && !OptimizerPatterns.Read(qilNode14).MatchesPattern(OptimizerPatternName.FilterContentKind) && !OptimizerPatterns.Read(qilNode14).MatchesPattern(OptimizerPatternName.FilterAttributeKind) && AllowReplace(XmlILOptimization.CommuteDodFilter, local0))
						{
							QilNode qilNode16 = VisitFor(f.For(VisitDocOrderDistinct(f.DocOrderDistinct(VisitLoop(f.Loop(qilNode13, body))))));
							return Replace(XmlILOptimization.CommuteDodFilter, local0, VisitFilter(f.Filter(qilNode16, Subs(expr4, qilNode15, qilNode16))));
						}
					}
				}
			}
			if (this[XmlILOptimization.IntroduceDod] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode17 = qilNode[0];
				QilNode expr5 = qilNode[1];
				if (qilNode17.NodeType == QilNodeType.For)
				{
					QilNode qilNode18 = qilNode17[0];
					if (!IsDocOrderDistinct(qilNode18) && !OptimizerPatterns.Read(qilNode17).MatchesPattern(OptimizerPatternName.IsPositional) && qilNode18.XmlType.IsSubtypeOf(XmlQueryTypeFactory.NodeNotRtfS) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterElements) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterContentKind) && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.FilterAttributeKind) && AllowReplace(XmlILOptimization.IntroduceDod, local0))
					{
						QilNode qilNode19 = VisitFor(f.For(VisitDocOrderDistinct(f.DocOrderDistinct(qilNode18))));
						return Replace(XmlILOptimization.IntroduceDod, local0, VisitDocOrderDistinct(f.DocOrderDistinct(VisitLoop(f.Loop(qilNode19, Subs(expr5, qilNode17, qilNode19))))));
					}
				}
			}
			if (this[XmlILOptimization.IntroducePrecedingDod] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode variable2 = qilNode[0];
				QilNode qilNode20 = qilNode[1];
				if (!IsDocOrderDistinct(qilNode20) && IsStepPattern(qilNode20, QilNodeType.PrecedingSibling) && AllowReplace(XmlILOptimization.IntroducePrecedingDod, local0))
				{
					return Replace(XmlILOptimization.IntroducePrecedingDod, local0, VisitDocOrderDistinct(f.DocOrderDistinct(VisitLoop(f.Loop(variable2, VisitDocOrderDistinct(f.DocOrderDistinct(qilNode20)))))));
				}
			}
			if (this[XmlILOptimization.EliminateReturnDod] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode variable3 = qilNode[0];
				QilNode qilNode21 = qilNode[1];
				if (qilNode21.NodeType == QilNodeType.DocOrderDistinct)
				{
					QilNode qilNode22 = qilNode21[0];
					if (!IsStepPattern(qilNode22, QilNodeType.PrecedingSibling) && AllowReplace(XmlILOptimization.EliminateReturnDod, local0))
					{
						return Replace(XmlILOptimization.EliminateReturnDod, local0, VisitDocOrderDistinct(f.DocOrderDistinct(VisitLoop(f.Loop(variable3, qilNode22)))));
					}
				}
			}
			if (this[XmlILOptimization.AnnotateDod] && AllowReplace(XmlILOptimization.AnnotateDod, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Inherit(qilNode, local0, OptimizerPatternName.SameDepth);
			}
			if (this[XmlILOptimization.AnnotateDodReverse] && AllowDodReverse(qilNode) && AllowReplace(XmlILOptimization.AnnotateDodReverse, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.DodReverse);
				OptimizerPatterns.Write(local0).AddArgument(OptimizerPatternArgument.ElementQName, qilNode);
			}
			if (this[XmlILOptimization.AnnotateJoinAndDod] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode23 = qilNode[0];
				QilNode qilNode24 = qilNode[1];
				if (qilNode23.NodeType == QilNodeType.For)
				{
					QilNode nd = qilNode23[0];
					if (IsDocOrderDistinct(nd) && AllowJoinAndDod(qilNode24) && qilNode23 == OptimizerPatterns.Read(qilNode24).GetArgument(OptimizerPatternArgument.StepInput) && AllowReplace(XmlILOptimization.AnnotateJoinAndDod, local0))
					{
						OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.JoinAndDod);
						OptimizerPatterns.Write(local0).AddArgument(OptimizerPatternArgument.ElementQName, qilNode24);
					}
				}
			}
			if (this[XmlILOptimization.AnnotateDodMerge] && qilNode.NodeType == QilNodeType.Loop)
			{
				QilNode qilNode25 = qilNode[1];
				if (qilNode25.NodeType == QilNodeType.Invoke && IsDocOrderDistinct(qilNode25) && AllowReplace(XmlILOptimization.AnnotateDodMerge, local0))
				{
					OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.DodMerge);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitFunction(QilFunction local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			QilNode qilNode3 = local0[2];
			XmlQueryType xmlType = local0.XmlType;
			if (local0.XmlType.IsSubtypeOf(XmlQueryTypeFactory.NodeS) && this[XmlILOptimization.AnnotateIndex1] && qilNode.Count == 2 && qilNode[0].XmlType.IsSubtypeOf(XmlQueryTypeFactory.Node) && qilNode[1].XmlType == XmlQueryTypeFactory.StringX && qilNode2.NodeType == QilNodeType.Filter)
			{
				QilNode qilNode4 = qilNode2[0];
				QilNode qilNode5 = qilNode2[1];
				if (qilNode4.NodeType == QilNodeType.For)
				{
					QilNode expr = qilNode4[0];
					if (qilNode5.NodeType == QilNodeType.Not)
					{
						QilNode qilNode6 = qilNode5[0];
						if (qilNode6.NodeType == QilNodeType.IsEmpty)
						{
							QilNode qilNode7 = qilNode6[0];
							if (qilNode7.NodeType == QilNodeType.Filter)
							{
								QilNode qilNode8 = qilNode7[0];
								QilNode qilNode9 = qilNode7[1];
								if (qilNode8.NodeType == QilNodeType.For)
								{
									QilNode qilNode10 = qilNode8[0];
									if (qilNode9.NodeType == QilNodeType.Eq)
									{
										QilNode qilNode11 = qilNode9[0];
										QilNode qilNode12 = qilNode9[1];
										if (qilNode11 == qilNode8 && qilNode12.NodeType == QilNodeType.Parameter && qilNode12 == qilNode[1] && IsDocOrderDistinct(qilNode2) && AllowReplace(XmlILOptimization.AnnotateIndex1, local0))
										{
											EqualityIndexVisitor equalityIndexVisitor = new EqualityIndexVisitor();
											if (equalityIndexVisitor.Scan(expr, qilNode[0], qilNode12) && equalityIndexVisitor.Scan(qilNode10, qilNode[0], qilNode12))
											{
												OptimizerPatterns optimizerPatterns = OptimizerPatterns.Write(qilNode2);
												optimizerPatterns.AddPattern(OptimizerPatternName.EqualityIndex);
												optimizerPatterns.AddArgument(OptimizerPatternArgument.StepNode, qilNode4);
												optimizerPatterns.AddArgument(OptimizerPatternArgument.StepInput, qilNode10);
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (local0.XmlType.IsSubtypeOf(XmlQueryTypeFactory.NodeS) && this[XmlILOptimization.AnnotateIndex2] && qilNode.Count == 2 && qilNode[0].XmlType == XmlQueryTypeFactory.Node && qilNode[1].XmlType == XmlQueryTypeFactory.StringX && qilNode2.NodeType == QilNodeType.Filter)
			{
				QilNode qilNode13 = qilNode2[0];
				QilNode qilNode14 = qilNode2[1];
				if (qilNode13.NodeType == QilNodeType.For)
				{
					QilNode expr2 = qilNode13[0];
					if (qilNode14.NodeType == QilNodeType.Eq)
					{
						QilNode qilNode15 = qilNode14[0];
						QilNode qilNode16 = qilNode14[1];
						if (qilNode16.NodeType == QilNodeType.Parameter && qilNode16 == qilNode[1] && IsDocOrderDistinct(qilNode2) && AllowReplace(XmlILOptimization.AnnotateIndex2, local0))
						{
							EqualityIndexVisitor equalityIndexVisitor2 = new EqualityIndexVisitor();
							if (equalityIndexVisitor2.Scan(expr2, qilNode[0], qilNode16) && equalityIndexVisitor2.Scan(qilNode15, qilNode[0], qilNode16))
							{
								OptimizerPatterns optimizerPatterns2 = OptimizerPatterns.Write(qilNode2);
								optimizerPatterns2.AddPattern(OptimizerPatternName.EqualityIndex);
								optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepNode, qilNode13);
								optimizerPatterns2.AddArgument(OptimizerPatternArgument.StepInput, qilNode15);
							}
						}
					}
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitInvoke(QilInvoke local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.NormalizeInvokeEmpty] && qilNode.NodeType == QilNodeType.Function)
			{
				QilNode qilNode3 = qilNode[1];
				if (qilNode3.NodeType == QilNodeType.Sequence && qilNode3.Count == 0 && AllowReplace(XmlILOptimization.NormalizeInvokeEmpty, local0))
				{
					return Replace(XmlILOptimization.NormalizeInvokeEmpty, local0, VisitSequence(f.Sequence()));
				}
			}
			if (this[XmlILOptimization.AnnotateTrackCallers] && AllowReplace(XmlILOptimization.AnnotateTrackCallers, local0))
			{
				XmlILConstructInfo.Write(qilNode).CallersInfo.Add(XmlILConstructInfo.Write(local0));
			}
			if (this[XmlILOptimization.AnnotateInvoke] && qilNode.NodeType == QilNodeType.Function)
			{
				QilNode ndSrc = qilNode[1];
				if (AllowReplace(XmlILOptimization.AnnotateInvoke, local0))
				{
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.IsDocOrderDistinct);
					OptimizerPatterns.Inherit(ndSrc, local0, OptimizerPatternName.SameDepth);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitContent(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateContent] && AllowReplace(XmlILOptimization.AnnotateContent, local0))
			{
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAttribute(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateAttribute] && AllowReplace(XmlILOptimization.AnnotateAttribute, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitParent(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateParent] && AllowReplace(XmlILOptimization.AnnotateParent, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitRoot(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateRoot] && AllowReplace(XmlILOptimization.AnnotateRoot, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDescendant(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateDescendant] && AllowReplace(XmlILOptimization.AnnotateDescendant, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDescendantOrSelf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateDescendantSelf] && AllowReplace(XmlILOptimization.AnnotateDescendantSelf, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAncestor(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateAncestor] && AllowReplace(XmlILOptimization.AnnotateAncestor, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAncestorOrSelf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateAncestorSelf] && AllowReplace(XmlILOptimization.AnnotateAncestorSelf, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitPreceding(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotatePreceding] && AllowReplace(XmlILOptimization.AnnotatePreceding, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitFollowingSibling(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateFollowingSibling] && AllowReplace(XmlILOptimization.AnnotateFollowingSibling, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitPrecedingSibling(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotatePrecedingSibling] && AllowReplace(XmlILOptimization.AnnotatePrecedingSibling, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNodeRange(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateNodeRange] && AllowReplace(XmlILOptimization.AnnotateNodeRange, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDeref(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitElementCtor(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Right = elemAnalyzer.Analyze(local0, qilNode2);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitAttributeCtor(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Right = contentAnalyzer.Analyze(local0, qilNode2);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitCommentCtor(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Child = contentAnalyzer.Analyze(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitPICtor(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Right = contentAnalyzer.Analyze(local0, qilNode2);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitTextCtor(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				contentAnalyzer.Analyze(local0, null);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitRawTextCtor(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				contentAnalyzer.Analyze(local0, null);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitDocumentCtor(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Child = contentAnalyzer.Analyze(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNamespaceDecl(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (XmlILConstructInfo.Read(local0).IsNamespaceInScope && this[XmlILOptimization.EliminateNamespaceDecl] && AllowReplace(XmlILOptimization.EliminateNamespaceDecl, local0))
			{
				return Replace(XmlILOptimization.EliminateNamespaceDecl, local0, VisitSequence(f.Sequence()));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				contentAnalyzer.Analyze(local0, null);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitRtfCtor(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Left = contentAnalyzer.Analyze(local0, qilNode);
			}
			if (this[XmlILOptimization.AnnotateSingleTextRtf] && qilNode.NodeType == QilNodeType.TextCtor)
			{
				QilNode arg = qilNode[0];
				if (AllowReplace(XmlILOptimization.AnnotateSingleTextRtf, local0))
				{
					OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SingleTextRtf);
					OptimizerPatterns.Write(local0).AddArgument(OptimizerPatternArgument.ElementQName, arg);
					XmlILConstructInfo.Write(local0).PullFromIteratorFirst = true;
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNameOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitLocalNameOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitNamespaceUriOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitPrefixOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitTypeAssert(QilTargetType local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateTypeAssert] && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.NeverSubtypeOf(baseType) && AllowReplace(XmlILOptimization.EliminateTypeAssert, local0))
				{
					return Replace(XmlILOptimization.EliminateTypeAssert, local0, VisitError(f.Error(VisitLiteralString(f.LiteralString(string.Empty)))));
				}
			}
			if (this[XmlILOptimization.EliminateTypeAssert] && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType xmlQueryType = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.Prime.NeverSubtypeOf(xmlQueryType.Prime) && AllowReplace(XmlILOptimization.EliminateTypeAssert, local0))
				{
					return Replace(XmlILOptimization.EliminateTypeAssert, local0, VisitConditional(f.Conditional(VisitIsEmpty(f.IsEmpty(qilNode)), VisitSequence(f.Sequence()), VisitError(f.Error(VisitLiteralString(f.LiteralString(string.Empty)))))));
				}
			}
			if (this[XmlILOptimization.EliminateTypeAssertOptional] && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType2 = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.IsSubtypeOf(baseType2) && AllowReplace(XmlILOptimization.EliminateTypeAssertOptional, local0))
				{
					return Replace(XmlILOptimization.EliminateTypeAssertOptional, local0, qilNode);
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitIsType(QilTargetType local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateIsType] && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.IsSubtypeOf(baseType) && AllowReplace(XmlILOptimization.EliminateIsType, local0))
				{
					return Replace(XmlILOptimization.EliminateIsType, local0, VisitTrue(f.True()));
				}
			}
			if (this[XmlILOptimization.EliminateIsType] && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType2 = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.NeverSubtypeOf(baseType2) && AllowReplace(XmlILOptimization.EliminateIsType, local0))
				{
					return Replace(XmlILOptimization.EliminateIsType, local0, VisitFalse(f.False()));
				}
			}
			if (this[XmlILOptimization.EliminateIsType] && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType xmlQueryType = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.Prime.NeverSubtypeOf(xmlQueryType.Prime) && AllowReplace(XmlILOptimization.EliminateIsType, local0))
				{
					return Replace(XmlILOptimization.EliminateIsType, local0, VisitIsEmpty(f.IsEmpty(qilNode)));
				}
			}
			if (this[XmlILOptimization.EliminateIsType] && OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType3 = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.IsSubtypeOf(baseType3) && AllowReplace(XmlILOptimization.EliminateIsType, local0))
				{
					return Replace(XmlILOptimization.EliminateIsType, local0, VisitLoop(f.Loop(VisitLet(f.Let(qilNode)), VisitTrue(f.True()))));
				}
			}
			if (this[XmlILOptimization.EliminateIsType] && OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType baseType4 = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType.NeverSubtypeOf(baseType4) && AllowReplace(XmlILOptimization.EliminateIsType, local0))
				{
					return Replace(XmlILOptimization.EliminateIsType, local0, VisitLoop(f.Loop(VisitLet(f.Let(qilNode)), VisitFalse(f.False()))));
				}
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitIsEmpty(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.EliminateIsEmpty] && qilNode.NodeType == QilNodeType.Sequence && qilNode.Count == 0 && AllowReplace(XmlILOptimization.EliminateIsEmpty, local0))
			{
				return Replace(XmlILOptimization.EliminateIsEmpty, local0, VisitTrue(f.True()));
			}
			if (this[XmlILOptimization.EliminateIsEmpty] && !qilNode.XmlType.MaybeEmpty && !OptimizerPatterns.Read(qilNode).MatchesPattern(OptimizerPatternName.MaybeSideEffects) && AllowReplace(XmlILOptimization.EliminateIsEmpty, local0))
			{
				return Replace(XmlILOptimization.EliminateIsEmpty, local0, VisitFalse(f.False()));
			}
			if (this[XmlILOptimization.EliminateIsEmpty] && !qilNode.XmlType.MaybeEmpty && AllowReplace(XmlILOptimization.EliminateIsEmpty, local0))
			{
				return Replace(XmlILOptimization.EliminateIsEmpty, local0, VisitLoop(f.Loop(VisitLet(f.Let(qilNode)), VisitFalse(f.False()))));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXPathNodeValue(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXPathFollowing(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateXPathFollowing] && AllowReplace(XmlILOptimization.AnnotateXPathFollowing, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXPathPreceding(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateXPathPreceding] && AllowReplace(XmlILOptimization.AnnotateXPathPreceding, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXPathNamespace(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateNamespace] && AllowReplace(XmlILOptimization.AnnotateNamespace, local0))
			{
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.Axis);
				AddStepPattern(local0, qilNode);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.IsDocOrderDistinct);
				OptimizerPatterns.Write(local0).AddPattern(OptimizerPatternName.SameDepth);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXsltGenerateId(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXsltCopy(QilBinary local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldNone] && (object)qilNode2.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode2)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				local0.Right = contentAnalyzer.Analyze(local0, qilNode2);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXsltCopyOf(QilUnary local0)
		{
			QilNode qilNode = local0[0];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.AnnotateConstruction] && AllowReplace(XmlILOptimization.AnnotateConstruction, local0))
			{
				contentAnalyzer.Analyze(local0, null);
			}
			return NoReplace(local0);
		}

		protected override QilNode VisitXsltConvert(QilTargetType local0)
		{
			QilNode qilNode = local0[0];
			QilNode qilNode2 = local0[1];
			if (this[XmlILOptimization.FoldNone] && (object)qilNode.XmlType == XmlQueryTypeFactory.None && AllowReplace(XmlILOptimization.FoldNone, local0))
			{
				return Replace(XmlILOptimization.FoldNone, local0, VisitNop(f.Nop(qilNode)));
			}
			if (this[XmlILOptimization.FoldXsltConvertLiteral] && IsLiteral(qilNode) && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType typTarget = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (CanFoldXsltConvert(qilNode, typTarget) && AllowReplace(XmlILOptimization.FoldXsltConvertLiteral, local0))
				{
					return Replace(XmlILOptimization.FoldXsltConvertLiteral, local0, FoldXsltConvert(qilNode, typTarget));
				}
			}
			if (this[XmlILOptimization.EliminateXsltConvert] && qilNode2.NodeType == QilNodeType.LiteralType)
			{
				XmlQueryType xmlQueryType = (XmlQueryType)((QilLiteral)qilNode2).Value;
				if (qilNode.XmlType == xmlQueryType && AllowReplace(XmlILOptimization.EliminateXsltConvert, local0))
				{
					return Replace(XmlILOptimization.EliminateXsltConvert, local0, qilNode);
				}
			}
			return NoReplace(local0);
		}

		private bool DependsOn(QilNode expr, QilNode target)
		{
			return new NodeFinder().Find(expr, target);
		}

		protected bool NonPositional(QilNode expr, QilNode iter)
		{
			return !new PositionOfFinder().Find(expr, iter);
		}

		private QilNode Subs(QilNode expr, QilNode refOld, QilNode refNew)
		{
			subs.AddSubstitutionPair(refOld, refNew);
			QilNode result = ((!(expr is QilReference)) ? Visit(expr) : VisitReference(expr));
			subs.RemoveLastSubstitutionPair();
			return result;
		}

		private bool IsGlobalVariable(QilIterator iter)
		{
			return qil.GlobalVariableList.Contains(iter);
		}

		private bool IsGlobalValue(QilNode nd)
		{
			if (nd.NodeType == QilNodeType.Let)
			{
				return qil.GlobalVariableList.Contains(nd);
			}
			if (nd.NodeType == QilNodeType.Parameter)
			{
				return qil.GlobalParameterList.Contains(nd);
			}
			return false;
		}

		private bool IsPrimitiveNumeric(XmlQueryType typ)
		{
			if (typ == XmlQueryTypeFactory.IntX)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.IntegerX)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.DecimalX)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.FloatX)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.DoubleX)
			{
				return true;
			}
			return false;
		}

		private bool MatchesContentTest(XmlQueryType typ)
		{
			if (typ == XmlQueryTypeFactory.Element)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.Text)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.Comment)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.PI)
			{
				return true;
			}
			if (typ == XmlQueryTypeFactory.Content)
			{
				return true;
			}
			return false;
		}

		private bool IsConstructedExpression(QilNode nd)
		{
			if (qil.IsDebug)
			{
				return true;
			}
			if (nd.XmlType.IsNode)
			{
				switch (nd.NodeType)
				{
				case QilNodeType.Choice:
				case QilNodeType.ElementCtor:
				case QilNodeType.AttributeCtor:
				case QilNodeType.CommentCtor:
				case QilNodeType.PICtor:
				case QilNodeType.TextCtor:
				case QilNodeType.RawTextCtor:
				case QilNodeType.DocumentCtor:
				case QilNodeType.NamespaceDecl:
				case QilNodeType.XsltCopy:
				case QilNodeType.XsltCopyOf:
					return true;
				case QilNodeType.Loop:
					return IsConstructedExpression(((QilLoop)nd).Body);
				case QilNodeType.Sequence:
					if (nd.Count == 0)
					{
						return true;
					}
					foreach (QilNode item in nd)
					{
						if (IsConstructedExpression(item))
						{
							return true;
						}
					}
					break;
				case QilNodeType.Conditional:
				{
					QilTernary qilTernary = (QilTernary)nd;
					if (!IsConstructedExpression(qilTernary.Center))
					{
						return IsConstructedExpression(qilTernary.Right);
					}
					return true;
				}
				case QilNodeType.Invoke:
					return !((QilInvoke)nd).Function.XmlType.IsAtomicValue;
				}
			}
			return false;
		}

		private bool IsLiteral(QilNode nd)
		{
			QilNodeType nodeType = nd.NodeType;
			if ((uint)(nodeType - 18) <= 7u)
			{
				return true;
			}
			return false;
		}

		private bool AreLiteralArgs(QilNode nd)
		{
			foreach (QilNode item in nd)
			{
				if (!IsLiteral(item))
				{
					return false;
				}
			}
			return true;
		}

		private object ExtractLiteralValue(QilNode nd)
		{
			if (nd.NodeType == QilNodeType.True)
			{
				return true;
			}
			if (nd.NodeType == QilNodeType.False)
			{
				return false;
			}
			if (nd.NodeType == QilNodeType.LiteralQName)
			{
				return nd;
			}
			return ((QilLiteral)nd).Value;
		}

		private bool HasNestedSequence(QilNode nd)
		{
			foreach (QilNode item in nd)
			{
				if (item.NodeType == QilNodeType.Sequence)
				{
					return true;
				}
			}
			return false;
		}

		private bool AllowJoinAndDod(QilNode nd)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(nd);
			if ((optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterElements) || optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterContentKind)) && (IsStepPattern(optimizerPatterns, QilNodeType.DescendantOrSelf) || IsStepPattern(optimizerPatterns, QilNodeType.Descendant) || IsStepPattern(optimizerPatterns, QilNodeType.Content) || IsStepPattern(optimizerPatterns, QilNodeType.XPathPreceding) || IsStepPattern(optimizerPatterns, QilNodeType.XPathFollowing) || IsStepPattern(optimizerPatterns, QilNodeType.FollowingSibling)))
			{
				return true;
			}
			return false;
		}

		private bool AllowDodReverse(QilNode nd)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(nd);
			if ((optimizerPatterns.MatchesPattern(OptimizerPatternName.Axis) || optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterElements) || optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterContentKind)) && (IsStepPattern(optimizerPatterns, QilNodeType.Ancestor) || IsStepPattern(optimizerPatterns, QilNodeType.AncestorOrSelf) || IsStepPattern(optimizerPatterns, QilNodeType.XPathPreceding) || IsStepPattern(optimizerPatterns, QilNodeType.PrecedingSibling)))
			{
				return true;
			}
			return false;
		}

		private bool CanFoldXsltConvert(QilNode ndLiteral, XmlQueryType typTarget)
		{
			return FoldXsltConvert(ndLiteral, typTarget).NodeType != QilNodeType.XsltConvert;
		}

		private bool CanFoldXsltConvertNonLossy(QilNode ndLiteral, XmlQueryType typTarget)
		{
			QilNode qilNode = FoldXsltConvert(ndLiteral, typTarget);
			if (qilNode.NodeType == QilNodeType.XsltConvert)
			{
				return false;
			}
			qilNode = FoldXsltConvert(qilNode, ndLiteral.XmlType);
			if (qilNode.NodeType == QilNodeType.XsltConvert)
			{
				return false;
			}
			return ExtractLiteralValue(ndLiteral).Equals(ExtractLiteralValue(qilNode));
		}

		private QilNode FoldXsltConvert(QilNode ndLiteral, XmlQueryType typTarget)
		{
			try
			{
				if (typTarget.IsAtomicValue)
				{
					XmlAtomicValue value = new XmlAtomicValue(ndLiteral.XmlType.SchemaType, ExtractLiteralValue(ndLiteral));
					value = XsltConvert.ConvertToType(value, typTarget);
					if (typTarget == XmlQueryTypeFactory.StringX)
					{
						return f.LiteralString(value.Value);
					}
					if (typTarget == XmlQueryTypeFactory.IntX)
					{
						return f.LiteralInt32(value.ValueAsInt);
					}
					if (typTarget == XmlQueryTypeFactory.IntegerX)
					{
						return f.LiteralInt64(value.ValueAsLong);
					}
					if (typTarget == XmlQueryTypeFactory.DecimalX)
					{
						return f.LiteralDecimal((decimal)value.ValueAs(XsltConvert.DecimalType));
					}
					if (typTarget == XmlQueryTypeFactory.DoubleX)
					{
						return f.LiteralDouble(value.ValueAsDouble);
					}
					if (typTarget == XmlQueryTypeFactory.BooleanX)
					{
						return value.ValueAsBoolean ? f.True() : f.False();
					}
				}
			}
			catch (OverflowException)
			{
			}
			catch (FormatException)
			{
			}
			return f.XsltConvert(ndLiteral, typTarget);
		}

		private QilNode FoldComparison(QilNodeType opType, QilNode left, QilNode right)
		{
			object obj = ExtractLiteralValue(left);
			object obj2 = ExtractLiteralValue(right);
			if (left.NodeType == QilNodeType.LiteralDouble && (double.IsNaN((double)obj) || double.IsNaN((double)obj2)))
			{
				if (opType != QilNodeType.Ne)
				{
					return f.False();
				}
				return f.True();
			}
			switch (opType)
			{
			case QilNodeType.Eq:
				if (!obj.Equals(obj2))
				{
					return f.False();
				}
				return f.True();
			case QilNodeType.Ne:
				if (!obj.Equals(obj2))
				{
					return f.True();
				}
				return f.False();
			default:
			{
				int num = ((left.NodeType != QilNodeType.LiteralString) ? ((IComparable)obj).CompareTo(obj2) : string.CompareOrdinal((string)obj, (string)obj2));
				switch (opType)
				{
				case QilNodeType.Gt:
					if (num <= 0)
					{
						return f.False();
					}
					return f.True();
				case QilNodeType.Ge:
					if (num < 0)
					{
						return f.False();
					}
					return f.True();
				case QilNodeType.Lt:
					if (num >= 0)
					{
						return f.False();
					}
					return f.True();
				case QilNodeType.Le:
					if (num > 0)
					{
						return f.False();
					}
					return f.True();
				default:
					return null;
				}
			}
			}
		}

		private bool CanFoldArithmetic(QilNodeType opType, QilLiteral left, QilLiteral right)
		{
			return FoldArithmetic(opType, left, right) is QilLiteral;
		}

		private QilNode FoldArithmetic(QilNodeType opType, QilLiteral left, QilLiteral right)
		{
			checked
			{
				try
				{
					switch (left.NodeType)
					{
					case QilNodeType.LiteralInt32:
					{
						int num7 = left;
						int num8 = right;
						switch (opType)
						{
						case QilNodeType.Add:
							return f.LiteralInt32(num7 + num8);
						case QilNodeType.Subtract:
							return f.LiteralInt32(num7 - num8);
						case QilNodeType.Multiply:
							return f.LiteralInt32(num7 * num8);
						case QilNodeType.Divide:
							return f.LiteralInt32(unchecked(num7 / num8));
						case QilNodeType.Modulo:
							return f.LiteralInt32(unchecked(num7 % num8));
						}
						break;
					}
					case QilNodeType.LiteralInt64:
					{
						long num5 = left;
						long num6 = right;
						switch (opType)
						{
						case QilNodeType.Add:
							return f.LiteralInt64(num5 + num6);
						case QilNodeType.Subtract:
							return f.LiteralInt64(num5 - num6);
						case QilNodeType.Multiply:
							return f.LiteralInt64(num5 * num6);
						case QilNodeType.Divide:
							return f.LiteralInt64(unchecked(num5 / num6));
						case QilNodeType.Modulo:
							return f.LiteralInt64(unchecked(num5 % num6));
						}
						break;
					}
					case QilNodeType.LiteralDecimal:
					{
						decimal num3 = left;
						decimal num4 = right;
						switch (opType)
						{
						case QilNodeType.Add:
							return f.LiteralDecimal(num3 + num4);
						case QilNodeType.Subtract:
							return f.LiteralDecimal(num3 - num4);
						case QilNodeType.Multiply:
							return f.LiteralDecimal(num3 * num4);
						case QilNodeType.Divide:
							return f.LiteralDecimal(num3 / num4);
						case QilNodeType.Modulo:
							return f.LiteralDecimal(num3 % num4);
						}
						break;
					}
					case QilNodeType.LiteralDouble:
					{
						double num = left;
						double num2 = right;
						switch (opType)
						{
						case QilNodeType.Add:
							return f.LiteralDouble(num + num2);
						case QilNodeType.Subtract:
							return f.LiteralDouble(num - num2);
						case QilNodeType.Multiply:
							return f.LiteralDouble(num * num2);
						case QilNodeType.Divide:
							return f.LiteralDouble(num / num2);
						case QilNodeType.Modulo:
							return f.LiteralDouble(num % num2);
						}
						break;
					}
					}
				}
				catch (OverflowException)
				{
				}
				catch (DivideByZeroException)
				{
				}
				return opType switch
				{
					QilNodeType.Add => f.Add(left, right), 
					QilNodeType.Subtract => f.Subtract(left, right), 
					QilNodeType.Multiply => f.Multiply(left, right), 
					QilNodeType.Divide => f.Divide(left, right), 
					QilNodeType.Modulo => f.Modulo(left, right), 
					_ => null, 
				};
			}
		}

		private void AddStepPattern(QilNode nd, QilNode input)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Write(nd);
			optimizerPatterns.AddPattern(OptimizerPatternName.Step);
			optimizerPatterns.AddArgument(OptimizerPatternArgument.StepNode, nd);
			optimizerPatterns.AddArgument(OptimizerPatternArgument.StepInput, input);
		}

		private bool IsDocOrderDistinct(QilNode nd)
		{
			return OptimizerPatterns.Read(nd).MatchesPattern(OptimizerPatternName.IsDocOrderDistinct);
		}

		private bool IsStepPattern(QilNode nd, QilNodeType stepType)
		{
			return IsStepPattern(OptimizerPatterns.Read(nd), stepType);
		}

		private bool IsStepPattern(OptimizerPatterns patt, QilNodeType stepType)
		{
			if (patt.MatchesPattern(OptimizerPatternName.Step))
			{
				return ((QilNode)patt.GetArgument(OptimizerPatternArgument.StepNode)).NodeType == stepType;
			}
			return false;
		}

		private static void EliminateUnusedGlobals(IList<QilNode> globals)
		{
			int num = 0;
			for (int i = 0; i < globals.Count; i++)
			{
				QilNode qilNode = globals[i];
				bool flag;
				if (qilNode.NodeType == QilNodeType.Function)
				{
					flag = XmlILConstructInfo.Read(qilNode).CallersInfo.Count != 0;
				}
				else
				{
					OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(qilNode);
					flag = optimizerPatterns.MatchesPattern(OptimizerPatternName.IsReferenced) || optimizerPatterns.MatchesPattern(OptimizerPatternName.MaybeSideEffects);
				}
				if (flag)
				{
					if (num < i)
					{
						globals[num] = globals[i];
					}
					num++;
				}
			}
			for (int num2 = globals.Count - 1; num2 >= num; num2--)
			{
				globals.RemoveAt(num2);
			}
		}
	}
	internal class XmlILTypeHelper
	{
		private static readonly Type[] TypeCodeToStorage = new Type[55]
		{
			typeof(XPathItem),
			typeof(XPathItem),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathNavigator),
			typeof(XPathItem),
			typeof(string),
			typeof(string),
			typeof(bool),
			typeof(decimal),
			typeof(float),
			typeof(double),
			typeof(string),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(DateTime),
			typeof(byte[]),
			typeof(byte[]),
			typeof(string),
			typeof(XmlQualifiedName),
			typeof(XmlQualifiedName),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(string),
			typeof(long),
			typeof(decimal),
			typeof(decimal),
			typeof(long),
			typeof(int),
			typeof(int),
			typeof(int),
			typeof(decimal),
			typeof(decimal),
			typeof(long),
			typeof(int),
			typeof(int),
			typeof(decimal),
			typeof(TimeSpan),
			typeof(TimeSpan)
		};

		private static readonly Type[] TypeCodeToCachedStorage = new Type[55]
		{
			typeof(IList<XPathItem>),
			typeof(IList<XPathItem>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathNavigator>),
			typeof(IList<XPathItem>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<bool>),
			typeof(IList<decimal>),
			typeof(IList<float>),
			typeof(IList<double>),
			typeof(IList<string>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<DateTime>),
			typeof(IList<byte[]>),
			typeof(IList<byte[]>),
			typeof(IList<string>),
			typeof(IList<XmlQualifiedName>),
			typeof(IList<XmlQualifiedName>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<string>),
			typeof(IList<long>),
			typeof(IList<decimal>),
			typeof(IList<decimal>),
			typeof(IList<long>),
			typeof(IList<int>),
			typeof(IList<int>),
			typeof(IList<int>),
			typeof(IList<decimal>),
			typeof(IList<decimal>),
			typeof(IList<long>),
			typeof(IList<int>),
			typeof(IList<int>),
			typeof(IList<decimal>),
			typeof(IList<TimeSpan>),
			typeof(IList<TimeSpan>)
		};

		private XmlILTypeHelper()
		{
		}

		public static Type GetStorageType(XmlQueryType qyTyp)
		{
			Type type;
			if (qyTyp.IsSingleton)
			{
				type = TypeCodeToStorage[(int)qyTyp.TypeCode];
				if (!qyTyp.IsStrict && type != typeof(XPathNavigator))
				{
					return typeof(XPathItem);
				}
			}
			else
			{
				type = TypeCodeToCachedStorage[(int)qyTyp.TypeCode];
				if (!qyTyp.IsStrict && type != typeof(IList<XPathNavigator>))
				{
					return typeof(IList<XPathItem>);
				}
			}
			return type;
		}
	}
	internal class XmlILVisitor : QilVisitor
	{
		private QilExpression qil;

		private GenerateHelper helper;

		private IteratorDescriptor iterCurr;

		private IteratorDescriptor iterNested;

		private int indexId;

		public void Visit(QilExpression qil, GenerateHelper helper, MethodInfo methRoot)
		{
			this.qil = qil;
			this.helper = helper;
			iterNested = null;
			indexId = 0;
			PrepareGlobalValues(qil.GlobalParameterList);
			PrepareGlobalValues(qil.GlobalVariableList);
			VisitGlobalValues(qil.GlobalParameterList);
			VisitGlobalValues(qil.GlobalVariableList);
			foreach (QilFunction function in qil.FunctionList)
			{
				Function(function);
			}
			this.helper.MethodBegin(methRoot, null, initWriters: true);
			StartNestedIterator(qil.Root);
			Visit(qil.Root);
			EndNestedIterator(qil.Root);
			this.helper.MethodEnd();
		}

		private void PrepareGlobalValues(QilList globalIterators)
		{
			foreach (QilIterator globalIterator in globalIterators)
			{
				MethodInfo functionBinding = XmlILAnnotation.Write(globalIterator).FunctionBinding;
				IteratorDescriptor iteratorDescriptor = new IteratorDescriptor(helper);
				iteratorDescriptor.Storage = StorageDescriptor.Global(functionBinding, GetItemStorageType(globalIterator), !globalIterator.XmlType.IsSingleton);
				XmlILAnnotation.Write(globalIterator).CachedIteratorDescriptor = iteratorDescriptor;
			}
		}

		private void VisitGlobalValues(QilList globalIterators)
		{
			foreach (QilIterator globalIterator in globalIterators)
			{
				QilParameter qilParameter = globalIterator as QilParameter;
				MethodInfo globalLocation = XmlILAnnotation.Write(globalIterator).CachedIteratorDescriptor.Storage.GlobalLocation;
				bool isCached = !globalIterator.XmlType.IsSingleton;
				int num = helper.StaticData.DeclareGlobalValue(globalIterator.DebugName);
				helper.MethodBegin(globalLocation, globalIterator.SourceLine, initWriters: false);
				Label label = helper.DefineLabel();
				Label label2 = helper.DefineLabel();
				helper.LoadQueryRuntime();
				helper.LoadInteger(num);
				helper.Call(XmlILMethods.GlobalComputed);
				helper.Emit(OpCodes.Brtrue, label);
				StartNestedIterator(globalIterator);
				if (qilParameter != null)
				{
					LocalBuilder locBldr = helper.DeclareLocal("$$$param", typeof(object));
					helper.CallGetParameter(qilParameter.Name.LocalName, qilParameter.Name.NamespaceUri);
					helper.Emit(OpCodes.Stloc, locBldr);
					helper.Emit(OpCodes.Ldloc, locBldr);
					helper.Emit(OpCodes.Brfalse, label2);
					helper.LoadQueryRuntime();
					helper.LoadInteger(num);
					helper.LoadQueryRuntime();
					helper.LoadInteger(helper.StaticData.DeclareXmlType(XmlQueryTypeFactory.ItemS));
					helper.Emit(OpCodes.Ldloc, locBldr);
					helper.Call(XmlILMethods.ChangeTypeXsltResult);
					helper.CallSetGlobalValue(typeof(object));
					helper.EmitUnconditionalBranch(OpCodes.Br, label);
				}
				helper.MarkLabel(label2);
				if (globalIterator.Binding != null)
				{
					helper.LoadQueryRuntime();
					helper.LoadInteger(num);
					NestedVisitEnsureStack(globalIterator.Binding, GetItemStorageType(globalIterator), isCached);
					helper.CallSetGlobalValue(GetStorageType(globalIterator));
				}
				else
				{
					helper.LoadQueryRuntime();
					GenerateHelper generateHelper = helper;
					OpCode ldstr = OpCodes.Ldstr;
					object[] args = new string[2]
					{
						qilParameter.Name.LocalName,
						qilParameter.Name.NamespaceUri
					};
					generateHelper.Emit(ldstr, System.Xml.Utils.Res.GetString("XmlIl_UnknownParam", args));
					helper.Call(XmlILMethods.ThrowException);
				}
				EndNestedIterator(globalIterator);
				helper.MarkLabel(label);
				helper.CallGetGlobalValue(num, GetStorageType(globalIterator));
				helper.MethodEnd();
			}
		}

		private void Function(QilFunction ndFunc)
		{
			foreach (QilIterator argument in ndFunc.Arguments)
			{
				IteratorDescriptor iteratorDescriptor = new IteratorDescriptor(helper);
				int paramIndex = XmlILAnnotation.Write(argument).ArgumentPosition + 1;
				iteratorDescriptor.Storage = StorageDescriptor.Parameter(paramIndex, GetItemStorageType(argument), !argument.XmlType.IsSingleton);
				XmlILAnnotation.Write(argument).CachedIteratorDescriptor = iteratorDescriptor;
			}
			MethodInfo functionBinding = XmlILAnnotation.Write(ndFunc).FunctionBinding;
			bool flag = XmlILConstructInfo.Read(ndFunc).ConstructMethod == XmlILConstructMethod.Writer;
			helper.MethodBegin(functionBinding, ndFunc.SourceLine, flag);
			foreach (QilIterator argument2 in ndFunc.Arguments)
			{
				if (qil.IsDebug && argument2.SourceLine != null)
				{
					helper.DebugSequencePoint(argument2.SourceLine);
				}
				if (argument2.Binding != null)
				{
					int paramIndex = (argument2.Annotation as XmlILAnnotation).ArgumentPosition + 1;
					Label label = helper.DefineLabel();
					helper.LoadQueryRuntime();
					helper.LoadParameter(paramIndex);
					helper.LoadInteger(29);
					helper.Call(XmlILMethods.SeqMatchesCode);
					helper.Emit(OpCodes.Brfalse, label);
					StartNestedIterator(argument2);
					NestedVisitEnsureStack(argument2.Binding, GetItemStorageType(argument2), !argument2.XmlType.IsSingleton);
					EndNestedIterator(argument2);
					helper.SetParameter(paramIndex);
					helper.MarkLabel(label);
				}
			}
			StartNestedIterator(ndFunc);
			if (flag)
			{
				NestedVisit(ndFunc.Definition);
			}
			else
			{
				NestedVisitEnsureStack(ndFunc.Definition, GetItemStorageType(ndFunc), !ndFunc.XmlType.IsSingleton);
			}
			EndNestedIterator(ndFunc);
			helper.MethodEnd();
		}

		protected override QilNode Visit(QilNode nd)
		{
			if (nd == null)
			{
				return null;
			}
			if (qil.IsDebug && nd.SourceLine != null && !(nd is QilIterator))
			{
				helper.DebugSequencePoint(nd.SourceLine);
			}
			switch (XmlILConstructInfo.Read(nd).ConstructMethod)
			{
			case XmlILConstructMethod.WriterThenIterator:
				NestedConstruction(nd);
				break;
			case XmlILConstructMethod.IteratorThenWriter:
				CopySequence(nd);
				break;
			default:
				base.Visit(nd);
				break;
			}
			return nd;
		}

		protected override QilNode VisitChildren(QilNode parent)
		{
			return parent;
		}

		private void NestedConstruction(QilNode nd)
		{
			helper.CallStartSequenceConstruction();
			base.Visit(nd);
			helper.CallEndSequenceConstruction();
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathItem), isCached: true);
		}

		private void CopySequence(QilNode nd)
		{
			XmlQueryType xmlType = nd.XmlType;
			StartWriterLoop(nd, out var hasOnEnd, out var lblOnEnd);
			if (xmlType.IsSingleton)
			{
				helper.LoadQueryOutput();
				base.Visit(nd);
				iterCurr.EnsureItemStorageType(nd.XmlType, typeof(XPathItem));
			}
			else
			{
				base.Visit(nd);
				iterCurr.EnsureItemStorageType(nd.XmlType, typeof(XPathItem));
				iterCurr.EnsureNoStackNoCache("$$$copyTemp");
				helper.LoadQueryOutput();
			}
			iterCurr.EnsureStackNoCache();
			helper.Call(XmlILMethods.WriteItem);
			EndWriterLoop(nd, hasOnEnd, lblOnEnd);
		}

		protected override QilNode VisitDataSource(QilDataSource ndSrc)
		{
			helper.LoadQueryContext();
			NestedVisitEnsureStack(ndSrc.Name);
			NestedVisitEnsureStack(ndSrc.BaseUri);
			helper.Call(XmlILMethods.GetDataSource);
			LocalBuilder localBuilder = helper.DeclareLocal("$$$navDoc", typeof(XPathNavigator));
			helper.Emit(OpCodes.Stloc, localBuilder);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.Emit(OpCodes.Brfalse, iterCurr.GetLabelNext());
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, typeof(XPathNavigator), isCached: false);
			return ndSrc;
		}

		protected override QilNode VisitNop(QilUnary ndNop)
		{
			return Visit(ndNop.Child);
		}

		protected override QilNode VisitOptimizeBarrier(QilUnary ndBarrier)
		{
			return Visit(ndBarrier.Child);
		}

		protected override QilNode VisitError(QilUnary ndErr)
		{
			helper.LoadQueryRuntime();
			NestedVisitEnsureStack(ndErr.Child);
			helper.Call(XmlILMethods.ThrowException);
			if (XmlILConstructInfo.Read(ndErr).ConstructMethod == XmlILConstructMethod.Writer)
			{
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				helper.Emit(OpCodes.Ldnull);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathItem), isCached: false);
			}
			return ndErr;
		}

		protected override QilNode VisitWarning(QilUnary ndWarning)
		{
			helper.LoadQueryRuntime();
			NestedVisitEnsureStack(ndWarning.Child);
			helper.Call(XmlILMethods.SendMessage);
			if (XmlILConstructInfo.Read(ndWarning).ConstructMethod == XmlILConstructMethod.Writer)
			{
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				VisitEmpty(ndWarning);
			}
			return ndWarning;
		}

		protected override QilNode VisitTrue(QilNode ndTrue)
		{
			if (iterCurr.CurrentBranchingContext != 0)
			{
				helper.EmitUnconditionalBranch((iterCurr.CurrentBranchingContext == BranchingContext.OnTrue) ? OpCodes.Brtrue : OpCodes.Brfalse, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				helper.LoadBoolean(boolVal: true);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
			}
			return ndTrue;
		}

		protected override QilNode VisitFalse(QilNode ndFalse)
		{
			if (iterCurr.CurrentBranchingContext != 0)
			{
				helper.EmitUnconditionalBranch((iterCurr.CurrentBranchingContext == BranchingContext.OnFalse) ? OpCodes.Brtrue : OpCodes.Brfalse, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				helper.LoadBoolean(boolVal: false);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
			}
			return ndFalse;
		}

		protected override QilNode VisitLiteralString(QilLiteral ndStr)
		{
			helper.Emit(OpCodes.Ldstr, (string)ndStr);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
			return ndStr;
		}

		protected override QilNode VisitLiteralInt32(QilLiteral ndInt)
		{
			helper.LoadInteger(ndInt);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(int), isCached: false);
			return ndInt;
		}

		protected override QilNode VisitLiteralInt64(QilLiteral ndLong)
		{
			helper.Emit(OpCodes.Ldc_I8, (long)ndLong);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(long), isCached: false);
			return ndLong;
		}

		protected override QilNode VisitLiteralDouble(QilLiteral ndDbl)
		{
			helper.Emit(OpCodes.Ldc_R8, (double)ndDbl);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(double), isCached: false);
			return ndDbl;
		}

		protected override QilNode VisitLiteralDecimal(QilLiteral ndDec)
		{
			helper.ConstructLiteralDecimal(ndDec);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(decimal), isCached: false);
			return ndDec;
		}

		protected override QilNode VisitLiteralQName(QilName ndQName)
		{
			helper.ConstructLiteralQName(ndQName.LocalName, ndQName.NamespaceUri);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XmlQualifiedName), isCached: false);
			return ndQName;
		}

		protected override QilNode VisitAnd(QilBinary ndAnd)
		{
			IteratorDescriptor iteratorDescriptor = iterCurr;
			StartNestedIterator(ndAnd.Left);
			Label lblOnFalse = StartConjunctiveTests(iteratorDescriptor.CurrentBranchingContext, iteratorDescriptor.LabelBranch);
			Visit(ndAnd.Left);
			EndNestedIterator(ndAnd.Left);
			StartNestedIterator(ndAnd.Right);
			StartLastConjunctiveTest(iteratorDescriptor.CurrentBranchingContext, iteratorDescriptor.LabelBranch, lblOnFalse);
			Visit(ndAnd.Right);
			EndNestedIterator(ndAnd.Right);
			EndConjunctiveTests(iteratorDescriptor.CurrentBranchingContext, iteratorDescriptor.LabelBranch, lblOnFalse);
			return ndAnd;
		}

		private Label StartConjunctiveTests(BranchingContext brctxt, Label lblBranch)
		{
			if (brctxt == BranchingContext.OnFalse)
			{
				iterCurr.SetBranching(BranchingContext.OnFalse, lblBranch);
				return lblBranch;
			}
			Label label = helper.DefineLabel();
			iterCurr.SetBranching(BranchingContext.OnFalse, label);
			return label;
		}

		private void StartLastConjunctiveTest(BranchingContext brctxt, Label lblBranch, Label lblOnFalse)
		{
			if (brctxt == BranchingContext.OnTrue)
			{
				iterCurr.SetBranching(BranchingContext.OnTrue, lblBranch);
			}
			else
			{
				iterCurr.SetBranching(BranchingContext.OnFalse, lblOnFalse);
			}
		}

		private void EndConjunctiveTests(BranchingContext brctxt, Label lblBranch, Label lblOnFalse)
		{
			switch (brctxt)
			{
			case BranchingContext.OnTrue:
				helper.MarkLabel(lblOnFalse);
				goto case BranchingContext.OnFalse;
			case BranchingContext.OnFalse:
				iterCurr.Storage = StorageDescriptor.None();
				break;
			case BranchingContext.None:
				helper.ConvBranchToBool(lblOnFalse, isTrueBranch: false);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
				break;
			}
		}

		protected override QilNode VisitOr(QilBinary ndOr)
		{
			Label label = default(Label);
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnFalse:
				label = helper.DefineLabel();
				NestedVisitWithBranch(ndOr.Left, BranchingContext.OnTrue, label);
				break;
			case BranchingContext.OnTrue:
				NestedVisitWithBranch(ndOr.Left, BranchingContext.OnTrue, iterCurr.LabelBranch);
				break;
			default:
				label = helper.DefineLabel();
				NestedVisitWithBranch(ndOr.Left, BranchingContext.OnTrue, label);
				break;
			}
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnFalse:
				NestedVisitWithBranch(ndOr.Right, BranchingContext.OnFalse, iterCurr.LabelBranch);
				break;
			case BranchingContext.OnTrue:
				NestedVisitWithBranch(ndOr.Right, BranchingContext.OnTrue, iterCurr.LabelBranch);
				break;
			default:
				NestedVisitWithBranch(ndOr.Right, BranchingContext.OnTrue, label);
				break;
			}
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnFalse:
				helper.MarkLabel(label);
				goto case BranchingContext.OnTrue;
			case BranchingContext.OnTrue:
				iterCurr.Storage = StorageDescriptor.None();
				break;
			case BranchingContext.None:
				helper.ConvBranchToBool(label, isTrueBranch: true);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
				break;
			}
			return ndOr;
		}

		protected override QilNode VisitNot(QilUnary ndNot)
		{
			Label lblBranch = default(Label);
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnFalse:
				NestedVisitWithBranch(ndNot.Child, BranchingContext.OnTrue, iterCurr.LabelBranch);
				break;
			case BranchingContext.OnTrue:
				NestedVisitWithBranch(ndNot.Child, BranchingContext.OnFalse, iterCurr.LabelBranch);
				break;
			default:
				lblBranch = helper.DefineLabel();
				NestedVisitWithBranch(ndNot.Child, BranchingContext.OnTrue, lblBranch);
				break;
			}
			if (iterCurr.CurrentBranchingContext == BranchingContext.None)
			{
				helper.ConvBranchToBool(lblBranch, isTrueBranch: false);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
			}
			else
			{
				iterCurr.Storage = StorageDescriptor.None();
			}
			return ndNot;
		}

		protected override QilNode VisitConditional(QilTernary ndCond)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(ndCond);
			if (xmlILConstructInfo.ConstructMethod == XmlILConstructMethod.Writer)
			{
				Label label = helper.DefineLabel();
				NestedVisitWithBranch(ndCond.Left, BranchingContext.OnFalse, label);
				NestedVisit(ndCond.Center);
				if (ndCond.Right.NodeType == QilNodeType.Sequence && ndCond.Right.Count == 0)
				{
					helper.MarkLabel(label);
					NestedVisit(ndCond.Right);
				}
				else
				{
					Label label2 = helper.DefineLabel();
					helper.EmitUnconditionalBranch(OpCodes.Br, label2);
					helper.MarkLabel(label);
					NestedVisit(ndCond.Right);
					helper.MarkLabel(label2);
				}
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				LocalBuilder localBuilder = null;
				LocalBuilder localBuilder2 = null;
				Type itemStorageType = GetItemStorageType(ndCond);
				Label label3 = helper.DefineLabel();
				if (ndCond.XmlType.IsSingleton)
				{
					NestedVisitWithBranch(ndCond.Left, BranchingContext.OnFalse, label3);
				}
				else
				{
					localBuilder2 = helper.DeclareLocal("$$$cond", itemStorageType);
					localBuilder = helper.DeclareLocal("$$$boolResult", typeof(bool));
					NestedVisitEnsureLocal(ndCond.Left, localBuilder);
					helper.Emit(OpCodes.Ldloc, localBuilder);
					helper.Emit(OpCodes.Brfalse, label3);
				}
				ConditionalBranch(ndCond.Center, itemStorageType, localBuilder2);
				IteratorDescriptor iteratorDescriptor = iterNested;
				Label label4 = helper.DefineLabel();
				helper.EmitUnconditionalBranch(OpCodes.Br, label4);
				helper.MarkLabel(label3);
				ConditionalBranch(ndCond.Right, itemStorageType, localBuilder2);
				if (!ndCond.XmlType.IsSingleton)
				{
					helper.EmitUnconditionalBranch(OpCodes.Brtrue, label4);
					Label label5 = helper.DefineLabel();
					helper.MarkLabel(label5);
					helper.Emit(OpCodes.Ldloc, localBuilder);
					helper.Emit(OpCodes.Brtrue, iteratorDescriptor.GetLabelNext());
					helper.EmitUnconditionalBranch(OpCodes.Br, iterNested.GetLabelNext());
					iterCurr.SetIterator(label5, StorageDescriptor.Local(localBuilder2, itemStorageType, isCached: false));
				}
				helper.MarkLabel(label4);
			}
			return ndCond;
		}

		private void ConditionalBranch(QilNode ndBranch, Type itemStorageType, LocalBuilder locResult)
		{
			if (locResult == null)
			{
				if (iterCurr.IsBranching)
				{
					NestedVisitWithBranch(ndBranch, iterCurr.CurrentBranchingContext, iterCurr.LabelBranch);
				}
				else
				{
					NestedVisitEnsureStack(ndBranch, itemStorageType, isCached: false);
				}
			}
			else
			{
				NestedVisit(ndBranch, iterCurr.GetLabelNext());
				iterCurr.EnsureItemStorageType(ndBranch.XmlType, itemStorageType);
				iterCurr.EnsureLocalNoCache(locResult);
			}
		}

		protected override QilNode VisitChoice(QilChoice ndChoice)
		{
			NestedVisit(ndChoice.Expression);
			QilNode branches = ndChoice.Branches;
			int num = branches.Count - 1;
			Label[] array = new Label[num];
			int i;
			for (i = 0; i < num; i++)
			{
				array[i] = helper.DefineLabel();
			}
			Label label = helper.DefineLabel();
			Label label2 = helper.DefineLabel();
			helper.Emit(OpCodes.Switch, array);
			helper.EmitUnconditionalBranch(OpCodes.Br, label);
			for (i = 0; i < num; i++)
			{
				helper.MarkLabel(array[i]);
				NestedVisit(branches[i]);
				helper.EmitUnconditionalBranch(OpCodes.Br, label2);
			}
			helper.MarkLabel(label);
			NestedVisit(branches[i]);
			helper.MarkLabel(label2);
			iterCurr.Storage = StorageDescriptor.None();
			return ndChoice;
		}

		protected override QilNode VisitLength(QilUnary ndSetLen)
		{
			Label label = helper.DefineLabel();
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(ndSetLen);
			if (CachesResult(ndSetLen.Child))
			{
				NestedVisitEnsureStack(ndSetLen.Child);
				helper.CallCacheCount(iterNested.Storage.ItemStorageType);
			}
			else
			{
				helper.Emit(OpCodes.Ldc_I4_0);
				StartNestedIterator(ndSetLen.Child, label);
				Visit(ndSetLen.Child);
				iterCurr.EnsureNoCache();
				iterCurr.DiscardStack();
				helper.Emit(OpCodes.Ldc_I4_1);
				helper.Emit(OpCodes.Add);
				if (optimizerPatterns.MatchesPattern(OptimizerPatternName.MaxPosition))
				{
					helper.Emit(OpCodes.Dup);
					helper.LoadInteger((int)optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
					helper.Emit(OpCodes.Bgt, label);
				}
				iterCurr.LoopToEnd(label);
				EndNestedIterator(ndSetLen.Child);
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(int), isCached: false);
			return ndSetLen;
		}

		protected override QilNode VisitSequence(QilList ndSeq)
		{
			if (XmlILConstructInfo.Read(ndSeq).ConstructMethod == XmlILConstructMethod.Writer)
			{
				foreach (QilNode item in ndSeq)
				{
					NestedVisit(item);
				}
				return ndSeq;
			}
			if (ndSeq.Count == 0)
			{
				VisitEmpty(ndSeq);
			}
			else
			{
				Sequence(ndSeq);
			}
			return ndSeq;
		}

		private void VisitEmpty(QilNode nd)
		{
			helper.EmitUnconditionalBranch(OpCodes.Brtrue, iterCurr.GetLabelNext());
			helper.Emit(OpCodes.Ldnull);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathItem), isCached: false);
		}

		private void Sequence(QilList ndSeq)
		{
			Label label = default(Label);
			Type itemStorageType = GetItemStorageType(ndSeq);
			if (ndSeq.XmlType.IsSingleton)
			{
				foreach (QilNode item in ndSeq)
				{
					if (item.XmlType.IsSingleton)
					{
						NestedVisitEnsureStack(item);
						continue;
					}
					label = helper.DefineLabel();
					NestedVisit(item, label);
					iterCurr.DiscardStack();
					helper.MarkLabel(label);
				}
				iterCurr.Storage = StorageDescriptor.Stack(itemStorageType, isCached: false);
				return;
			}
			LocalBuilder localBuilder = helper.DeclareLocal("$$$itemList", itemStorageType);
			LocalBuilder locBldr = helper.DeclareLocal("$$$idxList", typeof(int));
			Label[] array = new Label[ndSeq.Count];
			Label label2 = helper.DefineLabel();
			for (int i = 0; i < ndSeq.Count; i++)
			{
				if (i != 0)
				{
					helper.MarkLabel(label);
				}
				label = ((i != ndSeq.Count - 1) ? helper.DefineLabel() : iterCurr.GetLabelNext());
				helper.LoadInteger(i);
				helper.Emit(OpCodes.Stloc, locBldr);
				NestedVisit(ndSeq[i], label);
				iterCurr.EnsureItemStorageType(ndSeq[i].XmlType, itemStorageType);
				iterCurr.EnsureLocalNoCache(localBuilder);
				array[i] = iterNested.GetLabelNext();
				helper.EmitUnconditionalBranch(OpCodes.Brtrue, label2);
			}
			Label label3 = helper.DefineLabel();
			helper.MarkLabel(label3);
			helper.Emit(OpCodes.Ldloc, locBldr);
			helper.Emit(OpCodes.Switch, array);
			helper.MarkLabel(label2);
			iterCurr.SetIterator(label3, StorageDescriptor.Local(localBuilder, itemStorageType, isCached: false));
		}

		protected override QilNode VisitUnion(QilBinary ndUnion)
		{
			return CreateSetIterator(ndUnion, "$$$iterUnion", typeof(UnionIterator), XmlILMethods.UnionCreate, XmlILMethods.UnionNext);
		}

		protected override QilNode VisitIntersection(QilBinary ndInter)
		{
			return CreateSetIterator(ndInter, "$$$iterInter", typeof(IntersectIterator), XmlILMethods.InterCreate, XmlILMethods.InterNext);
		}

		protected override QilNode VisitDifference(QilBinary ndDiff)
		{
			return CreateSetIterator(ndDiff, "$$$iterDiff", typeof(DifferenceIterator), XmlILMethods.DiffCreate, XmlILMethods.DiffNext);
		}

		private QilNode CreateSetIterator(QilBinary ndSet, string iterName, Type iterType, MethodInfo methCreate, MethodInfo methNext)
		{
			LocalBuilder localBuilder = helper.DeclareLocal(iterName, iterType);
			LocalBuilder localBuilder2 = helper.DeclareLocal("$$$navSet", typeof(XPathNavigator));
			helper.Emit(OpCodes.Ldloca, localBuilder);
			helper.LoadQueryRuntime();
			helper.Call(methCreate);
			Label label = helper.DefineLabel();
			Label label2 = helper.DefineLabel();
			Label label3 = helper.DefineLabel();
			NestedVisit(ndSet.Left, label);
			Label labelNext = iterNested.GetLabelNext();
			iterCurr.EnsureLocal(localBuilder2);
			helper.EmitUnconditionalBranch(OpCodes.Brtrue, label2);
			helper.MarkLabel(label3);
			NestedVisit(ndSet.Right, label);
			Label labelNext2 = iterNested.GetLabelNext();
			iterCurr.EnsureLocal(localBuilder2);
			helper.EmitUnconditionalBranch(OpCodes.Brtrue, label2);
			helper.MarkLabel(label);
			helper.Emit(OpCodes.Ldnull);
			helper.Emit(OpCodes.Stloc, localBuilder2);
			helper.MarkLabel(label2);
			helper.Emit(OpCodes.Ldloca, localBuilder);
			helper.Emit(OpCodes.Ldloc, localBuilder2);
			helper.Call(methNext);
			if (ndSet.XmlType.IsSingleton)
			{
				helper.Emit(OpCodes.Switch, new Label[3] { label3, labelNext, labelNext2 });
				iterCurr.Storage = StorageDescriptor.Current(localBuilder, typeof(XPathNavigator));
			}
			else
			{
				helper.Emit(OpCodes.Switch, new Label[4]
				{
					iterCurr.GetLabelNext(),
					label3,
					labelNext,
					labelNext2
				});
				iterCurr.SetIterator(label, StorageDescriptor.Current(localBuilder, typeof(XPathNavigator)));
			}
			return ndSet;
		}

		protected override QilNode VisitAverage(QilUnary ndAvg)
		{
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[GetItemStorageType(ndAvg)];
			return CreateAggregator(ndAvg, "$$$aggAvg", xmlILStorageMethods, xmlILStorageMethods.AggAvg, xmlILStorageMethods.AggAvgResult);
		}

		protected override QilNode VisitSum(QilUnary ndSum)
		{
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[GetItemStorageType(ndSum)];
			return CreateAggregator(ndSum, "$$$aggSum", xmlILStorageMethods, xmlILStorageMethods.AggSum, xmlILStorageMethods.AggSumResult);
		}

		protected override QilNode VisitMinimum(QilUnary ndMin)
		{
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[GetItemStorageType(ndMin)];
			return CreateAggregator(ndMin, "$$$aggMin", xmlILStorageMethods, xmlILStorageMethods.AggMin, xmlILStorageMethods.AggMinResult);
		}

		protected override QilNode VisitMaximum(QilUnary ndMax)
		{
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[GetItemStorageType(ndMax)];
			return CreateAggregator(ndMax, "$$$aggMax", xmlILStorageMethods, xmlILStorageMethods.AggMax, xmlILStorageMethods.AggMaxResult);
		}

		private QilNode CreateAggregator(QilUnary ndAgg, string aggName, XmlILStorageMethods methods, MethodInfo methAgg, MethodInfo methResult)
		{
			Label lblOnEnd = helper.DefineLabel();
			Type declaringType = methAgg.DeclaringType;
			LocalBuilder locBldr = helper.DeclareLocal(aggName, declaringType);
			helper.Emit(OpCodes.Ldloca, locBldr);
			helper.Call(methods.AggCreate);
			StartNestedIterator(ndAgg.Child, lblOnEnd);
			helper.Emit(OpCodes.Ldloca, locBldr);
			Visit(ndAgg.Child);
			iterCurr.EnsureStackNoCache();
			iterCurr.EnsureItemStorageType(ndAgg.XmlType, GetItemStorageType(ndAgg));
			helper.Call(methAgg);
			helper.Emit(OpCodes.Ldloca, locBldr);
			iterCurr.LoopToEnd(lblOnEnd);
			EndNestedIterator(ndAgg.Child);
			if (ndAgg.XmlType.MaybeEmpty)
			{
				helper.Call(methods.AggIsEmpty);
				helper.Emit(OpCodes.Brtrue, iterCurr.GetLabelNext());
				helper.Emit(OpCodes.Ldloca, locBldr);
			}
			helper.Call(methResult);
			iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(ndAgg), isCached: false);
			return ndAgg;
		}

		protected override QilNode VisitNegate(QilUnary ndNeg)
		{
			NestedVisitEnsureStack(ndNeg.Child);
			helper.CallArithmeticOp(QilNodeType.Negate, ndNeg.XmlType.TypeCode);
			iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(ndNeg), isCached: false);
			return ndNeg;
		}

		protected override QilNode VisitAdd(QilBinary ndPlus)
		{
			return ArithmeticOp(ndPlus);
		}

		protected override QilNode VisitSubtract(QilBinary ndMinus)
		{
			return ArithmeticOp(ndMinus);
		}

		protected override QilNode VisitMultiply(QilBinary ndMul)
		{
			return ArithmeticOp(ndMul);
		}

		protected override QilNode VisitDivide(QilBinary ndDiv)
		{
			return ArithmeticOp(ndDiv);
		}

		protected override QilNode VisitModulo(QilBinary ndMod)
		{
			return ArithmeticOp(ndMod);
		}

		private QilNode ArithmeticOp(QilBinary ndOp)
		{
			NestedVisitEnsureStack(ndOp.Left, ndOp.Right);
			helper.CallArithmeticOp(ndOp.NodeType, ndOp.XmlType.TypeCode);
			iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(ndOp), isCached: false);
			return ndOp;
		}

		protected override QilNode VisitStrLength(QilUnary ndLen)
		{
			NestedVisitEnsureStack(ndLen.Child);
			helper.Call(XmlILMethods.StrLen);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(int), isCached: false);
			return ndLen;
		}

		protected override QilNode VisitStrConcat(QilStrConcat ndStrConcat)
		{
			QilNode qilNode = ndStrConcat.Delimiter;
			if (qilNode.NodeType == QilNodeType.LiteralString && ((string)(QilLiteral)qilNode).Length == 0)
			{
				qilNode = null;
			}
			QilNode values = ndStrConcat.Values;
			bool flag;
			if (values.NodeType == QilNodeType.Sequence && values.Count < 5)
			{
				flag = true;
				foreach (QilNode item in values)
				{
					if (!item.XmlType.IsSingleton)
					{
						flag = false;
					}
				}
			}
			else
			{
				flag = false;
			}
			if (flag)
			{
				foreach (QilNode item2 in values)
				{
					NestedVisitEnsureStack(item2);
				}
				helper.CallConcatStrings(values.Count);
			}
			else
			{
				LocalBuilder localBuilder = helper.DeclareLocal("$$$strcat", typeof(StringConcat));
				helper.Emit(OpCodes.Ldloca, localBuilder);
				helper.Call(XmlILMethods.StrCatClear);
				if (qilNode != null)
				{
					helper.Emit(OpCodes.Ldloca, localBuilder);
					NestedVisitEnsureStack(qilNode);
					helper.Call(XmlILMethods.StrCatDelim);
				}
				helper.Emit(OpCodes.Ldloca, localBuilder);
				if (values.NodeType == QilNodeType.Sequence)
				{
					foreach (QilNode item3 in values)
					{
						GenerateConcat(item3, localBuilder);
					}
				}
				else
				{
					GenerateConcat(values, localBuilder);
				}
				helper.Call(XmlILMethods.StrCatResult);
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
			return ndStrConcat;
		}

		private void GenerateConcat(QilNode ndStr, LocalBuilder locStringConcat)
		{
			Label lblOnEnd = helper.DefineLabel();
			StartNestedIterator(ndStr, lblOnEnd);
			Visit(ndStr);
			iterCurr.EnsureStackNoCache();
			iterCurr.EnsureItemStorageType(ndStr.XmlType, typeof(string));
			helper.Call(XmlILMethods.StrCatCat);
			helper.Emit(OpCodes.Ldloca, locStringConcat);
			iterCurr.LoopToEnd(lblOnEnd);
			EndNestedIterator(ndStr);
		}

		protected override QilNode VisitStrParseQName(QilBinary ndParsedTagName)
		{
			VisitStrParseQName(ndParsedTagName, preservePrefix: false);
			return ndParsedTagName;
		}

		private void VisitStrParseQName(QilBinary ndParsedTagName, bool preservePrefix)
		{
			if (!preservePrefix)
			{
				helper.LoadQueryRuntime();
			}
			NestedVisitEnsureStack(ndParsedTagName.Left);
			if (ndParsedTagName.Right.XmlType.TypeCode == XmlTypeCode.String)
			{
				NestedVisitEnsureStack(ndParsedTagName.Right);
				if (!preservePrefix)
				{
					helper.CallParseTagName(GenerateNameType.TagNameAndNamespace);
				}
			}
			else
			{
				if (ndParsedTagName.Right.NodeType == QilNodeType.Sequence)
				{
					helper.LoadInteger(helper.StaticData.DeclarePrefixMappings(ndParsedTagName.Right));
				}
				else
				{
					helper.LoadInteger(helper.StaticData.DeclarePrefixMappings(new QilNode[1] { ndParsedTagName.Right }));
				}
				if (!preservePrefix)
				{
					helper.CallParseTagName(GenerateNameType.TagNameAndMappings);
				}
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XmlQualifiedName), isCached: false);
		}

		protected override QilNode VisitNe(QilBinary ndNe)
		{
			Compare(ndNe);
			return ndNe;
		}

		protected override QilNode VisitEq(QilBinary ndEq)
		{
			Compare(ndEq);
			return ndEq;
		}

		protected override QilNode VisitGt(QilBinary ndGt)
		{
			Compare(ndGt);
			return ndGt;
		}

		protected override QilNode VisitGe(QilBinary ndGe)
		{
			Compare(ndGe);
			return ndGe;
		}

		protected override QilNode VisitLt(QilBinary ndLt)
		{
			Compare(ndLt);
			return ndLt;
		}

		protected override QilNode VisitLe(QilBinary ndLe)
		{
			Compare(ndLe);
			return ndLe;
		}

		private void Compare(QilBinary ndComp)
		{
			QilNodeType nodeType = ndComp.NodeType;
			if ((nodeType == QilNodeType.Eq || nodeType == QilNodeType.Ne) && (TryZeroCompare(nodeType, ndComp.Left, ndComp.Right) || TryZeroCompare(nodeType, ndComp.Right, ndComp.Left) || TryNameCompare(nodeType, ndComp.Left, ndComp.Right) || TryNameCompare(nodeType, ndComp.Right, ndComp.Left)))
			{
				return;
			}
			NestedVisitEnsureStack(ndComp.Left, ndComp.Right);
			XmlTypeCode typeCode = ndComp.Left.XmlType.TypeCode;
			switch (typeCode)
			{
			case XmlTypeCode.String:
			case XmlTypeCode.Decimal:
			case XmlTypeCode.QName:
				if (nodeType == QilNodeType.Eq || nodeType == QilNodeType.Ne)
				{
					helper.CallCompareEquals(typeCode);
					ZeroCompare((nodeType == QilNodeType.Eq) ? QilNodeType.Ne : QilNodeType.Eq, isBoolVal: true);
				}
				else
				{
					helper.CallCompare(typeCode);
					helper.Emit(OpCodes.Ldc_I4_0);
					ClrCompare(nodeType, typeCode);
				}
				break;
			case XmlTypeCode.Boolean:
			case XmlTypeCode.Double:
			case XmlTypeCode.Integer:
			case XmlTypeCode.Int:
				ClrCompare(nodeType, typeCode);
				break;
			}
		}

		protected override QilNode VisitIs(QilBinary ndIs)
		{
			NestedVisitEnsureStack(ndIs.Left, ndIs.Right);
			helper.Call(XmlILMethods.NavSamePos);
			ZeroCompare(QilNodeType.Ne, isBoolVal: true);
			return ndIs;
		}

		protected override QilNode VisitBefore(QilBinary ndBefore)
		{
			ComparePosition(ndBefore);
			return ndBefore;
		}

		protected override QilNode VisitAfter(QilBinary ndAfter)
		{
			ComparePosition(ndAfter);
			return ndAfter;
		}

		private void ComparePosition(QilBinary ndComp)
		{
			helper.LoadQueryRuntime();
			NestedVisitEnsureStack(ndComp.Left, ndComp.Right);
			helper.Call(XmlILMethods.CompPos);
			helper.LoadInteger(0);
			ClrCompare((ndComp.NodeType == QilNodeType.Before) ? QilNodeType.Lt : QilNodeType.Gt, XmlTypeCode.String);
		}

		protected override QilNode VisitFor(QilIterator ndFor)
		{
			IteratorDescriptor cachedIteratorDescriptor = XmlILAnnotation.Write(ndFor).CachedIteratorDescriptor;
			iterCurr.Storage = cachedIteratorDescriptor.Storage;
			if (iterCurr.Storage.Location == ItemLocation.Global)
			{
				iterCurr.EnsureStack();
			}
			return ndFor;
		}

		protected override QilNode VisitLet(QilIterator ndLet)
		{
			return VisitFor(ndLet);
		}

		protected override QilNode VisitParameter(QilParameter ndParameter)
		{
			return VisitFor(ndParameter);
		}

		protected override QilNode VisitLoop(QilLoop ndLoop)
		{
			StartWriterLoop(ndLoop, out var hasOnEnd, out var lblOnEnd);
			StartBinding(ndLoop.Variable);
			Visit(ndLoop.Body);
			EndBinding(ndLoop.Variable);
			EndWriterLoop(ndLoop, hasOnEnd, lblOnEnd);
			return ndLoop;
		}

		protected override QilNode VisitFilter(QilLoop ndFilter)
		{
			if (HandleFilterPatterns(ndFilter))
			{
				return ndFilter;
			}
			StartBinding(ndFilter.Variable);
			iterCurr.SetIterator(iterNested);
			StartNestedIterator(ndFilter.Body);
			iterCurr.SetBranching(BranchingContext.OnFalse, iterCurr.ParentIterator.GetLabelNext());
			Visit(ndFilter.Body);
			EndNestedIterator(ndFilter.Body);
			EndBinding(ndFilter.Variable);
			return ndFilter;
		}

		private bool HandleFilterPatterns(QilLoop ndFilter)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(ndFilter);
			bool flag = optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterElements);
			if (flag || optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterContentKind))
			{
				XmlNodeKindFlags xmlNodeKindFlags;
				QilName qilName;
				if (flag)
				{
					xmlNodeKindFlags = XmlNodeKindFlags.Element;
					qilName = (QilName)optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName);
				}
				else
				{
					xmlNodeKindFlags = ((XmlQueryType)optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName)).NodeKinds;
					qilName = null;
				}
				QilNode qilNode = (QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.StepNode);
				QilNode qilNode2 = (QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.StepInput);
				switch (qilNode.NodeType)
				{
				case QilNodeType.Content:
					if (flag)
					{
						LocalBuilder localBuilder = helper.DeclareLocal("$$$iterElemContent", typeof(ElementContentIterator));
						helper.Emit(OpCodes.Ldloca, localBuilder);
						NestedVisitEnsureStack(qilNode2);
						helper.CallGetAtomizedName(helper.StaticData.DeclareName(qilName.LocalName));
						helper.CallGetAtomizedName(helper.StaticData.DeclareName(qilName.NamespaceUri));
						helper.Call(XmlILMethods.ElemContentCreate);
						GenerateSimpleIterator(typeof(XPathNavigator), localBuilder, XmlILMethods.ElemContentNext);
					}
					else if (xmlNodeKindFlags == XmlNodeKindFlags.Content)
					{
						CreateSimpleIterator(qilNode2, "$$$iterContent", typeof(ContentIterator), XmlILMethods.ContentCreate, XmlILMethods.ContentNext);
					}
					else
					{
						LocalBuilder localBuilder = helper.DeclareLocal("$$$iterContent", typeof(NodeKindContentIterator));
						helper.Emit(OpCodes.Ldloca, localBuilder);
						NestedVisitEnsureStack(qilNode2);
						helper.LoadInteger((int)QilXmlToXPathNodeType(xmlNodeKindFlags));
						helper.Call(XmlILMethods.KindContentCreate);
						GenerateSimpleIterator(typeof(XPathNavigator), localBuilder, XmlILMethods.KindContentNext);
					}
					return true;
				case QilNodeType.Parent:
					CreateFilteredIterator(qilNode2, "$$$iterPar", typeof(ParentIterator), XmlILMethods.ParentCreate, XmlILMethods.ParentNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				case QilNodeType.Ancestor:
				case QilNodeType.AncestorOrSelf:
					CreateFilteredIterator(qilNode2, "$$$iterAnc", typeof(AncestorIterator), XmlILMethods.AncCreate, XmlILMethods.AncNext, xmlNodeKindFlags, qilName, (qilNode.NodeType != QilNodeType.Ancestor) ? TriState.True : TriState.False, null);
					return true;
				case QilNodeType.Descendant:
				case QilNodeType.DescendantOrSelf:
					CreateFilteredIterator(qilNode2, "$$$iterDesc", typeof(DescendantIterator), XmlILMethods.DescCreate, XmlILMethods.DescNext, xmlNodeKindFlags, qilName, (qilNode.NodeType != QilNodeType.Descendant) ? TriState.True : TriState.False, null);
					return true;
				case QilNodeType.Preceding:
					CreateFilteredIterator(qilNode2, "$$$iterPrec", typeof(PrecedingIterator), XmlILMethods.PrecCreate, XmlILMethods.PrecNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				case QilNodeType.FollowingSibling:
					CreateFilteredIterator(qilNode2, "$$$iterFollSib", typeof(FollowingSiblingIterator), XmlILMethods.FollSibCreate, XmlILMethods.FollSibNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				case QilNodeType.PrecedingSibling:
					CreateFilteredIterator(qilNode2, "$$$iterPreSib", typeof(PrecedingSiblingIterator), XmlILMethods.PreSibCreate, XmlILMethods.PreSibNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				case QilNodeType.NodeRange:
					CreateFilteredIterator(qilNode2, "$$$iterRange", typeof(NodeRangeIterator), XmlILMethods.NodeRangeCreate, XmlILMethods.NodeRangeNext, xmlNodeKindFlags, qilName, TriState.Unknown, ((QilBinary)qilNode).Right);
					return true;
				case QilNodeType.XPathFollowing:
					CreateFilteredIterator(qilNode2, "$$$iterFoll", typeof(XPathFollowingIterator), XmlILMethods.XPFollCreate, XmlILMethods.XPFollNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				case QilNodeType.XPathPreceding:
					CreateFilteredIterator(qilNode2, "$$$iterPrec", typeof(XPathPrecedingIterator), XmlILMethods.XPPrecCreate, XmlILMethods.XPPrecNext, xmlNodeKindFlags, qilName, TriState.Unknown, null);
					return true;
				}
			}
			else
			{
				if (optimizerPatterns.MatchesPattern(OptimizerPatternName.FilterAttributeKind))
				{
					QilNode qilNode2 = (QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.StepInput);
					CreateSimpleIterator(qilNode2, "$$$iterAttr", typeof(AttributeIterator), XmlILMethods.AttrCreate, XmlILMethods.AttrNext);
					return true;
				}
				if (optimizerPatterns.MatchesPattern(OptimizerPatternName.EqualityIndex))
				{
					Label lblOnEnd = helper.DefineLabel();
					Label label = helper.DefineLabel();
					QilIterator qilIterator = (QilIterator)optimizerPatterns.GetArgument(OptimizerPatternArgument.StepNode);
					QilNode n = (QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.StepInput);
					LocalBuilder locBldr = helper.DeclareLocal("$$$index", typeof(XmlILIndex));
					helper.LoadQueryRuntime();
					helper.Emit(OpCodes.Ldarg_1);
					helper.LoadInteger(indexId);
					helper.Emit(OpCodes.Ldloca, locBldr);
					helper.Call(XmlILMethods.FindIndex);
					helper.Emit(OpCodes.Brtrue, label);
					helper.LoadQueryRuntime();
					helper.Emit(OpCodes.Ldarg_1);
					helper.LoadInteger(indexId);
					helper.Emit(OpCodes.Ldloc, locBldr);
					StartNestedIterator(qilIterator, lblOnEnd);
					StartBinding(qilIterator);
					Visit(n);
					iterCurr.EnsureStackNoCache();
					VisitFor(qilIterator);
					iterCurr.EnsureStackNoCache();
					iterCurr.EnsureItemStorageType(qilIterator.XmlType, typeof(XPathNavigator));
					helper.Call(XmlILMethods.IndexAdd);
					helper.Emit(OpCodes.Ldloc, locBldr);
					iterCurr.LoopToEnd(lblOnEnd);
					EndBinding(qilIterator);
					EndNestedIterator(qilIterator);
					helper.Call(XmlILMethods.AddNewIndex);
					helper.MarkLabel(label);
					helper.Emit(OpCodes.Ldloc, locBldr);
					helper.Emit(OpCodes.Ldarg_2);
					helper.Call(XmlILMethods.IndexLookup);
					iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathNavigator), isCached: true);
					indexId++;
					return true;
				}
			}
			return false;
		}

		private void StartBinding(QilIterator ndIter)
		{
			OptimizerPatterns patt = OptimizerPatterns.Read(ndIter);
			if (qil.IsDebug && ndIter.SourceLine != null)
			{
				helper.DebugSequencePoint(ndIter.SourceLine);
			}
			if (ndIter.NodeType == QilNodeType.For || ndIter.XmlType.IsSingleton)
			{
				StartForBinding(ndIter, patt);
			}
			else
			{
				StartLetBinding(ndIter);
			}
			XmlILAnnotation.Write(ndIter).CachedIteratorDescriptor = iterNested;
		}

		private void StartForBinding(QilIterator ndFor, OptimizerPatterns patt)
		{
			LocalBuilder localBuilder = null;
			if (iterCurr.HasLabelNext)
			{
				StartNestedIterator(ndFor.Binding, iterCurr.GetLabelNext());
			}
			else
			{
				StartNestedIterator(ndFor.Binding);
			}
			if (patt.MatchesPattern(OptimizerPatternName.IsPositional))
			{
				localBuilder = helper.DeclareLocal("$$$pos", typeof(int));
				helper.Emit(OpCodes.Ldc_I4_0);
				helper.Emit(OpCodes.Stloc, localBuilder);
			}
			Visit(ndFor.Binding);
			if (qil.IsDebug && ndFor.DebugName != null)
			{
				helper.DebugStartScope();
				iterCurr.EnsureLocalNoCache("$$$for");
				iterCurr.Storage.LocalLocation.SetLocalSymInfo(ndFor.DebugName);
			}
			else
			{
				iterCurr.EnsureNoStackNoCache("$$$for");
			}
			if (patt.MatchesPattern(OptimizerPatternName.IsPositional))
			{
				helper.Emit(OpCodes.Ldloc, localBuilder);
				helper.Emit(OpCodes.Ldc_I4_1);
				helper.Emit(OpCodes.Add);
				helper.Emit(OpCodes.Stloc, localBuilder);
				if (patt.MatchesPattern(OptimizerPatternName.MaxPosition))
				{
					helper.Emit(OpCodes.Ldloc, localBuilder);
					helper.LoadInteger((int)patt.GetArgument(OptimizerPatternArgument.ElementQName));
					helper.Emit(OpCodes.Bgt, iterCurr.ParentIterator.GetLabelNext());
				}
				iterCurr.LocalPosition = localBuilder;
			}
			EndNestedIterator(ndFor.Binding);
			iterCurr.SetIterator(iterNested);
		}

		public void StartLetBinding(QilIterator ndLet)
		{
			StartNestedIterator(ndLet);
			NestedVisit(ndLet.Binding, GetItemStorageType(ndLet), !ndLet.XmlType.IsSingleton);
			if (qil.IsDebug && ndLet.DebugName != null)
			{
				helper.DebugStartScope();
				iterCurr.EnsureLocal("$$$cache");
				iterCurr.Storage.LocalLocation.SetLocalSymInfo(ndLet.DebugName);
			}
			else
			{
				iterCurr.EnsureNoStack("$$$cache");
			}
			EndNestedIterator(ndLet);
		}

		private void EndBinding(QilIterator ndIter)
		{
			if (qil.IsDebug && ndIter.DebugName != null)
			{
				helper.DebugEndScope();
			}
		}

		protected override QilNode VisitPositionOf(QilUnary ndPos)
		{
			QilIterator nd = ndPos.Child as QilIterator;
			LocalBuilder localPosition = XmlILAnnotation.Write(nd).CachedIteratorDescriptor.LocalPosition;
			iterCurr.Storage = StorageDescriptor.Local(localPosition, typeof(int), isCached: false);
			return ndPos;
		}

		protected override QilNode VisitSort(QilLoop ndSort)
		{
			Type itemStorageType = GetItemStorageType(ndSort);
			Label lblOnEnd = helper.DefineLabel();
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[itemStorageType];
			LocalBuilder localBuilder = helper.DeclareLocal("$$$cache", xmlILStorageMethods.SeqType);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.CallToken(xmlILStorageMethods.SeqReuse);
			helper.Emit(OpCodes.Stloc, localBuilder);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			LocalBuilder localBuilder2 = helper.DeclareLocal("$$$keys", typeof(XmlSortKeyAccumulator));
			helper.Emit(OpCodes.Ldloca, localBuilder2);
			helper.Call(XmlILMethods.SortKeyCreate);
			StartNestedIterator(ndSort.Variable, lblOnEnd);
			StartBinding(ndSort.Variable);
			iterCurr.EnsureStackNoCache();
			iterCurr.EnsureItemStorageType(ndSort.Variable.XmlType, GetItemStorageType(ndSort.Variable));
			helper.Call(xmlILStorageMethods.SeqAdd);
			helper.Emit(OpCodes.Ldloca, localBuilder2);
			foreach (QilSortKey item in ndSort.Body)
			{
				VisitSortKey(item, localBuilder2);
			}
			helper.Call(XmlILMethods.SortKeyFinish);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			iterCurr.LoopToEnd(lblOnEnd);
			helper.Emit(OpCodes.Pop);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.Emit(OpCodes.Ldloca, localBuilder2);
			helper.Call(XmlILMethods.SortKeyKeys);
			helper.Call(xmlILStorageMethods.SeqSortByKeys);
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, itemStorageType, isCached: true);
			EndBinding(ndSort.Variable);
			EndNestedIterator(ndSort.Variable);
			iterCurr.SetIterator(iterNested);
			return ndSort;
		}

		private void VisitSortKey(QilSortKey ndKey, LocalBuilder locKeys)
		{
			helper.Emit(OpCodes.Ldloca, locKeys);
			if (ndKey.Collation.NodeType == QilNodeType.LiteralString)
			{
				helper.CallGetCollation(helper.StaticData.DeclareCollation((QilLiteral)ndKey.Collation));
			}
			else
			{
				helper.LoadQueryRuntime();
				NestedVisitEnsureStack(ndKey.Collation);
				helper.Call(XmlILMethods.CreateCollation);
			}
			if (ndKey.XmlType.IsSingleton)
			{
				NestedVisitEnsureStack(ndKey.Key);
				helper.AddSortKey(ndKey.Key.XmlType);
				return;
			}
			Label label = helper.DefineLabel();
			StartNestedIterator(ndKey.Key, label);
			Visit(ndKey.Key);
			iterCurr.EnsureStackNoCache();
			iterCurr.EnsureItemStorageType(ndKey.Key.XmlType, GetItemStorageType(ndKey.Key));
			helper.AddSortKey(ndKey.Key.XmlType);
			Label label2 = helper.DefineLabel();
			helper.EmitUnconditionalBranch(OpCodes.Br_S, label2);
			helper.MarkLabel(label);
			helper.AddSortKey(null);
			helper.MarkLabel(label2);
			EndNestedIterator(ndKey.Key);
		}

		protected override QilNode VisitDocOrderDistinct(QilUnary ndDod)
		{
			if (ndDod.XmlType.IsSingleton)
			{
				return Visit(ndDod.Child);
			}
			if (HandleDodPatterns(ndDod))
			{
				return ndDod;
			}
			helper.LoadQueryRuntime();
			NestedVisitEnsureCache(ndDod.Child, typeof(XPathNavigator));
			iterCurr.EnsureStack();
			helper.Call(XmlILMethods.DocOrder);
			return ndDod;
		}

		private bool HandleDodPatterns(QilUnary ndDod)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(ndDod);
			bool flag = optimizerPatterns.MatchesPattern(OptimizerPatternName.JoinAndDod);
			if (flag || optimizerPatterns.MatchesPattern(OptimizerPatternName.DodReverse))
			{
				OptimizerPatterns optimizerPatterns2 = OptimizerPatterns.Read((QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
				XmlNodeKindFlags kinds;
				QilName ndName;
				if (optimizerPatterns2.MatchesPattern(OptimizerPatternName.FilterElements))
				{
					kinds = XmlNodeKindFlags.Element;
					ndName = (QilName)optimizerPatterns2.GetArgument(OptimizerPatternArgument.ElementQName);
				}
				else if (optimizerPatterns2.MatchesPattern(OptimizerPatternName.FilterContentKind))
				{
					kinds = ((XmlQueryType)optimizerPatterns2.GetArgument(OptimizerPatternArgument.ElementQName)).NodeKinds;
					ndName = null;
				}
				else
				{
					kinds = (((ndDod.XmlType.NodeKinds & XmlNodeKindFlags.Attribute) != 0) ? XmlNodeKindFlags.Any : XmlNodeKindFlags.Content);
					ndName = null;
				}
				QilNode qilNode = (QilNode)optimizerPatterns2.GetArgument(OptimizerPatternArgument.StepNode);
				if (flag)
				{
					switch (qilNode.NodeType)
					{
					case QilNodeType.Content:
						CreateContainerIterator(ndDod, "$$$iterContent", typeof(ContentMergeIterator), XmlILMethods.ContentMergeCreate, XmlILMethods.ContentMergeNext, kinds, ndName, TriState.Unknown);
						return true;
					case QilNodeType.Descendant:
					case QilNodeType.DescendantOrSelf:
						CreateContainerIterator(ndDod, "$$$iterDesc", typeof(DescendantMergeIterator), XmlILMethods.DescMergeCreate, XmlILMethods.DescMergeNext, kinds, ndName, (qilNode.NodeType != QilNodeType.Descendant) ? TriState.True : TriState.False);
						return true;
					case QilNodeType.XPathFollowing:
						CreateContainerIterator(ndDod, "$$$iterFoll", typeof(XPathFollowingMergeIterator), XmlILMethods.XPFollMergeCreate, XmlILMethods.XPFollMergeNext, kinds, ndName, TriState.Unknown);
						return true;
					case QilNodeType.FollowingSibling:
						CreateContainerIterator(ndDod, "$$$iterFollSib", typeof(FollowingSiblingMergeIterator), XmlILMethods.FollSibMergeCreate, XmlILMethods.FollSibMergeNext, kinds, ndName, TriState.Unknown);
						return true;
					case QilNodeType.XPathPreceding:
						CreateContainerIterator(ndDod, "$$$iterPrec", typeof(XPathPrecedingMergeIterator), XmlILMethods.XPPrecMergeCreate, XmlILMethods.XPPrecMergeNext, kinds, ndName, TriState.Unknown);
						return true;
					}
				}
				else
				{
					QilNode ndCtxt = (QilNode)optimizerPatterns2.GetArgument(OptimizerPatternArgument.StepInput);
					switch (qilNode.NodeType)
					{
					case QilNodeType.Ancestor:
					case QilNodeType.AncestorOrSelf:
						CreateFilteredIterator(ndCtxt, "$$$iterAnc", typeof(AncestorDocOrderIterator), XmlILMethods.AncDOCreate, XmlILMethods.AncDONext, kinds, ndName, (qilNode.NodeType != QilNodeType.Ancestor) ? TriState.True : TriState.False, null);
						return true;
					case QilNodeType.PrecedingSibling:
						CreateFilteredIterator(ndCtxt, "$$$iterPreSib", typeof(PrecedingSiblingDocOrderIterator), XmlILMethods.PreSibDOCreate, XmlILMethods.PreSibDONext, kinds, ndName, TriState.Unknown, null);
						return true;
					case QilNodeType.XPathPreceding:
						CreateFilteredIterator(ndCtxt, "$$$iterPrec", typeof(XPathPrecedingDocOrderIterator), XmlILMethods.XPPrecDOCreate, XmlILMethods.XPPrecDONext, kinds, ndName, TriState.Unknown, null);
						return true;
					}
				}
			}
			else if (optimizerPatterns.MatchesPattern(OptimizerPatternName.DodMerge))
			{
				LocalBuilder locBldr = helper.DeclareLocal("$$$dodMerge", typeof(DodSequenceMerge));
				Label lblOnEnd = helper.DefineLabel();
				helper.Emit(OpCodes.Ldloca, locBldr);
				helper.LoadQueryRuntime();
				helper.Call(XmlILMethods.DodMergeCreate);
				helper.Emit(OpCodes.Ldloca, locBldr);
				StartNestedIterator(ndDod.Child, lblOnEnd);
				Visit(ndDod.Child);
				iterCurr.EnsureStack();
				helper.Call(XmlILMethods.DodMergeAdd);
				helper.Emit(OpCodes.Ldloca, locBldr);
				iterCurr.LoopToEnd(lblOnEnd);
				EndNestedIterator(ndDod.Child);
				helper.Call(XmlILMethods.DodMergeSeq);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathNavigator), isCached: true);
				return true;
			}
			return false;
		}

		protected override QilNode VisitInvoke(QilInvoke ndInvoke)
		{
			QilFunction function = ndInvoke.Function;
			MethodInfo functionBinding = XmlILAnnotation.Write(function).FunctionBinding;
			bool flag = XmlILConstructInfo.Read(function).ConstructMethod == XmlILConstructMethod.Writer;
			helper.LoadQueryRuntime();
			for (int i = 0; i < ndInvoke.Arguments.Count; i++)
			{
				QilNode nd = ndInvoke.Arguments[i];
				QilNode qilNode = ndInvoke.Function.Arguments[i];
				NestedVisitEnsureStack(nd, GetItemStorageType(qilNode), !qilNode.XmlType.IsSingleton);
			}
			if (OptimizerPatterns.Read(ndInvoke).MatchesPattern(OptimizerPatternName.TailCall))
			{
				helper.TailCall(functionBinding);
			}
			else
			{
				helper.Call(functionBinding);
			}
			if (!flag)
			{
				iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(ndInvoke), !ndInvoke.XmlType.IsSingleton);
			}
			else
			{
				iterCurr.Storage = StorageDescriptor.None();
			}
			return ndInvoke;
		}

		protected override QilNode VisitContent(QilUnary ndContent)
		{
			CreateSimpleIterator(ndContent.Child, "$$$iterAttrContent", typeof(AttributeContentIterator), XmlILMethods.AttrContentCreate, XmlILMethods.AttrContentNext);
			return ndContent;
		}

		protected override QilNode VisitAttribute(QilBinary ndAttr)
		{
			QilName qilName = ndAttr.Right as QilName;
			LocalBuilder localBuilder = helper.DeclareLocal("$$$navAttr", typeof(XPathNavigator));
			SyncToNavigator(localBuilder, ndAttr.Left);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.CallGetAtomizedName(helper.StaticData.DeclareName(qilName.LocalName));
			helper.CallGetAtomizedName(helper.StaticData.DeclareName(qilName.NamespaceUri));
			helper.Call(XmlILMethods.NavMoveAttr);
			helper.Emit(OpCodes.Brfalse, iterCurr.GetLabelNext());
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, typeof(XPathNavigator), isCached: false);
			return ndAttr;
		}

		protected override QilNode VisitParent(QilUnary ndParent)
		{
			LocalBuilder localBuilder = helper.DeclareLocal("$$$navParent", typeof(XPathNavigator));
			SyncToNavigator(localBuilder, ndParent.Child);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.Call(XmlILMethods.NavMoveParent);
			helper.Emit(OpCodes.Brfalse, iterCurr.GetLabelNext());
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, typeof(XPathNavigator), isCached: false);
			return ndParent;
		}

		protected override QilNode VisitRoot(QilUnary ndRoot)
		{
			LocalBuilder localBuilder = helper.DeclareLocal("$$$navRoot", typeof(XPathNavigator));
			SyncToNavigator(localBuilder, ndRoot.Child);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			helper.Call(XmlILMethods.NavMoveRoot);
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, typeof(XPathNavigator), isCached: false);
			return ndRoot;
		}

		protected override QilNode VisitXmlContext(QilNode ndCtxt)
		{
			helper.LoadQueryContext();
			helper.Call(XmlILMethods.GetDefaultDataSource);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathNavigator), isCached: false);
			return ndCtxt;
		}

		protected override QilNode VisitDescendant(QilUnary ndDesc)
		{
			CreateFilteredIterator(ndDesc.Child, "$$$iterDesc", typeof(DescendantIterator), XmlILMethods.DescCreate, XmlILMethods.DescNext, XmlNodeKindFlags.Any, null, TriState.False, null);
			return ndDesc;
		}

		protected override QilNode VisitDescendantOrSelf(QilUnary ndDesc)
		{
			CreateFilteredIterator(ndDesc.Child, "$$$iterDesc", typeof(DescendantIterator), XmlILMethods.DescCreate, XmlILMethods.DescNext, XmlNodeKindFlags.Any, null, TriState.True, null);
			return ndDesc;
		}

		protected override QilNode VisitAncestor(QilUnary ndAnc)
		{
			CreateFilteredIterator(ndAnc.Child, "$$$iterAnc", typeof(AncestorIterator), XmlILMethods.AncCreate, XmlILMethods.AncNext, XmlNodeKindFlags.Any, null, TriState.False, null);
			return ndAnc;
		}

		protected override QilNode VisitAncestorOrSelf(QilUnary ndAnc)
		{
			CreateFilteredIterator(ndAnc.Child, "$$$iterAnc", typeof(AncestorIterator), XmlILMethods.AncCreate, XmlILMethods.AncNext, XmlNodeKindFlags.Any, null, TriState.True, null);
			return ndAnc;
		}

		protected override QilNode VisitPreceding(QilUnary ndPrec)
		{
			CreateFilteredIterator(ndPrec.Child, "$$$iterPrec", typeof(PrecedingIterator), XmlILMethods.PrecCreate, XmlILMethods.PrecNext, XmlNodeKindFlags.Any, null, TriState.Unknown, null);
			return ndPrec;
		}

		protected override QilNode VisitFollowingSibling(QilUnary ndFollSib)
		{
			CreateFilteredIterator(ndFollSib.Child, "$$$iterFollSib", typeof(FollowingSiblingIterator), XmlILMethods.FollSibCreate, XmlILMethods.FollSibNext, XmlNodeKindFlags.Any, null, TriState.Unknown, null);
			return ndFollSib;
		}

		protected override QilNode VisitPrecedingSibling(QilUnary ndPreSib)
		{
			CreateFilteredIterator(ndPreSib.Child, "$$$iterPreSib", typeof(PrecedingSiblingIterator), XmlILMethods.PreSibCreate, XmlILMethods.PreSibNext, XmlNodeKindFlags.Any, null, TriState.Unknown, null);
			return ndPreSib;
		}

		protected override QilNode VisitNodeRange(QilBinary ndRange)
		{
			CreateFilteredIterator(ndRange.Left, "$$$iterRange", typeof(NodeRangeIterator), XmlILMethods.NodeRangeCreate, XmlILMethods.NodeRangeNext, XmlNodeKindFlags.Any, null, TriState.Unknown, ndRange.Right);
			return ndRange;
		}

		protected override QilNode VisitDeref(QilBinary ndDeref)
		{
			LocalBuilder localBuilder = helper.DeclareLocal("$$$iterId", typeof(IdIterator));
			helper.Emit(OpCodes.Ldloca, localBuilder);
			NestedVisitEnsureStack(ndDeref.Left);
			NestedVisitEnsureStack(ndDeref.Right);
			helper.Call(XmlILMethods.IdCreate);
			GenerateSimpleIterator(typeof(XPathNavigator), localBuilder, XmlILMethods.IdNext);
			return ndDeref;
		}

		protected override QilNode VisitElementCtor(QilBinary ndElem)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(ndElem);
			bool flag = CheckWithinContent(xmlILConstructInfo) || !xmlILConstructInfo.IsNamespaceInScope || ElementCachesAttributes(xmlILConstructInfo);
			if (XmlILConstructInfo.Read(ndElem.Right).FinalStates == PossibleXmlStates.Any)
			{
				flag = true;
			}
			if (xmlILConstructInfo.FinalStates == PossibleXmlStates.Any)
			{
				flag = true;
			}
			if (!flag)
			{
				BeforeStartChecks(ndElem);
			}
			GenerateNameType nameType = LoadNameAndType(XPathNodeType.Element, ndElem.Left, isStart: true, flag);
			helper.CallWriteStartElement(nameType, flag);
			NestedVisit(ndElem.Right);
			if (XmlILConstructInfo.Read(ndElem.Right).FinalStates == PossibleXmlStates.EnumAttrs && !flag)
			{
				helper.CallStartElementContent();
			}
			nameType = LoadNameAndType(XPathNodeType.Element, ndElem.Left, isStart: false, flag);
			helper.CallWriteEndElement(nameType, flag);
			if (!flag)
			{
				AfterEndChecks(ndElem);
			}
			iterCurr.Storage = StorageDescriptor.None();
			return ndElem;
		}

		protected override QilNode VisitAttributeCtor(QilBinary ndAttr)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(ndAttr);
			bool flag = CheckEnumAttrs(xmlILConstructInfo) || !xmlILConstructInfo.IsNamespaceInScope;
			if (!flag)
			{
				BeforeStartChecks(ndAttr);
			}
			GenerateNameType nameType = LoadNameAndType(XPathNodeType.Attribute, ndAttr.Left, isStart: true, flag);
			helper.CallWriteStartAttribute(nameType, flag);
			NestedVisit(ndAttr.Right);
			helper.CallWriteEndAttribute(flag);
			if (!flag)
			{
				AfterEndChecks(ndAttr);
			}
			iterCurr.Storage = StorageDescriptor.None();
			return ndAttr;
		}

		protected override QilNode VisitCommentCtor(QilUnary ndComment)
		{
			helper.CallWriteStartComment();
			NestedVisit(ndComment.Child);
			helper.CallWriteEndComment();
			iterCurr.Storage = StorageDescriptor.None();
			return ndComment;
		}

		protected override QilNode VisitPICtor(QilBinary ndPI)
		{
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndPI.Left);
			helper.CallWriteStartPI();
			NestedVisit(ndPI.Right);
			helper.CallWriteEndPI();
			iterCurr.Storage = StorageDescriptor.None();
			return ndPI;
		}

		protected override QilNode VisitTextCtor(QilUnary ndText)
		{
			return VisitTextCtor(ndText, disableOutputEscaping: false);
		}

		protected override QilNode VisitRawTextCtor(QilUnary ndText)
		{
			return VisitTextCtor(ndText, disableOutputEscaping: true);
		}

		private QilNode VisitTextCtor(QilUnary ndText, bool disableOutputEscaping)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(ndText);
			PossibleXmlStates initialStates = xmlILConstructInfo.InitialStates;
			bool flag = (uint)(initialStates - 4) > 2u && CheckWithinContent(xmlILConstructInfo);
			if (!flag)
			{
				BeforeStartChecks(ndText);
			}
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndText.Child);
			switch (xmlILConstructInfo.InitialStates)
			{
			case PossibleXmlStates.WithinAttr:
				helper.CallWriteString(disableOutputEscaping: false, flag);
				break;
			case PossibleXmlStates.WithinComment:
				helper.Call(XmlILMethods.CommentText);
				break;
			case PossibleXmlStates.WithinPI:
				helper.Call(XmlILMethods.PIText);
				break;
			default:
				helper.CallWriteString(disableOutputEscaping, flag);
				break;
			}
			if (!flag)
			{
				AfterEndChecks(ndText);
			}
			iterCurr.Storage = StorageDescriptor.None();
			return ndText;
		}

		protected override QilNode VisitDocumentCtor(QilUnary ndDoc)
		{
			helper.CallWriteStartRoot();
			NestedVisit(ndDoc.Child);
			helper.CallWriteEndRoot();
			iterCurr.Storage = StorageDescriptor.None();
			return ndDoc;
		}

		protected override QilNode VisitNamespaceDecl(QilBinary ndNmsp)
		{
			XmlILConstructInfo info = XmlILConstructInfo.Read(ndNmsp);
			bool flag = CheckEnumAttrs(info) || MightHaveNamespacesAfterAttributes(info);
			if (!flag)
			{
				BeforeStartChecks(ndNmsp);
			}
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndNmsp.Left);
			NestedVisitEnsureStack(ndNmsp.Right);
			helper.CallWriteNamespaceDecl(flag);
			if (!flag)
			{
				AfterEndChecks(ndNmsp);
			}
			iterCurr.Storage = StorageDescriptor.None();
			return ndNmsp;
		}

		protected override QilNode VisitRtfCtor(QilBinary ndRtf)
		{
			OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(ndRtf);
			string text = (QilLiteral)ndRtf.Right;
			if (optimizerPatterns.MatchesPattern(OptimizerPatternName.SingleTextRtf))
			{
				helper.LoadQueryRuntime();
				NestedVisitEnsureStack((QilNode)optimizerPatterns.GetArgument(OptimizerPatternArgument.ElementQName));
				helper.Emit(OpCodes.Ldstr, text);
				helper.Call(XmlILMethods.RtfConstr);
			}
			else
			{
				helper.CallStartRtfConstruction(text);
				NestedVisit(ndRtf.Left);
				helper.CallEndRtfConstruction();
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathNavigator), isCached: false);
			return ndRtf;
		}

		protected override QilNode VisitNameOf(QilUnary ndName)
		{
			return VisitNodeProperty(ndName);
		}

		protected override QilNode VisitLocalNameOf(QilUnary ndName)
		{
			return VisitNodeProperty(ndName);
		}

		protected override QilNode VisitNamespaceUriOf(QilUnary ndName)
		{
			return VisitNodeProperty(ndName);
		}

		protected override QilNode VisitPrefixOf(QilUnary ndName)
		{
			return VisitNodeProperty(ndName);
		}

		private QilNode VisitNodeProperty(QilUnary ndProp)
		{
			NestedVisitEnsureStack(ndProp.Child);
			switch (ndProp.NodeType)
			{
			case QilNodeType.NameOf:
				helper.Emit(OpCodes.Dup);
				helper.Call(XmlILMethods.NavLocalName);
				helper.Call(XmlILMethods.NavNmsp);
				helper.Construct(XmlILConstructors.QName);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(XmlQualifiedName), isCached: false);
				break;
			case QilNodeType.LocalNameOf:
				helper.Call(XmlILMethods.NavLocalName);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
				break;
			case QilNodeType.NamespaceUriOf:
				helper.Call(XmlILMethods.NavNmsp);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
				break;
			case QilNodeType.PrefixOf:
				helper.Call(XmlILMethods.NavPrefix);
				iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
				break;
			}
			return ndProp;
		}

		protected override QilNode VisitTypeAssert(QilTargetType ndTypeAssert)
		{
			if (!ndTypeAssert.Source.XmlType.IsSingleton && ndTypeAssert.XmlType.IsSingleton && !iterCurr.HasLabelNext)
			{
				Label label = helper.DefineLabel();
				helper.MarkLabel(label);
				NestedVisit(ndTypeAssert.Source, label);
			}
			else
			{
				Visit(ndTypeAssert.Source);
			}
			iterCurr.EnsureItemStorageType(ndTypeAssert.Source.XmlType, GetItemStorageType(ndTypeAssert));
			return ndTypeAssert;
		}

		protected override QilNode VisitIsType(QilTargetType ndIsType)
		{
			XmlQueryType xmlType = ndIsType.Source.XmlType;
			XmlQueryType targetType = ndIsType.TargetType;
			if (xmlType.IsSingleton && (object)targetType == XmlQueryTypeFactory.Node)
			{
				NestedVisitEnsureStack(ndIsType.Source);
				helper.Call(XmlILMethods.ItemIsNode);
				ZeroCompare(QilNodeType.Ne, isBoolVal: true);
				return ndIsType;
			}
			if (MatchesNodeKinds(ndIsType, xmlType, targetType))
			{
				return ndIsType;
			}
			XmlTypeCode xmlTypeCode = (((object)targetType == XmlQueryTypeFactory.Double) ? XmlTypeCode.Double : (((object)targetType == XmlQueryTypeFactory.String) ? XmlTypeCode.String : (((object)targetType == XmlQueryTypeFactory.Boolean) ? XmlTypeCode.Boolean : (((object)targetType == XmlQueryTypeFactory.Node) ? XmlTypeCode.Node : XmlTypeCode.None))));
			if (xmlTypeCode != 0)
			{
				helper.LoadQueryRuntime();
				NestedVisitEnsureStack(ndIsType.Source, typeof(XPathItem), !xmlType.IsSingleton);
				helper.LoadInteger((int)xmlTypeCode);
				helper.Call(xmlType.IsSingleton ? XmlILMethods.ItemMatchesCode : XmlILMethods.SeqMatchesCode);
				ZeroCompare(QilNodeType.Ne, isBoolVal: true);
				return ndIsType;
			}
			helper.LoadQueryRuntime();
			NestedVisitEnsureStack(ndIsType.Source, typeof(XPathItem), !xmlType.IsSingleton);
			helper.LoadInteger(helper.StaticData.DeclareXmlType(targetType));
			helper.Call(xmlType.IsSingleton ? XmlILMethods.ItemMatchesType : XmlILMethods.SeqMatchesType);
			ZeroCompare(QilNodeType.Ne, isBoolVal: true);
			return ndIsType;
		}

		private bool MatchesNodeKinds(QilTargetType ndIsType, XmlQueryType typDerived, XmlQueryType typBase)
		{
			bool flag = true;
			if (!typBase.IsNode || !typBase.IsSingleton)
			{
				return false;
			}
			if (!typDerived.IsNode || !typDerived.IsSingleton || !typDerived.IsNotRtf)
			{
				return false;
			}
			XmlNodeKindFlags xmlNodeKindFlags = XmlNodeKindFlags.None;
			foreach (XmlQueryType item in typBase)
			{
				if ((object)item == XmlQueryTypeFactory.Element)
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Element;
					continue;
				}
				if ((object)item == XmlQueryTypeFactory.Attribute)
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Attribute;
					continue;
				}
				if ((object)item == XmlQueryTypeFactory.Text)
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Text;
					continue;
				}
				if ((object)item == XmlQueryTypeFactory.Document)
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Document;
					continue;
				}
				if ((object)item == XmlQueryTypeFactory.Comment)
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Comment;
					continue;
				}
				if ((object)item == XmlQueryTypeFactory.PI)
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.PI;
					continue;
				}
				if ((object)item == XmlQueryTypeFactory.Namespace)
				{
					xmlNodeKindFlags |= XmlNodeKindFlags.Namespace;
					continue;
				}
				return false;
			}
			xmlNodeKindFlags = typDerived.NodeKinds & xmlNodeKindFlags;
			if (!Bits.ExactlyOne((uint)xmlNodeKindFlags))
			{
				xmlNodeKindFlags = ~xmlNodeKindFlags & XmlNodeKindFlags.Any;
				flag = !flag;
			}
			XPathNodeType xPathNodeType;
			switch (xmlNodeKindFlags)
			{
			case XmlNodeKindFlags.Element:
				xPathNodeType = XPathNodeType.Element;
				break;
			case XmlNodeKindFlags.Attribute:
				xPathNodeType = XPathNodeType.Attribute;
				break;
			case XmlNodeKindFlags.Namespace:
				xPathNodeType = XPathNodeType.Namespace;
				break;
			case XmlNodeKindFlags.PI:
				xPathNodeType = XPathNodeType.ProcessingInstruction;
				break;
			case XmlNodeKindFlags.Comment:
				xPathNodeType = XPathNodeType.Comment;
				break;
			case XmlNodeKindFlags.Document:
				xPathNodeType = XPathNodeType.Root;
				break;
			default:
				helper.Emit(OpCodes.Ldc_I4_1);
				xPathNodeType = XPathNodeType.All;
				break;
			}
			NestedVisitEnsureStack(ndIsType.Source);
			helper.Call(XmlILMethods.NavType);
			if (xPathNodeType == XPathNodeType.All)
			{
				helper.Emit(OpCodes.Shl);
				int num = 0;
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Document) != 0)
				{
					num |= 1;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Element) != 0)
				{
					num |= 2;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Attribute) != 0)
				{
					num |= 4;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Text) != 0)
				{
					num |= 0x70;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Comment) != 0)
				{
					num |= 0x100;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.PI) != 0)
				{
					num |= 0x80;
				}
				if ((xmlNodeKindFlags & XmlNodeKindFlags.Namespace) != 0)
				{
					num |= 8;
				}
				helper.LoadInteger(num);
				helper.Emit(OpCodes.And);
				ZeroCompare(flag ? QilNodeType.Ne : QilNodeType.Eq, isBoolVal: false);
			}
			else
			{
				helper.LoadInteger((int)xPathNodeType);
				ClrCompare(flag ? QilNodeType.Eq : QilNodeType.Ne, XmlTypeCode.Int);
			}
			return true;
		}

		protected override QilNode VisitIsEmpty(QilUnary ndIsEmpty)
		{
			if (CachesResult(ndIsEmpty.Child))
			{
				NestedVisitEnsureStack(ndIsEmpty.Child);
				helper.CallCacheCount(iterNested.Storage.ItemStorageType);
				switch (iterCurr.CurrentBranchingContext)
				{
				case BranchingContext.OnFalse:
					helper.TestAndBranch(0, iterCurr.LabelBranch, OpCodes.Bne_Un);
					break;
				case BranchingContext.OnTrue:
					helper.TestAndBranch(0, iterCurr.LabelBranch, OpCodes.Beq);
					break;
				default:
				{
					Label label = helper.DefineLabel();
					helper.Emit(OpCodes.Brfalse_S, label);
					helper.ConvBranchToBool(label, isTrueBranch: true);
					break;
				}
				}
			}
			else
			{
				Label label2 = helper.DefineLabel();
				IteratorDescriptor iteratorDescriptor = iterCurr;
				if (iteratorDescriptor.CurrentBranchingContext == BranchingContext.OnTrue)
				{
					StartNestedIterator(ndIsEmpty.Child, iterCurr.LabelBranch);
				}
				else
				{
					StartNestedIterator(ndIsEmpty.Child, label2);
				}
				Visit(ndIsEmpty.Child);
				iterCurr.EnsureNoCache();
				iterCurr.DiscardStack();
				switch (iteratorDescriptor.CurrentBranchingContext)
				{
				case BranchingContext.OnFalse:
					helper.EmitUnconditionalBranch(OpCodes.Br, iteratorDescriptor.LabelBranch);
					helper.MarkLabel(label2);
					break;
				case BranchingContext.None:
					helper.ConvBranchToBool(label2, isTrueBranch: true);
					break;
				}
				EndNestedIterator(ndIsEmpty.Child);
			}
			if (iterCurr.IsBranching)
			{
				iterCurr.Storage = StorageDescriptor.None();
			}
			else
			{
				iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
			}
			return ndIsEmpty;
		}

		protected override QilNode VisitXPathNodeValue(QilUnary ndVal)
		{
			if (ndVal.Child.XmlType.IsSingleton)
			{
				NestedVisitEnsureStack(ndVal.Child, typeof(XPathNavigator), isCached: false);
				helper.Call(XmlILMethods.Value);
			}
			else
			{
				Label label = helper.DefineLabel();
				StartNestedIterator(ndVal.Child, label);
				Visit(ndVal.Child);
				iterCurr.EnsureStackNoCache();
				helper.Call(XmlILMethods.Value);
				Label label2 = helper.DefineLabel();
				helper.EmitUnconditionalBranch(OpCodes.Br, label2);
				helper.MarkLabel(label);
				helper.Emit(OpCodes.Ldstr, "");
				helper.MarkLabel(label2);
				EndNestedIterator(ndVal.Child);
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
			return ndVal;
		}

		protected override QilNode VisitXPathFollowing(QilUnary ndFoll)
		{
			CreateFilteredIterator(ndFoll.Child, "$$$iterFoll", typeof(XPathFollowingIterator), XmlILMethods.XPFollCreate, XmlILMethods.XPFollNext, XmlNodeKindFlags.Any, null, TriState.Unknown, null);
			return ndFoll;
		}

		protected override QilNode VisitXPathPreceding(QilUnary ndPrec)
		{
			CreateFilteredIterator(ndPrec.Child, "$$$iterPrec", typeof(XPathPrecedingIterator), XmlILMethods.XPPrecCreate, XmlILMethods.XPPrecNext, XmlNodeKindFlags.Any, null, TriState.Unknown, null);
			return ndPrec;
		}

		protected override QilNode VisitXPathNamespace(QilUnary ndNmsp)
		{
			CreateSimpleIterator(ndNmsp.Child, "$$$iterNmsp", typeof(NamespaceIterator), XmlILMethods.NmspCreate, XmlILMethods.NmspNext);
			return ndNmsp;
		}

		protected override QilNode VisitXsltGenerateId(QilUnary ndGenId)
		{
			helper.LoadQueryRuntime();
			if (ndGenId.Child.XmlType.IsSingleton)
			{
				NestedVisitEnsureStack(ndGenId.Child, typeof(XPathNavigator), isCached: false);
				helper.Call(XmlILMethods.GenId);
			}
			else
			{
				Label label = helper.DefineLabel();
				StartNestedIterator(ndGenId.Child, label);
				Visit(ndGenId.Child);
				iterCurr.EnsureStackNoCache();
				iterCurr.EnsureItemStorageType(ndGenId.Child.XmlType, typeof(XPathNavigator));
				helper.Call(XmlILMethods.GenId);
				Label label2 = helper.DefineLabel();
				helper.EmitUnconditionalBranch(OpCodes.Br, label2);
				helper.MarkLabel(label);
				helper.Emit(OpCodes.Pop);
				helper.Emit(OpCodes.Ldstr, "");
				helper.MarkLabel(label2);
				EndNestedIterator(ndGenId.Child);
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(string), isCached: false);
			return ndGenId;
		}

		protected override QilNode VisitXsltInvokeLateBound(QilInvokeLateBound ndInvoke)
		{
			LocalBuilder locBldr = helper.DeclareLocal("$$$args", typeof(IList<XPathItem>[]));
			QilName name = ndInvoke.Name;
			helper.LoadQueryContext();
			helper.Emit(OpCodes.Ldstr, name.LocalName);
			helper.Emit(OpCodes.Ldstr, name.NamespaceUri);
			helper.LoadInteger(ndInvoke.Arguments.Count);
			helper.Emit(OpCodes.Newarr, typeof(IList<XPathItem>));
			helper.Emit(OpCodes.Stloc, locBldr);
			for (int i = 0; i < ndInvoke.Arguments.Count; i++)
			{
				QilNode nd = ndInvoke.Arguments[i];
				helper.Emit(OpCodes.Ldloc, locBldr);
				helper.LoadInteger(i);
				helper.Emit(OpCodes.Ldelema, typeof(IList<XPathItem>));
				NestedVisitEnsureCache(nd, typeof(XPathItem));
				iterCurr.EnsureStack();
				helper.Emit(OpCodes.Stobj, typeof(IList<XPathItem>));
			}
			helper.Emit(OpCodes.Ldloc, locBldr);
			helper.Call(XmlILMethods.InvokeXsltLate);
			iterCurr.Storage = StorageDescriptor.Stack(typeof(XPathItem), isCached: true);
			return ndInvoke;
		}

		protected override QilNode VisitXsltInvokeEarlyBound(QilInvokeEarlyBound ndInvoke)
		{
			QilName name = ndInvoke.Name;
			XmlExtensionFunction xmlExtensionFunction = new XmlExtensionFunction(name.LocalName, name.NamespaceUri, ndInvoke.ClrMethod);
			Type clrReturnType = xmlExtensionFunction.ClrReturnType;
			Type storageType = GetStorageType(ndInvoke);
			if (clrReturnType != storageType && !ndInvoke.XmlType.IsEmpty)
			{
				helper.LoadQueryRuntime();
				helper.LoadInteger(helper.StaticData.DeclareXmlType(ndInvoke.XmlType));
			}
			if (!xmlExtensionFunction.Method.IsStatic)
			{
				if (name.NamespaceUri.Length == 0)
				{
					helper.LoadXsltLibrary();
				}
				else
				{
					helper.CallGetEarlyBoundObject(helper.StaticData.DeclareEarlyBound(name.NamespaceUri, xmlExtensionFunction.Method.DeclaringType), xmlExtensionFunction.Method.DeclaringType);
				}
			}
			for (int i = 0; i < ndInvoke.Arguments.Count; i++)
			{
				QilNode qilNode = ndInvoke.Arguments[i];
				XmlQueryType xmlArgumentType = xmlExtensionFunction.GetXmlArgumentType(i);
				Type clrArgumentType = xmlExtensionFunction.GetClrArgumentType(i);
				if (name.NamespaceUri.Length == 0)
				{
					Type itemStorageType = GetItemStorageType(qilNode);
					if (clrArgumentType == XmlILMethods.StorageMethods[itemStorageType].IListType)
					{
						NestedVisitEnsureStack(qilNode, itemStorageType, isCached: true);
					}
					else if (clrArgumentType == XmlILMethods.StorageMethods[typeof(XPathItem)].IListType)
					{
						NestedVisitEnsureStack(qilNode, typeof(XPathItem), isCached: true);
					}
					else if ((qilNode.XmlType.IsSingleton && clrArgumentType == itemStorageType) || qilNode.XmlType.TypeCode == XmlTypeCode.None)
					{
						NestedVisitEnsureStack(qilNode, clrArgumentType, isCached: false);
					}
					else if (qilNode.XmlType.IsSingleton && clrArgumentType == typeof(XPathItem))
					{
						NestedVisitEnsureStack(qilNode, typeof(XPathItem), isCached: false);
					}
				}
				else
				{
					Type storageType2 = GetStorageType(xmlArgumentType);
					if (xmlArgumentType.TypeCode == XmlTypeCode.Item || !clrArgumentType.IsAssignableFrom(storageType2))
					{
						helper.LoadQueryRuntime();
						helper.LoadInteger(helper.StaticData.DeclareXmlType(xmlArgumentType));
						NestedVisitEnsureStack(qilNode, GetItemStorageType(xmlArgumentType), !xmlArgumentType.IsSingleton);
						helper.TreatAs(storageType2, typeof(object));
						helper.LoadType(clrArgumentType);
						helper.Call(XmlILMethods.ChangeTypeXsltArg);
						helper.TreatAs(typeof(object), clrArgumentType);
					}
					else
					{
						NestedVisitEnsureStack(qilNode, GetItemStorageType(xmlArgumentType), !xmlArgumentType.IsSingleton);
					}
				}
			}
			helper.Call(xmlExtensionFunction.Method);
			if (ndInvoke.XmlType.IsEmpty)
			{
				helper.Emit(OpCodes.Ldsfld, XmlILMethods.StorageMethods[typeof(XPathItem)].SeqEmpty);
			}
			else if (clrReturnType != storageType)
			{
				helper.TreatAs(clrReturnType, typeof(object));
				helper.Call(XmlILMethods.ChangeTypeXsltResult);
				helper.TreatAs(typeof(object), storageType);
			}
			else if (name.NamespaceUri.Length != 0 && !clrReturnType.IsValueType)
			{
				Label label = helper.DefineLabel();
				helper.Emit(OpCodes.Dup);
				helper.Emit(OpCodes.Brtrue, label);
				helper.LoadQueryRuntime();
				helper.Emit(OpCodes.Ldstr, System.Xml.Utils.Res.GetString("Xslt_ItemNull"));
				helper.Call(XmlILMethods.ThrowException);
				helper.MarkLabel(label);
			}
			iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(ndInvoke), !ndInvoke.XmlType.IsSingleton);
			return ndInvoke;
		}

		protected override QilNode VisitXsltCopy(QilBinary ndCopy)
		{
			Label label = helper.DefineLabel();
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndCopy.Left);
			helper.Call(XmlILMethods.StartCopy);
			helper.Emit(OpCodes.Brfalse, label);
			NestedVisit(ndCopy.Right);
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndCopy.Left);
			helper.Call(XmlILMethods.EndCopy);
			helper.MarkLabel(label);
			iterCurr.Storage = StorageDescriptor.None();
			return ndCopy;
		}

		protected override QilNode VisitXsltCopyOf(QilUnary ndCopyOf)
		{
			helper.LoadQueryOutput();
			NestedVisitEnsureStack(ndCopyOf.Child);
			helper.Call(XmlILMethods.CopyOf);
			iterCurr.Storage = StorageDescriptor.None();
			return ndCopyOf;
		}

		protected override QilNode VisitXsltConvert(QilTargetType ndConv)
		{
			XmlQueryType xmlType = ndConv.Source.XmlType;
			XmlQueryType targetType = ndConv.TargetType;
			if (GetXsltConvertMethod(xmlType, targetType, out var meth))
			{
				NestedVisitEnsureStack(ndConv.Source);
			}
			else
			{
				NestedVisitEnsureStack(ndConv.Source, typeof(XPathItem), !xmlType.IsSingleton);
				GetXsltConvertMethod(xmlType.IsSingleton ? XmlQueryTypeFactory.Item : XmlQueryTypeFactory.ItemS, targetType, out meth);
			}
			if (meth != null)
			{
				helper.Call(meth);
			}
			iterCurr.Storage = StorageDescriptor.Stack(GetItemStorageType(targetType), !targetType.IsSingleton);
			return ndConv;
		}

		private bool GetXsltConvertMethod(XmlQueryType typSrc, XmlQueryType typDst, out MethodInfo meth)
		{
			meth = null;
			if ((object)typDst == XmlQueryTypeFactory.BooleanX)
			{
				if ((object)typSrc == XmlQueryTypeFactory.Item)
				{
					meth = XmlILMethods.ItemToBool;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.ItemS)
				{
					meth = XmlILMethods.ItemsToBool;
				}
			}
			else if ((object)typDst == XmlQueryTypeFactory.DateTimeX)
			{
				if ((object)typSrc == XmlQueryTypeFactory.StringX)
				{
					meth = XmlILMethods.StrToDT;
				}
			}
			else if ((object)typDst == XmlQueryTypeFactory.DecimalX)
			{
				if ((object)typSrc == XmlQueryTypeFactory.DoubleX)
				{
					meth = XmlILMethods.DblToDec;
				}
			}
			else if ((object)typDst == XmlQueryTypeFactory.DoubleX)
			{
				if ((object)typSrc == XmlQueryTypeFactory.DecimalX)
				{
					meth = XmlILMethods.DecToDbl;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.IntX)
				{
					meth = XmlILMethods.IntToDbl;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.Item)
				{
					meth = XmlILMethods.ItemToDbl;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.ItemS)
				{
					meth = XmlILMethods.ItemsToDbl;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.LongX)
				{
					meth = XmlILMethods.LngToDbl;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.StringX)
				{
					meth = XmlILMethods.StrToDbl;
				}
			}
			else if ((object)typDst == XmlQueryTypeFactory.IntX)
			{
				if ((object)typSrc == XmlQueryTypeFactory.DoubleX)
				{
					meth = XmlILMethods.DblToInt;
				}
			}
			else if ((object)typDst == XmlQueryTypeFactory.LongX)
			{
				if ((object)typSrc == XmlQueryTypeFactory.DoubleX)
				{
					meth = XmlILMethods.DblToLng;
				}
			}
			else if ((object)typDst == XmlQueryTypeFactory.NodeNotRtf)
			{
				if ((object)typSrc == XmlQueryTypeFactory.Item)
				{
					meth = XmlILMethods.ItemToNode;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.ItemS)
				{
					meth = XmlILMethods.ItemsToNode;
				}
			}
			else if ((object)typDst == XmlQueryTypeFactory.NodeSDod || (object)typDst == XmlQueryTypeFactory.NodeNotRtfS)
			{
				if ((object)typSrc == XmlQueryTypeFactory.Item)
				{
					meth = XmlILMethods.ItemToNodes;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.ItemS)
				{
					meth = XmlILMethods.ItemsToNodes;
				}
			}
			else if ((object)typDst == XmlQueryTypeFactory.StringX)
			{
				if ((object)typSrc == XmlQueryTypeFactory.DateTimeX)
				{
					meth = XmlILMethods.DTToStr;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.DoubleX)
				{
					meth = XmlILMethods.DblToStr;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.Item)
				{
					meth = XmlILMethods.ItemToStr;
				}
				else if ((object)typSrc == XmlQueryTypeFactory.ItemS)
				{
					meth = XmlILMethods.ItemsToStr;
				}
			}
			return meth != null;
		}

		private void SyncToNavigator(LocalBuilder locNav, QilNode ndCtxt)
		{
			helper.Emit(OpCodes.Ldloc, locNav);
			NestedVisitEnsureStack(ndCtxt);
			helper.CallSyncToNavigator();
			helper.Emit(OpCodes.Stloc, locNav);
		}

		private void CreateSimpleIterator(QilNode ndCtxt, string iterName, Type iterType, MethodInfo methCreate, MethodInfo methNext)
		{
			LocalBuilder localBuilder = helper.DeclareLocal(iterName, iterType);
			helper.Emit(OpCodes.Ldloca, localBuilder);
			NestedVisitEnsureStack(ndCtxt);
			helper.Call(methCreate);
			GenerateSimpleIterator(typeof(XPathNavigator), localBuilder, methNext);
		}

		private void CreateFilteredIterator(QilNode ndCtxt, string iterName, Type iterType, MethodInfo methCreate, MethodInfo methNext, XmlNodeKindFlags kinds, QilName ndName, TriState orSelf, QilNode ndEnd)
		{
			LocalBuilder localBuilder = helper.DeclareLocal(iterName, iterType);
			helper.Emit(OpCodes.Ldloca, localBuilder);
			NestedVisitEnsureStack(ndCtxt);
			LoadSelectFilter(kinds, ndName);
			if (orSelf != TriState.Unknown)
			{
				helper.LoadBoolean(orSelf == TriState.True);
			}
			if (ndEnd != null)
			{
				NestedVisitEnsureStack(ndEnd);
			}
			helper.Call(methCreate);
			GenerateSimpleIterator(typeof(XPathNavigator), localBuilder, methNext);
		}

		private void CreateContainerIterator(QilUnary ndDod, string iterName, Type iterType, MethodInfo methCreate, MethodInfo methNext, XmlNodeKindFlags kinds, QilName ndName, TriState orSelf)
		{
			LocalBuilder localBuilder = helper.DeclareLocal(iterName, iterType);
			QilLoop qilLoop = (QilLoop)ndDod.Child;
			helper.Emit(OpCodes.Ldloca, localBuilder);
			LoadSelectFilter(kinds, ndName);
			if (orSelf != TriState.Unknown)
			{
				helper.LoadBoolean(orSelf == TriState.True);
			}
			helper.Call(methCreate);
			Label label = helper.DefineLabel();
			StartNestedIterator(qilLoop, label);
			StartBinding(qilLoop.Variable);
			EndBinding(qilLoop.Variable);
			EndNestedIterator(qilLoop.Variable);
			iterCurr.Storage = iterNested.Storage;
			GenerateContainerIterator(ndDod, localBuilder, label, methNext, typeof(XPathNavigator));
		}

		private void GenerateSimpleIterator(Type itemStorageType, LocalBuilder locIter, MethodInfo methNext)
		{
			Label label = helper.DefineLabel();
			helper.MarkLabel(label);
			helper.Emit(OpCodes.Ldloca, locIter);
			helper.Call(methNext);
			helper.Emit(OpCodes.Brfalse, iterCurr.GetLabelNext());
			iterCurr.SetIterator(label, StorageDescriptor.Current(locIter, itemStorageType));
		}

		private void GenerateContainerIterator(QilNode nd, LocalBuilder locIter, Label lblOnEndNested, MethodInfo methNext, Type itemStorageType)
		{
			Label label = helper.DefineLabel();
			iterCurr.EnsureNoStackNoCache(nd.XmlType.IsNode ? "$$$navInput" : "$$$itemInput");
			helper.Emit(OpCodes.Ldloca, locIter);
			iterCurr.PushValue();
			helper.EmitUnconditionalBranch(OpCodes.Br, label);
			helper.MarkLabel(lblOnEndNested);
			helper.Emit(OpCodes.Ldloca, locIter);
			helper.Emit(OpCodes.Ldnull);
			helper.MarkLabel(label);
			helper.Call(methNext);
			if (nd.XmlType.IsSingleton)
			{
				helper.LoadInteger(1);
				helper.Emit(OpCodes.Beq, iterNested.GetLabelNext());
				iterCurr.Storage = StorageDescriptor.Current(locIter, itemStorageType);
			}
			else
			{
				helper.Emit(OpCodes.Switch, new Label[2]
				{
					iterCurr.GetLabelNext(),
					iterNested.GetLabelNext()
				});
				iterCurr.SetIterator(lblOnEndNested, StorageDescriptor.Current(locIter, itemStorageType));
			}
		}

		private GenerateNameType LoadNameAndType(XPathNodeType nodeType, QilNode ndName, bool isStart, bool callChk)
		{
			helper.LoadQueryOutput();
			GenerateNameType result = GenerateNameType.StackName;
			if (ndName.NodeType == QilNodeType.LiteralQName)
			{
				if (isStart || !callChk)
				{
					QilName qilName = ndName as QilName;
					string prefix = qilName.Prefix;
					string localName = qilName.LocalName;
					string namespaceUri = qilName.NamespaceUri;
					if (qilName.NamespaceUri.Length == 0)
					{
						helper.Emit(OpCodes.Ldstr, qilName.LocalName);
						return GenerateNameType.LiteralLocalName;
					}
					if (!ValidateNames.ValidateName(prefix, localName, namespaceUri, nodeType, ValidateNames.Flags.CheckPrefixMapping))
					{
						if (isStart)
						{
							helper.Emit(OpCodes.Ldstr, localName);
							helper.Emit(OpCodes.Ldstr, namespaceUri);
							helper.Construct(XmlILConstructors.QName);
							result = GenerateNameType.QName;
						}
					}
					else
					{
						helper.Emit(OpCodes.Ldstr, prefix);
						helper.Emit(OpCodes.Ldstr, localName);
						helper.Emit(OpCodes.Ldstr, namespaceUri);
						result = GenerateNameType.LiteralName;
					}
				}
			}
			else if (isStart)
			{
				if (ndName.NodeType == QilNodeType.NameOf)
				{
					NestedVisitEnsureStack((ndName as QilUnary).Child);
					result = GenerateNameType.CopiedName;
				}
				else if (ndName.NodeType == QilNodeType.StrParseQName)
				{
					VisitStrParseQName(ndName as QilBinary, preservePrefix: true);
					result = (((ndName as QilBinary).Right.XmlType.TypeCode != XmlTypeCode.String) ? GenerateNameType.TagNameAndMappings : GenerateNameType.TagNameAndNamespace);
				}
				else
				{
					NestedVisitEnsureStack(ndName);
					result = GenerateNameType.QName;
				}
			}
			return result;
		}

		private bool TryZeroCompare(QilNodeType relOp, QilNode ndFirst, QilNode ndSecond)
		{
			switch (ndFirst.NodeType)
			{
			case QilNodeType.LiteralInt64:
				if ((int)(QilLiteral)ndFirst != 0)
				{
					return false;
				}
				break;
			case QilNodeType.LiteralInt32:
				if ((int)(QilLiteral)ndFirst != 0)
				{
					return false;
				}
				break;
			case QilNodeType.True:
				relOp = ((relOp == QilNodeType.Eq) ? QilNodeType.Ne : QilNodeType.Eq);
				break;
			default:
				return false;
			case QilNodeType.False:
				break;
			}
			NestedVisitEnsureStack(ndSecond);
			ZeroCompare(relOp, ndSecond.XmlType.TypeCode == XmlTypeCode.Boolean);
			return true;
		}

		private bool TryNameCompare(QilNodeType relOp, QilNode ndFirst, QilNode ndSecond)
		{
			if (ndFirst.NodeType == QilNodeType.NameOf)
			{
				QilNodeType nodeType = ndSecond.NodeType;
				if (nodeType == QilNodeType.LiteralQName || nodeType == QilNodeType.NameOf)
				{
					helper.LoadQueryRuntime();
					NestedVisitEnsureStack((ndFirst as QilUnary).Child);
					if (ndSecond.NodeType == QilNodeType.LiteralQName)
					{
						QilName qilName = ndSecond as QilName;
						helper.LoadInteger(helper.StaticData.DeclareName(qilName.LocalName));
						helper.LoadInteger(helper.StaticData.DeclareName(qilName.NamespaceUri));
						helper.Call(XmlILMethods.QNameEqualLit);
					}
					else
					{
						NestedVisitEnsureStack(ndSecond);
						helper.Call(XmlILMethods.QNameEqualNav);
					}
					ZeroCompare((relOp == QilNodeType.Eq) ? QilNodeType.Ne : QilNodeType.Eq, isBoolVal: true);
					return true;
				}
			}
			return false;
		}

		private void ClrCompare(QilNodeType relOp, XmlTypeCode code)
		{
			OpCode opcode;
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnFalse:
				opcode = ((code == XmlTypeCode.Double || code == XmlTypeCode.Float) ? (relOp switch
				{
					QilNodeType.Gt => OpCodes.Ble_Un, 
					QilNodeType.Ge => OpCodes.Blt_Un, 
					QilNodeType.Lt => OpCodes.Bge_Un, 
					QilNodeType.Le => OpCodes.Bgt_Un, 
					QilNodeType.Eq => OpCodes.Bne_Un, 
					QilNodeType.Ne => OpCodes.Beq, 
					_ => OpCodes.Nop, 
				}) : (relOp switch
				{
					QilNodeType.Gt => OpCodes.Ble, 
					QilNodeType.Ge => OpCodes.Blt, 
					QilNodeType.Lt => OpCodes.Bge, 
					QilNodeType.Le => OpCodes.Bgt, 
					QilNodeType.Eq => OpCodes.Bne_Un, 
					QilNodeType.Ne => OpCodes.Beq, 
					_ => OpCodes.Nop, 
				}));
				helper.Emit(opcode, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
				return;
			case BranchingContext.OnTrue:
				opcode = relOp switch
				{
					QilNodeType.Gt => OpCodes.Bgt, 
					QilNodeType.Ge => OpCodes.Bge, 
					QilNodeType.Lt => OpCodes.Blt, 
					QilNodeType.Le => OpCodes.Ble, 
					QilNodeType.Eq => OpCodes.Beq, 
					QilNodeType.Ne => OpCodes.Bne_Un, 
					_ => OpCodes.Nop, 
				};
				helper.Emit(opcode, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
				return;
			}
			Label label;
			switch (relOp)
			{
			case QilNodeType.Gt:
				helper.Emit(OpCodes.Cgt);
				break;
			case QilNodeType.Lt:
				helper.Emit(OpCodes.Clt);
				break;
			case QilNodeType.Eq:
				helper.Emit(OpCodes.Ceq);
				break;
			case QilNodeType.Ge:
				opcode = OpCodes.Bge_S;
				goto IL_0207;
			case QilNodeType.Le:
				opcode = OpCodes.Ble_S;
				goto IL_0207;
			case QilNodeType.Ne:
				opcode = OpCodes.Bne_Un_S;
				goto IL_0207;
			default:
				{
					opcode = OpCodes.Nop;
					goto IL_0207;
				}
				IL_0207:
				label = helper.DefineLabel();
				helper.Emit(opcode, label);
				helper.ConvBranchToBool(label, isTrueBranch: true);
				break;
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
		}

		private void ZeroCompare(QilNodeType relOp, bool isBoolVal)
		{
			switch (iterCurr.CurrentBranchingContext)
			{
			case BranchingContext.OnTrue:
				helper.Emit((relOp == QilNodeType.Eq) ? OpCodes.Brfalse : OpCodes.Brtrue, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
				return;
			case BranchingContext.OnFalse:
				helper.Emit((relOp == QilNodeType.Eq) ? OpCodes.Brtrue : OpCodes.Brfalse, iterCurr.LabelBranch);
				iterCurr.Storage = StorageDescriptor.None();
				return;
			}
			if (!isBoolVal || relOp == QilNodeType.Eq)
			{
				Label label = helper.DefineLabel();
				helper.Emit((relOp == QilNodeType.Eq) ? OpCodes.Brfalse : OpCodes.Brtrue, label);
				helper.ConvBranchToBool(label, isTrueBranch: true);
			}
			iterCurr.Storage = StorageDescriptor.Stack(typeof(bool), isCached: false);
		}

		private void StartWriterLoop(QilNode nd, out bool hasOnEnd, out Label lblOnEnd)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(nd);
			hasOnEnd = false;
			lblOnEnd = default(Label);
			if (xmlILConstructInfo.PushToWriterLast && !nd.XmlType.IsSingleton && !iterCurr.HasLabelNext)
			{
				hasOnEnd = true;
				lblOnEnd = helper.DefineLabel();
				iterCurr.SetIterator(lblOnEnd, StorageDescriptor.None());
			}
		}

		private void EndWriterLoop(QilNode nd, bool hasOnEnd, Label lblOnEnd)
		{
			XmlILConstructInfo xmlILConstructInfo = XmlILConstructInfo.Read(nd);
			if (xmlILConstructInfo.PushToWriterLast)
			{
				iterCurr.Storage = StorageDescriptor.None();
				if (!nd.XmlType.IsSingleton && hasOnEnd)
				{
					iterCurr.LoopToEnd(lblOnEnd);
				}
			}
		}

		private bool MightHaveNamespacesAfterAttributes(XmlILConstructInfo info)
		{
			if (info != null)
			{
				info = info.ParentElementInfo;
			}
			return info?.MightHaveNamespacesAfterAttributes ?? true;
		}

		private bool ElementCachesAttributes(XmlILConstructInfo info)
		{
			if (!info.MightHaveDuplicateAttributes)
			{
				return info.MightHaveNamespacesAfterAttributes;
			}
			return true;
		}

		private void BeforeStartChecks(QilNode ndCtor)
		{
			switch (XmlILConstructInfo.Read(ndCtor).InitialStates)
			{
			case PossibleXmlStates.WithinSequence:
				helper.CallStartTree(QilConstructorToNodeType(ndCtor.NodeType));
				break;
			case PossibleXmlStates.EnumAttrs:
			{
				QilNodeType nodeType = ndCtor.NodeType;
				if (nodeType == QilNodeType.ElementCtor || (uint)(nodeType - 83) <= 3u)
				{
					helper.CallStartElementContent();
				}
				break;
			}
			}
		}

		private void AfterEndChecks(QilNode ndCtor)
		{
			if (XmlILConstructInfo.Read(ndCtor).FinalStates == PossibleXmlStates.WithinSequence)
			{
				helper.CallEndTree();
			}
		}

		private bool CheckWithinContent(XmlILConstructInfo info)
		{
			PossibleXmlStates initialStates = info.InitialStates;
			if ((uint)(initialStates - 1) <= 2u)
			{
				return false;
			}
			return true;
		}

		private bool CheckEnumAttrs(XmlILConstructInfo info)
		{
			PossibleXmlStates initialStates = info.InitialStates;
			if ((uint)(initialStates - 1) <= 1u)
			{
				return false;
			}
			return true;
		}

		private XPathNodeType QilXmlToXPathNodeType(XmlNodeKindFlags xmlTypes)
		{
			return xmlTypes switch
			{
				XmlNodeKindFlags.Element => XPathNodeType.Element, 
				XmlNodeKindFlags.Attribute => XPathNodeType.Attribute, 
				XmlNodeKindFlags.Text => XPathNodeType.Text, 
				XmlNodeKindFlags.Comment => XPathNodeType.Comment, 
				_ => XPathNodeType.ProcessingInstruction, 
			};
		}

		private XPathNodeType QilConstructorToNodeType(QilNodeType typ)
		{
			return typ switch
			{
				QilNodeType.DocumentCtor => XPathNodeType.Root, 
				QilNodeType.ElementCtor => XPathNodeType.Element, 
				QilNodeType.TextCtor => XPathNodeType.Text, 
				QilNodeType.RawTextCtor => XPathNodeType.Text, 
				QilNodeType.PICtor => XPathNodeType.ProcessingInstruction, 
				QilNodeType.CommentCtor => XPathNodeType.Comment, 
				QilNodeType.AttributeCtor => XPathNodeType.Attribute, 
				QilNodeType.NamespaceDecl => XPathNodeType.Namespace, 
				_ => XPathNodeType.All, 
			};
		}

		private void LoadSelectFilter(XmlNodeKindFlags xmlTypes, QilName ndName)
		{
			if (ndName != null)
			{
				helper.CallGetNameFilter(helper.StaticData.DeclareNameFilter(ndName.LocalName, ndName.NamespaceUri));
			}
			else if (IsNodeTypeUnion(xmlTypes))
			{
				if ((xmlTypes & XmlNodeKindFlags.Attribute) != 0)
				{
					helper.CallGetTypeFilter(XPathNodeType.All);
				}
				else
				{
					helper.CallGetTypeFilter(XPathNodeType.Attribute);
				}
			}
			else
			{
				helper.CallGetTypeFilter(QilXmlToXPathNodeType(xmlTypes));
			}
		}

		private static bool IsNodeTypeUnion(XmlNodeKindFlags xmlTypes)
		{
			return (xmlTypes & (xmlTypes - 1)) != 0;
		}

		private void StartNestedIterator(QilNode nd)
		{
			IteratorDescriptor iteratorDescriptor = iterCurr;
			if (iteratorDescriptor == null)
			{
				iterCurr = new IteratorDescriptor(helper);
			}
			else
			{
				iterCurr = new IteratorDescriptor(iteratorDescriptor);
			}
			iterNested = null;
		}

		private void StartNestedIterator(QilNode nd, Label lblOnEnd)
		{
			StartNestedIterator(nd);
			iterCurr.SetIterator(lblOnEnd, StorageDescriptor.None());
		}

		private void EndNestedIterator(QilNode nd)
		{
			if (iterCurr.IsBranching && iterCurr.Storage.Location != 0)
			{
				iterCurr.EnsureItemStorageType(nd.XmlType, typeof(bool));
				iterCurr.EnsureStackNoCache();
				if (iterCurr.CurrentBranchingContext == BranchingContext.OnTrue)
				{
					helper.Emit(OpCodes.Brtrue, iterCurr.LabelBranch);
				}
				else
				{
					helper.Emit(OpCodes.Brfalse, iterCurr.LabelBranch);
				}
				iterCurr.Storage = StorageDescriptor.None();
			}
			iterNested = iterCurr;
			iterCurr = iterCurr.ParentIterator;
		}

		private void NestedVisit(QilNode nd, Type itemStorageType, bool isCached)
		{
			if (XmlILConstructInfo.Read(nd).PushToWriterLast)
			{
				StartNestedIterator(nd);
				Visit(nd);
				EndNestedIterator(nd);
				iterCurr.Storage = StorageDescriptor.None();
			}
			else if (!isCached && nd.XmlType.IsSingleton)
			{
				StartNestedIterator(nd);
				Visit(nd);
				iterCurr.EnsureNoCache();
				iterCurr.EnsureItemStorageType(nd.XmlType, itemStorageType);
				EndNestedIterator(nd);
				iterCurr.Storage = iterNested.Storage;
			}
			else
			{
				NestedVisitEnsureCache(nd, itemStorageType);
			}
		}

		private void NestedVisit(QilNode nd)
		{
			NestedVisit(nd, GetItemStorageType(nd), !nd.XmlType.IsSingleton);
		}

		private void NestedVisit(QilNode nd, Label lblOnEnd)
		{
			StartNestedIterator(nd, lblOnEnd);
			Visit(nd);
			iterCurr.EnsureNoCache();
			iterCurr.EnsureItemStorageType(nd.XmlType, GetItemStorageType(nd));
			EndNestedIterator(nd);
			iterCurr.Storage = iterNested.Storage;
		}

		private void NestedVisitEnsureStack(QilNode nd)
		{
			NestedVisit(nd);
			iterCurr.EnsureStack();
		}

		private void NestedVisitEnsureStack(QilNode ndLeft, QilNode ndRight)
		{
			NestedVisitEnsureStack(ndLeft);
			NestedVisitEnsureStack(ndRight);
		}

		private void NestedVisitEnsureStack(QilNode nd, Type itemStorageType, bool isCached)
		{
			NestedVisit(nd, itemStorageType, isCached);
			iterCurr.EnsureStack();
		}

		private void NestedVisitEnsureLocal(QilNode nd, LocalBuilder loc)
		{
			NestedVisit(nd);
			iterCurr.EnsureLocal(loc);
		}

		private void NestedVisitWithBranch(QilNode nd, BranchingContext brctxt, Label lblBranch)
		{
			StartNestedIterator(nd);
			iterCurr.SetBranching(brctxt, lblBranch);
			Visit(nd);
			EndNestedIterator(nd);
			iterCurr.Storage = StorageDescriptor.None();
		}

		private void NestedVisitEnsureCache(QilNode nd, Type itemStorageType)
		{
			bool flag = CachesResult(nd);
			Label lblOnEnd = helper.DefineLabel();
			if (flag)
			{
				StartNestedIterator(nd);
				Visit(nd);
				EndNestedIterator(nd);
				iterCurr.Storage = iterNested.Storage;
				if (iterCurr.Storage.ItemStorageType == itemStorageType)
				{
					return;
				}
				if (iterCurr.Storage.ItemStorageType == typeof(XPathNavigator) || itemStorageType == typeof(XPathNavigator))
				{
					iterCurr.EnsureItemStorageType(nd.XmlType, itemStorageType);
					return;
				}
				iterCurr.EnsureNoStack("$$$cacheResult");
			}
			Type type = ((GetItemStorageType(nd) == typeof(XPathNavigator)) ? typeof(XPathNavigator) : itemStorageType);
			XmlILStorageMethods xmlILStorageMethods = XmlILMethods.StorageMethods[type];
			LocalBuilder localBuilder = helper.DeclareLocal("$$$cache", xmlILStorageMethods.SeqType);
			helper.Emit(OpCodes.Ldloc, localBuilder);
			if (nd.XmlType.IsSingleton)
			{
				NestedVisitEnsureStack(nd, type, isCached: false);
				helper.CallToken(xmlILStorageMethods.SeqReuseSgl);
				helper.Emit(OpCodes.Stloc, localBuilder);
			}
			else
			{
				helper.CallToken(xmlILStorageMethods.SeqReuse);
				helper.Emit(OpCodes.Stloc, localBuilder);
				helper.Emit(OpCodes.Ldloc, localBuilder);
				StartNestedIterator(nd, lblOnEnd);
				if (flag)
				{
					iterCurr.Storage = iterCurr.ParentIterator.Storage;
				}
				else
				{
					Visit(nd);
				}
				iterCurr.EnsureItemStorageType(nd.XmlType, type);
				iterCurr.EnsureStackNoCache();
				helper.Call(xmlILStorageMethods.SeqAdd);
				helper.Emit(OpCodes.Ldloc, localBuilder);
				iterCurr.LoopToEnd(lblOnEnd);
				EndNestedIterator(nd);
				helper.Emit(OpCodes.Pop);
			}
			iterCurr.Storage = StorageDescriptor.Local(localBuilder, itemStorageType, isCached: true);
		}

		private bool CachesResult(QilNode nd)
		{
			switch (nd.NodeType)
			{
			case QilNodeType.Let:
			case QilNodeType.Parameter:
			case QilNodeType.Invoke:
			case QilNodeType.XsltInvokeLateBound:
			case QilNodeType.XsltInvokeEarlyBound:
				return !nd.XmlType.IsSingleton;
			case QilNodeType.Filter:
			{
				OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(nd);
				return optimizerPatterns.MatchesPattern(OptimizerPatternName.EqualityIndex);
			}
			case QilNodeType.DocOrderDistinct:
			{
				if (nd.XmlType.IsSingleton)
				{
					return false;
				}
				OptimizerPatterns optimizerPatterns = OptimizerPatterns.Read(nd);
				if (!optimizerPatterns.MatchesPattern(OptimizerPatternName.JoinAndDod))
				{
					return !optimizerPatterns.MatchesPattern(OptimizerPatternName.DodReverse);
				}
				return false;
			}
			case QilNodeType.TypeAssert:
			{
				QilTargetType qilTargetType = (QilTargetType)nd;
				if (CachesResult(qilTargetType.Source))
				{
					return GetItemStorageType(qilTargetType.Source) == GetItemStorageType(qilTargetType);
				}
				return false;
			}
			default:
				return false;
			}
		}

		private Type GetStorageType(QilNode nd)
		{
			return XmlILTypeHelper.GetStorageType(nd.XmlType);
		}

		private Type GetStorageType(XmlQueryType typ)
		{
			return XmlILTypeHelper.GetStorageType(typ);
		}

		private Type GetItemStorageType(QilNode nd)
		{
			return XmlILTypeHelper.GetStorageType(nd.XmlType.Prime);
		}

		private Type GetItemStorageType(XmlQueryType typ)
		{
			return XmlILTypeHelper.GetStorageType(typ.Prime);
		}
	}
}
