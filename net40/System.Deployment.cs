
// C:\WINDOWS\Microsoft.NET\assembly\GAC_MSIL\System.Deployment\v4.0_4.0.0.0__b03f5f7f11d50a3a\System.Deployment.dll
// System.Deployment, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v4.0.30319
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Configuration;
using System.Deployment.Application;
using System.Deployment.Application.Manifest;
using System.Deployment.Application.Win32InterOp;
using System.Deployment.Internal;
using System.Deployment.Internal.CodeSigning;
using System.Deployment.Internal.Isolation;
using System.Deployment.Internal.Isolation.Manifest;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Cache;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Runtime.Remoting;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.Pkcs;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;
using System.Security.Permissions;
using System.Security.Policy;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using System.Xml;
using System.Xml.Schema;
using Microsoft.Internal.Performance;
using Microsoft.Runtime.Hosting;
using Microsoft.Win32;
using Microsoft.Win32.SafeHandles;

[assembly: CompilationRelaxations(8)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: InternalsVisibleTo("dfsvc, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
[assembly: ComVisible(false)]
[assembly: CLSCompliant(true)]
[assembly: AllowPartiallyTrustedCallers]
[assembly: SecurityRules(SecurityRuleSet.Level1, SkipVerificationInFullTrust = true)]
[assembly: AssemblyTitle("System.Deployment.dll")]
[assembly: AssemblyDescription("System.Deployment.dll")]
[assembly: AssemblyDefaultAlias("System.Deployment.dll")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyFileVersion("4.8.9037.0")]
[assembly: AssemblyInformationalVersion("4.8.9037.0")]
[assembly: SatelliteContractVersion("4.0.0.0")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: AssemblyDelaySign(true)]
[assembly: AssemblyKeyFile("f:\\dd\\tools\\devdiv\\FinalPublicKey.snk")]
[assembly: AssemblySignatureKey("002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3", "a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d")]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: DefaultDllImportSearchPaths(DllImportSearchPath.System32 | DllImportSearchPath.AssemblyDirectory)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("4.0.0.0")]
[module: UnverifiableCode]
namespace Microsoft.Internal.Performance
{
	internal sealed class CodeMarkers
	{
		private static class NativeMethods
		{
			[DllImport("Microsoft.Internal.Performance.CodeMarkers.dll", EntryPoint = "InitPerf")]
			public static extern void DllInitPerf(int iApp);

			[DllImport("Microsoft.Internal.Performance.CodeMarkers.dll", EntryPoint = "UnInitPerf")]
			public static extern void DllUnInitPerf(int iApp);

			[DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
			public static extern ushort AddAtom([MarshalAs(UnmanagedType.LPWStr)] string lpString);

			[DllImport("kernel32.dll")]
			public static extern ushort DeleteAtom(ushort atom);

			[DllImport("Microsoft.Internal.Performance.CodeMarkers.dll", EntryPoint = "PerfCodeMarker")]
			public static extern void DllPerfCodeMarker(int nTimerID, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] aUserParams, int cbParams);

			[DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
			public static extern ushort FindAtom([MarshalAs(UnmanagedType.LPWStr)] string lpString);
		}

		private enum State
		{
			Enabled,
			Disabled,
			DisabledDueToDllImportException,
			DisabledViaRegistryCheck
		}

		public static readonly CodeMarkers Instance = new CodeMarkers();

		private const string AtomName = "VSCodeMarkersEnabled";

		private const string DllName = "Microsoft.Internal.Performance.CodeMarkers.dll";

		private State state;

		public bool IsEnabled => state == State.Enabled;

		private CodeMarkers()
		{
			state = ((NativeMethods.FindAtom("VSCodeMarkersEnabled") == 0) ? State.Disabled : State.Enabled);
		}

		public bool CodeMarker(int nTimerID)
		{
			if (!IsEnabled)
			{
				return false;
			}
			try
			{
				NativeMethods.DllPerfCodeMarker(nTimerID, null, 0);
			}
			catch (DllNotFoundException)
			{
				state = State.DisabledDueToDllImportException;
				return false;
			}
			return true;
		}

		public bool CodeMarkerEx(int nTimerID, byte[] aBuff)
		{
			if (!IsEnabled)
			{
				return false;
			}
			if (aBuff == null)
			{
				throw new ArgumentNullException("aBuff");
			}
			try
			{
				NativeMethods.DllPerfCodeMarker(nTimerID, aBuff, aBuff.Length);
			}
			catch (DllNotFoundException)
			{
				state = State.DisabledDueToDllImportException;
				return false;
			}
			return true;
		}

		public bool CodeMarkerEx(int nTimerID, Guid guidData)
		{
			return CodeMarkerEx(nTimerID, guidData.ToByteArray());
		}

		public bool CodeMarkerEx(int nTimerID, string stringData)
		{
			return CodeMarkerEx(nTimerID, Encoding.Unicode.GetBytes(stringData));
		}

		public bool CodeMarkerEx(int nTimerID, uint uintData)
		{
			return CodeMarkerEx(nTimerID, BitConverter.GetBytes(uintData));
		}

		public bool CodeMarkerEx(int nTimerID, ulong ulongData)
		{
			return CodeMarkerEx(nTimerID, BitConverter.GetBytes(ulongData));
		}

		public bool InitPerformanceDll(int iApp, string strRegRoot)
		{
			return InitPerformanceDll(iApp, strRegRoot, RegistryView.Default);
		}

		public bool InitPerformanceDll(int iApp, string strRegRoot, RegistryView registryView)
		{
			if (IsEnabled)
			{
				return true;
			}
			if (!UseCodeMarkers(strRegRoot, registryView))
			{
				state = State.DisabledViaRegistryCheck;
				return false;
			}
			try
			{
				NativeMethods.AddAtom("VSCodeMarkersEnabled");
				NativeMethods.DllInitPerf(iApp);
				state = State.Enabled;
			}
			catch (DllNotFoundException)
			{
				state = State.DisabledDueToDllImportException;
				return false;
			}
			return true;
		}

		private static bool UseCodeMarkers(string regRoot, RegistryView registryView)
		{
			if (regRoot == null)
			{
				throw new ArgumentNullException("regRoot");
			}
			using (RegistryKey registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, registryView))
			{
				using RegistryKey registryKey2 = registryKey.OpenSubKey(regRoot + "\\Performance");
				if (registryKey2 != null)
				{
					string value = registryKey2.GetValue(string.Empty).ToString();
					return !string.IsNullOrEmpty(value);
				}
			}
			return false;
		}

		public void UninitializePerformanceDLL(int iApp)
		{
			if (!IsEnabled)
			{
				return;
			}
			state = State.Disabled;
			ushort num = NativeMethods.FindAtom("VSCodeMarkersEnabled");
			if (num != 0)
			{
				NativeMethods.DeleteAtom(num);
			}
			try
			{
				NativeMethods.DllUnInitPerf(iApp);
			}
			catch (DllNotFoundException)
			{
			}
		}
	}
	internal struct CodeMarkerStartEnd : IDisposable
	{
		private int _end;

		internal CodeMarkerStartEnd(int begin, int end)
		{
			CodeMarkers.Instance.CodeMarker(begin);
			_end = end;
		}

		public void Dispose()
		{
			if (_end != 0)
			{
				CodeMarkers.Instance.CodeMarker(_end);
				_end = 0;
			}
		}
	}
	internal struct CodeMarkerExStartEnd : IDisposable
	{
		private int _end;

		private byte[] _aBuff;

		internal CodeMarkerExStartEnd(int begin, int end, byte[] aBuff)
		{
			CodeMarkers.Instance.CodeMarkerEx(begin, aBuff);
			_end = end;
			_aBuff = aBuff;
		}

		internal CodeMarkerExStartEnd(int begin, int end, Guid guidData)
			: this(begin, end, guidData.ToByteArray())
		{
		}

		internal CodeMarkerExStartEnd(int begin, int end, string stringData)
			: this(begin, end, Encoding.Unicode.GetBytes(stringData))
		{
		}

		internal CodeMarkerExStartEnd(int begin, int end, uint uintData)
			: this(begin, end, BitConverter.GetBytes(uintData))
		{
		}

		internal CodeMarkerExStartEnd(int begin, int end, ulong ulongData)
			: this(begin, end, BitConverter.GetBytes(ulongData))
		{
		}

		public void Dispose()
		{
			if (_end != 0)
			{
				CodeMarkers.Instance.CodeMarkerEx(_end, _aBuff);
				_end = 0;
				_aBuff = null;
			}
		}
	}
}
namespace Microsoft.Runtime.Hosting
{
	internal static class StrongNameHelpers
	{
		[ThreadStatic]
		private static int ts_LastStrongNameHR;

		[SecurityCritical]
		[ThreadStatic]
		private static IClrStrongName s_StrongName;

		private static IClrStrongName StrongName
		{
			[SecurityCritical]
			get
			{
				if (s_StrongName == null)
				{
					s_StrongName = (IClrStrongName)RuntimeEnvironment.GetRuntimeInterfaceAsObject(new Guid("B79B0ACD-F5CD-409b-B5A5-A16244610B92"), new Guid("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D"));
				}
				return s_StrongName;
			}
		}

		private static IClrStrongNameUsingIntPtr StrongNameUsingIntPtr
		{
			[SecurityCritical]
			get
			{
				return (IClrStrongNameUsingIntPtr)StrongName;
			}
		}

		[SecurityCritical]
		public static int StrongNameErrorInfo()
		{
			return ts_LastStrongNameHR;
		}

		[SecurityCritical]
		public static void StrongNameFreeBuffer(IntPtr pbMemory)
		{
			StrongNameUsingIntPtr.StrongNameFreeBuffer(pbMemory);
		}

		[SecurityCritical]
		public static bool StrongNameGetPublicKey(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, out IntPtr ppbPublicKeyBlob, out int pcbPublicKeyBlob)
		{
			int num = StrongNameUsingIntPtr.StrongNameGetPublicKey(pwzKeyContainer, pbKeyBlob, cbKeyBlob, out ppbPublicKeyBlob, out pcbPublicKeyBlob);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				ppbPublicKeyBlob = IntPtr.Zero;
				pcbPublicKeyBlob = 0;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameKeyDelete(string pwzKeyContainer)
		{
			int num = StrongName.StrongNameKeyDelete(pwzKeyContainer);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameKeyGen(string pwzKeyContainer, int dwFlags, out IntPtr ppbKeyBlob, out int pcbKeyBlob)
		{
			int num = StrongName.StrongNameKeyGen(pwzKeyContainer, dwFlags, out ppbKeyBlob, out pcbKeyBlob);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				ppbKeyBlob = IntPtr.Zero;
				pcbKeyBlob = 0;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob)
		{
			int num = StrongNameUsingIntPtr.StrongNameKeyInstall(pwzKeyContainer, pbKeyBlob, cbKeyBlob);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob)
		{
			IntPtr ppbSignatureBlob = IntPtr.Zero;
			int pcbSignatureBlob = 0;
			return StrongNameSignatureGeneration(pwzFilePath, pwzKeyContainer, pbKeyBlob, cbKeyBlob, ref ppbSignatureBlob, out pcbSignatureBlob);
		}

		[SecurityCritical]
		public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, ref IntPtr ppbSignatureBlob, out int pcbSignatureBlob)
		{
			int num = StrongNameUsingIntPtr.StrongNameSignatureGeneration(pwzFilePath, pwzKeyContainer, pbKeyBlob, cbKeyBlob, ppbSignatureBlob, out pcbSignatureBlob);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				pcbSignatureBlob = 0;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameSignatureSize(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, out int pcbSize)
		{
			int num = StrongNameUsingIntPtr.StrongNameSignatureSize(pbPublicKeyBlob, cbPublicKeyBlob, out pcbSize);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				pcbSize = 0;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameSignatureVerification(string pwzFilePath, int dwInFlags, out int pdwOutFlags)
		{
			int num = StrongName.StrongNameSignatureVerification(pwzFilePath, dwInFlags, out pdwOutFlags);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				pdwOutFlags = 0;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, out bool pfWasVerified)
		{
			int num = StrongName.StrongNameSignatureVerificationEx(pwzFilePath, fForceVerification, out pfWasVerified);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				pfWasVerified = false;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameTokenFromPublicKey(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, out IntPtr ppbStrongNameToken, out int pcbStrongNameToken)
		{
			int num = StrongNameUsingIntPtr.StrongNameTokenFromPublicKey(pbPublicKeyBlob, cbPublicKeyBlob, out ppbStrongNameToken, out pcbStrongNameToken);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				ppbStrongNameToken = IntPtr.Zero;
				pcbStrongNameToken = 0;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameSignatureSize(byte[] bPublicKeyBlob, int cbPublicKeyBlob, out int pcbSize)
		{
			int num = StrongName.StrongNameSignatureSize(bPublicKeyBlob, cbPublicKeyBlob, out pcbSize);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				pcbSize = 0;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameTokenFromPublicKey(byte[] bPublicKeyBlob, int cbPublicKeyBlob, out IntPtr ppbStrongNameToken, out int pcbStrongNameToken)
		{
			int num = StrongName.StrongNameTokenFromPublicKey(bPublicKeyBlob, cbPublicKeyBlob, out ppbStrongNameToken, out pcbStrongNameToken);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				ppbStrongNameToken = IntPtr.Zero;
				pcbStrongNameToken = 0;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameGetPublicKey(string pwzKeyContainer, byte[] bKeyBlob, int cbKeyBlob, out IntPtr ppbPublicKeyBlob, out int pcbPublicKeyBlob)
		{
			int num = StrongName.StrongNameGetPublicKey(pwzKeyContainer, bKeyBlob, cbKeyBlob, out ppbPublicKeyBlob, out pcbPublicKeyBlob);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				ppbPublicKeyBlob = IntPtr.Zero;
				pcbPublicKeyBlob = 0;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameKeyInstall(string pwzKeyContainer, byte[] bKeyBlob, int cbKeyBlob)
		{
			int num = StrongName.StrongNameKeyInstall(pwzKeyContainer, bKeyBlob, cbKeyBlob);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				return false;
			}
			return true;
		}

		[SecurityCritical]
		public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, byte[] bKeyBlob, int cbKeyBlob)
		{
			IntPtr ppbSignatureBlob = IntPtr.Zero;
			int pcbSignatureBlob = 0;
			return StrongNameSignatureGeneration(pwzFilePath, pwzKeyContainer, bKeyBlob, cbKeyBlob, ref ppbSignatureBlob, out pcbSignatureBlob);
		}

		[SecurityCritical]
		public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, byte[] bKeyBlob, int cbKeyBlob, ref IntPtr ppbSignatureBlob, out int pcbSignatureBlob)
		{
			int num = StrongName.StrongNameSignatureGeneration(pwzFilePath, pwzKeyContainer, bKeyBlob, cbKeyBlob, ppbSignatureBlob, out pcbSignatureBlob);
			if (num < 0)
			{
				ts_LastStrongNameHR = num;
				pcbSignatureBlob = 0;
				return false;
			}
			return true;
		}
	}
	[ComImport]
	[SecurityCritical]
	[ComConversionLoss]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")]
	internal interface IClrStrongNameUsingIntPtr
	{
		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromAssemblyFile([In][MarshalAs(UnmanagedType.LPStr)] string pszFilePath, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromAssemblyFileW([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromBlob([In] IntPtr pbBlob, [In][MarshalAs(UnmanagedType.U4)] int cchBlob, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromFile([In][MarshalAs(UnmanagedType.LPStr)] string pszFilePath, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromFileW([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromHandle([In] IntPtr hFile, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameCompareAssemblies([In][MarshalAs(UnmanagedType.LPWStr)] string pwzAssembly1, [In][MarshalAs(UnmanagedType.LPWStr)] string pwzAssembly2, [MarshalAs(UnmanagedType.U4)] out int dwResult);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameFreeBuffer([In] IntPtr pbMemory);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameGetBlob([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] pbBlob, [In][Out][MarshalAs(UnmanagedType.U4)] ref int pcbBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameGetBlobFromImage([In] IntPtr pbBase, [In][MarshalAs(UnmanagedType.U4)] int dwLength, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbBlob, [In][Out][MarshalAs(UnmanagedType.U4)] ref int pcbBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameGetPublicKey([In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer, [In] IntPtr pbKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbKeyBlob, out IntPtr ppbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbPublicKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameHashSize([In][MarshalAs(UnmanagedType.U4)] int ulHashAlg, [MarshalAs(UnmanagedType.U4)] out int cbSize);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyDelete([In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyGen([In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer, [In][MarshalAs(UnmanagedType.U4)] int dwFlags, out IntPtr ppbKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyGenEx([In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer, [In][MarshalAs(UnmanagedType.U4)] int dwFlags, [In][MarshalAs(UnmanagedType.U4)] int dwKeySize, out IntPtr ppbKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyInstall([In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer, [In] IntPtr pbKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameSignatureGeneration([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer, [In] IntPtr pbKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbKeyBlob, [In][Out] IntPtr ppbSignatureBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSignatureBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameSignatureGenerationEx([In][MarshalAs(UnmanagedType.LPWStr)] string wszFilePath, [In][MarshalAs(UnmanagedType.LPWStr)] string wszKeyContainer, [In] IntPtr pbKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbKeyBlob, [In][Out] IntPtr ppbSignatureBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSignatureBlob, [In][MarshalAs(UnmanagedType.U4)] int dwFlags);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameSignatureSize([In] IntPtr pbPublicKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSize);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameSignatureVerification([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [In][MarshalAs(UnmanagedType.U4)] int dwInFlags, [MarshalAs(UnmanagedType.U4)] out int dwOutFlags);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameSignatureVerificationEx([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [In][MarshalAs(UnmanagedType.I1)] bool fForceVerification, [MarshalAs(UnmanagedType.I1)] out bool fWasVerified);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameSignatureVerificationFromImage([In] IntPtr pbBase, [In][MarshalAs(UnmanagedType.U4)] int dwLength, [In][MarshalAs(UnmanagedType.U4)] int dwInFlags, [MarshalAs(UnmanagedType.U4)] out int dwOutFlags);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameTokenFromAssembly([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameTokenFromAssemblyEx([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken, out IntPtr ppbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbPublicKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameTokenFromPublicKey([In] IntPtr pbPublicKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbPublicKeyBlob, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken);
	}
	[ComImport]
	[SecurityCritical]
	[ComConversionLoss]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")]
	internal interface IClrStrongName
	{
		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromAssemblyFile([In][MarshalAs(UnmanagedType.LPStr)] string pszFilePath, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromAssemblyFileW([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromBlob([In] IntPtr pbBlob, [In][MarshalAs(UnmanagedType.U4)] int cchBlob, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromFile([In][MarshalAs(UnmanagedType.LPStr)] string pszFilePath, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromFileW([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromHandle([In] IntPtr hFile, [In][Out][MarshalAs(UnmanagedType.U4)] ref int piHashAlg, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbHash, [In][MarshalAs(UnmanagedType.U4)] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameCompareAssemblies([In][MarshalAs(UnmanagedType.LPWStr)] string pwzAssembly1, [In][MarshalAs(UnmanagedType.LPWStr)] string pwzAssembly2, [MarshalAs(UnmanagedType.U4)] out int dwResult);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameFreeBuffer([In] IntPtr pbMemory);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameGetBlob([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] pbBlob, [In][Out][MarshalAs(UnmanagedType.U4)] ref int pcbBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameGetBlobFromImage([In] IntPtr pbBase, [In][MarshalAs(UnmanagedType.U4)] int dwLength, [Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbBlob, [In][Out][MarshalAs(UnmanagedType.U4)] ref int pcbBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameGetPublicKey([In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] pbKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbKeyBlob, out IntPtr ppbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbPublicKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameHashSize([In][MarshalAs(UnmanagedType.U4)] int ulHashAlg, [MarshalAs(UnmanagedType.U4)] out int cbSize);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyDelete([In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyGen([In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer, [In][MarshalAs(UnmanagedType.U4)] int dwFlags, out IntPtr ppbKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyGenEx([In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer, [In][MarshalAs(UnmanagedType.U4)] int dwFlags, [In][MarshalAs(UnmanagedType.U4)] int dwKeySize, out IntPtr ppbKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyInstall([In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] pbKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameSignatureGeneration([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [In][MarshalAs(UnmanagedType.LPWStr)] string pwzKeyContainer, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbKeyBlob, [In][Out] IntPtr ppbSignatureBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSignatureBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameSignatureGenerationEx([In][MarshalAs(UnmanagedType.LPWStr)] string wszFilePath, [In][MarshalAs(UnmanagedType.LPWStr)] string wszKeyContainer, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pbKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbKeyBlob, [In][Out] IntPtr ppbSignatureBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSignatureBlob, [In][MarshalAs(UnmanagedType.U4)] int dwFlags);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameSignatureSize([In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] pbPublicKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSize);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameSignatureVerification([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [In][MarshalAs(UnmanagedType.U4)] int dwInFlags, [MarshalAs(UnmanagedType.U4)] out int dwOutFlags);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameSignatureVerificationEx([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, [In][MarshalAs(UnmanagedType.I1)] bool fForceVerification, [MarshalAs(UnmanagedType.I1)] out bool fWasVerified);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameSignatureVerificationFromImage([In] IntPtr pbBase, [In][MarshalAs(UnmanagedType.U4)] int dwLength, [In][MarshalAs(UnmanagedType.U4)] int dwInFlags, [MarshalAs(UnmanagedType.U4)] out int dwOutFlags);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameTokenFromAssembly([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameTokenFromAssemblyEx([In][MarshalAs(UnmanagedType.LPWStr)] string pwzFilePath, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken, out IntPtr ppbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbPublicKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameTokenFromPublicKey([In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] pbPublicKeyBlob, [In][MarshalAs(UnmanagedType.U4)] int cbPublicKeyBlob, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken);
	}
}
namespace System
{
	internal static class AccessibilityImprovements
	{
		private static bool levelsValidated;

		private static int useLegacyAccessibilityFeatures;

		private static int useLegacyAccessibilityFeatures2;

		private static int useLegacyAccessibilityFeatures3;

		private static int useLegacyAccessibilityFeatures4;

		private static int useLegacyAccessibilityFeatures5;

		private static int useLegacyToolTipDisplayBehavior;

		internal const string UseLegacyAccessibilityFeaturesSwitchName = "Switch.UseLegacyAccessibilityFeatures";

		internal const string UseLegacyAccessibilityFeatures2SwitchName = "Switch.UseLegacyAccessibilityFeatures.2";

		internal const string UseLegacyAccessibilityFeatures3SwitchName = "Switch.UseLegacyAccessibilityFeatures.3";

		internal const string UseLegacyAccessibilityFeatures4SwitchName = "Switch.UseLegacyAccessibilityFeatures.4";

		internal const string UseLegacyAccessibilityFeatures5SwitchName = "Switch.UseLegacyAccessibilityFeatures.5";

		internal const string UseLegacyToolTipDisplaySwitchName = "Switch.System.Windows.Forms.UseLegacyToolTipDisplay";

		internal static bool Level1
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (useLegacyAccessibilityFeatures < 0)
				{
					return true;
				}
				if (useLegacyAccessibilityFeatures > 0)
				{
					return false;
				}
				ValidateLevels();
				return useLegacyAccessibilityFeatures < 0;
			}
		}

		internal static bool Level2
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (useLegacyAccessibilityFeatures2 < 0)
				{
					return true;
				}
				if (useLegacyAccessibilityFeatures2 > 0)
				{
					return false;
				}
				ValidateLevels();
				return useLegacyAccessibilityFeatures2 < 0;
			}
		}

		internal static bool Level3
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (useLegacyAccessibilityFeatures3 < 0)
				{
					return true;
				}
				if (useLegacyAccessibilityFeatures3 > 0)
				{
					return false;
				}
				ValidateLevels();
				return useLegacyAccessibilityFeatures3 < 0;
			}
		}

		internal static bool Level4
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (useLegacyAccessibilityFeatures4 < 0)
				{
					return true;
				}
				if (useLegacyAccessibilityFeatures4 > 0)
				{
					return false;
				}
				ValidateLevels();
				return useLegacyAccessibilityFeatures4 < 0;
			}
		}

		internal static bool Level5
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (useLegacyAccessibilityFeatures5 < 0)
				{
					return true;
				}
				if (useLegacyAccessibilityFeatures5 > 0)
				{
					return false;
				}
				ValidateLevels();
				return useLegacyAccessibilityFeatures5 < 0;
			}
		}

		internal static bool UseLegacyToolTipDisplay
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				if (useLegacyToolTipDisplayBehavior > 0)
				{
					return true;
				}
				if (useLegacyToolTipDisplayBehavior < 0)
				{
					return false;
				}
				ValidateLevels();
				return useLegacyToolTipDisplayBehavior > 0;
			}
		}

		internal static void ValidateLevels()
		{
			if (levelsValidated)
			{
				return;
			}
			Tuple<string, Action<int>>[] array = new Tuple<string, Action<int>>[5]
			{
				Tuple.Create<string, Action<int>>("Switch.UseLegacyAccessibilityFeatures", delegate(int switchValue)
				{
					useLegacyAccessibilityFeatures = switchValue;
				}),
				Tuple.Create<string, Action<int>>("Switch.UseLegacyAccessibilityFeatures.2", delegate(int switchValue)
				{
					useLegacyAccessibilityFeatures2 = switchValue;
				}),
				Tuple.Create<string, Action<int>>("Switch.UseLegacyAccessibilityFeatures.3", delegate(int switchValue)
				{
					useLegacyAccessibilityFeatures3 = switchValue;
				}),
				Tuple.Create<string, Action<int>>("Switch.UseLegacyAccessibilityFeatures.4", delegate(int switchValue)
				{
					useLegacyAccessibilityFeatures4 = switchValue;
				}),
				Tuple.Create<string, Action<int>>("Switch.UseLegacyAccessibilityFeatures.5", delegate(int switchValue)
				{
					useLegacyAccessibilityFeatures5 = switchValue;
				})
			};
			bool flag = false;
			bool flag2 = false;
			bool[] array2 = new bool[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				string item = array[i].Item1;
				Action<int> item2 = array[i].Item2;
				int switchValue2 = 0;
				bool cachedSwitchValue = LocalAppContext.GetCachedSwitchValue(item, ref switchValue2);
				if (cachedSwitchValue)
				{
					flag = true;
				}
				else if (flag)
				{
					flag2 = true;
				}
				item2(switchValue2);
				array2[i] = cachedSwitchValue;
			}
			if (flag2)
			{
				throw new NotSupportedException(System.Deployment.Application.Resources.GetString("CombinationOfAccessibilitySwitchesNotSupported"));
			}
			if (!LocalAppContext.GetCachedSwitchValue("Switch.System.Windows.Forms.UseLegacyToolTipDisplay", ref useLegacyToolTipDisplayBehavior) && array2[2])
			{
				throw new NotSupportedException(System.Deployment.Application.Resources.GetString("KeyboardToolTipDisplayBehaviorRequiresAccessibilityImprovementsLevel3"));
			}
			levelsValidated = true;
		}
	}
	internal static class AppContextDefaultValues
	{
		public static void PopulateDefaultValues()
		{
			ParseTargetFrameworkName(out var identifier, out var profile, out var version);
			PopulateDefaultValuesPartial(identifier, profile, version);
		}

		private static void ParseTargetFrameworkName(out string identifier, out string profile, out int version)
		{
			string targetFrameworkName = AppDomain.CurrentDomain.SetupInformation.TargetFrameworkName;
			if (!TryParseFrameworkName(targetFrameworkName, out identifier, out version, out profile))
			{
				identifier = ".NETFramework";
				version = 40000;
				profile = string.Empty;
			}
		}

		private static bool TryParseFrameworkName(string frameworkName, out string identifier, out int version, out string profile)
		{
			identifier = (profile = string.Empty);
			version = 0;
			if (frameworkName == null || frameworkName.Length == 0)
			{
				return false;
			}
			string[] array = frameworkName.Split(',');
			version = 0;
			if (array.Length < 2 || array.Length > 3)
			{
				return false;
			}
			identifier = array[0].Trim();
			if (identifier.Length == 0)
			{
				return false;
			}
			bool flag = false;
			profile = null;
			for (int i = 1; i < array.Length; i++)
			{
				string[] array2 = array[i].Split('=');
				if (array2.Length != 2)
				{
					return false;
				}
				string text = array2[0].Trim();
				string text2 = array2[1].Trim();
				if (text.Equals("Version", StringComparison.OrdinalIgnoreCase))
				{
					flag = true;
					if (text2.Length > 0 && (text2[0] == 'v' || text2[0] == 'V'))
					{
						text2 = text2.Substring(1);
					}
					Version version2 = new Version(text2);
					version = version2.Major * 10000;
					if (version2.Minor > 0)
					{
						version += version2.Minor * 100;
					}
					if (version2.Build > 0)
					{
						version += version2.Build;
					}
				}
				else
				{
					if (!text.Equals("Profile", StringComparison.OrdinalIgnoreCase))
					{
						return false;
					}
					if (!string.IsNullOrEmpty(text2))
					{
						profile = text2;
					}
				}
			}
			if (!flag)
			{
				return false;
			}
			return true;
		}

		private static void PopulateDefaultValuesPartial(string platformIdentifier, string profile, int version)
		{
			if (platformIdentifier == ".NETFramework")
			{
				if (version <= 40700)
				{
					LocalAppContext.DefineSwitchDefault("Switch.UseLegacyAccessibilityFeatures", initialValue: true);
				}
				if (version <= 40701)
				{
					LocalAppContext.DefineSwitchDefault("Switch.UseLegacyAccessibilityFeatures.2", initialValue: true);
				}
				if (version <= 40702)
				{
					LocalAppContext.DefineSwitchDefault("Switch.UseLegacyAccessibilityFeatures.3", initialValue: true);
				}
				if (version <= 40800)
				{
					LocalAppContext.DefineSwitchDefault("Switch.UseLegacyAccessibilityFeatures.4", initialValue: true);
					LocalAppContext.DefineSwitchDefault("Switch.UseLegacyAccessibilityFeatures.5", initialValue: true);
				}
				LocalAppContext.DefineSwitchDefault("Switch.System.Windows.Forms.UseLegacyToolTipDisplay", initialValue: true);
			}
		}
	}
	internal static class LocalAppContext
	{
		private delegate bool TryGetSwitchDelegate(string switchName, out bool value);

		private static TryGetSwitchDelegate TryGetSwitchFromCentralAppContext;

		private static bool s_canForwardCalls;

		private static Dictionary<string, bool> s_switchMap;

		private static readonly object s_syncLock;

		private static bool DisableCaching { get; set; }

		static LocalAppContext()
		{
			s_switchMap = new Dictionary<string, bool>();
			s_syncLock = new object();
			s_canForwardCalls = SetupDelegate();
			AppContextDefaultValues.PopulateDefaultValues();
			DisableCaching = IsSwitchEnabled("TestSwitch.LocalAppContext.DisableCaching");
		}

		public static bool IsSwitchEnabled(string switchName)
		{
			if (s_canForwardCalls && TryGetSwitchFromCentralAppContext(switchName, out var value))
			{
				return value;
			}
			return IsSwitchEnabledLocal(switchName);
		}

		private static bool IsSwitchEnabledLocal(string switchName)
		{
			bool flag;
			bool value;
			lock (s_switchMap)
			{
				flag = s_switchMap.TryGetValue(switchName, out value);
			}
			if (flag)
			{
				return value;
			}
			return false;
		}

		private static bool SetupDelegate()
		{
			Type type = typeof(object).Assembly.GetType("System.AppContext");
			if (type == null)
			{
				return false;
			}
			MethodInfo method = type.GetMethod("TryGetSwitch", BindingFlags.Static | BindingFlags.Public, null, new Type[2]
			{
				typeof(string),
				typeof(bool).MakeByRefType()
			}, null);
			if (method == null)
			{
				return false;
			}
			TryGetSwitchFromCentralAppContext = (TryGetSwitchDelegate)Delegate.CreateDelegate(typeof(TryGetSwitchDelegate), method);
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool GetCachedSwitchValue(string switchName, ref int switchValue)
		{
			if (switchValue < 0)
			{
				return false;
			}
			if (switchValue > 0)
			{
				return true;
			}
			return GetCachedSwitchValueInternal(switchName, ref switchValue);
		}

		private static bool GetCachedSwitchValueInternal(string switchName, ref int switchValue)
		{
			if (DisableCaching)
			{
				return IsSwitchEnabled(switchName);
			}
			bool flag = IsSwitchEnabled(switchName);
			switchValue = (flag ? 1 : (-1));
			return flag;
		}

		internal static void DefineSwitchDefault(string switchName, bool initialValue)
		{
			s_switchMap[switchName] = initialValue;
		}
	}
}
namespace System.Deployment.Internal.Isolation
{
	internal struct BLOB : IDisposable
	{
		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr BlobData;

		[SecuritySafeCritical]
		public void Dispose()
		{
			if (BlobData != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(BlobData);
				BlobData = IntPtr.Zero;
			}
		}
	}
	internal struct IDENTITY_ATTRIBUTE
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Namespace;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Name;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Value;
	}
	[Flags]
	internal enum STORE_ASSEMBLY_STATUS_FLAGS
	{
		STORE_ASSEMBLY_STATUS_MANIFEST_ONLY = 1,
		STORE_ASSEMBLY_STATUS_PAYLOAD_RESIDENT = 2,
		STORE_ASSEMBLY_STATUS_PARTIAL_INSTALL = 4
	}
	internal struct STORE_ASSEMBLY
	{
		public uint Status;

		public IDefinitionIdentity DefinitionIdentity;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string ManifestPath;

		public ulong AssemblySize;

		public ulong ChangeId;
	}
	[Flags]
	internal enum STORE_ASSEMBLY_FILE_STATUS_FLAGS
	{
		STORE_ASSEMBLY_FILE_STATUS_FLAG_PRESENT = 1
	}
	internal struct STORE_ASSEMBLY_FILE
	{
		public uint Size;

		public uint Flags;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string FileName;

		public uint FileStatusFlags;
	}
	internal struct STORE_CATEGORY
	{
		public IDefinitionIdentity DefinitionIdentity;
	}
	internal struct STORE_CATEGORY_SUBCATEGORY
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Subcategory;
	}
	internal struct STORE_CATEGORY_INSTANCE
	{
		public IDefinitionAppId DefinitionAppId_Application;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string XMLSnippet;
	}
	internal struct CATEGORY
	{
		public IDefinitionIdentity DefinitionIdentity;
	}
	internal struct CATEGORY_SUBCATEGORY
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Subcategory;
	}
	internal struct CATEGORY_INSTANCE
	{
		public IDefinitionAppId DefinitionAppId_Application;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string XMLSnippet;
	}
	[ComImport]
	[Guid("d8b1aacb-5142-4abb-bcc1-e9dc9052a89e")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumSTORE_ASSEMBLY_INSTALLATION_REFERENCE
	{
		[SecurityCritical]
		uint Next([In] uint celt, [Out][MarshalAs(UnmanagedType.LPArray)] StoreApplicationReference[] rgelt);

		[SecurityCritical]
		void Skip([In] uint celt);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumSTORE_ASSEMBLY_INSTALLATION_REFERENCE Clone();
	}
	[ComImport]
	[Guid("f9fd4090-93db-45c0-af87-624940f19cff")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumSTORE_DEPLOYMENT_METADATA
	{
		[SecurityCritical]
		uint Next([In] uint celt, [Out][MarshalAs(UnmanagedType.LPArray)] IDefinitionAppId[] AppIds);

		[SecurityCritical]
		void Skip([In] uint celt);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumSTORE_DEPLOYMENT_METADATA Clone();
	}
	internal class StoreDeploymentMetadataEnumeration : IEnumerator
	{
		private IEnumSTORE_DEPLOYMENT_METADATA _enum;

		private bool _fValid;

		private IDefinitionAppId _current;

		object IEnumerator.Current => GetCurrent();

		public IDefinitionAppId Current => GetCurrent();

		public StoreDeploymentMetadataEnumeration(IEnumSTORE_DEPLOYMENT_METADATA pI)
		{
			_enum = pI;
		}

		private IDefinitionAppId GetCurrent()
		{
			if (!_fValid)
			{
				throw new InvalidOperationException();
			}
			return _current;
		}

		public IEnumerator GetEnumerator()
		{
			return this;
		}

		[SecuritySafeCritical]
		public bool MoveNext()
		{
			IDefinitionAppId[] array = new IDefinitionAppId[1];
			uint num = _enum.Next(1u, array);
			if (num == 1)
			{
				_current = array[0];
			}
			return _fValid = num == 1;
		}

		[SecuritySafeCritical]
		public void Reset()
		{
			_fValid = false;
			_enum.Reset();
		}
	}
	[ComImport]
	[Guid("5fa4f590-a416-4b22-ac79-7c3f0d31f303")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY
	{
		[SecurityCritical]
		uint Next([In] uint celt, [Out][MarshalAs(UnmanagedType.LPArray)] StoreOperationMetadataProperty[] AppIds);

		[SecurityCritical]
		void Skip([In] uint celt);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY Clone();
	}
	internal class StoreDeploymentMetadataPropertyEnumeration : IEnumerator
	{
		private IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY _enum;

		private bool _fValid;

		private StoreOperationMetadataProperty _current;

		object IEnumerator.Current => GetCurrent();

		public StoreOperationMetadataProperty Current => GetCurrent();

		public StoreDeploymentMetadataPropertyEnumeration(IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY pI)
		{
			_enum = pI;
		}

		private StoreOperationMetadataProperty GetCurrent()
		{
			if (!_fValid)
			{
				throw new InvalidOperationException();
			}
			return _current;
		}

		public IEnumerator GetEnumerator()
		{
			return this;
		}

		[SecuritySafeCritical]
		public bool MoveNext()
		{
			StoreOperationMetadataProperty[] array = new StoreOperationMetadataProperty[1];
			uint num = _enum.Next(1u, array);
			if (num == 1)
			{
				_current = array[0];
			}
			return _fValid = num == 1;
		}

		[SecuritySafeCritical]
		public void Reset()
		{
			_fValid = false;
			_enum.Reset();
		}
	}
	[ComImport]
	[Guid("a5c637bf-6eaa-4e5f-b535-55299657e33e")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumSTORE_ASSEMBLY
	{
		[SecurityCritical]
		uint Next([In] uint celt, [Out][MarshalAs(UnmanagedType.LPArray)] STORE_ASSEMBLY[] rgelt);

		[SecurityCritical]
		void Skip([In] uint celt);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumSTORE_ASSEMBLY Clone();
	}
	internal class StoreAssemblyEnumeration : IEnumerator
	{
		private IEnumSTORE_ASSEMBLY _enum;

		private bool _fValid;

		private STORE_ASSEMBLY _current;

		object IEnumerator.Current => GetCurrent();

		public STORE_ASSEMBLY Current => GetCurrent();

		public StoreAssemblyEnumeration(IEnumSTORE_ASSEMBLY pI)
		{
			_enum = pI;
		}

		private STORE_ASSEMBLY GetCurrent()
		{
			if (!_fValid)
			{
				throw new InvalidOperationException();
			}
			return _current;
		}

		public IEnumerator GetEnumerator()
		{
			return this;
		}

		[SecuritySafeCritical]
		public bool MoveNext()
		{
			STORE_ASSEMBLY[] array = new STORE_ASSEMBLY[1];
			uint num = _enum.Next(1u, array);
			if (num == 1)
			{
				_current = array[0];
			}
			return _fValid = num == 1;
		}

		[SecuritySafeCritical]
		public void Reset()
		{
			_fValid = false;
			_enum.Reset();
		}
	}
	[ComImport]
	[Guid("a5c6aaa3-03e4-478d-b9f5-2e45908d5e4f")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumSTORE_ASSEMBLY_FILE
	{
		[SecurityCritical]
		uint Next([In] uint celt, [Out][MarshalAs(UnmanagedType.LPArray)] STORE_ASSEMBLY_FILE[] rgelt);

		[SecurityCritical]
		void Skip([In] uint celt);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumSTORE_ASSEMBLY_FILE Clone();
	}
	internal class StoreAssemblyFileEnumeration : IEnumerator
	{
		private IEnumSTORE_ASSEMBLY_FILE _enum;

		private bool _fValid;

		private STORE_ASSEMBLY_FILE _current;

		object IEnumerator.Current => GetCurrent();

		public STORE_ASSEMBLY_FILE Current => GetCurrent();

		public StoreAssemblyFileEnumeration(IEnumSTORE_ASSEMBLY_FILE pI)
		{
			_enum = pI;
		}

		public IEnumerator GetEnumerator()
		{
			return this;
		}

		private STORE_ASSEMBLY_FILE GetCurrent()
		{
			if (!_fValid)
			{
				throw new InvalidOperationException();
			}
			return _current;
		}

		[SecuritySafeCritical]
		public bool MoveNext()
		{
			STORE_ASSEMBLY_FILE[] array = new STORE_ASSEMBLY_FILE[1];
			uint num = _enum.Next(1u, array);
			if (num == 1)
			{
				_current = array[0];
			}
			return _fValid = num == 1;
		}

		[SecuritySafeCritical]
		public void Reset()
		{
			_fValid = false;
			_enum.Reset();
		}
	}
	[ComImport]
	[Guid("b840a2f5-a497-4a6d-9038-cd3ec2fbd222")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumSTORE_CATEGORY
	{
		[SecurityCritical]
		uint Next([In] uint celt, [Out][MarshalAs(UnmanagedType.LPArray)] STORE_CATEGORY[] rgElements);

		[SecurityCritical]
		void Skip([In] uint ulElements);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumSTORE_CATEGORY Clone();
	}
	internal class StoreCategoryEnumeration : IEnumerator
	{
		private IEnumSTORE_CATEGORY _enum;

		private bool _fValid;

		private STORE_CATEGORY _current;

		object IEnumerator.Current => GetCurrent();

		public STORE_CATEGORY Current => GetCurrent();

		public StoreCategoryEnumeration(IEnumSTORE_CATEGORY pI)
		{
			_enum = pI;
		}

		public IEnumerator GetEnumerator()
		{
			return this;
		}

		private STORE_CATEGORY GetCurrent()
		{
			if (!_fValid)
			{
				throw new InvalidOperationException();
			}
			return _current;
		}

		[SecuritySafeCritical]
		public bool MoveNext()
		{
			STORE_CATEGORY[] array = new STORE_CATEGORY[1];
			uint num = _enum.Next(1u, array);
			if (num == 1)
			{
				_current = array[0];
			}
			return _fValid = num == 1;
		}

		[SecuritySafeCritical]
		public void Reset()
		{
			_fValid = false;
			_enum.Reset();
		}
	}
	[ComImport]
	[Guid("19be1967-b2fc-4dc1-9627-f3cb6305d2a7")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumSTORE_CATEGORY_SUBCATEGORY
	{
		[SecurityCritical]
		uint Next([In] uint celt, [Out][MarshalAs(UnmanagedType.LPArray)] STORE_CATEGORY_SUBCATEGORY[] rgElements);

		[SecurityCritical]
		void Skip([In] uint ulElements);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumSTORE_CATEGORY_SUBCATEGORY Clone();
	}
	internal class StoreSubcategoryEnumeration : IEnumerator
	{
		private IEnumSTORE_CATEGORY_SUBCATEGORY _enum;

		private bool _fValid;

		private STORE_CATEGORY_SUBCATEGORY _current;

		object IEnumerator.Current => GetCurrent();

		public STORE_CATEGORY_SUBCATEGORY Current => GetCurrent();

		public StoreSubcategoryEnumeration(IEnumSTORE_CATEGORY_SUBCATEGORY pI)
		{
			_enum = pI;
		}

		public IEnumerator GetEnumerator()
		{
			return this;
		}

		private STORE_CATEGORY_SUBCATEGORY GetCurrent()
		{
			if (!_fValid)
			{
				throw new InvalidOperationException();
			}
			return _current;
		}

		[SecuritySafeCritical]
		public bool MoveNext()
		{
			STORE_CATEGORY_SUBCATEGORY[] array = new STORE_CATEGORY_SUBCATEGORY[1];
			uint num = _enum.Next(1u, array);
			if (num == 1)
			{
				_current = array[0];
			}
			return _fValid = num == 1;
		}

		[SecuritySafeCritical]
		public void Reset()
		{
			_fValid = false;
			_enum.Reset();
		}
	}
	[ComImport]
	[Guid("5ba7cb30-8508-4114-8c77-262fcda4fadb")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumSTORE_CATEGORY_INSTANCE
	{
		[SecurityCritical]
		uint Next([In] uint ulElements, [Out][MarshalAs(UnmanagedType.LPArray)] STORE_CATEGORY_INSTANCE[] rgInstances);

		[SecurityCritical]
		void Skip([In] uint ulElements);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumSTORE_CATEGORY_INSTANCE Clone();
	}
	internal class StoreCategoryInstanceEnumeration : IEnumerator
	{
		private IEnumSTORE_CATEGORY_INSTANCE _enum;

		private bool _fValid;

		private STORE_CATEGORY_INSTANCE _current;

		object IEnumerator.Current => GetCurrent();

		public STORE_CATEGORY_INSTANCE Current => GetCurrent();

		public StoreCategoryInstanceEnumeration(IEnumSTORE_CATEGORY_INSTANCE pI)
		{
			_enum = pI;
		}

		public IEnumerator GetEnumerator()
		{
			return this;
		}

		private STORE_CATEGORY_INSTANCE GetCurrent()
		{
			if (!_fValid)
			{
				throw new InvalidOperationException();
			}
			return _current;
		}

		[SecuritySafeCritical]
		public bool MoveNext()
		{
			STORE_CATEGORY_INSTANCE[] array = new STORE_CATEGORY_INSTANCE[1];
			uint num = _enum.Next(1u, array);
			if (num == 1)
			{
				_current = array[0];
			}
			return _fValid = num == 1;
		}

		[SecuritySafeCritical]
		public void Reset()
		{
			_fValid = false;
			_enum.Reset();
		}
	}
	internal sealed class ReferenceIdentity
	{
		internal IReferenceIdentity _id;

		internal ReferenceIdentity(IReferenceIdentity i)
		{
			if (i == null)
			{
				throw new ArgumentNullException();
			}
			_id = i;
		}

		private string GetAttribute(string ns, string n)
		{
			return _id.GetAttribute(ns, n);
		}

		private string GetAttribute(string n)
		{
			return _id.GetAttribute(null, n);
		}

		private void SetAttribute(string ns, string n, string v)
		{
			_id.SetAttribute(ns, n, v);
		}

		private void SetAttribute(string n, string v)
		{
			SetAttribute(null, n, v);
		}

		private void DeleteAttribute(string ns, string n)
		{
			SetAttribute(ns, n, null);
		}

		private void DeleteAttribute(string n)
		{
			SetAttribute(null, n, null);
		}
	}
	[ComImport]
	[Guid("6eaf5ace-7917-4f3c-b129-e046a9704766")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IReferenceIdentity
	{
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string GetAttribute([In][MarshalAs(UnmanagedType.LPWStr)] string Namespace, [In][MarshalAs(UnmanagedType.LPWStr)] string Name);

		[SecurityCritical]
		void SetAttribute([In][MarshalAs(UnmanagedType.LPWStr)] string Namespace, [In][MarshalAs(UnmanagedType.LPWStr)] string Name, [In][MarshalAs(UnmanagedType.LPWStr)] string Value);

		[SecurityCritical]
		IEnumIDENTITY_ATTRIBUTE EnumAttributes();

		[SecurityCritical]
		IReferenceIdentity Clone([In] IntPtr cDeltas, [In][MarshalAs(UnmanagedType.LPArray)] IDENTITY_ATTRIBUTE[] Deltas);
	}
	[ComImport]
	[Guid("587bf538-4d90-4a3c-9ef1-58a200a8a9e7")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IDefinitionIdentity
	{
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string GetAttribute([In][MarshalAs(UnmanagedType.LPWStr)] string Namespace, [In][MarshalAs(UnmanagedType.LPWStr)] string Name);

		[SecurityCritical]
		void SetAttribute([In][MarshalAs(UnmanagedType.LPWStr)] string Namespace, [In][MarshalAs(UnmanagedType.LPWStr)] string Name, [In][MarshalAs(UnmanagedType.LPWStr)] string Value);

		[SecurityCritical]
		IEnumIDENTITY_ATTRIBUTE EnumAttributes();

		[SecurityCritical]
		IDefinitionIdentity Clone([In] IntPtr cDeltas, [In][MarshalAs(UnmanagedType.LPArray)] IDENTITY_ATTRIBUTE[] Deltas);
	}
	internal sealed class DefinitionIdentity
	{
		internal IDefinitionIdentity _id;

		internal DefinitionIdentity(IDefinitionIdentity i)
		{
			if (i == null)
			{
				throw new ArgumentNullException();
			}
			_id = i;
		}

		private string GetAttribute(string ns, string n)
		{
			return _id.GetAttribute(ns, n);
		}

		private string GetAttribute(string n)
		{
			return _id.GetAttribute(null, n);
		}

		private void SetAttribute(string ns, string n, string v)
		{
			_id.SetAttribute(ns, n, v);
		}

		private void SetAttribute(string n, string v)
		{
			SetAttribute(null, n, v);
		}

		private void DeleteAttribute(string ns, string n)
		{
			SetAttribute(ns, n, null);
		}

		private void DeleteAttribute(string n)
		{
			SetAttribute(null, n, null);
		}
	}
	[ComImport]
	[Guid("9cdaae75-246e-4b00-a26d-b9aec137a3eb")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumIDENTITY_ATTRIBUTE
	{
		[SecurityCritical]
		uint Next([In] uint celt, [Out][MarshalAs(UnmanagedType.LPArray)] IDENTITY_ATTRIBUTE[] rgAttributes);

		[SecurityCritical]
		IntPtr CurrentIntoBuffer([In] IntPtr Available, [Out][MarshalAs(UnmanagedType.LPArray)] byte[] Data);

		[SecurityCritical]
		void Skip([In] uint celt);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumIDENTITY_ATTRIBUTE Clone();
	}
	[ComImport]
	[Guid("f3549d9c-fc73-4793-9c00-1cd204254c0c")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumDefinitionIdentity
	{
		[SecurityCritical]
		uint Next([In] uint celt, [Out][MarshalAs(UnmanagedType.LPArray)] IDefinitionIdentity[] DefinitionIdentity);

		[SecurityCritical]
		void Skip([In] uint celt);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumDefinitionIdentity Clone();
	}
	internal sealed class EnumDefinitionIdentity : IEnumerator
	{
		private IEnumDefinitionIdentity _enum;

		private IDefinitionIdentity _current;

		private IDefinitionIdentity[] _fetchList = new IDefinitionIdentity[1];

		object IEnumerator.Current => GetCurrent();

		public DefinitionIdentity Current => GetCurrent();

		internal EnumDefinitionIdentity(IEnumDefinitionIdentity e)
		{
			if (e == null)
			{
				throw new ArgumentNullException();
			}
			_enum = e;
		}

		private DefinitionIdentity GetCurrent()
		{
			if (_current == null)
			{
				throw new InvalidOperationException();
			}
			return new DefinitionIdentity(_current);
		}

		public IEnumerator GetEnumerator()
		{
			return this;
		}

		public bool MoveNext()
		{
			if (_enum.Next(1u, _fetchList) == 1)
			{
				_current = _fetchList[0];
				return true;
			}
			_current = null;
			return false;
		}

		public void Reset()
		{
			_current = null;
			_enum.Reset();
		}
	}
	[ComImport]
	[Guid("b30352cf-23da-4577-9b3f-b4e6573be53b")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IEnumReferenceIdentity
	{
		[SecurityCritical]
		uint Next([In] uint celt, [Out][MarshalAs(UnmanagedType.LPArray)] IReferenceIdentity[] ReferenceIdentity);

		[SecurityCritical]
		void Skip(uint celt);

		[SecurityCritical]
		void Reset();

		[SecurityCritical]
		IEnumReferenceIdentity Clone();
	}
	internal sealed class EnumReferenceIdentity : IEnumerator
	{
		private IEnumReferenceIdentity _enum;

		private IReferenceIdentity _current;

		private IReferenceIdentity[] _fetchList = new IReferenceIdentity[1];

		object IEnumerator.Current => GetCurrent();

		public ReferenceIdentity Current => GetCurrent();

		internal EnumReferenceIdentity(IEnumReferenceIdentity e)
		{
			_enum = e;
		}

		private ReferenceIdentity GetCurrent()
		{
			if (_current == null)
			{
				throw new InvalidOperationException();
			}
			return new ReferenceIdentity(_current);
		}

		public IEnumerator GetEnumerator()
		{
			return this;
		}

		public bool MoveNext()
		{
			if (_enum.Next(1u, _fetchList) == 1)
			{
				_current = _fetchList[0];
				return true;
			}
			_current = null;
			return false;
		}

		public void Reset()
		{
			_current = null;
			_enum.Reset();
		}
	}
	[ComImport]
	[Guid("d91e12d8-98ed-47fa-9936-39421283d59b")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IDefinitionAppId
	{
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string get_SubscriptionId();

		void put_SubscriptionId([In][MarshalAs(UnmanagedType.LPWStr)] string Subscription);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string get_Codebase();

		[SecurityCritical]
		void put_Codebase([In][MarshalAs(UnmanagedType.LPWStr)] string CodeBase);

		[SecurityCritical]
		IEnumDefinitionIdentity EnumAppPath();

		[SecurityCritical]
		void SetAppPath([In] uint cIDefinitionIdentity, [In][MarshalAs(UnmanagedType.LPArray)] IDefinitionIdentity[] DefinitionIdentity);
	}
	internal sealed class DefinitionAppId
	{
		internal IDefinitionAppId _id;

		public string SubscriptionId
		{
			get
			{
				return _id.get_SubscriptionId();
			}
			set
			{
				_id.put_SubscriptionId(value);
			}
		}

		public string Codebase
		{
			get
			{
				return _id.get_Codebase();
			}
			set
			{
				_id.put_Codebase(value);
			}
		}

		public EnumDefinitionIdentity AppPath => new EnumDefinitionIdentity(_id.EnumAppPath());

		internal DefinitionAppId(IDefinitionAppId id)
		{
			if (id == null)
			{
				throw new ArgumentNullException();
			}
			_id = id;
		}

		private void SetAppPath(IDefinitionIdentity[] Ids)
		{
			_id.SetAppPath((uint)Ids.Length, Ids);
		}
	}
	[ComImport]
	[Guid("054f0bef-9e45-4363-8f5a-2f8e142d9a3b")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IReferenceAppId
	{
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string get_SubscriptionId();

		void put_SubscriptionId([In][MarshalAs(UnmanagedType.LPWStr)] string Subscription);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string get_Codebase();

		void put_Codebase([In][MarshalAs(UnmanagedType.LPWStr)] string CodeBase);

		[SecurityCritical]
		IEnumReferenceIdentity EnumAppPath();
	}
	internal sealed class ReferenceAppId
	{
		internal IReferenceAppId _id;

		public string SubscriptionId
		{
			get
			{
				return _id.get_SubscriptionId();
			}
			set
			{
				_id.put_SubscriptionId(value);
			}
		}

		public string Codebase
		{
			get
			{
				return _id.get_Codebase();
			}
			set
			{
				_id.put_Codebase(value);
			}
		}

		public EnumReferenceIdentity AppPath => new EnumReferenceIdentity(_id.EnumAppPath());

		internal ReferenceAppId(IReferenceAppId id)
		{
			if (id == null)
			{
				throw new ArgumentNullException();
			}
			_id = id;
		}
	}
	internal enum IIDENTITYAUTHORITY_DEFINITION_IDENTITY_TO_TEXT_FLAGS
	{
		IIDENTITYAUTHORITY_DEFINITION_IDENTITY_TO_TEXT_FLAG_CANONICAL = 1
	}
	internal enum IIDENTITYAUTHORITY_REFERENCE_IDENTITY_TO_TEXT_FLAGS
	{
		IIDENTITYAUTHORITY_REFERENCE_IDENTITY_TO_TEXT_FLAG_CANONICAL = 1
	}
	internal enum IIDENTITYAUTHORITY_DOES_DEFINITION_MATCH_REFERENCE_FLAGS
	{
		IIDENTITYAUTHORITY_DOES_DEFINITION_MATCH_REFERENCE_FLAG_EXACT_MATCH_REQUIRED = 1
	}
	[ComImport]
	[Guid("261a6983-c35d-4d0d-aa5b-7867259e77bc")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IIdentityAuthority
	{
		[SecurityCritical]
		IDefinitionIdentity TextToDefinition([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string Identity);

		[SecurityCritical]
		IReferenceIdentity TextToReference([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string Identity);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string DefinitionToText([In] uint Flags, [In] IDefinitionIdentity DefinitionIdentity);

		[SecurityCritical]
		uint DefinitionToTextBuffer([In] uint Flags, [In] IDefinitionIdentity DefinitionIdentity, [In] uint BufferSize, [Out][MarshalAs(UnmanagedType.LPArray)] char[] Buffer);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string ReferenceToText([In] uint Flags, [In] IReferenceIdentity ReferenceIdentity);

		[SecurityCritical]
		uint ReferenceToTextBuffer([In] uint Flags, [In] IReferenceIdentity ReferenceIdentity, [In] uint BufferSize, [Out][MarshalAs(UnmanagedType.LPArray)] char[] Buffer);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool AreDefinitionsEqual([In] uint Flags, [In] IDefinitionIdentity Definition1, [In] IDefinitionIdentity Definition2);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool AreReferencesEqual([In] uint Flags, [In] IReferenceIdentity Reference1, [In] IReferenceIdentity Reference2);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool AreTextualDefinitionsEqual([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string IdentityLeft, [In][MarshalAs(UnmanagedType.LPWStr)] string IdentityRight);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool AreTextualReferencesEqual([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string IdentityLeft, [In][MarshalAs(UnmanagedType.LPWStr)] string IdentityRight);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool DoesDefinitionMatchReference([In] uint Flags, [In] IDefinitionIdentity DefinitionIdentity, [In] IReferenceIdentity ReferenceIdentity);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool DoesTextualDefinitionMatchTextualReference([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string Definition, [In][MarshalAs(UnmanagedType.LPWStr)] string Reference);

		[SecurityCritical]
		ulong HashReference([In] uint Flags, [In] IReferenceIdentity ReferenceIdentity);

		[SecurityCritical]
		ulong HashDefinition([In] uint Flags, [In] IDefinitionIdentity DefinitionIdentity);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string GenerateDefinitionKey([In] uint Flags, [In] IDefinitionIdentity DefinitionIdentity);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string GenerateReferenceKey([In] uint Flags, [In] IReferenceIdentity ReferenceIdentity);

		[SecurityCritical]
		IDefinitionIdentity CreateDefinition();

		[SecurityCritical]
		IReferenceIdentity CreateReference();
	}
	[Flags]
	internal enum IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAGS
	{
		IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAG_IGNORE_VERSION = 1
	}
	[Flags]
	internal enum IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAGS
	{
		IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAG_IGNORE_VERSION = 1
	}
	[ComImport]
	[Guid("8c87810c-2541-4f75-b2d0-9af515488e23")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IAppIdAuthority
	{
		[SecurityCritical]
		IDefinitionAppId TextToDefinition([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string Identity);

		[SecurityCritical]
		IReferenceAppId TextToReference([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string Identity);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string DefinitionToText([In] uint Flags, [In] IDefinitionAppId DefinitionAppId);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string ReferenceToText([In] uint Flags, [In] IReferenceAppId ReferenceAppId);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool AreDefinitionsEqual([In] uint Flags, [In] IDefinitionAppId Definition1, [In] IDefinitionAppId Definition2);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool AreReferencesEqual([In] uint Flags, [In] IReferenceAppId Reference1, [In] IReferenceAppId Reference2);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool AreTextualDefinitionsEqual([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string AppIdLeft, [In][MarshalAs(UnmanagedType.LPWStr)] string AppIdRight);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool AreTextualReferencesEqual([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string AppIdLeft, [In][MarshalAs(UnmanagedType.LPWStr)] string AppIdRight);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool DoesDefinitionMatchReference([In] uint Flags, [In] IDefinitionAppId DefinitionIdentity, [In] IReferenceAppId ReferenceIdentity);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Bool)]
		bool DoesTextualDefinitionMatchTextualReference([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string Definition, [In][MarshalAs(UnmanagedType.LPWStr)] string Reference);

		[SecurityCritical]
		ulong HashReference([In] uint Flags, [In] IReferenceAppId ReferenceIdentity);

		[SecurityCritical]
		ulong HashDefinition([In] uint Flags, [In] IDefinitionAppId DefinitionIdentity);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string GenerateDefinitionKey([In] uint Flags, [In] IDefinitionAppId DefinitionIdentity);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string GenerateReferenceKey([In] uint Flags, [In] IReferenceAppId ReferenceIdentity);

		[SecurityCritical]
		IDefinitionAppId CreateDefinition();

		[SecurityCritical]
		IReferenceAppId CreateReference();
	}
	[Flags]
	internal enum ISTORE_BIND_REFERENCE_TO_ASSEMBLY_FLAGS
	{
		ISTORE_BIND_REFERENCE_TO_ASSEMBLY_FLAG_FORCE_LIBRARY_SEMANTICS = 1
	}
	[Flags]
	internal enum ISTORE_ENUM_ASSEMBLIES_FLAGS
	{
		ISTORE_ENUM_ASSEMBLIES_FLAG_LIMIT_TO_VISIBLE_ONLY = 1,
		ISTORE_ENUM_ASSEMBLIES_FLAG_MATCH_SERVICING = 2,
		ISTORE_ENUM_ASSEMBLIES_FLAG_FORCE_LIBRARY_SEMANTICS = 4
	}
	[Flags]
	internal enum ISTORE_ENUM_FILES_FLAGS
	{
		ISTORE_ENUM_FILES_FLAG_INCLUDE_INSTALLED_FILES = 1,
		ISTORE_ENUM_FILES_FLAG_INCLUDE_MISSING_FILES = 2
	}
	internal struct StoreOperationStageComponent
	{
		[Flags]
		public enum OpFlags
		{
			Nothing = 0
		}

		public enum Disposition
		{
			Failed,
			Installed,
			Refreshed,
			AlreadyInstalled
		}

		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.U4)]
		public OpFlags Flags;

		[MarshalAs(UnmanagedType.Interface)]
		public IDefinitionAppId Application;

		[MarshalAs(UnmanagedType.Interface)]
		public IDefinitionIdentity Component;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string ManifestPath;

		public void Destroy()
		{
		}

		public StoreOperationStageComponent(IDefinitionAppId app, string Manifest)
			: this(app, null, Manifest)
		{
		}

		public StoreOperationStageComponent(IDefinitionAppId app, IDefinitionIdentity comp, string Manifest)
		{
			Size = (uint)Marshal.SizeOf(typeof(StoreOperationStageComponent));
			Flags = OpFlags.Nothing;
			Application = app;
			Component = comp;
			ManifestPath = Manifest;
		}
	}
	internal struct StoreOperationStageComponentFile
	{
		[Flags]
		public enum OpFlags
		{
			Nothing = 0
		}

		public enum Disposition
		{
			Failed,
			Installed,
			Refreshed,
			AlreadyInstalled
		}

		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.U4)]
		public OpFlags Flags;

		[MarshalAs(UnmanagedType.Interface)]
		public IDefinitionAppId Application;

		[MarshalAs(UnmanagedType.Interface)]
		public IDefinitionIdentity Component;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string ComponentRelativePath;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string SourceFilePath;

		public StoreOperationStageComponentFile(IDefinitionAppId App, string CompRelPath, string SrcFile)
			: this(App, null, CompRelPath, SrcFile)
		{
		}

		public StoreOperationStageComponentFile(IDefinitionAppId App, IDefinitionIdentity Component, string CompRelPath, string SrcFile)
		{
			Size = (uint)Marshal.SizeOf(typeof(StoreOperationStageComponentFile));
			Flags = OpFlags.Nothing;
			Application = App;
			this.Component = Component;
			ComponentRelativePath = CompRelPath;
			SourceFilePath = SrcFile;
		}

		public void Destroy()
		{
		}
	}
	internal struct StoreApplicationReference
	{
		[Flags]
		public enum RefFlags
		{
			Nothing = 0
		}

		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.U4)]
		public RefFlags Flags;

		public Guid GuidScheme;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Identifier;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string NonCanonicalData;

		public StoreApplicationReference(Guid RefScheme, string Id, string NcData)
		{
			Size = (uint)Marshal.SizeOf(typeof(StoreApplicationReference));
			Flags = RefFlags.Nothing;
			GuidScheme = RefScheme;
			Identifier = Id;
			NonCanonicalData = NcData;
		}

		[SecurityCritical]
		public IntPtr ToIntPtr()
		{
			IntPtr intPtr = Marshal.AllocCoTaskMem(Marshal.SizeOf((object)this));
			Marshal.StructureToPtr((object)this, intPtr, fDeleteOld: false);
			return intPtr;
		}

		[SecurityCritical]
		public static void Destroy(IntPtr ip)
		{
			if (ip != IntPtr.Zero)
			{
				Marshal.DestroyStructure(ip, typeof(StoreApplicationReference));
				Marshal.FreeCoTaskMem(ip);
			}
		}
	}
	internal struct StoreOperationPinDeployment
	{
		[Flags]
		public enum OpFlags
		{
			Nothing = 0,
			NeverExpires = 1
		}

		public enum Disposition
		{
			Failed,
			Pinned
		}

		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.U4)]
		public OpFlags Flags;

		[MarshalAs(UnmanagedType.Interface)]
		public IDefinitionAppId Application;

		[MarshalAs(UnmanagedType.I8)]
		public long ExpirationTime;

		public IntPtr Reference;

		[SecuritySafeCritical]
		public StoreOperationPinDeployment(IDefinitionAppId AppId, StoreApplicationReference Ref)
		{
			Size = (uint)Marshal.SizeOf(typeof(StoreOperationPinDeployment));
			Flags = OpFlags.NeverExpires;
			Application = AppId;
			Reference = Ref.ToIntPtr();
			ExpirationTime = 0L;
		}

		public StoreOperationPinDeployment(IDefinitionAppId AppId, DateTime Expiry, StoreApplicationReference Ref)
			: this(AppId, Ref)
		{
			Flags |= OpFlags.NeverExpires;
		}

		[SecurityCritical]
		public void Destroy()
		{
			StoreApplicationReference.Destroy(Reference);
		}
	}
	internal struct StoreOperationUnpinDeployment
	{
		[Flags]
		public enum OpFlags
		{
			Nothing = 0
		}

		public enum Disposition
		{
			Failed,
			Unpinned
		}

		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.U4)]
		public OpFlags Flags;

		[MarshalAs(UnmanagedType.Interface)]
		public IDefinitionAppId Application;

		public IntPtr Reference;

		[SecuritySafeCritical]
		public StoreOperationUnpinDeployment(IDefinitionAppId app, StoreApplicationReference reference)
		{
			Size = (uint)Marshal.SizeOf(typeof(StoreOperationUnpinDeployment));
			Flags = OpFlags.Nothing;
			Application = app;
			Reference = reference.ToIntPtr();
		}

		[SecurityCritical]
		public void Destroy()
		{
			StoreApplicationReference.Destroy(Reference);
		}
	}
	internal struct StoreOperationInstallDeployment
	{
		[Flags]
		public enum OpFlags
		{
			Nothing = 0,
			UninstallOthers = 1
		}

		public enum Disposition
		{
			Failed,
			AlreadyInstalled,
			Installed
		}

		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.U4)]
		public OpFlags Flags;

		[MarshalAs(UnmanagedType.Interface)]
		public IDefinitionAppId Application;

		public IntPtr Reference;

		public StoreOperationInstallDeployment(IDefinitionAppId App, StoreApplicationReference reference)
			: this(App, UninstallOthers: true, reference)
		{
		}

		[SecuritySafeCritical]
		public StoreOperationInstallDeployment(IDefinitionAppId App, bool UninstallOthers, StoreApplicationReference reference)
		{
			Size = (uint)Marshal.SizeOf(typeof(StoreOperationInstallDeployment));
			Flags = OpFlags.Nothing;
			Application = App;
			if (UninstallOthers)
			{
				Flags |= OpFlags.UninstallOthers;
			}
			Reference = reference.ToIntPtr();
		}

		[SecurityCritical]
		public void Destroy()
		{
			StoreApplicationReference.Destroy(Reference);
		}
	}
	internal struct StoreOperationUninstallDeployment
	{
		[Flags]
		public enum OpFlags
		{
			Nothing = 0
		}

		public enum Disposition
		{
			Failed,
			DidNotExist,
			Uninstalled
		}

		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.U4)]
		public OpFlags Flags;

		[MarshalAs(UnmanagedType.Interface)]
		public IDefinitionAppId Application;

		public IntPtr Reference;

		[SecuritySafeCritical]
		public StoreOperationUninstallDeployment(IDefinitionAppId appid, StoreApplicationReference AppRef)
		{
			Size = (uint)Marshal.SizeOf(typeof(StoreOperationUninstallDeployment));
			Flags = OpFlags.Nothing;
			Application = appid;
			Reference = AppRef.ToIntPtr();
		}

		[SecurityCritical]
		public void Destroy()
		{
			StoreApplicationReference.Destroy(Reference);
		}
	}
	internal struct StoreOperationMetadataProperty
	{
		public Guid GuidPropertySet;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Name;

		[MarshalAs(UnmanagedType.SysUInt)]
		public IntPtr ValueSize;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Value;

		public StoreOperationMetadataProperty(Guid PropertySet, string Name)
			: this(PropertySet, Name, null)
		{
		}

		public StoreOperationMetadataProperty(Guid PropertySet, string Name, string Value)
		{
			GuidPropertySet = PropertySet;
			this.Name = Name;
			this.Value = Value;
			ValueSize = ((Value != null) ? new IntPtr((Value.Length + 1) * 2) : IntPtr.Zero);
		}
	}
	internal struct StoreOperationSetDeploymentMetadata
	{
		[Flags]
		public enum OpFlags
		{
			Nothing = 0
		}

		public enum Disposition
		{
			Failed = 0,
			Set = 2
		}

		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.U4)]
		public OpFlags Flags;

		[MarshalAs(UnmanagedType.Interface)]
		public IDefinitionAppId Deployment;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr InstallerReference;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr cPropertiesToTest;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr PropertiesToTest;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr cPropertiesToSet;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr PropertiesToSet;

		public StoreOperationSetDeploymentMetadata(IDefinitionAppId Deployment, StoreApplicationReference Reference, StoreOperationMetadataProperty[] SetProperties)
			: this(Deployment, Reference, SetProperties, null)
		{
		}

		[SecuritySafeCritical]
		public StoreOperationSetDeploymentMetadata(IDefinitionAppId Deployment, StoreApplicationReference Reference, StoreOperationMetadataProperty[] SetProperties, StoreOperationMetadataProperty[] TestProperties)
		{
			Size = (uint)Marshal.SizeOf(typeof(StoreOperationSetDeploymentMetadata));
			Flags = OpFlags.Nothing;
			this.Deployment = Deployment;
			if (SetProperties != null)
			{
				PropertiesToSet = MarshalProperties(SetProperties);
				cPropertiesToSet = new IntPtr(SetProperties.Length);
			}
			else
			{
				PropertiesToSet = IntPtr.Zero;
				cPropertiesToSet = IntPtr.Zero;
			}
			if (TestProperties != null)
			{
				PropertiesToTest = MarshalProperties(TestProperties);
				cPropertiesToTest = new IntPtr(TestProperties.Length);
			}
			else
			{
				PropertiesToTest = IntPtr.Zero;
				cPropertiesToTest = IntPtr.Zero;
			}
			InstallerReference = Reference.ToIntPtr();
		}

		[SecurityCritical]
		public void Destroy()
		{
			if (PropertiesToSet != IntPtr.Zero)
			{
				DestroyProperties(PropertiesToSet, (ulong)cPropertiesToSet.ToInt64());
				PropertiesToSet = IntPtr.Zero;
				cPropertiesToSet = IntPtr.Zero;
			}
			if (PropertiesToTest != IntPtr.Zero)
			{
				DestroyProperties(PropertiesToTest, (ulong)cPropertiesToTest.ToInt64());
				PropertiesToTest = IntPtr.Zero;
				cPropertiesToTest = IntPtr.Zero;
			}
			if (InstallerReference != IntPtr.Zero)
			{
				StoreApplicationReference.Destroy(InstallerReference);
				InstallerReference = IntPtr.Zero;
			}
		}

		[SecurityCritical]
		private static void DestroyProperties(IntPtr rgItems, ulong iItems)
		{
			if (rgItems != IntPtr.Zero)
			{
				IntPtr intPtr = rgItems;
				ulong num = (ulong)Marshal.SizeOf(typeof(StoreOperationMetadataProperty));
				for (ulong num2 = 0uL; num2 < iItems; num2++)
				{
					Marshal.DestroyStructure(new IntPtr((long)(num2 * num) + rgItems.ToInt64()), typeof(StoreOperationMetadataProperty));
				}
				Marshal.FreeCoTaskMem(rgItems);
			}
		}

		[SecurityCritical]
		private static IntPtr MarshalProperties(StoreOperationMetadataProperty[] Props)
		{
			if (Props == null || Props.Length == 0)
			{
				return IntPtr.Zero;
			}
			int num = Marshal.SizeOf(typeof(StoreOperationMetadataProperty));
			IntPtr result = Marshal.AllocCoTaskMem(num * Props.Length);
			for (int i = 0; i != Props.Length; i++)
			{
				Marshal.StructureToPtr((object)Props[i], new IntPtr(i * num + result.ToInt64()), fDeleteOld: false);
			}
			return result;
		}
	}
	internal struct StoreOperationSetCanonicalizationContext
	{
		[Flags]
		public enum OpFlags
		{
			Nothing = 0
		}

		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.U4)]
		public OpFlags Flags;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string BaseAddressFilePath;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string ExportsFilePath;

		[SecurityCritical]
		public StoreOperationSetCanonicalizationContext(string Bases, string Exports)
		{
			Size = (uint)Marshal.SizeOf(typeof(StoreOperationSetCanonicalizationContext));
			Flags = OpFlags.Nothing;
			BaseAddressFilePath = Bases;
			ExportsFilePath = Exports;
		}

		public void Destroy()
		{
		}
	}
	internal struct StoreOperationScavenge
	{
		[Flags]
		public enum OpFlags
		{
			Nothing = 0,
			Light = 1,
			LimitSize = 2,
			LimitTime = 4,
			LimitCount = 8
		}

		[MarshalAs(UnmanagedType.U4)]
		public uint Size;

		[MarshalAs(UnmanagedType.U4)]
		public OpFlags Flags;

		[MarshalAs(UnmanagedType.U8)]
		public ulong SizeReclaimationLimit;

		[MarshalAs(UnmanagedType.U8)]
		public ulong RuntimeLimit;

		[MarshalAs(UnmanagedType.U4)]
		public uint ComponentCountLimit;

		public StoreOperationScavenge(bool Light, ulong SizeLimit, ulong RunLimit, uint ComponentLimit)
		{
			Size = (uint)Marshal.SizeOf(typeof(StoreOperationScavenge));
			Flags = OpFlags.Nothing;
			if (Light)
			{
				Flags |= OpFlags.Light;
			}
			SizeReclaimationLimit = SizeLimit;
			if (SizeLimit != 0L)
			{
				Flags |= OpFlags.LimitSize;
			}
			RuntimeLimit = RunLimit;
			if (RunLimit != 0L)
			{
				Flags |= OpFlags.LimitTime;
			}
			ComponentCountLimit = ComponentLimit;
			if (ComponentLimit != 0)
			{
				Flags |= OpFlags.LimitCount;
			}
		}

		public StoreOperationScavenge(bool Light)
			: this(Light, 0uL, 0uL, 0u)
		{
		}

		public void Destroy()
		{
		}
	}
	internal enum StoreTransactionOperationType
	{
		Invalid = 0,
		SetCanonicalizationContext = 14,
		StageComponent = 20,
		PinDeployment = 21,
		UnpinDeployment = 22,
		StageComponentFile = 23,
		InstallDeployment = 24,
		UninstallDeployment = 25,
		SetDeploymentMetadata = 26,
		Scavenge = 27
	}
	internal struct StoreTransactionOperation
	{
		[MarshalAs(UnmanagedType.U4)]
		public StoreTransactionOperationType Operation;

		public StoreTransactionData Data;
	}
	internal struct StoreTransactionData
	{
		public IntPtr DataPtr;
	}
	internal class Store
	{
		[Flags]
		public enum EnumAssembliesFlags
		{
			Nothing = 0,
			VisibleOnly = 1,
			MatchServicing = 2,
			ForceLibrarySemantics = 4
		}

		[Flags]
		public enum EnumAssemblyFilesFlags
		{
			Nothing = 0,
			IncludeInstalled = 1,
			IncludeMissing = 2
		}

		[Flags]
		public enum EnumApplicationPrivateFiles
		{
			Nothing = 0,
			IncludeInstalled = 1,
			IncludeMissing = 2
		}

		[Flags]
		public enum EnumAssemblyInstallReferenceFlags
		{
			Nothing = 0
		}

		public interface IPathLock : IDisposable
		{
			string Path { get; }
		}

		private class AssemblyPathLock : IPathLock, IDisposable
		{
			private IStore _pSourceStore;

			private IntPtr _pLockCookie = IntPtr.Zero;

			private string _path;

			public string Path => _path;

			public AssemblyPathLock(IStore s, IntPtr c, string path)
			{
				_pSourceStore = s;
				_pLockCookie = c;
				_path = path;
			}

			[SecuritySafeCritical]
			private void Dispose(bool fDisposing)
			{
				if (fDisposing)
				{
					GC.SuppressFinalize(this);
				}
				if (_pLockCookie != IntPtr.Zero)
				{
					_pSourceStore.ReleaseAssemblyPath(_pLockCookie);
					_pLockCookie = IntPtr.Zero;
				}
			}

			~AssemblyPathLock()
			{
				Dispose(fDisposing: false);
			}

			void IDisposable.Dispose()
			{
				Dispose(fDisposing: true);
			}
		}

		private class ApplicationPathLock : IPathLock, IDisposable
		{
			private IStore _pSourceStore;

			private IntPtr _pLockCookie = IntPtr.Zero;

			private string _path;

			public string Path => _path;

			public ApplicationPathLock(IStore s, IntPtr c, string path)
			{
				_pSourceStore = s;
				_pLockCookie = c;
				_path = path;
			}

			[SecuritySafeCritical]
			private void Dispose(bool fDisposing)
			{
				if (fDisposing)
				{
					GC.SuppressFinalize(this);
				}
				if (_pLockCookie != IntPtr.Zero)
				{
					_pSourceStore.ReleaseApplicationPath(_pLockCookie);
					_pLockCookie = IntPtr.Zero;
				}
			}

			~ApplicationPathLock()
			{
				Dispose(fDisposing: false);
			}

			void IDisposable.Dispose()
			{
				Dispose(fDisposing: true);
			}
		}

		[Flags]
		public enum EnumCategoriesFlags
		{
			Nothing = 0
		}

		[Flags]
		public enum EnumSubcategoriesFlags
		{
			Nothing = 0
		}

		[Flags]
		public enum EnumCategoryInstancesFlags
		{
			Nothing = 0
		}

		[Flags]
		public enum GetPackagePropertyFlags
		{
			Nothing = 0
		}

		private IStore _pStore;

		public IStore InternalStore => _pStore;

		public Store(IStore pStore)
		{
			if (pStore == null)
			{
				throw new ArgumentNullException("pStore");
			}
			_pStore = pStore;
		}

		[SecuritySafeCritical]
		public uint[] Transact(StoreTransactionOperation[] operations)
		{
			if (operations == null || operations.Length == 0)
			{
				throw new ArgumentException("operations");
			}
			uint[] array = new uint[operations.Length];
			int[] rgResults = new int[operations.Length];
			_pStore.Transact(new IntPtr(operations.Length), operations, array, rgResults);
			return array;
		}

		public void Transact(StoreTransactionOperation[] operations, uint[] rgDispositions, int[] rgResults)
		{
			if (operations == null || operations.Length == 0)
			{
				throw new ArgumentException("operations");
			}
			_pStore.Transact(new IntPtr(operations.Length), operations, rgDispositions, rgResults);
		}

		[SecuritySafeCritical]
		public IDefinitionIdentity BindReferenceToAssemblyIdentity(uint Flags, IReferenceIdentity ReferenceIdentity, uint cDeploymentsToIgnore, IDefinitionIdentity[] DefinitionIdentity_DeploymentsToIgnore)
		{
			Guid riid = IsolationInterop.IID_IDefinitionIdentity;
			object obj = _pStore.BindReferenceToAssembly(Flags, ReferenceIdentity, cDeploymentsToIgnore, DefinitionIdentity_DeploymentsToIgnore, ref riid);
			return (IDefinitionIdentity)obj;
		}

		[SecuritySafeCritical]
		public void CalculateDelimiterOfDeploymentsBasedOnQuota(uint dwFlags, uint cDeployments, IDefinitionAppId[] rgpIDefinitionAppId_Deployments, ref StoreApplicationReference InstallerReference, ulong ulonglongQuota, ref uint Delimiter, ref ulong SizeSharedWithExternalDeployment, ref ulong SizeConsumedByInputDeploymentArray)
		{
			IntPtr Delimiter2 = IntPtr.Zero;
			_pStore.CalculateDelimiterOfDeploymentsBasedOnQuota(dwFlags, new IntPtr(cDeployments), rgpIDefinitionAppId_Deployments, ref InstallerReference, ulonglongQuota, ref Delimiter2, ref SizeSharedWithExternalDeployment, ref SizeConsumedByInputDeploymentArray);
			Delimiter = (uint)Delimiter2.ToInt64();
		}

		[SecuritySafeCritical]
		public System.Deployment.Internal.Isolation.Manifest.ICMS BindReferenceToAssemblyManifest(uint Flags, IReferenceIdentity ReferenceIdentity, uint cDeploymentsToIgnore, IDefinitionIdentity[] DefinitionIdentity_DeploymentsToIgnore)
		{
			Guid riid = IsolationInterop.IID_ICMS;
			object obj = _pStore.BindReferenceToAssembly(Flags, ReferenceIdentity, cDeploymentsToIgnore, DefinitionIdentity_DeploymentsToIgnore, ref riid);
			return (System.Deployment.Internal.Isolation.Manifest.ICMS)obj;
		}

		[SecuritySafeCritical]
		public System.Deployment.Internal.Isolation.Manifest.ICMS GetAssemblyManifest(uint Flags, IDefinitionIdentity DefinitionIdentity)
		{
			Guid riid = IsolationInterop.IID_ICMS;
			object assemblyInformation = _pStore.GetAssemblyInformation(Flags, DefinitionIdentity, ref riid);
			return (System.Deployment.Internal.Isolation.Manifest.ICMS)assemblyInformation;
		}

		[SecuritySafeCritical]
		public IDefinitionIdentity GetAssemblyIdentity(uint Flags, IDefinitionIdentity DefinitionIdentity)
		{
			Guid riid = IsolationInterop.IID_IDefinitionIdentity;
			object assemblyInformation = _pStore.GetAssemblyInformation(Flags, DefinitionIdentity, ref riid);
			return (IDefinitionIdentity)assemblyInformation;
		}

		public StoreAssemblyEnumeration EnumAssemblies(EnumAssembliesFlags Flags)
		{
			return EnumAssemblies(Flags, null);
		}

		[SecuritySafeCritical]
		public StoreAssemblyEnumeration EnumAssemblies(EnumAssembliesFlags Flags, IReferenceIdentity refToMatch)
		{
			Guid riid = IsolationInterop.GetGuidOfType(typeof(IEnumSTORE_ASSEMBLY));
			object obj = _pStore.EnumAssemblies((uint)Flags, refToMatch, ref riid);
			return new StoreAssemblyEnumeration((IEnumSTORE_ASSEMBLY)obj);
		}

		[SecuritySafeCritical]
		public StoreAssemblyFileEnumeration EnumFiles(EnumAssemblyFilesFlags Flags, IDefinitionIdentity Assembly)
		{
			Guid riid = IsolationInterop.GetGuidOfType(typeof(IEnumSTORE_ASSEMBLY_FILE));
			object obj = _pStore.EnumFiles((uint)Flags, Assembly, ref riid);
			return new StoreAssemblyFileEnumeration((IEnumSTORE_ASSEMBLY_FILE)obj);
		}

		[SecuritySafeCritical]
		public StoreAssemblyFileEnumeration EnumPrivateFiles(EnumApplicationPrivateFiles Flags, IDefinitionAppId Application, IDefinitionIdentity Assembly)
		{
			Guid riid = IsolationInterop.GetGuidOfType(typeof(IEnumSTORE_ASSEMBLY_FILE));
			object obj = _pStore.EnumPrivateFiles((uint)Flags, Application, Assembly, ref riid);
			return new StoreAssemblyFileEnumeration((IEnumSTORE_ASSEMBLY_FILE)obj);
		}

		[SecuritySafeCritical]
		public IEnumSTORE_ASSEMBLY_INSTALLATION_REFERENCE EnumInstallationReferences(EnumAssemblyInstallReferenceFlags Flags, IDefinitionIdentity Assembly)
		{
			Guid riid = IsolationInterop.GetGuidOfType(typeof(IEnumSTORE_ASSEMBLY_INSTALLATION_REFERENCE));
			object obj = _pStore.EnumInstallationReferences((uint)Flags, Assembly, ref riid);
			return (IEnumSTORE_ASSEMBLY_INSTALLATION_REFERENCE)obj;
		}

		[SecuritySafeCritical]
		public IPathLock LockAssemblyPath(IDefinitionIdentity asm)
		{
			IntPtr Cookie;
			string path = _pStore.LockAssemblyPath(0u, asm, out Cookie);
			return new AssemblyPathLock(_pStore, Cookie, path);
		}

		[SecuritySafeCritical]
		public IPathLock LockApplicationPath(IDefinitionAppId app)
		{
			IntPtr Cookie;
			string path = _pStore.LockApplicationPath(0u, app, out Cookie);
			return new ApplicationPathLock(_pStore, Cookie, path);
		}

		[SecuritySafeCritical]
		public ulong QueryChangeID(IDefinitionIdentity asm)
		{
			return _pStore.QueryChangeID(asm);
		}

		[SecuritySafeCritical]
		public StoreCategoryEnumeration EnumCategories(EnumCategoriesFlags Flags, IReferenceIdentity CategoryMatch)
		{
			Guid riid = IsolationInterop.GetGuidOfType(typeof(IEnumSTORE_CATEGORY));
			object obj = _pStore.EnumCategories((uint)Flags, CategoryMatch, ref riid);
			return new StoreCategoryEnumeration((IEnumSTORE_CATEGORY)obj);
		}

		public StoreSubcategoryEnumeration EnumSubcategories(EnumSubcategoriesFlags Flags, IDefinitionIdentity CategoryMatch)
		{
			return EnumSubcategories(Flags, CategoryMatch, null);
		}

		[SecuritySafeCritical]
		public StoreSubcategoryEnumeration EnumSubcategories(EnumSubcategoriesFlags Flags, IDefinitionIdentity Category, string SearchPattern)
		{
			Guid riid = IsolationInterop.GetGuidOfType(typeof(IEnumSTORE_CATEGORY_SUBCATEGORY));
			object obj = _pStore.EnumSubcategories((uint)Flags, Category, SearchPattern, ref riid);
			return new StoreSubcategoryEnumeration((IEnumSTORE_CATEGORY_SUBCATEGORY)obj);
		}

		[SecuritySafeCritical]
		public StoreCategoryInstanceEnumeration EnumCategoryInstances(EnumCategoryInstancesFlags Flags, IDefinitionIdentity Category, string SubCat)
		{
			Guid riid = IsolationInterop.GetGuidOfType(typeof(IEnumSTORE_CATEGORY_INSTANCE));
			object obj = _pStore.EnumCategoryInstances((uint)Flags, Category, SubCat, ref riid);
			return new StoreCategoryInstanceEnumeration((IEnumSTORE_CATEGORY_INSTANCE)obj);
		}

		[SecurityCritical]
		public byte[] GetDeploymentProperty(GetPackagePropertyFlags Flags, IDefinitionAppId Deployment, StoreApplicationReference Reference, Guid PropertySet, string PropertyName)
		{
			BLOB blob = default(BLOB);
			byte[] array = null;
			try
			{
				_pStore.GetDeploymentProperty((uint)Flags, Deployment, ref Reference, ref PropertySet, PropertyName, out blob);
				array = new byte[blob.Size];
				Marshal.Copy(blob.BlobData, array, 0, (int)blob.Size);
				return array;
			}
			finally
			{
				blob.Dispose();
			}
		}

		[SecuritySafeCritical]
		public StoreDeploymentMetadataEnumeration EnumInstallerDeployments(Guid InstallerId, string InstallerName, string InstallerMetadata, IReferenceAppId DeploymentFilter)
		{
			object obj = null;
			StoreApplicationReference Reference = new StoreApplicationReference(InstallerId, InstallerName, InstallerMetadata);
			obj = _pStore.EnumInstallerDeploymentMetadata(0u, ref Reference, DeploymentFilter, ref IsolationInterop.IID_IEnumSTORE_DEPLOYMENT_METADATA);
			return new StoreDeploymentMetadataEnumeration((IEnumSTORE_DEPLOYMENT_METADATA)obj);
		}

		[SecuritySafeCritical]
		public StoreDeploymentMetadataPropertyEnumeration EnumInstallerDeploymentProperties(Guid InstallerId, string InstallerName, string InstallerMetadata, IDefinitionAppId Deployment)
		{
			object obj = null;
			StoreApplicationReference Reference = new StoreApplicationReference(InstallerId, InstallerName, InstallerMetadata);
			obj = _pStore.EnumInstallerDeploymentMetadataProperties(0u, ref Reference, Deployment, ref IsolationInterop.IID_IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY);
			return new StoreDeploymentMetadataPropertyEnumeration((IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY)obj);
		}
	}
	internal struct IStore_BindingResult_BoundVersion
	{
		[MarshalAs(UnmanagedType.U2)]
		public ushort Revision;

		[MarshalAs(UnmanagedType.U2)]
		public ushort Build;

		[MarshalAs(UnmanagedType.U2)]
		public ushort Minor;

		[MarshalAs(UnmanagedType.U2)]
		public ushort Major;
	}
	internal struct IStore_BindingResult
	{
		[MarshalAs(UnmanagedType.U4)]
		public uint Flags;

		[MarshalAs(UnmanagedType.U4)]
		public uint Disposition;

		public IStore_BindingResult_BoundVersion Component;

		public Guid CacheCoherencyGuid;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr Reserved;
	}
	[ComImport]
	[Guid("a5c62f6d-5e3e-4cd9-b345-6b281d7a1d1e")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IStore
	{
		[SecurityCritical]
		void Transact([In] IntPtr cOperation, [In][MarshalAs(UnmanagedType.LPArray)] StoreTransactionOperation[] rgOperations, [Out][MarshalAs(UnmanagedType.LPArray)] uint[] rgDispositions, [Out][MarshalAs(UnmanagedType.LPArray)] int[] rgResults);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object BindReferenceToAssembly([In] uint Flags, [In] IReferenceIdentity ReferenceIdentity, [In] uint cDeploymentsToIgnore, [In][MarshalAs(UnmanagedType.LPArray)] IDefinitionIdentity[] DefinitionIdentity_DeploymentsToIgnore, [In] ref Guid riid);

		[SecurityCritical]
		void CalculateDelimiterOfDeploymentsBasedOnQuota([In] uint dwFlags, [In] IntPtr cDeployments, [In][MarshalAs(UnmanagedType.LPArray)] IDefinitionAppId[] rgpIDefinitionAppId_Deployments, [In] ref StoreApplicationReference InstallerReference, [In] ulong ulonglongQuota, [In][Out] ref IntPtr Delimiter, [In][Out] ref ulong SizeSharedWithExternalDeployment, [In][Out] ref ulong SizeConsumedByInputDeploymentArray);

		[SecurityCritical]
		IntPtr BindDefinitions([In] uint Flags, [In][MarshalAs(UnmanagedType.SysInt)] IntPtr Count, [In][MarshalAs(UnmanagedType.LPArray)] IDefinitionIdentity[] DefsToBind, [In] uint DeploymentsToIgnore, [In][MarshalAs(UnmanagedType.LPArray)] IDefinitionIdentity[] DefsToIgnore);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object GetAssemblyInformation([In] uint Flags, [In] IDefinitionIdentity DefinitionIdentity, [In] ref Guid riid);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object EnumAssemblies([In] uint Flags, [In] IReferenceIdentity ReferenceIdentity_ToMatch, [In] ref Guid riid);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object EnumFiles([In] uint Flags, [In] IDefinitionIdentity DefinitionIdentity, [In] ref Guid riid);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object EnumInstallationReferences([In] uint Flags, [In] IDefinitionIdentity DefinitionIdentity, [In] ref Guid riid);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string LockAssemblyPath([In] uint Flags, [In] IDefinitionIdentity DefinitionIdentity, out IntPtr Cookie);

		[SecurityCritical]
		void ReleaseAssemblyPath([In] IntPtr Cookie);

		[SecurityCritical]
		ulong QueryChangeID([In] IDefinitionIdentity DefinitionIdentity);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object EnumCategories([In] uint Flags, [In] IReferenceIdentity ReferenceIdentity_ToMatch, [In] ref Guid riid);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object EnumSubcategories([In] uint Flags, [In] IDefinitionIdentity CategoryId, [In][MarshalAs(UnmanagedType.LPWStr)] string SubcategoryPathPattern, [In] ref Guid riid);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object EnumCategoryInstances([In] uint Flags, [In] IDefinitionIdentity CategoryId, [In][MarshalAs(UnmanagedType.LPWStr)] string SubcategoryPath, [In] ref Guid riid);

		[SecurityCritical]
		void GetDeploymentProperty([In] uint Flags, [In] IDefinitionAppId DeploymentInPackage, [In] ref StoreApplicationReference Reference, [In] ref Guid PropertySet, [In][MarshalAs(UnmanagedType.LPWStr)] string pcwszPropertyName, out BLOB blob);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.LPWStr)]
		string LockApplicationPath([In] uint Flags, [In] IDefinitionAppId ApId, out IntPtr Cookie);

		[SecurityCritical]
		void ReleaseApplicationPath([In] IntPtr Cookie);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object EnumPrivateFiles([In] uint Flags, [In] IDefinitionAppId Application, [In] IDefinitionIdentity DefinitionIdentity, [In] ref Guid riid);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object EnumInstallerDeploymentMetadata([In] uint Flags, [In] ref StoreApplicationReference Reference, [In] IReferenceAppId Filter, [In] ref Guid riid);

		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		object EnumInstallerDeploymentMetadataProperties([In] uint Flags, [In] ref StoreApplicationReference Reference, [In] IDefinitionAppId Filter, [In] ref Guid riid);
	}
	internal class StoreTransaction : IDisposable
	{
		private ArrayList _list = new ArrayList();

		private StoreTransactionOperation[] _storeOps;

		public StoreTransactionOperation[] Operations
		{
			get
			{
				if (_storeOps == null)
				{
					_storeOps = GenerateStoreOpsList();
				}
				return _storeOps;
			}
		}

		public void Add(StoreOperationInstallDeployment o)
		{
			_list.Add(o);
		}

		public void Add(StoreOperationPinDeployment o)
		{
			_list.Add(o);
		}

		public void Add(StoreOperationSetCanonicalizationContext o)
		{
			_list.Add(o);
		}

		public void Add(StoreOperationSetDeploymentMetadata o)
		{
			_list.Add(o);
		}

		public void Add(StoreOperationStageComponent o)
		{
			_list.Add(o);
		}

		public void Add(StoreOperationStageComponentFile o)
		{
			_list.Add(o);
		}

		public void Add(StoreOperationUninstallDeployment o)
		{
			_list.Add(o);
		}

		public void Add(StoreOperationUnpinDeployment o)
		{
			_list.Add(o);
		}

		public void Add(StoreOperationScavenge o)
		{
			_list.Add(o);
		}

		~StoreTransaction()
		{
			Dispose(fDisposing: false);
		}

		void IDisposable.Dispose()
		{
			Dispose(fDisposing: true);
		}

		[SecuritySafeCritical]
		private void Dispose(bool fDisposing)
		{
			if (fDisposing)
			{
				GC.SuppressFinalize(this);
			}
			StoreTransactionOperation[] storeOps = _storeOps;
			_storeOps = null;
			if (storeOps == null)
			{
				return;
			}
			for (int i = 0; i != storeOps.Length; i++)
			{
				StoreTransactionOperation storeTransactionOperation = storeOps[i];
				if (storeTransactionOperation.Data.DataPtr != IntPtr.Zero)
				{
					switch (storeTransactionOperation.Operation)
					{
					case StoreTransactionOperationType.StageComponent:
						Marshal.DestroyStructure(storeTransactionOperation.Data.DataPtr, typeof(StoreOperationStageComponent));
						break;
					case StoreTransactionOperationType.StageComponentFile:
						Marshal.DestroyStructure(storeTransactionOperation.Data.DataPtr, typeof(StoreOperationStageComponentFile));
						break;
					case StoreTransactionOperationType.PinDeployment:
						Marshal.DestroyStructure(storeTransactionOperation.Data.DataPtr, typeof(StoreOperationPinDeployment));
						break;
					case StoreTransactionOperationType.UninstallDeployment:
						Marshal.DestroyStructure(storeTransactionOperation.Data.DataPtr, typeof(StoreOperationUninstallDeployment));
						break;
					case StoreTransactionOperationType.UnpinDeployment:
						Marshal.DestroyStructure(storeTransactionOperation.Data.DataPtr, typeof(StoreOperationUnpinDeployment));
						break;
					case StoreTransactionOperationType.InstallDeployment:
						Marshal.DestroyStructure(storeTransactionOperation.Data.DataPtr, typeof(StoreOperationInstallDeployment));
						break;
					case StoreTransactionOperationType.SetCanonicalizationContext:
						Marshal.DestroyStructure(storeTransactionOperation.Data.DataPtr, typeof(StoreOperationSetCanonicalizationContext));
						break;
					case StoreTransactionOperationType.SetDeploymentMetadata:
						Marshal.DestroyStructure(storeTransactionOperation.Data.DataPtr, typeof(StoreOperationSetDeploymentMetadata));
						break;
					case StoreTransactionOperationType.Scavenge:
						Marshal.DestroyStructure(storeTransactionOperation.Data.DataPtr, typeof(StoreOperationScavenge));
						break;
					}
					Marshal.FreeCoTaskMem(storeTransactionOperation.Data.DataPtr);
				}
			}
		}

		[SecuritySafeCritical]
		private StoreTransactionOperation[] GenerateStoreOpsList()
		{
			StoreTransactionOperation[] array = new StoreTransactionOperation[_list.Count];
			for (int i = 0; i != _list.Count; i++)
			{
				object obj = _list[i];
				Type type = obj.GetType();
				array[i].Data.DataPtr = Marshal.AllocCoTaskMem(Marshal.SizeOf(obj));
				Marshal.StructureToPtr(obj, array[i].Data.DataPtr, fDeleteOld: false);
				if (type == typeof(StoreOperationSetCanonicalizationContext))
				{
					array[i].Operation = StoreTransactionOperationType.SetCanonicalizationContext;
					continue;
				}
				if (type == typeof(StoreOperationStageComponent))
				{
					array[i].Operation = StoreTransactionOperationType.StageComponent;
					continue;
				}
				if (type == typeof(StoreOperationPinDeployment))
				{
					array[i].Operation = StoreTransactionOperationType.PinDeployment;
					continue;
				}
				if (type == typeof(StoreOperationUnpinDeployment))
				{
					array[i].Operation = StoreTransactionOperationType.UnpinDeployment;
					continue;
				}
				if (type == typeof(StoreOperationStageComponentFile))
				{
					array[i].Operation = StoreTransactionOperationType.StageComponentFile;
					continue;
				}
				if (type == typeof(StoreOperationInstallDeployment))
				{
					array[i].Operation = StoreTransactionOperationType.InstallDeployment;
					continue;
				}
				if (type == typeof(StoreOperationUninstallDeployment))
				{
					array[i].Operation = StoreTransactionOperationType.UninstallDeployment;
					continue;
				}
				if (type == typeof(StoreOperationSetDeploymentMetadata))
				{
					array[i].Operation = StoreTransactionOperationType.SetDeploymentMetadata;
					continue;
				}
				if (type == typeof(StoreOperationScavenge))
				{
					array[i].Operation = StoreTransactionOperationType.Scavenge;
					continue;
				}
				throw new Exception("How did you get here?");
			}
			return array;
		}
	}
	[ComImport]
	[Guid("ace1b703-1aac-4956-ab87-90cac8b93ce6")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IManifestParseErrorCallback
	{
		[SecurityCritical]
		void OnError([In] uint StartLine, [In] uint nStartColumn, [In] uint cCharacterCount, [In] int hr, [In][MarshalAs(UnmanagedType.LPWStr)] string ErrorStatusHostFile, [In] uint ParameterCount, [In][MarshalAs(UnmanagedType.LPArray)] string[] Parameters);
	}
	internal static class IsolationInterop
	{
		internal struct CreateActContextParameters
		{
			[Flags]
			public enum CreateFlags
			{
				Nothing = 0,
				StoreListValid = 1,
				CultureListValid = 2,
				ProcessorFallbackListValid = 4,
				ProcessorValid = 8,
				SourceValid = 0x10,
				IgnoreVisibility = 0x20
			}

			[MarshalAs(UnmanagedType.U4)]
			public uint Size;

			[MarshalAs(UnmanagedType.U4)]
			public uint Flags;

			[MarshalAs(UnmanagedType.SysInt)]
			public IntPtr CustomStoreList;

			[MarshalAs(UnmanagedType.SysInt)]
			public IntPtr CultureFallbackList;

			[MarshalAs(UnmanagedType.SysInt)]
			public IntPtr ProcessorArchitectureList;

			[MarshalAs(UnmanagedType.SysInt)]
			public IntPtr Source;

			[MarshalAs(UnmanagedType.U2)]
			public ushort ProcArch;
		}

		internal struct CreateActContextParametersSource
		{
			[Flags]
			public enum SourceFlags
			{
				Definition = 1,
				Reference = 2
			}

			[MarshalAs(UnmanagedType.U4)]
			public uint Size;

			[MarshalAs(UnmanagedType.U4)]
			public uint Flags;

			[MarshalAs(UnmanagedType.U4)]
			public uint SourceType;

			[MarshalAs(UnmanagedType.SysInt)]
			public IntPtr Data;

			[SecurityCritical]
			public IntPtr ToIntPtr()
			{
				IntPtr intPtr = Marshal.AllocCoTaskMem(Marshal.SizeOf((object)this));
				Marshal.StructureToPtr((object)this, intPtr, fDeleteOld: false);
				return intPtr;
			}

			[SecurityCritical]
			public static void Destroy(IntPtr p)
			{
				Marshal.DestroyStructure(p, typeof(CreateActContextParametersSource));
				Marshal.FreeCoTaskMem(p);
			}
		}

		internal struct CreateActContextParametersSourceReferenceAppid
		{
			[MarshalAs(UnmanagedType.U4)]
			public uint Size;

			[MarshalAs(UnmanagedType.U4)]
			public uint Flags;

			public IReferenceAppId AppId;

			public IntPtr ToIntPtr()
			{
				IntPtr intPtr = Marshal.AllocCoTaskMem(Marshal.SizeOf((object)this));
				Marshal.StructureToPtr((object)this, intPtr, fDeleteOld: false);
				return intPtr;
			}

			public static void Destroy(IntPtr p)
			{
				Marshal.DestroyStructure(p, typeof(CreateActContextParametersSourceReferenceAppid));
				Marshal.FreeCoTaskMem(p);
			}
		}

		internal struct CreateActContextParametersSourceDefinitionAppid
		{
			[MarshalAs(UnmanagedType.U4)]
			public uint Size;

			[MarshalAs(UnmanagedType.U4)]
			public uint Flags;

			public IDefinitionAppId AppId;

			[SecurityCritical]
			public IntPtr ToIntPtr()
			{
				IntPtr intPtr = Marshal.AllocCoTaskMem(Marshal.SizeOf((object)this));
				Marshal.StructureToPtr((object)this, intPtr, fDeleteOld: false);
				return intPtr;
			}

			[SecurityCritical]
			public static void Destroy(IntPtr p)
			{
				Marshal.DestroyStructure(p, typeof(CreateActContextParametersSourceDefinitionAppid));
				Marshal.FreeCoTaskMem(p);
			}
		}

		private static object _synchObject = new object();

		private static Store _userStore = null;

		private static Store _systemStore = null;

		private static volatile IIdentityAuthority _idAuth = null;

		private static volatile IAppIdAuthority _appIdAuth = null;

		public const string IsolationDllName = "clr.dll";

		public static Guid IID_ICMS = GetGuidOfType(typeof(System.Deployment.Internal.Isolation.Manifest.ICMS));

		public static Guid IID_IDefinitionIdentity = GetGuidOfType(typeof(IDefinitionIdentity));

		public static Guid IID_IManifestInformation = GetGuidOfType(typeof(IManifestInformation));

		public static Guid IID_IEnumSTORE_ASSEMBLY = GetGuidOfType(typeof(IEnumSTORE_ASSEMBLY));

		public static Guid IID_IEnumSTORE_ASSEMBLY_FILE = GetGuidOfType(typeof(IEnumSTORE_ASSEMBLY_FILE));

		public static Guid IID_IEnumSTORE_CATEGORY = GetGuidOfType(typeof(IEnumSTORE_CATEGORY));

		public static Guid IID_IEnumSTORE_CATEGORY_INSTANCE = GetGuidOfType(typeof(IEnumSTORE_CATEGORY_INSTANCE));

		public static Guid IID_IEnumSTORE_DEPLOYMENT_METADATA = GetGuidOfType(typeof(IEnumSTORE_DEPLOYMENT_METADATA));

		public static Guid IID_IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY = GetGuidOfType(typeof(IEnumSTORE_DEPLOYMENT_METADATA_PROPERTY));

		public static Guid IID_IStore = GetGuidOfType(typeof(IStore));

		public static Guid GUID_SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING = new Guid("2ec93463-b0c3-45e1-8364-327e96aea856");

		public static Guid SXS_INSTALL_REFERENCE_SCHEME_SXS_STRONGNAME_SIGNED_PRIVATE_ASSEMBLY = new Guid("3ab20ac0-67e8-4512-8385-a487e35df3da");

		public static Store UserStore
		{
			get
			{
				if (_userStore == null)
				{
					lock (_synchObject)
					{
						if (_userStore == null)
						{
							_userStore = new Store(GetUserStore(0u, IntPtr.Zero, ref IID_IStore) as IStore);
						}
					}
				}
				return _userStore;
			}
		}

		public static Store SystemStore
		{
			get
			{
				if (_systemStore == null)
				{
					lock (_synchObject)
					{
						if (_systemStore == null)
						{
							_systemStore = new Store(GetSystemStore(0u, ref IID_IStore) as IStore);
						}
					}
				}
				return _systemStore;
			}
		}

		public static IIdentityAuthority IdentityAuthority
		{
			[SecuritySafeCritical]
			get
			{
				if (_idAuth == null)
				{
					lock (_synchObject)
					{
						if (_idAuth == null)
						{
							_idAuth = GetIdentityAuthority();
						}
					}
				}
				return _idAuth;
			}
		}

		public static IAppIdAuthority AppIdAuthority
		{
			[SecuritySafeCritical]
			get
			{
				if (_appIdAuth == null)
				{
					lock (_synchObject)
					{
						if (_appIdAuth == null)
						{
							_appIdAuth = GetAppIdAuthority();
						}
					}
				}
				return _appIdAuth;
			}
		}

		[SecuritySafeCritical]
		public static Store GetUserStore()
		{
			return new Store(GetUserStore(0u, IntPtr.Zero, ref IID_IStore) as IStore);
		}

		[SecuritySafeCritical]
		internal static IActContext CreateActContext(IDefinitionAppId AppId)
		{
			CreateActContextParameters Params = default(CreateActContextParameters);
			Params.Size = (uint)Marshal.SizeOf(typeof(CreateActContextParameters));
			Params.Flags = 16u;
			Params.CustomStoreList = IntPtr.Zero;
			Params.CultureFallbackList = IntPtr.Zero;
			Params.ProcessorArchitectureList = IntPtr.Zero;
			Params.Source = IntPtr.Zero;
			Params.ProcArch = 0;
			CreateActContextParametersSource createActContextParametersSource = default(CreateActContextParametersSource);
			createActContextParametersSource.Size = (uint)Marshal.SizeOf(typeof(CreateActContextParametersSource));
			createActContextParametersSource.Flags = 0u;
			createActContextParametersSource.SourceType = 1u;
			createActContextParametersSource.Data = IntPtr.Zero;
			CreateActContextParametersSourceDefinitionAppid createActContextParametersSourceDefinitionAppid = default(CreateActContextParametersSourceDefinitionAppid);
			createActContextParametersSourceDefinitionAppid.Size = (uint)Marshal.SizeOf(typeof(CreateActContextParametersSourceDefinitionAppid));
			createActContextParametersSourceDefinitionAppid.Flags = 0u;
			createActContextParametersSourceDefinitionAppid.AppId = AppId;
			try
			{
				createActContextParametersSource.Data = createActContextParametersSourceDefinitionAppid.ToIntPtr();
				Params.Source = createActContextParametersSource.ToIntPtr();
				return CreateActContext(ref Params) as IActContext;
			}
			finally
			{
				if (createActContextParametersSource.Data != IntPtr.Zero)
				{
					CreateActContextParametersSourceDefinitionAppid.Destroy(createActContextParametersSource.Data);
					createActContextParametersSource.Data = IntPtr.Zero;
				}
				if (Params.Source != IntPtr.Zero)
				{
					CreateActContextParametersSource.Destroy(Params.Source);
					Params.Source = IntPtr.Zero;
				}
			}
		}

		internal static IActContext CreateActContext(IReferenceAppId AppId)
		{
			CreateActContextParameters Params = default(CreateActContextParameters);
			Params.Size = (uint)Marshal.SizeOf(typeof(CreateActContextParameters));
			Params.Flags = 16u;
			Params.CustomStoreList = IntPtr.Zero;
			Params.CultureFallbackList = IntPtr.Zero;
			Params.ProcessorArchitectureList = IntPtr.Zero;
			Params.Source = IntPtr.Zero;
			Params.ProcArch = 0;
			CreateActContextParametersSource createActContextParametersSource = default(CreateActContextParametersSource);
			createActContextParametersSource.Size = (uint)Marshal.SizeOf(typeof(CreateActContextParametersSource));
			createActContextParametersSource.Flags = 0u;
			createActContextParametersSource.SourceType = 2u;
			createActContextParametersSource.Data = IntPtr.Zero;
			CreateActContextParametersSourceReferenceAppid createActContextParametersSourceReferenceAppid = default(CreateActContextParametersSourceReferenceAppid);
			createActContextParametersSourceReferenceAppid.Size = (uint)Marshal.SizeOf(typeof(CreateActContextParametersSourceReferenceAppid));
			createActContextParametersSourceReferenceAppid.Flags = 0u;
			createActContextParametersSourceReferenceAppid.AppId = AppId;
			try
			{
				createActContextParametersSource.Data = createActContextParametersSourceReferenceAppid.ToIntPtr();
				Params.Source = createActContextParametersSource.ToIntPtr();
				return CreateActContext(ref Params) as IActContext;
			}
			finally
			{
				if (createActContextParametersSource.Data != IntPtr.Zero)
				{
					CreateActContextParametersSourceDefinitionAppid.Destroy(createActContextParametersSource.Data);
					createActContextParametersSource.Data = IntPtr.Zero;
				}
				if (Params.Source != IntPtr.Zero)
				{
					CreateActContextParametersSource.Destroy(Params.Source);
					Params.Source = IntPtr.Zero;
				}
			}
		}

		[DllImport("clr.dll", PreserveSig = false)]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		internal static extern object CreateActContext(ref CreateActContextParameters Params);

		[DllImport("clr.dll", PreserveSig = false)]
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		internal static extern object CreateCMSFromXml([In] byte[] buffer, [In] uint bufferSize, [In] IManifestParseErrorCallback Callback, [In] ref Guid riid);

		[DllImport("clr.dll", PreserveSig = false)]
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		internal static extern object ParseManifest([In][MarshalAs(UnmanagedType.LPWStr)] string pszManifestPath, [In] IManifestParseErrorCallback pIManifestParseErrorCallback, [In] ref Guid riid);

		[DllImport("clr.dll", PreserveSig = false)]
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		private static extern object GetUserStore([In] uint Flags, [In] IntPtr hToken, [In] ref Guid riid);

		[DllImport("clr.dll", PreserveSig = false)]
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		private static extern object GetSystemStore([In] uint Flags, [In] ref Guid riid);

		[DllImport("clr.dll", PreserveSig = false)]
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Interface)]
		private static extern IIdentityAuthority GetIdentityAuthority();

		[DllImport("clr.dll", PreserveSig = false)]
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Interface)]
		private static extern IAppIdAuthority GetAppIdAuthority();

		[DllImport("clr.dll", PreserveSig = false)]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		internal static extern object GetUserStateManager([In] uint Flags, [In] IntPtr hToken, [In] ref Guid riid);

		internal static Guid GetGuidOfType(Type type)
		{
			GuidAttribute guidAttribute = (GuidAttribute)Attribute.GetCustomAttribute(type, typeof(GuidAttribute), inherit: false);
			return new Guid(guidAttribute.Value);
		}
	}
	internal class ApplicationContext
	{
		public enum ApplicationState
		{
			Undefined,
			Starting,
			Running
		}

		public enum ApplicationStateDisposition
		{
			Undefined = 0,
			Starting = 1,
			Starting_Migrated = 65537,
			Running = 2,
			Running_FirstTime = 131074
		}

		private IActContext _appcontext;

		public DefinitionAppId Identity
		{
			get
			{
				_appcontext.GetAppId(out var AppId);
				return new DefinitionAppId(AppId as IDefinitionAppId);
			}
		}

		public string BasePath
		{
			get
			{
				_appcontext.ApplicationBasePath(0u, out var ApplicationPath);
				return ApplicationPath;
			}
		}

		public EnumDefinitionIdentity Components
		{
			get
			{
				_appcontext.EnumComponents(0u, out var ppIdentityEnum);
				return new EnumDefinitionIdentity(ppIdentityEnum as IEnumDefinitionIdentity);
			}
		}

		public string StateLocation
		{
			get
			{
				_appcontext.GetApplicationStateFilesystemLocation(0u, UIntPtr.Zero, IntPtr.Zero, out var ppszPath);
				return ppszPath;
			}
		}

		internal ApplicationContext(IActContext a)
		{
			if (a == null)
			{
				throw new ArgumentNullException();
			}
			_appcontext = a;
		}

		public ApplicationContext(DefinitionAppId appid)
		{
			if (appid == null)
			{
				throw new ArgumentNullException();
			}
			_appcontext = IsolationInterop.CreateActContext(appid._id);
		}

		public ApplicationContext(ReferenceAppId appid)
		{
			if (appid == null)
			{
				throw new ArgumentNullException();
			}
			_appcontext = IsolationInterop.CreateActContext(appid._id);
		}

		public string ReplaceStrings(string culture, string toreplace)
		{
			_appcontext.ReplaceStringMacros(0u, culture, toreplace, out var Replaced);
			return Replaced;
		}

		internal System.Deployment.Internal.Isolation.Manifest.ICMS GetComponentManifest(DefinitionIdentity component)
		{
			_appcontext.GetComponentManifest(0u, component._id, ref IsolationInterop.IID_ICMS, out var ManifestInteface);
			return ManifestInteface as System.Deployment.Internal.Isolation.Manifest.ICMS;
		}

		internal string GetComponentManifestPath(DefinitionIdentity component)
		{
			_appcontext.GetComponentManifest(0u, component._id, ref IsolationInterop.IID_IManifestInformation, out var ManifestInteface);
			((IManifestInformation)ManifestInteface).get_FullPath(out var FullPath);
			return FullPath;
		}

		public string GetComponentPath(DefinitionIdentity component)
		{
			_appcontext.GetComponentPayloadPath(0u, component._id, out var PayloadPath);
			return PayloadPath;
		}

		public DefinitionIdentity MatchReference(ReferenceIdentity TheRef)
		{
			_appcontext.FindReferenceInContext(0u, TheRef._id, out var MatchedDefinition);
			return new DefinitionIdentity(MatchedDefinition as IDefinitionIdentity);
		}

		public void PrepareForExecution()
		{
			_appcontext.PrepareForExecution(IntPtr.Zero, IntPtr.Zero);
		}

		public ApplicationStateDisposition SetApplicationState(ApplicationState s)
		{
			_appcontext.SetApplicationRunningState(0u, (uint)s, out var ulDisposition);
			return (ApplicationStateDisposition)ulDisposition;
		}
	}
	[ComImport]
	[Guid("81c85208-fe61-4c15-b5bb-ff5ea66baad9")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IManifestInformation
	{
		[SecurityCritical]
		void get_FullPath([MarshalAs(UnmanagedType.LPWStr)] out string FullPath);
	}
	[ComImport]
	[Guid("0af57545-a72a-4fbe-813c-8554ed7d4528")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IActContext
	{
		[SecurityCritical]
		void GetAppId([MarshalAs(UnmanagedType.Interface)] out object AppId);

		[SecurityCritical]
		void EnumCategories([In] uint Flags, [In] IReferenceIdentity CategoryToMatch, [In] ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out object EnumOut);

		[SecurityCritical]
		void EnumSubcategories([In] uint Flags, [In] IDefinitionIdentity CategoryId, [In][MarshalAs(UnmanagedType.LPWStr)] string SubcategoryPattern, [In] ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out object EnumOut);

		[SecurityCritical]
		void EnumCategoryInstances([In] uint Flags, [In] IDefinitionIdentity CategoryId, [In][MarshalAs(UnmanagedType.LPWStr)] string Subcategory, [In] ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out object EnumOut);

		[SecurityCritical]
		void ReplaceStringMacros([In] uint Flags, [In][MarshalAs(UnmanagedType.LPWStr)] string Culture, [In][MarshalAs(UnmanagedType.LPWStr)] string ReplacementPattern, [MarshalAs(UnmanagedType.LPWStr)] out string Replaced);

		[SecurityCritical]
		void GetComponentStringTableStrings([In] uint Flags, [In][MarshalAs(UnmanagedType.SysUInt)] IntPtr ComponentIndex, [In][MarshalAs(UnmanagedType.SysUInt)] IntPtr StringCount, [Out][MarshalAs(UnmanagedType.LPArray)] string[] SourceStrings, [MarshalAs(UnmanagedType.LPArray)] out string[] DestinationStrings, [In][MarshalAs(UnmanagedType.SysUInt)] IntPtr CultureFallbacks);

		[SecurityCritical]
		void GetApplicationProperties([In] uint Flags, [In] UIntPtr cProperties, [In][MarshalAs(UnmanagedType.LPArray)] string[] PropertyNames, [MarshalAs(UnmanagedType.LPArray)] out string[] PropertyValues, [MarshalAs(UnmanagedType.LPArray)] out UIntPtr[] ComponentIndicies);

		[SecurityCritical]
		void ApplicationBasePath([In] uint Flags, [MarshalAs(UnmanagedType.LPWStr)] out string ApplicationPath);

		[SecurityCritical]
		void GetComponentManifest([In] uint Flags, [In] IDefinitionIdentity ComponentId, [In] ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out object ManifestInteface);

		[SecurityCritical]
		void GetComponentPayloadPath([In] uint Flags, [In] IDefinitionIdentity ComponentId, [MarshalAs(UnmanagedType.LPWStr)] out string PayloadPath);

		[SecurityCritical]
		void FindReferenceInContext([In] uint dwFlags, [In] IReferenceIdentity Reference, [MarshalAs(UnmanagedType.Interface)] out object MatchedDefinition);

		[SecurityCritical]
		void CreateActContextFromCategoryInstance([In] uint dwFlags, [In] ref CATEGORY_INSTANCE CategoryInstance, [MarshalAs(UnmanagedType.Interface)] out object ppCreatedAppContext);

		[SecurityCritical]
		void EnumComponents([In] uint dwFlags, [MarshalAs(UnmanagedType.Interface)] out object ppIdentityEnum);

		[SecurityCritical]
		void PrepareForExecution([In][MarshalAs(UnmanagedType.SysInt)] IntPtr Inputs, [In][MarshalAs(UnmanagedType.SysInt)] IntPtr Outputs);

		[SecurityCritical]
		void SetApplicationRunningState([In] uint dwFlags, [In] uint ulState, out uint ulDisposition);

		[SecurityCritical]
		void GetApplicationStateFilesystemLocation([In] uint dwFlags, [In] UIntPtr Component, [In][MarshalAs(UnmanagedType.SysInt)] IntPtr pCoordinateList, [MarshalAs(UnmanagedType.LPWStr)] out string ppszPath);

		[SecurityCritical]
		void FindComponentsByDefinition([In] uint dwFlags, [In] UIntPtr ComponentCount, [In][MarshalAs(UnmanagedType.LPArray)] IDefinitionIdentity[] Components, [Out][MarshalAs(UnmanagedType.LPArray)] UIntPtr[] Indicies, [Out][MarshalAs(UnmanagedType.LPArray)] uint[] Dispositions);

		[SecurityCritical]
		void FindComponentsByReference([In] uint dwFlags, [In] UIntPtr Components, [In][MarshalAs(UnmanagedType.LPArray)] IReferenceIdentity[] References, [Out][MarshalAs(UnmanagedType.LPArray)] UIntPtr[] Indicies, [Out][MarshalAs(UnmanagedType.LPArray)] uint[] Dispositions);
	}
	internal enum StateManager_RunningState
	{
		Undefined,
		Starting,
		Running
	}
	[ComImport]
	[Guid("07662534-750b-4ed5-9cfb-1c5bc5acfd07")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IStateManager
	{
		[SecurityCritical]
		void PrepareApplicationState([In] UIntPtr Inputs, ref UIntPtr Outputs);

		[SecurityCritical]
		void SetApplicationRunningState([In] uint Flags, [In] IActContext Context, [In] uint RunningState, out uint Disposition);

		[SecurityCritical]
		void GetApplicationStateFilesystemLocation([In] uint Flags, [In] IDefinitionAppId Appidentity, [In] IDefinitionIdentity ComponentIdentity, [In] UIntPtr Coordinates, [MarshalAs(UnmanagedType.LPWStr)] out string Path);

		[SecurityCritical]
		void Scavenge([In] uint Flags, out uint Disposition);
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("285a8862-c84a-11d7-850f-005cd062464f")]
	internal interface ISection
	{
		object _NewEnum
		{
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		uint Count { get; }

		uint SectionID { get; }

		string SectionName
		{
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("285a8871-c84a-11d7-850f-005cd062464f")]
	internal interface ISectionWithStringKey
	{
		bool IsCaseInsensitive { get; }

		void Lookup([MarshalAs(UnmanagedType.LPWStr)] string wzStringKey, [MarshalAs(UnmanagedType.Interface)] out object ppUnknown);
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("285a8876-c84a-11d7-850f-005cd062464f")]
	internal interface ISectionWithReferenceIdentityKey
	{
		void Lookup(IReferenceIdentity ReferenceIdentityKey, [MarshalAs(UnmanagedType.Interface)] out object ppUnknown);
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("285a8861-c84a-11d7-850f-005cd062464f")]
	internal interface ISectionEntry
	{
		object GetField(uint fieldId);

		string GetFieldName(uint fieldId);
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("00000100-0000-0000-C000-000000000046")]
	internal interface IEnumUnknown
	{
		[PreserveSig]
		int Next(uint celt, [Out][MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown)] object[] rgelt, ref uint celtFetched);

		[PreserveSig]
		int Skip(uint celt);

		[PreserveSig]
		int Reset();

		[PreserveSig]
		int Clone(out IEnumUnknown enumUnknown);
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("285a8860-c84a-11d7-850f-005cd062464f")]
	internal interface ICDF
	{
		object _NewEnum
		{
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		uint Count { get; }

		ISection GetRootSection(uint SectionId);

		ISectionEntry GetRootSectionEntry(uint SectionId);

		object GetItem(uint SectionId);
	}
}
namespace System.Deployment.Internal.Isolation.Manifest
{
	internal enum CMSSECTIONID
	{
		CMSSECTIONID_FILE_SECTION = 1,
		CMSSECTIONID_CATEGORY_INSTANCE_SECTION = 2,
		CMSSECTIONID_COM_REDIRECTION_SECTION = 3,
		CMSSECTIONID_PROGID_REDIRECTION_SECTION = 4,
		CMSSECTIONID_CLR_SURROGATE_SECTION = 5,
		CMSSECTIONID_ASSEMBLY_REFERENCE_SECTION = 6,
		CMSSECTIONID_WINDOW_CLASS_SECTION = 8,
		CMSSECTIONID_STRING_SECTION = 9,
		CMSSECTIONID_ENTRYPOINT_SECTION = 10,
		CMSSECTIONID_PERMISSION_SET_SECTION = 11,
		CMSSECTIONENTRYID_METADATA = 12,
		CMSSECTIONID_ASSEMBLY_REQUEST_SECTION = 13,
		CMSSECTIONID_REGISTRY_KEY_SECTION = 16,
		CMSSECTIONID_DIRECTORY_SECTION = 17,
		CMSSECTIONID_FILE_ASSOCIATION_SECTION = 18,
		CMSSECTIONID_COMPATIBLE_FRAMEWORKS_SECTION = 19,
		CMSSECTIONID_EVENT_SECTION = 101,
		CMSSECTIONID_EVENT_MAP_SECTION = 102,
		CMSSECTIONID_EVENT_TAG_SECTION = 103,
		CMSSECTIONID_COUNTERSET_SECTION = 110,
		CMSSECTIONID_COUNTER_SECTION = 111
	}
	internal enum CMS_ASSEMBLY_DEPLOYMENT_FLAG
	{
		CMS_ASSEMBLY_DEPLOYMENT_FLAG_BEFORE_APPLICATION_STARTUP = 4,
		CMS_ASSEMBLY_DEPLOYMENT_FLAG_RUN_AFTER_INSTALL = 0x10,
		CMS_ASSEMBLY_DEPLOYMENT_FLAG_INSTALL = 0x20,
		CMS_ASSEMBLY_DEPLOYMENT_FLAG_TRUST_URL_PARAMETERS = 0x40,
		CMS_ASSEMBLY_DEPLOYMENT_FLAG_DISALLOW_URL_ACTIVATION = 0x80,
		CMS_ASSEMBLY_DEPLOYMENT_FLAG_MAP_FILE_EXTENSIONS = 0x100,
		CMS_ASSEMBLY_DEPLOYMENT_FLAG_CREATE_DESKTOP_SHORTCUT = 0x200
	}
	internal enum CMS_ASSEMBLY_REFERENCE_FLAG
	{
		CMS_ASSEMBLY_REFERENCE_FLAG_OPTIONAL = 1,
		CMS_ASSEMBLY_REFERENCE_FLAG_VISIBLE = 2,
		CMS_ASSEMBLY_REFERENCE_FLAG_FOLLOW = 4,
		CMS_ASSEMBLY_REFERENCE_FLAG_IS_PLATFORM = 8,
		CMS_ASSEMBLY_REFERENCE_FLAG_CULTURE_WILDCARDED = 0x10,
		CMS_ASSEMBLY_REFERENCE_FLAG_PROCESSOR_ARCHITECTURE_WILDCARDED = 0x20,
		CMS_ASSEMBLY_REFERENCE_FLAG_PREREQUISITE = 0x80
	}
	internal enum CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG
	{
		CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_OPTIONAL = 1,
		CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_VISIBLE = 2,
		CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_PREREQUISITE = 4,
		CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_RESOURCE_FALLBACK_CULTURE_INTERNAL = 8,
		CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_INSTALL = 0x10,
		CMS_ASSEMBLY_REFERENCE_DEPENDENT_ASSEMBLY_FLAG_ALLOW_DELAYED_BINDING = 0x20
	}
	internal enum CMS_FILE_FLAG
	{
		CMS_FILE_FLAG_OPTIONAL = 1
	}
	internal enum CMS_ENTRY_POINT_FLAG
	{
		CMS_ENTRY_POINT_FLAG_HOST_IN_BROWSER = 1,
		CMS_ENTRY_POINT_FLAG_CUSTOMHOSTSPECIFIED = 2,
		CMS_ENTRY_POINT_FLAG_CUSTOMUX = 4
	}
	internal enum CMS_COM_SERVER_FLAG
	{
		CMS_COM_SERVER_FLAG_IS_CLR_CLASS = 1
	}
	internal enum CMS_REGISTRY_KEY_FLAG
	{
		CMS_REGISTRY_KEY_FLAG_OWNER = 1,
		CMS_REGISTRY_KEY_FLAG_LEAF_IN_MANIFEST
	}
	internal enum CMS_REGISTRY_VALUE_FLAG
	{
		CMS_REGISTRY_VALUE_FLAG_OWNER = 1
	}
	internal enum CMS_DIRECTORY_FLAG
	{
		CMS_DIRECTORY_FLAG_OWNER = 1
	}
	internal enum CMS_MANIFEST_FLAG
	{
		CMS_MANIFEST_FLAG_ASSEMBLY = 1,
		CMS_MANIFEST_FLAG_CATEGORY = 2,
		CMS_MANIFEST_FLAG_FEATURE = 3,
		CMS_MANIFEST_FLAG_APPLICATION = 4,
		CMS_MANIFEST_FLAG_USEMANIFESTFORTRUST = 8
	}
	internal enum CMS_USAGE_PATTERN
	{
		CMS_USAGE_PATTERN_SCOPE_APPLICATION = 1,
		CMS_USAGE_PATTERN_SCOPE_PROCESS = 2,
		CMS_USAGE_PATTERN_SCOPE_MACHINE = 3,
		CMS_USAGE_PATTERN_SCOPE_MASK = 7
	}
	internal enum CMS_SCHEMA_VERSION
	{
		CMS_SCHEMA_VERSION_V1 = 1
	}
	internal enum CMS_FILE_HASH_ALGORITHM
	{
		CMS_FILE_HASH_ALGORITHM_SHA1 = 1,
		CMS_FILE_HASH_ALGORITHM_SHA256,
		CMS_FILE_HASH_ALGORITHM_SHA384,
		CMS_FILE_HASH_ALGORITHM_SHA512,
		CMS_FILE_HASH_ALGORITHM_MD5,
		CMS_FILE_HASH_ALGORITHM_MD4,
		CMS_FILE_HASH_ALGORITHM_MD2
	}
	internal enum CMS_TIME_UNIT_TYPE
	{
		CMS_TIME_UNIT_TYPE_HOURS = 1,
		CMS_TIME_UNIT_TYPE_DAYS,
		CMS_TIME_UNIT_TYPE_WEEKS,
		CMS_TIME_UNIT_TYPE_MONTHS
	}
	internal enum CMS_REGISTRY_VALUE_TYPE
	{
		CMS_REGISTRY_VALUE_TYPE_NONE,
		CMS_REGISTRY_VALUE_TYPE_SZ,
		CMS_REGISTRY_VALUE_TYPE_EXPAND_SZ,
		CMS_REGISTRY_VALUE_TYPE_MULTI_SZ,
		CMS_REGISTRY_VALUE_TYPE_BINARY,
		CMS_REGISTRY_VALUE_TYPE_DWORD,
		CMS_REGISTRY_VALUE_TYPE_DWORD_LITTLE_ENDIAN,
		CMS_REGISTRY_VALUE_TYPE_DWORD_BIG_ENDIAN,
		CMS_REGISTRY_VALUE_TYPE_LINK,
		CMS_REGISTRY_VALUE_TYPE_RESOURCE_LIST,
		CMS_REGISTRY_VALUE_TYPE_FULL_RESOURCE_DESCRIPTOR,
		CMS_REGISTRY_VALUE_TYPE_RESOURCE_REQUIREMENTS_LIST,
		CMS_REGISTRY_VALUE_TYPE_QWORD,
		CMS_REGISTRY_VALUE_TYPE_QWORD_LITTLE_ENDIAN
	}
	internal enum CMS_REGISTRY_VALUE_HINT
	{
		CMS_REGISTRY_VALUE_HINT_REPLACE = 1,
		CMS_REGISTRY_VALUE_HINT_APPEND,
		CMS_REGISTRY_VALUE_HINT_PREPEND
	}
	internal enum CMS_SYSTEM_PROTECTION
	{
		CMS_SYSTEM_PROTECTION_READ_ONLY_IGNORE_WRITES = 1,
		CMS_SYSTEM_PROTECTION_READ_ONLY_FAIL_WRITES,
		CMS_SYSTEM_PROTECTION_OS_ONLY_IGNORE_WRITES,
		CMS_SYSTEM_PROTECTION_OS_ONLY_FAIL_WRITES,
		CMS_SYSTEM_PROTECTION_TRANSACTED,
		CMS_SYSTEM_PROTECTION_APPLICATION_VIRTUALIZED,
		CMS_SYSTEM_PROTECTION_USER_VIRTUALIZED,
		CMS_SYSTEM_PROTECTION_APPLICATION_AND_USER_VIRTUALIZED,
		CMS_SYSTEM_PROTECTION_INHERIT,
		CMS_SYSTEM_PROTECTION_NOT_PROTECTED
	}
	internal enum CMS_FILE_WRITABLE_TYPE
	{
		CMS_FILE_WRITABLE_TYPE_NOT_WRITABLE = 1,
		CMS_FILE_WRITABLE_TYPE_APPLICATION_DATA
	}
	internal enum CMS_HASH_TRANSFORM
	{
		CMS_HASH_TRANSFORM_IDENTITY = 1,
		CMS_HASH_TRANSFORM_MANIFESTINVARIANT
	}
	internal enum CMS_HASH_DIGESTMETHOD
	{
		CMS_HASH_DIGESTMETHOD_SHA1 = 1,
		CMS_HASH_DIGESTMETHOD_SHA256,
		CMS_HASH_DIGESTMETHOD_SHA384,
		CMS_HASH_DIGESTMETHOD_SHA512
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("a504e5b0-8ccf-4cb4-9902-c9d1b9abd033")]
	internal interface ICMS
	{
		IDefinitionIdentity Identity
		{
			[SecurityCritical]
			get;
		}

		ISection FileSection
		{
			[SecurityCritical]
			get;
		}

		ISection CategoryMembershipSection
		{
			[SecurityCritical]
			get;
		}

		ISection COMRedirectionSection
		{
			[SecurityCritical]
			get;
		}

		ISection ProgIdRedirectionSection
		{
			[SecurityCritical]
			get;
		}

		ISection CLRSurrogateSection
		{
			[SecurityCritical]
			get;
		}

		ISection AssemblyReferenceSection
		{
			[SecurityCritical]
			get;
		}

		ISection WindowClassSection
		{
			[SecurityCritical]
			get;
		}

		ISection StringSection
		{
			[SecurityCritical]
			get;
		}

		ISection EntryPointSection
		{
			[SecurityCritical]
			get;
		}

		ISection PermissionSetSection
		{
			[SecurityCritical]
			get;
		}

		ISectionEntry MetadataSectionEntry
		{
			[SecurityCritical]
			get;
		}

		ISection AssemblyRequestSection
		{
			[SecurityCritical]
			get;
		}

		ISection RegistryKeySection
		{
			[SecurityCritical]
			get;
		}

		ISection DirectorySection
		{
			[SecurityCritical]
			get;
		}

		ISection FileAssociationSection
		{
			[SecurityCritical]
			get;
		}

		ISection CompatibleFrameworksSection
		{
			[SecurityCritical]
			get;
		}

		ISection EventSection
		{
			[SecurityCritical]
			get;
		}

		ISection EventMapSection
		{
			[SecurityCritical]
			get;
		}

		ISection EventTagSection
		{
			[SecurityCritical]
			get;
		}

		ISection CounterSetSection
		{
			[SecurityCritical]
			get;
		}

		ISection CounterSection
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class MuiResourceIdLookupMapEntry
	{
		public uint Count;
	}
	internal enum MuiResourceIdLookupMapEntryFieldId
	{
		MuiResourceIdLookupMap_Count
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("24abe1f7-a396-4a03-9adf-1d5b86a5569f")]
	internal interface IMuiResourceIdLookupMapEntry
	{
		MuiResourceIdLookupMapEntry AllData
		{
			[SecurityCritical]
			get;
		}

		uint Count
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class MuiResourceTypeIdStringEntry : IDisposable
	{
		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr StringIds;

		public uint StringIdsSize;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr IntegerIds;

		public uint IntegerIdsSize;

		~MuiResourceTypeIdStringEntry()
		{
			Dispose(fDisposing: false);
		}

		void IDisposable.Dispose()
		{
			Dispose(fDisposing: true);
		}

		[SecuritySafeCritical]
		public void Dispose(bool fDisposing)
		{
			if (StringIds != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(StringIds);
				StringIds = IntPtr.Zero;
			}
			if (IntegerIds != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(IntegerIds);
				IntegerIds = IntPtr.Zero;
			}
			if (fDisposing)
			{
				GC.SuppressFinalize(this);
			}
		}
	}
	internal enum MuiResourceTypeIdStringEntryFieldId
	{
		MuiResourceTypeIdString_StringIds,
		MuiResourceTypeIdString_StringIdsSize,
		MuiResourceTypeIdString_IntegerIds,
		MuiResourceTypeIdString_IntegerIdsSize
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("11df5cad-c183-479b-9a44-3842b71639ce")]
	internal interface IMuiResourceTypeIdStringEntry
	{
		MuiResourceTypeIdStringEntry AllData
		{
			[SecurityCritical]
			get;
		}

		object StringIds
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		object IntegerIds
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class MuiResourceTypeIdIntEntry : IDisposable
	{
		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr StringIds;

		public uint StringIdsSize;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr IntegerIds;

		public uint IntegerIdsSize;

		~MuiResourceTypeIdIntEntry()
		{
			Dispose(fDisposing: false);
		}

		void IDisposable.Dispose()
		{
			Dispose(fDisposing: true);
		}

		[SecuritySafeCritical]
		public void Dispose(bool fDisposing)
		{
			if (StringIds != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(StringIds);
				StringIds = IntPtr.Zero;
			}
			if (IntegerIds != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(IntegerIds);
				IntegerIds = IntPtr.Zero;
			}
			if (fDisposing)
			{
				GC.SuppressFinalize(this);
			}
		}
	}
	internal enum MuiResourceTypeIdIntEntryFieldId
	{
		MuiResourceTypeIdInt_StringIds,
		MuiResourceTypeIdInt_StringIdsSize,
		MuiResourceTypeIdInt_IntegerIds,
		MuiResourceTypeIdInt_IntegerIdsSize
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("55b2dec1-d0f6-4bf4-91b1-30f73ad8e4df")]
	internal interface IMuiResourceTypeIdIntEntry
	{
		MuiResourceTypeIdIntEntry AllData
		{
			[SecurityCritical]
			get;
		}

		object StringIds
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		object IntegerIds
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class MuiResourceMapEntry : IDisposable
	{
		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr ResourceTypeIdInt;

		public uint ResourceTypeIdIntSize;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr ResourceTypeIdString;

		public uint ResourceTypeIdStringSize;

		~MuiResourceMapEntry()
		{
			Dispose(fDisposing: false);
		}

		void IDisposable.Dispose()
		{
			Dispose(fDisposing: true);
		}

		[SecuritySafeCritical]
		public void Dispose(bool fDisposing)
		{
			if (ResourceTypeIdInt != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(ResourceTypeIdInt);
				ResourceTypeIdInt = IntPtr.Zero;
			}
			if (ResourceTypeIdString != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(ResourceTypeIdString);
				ResourceTypeIdString = IntPtr.Zero;
			}
			if (fDisposing)
			{
				GC.SuppressFinalize(this);
			}
		}
	}
	internal enum MuiResourceMapEntryFieldId
	{
		MuiResourceMap_ResourceTypeIdInt,
		MuiResourceMap_ResourceTypeIdIntSize,
		MuiResourceMap_ResourceTypeIdString,
		MuiResourceMap_ResourceTypeIdStringSize
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("397927f5-10f2-4ecb-bfe1-3c264212a193")]
	internal interface IMuiResourceMapEntry
	{
		MuiResourceMapEntry AllData
		{
			[SecurityCritical]
			get;
		}

		object ResourceTypeIdInt
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		object ResourceTypeIdString
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class HashElementEntry : IDisposable
	{
		public uint index;

		public byte Transform;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr TransformMetadata;

		public uint TransformMetadataSize;

		public byte DigestMethod;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr DigestValue;

		public uint DigestValueSize;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Xml;

		~HashElementEntry()
		{
			Dispose(fDisposing: false);
		}

		void IDisposable.Dispose()
		{
			Dispose(fDisposing: true);
		}

		[SecuritySafeCritical]
		public void Dispose(bool fDisposing)
		{
			if (TransformMetadata != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(TransformMetadata);
				TransformMetadata = IntPtr.Zero;
			}
			if (DigestValue != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(DigestValue);
				DigestValue = IntPtr.Zero;
			}
			if (fDisposing)
			{
				GC.SuppressFinalize(this);
			}
		}
	}
	internal enum HashElementEntryFieldId
	{
		HashElement_Transform,
		HashElement_TransformMetadata,
		HashElement_TransformMetadataSize,
		HashElement_DigestMethod,
		HashElement_DigestValue,
		HashElement_DigestValueSize,
		HashElement_Xml
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("9D46FB70-7B54-4f4f-9331-BA9E87833FF5")]
	internal interface IHashElementEntry
	{
		HashElementEntry AllData
		{
			[SecurityCritical]
			get;
		}

		uint index
		{
			[SecurityCritical]
			get;
		}

		byte Transform
		{
			[SecurityCritical]
			get;
		}

		object TransformMetadata
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		byte DigestMethod
		{
			[SecurityCritical]
			get;
		}

		object DigestValue
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		string Xml
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class FileEntry : IDisposable
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Name;

		public uint HashAlgorithm;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string LoadFrom;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string SourcePath;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string ImportPath;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string SourceName;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Location;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr HashValue;

		public uint HashValueSize;

		public ulong Size;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Group;

		public uint Flags;

		public MuiResourceMapEntry MuiMapping;

		public uint WritableType;

		public ISection HashElements;

		~FileEntry()
		{
			Dispose(fDisposing: false);
		}

		void IDisposable.Dispose()
		{
			Dispose(fDisposing: true);
		}

		[SecuritySafeCritical]
		public void Dispose(bool fDisposing)
		{
			if (HashValue != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(HashValue);
				HashValue = IntPtr.Zero;
			}
			if (fDisposing)
			{
				if (MuiMapping != null)
				{
					MuiMapping.Dispose(fDisposing: true);
					MuiMapping = null;
				}
				GC.SuppressFinalize(this);
			}
		}
	}
	internal enum FileEntryFieldId
	{
		File_HashAlgorithm,
		File_LoadFrom,
		File_SourcePath,
		File_ImportPath,
		File_SourceName,
		File_Location,
		File_HashValue,
		File_HashValueSize,
		File_Size,
		File_Group,
		File_Flags,
		File_MuiMapping,
		File_WritableType,
		File_HashElements
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("A2A55FAD-349B-469b-BF12-ADC33D14A937")]
	internal interface IFileEntry
	{
		FileEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string Name
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		uint HashAlgorithm
		{
			[SecurityCritical]
			get;
		}

		string LoadFrom
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string SourcePath
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string ImportPath
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string SourceName
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Location
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		object HashValue
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		ulong Size
		{
			[SecurityCritical]
			get;
		}

		string Group
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		uint Flags
		{
			[SecurityCritical]
			get;
		}

		IMuiResourceMapEntry MuiMapping
		{
			[SecurityCritical]
			get;
		}

		uint WritableType
		{
			[SecurityCritical]
			get;
		}

		ISection HashElements
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class FileAssociationEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Extension;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Description;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string ProgID;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string DefaultIcon;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Parameter;
	}
	internal enum FileAssociationEntryFieldId
	{
		FileAssociation_Description,
		FileAssociation_ProgID,
		FileAssociation_DefaultIcon,
		FileAssociation_Parameter
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("0C66F299-E08E-48c5-9264-7CCBEB4D5CBB")]
	internal interface IFileAssociationEntry
	{
		FileAssociationEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string Extension
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Description
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string ProgID
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string DefaultIcon
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Parameter
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class CategoryMembershipDataEntry
	{
		public uint index;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Xml;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Description;
	}
	internal enum CategoryMembershipDataEntryFieldId
	{
		CategoryMembershipData_Xml,
		CategoryMembershipData_Description
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("DA0C3B27-6B6B-4b80-A8F8-6CE14F4BC0A4")]
	internal interface ICategoryMembershipDataEntry
	{
		CategoryMembershipDataEntry AllData
		{
			[SecurityCritical]
			get;
		}

		uint index
		{
			[SecurityCritical]
			get;
		}

		string Xml
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Description
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class SubcategoryMembershipEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Subcategory;

		public ISection CategoryMembershipData;
	}
	internal enum SubcategoryMembershipEntryFieldId
	{
		SubcategoryMembership_CategoryMembershipData
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("5A7A54D7-5AD5-418e-AB7A-CF823A8D48D0")]
	internal interface ISubcategoryMembershipEntry
	{
		SubcategoryMembershipEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string Subcategory
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		ISection CategoryMembershipData
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class CategoryMembershipEntry
	{
		public IDefinitionIdentity Identity;

		public ISection SubcategoryMembership;
	}
	internal enum CategoryMembershipEntryFieldId
	{
		CategoryMembership_SubcategoryMembership
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("97FDCA77-B6F2-4718-A1EB-29D0AECE9C03")]
	internal interface ICategoryMembershipEntry
	{
		CategoryMembershipEntry AllData
		{
			[SecurityCritical]
			get;
		}

		IDefinitionIdentity Identity
		{
			[SecurityCritical]
			get;
		}

		ISection SubcategoryMembership
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class COMServerEntry
	{
		public Guid Clsid;

		public uint Flags;

		public Guid ConfiguredGuid;

		public Guid ImplementedClsid;

		public Guid TypeLibrary;

		public uint ThreadingModel;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string RuntimeVersion;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string HostFile;
	}
	internal enum COMServerEntryFieldId
	{
		COMServer_Flags,
		COMServer_ConfiguredGuid,
		COMServer_ImplementedClsid,
		COMServer_TypeLibrary,
		COMServer_ThreadingModel,
		COMServer_RuntimeVersion,
		COMServer_HostFile
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("3903B11B-FBE8-477c-825F-DB828B5FD174")]
	internal interface ICOMServerEntry
	{
		COMServerEntry AllData
		{
			[SecurityCritical]
			get;
		}

		Guid Clsid
		{
			[SecurityCritical]
			get;
		}

		uint Flags
		{
			[SecurityCritical]
			get;
		}

		Guid ConfiguredGuid
		{
			[SecurityCritical]
			get;
		}

		Guid ImplementedClsid
		{
			[SecurityCritical]
			get;
		}

		Guid TypeLibrary
		{
			[SecurityCritical]
			get;
		}

		uint ThreadingModel
		{
			[SecurityCritical]
			get;
		}

		string RuntimeVersion
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string HostFile
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class ProgIdRedirectionEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string ProgId;

		public Guid RedirectedGuid;
	}
	internal enum ProgIdRedirectionEntryFieldId
	{
		ProgIdRedirection_RedirectedGuid
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("54F198EC-A63A-45ea-A984-452F68D9B35B")]
	internal interface IProgIdRedirectionEntry
	{
		ProgIdRedirectionEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string ProgId
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		Guid RedirectedGuid
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class CLRSurrogateEntry
	{
		public Guid Clsid;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string RuntimeVersion;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string ClassName;
	}
	internal enum CLRSurrogateEntryFieldId
	{
		CLRSurrogate_RuntimeVersion,
		CLRSurrogate_ClassName
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("1E0422A1-F0D2-44ae-914B-8A2DECCFD22B")]
	internal interface ICLRSurrogateEntry
	{
		CLRSurrogateEntry AllData
		{
			[SecurityCritical]
			get;
		}

		Guid Clsid
		{
			[SecurityCritical]
			get;
		}

		string RuntimeVersion
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string ClassName
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class AssemblyReferenceDependentAssemblyEntry : IDisposable
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Group;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Codebase;

		public ulong Size;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr HashValue;

		public uint HashValueSize;

		public uint HashAlgorithm;

		public uint Flags;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string ResourceFallbackCulture;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Description;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string SupportUrl;

		public ISection HashElements;

		~AssemblyReferenceDependentAssemblyEntry()
		{
			Dispose(fDisposing: false);
		}

		void IDisposable.Dispose()
		{
			Dispose(fDisposing: true);
		}

		[SecuritySafeCritical]
		public void Dispose(bool fDisposing)
		{
			if (HashValue != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(HashValue);
				HashValue = IntPtr.Zero;
			}
			if (fDisposing)
			{
				GC.SuppressFinalize(this);
			}
		}
	}
	internal enum AssemblyReferenceDependentAssemblyEntryFieldId
	{
		AssemblyReferenceDependentAssembly_Group,
		AssemblyReferenceDependentAssembly_Codebase,
		AssemblyReferenceDependentAssembly_Size,
		AssemblyReferenceDependentAssembly_HashValue,
		AssemblyReferenceDependentAssembly_HashValueSize,
		AssemblyReferenceDependentAssembly_HashAlgorithm,
		AssemblyReferenceDependentAssembly_Flags,
		AssemblyReferenceDependentAssembly_ResourceFallbackCulture,
		AssemblyReferenceDependentAssembly_Description,
		AssemblyReferenceDependentAssembly_SupportUrl,
		AssemblyReferenceDependentAssembly_HashElements
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("C31FF59E-CD25-47b8-9EF3-CF4433EB97CC")]
	internal interface IAssemblyReferenceDependentAssemblyEntry
	{
		AssemblyReferenceDependentAssemblyEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string Group
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Codebase
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		ulong Size
		{
			[SecurityCritical]
			get;
		}

		object HashValue
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		uint HashAlgorithm
		{
			[SecurityCritical]
			get;
		}

		uint Flags
		{
			[SecurityCritical]
			get;
		}

		string ResourceFallbackCulture
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Description
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string SupportUrl
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		ISection HashElements
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class AssemblyReferenceEntry
	{
		public IReferenceIdentity ReferenceIdentity;

		public uint Flags;

		public AssemblyReferenceDependentAssemblyEntry DependentAssembly;
	}
	internal enum AssemblyReferenceEntryFieldId
	{
		AssemblyReference_Flags,
		AssemblyReference_DependentAssembly
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("FD47B733-AFBC-45e4-B7C2-BBEB1D9F766C")]
	internal interface IAssemblyReferenceEntry
	{
		AssemblyReferenceEntry AllData
		{
			[SecurityCritical]
			get;
		}

		IReferenceIdentity ReferenceIdentity
		{
			[SecurityCritical]
			get;
		}

		uint Flags
		{
			[SecurityCritical]
			get;
		}

		IAssemblyReferenceDependentAssemblyEntry DependentAssembly
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class WindowClassEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string ClassName;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string HostDll;

		public bool fVersioned;
	}
	internal enum WindowClassEntryFieldId
	{
		WindowClass_HostDll,
		WindowClass_fVersioned
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8AD3FC86-AFD3-477a-8FD5-146C291195BA")]
	internal interface IWindowClassEntry
	{
		WindowClassEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string ClassName
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string HostDll
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		bool fVersioned
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class ResourceTableMappingEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string id;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string FinalStringMapped;
	}
	internal enum ResourceTableMappingEntryFieldId
	{
		ResourceTableMapping_FinalStringMapped
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("70A4ECEE-B195-4c59-85BF-44B6ACA83F07")]
	internal interface IResourceTableMappingEntry
	{
		ResourceTableMappingEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string id
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string FinalStringMapped
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class EntryPointEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Name;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string CommandLine_File;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string CommandLine_Parameters;

		public IReferenceIdentity Identity;

		public uint Flags;
	}
	internal enum EntryPointEntryFieldId
	{
		EntryPoint_CommandLine_File,
		EntryPoint_CommandLine_Parameters,
		EntryPoint_Identity,
		EntryPoint_Flags
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("1583EFE9-832F-4d08-B041-CAC5ACEDB948")]
	internal interface IEntryPointEntry
	{
		EntryPointEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string Name
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string CommandLine_File
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string CommandLine_Parameters
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		IReferenceIdentity Identity
		{
			[SecurityCritical]
			get;
		}

		uint Flags
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class PermissionSetEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Id;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string XmlSegment;
	}
	internal enum PermissionSetEntryFieldId
	{
		PermissionSet_XmlSegment
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("EBE5A1ED-FEBC-42c4-A9E1-E087C6E36635")]
	internal interface IPermissionSetEntry
	{
		PermissionSetEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string Id
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string XmlSegment
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class AssemblyRequestEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Name;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string permissionSetID;
	}
	internal enum AssemblyRequestEntryFieldId
	{
		AssemblyRequest_permissionSetID
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("2474ECB4-8EFD-4410-9F31-B3E7C4A07731")]
	internal interface IAssemblyRequestEntry
	{
		AssemblyRequestEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string Name
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string permissionSetID
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class DescriptionMetadataEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Publisher;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Product;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string SupportUrl;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string IconFile;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string ErrorReportUrl;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string SuiteName;
	}
	internal enum DescriptionMetadataEntryFieldId
	{
		DescriptionMetadata_Publisher,
		DescriptionMetadata_Product,
		DescriptionMetadata_SupportUrl,
		DescriptionMetadata_IconFile,
		DescriptionMetadata_ErrorReportUrl,
		DescriptionMetadata_SuiteName
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("CB73147E-5FC2-4c31-B4E6-58D13DBE1A08")]
	internal interface IDescriptionMetadataEntry
	{
		DescriptionMetadataEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string Publisher
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Product
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string SupportUrl
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string IconFile
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string ErrorReportUrl
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string SuiteName
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class DeploymentMetadataEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string DeploymentProviderCodebase;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string MinimumRequiredVersion;

		public ushort MaximumAge;

		public byte MaximumAge_Unit;

		public uint DeploymentFlags;
	}
	internal enum DeploymentMetadataEntryFieldId
	{
		DeploymentMetadata_DeploymentProviderCodebase,
		DeploymentMetadata_MinimumRequiredVersion,
		DeploymentMetadata_MaximumAge,
		DeploymentMetadata_MaximumAge_Unit,
		DeploymentMetadata_DeploymentFlags
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("CFA3F59F-334D-46bf-A5A5-5D11BB2D7EBC")]
	internal interface IDeploymentMetadataEntry
	{
		DeploymentMetadataEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string DeploymentProviderCodebase
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string MinimumRequiredVersion
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		ushort MaximumAge
		{
			[SecurityCritical]
			get;
		}

		byte MaximumAge_Unit
		{
			[SecurityCritical]
			get;
		}

		uint DeploymentFlags
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class DependentOSMetadataEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string SupportUrl;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Description;

		public ushort MajorVersion;

		public ushort MinorVersion;

		public ushort BuildNumber;

		public byte ServicePackMajor;

		public byte ServicePackMinor;
	}
	internal enum DependentOSMetadataEntryFieldId
	{
		DependentOSMetadata_SupportUrl,
		DependentOSMetadata_Description,
		DependentOSMetadata_MajorVersion,
		DependentOSMetadata_MinorVersion,
		DependentOSMetadata_BuildNumber,
		DependentOSMetadata_ServicePackMajor,
		DependentOSMetadata_ServicePackMinor
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("CF168CF4-4E8F-4d92-9D2A-60E5CA21CF85")]
	internal interface IDependentOSMetadataEntry
	{
		DependentOSMetadataEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string SupportUrl
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Description
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		ushort MajorVersion
		{
			[SecurityCritical]
			get;
		}

		ushort MinorVersion
		{
			[SecurityCritical]
			get;
		}

		ushort BuildNumber
		{
			[SecurityCritical]
			get;
		}

		byte ServicePackMajor
		{
			[SecurityCritical]
			get;
		}

		byte ServicePackMinor
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class CompatibleFrameworksMetadataEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string SupportUrl;
	}
	internal enum CompatibleFrameworksMetadataEntryFieldId
	{
		CompatibleFrameworksMetadata_SupportUrl
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("4A33D662-2210-463A-BE9F-FBDF1AA554E3")]
	internal interface ICompatibleFrameworksMetadataEntry
	{
		CompatibleFrameworksMetadataEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string SupportUrl
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class MetadataSectionEntry : IDisposable
	{
		public uint SchemaVersion;

		public uint ManifestFlags;

		public uint UsagePatterns;

		public IDefinitionIdentity CdfIdentity;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string LocalPath;

		public uint HashAlgorithm;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr ManifestHash;

		public uint ManifestHashSize;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string ContentType;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string RuntimeImageVersion;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr MvidValue;

		public uint MvidValueSize;

		public DescriptionMetadataEntry DescriptionData;

		public DeploymentMetadataEntry DeploymentData;

		public DependentOSMetadataEntry DependentOSData;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string defaultPermissionSetID;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string RequestedExecutionLevel;

		public bool RequestedExecutionLevelUIAccess;

		public IReferenceIdentity ResourceTypeResourcesDependency;

		public IReferenceIdentity ResourceTypeManifestResourcesDependency;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string KeyInfoElement;

		public CompatibleFrameworksMetadataEntry CompatibleFrameworksData;

		~MetadataSectionEntry()
		{
			Dispose(fDisposing: false);
		}

		void IDisposable.Dispose()
		{
			Dispose(fDisposing: true);
		}

		[SecuritySafeCritical]
		public void Dispose(bool fDisposing)
		{
			if (ManifestHash != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(ManifestHash);
				ManifestHash = IntPtr.Zero;
			}
			if (MvidValue != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(MvidValue);
				MvidValue = IntPtr.Zero;
			}
			if (fDisposing)
			{
				GC.SuppressFinalize(this);
			}
		}
	}
	internal enum MetadataSectionEntryFieldId
	{
		MetadataSection_SchemaVersion,
		MetadataSection_ManifestFlags,
		MetadataSection_UsagePatterns,
		MetadataSection_CdfIdentity,
		MetadataSection_LocalPath,
		MetadataSection_HashAlgorithm,
		MetadataSection_ManifestHash,
		MetadataSection_ManifestHashSize,
		MetadataSection_ContentType,
		MetadataSection_RuntimeImageVersion,
		MetadataSection_MvidValue,
		MetadataSection_MvidValueSize,
		MetadataSection_DescriptionData,
		MetadataSection_DeploymentData,
		MetadataSection_DependentOSData,
		MetadataSection_defaultPermissionSetID,
		MetadataSection_RequestedExecutionLevel,
		MetadataSection_RequestedExecutionLevelUIAccess,
		MetadataSection_ResourceTypeResourcesDependency,
		MetadataSection_ResourceTypeManifestResourcesDependency,
		MetadataSection_KeyInfoElement,
		MetadataSection_CompatibleFrameworksData
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("AB1ED79F-943E-407d-A80B-0744E3A95B28")]
	internal interface IMetadataSectionEntry
	{
		MetadataSectionEntry AllData
		{
			[SecurityCritical]
			get;
		}

		uint SchemaVersion
		{
			[SecurityCritical]
			get;
		}

		uint ManifestFlags
		{
			[SecurityCritical]
			get;
		}

		uint UsagePatterns
		{
			[SecurityCritical]
			get;
		}

		IDefinitionIdentity CdfIdentity
		{
			[SecurityCritical]
			get;
		}

		string LocalPath
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		uint HashAlgorithm
		{
			[SecurityCritical]
			get;
		}

		object ManifestHash
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		string ContentType
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string RuntimeImageVersion
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		object MvidValue
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		IDescriptionMetadataEntry DescriptionData
		{
			[SecurityCritical]
			get;
		}

		IDeploymentMetadataEntry DeploymentData
		{
			[SecurityCritical]
			get;
		}

		IDependentOSMetadataEntry DependentOSData
		{
			[SecurityCritical]
			get;
		}

		string defaultPermissionSetID
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string RequestedExecutionLevel
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		bool RequestedExecutionLevelUIAccess
		{
			[SecurityCritical]
			get;
		}

		IReferenceIdentity ResourceTypeResourcesDependency
		{
			[SecurityCritical]
			get;
		}

		IReferenceIdentity ResourceTypeManifestResourcesDependency
		{
			[SecurityCritical]
			get;
		}

		string KeyInfoElement
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		ICompatibleFrameworksMetadataEntry CompatibleFrameworksData
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class EventEntry
	{
		public uint EventID;

		public uint Level;

		public uint Version;

		public Guid Guid;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string SubTypeName;

		public uint SubTypeValue;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string DisplayName;

		public uint EventNameMicrodomIndex;
	}
	internal enum EventEntryFieldId
	{
		Event_Level,
		Event_Version,
		Event_Guid,
		Event_SubTypeName,
		Event_SubTypeValue,
		Event_DisplayName,
		Event_EventNameMicrodomIndex
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8AD3FC86-AFD3-477a-8FD5-146C291195BB")]
	internal interface IEventEntry
	{
		EventEntry AllData
		{
			[SecurityCritical]
			get;
		}

		uint EventID
		{
			[SecurityCritical]
			get;
		}

		uint Level
		{
			[SecurityCritical]
			get;
		}

		uint Version
		{
			[SecurityCritical]
			get;
		}

		Guid Guid
		{
			[SecurityCritical]
			get;
		}

		string SubTypeName
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		uint SubTypeValue
		{
			[SecurityCritical]
			get;
		}

		string DisplayName
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		uint EventNameMicrodomIndex
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class EventMapEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string MapName;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Name;

		public uint Value;

		public bool IsValueMap;
	}
	internal enum EventMapEntryFieldId
	{
		EventMap_Name,
		EventMap_Value,
		EventMap_IsValueMap
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8AD3FC86-AFD3-477a-8FD5-146C291195BC")]
	internal interface IEventMapEntry
	{
		EventMapEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string MapName
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Name
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		uint Value
		{
			[SecurityCritical]
			get;
		}

		bool IsValueMap
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class EventTagEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string TagData;

		public uint EventID;
	}
	internal enum EventTagEntryFieldId
	{
		EventTag_EventID
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8AD3FC86-AFD3-477a-8FD5-146C291195BD")]
	internal interface IEventTagEntry
	{
		EventTagEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string TagData
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		uint EventID
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class RegistryValueEntry
	{
		public uint Flags;

		public uint OperationHint;

		public uint Type;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Value;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string BuildFilter;
	}
	internal enum RegistryValueEntryFieldId
	{
		RegistryValue_Flags,
		RegistryValue_OperationHint,
		RegistryValue_Type,
		RegistryValue_Value,
		RegistryValue_BuildFilter
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("49e1fe8d-ebb8-4593-8c4e-3e14c845b142")]
	internal interface IRegistryValueEntry
	{
		RegistryValueEntry AllData
		{
			[SecurityCritical]
			get;
		}

		uint Flags
		{
			[SecurityCritical]
			get;
		}

		uint OperationHint
		{
			[SecurityCritical]
			get;
		}

		uint Type
		{
			[SecurityCritical]
			get;
		}

		string Value
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string BuildFilter
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class RegistryKeyEntry : IDisposable
	{
		public uint Flags;

		public uint Protection;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string BuildFilter;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr SecurityDescriptor;

		public uint SecurityDescriptorSize;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr Values;

		public uint ValuesSize;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr Keys;

		public uint KeysSize;

		~RegistryKeyEntry()
		{
			Dispose(fDisposing: false);
		}

		void IDisposable.Dispose()
		{
			Dispose(fDisposing: true);
		}

		[SecuritySafeCritical]
		public void Dispose(bool fDisposing)
		{
			if (SecurityDescriptor != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(SecurityDescriptor);
				SecurityDescriptor = IntPtr.Zero;
			}
			if (Values != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(Values);
				Values = IntPtr.Zero;
			}
			if (Keys != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(Keys);
				Keys = IntPtr.Zero;
			}
			if (fDisposing)
			{
				GC.SuppressFinalize(this);
			}
		}
	}
	internal enum RegistryKeyEntryFieldId
	{
		RegistryKey_Flags,
		RegistryKey_Protection,
		RegistryKey_BuildFilter,
		RegistryKey_SecurityDescriptor,
		RegistryKey_SecurityDescriptorSize,
		RegistryKey_Values,
		RegistryKey_ValuesSize,
		RegistryKey_Keys,
		RegistryKey_KeysSize
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("186685d1-6673-48c3-bc83-95859bb591df")]
	internal interface IRegistryKeyEntry
	{
		RegistryKeyEntry AllData
		{
			[SecurityCritical]
			get;
		}

		uint Flags
		{
			[SecurityCritical]
			get;
		}

		uint Protection
		{
			[SecurityCritical]
			get;
		}

		string BuildFilter
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		object SecurityDescriptor
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		object Values
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}

		object Keys
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class DirectoryEntry : IDisposable
	{
		public uint Flags;

		public uint Protection;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string BuildFilter;

		[MarshalAs(UnmanagedType.SysInt)]
		public IntPtr SecurityDescriptor;

		public uint SecurityDescriptorSize;

		~DirectoryEntry()
		{
			Dispose(fDisposing: false);
		}

		void IDisposable.Dispose()
		{
			Dispose(fDisposing: true);
		}

		[SecuritySafeCritical]
		public void Dispose(bool fDisposing)
		{
			if (SecurityDescriptor != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(SecurityDescriptor);
				SecurityDescriptor = IntPtr.Zero;
			}
			if (fDisposing)
			{
				GC.SuppressFinalize(this);
			}
		}
	}
	internal enum DirectoryEntryFieldId
	{
		Directory_Flags,
		Directory_Protection,
		Directory_BuildFilter,
		Directory_SecurityDescriptor,
		Directory_SecurityDescriptorSize
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("9f27c750-7dfb-46a1-a673-52e53e2337a9")]
	internal interface IDirectoryEntry
	{
		DirectoryEntry AllData
		{
			[SecurityCritical]
			get;
		}

		uint Flags
		{
			[SecurityCritical]
			get;
		}

		uint Protection
		{
			[SecurityCritical]
			get;
		}

		string BuildFilter
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		object SecurityDescriptor
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.Interface)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class SecurityDescriptorReferenceEntry
	{
		[MarshalAs(UnmanagedType.LPWStr)]
		public string Name;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string BuildFilter;
	}
	internal enum SecurityDescriptorReferenceEntryFieldId
	{
		SecurityDescriptorReference_Name,
		SecurityDescriptorReference_BuildFilter
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("a75b74e9-2c00-4ebb-b3f9-62a670aaa07e")]
	internal interface ISecurityDescriptorReferenceEntry
	{
		SecurityDescriptorReferenceEntry AllData
		{
			[SecurityCritical]
			get;
		}

		string Name
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string BuildFilter
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class CounterSetEntry
	{
		public Guid CounterSetGuid;

		public Guid ProviderGuid;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Name;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Description;

		public bool InstanceType;
	}
	internal enum CounterSetEntryFieldId
	{
		CounterSet_ProviderGuid,
		CounterSet_Name,
		CounterSet_Description,
		CounterSet_InstanceType
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8CD3FC85-AFD3-477a-8FD5-146C291195BB")]
	internal interface ICounterSetEntry
	{
		CounterSetEntry AllData
		{
			[SecurityCritical]
			get;
		}

		Guid CounterSetGuid
		{
			[SecurityCritical]
			get;
		}

		Guid ProviderGuid
		{
			[SecurityCritical]
			get;
		}

		string Name
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Description
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		bool InstanceType
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class CounterEntry
	{
		public Guid CounterSetGuid;

		public uint CounterId;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Name;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Description;

		public uint CounterType;

		public ulong Attributes;

		public uint BaseId;

		public uint DefaultScale;
	}
	internal enum CounterEntryFieldId
	{
		Counter_CounterId,
		Counter_Name,
		Counter_Description,
		Counter_CounterType,
		Counter_Attributes,
		Counter_BaseId,
		Counter_DefaultScale
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8CD3FC86-AFD3-477a-8FD5-146C291195BB")]
	internal interface ICounterEntry
	{
		CounterEntry AllData
		{
			[SecurityCritical]
			get;
		}

		Guid CounterSetGuid
		{
			[SecurityCritical]
			get;
		}

		uint CounterId
		{
			[SecurityCritical]
			get;
		}

		string Name
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Description
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		uint CounterType
		{
			[SecurityCritical]
			get;
		}

		ulong Attributes
		{
			[SecurityCritical]
			get;
		}

		uint BaseId
		{
			[SecurityCritical]
			get;
		}

		uint DefaultScale
		{
			[SecurityCritical]
			get;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class CompatibleFrameworkEntry
	{
		public uint index;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string TargetVersion;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string Profile;

		[MarshalAs(UnmanagedType.LPWStr)]
		public string SupportedRuntime;
	}
	internal enum CompatibleFrameworkEntryFieldId
	{
		CompatibleFramework_TargetVersion,
		CompatibleFramework_Profile,
		CompatibleFramework_SupportedRuntime
	}
	[ComImport]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("C98BFE2A-62C9-40AD-ADCE-A9037BE2BE6C")]
	internal interface ICompatibleFrameworkEntry
	{
		CompatibleFrameworkEntry AllData
		{
			[SecurityCritical]
			get;
		}

		uint index
		{
			[SecurityCritical]
			get;
		}

		string TargetVersion
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string Profile
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}

		string SupportedRuntime
		{
			[SecurityCritical]
			[return: MarshalAs(UnmanagedType.LPWStr)]
			get;
		}
	}
}
namespace System.Deployment.Internal.CodeSigning
{
	/// <summary>Creates <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureFormatter" /> and <see cref="T:System.Security.Cryptography.RSAPKCS1SignatureDeformatter" /> objects.</summary>
	public sealed class RSAPKCS1SHA256SignatureDescription : SignatureDescription
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription" /> class.</summary>
		public RSAPKCS1SHA256SignatureDescription()
		{
			base.KeyAlgorithm = typeof(RSACryptoServiceProvider).FullName;
			base.DigestAlgorithm = typeof(SHA256Cng).FullName;
			base.FormatterAlgorithm = typeof(RSAPKCS1SignatureFormatter).FullName;
			base.DeformatterAlgorithm = typeof(RSAPKCS1SignatureDeformatter).FullName;
		}

		/// <summary>Creates an asymmetric signature deformatter instance that has the specified key.</summary>
		/// <param name="key">The key to use in the deformatter.</param>
		/// <returns>An asymmetric signature deformatter object.</returns>
		public override AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			RSAPKCS1SignatureDeformatter rSAPKCS1SignatureDeformatter = new RSAPKCS1SignatureDeformatter(key);
			rSAPKCS1SignatureDeformatter.SetHashAlgorithm("SHA256");
			return rSAPKCS1SignatureDeformatter;
		}

		/// <summary>Creates an asymmetric signature formatter instance that has the specified key.</summary>
		/// <param name="key">The key to use in the formatter.</param>
		/// <returns>An asymmetric signature formatter object.</returns>
		public override AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			RSAPKCS1SignatureFormatter rSAPKCS1SignatureFormatter = new RSAPKCS1SignatureFormatter(key);
			rSAPKCS1SignatureFormatter.SetHashAlgorithm("SHA256");
			return rSAPKCS1SignatureFormatter;
		}
	}
	internal static class Win32
	{
		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct CRYPT_DATA_BLOB
		{
			internal uint cbData;

			internal IntPtr pbData;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct AXL_SIGNER_INFO
		{
			internal uint cbSize;

			internal uint dwError;

			internal uint algHash;

			internal IntPtr pwszHash;

			internal IntPtr pwszDescription;

			internal IntPtr pwszDescriptionUrl;

			internal IntPtr pChainContext;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		internal struct AXL_TIMESTAMPER_INFO
		{
			internal uint cbSize;

			internal uint dwError;

			internal uint algHash;

			internal System.Runtime.InteropServices.ComTypes.FILETIME ftTimestamp;

			internal IntPtr pChainContext;
		}

		internal struct CRYPT_TIMESTAMP_CONTEXT
		{
			internal uint cbEncoded;

			internal IntPtr pbEncoded;

			internal IntPtr pTimeStamp;
		}

		internal struct CRYPT_TIMESTAMP_INFO
		{
			internal int dwVersion;

			internal IntPtr pszTSAPolicyId;

			internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;

			internal CRYPTOAPI_BLOB HashedMessage;

			internal CRYPTOAPI_BLOB SerialNumber;

			internal System.Runtime.InteropServices.ComTypes.FILETIME ftTime;

			internal IntPtr pvAccuracy;

			[MarshalAs(UnmanagedType.Bool)]
			internal bool fOrdering;

			internal CRYPTOAPI_BLOB Nonce;

			internal CRYPTOAPI_BLOB Tsa;

			internal int cExtension;

			internal IntPtr rgExtension;
		}

		internal struct CRYPT_ALGORITHM_IDENTIFIER
		{
			internal IntPtr pszOid;

			internal CRYPTOAPI_BLOB Parameters;
		}

		internal struct CRYPTOAPI_BLOB
		{
			internal uint cbData;

			internal IntPtr pbData;
		}

		internal struct CRYPT_TIMESTAMP_PARA
		{
			internal IntPtr pszTSAPolicyId;

			internal bool fRequestCerts;

			internal CRYPTOAPI_BLOB Nonce;

			internal int cExtension;

			internal IntPtr rgExtension;
		}

		internal const string CRYPT32 = "crypt32.dll";

		internal const string KERNEL32 = "kernel32.dll";

		internal const string MSCORWKS = "clr.dll";

		internal const int S_OK = 0;

		internal const int NTE_BAD_HASH = -2146893822;

		internal const int NTE_BAD_KEY = -2146893821;

		internal const int TRUST_E_SYSTEM_ERROR = -2146869247;

		internal const int TRUST_E_NO_SIGNER_CERT = -2146869246;

		internal const int TRUST_E_COUNTER_SIGNER = -2146869245;

		internal const int TRUST_E_CERT_SIGNATURE = -2146869244;

		internal const int TRUST_E_TIME_STAMP = -2146869243;

		internal const int TRUST_E_BAD_DIGEST = -2146869232;

		internal const int TRUST_E_BASIC_CONSTRAINTS = -2146869223;

		internal const int TRUST_E_FINANCIAL_CRITERIA = -2146869218;

		internal const int TRUST_E_PROVIDER_UNKNOWN = -2146762751;

		internal const int TRUST_E_ACTION_UNKNOWN = -2146762750;

		internal const int TRUST_E_SUBJECT_FORM_UNKNOWN = -2146762749;

		internal const int TRUST_E_SUBJECT_NOT_TRUSTED = -2146762748;

		internal const int TRUST_E_NOSIGNATURE = -2146762496;

		internal const int CERT_E_UNTRUSTEDROOT = -2146762487;

		internal const int TRUST_E_FAIL = -2146762485;

		internal const int TRUST_E_EXPLICIT_DISTRUST = -2146762479;

		internal const int CERT_E_CHAINING = -2146762486;

		internal const int AXL_REVOCATION_NO_CHECK = 1;

		internal const int AXL_REVOCATION_CHECK_END_CERT_ONLY = 2;

		internal const int AXL_REVOCATION_CHECK_ENTIRE_CHAIN = 4;

		internal const int AXL_URL_CACHE_ONLY_RETRIEVAL = 8;

		internal const int AXL_LIFETIME_SIGNING = 16;

		internal const int AXL_TRUST_MICROSOFT_ROOT_ONLY = 32;

		internal const int WTPF_IGNOREREVOKATION = 512;

		internal const int WTPF_IGNOREREVOCATIONONTS = 131072;

		internal const string szOID_KP_LIFETIME_SIGNING = "1.3.6.1.4.1.311.10.3.13";

		internal const string szOID_RSA_signingTime = "1.2.840.113549.1.9.5";

		internal const string szOID_OIWSEC_sha1 = "1.3.14.3.2.26";

		internal const string szOID_NIST_sha256 = "2.16.840.1.101.3.4.2.1";

		internal const string szOID_RSA_messageDigest = "1.2.840.113549.1.9.4";

		internal const string szOID_PKIX_KP_TIMESTAMP_SIGNING = "1.3.6.1.5.5.7.3.8";

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern IntPtr GetProcessHeap();

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool HeapFree([In] IntPtr hHeap, [In] uint dwFlags, [In] IntPtr lpMem);

		[DllImport("clr.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern int CertTimestampAuthenticodeLicense([In] ref CRYPT_DATA_BLOB pSignedLicenseBlob, [In] string pwszTimestampURI, [In][Out] ref CRYPT_DATA_BLOB pTimestampSignatureBlob);

		[DllImport("clr.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern int CertVerifyAuthenticodeLicense([In] ref CRYPT_DATA_BLOB pLicenseBlob, [In] uint dwFlags, [In][Out] ref AXL_SIGNER_INFO pSignerInfo, [In][Out] ref AXL_TIMESTAMPER_INFO pTimestamperInfo);

		[DllImport("clr.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern int CertFreeAuthenticodeSignerInfo([In] ref AXL_SIGNER_INFO pSignerInfo);

		[DllImport("clr.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern int CertFreeAuthenticodeTimestamperInfo([In] ref AXL_TIMESTAMPER_INFO pTimestamperInfo);

		[DllImport("clr.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern int _AxlGetIssuerPublicKeyHash([In] IntPtr pCertContext, [In][Out] ref IntPtr ppwszPublicKeyHash);

		[DllImport("clr.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern int _AxlRSAKeyValueToPublicKeyToken([In] ref CRYPT_DATA_BLOB pModulusBlob, [In] ref CRYPT_DATA_BLOB pExponentBlob, [In][Out] ref IntPtr ppwszPublicKeyToken);

		[DllImport("clr.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern int _AxlPublicKeyBlobToPublicKeyToken([In] ref CRYPT_DATA_BLOB pCspPublicKeyBlob, [In][Out] ref IntPtr ppwszPublicKeyToken);

		[DllImport("crypt32.dll", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool CryptRetrieveTimeStamp([In][MarshalAs(UnmanagedType.LPWStr)] string wszUrl, [In] uint dwRetrievalFlags, [In] int dwTimeout, [In][MarshalAs(UnmanagedType.LPStr)] string pszHashId, [In][Out] ref CRYPT_TIMESTAMP_PARA pPara, [In] byte[] pbData, [In] int cbData, [In][Out] ref IntPtr ppTsContext, [In][Out] ref IntPtr ppTsSigner, [In][Out] ref IntPtr phStore);

		[DllImport("crypt32.dll", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool CryptVerifyTimeStampSignature([In] byte[] pbTSContentInfo, [In] int cbTSContentInfo, [In] byte[] pbData, [In] int cbData, [In] IntPtr hAdditionalStore, [In][Out] ref IntPtr ppTsContext, [In][Out] ref IntPtr ppTsSigner, [In][Out] ref IntPtr phStore);

		[DllImport("crypt32.dll", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern bool CertFreeCertificateContext(IntPtr pCertContext);

		[DllImport("crypt32.dll", SetLastError = true)]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern bool CertCloseStore(IntPtr pCertContext, int dwFlags);

		[DllImport("crypt32.dll")]
		[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
		internal static extern void CryptMemFree(IntPtr pv);
	}
	internal class ManifestSignedXml : SignedXml
	{
		private bool m_verify;

		internal ManifestSignedXml()
		{
		}

		internal ManifestSignedXml(XmlElement elem)
			: base(elem)
		{
		}

		internal ManifestSignedXml(XmlDocument document)
			: base(document)
		{
		}

		internal ManifestSignedXml(XmlDocument document, bool verify)
			: base(document)
		{
			m_verify = verify;
		}

		private static XmlElement FindIdElement(XmlElement context, string idValue)
		{
			if (context == null)
			{
				return null;
			}
			if (context.SelectSingleNode("//*[@Id=\"" + idValue + "\"]") is XmlElement result)
			{
				return result;
			}
			if (context.SelectSingleNode("//*[@id=\"" + idValue + "\"]") is XmlElement result2)
			{
				return result2;
			}
			return context.SelectSingleNode("//*[@ID=\"" + idValue + "\"]") as XmlElement;
		}

		public override XmlElement GetIdElement(XmlDocument document, string idValue)
		{
			if (m_verify)
			{
				return base.GetIdElement(document, idValue);
			}
			KeyInfo keyInfo = base.KeyInfo;
			if (keyInfo.Id != idValue)
			{
				return null;
			}
			return keyInfo.GetXml();
		}
	}
	internal class SignedCmiManifest
	{
		private XmlDocument m_manifestDom;

		private CmiStrongNameSignerInfo m_strongNameSignerInfo;

		private CmiAuthenticodeSignerInfo m_authenticodeSignerInfo;

		private const string AssemblyNamespaceUri = "urn:schemas-microsoft-com:asm.v1";

		private const string AssemblyV2NamespaceUri = "urn:schemas-microsoft-com:asm.v2";

		private const string MSRelNamespaceUri = "http://schemas.microsoft.com/windows/rel/2005/reldata";

		private const string LicenseNamespaceUri = "urn:mpeg:mpeg21:2003:01-REL-R-NS";

		private const string AuthenticodeNamespaceUri = "http://schemas.microsoft.com/windows/pki/2005/Authenticode";

		private const string licenseTemplate = "<r:license xmlns:r=\"urn:mpeg:mpeg21:2003:01-REL-R-NS\" xmlns:as=\"http://schemas.microsoft.com/windows/pki/2005/Authenticode\"><r:grant><as:ManifestInformation><as:assemblyIdentity /></as:ManifestInformation><as:SignedBy/><as:AuthenticodePublisher><as:X509SubjectName>CN=dummy</as:X509SubjectName></as:AuthenticodePublisher></r:grant><r:issuer></r:issuer></r:license>";

		private static readonly char[] hexValues = new char[16]
		{
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
			'a', 'b', 'c', 'd', 'e', 'f'
		};

		internal CmiStrongNameSignerInfo StrongNameSignerInfo => m_strongNameSignerInfo;

		internal CmiAuthenticodeSignerInfo AuthenticodeSignerInfo => m_authenticodeSignerInfo;

		private SignedCmiManifest()
		{
		}

		internal SignedCmiManifest(XmlDocument manifestDom)
		{
			if (manifestDom == null)
			{
				throw new ArgumentNullException("manifestDom");
			}
			m_manifestDom = manifestDom;
		}

		internal void Sign(CmiManifestSigner signer)
		{
			Sign(signer, null);
		}

		internal void Sign(CmiManifestSigner signer, string timeStampUrl)
		{
			m_strongNameSignerInfo = null;
			m_authenticodeSignerInfo = null;
			if (signer == null || signer.StrongNameKey == null)
			{
				throw new ArgumentNullException("signer");
			}
			RemoveExistingSignature(m_manifestDom);
			if ((signer.Flag & CmiManifestSignerFlag.DontReplacePublicKeyToken) == 0)
			{
				ReplacePublicKeyToken(m_manifestDom, signer.StrongNameKey);
			}
			XmlDocument licenseDom = null;
			if (signer.Certificate != null)
			{
				InsertPublisherIdentity(m_manifestDom, signer.Certificate);
				licenseDom = CreateLicenseDom(signer, ExtractPrincipalFromManifest(), ComputeHashFromManifest(m_manifestDom));
				AuthenticodeSignLicenseDom(licenseDom, signer, timeStampUrl);
			}
			StrongNameSignManifestDom(m_manifestDom, licenseDom, signer);
		}

		internal void Verify(CmiManifestVerifyFlags verifyFlags)
		{
			m_strongNameSignerInfo = null;
			m_authenticodeSignerInfo = null;
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			if (!(m_manifestDom.SelectSingleNode("//ds:Signature", xmlNamespaceManager) is XmlElement xmlElement))
			{
				throw new CryptographicException(-2146762496);
			}
			string name = "Id";
			if (!xmlElement.HasAttribute(name))
			{
				name = "id";
				if (!xmlElement.HasAttribute(name))
				{
					name = "ID";
					if (!xmlElement.HasAttribute(name))
					{
						throw new CryptographicException(-2146762749);
					}
				}
			}
			string attribute = xmlElement.GetAttribute(name);
			if (attribute == null || string.Compare(attribute, "StrongNameSignature", StringComparison.Ordinal) != 0)
			{
				throw new CryptographicException(-2146762749);
			}
			bool flag = false;
			XmlNodeList xmlNodeList = xmlElement.SelectNodes("ds:SignedInfo/ds:Reference", xmlNamespaceManager);
			foreach (XmlNode item in xmlNodeList)
			{
				if (!(item is XmlElement xmlElement2) || !xmlElement2.HasAttribute("URI"))
				{
					continue;
				}
				string attribute2 = xmlElement2.GetAttribute("URI");
				if (attribute2 == null || attribute2.Length != 0)
				{
					continue;
				}
				XmlNode xmlNode2 = xmlElement2.SelectSingleNode("ds:Transforms", xmlNamespaceManager);
				if (xmlNode2 == null)
				{
					throw new CryptographicException(-2146762749);
				}
				XmlNodeList xmlNodeList2 = xmlNode2.SelectNodes("ds:Transform", xmlNamespaceManager);
				if (xmlNodeList2.Count < 2)
				{
					throw new CryptographicException(-2146762749);
				}
				bool flag2 = false;
				bool flag3 = false;
				for (int i = 0; i < xmlNodeList2.Count; i++)
				{
					XmlElement xmlElement3 = xmlNodeList2[i] as XmlElement;
					string attribute3 = xmlElement3.GetAttribute("Algorithm");
					if (attribute3 == null)
					{
						break;
					}
					if (string.Compare(attribute3, "http://www.w3.org/2001/10/xml-exc-c14n#", StringComparison.Ordinal) != 0)
					{
						flag2 = true;
						if (flag3)
						{
							flag = true;
							break;
						}
					}
					else if (string.Compare(attribute3, "http://www.w3.org/2000/09/xmldsig#enveloped-signature", StringComparison.Ordinal) != 0)
					{
						flag3 = true;
						if (flag2)
						{
							flag = true;
							break;
						}
					}
				}
			}
			if (!flag)
			{
				throw new CryptographicException(-2146762749);
			}
			string publicKeyToken = VerifyPublicKeyToken();
			m_strongNameSignerInfo = new CmiStrongNameSignerInfo(-2146762485, publicKeyToken);
			ManifestSignedXml manifestSignedXml = new ManifestSignedXml(m_manifestDom, verify: true);
			manifestSignedXml.LoadXml(xmlElement);
			AsymmetricAlgorithm signingKey = null;
			bool flag4 = manifestSignedXml.CheckSignatureReturningKey(out signingKey);
			m_strongNameSignerInfo.PublicKey = signingKey;
			if (!flag4)
			{
				m_strongNameSignerInfo.ErrorCode = -2146869232;
				throw new CryptographicException(-2146869232);
			}
			if ((verifyFlags & CmiManifestVerifyFlags.StrongNameOnly) != CmiManifestVerifyFlags.StrongNameOnly)
			{
				VerifyLicense(verifyFlags);
			}
		}

		private unsafe void VerifyLicense(CmiManifestVerifyFlags verifyFlags)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("asm2", "urn:schemas-microsoft-com:asm.v2");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			xmlNamespaceManager.AddNamespace("msrel", "http://schemas.microsoft.com/windows/rel/2005/reldata");
			xmlNamespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
			xmlNamespaceManager.AddNamespace("as", "http://schemas.microsoft.com/windows/pki/2005/Authenticode");
			if (!(m_manifestDom.SelectSingleNode("asm:assembly/ds:Signature/ds:KeyInfo/msrel:RelData/r:license", xmlNamespaceManager) is XmlElement xmlElement))
			{
				return;
			}
			VerifyAssemblyIdentity(xmlNamespaceManager);
			m_authenticodeSignerInfo = new CmiAuthenticodeSignerInfo(-2146762485);
			byte[] bytes = Encoding.UTF8.GetBytes(xmlElement.OuterXml);
			fixed (byte* value = bytes)
			{
				Win32.AXL_SIGNER_INFO pSignerInfo = default(Win32.AXL_SIGNER_INFO);
				pSignerInfo.cbSize = (uint)Marshal.SizeOf(typeof(Win32.AXL_SIGNER_INFO));
				Win32.AXL_TIMESTAMPER_INFO pTimestamperInfo = default(Win32.AXL_TIMESTAMPER_INFO);
				pTimestamperInfo.cbSize = (uint)Marshal.SizeOf(typeof(Win32.AXL_TIMESTAMPER_INFO));
				Win32.CRYPT_DATA_BLOB pLicenseBlob = default(Win32.CRYPT_DATA_BLOB);
				IntPtr pbData = new IntPtr(value);
				pLicenseBlob.cbData = (uint)bytes.Length;
				pLicenseBlob.pbData = pbData;
				int num = Win32.CertVerifyAuthenticodeLicense(ref pLicenseBlob, (uint)verifyFlags, ref pSignerInfo, ref pTimestamperInfo);
				if (-2146762496 != (int)pSignerInfo.dwError)
				{
					m_authenticodeSignerInfo = new CmiAuthenticodeSignerInfo(pSignerInfo, pTimestamperInfo);
				}
				Win32.CertFreeAuthenticodeSignerInfo(ref pSignerInfo);
				Win32.CertFreeAuthenticodeTimestamperInfo(ref pTimestamperInfo);
				if (num != 0)
				{
					throw new CryptographicException(num);
				}
			}
			VerifyPublisherIdentity(xmlNamespaceManager);
		}

		private XmlElement ExtractPrincipalFromManifest()
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			XmlNode xmlNode = m_manifestDom.SelectSingleNode("asm:assembly/asm:assemblyIdentity", xmlNamespaceManager);
			if (xmlNode == null)
			{
				throw new CryptographicException(-2146762749);
			}
			return xmlNode as XmlElement;
		}

		private void VerifyAssemblyIdentity(XmlNamespaceManager nsm)
		{
			XmlElement xmlElement = m_manifestDom.SelectSingleNode("asm:assembly/asm:assemblyIdentity", nsm) as XmlElement;
			XmlElement xmlElement2 = m_manifestDom.SelectSingleNode("asm:assembly/ds:Signature/ds:KeyInfo/msrel:RelData/r:license/r:grant/as:ManifestInformation/as:assemblyIdentity", nsm) as XmlElement;
			if (xmlElement == null || xmlElement2 == null || !xmlElement.HasAttributes || !xmlElement2.HasAttributes)
			{
				throw new CryptographicException(-2146762749);
			}
			XmlAttributeCollection attributes = xmlElement.Attributes;
			if (attributes.Count == 0 || attributes.Count != xmlElement2.Attributes.Count)
			{
				throw new CryptographicException(-2146762749);
			}
			foreach (XmlAttribute item in attributes)
			{
				if (!xmlElement2.HasAttribute(item.LocalName) || item.Value != xmlElement2.GetAttribute(item.LocalName))
				{
					throw new CryptographicException(-2146762749);
				}
			}
			VerifyHash(nsm);
		}

		private void VerifyPublisherIdentity(XmlNamespaceManager nsm)
		{
			if (m_authenticodeSignerInfo.ErrorCode != -2146762496)
			{
				X509Certificate2 certificate = m_authenticodeSignerInfo.SignerChain.ChainElements[0].Certificate;
				if (!(m_manifestDom.SelectSingleNode("asm:assembly/asm2:publisherIdentity", nsm) is XmlElement xmlElement) || !xmlElement.HasAttributes)
				{
					throw new CryptographicException(-2146762749);
				}
				if (!xmlElement.HasAttribute("name") || !xmlElement.HasAttribute("issuerKeyHash"))
				{
					throw new CryptographicException(-2146762749);
				}
				string attribute = xmlElement.GetAttribute("name");
				string attribute2 = xmlElement.GetAttribute("issuerKeyHash");
				IntPtr ppwszPublicKeyHash = default(IntPtr);
				int num = Win32._AxlGetIssuerPublicKeyHash(certificate.Handle, ref ppwszPublicKeyHash);
				if (num != 0)
				{
					throw new CryptographicException(num);
				}
				string strB = Marshal.PtrToStringUni(ppwszPublicKeyHash);
				Win32.HeapFree(Win32.GetProcessHeap(), 0u, ppwszPublicKeyHash);
				if (string.Compare(attribute, certificate.SubjectName.Name, StringComparison.Ordinal) != 0 || string.Compare(attribute2, strB, StringComparison.Ordinal) != 0)
				{
					throw new CryptographicException(-2146762485);
				}
			}
		}

		private void VerifyHash(XmlNamespaceManager nsm)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			xmlDocument = (XmlDocument)m_manifestDom.Clone();
			if (!(xmlDocument.SelectSingleNode("asm:assembly/ds:Signature/ds:KeyInfo/msrel:RelData/r:license/r:grant/as:ManifestInformation", nsm) is XmlElement xmlElement))
			{
				throw new CryptographicException(-2146762749);
			}
			if (!xmlElement.HasAttribute("Hash"))
			{
				throw new CryptographicException(-2146762749);
			}
			string attribute = xmlElement.GetAttribute("Hash");
			if (attribute == null || attribute.Length == 0)
			{
				throw new CryptographicException(-2146762749);
			}
			if (!(xmlDocument.SelectSingleNode("asm:assembly/ds:Signature", nsm) is XmlElement xmlElement2))
			{
				throw new CryptographicException(-2146762749);
			}
			xmlElement2.ParentNode.RemoveChild(xmlElement2);
			byte[] array = HexStringToBytes(xmlElement.GetAttribute("Hash"));
			byte[] array2 = ComputeHashFromManifest(xmlDocument);
			if (array.Length == 0 || array.Length != array2.Length)
			{
				throw new CryptographicException(-2146869232);
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != array2[i])
				{
					throw new CryptographicException(-2146869232);
				}
			}
		}

		private unsafe string VerifyPublicKeyToken()
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			XmlElement xmlElement = m_manifestDom.SelectSingleNode("asm:assembly/ds:Signature/ds:KeyInfo/ds:KeyValue/ds:RSAKeyValue/ds:Modulus", xmlNamespaceManager) as XmlElement;
			XmlElement xmlElement2 = m_manifestDom.SelectSingleNode("asm:assembly/ds:Signature/ds:KeyInfo/ds:KeyValue/ds:RSAKeyValue/ds:Exponent", xmlNamespaceManager) as XmlElement;
			if (xmlElement == null || xmlElement2 == null)
			{
				throw new CryptographicException(-2146762749);
			}
			byte[] bytes = Encoding.UTF8.GetBytes(xmlElement.InnerXml);
			byte[] bytes2 = Encoding.UTF8.GetBytes(xmlElement2.InnerXml);
			string publicKeyToken = GetPublicKeyToken(m_manifestDom);
			byte[] array = HexStringToBytes(publicKeyToken);
			byte[] array2;
			fixed (byte* value = bytes)
			{
				fixed (byte* value2 = bytes2)
				{
					Win32.CRYPT_DATA_BLOB pModulusBlob = default(Win32.CRYPT_DATA_BLOB);
					Win32.CRYPT_DATA_BLOB pExponentBlob = default(Win32.CRYPT_DATA_BLOB);
					IntPtr ppwszPublicKeyToken = default(IntPtr);
					pModulusBlob.cbData = (uint)bytes.Length;
					pModulusBlob.pbData = new IntPtr(value);
					pExponentBlob.cbData = (uint)bytes2.Length;
					pExponentBlob.pbData = new IntPtr(value2);
					int num = Win32._AxlRSAKeyValueToPublicKeyToken(ref pModulusBlob, ref pExponentBlob, ref ppwszPublicKeyToken);
					if (num != 0)
					{
						throw new CryptographicException(num);
					}
					array2 = HexStringToBytes(Marshal.PtrToStringUni(ppwszPublicKeyToken));
					Win32.HeapFree(Win32.GetProcessHeap(), 0u, ppwszPublicKeyToken);
				}
			}
			if (array.Length == 0 || array.Length != array2.Length)
			{
				throw new CryptographicException(-2146762485);
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != array2[i])
				{
					throw new CryptographicException(-2146762485);
				}
			}
			return publicKeyToken;
		}

		private static void InsertPublisherIdentity(XmlDocument manifestDom, X509Certificate2 signerCert)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("asm2", "urn:schemas-microsoft-com:asm.v2");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			XmlElement xmlElement = manifestDom.SelectSingleNode("asm:assembly", xmlNamespaceManager) as XmlElement;
			if (!(manifestDom.SelectSingleNode("asm:assembly/asm:assemblyIdentity", xmlNamespaceManager) is XmlElement))
			{
				throw new CryptographicException(-2146762749);
			}
			XmlElement xmlElement3 = manifestDom.SelectSingleNode("asm:assembly/asm2:publisherIdentity", xmlNamespaceManager) as XmlElement;
			if (xmlElement3 == null)
			{
				xmlElement3 = manifestDom.CreateElement("publisherIdentity", "urn:schemas-microsoft-com:asm.v2");
			}
			IntPtr ppwszPublicKeyHash = default(IntPtr);
			int num = Win32._AxlGetIssuerPublicKeyHash(signerCert.Handle, ref ppwszPublicKeyHash);
			if (num != 0)
			{
				throw new CryptographicException(num);
			}
			string value = Marshal.PtrToStringUni(ppwszPublicKeyHash);
			Win32.HeapFree(Win32.GetProcessHeap(), 0u, ppwszPublicKeyHash);
			xmlElement3.SetAttribute("name", signerCert.SubjectName.Name);
			xmlElement3.SetAttribute("issuerKeyHash", value);
			if (manifestDom.SelectSingleNode("asm:assembly/ds:Signature", xmlNamespaceManager) is XmlElement refChild)
			{
				xmlElement.InsertBefore(xmlElement3, refChild);
			}
			else
			{
				xmlElement.AppendChild(xmlElement3);
			}
		}

		private static void RemoveExistingSignature(XmlDocument manifestDom)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			XmlNode xmlNode = manifestDom.SelectSingleNode("asm:assembly/ds:Signature", xmlNamespaceManager);
			xmlNode?.ParentNode.RemoveChild(xmlNode);
		}

		private unsafe static void ReplacePublicKeyToken(XmlDocument manifestDom, AsymmetricAlgorithm snKey)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			if (!(manifestDom.SelectSingleNode("asm:assembly/asm:assemblyIdentity", xmlNamespaceManager) is XmlElement xmlElement))
			{
				throw new CryptographicException(-2146762749);
			}
			if (!xmlElement.HasAttribute("publicKeyToken"))
			{
				throw new CryptographicException(-2146762749);
			}
			byte[] array = ((RSACryptoServiceProvider)snKey).ExportCspBlob(includePrivateParameters: false);
			if (array == null || array.Length == 0)
			{
				throw new CryptographicException(-2146893821);
			}
			fixed (byte* value = array)
			{
				Win32.CRYPT_DATA_BLOB pCspPublicKeyBlob = default(Win32.CRYPT_DATA_BLOB);
				pCspPublicKeyBlob.cbData = (uint)array.Length;
				pCspPublicKeyBlob.pbData = new IntPtr(value);
				IntPtr ppwszPublicKeyToken = default(IntPtr);
				int num = Win32._AxlPublicKeyBlobToPublicKeyToken(ref pCspPublicKeyBlob, ref ppwszPublicKeyToken);
				if (num != 0)
				{
					throw new CryptographicException(num);
				}
				string value2 = Marshal.PtrToStringUni(ppwszPublicKeyToken);
				Win32.HeapFree(Win32.GetProcessHeap(), 0u, ppwszPublicKeyToken);
				xmlElement.SetAttribute("publicKeyToken", value2);
			}
		}

		private static string GetPublicKeyToken(XmlDocument manifestDom)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			if (!(manifestDom.SelectSingleNode("asm:assembly/asm:assemblyIdentity", xmlNamespaceManager) is XmlElement xmlElement) || !xmlElement.HasAttribute("publicKeyToken"))
			{
				throw new CryptographicException(-2146762749);
			}
			return xmlElement.GetAttribute("publicKeyToken");
		}

		private static byte[] ComputeHashFromManifest(XmlDocument manifestDom)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			using (TextReader input = new StringReader(manifestDom.OuterXml))
			{
				XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
				xmlReaderSettings.DtdProcessing = DtdProcessing.Parse;
				XmlReader reader = XmlReader.Create(input, xmlReaderSettings, manifestDom.BaseURI);
				xmlDocument.Load(reader);
			}
			XmlDsigExcC14NTransform xmlDsigExcC14NTransform = new XmlDsigExcC14NTransform();
			xmlDsigExcC14NTransform.LoadInput(xmlDocument);
			using SHA1CryptoServiceProvider sHA1CryptoServiceProvider = new SHA1CryptoServiceProvider();
			byte[] array = sHA1CryptoServiceProvider.ComputeHash(xmlDsigExcC14NTransform.GetOutput() as MemoryStream);
			if (array == null)
			{
				throw new CryptographicException(-2146869232);
			}
			return array;
		}

		private static XmlDocument CreateLicenseDom(CmiManifestSigner signer, XmlElement principal, byte[] hash)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			xmlDocument.LoadXml("<r:license xmlns:r=\"urn:mpeg:mpeg21:2003:01-REL-R-NS\" xmlns:as=\"http://schemas.microsoft.com/windows/pki/2005/Authenticode\"><r:grant><as:ManifestInformation><as:assemblyIdentity /></as:ManifestInformation><as:SignedBy/><as:AuthenticodePublisher><as:X509SubjectName>CN=dummy</as:X509SubjectName></as:AuthenticodePublisher></r:grant><r:issuer></r:issuer></r:license>");
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(xmlDocument.NameTable);
			xmlNamespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
			xmlNamespaceManager.AddNamespace("as", "http://schemas.microsoft.com/windows/pki/2005/Authenticode");
			XmlElement xmlElement = xmlDocument.SelectSingleNode("r:license/r:grant/as:ManifestInformation/as:assemblyIdentity", xmlNamespaceManager) as XmlElement;
			xmlElement.RemoveAllAttributes();
			foreach (XmlAttribute attribute in principal.Attributes)
			{
				xmlElement.SetAttribute(attribute.Name, attribute.Value);
			}
			XmlElement xmlElement2 = xmlDocument.SelectSingleNode("r:license/r:grant/as:ManifestInformation", xmlNamespaceManager) as XmlElement;
			xmlElement2.SetAttribute("Hash", (hash.Length == 0) ? "" : BytesToHexString(hash, 0, hash.Length));
			xmlElement2.SetAttribute("Description", (signer.Description == null) ? "" : signer.Description);
			xmlElement2.SetAttribute("Url", (signer.DescriptionUrl == null) ? "" : signer.DescriptionUrl);
			XmlElement xmlElement3 = xmlDocument.SelectSingleNode("r:license/r:grant/as:AuthenticodePublisher/as:X509SubjectName", xmlNamespaceManager) as XmlElement;
			xmlElement3.InnerText = signer.Certificate.SubjectName.Name;
			return xmlDocument;
		}

		private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManifestSigner signer, string timeStampUrl)
		{
			RSA rSAPublicKey = System.Security.Cryptography.CngLightup.GetRSAPublicKey(signer.Certificate);
			if (rSAPublicKey == null)
			{
				throw new NotSupportedException();
			}
			ManifestSignedXml manifestSignedXml = new ManifestSignedXml(licenseDom);
			manifestSignedXml.SigningKey = System.Security.Cryptography.CngLightup.GetRSAPrivateKey(signer.Certificate);
			manifestSignedXml.SignedInfo.CanonicalizationMethod = "http://www.w3.org/2001/10/xml-exc-c14n#";
			manifestSignedXml.KeyInfo.AddClause(new RSAKeyValue(rSAPublicKey));
			manifestSignedXml.KeyInfo.AddClause(new KeyInfoX509Data(signer.Certificate, signer.IncludeOption));
			Reference reference = new Reference();
			reference.Uri = "";
			reference.AddTransform(new XmlDsigEnvelopedSignatureTransform());
			reference.AddTransform(new XmlDsigExcC14NTransform());
			manifestSignedXml.AddReference(reference);
			manifestSignedXml.ComputeSignature();
			XmlElement xml = manifestSignedXml.GetXml();
			xml.SetAttribute("Id", "AuthenticodeSignature");
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(licenseDom.NameTable);
			xmlNamespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
			XmlElement xmlElement = licenseDom.SelectSingleNode("r:license/r:issuer", xmlNamespaceManager) as XmlElement;
			xmlElement.AppendChild(licenseDom.ImportNode(xml, deep: true));
			if (timeStampUrl != null && timeStampUrl.Length != 0)
			{
				TimestampSignedLicenseDom(licenseDom, timeStampUrl);
			}
			licenseDom.DocumentElement.ParentNode.InnerXml = "<msrel:RelData xmlns:msrel=\"http://schemas.microsoft.com/windows/rel/2005/reldata\">" + licenseDom.OuterXml + "</msrel:RelData>";
		}

		private unsafe static void TimestampSignedLicenseDom(XmlDocument licenseDom, string timeStampUrl)
		{
			Win32.CRYPT_DATA_BLOB pTimestampSignatureBlob = default(Win32.CRYPT_DATA_BLOB);
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(licenseDom.NameTable);
			xmlNamespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			xmlNamespaceManager.AddNamespace("as", "http://schemas.microsoft.com/windows/pki/2005/Authenticode");
			byte[] bytes = Encoding.UTF8.GetBytes(licenseDom.OuterXml);
			fixed (byte* value = bytes)
			{
				Win32.CRYPT_DATA_BLOB pSignedLicenseBlob = default(Win32.CRYPT_DATA_BLOB);
				IntPtr pbData = new IntPtr(value);
				pSignedLicenseBlob.cbData = (uint)bytes.Length;
				pSignedLicenseBlob.pbData = pbData;
				int num = Win32.CertTimestampAuthenticodeLicense(ref pSignedLicenseBlob, timeStampUrl, ref pTimestampSignatureBlob);
				if (num != 0)
				{
					throw new CryptographicException(num);
				}
			}
			byte[] array = new byte[pTimestampSignatureBlob.cbData];
			Marshal.Copy(pTimestampSignatureBlob.pbData, array, 0, array.Length);
			Win32.HeapFree(Win32.GetProcessHeap(), 0u, pTimestampSignatureBlob.pbData);
			XmlElement xmlElement = licenseDom.CreateElement("as", "Timestamp", "http://schemas.microsoft.com/windows/pki/2005/Authenticode");
			xmlElement.InnerText = Encoding.UTF8.GetString(array);
			XmlElement xmlElement2 = licenseDom.CreateElement("Object", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement2.AppendChild(xmlElement);
			XmlElement xmlElement3 = licenseDom.SelectSingleNode("r:license/r:issuer/ds:Signature", xmlNamespaceManager) as XmlElement;
			xmlElement3.AppendChild(xmlElement2);
		}

		private static void StrongNameSignManifestDom(XmlDocument manifestDom, XmlDocument licenseDom, CmiManifestSigner signer)
		{
			if (!(signer.StrongNameKey is RSA key))
			{
				throw new NotSupportedException();
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			if (!(manifestDom.SelectSingleNode("asm:assembly", xmlNamespaceManager) is XmlElement xmlElement))
			{
				throw new CryptographicException(-2146762749);
			}
			ManifestSignedXml manifestSignedXml = new ManifestSignedXml(xmlElement);
			manifestSignedXml.SigningKey = signer.StrongNameKey;
			manifestSignedXml.SignedInfo.CanonicalizationMethod = "http://www.w3.org/2001/10/xml-exc-c14n#";
			manifestSignedXml.KeyInfo.AddClause(new RSAKeyValue(key));
			if (licenseDom != null)
			{
				manifestSignedXml.KeyInfo.AddClause(new KeyInfoNode(licenseDom.DocumentElement));
			}
			manifestSignedXml.KeyInfo.Id = "StrongNameKeyInfo";
			Reference reference = new Reference();
			reference.Uri = "";
			reference.AddTransform(new XmlDsigEnvelopedSignatureTransform());
			reference.AddTransform(new XmlDsigExcC14NTransform());
			manifestSignedXml.AddReference(reference);
			manifestSignedXml.ComputeSignature();
			XmlElement xml = manifestSignedXml.GetXml();
			xml.SetAttribute("Id", "StrongNameSignature");
			xmlElement.AppendChild(xml);
		}

		private static string BytesToHexString(byte[] array, int start, int end)
		{
			string result = null;
			if (array != null)
			{
				char[] array2 = new char[(end - start) * 2];
				int num = end;
				int num2 = 0;
				while (num-- > start)
				{
					int num3 = (array[num] & 0xF0) >> 4;
					array2[num2++] = hexValues[num3];
					num3 = array[num] & 0xF;
					array2[num2++] = hexValues[num3];
				}
				result = new string(array2);
			}
			return result;
		}

		private static byte[] HexStringToBytes(string hexString)
		{
			uint num = (uint)hexString.Length / 2u;
			byte[] array = new byte[num];
			int num2 = hexString.Length - 2;
			for (int i = 0; i < num; i++)
			{
				array[i] = (byte)((HexToByte(hexString[num2]) << 4) | HexToByte(hexString[num2 + 1]));
				num2 -= 2;
			}
			return array;
		}

		private static byte HexToByte(char val)
		{
			if (val <= '9' && val >= '0')
			{
				return (byte)(val - 48);
			}
			if (val >= 'a' && val <= 'f')
			{
				return (byte)(val - 97 + 10);
			}
			if (val >= 'A' && val <= 'F')
			{
				return (byte)(val - 65 + 10);
			}
			return byte.MaxValue;
		}
	}
	[Flags]
	internal enum CmiManifestSignerFlag
	{
		None = 0,
		DontReplacePublicKeyToken = 1
	}
	[Flags]
	internal enum CmiManifestVerifyFlags
	{
		None = 0,
		RevocationNoCheck = 1,
		RevocationCheckEndCertOnly = 2,
		RevocationCheckEntireChain = 4,
		UrlCacheOnlyRetrieval = 8,
		LifetimeSigning = 0x10,
		TrustMicrosoftRootOnly = 0x20,
		StrongNameOnly = 0x10000
	}
	internal class CmiManifestSigner
	{
		private AsymmetricAlgorithm m_strongNameKey;

		private X509Certificate2 m_certificate;

		private string m_description;

		private string m_url;

		private X509Certificate2Collection m_certificates;

		private X509IncludeOption m_includeOption;

		private CmiManifestSignerFlag m_signerFlag;

		internal const uint CimManifestSignerFlagMask = 1u;

		internal AsymmetricAlgorithm StrongNameKey => m_strongNameKey;

		internal X509Certificate2 Certificate => m_certificate;

		internal string Description
		{
			get
			{
				return m_description;
			}
			set
			{
				m_description = value;
			}
		}

		internal string DescriptionUrl
		{
			get
			{
				return m_url;
			}
			set
			{
				m_url = value;
			}
		}

		internal X509Certificate2Collection ExtraStore => m_certificates;

		internal X509IncludeOption IncludeOption
		{
			get
			{
				return m_includeOption;
			}
			set
			{
				if (value < X509IncludeOption.None || value > X509IncludeOption.WholeChain)
				{
					throw new ArgumentException("value");
				}
				if (m_includeOption == X509IncludeOption.None)
				{
					throw new NotSupportedException();
				}
				m_includeOption = value;
			}
		}

		internal CmiManifestSignerFlag Flag
		{
			get
			{
				return m_signerFlag;
			}
			set
			{
				if (((uint)value & 0xFFFFFFFEu) != 0)
				{
					throw new ArgumentException("value");
				}
				m_signerFlag = value;
			}
		}

		private CmiManifestSigner()
		{
		}

		internal CmiManifestSigner(AsymmetricAlgorithm strongNameKey)
			: this(strongNameKey, null)
		{
		}

		internal CmiManifestSigner(AsymmetricAlgorithm strongNameKey, X509Certificate2 certificate)
		{
			if (strongNameKey == null)
			{
				throw new ArgumentNullException("strongNameKey");
			}
			if (!(strongNameKey is RSA))
			{
				throw new ArgumentNullException("strongNameKey");
			}
			m_strongNameKey = strongNameKey;
			m_certificate = certificate;
			m_certificates = new X509Certificate2Collection();
			m_includeOption = X509IncludeOption.ExcludeRoot;
			m_signerFlag = CmiManifestSignerFlag.None;
		}
	}
	internal class CmiStrongNameSignerInfo
	{
		private int m_error;

		private string m_publicKeyToken;

		private AsymmetricAlgorithm m_snKey;

		internal int ErrorCode
		{
			get
			{
				return m_error;
			}
			set
			{
				m_error = value;
			}
		}

		internal string PublicKeyToken
		{
			get
			{
				return m_publicKeyToken;
			}
			set
			{
				m_publicKeyToken = value;
			}
		}

		internal AsymmetricAlgorithm PublicKey
		{
			get
			{
				return m_snKey;
			}
			set
			{
				m_snKey = value;
			}
		}

		internal CmiStrongNameSignerInfo()
		{
		}

		internal CmiStrongNameSignerInfo(int errorCode, string publicKeyToken)
		{
			m_error = errorCode;
			m_publicKeyToken = publicKeyToken;
		}
	}
	internal class CmiAuthenticodeSignerInfo
	{
		private int m_error;

		private X509Chain m_signerChain;

		private uint m_algHash;

		private string m_hash;

		private string m_description;

		private string m_descriptionUrl;

		private CmiAuthenticodeTimestamperInfo m_timestamperInfo;

		internal int ErrorCode
		{
			get
			{
				return m_error;
			}
			set
			{
				m_error = value;
			}
		}

		internal uint HashAlgId
		{
			get
			{
				return m_algHash;
			}
			set
			{
				m_algHash = value;
			}
		}

		internal string Hash
		{
			get
			{
				return m_hash;
			}
			set
			{
				m_hash = value;
			}
		}

		internal string Description
		{
			get
			{
				return m_description;
			}
			set
			{
				m_description = value;
			}
		}

		internal string DescriptionUrl
		{
			get
			{
				return m_descriptionUrl;
			}
			set
			{
				m_descriptionUrl = value;
			}
		}

		internal CmiAuthenticodeTimestamperInfo TimestamperInfo => m_timestamperInfo;

		internal X509Chain SignerChain
		{
			get
			{
				return m_signerChain;
			}
			set
			{
				m_signerChain = value;
			}
		}

		internal CmiAuthenticodeSignerInfo()
		{
		}

		internal CmiAuthenticodeSignerInfo(int errorCode)
		{
			m_error = errorCode;
		}

		internal CmiAuthenticodeSignerInfo(Win32.AXL_SIGNER_INFO signerInfo, Win32.AXL_TIMESTAMPER_INFO timestamperInfo)
		{
			m_error = (int)signerInfo.dwError;
			if (signerInfo.pChainContext != IntPtr.Zero)
			{
				m_signerChain = new X509Chain(signerInfo.pChainContext);
			}
			m_algHash = signerInfo.algHash;
			if (signerInfo.pwszHash != IntPtr.Zero)
			{
				m_hash = Marshal.PtrToStringUni(signerInfo.pwszHash);
			}
			if (signerInfo.pwszDescription != IntPtr.Zero)
			{
				m_description = Marshal.PtrToStringUni(signerInfo.pwszDescription);
			}
			if (signerInfo.pwszDescriptionUrl != IntPtr.Zero)
			{
				m_descriptionUrl = Marshal.PtrToStringUni(signerInfo.pwszDescriptionUrl);
			}
			if (timestamperInfo.dwError != 2148204800u)
			{
				m_timestamperInfo = new CmiAuthenticodeTimestamperInfo(timestamperInfo);
			}
		}
	}
	internal class CmiAuthenticodeTimestamperInfo
	{
		private int m_error;

		private X509Chain m_timestamperChain;

		private DateTime m_timestampTime;

		private uint m_algHash;

		internal int ErrorCode => m_error;

		internal uint HashAlgId => m_algHash;

		internal DateTime TimestampTime => m_timestampTime;

		internal X509Chain TimestamperChain => m_timestamperChain;

		private CmiAuthenticodeTimestamperInfo()
		{
		}

		internal CmiAuthenticodeTimestamperInfo(Win32.AXL_TIMESTAMPER_INFO timestamperInfo)
		{
			m_error = (int)timestamperInfo.dwError;
			m_algHash = timestamperInfo.algHash;
			long fileTime = (long)(((ulong)(uint)timestamperInfo.ftTimestamp.dwHighDateTime << 32) | (uint)timestamperInfo.ftTimestamp.dwLowDateTime);
			m_timestampTime = DateTime.FromFileTime(fileTime);
			if (timestamperInfo.pChainContext != IntPtr.Zero)
			{
				m_timestamperChain = new X509Chain(timestamperInfo.pChainContext);
			}
		}
	}
	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	internal struct BLOBHEADER
	{
		internal byte bType;

		internal byte bVersion;

		internal short reserved;

		internal uint aiKeyAlg;
	}
	internal class ManifestSignedXml2 : SignedXml
	{
		private bool m_verify;

		private const string Sha256SignatureMethodUri = "http://www.w3.org/2000/09/xmldsig#rsa-sha256";

		private const string Sha256DigestMethod = "http://www.w3.org/2000/09/xmldsig#sha256";

		internal ManifestSignedXml2()
		{
			init();
		}

		internal ManifestSignedXml2(XmlElement elem)
			: base(elem)
		{
			init();
		}

		internal ManifestSignedXml2(XmlDocument document)
			: base(document)
		{
			init();
		}

		internal ManifestSignedXml2(XmlDocument document, bool verify)
			: base(document)
		{
			m_verify = verify;
			init();
		}

		private void init()
		{
			CryptoConfig.AddAlgorithm(typeof(RSAPKCS1SHA256SignatureDescription), "http://www.w3.org/2000/09/xmldsig#rsa-sha256");
			CryptoConfig.AddAlgorithm(typeof(SHA256Cng), "http://www.w3.org/2000/09/xmldsig#sha256");
		}

		public override XmlElement GetIdElement(XmlDocument document, string idValue)
		{
			if (m_verify)
			{
				return base.GetIdElement(document, idValue);
			}
			KeyInfo keyInfo = base.KeyInfo;
			if (keyInfo.Id != idValue)
			{
				return null;
			}
			return keyInfo.GetXml();
		}
	}
	internal class SignedCmiManifest2
	{
		private XmlDocument m_manifestDom;

		private CmiStrongNameSignerInfo m_strongNameSignerInfo;

		private CmiAuthenticodeSignerInfo m_authenticodeSignerInfo;

		private bool m_useSha256;

		private const string Sha256SignatureMethodUri = "http://www.w3.org/2000/09/xmldsig#rsa-sha256";

		private const string Sha256DigestMethod = "http://www.w3.org/2000/09/xmldsig#sha256";

		private const string wintrustPolicyFlagsRegPath = "Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing";

		private const string wintrustPolicyFlagsRegName = "State";

		private const string AssemblyNamespaceUri = "urn:schemas-microsoft-com:asm.v1";

		private const string AssemblyV2NamespaceUri = "urn:schemas-microsoft-com:asm.v2";

		private const string MSRelNamespaceUri = "http://schemas.microsoft.com/windows/rel/2005/reldata";

		private const string LicenseNamespaceUri = "urn:mpeg:mpeg21:2003:01-REL-R-NS";

		private const string AuthenticodeNamespaceUri = "http://schemas.microsoft.com/windows/pki/2005/Authenticode";

		private const string licenseTemplate = "<r:license xmlns:r=\"urn:mpeg:mpeg21:2003:01-REL-R-NS\" xmlns:as=\"http://schemas.microsoft.com/windows/pki/2005/Authenticode\"><r:grant><as:ManifestInformation><as:assemblyIdentity /></as:ManifestInformation><as:SignedBy/><as:AuthenticodePublisher><as:X509SubjectName>CN=dummy</as:X509SubjectName></as:AuthenticodePublisher></r:grant><r:issuer></r:issuer></r:license>";

		private static readonly char[] hexValues = new char[16]
		{
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
			'a', 'b', 'c', 'd', 'e', 'f'
		};

		internal CmiStrongNameSignerInfo StrongNameSignerInfo => m_strongNameSignerInfo;

		internal CmiAuthenticodeSignerInfo AuthenticodeSignerInfo => m_authenticodeSignerInfo;

		private SignedCmiManifest2()
		{
		}

		internal SignedCmiManifest2(XmlDocument manifestDom, bool useSha256)
		{
			if (manifestDom == null)
			{
				throw new ArgumentNullException("manifestDom");
			}
			m_manifestDom = manifestDom;
			m_useSha256 = useSha256;
		}

		internal void Sign(CmiManifestSigner2 signer)
		{
			Sign(signer, null);
		}

		internal void Sign(CmiManifestSigner2 signer, string timeStampUrl)
		{
			m_strongNameSignerInfo = null;
			m_authenticodeSignerInfo = null;
			if (signer == null || signer.StrongNameKey == null)
			{
				throw new ArgumentNullException("signer");
			}
			RemoveExistingSignature(m_manifestDom);
			if ((signer.Flag & CmiManifestSignerFlag.DontReplacePublicKeyToken) == 0)
			{
				ReplacePublicKeyToken(m_manifestDom, signer.StrongNameKey, m_useSha256);
			}
			XmlDocument licenseDom = null;
			if (signer.Certificate != null)
			{
				InsertPublisherIdentity(m_manifestDom, signer.Certificate);
				licenseDom = CreateLicenseDom(signer, ExtractPrincipalFromManifest(), ComputeHashFromManifest(m_manifestDom, m_useSha256));
				AuthenticodeSignLicenseDom(licenseDom, signer, timeStampUrl, m_useSha256);
			}
			StrongNameSignManifestDom(m_manifestDom, licenseDom, signer, m_useSha256);
		}

		internal void Verify(CmiManifestVerifyFlags verifyFlags)
		{
			m_strongNameSignerInfo = null;
			m_authenticodeSignerInfo = null;
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			if (!(GetSingleNode(m_manifestDom, "//ds:Signature[@Id=\"StrongNameSignature\"]", xmlNamespaceManager) is XmlElement xmlElement))
			{
				throw new CryptographicException(-2146762496);
			}
			VerifySignatureForm(xmlElement, "StrongNameSignature", xmlNamespaceManager);
			string publicKeyToken = VerifyPublicKeyToken();
			m_strongNameSignerInfo = new CmiStrongNameSignerInfo(-2146762485, publicKeyToken);
			ManifestSignedXml2 manifestSignedXml = new ManifestSignedXml2(m_manifestDom, verify: true);
			manifestSignedXml.LoadXml(xmlElement);
			if (m_useSha256)
			{
				manifestSignedXml.SignedInfo.SignatureMethod = "http://www.w3.org/2000/09/xmldsig#rsa-sha256";
			}
			AsymmetricAlgorithm signingKey = null;
			bool flag = manifestSignedXml.CheckSignatureReturningKey(out signingKey);
			m_strongNameSignerInfo.PublicKey = signingKey;
			if (!flag)
			{
				m_strongNameSignerInfo.ErrorCode = -2146869232;
				throw new CryptographicException(-2146869232);
			}
			if ((verifyFlags & CmiManifestVerifyFlags.StrongNameOnly) != CmiManifestVerifyFlags.StrongNameOnly)
			{
				if (m_useSha256)
				{
					VerifyLicenseNew(verifyFlags);
				}
				else
				{
					VerifyLicense(verifyFlags);
				}
			}
		}

		private unsafe void VerifyLicense(CmiManifestVerifyFlags verifyFlags)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("asm2", "urn:schemas-microsoft-com:asm.v2");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			xmlNamespaceManager.AddNamespace("msrel", "http://schemas.microsoft.com/windows/rel/2005/reldata");
			xmlNamespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
			xmlNamespaceManager.AddNamespace("as", "http://schemas.microsoft.com/windows/pki/2005/Authenticode");
			if (!(GetSingleNode(m_manifestDom, "asm:assembly/ds:Signature/ds:KeyInfo/msrel:RelData/r:license", xmlNamespaceManager) is XmlElement xmlElement))
			{
				return;
			}
			if (!OverrideTimestampImprovements(xmlNamespaceManager))
			{
				XmlNodeList xmlNodeList = xmlElement.SelectNodes("r:issuer/ds:Signature", xmlNamespaceManager);
				if (xmlNodeList == null || xmlNodeList.Count != 1)
				{
					m_authenticodeSignerInfo.ErrorCode = -2146762496;
					throw new CryptographicException(-2146762496);
				}
				VerifySignatureTimestampNew(xmlNodeList[0] as XmlElement, xmlNamespaceManager, out var _);
			}
			VerifyAssemblyIdentity(xmlNamespaceManager);
			m_authenticodeSignerInfo = new CmiAuthenticodeSignerInfo(-2146762485);
			byte[] bytes = Encoding.UTF8.GetBytes(xmlElement.OuterXml);
			fixed (byte* value = bytes)
			{
				Win32.AXL_SIGNER_INFO pSignerInfo = default(Win32.AXL_SIGNER_INFO);
				pSignerInfo.cbSize = (uint)Marshal.SizeOf(typeof(Win32.AXL_SIGNER_INFO));
				Win32.AXL_TIMESTAMPER_INFO pTimestamperInfo = default(Win32.AXL_TIMESTAMPER_INFO);
				pTimestamperInfo.cbSize = (uint)Marshal.SizeOf(typeof(Win32.AXL_TIMESTAMPER_INFO));
				Win32.CRYPT_DATA_BLOB pLicenseBlob = default(Win32.CRYPT_DATA_BLOB);
				IntPtr pbData = new IntPtr(value);
				pLicenseBlob.cbData = (uint)bytes.Length;
				pLicenseBlob.pbData = pbData;
				int num = Win32.CertVerifyAuthenticodeLicense(ref pLicenseBlob, (uint)verifyFlags, ref pSignerInfo, ref pTimestamperInfo);
				if (-2146762496 != (int)pSignerInfo.dwError)
				{
					m_authenticodeSignerInfo = new CmiAuthenticodeSignerInfo(pSignerInfo, pTimestamperInfo);
				}
				Win32.CertFreeAuthenticodeSignerInfo(ref pSignerInfo);
				Win32.CertFreeAuthenticodeTimestamperInfo(ref pTimestamperInfo);
				if (num != 0)
				{
					throw new CryptographicException(num);
				}
			}
			VerifyPublisherIdentity(xmlNamespaceManager);
		}

		private void VerifyLicenseNew(CmiManifestVerifyFlags verifyFlags)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("asm2", "urn:schemas-microsoft-com:asm.v2");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			xmlNamespaceManager.AddNamespace("msrel", "http://schemas.microsoft.com/windows/rel/2005/reldata");
			xmlNamespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
			xmlNamespaceManager.AddNamespace("as", "http://schemas.microsoft.com/windows/pki/2005/Authenticode");
			if (!(GetSingleNode(m_manifestDom, "asm:assembly/ds:Signature/ds:KeyInfo/msrel:RelData/r:license", xmlNamespaceManager) is XmlElement xmlElement))
			{
				return;
			}
			VerifyAssemblyIdentity(xmlNamespaceManager);
			m_authenticodeSignerInfo = new CmiAuthenticodeSignerInfo(-2146762485);
			if (!(GetSingleNode(xmlElement, "//r:issuer/ds:Signature", xmlNamespaceManager) is XmlElement signatureNode))
			{
				throw new CryptographicException(-2146762496);
			}
			VerifySignatureForm(signatureNode, "AuthenticodeSignature", xmlNamespaceManager);
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.LoadXml(xmlElement.OuterXml);
			XmlElement xmlElement2 = GetSingleNode(xmlDocument, "//r:issuer/ds:Signature", xmlNamespaceManager) as XmlElement;
			ManifestSignedXml2 manifestSignedXml = new ManifestSignedXml2(xmlDocument);
			manifestSignedXml.LoadXml(xmlElement2);
			if (m_useSha256)
			{
				manifestSignedXml.SignedInfo.SignatureMethod = "http://www.w3.org/2000/09/xmldsig#rsa-sha256";
			}
			if (!manifestSignedXml.CheckSignature())
			{
				m_authenticodeSignerInfo = null;
				throw new CryptographicException(-2146869244);
			}
			X509Certificate2 signingCertificate = GetSigningCertificate(manifestSignedXml, xmlNamespaceManager);
			X509Store x509Store = new X509Store(StoreName.Disallowed, StoreLocation.CurrentUser);
			x509Store.Open(OpenFlags.OpenExistingOnly);
			X509Certificate2Collection x509Certificate2Collection = null;
			try
			{
				x509Certificate2Collection = x509Store.Certificates;
				if (x509Certificate2Collection == null)
				{
					m_authenticodeSignerInfo.ErrorCode = -2146762485;
					throw new CryptographicException(-2146762485);
				}
				if (x509Certificate2Collection.Contains(signingCertificate))
				{
					m_authenticodeSignerInfo.ErrorCode = -2146762479;
					throw new CryptographicException(-2146762479);
				}
			}
			finally
			{
				x509Store.Close();
			}
			if (!GetManifestInformation(xmlElement, xmlNamespaceManager, out var hash, out var description, out var url))
			{
				m_authenticodeSignerInfo.ErrorCode = -2146762749;
				throw new CryptographicException(-2146762749);
			}
			m_authenticodeSignerInfo.Hash = hash;
			m_authenticodeSignerInfo.Description = description;
			m_authenticodeSignerInfo.DescriptionUrl = url;
			DateTime verificationTime;
			bool flag = (OverrideTimestampImprovements(xmlNamespaceManager) ? VerifySignatureTimestamp(xmlElement2, xmlNamespaceManager, out verificationTime) : VerifySignatureTimestampNew(xmlElement2, xmlNamespaceManager, out verificationTime));
			bool flag2 = false;
			if (flag)
			{
				flag2 = (verifyFlags & CmiManifestVerifyFlags.LifetimeSigning) == CmiManifestVerifyFlags.LifetimeSigning;
				if (!flag2)
				{
					flag2 = GetLifetimeSigning(signingCertificate);
				}
			}
			uint authenticodePolicies = GetAuthenticodePolicies();
			X509Chain x509Chain = new X509Chain();
			x509Chain.ChainPolicy.RevocationFlag = X509RevocationFlag.ExcludeRoot;
			x509Chain.ChainPolicy.RevocationMode = X509RevocationMode.Online;
			if ((CmiManifestVerifyFlags.RevocationCheckEndCertOnly & verifyFlags) == CmiManifestVerifyFlags.RevocationCheckEndCertOnly)
			{
				x509Chain.ChainPolicy.RevocationFlag = X509RevocationFlag.EndCertificateOnly;
			}
			else if ((CmiManifestVerifyFlags.RevocationCheckEntireChain & verifyFlags) == CmiManifestVerifyFlags.RevocationCheckEntireChain)
			{
				x509Chain.ChainPolicy.RevocationFlag = X509RevocationFlag.EntireChain;
			}
			else if ((CmiManifestVerifyFlags.RevocationNoCheck & verifyFlags) == CmiManifestVerifyFlags.RevocationNoCheck || (0x200 & authenticodePolicies) == 512)
			{
				x509Chain.ChainPolicy.RevocationMode = X509RevocationMode.NoCheck;
			}
			x509Chain.ChainPolicy.VerificationTime = verificationTime;
			if (flag && flag2)
			{
				x509Chain.ChainPolicy.ApplicationPolicy.Add(new Oid("1.3.6.1.4.1.311.10.3.13"));
			}
			x509Chain.ChainPolicy.UrlRetrievalTimeout = new TimeSpan(0, 1, 0);
			x509Chain.ChainPolicy.VerificationFlags = X509VerificationFlags.NoFlag;
			if (!x509Chain.Build(signingCertificate))
			{
				AuthenticodeSignerInfo.ErrorCode = -2146762748;
				throw new CryptographicException(-2146762748);
			}
			m_authenticodeSignerInfo.SignerChain = x509Chain;
			x509Store = new X509Store(StoreName.TrustedPublisher, StoreLocation.CurrentUser);
			x509Store.Open(OpenFlags.OpenExistingOnly);
			try
			{
				x509Certificate2Collection = x509Store.Certificates;
				if (x509Certificate2Collection == null)
				{
					m_authenticodeSignerInfo.ErrorCode = -2146762485;
					throw new CryptographicException(-2146762485);
				}
				if (!x509Certificate2Collection.Contains(signingCertificate))
				{
					AuthenticodeSignerInfo.ErrorCode = -2146762748;
					throw new CryptographicException(-2146762748);
				}
			}
			finally
			{
				x509Store.Close();
			}
			if (!(GetSingleNode(xmlElement, "r:grant/as:AuthenticodePublisher/as:X509SubjectName", xmlNamespaceManager) is XmlElement xmlElement3) || string.Compare(signingCertificate.Subject, xmlElement3.InnerText, StringComparison.Ordinal) != 0)
			{
				AuthenticodeSignerInfo.ErrorCode = -2146869244;
				throw new CryptographicException(-2146869244);
			}
			VerifyPublisherIdentity(xmlNamespaceManager);
		}

		private X509Certificate2 GetSigningCertificate(ManifestSignedXml2 signedXml, XmlNamespaceManager nsm)
		{
			X509Certificate2 x509Certificate = null;
			KeyInfo keyInfo = signedXml.KeyInfo;
			KeyInfoX509Data keyInfoX509Data = null;
			RSAKeyValue rSAKeyValue = null;
			foreach (KeyInfoClause item in keyInfo)
			{
				if (rSAKeyValue == null)
				{
					rSAKeyValue = item as RSAKeyValue;
					if (rSAKeyValue == null)
					{
						break;
					}
				}
				if (keyInfoX509Data == null)
				{
					keyInfoX509Data = item as KeyInfoX509Data;
				}
				if (rSAKeyValue != null && keyInfoX509Data != null)
				{
					break;
				}
			}
			if (rSAKeyValue == null || keyInfoX509Data == null)
			{
				m_authenticodeSignerInfo.ErrorCode = -2146762749;
				throw new CryptographicException(-2146762749);
			}
			RSA key = rSAKeyValue.Key;
			if (key != null)
			{
				RSAParameters rSAParameters = key.ExportParameters(includePrivateParameters: false);
				foreach (X509Certificate2 certificate in keyInfoX509Data.Certificates)
				{
					if (certificate == null)
					{
						continue;
					}
					bool flag = false;
					X509ExtensionEnumerator enumerator3 = certificate.Extensions.GetEnumerator();
					while (enumerator3.MoveNext())
					{
						X509Extension current = enumerator3.Current;
						if (current is X509BasicConstraintsExtension x509BasicConstraintsExtension)
						{
							flag = x509BasicConstraintsExtension.CertificateAuthority;
							if (flag)
							{
								break;
							}
						}
					}
					if (!flag)
					{
						RSA rSAPublicKey = System.Security.Cryptography.CngLightup.GetRSAPublicKey(certificate);
						RSAParameters rSAParameters2 = rSAPublicKey.ExportParameters(includePrivateParameters: false);
						if (StructuralComparisons.StructuralEqualityComparer.Equals(rSAParameters.Exponent, rSAParameters2.Exponent) && StructuralComparisons.StructuralEqualityComparer.Equals(rSAParameters.Modulus, rSAParameters2.Modulus))
						{
							x509Certificate = certificate;
							break;
						}
					}
				}
				if (x509Certificate == null)
				{
					m_authenticodeSignerInfo.ErrorCode = -2146869244;
					throw new CryptographicException(-2146869244);
				}
				return x509Certificate;
			}
			m_authenticodeSignerInfo.ErrorCode = -2146869244;
			throw new CryptographicException(-2146869244);
		}

		private void VerifySignatureForm(XmlElement signatureNode, string signatureKind, XmlNamespaceManager nsm)
		{
			string name = "Id";
			if (!signatureNode.HasAttribute(name))
			{
				name = "id";
				if (!signatureNode.HasAttribute(name))
				{
					name = "ID";
					if (!signatureNode.HasAttribute(name))
					{
						throw new CryptographicException(-2146762749);
					}
				}
			}
			string attribute = signatureNode.GetAttribute(name);
			if (attribute == null || string.Compare(attribute, signatureKind, StringComparison.Ordinal) != 0)
			{
				throw new CryptographicException(-2146762749);
			}
			bool flag = false;
			XmlNodeList xmlNodeList = signatureNode.SelectNodes("ds:SignedInfo/ds:Reference", nsm);
			foreach (XmlNode item in xmlNodeList)
			{
				if (!(item is XmlElement xmlElement) || !xmlElement.HasAttribute("URI"))
				{
					continue;
				}
				string attribute2 = xmlElement.GetAttribute("URI");
				if (attribute2 == null || attribute2.Length != 0)
				{
					continue;
				}
				XmlNode singleNode = GetSingleNode(xmlElement, "ds:Transforms", nsm);
				if (singleNode == null)
				{
					throw new CryptographicException(-2146762749);
				}
				XmlNodeList xmlNodeList2 = singleNode.SelectNodes("ds:Transform", nsm);
				if (xmlNodeList2.Count < 2)
				{
					throw new CryptographicException(-2146762749);
				}
				bool flag2 = false;
				bool flag3 = false;
				for (int i = 0; i < xmlNodeList2.Count; i++)
				{
					XmlElement xmlElement2 = xmlNodeList2[i] as XmlElement;
					string attribute3 = xmlElement2.GetAttribute("Algorithm");
					if (attribute3 == null)
					{
						break;
					}
					if (string.Compare(attribute3, "http://www.w3.org/2001/10/xml-exc-c14n#", StringComparison.Ordinal) != 0)
					{
						flag2 = true;
						if (flag3)
						{
							flag = true;
							break;
						}
					}
					else if (string.Compare(attribute3, "http://www.w3.org/2000/09/xmldsig#enveloped-signature", StringComparison.Ordinal) != 0)
					{
						flag3 = true;
						if (flag2)
						{
							flag = true;
							break;
						}
					}
				}
			}
			if (!flag)
			{
				throw new CryptographicException(-2146762749);
			}
		}

		private bool GetManifestInformation(XmlElement licenseNode, XmlNamespaceManager nsm, out string hash, out string description, out string url)
		{
			hash = "";
			description = "";
			url = "";
			if (!(GetSingleNode(licenseNode, "r:grant/as:ManifestInformation", nsm) is XmlElement xmlElement))
			{
				return false;
			}
			if (!xmlElement.HasAttribute("Hash"))
			{
				return false;
			}
			hash = xmlElement.GetAttribute("Hash");
			if (string.IsNullOrEmpty(hash))
			{
				return false;
			}
			string text = hash;
			foreach (char val in text)
			{
				if (byte.MaxValue == HexToByte(val))
				{
					return false;
				}
			}
			if (xmlElement.HasAttribute("Description"))
			{
				description = xmlElement.GetAttribute("Description");
			}
			if (xmlElement.HasAttribute("Url"))
			{
				url = xmlElement.GetAttribute("Url");
			}
			return true;
		}

		private bool VerifySignatureTimestamp(XmlElement signatureNode, XmlNamespaceManager nsm, out DateTime verificationTime)
		{
			verificationTime = DateTime.Now;
			if (GetSingleNode(signatureNode, "ds:Object/as:Timestamp", nsm) is XmlElement xmlElement)
			{
				string innerText = xmlElement.InnerText;
				if (!string.IsNullOrEmpty(innerText))
				{
					byte[] array = null;
					try
					{
						array = Convert.FromBase64String(innerText);
					}
					catch (FormatException)
					{
						m_authenticodeSignerInfo.ErrorCode = -2146869243;
						throw new CryptographicException(-2146869243);
					}
					if (array != null)
					{
						SignedCms signedCms = new SignedCms();
						signedCms.Decode(array);
						signedCms.CheckSignature(verifySignatureOnly: true);
						byte[] array2 = null;
						CryptographicAttributeObjectCollection signedAttributes = signedCms.SignerInfos[0].SignedAttributes;
						CryptographicAttributeObjectEnumerator enumerator = signedAttributes.GetEnumerator();
						while (enumerator.MoveNext())
						{
							CryptographicAttributeObject current = enumerator.Current;
							if (string.Compare(current.Oid.Value, "1.2.840.113549.1.9.5", StringComparison.Ordinal) != 0)
							{
								continue;
							}
							AsnEncodedDataEnumerator enumerator2 = current.Values.GetEnumerator();
							while (enumerator2.MoveNext())
							{
								AsnEncodedData current2 = enumerator2.Current;
								if (string.Compare(current2.Oid.Value, "1.2.840.113549.1.9.5", StringComparison.Ordinal) == 0)
								{
									array2 = current2.RawData;
									Pkcs9SigningTime pkcs9SigningTime = new Pkcs9SigningTime(array2);
									verificationTime = pkcs9SigningTime.SigningTime;
									return true;
								}
							}
						}
					}
				}
			}
			return false;
		}

		private bool VerifySignatureTimestampNew(XmlElement signatureNode, XmlNamespaceManager nsm, out DateTime verificationTime)
		{
			verificationTime = DateTime.Now;
			DateTime? dateTime = null;
			string text = null;
			byte[] array = null;
			XmlNodeList xmlNodeList = signatureNode.SelectNodes("ds:Object/as:Timestamp", nsm);
			XmlNodeList xmlNodeList2 = signatureNode.SelectNodes("ds:SignatureValue", nsm);
			if (xmlNodeList == null || xmlNodeList.Count == 0 || xmlNodeList2 == null || xmlNodeList2.Count == 0)
			{
				return false;
			}
			if (xmlNodeList.Count > 1 || xmlNodeList2.Count > 1 || string.IsNullOrEmpty(xmlNodeList[0].InnerText) || string.IsNullOrEmpty(xmlNodeList2[0].InnerText))
			{
				m_authenticodeSignerInfo.ErrorCode = -2146869243;
				throw new CryptographicException(-2146869243);
			}
			byte[] array2 = null;
			byte[] array3 = null;
			try
			{
				array2 = Convert.FromBase64String(xmlNodeList[0].InnerText);
				array3 = Convert.FromBase64String(xmlNodeList2[0].InnerText);
			}
			catch (FormatException)
			{
				m_authenticodeSignerInfo.ErrorCode = -2146869243;
				throw new CryptographicException(-2146869243);
			}
			if (array2 == null || array3 == null)
			{
				return false;
			}
			SignedCms signedCms = new SignedCms();
			signedCms.Decode(array2);
			signedCms.CheckSignature(verifySignatureOnly: true);
			if (signedCms.SignerInfos.Count != 1)
			{
				m_authenticodeSignerInfo.ErrorCode = -2146869246;
				throw new CryptographicException(-2146869246);
			}
			text = signedCms.SignerInfos[0].DigestAlgorithm.Value;
			CryptographicAttributeObjectCollection signedAttributes = signedCms.SignerInfos[0].SignedAttributes;
			CryptographicAttributeObjectEnumerator enumerator = signedAttributes.GetEnumerator();
			while (enumerator.MoveNext())
			{
				CryptographicAttributeObject current = enumerator.Current;
				if (!dateTime.HasValue && string.Compare(current.Oid.Value, "1.2.840.113549.1.9.5", StringComparison.Ordinal) == 0)
				{
					AsnEncodedDataEnumerator enumerator2 = current.Values.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						AsnEncodedData current2 = enumerator2.Current;
						if (string.Compare(current2.Oid.Value, "1.2.840.113549.1.9.5", StringComparison.Ordinal) == 0)
						{
							dateTime = new Pkcs9SigningTime(current2.RawData).SigningTime;
							break;
						}
					}
				}
				else
				{
					if (array != null || string.Compare(current.Oid.Value, "1.2.840.113549.1.9.4", StringComparison.Ordinal) != 0)
					{
						continue;
					}
					AsnEncodedDataEnumerator enumerator3 = current.Values.GetEnumerator();
					while (enumerator3.MoveNext())
					{
						AsnEncodedData current3 = enumerator3.Current;
						if (string.Compare(current3.Oid.Value, "1.2.840.113549.1.9.4", StringComparison.Ordinal) == 0)
						{
							byte[] rawData = current3.RawData;
							Pkcs9MessageDigest pkcs9MessageDigest = new Pkcs9MessageDigest();
							pkcs9MessageDigest.RawData = rawData;
							array = pkcs9MessageDigest.MessageDigest;
							break;
						}
					}
				}
			}
			bool flag = false;
			bool flag2 = false;
			try
			{
				dateTime = VerifyRFC3161Timestamp(array2, array3);
				flag = true;
				flag2 = true;
			}
			catch (Exception ex2)
			{
				if ((!(ex2 is CryptographicException) || ex2.HResult != -2146893822) && array != null)
				{
					byte[] array4 = null;
					HashAlgorithm hashAlgorithm = null;
					if (text == "2.16.840.1.101.3.4.2.1")
					{
						hashAlgorithm = SHA256.Create();
					}
					else if (text == "1.3.14.3.2.26")
					{
						hashAlgorithm = SHA1.Create();
					}
					if (hashAlgorithm != null)
					{
						array4 = hashAlgorithm.ComputeHash(array3);
						if (array4 != null && array4.Length == array.Length)
						{
							flag = array4.SequenceEqual(array);
						}
					}
				}
			}
			if (!flag)
			{
				m_authenticodeSignerInfo.ErrorCode = -2146893822;
				throw new CryptographicException(-2146893822);
			}
			if (!dateTime.HasValue)
			{
				return false;
			}
			if (!flag2)
			{
				X509Certificate2 certificate = signedCms.SignerInfos[0].Certificate;
				DateTime notAfter = certificate.NotAfter;
				DateTime? dateTime2 = dateTime;
				if (!(notAfter < dateTime2))
				{
					notAfter = certificate.NotBefore;
					dateTime2 = dateTime;
					if (!(notAfter > dateTime2))
					{
						goto IL_03bc;
					}
				}
				m_authenticodeSignerInfo.ErrorCode = -2146869243;
				throw new CryptographicException(-2146869243);
			}
			goto IL_03bc;
			IL_03bc:
			bool flag3 = false;
			try
			{
				using X509Chain x509Chain = new X509Chain();
				x509Chain.ChainPolicy.ExtraStore.AddRange(signedCms.Certificates);
				x509Chain.ChainPolicy.VerificationTime = dateTime.Value;
				x509Chain.ChainPolicy.ApplicationPolicy.Add(new Oid("1.3.6.1.5.5.7.3.8"));
				uint authenticodePolicies = GetAuthenticodePolicies();
				if ((0x20000 & authenticodePolicies) == 131072)
				{
					x509Chain.ChainPolicy.VerificationFlags |= X509VerificationFlags.IgnoreEndRevocationUnknown | X509VerificationFlags.IgnoreCertificateAuthorityRevocationUnknown | X509VerificationFlags.IgnoreRootRevocationUnknown;
				}
				flag3 = x509Chain.Build(signedCms.SignerInfos[0].Certificate);
			}
			catch (Exception ex3)
			{
				if (ex3 is ArgumentException || ex3 is CryptographicException)
				{
					m_authenticodeSignerInfo.ErrorCode = -2146869243;
					throw new CryptographicException(-2146869243);
				}
			}
			if (!flag3)
			{
				m_authenticodeSignerInfo.ErrorCode = -2146762748;
				throw new CryptographicException(-2146762748);
			}
			verificationTime = dateTime.Value;
			return true;
		}

		private DateTime VerifyRFC3161Timestamp(byte[] base64DecodedMessage, byte[] base64DecodedSignatureValue)
		{
			IntPtr ppTsContext = IntPtr.Zero;
			IntPtr ppTsSigner = IntPtr.Zero;
			IntPtr phStore = IntPtr.Zero;
			try
			{
				if (!Win32.CryptVerifyTimeStampSignature(base64DecodedMessage, base64DecodedMessage.Length, base64DecodedSignatureValue, base64DecodedSignatureValue.Length, IntPtr.Zero, ref ppTsContext, ref ppTsSigner, ref phStore) || ppTsContext == IntPtr.Zero)
				{
					throw new CryptographicException(Marshal.GetLastWin32Error());
				}
				try
				{
					return ReadRfc3161TimestampTokenTime(ppTsContext);
				}
				catch (Exception ex)
				{
					throw new CryptographicException(ex.Message);
				}
			}
			finally
			{
				if (ppTsContext != IntPtr.Zero)
				{
					Win32.CryptMemFree(ppTsContext);
				}
				if (ppTsSigner != IntPtr.Zero)
				{
					Win32.CertFreeCertificateContext(ppTsSigner);
				}
				if (phStore != IntPtr.Zero)
				{
					Win32.CertCloseStore(phStore, 0);
				}
			}
		}

		private DateTime ReadRfc3161TimestampTokenTime(IntPtr pTsContext)
		{
			Win32.CRYPT_TIMESTAMP_INFO cRYPT_TIMESTAMP_INFO = (Win32.CRYPT_TIMESTAMP_INFO)Marshal.PtrToStructure(((Win32.CRYPT_TIMESTAMP_CONTEXT)Marshal.PtrToStructure(pTsContext, typeof(Win32.CRYPT_TIMESTAMP_CONTEXT))).pTimeStamp, typeof(Win32.CRYPT_TIMESTAMP_INFO));
			long num = cRYPT_TIMESTAMP_INFO.ftTime.dwHighDateTime;
			num <<= 32;
			num |= cRYPT_TIMESTAMP_INFO.ftTime.dwLowDateTime & 0xFFFFFFFFu;
			return DateTime.FromFileTimeUtc(num);
		}

		private bool OverrideTimestampImprovements(XmlNamespaceManager nsm)
		{
			if (!(GetSingleNode(m_manifestDom, "asm:assembly/asm2:publisherIdentity", nsm) is XmlElement xmlElement) || !xmlElement.HasAttributes)
			{
				return true;
			}
			if (!xmlElement.HasAttribute("issuerKeyHash"))
			{
				return true;
			}
			string attribute = xmlElement.GetAttribute("issuerKeyHash");
			try
			{
				string text = ConfigurationManager.AppSettings.Get("ClickOnceTimeStampImprovementsOverride");
				if (!string.IsNullOrEmpty(text))
				{
					string[] array = text.Split(';');
					string[] array2 = array;
					foreach (string text2 in array2)
					{
						if (text2.Trim().Equals(attribute, StringComparison.OrdinalIgnoreCase))
						{
							return true;
						}
					}
				}
			}
			catch
			{
			}
			return false;
		}

		private bool GetLifetimeSigning(X509Certificate2 signingCertificate)
		{
			X509ExtensionEnumerator enumerator = signingCertificate.Extensions.GetEnumerator();
			while (enumerator.MoveNext())
			{
				X509Extension current = enumerator.Current;
				if (!(current is X509EnhancedKeyUsageExtension x509EnhancedKeyUsageExtension))
				{
					continue;
				}
				OidCollection enhancedKeyUsages = x509EnhancedKeyUsageExtension.EnhancedKeyUsages;
				OidEnumerator enumerator2 = enhancedKeyUsages.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					Oid current2 = enumerator2.Current;
					if (string.Compare("1.3.6.1.4.1.311.10.3.13", current2.Value, StringComparison.Ordinal) == 0)
					{
						return true;
					}
				}
			}
			return false;
		}

		private uint GetAuthenticodePolicies()
		{
			uint result = 0u;
			try
			{
				RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing");
				if (registryKey != null)
				{
					RegistryValueKind valueKind = registryKey.GetValueKind("State");
					if (valueKind == RegistryValueKind.DWord || valueKind == RegistryValueKind.Binary)
					{
						object value = registryKey.GetValue("State");
						if (value != null)
						{
							result = Convert.ToUInt32(value);
						}
					}
					registryKey.Close();
					return result;
				}
				return result;
			}
			catch (SecurityException)
			{
				return result;
			}
			catch (ObjectDisposedException)
			{
				return result;
			}
			catch (UnauthorizedAccessException)
			{
				return result;
			}
			catch (IOException)
			{
				return result;
			}
		}

		private XmlElement ExtractPrincipalFromManifest()
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			XmlNode singleNode = GetSingleNode(m_manifestDom, "asm:assembly/asm:assemblyIdentity", xmlNamespaceManager);
			if (singleNode == null)
			{
				throw new CryptographicException(-2146762749);
			}
			return singleNode as XmlElement;
		}

		private void VerifyAssemblyIdentity(XmlNamespaceManager nsm)
		{
			XmlElement xmlElement = GetSingleNode(m_manifestDom, "asm:assembly/asm:assemblyIdentity", nsm) as XmlElement;
			XmlElement xmlElement2 = GetSingleNode(m_manifestDom, "asm:assembly/ds:Signature/ds:KeyInfo/msrel:RelData/r:license/r:grant/as:ManifestInformation/as:assemblyIdentity", nsm) as XmlElement;
			if (xmlElement == null || xmlElement2 == null || !xmlElement.HasAttributes || !xmlElement2.HasAttributes)
			{
				throw new CryptographicException(-2146762749);
			}
			XmlAttributeCollection attributes = xmlElement.Attributes;
			if (attributes.Count == 0 || attributes.Count != xmlElement2.Attributes.Count)
			{
				throw new CryptographicException(-2146762749);
			}
			foreach (XmlAttribute item in attributes)
			{
				if (!xmlElement2.HasAttribute(item.LocalName) || item.Value != xmlElement2.GetAttribute(item.LocalName))
				{
					throw new CryptographicException(-2146762749);
				}
			}
			VerifyHash(nsm);
		}

		private void VerifyPublisherIdentity(XmlNamespaceManager nsm)
		{
			if (m_authenticodeSignerInfo.ErrorCode != -2146762496)
			{
				X509Certificate2 certificate = m_authenticodeSignerInfo.SignerChain.ChainElements[0].Certificate;
				if (!(GetSingleNode(m_manifestDom, "asm:assembly/asm2:publisherIdentity", nsm) is XmlElement xmlElement) || !xmlElement.HasAttributes)
				{
					throw new CryptographicException(-2146762749);
				}
				if (!xmlElement.HasAttribute("name") || !xmlElement.HasAttribute("issuerKeyHash"))
				{
					throw new CryptographicException(-2146762749);
				}
				string attribute = xmlElement.GetAttribute("name");
				string attribute2 = xmlElement.GetAttribute("issuerKeyHash");
				IntPtr ppwszPublicKeyHash = default(IntPtr);
				int num = Win32._AxlGetIssuerPublicKeyHash(certificate.Handle, ref ppwszPublicKeyHash);
				if (num != 0)
				{
					throw new CryptographicException(num);
				}
				string strB = Marshal.PtrToStringUni(ppwszPublicKeyHash);
				Win32.HeapFree(Win32.GetProcessHeap(), 0u, ppwszPublicKeyHash);
				if (string.Compare(attribute, certificate.SubjectName.Name, StringComparison.Ordinal) != 0 || string.Compare(attribute2, strB, StringComparison.Ordinal) != 0)
				{
					throw new CryptographicException(-2146762485);
				}
			}
		}

		private void VerifyHash(XmlNamespaceManager nsm)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			xmlDocument = (XmlDocument)m_manifestDom.Clone();
			if (!(GetSingleNode(xmlDocument, "asm:assembly/ds:Signature/ds:KeyInfo/msrel:RelData/r:license/r:grant/as:ManifestInformation", nsm) is XmlElement xmlElement))
			{
				throw new CryptographicException(-2146762749);
			}
			if (!xmlElement.HasAttribute("Hash"))
			{
				throw new CryptographicException(-2146762749);
			}
			string attribute = xmlElement.GetAttribute("Hash");
			if (attribute == null || attribute.Length == 0)
			{
				throw new CryptographicException(-2146762749);
			}
			if (!(GetSingleNode(xmlDocument, "asm:assembly/ds:Signature", nsm) is XmlElement xmlElement2))
			{
				throw new CryptographicException(-2146762749);
			}
			xmlElement2.ParentNode.RemoveChild(xmlElement2);
			byte[] array = HexStringToBytes(xmlElement.GetAttribute("Hash"));
			byte[] array2 = ComputeHashFromManifest(xmlDocument, m_useSha256);
			if (array.Length == 0 || array.Length != array2.Length)
			{
				throw new CryptographicException(-2146869232);
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != array2[i])
				{
					throw new CryptographicException(-2146869232);
				}
			}
		}

		private unsafe string VerifyPublicKeyToken()
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(m_manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			XmlElement xmlElement = GetSingleNode(m_manifestDom, "asm:assembly/ds:Signature/ds:KeyInfo/ds:KeyValue/ds:RSAKeyValue/ds:Modulus", xmlNamespaceManager) as XmlElement;
			XmlElement xmlElement2 = GetSingleNode(m_manifestDom, "asm:assembly/ds:Signature/ds:KeyInfo/ds:KeyValue/ds:RSAKeyValue/ds:Exponent", xmlNamespaceManager) as XmlElement;
			if (xmlElement == null || xmlElement2 == null)
			{
				throw new CryptographicException(-2146762749);
			}
			byte[] bytes = Encoding.UTF8.GetBytes(xmlElement.InnerXml);
			byte[] bytes2 = Encoding.UTF8.GetBytes(xmlElement2.InnerXml);
			string publicKeyToken = GetPublicKeyToken(m_manifestDom);
			byte[] array = HexStringToBytes(publicKeyToken);
			byte[] array2;
			fixed (byte* value = bytes)
			{
				fixed (byte* value2 = bytes2)
				{
					Win32.CRYPT_DATA_BLOB pModulusBlob = default(Win32.CRYPT_DATA_BLOB);
					Win32.CRYPT_DATA_BLOB pExponentBlob = default(Win32.CRYPT_DATA_BLOB);
					IntPtr ppwszPublicKeyToken = default(IntPtr);
					pModulusBlob.cbData = (uint)bytes.Length;
					pModulusBlob.pbData = new IntPtr(value);
					pExponentBlob.cbData = (uint)bytes2.Length;
					pExponentBlob.pbData = new IntPtr(value2);
					int num = Win32._AxlRSAKeyValueToPublicKeyToken(ref pModulusBlob, ref pExponentBlob, ref ppwszPublicKeyToken);
					if (num != 0)
					{
						throw new CryptographicException(num);
					}
					array2 = HexStringToBytes(Marshal.PtrToStringUni(ppwszPublicKeyToken));
					Win32.HeapFree(Win32.GetProcessHeap(), 0u, ppwszPublicKeyToken);
				}
			}
			if (array.Length == 0 || array.Length != array2.Length)
			{
				throw new CryptographicException(-2146762485);
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != array2[i])
				{
					throw new CryptographicException(-2146762485);
				}
			}
			return publicKeyToken;
		}

		private static void InsertPublisherIdentity(XmlDocument manifestDom, X509Certificate2 signerCert)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("asm2", "urn:schemas-microsoft-com:asm.v2");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			XmlElement xmlElement = GetSingleNode(manifestDom, "asm:assembly", xmlNamespaceManager) as XmlElement;
			if (!(GetSingleNode(manifestDom, "asm:assembly/asm:assemblyIdentity", xmlNamespaceManager) is XmlElement))
			{
				throw new CryptographicException(-2146762749);
			}
			XmlElement xmlElement3 = GetSingleNode(manifestDom, "asm:assembly/asm2:publisherIdentity", xmlNamespaceManager) as XmlElement;
			if (xmlElement3 == null)
			{
				xmlElement3 = manifestDom.CreateElement("publisherIdentity", "urn:schemas-microsoft-com:asm.v2");
			}
			IntPtr ppwszPublicKeyHash = default(IntPtr);
			int num = Win32._AxlGetIssuerPublicKeyHash(signerCert.Handle, ref ppwszPublicKeyHash);
			if (num != 0)
			{
				throw new CryptographicException(num);
			}
			string value = Marshal.PtrToStringUni(ppwszPublicKeyHash);
			Win32.HeapFree(Win32.GetProcessHeap(), 0u, ppwszPublicKeyHash);
			xmlElement3.SetAttribute("name", signerCert.SubjectName.Name);
			xmlElement3.SetAttribute("issuerKeyHash", value);
			if (GetSingleNode(manifestDom, "asm:assembly/ds:Signature", xmlNamespaceManager) is XmlElement refChild)
			{
				xmlElement.InsertBefore(xmlElement3, refChild);
			}
			else
			{
				xmlElement.AppendChild(xmlElement3);
			}
		}

		private static void RemoveExistingSignature(XmlDocument manifestDom)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			XmlNode singleNode = GetSingleNode(manifestDom, "asm:assembly/ds:Signature", xmlNamespaceManager);
			singleNode?.ParentNode.RemoveChild(singleNode);
		}

		internal static RSACryptoServiceProvider GetFixedRSACryptoServiceProvider(RSACryptoServiceProvider oldCsp, bool useSha256)
		{
			if (!useSha256)
			{
				return oldCsp;
			}
			if (!oldCsp.CspKeyContainerInfo.ProviderName.StartsWith("Microsoft", StringComparison.Ordinal))
			{
				return oldCsp;
			}
			CspParameters cspParameters = new CspParameters();
			cspParameters.ProviderType = 24;
			cspParameters.KeyContainerName = oldCsp.CspKeyContainerInfo.KeyContainerName;
			cspParameters.KeyNumber = (int)oldCsp.CspKeyContainerInfo.KeyNumber;
			if (oldCsp.CspKeyContainerInfo.MachineKeyStore)
			{
				cspParameters.Flags = CspProviderFlags.UseMachineKeyStore;
			}
			return new RSACryptoServiceProvider(cspParameters);
		}

		private unsafe static void ReplacePublicKeyToken(XmlDocument manifestDom, AsymmetricAlgorithm snKey, bool useSha256)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			if (!(GetSingleNode(manifestDom, "asm:assembly/asm:assemblyIdentity", xmlNamespaceManager) is XmlElement xmlElement))
			{
				throw new CryptographicException(-2146762749);
			}
			if (!xmlElement.HasAttribute("publicKeyToken"))
			{
				throw new CryptographicException(-2146762749);
			}
			byte[] array;
			if (snKey is RSACryptoServiceProvider)
			{
				array = GetFixedRSACryptoServiceProvider((RSACryptoServiceProvider)snKey, useSha256).ExportCspBlob(includePrivateParameters: false);
				if (array == null || array.Length == 0)
				{
					throw new CryptographicException(-2146893821);
				}
			}
			else
			{
				using RSACryptoServiceProvider rSACryptoServiceProvider = new RSACryptoServiceProvider();
				rSACryptoServiceProvider.ImportParameters(((RSA)snKey).ExportParameters(includePrivateParameters: false));
				array = rSACryptoServiceProvider.ExportCspBlob(includePrivateParameters: false);
			}
			fixed (byte* value = array)
			{
				Win32.CRYPT_DATA_BLOB pCspPublicKeyBlob = default(Win32.CRYPT_DATA_BLOB);
				pCspPublicKeyBlob.cbData = (uint)array.Length;
				pCspPublicKeyBlob.pbData = new IntPtr(value);
				IntPtr ppwszPublicKeyToken = default(IntPtr);
				int num = Win32._AxlPublicKeyBlobToPublicKeyToken(ref pCspPublicKeyBlob, ref ppwszPublicKeyToken);
				if (num != 0)
				{
					throw new CryptographicException(num);
				}
				string value2 = Marshal.PtrToStringUni(ppwszPublicKeyToken);
				Win32.HeapFree(Win32.GetProcessHeap(), 0u, ppwszPublicKeyToken);
				xmlElement.SetAttribute("publicKeyToken", value2);
			}
		}

		private static string GetPublicKeyToken(XmlDocument manifestDom)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			if (!(GetSingleNode(manifestDom, "asm:assembly/asm:assemblyIdentity", xmlNamespaceManager) is XmlElement xmlElement) || !xmlElement.HasAttribute("publicKeyToken"))
			{
				throw new CryptographicException(-2146762749);
			}
			return xmlElement.GetAttribute("publicKeyToken");
		}

		private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool useSha256)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			using (TextReader input = new StringReader(manifestDom.OuterXml))
			{
				XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
				xmlReaderSettings.DtdProcessing = DtdProcessing.Parse;
				XmlReader reader = XmlReader.Create(input, xmlReaderSettings, manifestDom.BaseURI);
				xmlDocument.Load(reader);
			}
			XmlDsigExcC14NTransform xmlDsigExcC14NTransform = new XmlDsigExcC14NTransform();
			xmlDsigExcC14NTransform.LoadInput(xmlDocument);
			if (useSha256)
			{
				using (SHA256CryptoServiceProvider sHA256CryptoServiceProvider = new SHA256CryptoServiceProvider())
				{
					byte[] array = sHA256CryptoServiceProvider.ComputeHash(xmlDsigExcC14NTransform.GetOutput() as MemoryStream);
					if (array == null)
					{
						throw new CryptographicException(-2146869232);
					}
					return array;
				}
			}
			using SHA1CryptoServiceProvider sHA1CryptoServiceProvider = new SHA1CryptoServiceProvider();
			byte[] array2 = sHA1CryptoServiceProvider.ComputeHash(xmlDsigExcC14NTransform.GetOutput() as MemoryStream);
			if (array2 == null)
			{
				throw new CryptographicException(-2146869232);
			}
			return array2;
		}

		private static XmlDocument CreateLicenseDom(CmiManifestSigner2 signer, XmlElement principal, byte[] hash)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			xmlDocument.LoadXml("<r:license xmlns:r=\"urn:mpeg:mpeg21:2003:01-REL-R-NS\" xmlns:as=\"http://schemas.microsoft.com/windows/pki/2005/Authenticode\"><r:grant><as:ManifestInformation><as:assemblyIdentity /></as:ManifestInformation><as:SignedBy/><as:AuthenticodePublisher><as:X509SubjectName>CN=dummy</as:X509SubjectName></as:AuthenticodePublisher></r:grant><r:issuer></r:issuer></r:license>");
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(xmlDocument.NameTable);
			xmlNamespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
			xmlNamespaceManager.AddNamespace("as", "http://schemas.microsoft.com/windows/pki/2005/Authenticode");
			XmlElement xmlElement = GetSingleNode(xmlDocument, "r:license/r:grant/as:ManifestInformation/as:assemblyIdentity", xmlNamespaceManager) as XmlElement;
			xmlElement.RemoveAllAttributes();
			foreach (XmlAttribute attribute in principal.Attributes)
			{
				xmlElement.SetAttribute(attribute.Name, attribute.Value);
			}
			XmlElement xmlElement2 = GetSingleNode(xmlDocument, "r:license/r:grant/as:ManifestInformation", xmlNamespaceManager) as XmlElement;
			xmlElement2.SetAttribute("Hash", (hash.Length == 0) ? "" : BytesToHexString(hash, 0, hash.Length));
			xmlElement2.SetAttribute("Description", (signer.Description == null) ? "" : signer.Description);
			xmlElement2.SetAttribute("Url", (signer.DescriptionUrl == null) ? "" : signer.DescriptionUrl);
			XmlElement xmlElement3 = GetSingleNode(xmlDocument, "r:license/r:grant/as:AuthenticodePublisher/as:X509SubjectName", xmlNamespaceManager) as XmlElement;
			xmlElement3.InnerText = signer.Certificate.SubjectName.Name;
			return xmlDocument;
		}

		private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManifestSigner2 signer, string timeStampUrl, bool useSha256)
		{
			using RSA rSA = System.Security.Cryptography.CngLightup.GetRSAPrivateKey(signer.Certificate);
			if (rSA == null)
			{
				throw new NotSupportedException();
			}
			ManifestSignedXml2 manifestSignedXml = new ManifestSignedXml2(licenseDom);
			manifestSignedXml.SigningKey = rSA;
			manifestSignedXml.SignedInfo.CanonicalizationMethod = "http://www.w3.org/2001/10/xml-exc-c14n#";
			if (signer.UseSha256)
			{
				manifestSignedXml.SignedInfo.SignatureMethod = "http://www.w3.org/2000/09/xmldsig#rsa-sha256";
			}
			manifestSignedXml.KeyInfo.AddClause(new RSAKeyValue(rSA));
			manifestSignedXml.KeyInfo.AddClause(new KeyInfoX509Data(signer.Certificate, signer.IncludeOption));
			Reference reference = new Reference();
			reference.Uri = "";
			if (signer.UseSha256)
			{
				reference.DigestMethod = "http://www.w3.org/2000/09/xmldsig#sha256";
			}
			reference.AddTransform(new XmlDsigEnvelopedSignatureTransform());
			reference.AddTransform(new XmlDsigExcC14NTransform());
			manifestSignedXml.AddReference(reference);
			manifestSignedXml.ComputeSignature();
			XmlElement xml = manifestSignedXml.GetXml();
			xml.SetAttribute("Id", "AuthenticodeSignature");
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(licenseDom.NameTable);
			xmlNamespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
			XmlElement xmlElement = GetSingleNode(licenseDom, "r:license/r:issuer", xmlNamespaceManager) as XmlElement;
			xmlElement.AppendChild(licenseDom.ImportNode(xml, deep: true));
			if (timeStampUrl != null && timeStampUrl.Length != 0)
			{
				TimestampSignedLicenseDom(licenseDom, timeStampUrl, useSha256);
			}
			licenseDom.DocumentElement.ParentNode.InnerXml = "<msrel:RelData xmlns:msrel=\"http://schemas.microsoft.com/windows/rel/2005/reldata\">" + licenseDom.OuterXml + "</msrel:RelData>";
		}

		private unsafe static string ObtainRFC3161Timestamp(string timeStampUrl, string signatureValue, bool useSha256)
		{
			byte[] array = Convert.FromBase64String(signatureValue);
			string empty = string.Empty;
			string pszHashId = (useSha256 ? "2.16.840.1.101.3.4.2.1" : "1.3.14.3.2.26");
			IntPtr ppTsContext = IntPtr.Zero;
			IntPtr ppTsSigner = IntPtr.Zero;
			IntPtr phStore = IntPtr.Zero;
			try
			{
				byte[] array2 = new byte[24];
				using (RandomNumberGenerator randomNumberGenerator = RandomNumberGenerator.Create())
				{
					randomNumberGenerator.GetBytes(array2);
				}
				Win32.CRYPT_TIMESTAMP_PARA cRYPT_TIMESTAMP_PARA = default(Win32.CRYPT_TIMESTAMP_PARA);
				cRYPT_TIMESTAMP_PARA.fRequestCerts = true;
				cRYPT_TIMESTAMP_PARA.pszTSAPolicyId = IntPtr.Zero;
				Win32.CRYPT_TIMESTAMP_PARA pPara = cRYPT_TIMESTAMP_PARA;
				try
				{
					fixed (byte* ptr = array2)
					{
						pPara.Nonce.cbData = (uint)array2.Length;
						pPara.Nonce.pbData = (IntPtr)ptr;
						if (!Win32.CryptRetrieveTimeStamp(timeStampUrl, 0u, 60000, pszHashId, ref pPara, array, array.Length, ref ppTsContext, ref ppTsSigner, ref phStore))
						{
							throw new CryptographicException(Marshal.GetLastWin32Error());
						}
					}
				}
				finally
				{
				}
				Win32.CRYPT_TIMESTAMP_CONTEXT cRYPT_TIMESTAMP_CONTEXT = (Win32.CRYPT_TIMESTAMP_CONTEXT)Marshal.PtrToStructure(ppTsContext, typeof(Win32.CRYPT_TIMESTAMP_CONTEXT));
				byte[] array3 = new byte[cRYPT_TIMESTAMP_CONTEXT.cbEncoded];
				Marshal.Copy(cRYPT_TIMESTAMP_CONTEXT.pbEncoded, array3, 0, (int)cRYPT_TIMESTAMP_CONTEXT.cbEncoded);
				return Convert.ToBase64String(array3);
			}
			finally
			{
				if (ppTsContext != IntPtr.Zero)
				{
					Win32.CryptMemFree(ppTsContext);
				}
				if (ppTsSigner != IntPtr.Zero)
				{
					Win32.CertFreeCertificateContext(ppTsSigner);
				}
				if (phStore != IntPtr.Zero)
				{
					Win32.CertCloseStore(phStore, 0);
				}
			}
		}

		private unsafe static void TimestampSignedLicenseDom(XmlDocument licenseDom, string timeStampUrl, bool useSha256)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(licenseDom.NameTable);
			xmlNamespaceManager.AddNamespace("r", "urn:mpeg:mpeg21:2003:01-REL-R-NS");
			xmlNamespaceManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#");
			xmlNamespaceManager.AddNamespace("as", "http://schemas.microsoft.com/windows/pki/2005/Authenticode");
			string empty = string.Empty;
			try
			{
				XmlElement xmlElement = GetSingleNode(licenseDom, "r:license/r:issuer/ds:Signature/ds:SignatureValue", xmlNamespaceManager) as XmlElement;
				string innerText = xmlElement.InnerText;
				empty = ObtainRFC3161Timestamp(timeStampUrl, innerText, useSha256);
			}
			catch
			{
				Win32.CRYPT_DATA_BLOB pTimestampSignatureBlob = default(Win32.CRYPT_DATA_BLOB);
				byte[] bytes = Encoding.UTF8.GetBytes(licenseDom.OuterXml);
				fixed (byte* value = bytes)
				{
					Win32.CRYPT_DATA_BLOB pSignedLicenseBlob = default(Win32.CRYPT_DATA_BLOB);
					IntPtr pbData = new IntPtr(value);
					pSignedLicenseBlob.cbData = (uint)bytes.Length;
					pSignedLicenseBlob.pbData = pbData;
					int num = Win32.CertTimestampAuthenticodeLicense(ref pSignedLicenseBlob, timeStampUrl, ref pTimestampSignatureBlob);
					if (num != 0)
					{
						throw new CryptographicException(num);
					}
				}
				byte[] array = new byte[pTimestampSignatureBlob.cbData];
				Marshal.Copy(pTimestampSignatureBlob.pbData, array, 0, array.Length);
				Win32.HeapFree(Win32.GetProcessHeap(), 0u, pTimestampSignatureBlob.pbData);
				empty = Encoding.UTF8.GetString(array);
			}
			XmlElement xmlElement2 = licenseDom.CreateElement("as", "Timestamp", "http://schemas.microsoft.com/windows/pki/2005/Authenticode");
			xmlElement2.InnerText = empty;
			XmlElement xmlElement3 = licenseDom.CreateElement("Object", "http://www.w3.org/2000/09/xmldsig#");
			xmlElement3.AppendChild(xmlElement2);
			XmlElement xmlElement4 = GetSingleNode(licenseDom, "r:license/r:issuer/ds:Signature", xmlNamespaceManager) as XmlElement;
			xmlElement4.AppendChild(xmlElement3);
		}

		private static void StrongNameSignManifestDom(XmlDocument manifestDom, XmlDocument licenseDom, CmiManifestSigner2 signer, bool useSha256)
		{
			if (!(signer.StrongNameKey is RSA key))
			{
				throw new NotSupportedException();
			}
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(manifestDom.NameTable);
			xmlNamespaceManager.AddNamespace("asm", "urn:schemas-microsoft-com:asm.v1");
			if (!(GetSingleNode(manifestDom, "asm:assembly", xmlNamespaceManager) is XmlElement xmlElement))
			{
				throw new CryptographicException(-2146762749);
			}
			if (!(signer.StrongNameKey is RSA))
			{
				throw new NotSupportedException();
			}
			ManifestSignedXml2 manifestSignedXml = new ManifestSignedXml2(xmlElement);
			if (signer.StrongNameKey is RSACryptoServiceProvider)
			{
				manifestSignedXml.SigningKey = GetFixedRSACryptoServiceProvider(signer.StrongNameKey as RSACryptoServiceProvider, useSha256);
			}
			else
			{
				manifestSignedXml.SigningKey = signer.StrongNameKey;
			}
			manifestSignedXml.SignedInfo.CanonicalizationMethod = "http://www.w3.org/2001/10/xml-exc-c14n#";
			if (signer.UseSha256)
			{
				manifestSignedXml.SignedInfo.SignatureMethod = "http://www.w3.org/2000/09/xmldsig#rsa-sha256";
			}
			manifestSignedXml.KeyInfo.AddClause(new RSAKeyValue(key));
			if (licenseDom != null)
			{
				manifestSignedXml.KeyInfo.AddClause(new KeyInfoNode(licenseDom.DocumentElement));
			}
			manifestSignedXml.KeyInfo.Id = "StrongNameKeyInfo";
			Reference reference = new Reference();
			reference.Uri = "";
			if (signer.UseSha256)
			{
				reference.DigestMethod = "http://www.w3.org/2000/09/xmldsig#sha256";
			}
			reference.AddTransform(new XmlDsigEnvelopedSignatureTransform());
			reference.AddTransform(new XmlDsigExcC14NTransform());
			manifestSignedXml.AddReference(reference);
			manifestSignedXml.ComputeSignature();
			XmlElement xml = manifestSignedXml.GetXml();
			xml.SetAttribute("Id", "StrongNameSignature");
			xmlElement.AppendChild(xml);
		}

		private static string BytesToHexString(byte[] array, int start, int end)
		{
			string result = null;
			if (array != null)
			{
				char[] array2 = new char[(end - start) * 2];
				int num = end;
				int num2 = 0;
				while (num-- > start)
				{
					int num3 = (array[num] & 0xF0) >> 4;
					array2[num2++] = hexValues[num3];
					num3 = array[num] & 0xF;
					array2[num2++] = hexValues[num3];
				}
				result = new string(array2);
			}
			return result;
		}

		private static byte[] HexStringToBytes(string hexString)
		{
			uint num = (uint)hexString.Length / 2u;
			byte[] array = new byte[num];
			int num2 = hexString.Length - 2;
			for (int i = 0; i < num; i++)
			{
				array[i] = (byte)((HexToByte(hexString[num2]) << 4) | HexToByte(hexString[num2 + 1]));
				num2 -= 2;
			}
			return array;
		}

		private static byte HexToByte(char val)
		{
			if (val <= '9' && val >= '0')
			{
				return (byte)(val - 48);
			}
			if (val >= 'a' && val <= 'f')
			{
				return (byte)(val - 97 + 10);
			}
			if (val >= 'A' && val <= 'F')
			{
				return (byte)(val - 65 + 10);
			}
			return byte.MaxValue;
		}

		private static XmlNode GetSingleNode(XmlNode parentNode, string xPath, XmlNamespaceManager namespaceManager = null)
		{
			XmlNodeList xmlNodeList = ((namespaceManager != null) ? parentNode.SelectNodes(xPath, namespaceManager) : parentNode.SelectNodes(xPath));
			if (xmlNodeList == null)
			{
				return null;
			}
			if (xmlNodeList.Count > 1)
			{
				throw new CryptographicException(-2146869247);
			}
			return xmlNodeList[0];
		}
	}
	internal class CmiManifestSigner2
	{
		private AsymmetricAlgorithm m_strongNameKey;

		private X509Certificate2 m_certificate;

		private string m_description;

		private string m_url;

		private X509Certificate2Collection m_certificates;

		private X509IncludeOption m_includeOption;

		private CmiManifestSignerFlag m_signerFlag;

		private bool m_useSha256;

		internal const uint CimManifestSignerFlagMask = 1u;

		internal bool UseSha256 => m_useSha256;

		internal AsymmetricAlgorithm StrongNameKey => m_strongNameKey;

		internal X509Certificate2 Certificate => m_certificate;

		internal string Description
		{
			get
			{
				return m_description;
			}
			set
			{
				m_description = value;
			}
		}

		internal string DescriptionUrl
		{
			get
			{
				return m_url;
			}
			set
			{
				m_url = value;
			}
		}

		internal X509Certificate2Collection ExtraStore => m_certificates;

		internal X509IncludeOption IncludeOption
		{
			get
			{
				return m_includeOption;
			}
			set
			{
				if (value < X509IncludeOption.None || value > X509IncludeOption.WholeChain)
				{
					throw new ArgumentException("value");
				}
				if (m_includeOption == X509IncludeOption.None)
				{
					throw new NotSupportedException();
				}
				m_includeOption = value;
			}
		}

		internal CmiManifestSignerFlag Flag
		{
			get
			{
				return m_signerFlag;
			}
			set
			{
				if (((uint)value & 0xFFFFFFFEu) != 0)
				{
					throw new ArgumentException("value");
				}
				m_signerFlag = value;
			}
		}

		private CmiManifestSigner2()
		{
		}

		internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey)
			: this(strongNameKey, null, useSha256: false)
		{
		}

		internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey, X509Certificate2 certificate, bool useSha256)
		{
			if (strongNameKey == null)
			{
				throw new ArgumentNullException("strongNameKey");
			}
			if (!(strongNameKey is RSA))
			{
				throw new ArgumentNullException("strongNameKey");
			}
			m_strongNameKey = strongNameKey;
			m_certificate = certificate;
			m_certificates = new X509Certificate2Collection();
			m_includeOption = X509IncludeOption.ExcludeRoot;
			m_signerFlag = CmiManifestSignerFlag.None;
			m_useSha256 = useSha256;
		}
	}
}
namespace System.Deployment.Application
{
	internal class ApplicationActivator
	{
		private class BrowserSettings
		{
			public enum ManagedFlags
			{
				URLPOLICY_ALLOW = 0,
				URLPOLICY_QUERY = 1,
				URLPOLICY_DISALLOW = 3
			}

			public ManagedFlags ManagedSignedFlag = ManagedFlags.URLPOLICY_DISALLOW;

			public ManagedFlags ManagedUnSignedFlag = ManagedFlags.URLPOLICY_DISALLOW;

			public void Validate(string manifestPath)
			{
				Logger.AddMethodCall("BrowserSettings.Validate(" + manifestPath + ") called.");
				AssemblyManifest.CertificateStatus certificateStatus = AssemblyManifest.AnalyzeManifestCertificate(manifestPath);
				if (certificateStatus == AssemblyManifest.CertificateStatus.TrustedPublisher || certificateStatus == AssemblyManifest.CertificateStatus.AuthenticodedNotInTrustedList)
				{
					if (ManagedSignedFlag != 0 && ManagedSignedFlag != ManagedFlags.URLPOLICY_QUERY)
					{
						throw new InvalidDeploymentException(ExceptionTypes.Manifest, Resources.GetString("Ex_SignedManifestDisallow"));
					}
				}
				else if (ManagedUnSignedFlag != 0 && ManagedUnSignedFlag != ManagedFlags.URLPOLICY_QUERY)
				{
					throw new InvalidDeploymentException(ExceptionTypes.Manifest, Resources.GetString("Ex_UnSignedManifestDisallow"));
				}
				Logger.AddInternalState("Browser settings allow activation. ManagedSignedFlag=" + ManagedSignedFlag.ToString() + ",ManagedUnSignedFlag=" + ManagedUnSignedFlag);
			}

			public static ManagedFlags GetManagedFlagValue(int policyValue)
			{
				return policyValue switch
				{
					0 => ManagedFlags.URLPOLICY_ALLOW, 
					1 => ManagedFlags.URLPOLICY_QUERY, 
					3 => ManagedFlags.URLPOLICY_DISALLOW, 
					_ => ManagedFlags.URLPOLICY_DISALLOW, 
				};
			}
		}

		private static Hashtable _activationsInProgress = new Hashtable();

		private bool _remActivationInProgressEntry;

		private SubscriptionStore _subStore;

		private UserInterface _ui;

		private bool _fullTrust;

		private const int _liveActivationLimitUINotVisible = 0;

		private const int _liveActivationLimitUIVisible = 1;

		private static int _liveActivationLimitUIStatus = 0;

		private const int ActivateArgumentCount = 5;

		private void DisplayActivationFailureReason(Exception exception, string errorPageUrl)
		{
			string message = Resources.GetString("ErrorMessage_GenericActivationFailure");
			string @string = Resources.GetString("ErrorMessage_GenericLinkUrlMessage");
			Exception innerMostException = GetInnerMostException(exception);
			if (exception is DeploymentDownloadException)
			{
				message = Resources.GetString("ErrorMessage_NetworkError");
				DeploymentDownloadException ex = (DeploymentDownloadException)exception;
				if (ex.SubType == ExceptionTypes.SizeLimitForPartialTrustOnlineAppExceeded)
				{
					message = Resources.GetString("ErrorMessage_SizeLimitForPartialTrustOnlineAppExceeded");
				}
				if (innerMostException is WebException)
				{
					WebException ex2 = (WebException)innerMostException;
					if (ex2.Response != null && ex2.Response is HttpWebResponse)
					{
						HttpWebResponse httpWebResponse = (HttpWebResponse)ex2.Response;
						if (httpWebResponse.StatusCode == HttpStatusCode.NotFound)
						{
							message = Resources.GetString("ErrorMessage_FileMissing");
						}
						else if (httpWebResponse.StatusCode == HttpStatusCode.Unauthorized)
						{
							message = Resources.GetString("ErrorMessage_AuthenticationError");
						}
						else if (httpWebResponse.StatusCode == HttpStatusCode.Forbidden)
						{
							message = Resources.GetString("ErrorMessage_Forbidden");
						}
					}
				}
				else if (innerMostException is FileNotFoundException || innerMostException is DirectoryNotFoundException)
				{
					message = Resources.GetString("ErrorMessage_FileMissing");
				}
				else if (innerMostException is UnauthorizedAccessException)
				{
					message = Resources.GetString("ErrorMessage_AuthenticationError");
				}
				else if (innerMostException is IOException && !IsWebExceptionInExceptionStack(exception))
				{
					message = Resources.GetString("ErrorMessage_DownloadIOError");
				}
			}
			else if (exception is InvalidDeploymentException)
			{
				InvalidDeploymentException ex3 = (InvalidDeploymentException)exception;
				if (ex3.SubType == ExceptionTypes.ManifestLoad)
				{
					message = Resources.GetString("ErrorMessage_ManifestCannotBeLoaded");
				}
				else if (ex3.SubType == ExceptionTypes.Manifest || ex3.SubType == ExceptionTypes.ManifestParse || ex3.SubType == ExceptionTypes.ManifestSemanticValidation)
				{
					message = Resources.GetString("ErrorMessage_InvalidManifest");
				}
				else if (ex3.SubType == ExceptionTypes.Validation || ex3.SubType == ExceptionTypes.HashValidation || ex3.SubType == ExceptionTypes.SignatureValidation || ex3.SubType == ExceptionTypes.RefDefValidation || ex3.SubType == ExceptionTypes.ClrValidation || ex3.SubType == ExceptionTypes.StronglyNamedAssemblyVerification || ex3.SubType == ExceptionTypes.IdentityMatchValidationForMixedModeAssembly || ex3.SubType == ExceptionTypes.AppFileLocationValidation || ex3.SubType == ExceptionTypes.FileSizeValidation)
				{
					message = Resources.GetString("ErrorMessage_ValidationFailed");
				}
				else if (ex3.SubType == ExceptionTypes.UnsupportedElevetaionRequest)
				{
					message = Resources.GetString("ErrorMessage_ManifestExecutionLevelNotSupported");
				}
			}
			else if (exception is DeploymentException)
			{
				if (((DeploymentException)exception).SubType == ExceptionTypes.ComponentStore)
				{
					message = Resources.GetString("ErrorMessage_StoreError");
				}
				else if (((DeploymentException)exception).SubType == ExceptionTypes.ActivationLimitExceeded)
				{
					message = Resources.GetString("ErrorMessage_ConcurrentActivationLimitExceeded");
				}
				else if (((DeploymentException)exception).SubType == ExceptionTypes.DiskIsFull)
				{
					message = Resources.GetString("ErrorMessage_DiskIsFull");
				}
				else if (((DeploymentException)exception).SubType == ExceptionTypes.DeploymentUriDifferent)
				{
					message = exception.Message;
				}
				else if (((DeploymentException)exception).SubType == ExceptionTypes.GroupMultipleMatch)
				{
					message = exception.Message;
				}
				else if (((DeploymentException)exception).SubType == ExceptionTypes.TrustFailDependentPlatform)
				{
					message = exception.Message;
				}
			}
			string logFileLocation = Logger.GetLogFilePath();
			if (!Logger.FlushCurrentThreadLogs())
			{
				logFileLocation = null;
			}
			string text = null;
			if (errorPageUrl != null)
			{
				text = $"{errorPageUrl}?outer={exception.GetType().ToString()}&&inner={innerMostException.GetType().ToString()}&&msg={innerMostException.Message}";
				if (text.Length > 2048)
				{
					text = text.Substring(0, 2048);
				}
			}
			_ui.ShowError(Resources.GetString("UI_ErrorTitle"), message, logFileLocation, text, @string);
		}

		private void DisplayPlatformDetectionFailureUI(DependentPlatformMissingException ex)
		{
			Uri supportUrl = null;
			if (_fullTrust)
			{
				supportUrl = ex.SupportUrl;
			}
			_ui.ShowPlatform(ex.Message, supportUrl);
		}

		public void ActivateDeployment(string activationUrl, bool isShortcut)
		{
			LifetimeManager.StartOperation();
			bool flag = false;
			try
			{
				flag = ThreadPool.QueueUserWorkItem(state: new object[5] { activationUrl, isShortcut, null, null, null }, callBack: ActivateDeploymentWorker);
				if (!flag)
				{
					throw new OutOfMemoryException();
				}
			}
			finally
			{
				if (!flag)
				{
					LifetimeManager.EndOperation();
				}
			}
		}

		public void ActivateDeploymentEx(string activationUrl, int unsignedPolicy, int signedPolicy)
		{
			LifetimeManager.StartOperation();
			bool flag = false;
			try
			{
				BrowserSettings browserSettings = new BrowserSettings();
				browserSettings.ManagedSignedFlag = BrowserSettings.GetManagedFlagValue(signedPolicy);
				browserSettings.ManagedUnSignedFlag = BrowserSettings.GetManagedFlagValue(unsignedPolicy);
				flag = ThreadPool.QueueUserWorkItem(state: new object[5] { activationUrl, false, null, null, browserSettings }, callBack: ActivateDeploymentWorker);
				if (!flag)
				{
					throw new OutOfMemoryException();
				}
			}
			finally
			{
				if (!flag)
				{
					LifetimeManager.EndOperation();
				}
			}
		}

		public void ActivateApplicationExtension(string textualSubId, string deploymentProviderUrl, string targetAssociatedFile)
		{
			LifetimeManager.StartOperation();
			bool flag = false;
			try
			{
				flag = ThreadPool.QueueUserWorkItem(state: new object[5] { targetAssociatedFile, false, textualSubId, deploymentProviderUrl, null }, callBack: ActivateDeploymentWorker);
				if (!flag)
				{
					throw new OutOfMemoryException();
				}
			}
			finally
			{
				if (!flag)
				{
					LifetimeManager.EndOperation();
				}
			}
		}

		private void ActivateDeploymentWorker(object state)
		{
			string text = null;
			string textualSubId = null;
			string deploymentProviderUrlFromExtension = null;
			try
			{
				CodeMarker_Singleton.Instance.CodeMarker(525);
				object[] array = (object[])state;
				text = ((string)array[0]) ?? string.Empty;
				Logger.StartCurrentThreadLogging();
				Logger.SetSubscriptionUrl(text);
				Logger.AddInternalState("Activation through dfsvc.exe started.");
				Logger.AddMethodCall("ActivateDeploymentWorker({0},{1},{2},{3},{4}) called.", array);
				bool isShortcut = (bool)array[1];
				if (array[2] != null)
				{
					textualSubId = (string)array[2];
				}
				if (array[3] != null)
				{
					deploymentProviderUrlFromExtension = (string)array[3];
				}
				BrowserSettings browserSettings = null;
				if (array[4] != null)
				{
					browserSettings = (BrowserSettings)array[4];
				}
				Uri uri = null;
				string errorPageUrl = null;
				try
				{
					int num = CheckActivationInProgress(text);
					_ui = new UserInterface(wait: false);
					if (!PolicyKeys.SuppressLimitOnNumberOfActivations() && num > 8)
					{
						throw new DeploymentException(ExceptionTypes.ActivationLimitExceeded, Resources.GetString("Ex_TooManyLiveActivation"));
					}
					if (text.Length > 16384)
					{
						throw new DeploymentException(ExceptionTypes.Activation, Resources.GetString("Ex_UrlTooLong"));
					}
					uri = new Uri(text);
					try
					{
						UriHelper.ValidateSupportedSchemeInArgument(uri, "activationUrl");
					}
					catch (ArgumentException innerException)
					{
						throw new InvalidDeploymentException(ExceptionTypes.UriSchemeNotSupported, Resources.GetString("Ex_NotSupportedUriScheme"), innerException);
					}
					Logger.AddPhaseInformation(Resources.GetString("PhaseLog_StartOfActivation"), text);
					PerformDeploymentActivationWithRetry(uri, isShortcut, textualSubId, deploymentProviderUrlFromExtension, browserSettings, ref errorPageUrl);
					Logger.AddPhaseInformation(Resources.GetString("ActivateManifestSucceeded"), text);
				}
				catch (DependentPlatformMissingException ex)
				{
					Logger.AddErrorInformation(ex, Resources.GetString("ActivateManifestException"), text);
					if (_ui == null)
					{
						_ui = new UserInterface();
					}
					if (!_ui.SplashCancelled())
					{
						DisplayPlatformDetectionFailureUI(ex);
					}
				}
				catch (DownloadCancelledException exception)
				{
					Logger.AddErrorInformation(exception, Resources.GetString("ActivateManifestException"), text);
				}
				catch (TrustNotGrantedException exception2)
				{
					Logger.AddErrorInformation(exception2, Resources.GetString("ActivateManifestException"), text);
				}
				catch (DeploymentException ex2)
				{
					Logger.AddErrorInformation(ex2, Resources.GetString("ActivateManifestException"), text);
					if (ex2.SubType == ExceptionTypes.ActivationInProgress)
					{
						return;
					}
					if (_ui == null)
					{
						_ui = new UserInterface();
					}
					if (_ui.SplashCancelled())
					{
						return;
					}
					if (ex2.SubType == ExceptionTypes.ActivationLimitExceeded)
					{
						if (Interlocked.CompareExchange(ref _liveActivationLimitUIStatus, 1, 0) == 0)
						{
							DisplayActivationFailureReason(ex2, errorPageUrl);
							Interlocked.CompareExchange(ref _liveActivationLimitUIStatus, 0, 1);
						}
					}
					else
					{
						DisplayActivationFailureReason(ex2, errorPageUrl);
					}
				}
				catch (Exception ex3)
				{
					if (ex3 is AccessViolationException || ex3 is OutOfMemoryException)
					{
						throw;
					}
					if (PolicyKeys.DisableGenericExceptionHandler())
					{
						throw;
					}
					Logger.AddErrorInformation(ex3, Resources.GetString("ActivateManifestException"), text);
					if (_ui == null)
					{
						_ui = new UserInterface();
					}
					if (!_ui.SplashCancelled())
					{
						DisplayActivationFailureReason(ex3, errorPageUrl);
					}
				}
			}
			finally
			{
				RemoveActivationInProgressEntry(text);
				if (_ui != null)
				{
					_ui.Dispose();
					_ui = null;
				}
				CodeMarker_Singleton.Instance.CodeMarker(526);
				Logger.EndCurrentThreadLogging();
				LifetimeManager.EndOperation();
			}
		}

		private void UninstallApplicationAndRedirectActivation(ref bool isShortCut, ref Uri deploymentProviderUri, string textualSubId, Uri activationUri)
		{
			try
			{
				DefinitionIdentity subId = null;
				SubscriptionState subState = null;
				TempFile tempFile = null;
				Uri providerUri = null;
				SubscriptionStore currentUser = SubscriptionStore.CurrentUser;
				currentUser.RefreshStorePointer();
				if (isShortCut)
				{
					int num = activationUri.LocalPath.IndexOf('|', 0);
					string shortcutFile = ((num > 0) ? activationUri.LocalPath.Substring(0, num) : activationUri.LocalPath);
					ShellExposure.ParseAppShortcut(shortcutFile, out subId, out providerUri);
					subState = currentUser.GetSubscriptionState(subId);
				}
				else if (textualSubId != null)
				{
					subId = new DefinitionIdentity(textualSubId);
					subState = currentUser.GetSubscriptionState(subId);
				}
				else
				{
					AssemblyManifest assemblyManifest = DownloadManager.DownloadDeploymentManifestBypass(currentUser, ref deploymentProviderUri, out tempFile, out subState, null, null);
				}
				subState.SubscriptionStore.UninstallSubscription(subState);
				if (isShortCut)
				{
					deploymentProviderUri = providerUri;
					isShortCut = false;
				}
			}
			catch (DeploymentException ex)
			{
				Logger.AddErrorInformation(Resources.GetString("Uninstall_FailedMsg"), ex);
				ExceptionDispatchInfo exceptionDispatchInfo = ExceptionDispatchInfo.Capture(ex);
				exceptionDispatchInfo.Throw();
			}
		}

		private void CleanApplicationReInstall(bool isShortcut, Uri deploymentUri, Uri activationUri, BrowserSettings browserSettings, string textualSubId, string errorPageUrl, string deploymentProviderUrlFromExtension, string shortcutFilePath)
		{
			if (isShortcut && string.IsNullOrEmpty(shortcutFilePath))
			{
				throw new DeploymentException(ExceptionTypes.InvalidShortcut, Resources.GetString("Ex_InvalidShortcutFormat"));
			}
			int num = shortcutFilePath.IndexOf('|', 0);
			if (num > 0)
			{
				shortcutFilePath = shortcutFilePath.Substring(0, num);
			}
			FileInfo fileInfo = null;
			string text = string.Empty;
			if (isShortcut)
			{
				fileInfo = new FileInfo(shortcutFilePath);
				text = $"{shortcutFilePath}_{Guid.NewGuid()}";
				fileInfo = fileInfo.CopyTo(text);
			}
			UninstallApplicationAndRedirectActivation(ref isShortcut, ref deploymentUri, textualSubId, activationUri);
			try
			{
				PerformDeploymentActivation(activationUri, isShortcut, textualSubId, deploymentProviderUrlFromExtension, browserSettings, ref errorPageUrl, ref deploymentUri);
			}
			catch (Exception source)
			{
				if (text != string.Empty)
				{
					fileInfo.MoveTo(shortcutFilePath);
				}
				ExceptionDispatchInfo exceptionDispatchInfo = ExceptionDispatchInfo.Capture(source);
				exceptionDispatchInfo.Throw();
			}
			if (text != string.Empty)
			{
				fileInfo.Delete();
			}
		}

		private void PerformDeploymentActivationWithRetry(Uri activationUri, bool isShortcut, string textualSubId, string deploymentProviderUrlFromExtension, BrowserSettings browserSettings, ref string errorPageUrl)
		{
			Uri deploymentUri = null;
			try
			{
				PerformDeploymentActivation(activationUri, isShortcut, textualSubId, deploymentProviderUrlFromExtension, browserSettings, ref errorPageUrl, ref deploymentUri);
			}
			catch (Exception ex)
			{
				if (textualSubId == null)
				{
					if (ex is DirectoryNotFoundException || ex is FileNotFoundException || ex is DriveNotFoundException || (ex is COMException && (ex.HResult & 0xFFFF) == 267))
					{
						Logger.AddMethodCall("Partial store corruption scenario called due to exception {0}", ex.ToString());
						CleanApplicationReInstall(isShortcut, deploymentUri, activationUri, browserSettings, textualSubId, errorPageUrl, deploymentProviderUrlFromExtension, activationUri.LocalPath);
					}
					else if (ex is FileLoadException)
					{
						Logger.AddMethodCall("Locked file scenario called");
						Thread.Sleep(10000);
						PerformDeploymentActivation(activationUri, isShortcut, textualSubId, deploymentProviderUrlFromExtension, browserSettings, ref errorPageUrl, ref deploymentUri);
					}
					else
					{
						ExceptionDispatchInfo exceptionDispatchInfo = ExceptionDispatchInfo.Capture(ex);
						exceptionDispatchInfo.Throw();
					}
				}
				else
				{
					ExceptionDispatchInfo exceptionDispatchInfo2 = ExceptionDispatchInfo.Capture(ex);
					exceptionDispatchInfo2.Throw();
				}
			}
		}

		private void PerformDeploymentActivation(Uri activationUri, bool isShortcut, string textualSubId, string deploymentProviderUrlFromExtension, BrowserSettings browserSettings, ref string errorPageUrl, ref Uri deploymentUri)
		{
			TempFile deployFile = null;
			Logger.AddMethodCall("PerformDeploymentActivation called.");
			try
			{
				string text = null;
				Uri uri = null;
				bool flag = false;
				_subStore = SubscriptionStore.CurrentUser;
				_subStore.RefreshStorePointer();
				if (null == deploymentUri)
				{
					deploymentUri = activationUri;
				}
				bool flag2 = false;
				ActivationDescription activationDescription;
				if (textualSubId != null)
				{
					Logger.AddInternalState("Activating through file association.");
					flag2 = true;
					activationDescription = ProcessOrFollowExtension(activationUri, textualSubId, deploymentProviderUrlFromExtension, ref errorPageUrl, out deployFile);
					if (activationDescription == null)
					{
						return;
					}
				}
				else if (isShortcut)
				{
					Logger.AddInternalState("Activating through shortcut.");
					text = activationUri.LocalPath;
					activationDescription = ProcessOrFollowShortcut(text, ref errorPageUrl, out deployFile);
					if (activationDescription == null)
					{
						return;
					}
				}
				else
				{
					Logger.AddInternalState("Activating through deployment manifest.");
					Logger.AddInternalState("Start processing deployment manifest.");
					SubscriptionState subState;
					AssemblyManifest assemblyManifest = DownloadManager.DownloadDeploymentManifestBypass(_subStore, ref deploymentUri, out deployFile, out subState, null, null);
					if (browserSettings != null && deployFile != null)
					{
						browserSettings.Validate(deployFile.Path);
					}
					if (assemblyManifest.Description != null)
					{
						errorPageUrl = assemblyManifest.Description.ErrorReportUrl;
					}
					activationDescription = new ActivationDescription();
					if (subState != null)
					{
						text = null;
						activationDescription.SetApplicationManifest(subState.CurrentApplicationManifest, null, null);
						activationDescription.AppId = subState.CurrentBind;
						Logger.AddInternalState("Running from the store. Bypass further downloads and verifications.");
						flag = true;
					}
					else
					{
						text = deployFile.Path;
					}
					Logger.SetDeploymentManifest(assemblyManifest);
					Logger.AddPhaseInformation(Resources.GetString("PhaseLog_ProcessingDeploymentManifestComplete"));
					Logger.AddInternalState("Processing of deployment manifest has successfully completed.");
					activationDescription.SetDeploymentManifest(assemblyManifest, deploymentUri, text);
					activationDescription.IsUpdate = false;
					activationDescription.ActType = ActivationType.InstallViaDotApplication;
					uri = activationUri;
				}
				if (_ui.SplashCancelled())
				{
					throw new DownloadCancelledException();
				}
				if (activationDescription.DeployManifest.Deployment != null)
				{
					bool flag3 = false;
					SubscriptionState subState2 = _subStore.GetSubscriptionState(activationDescription.DeployManifest);
					CheckDeploymentProviderValidity(activationDescription, subState2);
					if (!flag)
					{
						Logger.AddInternalState("Could not find application in store. Continue with downloading application manifest.");
						flag3 = InstallApplication(ref subState2, activationDescription);
						Logger.AddPhaseInformation(Resources.GetString("PhaseLog_InstallationComplete"));
						Logger.AddInternalState("Installation of application has successfully completed.");
					}
					else
					{
						_subStore.SetLastCheckTimeToNow(subState2);
					}
					if (activationDescription.DeployManifest.Deployment.DisallowUrlActivation && !isShortcut && (!activationUri.IsFile || activationUri.IsUnc))
					{
						if (flag3)
						{
							_ui.ShowMessage(Resources.GetString("Activation_DisallowUrlActivationMessageAfterInstall"), Resources.GetString("Activation_DisallowUrlActivationCaptionAfterInstall"));
						}
						else
						{
							_ui.ShowMessage(Resources.GetString("Activation_DisallowUrlActivationMessage"), Resources.GetString("Activation_DisallowUrlActivationCaption"));
						}
					}
					else if (flag2)
					{
						Activate(activationDescription.AppId, activationDescription.AppManifest, activationUri.AbsoluteUri, useActivationParameter: true);
					}
					else if (isShortcut)
					{
						string text2 = null;
						int num = text.IndexOf('|', 0);
						if (num > 0 && num + 1 < text.Length)
						{
							text2 = text.Substring(num + 1);
						}
						if (text2 == null)
						{
							Activate(activationDescription.AppId, activationDescription.AppManifest, null, useActivationParameter: false);
						}
						else
						{
							Activate(activationDescription.AppId, activationDescription.AppManifest, text2, useActivationParameter: true);
						}
					}
					else
					{
						Activate(activationDescription.AppId, activationDescription.AppManifest, uri.AbsoluteUri, useActivationParameter: false);
					}
					return;
				}
				throw new DeploymentException(ExceptionTypes.Activation, Resources.GetString("Ex_NotDeploymentOrShortcut"));
			}
			finally
			{
				deployFile?.Dispose();
			}
		}

		private ActivationDescription ProcessOrFollowExtension(Uri associatedFile, string textualSubId, string deploymentProviderUrlFromExtension, ref string errorPageUrl, out TempFile deployFile)
		{
			deployFile = null;
			Logger.AddMethodCall("ProcessOrFollowExtension(" + associatedFile?.ToString() + "," + textualSubId + "," + deploymentProviderUrlFromExtension + "," + errorPageUrl + ") called.");
			DefinitionIdentity subId = new DefinitionIdentity(textualSubId);
			SubscriptionState subState = _subStore.GetSubscriptionState(subId);
			ActivationDescription activationDescription = null;
			if (subState.IsInstalled && subState.IsShellVisible)
			{
				Logger.AddInternalState("Application family is already installed and Shell Visible.");
				PerformDeploymentUpdate(ref subState, ref errorPageUrl);
				Activate(subState.CurrentBind, subState.CurrentApplicationManifest, associatedFile.AbsoluteUri, useActivationParameter: true);
			}
			else
			{
				Logger.AddInternalState("Application family is not installed or is not Shell-Visible.  Try to deploy it from the deployment provider specified in the extension : " + deploymentProviderUrlFromExtension);
				if (string.IsNullOrEmpty(deploymentProviderUrlFromExtension))
				{
					throw new DeploymentException(ExceptionTypes.Activation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileAssociationNoDpUrl"), new object[1] { textualSubId }));
				}
				Uri sourceUri = new Uri(deploymentProviderUrlFromExtension);
				Logger.AddInternalState("Start processing deployment manifest.");
				AssemblyManifest assemblyManifest = DownloadManager.DownloadDeploymentManifest(_subStore, ref sourceUri, out deployFile);
				if (assemblyManifest.Description != null)
				{
					errorPageUrl = assemblyManifest.Description.ErrorReportUrl;
				}
				Logger.AddInternalState("Processing of deployment manifest has successfully completed.");
				if (!assemblyManifest.Deployment.Install)
				{
					throw new DeploymentException(ExceptionTypes.Activation, Resources.GetString("Ex_FileAssociationRefOnline"));
				}
				activationDescription = new ActivationDescription();
				activationDescription.SetDeploymentManifest(assemblyManifest, sourceUri, deployFile.Path);
				activationDescription.IsUpdate = false;
				activationDescription.ActType = ActivationType.InstallViaFileAssociation;
			}
			return activationDescription;
		}

		private ActivationDescription ProcessOrFollowShortcut(string shortcutFile, ref string errorPageUrl, out TempFile deployFile)
		{
			deployFile = null;
			Logger.AddMethodCall("ProcessOrFollowShortcut(shortcutFile=" + shortcutFile + ",errorPageUrl=" + errorPageUrl + ") called.");
			string shortcutFile2 = shortcutFile;
			string text = null;
			int num = shortcutFile.IndexOf('|', 0);
			if (num > 0)
			{
				shortcutFile2 = shortcutFile.Substring(0, num);
				if (num + 1 < shortcutFile.Length)
				{
					text = shortcutFile.Substring(num + 1);
				}
			}
			Logger.AddInternalState("shortcutParameter=" + text);
			ShellExposure.ParseAppShortcut(shortcutFile2, out var subId, out var providerUri);
			SubscriptionState subState = _subStore.GetSubscriptionState(subId);
			ActivationDescription activationDescription = null;
			if (subState.IsInstalled && subState.IsShellVisible)
			{
				Logger.AddInternalState("Application family is already installed and Shell Visible.");
				PerformDeploymentUpdate(ref subState, ref errorPageUrl);
				if (text == null)
				{
					Activate(subState.CurrentBind, subState.CurrentApplicationManifest, null, useActivationParameter: false);
				}
				else
				{
					Activate(subState.CurrentBind, subState.CurrentApplicationManifest, text, useActivationParameter: true);
				}
			}
			else
			{
				Uri sourceUri = providerUri;
				Logger.AddInternalState("Application family is not installed or is not Shell-Visible.  Try to deploy it from the deployment provider specified in the shortcut : " + sourceUri);
				Logger.AddInternalState("Start processing deployment manifest.");
				AssemblyManifest assemblyManifest = DownloadManager.DownloadDeploymentManifest(_subStore, ref sourceUri, out deployFile);
				Logger.AddInternalState("Processing of deployment manifest has successfully completed.");
				if (assemblyManifest.Description != null)
				{
					errorPageUrl = assemblyManifest.Description.ErrorReportUrl;
				}
				if (!assemblyManifest.Deployment.Install)
				{
					throw new DeploymentException(ExceptionTypes.Activation, Resources.GetString("Ex_ShortcutRefOnlineOnly"));
				}
				activationDescription = new ActivationDescription();
				activationDescription.SetDeploymentManifest(assemblyManifest, sourceUri, deployFile.Path);
				activationDescription.IsUpdate = false;
				activationDescription.ActType = ActivationType.InstallViaShortcut;
			}
			return activationDescription;
		}

		private void Activate(DefinitionAppId appId, AssemblyManifest appManifest, string activationParameter, bool useActivationParameter)
		{
			using ActivationContext appInfo = ActivationContext.CreatePartialActivationContext(appId.ToApplicationIdentity());
			InternalActivationContextHelper.PrepareForExecution(appInfo);
			_subStore.ActivateApplication(appId, activationParameter, useActivationParameter);
		}

		private void PerformDeploymentUpdate(ref SubscriptionState subState, ref string errorPageUrl)
		{
			bool flag = subState.CurrentDeploymentManifest.Deployment.DeploymentUpdate?.BeforeApplicationStartup ?? false;
			Logger.AddPhaseInformation(Resources.GetString("PhaseLog_DeploymentUpdateCheck"));
			Logger.AddMethodCall("PerformDeploymentUpdate called.");
			Logger.AddInternalState("UpdateOnStart=" + flag + ",PendingDeployment=" + subState.PendingDeployment);
			if (!flag && (subState.PendingDeployment == null || SkipUpdate(subState, subState.PendingDeployment)))
			{
				return;
			}
			TempFile tempFile = null;
			try
			{
				Uri sourceUri = subState.DeploymentProviderUri;
				AssemblyManifest assemblyManifest;
				try
				{
					Logger.AddInternalState("Start processing deployment manifest for update check : " + sourceUri);
					assemblyManifest = DownloadManager.DownloadDeploymentManifest(_subStore, ref sourceUri, out tempFile);
					Logger.AddInternalState("End processing deployment manifest.");
					if (assemblyManifest.Description != null)
					{
						errorPageUrl = assemblyManifest.Description.ErrorReportUrl;
					}
				}
				catch (DeploymentDownloadException exception)
				{
					Logger.AddErrorInformation(exception, Resources.GetString("Upd_UpdateCheckDownloadFailed"), subState.SubscriptionId.ToString());
					return;
				}
				if (_ui.SplashCancelled())
				{
					throw new DownloadCancelledException();
				}
				if (!SkipUpdate(subState, assemblyManifest.Identity) && _subStore.CheckUpdateInManifest(subState, sourceUri, assemblyManifest, subState.CurrentDeployment.Version) != null && !assemblyManifest.Identity.Equals(subState.ExcludedDeployment))
				{
					Logger.AddInternalState("Update available in the deployment server.");
					ActivationDescription activationDescription = new ActivationDescription();
					activationDescription.SetDeploymentManifest(assemblyManifest, sourceUri, tempFile.Path);
					activationDescription.IsUpdate = true;
					activationDescription.IsRequiredUpdate = false;
					activationDescription.ActType = ActivationType.UpdateViaShortcutOrFA;
					if (assemblyManifest.Deployment.MinimumRequiredVersion != null && assemblyManifest.Deployment.MinimumRequiredVersion.CompareTo(subState.CurrentDeployment.Version) > 0)
					{
						activationDescription.IsRequiredUpdate = true;
					}
					CheckDeploymentProviderValidity(activationDescription, subState);
					ConsumeUpdatedDeployment(ref subState, activationDescription);
				}
			}
			finally
			{
				tempFile?.Dispose();
			}
		}

		private void CheckDeploymentProviderValidity(ActivationDescription actDesc, SubscriptionState subState)
		{
			if (actDesc.DeployManifest.Deployment.Install && actDesc.DeployManifest.Deployment.ProviderCodebaseUri == null && subState != null && subState.DeploymentProviderUri != null)
			{
				Uri uri = ((subState.DeploymentProviderUri.Query != null && subState.DeploymentProviderUri.Query.Length > 0) ? new Uri(subState.DeploymentProviderUri.GetLeftPart(UriPartial.Path)) : subState.DeploymentProviderUri);
				Logger.AddInternalState("Checking deployment provider validity.");
				Logger.AddInternalState("providerCodebaseUri=" + uri);
				Logger.AddInternalState("actDesc.ToAppCodebase()=" + actDesc.ToAppCodebase());
				if (!uri.Equals(actDesc.ToAppCodebase()))
				{
					throw new DeploymentException(ExceptionTypes.DeploymentUriDifferent, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("ErrorMessage_DeploymentUriDifferent"), new object[1] { actDesc.DeployManifest.Description.FilteredProduct }), new DeploymentException(ExceptionTypes.DeploymentUriDifferent, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DeploymentUriDifferentExText"), new object[3]
					{
						actDesc.DeployManifest.Description.FilteredProduct,
						actDesc.DeploySourceUri.AbsoluteUri,
						subState.DeploymentProviderUri.AbsoluteUri
					})));
				}
			}
		}

		private void ConsumeUpdatedDeployment(ref SubscriptionState subState, ActivationDescription actDesc)
		{
			AssemblyManifest deployManifest = actDesc.DeployManifest;
			DefinitionIdentity identity = deployManifest.Identity;
			Uri deploySourceUri = actDesc.DeploySourceUri;
			Logger.AddPhaseInformation(Resources.GetString("PhaseLog_ConsumeUpdatedDeployment"));
			Logger.AddInternalState("Consuming new update.");
			if (!actDesc.IsRequiredUpdate)
			{
				Logger.AddInternalState("Update is not a required update.");
				Description effectiveDescription = subState.EffectiveDescription;
				UserInterfaceInfo userInterfaceInfo = new UserInterfaceInfo();
				userInterfaceInfo.formTitle = Resources.GetString("UI_UpdateTitle");
				userInterfaceInfo.productName = effectiveDescription.Product;
				userInterfaceInfo.supportUrl = effectiveDescription.SupportUrl;
				userInterfaceInfo.sourceSite = UserInterface.GetDisplaySite(deploySourceUri);
				switch (_ui.ShowUpdate(userInterfaceInfo))
				{
				case UserInterfaceModalResult.Skip:
				{
					TimeSpan timeSpan = new TimeSpan(7, 0, 0, 0);
					DateTime updateSkipTime = DateTime.UtcNow + timeSpan;
					_subStore.SetUpdateSkipTime(subState, identity, updateSkipTime);
					Logger.AddPhaseInformation(Resources.GetString("Upd_DeployUpdateSkipping"));
					Logger.AddInternalState("User has decided to skip the update.");
					return;
				}
				case UserInterfaceModalResult.Cancel:
					Logger.AddInternalState("Do not update now, but prompt for update on next activation.");
					return;
				}
			}
			InstallApplication(ref subState, actDesc);
			Logger.AddPhaseInformation(Resources.GetString("Upd_Consumed"), identity.ToString(), deploySourceUri);
			Logger.AddInternalState("Update consumed.");
		}

		private bool InstallApplication(ref SubscriptionState subState, ActivationDescription actDesc)
		{
			bool flag = false;
			Logger.AddMethodCall("InstallApplication called.");
			Logger.AddPhaseInformation(Resources.GetString("PhaseLog_InstallApplication"));
			_subStore.CheckDeploymentSubscriptionState(subState, actDesc.DeployManifest);
			long transactionId;
			using (_subStore.AcquireReferenceTransaction(out transactionId))
			{
				TempDirectory downloadTemp = null;
				try
				{
					flag = DownloadApplication(subState, actDesc, transactionId, out downloadTemp);
					actDesc.CommitDeploy = true;
					actDesc.IsConfirmed = true;
					actDesc.TimeStamp = DateTime.UtcNow;
					if (actDesc.CommitApp)
					{
						SetMarkOfTheWebIfNeeded(actDesc);
					}
					Logger.AddPhaseInformation(Resources.GetString("PhaseLog_CommitApplication"));
					_subStore.CommitApplication(ref subState, actDesc);
					return flag;
				}
				finally
				{
					downloadTemp?.Dispose();
				}
			}
		}

		private void SetMarkOfTheWebIfNeeded(CommitApplicationParams p)
		{
			string deployManifestPath = p.DeployManifestPath;
			string absoluteUri = p.AppSourceUri.AbsoluteUri;
			if (p.AppPayloadPath != null)
			{
				string text = Path.Combine(p.AppPayloadPath, p.AppId.ApplicationIdentity.Name);
				if (System.IO.File.Exists(text) && PlatformDetector.IsWin8orLater() && p.Trust.DefaultGrantSet.PermissionSet.IsUnrestricted() && AssemblyManifest.AnalyzeManifestCertificate(deployManifestPath) != 0 && Utilities.IsAppRepCheckRequired(absoluteUri))
				{
					Utilities.SetMarkOfTheWeb(text);
				}
			}
		}

		private bool DownloadApplication(SubscriptionState subState, ActivationDescription actDesc, long transactionId, out TempDirectory downloadTemp)
		{
			bool result = false;
			Logger.AddMethodCall("DownloadApplication called.");
			downloadTemp = _subStore.AcquireTempDirectory();
			Logger.AddInternalState("Start processing application manifest.");
			Uri appSourceUri;
			string appManifestPath;
			AssemblyManifest assemblyManifest = DownloadManager.DownloadApplicationManifest(actDesc.DeployManifest, downloadTemp.Path, actDesc.DeploySourceUri, out appSourceUri, out appManifestPath);
			AssemblyManifest.ReValidateManifestSignatures(actDesc.DeployManifest, assemblyManifest);
			if (assemblyManifest.EntryPoints[0].HostInBrowser)
			{
				throw new DeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_HostInBrowserAppNotSupported"));
			}
			if (assemblyManifest.EntryPoints[0].CustomHostSpecified)
			{
				throw new DeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_CustomHostSpecifiedAppNotSupported"));
			}
			if (assemblyManifest.EntryPoints[0].CustomUX && (actDesc.ActType == ActivationType.InstallViaDotApplication || actDesc.ActType == ActivationType.InstallViaFileAssociation || actDesc.ActType == ActivationType.InstallViaShortcut || actDesc.ActType == ActivationType.None))
			{
				throw new DeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_CustomUXAppNotSupported"));
			}
			Logger.AddPhaseInformation(Resources.GetString("PhaseLog_ProcessingApplicationManifestComplete"));
			Logger.AddInternalState("Processing of application manifest has successfully completed.");
			actDesc.SetApplicationManifest(assemblyManifest, appSourceUri, appManifestPath);
			Logger.SetApplicationManifest(assemblyManifest);
			_subStore.CheckCustomUXFlag(subState, actDesc.AppManifest);
			actDesc.AppId = new DefinitionAppId(actDesc.ToAppCodebase(), actDesc.DeployManifest.Identity, actDesc.AppManifest.Identity);
			Logger.AddInternalState("Start request of trust and detection of platform.");
			if (assemblyManifest.EntryPoints[0].CustomUX)
			{
				Logger.AddInternalState("This is a CustomUX application. Calling PersistTrustWithoutEvaluation.");
				actDesc.Trust = ApplicationTrust.PersistTrustWithoutEvaluation(actDesc.ToActivationContext());
			}
			else
			{
				_ui.Hide();
				if (_ui.SplashCancelled())
				{
					throw new DownloadCancelledException();
				}
				if (subState.IsInstalled && !string.Equals(subState.EffectiveCertificatePublicKeyToken, actDesc.EffectiveCertificatePublicKeyToken, StringComparison.Ordinal))
				{
					Logger.AddInternalState("EffectiveCertificatePublicKeyToken has changed between versions: subState.EffectiveCertificatePublicKeyToken=" + subState.EffectiveCertificatePublicKeyToken + ",actDesc.EffectiveCertificatePublicKeyToken=" + actDesc.EffectiveCertificatePublicKeyToken);
					Logger.AddInternalState("Removing the cached trust decision for CurrentBind.");
					ApplicationTrust.RemoveCachedTrust(subState.CurrentBind);
				}
				try
				{
					actDesc.Trust = ApplicationTrust.RequestTrust(subState, actDesc.DeployManifest.Deployment.Install, actDesc.IsUpdate, actDesc.ToActivationContext());
				}
				catch (Exception ex)
				{
					Logger.AddErrorInformation(Resources.GetString("Ex_DetermineTrustFailed"), ex);
					if (!(ex is TrustNotGrantedException))
					{
						try
						{
							PlatformDetector.VerifyPlatformDependencies(actDesc.AppManifest, actDesc.DeployManifest, downloadTemp.Path);
						}
						catch (Exception ex2)
						{
							if (ex2 is DependentPlatformMissingException)
							{
								throw new DeploymentException(ExceptionTypes.TrustFailDependentPlatform, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("ErrorMessage_TrustFailDependentPlatformMissing"), new object[1] { ex2.Message }), ex);
							}
						}
					}
					throw;
				}
			}
			_fullTrust = actDesc.Trust.DefaultGrantSet.PermissionSet.IsUnrestricted();
			Logger.AddInternalState("_fullTrust = " + _fullTrust);
			if (!_fullTrust && actDesc.AppManifest.FileAssociations.Length != 0)
			{
				throw new DeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_FileExtensionNotSupported"));
			}
			PlatformDetector.VerifyPlatformDependencies(actDesc.AppManifest, actDesc.DeployManifest, downloadTemp.Path);
			Logger.AddPhaseInformation(Resources.GetString("PhaseLog_PlatformDetectAndTrustGrantComplete"));
			Logger.AddInternalState("Request of trust and detection of platform is complete.");
			Logger.AddInternalState("Start downloading  and verifying dependencies.");
			if (!_subStore.CheckAndReferenceApplication(subState, actDesc.AppId, transactionId))
			{
				result = true;
				Description effectiveDescription = actDesc.EffectiveDescription;
				UserInterfaceInfo userInterfaceInfo = new UserInterfaceInfo();
				userInterfaceInfo.productName = effectiveDescription.Product;
				if (actDesc.IsUpdate)
				{
					if (actDesc.IsRequiredUpdate)
					{
						userInterfaceInfo.formTitle = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("UI_ProgressTitleRequiredUpdate"), new object[1] { userInterfaceInfo.productName });
					}
					else
					{
						userInterfaceInfo.formTitle = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("UI_ProgressTitleUpdate"), new object[1] { userInterfaceInfo.productName });
					}
				}
				else if (!actDesc.DeployManifest.Deployment.Install)
				{
					userInterfaceInfo.formTitle = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("UI_ProgressTitleDownload"), new object[1] { userInterfaceInfo.productName });
				}
				else
				{
					userInterfaceInfo.formTitle = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("UI_ProgressTitleInstall"), new object[1] { userInterfaceInfo.productName });
				}
				userInterfaceInfo.supportUrl = effectiveDescription.SupportUrl;
				userInterfaceInfo.sourceSite = UserInterface.GetDisplaySite(actDesc.DeploySourceUri);
				if (assemblyManifest.Description != null && assemblyManifest.Description.IconFileFS != null)
				{
					userInterfaceInfo.iconFilePath = Path.Combine(downloadTemp.Path, assemblyManifest.Description.IconFileFS);
				}
				ProgressPiece notification = _ui.ShowProgress(userInterfaceInfo);
				DownloadOptions downloadOptions = null;
				bool flag = !actDesc.DeployManifest.Deployment.Install;
				if (!_fullTrust && flag)
				{
					downloadOptions = new DownloadOptions();
					downloadOptions.EnforceSizeLimit = true;
					downloadOptions.SizeLimit = _subStore.GetSizeLimitInBytesForSemiTrustApps();
					downloadOptions.Size = actDesc.DeployManifest.SizeInBytes + actDesc.AppManifest.SizeInBytes;
				}
				DownloadManager.DownloadDependencies(subState, actDesc.DeployManifest, actDesc.AppManifest, actDesc.AppSourceUri, downloadTemp.Path, null, notification, downloadOptions);
				Logger.AddPhaseInformation(Resources.GetString("PhaseLog_DownloadDependenciesComplete"));
				actDesc.CommitApp = true;
				actDesc.AppPayloadPath = downloadTemp.Path;
				actDesc.AppGroup = null;
			}
			return result;
		}

		private static bool SkipUpdate(SubscriptionState subState, DefinitionIdentity targetIdentity)
		{
			Logger.AddMethodCall("SkipUpdate called.");
			if (subState.UpdateSkippedDeployment != null && targetIdentity != null && subState.UpdateSkippedDeployment.Equals(targetIdentity) && subState.UpdateSkipTime > DateTime.UtcNow)
			{
				Logger.AddInternalState("Skipped Update. UpdateSkipTime was " + subState.UpdateSkipTime.ToString());
				return true;
			}
			Logger.AddInternalState("Update is not skipped.");
			return false;
		}

		private Exception GetInnerMostException(Exception exception)
		{
			if (exception.InnerException != null)
			{
				return GetInnerMostException(exception.InnerException);
			}
			return exception;
		}

		private bool IsWebExceptionInExceptionStack(Exception exception)
		{
			if (exception == null)
			{
				return false;
			}
			if (exception is WebException)
			{
				return true;
			}
			return IsWebExceptionInExceptionStack(exception.InnerException);
		}

		private int CheckActivationInProgress(string activationUrl)
		{
			lock (_activationsInProgress.SyncRoot)
			{
				if (_activationsInProgress.Contains(activationUrl))
				{
					ApplicationActivator applicationActivator = (ApplicationActivator)_activationsInProgress[activationUrl];
					applicationActivator.ActivateUI();
					_remActivationInProgressEntry = false;
					throw new DeploymentException(ExceptionTypes.ActivationInProgress, Resources.GetString("Ex_ActivationInProgressException"));
				}
				_activationsInProgress.Add(activationUrl, this);
				_remActivationInProgressEntry = true;
				return _activationsInProgress.Count;
			}
		}

		private void RemoveActivationInProgressEntry(string activationUrl)
		{
			if (!_remActivationInProgressEntry || activationUrl == null)
			{
				return;
			}
			lock (_activationsInProgress.SyncRoot)
			{
				_activationsInProgress.Remove(activationUrl);
			}
		}

		private void ActivateUI()
		{
			if (_ui != null)
			{
				_ui.Activate();
			}
		}
	}
	internal enum ActivationType
	{
		None,
		InstallViaDotApplication,
		InstallViaShortcut,
		InstallViaFileAssociation,
		UpdateViaShortcutOrFA
	}
	internal class ActivationDescription : CommitApplicationParams
	{
		private ActivationType activationType;

		public ActivationType ActType
		{
			get
			{
				return activationType;
			}
			set
			{
				activationType = value;
			}
		}

		public void SetApplicationManifest(AssemblyManifest manifest, Uri manifestUri, string manifestPath)
		{
			AppManifest = manifest;
			AppSourceUri = manifestUri;
			AppManifestPath = manifestPath;
			if (AppManifest.EntryPoints[0].CustomHostSpecified)
			{
				appType = AppType.CustomHostSpecified;
			}
			if (AppManifest.EntryPoints[0].CustomUX)
			{
				appType = AppType.CustomUX;
			}
		}

		public void SetDeploymentManifest(AssemblyManifest manifest, Uri manifestUri, string manifestPath)
		{
			DeploySourceUri = manifestUri;
			DeployManifest = manifest;
			DeployManifestPath = manifestPath;
		}

		public string ToAppCodebase()
		{
			Uri uri = ((DeploySourceUri.Query != null && DeploySourceUri.Query.Length > 0) ? new Uri(DeploySourceUri.GetLeftPart(UriPartial.Path)) : DeploySourceUri);
			return uri.AbsoluteUri;
		}

		public ActivationContext ToActivationContext()
		{
			ApplicationIdentity identity = AppId.ToApplicationIdentity();
			return ActivationContext.CreatePartialActivationContext(identity, new string[2] { DeployManifestPath, AppManifestPath });
		}
	}
	/// <summary>Supports updates of the current deployment programmatically, and handles on-demand downloading of files. This class cannot be inherited.</summary>
	public sealed class ApplicationDeployment
	{
		private static readonly object checkForUpdateCompletedKey = new object();

		private static readonly object updateCompletedKey = new object();

		private static readonly object downloadFileGroupCompletedKey = new object();

		private static readonly object checkForUpdateProgressChangedKey = new object();

		private static readonly object updateProgressChangedKey = new object();

		private static readonly object downloadFileGroupProgressChangedKey = new object();

		private static readonly object lockObject = new object();

		private const int guardInitial = 0;

		private const int guardAsync = 1;

		private const int guardSync = 2;

		private static ApplicationDeployment _currentDeployment = null;

		private readonly AsyncOperation asyncOperation;

		private readonly CodeAccessPermission accessPermission;

		private int _guard;

		private bool _cancellationPending;

		private SubscriptionStore _subStore;

		private EventHandlerList _events;

		private DefinitionAppId _fullAppId;

		private Version _currentVersion;

		private SubscriptionState _subState;

		private object _syncGroupDeploymentManager;

		/// <summary>Returns the current <see cref="T:System.Deployment.Application.ApplicationDeployment" /> for this deployment.</summary>
		/// <returns>The current deployment.</returns>
		/// <exception cref="T:System.Deployment.Application.InvalidDeploymentException">You attempted to call this static property from a non-ClickOnce application.</exception>
		public static ApplicationDeployment CurrentDeployment
		{
			[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
			get
			{
				bool flag = false;
				if (_currentDeployment == null)
				{
					lock (lockObject)
					{
						if (_currentDeployment == null)
						{
							string text = null;
							ActivationContext activationContext = AppDomain.CurrentDomain.ActivationContext;
							if (activationContext != null)
							{
								text = activationContext.Identity.FullName;
							}
							if (string.IsNullOrEmpty(text))
							{
								throw new InvalidDeploymentException(Resources.GetString("Ex_AppIdNotSet"));
							}
							_currentDeployment = new ApplicationDeployment(text);
							flag = true;
						}
					}
				}
				if (!flag)
				{
					_currentDeployment.DemandPermission();
				}
				return _currentDeployment;
			}
		}

		/// <summary>Gets a value indicating whether the current application is a ClickOnce application.</summary>
		/// <returns>
		///   <see langword="true" /> if this is a ClickOnce application; otherwise, <see langword="false" />.</returns>
		public static bool IsNetworkDeployed
		{
			get
			{
				bool result = true;
				try
				{
					ApplicationDeployment currentDeployment = CurrentDeployment;
					return result;
				}
				catch (InvalidDeploymentException)
				{
					return false;
				}
			}
		}

		/// <summary>Gets the version of the deployment for the current running instance of the application.</summary>
		/// <returns>The current deployment version.</returns>
		public Version CurrentVersion => _currentVersion;

		/// <summary>Gets the version of the update that was recently downloaded.</summary>
		/// <returns>The <see cref="T:System.Version" /> describing the version of the update.</returns>
		public Version UpdatedVersion
		{
			[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
			get
			{
				_subState.Invalidate();
				return _subState.CurrentDeployment.Version;
			}
		}

		/// <summary>Gets the full name of the application after it has been updated.</summary>
		/// <returns>A <see cref="T:System.String" /> that contains the full name of the application.</returns>
		public string UpdatedApplicationFullName
		{
			[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
			get
			{
				_subState.Invalidate();
				return _subState.CurrentBind.ToString();
			}
		}

		/// <summary>Gets the date and the time ClickOnce last checked for an application update.</summary>
		/// <returns>The <see cref="T:System.DateTime" /> of the last update check.</returns>
		public DateTime TimeOfLastUpdateCheck
		{
			[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
			get
			{
				_subState.Invalidate();
				return _subState.LastCheckTime;
			}
		}

		/// <summary>Gets the Web site or file share from which this application updates itself.</summary>
		/// <returns>The update path, expressed as an HTTP, HTTPS, or file URL; or as a Windows network file path (UNC).</returns>
		public Uri UpdateLocation
		{
			[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
			get
			{
				_subState.Invalidate();
				return _subState.DeploymentProviderUri;
			}
		}

		/// <summary>Gets the URL used to launch the deployment manifest of the application.</summary>
		/// <returns>A zero-length string if the <c>TrustUrlParameters</c> property in the deployment manifest is <see langword="false" />, or if the user has supplied a UNC to open the deployment or has opened it locally. Otherwise, the return value is the full URL used to launch the application, including any parameters.</returns>
		public Uri ActivationUri
		{
			[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
			get
			{
				_subState.Invalidate();
				if (!_subState.CurrentDeploymentManifest.Deployment.TrustURLParameters)
				{
					return null;
				}
				string[] activationData = AppDomain.CurrentDomain.SetupInformation.ActivationArguments.ActivationData;
				if (activationData == null || activationData[0] == null)
				{
					return null;
				}
				Uri uri = new Uri(activationData[0]);
				if (uri.IsFile || uri.IsUnc)
				{
					return null;
				}
				return uri;
			}
		}

		/// <summary>Gets the path to the ClickOnce data directory.</summary>
		/// <returns>A string containing the path to the application's data directory on the local disk.</returns>
		public string DataDirectory => AppDomain.CurrentDomain.GetData("DataDirectory")?.ToString();

		/// <summary>Gets a value indicating whether this is the first time this application has run on the client computer.</summary>
		/// <returns>
		///   <see langword="true" /> if this version of the application has never run on the client computer before; otherwise, <see langword="false" />.</returns>
		public bool IsFirstRun
		{
			[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
			get
			{
				ActivationContext activationContext = AppDomain.CurrentDomain.ActivationContext;
				return InternalActivationContextHelper.IsFirstRun(activationContext);
			}
		}

		private EventHandlerList Events => _events;

		private DeploymentManager SyncGroupDeploymentManager
		{
			get
			{
				if (_syncGroupDeploymentManager == null)
				{
					DeploymentManager deploymentManager = null;
					bool flag = false;
					try
					{
						deploymentManager = new DeploymentManager(_fullAppId.ToString(), isUpdate: true, isConfirmed: true, null, asyncOperation);
						deploymentManager.Callertype = DeploymentManager.CallerType.ApplicationDeployment;
						deploymentManager.Bind();
						flag = Interlocked.CompareExchange(ref _syncGroupDeploymentManager, deploymentManager, null) == null;
					}
					finally
					{
						if (!flag)
						{
							deploymentManager?.Dispose();
						}
					}
					if (flag)
					{
						deploymentManager.ProgressChanged += DownloadFileGroupProgressChangedEventHandler;
						deploymentManager.SynchronizeCompleted += SynchronizeGroupCompletedEventHandler;
					}
				}
				return (DeploymentManager)_syncGroupDeploymentManager;
			}
		}

		/// <summary>Occurs when a progress update is available on a <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> call.</summary>
		public event DeploymentProgressChangedEventHandler CheckForUpdateProgressChanged
		{
			add
			{
				Events.AddHandler(checkForUpdateProgressChangedKey, value);
			}
			remove
			{
				Events.RemoveHandler(checkForUpdateProgressChangedKey, value);
			}
		}

		/// <summary>Occurs when <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> has completed.</summary>
		public event CheckForUpdateCompletedEventHandler CheckForUpdateCompleted
		{
			add
			{
				Events.AddHandler(checkForUpdateCompletedKey, value);
			}
			remove
			{
				Events.RemoveHandler(checkForUpdateCompletedKey, value);
			}
		}

		/// <summary>Occurs when ClickOnce has new status information for an update operation initiated by calling the <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" /> method.</summary>
		public event DeploymentProgressChangedEventHandler UpdateProgressChanged
		{
			add
			{
				Events.AddHandler(updateProgressChangedKey, value);
			}
			remove
			{
				Events.RemoveHandler(updateProgressChangedKey, value);
			}
		}

		/// <summary>Occurs when ClickOnce has finished upgrading the application as the result of a call to <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />.</summary>
		public event AsyncCompletedEventHandler UpdateCompleted
		{
			add
			{
				Events.AddHandler(updateCompletedKey, value);
			}
			remove
			{
				Events.RemoveHandler(updateCompletedKey, value);
			}
		}

		/// <summary>Occurs when status information is available on a file download operation initiated by a call to <see cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />.</summary>
		public event DeploymentProgressChangedEventHandler DownloadFileGroupProgressChanged
		{
			add
			{
				Events.AddHandler(downloadFileGroupProgressChangedKey, value);
			}
			remove
			{
				Events.RemoveHandler(downloadFileGroupProgressChangedKey, value);
			}
		}

		/// <summary>Occurs on the main application thread when a file download is complete.</summary>
		public event DownloadFileGroupCompletedEventHandler DownloadFileGroupCompleted
		{
			add
			{
				Events.AddHandler(downloadFileGroupCompletedKey, value);
			}
			remove
			{
				Events.RemoveHandler(downloadFileGroupCompletedKey, value);
			}
		}

		private ApplicationDeployment(string fullAppId)
		{
			if (fullAppId.Length > 65536)
			{
				throw new InvalidDeploymentException(Resources.GetString("Ex_AppIdTooLong"));
			}
			try
			{
				_fullAppId = new DefinitionAppId(fullAppId);
			}
			catch (COMException innerException)
			{
				throw new InvalidDeploymentException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_SubAppIdNotValid"), new object[1] { fullAppId }), innerException);
			}
			catch (SEHException innerException2)
			{
				throw new InvalidDeploymentException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_SubAppIdNotValid"), new object[1] { fullAppId }), innerException2);
			}
			DefinitionIdentity deploymentIdentity = _fullAppId.DeploymentIdentity;
			_currentVersion = deploymentIdentity.Version;
			DefinitionIdentity subId = deploymentIdentity.ToSubscriptionId();
			_subStore = SubscriptionStore.CurrentUser;
			_subState = _subStore.GetSubscriptionState(subId);
			if (!_subState.IsInstalled)
			{
				throw new InvalidDeploymentException(Resources.GetString("Ex_SubNotInstalled"));
			}
			if (!_fullAppId.Equals(_subState.CurrentBind))
			{
				throw new InvalidDeploymentException(Resources.GetString("Ex_AppIdNotMatchInstalled"));
			}
			Uri uri = new Uri(_fullAppId.Codebase);
			if (uri.IsFile)
			{
				accessPermission = new FileIOPermission(FileIOPermissionAccess.Read, uri.LocalPath);
			}
			else
			{
				accessPermission = new WebPermission(NetworkAccess.Connect, _fullAppId.Codebase);
			}
			accessPermission.Demand();
			_events = new EventHandlerList();
			asyncOperation = AsyncOperationManager.CreateOperation(null);
		}

		/// <summary>Performs the same operation as <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, but returns extended information about the available update.</summary>
		/// <returns>An <see cref="T:System.Deployment.Application.UpdateCheckInfo" /> for the available update.</returns>
		/// <exception cref="T:System.InvalidOperationException">The current application is either not configured to support updates, or there is another update check operation already in progress.</exception>
		/// <exception cref="T:System.Deployment.Application.DeploymentDownloadException">The deployment manifest cannot be downloaded. This exception will appear in the <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> property of the <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> event.</exception>
		/// <exception cref="T:System.Deployment.Application.InvalidDeploymentException">The deployment manifest is corrupted. Regenerate the application's manifest before you attempt to deploy this application to users. This exception will appear in the <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> property of the <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> event.</exception>
		public UpdateCheckInfo CheckForDetailedUpdate()
		{
			return CheckForDetailedUpdate(persistUpdateCheckResult: true);
		}

		/// <summary>Performs the same operation as <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, but returns extended information about the available update.</summary>
		/// <param name="persistUpdateCheckResult">If <see langword="false" />, the update will be applied silently and no dialog box will be displayed.</param>
		/// <returns>An <see cref="T:System.Deployment.Application.UpdateCheckInfo" /> for the available update.</returns>
		public UpdateCheckInfo CheckForDetailedUpdate(bool persistUpdateCheckResult)
		{
			new NamedPermissionSet("FullTrust").Demand();
			if (Interlocked.CompareExchange(ref _guard, 2, 0) != 0)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_SingleOperation"));
			}
			_cancellationPending = false;
			UpdateCheckInfo updateCheckInfo = null;
			try
			{
				DeploymentManager deploymentManager = CreateDeploymentManager();
				try
				{
					deploymentManager.Bind();
					updateCheckInfo = DetermineUpdateCheckResult(deploymentManager.ActivationDescription);
					if (updateCheckInfo.UpdateAvailable)
					{
						deploymentManager.DeterminePlatformRequirements();
						try
						{
							TrustParams trustParams = new TrustParams();
							trustParams.NoPrompt = true;
							deploymentManager.DetermineTrust(trustParams);
						}
						catch (TrustNotGrantedException)
						{
							if (!deploymentManager.ActivationDescription.IsUpdateInPKTGroup)
							{
								throw;
							}
						}
					}
					if (persistUpdateCheckResult)
					{
						ProcessUpdateCheckResult(updateCheckInfo, deploymentManager.ActivationDescription);
						return updateCheckInfo;
					}
					return updateCheckInfo;
				}
				finally
				{
					deploymentManager.Dispose();
				}
			}
			finally
			{
				Interlocked.Exchange(ref _guard, 0);
			}
		}

		/// <summary>Checks <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> to determine whether a new update is available.</summary>
		/// <returns>
		///   <see langword="true" /> if a new update is available; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.InvalidOperationException">ClickOnce throws this exception immediately if you call the <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" /> method while an update is already in progress.</exception>
		/// <exception cref="T:System.Deployment.Application.DeploymentDownloadException">The deployment manifest cannot be downloaded.</exception>
		/// <exception cref="T:System.Deployment.Application.InvalidDeploymentException">The deployment manifest is corrupted. You will likely need to redeploy the application to fix this problem.</exception>
		public bool CheckForUpdate()
		{
			return CheckForUpdate(persistUpdateCheckResult: true);
		}

		/// <summary>Checks <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> to determine whether a new update is available.</summary>
		/// <param name="persistUpdateCheckResult">If <see langword="false" />, the update will be applied silently and no dialog box will be displayed.</param>
		/// <returns>
		///   <see langword="true" /> if a new update is available; otherwise, <see langword="false" />.</returns>
		public bool CheckForUpdate(bool persistUpdateCheckResult)
		{
			UpdateCheckInfo updateCheckInfo = CheckForDetailedUpdate(persistUpdateCheckResult);
			return updateCheckInfo.UpdateAvailable;
		}

		/// <summary>Checks <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> asynchronously to determine whether a new update is available.</summary>
		/// <exception cref="T:System.InvalidOperationException">ClickOnce throws this exception immediately if you call the <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> method while an update is already in progress.</exception>
		/// <exception cref="T:System.Deployment.Application.DeploymentDownloadException">The deployment manifest cannot be downloaded. This exception appears in the <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> property of the <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> event.</exception>
		/// <exception cref="T:System.Deployment.Application.InvalidDeploymentException">The deployment manifest is corrupted. You will likely need to redeploy the application to fix this problem. This exception appears in the <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> property of the <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> event.</exception>
		public void CheckForUpdateAsync()
		{
			new NamedPermissionSet("FullTrust").Demand();
			if (Interlocked.CompareExchange(ref _guard, 1, 0) != 0)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_SingleOperation"));
			}
			_cancellationPending = false;
			DeploymentManager deploymentManager = CreateDeploymentManager();
			deploymentManager.ProgressChanged += CheckForUpdateProgressChangedEventHandler;
			deploymentManager.BindCompleted += CheckForUpdateBindCompletedEventHandler;
			deploymentManager.BindAsync();
		}

		/// <summary>Cancels the asynchronous update check.</summary>
		public void CheckForUpdateAsyncCancel()
		{
			if (_guard == 1)
			{
				_cancellationPending = true;
			}
		}

		/// <summary>Starts a synchronous download and installation of the latest version of this application.</summary>
		/// <returns>
		///   <see langword="true" /> if an application has been updated; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.Deployment.Application.TrustNotGrantedException">The local computer did not grant the application the permission level it requested to execute.</exception>
		/// <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Your ClickOnce deployment is corrupted. For tips on how to diagnose and correct the problem, see Troubleshooting ClickOnce Deployments.</exception>
		/// <exception cref="T:System.Deployment.Application.DeploymentDownloadException">The new deployment could not be downloaded from its location on the network.</exception>
		/// <exception cref="T:System.InvalidOperationException">The application is currently being updated.</exception>
		public bool Update()
		{
			new NamedPermissionSet("FullTrust").Demand();
			if (Interlocked.CompareExchange(ref _guard, 2, 0) != 0)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_SingleOperation"));
			}
			_cancellationPending = false;
			try
			{
				DeploymentManager deploymentManager = CreateDeploymentManager();
				try
				{
					deploymentManager.Bind();
					UpdateCheckInfo updateCheckInfo = DetermineUpdateCheckResult(deploymentManager.ActivationDescription);
					if (updateCheckInfo.UpdateAvailable)
					{
						deploymentManager.DeterminePlatformRequirements();
						try
						{
							TrustParams trustParams = new TrustParams();
							trustParams.NoPrompt = true;
							deploymentManager.DetermineTrust(trustParams);
						}
						catch (TrustNotGrantedException)
						{
							if (!deploymentManager.ActivationDescription.IsUpdateInPKTGroup)
							{
								throw;
							}
						}
					}
					ProcessUpdateCheckResult(updateCheckInfo, deploymentManager.ActivationDescription);
					if (!updateCheckInfo.UpdateAvailable)
					{
						return false;
					}
					deploymentManager.Synchronize();
					if (deploymentManager.ActivationDescription.IsUpdateInPKTGroup)
					{
						_subState = _subStore.GetSubscriptionState(deploymentManager.ActivationDescription.DeployManifest);
					}
				}
				finally
				{
					deploymentManager.Dispose();
				}
			}
			finally
			{
				Interlocked.Exchange(ref _guard, 0);
			}
			return true;
		}

		/// <summary>Starts an asynchronous download and installation of the latest version of this application.</summary>
		/// <exception cref="T:System.Deployment.Application.TrustNotGrantedException">The local computer did not grant this application the permission level it requested to execute.</exception>
		/// <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Your ClickOnce deployment is corrupted. For tips on how to diagnose and correct the problem, see Troubleshooting ClickOnce Deployments.</exception>
		/// <exception cref="T:System.Deployment.Application.DeploymentDownloadException">The new deployment could not be downloaded from its location on the network.</exception>
		public void UpdateAsync()
		{
			new NamedPermissionSet("FullTrust").Demand();
			if (Interlocked.CompareExchange(ref _guard, 1, 0) != 0)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_SingleOperation"));
			}
			_cancellationPending = false;
			DeploymentManager deploymentManager = CreateDeploymentManager();
			deploymentManager.ProgressChanged += UpdateProgressChangedEventHandler;
			deploymentManager.BindCompleted += UpdateBindCompletedEventHandler;
			deploymentManager.SynchronizeCompleted += SynchronizeNullCompletedEventHandler;
			deploymentManager.BindAsync();
		}

		/// <summary>Cancels an asynchronous update initiated by <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />.</summary>
		public void UpdateAsyncCancel()
		{
			if (_guard == 1)
			{
				_cancellationPending = true;
			}
		}

		/// <summary>Downloads a set of optional files on demand.</summary>
		/// <param name="groupName">The named group of files to download. All files marked "optional" in a ClickOnce application require a group name.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="groupName" /> parameter is null or zero-length.</exception>
		[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
		public void DownloadFileGroup(string groupName)
		{
			if (groupName == null)
			{
				throw new ArgumentNullException("groupName");
			}
			_subState.Invalidate();
			if (!_fullAppId.Equals(_subState.CurrentBind))
			{
				throw new InvalidOperationException(Resources.GetString("Ex_DownloadGroupAfterUpdate"));
			}
			SyncGroupDeploymentManager.Synchronize(groupName);
		}

		/// <summary>Downloads, on demand, a set of optional files in the background.</summary>
		/// <param name="groupName">The named group of files to download. All files marked "optional" in a ClickOnce application require a group name.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="groupName" /> parameter is null or zero-length.</exception>
		/// <exception cref="T:System.InvalidOperationException">You cannot initiate more than one download of <paramref name="groupName" /> at a time.</exception>
		public void DownloadFileGroupAsync(string groupName)
		{
			DownloadFileGroupAsync(groupName, null);
		}

		/// <summary>Downloads, on demand, a set of optional files in the background, and passes a piece of application state to the event callbacks.</summary>
		/// <param name="groupName">The named group of files to download. All files marked "optional" in a ClickOnce application require a group name.</param>
		/// <param name="userState">An arbitrary object containing state information for the asynchronous operation.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="groupName" /> parameter is null or zero-length.</exception>
		/// <exception cref="T:System.InvalidOperationException">You cannot initiate more than one download of <paramref name="groupName" /> at a time.</exception>
		[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
		public void DownloadFileGroupAsync(string groupName, object userState)
		{
			if (groupName == null)
			{
				throw new ArgumentNullException("groupName");
			}
			_subState.Invalidate();
			if (!_fullAppId.Equals(_subState.CurrentBind))
			{
				throw new InvalidOperationException(Resources.GetString("Ex_DownloadGroupAfterUpdate"));
			}
			SyncGroupDeploymentManager.SynchronizeAsync(groupName, userState);
		}

		/// <summary>Checks whether the named file group has already been downloaded to the client computer.</summary>
		/// <param name="groupName">The named group of files to download. All files marked "optional" in a ClickOnce application require a group name.</param>
		/// <returns>
		///   <see langword="true" /> if the file group has already been downloaded for the current version of this application; otherwise, <see langword="false" />. If a new version of the application has been installed, and the new version has not added, removed, or altered files in the file group, <see cref="M:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded(System.String)" /> returns <see langword="true" />.</returns>
		/// <exception cref="T:System.Deployment.Application.InvalidDeploymentException">
		///   <paramref name="groupName" /> is not a file group defined in the application manifest.</exception>
		[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
		public bool IsFileGroupDownloaded(string groupName)
		{
			return _subStore.CheckGroupInstalled(_subState, _fullAppId, groupName);
		}

		/// <summary>Cancels an asynchronous file download.</summary>
		/// <param name="groupName">The named group of files to download. All files marked "optional" in a ClickOnce application require a group name.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="groupName" /> cannot be <see langword="null" />.</exception>
		[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
		public void DownloadFileGroupAsyncCancel(string groupName)
		{
			if (groupName == null)
			{
				throw new ArgumentNullException("groupName");
			}
			SyncGroupDeploymentManager.CancelAsync(groupName);
		}

		private DeploymentManager CreateDeploymentManager()
		{
			_subState.Invalidate();
			DeploymentManager deploymentManager = new DeploymentManager(_subState.DeploymentProviderUri, isUpdate: true, isConfirmed: true, null, asyncOperation);
			deploymentManager.Callertype = DeploymentManager.CallerType.ApplicationDeployment;
			return deploymentManager;
		}

		private void CheckForUpdateProgressChangedEventHandler(object sender, DeploymentProgressChangedEventArgs e)
		{
			if (_cancellationPending)
			{
				((DeploymentManager)sender).CancelAsync();
			}
			((DeploymentProgressChangedEventHandler)Events[checkForUpdateProgressChangedKey])?.Invoke(this, e);
		}

		private void UpdateProgressChangedEventHandler(object sender, DeploymentProgressChangedEventArgs e)
		{
			if (_cancellationPending)
			{
				((DeploymentManager)sender).CancelAsync();
			}
			((DeploymentProgressChangedEventHandler)Events[updateProgressChangedKey])?.Invoke(this, e);
		}

		private void DownloadFileGroupProgressChangedEventHandler(object sender, DeploymentProgressChangedEventArgs e)
		{
			((DeploymentProgressChangedEventHandler)Events[downloadFileGroupProgressChangedKey])?.Invoke(this, e);
		}

		private void CheckForUpdateBindCompletedEventHandler(object sender, BindCompletedEventArgs e)
		{
			Exception error = null;
			DeploymentManager deploymentManager = null;
			bool updateAvailable = false;
			Version availableVersion = null;
			bool isUpdateRequired = false;
			Version minimumRequiredVersion = null;
			long updateSize = 0L;
			new NamedPermissionSet("FullTrust").Assert();
			try
			{
				deploymentManager = (DeploymentManager)sender;
				if (e.Error == null && !e.Cancelled)
				{
					UpdateCheckInfo updateCheckInfo = DetermineUpdateCheckResult(deploymentManager.ActivationDescription);
					if (updateCheckInfo.UpdateAvailable)
					{
						deploymentManager.DeterminePlatformRequirements();
						try
						{
							TrustParams trustParams = new TrustParams();
							trustParams.NoPrompt = true;
							deploymentManager.DetermineTrust(trustParams);
						}
						catch (TrustNotGrantedException)
						{
							if (!deploymentManager.ActivationDescription.IsUpdateInPKTGroup)
							{
								throw;
							}
						}
					}
					ProcessUpdateCheckResult(updateCheckInfo, deploymentManager.ActivationDescription);
					if (updateCheckInfo.UpdateAvailable)
					{
						updateAvailable = true;
						availableVersion = updateCheckInfo.AvailableVersion;
						isUpdateRequired = updateCheckInfo.IsUpdateRequired;
						minimumRequiredVersion = updateCheckInfo.MinimumRequiredVersion;
						updateSize = updateCheckInfo.UpdateSizeBytes;
					}
				}
				else
				{
					error = e.Error;
				}
			}
			catch (Exception ex2)
			{
				if (ExceptionUtility.IsHardException(ex2))
				{
					throw;
				}
				error = ex2;
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
				Interlocked.Exchange(ref _guard, 0);
				CheckForUpdateCompletedEventArgs e2 = new CheckForUpdateCompletedEventArgs(error, e.Cancelled, null, updateAvailable, availableVersion, isUpdateRequired, minimumRequiredVersion, updateSize);
				((CheckForUpdateCompletedEventHandler)Events[checkForUpdateCompletedKey])?.Invoke(this, e2);
				if (deploymentManager != null)
				{
					deploymentManager.ProgressChanged -= CheckForUpdateProgressChangedEventHandler;
					deploymentManager.BindCompleted -= CheckForUpdateBindCompletedEventHandler;
					new NamedPermissionSet("FullTrust").Assert();
					try
					{
						deploymentManager.Dispose();
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
				}
			}
		}

		private void UpdateBindCompletedEventHandler(object sender, BindCompletedEventArgs e)
		{
			Exception error = null;
			DeploymentManager deploymentManager = null;
			bool flag = false;
			new NamedPermissionSet("FullTrust").Assert();
			try
			{
				deploymentManager = (DeploymentManager)sender;
				if (e.Error == null && !e.Cancelled)
				{
					UpdateCheckInfo updateCheckInfo = DetermineUpdateCheckResult(deploymentManager.ActivationDescription);
					if (updateCheckInfo.UpdateAvailable)
					{
						deploymentManager.DeterminePlatformRequirements();
						try
						{
							TrustParams trustParams = new TrustParams();
							trustParams.NoPrompt = true;
							deploymentManager.DetermineTrust(trustParams);
						}
						catch (TrustNotGrantedException)
						{
							if (!deploymentManager.ActivationDescription.IsUpdateInPKTGroup)
							{
								throw;
							}
						}
					}
					ProcessUpdateCheckResult(updateCheckInfo, deploymentManager.ActivationDescription);
					if (updateCheckInfo.UpdateAvailable)
					{
						flag = true;
						deploymentManager.SynchronizeAsync();
					}
					if (deploymentManager.ActivationDescription.IsUpdateInPKTGroup)
					{
						_subState = _subStore.GetSubscriptionState(deploymentManager.ActivationDescription.DeployManifest);
					}
				}
				else
				{
					error = e.Error;
				}
			}
			catch (Exception ex2)
			{
				if (ExceptionUtility.IsHardException(ex2))
				{
					throw;
				}
				error = ex2;
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
				if (!flag)
				{
					EndUpdateAsync(deploymentManager, error, e.Cancelled);
				}
			}
		}

		private void EndUpdateAsync(DeploymentManager dm, Exception error, bool cancelled)
		{
			Interlocked.Exchange(ref _guard, 0);
			AsyncCompletedEventArgs e = new AsyncCompletedEventArgs(error, cancelled, null);
			((AsyncCompletedEventHandler)Events[updateCompletedKey])?.Invoke(this, e);
			if (dm != null)
			{
				dm.ProgressChanged -= UpdateProgressChangedEventHandler;
				dm.BindCompleted -= UpdateBindCompletedEventHandler;
				dm.SynchronizeCompleted -= SynchronizeNullCompletedEventHandler;
				new NamedPermissionSet("FullTrust").Assert();
				try
				{
					dm.Dispose();
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
			}
		}

		private void SynchronizeNullCompletedEventHandler(object sender, SynchronizeCompletedEventArgs e)
		{
			Exception error = null;
			DeploymentManager dm = null;
			new NamedPermissionSet("FullTrust").Assert();
			try
			{
				dm = (DeploymentManager)sender;
				error = e.Error;
			}
			catch (Exception ex)
			{
				if (ExceptionUtility.IsHardException(ex))
				{
					throw;
				}
				error = ex;
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
				EndUpdateAsync(dm, error, e.Cancelled);
			}
		}

		private void SynchronizeGroupCompletedEventHandler(object sender, SynchronizeCompletedEventArgs e)
		{
			Exception ex = null;
			DeploymentManager deploymentManager = null;
			try
			{
				deploymentManager = (DeploymentManager)sender;
				ex = e.Error;
			}
			catch (Exception ex2)
			{
				if (ExceptionUtility.IsHardException(ex2))
				{
					throw;
				}
				ex = ex2;
			}
			finally
			{
				DownloadFileGroupCompletedEventArgs e2 = new DownloadFileGroupCompletedEventArgs(e.Error, e.Cancelled, e.UserState, e.Group);
				((DownloadFileGroupCompletedEventHandler)Events[downloadFileGroupCompletedKey])?.Invoke(this, e2);
			}
		}

		private UpdateCheckInfo DetermineUpdateCheckResult(ActivationDescription actDesc)
		{
			bool updateAvailable = false;
			Version availableVersion = null;
			bool isUpdateRequired = false;
			Version version = null;
			long updateSize = 0L;
			bool bUpdateInPKTGroup = false;
			AssemblyManifest deployManifest = actDesc.DeployManifest;
			_subState.Invalidate();
			Version version2 = _subStore.CheckUpdateInManifest(_subState, actDesc.DeploySourceUri, deployManifest, _currentVersion, ref bUpdateInPKTGroup);
			if (version2 != null && !deployManifest.Identity.Equals(_subState.ExcludedDeployment))
			{
				updateAvailable = true;
				availableVersion = version2;
				version = deployManifest.Deployment.MinimumRequiredVersion;
				if (version != null && version.CompareTo(_currentVersion) > 0)
				{
					isUpdateRequired = true;
				}
				ulong num = actDesc.AppManifest.CalculateDependenciesSize();
				updateSize = (long)((num <= long.MaxValue) ? num : long.MaxValue);
				actDesc.IsUpdateInPKTGroup = bUpdateInPKTGroup;
			}
			return new UpdateCheckInfo(updateAvailable, availableVersion, isUpdateRequired, version, updateSize);
		}

		private void ProcessUpdateCheckResult(UpdateCheckInfo info, ActivationDescription actDesc)
		{
			if (_subState.IsShellVisible)
			{
				AssemblyManifest deployManifest = actDesc.DeployManifest;
				DefinitionIdentity deployId = (info.UpdateAvailable ? deployManifest.Identity : null);
				_subStore.SetPendingDeployment(_subState, deployId, DateTime.UtcNow);
			}
		}

		private void DemandPermission()
		{
			accessPermission.Demand();
		}
	}
	/// <summary>Represents detailed update information obtained through a call to <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />.</summary>
	public class UpdateCheckInfo
	{
		private readonly bool _updateAvailable;

		private readonly Version _availableVersion;

		private readonly bool _isUpdateRequired;

		private readonly Version _minimumRequiredVersion;

		private readonly long _updateSize;

		/// <summary>Gets whether an uninstalled update is available.</summary>
		/// <returns>
		///   <see langword="true" /> if new version of the application is available; otherwise, <see langword="false" />.</returns>
		public bool UpdateAvailable => _updateAvailable;

		/// <summary>Gets the version number of the latest uninstalled version.</summary>
		/// <returns>The <see cref="T:System.Version" /> expressing the major and minor build and revision numbers of the latest version.</returns>
		public Version AvailableVersion
		{
			get
			{
				RaiseExceptionIfUpdateNotAvailable();
				return _availableVersion;
			}
		}

		/// <summary>Gets a value indicating whether the update must be installed.</summary>
		/// <returns>
		///   <see langword="true" /> if the update is required; otherwise, <see langword="false" />.</returns>
		public bool IsUpdateRequired
		{
			get
			{
				RaiseExceptionIfUpdateNotAvailable();
				return _isUpdateRequired;
			}
		}

		/// <summary>Gets the minimum version that the user must have installed on the computer.</summary>
		/// <returns>A <see cref="T:System.Version" /> expressing the least version that the user must install.</returns>
		/// <exception cref="T:System.InvalidOperationException">There is no new version available to install.</exception>
		public Version MinimumRequiredVersion
		{
			get
			{
				RaiseExceptionIfUpdateNotAvailable();
				return _minimumRequiredVersion;
			}
		}

		/// <summary>Gets the size of the available update.</summary>
		/// <returns>An <see cref="T:System.Int64" /> describing the size, in bytes, of the available update. If no update is available, returns 0.</returns>
		public long UpdateSizeBytes
		{
			get
			{
				RaiseExceptionIfUpdateNotAvailable();
				return _updateSize;
			}
		}

		internal UpdateCheckInfo(bool updateAvailable, Version availableVersion, bool isUpdateRequired, Version minimumRequiredVersion, long updateSize)
		{
			_updateAvailable = updateAvailable;
			_availableVersion = availableVersion;
			_isUpdateRequired = isUpdateRequired;
			_minimumRequiredVersion = minimumRequiredVersion;
			_updateSize = updateSize;
		}

		private void RaiseExceptionIfUpdateNotAvailable()
		{
			if (!UpdateAvailable)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_UpdateNotAvailable"));
			}
		}
	}
	/// <summary>Represents the method that will handle the <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> event of an <see cref="T:System.Deployment.Application.ApplicationDeployment" />.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Deployment.Application.CheckForUpdateCompletedEventArgs" /> that contains the event data.</param>
	public delegate void CheckForUpdateCompletedEventHandler(object sender, CheckForUpdateCompletedEventArgs e);
	/// <summary>Represents detailed update information obtained through a call to <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />.</summary>
	public class CheckForUpdateCompletedEventArgs : AsyncCompletedEventArgs
	{
		private readonly bool _updateAvailable;

		private readonly Version _availableVersion;

		private readonly bool _isUpdateRequired;

		private readonly Version _minimumRequiredVersion;

		private readonly long _updateSize;

		/// <summary>Gets whether an uninstalled update is available.</summary>
		/// <returns>
		///   <see langword="true" /> if new version of the application is available; otherwise, <see langword="false" />.</returns>
		public bool UpdateAvailable
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _updateAvailable;
			}
		}

		/// <summary>Gets the version number of the latest uninstalled version.</summary>
		/// <returns>The <see cref="T:System.Version" /> expressing the major, minor, build and revision numbers of the latest version.</returns>
		public Version AvailableVersion
		{
			get
			{
				RaiseExceptionIfUpdateNotAvailable();
				return _availableVersion;
			}
		}

		/// <summary>Gets a value indicating whether the update must be installed.</summary>
		/// <returns>
		///   <see langword="true" /> if the update is required; otherwise, <see langword="false" />.</returns>
		public bool IsUpdateRequired
		{
			get
			{
				RaiseExceptionIfUpdateNotAvailable();
				return _isUpdateRequired;
			}
		}

		/// <summary>Gets the minimum version that the user must have installed on the computer.</summary>
		/// <returns>A <see cref="T:System.Version" /> object expressing the earliest version that all users must install.</returns>
		public Version MinimumRequiredVersion
		{
			get
			{
				RaiseExceptionIfUpdateNotAvailable();
				return _minimumRequiredVersion;
			}
		}

		/// <summary>Gets the size of the available update.</summary>
		/// <returns>An <see cref="T:System.Int64" /> describing the size, in bytes, of the available update. If no update is available, returns 0.</returns>
		public long UpdateSizeBytes
		{
			get
			{
				RaiseExceptionIfUpdateNotAvailable();
				return _updateSize;
			}
		}

		internal CheckForUpdateCompletedEventArgs(Exception error, bool cancelled, object userState, bool updateAvailable, Version availableVersion, bool isUpdateRequired, Version minimumRequiredVersion, long updateSize)
			: base(error, cancelled, userState)
		{
			_updateAvailable = updateAvailable;
			_availableVersion = availableVersion;
			_isUpdateRequired = isUpdateRequired;
			_minimumRequiredVersion = minimumRequiredVersion;
			_updateSize = updateSize;
		}

		private void RaiseExceptionIfUpdateNotAvailable()
		{
			if (!UpdateAvailable)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_UpdateNotAvailable"));
			}
		}
	}
	/// <summary>Represents the method that will handle the <see cref="E:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupCompleted" /> event of an <see cref="T:System.Deployment.Application.ApplicationDeployment" />.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Deployment.Application.DownloadFileGroupCompletedEventArgs" /> that contains the event data.</param>
	public delegate void DownloadFileGroupCompletedEventHandler(object sender, DownloadFileGroupCompletedEventArgs e);
	/// <summary>Describes a file download that has recently completed.</summary>
	public class DownloadFileGroupCompletedEventArgs : AsyncCompletedEventArgs
	{
		private readonly string _groupName;

		/// <summary>Gets the name of the file group being downloaded.</summary>
		/// <returns>A <see cref="T:System.String" /> representing the name of the file group.</returns>
		public string Group => _groupName;

		internal DownloadFileGroupCompletedEventArgs(Exception error, bool cancelled, object userState, string groupName)
			: base(error, cancelled, userState)
		{
			_groupName = groupName;
		}
	}
	internal class DefinitionAppId
	{
		private System.Deployment.Internal.Isolation.IDefinitionAppId _idComPtr;

		public ulong Hash => System.Deployment.Internal.Isolation.IsolationInterop.AppIdAuthority.HashDefinition(0u, _idComPtr);

		public System.Deployment.Internal.Isolation.IDefinitionAppId ComPointer => _idComPtr;

		public string Codebase => _idComPtr.get_Codebase();

		public DefinitionIdentity DeploymentIdentity => PathComponent(0u);

		public DefinitionIdentity ApplicationIdentity => PathComponent(1u);

		public DefinitionAppId()
		{
			_idComPtr = System.Deployment.Internal.Isolation.IsolationInterop.AppIdAuthority.CreateDefinition();
		}

		public DefinitionAppId(params DefinitionIdentity[] idPath)
			: this(null, idPath)
		{
		}

		public DefinitionAppId(string codebase, params DefinitionIdentity[] idPath)
		{
			uint num = (uint)idPath.Length;
			System.Deployment.Internal.Isolation.IDefinitionIdentity[] array = new System.Deployment.Internal.Isolation.IDefinitionIdentity[num];
			for (uint num2 = 0u; num2 < num; num2++)
			{
				array[num2] = idPath[num2].ComPointer;
			}
			_idComPtr = System.Deployment.Internal.Isolation.IsolationInterop.AppIdAuthority.CreateDefinition();
			_idComPtr.put_Codebase(codebase);
			_idComPtr.SetAppPath(num, array);
		}

		public DefinitionAppId(string text)
		{
			_idComPtr = System.Deployment.Internal.Isolation.IsolationInterop.AppIdAuthority.TextToDefinition(0u, text);
		}

		public DefinitionAppId(System.Deployment.Internal.Isolation.IDefinitionAppId idComPtr)
		{
			_idComPtr = idComPtr;
		}

		public DefinitionAppId ToDeploymentAppId()
		{
			return new DefinitionAppId(Codebase, DeploymentIdentity);
		}

		public ApplicationIdentity ToApplicationIdentity()
		{
			return new ApplicationIdentity(System.Deployment.Internal.Isolation.IsolationInterop.AppIdAuthority.DefinitionToText(0u, _idComPtr));
		}

		public override bool Equals(object obj)
		{
			if (obj is DefinitionAppId)
			{
				return System.Deployment.Internal.Isolation.IsolationInterop.AppIdAuthority.AreDefinitionsEqual(0u, ComPointer, ((DefinitionAppId)obj).ComPointer);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (int)Hash;
		}

		public override string ToString()
		{
			return System.Deployment.Internal.Isolation.IsolationInterop.AppIdAuthority.DefinitionToText(0u, _idComPtr);
		}

		private DefinitionIdentity PathComponent(uint index)
		{
			System.Deployment.Internal.Isolation.IEnumDefinitionIdentity enumDefinitionIdentity = null;
			try
			{
				enumDefinitionIdentity = _idComPtr.EnumAppPath();
				if (index != 0)
				{
					enumDefinitionIdentity.Skip(index);
				}
				System.Deployment.Internal.Isolation.IDefinitionIdentity[] array = new System.Deployment.Internal.Isolation.IDefinitionIdentity[1];
				uint num = enumDefinitionIdentity.Next(1u, array);
				return (num == 1) ? new DefinitionIdentity(array[0]) : null;
			}
			finally
			{
				if (enumDefinitionIdentity != null)
				{
					Marshal.ReleaseComObject(enumDefinitionIdentity);
				}
			}
		}
	}
	internal static class ApplicationTrust
	{
		public static System.Security.Policy.ApplicationTrust RequestTrust(SubscriptionState subState, bool isShellVisible, bool isUpdate, ActivationContext actCtx)
		{
			TrustManagerContext trustManagerContext = new TrustManagerContext();
			trustManagerContext.IgnorePersistedDecision = false;
			trustManagerContext.NoPrompt = false;
			trustManagerContext.Persist = true;
			return RequestTrust(subState, isShellVisible, isUpdate, actCtx, trustManagerContext);
		}

		public static System.Security.Policy.ApplicationTrust RequestTrust(SubscriptionState subState, bool isShellVisible, bool isUpdate, ActivationContext actCtx, TrustManagerContext tmc)
		{
			Logger.AddMethodCall("ApplicationTrust.RequestTrust(isShellVisible=" + isShellVisible + ", isUpdate=" + isUpdate + ", subState.IsInstalled=" + subState.IsInstalled + ") called.");
			if (!subState.IsInstalled || subState.IsShellVisible != isShellVisible)
			{
				tmc.IgnorePersistedDecision = true;
			}
			if (isUpdate)
			{
				tmc.PreviousApplicationIdentity = subState.CurrentBind.ToApplicationIdentity();
			}
			bool flag = false;
			try
			{
				Logger.AddInternalState("Calling ApplicationSecurityManager.DetermineApplicationTrust().");
				Logger.AddInternalState("Trust Manager Context=" + Logger.Serialize(tmc));
				flag = ApplicationSecurityManager.DetermineApplicationTrust(actCtx, tmc);
			}
			catch (TypeLoadException innerException)
			{
				throw new InvalidDeploymentException(Resources.GetString("Ex_InvalidTrustInfo"), innerException);
			}
			if (!flag)
			{
				throw new TrustNotGrantedException(Resources.GetString("Ex_NoTrust"));
			}
			Logger.AddInternalState("Trust granted.");
			System.Security.Policy.ApplicationTrust applicationTrust = null;
			for (int i = 0; i < 5; i++)
			{
				applicationTrust = ApplicationSecurityManager.UserApplicationTrusts[actCtx.Identity.FullName];
				if (applicationTrust != null)
				{
					break;
				}
				Thread.Sleep(10);
			}
			if (applicationTrust == null)
			{
				throw new InvalidDeploymentException(Resources.GetString("Ex_InvalidMatchTrust"));
			}
			return applicationTrust;
		}

		public static void RemoveCachedTrust(DefinitionAppId appId)
		{
			ApplicationSecurityManager.UserApplicationTrusts.Remove(appId.ToApplicationIdentity(), ApplicationVersionMatch.MatchExactVersion);
		}

		public static System.Security.Policy.ApplicationTrust PersistTrustWithoutEvaluation(ActivationContext actCtx)
		{
			ApplicationSecurityInfo applicationSecurityInfo = new ApplicationSecurityInfo(actCtx);
			System.Security.Policy.ApplicationTrust applicationTrust = new System.Security.Policy.ApplicationTrust(actCtx.Identity);
			applicationTrust.IsApplicationTrustedToRun = true;
			applicationTrust.DefaultGrantSet = new PolicyStatement(applicationSecurityInfo.DefaultRequestSet, PolicyStatementAttribute.Nothing);
			applicationTrust.Persist = true;
			applicationTrust.ApplicationIdentity = actCtx.Identity;
			ApplicationSecurityManager.UserApplicationTrusts.Add(applicationTrust);
			return applicationTrust;
		}
	}
	internal static class AssemblyIdentityItems
	{
		public const string Name = "name";

		public const string PublicKeyToken = "publicKeyToken";

		public const string Version = "version";

		public const string ProcessorArchitecture = "processorArchitecture";

		public const string Culture = "culture";

		public const string Type = "type";

		public const string Language = "language";
	}
	internal class DefinitionIdentity : ICloneable
	{
		private System.Deployment.Internal.Isolation.IDefinitionIdentity _idComPtr;

		public string this[string name]
		{
			get
			{
				return _idComPtr.GetAttribute(null, name);
			}
			set
			{
				_idComPtr.SetAttribute(null, name, value);
			}
		}

		public string this[string ns, string name]
		{
			set
			{
				_idComPtr.SetAttribute(ns, name, value);
			}
		}

		public string Name
		{
			get
			{
				return this["name"];
			}
			set
			{
				this["name"] = value;
			}
		}

		public Version Version
		{
			get
			{
				string text = this["version"];
				if (text == null)
				{
					return null;
				}
				return new Version(text);
			}
		}

		public string PublicKeyToken => this["publicKeyToken"];

		public string ProcessorArchitecture => this["processorArchitecture"];

		public ulong Hash => System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.HashDefinition(0u, _idComPtr);

		public string KeyForm => System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.GenerateDefinitionKey(0u, _idComPtr);

		public System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[] Attributes
		{
			get
			{
				System.Deployment.Internal.Isolation.IEnumIDENTITY_ATTRIBUTE enumIDENTITY_ATTRIBUTE = null;
				try
				{
					ArrayList arrayList = new ArrayList();
					enumIDENTITY_ATTRIBUTE = _idComPtr.EnumAttributes();
					System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[] array = new System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[1];
					while (enumIDENTITY_ATTRIBUTE.Next(1u, array) == 1)
					{
						arrayList.Add(array[0]);
					}
					return (System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[])arrayList.ToArray(typeof(System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE));
				}
				finally
				{
					if (enumIDENTITY_ATTRIBUTE != null)
					{
						Marshal.ReleaseComObject(enumIDENTITY_ATTRIBUTE);
					}
				}
			}
		}

		public bool IsEmpty
		{
			get
			{
				System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[] attributes = Attributes;
				System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[] array = attributes;
				for (int i = 0; i < array.Length; i++)
				{
					System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE iDENTITY_ATTRIBUTE = array[i];
					if (!string.IsNullOrEmpty(iDENTITY_ATTRIBUTE.Value))
					{
						return false;
					}
				}
				return true;
			}
		}

		public System.Deployment.Internal.Isolation.IDefinitionIdentity ComPointer => _idComPtr;

		public DefinitionIdentity()
		{
			_idComPtr = System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.CreateDefinition();
		}

		public DefinitionIdentity(string text)
		{
			_idComPtr = System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.TextToDefinition(0u, text);
		}

		public DefinitionIdentity(System.Deployment.Internal.Isolation.IDefinitionIdentity idComPtr)
		{
			_idComPtr = idComPtr;
		}

		public DefinitionIdentity(ReferenceIdentity refId)
		{
			_idComPtr = System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.CreateDefinition();
			System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[] attributes = refId.Attributes;
			System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[] array = attributes;
			for (int i = 0; i < array.Length; i++)
			{
				System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE iDENTITY_ATTRIBUTE = array[i];
				this[iDENTITY_ATTRIBUTE.Namespace, iDENTITY_ATTRIBUTE.Name] = iDENTITY_ATTRIBUTE.Value;
			}
		}

		public DefinitionIdentity(AssemblyName asmName)
		{
			_idComPtr = System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.CreateDefinition();
			this["name"] = asmName.Name;
			this["version"] = asmName.Version.ToString();
			if (asmName.CultureInfo != null)
			{
				this["culture"] = asmName.CultureInfo.Name;
			}
			byte[] publicKeyToken = asmName.GetPublicKeyToken();
			if (publicKeyToken != null && publicKeyToken.Length != 0)
			{
				this["publicKeyToken"] = HexString.FromBytes(publicKeyToken);
			}
		}

		public bool Matches(ReferenceIdentity refId, bool exact)
		{
			if (System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.DoesDefinitionMatchReference(exact ? 1u : 0u, _idComPtr, refId.ComPointer))
			{
				return Version == refId.Version;
			}
			return false;
		}

		public DefinitionIdentity ToSubscriptionId()
		{
			DefinitionIdentity definitionIdentity = (DefinitionIdentity)Clone();
			definitionIdentity["version"] = null;
			return definitionIdentity;
		}

		public DefinitionIdentity ToPKTGroupId()
		{
			DefinitionIdentity definitionIdentity = (DefinitionIdentity)Clone();
			definitionIdentity["version"] = null;
			definitionIdentity["publicKeyToken"] = null;
			return definitionIdentity;
		}

		public override bool Equals(object obj)
		{
			if (obj is DefinitionIdentity)
			{
				return System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.AreDefinitionsEqual(0u, ComPointer, ((DefinitionIdentity)obj).ComPointer);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (int)Hash;
		}

		public override string ToString()
		{
			return System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.DefinitionToText(0u, _idComPtr);
		}

		public object Clone()
		{
			return new DefinitionIdentity(_idComPtr.Clone(IntPtr.Zero, null));
		}
	}
	internal class ReferenceIdentity : ICloneable
	{
		private System.Deployment.Internal.Isolation.IReferenceIdentity _idComPtr;

		public string this[string name]
		{
			get
			{
				return _idComPtr.GetAttribute(null, name);
			}
			set
			{
				_idComPtr.SetAttribute(null, name, value);
			}
		}

		public string Name => this["name"];

		public string Culture => this["culture"];

		public Version Version
		{
			get
			{
				string text = this["version"];
				if (text == null)
				{
					return null;
				}
				return new Version(text);
			}
		}

		public string PublicKeyToken => this["publicKeyToken"];

		public string ProcessorArchitecture
		{
			get
			{
				return this["processorArchitecture"];
			}
			set
			{
				this["processorArchitecture"] = value;
			}
		}

		public ulong Hash => System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.HashReference(0u, _idComPtr);

		public System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[] Attributes
		{
			get
			{
				System.Deployment.Internal.Isolation.IEnumIDENTITY_ATTRIBUTE enumIDENTITY_ATTRIBUTE = null;
				try
				{
					ArrayList arrayList = new ArrayList();
					enumIDENTITY_ATTRIBUTE = _idComPtr.EnumAttributes();
					System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[] array = new System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[1];
					while (enumIDENTITY_ATTRIBUTE.Next(1u, array) == 1)
					{
						arrayList.Add(array[0]);
					}
					return (System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[])arrayList.ToArray(typeof(System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE));
				}
				finally
				{
					if (enumIDENTITY_ATTRIBUTE != null)
					{
						Marshal.ReleaseComObject(enumIDENTITY_ATTRIBUTE);
					}
				}
			}
		}

		public System.Deployment.Internal.Isolation.IReferenceIdentity ComPointer => _idComPtr;

		public ReferenceIdentity()
		{
			_idComPtr = System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.CreateReference();
		}

		public ReferenceIdentity(string text)
		{
			_idComPtr = System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.TextToReference(0u, text);
		}

		public ReferenceIdentity(System.Deployment.Internal.Isolation.IReferenceIdentity idComPtr)
		{
			_idComPtr = idComPtr;
		}

		public override bool Equals(object obj)
		{
			if (obj is ReferenceIdentity)
			{
				return System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.AreReferencesEqual(0u, ComPointer, ((ReferenceIdentity)obj).ComPointer);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (int)Hash;
		}

		public override string ToString()
		{
			return System.Deployment.Internal.Isolation.IsolationInterop.IdentityAuthority.ReferenceToText(0u, _idComPtr);
		}

		public object Clone()
		{
			return new ReferenceIdentity(_idComPtr.Clone(IntPtr.Zero, null));
		}
	}
	/// <summary>Represents a version of the .NET Framework where an application can install and run.</summary>
	[Serializable]
	public class CompatibleFramework
	{
		private readonly string _supportedRuntime;

		private readonly string _profile;

		private readonly string _targetVersion;

		/// <summary>Specifies the runtime version number of the .NET Framework where an application can install and run.</summary>
		/// <returns>A string that represents the runtime version.</returns>
		public string SupportedRuntime => _supportedRuntime;

		/// <summary>Specifies the profile of the .NET Framework version where an application can install and run.</summary>
		/// <returns>A string that represents the profile.</returns>
		public string Profile => _profile;

		/// <summary>Specifies the version of the .NET Framework where an application can install and run.</summary>
		/// <returns>A string that represents the version.</returns>
		public string TargetVersion => _targetVersion;

		internal CompatibleFramework(System.Deployment.Internal.Isolation.Manifest.CompatibleFrameworkEntry compatibleFrameworkEntry)
		{
			_supportedRuntime = compatibleFrameworkEntry.SupportedRuntime;
			_profile = compatibleFrameworkEntry.Profile;
			_targetVersion = compatibleFrameworkEntry.TargetVersion;
		}
	}
	/// <summary>Provides details about versions of the .NET Framework on which this application can install and run.</summary>
	[Serializable]
	public class CompatibleFrameworks
	{
		private readonly Uri _supportUrl;

		private readonly CompatibleFramework[] _frameworks;

		/// <summary>Gets a <see cref="T:System.Uri" /> that provides the user with instructions for installing a version of the .NET Framework on which this application can install and run.</summary>
		/// <returns>A <see cref="T:System.Uri" /> that provides the user with instructions for installing a version of the .NET Framework on which this application can install and run.</returns>
		public Uri SupportUrl => _supportUrl;

		/// <summary>Gets a list of .NET Framework versions on which this application can install and run.</summary>
		/// <returns>A list of <see cref="T:System.Deployment.Application.CompatibleFramework" /> objects that specify the .NET Framework versions on which this application can install and run.</returns>
		public IList<CompatibleFramework> Frameworks => Array.AsReadOnly(_frameworks);

		internal CompatibleFrameworks(System.Deployment.Internal.Isolation.Manifest.CompatibleFrameworksMetadataEntry compatibleFrameworksMetadataEntry, CompatibleFramework[] frameworks)
		{
			_supportUrl = AssemblyManifest.UriFromMetadataEntry(compatibleFrameworksMetadataEntry.SupportUrl, "Ex_CompatibleFrameworksSupportUrlNotValid");
			_frameworks = frameworks;
		}
	}
	internal class ComponentStore
	{
		internal class CrossGroupApplicationData
		{
			public enum GroupType
			{
				UndefinedGroup,
				LocationGroup,
				IdentityGroup
			}

			public SubscriptionState SubState;

			public GroupType CrossGroupType;

			public CrossGroupApplicationData(SubscriptionState subState, GroupType groupType)
			{
				SubState = subState;
				CrossGroupType = groupType;
			}
		}

		private enum HostType
		{
			Default,
			AppLaunch,
			CorFlag
		}

		private class StoreTransactionContext : System.Deployment.Internal.Isolation.StoreTransaction
		{
			private object _scavengeContext;

			private ComponentStore _compStore;

			public ScavengeContext ScavengeContext
			{
				get
				{
					if (_scavengeContext == null)
					{
						Interlocked.CompareExchange(ref _scavengeContext, new ScavengeContext(_compStore), null);
					}
					return (ScavengeContext)_scavengeContext;
				}
			}

			public StoreTransactionContext(ComponentStore compStore)
			{
				_compStore = compStore;
			}
		}

		private class ScavengeContext
		{
			private class SubInstance : IComparable
			{
				public SubscriptionState SubState;

				public DateTime LastAccessTime;

				public int CompareTo(object other)
				{
					return ((SubInstance)other).LastAccessTime.CompareTo(LastAccessTime);
				}
			}

			private ComponentStore _compStore;

			private ArrayList _onlineDeploysToPin;

			private ArrayList _onlineDeploysToPinAlreadyPinned;

			private ArrayList _shellVisbleDeploysToUnpin;

			private ArrayList _addinDeploysToUnpin;

			private ArrayList _onlineDeploysToUnpin;

			private ulong _onlineToPinPrivateSizePreTransact;

			private ulong _onlineToPinPrivateSizePostTransact;

			private ulong _shellVisibleToUnpinSharedSize;

			private ulong _onlineToUnpinPrivateSize;

			private ulong _addinToUnpinSharedSize;

			public ScavengeContext(ComponentStore compStore)
			{
				_compStore = compStore;
			}

			public void CheckQuotaAndScavenge()
			{
				ulong onlineAppQuotaInBytes = _compStore.GetOnlineAppQuotaInBytes();
				ulong onlineAppQuotaUsageEstimate = GetOnlineAppQuotaUsageEstimate();
				long num = (long)(_onlineToPinPrivateSizePostTransact - _onlineToPinPrivateSizePreTransact - _onlineToUnpinPrivateSize + _shellVisibleToUnpinSharedSize + _addinToUnpinSharedSize);
				ulong num2;
				if (num >= 0)
				{
					num2 = onlineAppQuotaUsageEstimate + (ulong)num;
					if (num2 < onlineAppQuotaUsageEstimate)
					{
						num2 = ulong.MaxValue;
					}
				}
				else
				{
					num2 = onlineAppQuotaUsageEstimate - (ulong)(-num);
					if (num2 > onlineAppQuotaUsageEstimate)
					{
						num2 = ulong.MaxValue;
					}
				}
				if (num2 > onlineAppQuotaInBytes)
				{
					System.Deployment.Internal.Isolation.IDefinitionAppId[] deployAppIdPtrs;
					SubInstance[] subs = CollectOnlineAppsMRU(out deployAppIdPtrs);
					ulong privateSize = 0uL;
					ulong sharedSize = 0uL;
					if (deployAppIdPtrs.Length != 0)
					{
						_compStore.CalculateDeploymentsUnderQuota(deployAppIdPtrs.Length, deployAppIdPtrs, ulong.MaxValue, ref privateSize, ref sharedSize);
						if (privateSize > onlineAppQuotaInBytes)
						{
							ulong quotaSize = onlineAppQuotaInBytes / 2uL;
							int num3 = _compStore.CalculateDeploymentsUnderQuota(deployAppIdPtrs.Length, deployAppIdPtrs, quotaSize, ref privateSize, ref sharedSize);
							ScavengeAppsOverQuota(subs, deployAppIdPtrs.Length - num3, out var appExcluded);
							if (appExcluded)
							{
								CollectOnlineApps(out deployAppIdPtrs);
								_compStore.CalculateDeploymentsUnderQuota(deployAppIdPtrs.Length, deployAppIdPtrs, ulong.MaxValue, ref privateSize, ref sharedSize);
							}
						}
					}
					num2 = privateSize;
				}
				PersistOnlineAppQuotaUsageEstimate(num2);
			}

			public void AddOnlineAppToCommit(DefinitionAppId appId, SubscriptionState subState)
			{
				DefinitionAppId deployAppId = appId.ToDeploymentAppId();
				AddDeploymentToList(ref _onlineDeploysToPin, deployAppId);
				if (appId.Equals(subState.CurrentBind) || appId.Equals(subState.PreviousBind))
				{
					AddDeploymentToList(ref _onlineDeploysToPinAlreadyPinned, deployAppId);
				}
			}

			public void AddDeploymentToUnpin(DefinitionAppId deployAppId, SubscriptionState subState)
			{
				if (subState.IsShellVisible)
				{
					AddDeploymentToList(ref _shellVisbleDeploysToUnpin, deployAppId);
				}
				else if (subState.appType == AppType.CustomHostSpecified)
				{
					AddDeploymentToList(ref _addinDeploysToUnpin, deployAppId);
				}
				else
				{
					AddDeploymentToList(ref _onlineDeploysToUnpin, deployAppId);
				}
			}

			public void CalculateSizesPreTransact()
			{
				_onlineToPinPrivateSizePreTransact = _compStore.GetPrivateSize(_onlineDeploysToPinAlreadyPinned);
				_onlineToUnpinPrivateSize = _compStore.GetPrivateSize(_onlineDeploysToUnpin);
				_shellVisibleToUnpinSharedSize = _compStore.GetSharedSize(_shellVisbleDeploysToUnpin);
				_addinToUnpinSharedSize = _compStore.GetSharedSize(_addinDeploysToUnpin);
			}

			public void CalculateSizesPostTransact()
			{
				_onlineToPinPrivateSizePostTransact = _compStore.GetPrivateSize(_onlineDeploysToPin);
			}

			public void CleanOnlineAppCache()
			{
				SubInstance[] array = CollectOnlineApps(out var deployAppIdPtrs);
				using (StoreTransactionContext storeTxn = new StoreTransactionContext(_compStore))
				{
					SubInstance[] array2 = array;
					foreach (SubInstance subInstance in array2)
					{
						SubscriptionStateInternal subscriptionStateInternal = new SubscriptionStateInternal(subInstance.SubState);
						subscriptionStateInternal.IsInstalled = false;
						_compStore.PrepareFinalizeSubscriptionState(storeTxn, subInstance.SubState, subscriptionStateInternal);
					}
					_compStore.SubmitStoreTransaction(storeTxn, null);
				}
				array = CollectOnlineApps(out deployAppIdPtrs);
				ulong privateSize = 0uL;
				ulong sharedSize = 0uL;
				if (deployAppIdPtrs.Length != 0)
				{
					_compStore.CalculateDeploymentsUnderQuota(deployAppIdPtrs.Length, deployAppIdPtrs, ulong.MaxValue, ref privateSize, ref sharedSize);
				}
				PersistOnlineAppQuotaUsageEstimate(privateSize);
			}

			private static void AddDeploymentToList(ref ArrayList list, DefinitionAppId deployAppId)
			{
				if (list == null)
				{
					list = new ArrayList();
				}
				if (!list.Contains(deployAppId))
				{
					list.Add(deployAppId);
				}
			}

			private SubInstance[] CollectOnlineApps(out System.Deployment.Internal.Isolation.IDefinitionAppId[] deployAppIdPtrs)
			{
				Hashtable hashtable = new Hashtable();
				System.Deployment.Internal.Isolation.StoreAssemblyEnumeration storeAssemblyEnumeration = _compStore._store.EnumAssemblies(System.Deployment.Internal.Isolation.Store.EnumAssembliesFlags.Nothing);
				foreach (System.Deployment.Internal.Isolation.STORE_ASSEMBLY item in storeAssemblyEnumeration)
				{
					DefinitionIdentity definitionIdentity = new DefinitionIdentity(item.DefinitionIdentity);
					DefinitionIdentity definitionIdentity2 = definitionIdentity.ToSubscriptionId();
					SubscriptionState subscriptionState = _compStore._subStore.GetSubscriptionState(definitionIdentity2);
					if (subscriptionState.IsInstalled && !subscriptionState.IsShellVisible && subscriptionState.appType != AppType.CustomHostSpecified && !hashtable.Contains(definitionIdentity2))
					{
						SubInstance subInstance = new SubInstance();
						subInstance.SubState = subscriptionState;
						subInstance.LastAccessTime = subscriptionState.LastCheckTime;
						hashtable.Add(definitionIdentity2, subInstance);
					}
				}
				SubInstance[] array = new SubInstance[hashtable.Count];
				hashtable.Values.CopyTo(array, 0);
				ArrayList arrayList = new ArrayList();
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i].SubState.CurrentBind != null)
					{
						arrayList.Add(array[i].SubState.CurrentBind.ToDeploymentAppId().ComPointer);
					}
					if (array[i].SubState.PreviousBind != null)
					{
						arrayList.Add(array[i].SubState.PreviousBind.ToDeploymentAppId().ComPointer);
					}
				}
				deployAppIdPtrs = (System.Deployment.Internal.Isolation.IDefinitionAppId[])arrayList.ToArray(typeof(System.Deployment.Internal.Isolation.IDefinitionAppId));
				return array;
			}

			private SubInstance[] CollectOnlineAppsMRU(out System.Deployment.Internal.Isolation.IDefinitionAppId[] deployAppIdPtrs)
			{
				Hashtable hashtable = new Hashtable();
				System.Deployment.Internal.Isolation.StoreAssemblyEnumeration storeAssemblyEnumeration = _compStore._store.EnumAssemblies(System.Deployment.Internal.Isolation.Store.EnumAssembliesFlags.Nothing);
				foreach (System.Deployment.Internal.Isolation.STORE_ASSEMBLY item in storeAssemblyEnumeration)
				{
					DefinitionIdentity definitionIdentity = new DefinitionIdentity(item.DefinitionIdentity);
					DefinitionIdentity definitionIdentity2 = definitionIdentity.ToSubscriptionId();
					SubscriptionState subscriptionState = _compStore._subStore.GetSubscriptionState(definitionIdentity2);
					if (subscriptionState.IsInstalled && !subscriptionState.IsShellVisible && subscriptionState.appType != AppType.CustomHostSpecified && !hashtable.Contains(definitionIdentity2))
					{
						SubInstance subInstance = new SubInstance();
						subInstance.SubState = subscriptionState;
						subInstance.LastAccessTime = subscriptionState.LastCheckTime;
						hashtable.Add(definitionIdentity2, subInstance);
					}
				}
				SubInstance[] array = new SubInstance[hashtable.Count];
				hashtable.Values.CopyTo(array, 0);
				Array.Sort(array);
				ArrayList arrayList = new ArrayList();
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i].SubState.CurrentBind != null)
					{
						arrayList.Add(array[i].SubState.CurrentBind.ToDeploymentAppId().ComPointer);
					}
					if (array[i].SubState.PreviousBind != null)
					{
						arrayList.Add(array[i].SubState.PreviousBind.ToDeploymentAppId().ComPointer);
					}
				}
				deployAppIdPtrs = (System.Deployment.Internal.Isolation.IDefinitionAppId[])arrayList.ToArray(typeof(System.Deployment.Internal.Isolation.IDefinitionAppId));
				return array;
			}

			private void ScavengeAppsOverQuota(SubInstance[] subs, int deploysToScavenge, out bool appExcluded)
			{
				appExcluded = false;
				DateTime dateTime = DateTime.UtcNow - Constants.OnlineAppScavengingGracePeriod;
				using StoreTransactionContext storeTxn = new StoreTransactionContext(_compStore);
				int num = subs.Length - 1;
				while (num >= 0 && deploysToScavenge > 0)
				{
					bool flag = false;
					bool flag2 = false;
					if (subs[num].SubState.PreviousBind != null)
					{
						if (subs[num].LastAccessTime >= dateTime)
						{
							appExcluded = true;
						}
						else
						{
							flag = true;
						}
						deploysToScavenge--;
					}
					if (deploysToScavenge > 0)
					{
						if (subs[num].LastAccessTime >= dateTime)
						{
							appExcluded = true;
						}
						else
						{
							flag2 = true;
						}
						deploysToScavenge--;
					}
					if (flag2 || flag)
					{
						SubscriptionStateInternal subscriptionStateInternal = new SubscriptionStateInternal(subs[num].SubState);
						if (flag2)
						{
							subscriptionStateInternal.IsInstalled = false;
						}
						else
						{
							subscriptionStateInternal.PreviousBind = null;
						}
						_compStore.PrepareFinalizeSubscriptionState(storeTxn, subs[num].SubState, subscriptionStateInternal);
					}
					num--;
				}
				_compStore.SubmitStoreTransaction(storeTxn, null);
			}

			private ulong GetOnlineAppQuotaUsageEstimate()
			{
				ulong result = ulong.MaxValue;
				using RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Classes\\Software\\Microsoft\\Windows\\CurrentVersion\\Deployment");
				if (registryKey != null && registryKey.GetValue("OnlineAppQuotaUsageEstimate") is long num)
				{
					result = (ulong)((num >= 0) ? num : (-1 - -num + 1));
				}
				return result;
			}

			private static void PersistOnlineAppQuotaUsageEstimate(ulong usage)
			{
				using RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("SOFTWARE\\Classes\\Software\\Microsoft\\Windows\\CurrentVersion\\Deployment");
				registryKey?.SetValue("OnlineAppQuotaUsageEstimate", usage, RegistryValueKind.QWord);
			}
		}

		private const string DateTimeFormatString = "yyyy/MM/dd HH:mm:ss";

		private static object _installReference;

		private ComponentStoreType _storeType;

		private System.Deployment.Internal.Isolation.Store _store;

		private System.Deployment.Internal.Isolation.IStateManager _stateMgr;

		private SubscriptionStore _subStore;

		private bool _firstRefresh;

		private System.Deployment.Internal.Isolation.StoreApplicationReference InstallReference
		{
			get
			{
				if (_installReference == null)
				{
					Interlocked.CompareExchange(ref _installReference, new System.Deployment.Internal.Isolation.StoreApplicationReference(System.Deployment.Internal.Isolation.IsolationInterop.GUID_SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING, "{3f471841-eef2-47d6-89c0-d028f03a4ad5}", null), null);
				}
				return (System.Deployment.Internal.Isolation.StoreApplicationReference)_installReference;
			}
		}

		public static ComponentStore GetStore(ComponentStoreType storeType, SubscriptionStore subStore)
		{
			return new ComponentStore(storeType, subStore);
		}

		private ComponentStore(ComponentStoreType storeType, SubscriptionStore subStore)
		{
			if (storeType == ComponentStoreType.UserStore)
			{
				_storeType = storeType;
				_subStore = subStore;
				_store = System.Deployment.Internal.Isolation.IsolationInterop.GetUserStore();
				Guid riid = System.Deployment.Internal.Isolation.IsolationInterop.GetGuidOfType(typeof(System.Deployment.Internal.Isolation.IStateManager));
				_stateMgr = System.Deployment.Internal.Isolation.IsolationInterop.GetUserStateManager(0u, IntPtr.Zero, ref riid) as System.Deployment.Internal.Isolation.IStateManager;
				_firstRefresh = true;
				return;
			}
			throw new NotImplementedException();
		}

		internal ulong GetOnlineAppQuotaInBytes()
		{
			uint num = 256000u;
			using (RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Classes\\Software\\Microsoft\\Windows\\CurrentVersion\\Deployment"))
			{
				if (registryKey != null)
				{
					object value = registryKey.GetValue("OnlineAppQuotaInKB");
					if (value is int)
					{
						int num2 = (int)value;
						num = (uint)((num2 >= 0) ? num2 : (-1 - -num2 + 1));
					}
				}
			}
			return (ulong)num * 1024uL;
		}

		internal ulong GetPrivateSize(ArrayList deployAppIds)
		{
			GetPrivateAndSharedSizes(deployAppIds, out var privateSize, out var _);
			return privateSize;
		}

		internal ulong GetSharedSize(ArrayList deployAppIds)
		{
			GetPrivateAndSharedSizes(deployAppIds, out var _, out var sharedSize);
			return sharedSize;
		}

		internal ArrayList CollectCrossGroupApplications(Uri codebaseUri, DefinitionIdentity deploymentIdentity, ref bool identityGroupFound, ref bool locationGroupFound, ref string identityGroupProductName)
		{
			Hashtable hashtable = new Hashtable();
			ArrayList arrayList = new ArrayList();
			System.Deployment.Internal.Isolation.StoreAssemblyEnumeration storeAssemblyEnumeration = _store.EnumAssemblies(System.Deployment.Internal.Isolation.Store.EnumAssembliesFlags.Nothing);
			foreach (System.Deployment.Internal.Isolation.STORE_ASSEMBLY item in storeAssemblyEnumeration)
			{
				DefinitionIdentity definitionIdentity = new DefinitionIdentity(item.DefinitionIdentity);
				DefinitionIdentity definitionIdentity2 = definitionIdentity.ToSubscriptionId();
				SubscriptionState subscriptionState = _subStore.GetSubscriptionState(definitionIdentity2);
				if (!subscriptionState.IsInstalled)
				{
					continue;
				}
				bool flag = subscriptionState.DeploymentProviderUri.Equals(codebaseUri);
				bool flag2 = subscriptionState.PKTGroupId.Equals(deploymentIdentity.ToPKTGroupId());
				bool flag3 = subscriptionState.SubscriptionId.PublicKeyToken.Equals(deploymentIdentity.ToSubscriptionId().PublicKeyToken);
				if (flag && flag2 && flag3)
				{
					continue;
				}
				if (flag && flag2 && !flag3)
				{
					if (!hashtable.Contains(definitionIdentity2))
					{
						hashtable.Add(definitionIdentity2, subscriptionState);
						arrayList.Add(new CrossGroupApplicationData(subscriptionState, CrossGroupApplicationData.GroupType.LocationGroup));
						locationGroupFound = true;
					}
				}
				else if (!flag && flag2 && flag3 && !hashtable.Contains(definitionIdentity2))
				{
					hashtable.Add(definitionIdentity2, subscriptionState);
					arrayList.Add(new CrossGroupApplicationData(subscriptionState, CrossGroupApplicationData.GroupType.IdentityGroup));
					if (subscriptionState.CurrentDeploymentManifest != null && subscriptionState.CurrentDeploymentManifest.Description != null && subscriptionState.CurrentDeploymentManifest.Description.Product != null)
					{
						identityGroupProductName = subscriptionState.CurrentDeploymentManifest.Description.Product;
					}
					identityGroupFound = true;
				}
			}
			return arrayList;
		}

		internal void RemoveApplicationInstance(SubscriptionState subState, DefinitionAppId appId)
		{
			using StoreTransactionContext storeTxn = new StoreTransactionContext(this);
			PrepareRemoveDeployment(storeTxn, subState, appId);
			SubmitStoreTransaction(storeTxn, subState);
		}

		private void GetPrivateAndSharedSizes(ArrayList deployAppIds, out ulong privateSize, out ulong sharedSize)
		{
			privateSize = 0uL;
			sharedSize = 0uL;
			if (deployAppIds != null && deployAppIds.Count > 0)
			{
				System.Deployment.Internal.Isolation.IDefinitionAppId[] array = DeployAppIdsToComPtrs(deployAppIds);
				CalculateDeploymentsUnderQuota(array.Length, array, ulong.MaxValue, ref privateSize, ref sharedSize);
			}
		}

		private int CalculateDeploymentsUnderQuota(int numberOfDeployments, System.Deployment.Internal.Isolation.IDefinitionAppId[] deployAppIdPtrs, ulong quotaSize, ref ulong privateSize, ref ulong sharedSize)
		{
			uint Delimiter = 0u;
			System.Deployment.Internal.Isolation.StoreApplicationReference InstallerReference = InstallReference;
			_store.CalculateDelimiterOfDeploymentsBasedOnQuota(0u, (uint)numberOfDeployments, deployAppIdPtrs, ref InstallerReference, quotaSize, ref Delimiter, ref sharedSize, ref privateSize);
			return (int)Delimiter;
		}

		private static System.Deployment.Internal.Isolation.IDefinitionAppId[] DeployAppIdsToComPtrs(ArrayList deployAppIdList)
		{
			System.Deployment.Internal.Isolation.IDefinitionAppId[] array = new System.Deployment.Internal.Isolation.IDefinitionAppId[deployAppIdList.Count];
			for (int i = 0; i < deployAppIdList.Count; i++)
			{
				array[i] = ((DefinitionAppId)deployAppIdList[i]).ComPointer;
			}
			return array;
		}

		public void RefreshStorePointer()
		{
			if (_firstRefresh)
			{
				_firstRefresh = false;
				return;
			}
			if (_storeType == ComponentStoreType.UserStore)
			{
				Marshal.ReleaseComObject(_store.InternalStore);
				Marshal.ReleaseComObject(_stateMgr);
				_store = System.Deployment.Internal.Isolation.IsolationInterop.GetUserStore();
				Guid riid = System.Deployment.Internal.Isolation.IsolationInterop.GetGuidOfType(typeof(System.Deployment.Internal.Isolation.IStateManager));
				_stateMgr = System.Deployment.Internal.Isolation.IsolationInterop.GetUserStateManager(0u, IntPtr.Zero, ref riid) as System.Deployment.Internal.Isolation.IStateManager;
				return;
			}
			throw new NotImplementedException();
		}

		public void CleanOnlineAppCache()
		{
			using StoreTransactionContext storeTransactionContext = new StoreTransactionContext(this);
			storeTransactionContext.ScavengeContext.CleanOnlineAppCache();
		}

		public void CommitApplication(SubscriptionState subState, CommitApplicationParams commitParams)
		{
			try
			{
				using StoreTransactionContext storeTxn = new StoreTransactionContext(this);
				PrepareCommitApplication(storeTxn, subState, commitParams);
				SubmitStoreTransactionCheckQuota(storeTxn, subState);
			}
			catch (COMException ex)
			{
				if (ex.ErrorCode == -2147024784)
				{
					throw new DeploymentException(ExceptionTypes.DiskIsFull, Resources.GetString("Ex_StoreOperationFailed"), ex);
				}
				if (ex.ErrorCode == -2147023590)
				{
					throw new DeploymentException(ExceptionTypes.ComponentStore, Resources.GetString("Ex_InplaceUpdateOfApplicationAttempted"), ex);
				}
				throw;
			}
		}

		public void RemoveSubscription(SubscriptionState subState)
		{
			try
			{
				using StoreTransactionContext storeTxn = new StoreTransactionContext(this);
				PrepareRemoveSubscription(storeTxn, subState);
				SubmitStoreTransactionCheckQuota(storeTxn, subState);
			}
			catch (COMException ex)
			{
				if (ex.ErrorCode == -2147024784)
				{
					throw new DeploymentException(ExceptionTypes.DiskIsFull, Resources.GetString("Ex_StoreOperationFailed"), ex);
				}
				throw;
			}
		}

		public void RollbackSubscription(SubscriptionState subState)
		{
			try
			{
				using StoreTransactionContext storeTxn = new StoreTransactionContext(this);
				PrepareRollbackSubscription(storeTxn, subState);
				SubmitStoreTransactionCheckQuota(storeTxn, subState);
			}
			catch (COMException ex)
			{
				if (ex.ErrorCode == -2147024784)
				{
					throw new DeploymentException(ExceptionTypes.DiskIsFull, Resources.GetString("Ex_StoreOperationFailed"), ex);
				}
				throw;
			}
		}

		public void SetPendingDeployment(SubscriptionState subState, DefinitionIdentity deployId, DateTime checkTime)
		{
			try
			{
				using StoreTransactionContext storeTxn = new StoreTransactionContext(this);
				PrepareSetPendingDeployment(storeTxn, subState, deployId, checkTime);
				SubmitStoreTransaction(storeTxn, subState);
			}
			catch (COMException ex)
			{
				if (ex.ErrorCode == -2147024784)
				{
					throw new DeploymentException(ExceptionTypes.DiskIsFull, Resources.GetString("Ex_StoreOperationFailed"), ex);
				}
				throw;
			}
		}

		public void SetUpdateSkipTime(SubscriptionState subState, DefinitionIdentity updateSkippedDeployment, DateTime updateSkipTime)
		{
			try
			{
				using StoreTransactionContext storeTxn = new StoreTransactionContext(this);
				PrepareUpdateSkipTime(storeTxn, subState, updateSkippedDeployment, updateSkipTime);
				SubmitStoreTransaction(storeTxn, subState);
			}
			catch (COMException ex)
			{
				if (ex.ErrorCode == -2147024784)
				{
					throw new DeploymentException(ExceptionTypes.DiskIsFull, Resources.GetString("Ex_StoreOperationFailed"), ex);
				}
				throw;
			}
		}

		public SubscriptionStateInternal GetSubscriptionStateInternal(SubscriptionState subState)
		{
			return GetSubscriptionStateInternal(subState.SubscriptionId);
		}

		public SubscriptionStateInternal GetSubscriptionStateInternal(DefinitionIdentity subId)
		{
			SubscriptionStateInternal subscriptionStateInternal = new SubscriptionStateInternal();
			subscriptionStateInternal.IsInstalled = IsSubscriptionInstalled(subId);
			if (subscriptionStateInternal.IsInstalled)
			{
				DefinitionAppId appId = new DefinitionAppId(subId);
				subscriptionStateInternal.IsShellVisible = GetPropertyBoolean(appId, "IsShellVisible");
				subscriptionStateInternal.CurrentBind = GetPropertyDefinitionAppId(appId, "CurrentBind");
				subscriptionStateInternal.PreviousBind = GetPropertyDefinitionAppId(appId, "PreviousBind");
				subscriptionStateInternal.PendingBind = GetPropertyDefinitionAppId(appId, "PendingBind");
				subscriptionStateInternal.ExcludedDeployment = GetPropertyDefinitionIdentity(appId, "ExcludedDeployment");
				subscriptionStateInternal.PendingDeployment = GetPropertyDefinitionIdentity(appId, "PendingDeployment");
				subscriptionStateInternal.DeploymentProviderUri = GetPropertyUri(appId, "DeploymentProviderUri");
				subscriptionStateInternal.MinimumRequiredVersion = GetPropertyVersion(appId, "MinimumRequiredVersion");
				subscriptionStateInternal.LastCheckTime = GetPropertyDateTime(appId, "LastCheckTime");
				subscriptionStateInternal.UpdateSkippedDeployment = GetPropertyDefinitionIdentity(appId, "UpdateSkippedDeployment");
				subscriptionStateInternal.UpdateSkipTime = GetPropertyDateTime(appId, "UpdateSkipTime");
				subscriptionStateInternal.appType = GetPropertyAppType(appId, "AppType");
				if (subscriptionStateInternal.CurrentBind == null)
				{
					throw new InvalidDeploymentException(Resources.GetString("Ex_NoCurrentBind"));
				}
				subscriptionStateInternal.CurrentDeployment = subscriptionStateInternal.CurrentBind.DeploymentIdentity;
				subscriptionStateInternal.CurrentDeploymentManifest = GetAssemblyManifest(subscriptionStateInternal.CurrentDeployment);
				subscriptionStateInternal.CurrentDeploymentSourceUri = GetPropertyUri(subscriptionStateInternal.CurrentBind, "DeploymentSourceUri");
				subscriptionStateInternal.CurrentApplication = subscriptionStateInternal.CurrentBind.ApplicationIdentity;
				subscriptionStateInternal.CurrentApplicationManifest = GetAssemblyManifest(subscriptionStateInternal.CurrentBind.ApplicationIdentity);
				subscriptionStateInternal.CurrentApplicationSourceUri = GetPropertyUri(subscriptionStateInternal.CurrentBind, "ApplicationSourceUri");
				DefinitionIdentity definitionIdentity = ((subscriptionStateInternal.PreviousBind != null) ? subscriptionStateInternal.PreviousBind.DeploymentIdentity : null);
				subscriptionStateInternal.RollbackDeployment = ((definitionIdentity != null && (subscriptionStateInternal.MinimumRequiredVersion == null || definitionIdentity.Version >= subscriptionStateInternal.MinimumRequiredVersion)) ? definitionIdentity : null);
				if (subscriptionStateInternal.PreviousBind != null)
				{
					try
					{
						subscriptionStateInternal.PreviousApplication = subscriptionStateInternal.PreviousBind.ApplicationIdentity;
						subscriptionStateInternal.PreviousApplicationManifest = GetAssemblyManifest(subscriptionStateInternal.PreviousBind.ApplicationIdentity);
						return subscriptionStateInternal;
					}
					catch (Exception ex)
					{
						if (ExceptionUtility.IsHardException(ex))
						{
							throw;
						}
						Logger.AddInternalState("Exception thrown for GetAssemblyManifest in GetSubscriptionStateInternal: " + ex.GetType().ToString() + ":" + ex.Message);
						subscriptionStateInternal.PreviousBind = null;
						subscriptionStateInternal.RollbackDeployment = null;
						subscriptionStateInternal.PreviousApplication = null;
						subscriptionStateInternal.PreviousApplicationManifest = null;
						return subscriptionStateInternal;
					}
				}
			}
			return subscriptionStateInternal;
		}

		public void ActivateApplication(DefinitionAppId appId, string activationParameter, bool useActivationParameter)
		{
			HostType hostType = GetHostTypeFromMetadata(appId);
			uint num = 0u;
			switch (PolicyKeys.ClrHostType())
			{
			case PolicyKeys.HostType.AppLaunch:
				hostType = HostType.AppLaunch;
				break;
			case PolicyKeys.HostType.Cor:
				hostType = HostType.CorFlag;
				break;
			}
			string text = appId.ToString();
			AssemblyManifest assemblyManifest = GetAssemblyManifest(appId.DeploymentIdentity);
			Logger.AddMethodCall("ComponentStore.ActivateApplication(appId=[" + text + "] ,activationParameter=" + activationParameter + ",useActivationParameter=" + useActivationParameter + ") called.");
			uint num2 = (uint)hostType;
			Logger.AddInternalState("HostType=" + num2);
			int activationDataCount = 0;
			string[] activationData = null;
			if (activationParameter != null)
			{
				if (assemblyManifest.Deployment.TrustURLParameters || useActivationParameter)
				{
					activationDataCount = 1;
					activationData = new string[1] { activationParameter };
				}
				else
				{
					Logger.AddInternalState("Activation parameters are not passed.");
				}
			}
			num = (uint)hostType;
			if (!assemblyManifest.Deployment.Install)
			{
				num |= 0x80000100u;
			}
			try
			{
				Logger.AddInternalState("Activating application via CorLaunchApplication.");
				NativeMethods.CorLaunchApplication(num, text, 0, null, activationDataCount, activationData, new NativeMethods.PROCESS_INFORMATION());
			}
			catch (COMException ex)
			{
				int num3 = ex.ErrorCode & 0xFFFF;
				if (num3 >= 14000 && num3 <= 14999)
				{
					throw new DeploymentException(ExceptionTypes.Activation, Resources.GetString("Ex_ActivationFailureDueToSxSError"), ex);
				}
				if (ex.ErrorCode == -2147024784)
				{
					throw new DeploymentException(ExceptionTypes.DiskIsFull, Resources.GetString("Ex_StoreOperationFailed"), ex);
				}
				throw;
			}
			catch (UnauthorizedAccessException innerException)
			{
				throw new DeploymentException(ExceptionTypes.Activation, Resources.GetString("Ex_GenericActivationFailure"), innerException);
			}
		}

		public bool IsAssemblyInstalled(DefinitionIdentity asmId)
		{
			System.Deployment.Internal.Isolation.IDefinitionIdentity definitionIdentity = null;
			try
			{
				definitionIdentity = _store.GetAssemblyIdentity(0u, asmId.ComPointer);
				return true;
			}
			catch (COMException)
			{
				return false;
			}
			finally
			{
				if (definitionIdentity != null)
				{
					Marshal.ReleaseComObject(definitionIdentity);
				}
			}
		}

		public System.Deployment.Internal.Isolation.Store.IPathLock LockApplicationPath(DefinitionAppId definitionAppId)
		{
			try
			{
				return _store.LockApplicationPath(definitionAppId.ComPointer);
			}
			catch (COMException ex)
			{
				if (ex.ErrorCode == -2147024784)
				{
					throw new DeploymentException(ExceptionTypes.DiskIsFull, Resources.GetString("Ex_StoreOperationFailed"), ex);
				}
				throw;
			}
		}

		public System.Deployment.Internal.Isolation.Store.IPathLock LockAssemblyPath(DefinitionIdentity asmId)
		{
			try
			{
				return _store.LockAssemblyPath(asmId.ComPointer);
			}
			catch (COMException ex)
			{
				if (ex.ErrorCode == -2147024784)
				{
					throw new DeploymentException(ExceptionTypes.DiskIsFull, Resources.GetString("Ex_StoreOperationFailed"), ex);
				}
				throw;
			}
		}

		public bool CheckGroupInstalled(DefinitionAppId appId, string groupName)
		{
			AssemblyManifest assemblyManifest = GetAssemblyManifest(appId.ApplicationIdentity);
			return CheckGroupInstalled(appId, assemblyManifest, groupName);
		}

		public bool CheckGroupInstalled(DefinitionAppId appId, AssemblyManifest appManifest, string groupName)
		{
			System.Deployment.Internal.Isolation.Store.IPathLock pathLock = null;
			try
			{
				pathLock = LockApplicationPath(appId);
				string path = pathLock.Path;
				System.Deployment.Application.Manifest.File[] filesInGroup = appManifest.GetFilesInGroup(groupName, optionalOnly: true);
				System.Deployment.Application.Manifest.File[] array = filesInGroup;
				foreach (System.Deployment.Application.Manifest.File file in array)
				{
					string path2 = Path.Combine(path, file.NameFS);
					if (!System.IO.File.Exists(path2))
					{
						return false;
					}
				}
				DependentAssembly[] privateAssembliesInGroup = appManifest.GetPrivateAssembliesInGroup(groupName, optionalOnly: true);
				DependentAssembly[] array2 = privateAssembliesInGroup;
				foreach (DependentAssembly dependentAssembly in array2)
				{
					string path3 = Path.Combine(path, dependentAssembly.CodebaseFS);
					if (!System.IO.File.Exists(path3))
					{
						return false;
					}
				}
				if (filesInGroup.Length + privateAssembliesInGroup.Length == 0)
				{
					throw new InvalidDeploymentException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_NoSuchDownloadGroup"), new object[1] { groupName }));
				}
			}
			finally
			{
				pathLock?.Dispose();
			}
			return true;
		}

		private HostType GetHostTypeFromMetadata(DefinitionAppId defAppId)
		{
			HostType result = HostType.Default;
			try
			{
				if (GetPropertyBoolean(defAppId, "IsFullTrust"))
				{
					result = HostType.CorFlag;
					return result;
				}
				result = HostType.AppLaunch;
				return result;
			}
			catch (DeploymentException)
			{
				return result;
			}
		}

		private AssemblyManifest GetAssemblyManifest(DefinitionIdentity asmId)
		{
			return GetAssemblyManifestWithRetry(asmId, TimeSpan.FromSeconds(3.0));
		}

		private AssemblyManifest GetAssemblyManifestWithRetry(DefinitionIdentity asmId, TimeSpan retryInterval, int maxRetryCount = 3)
		{
			AssemblyManifest result = null;
			while (maxRetryCount >= 0)
			{
				try
				{
					result = GetAssemblyManifestFromStore(asmId);
					return result;
				}
				catch (Exception)
				{
					if (maxRetryCount <= 0)
					{
						throw;
					}
					Thread.Sleep(retryInterval);
				}
				maxRetryCount--;
			}
			return result;
		}

		private AssemblyManifest GetAssemblyManifestFromStore(DefinitionIdentity asmId)
		{
			System.Deployment.Internal.Isolation.Manifest.ICMS assemblyManifest = _store.GetAssemblyManifest(0u, asmId.ComPointer);
			return new AssemblyManifest(assemblyManifest);
		}

		private bool IsSubscriptionInstalled(DefinitionIdentity subId)
		{
			DefinitionAppId appId = new DefinitionAppId(subId);
			try
			{
				DefinitionAppId propertyDefinitionAppId = GetPropertyDefinitionAppId(appId, "CurrentBind");
				return propertyDefinitionAppId != null;
			}
			catch (DeploymentException)
			{
				return false;
			}
		}

		private string GetPropertyString(DefinitionAppId appId, string propName)
		{
			byte[] deploymentProperty;
			try
			{
				deploymentProperty = _store.GetDeploymentProperty(System.Deployment.Internal.Isolation.Store.GetPackagePropertyFlags.Nothing, appId.ComPointer, InstallReference, Constants.DeploymentPropertySet, propName);
			}
			catch (COMException)
			{
				return null;
			}
			int num = deploymentProperty.Length;
			if (num == 0 || deploymentProperty.Length % 2 != 0 || deploymentProperty[num - 2] != 0 || deploymentProperty[num - 1] != 0)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }));
			}
			return Encoding.Unicode.GetString(deploymentProperty, 0, num - 2);
		}

		private DefinitionIdentity GetPropertyDefinitionIdentity(DefinitionAppId appId, string propName)
		{
			try
			{
				string propertyString = GetPropertyString(appId, propName);
				return (propertyString != null && propertyString.Length > 0) ? new DefinitionIdentity(propertyString) : null;
			}
			catch (COMException innerException)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException);
			}
			catch (SEHException innerException2)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException2);
			}
		}

		private DefinitionAppId GetPropertyDefinitionAppId(DefinitionAppId appId, string propName)
		{
			try
			{
				string propertyString = GetPropertyString(appId, propName);
				return (propertyString != null && propertyString.Length > 0) ? new DefinitionAppId(propertyString) : null;
			}
			catch (COMException innerException)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException);
			}
			catch (SEHException innerException2)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException2);
			}
		}

		private bool GetPropertyBoolean(DefinitionAppId appId, string propName)
		{
			try
			{
				string propertyString = GetPropertyString(appId, propName);
				return propertyString != null && propertyString.Length > 0 && Convert.ToBoolean(propertyString, CultureInfo.InvariantCulture);
			}
			catch (FormatException innerException)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException);
			}
		}

		private Uri GetPropertyUri(DefinitionAppId appId, string propName)
		{
			try
			{
				string propertyString = GetPropertyString(appId, propName);
				return (propertyString != null && propertyString.Length > 0) ? new Uri(propertyString) : null;
			}
			catch (UriFormatException innerException)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException);
			}
		}

		private Version GetPropertyVersion(DefinitionAppId appId, string propName)
		{
			try
			{
				string propertyString = GetPropertyString(appId, propName);
				return (propertyString != null && propertyString.Length > 0) ? new Version(propertyString) : null;
			}
			catch (ArgumentException innerException)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException);
			}
			catch (FormatException innerException2)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException2);
			}
		}

		private DateTime GetPropertyDateTime(DefinitionAppId appId, string propName)
		{
			try
			{
				string propertyString = GetPropertyString(appId, propName);
				return (propertyString != null && propertyString.Length > 0) ? DateTime.ParseExact(propertyString, "yyyy/MM/dd HH:mm:ss", DateTimeFormatInfo.InvariantInfo) : DateTime.MinValue;
			}
			catch (FormatException innerException)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException);
			}
		}

		private AppType GetPropertyAppType(DefinitionAppId appId, string propName)
		{
			string text = null;
			try
			{
				text = GetPropertyString(appId, propName);
				if (text == null)
				{
					return AppType.None;
				}
				return Convert.ToUInt16(text, CultureInfo.InvariantCulture) switch
				{
					0 => AppType.None, 
					1 => AppType.Installed, 
					2 => AppType.Online, 
					3 => AppType.CustomHostSpecified, 
					4 => AppType.CustomUX, 
					_ => AppType.None, 
				};
			}
			catch (DeploymentException)
			{
				return AppType.None;
			}
			catch (FormatException innerException)
			{
				Logger.AddInternalState("Unable to convert store property," + propName + ", from string to UInt16." + propName + "=" + text);
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException);
			}
			catch (OverflowException innerException2)
			{
				Logger.AddInternalState("Unable to convert store property," + propName + ", from string to UInt16." + propName + "=" + text);
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidStoreMetaData"), new object[1] { propName }), innerException2);
			}
		}

		private void PrepareCommitApplication(StoreTransactionContext storeTxn, SubscriptionState subState, CommitApplicationParams commitParams)
		{
			DefinitionAppId appId = commitParams.AppId;
			SubscriptionStateInternal subscriptionStateInternal = null;
			if (commitParams.CommitDeploy)
			{
				subscriptionStateInternal = PrepareCommitDeploymentState(storeTxn, subState, commitParams);
				if ((commitParams.IsConfirmed && appId.Equals(subscriptionStateInternal.CurrentBind)) || (!commitParams.IsConfirmed && appId.Equals(subscriptionStateInternal.PendingBind)))
				{
					PrepareStageDeploymentComponent(storeTxn, subState, commitParams);
				}
			}
			if (commitParams.CommitApp)
			{
				PrepareStageAppComponent(storeTxn, commitParams);
				if (!commitParams.DeployManifest.Deployment.Install && commitParams.appType != AppType.CustomHostSpecified)
				{
					storeTxn.ScavengeContext.AddOnlineAppToCommit(appId, subState);
				}
			}
			if (commitParams.CommitDeploy)
			{
				PrepareSetSubscriptionState(storeTxn, subState, subscriptionStateInternal);
			}
		}

		private SubscriptionStateInternal PrepareCommitDeploymentState(StoreTransactionContext storeTxn, SubscriptionState subState, CommitApplicationParams commitParams)
		{
			DefinitionAppId appId = commitParams.AppId;
			AssemblyManifest deployManifest = commitParams.DeployManifest;
			SubscriptionStateInternal subscriptionStateInternal = new SubscriptionStateInternal(subState);
			if (commitParams.IsConfirmed)
			{
				subscriptionStateInternal.IsInstalled = true;
				subscriptionStateInternal.IsShellVisible = deployManifest.Deployment.Install;
				subscriptionStateInternal.DeploymentProviderUri = ((deployManifest.Deployment.ProviderCodebaseUri != null) ? deployManifest.Deployment.ProviderCodebaseUri : commitParams.DeploySourceUri);
				if (deployManifest.Deployment.MinimumRequiredVersion != null)
				{
					subscriptionStateInternal.MinimumRequiredVersion = deployManifest.Deployment.MinimumRequiredVersion;
				}
				if (!appId.Equals(subState.CurrentBind))
				{
					subscriptionStateInternal.CurrentBind = appId;
					subscriptionStateInternal.PreviousBind = ((subscriptionStateInternal.IsShellVisible && !subState.IsShellVisible) ? null : subState.CurrentBind);
				}
				subscriptionStateInternal.PendingBind = null;
				subscriptionStateInternal.PendingDeployment = null;
				subscriptionStateInternal.ExcludedDeployment = null;
				subscriptionStateInternal.appType = commitParams.appType;
				ResetUpdateSkippedState(subscriptionStateInternal);
			}
			else
			{
				subscriptionStateInternal.PendingBind = appId;
				subscriptionStateInternal.PendingDeployment = appId.DeploymentIdentity;
				if (!subscriptionStateInternal.PendingDeployment.Equals(subState.UpdateSkippedDeployment))
				{
					ResetUpdateSkippedState(subscriptionStateInternal);
				}
			}
			subscriptionStateInternal.LastCheckTime = commitParams.TimeStamp;
			FinalizeSubscriptionState(subscriptionStateInternal);
			return subscriptionStateInternal;
		}

		private void PrepareStageDeploymentComponent(StoreTransactionContext storeTxn, SubscriptionState subState, CommitApplicationParams commitParams)
		{
			DefinitionAppId definitionAppId = commitParams.AppId.ToDeploymentAppId();
			string deployManifestPath = commitParams.DeployManifestPath;
			storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationStageComponent(definitionAppId.ComPointer, deployManifestPath));
			PrepareSetDeploymentProperties(storeTxn, commitParams.AppId, commitParams);
		}

		private void PrepareSetDeploymentProperties(StoreTransactionContext storeTxn, DefinitionAppId appId, CommitApplicationParams commitParams)
		{
			string value = null;
			string value2 = null;
			string value3 = null;
			if (commitParams != null)
			{
				value = ToPropertyString(commitParams.DeploySourceUri);
				value2 = ToPropertyString(commitParams.AppSourceUri);
				if (commitParams.Trust != null)
				{
					if (commitParams.appType != AppType.CustomHostSpecified)
					{
						value3 = ToPropertyString(commitParams.Trust.DefaultGrantSet.PermissionSet.IsUnrestricted());
					}
				}
				else if (commitParams.IsUpdateInPKTGroup && commitParams.IsFullTrustRequested)
				{
					value3 = ToPropertyString(commitParams.IsFullTrustRequested);
				}
			}
			System.Deployment.Internal.Isolation.StoreOperationMetadataProperty[] setProperties = new System.Deployment.Internal.Isolation.StoreOperationMetadataProperty[3]
			{
				new System.Deployment.Internal.Isolation.StoreOperationMetadataProperty(Constants.DeploymentPropertySet, "DeploymentSourceUri", value),
				new System.Deployment.Internal.Isolation.StoreOperationMetadataProperty(Constants.DeploymentPropertySet, "ApplicationSourceUri", value2),
				new System.Deployment.Internal.Isolation.StoreOperationMetadataProperty(Constants.DeploymentPropertySet, "IsFullTrust", value3)
			};
			storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationSetDeploymentMetadata(appId.ComPointer, InstallReference, setProperties));
		}

		private void PrepareStageAppComponent(StoreTransactionContext storeTxn, CommitApplicationParams commitParams)
		{
			DefinitionAppId appId = commitParams.AppId;
			AssemblyManifest appManifest = commitParams.AppManifest;
			string appManifestPath = commitParams.AppManifestPath;
			string appPayloadPath = commitParams.AppPayloadPath;
			string appGroup = commitParams.AppGroup;
			if (appGroup == null)
			{
				if (appManifestPath == null)
				{
					throw new ArgumentNullException("commitParams");
				}
				storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationStageComponent(appId.ComPointer, appManifestPath));
			}
			System.Deployment.Application.Manifest.File[] filesInGroup = appManifest.GetFilesInGroup(appGroup, optionalOnly: true);
			System.Deployment.Application.Manifest.File[] array = filesInGroup;
			foreach (System.Deployment.Application.Manifest.File file in array)
			{
				PrepareInstallFile(storeTxn, file, appId, null, appPayloadPath);
			}
			DependentAssembly[] privateAssembliesInGroup = appManifest.GetPrivateAssembliesInGroup(appGroup, optionalOnly: true);
			DependentAssembly[] array2 = privateAssembliesInGroup;
			foreach (DependentAssembly privAsm in array2)
			{
				PrepareInstallPrivateAssembly(storeTxn, privAsm, appId, appPayloadPath);
			}
		}

		private void PrepareInstallFile(StoreTransactionContext storeTxn, System.Deployment.Application.Manifest.File file, DefinitionAppId appId, DefinitionIdentity asmId, string asmPayloadPath)
		{
			string srcFile = Path.Combine(asmPayloadPath, file.NameFS);
			string name = file.Name;
			storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationStageComponentFile(appId.ComPointer, asmId?.ComPointer, name, srcFile));
		}

		private void PrepareInstallPrivateAssembly(StoreTransactionContext storeTxn, DependentAssembly privAsm, DefinitionAppId appId, string appPayloadPath)
		{
			string codebaseFS = privAsm.CodebaseFS;
			string text = Path.Combine(appPayloadPath, codebaseFS);
			string directoryName = Path.GetDirectoryName(text);
			AssemblyManifest assemblyManifest = new AssemblyManifest(text);
			DefinitionIdentity definitionIdentity = assemblyManifest.Identity;
			string text2 = assemblyManifest.RawXmlFilePath;
			if (text2 == null)
			{
				text2 = text + ".genman";
				definitionIdentity = ManifestGenerator.GenerateManifest(privAsm.Identity, assemblyManifest, text2);
			}
			storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationStageComponent(appId.ComPointer, definitionIdentity.ComPointer, text2));
			System.Deployment.Application.Manifest.File[] files = assemblyManifest.Files;
			foreach (System.Deployment.Application.Manifest.File file in files)
			{
				PrepareInstallFile(storeTxn, file, appId, definitionIdentity, directoryName);
			}
		}

		private void PrepareRemoveSubscription(StoreTransactionContext storeTxn, SubscriptionState subState)
		{
			SubscriptionStateInternal subscriptionStateInternal = new SubscriptionStateInternal(subState);
			subscriptionStateInternal.IsInstalled = false;
			PrepareFinalizeSubscriptionState(storeTxn, subState, subscriptionStateInternal);
		}

		private void PrepareRollbackSubscription(StoreTransactionContext storeTxn, SubscriptionState subState)
		{
			SubscriptionStateInternal subscriptionStateInternal = new SubscriptionStateInternal(subState);
			subscriptionStateInternal.ExcludedDeployment = subState.CurrentBind.DeploymentIdentity;
			subscriptionStateInternal.CurrentBind = subState.PreviousBind;
			subscriptionStateInternal.PreviousBind = null;
			PrepareFinalizeSubscriptionState(storeTxn, subState, subscriptionStateInternal);
		}

		private void PrepareSetPendingDeployment(StoreTransactionContext storeTxn, SubscriptionState subState, DefinitionIdentity deployId, DateTime checkTime)
		{
			SubscriptionStateInternal subscriptionStateInternal = new SubscriptionStateInternal(subState);
			subscriptionStateInternal.PendingDeployment = deployId;
			subscriptionStateInternal.LastCheckTime = checkTime;
			if (subscriptionStateInternal.PendingDeployment != null && !subscriptionStateInternal.PendingDeployment.Equals(subState.UpdateSkippedDeployment))
			{
				ResetUpdateSkippedState(subscriptionStateInternal);
			}
			PrepareFinalizeSubscriptionState(storeTxn, subState, subscriptionStateInternal);
		}

		private void PrepareUpdateSkipTime(StoreTransactionContext storeTxn, SubscriptionState subState, DefinitionIdentity updateSkippedDeployment, DateTime updateSkipTime)
		{
			SubscriptionStateInternal subscriptionStateInternal = new SubscriptionStateInternal(subState);
			subscriptionStateInternal.UpdateSkippedDeployment = updateSkippedDeployment;
			subscriptionStateInternal.UpdateSkipTime = updateSkipTime;
			PrepareFinalizeSubscriptionState(storeTxn, subState, subscriptionStateInternal);
		}

		private void PrepareFinalizeSubscriptionState(StoreTransactionContext storeTxn, SubscriptionState subState, SubscriptionStateInternal newState)
		{
			FinalizeSubscriptionState(newState);
			PrepareSetSubscriptionState(storeTxn, subState, newState);
		}

		private void PrepareSetSubscriptionState(StoreTransactionContext storeTxn, SubscriptionState subState, SubscriptionStateInternal newState)
		{
			PrepareFinalizeSubscription(storeTxn, subState, newState);
			PrepareSetSubscriptionProperties(storeTxn, subState, newState);
			PrepareRemoveOrphanedDeployments(storeTxn, subState, newState);
		}

		private static void FinalizeSubscriptionState(SubscriptionStateInternal newState)
		{
			if (!newState.IsInstalled)
			{
				newState.Reset();
				return;
			}
			DefinitionAppId currentBind = newState.CurrentBind;
			DefinitionIdentity deploymentIdentity = currentBind.DeploymentIdentity;
			DefinitionAppId definitionAppId = newState.PreviousBind;
			if (definitionAppId != null && definitionAppId.Equals(currentBind))
			{
				definitionAppId = (newState.PreviousBind = null);
			}
			DefinitionIdentity obj = definitionAppId?.DeploymentIdentity;
			DefinitionIdentity definitionIdentity = newState.ExcludedDeployment;
			if (definitionIdentity != null && (definitionIdentity.Equals(deploymentIdentity) || definitionIdentity.Equals(obj)))
			{
				definitionIdentity = (newState.ExcludedDeployment = null);
			}
			DefinitionIdentity definitionIdentity2 = newState.PendingDeployment;
			if (definitionIdentity2 != null && (definitionIdentity2.Equals(deploymentIdentity) || definitionIdentity2.Equals(definitionIdentity)))
			{
				definitionIdentity2 = (newState.PendingDeployment = null);
			}
			DefinitionAppId pendingBind = newState.PendingBind;
			if (pendingBind != null && (!pendingBind.DeploymentIdentity.Equals(definitionIdentity2) || pendingBind.Equals(definitionAppId)))
			{
				pendingBind = (newState.PendingBind = null);
			}
		}

		private static void ResetUpdateSkippedState(SubscriptionStateInternal newState)
		{
			newState.UpdateSkippedDeployment = null;
			newState.UpdateSkipTime = DateTime.MinValue;
		}

		private void PrepareSetSubscriptionProperties(StoreTransactionContext storeTxn, SubscriptionState subState, SubscriptionStateInternal newState)
		{
			Logger.AddInternalState("Changing Subscription Properties:");
			Logger.AddInternalState("Old subscription state = " + subState.ToString());
			Logger.AddInternalState("New subscription state = " + newState.ToString());
			SubscriptionStateVariable[] array = new SubscriptionStateVariable[12]
			{
				new SubscriptionStateVariable("IsShellVisible", newState.IsShellVisible, subState.IsShellVisible),
				new SubscriptionStateVariable("PreviousBind", newState.PreviousBind, subState.PreviousBind),
				new SubscriptionStateVariable("PendingBind", newState.PendingBind, subState.PendingBind),
				new SubscriptionStateVariable("ExcludedDeployment", newState.ExcludedDeployment, subState.ExcludedDeployment),
				new SubscriptionStateVariable("PendingDeployment", newState.PendingDeployment, subState.PendingDeployment),
				new SubscriptionStateVariable("DeploymentProviderUri", newState.DeploymentProviderUri, subState.DeploymentProviderUri),
				new SubscriptionStateVariable("MinimumRequiredVersion", newState.MinimumRequiredVersion, subState.MinimumRequiredVersion),
				new SubscriptionStateVariable("LastCheckTime", newState.LastCheckTime, subState.LastCheckTime),
				new SubscriptionStateVariable("UpdateSkippedDeployment", newState.UpdateSkippedDeployment, subState.UpdateSkippedDeployment),
				new SubscriptionStateVariable("UpdateSkipTime", newState.UpdateSkipTime, subState.UpdateSkipTime),
				new SubscriptionStateVariable("AppType", (ushort)newState.appType, (ushort)subState.appType),
				new SubscriptionStateVariable("CurrentBind", newState.CurrentBind, subState.CurrentBind)
			};
			ArrayList arrayList = new ArrayList();
			SubscriptionStateVariable[] array2 = array;
			foreach (SubscriptionStateVariable subscriptionStateVariable in array2)
			{
				if (!subState.IsInstalled || !subscriptionStateVariable.IsUnchanged || !newState.IsInstalled)
				{
					arrayList.Add(new System.Deployment.Internal.Isolation.StoreOperationMetadataProperty(Constants.DeploymentPropertySet, subscriptionStateVariable.PropertyName, newState.IsInstalled ? ToPropertyString(subscriptionStateVariable.NewValue) : null));
				}
			}
			if (arrayList.Count > 0)
			{
				System.Deployment.Internal.Isolation.StoreOperationMetadataProperty[] setProperties = (System.Deployment.Internal.Isolation.StoreOperationMetadataProperty[])arrayList.ToArray(typeof(System.Deployment.Internal.Isolation.StoreOperationMetadataProperty));
				DefinitionAppId definitionAppId = new DefinitionAppId(subState.SubscriptionId);
				storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationSetDeploymentMetadata(definitionAppId.ComPointer, InstallReference, setProperties));
			}
		}

		private void PrepareRemoveOrphanedDeployments(StoreTransactionContext storeTxn, SubscriptionState subState, SubscriptionStateInternal newState)
		{
			ArrayList arrayList = new ArrayList();
			arrayList.Add(subState.CurrentBind);
			arrayList.Add(subState.PreviousBind);
			arrayList.Add(subState.PendingBind);
			arrayList.Remove(newState.CurrentBind);
			arrayList.Remove(newState.PreviousBind);
			arrayList.Remove(newState.PendingBind);
			foreach (DefinitionAppId item in arrayList)
			{
				if (item != null)
				{
					PrepareRemoveDeployment(storeTxn, subState, item);
				}
			}
		}

		private void PrepareRemoveDeployment(StoreTransactionContext storeTxn, SubscriptionState subState, DefinitionAppId appId)
		{
			DefinitionAppId deployAppId = appId.ToDeploymentAppId();
			if (subState.IsShellVisible)
			{
				PrepareInstallUninstallDeployment(storeTxn, deployAppId, isInstall: false);
			}
			else
			{
				PreparePinUnpinDeployment(storeTxn, deployAppId, isPin: false);
			}
			PrepareSetDeploymentProperties(storeTxn, appId, null);
			storeTxn.ScavengeContext.AddDeploymentToUnpin(deployAppId, subState);
			ApplicationTrust.RemoveCachedTrust(appId);
		}

		private void PrepareFinalizeSubscription(StoreTransactionContext storeTxn, SubscriptionState subState, SubscriptionStateInternal newState)
		{
			if (newState.IsInstalled && (!subState.IsInstalled || newState.IsShellVisible != subState.IsShellVisible || !newState.CurrentBind.Equals(subState.CurrentBind)))
			{
				DefinitionAppId deployAppId = newState.CurrentBind.ToDeploymentAppId();
				if (newState.IsShellVisible)
				{
					PrepareInstallUninstallDeployment(storeTxn, deployAppId, isInstall: true);
				}
				else
				{
					PreparePinUnpinDeployment(storeTxn, deployAppId, isPin: true);
				}
			}
		}

		private void PreparePinUnpinDeployment(StoreTransactionContext storeTxn, DefinitionAppId deployAppId, bool isPin)
		{
			if (isPin)
			{
				storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationPinDeployment(deployAppId.ComPointer, InstallReference));
			}
			else
			{
				storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationUnpinDeployment(deployAppId.ComPointer, InstallReference));
			}
		}

		private void PrepareInstallUninstallDeployment(StoreTransactionContext storeTxn, DefinitionAppId deployAppId, bool isInstall)
		{
			if (isInstall)
			{
				storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationInstallDeployment(deployAppId.ComPointer, InstallReference));
			}
			else
			{
				storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationUninstallDeployment(deployAppId.ComPointer, InstallReference));
			}
		}

		private void SubmitStoreTransaction(StoreTransactionContext storeTxn, SubscriptionState subState)
		{
			CodeMarker_Singleton.Instance.CodeMarker(8080);
			storeTxn.Add(new System.Deployment.Internal.Isolation.StoreOperationScavenge(Light: false));
			System.Deployment.Internal.Isolation.StoreTransactionOperation[] operations = storeTxn.Operations;
			if (operations.Length == 0)
			{
				return;
			}
			uint[] rgDispositions = new uint[operations.Length];
			int[] rgResults = new int[operations.Length];
			try
			{
				_store.Transact(operations, rgDispositions, rgResults);
				_stateMgr.Scavenge(0u, out var _);
			}
			catch (DirectoryNotFoundException innerException)
			{
				throw new DeploymentException(ExceptionTypes.ComponentStore, Resources.GetString("Ex_TransactDirectoryNotFoundException"), innerException);
			}
			catch (ArgumentException innerException2)
			{
				throw new DeploymentException(ExceptionTypes.ComponentStore, Resources.GetString("Ex_StoreOperationFailed"), innerException2);
			}
			catch (UnauthorizedAccessException innerException3)
			{
				throw new DeploymentException(ExceptionTypes.ComponentStore, Resources.GetString("Ex_StoreOperationFailed"), innerException3);
			}
			catch (IOException innerException4)
			{
				throw new DeploymentException(ExceptionTypes.ComponentStore, Resources.GetString("Ex_StoreOperationFailed"), innerException4);
			}
			finally
			{
				CodeMarker_Singleton.Instance.CodeMarker(8081);
				Logger.AddTransactionInformation(operations, rgDispositions, rgResults);
			}
			subState?.Invalidate();
		}

		private void SubmitStoreTransactionCheckQuota(StoreTransactionContext storeTxn, SubscriptionState subState)
		{
			storeTxn.ScavengeContext.CalculateSizesPreTransact();
			SubmitStoreTransaction(storeTxn, subState);
			storeTxn.ScavengeContext.CalculateSizesPostTransact();
			storeTxn.ScavengeContext.CheckQuotaAndScavenge();
		}

		private static string ToPropertyString(object propValue)
		{
			if (propValue == null)
			{
				return string.Empty;
			}
			if (propValue is bool flag)
			{
				return flag.ToString(CultureInfo.InvariantCulture);
			}
			if (propValue is DateTime dateTime)
			{
				return dateTime.ToString("yyyy/MM/dd HH:mm:ss", DateTimeFormatInfo.InvariantInfo);
			}
			if (propValue is Uri)
			{
				return ((Uri)propValue).AbsoluteUri;
			}
			return propValue.ToString();
		}
	}
	internal class SubscriptionStateInternal
	{
		public bool IsInstalled;

		public bool IsShellVisible;

		public DefinitionAppId CurrentBind;

		public DefinitionAppId PreviousBind;

		public DefinitionAppId PendingBind;

		public DefinitionIdentity PendingDeployment;

		public DefinitionIdentity ExcludedDeployment;

		public Uri DeploymentProviderUri;

		public Version MinimumRequiredVersion;

		public DateTime LastCheckTime;

		public DateTime UpdateSkipTime;

		public DefinitionIdentity UpdateSkippedDeployment;

		public AppType appType;

		public DefinitionIdentity CurrentDeployment;

		public DefinitionIdentity RollbackDeployment;

		public AssemblyManifest CurrentDeploymentManifest;

		public Uri CurrentDeploymentSourceUri;

		public DefinitionIdentity CurrentApplication;

		public AssemblyManifest CurrentApplicationManifest;

		public Uri CurrentApplicationSourceUri;

		public DefinitionIdentity PreviousApplication;

		public AssemblyManifest PreviousApplicationManifest;

		public SubscriptionStateInternal()
		{
			Reset();
		}

		public SubscriptionStateInternal(SubscriptionState subState)
		{
			IsInstalled = subState.IsInstalled;
			IsShellVisible = subState.IsShellVisible;
			CurrentBind = subState.CurrentBind;
			PreviousBind = subState.PreviousBind;
			PendingBind = subState.PreviousBind;
			PendingDeployment = subState.PendingDeployment;
			ExcludedDeployment = subState.ExcludedDeployment;
			DeploymentProviderUri = subState.DeploymentProviderUri;
			MinimumRequiredVersion = subState.MinimumRequiredVersion;
			LastCheckTime = subState.LastCheckTime;
			UpdateSkippedDeployment = subState.UpdateSkippedDeployment;
			UpdateSkipTime = subState.UpdateSkipTime;
			appType = subState.appType;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("IsInstalled=" + IsInstalled + "\r\n");
			stringBuilder.Append("IsShellVisible=" + IsShellVisible + "\r\n");
			stringBuilder.Append("CurrentBind=" + ((CurrentBind != null) ? CurrentBind.ToString() : "null") + "\r\n");
			stringBuilder.Append("PreviousBind=" + ((PreviousBind != null) ? PreviousBind.ToString() : "null") + "\r\n");
			stringBuilder.Append("PendingBind=" + ((PendingBind != null) ? PendingBind.ToString() : "null") + "\r\n");
			stringBuilder.Append("PendingDeployment=" + ((PendingDeployment != null) ? PendingDeployment.ToString() : "null") + "\r\n");
			stringBuilder.Append("ExcludedDeployment=" + ((ExcludedDeployment != null) ? ExcludedDeployment.ToString() : "null") + "\r\n");
			stringBuilder.Append("DeploymentProviderUri=" + ((DeploymentProviderUri != null) ? DeploymentProviderUri.ToString() : "null") + "\r\n");
			stringBuilder.Append("MinimumRequiredVersion=" + ((MinimumRequiredVersion != null) ? MinimumRequiredVersion.ToString() : "null") + "\r\n");
			_ = LastCheckTime;
			stringBuilder.Append("LastCheckTime=" + LastCheckTime.ToString() + "\r\n");
			_ = UpdateSkipTime;
			stringBuilder.Append("UpdateSkipTime=" + UpdateSkipTime.ToString() + "\r\n");
			stringBuilder.Append("UpdateSkippedDeployment=" + ((UpdateSkippedDeployment != null) ? UpdateSkippedDeployment.ToString() : "null") + "\r\n");
			stringBuilder.Append("appType=" + (ushort)appType + "\r\n");
			return stringBuilder.ToString();
		}

		public void Reset()
		{
			IsInstalled = (IsShellVisible = false);
			CurrentBind = (PreviousBind = (PendingBind = null));
			ExcludedDeployment = (PendingDeployment = null);
			DeploymentProviderUri = null;
			MinimumRequiredVersion = null;
			LastCheckTime = DateTime.MinValue;
			UpdateSkippedDeployment = null;
			UpdateSkipTime = DateTime.MinValue;
			CurrentDeployment = null;
			RollbackDeployment = null;
			CurrentDeploymentManifest = null;
			CurrentDeploymentSourceUri = null;
			CurrentApplication = null;
			CurrentApplicationManifest = null;
			CurrentApplicationSourceUri = null;
			PreviousApplication = null;
			PreviousApplicationManifest = null;
			appType = AppType.None;
		}
	}
	internal class SubscriptionStateVariable
	{
		public string PropertyName;

		public object NewValue;

		public object OldValue;

		public bool IsUnchanged
		{
			get
			{
				if (NewValue == null)
				{
					return OldValue == null;
				}
				return NewValue.Equals(OldValue);
			}
		}

		public SubscriptionStateVariable(string name, object newValue, object oldValue)
		{
			PropertyName = name;
			NewValue = newValue;
			OldValue = oldValue;
		}
	}
	internal enum ComponentStoreType
	{
		UserStore,
		SystemStore
	}
	internal class Hash
	{
		private byte[] _digestValue;

		private System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD _digestMethod;

		private System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM _transform;

		public byte[] DigestValue => _digestValue;

		public System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD DigestMethod => _digestMethod;

		public System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM Transform => _transform;

		public string CompositString => DigestMethodCodeString + TranformCodeString + HexString.FromBytes(DigestValue);

		protected string TranformCodeString => ToCodedString((uint)Transform);

		protected string DigestMethodCodeString => ToCodedString((uint)DigestMethod);

		public Hash(byte[] digestValue, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD digestMethod, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM transform)
		{
			if (digestValue == null)
			{
				throw new ArgumentException(Resources.GetString("Ex_HashNullDigestValue"));
			}
			_digestValue = digestValue;
			_digestMethod = digestMethod;
			_transform = transform;
		}

		protected static string ToCodedString(uint value)
		{
			if (value > 255)
			{
				throw new ArgumentException(Resources.GetString("Ex_CodeLimitExceeded"));
			}
			return string.Format(CultureInfo.InvariantCulture, "{0:x2}", new object[1] { value });
		}
	}
	internal class HashCollection : IEnumerable
	{
		public class HashEnumerator : IEnumerator
		{
			private int _index;

			private HashCollection _hashCollection;

			public Hash Current => (Hash)_hashCollection._hashes[_index];

			object IEnumerator.Current => _hashCollection._hashes[_index];

			public HashEnumerator(HashCollection hashCollection)
			{
				_hashCollection = hashCollection;
				_index = -1;
			}

			public void Reset()
			{
				_index = -1;
			}

			public bool MoveNext()
			{
				_index++;
				return _index < _hashCollection._hashes.Count;
			}
		}

		protected ArrayList _hashes = new ArrayList();

		public int Count => _hashes.Count;

		public void AddHash(byte[] digestValue, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD digestMethod, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM transform)
		{
			Hash value = new Hash(digestValue, digestMethod, transform);
			_hashes.Add(value);
		}

		public HashEnumerator GetEnumerator()
		{
			return new HashEnumerator(this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal class ComponentVerifier
	{
		protected abstract class VerificationComponent
		{
			public abstract void Verify();
		}

		protected class FileComponent : VerificationComponent
		{
			protected string _filePath;

			protected HashCollection _hashCollection;

			public FileComponent(string filePath, HashCollection hashCollection)
			{
				_filePath = filePath;
				_hashCollection = hashCollection;
			}

			public override void Verify()
			{
				VerifyFileHash(_filePath, _hashCollection);
			}
		}

		protected class SimplyNamedAssemblyComponent : VerificationComponent
		{
			protected string _filePath;

			protected AssemblyManifest _assemblyManifest;

			public SimplyNamedAssemblyComponent(string filePath, AssemblyManifest assemblyManifest)
			{
				_filePath = filePath;
				_assemblyManifest = assemblyManifest;
			}

			public override void Verify()
			{
				VerifySimplyNamedAssembly(_filePath, _assemblyManifest);
			}
		}

		protected class StrongNameAssemblyComponent : VerificationComponent
		{
			protected string _filePath;

			protected AssemblyManifest _assemblyManifest;

			public StrongNameAssemblyComponent(string filePath, AssemblyManifest assemblyManifest)
			{
				_filePath = filePath;
				_assemblyManifest = assemblyManifest;
			}

			public override void Verify()
			{
				VerifyStrongNameAssembly(_filePath, _assemblyManifest);
			}
		}

		protected ArrayList _verificationComponents = new ArrayList();

		protected static System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD[] _supportedDigestMethods = new System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD[4]
		{
			System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA1,
			System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA256,
			System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA384,
			System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA512
		};

		protected static System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM[] _supportedTransforms = new System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM[2]
		{
			System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM.CMS_HASH_TRANSFORM_MANIFESTINVARIANT,
			System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM.CMS_HASH_TRANSFORM_IDENTITY
		};

		public static System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM[] VerifiableTransformTypes => _supportedTransforms;

		public static System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD[] VerifiableDigestMethods => _supportedDigestMethods;

		public void AddFileForVerification(string filePath, HashCollection verificationHashCollection)
		{
			FileComponent value = new FileComponent(filePath, verificationHashCollection);
			_verificationComponents.Add(value);
		}

		public void AddSimplyNamedAssemblyForVerification(string filePath, AssemblyManifest assemblyManifest)
		{
			SimplyNamedAssemblyComponent value = new SimplyNamedAssemblyComponent(filePath, assemblyManifest);
			_verificationComponents.Add(value);
		}

		public void AddStrongNameAssemblyForVerification(string filePath, AssemblyManifest assemblyManifest)
		{
			StrongNameAssemblyComponent value = new StrongNameAssemblyComponent(filePath, assemblyManifest);
			_verificationComponents.Add(value);
		}

		public void VerifyComponents()
		{
			foreach (VerificationComponent verificationComponent in _verificationComponents)
			{
				verificationComponent.Verify();
			}
		}

		public static void VerifyFileHash(string filePath, HashCollection hashCollection)
		{
			string fileName = Path.GetFileName(filePath);
			if (hashCollection.Count == 0)
			{
				if (PolicyKeys.RequireHashInManifests())
				{
					throw new InvalidDeploymentException(ExceptionTypes.HashValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_HashNotSpecified"), new object[1] { fileName }));
				}
				Logger.AddWarningInformation(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("NoHashFile"), new object[1] { fileName }));
			}
			foreach (Hash item in hashCollection)
			{
				VerifyFileHash(filePath, item);
			}
		}

		public static void VerifyFileHash(string filePath, Hash hash)
		{
			string fileName = Path.GetFileName(filePath);
			byte[] array;
			try
			{
				array = GenerateDigestValue(filePath, hash.DigestMethod, hash.Transform);
			}
			catch (IOException innerException)
			{
				throw new InvalidDeploymentException(ExceptionTypes.HashValidation, Resources.GetString("Ex_HashValidationException"), innerException);
			}
			byte[] digestValue = hash.DigestValue;
			bool flag = false;
			if (array.Length == digestValue.Length)
			{
				int i;
				for (i = 0; i < digestValue.Length && digestValue[i] == array[i]; i++)
				{
				}
				if (i >= digestValue.Length)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				Logger.AddInternalState("File," + fileName + ", has a different computed hash than specified in manifest. Computed hash is " + Encoding.UTF8.GetString(array) + ". Specified hash is " + Encoding.UTF8.GetString(digestValue));
				throw new InvalidDeploymentException(ExceptionTypes.HashValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DifferentHashes"), new object[1] { fileName }));
			}
		}

		public static byte[] GenerateDigestValue(string filePath, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD digestMethod, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM transform)
		{
			Stream stream = null;
			byte[] array = null;
			try
			{
				HashAlgorithm hashAlgorithm = GetHashAlgorithm(digestMethod);
				stream = GetTransformedStream(filePath, transform);
				return hashAlgorithm.ComputeHash(stream);
			}
			finally
			{
				stream?.Close();
			}
		}

		public static bool IsVerifiableHashCollection(HashCollection hashCollection)
		{
			foreach (Hash item in hashCollection)
			{
				if (!IsVerifiableHash(item))
				{
					return false;
				}
			}
			return true;
		}

		public static bool IsVerifiableHash(Hash hash)
		{
			if (Array.IndexOf(VerifiableTransformTypes, hash.Transform) >= 0 && Array.IndexOf(VerifiableDigestMethods, hash.DigestMethod) >= 0 && hash.DigestValue != null && hash.DigestValue.Length != 0)
			{
				return true;
			}
			return false;
		}

		public static HashAlgorithm GetHashAlgorithm(System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD digestMethod)
		{
			HashAlgorithm hashAlgorithm = null;
			switch (digestMethod)
			{
			case System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA1:
				return new SHA1CryptoServiceProvider();
			case System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA256:
				if (PlatformSpecific.OnWindows2003 || PlatformSpecific.OnVistaOrAbove)
				{
					return CryptoConfig.CreateFromName("System.Security.Cryptography.SHA256CryptoServiceProvider") as HashAlgorithm;
				}
				return new SHA256Managed();
			case System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA384:
				if (PlatformSpecific.OnWindows2003 || PlatformSpecific.OnVistaOrAbove)
				{
					return CryptoConfig.CreateFromName("System.Security.Cryptography.SHA384CryptoServiceProvider") as HashAlgorithm;
				}
				return new SHA384Managed();
			case System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA512:
				if (PlatformSpecific.OnWindows2003 || PlatformSpecific.OnVistaOrAbove)
				{
					return CryptoConfig.CreateFromName("System.Security.Cryptography.SHA512CryptoServiceProvider") as HashAlgorithm;
				}
				return new SHA512Managed();
			default:
				throw new NotSupportedException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DigestMethodNotSupported"), new object[1] { digestMethod.ToString() }));
			}
		}

		public static Stream GetTransformedStream(string filePath, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM transform)
		{
			Stream stream = null;
			switch (transform)
			{
			case System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM.CMS_HASH_TRANSFORM_MANIFESTINVARIANT:
			{
				PEStream pEStream = null;
				try
				{
					pEStream = new PEStream(filePath, partialConstruct: true);
					pEStream.ZeroOutOptionalHeaderCheckSum();
					pEStream.ZeroOutDefaultId1ManifestResource();
					stream = pEStream;
				}
				finally
				{
					if (pEStream != stream)
					{
						pEStream?.Close();
					}
				}
				break;
			}
			case System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM.CMS_HASH_TRANSFORM_IDENTITY:
				stream = new FileStream(filePath, FileMode.Open, FileAccess.Read);
				break;
			default:
				throw new NotSupportedException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_TransformAlgorithmNotSupported"), new object[1] { transform.ToString() }));
			}
			return stream;
		}

		public static void VerifySimplyNamedAssembly(string filePath, AssemblyManifest assemblyManifest)
		{
			string fileName = Path.GetFileName(filePath);
			if (assemblyManifest.Identity.PublicKeyToken != null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.Validation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_SimplyNamedAsmWithPKT"), new object[1] { fileName }));
			}
			if (assemblyManifest.ManifestSourceFormat == ManifestSourceFormat.ID_1 && assemblyManifest.ComplibIdentity != null && assemblyManifest.ComplibIdentity.PublicKeyToken != null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.IdentityMatchValidationForMixedModeAssembly, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_SimplyNamedAsmWithStrongNameComplib"), new object[1] { fileName }));
			}
		}

		public static void VerifyStrongNameAssembly(string filePath, AssemblyManifest assemblyManifest)
		{
			string fileName = Path.GetFileName(filePath);
			if (assemblyManifest.Identity.PublicKeyToken == null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.Validation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_StrongNameAsmWithNoPKT"), new object[1] { fileName }));
			}
			bool ignoreSelfReferentialFileHash = false;
			if (assemblyManifest.ManifestSourceFormat == ManifestSourceFormat.XmlFile)
			{
				assemblyManifest.ValidateSignature(null);
			}
			else if (assemblyManifest.ManifestSourceFormat == ManifestSourceFormat.ID_1)
			{
				if (assemblyManifest.ComplibIdentity == null)
				{
					byte[] array = null;
					PEStream pEStream = null;
					MemoryStream memoryStream = null;
					try
					{
						pEStream = new PEStream(filePath, partialConstruct: true);
						array = pEStream.GetDefaultId1ManifestResource();
						if (array != null)
						{
							memoryStream = new MemoryStream(array);
						}
						if (memoryStream == null)
						{
							throw new InvalidDeploymentException(ExceptionTypes.StronglyNamedAssemblyVerification, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_StronglyNamedAssemblyNotVerifiable"), new object[1] { fileName }));
						}
						assemblyManifest.ValidateSignature(memoryStream);
					}
					finally
					{
						pEStream?.Close();
						memoryStream?.Close();
					}
				}
				else
				{
					if (!assemblyManifest.ComplibIdentity.Equals(assemblyManifest.Identity))
					{
						throw new InvalidDeploymentException(ExceptionTypes.IdentityMatchValidationForMixedModeAssembly, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_IdentitiesDoNotMatchForMixedModeAssembly"), new object[1] { fileName }));
					}
					if (!Microsoft.Runtime.Hosting.StrongNameHelpers.StrongNameSignatureVerificationEx(filePath, fForceVerification: false, out var _))
					{
						throw new InvalidDeploymentException(ExceptionTypes.SignatureValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_StrongNameSignatureInvalid"), new object[1] { fileName }));
					}
					ignoreSelfReferentialFileHash = true;
				}
			}
			else
			{
				if (assemblyManifest.ManifestSourceFormat != ManifestSourceFormat.CompLib)
				{
					throw new InvalidDeploymentException(ExceptionTypes.StronglyNamedAssemblyVerification, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_StronglyNamedAssemblyNotVerifiable"), new object[1] { fileName }));
				}
				if (!Microsoft.Runtime.Hosting.StrongNameHelpers.StrongNameSignatureVerificationEx(filePath, fForceVerification: false, out var _))
				{
					throw new InvalidDeploymentException(ExceptionTypes.SignatureValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_StrongNameSignatureInvalid"), new object[1] { fileName }));
				}
				ignoreSelfReferentialFileHash = true;
			}
			VerifyManifestComponentFiles(assemblyManifest, filePath, ignoreSelfReferentialFileHash);
		}

		protected static void VerifyManifestComponentFiles(AssemblyManifest manifest, string componentPath, bool ignoreSelfReferentialFileHash)
		{
			string directoryName = Path.GetDirectoryName(componentPath);
			System.Deployment.Application.Manifest.File[] files = manifest.Files;
			foreach (System.Deployment.Application.Manifest.File file in files)
			{
				string text = Path.Combine(directoryName, file.NameFS);
				if ((!ignoreSelfReferentialFileHash || string.Compare(componentPath, text, StringComparison.OrdinalIgnoreCase) != 0) && System.IO.File.Exists(text))
				{
					VerifyFileHash(text, file.HashCollection);
				}
			}
		}
	}
	internal static class Constants
	{
		public const string ShimDll = "dfshim.dll";

		public const string DfDll = "dfdll.dll";

		public const string DeploymentFolder = "Deployment";

		public const string Dfsvc = "dfsvc.exe";

		public const string SystemDeploymentDll = "system.deployment.dll";

		public const string Kernel32Dll = "kernel32.dll";

		public const string MscoreeDll = "mscoree.dll";

		public const string WininetDll = "wininet.dll";

		public const string ClrDll = "clr.dll";

		public const string SrClientDll = "srclient.dll";

		public const string WinInetDll = "wininet.dll";

		public const string Shell32Dll = "shell32.dll";

		public const string ShellAppShortcutExtension = ".appref-ms";

		public const string ShellSupportShortcutExtension = ".url";

		public const int SupportIconIndex = 0;

		public const int ShortCutRemovalRetryTimes = 2;

		public const int ShortCutRemovalRetryInternal = 1000;

		public const string UninstallSubkeyName = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall";

		public const string DeploymentSubkeyName = "SOFTWARE\\Classes\\Software\\Microsoft\\Windows\\CurrentVersion\\Deployment";

		public const string LUAPolicyKeyName = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System";

		public const string OnlineAppQuotaInKBValueName = "OnlineAppQuotaInKB";

		public const string OnlineAppQuotaUsageEstimateValueName = "OnlineAppQuotaUsageEstimate";

		public const string LUAPolicyValueName = "EnableLUA";

		public const string ClassesSubKeyName = "Software\\Classes";

		public const string AppIdValueName = "AppId";

		public const string DPUrlValueName = "DeploymentProviderUrl";

		public const string IconFileValueName = "IconFile";

		public const string ContentTypeValueName = "Content Type";

		public const string ShellKeyName = "shell";

		public const string OpenCommandKeyName = "open\\command";

		public const string IconHandlerKeyName = "shellex\\IconHandler";

		public const string CLSIDKeyName = "CLSID";

		public const string InProcServerKeyName = "InProcServer32";

		public const string GuidValueName = "Guid";

		public const string RootKeyName = "Software\\Microsoft\\.NETFramework\\DeploymentFramework";

		public const string RequireSignedManifests = "RequireSignedManifests";

		public const string RequireHashInManifests = "RequireHashInManifests";

		public const string SkipSignatureValidationValueName = "SkipSignatureValidation";

		public const string SkipDeploymentProviderValueName = "SkipDeploymentProvider";

		public const string SkipSchemaValidationValueName = "SkipSchemaValidation";

		public const string SkipSemanticValidationValueName = "SkipSemanticValidation";

		public const string SkipApplicationDependencyHashCheckValueName = "SkipApplicationDependencyHashCheck";

		public const string SuppressLimitOnNumberOfActivationsValueName = "SuppressLimitOnNumberOfActivations";

		public const string DisableGenericExceptionHandler = "DisableGenericExceptionHandler";

		public const string LogVerbosityLevel = "LogVerbosityLevel";

		public const string DeploymentManifestSuffix = ".application";

		public const string ManifestSuffix = ".manifest";

		public const string DllSuffix = ".dll";

		public const string ExeSuffix = ".exe";

		public const string MapFileExtensionsSuffix = ".deploy";

		public const string InstallReferenceIdentifier = "{3f471841-eef2-47d6-89c0-d028f03a4ad5}";

		public static Guid DeploymentPropertySet = new Guid("2ad613da-6fdb-4671-af9e-18ab2e4df4d8");

		public const string SubscriptionStoreLock = "__SubscriptionStoreLock__";

		public static TimeSpan OnlineAppScavengingGracePeriod = TimeSpan.FromMinutes(1.0);

		public const string IsShellVisible = "IsShellVisible";

		public const string CurrentBind = "CurrentBind";

		public const string PreviousBind = "PreviousBind";

		public const string PendingBind = "PendingBind";

		public const string ExcludedDeployment = "ExcludedDeployment";

		public const string PendingDeployment = "PendingDeployment";

		public const string DeploymentProviderUri = "DeploymentProviderUri";

		public const string MinimumRequiredVersion = "MinimumRequiredVersion";

		public const string LastCheckTime = "LastCheckTime";

		public const string UpdateSkipTime = "UpdateSkipTime";

		public const string UpdateSkippedDeployment = "UpdateSkippedDeployment";

		public const string AppType = "AppType";

		public const string UseApplicationManifestDescription = "UseApplicationManifestDescription";

		public const string DeploymentSourceUri = "DeploymentSourceUri";

		public const string ApplicationSourceUri = "ApplicationSourceUri";

		public const string IsFullTrust = "IsFullTrust";

		public const string CLRCoreComp = "Microsoft-Windows-CLRCoreComp";

		public const string CommonLanguageRuntime = "Microsoft.Windows.CommonLanguageRuntime";

		public static Version V2CLRVersion = new Version("2.0.50727.0");

		public static Version V4CLRVersion = new Version("4.0");

		public const uint MinVersionCLRMajor = 2u;

		public const string MSIL = "msil";

		public const string X86 = "x86";

		public const string AMD64 = "amd64";

		public const string ARM64 = "arm64";

		public const string IA64 = "ia64";

		public const string AsmV1Namespace = "urn:schemas-microsoft-com:asm.v1";

		public const string AsmV2Namespace = "urn:schemas-microsoft-com:asm.v2";

		public const string XmlDSigNamespace = "http://www.w3.org/2000/09/xmldsig#";

		public const string AdaptiveSchemaResourceName = "manifest.2.0.0.15-pre.adaptive.xsd";

		public const string PublicIdForDTD4XMLSchemas = "-//W3C//DTD XMLSCHEMA 200102//EN";

		public const string XMLSchemaDTDResourceName = "XMLSchema.dtd";

		public const string PublicIdForDTD4DataTypes = "xs-datatypes";

		public const string DataTypesDTDResourceName = "datatypes.dtd";

		public const string UnsignedPublicKeyToken = "0000000000000000";

		public const string RequireAdministrator = "requireAdministrator";

		public const string HighestAvailable = "highestAvailable";

		public const int MaxNumberOfFilesInApplication = 24576;

		public const int MaxNumberOfFileAssociationsInApplication = 8;

		public const int MaxNumberOfFileExtensionLength = 24;

		public const int MaxNumberOfAssembliesInApplication = 24576;

		public const int MaxNumberOfGroupsInApplication = 49152;

		public const int MaxUrlLength = 16384;

		public const int MaxLiveActivation = 8;

		public const int MaxIdentityLength = 2048;

		public const int MaxAppIdLength = 65536;

		public const int MaxShortcutFileSize = 65536;

		public const int MaxManifestFileSize = 16777216;

		public const int MaxValueForMaximumAge = 365;

		public const int MaxErrorUrlLength = 2048;

		public const uint DefaultOnlineAppQuotaInKB = 256000u;

		public const int LifetimeDefaultMinutes = 10;

		public static TimeSpan LockTimeout = TimeSpan.FromMinutes(2.0);

		public static TimeSpan AssertApplicationRequirementsTimeout = TimeSpan.FromMinutes(2.0);

		public const int LockRetryIntervalMs = 1;

		public const int MinProgressCallbackIntervalInMs = 100;

		public const string DefaultLogTextualId = "__DeploymentDefaultLogFile__";

		public const int MAX_PATH = 260;

		public const string LogFileExtension = "log";

		public const string LogFilePathRegistryString = "LogFilePath";

		public const string WininetCacheLogUrlPrefix = "System_Deployment_Log_";

		public const string GACDetectionTempManifestAsmIdText = "GACDetectionTempManifest, version=1.0.0.0, type=win32";

		public const string DataDirectory = "DataDirectory";

		public const int HRESULT_DiskFull = -2147024784;

		public const uint MASK_NOTPINNABLE = 2147483648u;

		public const uint MASK_DONT_SHOW_INSTALL_DIALOG = 256u;

		public const string Client35SP1SignatureAssembly = "Sentinel.v3.5Client, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a,processorArchitecture=msil";

		public const string Full35SP1SignatureAssembly = "System.Data.Entity, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089,processorArchitecture=msil";

		public const string DotNetFX35SP1 = ".NET Framework 3.5 SP1";

		public const string SkipSKUDetectionKeyName = "SOFTWARE\\Microsoft\\Fusion";

		public const string SkipSKUDetectionValueName = "NoClientChecks";

		public const string SetupKeyCommonPath = "SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v";

		public const string PreV4ClientSetupKeyCommonPath = "SOFTWARE\\Microsoft\\NET Framework Setup\\DotNetClient\\v";

		public const string V30SetupKeyPath = "SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v3.0\\Setup";

		public const string NetFxKeyCommonPath = "SOFTWARE\\Microsoft\\.NETFramework\\v";

		public const string TFMFormatNoProfile = ".NETFramework,Version=v{0}";

		public const string TFMFormatWithProfile = ".NETFramework,Version=v{0},Profile={1}";

		public const string FullProfileName = "Full";

		public const string PreV4ClientProfileName = "Client";

		public const string PreV4SetupValueName = "Version";

		public const string V4SetupValueName = "TargetVersion";

		public const string InstallValueName = "Install";

		public const string V30InstallValueName = "InstallSuccess";

		public const string FrameworkGroupName = "framework";

		public const int CLSCTX_INPROC_SERVER = 1;

		public static Guid CLSID_StartMenuPin = new Guid("A2A9545D-A0C2-42B4-9708-A0B2BADD77C8");

		public static Guid IID_IUnknown = new Guid("00000000-0000-0000-C000-000000000046");

		public static Guid uuid = new Guid("43826d1e-e718-42ee-bc55-a1e261c37bfe");
	}
	internal class DeploymentManager : IDisposable, IDownloadNotification
	{
		public enum CallerType
		{
			Other,
			ApplicationDeployment,
			InPlaceHostingManager
		}

		private static readonly object bindCompletedKey = new object();

		private static readonly object synchronizeCompletedKey = new object();

		private static readonly object progressChangedKey = new object();

		private readonly ThreadStart bindWorker;

		private readonly ThreadStart synchronizeWorker;

		private readonly WaitCallback synchronizeGroupWorker;

		private readonly SendOrPostCallback bindCompleted;

		private readonly SendOrPostCallback synchronizeCompleted;

		private readonly SendOrPostCallback progressReporter;

		private readonly AsyncOperation asyncOperation;

		private int _bindGuard;

		private int _syncGuard;

		private bool _cancellationPending;

		private bool _cached;

		private ManualResetEvent _trustNotGrantedEvent = new ManualResetEvent(initialState: false);

		private ManualResetEvent _trustGrantedEvent = new ManualResetEvent(initialState: false);

		private ManualResetEvent _platformRequirementsFailedEvent = new ManualResetEvent(initialState: false);

		private ManualResetEvent[] _assertApplicationReqEvents;

		private CallerType _callerType;

		private Uri _deploySource;

		private DefinitionAppId _bindAppId;

		private SubscriptionStore _subStore;

		private bool _isupdate;

		private bool _isConfirmed = true;

		private DownloadOptions _downloadOptions;

		private EventHandlerList _events;

		private Hashtable _syncGroupMap;

		private ActivationDescription _actDesc;

		private ActivationContext _actCtx;

		private DeploymentProgressState _state = DeploymentProgressState.DownloadingApplicationFiles;

		private TempFile _tempDeployment;

		private TempDirectory _tempApplicationDirectory;

		private FileStream _referenceTransaction;

		private Logger.LogIdentity _log;

		private long _downloadedAppSize;

		public CallerType Callertype
		{
			get
			{
				return _callerType;
			}
			set
			{
				_callerType = value;
			}
		}

		public Logger.LogIdentity LogId => _log;

		public bool CancellationPending => _cancellationPending;

		public string ShortcutAppId
		{
			get
			{
				AssemblyManifest deployManifest = _actDesc.DeployManifest;
				SubscriptionState subscriptionState = _subStore.GetSubscriptionState(deployManifest);
				string result = null;
				if (subscriptionState.IsInstalled)
				{
					result = $"{subscriptionState.DeploymentProviderUri.AbsoluteUri}#{subscriptionState.SubscriptionId.ToString()}";
				}
				return result;
			}
		}

		public string LogFilePath
		{
			get
			{
				string result = Logger.GetLogFilePath(_log);
				if (!Logger.FlushLog(_log))
				{
					result = null;
				}
				return result;
			}
		}

		internal ActivationDescription ActivationDescription => _actDesc;

		private EventHandlerList Events => _events;

		public event BindCompletedEventHandler BindCompleted
		{
			add
			{
				Events.AddHandler(bindCompletedKey, value);
			}
			remove
			{
				Events.RemoveHandler(bindCompletedKey, value);
			}
		}

		public event SynchronizeCompletedEventHandler SynchronizeCompleted
		{
			add
			{
				Events.AddHandler(synchronizeCompletedKey, value);
			}
			remove
			{
				Events.RemoveHandler(synchronizeCompletedKey, value);
			}
		}

		public event DeploymentProgressChangedEventHandler ProgressChanged
		{
			add
			{
				Events.AddHandler(progressChangedKey, value);
			}
			remove
			{
				Events.RemoveHandler(progressChangedKey, value);
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public DeploymentManager(string appId)
			: this(appId, isUpdate: false, isConfirmed: true, null, null)
		{
			if (appId == null)
			{
				throw new ArgumentNullException("appId");
			}
		}

		[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
		public DeploymentManager(Uri deploymentSource)
			: this(deploymentSource, isUpdate: false, isConfirmed: true, null, null)
		{
			if (deploymentSource == null)
			{
				throw new ArgumentNullException("deploymentSource");
			}
			UriHelper.ValidateSupportedSchemeInArgument(deploymentSource, "deploymentSource");
		}

		internal DeploymentManager(Uri deploymentSource, bool isUpdate, bool isConfirmed, DownloadOptions downloadOptions, AsyncOperation optionalAsyncOp)
		{
			_deploySource = deploymentSource;
			_isupdate = isUpdate;
			_isConfirmed = isConfirmed;
			_downloadOptions = downloadOptions;
			_events = new EventHandlerList();
			_syncGroupMap = CollectionsUtil.CreateCaseInsensitiveHashtable();
			_subStore = SubscriptionStore.CurrentUser;
			bindWorker = BindAsyncWorker;
			synchronizeWorker = SynchronizeAsyncWorker;
			synchronizeGroupWorker = SynchronizeGroupAsyncWorker;
			bindCompleted = BindAsyncCompleted;
			synchronizeCompleted = SynchronizeAsyncCompleted;
			progressReporter = ProgressReporter;
			if (optionalAsyncOp == null)
			{
				asyncOperation = AsyncOperationManager.CreateOperation(null);
			}
			else
			{
				asyncOperation = optionalAsyncOp;
			}
			_log = Logger.StartLogging();
			if (deploymentSource != null)
			{
				Logger.SetSubscriptionUrl(_log, deploymentSource);
			}
			_assertApplicationReqEvents = new ManualResetEvent[3];
			_assertApplicationReqEvents[0] = _trustNotGrantedEvent;
			_assertApplicationReqEvents[1] = _platformRequirementsFailedEvent;
			_assertApplicationReqEvents[2] = _trustGrantedEvent;
			_callerType = CallerType.Other;
			PolicyKeys.SkipApplicationDependencyHashCheck();
			PolicyKeys.SkipDeploymentProvider();
			PolicyKeys.SkipSchemaValidation();
			PolicyKeys.SkipSemanticValidation();
			PolicyKeys.SkipSignatureValidation();
		}

		internal DeploymentManager(string appId, bool isUpdate, bool isConfirmed, DownloadOptions downloadOptions, AsyncOperation optionalAsyncOp)
			: this((Uri)null, isUpdate, isConfirmed, downloadOptions, optionalAsyncOp)
		{
			_bindAppId = new DefinitionAppId(appId);
		}

		public void BindAsync()
		{
			Logger.AddMethodCall(_log, "DeploymentManager.BindAsync() called.");
			if (!_cancellationPending)
			{
				if (Interlocked.Exchange(ref _bindGuard, 1) != 0)
				{
					throw new InvalidOperationException(Resources.GetString("Ex_BindOnce"));
				}
				bindWorker.BeginInvoke(null, null);
			}
		}

		public ActivationContext Bind()
		{
			if (Interlocked.Exchange(ref _bindGuard, 1) != 0)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_BindOnce"));
			}
			bool flag = false;
			TempFile tempDeploy = null;
			TempDirectory tempAppDir = null;
			FileStream refTransaction = null;
			try
			{
				string productName = null;
				BindCore(blocking: true, ref tempDeploy, ref tempAppDir, ref refTransaction, ref productName);
			}
			catch (Exception)
			{
				flag = true;
				throw;
			}
			finally
			{
				_state = DeploymentProgressState.DownloadingApplicationFiles;
				if (flag)
				{
					tempAppDir?.Dispose();
					tempDeploy?.Dispose();
					refTransaction?.Close();
				}
			}
			return _actCtx;
		}

		public void DeterminePlatformRequirements()
		{
			try
			{
				if (_actDesc == null)
				{
					throw new InvalidOperationException(Resources.GetString("Ex_BindFirst"));
				}
				DeterminePlatformRequirementsCore(blocking: true);
			}
			catch (Exception)
			{
				_platformRequirementsFailedEvent.Set();
				throw;
			}
		}

		public void DetermineTrust(TrustParams trustParams)
		{
			try
			{
				if (_actDesc == null)
				{
					throw new InvalidOperationException(Resources.GetString("Ex_BindFirst"));
				}
				DetermineTrustCore(blocking: true, trustParams);
			}
			catch (Exception)
			{
				_trustNotGrantedEvent.Set();
				throw;
			}
			_trustGrantedEvent.Set();
		}

		public void SynchronizeAsync()
		{
			Logger.AddMethodCall(_log, "DeploymentManager.SynchronizeAsync() called.");
			if (!_cancellationPending)
			{
				if (_actDesc == null)
				{
					throw new InvalidOperationException(Resources.GetString("Ex_BindFirst"));
				}
				if (Interlocked.Exchange(ref _syncGuard, 1) != 0)
				{
					throw new InvalidOperationException(Resources.GetString("Ex_SyncNullOnce"));
				}
				synchronizeWorker.BeginInvoke(null, null);
			}
		}

		public void Synchronize()
		{
			if (_actDesc == null)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_BindFirst"));
			}
			if (Interlocked.Exchange(ref _syncGuard, 1) != 0)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_SyncNullOnce"));
			}
			SynchronizeCore(blocking: true);
		}

		public void SynchronizeAsync(string groupName)
		{
			SynchronizeAsync(groupName, null);
		}

		public void SynchronizeAsync(string groupName, object userState)
		{
			if (groupName == null)
			{
				SynchronizeAsync();
				return;
			}
			if (_actDesc == null)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_BindFirst"));
			}
			if (!_cached)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_SyncNullFirst"));
			}
			bool created;
			SyncGroupHelper state = AttachToGroup(groupName, userState, out created);
			if (created)
			{
				ThreadPool.QueueUserWorkItem(synchronizeGroupWorker, state);
				return;
			}
			throw new InvalidOperationException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_SyncGroupOnce"), new object[1] { groupName }));
		}

		public void Synchronize(string groupName)
		{
			if (groupName == null)
			{
				Synchronize();
				return;
			}
			if (_actDesc == null)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_BindFirst"));
			}
			if (!_cached)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_SyncNullFirst"));
			}
			bool created;
			SyncGroupHelper sgh = AttachToGroup(groupName, null, out created);
			if (created)
			{
				SynchronizeGroupCore(blocking: true, sgh);
				return;
			}
			throw new InvalidOperationException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_SyncGroupOnce"), new object[1] { groupName }));
		}

		public ObjectHandle ExecuteNewDomain()
		{
			if (_actDesc == null)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_BindFirst"));
			}
			if (!_cached)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_SyncNullFirst"));
			}
			Logger.AddInternalState(_log, "Activating " + ((_actCtx != null && _actCtx.Identity != null) ? _actCtx.Identity.ToString() : "null") + " in a new domain.");
			return Activator.CreateInstance(_actCtx);
		}

		public void ExecuteNewProcess()
		{
			if (_actDesc == null)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_BindFirst"));
			}
			if (!_cached)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_SyncNullFirst"));
			}
			_subStore.ActivateApplication(_actDesc.AppId, null, useActivationParameter: false);
		}

		public void CancelAsync()
		{
			_cancellationPending = true;
		}

		public void CancelAsync(string groupName)
		{
			if (groupName == null)
			{
				CancelAsync();
				return;
			}
			lock (_syncGroupMap.SyncRoot)
			{
				((SyncGroupHelper)_syncGroupMap[groupName])?.CancelAsync();
			}
		}

		public void Dispose()
		{
			_events.Dispose();
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		void IDownloadNotification.DownloadModified(object sender, DownloadEventArgs e)
		{
			if (_cancellationPending)
			{
				((FileDownloader)sender).Cancel();
			}
			asyncOperation.Post(progressReporter, new DeploymentProgressChangedEventArgs(e.Progress, null, e.BytesCompleted, e.BytesTotal, _state, null));
		}

		void IDownloadNotification.DownloadCompleted(object sender, DownloadEventArgs e)
		{
			_downloadedAppSize = e.BytesCompleted;
		}

		private void BindAsyncCompleted(object arg)
		{
			BindCompletedEventArgs e = (BindCompletedEventArgs)arg;
			((BindCompletedEventHandler)Events[bindCompletedKey])?.Invoke(this, e);
		}

		private void SynchronizeAsyncCompleted(object arg)
		{
			SynchronizeCompletedEventArgs e = (SynchronizeCompletedEventArgs)arg;
			((SynchronizeCompletedEventHandler)Events[synchronizeCompletedKey])?.Invoke(this, e);
		}

		private void ProgressReporter(object arg)
		{
			DeploymentProgressChangedEventArgs e = (DeploymentProgressChangedEventArgs)arg;
			((DeploymentProgressChangedEventHandler)Events[progressChangedKey])?.Invoke(this, e);
		}

		private void BindAsyncWorker()
		{
			Exception ex = null;
			bool flag = false;
			string productName = null;
			TempFile tempDeploy = null;
			TempDirectory tempAppDir = null;
			FileStream refTransaction = null;
			try
			{
				Logger.AddInternalState(_log, "Binding started in a worker thread.");
				flag = BindCore(blocking: false, ref tempDeploy, ref tempAppDir, ref refTransaction, ref productName);
				Logger.AddInternalState(_log, "Binding is successful.");
			}
			catch (Exception ex2)
			{
				if (ExceptionUtility.IsHardException(ex2))
				{
					throw;
				}
				if (ex2 is DownloadCancelledException)
				{
					flag = true;
				}
				else
				{
					ex = ex2;
				}
			}
			finally
			{
				_state = DeploymentProgressState.DownloadingApplicationFiles;
				if (ex != null || flag)
				{
					tempAppDir?.Dispose();
					tempDeploy?.Dispose();
					refTransaction?.Close();
				}
				BindCompletedEventArgs arg = new BindCompletedEventArgs(ex, flag, null, _actCtx, productName, _cached);
				asyncOperation.Post(bindCompleted, arg);
			}
		}

		private bool BindCore(bool blocking, ref TempFile tempDeploy, ref TempDirectory tempAppDir, ref FileStream refTransaction, ref string productName)
		{
			try
			{
				if (_deploySource == null)
				{
					return BindCoreWithAppId(blocking, ref refTransaction, ref productName);
				}
				bool flag = false;
				AssemblyManifest assemblyManifest = null;
				string text = null;
				Uri sourceUri = _deploySource;
				_state = DeploymentProgressState.DownloadingDeploymentInformation;
				Logger.AddInternalState(_log, "Internal state=" + _state);
				assemblyManifest = DownloadManager.DownloadDeploymentManifest(_subStore, ref sourceUri, out tempDeploy, blocking ? null : this, _downloadOptions);
				text = tempDeploy.Path;
				ActivationDescription activationDescription = new ActivationDescription();
				activationDescription.SetDeploymentManifest(assemblyManifest, sourceUri, text);
				Logger.SetDeploymentManifest(_log, assemblyManifest);
				activationDescription.IsUpdate = _isupdate;
				if (activationDescription.DeployManifest.Deployment == null)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_NotDeploymentOrShortcut"));
				}
				if (!blocking && _cancellationPending)
				{
					return true;
				}
				refTransaction = _subStore.AcquireReferenceTransaction(out var transactionId);
				SubscriptionState subscriptionState = _subStore.GetSubscriptionState(activationDescription.DeployManifest);
				if (activationDescription.DeployManifest.Deployment.Install && activationDescription.DeployManifest.Deployment.ProviderCodebaseUri == null && subscriptionState != null && subscriptionState.DeploymentProviderUri != null && !subscriptionState.DeploymentProviderUri.Equals(sourceUri))
				{
					throw new DeploymentException(ExceptionTypes.DeploymentUriDifferent, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DeploymentUriDifferentExText"), new object[3]
					{
						activationDescription.DeployManifest.Description.FilteredProduct,
						sourceUri.AbsoluteUri,
						subscriptionState.DeploymentProviderUri.AbsoluteUri
					}));
				}
				DefinitionAppId definitionAppId = null;
				try
				{
					definitionAppId = new DefinitionAppId(activationDescription.ToAppCodebase(), activationDescription.DeployManifest.Identity, new DefinitionIdentity(activationDescription.DeployManifest.MainDependentAssembly.Identity));
				}
				catch (COMException innerException)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_IdentityIsNotValid"), innerException);
				}
				catch (SEHException innerException2)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_IdentityIsNotValid"), innerException2);
				}
				Logger.AddInternalState(_log, "expectedAppId=" + definitionAppId.ToString());
				flag = _subStore.CheckAndReferenceApplication(subscriptionState, definitionAppId, transactionId);
				if (flag && definitionAppId.Equals(subscriptionState.CurrentBind))
				{
					Logger.AddInternalState(_log, "Application is found in store and it is the CurrentBind. Binding with appid.");
					_bindAppId = definitionAppId;
					return BindCoreWithAppId(blocking, ref refTransaction, ref productName);
				}
				if (flag)
				{
					Logger.AddInternalState(_log, "Application is found in store but it is not the CurrentBind.");
				}
				else
				{
					Logger.AddInternalState(_log, "Application is not found in store.");
				}
				if (!blocking && _cancellationPending)
				{
					return true;
				}
				_state = DeploymentProgressState.DownloadingApplicationInformation;
				Logger.AddInternalState(_log, "Internal state=" + _state);
				tempAppDir = _subStore.AcquireTempDirectory();
				Uri appSourceUri;
				string appManifestPath;
				AssemblyManifest assemblyManifest2 = DownloadManager.DownloadApplicationManifest(activationDescription.DeployManifest, tempAppDir.Path, activationDescription.DeploySourceUri, blocking ? null : this, _downloadOptions, out appSourceUri, out appManifestPath);
				AssemblyManifest.ReValidateManifestSignatures(activationDescription.DeployManifest, assemblyManifest2);
				Logger.SetApplicationManifest(_log, assemblyManifest2);
				Logger.SetApplicationUrl(_log, appSourceUri);
				activationDescription.SetApplicationManifest(assemblyManifest2, appSourceUri, appManifestPath);
				activationDescription.AppId = new DefinitionAppId(activationDescription.ToAppCodebase(), activationDescription.DeployManifest.Identity, activationDescription.AppManifest.Identity);
				flag = _subStore.CheckAndReferenceApplication(subscriptionState, activationDescription.AppId, transactionId);
				if (!blocking && _cancellationPending)
				{
					return true;
				}
				Description effectiveDescription = activationDescription.EffectiveDescription;
				productName = effectiveDescription.Product;
				_cached = flag;
				Logger.AddInternalState(_log, "_cached=" + _cached);
				Logger.AddInternalState(_log, "_isupdate=" + _isupdate);
				_tempApplicationDirectory = tempAppDir;
				_tempDeployment = tempDeploy;
				_referenceTransaction = refTransaction;
				_actCtx = ConstructActivationContext(activationDescription);
				_actDesc = activationDescription;
			}
			catch (Exception ex)
			{
				LogError(Resources.GetString("Ex_FailedToDownloadManifest"), ex);
				Logger.AddInternalState(_log, "Exception thrown in  BindCore(): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
				throw;
			}
			return false;
		}

		private bool BindCoreWithAppId(bool blocking, ref FileStream refTransaction, ref string productName)
		{
			bool flag = false;
			DefinitionIdentity subId = _bindAppId.DeploymentIdentity.ToSubscriptionId();
			SubscriptionState subscriptionState = _subStore.GetSubscriptionState(subId);
			if (!subscriptionState.IsInstalled)
			{
				throw new InvalidDeploymentException(Resources.GetString("Ex_BindAppIdNotInstalled"));
			}
			if (!_bindAppId.Equals(subscriptionState.CurrentBind))
			{
				throw new InvalidDeploymentException(Resources.GetString("Ex_BindAppIdNotCurrrent"));
			}
			if (!blocking && _cancellationPending)
			{
				return true;
			}
			refTransaction = _subStore.AcquireReferenceTransaction(out var transactionId);
			flag = _subStore.CheckAndReferenceApplication(subscriptionState, _bindAppId, transactionId);
			ActivationDescription activationDescription = new ActivationDescription();
			activationDescription.SetDeploymentManifest(subscriptionState.CurrentDeploymentManifest, subscriptionState.CurrentDeploymentSourceUri, null);
			Logger.SetDeploymentManifest(_log, subscriptionState.CurrentDeploymentManifest);
			activationDescription.IsUpdate = _isupdate;
			activationDescription.SetApplicationManifest(subscriptionState.CurrentApplicationManifest, subscriptionState.CurrentApplicationSourceUri, null);
			Logger.SetApplicationManifest(_log, subscriptionState.CurrentApplicationManifest);
			Logger.SetApplicationUrl(_log, subscriptionState.CurrentApplicationSourceUri);
			activationDescription.AppId = new DefinitionAppId(activationDescription.ToAppCodebase(), activationDescription.DeployManifest.Identity, activationDescription.AppManifest.Identity);
			if (!blocking && _cancellationPending)
			{
				return true;
			}
			Description effectiveDescription = subscriptionState.EffectiveDescription;
			productName = effectiveDescription.Product;
			_cached = flag;
			Logger.AddInternalState(_log, "_cached=" + _cached);
			Logger.AddInternalState(_log, "_isupdate=" + _isupdate);
			_referenceTransaction = refTransaction;
			_actCtx = ConstructActivationContextFromStore(activationDescription.AppId);
			_actDesc = activationDescription;
			return false;
		}

		private bool DeterminePlatformRequirementsCore(bool blocking)
		{
			try
			{
				Logger.AddMethodCall(_log, "DeploymentManager.DeterminePlatformRequirementsCore(" + blocking + ") called.");
				if (!blocking && _cancellationPending)
				{
					return true;
				}
				using TempDirectory tempDirectory = _subStore.AcquireTempDirectory();
				PlatformDetector.VerifyPlatformDependencies(_actDesc.AppManifest, _actDesc.DeployManifest, tempDirectory.Path);
			}
			catch (Exception ex)
			{
				LogError(Resources.GetString("Ex_DeterminePlatformRequirementsFailed"), ex);
				Logger.AddInternalState(_log, "Exception thrown in  DeterminePlatformRequirementsCore(): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
				throw;
			}
			return false;
		}

		private bool DetermineTrustCore(bool blocking, TrustParams tp)
		{
			try
			{
				Logger.AddMethodCall(_log, "DeploymentManager.DetermineTrustCore() called.");
				SubscriptionState subscriptionState = _subStore.GetSubscriptionState(_actDesc.DeployManifest);
				TrustManagerContext trustManagerContext = new TrustManagerContext();
				trustManagerContext.IgnorePersistedDecision = false;
				trustManagerContext.NoPrompt = false;
				trustManagerContext.Persist = true;
				if (tp != null)
				{
					trustManagerContext.NoPrompt = tp.NoPrompt;
				}
				if (!blocking && _cancellationPending)
				{
					return true;
				}
				if (subscriptionState.IsInstalled && !string.Equals(subscriptionState.EffectiveCertificatePublicKeyToken, _actDesc.EffectiveCertificatePublicKeyToken, StringComparison.Ordinal))
				{
					Logger.AddInternalState(_log, "Application family is installed but effective certificate public key token has changed between versions: subState.EffectiveCertificatePublicKeyToken=" + subscriptionState.EffectiveCertificatePublicKeyToken + ",_actDesc.EffectiveCertificatePublicKeyToken=" + _actDesc.EffectiveCertificatePublicKeyToken);
					Logger.AddInternalState(_log, "Removing cached trust for the CurrentBind.");
					ApplicationTrust.RemoveCachedTrust(subscriptionState.CurrentBind);
				}
				bool isUpdate = false;
				if (_actDesc.IsUpdate)
				{
					isUpdate = true;
				}
				if (_actDesc.IsUpdateInPKTGroup)
				{
					isUpdate = false;
					ApplicationSecurityInfo applicationSecurityInfo = new ApplicationSecurityInfo(_actCtx);
					_actDesc.IsFullTrustRequested = applicationSecurityInfo.DefaultRequestSet.IsUnrestricted();
				}
				_actDesc.Trust = ApplicationTrust.RequestTrust(subscriptionState, _actDesc.DeployManifest.Deployment.Install, isUpdate, _actCtx, trustManagerContext);
			}
			catch (Exception ex)
			{
				LogError(Resources.GetString("Ex_DetermineTrustFailed"), ex);
				Logger.AddInternalState(_log, "Exception thrown in  DetermineTrustCore(): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
				throw;
			}
			return false;
		}

		public void PersistTrustWithoutEvaluation()
		{
			try
			{
				_actDesc.Trust = ApplicationTrust.PersistTrustWithoutEvaluation(_actCtx);
			}
			catch (Exception)
			{
				_trustNotGrantedEvent.Set();
				throw;
			}
			_trustGrantedEvent.Set();
		}

		private void SynchronizeAsyncWorker()
		{
			Exception error = null;
			bool cancelled = false;
			try
			{
				Logger.AddInternalState(_log, "Download and install of the application started in a worker thread.");
				cancelled = SynchronizeCore(blocking: false);
				Logger.AddInternalState(_log, "Installation is successful.");
			}
			catch (Exception ex)
			{
				if (ExceptionUtility.IsHardException(ex))
				{
					throw;
				}
				if (ex is DownloadCancelledException)
				{
					cancelled = true;
				}
				else
				{
					error = ex;
				}
			}
			finally
			{
				SynchronizeCompletedEventArgs arg = new SynchronizeCompletedEventArgs(error, cancelled, null, null);
				asyncOperation.Post(synchronizeCompleted, arg);
			}
		}

		private bool SynchronizeCore(bool blocking)
		{
			try
			{
				AssemblyManifest deployManifest = _actDesc.DeployManifest;
				SubscriptionState subState = _subStore.GetSubscriptionState(deployManifest);
				_subStore.CheckDeploymentSubscriptionState(subState, deployManifest);
				_subStore.CheckCustomUXFlag(subState, _actDesc.AppManifest);
				if (_actDesc.DeployManifestPath != null)
				{
					_actDesc.CommitDeploy = true;
					_actDesc.IsConfirmed = _isConfirmed;
					_actDesc.TimeStamp = DateTime.UtcNow;
				}
				else
				{
					_actDesc.CommitDeploy = false;
				}
				if (!blocking && _cancellationPending)
				{
					return true;
				}
				if (!_cached)
				{
					Logger.AddInternalState(_log, "Application is not cached.");
					bool flag = false;
					if (_actDesc.appType != AppType.CustomHostSpecified)
					{
						if (_actDesc.Trust != null)
						{
							bool flag2 = _actDesc.Trust.DefaultGrantSet.PermissionSet.IsUnrestricted();
							Logger.AddInternalState(_log, "fullTrust=" + flag2);
							if (!flag2 && _actDesc.AppManifest.FileAssociations.Length != 0)
							{
								throw new DeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_FileExtensionNotSupported"));
							}
							bool flag3 = !_actDesc.DeployManifest.Deployment.Install;
							if (!flag2 && flag3)
							{
								Logger.AddInternalState(_log, "Application is semi-trust and online. Size limits will be checked during download.");
								if (_downloadOptions == null)
								{
									_downloadOptions = new DownloadOptions();
								}
								_downloadOptions.EnforceSizeLimit = true;
								_downloadOptions.SizeLimit = _subStore.GetSizeLimitInBytesForSemiTrustApps();
								_downloadOptions.Size = _actDesc.DeployManifest.SizeInBytes + _actDesc.AppManifest.SizeInBytes;
							}
						}
						else
						{
							flag = true;
						}
					}
					DownloadManager.DownloadDependencies(subState, _actDesc.DeployManifest, _actDesc.AppManifest, _actDesc.AppSourceUri, _tempApplicationDirectory.Path, null, blocking ? null : this, _downloadOptions);
					if (!blocking && _cancellationPending)
					{
						return true;
					}
					WaitForAssertApplicationRequirements();
					if (flag)
					{
						CheckSizeLimit();
					}
					_actDesc.CommitApp = true;
					_actDesc.AppPayloadPath = _tempApplicationDirectory.Path;
				}
				else
				{
					Logger.AddInternalState(_log, "Application is cached.");
					WaitForAssertApplicationRequirements();
				}
				if (_actDesc.CommitDeploy || _actDesc.CommitApp)
				{
					_subStore.CommitApplication(ref subState, _actDesc);
					Logger.AddInternalState(_log, "Application is successfully committed to the store.");
				}
				if (_tempApplicationDirectory != null)
				{
					_tempApplicationDirectory.Dispose();
					_tempApplicationDirectory = null;
				}
				if (_tempDeployment != null)
				{
					_tempDeployment.Dispose();
					_tempDeployment = null;
				}
				if (_referenceTransaction != null)
				{
					_referenceTransaction.Close();
					_referenceTransaction = null;
				}
				Logger.AddInternalState(_log, "Refreshing ActivationContext from store.");
				ActivationContext actCtx = _actCtx;
				_actCtx = ConstructActivationContextFromStore(_actDesc.AppId);
				actCtx.Dispose();
				_cached = true;
			}
			catch (Exception ex)
			{
				LogError(Resources.GetString("Ex_DownloadApplicationFailed"), ex);
				Logger.AddInternalState(_log, "Exception thrown in  SynchronizeCore(): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
				throw;
			}
			return false;
		}

		private void WaitForAssertApplicationRequirements()
		{
			if (_actDesc.appType != AppType.CustomHostSpecified && _callerType != CallerType.ApplicationDeployment)
			{
				Logger.AddInternalState(_log, "WaitForAssertApplicationRequirements() called.");
				WaitHandle[] assertApplicationReqEvents = _assertApplicationReqEvents;
				switch (WaitHandle.WaitAny(assertApplicationReqEvents, Constants.AssertApplicationRequirementsTimeout, exitContext: false))
				{
				case 258:
					throw new DeploymentException(Resources.GetString("Ex_CannotCommitNoTrustDecision"));
				case 0:
					throw new DeploymentException(Resources.GetString("Ex_CannotCommitTrustFailed"));
				case 1:
					throw new DeploymentException(Resources.GetString("Ex_CannotCommitPlatformRequirementsFailed"));
				}
				Logger.AddInternalState(_log, "WaitForAssertApplicationRequirements() returned.");
			}
		}

		private void CheckSizeLimit()
		{
			if (_actDesc.appType == AppType.CustomHostSpecified || _actDesc.Trust == null)
			{
				return;
			}
			bool flag = _actDesc.Trust.DefaultGrantSet.PermissionSet.IsUnrestricted();
			bool flag2 = !_actDesc.DeployManifest.Deployment.Install;
			if (!flag && flag2)
			{
				ulong sizeLimitInBytesForSemiTrustApps = _subStore.GetSizeLimitInBytesForSemiTrustApps();
				if ((ulong)_downloadedAppSize > sizeLimitInBytesForSemiTrustApps)
				{
					throw new DeploymentDownloadException(ExceptionTypes.SizeLimitForPartialTrustOnlineAppExceeded, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_OnlineSemiTrustAppSizeLimitExceeded"), new object[1] { sizeLimitInBytesForSemiTrustApps }));
				}
			}
		}

		private void SynchronizeGroupAsyncWorker(object arg)
		{
			Exception error = null;
			bool cancelled = false;
			string groupName = null;
			object userState = null;
			try
			{
				SyncGroupHelper syncGroupHelper = (SyncGroupHelper)arg;
				groupName = syncGroupHelper.Group;
				userState = syncGroupHelper.UserState;
				cancelled = SynchronizeGroupCore(blocking: false, syncGroupHelper);
			}
			catch (Exception ex)
			{
				if (ExceptionUtility.IsHardException(ex))
				{
					throw;
				}
				if (ex is DownloadCancelledException)
				{
					cancelled = true;
				}
				else
				{
					error = ex;
				}
			}
			finally
			{
				SynchronizeCompletedEventArgs arg2 = new SynchronizeCompletedEventArgs(error, cancelled, userState, groupName);
				asyncOperation.Post(synchronizeCompleted, arg2);
			}
		}

		[PermissionSet(SecurityAction.Assert, Name = "FullTrust")]
		private bool SynchronizeGroupCore(bool blocking, SyncGroupHelper sgh)
		{
			TempDirectory tempDirectory = null;
			try
			{
				string group = sgh.Group;
				SubscriptionState subState = _subStore.GetSubscriptionState(_actDesc.DeployManifest);
				if (_subStore.CheckGroupInstalled(subState, _actDesc.AppId, _actDesc.AppManifest, group))
				{
					return false;
				}
				bool flag = AppDomain.CurrentDomain.ApplicationTrust.DefaultGrantSet.PermissionSet.IsUnrestricted();
				if (!flag && _actDesc.AppManifest.FileAssociations.Length != 0)
				{
					throw new DeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_FileExtensionNotSupported"));
				}
				bool flag2 = !_actDesc.DeployManifest.Deployment.Install;
				if (!flag && flag2)
				{
					if (_downloadOptions == null)
					{
						_downloadOptions = new DownloadOptions();
					}
					_downloadOptions.EnforceSizeLimit = true;
					_downloadOptions.SizeLimit = _subStore.GetSizeLimitInBytesForSemiTrustApps();
					_downloadOptions.Size = _subStore.GetPrivateSize(_actDesc.AppId);
				}
				tempDirectory = _subStore.AcquireTempDirectory();
				DownloadManager.DownloadDependencies(subState, _actDesc.DeployManifest, _actDesc.AppManifest, _actDesc.AppSourceUri, tempDirectory.Path, group, blocking ? null : sgh, _downloadOptions);
				if (!blocking && sgh.CancellationPending)
				{
					return true;
				}
				CommitApplicationParams commitApplicationParams = new CommitApplicationParams(_actDesc);
				commitApplicationParams.CommitApp = true;
				commitApplicationParams.AppPayloadPath = tempDirectory.Path;
				commitApplicationParams.AppManifestPath = null;
				commitApplicationParams.AppGroup = group;
				commitApplicationParams.CommitDeploy = false;
				_subStore.CommitApplication(ref subState, commitApplicationParams);
			}
			finally
			{
				DetachFromGroup(sgh);
				tempDirectory?.Dispose();
			}
			return false;
		}

		private SyncGroupHelper AttachToGroup(string groupName, object userState, out bool created)
		{
			created = false;
			SyncGroupHelper syncGroupHelper = null;
			lock (_syncGroupMap.SyncRoot)
			{
				syncGroupHelper = (SyncGroupHelper)_syncGroupMap[groupName];
				if (syncGroupHelper == null)
				{
					syncGroupHelper = new SyncGroupHelper(groupName, userState, asyncOperation, progressReporter);
					_syncGroupMap[groupName] = syncGroupHelper;
					created = true;
					return syncGroupHelper;
				}
				return syncGroupHelper;
			}
		}

		private void DetachFromGroup(SyncGroupHelper sgh)
		{
			string group = sgh.Group;
			lock (_syncGroupMap.SyncRoot)
			{
				_syncGroupMap.Remove(group);
			}
			sgh.SetComplete();
		}

		private void Dispose(bool disposing)
		{
			if (disposing)
			{
				Logger.EndLogging(_log);
				if (_tempDeployment != null)
				{
					_tempDeployment.Dispose();
				}
				if (_tempApplicationDirectory != null)
				{
					_tempApplicationDirectory.Dispose();
				}
				if (_referenceTransaction != null)
				{
					_referenceTransaction.Close();
				}
				if (_actCtx != null)
				{
					_actCtx.Dispose();
				}
				if (_events != null)
				{
					_events.Dispose();
				}
				if (_trustNotGrantedEvent != null)
				{
					_trustNotGrantedEvent.Close();
				}
				if (_trustGrantedEvent != null)
				{
					_trustGrantedEvent.Close();
				}
				if (_platformRequirementsFailedEvent != null)
				{
					_platformRequirementsFailedEvent.Close();
				}
			}
		}

		private static ActivationContext ConstructActivationContext(ActivationDescription actDesc)
		{
			ApplicationIdentity identity = actDesc.AppId.ToApplicationIdentity();
			return ActivationContext.CreatePartialActivationContext(identity, new string[2] { actDesc.DeployManifestPath, actDesc.AppManifestPath });
		}

		private static ActivationContext ConstructActivationContextFromStore(DefinitionAppId defAppId)
		{
			return ActivationContext.CreatePartialActivationContext(defAppId.ToApplicationIdentity());
		}

		private void LogError(string message, Exception ex)
		{
			Logger.AddErrorInformation(_log, message, ex);
			Logger.FlushLog(_log);
		}
	}
	internal class TrustParams
	{
		private bool noPrompt;

		public bool NoPrompt
		{
			get
			{
				return noPrompt;
			}
			set
			{
				noPrompt = value;
			}
		}
	}
	internal delegate void BindCompletedEventHandler(object sender, BindCompletedEventArgs e);
	internal class BindCompletedEventArgs : AsyncCompletedEventArgs
	{
		private readonly ActivationContext _actCtx;

		private readonly string _name;

		private readonly bool _cached;

		public ActivationContext ActivationContext
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _actCtx;
			}
		}

		public string FriendlyName
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _name;
			}
		}

		public bool IsCached
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _cached;
			}
		}

		internal BindCompletedEventArgs(Exception error, bool cancelled, object userState, ActivationContext actCtx, string name, bool cached)
			: base(error, cancelled, userState)
		{
			_actCtx = actCtx;
			_name = name;
			_cached = cached;
		}
	}
	internal delegate void SynchronizeCompletedEventHandler(object sender, SynchronizeCompletedEventArgs e);
	internal class SynchronizeCompletedEventArgs : AsyncCompletedEventArgs
	{
		private readonly string _groupName;

		public string Group => _groupName;

		internal SynchronizeCompletedEventArgs(Exception error, bool cancelled, object userState, string groupName)
			: base(error, cancelled, userState)
		{
			_groupName = groupName;
		}
	}
	/// <summary>Represents the method that will handle the <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged" /> event, <see cref="E:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged" /> event, or <see cref="E:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged" /> event of an <see cref="T:System.Deployment.Application.ApplicationDeployment" />.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Deployment.Application.DeploymentProgressChangedEventArgs" /> that contains the event data.</param>
	public delegate void DeploymentProgressChangedEventHandler(object sender, DeploymentProgressChangedEventArgs e);
	/// <summary>Represents progress data reported in an asynchronous operation.</summary>
	public class DeploymentProgressChangedEventArgs : ProgressChangedEventArgs
	{
		private readonly long _bytesCompleted;

		private readonly long _bytesTotal;

		private readonly DeploymentProgressState _state;

		private readonly string _groupName;

		/// <summary>Gets the number of bytes already downloaded by this operation.</summary>
		/// <returns>An <see cref="T:System.Int64" /> representing the data already transferred, in bytes.</returns>
		public long BytesCompleted => _bytesCompleted;

		/// <summary>Gets the total number of bytes in the download operation.</summary>
		/// <returns>An <see cref="T:System.Int64" /> representing the total size of the download, in bytes.</returns>
		public long BytesTotal => _bytesTotal;

		/// <summary>Gets the action that the process is currently executing.</summary>
		/// <returns>A <see cref="T:System.Deployment.Application.DeploymentProgressState" /> value, stating what element or elements the operation is currently downloading.</returns>
		public DeploymentProgressState State => _state;

		/// <summary>Gets the name of the file group being downloaded.</summary>
		/// <returns>A <see cref="T:System.String" /> containing the name of the file group, if the event occurred as the result of a call to <see cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />; otherwise, a zero-length string.</returns>
		public string Group => _groupName;

		internal DeploymentProgressChangedEventArgs(int progressPercentage, object userState, long bytesCompleted, long bytesTotal, DeploymentProgressState state, string groupName)
			: base(progressPercentage, userState)
		{
			_bytesCompleted = bytesCompleted;
			_bytesTotal = bytesTotal;
			_state = state;
			_groupName = groupName;
		}
	}
	/// <summary>Specifies the current stage of a ClickOnce download operation.</summary>
	public enum DeploymentProgressState
	{
		/// <summary>ClickOnce is downloading the deployment manifest.</summary>
		DownloadingDeploymentInformation,
		/// <summary>ClickOnce is downloading the application manifest.</summary>
		DownloadingApplicationInformation,
		/// <summary>ClickOnce is downloading the DLLs and data files that comprised the application.</summary>
		DownloadingApplicationFiles
	}
	internal class SyncGroupHelper : IDownloadNotification
	{
		private readonly string groupName;

		private readonly object userState;

		private readonly AsyncOperation asyncOperation;

		private readonly SendOrPostCallback progressReporter;

		private bool _cancellationPending;

		public bool CancellationPending => _cancellationPending;

		public string Group => groupName;

		public object UserState => userState;

		public SyncGroupHelper(string groupName, object userState, AsyncOperation asyncOp, SendOrPostCallback progressReporterDelegate)
		{
			if (groupName == null)
			{
				throw new ArgumentNullException("groupName");
			}
			this.groupName = groupName;
			this.userState = userState;
			asyncOperation = asyncOp;
			progressReporter = progressReporterDelegate;
		}

		public void SetComplete()
		{
		}

		public void CancelAsync()
		{
			_cancellationPending = true;
		}

		public void DownloadModified(object sender, DownloadEventArgs e)
		{
			if (_cancellationPending)
			{
				((FileDownloader)sender).Cancel();
			}
			asyncOperation.Post(progressReporter, new DeploymentProgressChangedEventArgs(e.Progress, userState, e.BytesCompleted, e.BytesTotal, DeploymentProgressState.DownloadingApplicationFiles, groupName));
		}

		public void DownloadCompleted(object sender, DownloadEventArgs e)
		{
		}
	}
	/// <summary>Provides internal services for the ClickOnce deployment API.</summary>
	[StructLayout(LayoutKind.Sequential)]
	[Guid("20FD4E26-8E0F-4F73-A0E0-F27B8C57BE6F")]
	[ClassInterface(ClassInterfaceType.AutoDispatch)]
	[ComVisible(true)]
	[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
	public class DeploymentServiceCom
	{
		/// <summary>Creates a new instance of <see cref="T:System.Deployment.Application.DeploymentServiceCom" />.</summary>
		public DeploymentServiceCom()
		{
			LifetimeManager.ExtendLifetime();
		}

		/// <summary>Starts the deployment on the client computer.</summary>
		/// <param name="deploymentLocation">The location of the deployment manifest on disk.</param>
		/// <param name="isShortcut">Whether <paramref name="deploymentLocation" /> is a shortcut, or the actual file.</param>
		public void ActivateDeployment(string deploymentLocation, bool isShortcut)
		{
			new ApplicationActivator().ActivateDeployment(deploymentLocation, isShortcut);
		}

		/// <summary>Starts the deployment on the client computer.</summary>
		/// <param name="deploymentLocation">The location of the deployment manifest.</param>
		/// <param name="unsignedPolicy">The policy to use for unsigned applications.</param>
		/// <param name="signedPolicy">The policy to use for signed applications.</param>
		public void ActivateDeploymentEx(string deploymentLocation, int unsignedPolicy, int signedPolicy)
		{
			new ApplicationActivator().ActivateDeploymentEx(deploymentLocation, unsignedPolicy, signedPolicy);
		}

		/// <summary>Activates an application extension.</summary>
		/// <param name="textualSubId">The internal ID of the deployment.</param>
		/// <param name="deploymentProviderUrl">The URL of the deployment.</param>
		/// <param name="targetAssociatedFile">The target file.</param>
		public void ActivateApplicationExtension(string textualSubId, string deploymentProviderUrl, string targetAssociatedFile)
		{
			new ApplicationActivator().ActivateApplicationExtension(textualSubId, deploymentProviderUrl, targetAssociatedFile);
		}

		/// <summary>Maintains the update subscription.</summary>
		/// <param name="textualSubId">The internal ID of the deployment.</param>
		public void MaintainSubscription(string textualSubId)
		{
			LifetimeManager.StartOperation();
			try
			{
				MaintainSubscriptionInternal(textualSubId);
			}
			finally
			{
				LifetimeManager.EndOperation();
			}
		}

		/// <summary>Checks the update location to determine whether an updated version of this deployment exists.</summary>
		/// <param name="textualSubId">An internal identifier for the deployment.</param>
		public void CheckForDeploymentUpdate(string textualSubId)
		{
			LifetimeManager.StartOperation();
			try
			{
				CheckForDeploymentUpdateInternal(textualSubId);
			}
			finally
			{
				LifetimeManager.EndOperation();
			}
		}

		/// <summary>Stops a deployment update immediately.</summary>
		public void EndServiceRightNow()
		{
			LifetimeManager.EndImmediately();
		}

		/// <summary>Removes all online-only ClickOnce applications that are installed on a computer.</summary>
		public void CleanOnlineAppCache()
		{
			LifetimeManager.StartOperation();
			try
			{
				CleanOnlineAppCacheInternal();
			}
			finally
			{
				LifetimeManager.EndOperation();
			}
		}

		private void MaintainSubscriptionInternal(string textualSubId)
		{
			bool flag = false;
			string[] array = new string[4] { "Maintain_Exception", "Maintain_Completed", "Maintain_Failed", "Maintain_FailedMsg" };
			bool flag2 = false;
			Exception ex = null;
			bool flag3 = false;
			bool flag4 = false;
			string @string = Resources.GetString("ErrorMessage_GenericLinkUrlMessage");
			string text = null;
			string text2 = null;
			Logger.StartCurrentThreadLogging();
			Logger.SetTextualSubscriptionIdentity(textualSubId);
			using UserInterface userInterface = new UserInterface();
			MaintenanceInfo maintenanceInfo = new MaintenanceInfo();
			try
			{
				UserInterfaceInfo userInterfaceInfo = new UserInterfaceInfo();
				Logger.AddPhaseInformation(Resources.GetString("PhaseLog_StoreQueryForMaintenanceInfo"));
				SubscriptionState subscriptionState = GetSubscriptionState(textualSubId);
				try
				{
					subscriptionState.SubscriptionStore.CheckInstalledAndShellVisible(subscriptionState);
					if (subscriptionState.RollbackDeployment == null)
					{
						maintenanceInfo.maintenanceFlags |= MaintenanceFlags.RemoveSelected;
					}
					else
					{
						maintenanceInfo.maintenanceFlags |= MaintenanceFlags.RestorationPossible;
						maintenanceInfo.maintenanceFlags |= MaintenanceFlags.RestoreSelected;
					}
					AssemblyManifest currentDeploymentManifest = subscriptionState.CurrentDeploymentManifest;
					if (currentDeploymentManifest != null && currentDeploymentManifest.Description != null)
					{
						text2 = currentDeploymentManifest.Description.ErrorReportUrl;
					}
					Description effectiveDescription = subscriptionState.EffectiveDescription;
					userInterfaceInfo.productName = effectiveDescription.Product;
					userInterfaceInfo.supportUrl = effectiveDescription.SupportUrl;
					userInterfaceInfo.formTitle = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("UI_MaintenanceTitle"), new object[1] { userInterfaceInfo.productName });
					flag3 = true;
				}
				catch (DeploymentException exception)
				{
					flag3 = false;
					Logger.AddErrorInformation(Resources.GetString("MaintainLogMsg_FailedStoreLookup"), exception);
					maintenanceInfo.maintenanceFlags |= MaintenanceFlags.RemoveSelected;
				}
				catch (FormatException exception2)
				{
					flag3 = false;
					Logger.AddErrorInformation(Resources.GetString("MaintainLogMsg_FailedStoreLookup"), exception2);
					maintenanceInfo.maintenanceFlags |= MaintenanceFlags.RemoveSelected;
				}
				bool flag5 = false;
				if (flag3)
				{
					if (userInterface.ShowMaintenance(userInterfaceInfo, maintenanceInfo) == UserInterfaceModalResult.Ok)
					{
						flag5 = true;
					}
				}
				else
				{
					maintenanceInfo.maintenanceFlags = MaintenanceFlags.RemoveSelected;
					flag5 = true;
				}
				if (!flag5)
				{
					return;
				}
				flag2 = true;
				if ((maintenanceInfo.maintenanceFlags & MaintenanceFlags.RestoreSelected) != 0)
				{
					array = new string[4] { "Rollback_Exception", "Rollback_Completed", "Rollback_Failed", "Rollback_FailedMsg" };
					subscriptionState.SubscriptionStore.RollbackSubscription(subscriptionState);
					flag2 = false;
					userInterface.ShowMessage(Resources.GetString("UI_RollbackCompletedMsg"), Resources.GetString("UI_RollbackCompletedTitle"));
				}
				else if ((maintenanceInfo.maintenanceFlags & MaintenanceFlags.RemoveSelected) != 0)
				{
					array = new string[4] { "Uninstall_Exception", "Uninstall_Completed", "Uninstall_Failed", "Uninstall_FailedMsg" };
					try
					{
						subscriptionState.SubscriptionStore.UninstallSubscription(subscriptionState);
						flag2 = false;
					}
					catch (DeploymentException exception3)
					{
						Logger.AddErrorInformation(Resources.GetString("MaintainLogMsg_UninstallFailed"), exception3);
						flag4 = true;
						ShellExposure.RemoveSubscriptionShellExposure(subscriptionState);
						flag4 = false;
					}
				}
				flag = true;
			}
			catch (DeploymentException ex2)
			{
				Logger.AddErrorInformation(ex2, Resources.GetString(array[0]), textualSubId);
				ex = ex2;
			}
			finally
			{
				Logger.AddPhaseInformation(Resources.GetString(flag ? array[1] : array[2]), textualSubId);
				if (((maintenanceInfo.maintenanceFlags & MaintenanceFlags.RestoreSelected) != 0 && flag2) || ((maintenanceInfo.maintenanceFlags & MaintenanceFlags.RemoveSelected) != 0 && flag4 && flag2))
				{
					string logFileLocation = Logger.GetLogFilePath();
					if (!Logger.FlushCurrentThreadLogs())
					{
						logFileLocation = null;
					}
					if (text2 != null && ex != null)
					{
						Exception innerMostException = GetInnerMostException(ex);
						text = $"{text2}?outer={ex.GetType().ToString()}&&inner={innerMostException.GetType().ToString()}&&msg={innerMostException.Message}";
						if (text.Length > 2048)
						{
							text = text.Substring(0, 2048);
						}
					}
					userInterface.ShowError(Resources.GetString("UI_MaintenceErrorTitle"), Resources.GetString(array[3]), logFileLocation, text, @string);
				}
				Logger.EndCurrentThreadLogging();
			}
		}

		private void CheckForDeploymentUpdateInternal(string textualSubId)
		{
			bool flag = false;
			Logger.StartCurrentThreadLogging();
			Logger.SetTextualSubscriptionIdentity(textualSubId);
			try
			{
				SubscriptionState shellVisibleSubscriptionState = GetShellVisibleSubscriptionState(textualSubId);
				shellVisibleSubscriptionState.SubscriptionStore.CheckForDeploymentUpdate(shellVisibleSubscriptionState);
				flag = true;
			}
			catch (DeploymentException exception)
			{
				Logger.AddErrorInformation(Resources.GetString("Upd_Exception"), exception);
			}
			finally
			{
				Logger.AddPhaseInformation(Resources.GetString(flag ? "Upd_Completed" : "Upd_Failed"));
				Logger.EndCurrentThreadLogging();
			}
		}

		private void CleanOnlineAppCacheInternal()
		{
			bool flag = false;
			Logger.StartCurrentThreadLogging();
			try
			{
				SubscriptionStore.CurrentUser.CleanOnlineAppCache();
				flag = true;
			}
			catch (Exception exception)
			{
				Logger.AddErrorInformation(Resources.GetString("Ex_CleanOnlineAppCache"), exception);
				throw;
			}
			finally
			{
				Logger.AddPhaseInformation(Resources.GetString(flag ? "CleanOnlineCache_Completed" : "CleanOnlineCache_Failed"));
				Logger.EndCurrentThreadLogging();
			}
		}

		private SubscriptionState GetShellVisibleSubscriptionState(string textualSubId)
		{
			SubscriptionState subscriptionState = GetSubscriptionState(textualSubId);
			subscriptionState.SubscriptionStore.CheckInstalledAndShellVisible(subscriptionState);
			return subscriptionState;
		}

		private SubscriptionState GetSubscriptionState(string textualSubId)
		{
			if (textualSubId == null)
			{
				throw new ArgumentNullException("textualSubId", Resources.GetString("Ex_ComArgSubIdentityNull"));
			}
			DefinitionIdentity definitionIdentity = null;
			try
			{
				definitionIdentity = new DefinitionIdentity(textualSubId);
			}
			catch (COMException innerException)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentCulture, Resources.GetString("Ex_ComArgSubIdentityNotValid"), new object[1] { textualSubId }), innerException);
			}
			catch (SEHException innerException2)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, string.Format(CultureInfo.CurrentCulture, Resources.GetString("Ex_ComArgSubIdentityNotValid"), new object[1] { textualSubId }), innerException2);
			}
			if (definitionIdentity.Version != null)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, Resources.GetString("Ex_ComArgSubIdentityWithVersion"));
			}
			SubscriptionStore currentUser = SubscriptionStore.CurrentUser;
			currentUser.RefreshStorePointer();
			return currentUser.GetSubscriptionState(definitionIdentity);
		}

		private Exception GetInnerMostException(Exception exception)
		{
			if (exception.InnerException != null)
			{
				return GetInnerMostException(exception.InnerException);
			}
			return exception;
		}
	}
	[ComImport]
	[Guid("B3CA4E79-0107-4CA7-9708-3BE0A97957FB")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IManagedDeploymentServiceCom
	{
		void ActivateDeployment(string deploymentLocation, bool isShortcut);

		void ActivateDeploymentEx(string deploymentLocation, int unsignedPolicy, int signedPolicy);

		void ActivateApplicationExtension(string textualSubId, string deploymentProviderUrl, string targetAssociatedFile);

		void MaintainSubscription(string textualSubId);

		void CheckForDeploymentUpdate(string textualSubId);

		void EndServiceRightNow();

		void CleanOnlineAppCache();
	}
	internal class DeploymentServiceComWrapper : IManagedDeploymentServiceCom
	{
		private DeploymentServiceCom m_deploymentServiceCom;

		public DeploymentServiceComWrapper()
		{
			m_deploymentServiceCom = new DeploymentServiceCom();
		}

		public void ActivateApplicationExtension(string textualSubId, string deploymentProviderUrl, string targetAssociatedFile)
		{
			m_deploymentServiceCom.ActivateApplicationExtension(textualSubId, deploymentProviderUrl, targetAssociatedFile);
		}

		public void ActivateDeployment(string deploymentLocation, bool isShortcut)
		{
			m_deploymentServiceCom.ActivateDeployment(deploymentLocation, isShortcut);
		}

		public void ActivateDeploymentEx(string deploymentLocation, int unsignedPolicy, int signedPolicy)
		{
			m_deploymentServiceCom.ActivateDeploymentEx(deploymentLocation, unsignedPolicy, signedPolicy);
		}

		public void CheckForDeploymentUpdate(string textualSubId)
		{
			m_deploymentServiceCom.CheckForDeploymentUpdate(textualSubId);
		}

		public void CleanOnlineAppCache()
		{
			m_deploymentServiceCom.CleanOnlineAppCache();
		}

		public void EndServiceRightNow()
		{
			m_deploymentServiceCom.EndServiceRightNow();
		}

		public void MaintainSubscription(string textualSubId)
		{
			m_deploymentServiceCom.MaintainSubscription(textualSubId);
		}
	}
	internal abstract class DisposableBase : IDisposable
	{
		private bool _disposed;

		public DisposableBase()
		{
		}

		~DisposableBase()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!_disposed)
			{
				if (disposing)
				{
					DisposeManagedResources();
				}
				DisposeUnmanagedResources();
			}
			_disposed = true;
		}

		protected virtual void DisposeManagedResources()
		{
		}

		protected virtual void DisposeUnmanagedResources()
		{
		}
	}
	internal static class DownloadManager
	{
		private class DependencyDownloadCookie
		{
			public readonly object ManifestElement;

			public readonly AssemblyManifest DeployManifest;

			public readonly AssemblyManifest AppManifest;

			public DependencyDownloadCookie(object manifestElement, AssemblyManifest deployManifest, AssemblyManifest appManifest)
			{
				ManifestElement = manifestElement;
				DeployManifest = deployManifest;
				AppManifest = appManifest;
			}
		}

		private static X509Certificate2 ClientCertificate;

		public static AssemblyManifest DownloadDeploymentManifest(SubscriptionStore subStore, ref Uri sourceUri, out TempFile tempFile)
		{
			return DownloadDeploymentManifest(subStore, ref sourceUri, out tempFile, null, null);
		}

		public static AssemblyManifest DownloadDeploymentManifest(SubscriptionStore subStore, ref Uri sourceUri, out TempFile tempFile, IDownloadNotification notification, DownloadOptions options)
		{
			Logger.AddMethodCall("DownloadDeploymentManifest called.");
			Logger.AddInternalState("SourceUri=" + sourceUri);
			Logger.AddInternalState("DownloadOptions=" + ((options != null) ? options.ToString() : "null"));
			tempFile = null;
			TempFile tempFile2 = null;
			TempFile tempFile3 = null;
			ClientCertificate = null;
			try
			{
				ServerInformation serverInformation;
				AssemblyManifest deployment = DownloadDeploymentManifestDirect(subStore, ref sourceUri, out tempFile2, notification, options, out serverInformation);
				Logger.SetSubscriptionServerInformation(serverInformation);
				bool flag = FollowDeploymentProviderUri(subStore, ref deployment, ref sourceUri, out tempFile3, notification, options);
				tempFile = (flag ? tempFile3 : tempFile2);
				return deployment;
			}
			finally
			{
				if (tempFile2 != null && tempFile2 != tempFile)
				{
					tempFile2.Dispose();
					tempFile2 = null;
				}
				if (tempFile3 != null && tempFile3 != tempFile)
				{
					tempFile3.Dispose();
					tempFile3 = null;
				}
			}
		}

		public static bool FollowDeploymentProviderUri(SubscriptionStore subStore, ref AssemblyManifest deployment, ref Uri sourceUri, out TempFile tempFile, IDownloadNotification notification, DownloadOptions options)
		{
			Logger.AddMethodCall("FollowDeploymentProviderUri called.");
			tempFile = null;
			bool flag = false;
			Zone zone = Zone.CreateFromUrl(sourceUri.AbsoluteUri);
			bool flag2 = false;
			if (zone.SecurityZone != 0)
			{
				Logger.AddInternalState("Deployment manifest zone is not local machine. Zone = " + zone.SecurityZone);
				flag2 = true;
			}
			else
			{
				Logger.AddInternalState("Deployment manifest zone is local machine. Zone = " + zone.SecurityZone);
				DependentAssembly mainDependentAssembly = deployment.MainDependentAssembly;
				if (mainDependentAssembly == null || mainDependentAssembly.Codebase == null)
				{
					throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_NoAppInDeploymentManifest"));
				}
				Uri uri = new Uri(sourceUri, mainDependentAssembly.Codebase);
				Zone zone2 = Zone.CreateFromUrl(uri.AbsoluteUri);
				if (zone2.SecurityZone == SecurityZone.MyComputer)
				{
					Logger.AddInternalState("Application manifest zone is local machine. Zone = " + zone2.SecurityZone);
					if (!System.IO.File.Exists(uri.LocalPath))
					{
						Logger.AddInternalState(uri.LocalPath + " does not exist in local machine.");
						flag2 = true;
					}
				}
			}
			if (flag2)
			{
				Uri sourceUri2 = deployment.Deployment.ProviderCodebaseUri;
				Logger.SetDeploymentProviderUrl(sourceUri2);
				Logger.AddInternalState("providerUri=" + sourceUri2?.ToString() + ",sourceUri=" + sourceUri);
				if (!PolicyKeys.SkipDeploymentProvider() && sourceUri2 != null && !sourceUri2.Equals(sourceUri))
				{
					AssemblyManifest assemblyManifest = null;
					ServerInformation serverInformation;
					try
					{
						assemblyManifest = DownloadDeploymentManifestDirect(subStore, ref sourceUri2, out tempFile, notification, options, out serverInformation);
					}
					catch (InvalidDeploymentException ex)
					{
						if (ex.SubType == ExceptionTypes.Manifest || ex.SubType == ExceptionTypes.ManifestLoad || ex.SubType == ExceptionTypes.ManifestParse || ex.SubType == ExceptionTypes.ManifestSemanticValidation)
						{
							throw new InvalidDeploymentException(ExceptionTypes.Manifest, Resources.GetString("Ex_InvalidProviderManifest"), ex);
						}
						throw;
					}
					Logger.SetDeploymentProviderServerInformation(serverInformation);
					SubscriptionState subscriptionState = subStore.GetSubscriptionState(deployment);
					SubscriptionState subscriptionState2 = subStore.GetSubscriptionState(assemblyManifest);
					if (!subscriptionState2.SubscriptionId.Equals(subscriptionState.SubscriptionId))
					{
						throw new InvalidDeploymentException(ExceptionTypes.SubscriptionSemanticValidation, Resources.GetString("Ex_ProviderNotInSubscription"));
					}
					Logger.AddInternalState("Deployment provider followed: " + sourceUri2);
					deployment = assemblyManifest;
					sourceUri = sourceUri2;
					flag = true;
				}
			}
			if (!flag)
			{
				Logger.AddInternalState("Deployment provider not followed.");
			}
			return flag;
		}

		public static AssemblyManifest DownloadDeploymentManifestBypass(SubscriptionStore subStore, ref Uri sourceUri, out TempFile tempFile, out SubscriptionState subState, IDownloadNotification notification, DownloadOptions options)
		{
			Logger.AddMethodCall("DownloadDeploymentManifestBypass called.");
			tempFile = null;
			subState = null;
			TempFile tempFile2 = null;
			TempFile tempFile3 = null;
			ClientCertificate = null;
			try
			{
				ServerInformation serverInformation;
				AssemblyManifest deployment = DownloadDeploymentManifestDirectBypass(subStore, ref sourceUri, out tempFile2, out subState, notification, options, out serverInformation);
				Logger.SetSubscriptionServerInformation(serverInformation);
				if (subState != null)
				{
					tempFile = tempFile2;
					return deployment;
				}
				bool flag = FollowDeploymentProviderUri(subStore, ref deployment, ref sourceUri, out tempFile3, notification, options);
				tempFile = (flag ? tempFile3 : tempFile2);
				return deployment;
			}
			finally
			{
				if (tempFile2 != null && tempFile2 != tempFile)
				{
					tempFile2.Dispose();
				}
				if (tempFile3 != null && tempFile3 != tempFile)
				{
					tempFile3.Dispose();
				}
			}
		}

		public static AssemblyManifest DownloadApplicationManifest(AssemblyManifest deploymentManifest, string targetDir, Uri deploymentUri, out Uri appSourceUri, out string appManifestPath)
		{
			return DownloadApplicationManifest(deploymentManifest, targetDir, deploymentUri, null, null, out appSourceUri, out appManifestPath);
		}

		public static AssemblyManifest DownloadApplicationManifest(AssemblyManifest deploymentManifest, string targetDir, Uri deploymentUri, IDownloadNotification notification, DownloadOptions options, out Uri appSourceUri, out string appManifestPath)
		{
			Logger.AddMethodCall("DownloadApplicationManifest called.");
			DependentAssembly mainDependentAssembly = deploymentManifest.MainDependentAssembly;
			if (mainDependentAssembly == null || mainDependentAssembly.Codebase == null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_NoAppInDeploymentManifest"));
			}
			appSourceUri = new Uri(deploymentUri, mainDependentAssembly.Codebase);
			Zone zone = Zone.CreateFromUrl(deploymentUri.AbsoluteUri);
			Zone zone2 = Zone.CreateFromUrl(appSourceUri.AbsoluteUri);
			if (!zone.Equals(zone2))
			{
				Logger.AddInternalState("Deployment and application does not have matching security zones. deploymentZone=" + zone?.ToString() + ",applicationZone=" + zone2);
				throw new InvalidDeploymentException(ExceptionTypes.Zone, Resources.GetString("Ex_DeployAppZoneMismatch"));
			}
			appManifestPath = Path.Combine(targetDir, mainDependentAssembly.Identity.Name + ".manifest");
			ServerInformation serverInformation;
			AssemblyManifest assemblyManifest = DownloadManifest(ref appSourceUri, appManifestPath, notification, options, AssemblyManifest.ManifestType.Application, out serverInformation);
			Logger.SetApplicationUrl(appSourceUri);
			Logger.SetApplicationServerInformation(serverInformation);
			zone2 = Zone.CreateFromUrl(appSourceUri.AbsoluteUri);
			if (!zone.Equals(zone2))
			{
				Logger.AddInternalState("Deployment and application does not have matching security zones. deploymentZone=" + zone?.ToString() + ",applicationZone=" + zone2);
				throw new InvalidDeploymentException(ExceptionTypes.Zone, Resources.GetString("Ex_DeployAppZoneMismatch"));
			}
			if (assemblyManifest.Identity.Equals(deploymentManifest.Identity))
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DepSameDeploymentAndApplicationIdentity"), new object[1] { assemblyManifest.Identity.ToString() }));
			}
			if (!assemblyManifest.Identity.Matches(mainDependentAssembly.Identity, assemblyManifest.Application))
			{
				throw new InvalidDeploymentException(ExceptionTypes.SubscriptionSemanticValidation, Resources.GetString("Ex_RefDefMismatch"));
			}
			if (!PolicyKeys.SkipApplicationDependencyHashCheck())
			{
				try
				{
					ComponentVerifier.VerifyFileHash(appManifestPath, mainDependentAssembly.HashCollection);
				}
				catch (InvalidDeploymentException ex)
				{
					if (ex.SubType == ExceptionTypes.HashValidation)
					{
						throw new InvalidDeploymentException(ExceptionTypes.HashValidation, Resources.GetString("Ex_AppManInvalidHash"), ex);
					}
					throw;
				}
			}
			if (assemblyManifest.RequestedExecutionLevel != null)
			{
				Logger.AddInternalState("Application manifest has RequestedExecutionLevel specified. Check requested privileges.");
				VerifyRequestedPrivilegesSupport(assemblyManifest.RequestedExecutionLevel);
			}
			return assemblyManifest;
		}

		public static void DownloadDependencies(SubscriptionState subState, AssemblyManifest deployManifest, AssemblyManifest appManifest, Uri sourceUriBase, string targetDirectory, string group, IDownloadNotification notification, DownloadOptions options)
		{
			Logger.AddMethodCall("DownloadDependencies called.");
			Logger.AddInternalState("sourceUriBase=" + sourceUriBase);
			Logger.AddInternalState("targetDirectory=" + targetDirectory);
			Logger.AddInternalState("group=" + group);
			Logger.AddInternalState("DownloadOptions=" + options);
			FileDownloader fileDownloader = FileDownloader.Create();
			fileDownloader.Options = options;
			if (group == null)
			{
				fileDownloader.CheckForSizeLimit(appManifest.CalculateDependenciesSize(), addToSize: false);
			}
			AddDependencies(fileDownloader, deployManifest, appManifest, sourceUriBase, targetDirectory, group);
			fileDownloader.DownloadModified += ProcessDownloadedFile;
			if (notification != null)
			{
				fileDownloader.AddNotification(notification);
			}
			try
			{
				fileDownloader.Download(subState, ClientCertificate);
				fileDownloader.ComponentVerifier.VerifyComponents();
				VerifyRequestedPrivilegesSupport(appManifest, targetDirectory);
			}
			finally
			{
				if (notification != null)
				{
					fileDownloader.RemoveNotification(notification);
				}
				fileDownloader.DownloadModified -= ProcessDownloadedFile;
			}
		}

		private static void VerifyRequestedPrivilegesSupport(AssemblyManifest appManifest, string targetDirectory)
		{
			if (appManifest.EntryPoints[0].CustomHostSpecified)
			{
				return;
			}
			string text = Path.Combine(targetDirectory, appManifest.EntryPoints[0].Assembly.Codebase);
			if (System.IO.File.Exists(text))
			{
				AssemblyManifest assemblyManifest = new AssemblyManifest(text);
				if (assemblyManifest.Id1ManifestPresent && assemblyManifest.Id1RequestedExecutionLevel != null)
				{
					VerifyRequestedPrivilegesSupport(assemblyManifest.Id1RequestedExecutionLevel);
				}
			}
			else
			{
				Logger.AddInternalState("Main exe=" + text + " does not exist. No Requested Priviliges Verification done.");
			}
		}

		private static void VerifyRequestedPrivilegesSupport(string requestedExecutionLevel)
		{
			Logger.AddMethodCall("VerifyRequestedPrivilegesSupport(" + requestedExecutionLevel + ") called.");
			if (!PlatformSpecific.OnVistaOrAbove)
			{
				return;
			}
			bool flag = false;
			RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System");
			if (registryKey != null && registryKey.GetValue("EnableLUA") != null)
			{
				Logger.AddInternalState("LUA policy key = " + registryKey.Name);
				if ((int)registryKey.GetValue("EnableLUA") != 0)
				{
					flag = true;
					Logger.AddInternalState("LUA is enabled.");
				}
			}
			if (flag && (string.Compare(requestedExecutionLevel, "requireAdministrator", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(requestedExecutionLevel, "highestAvailable", StringComparison.OrdinalIgnoreCase) == 0))
			{
				throw new InvalidDeploymentException(ExceptionTypes.UnsupportedElevetaionRequest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestExecutionLevelNotSupported")));
			}
		}

		private static AssemblyManifest DownloadDeploymentManifestDirect(SubscriptionStore subStore, ref Uri sourceUri, out TempFile tempFile, IDownloadNotification notification, DownloadOptions options, out ServerInformation serverInformation)
		{
			Logger.AddMethodCall("DownloadDeploymentManifestDirect(" + sourceUri?.ToString() + ") called.");
			tempFile = subStore.AcquireTempFile(".application");
			AssemblyManifest assemblyManifest = DownloadManifest(ref sourceUri, tempFile.Path, notification, options, AssemblyManifest.ManifestType.Deployment, out serverInformation);
			if (assemblyManifest.Identity.Version == null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_DeploymentManifestNoVersion"));
			}
			if (assemblyManifest.Deployment == null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_InvalidDeploymentManifest"));
			}
			return assemblyManifest;
		}

		private static AssemblyManifest DownloadDeploymentManifestDirectBypass(SubscriptionStore subStore, ref Uri sourceUri, out TempFile tempFile, out SubscriptionState subState, IDownloadNotification notification, DownloadOptions options, out ServerInformation serverInformation)
		{
			Logger.AddMethodCall("DownloadDeploymentManifestDirectBypass called.");
			subState = null;
			tempFile = subStore.AcquireTempFile(".application");
			DownloadManifestAsRawFile(ref sourceUri, tempFile.Path, notification, options, out serverInformation);
			bool flag = false;
			AssemblyManifest assemblyManifest = null;
			DefinitionIdentity definitionIdentity = null;
			DefinitionIdentity definitionIdentity2 = null;
			DefinitionAppId definitionAppId = null;
			try
			{
				assemblyManifest = ManifestReader.FromDocumentNoValidation(tempFile.Path);
				definitionIdentity = assemblyManifest.Identity;
				definitionIdentity2 = new DefinitionIdentity(assemblyManifest.MainDependentAssembly.Identity);
				Uri uri = ((sourceUri.Query != null && sourceUri.Query.Length > 0) ? new Uri(sourceUri.GetLeftPart(UriPartial.Path)) : sourceUri);
				definitionAppId = new DefinitionAppId(uri.AbsoluteUri, definitionIdentity, definitionIdentity2);
				Logger.AddInternalState("expectedAppId=" + definitionAppId.ToString());
			}
			catch (InvalidDeploymentException)
			{
				flag = true;
			}
			catch (COMException)
			{
				flag = true;
			}
			catch (SEHException)
			{
				flag = true;
			}
			catch (IndexOutOfRangeException)
			{
				flag = true;
			}
			if (!flag)
			{
				SubscriptionState subscriptionState = subStore.GetSubscriptionState(assemblyManifest);
				bool flag2 = false;
				long transactionId;
				using (subStore.AcquireReferenceTransaction(out transactionId))
				{
					flag2 = subStore.CheckAndReferenceApplication(subscriptionState, definitionAppId, transactionId);
				}
				if (flag2 && definitionAppId.Equals(subscriptionState.CurrentBind))
				{
					Logger.AddInternalState("Application is found in store and it is the CurrentBind, bypass validation and further downloads.");
					subState = subscriptionState;
					return subState.CurrentDeploymentManifest;
				}
				flag = true;
				if (flag2)
				{
					Logger.AddInternalState("Application is found in store and but it is not the CurrentBind.");
				}
			}
			else
			{
				Logger.AddInternalState("Application is not found in store.");
			}
			Logger.AddInternalState("Reparse the deployment manifest for validations.");
			AssemblyManifest assemblyManifest2 = ManifestReader.FromDocument(tempFile.Path, AssemblyManifest.ManifestType.Deployment, sourceUri);
			if (assemblyManifest2.Identity.Version == null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_DeploymentManifestNoVersion"));
			}
			if (assemblyManifest2.Deployment == null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_InvalidDeploymentManifest"));
			}
			return assemblyManifest2;
		}

		private static AssemblyManifest DownloadManifest(ref Uri sourceUri, string targetPath, IDownloadNotification notification, DownloadOptions options, AssemblyManifest.ManifestType manifestType, out ServerInformation serverInformation)
		{
			Logger.AddMethodCall("DownloadManifest called.");
			DownloadManifestAsRawFile(ref sourceUri, targetPath, notification, options, out serverInformation);
			return ManifestReader.FromDocument(targetPath, manifestType, sourceUri);
		}

		private static void DownloadManifestAsRawFile(ref Uri sourceUri, string targetPath, IDownloadNotification notification, DownloadOptions options, out ServerInformation serverInformation)
		{
			Logger.AddMethodCall("DownloadManifestAsRawFile called.");
			FileDownloader fileDownloader = FileDownloader.Create();
			fileDownloader.Options = options;
			if (notification != null)
			{
				fileDownloader.AddNotification(notification);
			}
			try
			{
				fileDownloader.AddFile(sourceUri, targetPath, 16777216);
				fileDownloader.Download(null, ClientCertificate);
				sourceUri = fileDownloader.DownloadResults[0].ResponseUri;
				serverInformation = fileDownloader.DownloadResults[0].ServerInformation;
				ClientCertificate = fileDownloader.ClientCertificate;
			}
			finally
			{
				if (notification != null)
				{
					fileDownloader.RemoveNotification(notification);
				}
			}
		}

		private static void AddDependencies(FileDownloader downloader, AssemblyManifest deployManifest, AssemblyManifest appManifest, Uri sourceUriBase, string targetDirectory, string group)
		{
			long num = 0L;
			System.Deployment.Application.Manifest.File[] filesInGroup = appManifest.GetFilesInGroup(group, optionalOnly: true);
			ReorderFilesForIconFile(appManifest, filesInGroup);
			System.Deployment.Application.Manifest.File[] array = filesInGroup;
			foreach (System.Deployment.Application.Manifest.File file in array)
			{
				Uri fileSourceUri = MapFileSourceUri(deployManifest, sourceUriBase, file.Name);
				AddFileToDownloader(downloader, deployManifest, appManifest, file, fileSourceUri, targetDirectory, file.NameFS, file.HashCollection);
				num += (long)file.Size;
			}
			DependentAssembly[] privateAssembliesInGroup = appManifest.GetPrivateAssembliesInGroup(group, optionalOnly: true);
			DependentAssembly[] array2 = privateAssembliesInGroup;
			foreach (DependentAssembly dependentAssembly in array2)
			{
				Uri fileSourceUri = MapFileSourceUri(deployManifest, sourceUriBase, dependentAssembly.Codebase);
				AddFileToDownloader(downloader, deployManifest, appManifest, dependentAssembly, fileSourceUri, targetDirectory, dependentAssembly.CodebaseFS, dependentAssembly.HashCollection);
				num += (long)dependentAssembly.Size;
			}
			downloader.SetExpectedBytesTotal(num);
			if (filesInGroup.Length == 0 && privateAssembliesInGroup.Length == 0)
			{
				throw new InvalidDeploymentException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_NoSuchDownloadGroup"), new object[1] { group }));
			}
		}

		private static Uri MapFileSourceUri(AssemblyManifest deployManifest, Uri sourceUriBase, string fileName)
		{
			return UriHelper.UriFromRelativeFilePath(sourceUriBase, deployManifest.Deployment.MapFileExtensions ? (fileName + ".deploy") : fileName);
		}

		private static void AddFileToDownloader(FileDownloader downloader, AssemblyManifest deployManifest, AssemblyManifest appManifest, object manifestElement, Uri fileSourceUri, string targetDirectory, string targetFileName, HashCollection hashCollection)
		{
			string targetFilePath = Path.Combine(targetDirectory, targetFileName);
			DependencyDownloadCookie cookie = new DependencyDownloadCookie(manifestElement, deployManifest, appManifest);
			downloader.AddFile(fileSourceUri, targetFilePath, cookie, hashCollection);
		}

		private static void ProcessDownloadedFile(object sender, DownloadEventArgs e)
		{
			if (e.Cookie == null)
			{
				return;
			}
			string fileName = Path.GetFileName(e.FileLocalPath);
			FileDownloader fileDownloader = (FileDownloader)sender;
			if (e.FileResponseUri != null && !e.FileResponseUri.Equals(e.FileSourceUri))
			{
				throw new InvalidDeploymentException(ExceptionTypes.AppFileLocationValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DownloadAppFileAsmRedirected"), new object[1] { fileName }));
			}
			DependencyDownloadCookie dependencyDownloadCookie = (DependencyDownloadCookie)e.Cookie;
			if (dependencyDownloadCookie.ManifestElement is DependentAssembly)
			{
				DependentAssembly dependentAssembly = (DependentAssembly)dependencyDownloadCookie.ManifestElement;
				AssemblyManifest deployManifest = dependencyDownloadCookie.DeployManifest;
				AssemblyManifest appManifest = dependencyDownloadCookie.AppManifest;
				AssemblyManifest assemblyManifest = new AssemblyManifest(e.FileLocalPath);
				if (!assemblyManifest.Identity.Matches(dependentAssembly.Identity, exact: true))
				{
					throw new InvalidDeploymentException(ExceptionTypes.RefDefValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DownloadRefDefMismatch"), new object[1] { fileName }));
				}
				if (assemblyManifest.Identity.Equals(deployManifest.Identity) || assemblyManifest.Identity.Equals(appManifest.Identity))
				{
					throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_AppPrivAsmIdSameAsDeployOrApp"), new object[1] { assemblyManifest.Identity.ToString() }));
				}
				System.Deployment.Application.Manifest.File[] files = assemblyManifest.Files;
				for (int i = 0; i < files.Length; i++)
				{
					Uri uri = MapFileSourceUri(deployManifest, e.FileSourceUri, files[i].Name);
					if (!uri.AbsoluteUri.Equals(e.FileSourceUri.AbsoluteUri, StringComparison.OrdinalIgnoreCase))
					{
						string directoryName = Path.GetDirectoryName(e.FileLocalPath);
						AddFileToDownloader(fileDownloader, deployManifest, appManifest, files[i], uri, directoryName, files[i].NameFS, files[i].HashCollection);
					}
				}
				fileDownloader.ComponentVerifier.AddFileForVerification(e.FileLocalPath, dependentAssembly.HashCollection);
				if (assemblyManifest.Identity.PublicKeyToken == null)
				{
					fileDownloader.ComponentVerifier.AddSimplyNamedAssemblyForVerification(e.FileLocalPath, assemblyManifest);
				}
				else
				{
					fileDownloader.ComponentVerifier.AddStrongNameAssemblyForVerification(e.FileLocalPath, assemblyManifest);
				}
			}
			else if (dependencyDownloadCookie.ManifestElement is System.Deployment.Application.Manifest.File)
			{
				System.Deployment.Application.Manifest.File file = (System.Deployment.Application.Manifest.File)dependencyDownloadCookie.ManifestElement;
				fileDownloader.ComponentVerifier.AddFileForVerification(e.FileLocalPath, file.HashCollection);
			}
		}

		private static void ReorderFilesForIconFile(AssemblyManifest manifest, System.Deployment.Application.Manifest.File[] files)
		{
			if (manifest.Description == null || manifest.Description.IconFile == null)
			{
				return;
			}
			for (int i = 0; i < files.Length; i++)
			{
				if (string.Compare(files[i].NameFS, manifest.Description.IconFileFS, StringComparison.OrdinalIgnoreCase) == 0)
				{
					if (i != 0)
					{
						System.Deployment.Application.Manifest.File file = files[0];
						files[0] = files[i];
						files[i] = file;
					}
					break;
				}
			}
		}
	}
	internal class ErrorPiece : ModalPiece
	{
		private Label lblMessage;

		private PictureBox pictureIcon;

		private Button btnOk;

		private Button btnSupport;

		private TableLayoutPanel okDetailsTableLayoutPanel;

		private TableLayoutPanel overarchingTableLayoutPanel;

		private LinkLabel errorLink;

		private string _errorMessage;

		private string _logFileLocation;

		private string _linkUrl;

		private string _linkUrlMessage;

		public ErrorPiece(UserInterfaceForm parentForm, string errorTitle, string errorMessage, string logFileLocation, string linkUrl, string linkUrlMessage, ManualResetEvent modalEvent)
		{
			_errorMessage = errorMessage;
			_logFileLocation = logFileLocation;
			_linkUrl = linkUrl;
			_linkUrlMessage = linkUrlMessage;
			_modalResult = UserInterfaceModalResult.Ok;
			_modalEvent = modalEvent;
			SuspendLayout();
			InitializeComponent();
			InitializeContent();
			ResumeLayout(performLayout: false);
			parentForm.SuspendLayout();
			parentForm.SwitchUserInterfacePiece(this);
			parentForm.Text = errorTitle;
			parentForm.MinimizeBox = false;
			parentForm.MaximizeBox = false;
			parentForm.ControlBox = true;
			parentForm.ActiveControl = btnOk;
			parentForm.ResumeLayout(performLayout: false);
			parentForm.PerformLayout();
			parentForm.Visible = true;
			if (Form.ActiveForm != parentForm)
			{
				parentForm.Activate();
			}
		}

		private void InitializeComponent()
		{
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(System.Deployment.Application.ErrorPiece));
			this.lblMessage = new System.Windows.Forms.Label();
			this.pictureIcon = new System.Windows.Forms.PictureBox();
			this.btnOk = new System.Windows.Forms.Button();
			this.btnSupport = new System.Windows.Forms.Button();
			this.okDetailsTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.overarchingTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.errorLink = new System.Windows.Forms.LinkLabel();
			((System.ComponentModel.ISupportInitialize)this.pictureIcon).BeginInit();
			this.okDetailsTableLayoutPanel.SuspendLayout();
			this.overarchingTableLayoutPanel.SuspendLayout();
			base.SuspendLayout();
			resources.ApplyResources(this.lblMessage, "lblMessage");
			this.lblMessage.Name = "lblMessage";
			this.lblMessage.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits32 + System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits6, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			resources.ApplyResources(this.pictureIcon, "pictureIcon");
			this.pictureIcon.Name = "pictureIcon";
			this.pictureIcon.TabStop = false;
			this.pictureIcon.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits32 + System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits32 + System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3);
			this.pictureIcon.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			this.pictureIcon.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			resources.ApplyResources(this.btnOk, "btnOk");
			this.btnOk.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits78, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits28);
			this.btnOk.Name = "btnOk";
			this.btnOk.Click += new System.EventHandler(btnOk_Click);
			this.btnOk.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			resources.ApplyResources(this.btnSupport, "btnSupport");
			this.btnSupport.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits78, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits28);
			this.btnSupport.Name = "btnSupport";
			this.btnSupport.Click += new System.EventHandler(btnSupport_Click);
			this.btnSupport.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			resources.ApplyResources(this.okDetailsTableLayoutPanel, "okDetailsTableLayoutPanel");
			this.overarchingTableLayoutPanel.SetColumnSpan(this.okDetailsTableLayoutPanel, 2);
			this.okDetailsTableLayoutPanel.Controls.Add(this.btnOk, 0, 0);
			this.okDetailsTableLayoutPanel.Controls.Add(this.btnSupport, 1, 0);
			this.okDetailsTableLayoutPanel.Name = "okDetailsTableLayoutPanel";
			resources.ApplyResources(this.overarchingTableLayoutPanel, "overarchingTableLayoutPanel");
			this.overarchingTableLayoutPanel.Controls.Add(this.pictureIcon, 0, 0);
			this.overarchingTableLayoutPanel.Controls.Add(this.lblMessage, 1, 0);
			this.overarchingTableLayoutPanel.Controls.Add(this.errorLink, 1, 1);
			this.overarchingTableLayoutPanel.Controls.Add(this.okDetailsTableLayoutPanel, 0, 2);
			this.overarchingTableLayoutPanel.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits466, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits32);
			this.overarchingTableLayoutPanel.Name = "overarchingTableLayoutPanel";
			this.overarchingTableLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;
			resources.ApplyResources(this.errorLink, "errorLink");
			this.errorLink.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits280, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits32);
			this.errorLink.Name = "errorLink";
			this.errorLink.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(errorLink_LinkClicked);
			resources.ApplyResources(this, "$this");
			base.Controls.Add(this.overarchingTableLayoutPanel);
			base.Name = "ErrorPiece";
			((System.ComponentModel.ISupportInitialize)this.pictureIcon).EndInit();
			this.okDetailsTableLayoutPanel.ResumeLayout(false);
			this.okDetailsTableLayoutPanel.PerformLayout();
			this.overarchingTableLayoutPanel.ResumeLayout(false);
			this.overarchingTableLayoutPanel.PerformLayout();
			base.ResumeLayout(false);
			base.PerformLayout();
		}

		private void InitializeContent()
		{
			pictureIcon.Image = Resources.GetIcon("information.ico").ToBitmap();
			lblMessage.Text = _errorMessage;
			if (_linkUrl != null && _linkUrlMessage != null)
			{
				string @string = Resources.GetString("UI_ErrorClickHereHere");
				errorLink.Text = _linkUrlMessage;
				int start = _linkUrlMessage.LastIndexOf(@string, StringComparison.Ordinal);
				errorLink.Links.Add(start, @string.Length, _linkUrl);
			}
			else
			{
				errorLink.Text = string.Empty;
				errorLink.Links.Clear();
			}
			if (_logFileLocation == null)
			{
				btnSupport.Enabled = false;
			}
		}

		private void errorLink_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			errorLink.Links[errorLink.Links.IndexOf(e.Link)].Visited = true;
			if (_linkUrl != null && UserInterface.IsValidHttpUrl(_linkUrl))
			{
				UserInterface.LaunchUrlInBrowser(e.Link.LinkData.ToString());
			}
		}

		private void btnOk_Click(object sender, EventArgs e)
		{
			_modalResult = UserInterfaceModalResult.Ok;
			_modalEvent.Set();
			base.Enabled = false;
		}

		private void btnSupport_Click(object sender, EventArgs e)
		{
			try
			{
				Process.Start("notepad.exe", _logFileLocation);
			}
			catch (Win32Exception)
			{
			}
		}
	}
	internal enum ExceptionTypes
	{
		Unknown,
		Activation,
		ComponentStore,
		ActivationInProgress,
		InvalidShortcut,
		InvalidARPEntry,
		LockTimeout,
		Subscription,
		SubscriptionState,
		ActivationLimitExceeded,
		DiskIsFull,
		GroupMultipleMatch,
		InvalidManifest,
		Manifest,
		ManifestLoad,
		ManifestParse,
		ManifestSemanticValidation,
		ManifestComponentSemanticValidation,
		UnsupportedElevetaionRequest,
		SubscriptionSemanticValidation,
		UriSchemeNotSupported,
		Zone,
		DeploymentUriDifferent,
		SizeLimitForPartialTrustOnlineAppExceeded,
		Validation,
		HashValidation,
		SignatureValidation,
		RefDefValidation,
		ClrValidation,
		StronglyNamedAssemblyVerification,
		IdentityMatchValidationForMixedModeAssembly,
		AppFileLocationValidation,
		FileSizeValidation,
		TrustFailDependentPlatform
	}
	/// <summary>Defines a base class for all deployment-related exceptions.</summary>
	[Serializable]
	public class DeploymentException : SystemException
	{
		private ExceptionTypes _type;

		internal ExceptionTypes SubType => _type;

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DeploymentException" /> class.</summary>
		public DeploymentException()
			: this(Resources.GetString("Ex_DeploymentException"))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DeploymentException" /> class.</summary>
		/// <param name="message">Represents text as a series of Unicode characters.</param>
		public DeploymentException(string message)
			: base(message)
		{
			_type = ExceptionTypes.Unknown;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DeploymentException" /> class.</summary>
		/// <param name="message">Represents text as a series of Unicode characters.</param>
		/// <param name="innerException">Represents errors that occur during application execution.</param>
		public DeploymentException(string message, Exception innerException)
			: base(message, innerException)
		{
			_type = ExceptionTypes.Unknown;
		}

		/// <summary>Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
		/// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("_type", _type);
		}

		internal DeploymentException(ExceptionTypes exceptionType, string message)
			: base(message)
		{
			_type = exceptionType;
		}

		internal DeploymentException(ExceptionTypes exceptionType, string message, Exception innerException)
			: base(message, innerException)
		{
			_type = exceptionType;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DeploymentException" /> class.</summary>
		/// <param name="serializationInfo">Stores all the data needed to serialize or deserialize an object. This class cannot be inherited.</param>
		/// <param name="streamingContext">Describes the source and destination of a given serialized stream, and provides an additional caller-defined context.</param>
		protected DeploymentException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
			_type = (ExceptionTypes)serializationInfo.GetValue("_type", typeof(ExceptionTypes));
		}
	}
	/// <summary>Indicates that ClickOnce could not read either the deployment or application manifests.</summary>
	[Serializable]
	public class InvalidDeploymentException : DeploymentException
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.InvalidDeploymentException" /> class.</summary>
		public InvalidDeploymentException()
			: this(Resources.GetString("Ex_InvalidDeploymentException"))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.InvalidDeploymentException" /> class with the specified message that describes the exception.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		public InvalidDeploymentException(string message)
			: base(message)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.InvalidDeploymentException" /> class.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		/// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not <see langword="null" />, the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</param>
		public InvalidDeploymentException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		internal InvalidDeploymentException(ExceptionTypes exceptionType, string message)
			: base(exceptionType, message)
		{
		}

		internal InvalidDeploymentException(ExceptionTypes exceptionType, string message, Exception innerException)
			: base(exceptionType, message, innerException)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.InvalidDeploymentException" /> class.</summary>
		/// <param name="serializationInfo">The object that holds the serialized object data.</param>
		/// <param name="streamingContext">The contextual information about the source or destination.</param>
		protected InvalidDeploymentException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}
	}
	/// <summary>Indicates that there was an error downloading either the ClickOnce manifests or the deployment's files to the client computer.</summary>
	[Serializable]
	public class DeploymentDownloadException : DeploymentException
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DeploymentDownloadException" /> class.</summary>
		public DeploymentDownloadException()
			: this(Resources.GetString("Ex_DeploymentDownloadException"))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DeploymentDownloadException" /> class with a message that describes the exception.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		public DeploymentDownloadException(string message)
			: base(message)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DeploymentDownloadException" /> class.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		/// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not <see langword="null" />, the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</param>
		public DeploymentDownloadException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		internal DeploymentDownloadException(ExceptionTypes exceptionType, string message)
			: base(exceptionType, message)
		{
		}

		internal DeploymentDownloadException(ExceptionTypes exceptionType, string message, Exception innerException)
			: base(exceptionType, message, innerException)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DeploymentDownloadException" /> class.</summary>
		/// <param name="serializationInfo">The object that holds the serialized object data.</param>
		/// <param name="streamingContext">The contextual information about the source or destination.</param>
		protected DeploymentDownloadException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}
	}
	/// <summary>Indicates that the application does not have the appropriate level of trust to run on the local computer.</summary>
	[Serializable]
	public class TrustNotGrantedException : DeploymentException
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.TrustNotGrantedException" /> class with a system-supplied message that describes the error.</summary>
		public TrustNotGrantedException()
			: this(Resources.GetString("Ex_TrustNotGrantedException"))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.TrustNotGrantedException" /> class with a specified message that describes the error.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		public TrustNotGrantedException(string message)
			: base(message)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.TrustNotGrantedException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		/// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not <see langword="null" />, the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</param>
		public TrustNotGrantedException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		internal TrustNotGrantedException(ExceptionTypes exceptionType, string message)
			: base(exceptionType, message)
		{
		}

		internal TrustNotGrantedException(ExceptionTypes exceptionType, string message, Exception innerException)
			: base(exceptionType, message, innerException)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.TrustNotGrantedException" /> class with serialized data.</summary>
		/// <param name="serializationInfo">The object that holds the serialized object data.</param>
		/// <param name="streamingContext">The contextual information about the source or destination.</param>
		protected TrustNotGrantedException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}
	}
	/// <summary>The exception that is thrown when the platform dependency is not found during activation of the ClickOnce deployment and the deployment will not run.</summary>
	[Serializable]
	public class DependentPlatformMissingException : DeploymentException
	{
		private Uri _supportUrl;

		/// <summary>Gets a URI that indicates where support can be found for the problem encountered.</summary>
		/// <returns>A URI that indicates where support can be found for the problem encountered.</returns>
		public Uri SupportUrl => _supportUrl;

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DependentPlatformMissingException" /> class.</summary>
		public DependentPlatformMissingException()
			: this(Resources.GetString("Ex_DependentPlatformMissingException"))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DependentPlatformMissingException" /> class with a specified message that describes the error.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		public DependentPlatformMissingException(string message)
			: base(message)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DependentPlatformMissingException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		/// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not <see langword="null" />, the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</param>
		public DependentPlatformMissingException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DependentPlatformMissingException" /> class.</summary>
		/// <param name="serializationInfo">The object that holds the serialized object data.</param>
		/// <param name="streamingContext">The contextual information about the source or destination.</param>
		protected DependentPlatformMissingException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
			_supportUrl = (Uri)serializationInfo.GetValue("_supportUrl", typeof(Uri));
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.DependentPlatformMissingException" /> class.</summary>
		/// <param name="message">The exception message.</param>
		/// <param name="supportUrl">The URL to visit for product support information.</param>
		public DependentPlatformMissingException(string message, Uri supportUrl)
			: base(message)
		{
			_supportUrl = supportUrl;
		}

		internal DependentPlatformMissingException(ExceptionTypes exceptionType, string message)
			: base(exceptionType, message)
		{
		}

		internal DependentPlatformMissingException(ExceptionTypes exceptionType, string message, Exception innerException)
			: base(exceptionType, message, innerException)
		{
		}

		/// <summary>Gets the object data.</summary>
		/// <param name="info">The object that holds the serialized object data.</param>
		/// <param name="context">The contextual information about the source or destination.</param>
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("_supportUrl", _supportUrl);
		}
	}
	/// <summary>This exception is thrown when a version of the .NET Framework that is compatible with this application cannot be found.</summary>
	[Serializable]
	public class CompatibleFrameworkMissingException : DependentPlatformMissingException
	{
		private CompatibleFrameworks _compatibleFrameworks;

		/// <summary>Gets a list of .NET Framework versions where this application can install and run.</summary>
		/// <returns>A list of .NET Framework versions where this application can install and run.</returns>
		public CompatibleFrameworks CompatibleFrameworks => _compatibleFrameworks;

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.CompatibleFrameworkMissingException" /> class with a system-supplied message that describes the error.</summary>
		public CompatibleFrameworkMissingException()
			: this(Resources.GetString("Ex_CompatibleFrameworkMissingException"))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.CompatibleFrameworkMissingException" /> class with a specified message that describes the error.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		public CompatibleFrameworkMissingException(string message)
			: base(message)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.CompatibleFrameworkMissingException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		/// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not <see langword="null" />, the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</param>
		public CompatibleFrameworkMissingException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.CompatibleFrameworkMissingException" /> class with serialized data.</summary>
		/// <param name="serializationInfo">The object that holds the serialized object data.</param>
		/// <param name="streamingContext">The contextual information about the source or destination.</param>
		protected CompatibleFrameworkMissingException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
			_compatibleFrameworks = (CompatibleFrameworks)serializationInfo.GetValue("_compatibleFrameworks", typeof(CompatibleFrameworks));
		}

		internal CompatibleFrameworkMissingException(string message, Uri supportUrl, CompatibleFrameworks compatibleFrameworks)
			: base(message, supportUrl)
		{
			_compatibleFrameworks = compatibleFrameworks;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.CompatibleFrameworkMissingException" /> class with serialized data.</summary>
		/// <param name="info">The object that holds the serialized object data.</param>
		/// <param name="context">The contextual information about the source or destination.</param>
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("_compatibleFrameworks", _compatibleFrameworks);
		}
	}
	/// <summary>This exception is thrown when a runtime version that is compatible with this application cannot be found.</summary>
	[Serializable]
	public class SupportedRuntimeMissingException : DependentPlatformMissingException
	{
		private string _supportedRuntimeVersion;

		/// <summary>Gets the version of the runtime where this application can install and run.</summary>
		/// <returns>A string that contains the runtime version number.</returns>
		public string SupportedRuntimeVersion => _supportedRuntimeVersion;

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.SupportedRuntimeMissingException" /> class with a system-supplied message that describes the error.</summary>
		public SupportedRuntimeMissingException()
			: this(Resources.GetString("Ex_SupportedRuntimeMissingException"))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.SupportedRuntimeMissingException" /> class with a specified message that describes the error.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		public SupportedRuntimeMissingException(string message)
			: base(message)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.SupportedRuntimeMissingException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
		/// <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
		/// <param name="innerException">The exception that is the cause of the current exception. If the <paramref name="innerException" /> parameter is not <see langword="null" />, the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</param>
		public SupportedRuntimeMissingException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.SupportedRuntimeMissingException" /> class with serialized data.</summary>
		/// <param name="serializationInfo">The object that holds the serialized object data.</param>
		/// <param name="streamingContext">The contextual information about the source or destination.</param>
		protected SupportedRuntimeMissingException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
			_supportedRuntimeVersion = (string)serializationInfo.GetValue("_supportedRuntimeVersion", typeof(string));
		}

		internal SupportedRuntimeMissingException(string message, Uri supportUrl, string supportedRuntimeVersion)
			: base(message, supportUrl)
		{
			_supportedRuntimeVersion = supportedRuntimeVersion;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Deployment.Application.SupportedRuntimeMissingException" /> class with serialized data.</summary>
		/// <param name="info">The object that holds the serialized object data.</param>
		/// <param name="context">The contextual information about the source or destination.</param>
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("_supportedRuntimeVersion", _supportedRuntimeVersion);
		}
	}
	[Serializable]
	internal class DownloadCancelledException : DeploymentDownloadException
	{
		public DownloadCancelledException()
			: this(Resources.GetString("Ex_DownloadCancelledException"))
		{
		}

		public DownloadCancelledException(string message)
			: base(message)
		{
		}

		public DownloadCancelledException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected DownloadCancelledException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}
	}
	internal sealed class ExceptionUtility
	{
		public static bool IsHardException(Exception exception)
		{
			if (exception == null)
			{
				throw new ArgumentNullException("exception");
			}
			if (exception is Win32Exception ex)
			{
				exception = Marshal.GetExceptionForHR(ex.ErrorCode);
			}
			if (exception is DivideByZeroException || exception is OutOfMemoryException || exception is StackOverflowException || exception is AccessViolationException)
			{
				return true;
			}
			return false;
		}
	}
	internal interface IDownloadNotification
	{
		void DownloadModified(object sender, DownloadEventArgs e);

		void DownloadCompleted(object sender, DownloadEventArgs e);
	}
	internal class DownloadEventArgs : EventArgs
	{
		internal int _progress;

		internal int _filesCompleted;

		internal int _filesTotal;

		internal long _bytesCompleted;

		internal long _bytesTotal;

		internal Uri _fileSourceUri;

		internal Uri _fileResponseUri;

		internal string _fileLocalPath;

		internal object _cookie;

		public int Progress => _progress;

		public long BytesCompleted => _bytesCompleted;

		public long BytesTotal => _bytesTotal;

		public Uri FileSourceUri => _fileSourceUri;

		public Uri FileResponseUri => _fileResponseUri;

		internal string FileLocalPath
		{
			get
			{
				return _fileLocalPath;
			}
			set
			{
				_fileLocalPath = value;
			}
		}

		internal object Cookie
		{
			get
			{
				return _cookie;
			}
			set
			{
				_cookie = value;
			}
		}
	}
	internal class DownloadOptions
	{
		public bool Background;

		public bool EnforceSizeLimit;

		public ulong SizeLimit;

		public ulong Size;

		public override string ToString()
		{
			string text = " Background = " + Background;
			text = text + " EnforceSizeLimit = " + EnforceSizeLimit;
			text = text + " SizeLimit =" + SizeLimit.ToString(CultureInfo.InvariantCulture);
			return text + " Size =" + Size.ToString(CultureInfo.InvariantCulture);
		}
	}
	internal class ServerInformation
	{
		private string _server;

		private string _poweredBy;

		private string _aspNetVersion;

		public string Server
		{
			get
			{
				return _server;
			}
			set
			{
				_server = value;
			}
		}

		public string PoweredBy
		{
			get
			{
				return _poweredBy;
			}
			set
			{
				_poweredBy = value;
			}
		}

		public string AspNetVersion
		{
			get
			{
				return _aspNetVersion;
			}
			set
			{
				_aspNetVersion = value;
			}
		}
	}
	internal class DownloadResult
	{
		private Uri _responseUri;

		private ServerInformation _serverInformation = new ServerInformation();

		public Uri ResponseUri
		{
			get
			{
				return _responseUri;
			}
			set
			{
				_responseUri = value;
			}
		}

		public ServerInformation ServerInformation => _serverInformation;
	}
	internal abstract class FileDownloader
	{
		public delegate void DownloadModifiedEventHandler(object sender, DownloadEventArgs e);

		public delegate void DownloadCompletedEventHandler(object sender, DownloadEventArgs e);

		protected class DownloadQueueItem
		{
			public Uri _sourceUri;

			public string _targetPath;

			public object _cookie;

			public HashCollection _hashCollection;

			public int _maxFileSize;

			public const int FileOfAnySize = -1;

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(" _sourceUri = " + _sourceUri);
				stringBuilder.Append(",  _targetPath = " + _targetPath);
				return stringBuilder.ToString();
			}
		}

		protected Queue _fileQueue;

		protected DownloadEventArgs _eventArgs;

		protected DownloadOptions _options = new DownloadOptions();

		protected ArrayList _downloadResults;

		protected long _accumulatedBytesTotal;

		protected long _expectedBytesTotal;

		protected ComponentVerifier _componentVerifier = new ComponentVerifier();

		protected bool _fCancelPending;

		protected byte[] _buffer;

		public X509Certificate2 ClientCertificate { get; protected set; }

		public DownloadOptions Options
		{
			set
			{
				_options = value;
			}
		}

		public ComponentVerifier ComponentVerifier => _componentVerifier;

		public DownloadResult[] DownloadResults => (DownloadResult[])_downloadResults.ToArray(typeof(DownloadResult));

		public event DownloadModifiedEventHandler DownloadModified;

		public event DownloadCompletedEventHandler DownloadCompleted;

		protected FileDownloader()
		{
			_fileQueue = new Queue();
			_eventArgs = new DownloadEventArgs();
			_downloadResults = new ArrayList();
			_buffer = new byte[4096];
		}

		public static FileDownloader Create()
		{
			return new SystemNetDownloader();
		}

		public void AddNotification(IDownloadNotification notification)
		{
			DownloadCompleted += notification.DownloadCompleted;
			DownloadModified += notification.DownloadModified;
		}

		public void RemoveNotification(IDownloadNotification notification)
		{
			DownloadModified -= notification.DownloadModified;
			DownloadCompleted -= notification.DownloadCompleted;
		}

		protected void OnModified()
		{
			if (this.DownloadModified != null)
			{
				this.DownloadModified(this, _eventArgs);
			}
		}

		protected void OnCompleted()
		{
			if (this.DownloadCompleted != null)
			{
				this.DownloadCompleted(this, _eventArgs);
			}
		}

		public void AddFile(Uri sourceUri, string targetFilePath)
		{
			AddFile(sourceUri, targetFilePath, null, null);
		}

		public void AddFile(Uri sourceUri, string targetFilePath, int maxFileSize)
		{
			AddFile(sourceUri, targetFilePath, null, null, maxFileSize);
		}

		public void AddFile(Uri sourceUri, string targetFilePath, object cookie, HashCollection hashCollection)
		{
			AddFile(sourceUri, targetFilePath, cookie, hashCollection, -1);
		}

		public void AddFile(Uri sourceUri, string targetFilePath, object cookie, HashCollection hashCollection, int maxFileSize)
		{
			UriHelper.ValidateSupportedScheme(sourceUri);
			DownloadQueueItem downloadQueueItem = new DownloadQueueItem();
			downloadQueueItem._sourceUri = sourceUri;
			downloadQueueItem._targetPath = targetFilePath;
			downloadQueueItem._cookie = cookie;
			downloadQueueItem._hashCollection = hashCollection;
			downloadQueueItem._maxFileSize = maxFileSize;
			lock (_fileQueue)
			{
				_fileQueue.Enqueue(downloadQueueItem);
				_eventArgs._filesTotal++;
			}
		}

		private static FileStream GetPatchSourceStream(string filePath)
		{
			Logger.AddMethodCall("GetPatchSourceStream(" + filePath + ") called.");
			FileStream result = null;
			try
			{
				result = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
				return result;
			}
			catch (IOException exception)
			{
				Logger.AddErrorInformation(exception, Resources.GetString("Ex_PatchSourceOpenFailed"), Path.GetFileName(filePath));
				return result;
			}
			catch (UnauthorizedAccessException exception2)
			{
				Logger.AddErrorInformation(exception2, Resources.GetString("Ex_PatchSourceOpenFailed"), Path.GetFileName(filePath));
				return result;
			}
		}

		private static FileStream GetPatchTargetStream(string filePath)
		{
			return new FileStream(filePath, FileMode.CreateNew, FileAccess.Write, FileShare.Read);
		}

		private static bool FileHashVerified(HashCollection hashCollection, string location)
		{
			try
			{
				ComponentVerifier.VerifyFileHash(location, hashCollection);
			}
			catch (InvalidDeploymentException ex)
			{
				if (ex.SubType == ExceptionTypes.HashValidation)
				{
					return false;
				}
				throw;
			}
			return true;
		}

		private static bool AddSingleFileInHashtable(Hashtable hashtable, HashCollection hashCollection, string location)
		{
			bool result = false;
			if (System.IO.File.Exists(location))
			{
				foreach (Hash item in hashCollection)
				{
					string compositString = item.CompositString;
					if (!hashtable.Contains(compositString))
					{
						hashtable.Add(compositString, location);
						result = true;
					}
				}
				return result;
			}
			return result;
		}

		private static void AddFilesInHashtable(Hashtable hashtable, AssemblyManifest applicationManifest, string applicationFolder)
		{
			Logger.AddMethodCall("AddFilesInHashtable called.");
			Logger.AddInternalState("applicationFolder=" + applicationFolder);
			string text = null;
			System.Deployment.Application.Manifest.File[] files = applicationManifest.Files;
			System.Deployment.Application.Manifest.File[] array = files;
			foreach (System.Deployment.Application.Manifest.File file in array)
			{
				text = Path.Combine(applicationFolder, file.NameFS);
				try
				{
					AddSingleFileInHashtable(hashtable, file.HashCollection, text);
				}
				catch (IOException ex)
				{
					Logger.AddErrorInformation(ex, Resources.GetString("Ex_PatchDependencyFailed"), Path.GetFileName(text));
					Logger.AddInternalState("Exception thrown : " + ex.GetType().ToString() + ":" + ex.Message);
				}
			}
			DependentAssembly[] dependentAssemblies = applicationManifest.DependentAssemblies;
			foreach (DependentAssembly dependentAssembly in dependentAssemblies)
			{
				if (dependentAssembly.IsPreRequisite)
				{
					continue;
				}
				text = Path.Combine(applicationFolder, dependentAssembly.Codebase);
				try
				{
					if (AddSingleFileInHashtable(hashtable, dependentAssembly.HashCollection, text))
					{
						AssemblyManifest assemblyManifest = new AssemblyManifest(text);
						System.Deployment.Application.Manifest.File[] files2 = assemblyManifest.Files;
						for (int k = 0; k < files2.Length; k++)
						{
							string location = Path.Combine(Path.GetDirectoryName(text), files2[k].NameFS);
							AddSingleFileInHashtable(hashtable, files2[k].HashCollection, location);
						}
					}
				}
				catch (InvalidDeploymentException ex2)
				{
					Logger.AddErrorInformation(ex2, Resources.GetString("Ex_PatchDependencyFailed"), Path.GetFileName(text));
					Logger.AddInternalState("Exception thrown : " + ex2.GetType().ToString() + ":" + ex2.Message);
				}
				catch (IOException ex3)
				{
					Logger.AddErrorInformation(ex3, Resources.GetString("Ex_PatchDependencyFailed"), Path.GetFileName(text));
					Logger.AddInternalState("Exception thrown : " + ex3.GetType().ToString() + ":" + ex3.Message);
				}
			}
		}

		private bool PatchSingleFile(DownloadQueueItem item, Hashtable dependencyTable)
		{
			if (item._hashCollection == null)
			{
				return false;
			}
			string text = null;
			foreach (Hash item2 in item._hashCollection)
			{
				string compositString = item2.CompositString;
				if (dependencyTable.Contains(compositString))
				{
					text = (string)dependencyTable[compositString];
					break;
				}
			}
			if (text == null)
			{
				return false;
			}
			if (_fCancelPending)
			{
				return false;
			}
			if (!FileHashVerified(item._hashCollection, text))
			{
				Logger.AddInternalState("Hash verify failed for " + text + ", not using it for file patching.");
				return false;
			}
			FileStream fileStream = null;
			FileStream fileStream2 = null;
			try
			{
				fileStream = GetPatchSourceStream(text);
				if (fileStream == null)
				{
					return false;
				}
				Directory.CreateDirectory(Path.GetDirectoryName(item._targetPath));
				fileStream2 = GetPatchTargetStream(item._targetPath);
				if (fileStream2 == null)
				{
					return false;
				}
				_eventArgs._fileSourceUri = item._sourceUri;
				_eventArgs.FileLocalPath = item._targetPath;
				_eventArgs.Cookie = null;
				_eventArgs._fileResponseUri = null;
				CheckForSizeLimit((ulong)fileStream.Length, addToSize: true);
				_accumulatedBytesTotal += fileStream.Length;
				SetBytesTotal();
				OnModified();
				int num = 0;
				int lastTick = Environment.TickCount;
				fileStream2.SetLength(fileStream.Length);
				fileStream2.Position = 0L;
				do
				{
					if (_fCancelPending)
					{
						return false;
					}
					num = fileStream.Read(_buffer, 0, _buffer.Length);
					if (num > 0)
					{
						fileStream2.Write(_buffer, 0, num);
					}
					_eventArgs._bytesCompleted += num;
					_eventArgs._progress = (int)(_eventArgs._bytesCompleted * 100 / _eventArgs._bytesTotal);
					OnModifiedWithThrottle(ref lastTick);
				}
				while (num > 0);
			}
			finally
			{
				fileStream?.Close();
				fileStream2?.Close();
			}
			_eventArgs.Cookie = item._cookie;
			_eventArgs._filesCompleted++;
			OnModified();
			DownloadResult downloadResult = new DownloadResult();
			downloadResult.ResponseUri = null;
			_downloadResults.Add(downloadResult);
			Logger.AddInternalState(item._targetPath + " is patched from store.");
			return true;
		}

		private void PatchFiles(SubscriptionState subState)
		{
			if (!subState.IsInstalled)
			{
				Logger.AddInternalState("Subscription is not installed. No patching.");
				return;
			}
			System.Deployment.Internal.Isolation.Store.IPathLock pathLock = null;
			System.Deployment.Internal.Isolation.Store.IPathLock pathLock2 = null;
			using (subState.SubscriptionStore.AcquireSubscriptionReaderLock(subState))
			{
				if (!subState.IsInstalled)
				{
					Logger.AddInternalState("Subscription is not installed. No patching.");
					return;
				}
				Hashtable hashtable = new Hashtable();
				try
				{
					pathLock = subState.SubscriptionStore.LockApplicationPath(subState.CurrentBind);
					AddFilesInHashtable(hashtable, subState.CurrentApplicationManifest, pathLock.Path);
					try
					{
						if (subState.PreviousBind != null)
						{
							pathLock2 = subState.SubscriptionStore.LockApplicationPath(subState.PreviousBind);
							AddFilesInHashtable(hashtable, subState.PreviousApplicationManifest, pathLock2.Path);
						}
						Queue queue = new Queue();
						do
						{
							DownloadQueueItem downloadQueueItem = null;
							lock (_fileQueue)
							{
								if (_fileQueue.Count > 0)
								{
									downloadQueueItem = (DownloadQueueItem)_fileQueue.Dequeue();
								}
							}
							if (downloadQueueItem == null)
							{
								break;
							}
							if (!PatchSingleFile(downloadQueueItem, hashtable))
							{
								queue.Enqueue(downloadQueueItem);
							}
						}
						while (!_fCancelPending);
						lock (_fileQueue)
						{
							while (_fileQueue.Count > 0)
							{
								queue.Enqueue(_fileQueue.Dequeue());
							}
							_fileQueue = queue;
						}
					}
					finally
					{
						pathLock2?.Dispose();
					}
				}
				finally
				{
					pathLock?.Dispose();
				}
			}
			if (!_fCancelPending)
			{
				return;
			}
			throw new DownloadCancelledException();
		}

		public void Download(SubscriptionState subState, X509Certificate2 clientCertificate)
		{
			ClientCertificate = clientCertificate;
			try
			{
				OnModified();
				if (subState != null)
				{
					CodeMarker_Singleton.Instance.CodeMarker(564);
					PatchFiles(subState);
					CodeMarker_Singleton.Instance.CodeMarker(565);
				}
				DownloadAllFiles();
			}
			finally
			{
				OnCompleted();
			}
		}

		public void SetExpectedBytesTotal(long total)
		{
			_expectedBytesTotal = total;
		}

		protected void SetBytesTotal()
		{
			if (_expectedBytesTotal < _accumulatedBytesTotal)
			{
				_eventArgs._bytesTotal = _accumulatedBytesTotal;
			}
			else
			{
				_eventArgs._bytesTotal = _expectedBytesTotal;
			}
		}

		internal void CheckForSizeLimit(ulong bytesDownloaded, bool addToSize)
		{
			if (_options != null && _options.EnforceSizeLimit)
			{
				ulong num = ((_options.SizeLimit > _options.Size) ? (_options.SizeLimit - _options.Size) : 0);
				if (bytesDownloaded > num)
				{
					throw new DeploymentDownloadException(ExceptionTypes.SizeLimitForPartialTrustOnlineAppExceeded, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_OnlineSemiTrustAppSizeLimitExceeded"), new object[1] { _options.SizeLimit }));
				}
				if (addToSize && bytesDownloaded != 0)
				{
					_options.Size += bytesDownloaded;
				}
			}
		}

		protected void OnModifiedWithThrottle(ref int lastTick)
		{
			int tickCount = Environment.TickCount;
			int num = tickCount - lastTick;
			if (num < 0)
			{
				num += int.MaxValue;
			}
			if (num >= 100)
			{
				OnModified();
				lastTick = tickCount;
			}
		}

		public virtual void Cancel()
		{
			_fCancelPending = true;
		}

		protected abstract void DownloadAllFiles();
	}
	/// <summary>Install or update a ClickOnce deployment on a computer.</summary>
	[SecurityPermission(SecurityAction.Demand, Unrestricted = true)]
	public class InPlaceHostingManager : IDisposable
	{
		private enum State
		{
			Ready,
			GettingManifest,
			GetManifestSucceeded,
			VerifyingRequirements,
			VerifyRequirementsSucceeded,
			DownloadingApplication,
			DownloadApplicationSucceeded,
			Done
		}

		private DeploymentManager _deploymentManager;

		private State _state;

		private bool _isCached;

		private bool _isLaunchInHostProcess;

		private object _lock;

		private AppType _appType;

		private Logger.LogIdentity _log;

		/// <summary>Occurs when the deployment manifest has been downloaded to the local computer.</summary>
		public event EventHandler<GetManifestCompletedEventArgs> GetManifestCompleted;

		/// <summary>Occurs when there is a change in the status of an application or manifest download.</summary>
		public event EventHandler<DownloadProgressChangedEventArgs> DownloadProgressChanged;

		/// <summary>Occurs when the application has finished downloading to the local computer.</summary>
		public event EventHandler<DownloadApplicationCompletedEventArgs> DownloadApplicationCompleted;

		/// <summary>Creates a new instance of <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> to download and install the specified application, which can be either a stand-alone Windows Forms-based application or an application hosted in a Web browser.</summary>
		/// <param name="deploymentManifest">The Uniform Resource Identifier (URI) to the deployment manifest of the application that will be installed.</param>
		/// <param name="launchInHostProcess">Whether this application will be run in a host, such as a Web browser. For a stand-alone application, set this value to <see langword="false" />.</param>
		/// <exception cref="T:System.PlatformNotSupportedException">
		///   <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> can be used only in Windows XP or in later versions of the Windows operating system.</exception>
		/// <exception cref="T:System.ArgumentNullException">Cannot pass <see langword="null" /> for the <paramref name="deploymentManifest" /> argument.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="deploymentManifest" /> uses a URI scheme that is not supported by ClickOnce.</exception>
		public InPlaceHostingManager(Uri deploymentManifest, bool launchInHostProcess)
		{
			if (!PlatformSpecific.OnXPOrAbove)
			{
				throw new PlatformNotSupportedException(Resources.GetString("Ex_RequiresXPOrHigher"));
			}
			if (deploymentManifest == null)
			{
				throw new ArgumentNullException("deploymentManifest");
			}
			UriHelper.ValidateSupportedSchemeInArgument(deploymentManifest, "deploymentSource");
			_deploymentManager = new DeploymentManager(deploymentManifest, isUpdate: false, isConfirmed: true, null, null);
			_log = _deploymentManager.LogId;
			_isLaunchInHostProcess = launchInHostProcess;
			_Initialize();
			Logger.AddInternalState(_log, "Activation through IPHM APIs started.");
			Logger.AddMethodCall(_log, "InPlaceHostingManager(" + deploymentManifest?.ToString() + "," + launchInHostProcess + ") called.");
		}

		/// <summary>Creates a new instance of <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> to download and install the specified browser-hosted application.</summary>
		/// <param name="deploymentManifest">A Uniform Resource Identifier (<see cref="T:System.Uri" />) to a ClickOnce application's deployment manifest.</param>
		/// <exception cref="T:System.PlatformNotSupportedException">
		///   <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> can be used only in Windows XP or in later versions of the Windows operating system.</exception>
		/// <exception cref="T:System.ArgumentNullException">Cannot pass <see langword="null" /> for the <paramref name="deploymentManifest" /> argument.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="deploymentManifest" /> uses a URI scheme that is not supported by ClickOnce.</exception>
		public InPlaceHostingManager(Uri deploymentManifest)
			: this(deploymentManifest, launchInHostProcess: true)
		{
		}

		private void _Initialize()
		{
			_lock = new object();
			_deploymentManager.BindCompleted += OnBindCompleted;
			_deploymentManager.SynchronizeCompleted += OnSynchronizeCompleted;
			_deploymentManager.ProgressChanged += OnProgressChanged;
			_state = State.Ready;
		}

		/// <summary>Downloads the deployment manifest of the ClickOnce application in the background, and raises an event when the operation has either completed or encountered an error.</summary>
		public void GetManifestAsync()
		{
			lock (_lock)
			{
				try
				{
					AssertState(State.Ready);
					Logger.AddMethodCall(_log, "InPlaceHostingManager.GetManifestAsync() called.");
					ChangeState(State.GettingManifest);
					_deploymentManager.BindAsync();
				}
				catch (Exception ex)
				{
					Logger.AddInternalState(_log, "Exception thrown in  GetManifestAsync(): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
					ChangeState(State.Done);
					throw;
				}
			}
		}

		/// <summary>Determines whether the ClickOnce application has the appropriate permissions and platform dependencies to run on the local computer.</summary>
		/// <exception cref="T:System.InvalidOperationException">Raised if this method is called before the <see cref="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" /> method.</exception>
		public void AssertApplicationRequirements()
		{
			lock (_lock)
			{
				try
				{
					Logger.AddMethodCall(_log, "InPlaceHostingManager.AssertApplicationRequirements() called.");
					if (_appType == AppType.CustomHostSpecified)
					{
						throw new InvalidOperationException(Resources.GetString("Ex_CannotCallAssertApplicationRequirements"));
					}
					AssertApplicationRequirements(grantApplicationTrust: false);
				}
				catch (Exception ex)
				{
					Logger.AddInternalState(_log, "Exception thrown in AssertApplicationRequirements(): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
					throw;
				}
			}
		}

		/// <summary>Determines whether the ClickOnce application has the appropriate permissions and platform dependencies to run on the local computer.</summary>
		/// <param name="grantApplicationTrust">If <see langword="true" />, the application will attempt to elevate its permissions to the required level.</param>
		public void AssertApplicationRequirements(bool grantApplicationTrust)
		{
			lock (_lock)
			{
				try
				{
					Logger.AddMethodCall(_log, "InPlaceHostingManager.AssertApplicationRequirements(" + grantApplicationTrust + ") called.");
					if (_appType == AppType.CustomHostSpecified)
					{
						throw new InvalidOperationException(Resources.GetString("Ex_CannotCallAssertApplicationRequirements"));
					}
					AssertState(State.GetManifestSucceeded, State.DownloadingApplication);
					ChangeState(State.VerifyingRequirements);
					_deploymentManager.DeterminePlatformRequirements();
					if (grantApplicationTrust)
					{
						Logger.AddMethodCall(_log, "Persisting trust without evaluation.");
						_deploymentManager.PersistTrustWithoutEvaluation();
					}
					else
					{
						TrustParams trustParams = new TrustParams();
						trustParams.NoPrompt = true;
						_deploymentManager.DetermineTrust(trustParams);
					}
					ChangeState(State.VerifyRequirementsSucceeded);
				}
				catch (Exception ex)
				{
					Logger.AddInternalState(_log, "Exception thrown in AssertApplicationRequirements(bool grantApplicationTrust): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
					ChangeState(State.Done);
					throw;
				}
			}
		}

		/// <summary>Downloads an application update in the background.</summary>
		/// <exception cref="T:System.InvalidOperationException">Raised if this method is called before the <see cref="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" /> and <see cref="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements" /> methods.</exception>
		public void DownloadApplicationAsync()
		{
			lock (_lock)
			{
				try
				{
					Logger.AddMethodCall(_log, "InPlaceHostingManager.DownloadApplicationAsync() called.");
					if (_appType == AppType.CustomHostSpecified)
					{
						AssertState(State.GetManifestSucceeded);
					}
					else if (_isCached)
					{
						AssertState(State.GetManifestSucceeded, State.VerifyRequirementsSucceeded);
					}
					else
					{
						AssertState(State.GetManifestSucceeded, State.VerifyRequirementsSucceeded);
					}
					ChangeState(State.DownloadingApplication);
					_deploymentManager.SynchronizeAsync();
				}
				catch (Exception ex)
				{
					Logger.AddInternalState(_log, "Exception thrown DownloadApplicationAsync(): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
					ChangeState(State.Done);
					throw;
				}
			}
		}

		/// <summary>Launches the ClickOnce application, if and only if it is a Windows Presentation Foundation-based application running in a Web browser.</summary>
		/// <returns>An <see cref="T:System.Runtime.Remoting.ObjectHandle" /> corresponding to the launched application.</returns>
		public ObjectHandle Execute()
		{
			lock (_lock)
			{
				try
				{
					Logger.AddMethodCall(_log, "InPlaceHostingManager.Execute() called.");
					AssertState(State.DownloadApplicationSucceeded);
					ChangeState(State.Done);
					return _deploymentManager.ExecuteNewDomain();
				}
				catch (Exception ex)
				{
					Logger.AddInternalState(_log, "Exception thrown in Execute(): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
					throw;
				}
			}
		}

		/// <summary>Cancels an asynchronous download operation.</summary>
		public void CancelAsync()
		{
			lock (_lock)
			{
				try
				{
					Logger.AddMethodCall(_log, "InPlaceHostingManager.CancelAsync() called.");
					ChangeState(State.Done);
					_deploymentManager.CancelAsync();
				}
				catch (Exception ex)
				{
					Logger.AddInternalState(_log, "Exception thrown in CancelAsync(): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
					throw;
				}
			}
		}

		/// <summary>Releases all resources used by the <see cref="T:System.Deployment.Application.InPlaceHostingManager" />.</summary>
		public void Dispose()
		{
			lock (_lock)
			{
				try
				{
					Logger.AddMethodCall(_log, "InPlaceHostingManager.Dispose() called.");
					ChangeState(State.Done);
					_deploymentManager.BindCompleted -= OnBindCompleted;
					_deploymentManager.SynchronizeCompleted -= OnSynchronizeCompleted;
					_deploymentManager.ProgressChanged -= OnProgressChanged;
					_deploymentManager.Dispose();
					GC.SuppressFinalize(this);
				}
				catch (Exception ex)
				{
					Logger.AddInternalState(_log, "Exception thrown in Dispose(): " + ex.GetType().ToString() + " : " + ex.Message + "\r\n" + ex.StackTrace);
					throw;
				}
			}
		}

		/// <summary>Removes a ClickOnce application that includes the &lt;customUX&gt; element.</summary>
		/// <param name="subscriptionId">A string that contains a subscription identifier, which indicates the ClickOnce application to remove.</param>
		public static void UninstallCustomUXApplication(string subscriptionId)
		{
			DefinitionIdentity definitionIdentity = null;
			definitionIdentity = GetSubIdAndValidate(subscriptionId);
			SubscriptionStore currentUser = SubscriptionStore.CurrentUser;
			currentUser.RefreshStorePointer();
			SubscriptionState subscriptionState = currentUser.GetSubscriptionState(definitionIdentity);
			subscriptionState.SubscriptionStore.UninstallCustomUXSubscription(subscriptionState);
		}

		/// <summary>Removes a previously installed user-defined component of an application.</summary>
		/// <param name="subscriptionId">A string that contains a subscription identifier, which indicates the add-in to remove.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="subscriptionId" /> is not a valid subscription identity, or does not include a name, public key token, processor architecture, and version number.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="subscriptionId" /> is <see langword="null" />.</exception>
		public static void UninstallCustomAddIn(string subscriptionId)
		{
			DefinitionIdentity definitionIdentity = null;
			definitionIdentity = GetSubIdAndValidate(subscriptionId);
			SubscriptionStore currentUser = SubscriptionStore.CurrentUser;
			currentUser.RefreshStorePointer();
			SubscriptionState subscriptionState = currentUser.GetSubscriptionState(definitionIdentity);
			subscriptionState.SubscriptionStore.UninstallCustomHostSpecifiedSubscription(subscriptionState);
		}

		private static DefinitionIdentity GetSubIdAndValidate(string subscriptionId)
		{
			if (subscriptionId == null)
			{
				throw new ArgumentNullException("subscriptionId", Resources.GetString("Ex_ComArgSubIdentityNull"));
			}
			DefinitionIdentity definitionIdentity = null;
			try
			{
				definitionIdentity = new DefinitionIdentity(subscriptionId);
			}
			catch (COMException innerException)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.GetString("Ex_ComArgSubIdentityNotValid"), new object[1] { subscriptionId }), innerException);
			}
			catch (SEHException innerException2)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.GetString("Ex_ComArgSubIdentityNotValid"), new object[1] { subscriptionId }), innerException2);
			}
			catch (ArgumentException innerException3)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.GetString("Ex_ComArgSubIdentityNotValid"), new object[1] { subscriptionId }), innerException3);
			}
			if (definitionIdentity.Name == null)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.GetString("Ex_ComArgSubIdentityNotValid"), new object[1] { subscriptionId }));
			}
			if (definitionIdentity.PublicKeyToken == null)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.GetString("Ex_ComArgSubIdentityNotValid"), new object[1] { subscriptionId }));
			}
			if (definitionIdentity.ProcessorArchitecture == null)
			{
				throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.GetString("Ex_ComArgSubIdentityNotValid"), new object[1] { subscriptionId }));
			}
			if (definitionIdentity.Version != null)
			{
				throw new ArgumentException(Resources.GetString("Ex_ComArgSubIdentityWithVersion"));
			}
			return definitionIdentity;
		}

		private void OnBindCompleted(object sender, BindCompletedEventArgs e)
		{
			lock (_lock)
			{
				GetManifestCompletedEventArgs getManifestCompletedEventArgs = null;
				try
				{
					AssertState(State.GettingManifest, State.Done);
					if (_state != State.Done)
					{
						if (e.Cancelled || e.Error != null)
						{
							ChangeState(State.Done);
						}
						else
						{
							ChangeState(State.GetManifestSucceeded, e);
						}
					}
					if (this.GetManifestCompleted == null)
					{
						return;
					}
					if (e.Error != null || e.Cancelled)
					{
						if (e.Cancelled)
						{
							Logger.AddInternalState(_log, "GetManifestAsync call cancelled.");
						}
						getManifestCompletedEventArgs = new GetManifestCompletedEventArgs(e, _deploymentManager.LogFilePath);
					}
					else
					{
						_isCached = e.IsCached;
						bool install = _deploymentManager.ActivationDescription.DeployManifest.Deployment.Install;
						bool hostInBrowser = _deploymentManager.ActivationDescription.AppManifest.EntryPoints[0].HostInBrowser;
						_appType = _deploymentManager.ActivationDescription.appType;
						bool useManifestForTrust = _deploymentManager.ActivationDescription.AppManifest.UseManifestForTrust;
						Uri providerCodebaseUri = _deploymentManager.ActivationDescription.DeployManifest.Deployment.ProviderCodebaseUri;
						getManifestCompletedEventArgs = ((_isLaunchInHostProcess && _appType != AppType.CustomHostSpecified && !hostInBrowser) ? new GetManifestCompletedEventArgs(e, new InvalidOperationException(Resources.GetString("Ex_HostInBrowserFlagMustBeTrue")), _deploymentManager.LogFilePath) : ((install && (_isLaunchInHostProcess || _appType == AppType.CustomHostSpecified)) ? new GetManifestCompletedEventArgs(e, new InvalidOperationException(Resources.GetString("Ex_InstallFlagMustBeFalse")), _deploymentManager.LogFilePath) : ((useManifestForTrust && _appType == AppType.CustomHostSpecified) ? new GetManifestCompletedEventArgs(e, new InvalidOperationException(Resources.GetString("Ex_CannotHaveUseManifestForTrustFlag")), _deploymentManager.LogFilePath) : ((providerCodebaseUri != null && _appType == AppType.CustomHostSpecified) ? new GetManifestCompletedEventArgs(e, new InvalidOperationException(Resources.GetString("Ex_CannotHaveDeploymentProvider")), _deploymentManager.LogFilePath) : ((!hostInBrowser || _appType != AppType.CustomUX) ? new GetManifestCompletedEventArgs(e, _deploymentManager.ActivationDescription, _deploymentManager.LogFilePath, _log) : new GetManifestCompletedEventArgs(e, new InvalidOperationException(Resources.GetString("Ex_CannotHaveCustomUXFlag")), _deploymentManager.LogFilePath))))));
						if (getManifestCompletedEventArgs.Error != null)
						{
							Logger.AddInternalState(_log, "Exception thrown after binding: " + getManifestCompletedEventArgs.Error.GetType().ToString() + " : " + getManifestCompletedEventArgs.Error.Message + "\r\n" + getManifestCompletedEventArgs.Error.StackTrace);
						}
					}
				}
				catch (Exception ex)
				{
					Logger.AddInternalState(_log, "Exception thrown:" + ex.GetType().ToString() + " : " + ex.Message);
					ChangeState(State.Done);
					throw;
				}
				this.GetManifestCompleted(this, getManifestCompletedEventArgs);
			}
		}

		private void OnSynchronizeCompleted(object sender, SynchronizeCompletedEventArgs e)
		{
			lock (_lock)
			{
				try
				{
					AssertState(State.DownloadingApplication, State.VerifyRequirementsSucceeded, State.Done);
					if (_state != State.Done)
					{
						if (e.Cancelled || e.Error != null)
						{
							ChangeState(State.Done);
						}
						else
						{
							ChangeState(State.DownloadApplicationSucceeded, e);
						}
					}
					if ((!_isLaunchInHostProcess || _appType == AppType.CustomHostSpecified) && _appType != AppType.CustomUX)
					{
						ChangeState(State.Done);
					}
					if (this.DownloadApplicationCompleted != null)
					{
						DownloadApplicationCompletedEventArgs e2 = new DownloadApplicationCompletedEventArgs(e, _deploymentManager.LogFilePath, _deploymentManager.ShortcutAppId);
						this.DownloadApplicationCompleted(this, e2);
					}
				}
				catch (Exception ex)
				{
					Logger.AddInternalState(_log, "Exception thrown:" + ex.GetType().ToString() + " : " + ex.Message);
					throw;
				}
			}
		}

		private void OnProgressChanged(object sender, DeploymentProgressChangedEventArgs e)
		{
			lock (_lock)
			{
				if (this.DownloadProgressChanged != null)
				{
					DownloadProgressChangedEventArgs e2 = new DownloadProgressChangedEventArgs(e.ProgressPercentage, e.UserState, e.BytesCompleted, e.BytesTotal, e.State);
					this.DownloadProgressChanged(this, e2);
				}
			}
		}

		private void AssertState(State validState)
		{
			if (_state == State.Done)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_NoFurtherOperations"));
			}
			if (validState != _state)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_InvalidSequence"));
			}
		}

		private void AssertState(State validState0, State validState1)
		{
			if (_state == State.Done && validState0 != _state && validState1 != _state)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_NoFurtherOperations"));
			}
			if (validState0 != _state && validState1 != _state)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_InvalidSequence"));
			}
		}

		private void AssertState(State validState0, State validState1, State validState2)
		{
			if (_state == State.Done && validState0 != _state && validState1 != _state && validState2 != _state)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_NoFurtherOperations"));
			}
			if (validState0 != _state && validState1 != _state && validState2 != _state)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_InvalidSequence"));
			}
		}

		private void ChangeState(State nextState, AsyncCompletedEventArgs e)
		{
			if (e.Cancelled || e.Error != null)
			{
				_state = State.Done;
			}
			else
			{
				_state = nextState;
			}
		}

		private void ChangeState(State nextState)
		{
			_state = nextState;
			Logger.AddInternalState(_log, "Internal state=" + _state);
		}
	}
	/// <summary>Provides data for the <see cref="E:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted" /> event of <see cref="T:System.Deployment.Application.InPlaceHostingManager" />.</summary>
	public class GetManifestCompletedEventArgs : AsyncCompletedEventArgs
	{
		private ActivationDescription _activationDescription;

		private Version _version;

		private ApplicationIdentity _applicationIdentity;

		private DefinitionIdentity _subId;

		private bool _isCached;

		private string _name;

		private Uri _support;

		private string _logFilePath;

		private byte[] _rawApplicationManifest;

		private byte[] _rawDeploymentManifest;

		private ActivationContext _actContext;

		/// <summary>Gets a description of the ClickOnce application.</summary>
		/// <returns>An <see cref="T:System.ApplicationIdentity" /> object.</returns>
		public ApplicationIdentity ApplicationIdentity
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _applicationIdentity;
			}
		}

		/// <summary>Gets the version of the update for the ClickOnce application.</summary>
		/// <returns>A <see cref="T:System.Version" /> representing the version number contained within the downloaded manifest.</returns>
		public Version Version
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _version;
			}
		}

		/// <summary>Gets a value indicating whether this ClickOnce application is cached.</summary>
		/// <returns>
		///   <see langword="true" /> if the application is cached; otherwise, <see langword="false" />.</returns>
		public bool IsCached
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _isCached;
			}
		}

		/// <summary>Gets the name of the ClickOnce application.</summary>
		/// <returns>A <see cref="T:System.String" /> representing the product name of the ClickOnce application, as stored in the assembly metadata of the application's main executable file.</returns>
		public string ProductName
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _name;
			}
		}

		/// <summary>Gets the location of a Web page users can visit to obtain product support for the ClickOnce application.</summary>
		/// <returns>A <see cref="T:System.Uri" /> containing the value found in the <c>supportUrl</c> attribute of the deployment manifest's <c>&lt;description&gt;</c> tag. For more information, see ClickOnce Deployment Manifest.</returns>
		public Uri SupportUri
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _support;
			}
		}

		/// <summary>Gets the location of the ClickOnce error log.</summary>
		/// <returns>A <see cref="T:System.String" /> containing the location of the ClickOnce error log.</returns>
		public string LogFilePath => _logFilePath;

		/// <summary>Gets the ClickOnce deployment manifest for this deployment.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlReader" /> representing the deployment manifest.</returns>
		public XmlReader DeploymentManifest
		{
			get
			{
				RaiseExceptionIfNecessary();
				return ManifestToXml(RawDeploymentManifest);
			}
		}

		/// <summary>Gets the ClickOnce application manifest for this deployment.</summary>
		/// <returns>An <see cref="T:System.Xml.XmlReader" /> representing the application manifest.</returns>
		public XmlReader ApplicationManifest
		{
			get
			{
				RaiseExceptionIfNecessary();
				return ManifestToXml(RawApplicationManifest);
			}
		}

		/// <summary>Gets the context for the current ClickOnce application.</summary>
		/// <returns>An <see cref="T:System.ActivationContext" /> object representing the context for the current application.</returns>
		public ActivationContext ActivationContext
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _actContext;
			}
		}

		/// <summary>Gets a string identifying the subscription.</summary>
		/// <returns>A string with information identifying the subscription.</returns>
		public string SubscriptionIdentity
		{
			get
			{
				RaiseExceptionIfNecessary();
				return _subId.ToString();
			}
		}

		private byte[] RawDeploymentManifest
		{
			get
			{
				if (_rawDeploymentManifest == null)
				{
					_rawDeploymentManifest = _activationDescription.DeployManifest.RawXmlBytes;
				}
				return _rawDeploymentManifest;
			}
		}

		private byte[] RawApplicationManifest
		{
			get
			{
				if (_rawApplicationManifest == null)
				{
					_rawApplicationManifest = _activationDescription.AppManifest.RawXmlBytes;
				}
				return _rawApplicationManifest;
			}
		}

		internal GetManifestCompletedEventArgs(BindCompletedEventArgs e, ActivationDescription activationDescription, string logFilePath, Logger.LogIdentity log)
			: base(e.Error, e.Cancelled, e.UserState)
		{
			_applicationIdentity = ((e.ActivationContext != null) ? e.ActivationContext.Identity : null);
			Logger.AddInternalState(log, "Creating GetManifestCompletedEventArgs.");
			string text = _applicationIdentity.ToString();
			DefinitionAppId definitionAppId = new DefinitionAppId(text);
			DefinitionIdentity deploymentIdentity = definitionAppId.DeploymentIdentity;
			_subId = deploymentIdentity.ToSubscriptionId();
			_logFilePath = logFilePath;
			_isCached = e.IsCached;
			_name = e.FriendlyName;
			_actContext = e.ActivationContext;
			Logger.AddInternalState(log, "Application identity=" + text);
			Logger.AddInternalState(log, "Subscription identity=" + ((_subId != null) ? _subId.ToString() : "null"));
			Logger.AddInternalState(log, "IsCached=" + _isCached);
			if (_isCached)
			{
				_rawDeploymentManifest = e.ActivationContext.DeploymentManifestBytes;
				_rawApplicationManifest = e.ActivationContext.ApplicationManifestBytes;
			}
			_activationDescription = activationDescription;
			_version = _activationDescription.AppId.DeploymentIdentity.Version;
			_support = _activationDescription.DeployManifest.Description.SupportUri;
		}

		internal GetManifestCompletedEventArgs(BindCompletedEventArgs e, Exception error, string logFilePath)
			: base(error, e.Cancelled, e.UserState)
		{
			_logFilePath = logFilePath;
		}

		internal GetManifestCompletedEventArgs(BindCompletedEventArgs e, string logFilePath)
			: base(e.Error, e.Cancelled, e.UserState)
		{
			_logFilePath = logFilePath;
		}

		private static XmlReader ManifestToXml(byte[] rawManifest)
		{
			if (rawManifest == null)
			{
				return null;
			}
			return new XmlTextReader(new MemoryStream(rawManifest));
		}
	}
	/// <summary>Provides data for the <see cref="E:System.Deployment.Application.InPlaceHostingManager.DownloadProgressChanged" /> event.</summary>
	public class DownloadProgressChangedEventArgs : ProgressChangedEventArgs
	{
		private long _bytesCompleted;

		private long _bytesTotal;

		private DeploymentProgressState _deploymentProgressState;

		/// <summary>Gets the number of bytes downloaded to the local computer.</summary>
		/// <returns>An <see cref="T:System.Int64" /> representing the number of downloaded bytes.</returns>
		public long BytesDownloaded => _bytesCompleted;

		/// <summary>Gets the total number of bytes for the download operation.</summary>
		/// <returns>An <see cref="T:System.Int64" /> representing the total size of the download, in bytes.</returns>
		public long TotalBytesToDownload => _bytesTotal;

		/// <summary>Gets the progress state of the download.</summary>
		/// <returns>A <see cref="T:System.Deployment.Application.DeploymentProgressState" /> value describing which portion of the ClickOnce application is being downloaded.</returns>
		public DeploymentProgressState State => _deploymentProgressState;

		internal DownloadProgressChangedEventArgs(int progressPercentage, object userState, long bytesCompleted, long bytesTotal, DeploymentProgressState downloadProgressState)
			: base(progressPercentage, userState)
		{
			_bytesCompleted = bytesCompleted;
			_bytesTotal = bytesTotal;
			_deploymentProgressState = downloadProgressState;
		}
	}
	/// <summary>Provides data for the <see cref="E:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationCompleted" /> event.</summary>
	public class DownloadApplicationCompletedEventArgs : AsyncCompletedEventArgs
	{
		private string _logFilePath;

		private string _shortcutAppId;

		/// <summary>Gets the path of the ClickOnce log file.</summary>
		/// <returns>The path of the ClickOnce log file.</returns>
		public string LogFilePath => _logFilePath;

		/// <summary>Gets the contents of an .appref-ms file that can launch this ClickOnce application.</summary>
		/// <returns>The contents of an .appref-ms file.</returns>
		public string ShortcutAppId => _shortcutAppId;

		internal DownloadApplicationCompletedEventArgs(AsyncCompletedEventArgs e, string logFilePath, string shortcutAppId)
			: base(e.Error, e.Cancelled, e.UserState)
		{
			_logFilePath = logFilePath;
			_shortcutAppId = shortcutAppId;
		}
	}
	internal static class LifetimeManager
	{
		private static ManualResetEvent _lifetimeEndedEvent = new ManualResetEvent(initialState: false);

		private static System.Threading.Timer _periodicTimer = new System.Threading.Timer(PeriodicTimerCallback, null, 600000, 600000);

		private static int _operationsInProgress;

		private static bool _lifetimeExtended;

		private static bool _lifetimeEnded;

		private static bool _immediate;

		private static object _TimerLock = new object();

		public static void StartOperation()
		{
			lock (_TimerLock)
			{
				CheckAlive();
				_operationsInProgress++;
			}
		}

		public static void EndOperation()
		{
			lock (_TimerLock)
			{
				CheckAlive();
				_operationsInProgress--;
				_lifetimeExtended = true;
			}
		}

		public static void ExtendLifetime()
		{
			lock (_TimerLock)
			{
				CheckAlive();
				_lifetimeExtended = true;
			}
		}

		public static bool WaitForEnd()
		{
			_lifetimeEndedEvent.WaitOne();
			return _immediate;
		}

		public static void EndImmediately()
		{
			lock (_TimerLock)
			{
				if (_operationsInProgress != 0)
				{
					Logger.StartCurrentThreadLogging();
					Logger.AddPhaseInformation(Resources.GetString("Life_OperationsInProgress"), _operationsInProgress);
					Logger.EndCurrentThreadLogging();
				}
				_lifetimeEndedEvent.Set();
				_lifetimeEnded = true;
				_immediate = true;
			}
		}

		private static void CheckAlive()
		{
			if (_lifetimeEnded)
			{
				throw new InvalidOperationException(Resources.GetString("Ex_LifetimeEnded"));
			}
		}

		private static void PeriodicTimerCallback(object state)
		{
			lock (_TimerLock)
			{
				if (_operationsInProgress == 0 && !_lifetimeExtended)
				{
					_lifetimeEndedEvent.Set();
					_lifetimeEnded = true;
					_periodicTimer.Dispose();
				}
				else
				{
					_lifetimeExtended = false;
				}
			}
		}
	}
	internal static class LockedFile
	{
		private class LockedFileHandle : IDisposable
		{
			private SafeFileHandle _handle;

			private string _path;

			private FileAccess _access;

			private bool _disposed;

			public LockedFileHandle()
			{
			}

			public LockedFileHandle(SafeFileHandle handle, string path, FileAccess access)
			{
				if (handle == null)
				{
					throw new ArgumentNullException("handle");
				}
				_handle = handle;
				_path = path;
				_access = access;
				Hashtable hashtable = ((_access == FileAccess.Read) ? ThreadReaderLocks : ThreadWriterLocks);
				hashtable.Add(_path, this);
			}

			public void Dispose()
			{
				if (!_disposed)
				{
					if (_handle != null)
					{
						Hashtable hashtable = ((_access == FileAccess.Read) ? ThreadReaderLocks : ThreadWriterLocks);
						hashtable.Remove(_path);
						_handle.Dispose();
					}
					GC.SuppressFinalize(this);
					_disposed = true;
				}
			}
		}

		[ThreadStatic]
		private static Hashtable _threadReaderLocks;

		[ThreadStatic]
		private static Hashtable _threadWriterLocks;

		private static Hashtable ThreadReaderLocks
		{
			get
			{
				if (_threadReaderLocks == null)
				{
					_threadReaderLocks = new Hashtable();
				}
				return _threadReaderLocks;
			}
		}

		private static Hashtable ThreadWriterLocks
		{
			get
			{
				if (_threadWriterLocks == null)
				{
					_threadWriterLocks = new Hashtable();
				}
				return _threadWriterLocks;
			}
		}

		public static IDisposable AcquireLock(string path, TimeSpan timeout, bool writer)
		{
			LockedFileHandle lockedFileHandle = LockHeldByThread(path, writer);
			if (lockedFileHandle != null)
			{
				return lockedFileHandle;
			}
			DateTime dateTime = DateTime.UtcNow + timeout;
			FileAccess access;
			NativeMethods.GenericAccess dwDesiredAccess;
			NativeMethods.ShareMode dwShareMode;
			if (writer)
			{
				access = FileAccess.Write;
				dwDesiredAccess = NativeMethods.GenericAccess.GENERIC_WRITE;
				dwShareMode = NativeMethods.ShareMode.FILE_SHARE_NONE;
			}
			else
			{
				access = FileAccess.Read;
				dwDesiredAccess = NativeMethods.GenericAccess.GENERIC_READ;
				dwShareMode = (PlatformSpecific.OnWin9x ? NativeMethods.ShareMode.FILE_SHARE_READ : (NativeMethods.ShareMode.FILE_SHARE_READ | NativeMethods.ShareMode.FILE_SHARE_DELETE));
			}
			while (true)
			{
				SafeFileHandle safeFileHandle = NativeMethods.CreateFile(path, (uint)dwDesiredAccess, (uint)dwShareMode, IntPtr.Zero, 4u, 67108864u, IntPtr.Zero);
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (!safeFileHandle.IsInvalid)
				{
					return new LockedFileHandle(safeFileHandle, path, access);
				}
				if (lastWin32Error != 32 && lastWin32Error != 5)
				{
					Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
				}
				if (DateTime.UtcNow > dateTime)
				{
					break;
				}
				Thread.Sleep(1);
			}
			throw new DeploymentException(ExceptionTypes.LockTimeout, Resources.GetString("Ex_LockTimeoutException"));
		}

		private static LockedFileHandle LockHeldByThread(string path, bool writer)
		{
			LockedFileHandle lockedFileHandle = (LockedFileHandle)ThreadWriterLocks[path];
			if (lockedFileHandle != null)
			{
				return new LockedFileHandle();
			}
			LockedFileHandle lockedFileHandle2 = (LockedFileHandle)ThreadReaderLocks[path];
			if (lockedFileHandle2 != null)
			{
				if (!writer)
				{
					return new LockedFileHandle();
				}
				throw new NotImplementedException();
			}
			return null;
		}
	}
	internal class Logger
	{
		protected class LogInformation
		{
			protected string _message = "";

			protected DateTime _time = DateTime.Now;

			public string Message => _message;

			public DateTime Time => _time;

			public LogInformation()
			{
			}

			public LogInformation(string message, DateTime time)
			{
				if (message != null)
				{
					_message = message;
				}
				_time = time;
			}
		}

		protected class ErrorInformation : LogInformation
		{
			protected Exception _exception;

			public string Summary
			{
				get
				{
					StringBuilder stringBuilder = new StringBuilder();
					stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_IndividualErrorSummary"), new object[1] { _message });
					for (Exception ex = _exception; ex != null; ex = ex.InnerException)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_IndividualErrorSummaryBullets"), new object[1] { ex.Message });
					}
					return stringBuilder.ToString();
				}
			}

			public ErrorInformation(string message, Exception exception, DateTime time)
				: base(message, time)
			{
				_exception = exception;
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				for (Exception ex = _exception; ex != null; ex = ex.InnerException)
				{
					string text = null;
					if (ex.StackTrace != null)
					{
						text = ex.StackTrace.Replace("   ", "\t\t\t");
					}
					if (ex == _exception)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_IndividualErrorOutermostException"), base.Time.ToString(DateTimeFormatInfo.CurrentInfo), GetExceptionType(ex), ex.Message, ex.Source, text);
					}
					else
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_IndividualErrorInnerException"), GetExceptionType(ex), ex.Message, ex.Source, text);
					}
				}
				return stringBuilder.ToString();
			}

			private static string GetExceptionType(Exception exception)
			{
				if (exception is DeploymentException ex)
				{
					if (ex.SubType != 0)
					{
						return string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_ExceptionType"), new object[2]
						{
							ex.GetType().ToString(),
							ex.SubType.ToString()
						});
					}
					return string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_ExceptionTypeUnknown"), new object[1] { ex.GetType().ToString() });
				}
				return exception.GetType().ToString();
			}
		}

		protected class TransactionInformation : LogInformation
		{
			public class TransactionOperation
			{
				protected bool _failed;

				protected string _message = "";

				protected string _failureMessage = "";

				public bool Failed => _failed;

				public string FailureMessage => _failureMessage;

				public TransactionOperation(System.Deployment.Internal.Isolation.StoreTransactionOperation operation, uint disposition, int hresult)
				{
					AnalyzeTransactionOperation(operation, disposition, hresult);
				}

				public override string ToString()
				{
					return _message;
				}

				protected void AnalyzeTransactionOperation(System.Deployment.Internal.Isolation.StoreTransactionOperation operation, uint dispositionValue, int hresult)
				{
					string text = "";
					try
					{
						if (operation.Operation == System.Deployment.Internal.Isolation.StoreTransactionOperationType.StageComponent)
						{
							System.Deployment.Internal.Isolation.StoreOperationStageComponent storeOperationStageComponent = (System.Deployment.Internal.Isolation.StoreOperationStageComponent)Marshal.PtrToStructure(operation.Data.DataPtr, typeof(System.Deployment.Internal.Isolation.StoreOperationStageComponent));
							System.Deployment.Internal.Isolation.StoreOperationStageComponent.Disposition disposition = (System.Deployment.Internal.Isolation.StoreOperationStageComponent.Disposition)dispositionValue;
							text = disposition.ToString();
							_message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionStageComponent"), storeOperationStageComponent.GetType().ToString(), text, hresult, Path.GetFileName(storeOperationStageComponent.ManifestPath));
							if (disposition == System.Deployment.Internal.Isolation.StoreOperationStageComponent.Disposition.Failed)
							{
								_failureMessage = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionStageComponentFailure"), new object[1] { Path.GetFileName(storeOperationStageComponent.ManifestPath) });
								_failed = true;
							}
						}
						else if (operation.Operation == System.Deployment.Internal.Isolation.StoreTransactionOperationType.PinDeployment)
						{
							System.Deployment.Internal.Isolation.StoreOperationPinDeployment storeOperationPinDeployment = (System.Deployment.Internal.Isolation.StoreOperationPinDeployment)Marshal.PtrToStructure(operation.Data.DataPtr, typeof(System.Deployment.Internal.Isolation.StoreOperationPinDeployment));
							System.Deployment.Internal.Isolation.StoreOperationPinDeployment.Disposition disposition2 = (System.Deployment.Internal.Isolation.StoreOperationPinDeployment.Disposition)dispositionValue;
							text = disposition2.ToString();
							DefinitionAppId definitionAppId = new DefinitionAppId(storeOperationPinDeployment.Application);
							_message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionPinDeployment"), storeOperationPinDeployment.GetType().ToString(), text, hresult, definitionAppId.ToString());
							if (disposition2 == System.Deployment.Internal.Isolation.StoreOperationPinDeployment.Disposition.Failed)
							{
								_failureMessage = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionPinDeploymentFailure"), new object[1] { definitionAppId.ToString() });
								_failed = true;
							}
						}
						else if (operation.Operation == System.Deployment.Internal.Isolation.StoreTransactionOperationType.UnpinDeployment)
						{
							System.Deployment.Internal.Isolation.StoreOperationUnpinDeployment storeOperationUnpinDeployment = (System.Deployment.Internal.Isolation.StoreOperationUnpinDeployment)Marshal.PtrToStructure(operation.Data.DataPtr, typeof(System.Deployment.Internal.Isolation.StoreOperationUnpinDeployment));
							System.Deployment.Internal.Isolation.StoreOperationUnpinDeployment.Disposition disposition3 = (System.Deployment.Internal.Isolation.StoreOperationUnpinDeployment.Disposition)dispositionValue;
							text = disposition3.ToString();
							DefinitionAppId definitionAppId2 = new DefinitionAppId(storeOperationUnpinDeployment.Application);
							_message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionUnPinDeployment"), storeOperationUnpinDeployment.GetType().ToString(), text, hresult, definitionAppId2.ToString());
							if (disposition3 == System.Deployment.Internal.Isolation.StoreOperationUnpinDeployment.Disposition.Failed)
							{
								_failureMessage = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionUnPinDeploymentFailure"), new object[1] { definitionAppId2.ToString() });
								_failed = true;
							}
						}
						else if (operation.Operation == System.Deployment.Internal.Isolation.StoreTransactionOperationType.InstallDeployment)
						{
							System.Deployment.Internal.Isolation.StoreOperationInstallDeployment storeOperationInstallDeployment = (System.Deployment.Internal.Isolation.StoreOperationInstallDeployment)Marshal.PtrToStructure(operation.Data.DataPtr, typeof(System.Deployment.Internal.Isolation.StoreOperationInstallDeployment));
							System.Deployment.Internal.Isolation.StoreOperationInstallDeployment.Disposition disposition4 = (System.Deployment.Internal.Isolation.StoreOperationInstallDeployment.Disposition)dispositionValue;
							text = disposition4.ToString();
							DefinitionAppId definitionAppId3 = new DefinitionAppId(storeOperationInstallDeployment.Application);
							_message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionInstallDeployment"), storeOperationInstallDeployment.GetType().ToString(), text, hresult, definitionAppId3.ToString());
							if (disposition4 == System.Deployment.Internal.Isolation.StoreOperationInstallDeployment.Disposition.Failed)
							{
								_failureMessage = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionInstallDeploymentFailure"), new object[1] { definitionAppId3.ToString() });
								_failed = true;
							}
						}
						else if (operation.Operation == System.Deployment.Internal.Isolation.StoreTransactionOperationType.UninstallDeployment)
						{
							System.Deployment.Internal.Isolation.StoreOperationUninstallDeployment storeOperationUninstallDeployment = (System.Deployment.Internal.Isolation.StoreOperationUninstallDeployment)Marshal.PtrToStructure(operation.Data.DataPtr, typeof(System.Deployment.Internal.Isolation.StoreOperationUninstallDeployment));
							System.Deployment.Internal.Isolation.StoreOperationUninstallDeployment.Disposition disposition5 = (System.Deployment.Internal.Isolation.StoreOperationUninstallDeployment.Disposition)dispositionValue;
							text = disposition5.ToString();
							DefinitionAppId definitionAppId4 = new DefinitionAppId(storeOperationUninstallDeployment.Application);
							_message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionUninstallDeployment"), storeOperationUninstallDeployment.GetType().ToString(), text, hresult, definitionAppId4.ToString());
							if (disposition5 == System.Deployment.Internal.Isolation.StoreOperationUninstallDeployment.Disposition.Failed)
							{
								_failureMessage = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionUninstallDeploymentFailure"), new object[1] { definitionAppId4.ToString() });
								_failed = true;
							}
						}
						else if (operation.Operation == System.Deployment.Internal.Isolation.StoreTransactionOperationType.SetDeploymentMetadata)
						{
							System.Deployment.Internal.Isolation.StoreOperationSetDeploymentMetadata storeOperationSetDeploymentMetadata = (System.Deployment.Internal.Isolation.StoreOperationSetDeploymentMetadata)Marshal.PtrToStructure(operation.Data.DataPtr, typeof(System.Deployment.Internal.Isolation.StoreOperationSetDeploymentMetadata));
							System.Deployment.Internal.Isolation.StoreOperationSetDeploymentMetadata.Disposition disposition6 = (System.Deployment.Internal.Isolation.StoreOperationSetDeploymentMetadata.Disposition)dispositionValue;
							text = disposition6.ToString();
							_message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionSetDeploymentMetadata"), new object[3]
							{
								storeOperationSetDeploymentMetadata.GetType().ToString(),
								text,
								hresult
							});
							if (disposition6 == System.Deployment.Internal.Isolation.StoreOperationSetDeploymentMetadata.Disposition.Failed)
							{
								_failureMessage = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionSetDeploymentMetadataFailure"));
								_failed = true;
							}
						}
						else if (operation.Operation == System.Deployment.Internal.Isolation.StoreTransactionOperationType.StageComponentFile)
						{
							System.Deployment.Internal.Isolation.StoreOperationStageComponentFile storeOperationStageComponentFile = (System.Deployment.Internal.Isolation.StoreOperationStageComponentFile)Marshal.PtrToStructure(operation.Data.DataPtr, typeof(System.Deployment.Internal.Isolation.StoreOperationStageComponentFile));
							System.Deployment.Internal.Isolation.StoreOperationStageComponentFile.Disposition disposition7 = (System.Deployment.Internal.Isolation.StoreOperationStageComponentFile.Disposition)dispositionValue;
							text = disposition7.ToString();
							_message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionStageComponentFile"), storeOperationStageComponentFile.GetType().ToString(), text, hresult, storeOperationStageComponentFile.ComponentRelativePath);
							if (disposition7 == System.Deployment.Internal.Isolation.StoreOperationStageComponentFile.Disposition.Failed)
							{
								_failureMessage = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionStageComponentFileFailure"), new object[1] { storeOperationStageComponentFile.ComponentRelativePath });
								_failed = true;
							}
						}
						else
						{
							_message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionUnknownOperation"), new object[3]
							{
								operation.Operation.GetType().ToString(),
								(uint)operation.Operation,
								hresult
							});
						}
					}
					catch (FormatException)
					{
					}
					catch (ArgumentException)
					{
					}
				}
			}

			protected ArrayList _operations = new ArrayList();

			protected bool _failed;

			public bool Failed => _failed;

			public string FailureSummary
			{
				get
				{
					if (Failed)
					{
						StringBuilder stringBuilder = new StringBuilder();
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionFailureSummaryItem"), new object[1] { base.Time.ToString(DateTimeFormatInfo.CurrentInfo) });
						foreach (TransactionOperation operation in _operations)
						{
							if (operation.Failed)
							{
								stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionFailureSummaryBullets"), new object[1] { operation.FailureMessage });
							}
						}
						return stringBuilder.ToString();
					}
					return Resources.GetString("LogFile_TransactionFailureSummaryNoFailure");
				}
			}

			public TransactionInformation(System.Deployment.Internal.Isolation.StoreTransactionOperation[] storeOperations, uint[] rgDispositions, int[] rgResults, DateTime time)
				: base(null, time)
			{
				int num = Math.Min(Math.Min(storeOperations.Length, rgDispositions.Length), rgResults.Length);
				int num2 = 0;
				for (num2 = 0; num2 < num; num2++)
				{
					TransactionOperation transactionOperation = new TransactionOperation(storeOperations[num2], rgDispositions[num2], rgResults[num2]);
					_operations.Add(transactionOperation);
					if (transactionOperation.Failed)
					{
						_failed = true;
					}
				}
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionItem"), new object[1] { base.Time.ToString(DateTimeFormatInfo.CurrentInfo) });
				foreach (TransactionOperation operation in _operations)
				{
					stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_TransactionBullets"), new object[1] { operation });
				}
				return stringBuilder.ToString();
			}
		}

		protected class HeaderSection : LogInformation
		{
			public HeaderSection()
			{
				_message = GenerateLogHeaderText();
			}

			public override string ToString()
			{
				return _message;
			}

			protected static string GetModulePathInSystemFolder(string moduleName)
			{
				try
				{
					return Path.Combine(Environment.SystemDirectory, moduleName);
				}
				catch (ArgumentException)
				{
					return null;
				}
			}

			protected static string GetModulePathInClrFolder(string moduleName)
			{
				string text = null;
				try
				{
					string runtimeDirectory = RuntimeEnvironment.GetRuntimeDirectory();
					return Path.Combine(runtimeDirectory, moduleName);
				}
				catch (ArgumentException)
				{
					return null;
				}
			}

			protected static string GetModulePath(string moduleName)
			{
				string text = NativeMethods.GetLoadedModulePath(moduleName);
				if (text == null)
				{
					text = GetModulePathInClrFolder(moduleName);
					if (text == null)
					{
						text = GetModulePathInSystemFolder(moduleName);
					}
				}
				return text;
			}

			protected static string GetExecutingAssemblyPath()
			{
				Assembly executingAssembly = Assembly.GetExecutingAssembly();
				return executingAssembly.Location;
			}

			protected static FileVersionInfo GetVersionInfo(string modulePath)
			{
				FileVersionInfo result = null;
				if (modulePath != null && System.IO.File.Exists(modulePath))
				{
					try
					{
						result = FileVersionInfo.GetVersionInfo(modulePath);
						return result;
					}
					catch (FileNotFoundException)
					{
						return result;
					}
				}
				return result;
			}

			protected static string GenerateLogHeaderText()
			{
				string executingAssemblyPath = GetExecutingAssemblyPath();
				string modulePathInClrFolder = GetModulePathInClrFolder("clr.dll");
				string modulePathInClrFolder2 = GetModulePathInClrFolder("dfdll.dll");
				string modulePath = GetModulePath("dfshim.dll");
				FileVersionInfo versionInfo = GetVersionInfo(executingAssemblyPath);
				if (versionInfo == null)
				{
					executingAssemblyPath = GetModulePathInClrFolder("system.deployment.dll");
					versionInfo = GetVersionInfo(executingAssemblyPath);
				}
				FileVersionInfo versionInfo2 = GetVersionInfo(modulePathInClrFolder);
				FileVersionInfo versionInfo3 = GetVersionInfo(modulePathInClrFolder2);
				FileVersionInfo versionInfo4 = GetVersionInfo(modulePath);
				StringBuilder stringBuilder = new StringBuilder();
				try
				{
					stringBuilder.Append(Resources.GetString("LogFile_Header"));
					stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_HeaderOSVersion"), new object[2]
					{
						Environment.OSVersion.Platform.ToString(),
						Environment.OSVersion.Version.ToString()
					});
					stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_HeaderCLRVersion"), new object[1] { Environment.Version.ToString() });
					if (versionInfo != null)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_HeaderSystemDeploymentVersion"), new object[1] { versionInfo.FileVersion });
					}
					if (versionInfo2 != null)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_HeaderClrDllVersion"), new object[1] { versionInfo2.FileVersion });
					}
					if (versionInfo3 != null)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_HeaderDfdllVersion"), new object[1] { versionInfo3.FileVersion });
					}
					if (versionInfo4 != null)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_HeaderDfshimVersion"), new object[1] { versionInfo4.FileVersion });
					}
				}
				catch (ArgumentException)
				{
				}
				catch (FormatException)
				{
				}
				return stringBuilder.ToString();
			}
		}

		protected class SourceSection : LogInformation
		{
			protected Uri _subscriptonUri;

			protected Uri _deploymentProviderUri;

			protected Uri _applicationUri;

			protected ServerInformation _subscriptionServerInformation;

			protected ServerInformation _deploymentProviderServerInformation;

			protected ServerInformation _applicationServerInformation;

			public Uri SubscriptionUri
			{
				set
				{
					_subscriptonUri = value;
				}
			}

			public Uri DeploymentProviderUri
			{
				set
				{
					_deploymentProviderUri = value;
				}
			}

			public Uri ApplicationUri
			{
				set
				{
					_applicationUri = value;
				}
			}

			public ServerInformation SubscriptionServerInformation
			{
				set
				{
					_subscriptionServerInformation = value;
				}
			}

			public ServerInformation DeploymentProviderServerInformation
			{
				set
				{
					_deploymentProviderServerInformation = value;
				}
			}

			public ServerInformation ApplicationServerInformation
			{
				set
				{
					_applicationServerInformation = value;
				}
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				if (_subscriptonUri != null || _deploymentProviderUri != null || _applicationUri != null)
				{
					stringBuilder.Append(Resources.GetString("LogFile_Source"));
					if (_subscriptonUri != null)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_SourceDeploymentUrl"), new object[1] { _subscriptonUri.AbsoluteUri });
					}
					if (_subscriptionServerInformation != null)
					{
						AppendServerInformation(stringBuilder, _subscriptionServerInformation);
					}
					if (_deploymentProviderUri != null)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_SourceDeploymentProviderUrl"), new object[1] { _deploymentProviderUri.AbsoluteUri });
					}
					if (_deploymentProviderServerInformation != null)
					{
						AppendServerInformation(stringBuilder, _deploymentProviderServerInformation);
					}
					if (_applicationUri != null)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_SourceApplicationUrl"), new object[1] { _applicationUri.AbsoluteUri });
					}
					if (_applicationServerInformation != null)
					{
						AppendServerInformation(stringBuilder, _applicationServerInformation);
					}
					stringBuilder.Append(Environment.NewLine);
				}
				return stringBuilder.ToString();
			}

			private static void AppendServerInformation(StringBuilder destination, ServerInformation serverInformation)
			{
				if (!string.IsNullOrEmpty(serverInformation.Server))
				{
					destination.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_ServerInformationServer"), new object[1] { serverInformation.Server });
				}
				if (!string.IsNullOrEmpty(serverInformation.PoweredBy))
				{
					destination.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_ServerInformationPoweredBy"), new object[1] { serverInformation.PoweredBy });
				}
				if (!string.IsNullOrEmpty(serverInformation.AspNetVersion))
				{
					destination.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_ServerInformationAspNetVersion"), new object[1] { serverInformation.AspNetVersion });
				}
			}
		}

		protected class IdentitySection : LogInformation
		{
			protected DefinitionIdentity _deploymentIdentity;

			protected DefinitionIdentity _applicationIdentity;

			public DefinitionIdentity DeploymentIdentity
			{
				get
				{
					return _deploymentIdentity;
				}
				set
				{
					_deploymentIdentity = value;
				}
			}

			public DefinitionIdentity ApplicationIdentity
			{
				set
				{
					_applicationIdentity = value;
				}
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				if (_deploymentIdentity != null || _applicationIdentity != null)
				{
					stringBuilder.Append(Resources.GetString("LogFile_Identity"));
					if (_deploymentIdentity != null)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_IdentityDeploymentIdentity"), new object[1] { _deploymentIdentity.ToString() });
					}
					if (_applicationIdentity != null)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_IdentityApplicationIdentity"), new object[1] { _applicationIdentity.ToString() });
					}
					stringBuilder.Append(Environment.NewLine);
				}
				return stringBuilder.ToString();
			}
		}

		protected class SummarySection : LogInformation
		{
			protected AssemblyManifest _deploymentManifest;

			protected AssemblyManifest _applicationManifest;

			public AssemblyManifest DeploymentManifest
			{
				set
				{
					_deploymentManifest = value;
				}
			}

			public AssemblyManifest ApplicationManifest
			{
				set
				{
					_applicationManifest = value;
				}
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				if (_deploymentManifest != null)
				{
					stringBuilder.Append(Resources.GetString("LogFile_Summary"));
					if (_deploymentManifest.Deployment.Install)
					{
						stringBuilder.Append(Resources.GetString("LogFile_SummaryInstallableApp"));
					}
					else
					{
						stringBuilder.Append(Resources.GetString("LogFile_SummaryOnlineOnlyApp"));
					}
					if (_deploymentManifest.Deployment.TrustURLParameters)
					{
						stringBuilder.Append(Resources.GetString("LogFile_SummaryTrustUrlParameterSet"));
					}
					if (_applicationManifest != null && _applicationManifest.EntryPoints[0].HostInBrowser)
					{
						stringBuilder.Append(Resources.GetString("LogFile_SummaryBrowserHostedApp"));
					}
					stringBuilder.Append(Environment.NewLine);
				}
				return stringBuilder.ToString();
			}
		}

		protected class ErrorSection : LogInformation
		{
			protected ArrayList _errors = new ArrayList();

			public string ErrorSummary
			{
				get
				{
					StringBuilder stringBuilder = new StringBuilder();
					stringBuilder.Append(Resources.GetString("LogFile_ErrorSummary"));
					if (_errors.Count > 0)
					{
						stringBuilder.Append(Resources.GetString("LogFile_ErrorSummaryStatusError"));
						foreach (ErrorInformation error in _errors)
						{
							stringBuilder.Append(error.Summary);
						}
					}
					else
					{
						stringBuilder.Append(Resources.GetString("LogFile_ErrorSummaryStatusNoError"));
					}
					return stringBuilder.ToString();
				}
			}

			public void AddError(string message, Exception exception, DateTime time)
			{
				ErrorInformation value = new ErrorInformation(message, exception, time);
				_errors.Add(value);
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(Resources.GetString("LogFile_Error"));
				if (_errors.Count > 0)
				{
					stringBuilder.Append(Resources.GetString("LogFile_ErrorStatusError"));
					foreach (ErrorInformation error in _errors)
					{
						stringBuilder.Append(error.ToString());
					}
				}
				else
				{
					stringBuilder.Append(Resources.GetString("LogFile_ErrorStatusNoError"));
				}
				return stringBuilder.ToString();
			}
		}

		protected class WarningSection : LogInformation
		{
			protected ArrayList _warnings = new ArrayList();

			public void AddWarning(string message, DateTime time)
			{
				LogInformation value = new LogInformation(message, time);
				_warnings.Add(value);
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(Resources.GetString("LogFile_Warning"));
				if (_warnings.Count > 0)
				{
					foreach (LogInformation warning in _warnings)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_WarningStatusIndivualWarning"), new object[1] { warning.Message });
					}
				}
				else
				{
					stringBuilder.Append(Resources.GetString("LogFile_WarningStatusNoWarning"));
				}
				return stringBuilder.ToString();
			}
		}

		protected class PhaseSection : LogInformation
		{
			protected ArrayList _phaseInformations = new ArrayList();

			public void AddPhaseInformation(string phaseMessage, DateTime time)
			{
				LogInformation value = new LogInformation(phaseMessage, time);
				_phaseInformations.Add(value);
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(Resources.GetString("LogFile_PhaseInformation"));
				if (_phaseInformations.Count > 0)
				{
					foreach (LogInformation phaseInformation in _phaseInformations)
					{
						stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("LogFile_PhaseInformationStatusIndivualPhaseInformation"), new object[2]
						{
							phaseInformation.Time.ToString(DateTimeFormatInfo.CurrentInfo),
							phaseInformation.Message
						});
					}
				}
				else
				{
					stringBuilder.Append(Resources.GetString("LogFile_PhaseInformationStatusNoPhaseInformation"));
				}
				return stringBuilder.ToString();
			}
		}

		protected class ExecutionFlowSection : LogInformation
		{
			protected ArrayList _executionFlow = new ArrayList();

			private static DateTimeFormatInfo DTFI = CultureInfo.InvariantCulture.DateTimeFormat;

			public void AddMethodCall(string phaseMessage, DateTime time)
			{
				phaseMessage = "Method Call : " + phaseMessage;
				LogInformation value = new LogInformation(phaseMessage, time);
				_executionFlow.Add(value);
			}

			public void AddInternalState(string phaseMessage, DateTime time)
			{
				LogInformation value = new LogInformation(phaseMessage, time);
				_executionFlow.Add(value);
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("DETAILED EXECUTION FLOW\r\n");
				if (_executionFlow.Count > 0)
				{
					foreach (LogInformation item in _executionFlow)
					{
						stringBuilder.AppendFormat("[{0}] : {1}\r\n", item.Time.ToString(DTFI.LongTimePattern, CultureInfo.InvariantCulture), item.Message);
					}
				}
				else
				{
					stringBuilder.Append("No detailed execution log found.");
				}
				return stringBuilder.ToString();
			}
		}

		protected class TransactionSection : LogInformation
		{
			protected ArrayList _transactionInformations = new ArrayList();

			protected ArrayList _failedTransactionInformations = new ArrayList();

			public string FailureSummary
			{
				get
				{
					StringBuilder stringBuilder = new StringBuilder();
					stringBuilder.Append(Resources.GetString("LogFile_TransactionFailureSummary"));
					if (_failedTransactionInformations.Count > 0)
					{
						foreach (TransactionInformation failedTransactionInformation in _failedTransactionInformations)
						{
							stringBuilder.Append(failedTransactionInformation.FailureSummary);
						}
					}
					else
					{
						stringBuilder.Append(Resources.GetString("LogFile_TransactionFailureSummaryNoError"));
					}
					return stringBuilder.ToString();
				}
			}

			public void AddTransactionInformation(System.Deployment.Internal.Isolation.StoreTransactionOperation[] storeOperations, uint[] rgDispositions, int[] rgResults, DateTime time)
			{
				TransactionInformation transactionInformation = new TransactionInformation(storeOperations, rgDispositions, rgResults, time);
				_transactionInformations.Add(transactionInformation);
				if (transactionInformation.Failed)
				{
					_failedTransactionInformations.Add(transactionInformation);
				}
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(Resources.GetString("LogFile_Transaction"));
				if (_transactionInformations.Count > 0)
				{
					foreach (TransactionInformation transactionInformation in _transactionInformations)
					{
						stringBuilder.Append(transactionInformation.ToString());
					}
				}
				else
				{
					stringBuilder.Append(Resources.GetString("LogFile_TransactionNoTransaction"));
				}
				return stringBuilder.ToString();
			}
		}

		public class LogIdentity
		{
			protected readonly long _ticks = DateTime.Now.Ticks;

			protected readonly uint _threadId = NativeMethods.GetCurrentThreadId();

			protected string _logIdentityStringForm;

			public uint ThreadId => _threadId;

			public override string ToString()
			{
				if (_logIdentityStringForm == null)
				{
					_logIdentityStringForm = string.Format(CultureInfo.InvariantCulture, "{0:x8}{1:x16}", new object[2] { _threadId, _ticks });
				}
				return _logIdentityStringForm;
			}
		}

		protected enum LogFileLocation
		{
			NoLogFile,
			RegistryBased,
			WinInetCache
		}

		protected SourceSection _sources = new SourceSection();

		protected IdentitySection _identities = new IdentitySection();

		protected SummarySection _summary = new SummarySection();

		protected ErrorSection _errors = new ErrorSection();

		protected WarningSection _warnings = new WarningSection();

		protected PhaseSection _phases = new PhaseSection();

		protected ExecutionFlowSection _executionFlow = new ExecutionFlowSection();

		protected TransactionSection _transactions = new TransactionSection();

		protected LogIdentity _logIdentity = new LogIdentity();

		protected string _logFilePath;

		protected string _urlName;

		protected LogFileLocation _logFileLocation;

		protected static object _logFileEncoding;

		protected static Hashtable _loggerCollection = new Hashtable();

		protected static Hashtable _threadLogIdTable = new Hashtable();

		protected static object _logAccessLock = new object();

		protected static bool _detailedLoggingEnabled = PolicyKeys.ProduceDetailedExecutionSectionInLog();

		protected static object _header;

		protected TransactionSection Transactions => _transactions;

		protected ErrorSection Errors => _errors;

		protected WarningSection Warnings => _warnings;

		protected PhaseSection Phases => _phases;

		protected ExecutionFlowSection ExecutionFlow => _executionFlow;

		protected SourceSection Sources => _sources;

		protected IdentitySection Identities => _identities;

		protected SummarySection Summary => _summary;

		protected LogIdentity Identity => _logIdentity;

		protected string LogFilePath
		{
			get
			{
				if (_logFilePath == null)
				{
					_logFilePath = GetRegitsryBasedLogFilePath();
					if (_logFilePath == null)
					{
						_logFilePath = GetWinInetBasedLogFilePath();
						if (_logFilePath != null)
						{
							_logFileLocation = LogFileLocation.WinInetCache;
						}
					}
					else
					{
						_logFileLocation = LogFileLocation.RegistryBased;
					}
				}
				return _logFilePath;
			}
		}

		protected static Encoding LogFileEncoding
		{
			get
			{
				if (_logFileEncoding == null)
				{
					Encoding encoding = null;
					encoding = ((!PlatformSpecific.OnWin9x) ? Encoding.Unicode : Encoding.Default);
					Interlocked.CompareExchange(ref _logFileEncoding, encoding, null);
				}
				return (Encoding)_logFileEncoding;
			}
		}

		protected static HeaderSection Header
		{
			get
			{
				if (_header == null)
				{
					object value = new HeaderSection();
					Interlocked.CompareExchange(ref _header, value, null);
				}
				return (HeaderSection)_header;
			}
		}

		protected Logger()
		{
		}

		protected static string GetRegitsryBasedLogFilePath()
		{
			string result = null;
			try
			{
				using RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Classes\\Software\\Microsoft\\Windows\\CurrentVersion\\Deployment");
				if (registryKey != null)
				{
					result = registryKey.GetValue("LogFilePath") as string;
					return result;
				}
				return result;
			}
			catch (ArgumentException)
			{
				return result;
			}
			catch (ObjectDisposedException)
			{
				return result;
			}
			catch (SecurityException)
			{
				return result;
			}
		}

		protected string GetWinInetBasedLogFilePath()
		{
			try
			{
				string text = "System_Deployment_Log_";
				if (Identities.DeploymentIdentity != null)
				{
					text += Identities.DeploymentIdentity.KeyForm;
				}
				text = string.Format(CultureInfo.InvariantCulture, "{0}_{1}", new object[2]
				{
					text,
					Identity.ToString()
				});
				StringBuilder stringBuilder = new StringBuilder(261);
				if (!NativeMethods.CreateUrlCacheEntry(text, 0, "log", stringBuilder, 0))
				{
					return null;
				}
				_urlName = text;
				return stringBuilder.ToString();
			}
			catch (COMException)
			{
				return null;
			}
			catch (SEHException)
			{
				return null;
			}
			catch (FormatException)
			{
				return null;
			}
		}

		protected FileStream CreateLogFileStream()
		{
			FileStream result = null;
			string logFilePath = LogFilePath;
			if (logFilePath == null)
			{
				return null;
			}
			for (uint num = 0u; num < 1000; num++)
			{
				try
				{
					if (_logFileLocation == LogFileLocation.RegistryBased)
					{
						result = new FileStream(logFilePath, FileMode.Append, FileAccess.Write, FileShare.None);
						return result;
					}
					result = new FileStream(logFilePath, FileMode.Create, FileAccess.Write, FileShare.None);
					return result;
				}
				catch (IOException)
				{
					if (num == 1000)
					{
						throw;
					}
				}
				Thread.Sleep(20);
			}
			return result;
		}

		protected bool FlushLogs()
		{
			FileStream fileStream = null;
			try
			{
				fileStream = CreateLogFileStream();
				if (fileStream == null)
				{
					return false;
				}
				StreamWriter streamWriter = new StreamWriter(fileStream, LogFileEncoding);
				streamWriter.WriteLine(Header);
				streamWriter.Write(Sources);
				streamWriter.Write(Identities);
				streamWriter.Write(Summary);
				streamWriter.WriteLine(Errors.ErrorSummary);
				streamWriter.WriteLine(Transactions.FailureSummary);
				streamWriter.WriteLine(Warnings);
				streamWriter.WriteLine(Phases);
				streamWriter.WriteLine(Errors);
				streamWriter.WriteLine(Transactions);
				if (_detailedLoggingEnabled)
				{
					streamWriter.WriteLine(ExecutionFlow);
				}
				streamWriter.Close();
				fileStream.Close();
			}
			catch (IOException)
			{
				return false;
			}
			catch (SecurityException)
			{
				return false;
			}
			catch (UnauthorizedAccessException)
			{
				return false;
			}
			return true;
		}

		protected void EndLogOperation()
		{
			if (FlushLogs() && _logFileLocation == LogFileLocation.WinInetCache)
			{
				NativeMethods.CommitUrlCacheEntry(_urlName, _logFilePath, 0L, 0L, 4u, null, 0, null, null);
			}
		}

		protected static uint GetCurrentLogThreadId()
		{
			return NativeMethods.GetCurrentThreadId();
		}

		protected static Logger GetCurrentThreadLogger()
		{
			Logger result = null;
			uint currentLogThreadId = GetCurrentLogThreadId();
			lock (_logAccessLock)
			{
				if (_threadLogIdTable.Contains(currentLogThreadId))
				{
					LogIdentity logIdentity = (LogIdentity)_threadLogIdTable[currentLogThreadId];
					if (_loggerCollection.Contains(logIdentity.ToString()))
					{
						return (Logger)_loggerCollection[logIdentity.ToString()];
					}
					return result;
				}
				return result;
			}
		}

		protected static Logger GetLogger(LogIdentity logIdentity)
		{
			Logger result = null;
			lock (_logAccessLock)
			{
				if (_loggerCollection.Contains(logIdentity.ToString()))
				{
					return (Logger)_loggerCollection[logIdentity.ToString()];
				}
				return result;
			}
		}

		protected static void AddLogger(Logger logger)
		{
			lock (_logAccessLock)
			{
				if (!_loggerCollection.Contains(logger.Identity.ToString()))
				{
					_loggerCollection.Add(logger.Identity.ToString(), logger);
				}
			}
		}

		protected static void AddCurrentThreadLogger(Logger logger)
		{
			lock (_logAccessLock)
			{
				if (_threadLogIdTable.Contains(logger.Identity.ThreadId))
				{
					_threadLogIdTable.Remove(logger.Identity.ThreadId);
				}
				_threadLogIdTable.Add(logger.Identity.ThreadId, logger.Identity);
				if (!_loggerCollection.Contains(logger.Identity.ToString()))
				{
					_loggerCollection.Add(logger.Identity.ToString(), logger);
				}
			}
		}

		protected static void RemoveLogger(LogIdentity logIdentity)
		{
			lock (_logAccessLock)
			{
				if (_loggerCollection.Contains(logIdentity.ToString()))
				{
					_loggerCollection.Remove(logIdentity.ToString());
				}
			}
		}

		protected static void RemoveCurrentThreadLogger()
		{
			lock (_logAccessLock)
			{
				uint currentLogThreadId = GetCurrentLogThreadId();
				if (_threadLogIdTable.Contains(currentLogThreadId))
				{
					LogIdentity logIdentity = (LogIdentity)_threadLogIdTable[currentLogThreadId];
					_threadLogIdTable.Remove(currentLogThreadId);
					if (_loggerCollection.Contains(logIdentity.ToString()))
					{
						_loggerCollection.Remove(logIdentity.ToString());
					}
				}
			}
		}

		internal static LogIdentity StartCurrentThreadLogging()
		{
			EndCurrentThreadLogging();
			Logger logger = new Logger();
			AddCurrentThreadLogger(logger);
			return logger.Identity;
		}

		internal static void EndCurrentThreadLogging()
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					currentThreadLogger.EndLogOperation();
				}
				RemoveCurrentThreadLogger();
			}
		}

		internal static LogIdentity StartLogging()
		{
			Logger logger = new Logger();
			AddLogger(logger);
			return logger.Identity;
		}

		internal static void EndLogging(LogIdentity logIdentity)
		{
			try
			{
				Logger logger = GetLogger(logIdentity);
				if (logger != null)
				{
					lock (logger)
					{
						logger.EndLogOperation();
					}
				}
				RemoveLogger(logIdentity);
			}
			catch (Exception exception)
			{
				if (ExceptionUtility.IsHardException(exception))
				{
					throw;
				}
			}
		}

		internal static void SetSubscriptionUrl(Uri subscriptionUri)
		{
			GetCurrentThreadLogger()?.SetSubscriptionUri(subscriptionUri);
		}

		internal static void SetSubscriptionUrl(LogIdentity log, Uri subscriptionUri)
		{
			GetLogger(log)?.SetSubscriptionUri(subscriptionUri);
		}

		private void SetSubscriptionUri(Uri subscriptionUri)
		{
			lock (this)
			{
				Sources.SubscriptionUri = subscriptionUri;
			}
		}

		internal static void SetSubscriptionServerInformation(ServerInformation serverInformation)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					currentThreadLogger.Sources.SubscriptionServerInformation = serverInformation;
				}
			}
		}

		internal static void SetSubscriptionUrl(string subscrioptionUrl)
		{
			try
			{
				Uri subscriptionUrl = new Uri(subscrioptionUrl);
				SetSubscriptionUrl(subscriptionUrl);
			}
			catch (UriFormatException)
			{
			}
		}

		internal static void SetDeploymentProviderUrl(Uri deploymentProviderUri)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					currentThreadLogger.Sources.DeploymentProviderUri = deploymentProviderUri;
				}
			}
		}

		internal static void SetDeploymentProviderServerInformation(ServerInformation serverInformation)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					currentThreadLogger.Sources.DeploymentProviderServerInformation = serverInformation;
				}
			}
		}

		internal static void SetApplicationUrl(Uri applicationUri)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					currentThreadLogger.Sources.ApplicationUri = applicationUri;
				}
			}
		}

		internal static void SetApplicationUrl(LogIdentity log, Uri applicationUri)
		{
			Logger logger = GetLogger(log);
			if (logger != null)
			{
				lock (logger)
				{
					logger.Sources.ApplicationUri = applicationUri;
				}
			}
		}

		internal static void SetApplicationServerInformation(ServerInformation serverInformation)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					currentThreadLogger.Sources.ApplicationServerInformation = serverInformation;
				}
			}
		}

		internal static void SetTextualSubscriptionIdentity(string textualIdentity)
		{
			try
			{
				GetCurrentThreadLogger()?.SetTextualSubscriptionIdentity(new DefinitionIdentity(textualIdentity));
			}
			catch (COMException)
			{
			}
			catch (SEHException)
			{
			}
		}

		internal static void SetTextualSubscriptionIdentity(LogIdentity log, string textualIdentity)
		{
			try
			{
				GetLogger(log)?.SetTextualSubscriptionIdentity(new DefinitionIdentity(textualIdentity));
			}
			catch (COMException)
			{
			}
			catch (SEHException)
			{
			}
		}

		internal void SetTextualSubscriptionIdentity(DefinitionIdentity definitionIdentity)
		{
			lock (this)
			{
				Identities.DeploymentIdentity = definitionIdentity;
			}
		}

		internal static void SetDeploymentManifest(AssemblyManifest deploymentManifest)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger == null)
			{
				return;
			}
			lock (currentThreadLogger)
			{
				if (deploymentManifest.Identity != null)
				{
					currentThreadLogger.Identities.DeploymentIdentity = deploymentManifest.Identity;
				}
				currentThreadLogger.Summary.DeploymentManifest = deploymentManifest;
			}
		}

		internal static void SetDeploymentManifest(LogIdentity log, AssemblyManifest deploymentManifest)
		{
			Logger logger = GetLogger(log);
			if (logger == null)
			{
				return;
			}
			lock (logger)
			{
				if (deploymentManifest.Identity != null)
				{
					logger.Identities.DeploymentIdentity = deploymentManifest.Identity;
				}
				logger.Summary.DeploymentManifest = deploymentManifest;
			}
		}

		internal static void SetApplicationManifest(AssemblyManifest applicationManifest)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger == null)
			{
				return;
			}
			lock (currentThreadLogger)
			{
				if (applicationManifest.Identity != null)
				{
					currentThreadLogger.Identities.ApplicationIdentity = applicationManifest.Identity;
				}
				currentThreadLogger.Summary.ApplicationManifest = applicationManifest;
			}
		}

		internal static void SetApplicationManifest(LogIdentity log, AssemblyManifest applicationManifest)
		{
			Logger logger = GetLogger(log);
			if (logger == null)
			{
				return;
			}
			lock (logger)
			{
				if (applicationManifest.Identity != null)
				{
					logger.Identities.ApplicationIdentity = applicationManifest.Identity;
				}
				logger.Summary.ApplicationManifest = applicationManifest;
			}
		}

		internal static void AddErrorInformation(string message, Exception exception, DateTime time)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					currentThreadLogger.Errors.AddError(message, exception, time);
				}
			}
		}

		internal static void AddErrorInformation(LogIdentity log, string message, Exception exception, DateTime time)
		{
			Logger logger = GetLogger(log);
			if (logger != null)
			{
				lock (logger)
				{
					logger.Errors.AddError(message, exception, time);
				}
			}
		}

		internal static void AddWarningInformation(string message, DateTime time)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					currentThreadLogger.Warnings.AddWarning(message, time);
				}
			}
		}

		internal static void AddPhaseInformation(string message, DateTime time)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					currentThreadLogger.Phases.AddPhaseInformation(message, time);
				}
			}
		}

		internal static void AddMethodCall(string message, DateTime time)
		{
			if (!_detailedLoggingEnabled)
			{
				return;
			}
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger == null)
			{
				return;
			}
			lock (currentThreadLogger)
			{
				currentThreadLogger.ExecutionFlow.AddMethodCall(message, time);
			}
		}

		internal static void AddMethodCall(LogIdentity log, string message, DateTime time)
		{
			if (!_detailedLoggingEnabled)
			{
				return;
			}
			Logger logger = GetLogger(log);
			if (logger == null)
			{
				return;
			}
			lock (logger)
			{
				logger.ExecutionFlow.AddMethodCall(message, time);
			}
		}

		internal static void AddInternalState(string message, DateTime time)
		{
			if (!_detailedLoggingEnabled)
			{
				return;
			}
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger == null)
			{
				return;
			}
			lock (currentThreadLogger)
			{
				currentThreadLogger.ExecutionFlow.AddInternalState(message, time);
			}
		}

		internal static void AddInternalState(LogIdentity log, string message, DateTime time)
		{
			if (!_detailedLoggingEnabled)
			{
				return;
			}
			Logger logger = GetLogger(log);
			if (logger == null)
			{
				return;
			}
			lock (logger)
			{
				logger.ExecutionFlow.AddInternalState(message, time);
			}
		}

		internal static void AddTransactionInformation(System.Deployment.Internal.Isolation.StoreTransactionOperation[] storeOperations, uint[] rgDispositions, int[] rgResults, DateTime time)
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					currentThreadLogger.Transactions.AddTransactionInformation(storeOperations, rgDispositions, rgResults, time);
				}
			}
		}

		internal static void AddErrorInformation(string message, Exception exception)
		{
			AddErrorInformation(message, exception, DateTime.Now);
		}

		internal static void AddErrorInformation(LogIdentity log, string message, Exception exception)
		{
			AddErrorInformation(log, message, exception, DateTime.Now);
		}

		internal static void AddErrorInformation(Exception exception, string messageFormat, params object[] args)
		{
			try
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.AppendFormat(messageFormat, args);
				AddErrorInformation(stringBuilder.ToString(), exception, DateTime.Now);
			}
			catch (FormatException)
			{
			}
		}

		internal static void AddWarningInformation(string message)
		{
			AddWarningInformation(message, DateTime.Now);
		}

		internal static void AddPhaseInformation(string message)
		{
			AddPhaseInformation(message, DateTime.Now);
		}

		internal static void AddMethodCall(string message)
		{
			AddMethodCall(message, DateTime.Now);
		}

		internal static void AddMethodCall(LogIdentity log, string message)
		{
			AddMethodCall(log, message, DateTime.Now);
		}

		internal static void AddMethodCall(string messageFormat, params object[] args)
		{
			if (!_detailedLoggingEnabled)
			{
				return;
			}
			try
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.AppendFormat(CultureInfo.InvariantCulture, messageFormat, args);
				AddMethodCall(stringBuilder.ToString(), DateTime.Now);
			}
			catch (FormatException)
			{
			}
		}

		internal static void AddInternalState(LogIdentity log, string message)
		{
			AddInternalState(log, message, DateTime.Now);
		}

		internal static void AddInternalState(string message)
		{
			AddInternalState(message, DateTime.Now);
		}

		internal static void AddPhaseInformation(string messageFormat, params object[] args)
		{
			try
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.AppendFormat(messageFormat, args);
				AddPhaseInformation(stringBuilder.ToString(), DateTime.Now);
			}
			catch (FormatException)
			{
			}
		}

		internal static void AddTransactionInformation(System.Deployment.Internal.Isolation.StoreTransactionOperation[] storeOperations, uint[] rgDispositions, int[] rgResults)
		{
			AddTransactionInformation(storeOperations, rgDispositions, rgResults, DateTime.Now);
		}

		internal static string GetLogFilePath()
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				return GetLogFilePath(currentThreadLogger);
			}
			return null;
		}

		internal static string GetLogFilePath(LogIdentity log)
		{
			Logger logger = GetLogger(log);
			if (logger != null)
			{
				return GetLogFilePath(logger);
			}
			return null;
		}

		internal static string GetLogFilePath(Logger logger)
		{
			if (logger == null)
			{
				return null;
			}
			lock (logger)
			{
				return logger.LogFilePath;
			}
		}

		internal static bool FlushCurrentThreadLogs()
		{
			Logger currentThreadLogger = GetCurrentThreadLogger();
			if (currentThreadLogger != null)
			{
				lock (currentThreadLogger)
				{
					return currentThreadLogger.FlushLogs();
				}
			}
			return false;
		}

		internal static bool FlushLog(LogIdentity log)
		{
			Logger logger = GetLogger(log);
			if (logger != null)
			{
				lock (logger)
				{
					return logger.FlushLogs();
				}
			}
			return false;
		}

		internal static string Serialize(WebRequest httpreq)
		{
			if (httpreq == null)
			{
				return "";
			}
			IWebProxy proxy = httpreq.Proxy;
			StringBuilder stringBuilder = new StringBuilder();
			if (proxy != null)
			{
				stringBuilder.Append(" Proxy.IsByPassed=" + proxy.IsBypassed(httpreq.RequestUri));
				stringBuilder.Append(", ProxyUri=" + proxy.GetProxy(httpreq.RequestUri));
			}
			else
			{
				stringBuilder.Append(" No proxy set.");
			}
			return stringBuilder.ToString();
		}

		internal static string Serialize(WebResponse response)
		{
			if (response == null)
			{
				return "";
			}
			string text = "";
			return text + "ResponseUri=" + response.ResponseUri;
		}

		internal static string Serialize(TrustManagerContext tmc)
		{
			if (tmc == null)
			{
				return "";
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("IgnorePersistedDecision=" + tmc.IgnorePersistedDecision);
			stringBuilder.Append(", NoPrompt=" + tmc.NoPrompt);
			stringBuilder.Append(", Persist=" + tmc.Persist);
			stringBuilder.Append(", PreviousApplicationIdentity = " + tmc.PreviousApplicationIdentity);
			return stringBuilder.ToString();
		}
	}
	internal class MaintenancePiece : ModalPiece
	{
		private Label lblHeader;

		private Label lblSubHeader;

		private PictureBox pictureDesktop;

		private PictureBox pictureRestore;

		private PictureBox pictureRemove;

		private RadioButton radioRestore;

		private RadioButton radioRemove;

		private GroupBox groupRule;

		private GroupBox groupDivider;

		private Button btnOk;

		private Button btnCancel;

		private Button btnHelp;

		private TableLayoutPanel okCancelHelpTableLayoutPanel;

		private TableLayoutPanel contentTableLayoutPanel;

		private TableLayoutPanel topTableLayoutPanel;

		private TableLayoutPanel overarchingTableLayoutPanel;

		private UserInterfaceInfo _info;

		private MaintenanceInfo _maintenanceInfo;

		public MaintenancePiece(UserInterfaceForm parentForm, UserInterfaceInfo info, MaintenanceInfo maintenanceInfo, ManualResetEvent modalEvent)
		{
			_modalResult = UserInterfaceModalResult.Cancel;
			_info = info;
			_maintenanceInfo = maintenanceInfo;
			_modalEvent = modalEvent;
			SuspendLayout();
			InitializeComponent();
			InitializeContent();
			ResumeLayout(performLayout: false);
			parentForm.SuspendLayout();
			parentForm.SwitchUserInterfacePiece(this);
			parentForm.Text = _info.formTitle;
			parentForm.MinimizeBox = false;
			parentForm.MaximizeBox = false;
			parentForm.ControlBox = true;
			lblHeader.Font = new Font(lblHeader.Font, lblHeader.Font.Style | FontStyle.Bold);
			parentForm.ActiveControl = btnCancel;
			parentForm.ResumeLayout(performLayout: false);
			parentForm.PerformLayout();
			parentForm.Visible = true;
		}

		private void InitializeComponent()
		{
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(System.Deployment.Application.MaintenancePiece));
			this.lblHeader = new System.Windows.Forms.Label();
			this.lblSubHeader = new System.Windows.Forms.Label();
			this.pictureRestore = new System.Windows.Forms.PictureBox();
			this.pictureRemove = new System.Windows.Forms.PictureBox();
			this.radioRestore = new System.Windows.Forms.RadioButton();
			this.radioRemove = new System.Windows.Forms.RadioButton();
			this.groupRule = new System.Windows.Forms.GroupBox();
			this.groupDivider = new System.Windows.Forms.GroupBox();
			this.btnOk = new System.Windows.Forms.Button();
			this.btnCancel = new System.Windows.Forms.Button();
			this.btnHelp = new System.Windows.Forms.Button();
			this.topTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.pictureDesktop = new System.Windows.Forms.PictureBox();
			this.okCancelHelpTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.contentTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.overarchingTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			((System.ComponentModel.ISupportInitialize)this.pictureRestore).BeginInit();
			((System.ComponentModel.ISupportInitialize)this.pictureRemove).BeginInit();
			this.topTableLayoutPanel.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)this.pictureDesktop).BeginInit();
			this.okCancelHelpTableLayoutPanel.SuspendLayout();
			this.contentTableLayoutPanel.SuspendLayout();
			this.overarchingTableLayoutPanel.SuspendLayout();
			base.SuspendLayout();
			this.lblHeader.AutoEllipsis = true;
			resources.ApplyResources(this.lblHeader, "lblHeader");
			this.lblHeader.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits11, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			this.lblHeader.Name = "lblHeader";
			this.lblHeader.UseMnemonic = false;
			resources.ApplyResources(this.lblSubHeader, "lblSubHeader");
			this.lblSubHeader.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits29, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits8);
			this.lblSubHeader.Name = "lblSubHeader";
			resources.ApplyResources(this.pictureRestore, "pictureRestore");
			this.pictureRestore.Margin = new System.Windows.Forms.Padding(0, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			this.pictureRestore.Name = "pictureRestore";
			this.pictureRestore.TabStop = false;
			this.pictureRestore.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			resources.ApplyResources(this.pictureRemove, "pictureRemove");
			this.pictureRemove.Margin = new System.Windows.Forms.Padding(0, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			this.pictureRemove.Name = "pictureRemove";
			this.pictureRemove.TabStop = false;
			this.pictureRemove.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			resources.ApplyResources(this.radioRestore, "radioRestore");
			this.radioRestore.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0, 0, 0);
			this.radioRestore.Name = "radioRestore";
			this.radioRestore.CheckedChanged += new System.EventHandler(radioRestore_CheckedChanged);
			resources.ApplyResources(this.radioRemove, "radioRemove");
			this.radioRemove.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0, 0, 0);
			this.radioRemove.Name = "radioRemove";
			this.radioRemove.CheckedChanged += new System.EventHandler(radioRemove_CheckedChanged);
			resources.ApplyResources(this.groupRule, "groupRule");
			this.groupRule.Margin = new System.Windows.Forms.Padding(0);
			this.groupRule.BackColor = System.Drawing.SystemColors.ControlDark;
			this.groupRule.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
			this.groupRule.Name = "groupRule";
			this.groupRule.TabStop = false;
			resources.ApplyResources(this.groupDivider, "groupDivider");
			this.groupDivider.Margin = new System.Windows.Forms.Padding(0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3);
			this.groupDivider.BackColor = System.Drawing.SystemColors.ControlDark;
			this.groupDivider.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
			this.groupDivider.Name = "groupDivider";
			this.groupDivider.TabStop = false;
			resources.ApplyResources(this.btnOk, "btnOk");
			this.btnOk.Margin = new System.Windows.Forms.Padding(0, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits4, 0);
			this.btnOk.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeWidth, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeHeight);
			this.btnOk.Name = "btnOk";
			this.btnOk.Padding = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, 0);
			this.btnOk.Click += new System.EventHandler(btnOk_Click);
			resources.ApplyResources(this.btnCancel, "btnCancel");
			this.btnCancel.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits2, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits2, 0);
			this.btnCancel.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeWidth, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeHeight);
			this.btnCancel.Name = "btnCancel";
			this.btnCancel.Padding = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, 0);
			this.btnCancel.Click += new System.EventHandler(btnCancel_Click);
			resources.ApplyResources(this.btnHelp, "btnHelp");
			this.btnHelp.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits4, 0, 0, 0);
			this.btnHelp.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeWidth, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeHeight);
			this.btnHelp.Name = "btnHelp";
			this.btnHelp.Padding = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, 0);
			this.btnHelp.Click += new System.EventHandler(btnHelp_Click);
			resources.ApplyResources(this.topTableLayoutPanel, "topTableLayoutPanel");
			this.topTableLayoutPanel.BackColor = System.Drawing.SystemColors.Window;
			this.topTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 87.2f));
			this.topTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 12.8f));
			this.topTableLayoutPanel.Controls.Add(this.pictureDesktop, 1, 0);
			this.topTableLayoutPanel.Controls.Add(this.lblHeader, 0, 0);
			this.topTableLayoutPanel.Controls.Add(this.lblSubHeader, 0, 1);
			this.topTableLayoutPanel.Margin = new System.Windows.Forms.Padding(0);
			this.topTableLayoutPanel.Name = "topTableLayoutPanel";
			this.topTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.topTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.topTableLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;
			resources.ApplyResources(this.pictureDesktop, "pictureDesktop");
			this.pictureDesktop.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0, 0, 0);
			this.pictureDesktop.Name = "pictureDesktop";
			this.topTableLayoutPanel.SetRowSpan(this.pictureDesktop, 2);
			this.pictureDesktop.TabStop = false;
			this.pictureDesktop.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			resources.ApplyResources(this.okCancelHelpTableLayoutPanel, "okCancelHelpTableLayoutPanel");
			this.okCancelHelpTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
			this.okCancelHelpTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
			this.okCancelHelpTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
			this.okCancelHelpTableLayoutPanel.Controls.Add(this.btnOk, 0, 0);
			this.okCancelHelpTableLayoutPanel.Controls.Add(this.btnCancel, 1, 0);
			this.okCancelHelpTableLayoutPanel.Controls.Add(this.btnHelp, 2, 0);
			this.okCancelHelpTableLayoutPanel.Margin = new System.Windows.Forms.Padding(0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits9, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits8, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits8);
			this.okCancelHelpTableLayoutPanel.Name = "okCancelHelpTableLayoutPanel";
			this.okCancelHelpTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			resources.ApplyResources(this.contentTableLayoutPanel, "contentTableLayoutPanel");
			this.contentTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
			this.contentTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100f));
			this.contentTableLayoutPanel.Controls.Add(this.pictureRestore, 0, 0);
			this.contentTableLayoutPanel.Controls.Add(this.pictureRemove, 0, 1);
			this.contentTableLayoutPanel.Controls.Add(this.radioRemove, 1, 1);
			this.contentTableLayoutPanel.Controls.Add(this.radioRestore, 1, 0);
			this.contentTableLayoutPanel.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits20, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits22, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits12, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits22);
			this.contentTableLayoutPanel.Name = "contentTableLayoutPanel";
			this.contentTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.contentTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.contentTableLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;
			resources.ApplyResources(this.overarchingTableLayoutPanel, "overarchingTableLayoutPanel");
			this.overarchingTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100f));
			this.overarchingTableLayoutPanel.Controls.Add(this.topTableLayoutPanel, 0, 0);
			this.overarchingTableLayoutPanel.Controls.Add(this.okCancelHelpTableLayoutPanel, 0, 4);
			this.overarchingTableLayoutPanel.Controls.Add(this.contentTableLayoutPanel, 0, 2);
			this.overarchingTableLayoutPanel.Controls.Add(this.groupDivider, 0, 3);
			this.overarchingTableLayoutPanel.Controls.Add(this.groupRule, 0, 1);
			this.overarchingTableLayoutPanel.Margin = new System.Windows.Forms.Padding(0);
			this.overarchingTableLayoutPanel.Name = "overarchingTableLayoutPanel";
			this.overarchingTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.overarchingTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.overarchingTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.overarchingTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.overarchingTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.overarchingTableLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;
			if (System.AccessibilityImprovements.Level3)
			{
				this.pictureDesktop.AccessibleName = System.Deployment.Application.Resources.GetString("ClickOnceGlobeIcon");
				this.pictureDesktop.AccessibleRole = System.Windows.Forms.AccessibleRole.Graphic;
				this.pictureRemove.AccessibleName = System.Deployment.Application.Resources.GetString("ClickOnceRemoveIcon");
				this.pictureRemove.AccessibleRole = System.Windows.Forms.AccessibleRole.Graphic;
				this.pictureRestore.AccessibleName = System.Deployment.Application.Resources.GetString("ClickOnceRestoreIcon");
				this.pictureRestore.AccessibleRole = System.Windows.Forms.AccessibleRole.Graphic;
				string text2 = (this.groupRule.AccessibleName = (this.groupDivider.AccessibleName = string.Empty));
				System.Windows.Forms.AccessibleRole accessibleRole3 = (this.groupRule.AccessibleRole = (this.groupDivider.AccessibleRole = System.Windows.Forms.AccessibleRole.Separator));
				this.topTableLayoutPanel.Controls.SetChildIndex(this.pictureDesktop, 2);
				this.topTableLayoutPanel.Controls.SetChildIndex(this.lblHeader, 0);
				this.topTableLayoutPanel.Controls.SetChildIndex(this.lblSubHeader, 1);
				this.contentTableLayoutPanel.Controls.SetChildIndex(this.pictureRestore, 0);
				this.contentTableLayoutPanel.Controls.SetChildIndex(this.radioRestore, 1);
				this.contentTableLayoutPanel.Controls.SetChildIndex(this.pictureRemove, 2);
				this.contentTableLayoutPanel.Controls.SetChildIndex(this.radioRemove, 3);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.topTableLayoutPanel, 0);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.groupRule, 1);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.contentTableLayoutPanel, 2);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.groupDivider, 3);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.okCancelHelpTableLayoutPanel, 4);
			}
			resources.ApplyResources(this, "$this");
			base.Controls.Add(this.overarchingTableLayoutPanel);
			base.Name = "MaintenancePiece";
			((System.ComponentModel.ISupportInitialize)this.pictureRestore).EndInit();
			((System.ComponentModel.ISupportInitialize)this.pictureRemove).EndInit();
			this.topTableLayoutPanel.ResumeLayout(false);
			this.topTableLayoutPanel.PerformLayout();
			((System.ComponentModel.ISupportInitialize)this.pictureDesktop).EndInit();
			this.okCancelHelpTableLayoutPanel.ResumeLayout(false);
			this.okCancelHelpTableLayoutPanel.PerformLayout();
			this.contentTableLayoutPanel.ResumeLayout(false);
			this.contentTableLayoutPanel.PerformLayout();
			this.overarchingTableLayoutPanel.ResumeLayout(false);
			this.overarchingTableLayoutPanel.PerformLayout();
			base.ResumeLayout(false);
			base.PerformLayout();
		}

		private void InitializeContent()
		{
			pictureDesktop.Image = Resources.GetIcon("form.ico").ToBitmap();
			pictureRestore.Enabled = (_maintenanceInfo.maintenanceFlags & MaintenanceFlags.RestorationPossible) != 0;
			pictureRestore.Image = Resources.GetIcon("restore.ico").ToBitmap();
			pictureRemove.Image = Resources.GetIcon("remove.ico").ToBitmap();
			lblHeader.Text = _info.productName;
			radioRestore.Checked = (_maintenanceInfo.maintenanceFlags & MaintenanceFlags.RestorationPossible) != 0;
			radioRestore.Enabled = (_maintenanceInfo.maintenanceFlags & MaintenanceFlags.RestorationPossible) != 0;
			radioRemove.Checked = (_maintenanceInfo.maintenanceFlags & MaintenanceFlags.RestorationPossible) == 0;
			btnHelp.Enabled = UserInterface.IsValidHttpUrl(_info.supportUrl);
		}

		private void btnOk_Click(object sender, EventArgs e)
		{
			_modalResult = UserInterfaceModalResult.Ok;
			_modalEvent.Set();
			base.Enabled = false;
		}

		private void btnCancel_Click(object sender, EventArgs e)
		{
			_modalResult = UserInterfaceModalResult.Cancel;
			_modalEvent.Set();
			base.Enabled = false;
		}

		private void btnHelp_Click(object sender, EventArgs e)
		{
			if (UserInterface.IsValidHttpUrl(_info.supportUrl))
			{
				UserInterface.LaunchUrlInBrowser(_info.supportUrl);
			}
		}

		private void radioRestore_CheckedChanged(object sender, EventArgs e)
		{
			if (radioRestore.Checked)
			{
				_maintenanceInfo.maintenanceFlags |= MaintenanceFlags.RestoreSelected;
			}
			else
			{
				_maintenanceInfo.maintenanceFlags &= ~MaintenanceFlags.RestoreSelected;
			}
		}

		private void radioRemove_CheckedChanged(object sender, EventArgs e)
		{
			if (radioRemove.Checked)
			{
				_maintenanceInfo.maintenanceFlags |= MaintenanceFlags.RemoveSelected;
			}
			else
			{
				_maintenanceInfo.maintenanceFlags &= ~MaintenanceFlags.RemoveSelected;
			}
		}
	}
	[Flags]
	internal enum MaintenanceFlags
	{
		ClearFlag = 0,
		RestorationPossible = 1,
		RestoreSelected = 2,
		RemoveSelected = 4
	}
	internal class MaintenanceInfo
	{
		public MaintenanceFlags maintenanceFlags;
	}
	internal static class ManifestGenerator
	{
		private const string AssemblyTemplateResource = "AssemblyTemplate.xml";

		private static object assemblyTemplateDoc;

		private static object GACDetectionTempManifestAsmId;

		public static DefinitionIdentity GenerateManifest(ReferenceIdentity suggestedReferenceIdentity, AssemblyManifest manifest, string outputManifest)
		{
			DefinitionIdentity identity = manifest.Identity;
			if (manifest.RawXmlBytes != null)
			{
				using (FileStream fileStream = System.IO.File.Open(outputManifest, FileMode.CreateNew, FileAccess.Write))
				{
					fileStream.Write(manifest.RawXmlBytes, 0, manifest.RawXmlBytes.Length);
					return identity;
				}
			}
			XmlDocument xmlDocument = CloneAssemblyTemplate();
			identity = new DefinitionIdentity(suggestedReferenceIdentity);
			InjectIdentityXml(xmlDocument, identity);
			AddFiles(xmlDocument, manifest.Files);
			AddDependencies(xmlDocument, manifest.DependentAssemblies);
			using FileStream outStream = System.IO.File.Open(outputManifest, FileMode.CreateNew, FileAccess.Write);
			xmlDocument.Save(outStream);
			return identity;
		}

		public static void GenerateGACDetectionManifest(ReferenceIdentity refId, string outputManifest)
		{
			XmlDocument xmlDocument = CloneAssemblyTemplate();
			if (GACDetectionTempManifestAsmId == null)
			{
				Interlocked.CompareExchange(ref GACDetectionTempManifestAsmId, new DefinitionIdentity("GACDetectionTempManifest, version=1.0.0.0, type=win32"), null);
			}
			InjectIdentityXml(xmlDocument, (DefinitionIdentity)GACDetectionTempManifestAsmId);
			AddDependencies(xmlDocument, new DependentAssembly[1]
			{
				new DependentAssembly(refId)
			});
			using FileStream outStream = System.IO.File.Open(outputManifest, FileMode.CreateNew, FileAccess.Write);
			xmlDocument.Save(outStream);
		}

		private static void AddFiles(XmlDocument document, System.Deployment.Application.Manifest.File[] files)
		{
			XmlNamespaceManager namespaceMgr = GetNamespaceMgr(document);
			XmlElement assemblyNode = (XmlElement)document.SelectSingleNode("/asmv1:assembly", namespaceMgr);
			foreach (System.Deployment.Application.Manifest.File file in files)
			{
				AddFile(document, assemblyNode, file);
			}
		}

		private static void AddFile(XmlDocument document, XmlElement assemblyNode, System.Deployment.Application.Manifest.File file)
		{
			XmlElement xmlElement = document.CreateElement("file", "urn:schemas-microsoft-com:asm.v1");
			assemblyNode.AppendChild(xmlElement);
			XmlAttribute xmlAttribute = xmlElement.SetAttributeNode("name", null);
			xmlAttribute.Value = file.Name;
		}

		private static void AddDependencies(XmlDocument document, DependentAssembly[] dependentAssemblies)
		{
			Hashtable hashtable = new Hashtable();
			XmlNamespaceManager namespaceMgr = GetNamespaceMgr(document);
			XmlElement xmlElement = (XmlElement)document.SelectSingleNode("/asmv1:assembly", namespaceMgr);
			foreach (DependentAssembly dependentAssembly in dependentAssemblies)
			{
				if (!hashtable.Contains(dependentAssembly.Identity))
				{
					XmlElement xmlElement2 = document.CreateElement("dependency", "urn:schemas-microsoft-com:asm.v1");
					xmlElement.AppendChild(xmlElement2);
					XmlElement xmlElement3 = document.CreateElement("dependentAssembly", "urn:schemas-microsoft-com:asm.v1");
					xmlElement2.AppendChild(xmlElement3);
					ReferenceIdentity identity = dependentAssembly.Identity;
					DefinitionIdentity definitionIdentity = new DefinitionIdentity(identity);
					XmlElement newChild = CreateAssemblyIdentityElement(document, definitionIdentity);
					xmlElement3.AppendChild(newChild);
					hashtable.Add(identity, definitionIdentity);
				}
			}
		}

		private static void InjectIdentityXml(XmlDocument document, DefinitionIdentity asmId)
		{
			XmlElement newChild = CreateAssemblyIdentityElement(document, asmId);
			document.DocumentElement.AppendChild(newChild);
		}

		private static XmlElement CreateAssemblyIdentityElement(XmlDocument document, DefinitionIdentity asmId)
		{
			XmlElement xmlElement = document.CreateElement("assemblyIdentity", "urn:schemas-microsoft-com:asm.v1");
			System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[] attributes = asmId.Attributes;
			StringComparison comparisonType = StringComparison.InvariantCultureIgnoreCase;
			System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE[] array = attributes;
			for (int i = 0; i < array.Length; i++)
			{
				System.Deployment.Internal.Isolation.IDENTITY_ATTRIBUTE iDENTITY_ATTRIBUTE = array[i];
				string @namespace = iDENTITY_ATTRIBUTE.Namespace;
				string text = iDENTITY_ATTRIBUTE.Name;
				if (@namespace == null)
				{
					if (text.Equals("name", comparisonType))
					{
						text = "name";
					}
					else if (text.Equals("version", comparisonType))
					{
						text = "version";
					}
					else if (text.Equals("processorArchitecture", comparisonType))
					{
						text = "processorArchitecture";
					}
					else if (text.Equals("publicKeyToken", comparisonType))
					{
						text = "publicKeyToken";
					}
					else if (text.Equals("type", comparisonType))
					{
						text = "type";
					}
					else if (text.Equals("culture", comparisonType))
					{
						text = "language";
					}
				}
				xmlElement.SetAttribute(text, @namespace, iDENTITY_ATTRIBUTE.Value);
			}
			return xmlElement;
		}

		private static XmlDocument CloneAssemblyTemplate()
		{
			if (assemblyTemplateDoc == null)
			{
				Assembly executingAssembly = Assembly.GetExecutingAssembly();
				Stream manifestResourceStream = executingAssembly.GetManifestResourceStream("AssemblyTemplate.xml");
				XmlDocument xmlDocument = new XmlDocument();
				xmlDocument.Load(manifestResourceStream);
				Interlocked.CompareExchange(ref assemblyTemplateDoc, xmlDocument, null);
			}
			return (XmlDocument)((XmlDocument)assemblyTemplateDoc).Clone();
		}

		private static XmlNamespaceManager GetNamespaceMgr(XmlDocument document)
		{
			XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(document.NameTable);
			xmlNamespaceManager.AddNamespace("asmv1", "urn:schemas-microsoft-com:asm.v1");
			xmlNamespaceManager.AddNamespace("asmv2", "urn:schemas-microsoft-com:asm.v2");
			xmlNamespaceManager.AddNamespace("dsig", "http://www.w3.org/2000/09/xmldsig#");
			return xmlNamespaceManager;
		}
	}
	internal class AssemblyModule
	{
		private string _name;

		private byte[] _hash;

		public string Name => _name;

		public byte[] Hash => _hash;

		public AssemblyModule(string name, byte[] hash)
		{
			_name = name;
			_hash = hash;
		}
	}
	internal class AssemblyReference
	{
		private AssemblyName _name;

		public AssemblyName Name => _name;

		public AssemblyReference(AssemblyName name)
		{
			_name = name;
		}
	}
	internal class AssemblyMetaDataImport : DisposableBase
	{
		private AssemblyModule[] _modules;

		private AssemblyName _name;

		private AssemblyReference[] _asmRefs;

		private IMetaDataDispenser _metaDispenser;

		private IMetaDataAssemblyImport _assemblyImport;

		private static Guid _importerGuid = new Guid(((GuidAttribute)Attribute.GetCustomAttribute(typeof(IMetaDataImport), typeof(GuidAttribute), inherit: false)).Value);

		private const int GENMAN_STRING_BUF_SIZE = 1024;

		private const int GENMAN_LOCALE_BUF_SIZE = 64;

		private const int GENMAN_ENUM_TOKEN_BUF_SIZE = 16;

		public AssemblyModule[] Files
		{
			get
			{
				if (_modules == null)
				{
					lock (this)
					{
						if (_modules == null)
						{
							_modules = ImportAssemblyFiles();
						}
					}
				}
				return _modules;
			}
		}

		public AssemblyName Name
		{
			get
			{
				if (_name == null)
				{
					lock (this)
					{
						if (_name == null)
						{
							_name = ImportIdentity();
						}
					}
				}
				return _name;
			}
		}

		public AssemblyReference[] References
		{
			get
			{
				if (_asmRefs == null)
				{
					lock (this)
					{
						if (_asmRefs == null)
						{
							_asmRefs = ImportAssemblyReferences();
						}
					}
				}
				return _asmRefs;
			}
		}

		public AssemblyMetaDataImport(string sourceFile)
		{
			_metaDispenser = (IMetaDataDispenser)new CorMetaDataDispenser();
			_assemblyImport = (IMetaDataAssemblyImport)_metaDispenser.OpenScope(sourceFile, 0u, ref _importerGuid);
		}

		protected override void DisposeUnmanagedResources()
		{
			if (_assemblyImport != null)
			{
				Marshal.ReleaseComObject(_assemblyImport);
			}
			if (_metaDispenser != null)
			{
				Marshal.ReleaseComObject(_metaDispenser);
			}
		}

		private AssemblyModule[] ImportAssemblyFiles()
		{
			ArrayList arrayList = new ArrayList();
			IntPtr phEnum = IntPtr.Zero;
			uint[] array = new uint[16];
			char[] array2 = new char[1024];
			try
			{
				uint iFetched;
				do
				{
					_assemblyImport.EnumFiles(ref phEnum, array, (uint)array.Length, out iFetched);
					for (uint num = 0u; num < iFetched; num++)
					{
						_assemblyImport.GetFileProps(array[num], array2, (uint)array2.Length, out var cchNameRequired, out var bHashData, out var cchHashBytes, out var _);
						byte[] array3 = new byte[cchHashBytes];
						Marshal.Copy(bHashData, array3, 0, (int)cchHashBytes);
						arrayList.Add(new AssemblyModule(new string(array2, 0, (int)(cchNameRequired - 1)), array3));
					}
				}
				while (iFetched != 0);
			}
			finally
			{
				if (phEnum != IntPtr.Zero)
				{
					_assemblyImport.CloseEnum(phEnum);
				}
			}
			return (AssemblyModule[])arrayList.ToArray(typeof(AssemblyModule));
		}

		private AssemblyName ImportIdentity()
		{
			_assemblyImport.GetAssemblyFromScope(out var mdAsm);
			_assemblyImport.GetAssemblyProps(mdAsm, out var pPublicKeyPtr, out var ucbPublicKeyPtr, out var uHashAlg, null, 0u, out var cchNameRequired, IntPtr.Zero, out var dwFlags);
			char[] array = new char[cchNameRequired + 1];
			IntPtr intPtr = IntPtr.Zero;
			try
			{
				intPtr = AllocAsmMeta();
				_assemblyImport.GetAssemblyProps(mdAsm, out pPublicKeyPtr, out ucbPublicKeyPtr, out uHashAlg, array, (uint)array.Length, out cchNameRequired, intPtr, out dwFlags);
				return ConstructAssemblyName(intPtr, array, cchNameRequired, pPublicKeyPtr, ucbPublicKeyPtr, dwFlags);
			}
			finally
			{
				FreeAsmMeta(intPtr);
			}
		}

		private AssemblyReference[] ImportAssemblyReferences()
		{
			ArrayList arrayList = new ArrayList();
			IntPtr phEnum = IntPtr.Zero;
			uint[] array = new uint[16];
			try
			{
				uint iFetched;
				do
				{
					_assemblyImport.EnumAssemblyRefs(ref phEnum, array, (uint)array.Length, out iFetched);
					for (uint num = 0u; num < iFetched; num++)
					{
						_assemblyImport.GetAssemblyRefProps(array[num], out var ppbPublicKeyOrToken, out var pcbPublicKeyOrToken, null, 0u, out var pchNameOut, IntPtr.Zero, out var ppbHashValue, out var pcbHashValue, out var pdwAssemblyRefFlags);
						char[] array2 = new char[pchNameOut + 1];
						IntPtr intPtr = IntPtr.Zero;
						try
						{
							intPtr = AllocAsmMeta();
							_assemblyImport.GetAssemblyRefProps(array[num], out ppbPublicKeyOrToken, out pcbPublicKeyOrToken, array2, (uint)array2.Length, out pchNameOut, intPtr, out ppbHashValue, out pcbHashValue, out pdwAssemblyRefFlags);
							AssemblyName name = ConstructAssemblyName(intPtr, array2, pchNameOut, ppbPublicKeyOrToken, pcbPublicKeyOrToken, pdwAssemblyRefFlags);
							arrayList.Add(new AssemblyReference(name));
						}
						finally
						{
							FreeAsmMeta(intPtr);
						}
					}
				}
				while (iFetched != 0);
			}
			finally
			{
				if (phEnum != IntPtr.Zero)
				{
					_assemblyImport.CloseEnum(phEnum);
				}
			}
			return (AssemblyReference[])arrayList.ToArray(typeof(AssemblyReference));
		}

		private IntPtr AllocAsmMeta()
		{
			ASSEMBLYMETADATA aSSEMBLYMETADATA = default(ASSEMBLYMETADATA);
			aSSEMBLYMETADATA.usMajorVersion = (aSSEMBLYMETADATA.usMinorVersion = (aSSEMBLYMETADATA.usBuildNumber = (aSSEMBLYMETADATA.usRevisionNumber = 0)));
			aSSEMBLYMETADATA.cOses = (aSSEMBLYMETADATA.cProcessors = 0u);
			aSSEMBLYMETADATA.rOses = (aSSEMBLYMETADATA.rpProcessors = IntPtr.Zero);
			aSSEMBLYMETADATA.rpLocale = Marshal.AllocCoTaskMem(128);
			aSSEMBLYMETADATA.cchLocale = 64u;
			int cb = Marshal.SizeOf(typeof(ASSEMBLYMETADATA));
			IntPtr intPtr = Marshal.AllocCoTaskMem(cb);
			Marshal.StructureToPtr((object)aSSEMBLYMETADATA, intPtr, fDeleteOld: false);
			return intPtr;
		}

		private AssemblyName ConstructAssemblyName(IntPtr asmMetaPtr, char[] asmNameBuf, uint asmNameLength, IntPtr pubKeyPtr, uint pubKeyBytes, uint flags)
		{
			ASSEMBLYMETADATA aSSEMBLYMETADATA = (ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));
			AssemblyName assemblyName = new AssemblyName();
			assemblyName.Name = new string(asmNameBuf, 0, (int)(asmNameLength - 1));
			assemblyName.Version = new Version(aSSEMBLYMETADATA.usMajorVersion, aSSEMBLYMETADATA.usMinorVersion, aSSEMBLYMETADATA.usBuildNumber, aSSEMBLYMETADATA.usRevisionNumber);
			string name = Marshal.PtrToStringUni(aSSEMBLYMETADATA.rpLocale);
			assemblyName.CultureInfo = new CultureInfo(name);
			if (pubKeyBytes != 0)
			{
				byte[] array = new byte[pubKeyBytes];
				Marshal.Copy(pubKeyPtr, array, 0, (int)pubKeyBytes);
				if ((flags & (true ? 1u : 0u)) != 0)
				{
					assemblyName.SetPublicKey(array);
				}
				else
				{
					assemblyName.SetPublicKeyToken(array);
				}
			}
			return assemblyName;
		}

		private void FreeAsmMeta(IntPtr asmMetaPtr)
		{
			if (asmMetaPtr != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(((ASSEMBLYMETADATA)Marshal.PtrToStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA))).rpLocale);
				Marshal.DestroyStructure(asmMetaPtr, typeof(ASSEMBLYMETADATA));
				Marshal.FreeCoTaskMem(asmMetaPtr);
			}
		}
	}
	[Flags]
	internal enum CorAssemblyFlags : uint
	{
		afPublicKey = 1u
	}
	[ComImport]
	[Guid("809c652e-7396-11d2-9771-00a0c9b4d50c")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[TypeLibType(TypeLibTypeFlags.FRestricted)]
	internal interface IMetaDataDispenser
	{
		[return: MarshalAs(UnmanagedType.Interface)]
		object DefineScope([In] ref Guid rclsid, [In] uint dwCreateFlags, [In] ref Guid riid);

		[return: MarshalAs(UnmanagedType.Interface)]
		object OpenScope([In][MarshalAs(UnmanagedType.LPWStr)] string szScope, [In] uint dwOpenFlags, [In] ref Guid riid);

		[return: MarshalAs(UnmanagedType.Interface)]
		object OpenScopeOnMemory([In] IntPtr pData, [In] uint cbData, [In] uint dwOpenFlags, [In] ref Guid riid);
	}
	internal struct ASSEMBLYMETADATA
	{
		public ushort usMajorVersion;

		public ushort usMinorVersion;

		public ushort usBuildNumber;

		public ushort usRevisionNumber;

		public IntPtr rpLocale;

		public uint cchLocale;

		public IntPtr rpProcessors;

		public uint cProcessors;

		public IntPtr rOses;

		public uint cOses;
	}
	[ComImport]
	[Guid("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IMetaDataImport
	{
		[PreserveSig]
		void CloseEnum();

		void CountEnum(IntPtr iRef, ref uint ulCount);

		void ResetEnum();

		void EnumTypeDefs();

		void EnumInterfaceImpls();

		void EnumTypeRefs();

		void FindTypeDefByName();

		void GetScopeProps();

		void GetModuleFromScope();

		void GetTypeDefProps();

		void GetInterfaceImplProps();

		void GetTypeRefProps();

		void ResolveTypeRef();

		void EnumMembers();

		void EnumMembersWithName();

		void EnumMethods();

		void EnumMethodsWithName();

		void EnumFields();

		void EnumFieldsWithName();

		void EnumParams();

		void EnumMemberRefs();

		void EnumMethodImpls();

		void EnumPermissionSets();

		void FindMember();

		void FindMethod();

		void FindField();

		void FindMemberRef();

		void GetMethodProps();

		void GetMemberRefProps();

		void EnumProperties();

		void EnumEvents();

		void GetEventProps();

		void EnumMethodSemantics();

		void GetMethodSemantics();

		void GetClassLayout();

		void GetFieldMarshal();

		void GetRVA();

		void GetPermissionSetProps();

		void GetSigFromToken();

		void GetModuleRefProps();

		void EnumModuleRefs();

		void GetTypeSpecFromToken();

		void GetNameFromToken();

		void EnumUnresolvedMethods();

		void GetUserString();

		void GetPinvokeMap();

		void EnumSignatures();

		void EnumTypeSpecs();

		void EnumUserStrings();

		void GetParamForMethodIndex();

		void EnumCustomAttributes();

		void GetCustomAttributeProps();

		void FindTypeRef();

		void GetMemberProps();

		void GetFieldProps();

		void GetPropertyProps();

		void GetParamProps();

		void GetCustomAttributeByName();

		void IsValidToken();

		void GetNestedClassProps();

		void GetNativeCallConvFromSig();

		void IsGlobal();
	}
	[ComImport]
	[Guid("E5CB7A31-7512-11d2-89CE-0080C792E5D8")]
	[TypeLibType(TypeLibTypeFlags.FCanCreate)]
	[ClassInterface(ClassInterfaceType.None)]
	internal class CorMetaDataDispenser
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		public extern CorMetaDataDispenser();
	}
	[ComImport]
	[Guid("EE62470B-E94B-424e-9B7C-2F00C9249F93")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IMetaDataAssemblyImport
	{
		void GetAssemblyProps(uint mdAsm, out IntPtr pPublicKeyPtr, out uint ucbPublicKeyPtr, out uint uHashAlg, [MarshalAs(UnmanagedType.LPArray)] char[] strName, uint cchNameIn, out uint cchNameRequired, IntPtr amdInfo, out uint dwFlags);

		void GetAssemblyRefProps(uint mdAsmRef, out IntPtr ppbPublicKeyOrToken, out uint pcbPublicKeyOrToken, [MarshalAs(UnmanagedType.LPArray)] char[] strName, uint cchNameIn, out uint pchNameOut, IntPtr amdInfo, out IntPtr ppbHashValue, out uint pcbHashValue, out uint pdwAssemblyRefFlags);

		void GetFileProps([In] uint mdFile, [MarshalAs(UnmanagedType.LPArray)] char[] strName, uint cchName, out uint cchNameRequired, out IntPtr bHashData, out uint cchHashBytes, out uint dwFileFlags);

		void GetExportedTypeProps();

		void GetManifestResourceProps();

		void EnumAssemblyRefs([In][Out] ref IntPtr phEnum, [Out][MarshalAs(UnmanagedType.LPArray)] uint[] asmRefs, uint asmRefCount, out uint iFetched);

		void EnumFiles([In][Out] ref IntPtr phEnum, [Out][MarshalAs(UnmanagedType.LPArray)] uint[] fileRefs, uint fileRefCount, out uint iFetched);

		void EnumExportedTypes();

		void EnumManifestResources();

		void GetAssemblyFromScope(out uint mdAsm);

		void FindExportedTypeByName();

		void FindManifestResourceByName();

		[PreserveSig]
		void CloseEnum([In] IntPtr phEnum);

		void FindAssembliesByName();
	}
	internal static class ManifestReader
	{
		internal static AssemblyManifest FromDocument(string localPath, AssemblyManifest.ManifestType manifestType, Uri sourceUri)
		{
			CodeMarker_Singleton.Instance.CodeMarker(7302);
			Logger.AddMethodCall("ManifestReader.FromDocument(" + localPath + ") called.");
			FileInfo fileInfo = new FileInfo(localPath);
			if (fileInfo.Length > 16777216)
			{
				throw new DeploymentException(Resources.GetString("Ex_ManifestFileTooLarge"));
			}
			AssemblyManifest assemblyManifest;
			using (FileStream fileStream = new FileStream(localPath, FileMode.Open, FileAccess.Read))
			{
				try
				{
					XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
					xmlReaderSettings.DtdProcessing = DtdProcessing.Prohibit;
					xmlReaderSettings.XmlResolver = null;
					XmlReader xmlReader = (PolicyKeys.SkipSchemaValidation() ? XmlReader.Create(fileStream, xmlReaderSettings) : ManifestValidatingReader.Create(fileStream));
					while (xmlReader.Read())
					{
					}
					Logger.AddInternalState("Schema validation passed.");
					assemblyManifest = new AssemblyManifest(fileStream);
					Logger.AddInternalState("Manifest is parsed successfully.");
					if (!PolicyKeys.SkipSemanticValidation())
					{
						assemblyManifest.ValidateSemantics(manifestType);
					}
					Logger.AddInternalState("Semantic validation passed.");
					if (!PolicyKeys.SkipSignatureValidation())
					{
						fileStream.Position = 0L;
						assemblyManifest.ValidateSignature(fileStream);
					}
					Logger.AddInternalState("Signature validation passed.");
				}
				catch (XmlException innerException)
				{
					string message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestFromDocument"), new object[1] { (sourceUri != null) ? sourceUri.AbsoluteUri : Path.GetFileName(localPath) });
					throw new InvalidDeploymentException(ExceptionTypes.ManifestParse, message, innerException);
				}
				catch (XmlSchemaValidationException innerException2)
				{
					string message2 = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestFromDocument"), new object[1] { (sourceUri != null) ? sourceUri.AbsoluteUri : Path.GetFileName(localPath) });
					throw new InvalidDeploymentException(ExceptionTypes.ManifestParse, message2, innerException2);
				}
				catch (InvalidDeploymentException innerException3)
				{
					string message3 = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestFromDocument"), new object[1] { (sourceUri != null) ? sourceUri.AbsoluteUri : Path.GetFileName(localPath) });
					throw new InvalidDeploymentException(ExceptionTypes.ManifestParse, message3, innerException3);
				}
			}
			CodeMarker_Singleton.Instance.CodeMarker(7303);
			return assemblyManifest;
		}

		internal static AssemblyManifest FromDocumentNoValidation(string localPath)
		{
			CodeMarker_Singleton.Instance.CodeMarker(7302);
			Logger.AddMethodCall("ManifestReader.FromDocumentNoValidation(" + localPath + ") called.");
			FileInfo fileInfo = new FileInfo(localPath);
			if (fileInfo.Length > 16777216)
			{
				throw new DeploymentException(Resources.GetString("Ex_ManifestFileTooLarge"));
			}
			AssemblyManifest result;
			using (FileStream fileStream = new FileStream(localPath, FileMode.Open, FileAccess.Read))
			{
				result = new AssemblyManifest(fileStream);
			}
			CodeMarker_Singleton.Instance.CodeMarker(7303);
			return result;
		}
	}
	internal static class ManifestValidatingReader
	{
		private class ResourceResolver : XmlUrlResolver
		{
			private const string Prefix = "df://resources/";

			private Assembly _assembly;

			public ResourceResolver(Assembly assembly)
			{
				_assembly = assembly;
			}

			public override Uri ResolveUri(Uri baseUri, string relativeUri)
			{
				if (baseUri == null || baseUri.ToString() == string.Empty || (baseUri.IsAbsoluteUri && baseUri.AbsoluteUri.StartsWith("df://resources/", StringComparison.Ordinal)))
				{
					return new Uri("df://resources/" + relativeUri);
				}
				return base.ResolveUri(baseUri, relativeUri);
			}

			public override object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn)
			{
				if (absoluteUri.AbsoluteUri.StartsWith("df://resources/", StringComparison.Ordinal))
				{
					if (ofObjectToReturn != null && ofObjectToReturn != typeof(Stream))
					{
						throw new XmlException(Resources.GetString("Ex_OnlyStreamTypeSupported"));
					}
					if (absoluteUri.ToString() == "df://resources/-//W3C//DTD XMLSCHEMA 200102//EN")
					{
						return _assembly.GetManifestResourceStream("XMLSchema.dtd");
					}
					if (absoluteUri.ToString() == "df://resources/xs-datatypes")
					{
						return _assembly.GetManifestResourceStream("datatypes.dtd");
					}
					string name = absoluteUri.AbsoluteUri.Remove(0, "df://resources/".Length);
					return _assembly.GetManifestResourceStream(name);
				}
				return base.GetEntity(absoluteUri, role, ofObjectToReturn);
			}
		}

		private class XmlFilteredReader : XmlTextReader
		{
			private static StringCollection KnownNamespaces;

			static XmlFilteredReader()
			{
				KnownNamespaces = new StringCollection();
				KnownNamespaces.Add("urn:schemas-microsoft-com:asm.v1");
				KnownNamespaces.Add("urn:schemas-microsoft-com:asm.v2");
				KnownNamespaces.Add("http://www.w3.org/2000/09/xmldsig#");
			}

			public XmlFilteredReader(Stream stream)
				: base(stream)
			{
				base.DtdProcessing = DtdProcessing.Prohibit;
			}

			public override bool Read()
			{
				bool result = base.Read();
				XmlNodeType nodeType = base.NodeType;
				if (nodeType == XmlNodeType.Element && !KnownNamespaces.Contains(base.NamespaceURI))
				{
					Skip();
				}
				return result;
			}
		}

		private static string[] _manifestSchemas = new string[1] { "manifest.2.0.0.15-pre.adaptive.xsd" };

		private static XmlSchemaSet _manifestSchemaSet = null;

		private static object _manifestSchemaSetLock = new object();

		private static XmlSchemaSet ManifestSchemaSet
		{
			get
			{
				if (_manifestSchemaSet == null)
				{
					lock (_manifestSchemaSetLock)
					{
						if (_manifestSchemaSet == null)
						{
							_manifestSchemaSet = MakeSchemaSet(_manifestSchemas);
						}
					}
				}
				return _manifestSchemaSet;
			}
		}

		public static XmlReader Create(Stream stream)
		{
			return Create(stream, ManifestSchemaSet);
		}

		private static XmlReader Create(Stream stream, XmlSchemaSet schemaSet)
		{
			XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
			xmlReaderSettings.Schemas = schemaSet;
			xmlReaderSettings.ValidationType = ValidationType.Schema;
			xmlReaderSettings.DtdProcessing = DtdProcessing.Prohibit;
			xmlReaderSettings.XmlResolver = null;
			XmlFilteredReader reader = new XmlFilteredReader(stream);
			return XmlReader.Create(reader, xmlReaderSettings);
		}

		private static XmlSchemaSet MakeSchemaSet(string[] schemas)
		{
			XmlSchemaSet xmlSchemaSet = new XmlSchemaSet();
			Assembly executingAssembly = Assembly.GetExecutingAssembly();
			xmlSchemaSet.XmlResolver = new ResourceResolver(executingAssembly);
			for (int i = 0; i < schemas.Length; i++)
			{
				using Stream input = executingAssembly.GetManifestResourceStream(schemas[i]);
				xmlSchemaSet.Add(null, new XmlTextReader(input));
			}
			return xmlSchemaSet;
		}
	}
	internal static class NativeMethods
	{
		public struct SYSTEM_INFO
		{
			internal _PROCESSOR_INFO_UNION uProcessorInfo;

			public uint dwPageSize;

			public IntPtr lpMinimumApplicationAddress;

			public IntPtr lpMaximumApplicationAddress;

			public IntPtr dwActiveProcessorMask;

			public uint dwNumberOfProcessors;

			public uint dwProcessorType;

			public uint dwAllocationGranularity;

			public uint dwProcessorLevel;

			public uint dwProcessorRevision;
		}

		[StructLayout(LayoutKind.Explicit)]
		public struct _PROCESSOR_INFO_UNION
		{
			[FieldOffset(0)]
			internal uint dwOemId;

			[FieldOffset(0)]
			internal ushort wProcessorArchitecture;

			[FieldOffset(2)]
			internal ushort wReserved;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class OSVersionInfoEx
		{
			public uint dwOSVersionInfoSize;

			public uint dwMajorVersion;

			public uint dwMinorVersion;

			public uint dwBuildNumber;

			public uint dwPlatformId;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
			public string szCSDVersion;

			public ushort wServicePackMajor;

			public ushort wServicePackMinor;

			public ushort wSuiteMask;

			public byte bProductType;

			public byte bReserved;
		}

		[Flags]
		internal enum GenericAccess : uint
		{
			GENERIC_READ = 0x80000000u,
			GENERIC_WRITE = 0x40000000u,
			GENERIC_EXECUTE = 0x20000000u,
			GENERIC_ALL = 0x10000000u
		}

		internal enum CreationDisposition : uint
		{
			CREATE_NEW = 1u,
			CREATE_ALWAYS,
			OPEN_EXISTING,
			OPEN_ALWAYS,
			TRUNCATE_EXISTING
		}

		[Flags]
		internal enum ShareMode : uint
		{
			FILE_SHARE_NONE = 0u,
			FILE_SHARE_READ = 1u,
			FILE_SHARE_WRITE = 2u,
			FILE_SHARE_DELETE = 4u
		}

		[Flags]
		internal enum FlagsAndAttributes : uint
		{
			FILE_FLAG_WRITE_THROUGH = 0x80000000u,
			FILE_FLAG_OVERLAPPED = 0x40000000u,
			FILE_FLAG_NO_BUFFERING = 0x20000000u,
			FILE_FLAG_RANDOM_ACCESS = 0x10000000u,
			FILE_FLAG_SEQUENTIAL_SCAN = 0x8000000u,
			FILE_FLAG_DELETE_ON_CLOSE = 0x4000000u,
			FILE_FLAG_BACKUP_SEMANTICS = 0x2000000u,
			FILE_FLAG_POSIX_SEMANTICS = 0x1000000u,
			FILE_FLAG_OPEN_REPARSE_POINT = 0x200000u,
			FILE_FLAG_OPEN_NO_RECALL = 0x100000u,
			FILE_FLAG_FIRST_PIPE_INSTANCE = 0x80000u,
			FILE_ATTRIBUTE_READONLY = 1u,
			FILE_ATTRIBUTE_HIDDEN = 2u,
			FILE_ATTRIBUTE_SYSTEM = 4u,
			FILE_ATTRIBUTE_DIRECTORY = 0x10u,
			FILE_ATTRIBUTE_ARCHIVE = 0x20u,
			FILE_ATTRIBUTE_DEVICE = 0x40u,
			FILE_ATTRIBUTE_NORMAL = 0x80u,
			FILE_ATTRIBUTE_TEMPORARY = 0x100u,
			FILE_ATTRIBUTE_SPARSE_FILE = 0x200u,
			FILE_ATTRIBUTE_REPARSE_POINT = 0x400u,
			FILE_ATTRIBUTE_COMPRESSED = 0x800u,
			FILE_ATTRIBUTE_OFFLINE = 0x1000u,
			FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x2000u,
			FILE_ATTRIBUTE_ENCRYPTED = 0x4000u
		}

		internal enum Win32Error
		{
			ERROR_SUCCESS = 0,
			ERROR_INVALID_FUNCTION = 1,
			ERROR_FILE_NOT_FOUND = 2,
			ERROR_PATH_NOT_FOUND = 3,
			ERROR_TOO_MANY_OPEN_FILES = 4,
			ERROR_ACCESS_DENIED = 5,
			ERROR_INVALID_HANDLE = 6,
			ERROR_NO_MORE_FILES = 18,
			ERROR_NOT_READY = 21,
			ERROR_SHARING_VIOLATION = 32,
			ERROR_FILE_EXISTS = 80,
			ERROR_INVALID_PARAMETER = 87,
			ERROR_CALL_NOT_IMPLEMENTED = 120,
			ERROR_ALREADY_EXISTS = 183,
			ERROR_FILENAME_EXCED_RANGE = 206
		}

		internal enum HResults
		{
			HRESULT_ERROR_REVISION_MISMATCH = -2147023590
		}

		[StructLayout(LayoutKind.Sequential)]
		[SuppressUnmanagedCodeSecurity]
		internal class PROCESS_INFORMATION
		{
			public IntPtr hProcess = IntPtr.Zero;

			public IntPtr hThread = IntPtr.Zero;

			public int dwProcessId;

			public int dwThreadId;

			~PROCESS_INFORMATION()
			{
				Close();
			}

			[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
			internal void Close()
			{
				if (hProcess != IntPtr.Zero && hProcess != INVALID_HANDLE_VALUE)
				{
					CloseHandle(new HandleRef(this, hProcess));
					hProcess = INVALID_HANDLE_VALUE;
				}
				if (hThread != IntPtr.Zero && hThread != INVALID_HANDLE_VALUE)
				{
					CloseHandle(new HandleRef(this, hThread));
					hThread = INVALID_HANDLE_VALUE;
				}
			}
		}

		internal struct AssemblyInfoInternal
		{
			internal int cbAssemblyInfo;

			internal int assemblyFlags;

			internal long assemblySizeInKB;

			internal IntPtr currentAssemblyPathBuf;

			internal int cchBuf;

			internal const int MaxPath = 1024;
		}

		[ComImport]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("e707dcde-d1cd-11d2-bab9-00c04f8eceae")]
		internal interface IAssemblyCache
		{
			void UninstallAssembly();

			void QueryAssemblyInfo(int flags, [MarshalAs(UnmanagedType.LPWStr)] string assemblyName, ref AssemblyInfoInternal assemblyInfo);

			void CreateAssemblyCacheItem();

			void CreateAssemblyScavenger();

			void InstallAssembly();
		}

		internal delegate int CreateAssemblyCacheDelegate([MarshalAs(UnmanagedType.Interface)] out IAssemblyCache ppAsmCache, uint reserved);

		public enum tagCOINITEE : uint
		{
			COINITEE_DEFAULT,
			COINITEE_DLL,
			COINITEE_MAIN
		}

		internal delegate int CoInitializeEEDelegate(uint fFlags);

		[ComImport]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("21b8916c-f28e-11d2-a473-00c04f8ef448")]
		internal interface IAssemblyEnum
		{
			[PreserveSig]
			int GetNextAssembly(IApplicationContext ppAppCtx, out IAssemblyName ppName, uint dwFlags);

			[PreserveSig]
			int Reset();

			[PreserveSig]
			int Clone(out IAssemblyEnum ppEnum);
		}

		[ComImport]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("7c23ff90-33af-11d3-95da-00a024a85b51")]
		internal interface IApplicationContext
		{
			void SetContextNameObject(IAssemblyName pName);

			void GetContextNameObject(out IAssemblyName ppName);

			void Set([MarshalAs(UnmanagedType.LPWStr)] string szName, int pvValue, uint cbValue, uint dwFlags);

			void Get([MarshalAs(UnmanagedType.LPWStr)] string szName, out int pvValue, ref uint pcbValue, uint dwFlags);

			void GetDynamicDirectory(out int wzDynamicDir, ref uint pdwSize);
		}

		[ComImport]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")]
		internal interface IAssemblyName
		{
			[PreserveSig]
			int SetProperty(uint PropertyId, IntPtr pvProperty, uint cbProperty);

			[PreserveSig]
			int GetProperty(uint PropertyId, IntPtr pvProperty, ref uint pcbProperty);

			[PreserveSig]
			int Finalize();

			[PreserveSig]
			int GetDisplayName(IntPtr szDisplayName, ref uint pccDisplayName, uint dwDisplayFlags);

			[PreserveSig]
			int BindToObject(object refIID, object pAsmBindSink, IApplicationContext pApplicationContext, [MarshalAs(UnmanagedType.LPWStr)] string szCodeBase, long llFlags, int pvReserved, uint cbReserved, out int ppv);

			[PreserveSig]
			int GetName(out uint lpcwBuffer, out int pwzName);

			[PreserveSig]
			int GetVersion(out uint pdwVersionHi, out uint pdwVersionLow);

			[PreserveSig]
			int IsEqual(IAssemblyName pName, uint dwCmpFlags);

			[PreserveSig]
			int Clone(out IAssemblyName pName);
		}

		internal enum ASM_CACHE : uint
		{
			ZAP = 1u,
			GAC = 2u,
			DOWNLOAD = 4u
		}

		internal enum CreateAssemblyNameObjectFlags : uint
		{
			CANOF_DEFAULT,
			CANOF_PARSE_DISPLAY_NAME
		}

		[StructLayout(LayoutKind.Sequential)]
		internal class ACTCTXW
		{
			public uint cbSize;

			public uint dwFlags;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string lpSource;

			public ushort wProcessorArchitecture;

			public ushort wLangId;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string lpAssemblyDirectory;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string lpResourceName;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string lpApplicationName;

			public IntPtr hModule;

			public ACTCTXW(string manifestPath)
			{
				cbSize = (uint)Marshal.SizeOf(typeof(ACTCTXW));
				dwFlags = 0u;
				lpSource = manifestPath;
			}
		}

		public enum CacheEntryFlags : uint
		{
			Normal = 1u,
			Sticky = 4u,
			Edited = 8u,
			TrackOffline = 0x10u,
			TrackOnline = 0x20u,
			Sparse = 0x10000u,
			Cookie = 0x100000u,
			UrlHistory = 0x200000u
		}

		[ComImport]
		[SecurityCritical]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("00000100-0000-0000-C000-000000000046")]
		public interface IEnumUnknown
		{
			[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
			int Next([In][MarshalAs(UnmanagedType.U4)] int elementArrayLength, [Out][MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown, SizeParamIndex = 0)] object[] elementArray, [MarshalAs(UnmanagedType.U4)] out int fetchedElementCount);

			[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
			int Skip([In][MarshalAs(UnmanagedType.U4)] int count);

			[MethodImpl(MethodImplOptions.InternalCall)]
			void Reset();

			[MethodImpl(MethodImplOptions.InternalCall)]
			void Clone([MarshalAs(UnmanagedType.Interface)] out IEnumUnknown enumerator);
		}

		[ComImport]
		[SecurityCritical]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("BD39D1D2-BA2F-486A-89B0-B4B0CB466891")]
		public interface IClrRuntimeInfo
		{
			[MethodImpl(MethodImplOptions.InternalCall)]
			void GetVersionString([Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder buffer, [In][Out][MarshalAs(UnmanagedType.U4)] ref int bufferLength);

			[MethodImpl(MethodImplOptions.InternalCall)]
			void GetRuntimeDirectory([Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder buffer, [In][Out][MarshalAs(UnmanagedType.U4)] ref int bufferLength);

			[MethodImpl(MethodImplOptions.InternalCall)]
			[return: MarshalAs(UnmanagedType.Bool)]
			bool IsLoaded([In] IntPtr processHandle);

			[MethodImpl(MethodImplOptions.InternalCall)]
			[LCIDConversion(3)]
			void LoadErrorString([In][MarshalAs(UnmanagedType.U4)] int resourceId, [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder buffer, [In][Out][MarshalAs(UnmanagedType.U4)] ref int bufferLength);

			[MethodImpl(MethodImplOptions.InternalCall)]
			IntPtr LoadLibrary([In][MarshalAs(UnmanagedType.LPWStr)] string dllName);

			[MethodImpl(MethodImplOptions.InternalCall)]
			IntPtr GetProcAddress([In][MarshalAs(UnmanagedType.LPStr)] string procName);

			[MethodImpl(MethodImplOptions.InternalCall)]
			[return: MarshalAs(UnmanagedType.Interface)]
			object GetInterface([In][MarshalAs(UnmanagedType.LPStruct)] Guid coClassId, [In][MarshalAs(UnmanagedType.LPStruct)] Guid interfaceId);
		}

		[SecurityCritical]
		[Flags]
		public enum MetaHostPolicyFlags
		{
			MetaHostPolicyHighCompatibility = 0,
			MetaHostPolicyApplyUpgradePolicy = 8,
			MetaHostPolicyEmulateExeLaunch = 0xF
		}

		[ComImport]
		[SecurityCritical]
		[Guid("E2190695-77B2-492E-8E14-C4B3A7FDD593")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		public interface IClrMetaHostPolicy
		{
			[MethodImpl(MethodImplOptions.InternalCall)]
			[return: MarshalAs(UnmanagedType.Interface)]
			object GetRequestedRuntime([In][ComAliasName("Microsoft.Runtime.Hosting.Interop.MetaHostPolicyFlags")] MetaHostPolicyFlags policyFlags, [In][MarshalAs(UnmanagedType.LPWStr)] string binaryPath, [In][MarshalAs(UnmanagedType.Interface)] IStream configStream, [In][Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder version, [In][Out][MarshalAs(UnmanagedType.U4)] ref int versionLength, [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder imageVersion, [In][Out][MarshalAs(UnmanagedType.U4)] ref int imageVersionLength, [MarshalAs(UnmanagedType.U4)] out int pdwConfigFlags, [In][MarshalAs(UnmanagedType.LPStruct)] Guid interfaceId);
		}

		[ComImport]
		[Guid("CB2F6722-AB3A-11d2-9C40-00C04FA30A3E")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		internal interface ICorRuntimeHost
		{
			[PreserveSig]
			int CreateLogicalThreadState();

			[PreserveSig]
			int DeleteLogicalThreadState();

			[PreserveSig]
			int SwitchInLogicalThreadState([In] ref uint pFiberCookie);

			[PreserveSig]
			int SwitchOutLogicalThreadState(out uint FiberCookie);

			[PreserveSig]
			int LocksHeldByLogicalThread(out uint pCount);

			[PreserveSig]
			int MapFile(IntPtr hFile, out IntPtr hMapAddress);

			[PreserveSig]
			int GetConfiguration([MarshalAs(UnmanagedType.IUnknown)] out object pConfiguration);

			[PreserveSig]
			int Start();

			[PreserveSig]
			int Stop();

			[PreserveSig]
			int CreateDomain(string pwzFriendlyName, [MarshalAs(UnmanagedType.IUnknown)] object pIdentityArray, [MarshalAs(UnmanagedType.IUnknown)] out object pAppDomain);

			[PreserveSig]
			int GetDefaultDomain([MarshalAs(UnmanagedType.IUnknown)] out object pAppDomain);

			[PreserveSig]
			int EnumDomains(out IntPtr hEnum);

			[PreserveSig]
			int NextDomain(IntPtr hEnum, [MarshalAs(UnmanagedType.IUnknown)] out object pAppDomain);

			[PreserveSig]
			int CloseEnum(IntPtr hEnum);

			[PreserveSig]
			int CreateDomainEx(string pwzFriendlyName, [MarshalAs(UnmanagedType.IUnknown)] object pSetup, [MarshalAs(UnmanagedType.IUnknown)] object pEvidence, [MarshalAs(UnmanagedType.IUnknown)] out object pAppDomain);

			[PreserveSig]
			int CreateDomainSetup([MarshalAs(UnmanagedType.IUnknown)] out object pAppDomainSetup);

			[PreserveSig]
			int CreateEvidence([MarshalAs(UnmanagedType.IUnknown)] out object pEvidence);

			[PreserveSig]
			int UnloadDomain([MarshalAs(UnmanagedType.IUnknown)] object pAppDomain);

			[PreserveSig]
			int CurrentDomain([MarshalAs(UnmanagedType.IUnknown)] out object pAppDomain);
		}

		public sealed class CCorRuntimeHost : IDisposable
		{
			[UnmanagedFunctionPointer(CallingConvention.StdCall)]
			private delegate int Host_CurrentDomain(IntPtr _this, out IntPtr domain);

			[UnmanagedFunctionPointer(CallingConvention.StdCall)]
			private delegate int AppDomain_GetType(IntPtr _this, out IntPtr domainType);

			[UnmanagedFunctionPointer(CallingConvention.StdCall)]
			private delegate int Type_InvokeMember(IntPtr _this, [MarshalAs(UnmanagedType.BStr)] string name, BindingFlags invokeAttr, Binder binder, VARIANT target, [MarshalAs(UnmanagedType.SafeArray)] object[] args, out object retval);

			private struct VARIANT
			{
				public ushort vt;

				public ushort wReserved1;

				public ushort wReserved2;

				public ushort wReserved3;

				public IntPtr data1;

				public IntPtr data2;

				public const ushort VT_UNKNOWN = 13;
			}

			private ICorRuntimeHost RuntimeHostInstance;

			private IntPtr RuntimeHostPtr = IntPtr.Zero;

			private Host_CurrentDomain CurrentDomainFnPtr;

			private IntPtr DomainObjectPtr = IntPtr.Zero;

			private AppDomain_GetType GetTypeFnPtr;

			private IntPtr DomainTypePtr = IntPtr.Zero;

			private Type_InvokeMember InvokeMemberFnPtr;

			private bool fDelegatesBound;

			private string ClrRuntimeInfoVersion = string.Empty;

			public CCorRuntimeHost(IClrRuntimeInfo RuntimeInfo)
			{
				StringBuilder stringBuilder = new StringBuilder(260);
				int bufferLength = stringBuilder.Capacity;
				RuntimeInfo.GetVersionString(stringBuilder, ref bufferLength);
				ClrRuntimeInfoVersion = stringBuilder.ToString();
				Logger.AddMethodCall("CCorRuntimeHost.ctor called with IClrRuntimeInfo version " + ClrRuntimeInfoVersion, DateTime.Now);
				RuntimeHostInstance = (ICorRuntimeHost)RuntimeInfo.GetInterface(_corRuntimeHostClsIdGuid, _corRuntimeHostInterfaceIdGuid);
			}

			public void Dispose()
			{
				fDelegatesBound = false;
				InvokeMemberFnPtr = null;
				if (IntPtr.Zero != DomainTypePtr)
				{
					Marshal.Release(DomainTypePtr);
					DomainTypePtr = IntPtr.Zero;
				}
				GetTypeFnPtr = null;
				if (IntPtr.Zero != DomainObjectPtr)
				{
					Marshal.Release(DomainObjectPtr);
					DomainObjectPtr = IntPtr.Zero;
				}
				CurrentDomainFnPtr = null;
				if (IntPtr.Zero != RuntimeHostPtr)
				{
					Marshal.Release(RuntimeHostPtr);
					RuntimeHostPtr = IntPtr.Zero;
				}
				RuntimeHostInstance = null;
			}

			private void BindDelegatesToManualCOMPInvokeFunctionPointers()
			{
				if (!fDelegatesBound)
				{
					RuntimeHostInstance.Start();
					int ofs = 21 * IntPtr.Size;
					int ofs2 = 10 * IntPtr.Size;
					int ofs3 = 57 * IntPtr.Size;
					RuntimeHostPtr = Marshal.GetIUnknownForObject(RuntimeHostInstance);
					CurrentDomainFnPtr = (Host_CurrentDomain)Marshal.GetDelegateForFunctionPointer(Marshal.ReadIntPtr(Marshal.ReadIntPtr(RuntimeHostPtr), ofs), typeof(Host_CurrentDomain));
					int num = CurrentDomainFnPtr(RuntimeHostPtr, out var domain);
					if (num < 0)
					{
						Marshal.ThrowExceptionForHR(num);
					}
					Guid iid = typeof(_AppDomain).GUID;
					num = Marshal.QueryInterface(domain, ref iid, out DomainObjectPtr);
					if (num < 0)
					{
						Marshal.ThrowExceptionForHR(num);
					}
					GetTypeFnPtr = (AppDomain_GetType)Marshal.GetDelegateForFunctionPointer(Marshal.ReadIntPtr(Marshal.ReadIntPtr(DomainObjectPtr), ofs2), typeof(AppDomain_GetType));
					num = GetTypeFnPtr(DomainObjectPtr, out DomainTypePtr);
					if (num < 0)
					{
						Marshal.ThrowExceptionForHR(num);
					}
					InvokeMemberFnPtr = (Type_InvokeMember)Marshal.GetDelegateForFunctionPointer(Marshal.ReadIntPtr(Marshal.ReadIntPtr(DomainTypePtr), ofs3), typeof(Type_InvokeMember));
					fDelegatesBound = true;
				}
			}

			public string ApplyPolicyInOtherRuntime(string name)
			{
				if (!fDelegatesBound)
				{
					BindDelegatesToManualCOMPInvokeFunctionPointers();
				}
				object[] args = new object[1] { name };
				object retval = null;
				VARIANT target = default(VARIANT);
				target.vt = 13;
				target.data1 = DomainObjectPtr;
				int num = InvokeMemberFnPtr(DomainTypePtr, "ApplyPolicy", BindingFlags.Instance | BindingFlags.Public | BindingFlags.InvokeMethod, null, target, args, out retval);
				if (num < 0)
				{
					Marshal.ThrowExceptionForHR(num);
				}
				return retval.ToString();
			}
		}

		[ComImport]
		[SecurityCritical]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("D332DB9E-B9B3-4125-8207-A14884F53216")]
		public interface IClrMetaHost
		{
			[MethodImpl(MethodImplOptions.InternalCall)]
			[return: MarshalAs(UnmanagedType.Interface)]
			object GetRuntime([In][MarshalAs(UnmanagedType.LPWStr)] string version, [In][MarshalAs(UnmanagedType.LPStruct)] Guid interfaceId);

			[MethodImpl(MethodImplOptions.InternalCall)]
			void GetVersionFromFile([In][MarshalAs(UnmanagedType.LPWStr)] string filePath, [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder buffer, [In][Out][MarshalAs(UnmanagedType.U4)] ref uint bufferLength);

			[MethodImpl(MethodImplOptions.InternalCall)]
			[return: MarshalAs(UnmanagedType.Interface)]
			IEnumUnknown EnumerateInstalledRuntimes();

			[MethodImpl(MethodImplOptions.InternalCall)]
			[return: MarshalAs(UnmanagedType.Interface)]
			IEnumUnknown EnumerateLoadedRuntimes([In] IntPtr processHandle);

			[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
			int Reserved01([In] IntPtr reserved1);
		}

		public enum SHChangeNotifyEventID
		{
			SHCNE_ASSOCCHANGED = 0x8000000
		}

		public enum SHChangeNotifyFlags : uint
		{
			SHCNF_IDLIST
		}

		internal enum SIGDN : uint
		{
			NORMALDISPLAY = 0u,
			PARENTRELATIVEPARSING = 2147581953u,
			DESKTOPABSOLUTEPARSING = 2147647488u,
			PARENTRELATIVEEDITING = 2147684353u,
			DESKTOPABSOLUTEEDITING = 2147794944u,
			FILESYSPATH = 2147844096u,
			URL = 2147909632u,
			PARENTRELATIVEFORADDRESSBAR = 2147991553u,
			PARENTRELATIVE = 2148007937u
		}

		[ComImport]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("43826d1e-e718-42ee-bc55-a1e261c37bfe")]
		public interface IShellItem
		{
			void BindToHandler(IntPtr pbc, [MarshalAs(UnmanagedType.LPStruct)] Guid bhid, [MarshalAs(UnmanagedType.LPStruct)] Guid riid, out IntPtr ppv);

			void GetParent(out IShellItem ppsi);

			void GetDisplayName(SIGDN sigdnName, out IntPtr ppszName);

			void GetAttributes(uint sfgaoMask, out uint psfgaoAttribs);

			void Compare(IShellItem psi, uint hint, out int piOrder);
		}

		[ComImport]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[Guid("4CD19ADA-25A5-4A32-B3B7-347BEE5BE36B")]
		public interface IStartMenuPinnedList
		{
			void RemoveFromList(IShellItem psi);
		}

		internal static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);

		public const ushort PROCESSOR_ARCHITECTURE_INTEL = 0;

		public const ushort PROCESSOR_ARCHITECTURE_IA64 = 6;

		public const ushort PROCESSOR_ARCHITECTURE_AMD64 = 9;

		public const ushort PROCESSOR_ARCHITECTURE_ARM64 = 12;

		public const ushort IMAGE_FILE_MACHINE_I386 = 332;

		public const ushort IMAGE_FILE_MACHINE_AMD64 = 34404;

		public const ushort IMAGE_FILE_MACHINE_ARM64 = 43620;

		private static Guid _metaHostPolicyGuid = new Guid(3793290901u, 30642, 18734, 142, 20, 196, 179, 167, 253, 213, 147);

		private static Guid _clrRuntimeInfoGuid = new Guid(3174683090u, 47663, 18538, 137, 176, 180, 176, 203, 70, 104, 145);

		private static Guid _metaHostPolicyClsIdGuid = new Guid(784127130, 6983, 19041, 177, 58, 74, 3, 112, 30, 89, 75);

		private static Guid _corRuntimeHostClsIdGuid = new Guid(3408881443u, 43834, 4562, 156, 64, 0, 192, 79, 163, 10, 62);

		private static Guid _corRuntimeHostInterfaceIdGuid = new Guid(3408881442u, 43834, 4562, 156, 64, 0, 192, 79, 163, 10, 62);

		private static Guid _metaHostGuid = new Guid(3543325598u, 47539, 16677, 130, 7, 161, 72, 132, 245, 50, 22);

		private static Guid _metaHostClsId = new Guid(2457868429u, 3726, 18535, 179, 12, 127, 168, 56, 132, 232, 222);

		[DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true)]
		public static extern void GetSystemInfo([MarshalAs(UnmanagedType.Struct)] ref SYSTEM_INFO sysInfo);

		[DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true)]
		public static extern void GetNativeSystemInfo([MarshalAs(UnmanagedType.Struct)] ref SYSTEM_INFO sysInfo);

		[DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool IsWow64Process2(IntPtr processHandle, out ushort pProcessMachine, out ushort nativeMachine);

		[DllImport("kernel32.dll", BestFitMapping = false, SetLastError = true)]
		public static extern bool VerifyVersionInfo([In][Out] OSVersionInfoEx osvi, [In] uint dwTypeMask, [In] ulong dwConditionMask);

		[DllImport("kernel32.dll")]
		public static extern ulong VerSetConditionMask([In] ulong ConditionMask, [In] uint TypeMask, [In] byte Condition);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern IntPtr LoadLibraryEx(string lpModuleName, IntPtr hFile, uint dwFlags);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern IntPtr LoadLibrary(string lpModuleName);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Ansi, SetLastError = true)]
		public static extern IntPtr GetProcAddress(IntPtr hModule, string procedureName);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool FreeLibrary(IntPtr hModule);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern IntPtr FindResource(IntPtr hModule, string lpName, string lpType);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr LoadResource(IntPtr hModule, IntPtr handle);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr LockResource(IntPtr hglobal);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern uint SizeofResource(IntPtr hModule, IntPtr handle);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		internal static extern bool CloseHandle(HandleRef handle);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern int GetShortPathName(string LongPath, [Out] StringBuilder ShortPath, int BufferSize);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern SafeFileHandle CreateFile(string lpFileName, uint dwDesiredAccess, uint dwShareMode, IntPtr lpSecurityAttributes, uint dwCreationDisposition, uint dwFlagsAndAttributes, IntPtr hTemplateFile);

		[DllImport("clr.dll", BestFitMapping = false, CharSet = CharSet.Unicode, ExactSpelling = true, PreserveSig = false)]
		internal static extern void CorLaunchApplication(uint hostType, string applicationFullName, int manifestPathsCount, string[] manifestPaths, int activationDataCount, string[] activationData, PROCESS_INFORMATION processInformation);

		[DllImport("clr.dll", PreserveSig = false)]
		internal static extern void CreateAssemblyCache(out IAssemblyCache ppAsmCache, int reserved);

		[DllImport("clr.dll", CharSet = CharSet.Unicode, ExactSpelling = true, PreserveSig = false)]
		[return: MarshalAs(UnmanagedType.IUnknown)]
		internal static extern object GetAssemblyIdentityFromFile([In][MarshalAs(UnmanagedType.LPWStr)] string filePath, [In] ref Guid riid);

		[DllImport("clr.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
		internal static extern void CreateAssemblyNameObject(out IAssemblyName ppEnum, string szAssemblyName, uint dwFlags, IntPtr pvReserved);

		[DllImport("clr.dll", CharSet = CharSet.Auto, PreserveSig = false)]
		internal static extern void CreateAssemblyEnum(out IAssemblyEnum ppEnum, IApplicationContext pAppCtx, IAssemblyName pName, uint dwFlags, IntPtr pvReserved);

		[DllImport("kernel32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		internal static extern IntPtr CreateActCtxW([In] ACTCTXW actCtx);

		[DllImport("kernel32.dll", ExactSpelling = true)]
		internal static extern void ReleaseActCtx([In] IntPtr hActCtx);

		internal static string GetLoadedModulePath(string moduleName)
		{
			string result = null;
			IntPtr moduleHandle = GetModuleHandle(moduleName);
			if (moduleHandle != IntPtr.Zero)
			{
				StringBuilder stringBuilder = new StringBuilder(260);
				int moduleFileName = GetModuleFileName(moduleHandle, stringBuilder, stringBuilder.Capacity);
				if (moduleFileName > 0)
				{
					result = stringBuilder.ToString();
				}
			}
			return result;
		}

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern IntPtr GetModuleHandle(string moduleName);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetModuleFileName(IntPtr module, [Out] StringBuilder fileName, int size);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern uint GetCurrentThreadId();

		[DllImport("wininet.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool CreateUrlCacheEntry([In] string urlName, [In] int expectedFileSize, [In] string fileExtension, [Out] StringBuilder fileName, [In] int dwReserved);

		[DllImport("wininet.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool CommitUrlCacheEntry([In] string lpszUrlName, [In] string lpszLocalFileName, [In] long ExpireTime, [In] long LastModifiedTime, [In] uint CacheEntryType, [In] string lpHeaderInfo, [In] int dwHeaderSize, [In] string lpszFileExtension, [In] string lpszOriginalUrl);

		[DllImport("mscoree.dll", EntryPoint = "CLRCreateInstance", PreserveSig = false)]
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Interface)]
		private static extern void GetClrMetaHostPolicy(ref Guid clsid, ref Guid iid, [MarshalAs(UnmanagedType.Interface)] out IClrMetaHostPolicy ClrMetaHostPolicy);

		public static IAssemblyCache GetAssemblyCacheInterface(string CLRVersionString, bool FetchRuntimeHost, out CCorRuntimeHost RuntimeHost)
		{
			IClrMetaHostPolicy ClrMetaHostPolicy = null;
			RuntimeHost = null;
			GetClrMetaHostPolicy(ref _metaHostPolicyClsIdGuid, ref _metaHostPolicyGuid, out ClrMetaHostPolicy);
			if (ClrMetaHostPolicy == null)
			{
				return null;
			}
			StringBuilder stringBuilder = new StringBuilder("v", "v65535.65535.65535".Length);
			stringBuilder.Append(CLRVersionString);
			int versionLength = stringBuilder.Capacity;
			int imageVersionLength = 0;
			int pdwConfigFlags = 0;
			IClrRuntimeInfo clrRuntimeInfo = (IClrRuntimeInfo)ClrMetaHostPolicy.GetRequestedRuntime(MetaHostPolicyFlags.MetaHostPolicyApplyUpgradePolicy, null, null, stringBuilder, ref versionLength, null, ref imageVersionLength, out pdwConfigFlags, _clrRuntimeInfoGuid);
			if (clrRuntimeInfo == null)
			{
				return null;
			}
			IntPtr procAddress = clrRuntimeInfo.GetProcAddress("CoInitializeEE");
			CoInitializeEEDelegate coInitializeEEDelegate = (CoInitializeEEDelegate)Marshal.GetDelegateForFunctionPointer(procAddress, typeof(CoInitializeEEDelegate));
			int errorCode = coInitializeEEDelegate(0u);
			Marshal.ThrowExceptionForHR(errorCode);
			if (FetchRuntimeHost)
			{
				RuntimeHost = new CCorRuntimeHost(clrRuntimeInfo);
			}
			IntPtr procAddress2 = clrRuntimeInfo.GetProcAddress("CreateAssemblyCache");
			CreateAssemblyCacheDelegate createAssemblyCacheDelegate = (CreateAssemblyCacheDelegate)Marshal.GetDelegateForFunctionPointer(procAddress2, typeof(CreateAssemblyCacheDelegate));
			IAssemblyCache ppAsmCache = null;
			errorCode = createAssemblyCacheDelegate(out ppAsmCache, 0u);
			Marshal.ThrowExceptionForHR(errorCode);
			return ppAsmCache;
		}

		public static bool VerifyCLRVersionInfo(Version v, string procArch)
		{
			bool result = true;
			IClrMetaHostPolicy ClrMetaHostPolicy = null;
			GetClrMetaHostPolicy(ref _metaHostPolicyClsIdGuid, ref _metaHostPolicyGuid, out ClrMetaHostPolicy);
			if (ClrMetaHostPolicy == null)
			{
				return false;
			}
			string value = v.ToString(3);
			StringBuilder stringBuilder = new StringBuilder("v", "v65535.65535.65535".Length);
			stringBuilder.Append(value);
			int versionLength = stringBuilder.Capacity;
			int imageVersionLength = 0;
			int pdwConfigFlags = 0;
			try
			{
				IClrRuntimeInfo clrRuntimeInfo = (IClrRuntimeInfo)ClrMetaHostPolicy.GetRequestedRuntime(MetaHostPolicyFlags.MetaHostPolicyApplyUpgradePolicy, null, null, stringBuilder, ref versionLength, null, ref imageVersionLength, out pdwConfigFlags, _clrRuntimeInfoGuid);
				if (clrRuntimeInfo == null)
				{
					return false;
				}
				return result;
			}
			catch (COMException ex)
			{
				result = false;
				if (ex.ErrorCode != -2146232576)
				{
					throw;
				}
				return result;
			}
		}

		[DllImport("mscoree.dll", EntryPoint = "CLRCreateInstance", PreserveSig = false)]
		[SecurityCritical]
		[return: MarshalAs(UnmanagedType.Interface)]
		private static extern object nCLRCreateInstance([MarshalAs(UnmanagedType.LPStruct)] Guid clsid, [MarshalAs(UnmanagedType.LPStruct)] Guid iid);

		[SecurityCritical]
		public static void GetFileVersion(string szFileName, StringBuilder szBuffer, uint cchBuffer, out uint dwLength)
		{
			IClrMetaHost clrMetaHost = (IClrMetaHost)nCLRCreateInstance(_metaHostClsId, _metaHostGuid);
			clrMetaHost.GetVersionFromFile(szFileName, szBuffer, ref cchBuffer);
			dwLength = cchBuffer;
		}

		[SecurityCritical]
		private static T GetClrMetaHost<T>()
		{
			return (T)nCLRCreateInstance(_metaHostClsId, _metaHostGuid);
		}

		[DllImport("mscoree.dll", CharSet = CharSet.Unicode, ExactSpelling = true, PreserveSig = false)]
		public static extern void GetRequestedRuntimeInfo(string pExe, string pwszVersion, string pConfigurationFile, uint startupFlags, uint runtimeInfoFlags, StringBuilder pDirectory, uint dwDirectory, out uint dwDirectoryLength, StringBuilder pVersion, uint cchBuffer, out uint dwLength);

		[DllImport("wininet.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		public static extern bool InternetGetCookieW([In] string url, [In] string cookieName, [Out] StringBuilder cookieData, [In][Out] ref uint bytes);

		[DllImport("shell32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		public static extern void SHChangeNotify(int eventID, uint flags, IntPtr item1, IntPtr item2);

		[DllImport("shell32.dll", CharSet = CharSet.Unicode)]
		public static extern uint SHCreateItemFromParsingName([In][MarshalAs(UnmanagedType.LPWStr)] string pszPath, [In] IntPtr pbc, [In][MarshalAs(UnmanagedType.LPStruct)] Guid riid, [MarshalAs(UnmanagedType.Interface)] out object ppv);

		[DllImport("Ole32.dll")]
		public static extern uint CoCreateInstance([In] ref Guid clsid, [MarshalAs(UnmanagedType.IUnknown)] object punkOuter, int context, [In] ref Guid iid, [MarshalAs(UnmanagedType.IUnknown)] out object o);
	}
	internal class PEStream : Stream
	{
		protected class StreamComponentList : ArrayList
		{
			public int Add(PEComponent peComponent)
			{
				if (peComponent.Size > 0)
				{
					return Add((object)peComponent);
				}
				return -1;
			}
		}

		protected class PEComponentComparer : IComparer
		{
			public int Compare(object a, object b)
			{
				PEComponent pEComponent = (PEComponent)a;
				PEComponent pEComponent2 = (PEComponent)b;
				if (pEComponent.Address > pEComponent2.Address)
				{
					return 1;
				}
				if (pEComponent.Address < pEComponent2.Address)
				{
					return -1;
				}
				return 0;
			}
		}

		protected struct IMAGE_DOS_HEADER
		{
			public ushort e_magic;

			public ushort e_cblp;

			public ushort e_cp;

			public ushort e_crlc;

			public ushort e_cparhdr;

			public ushort e_minalloc;

			public ushort e_maxalloc;

			public ushort e_ss;

			public ushort e_sp;

			public ushort e_csum;

			public ushort e_ip;

			public ushort e_cs;

			public ushort e_lfarlc;

			public ushort e_ovno;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
			public ushort[] e_res;

			public ushort e_oemid;

			public ushort e_oeminfo;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
			public ushort[] e_res2;

			public uint e_lfanew;
		}

		protected struct IMAGE_FILE_HEADER
		{
			public ushort Machine;

			public ushort NumberOfSections;

			public uint TimeDateStamp;

			public uint PointerToSymbolTable;

			public uint NumberOfSymbols;

			public ushort SizeOfOptionalHeader;

			public ushort Characteristics;
		}

		protected struct IMAGE_OPTIONAL_HEADER32
		{
			public ushort Magic;

			public byte MajorLinkerVersion;

			public byte MinorLinkerVersion;

			public uint SizeOfCode;

			public uint SizeOfInitializedData;

			public uint SizeOfUninitializedData;

			public uint AddressOfEntryPoint;

			public uint BaseOfCode;

			public uint BaseOfData;

			public uint ImageBase;

			public uint SectionAlignment;

			public uint FileAlignment;

			public ushort MajorOperatingSystemVersion;

			public ushort MinorOperatingSystemVersion;

			public ushort MajorImageVersion;

			public ushort MinorImageVersion;

			public ushort MajorSubsystemVersion;

			public ushort MinorSubsystemVersion;

			public uint Win32VersionValue;

			public uint SizeOfImage;

			public uint SizeOfHeaders;

			public uint CheckSum;

			public ushort Subsystem;

			public ushort DllCharacteristics;

			public uint SizeOfStackReserve;

			public uint SizeOfStackCommit;

			public uint SizeOfHeapReserve;

			public uint SizeOfHeapCommit;

			public uint LoaderFlags;

			public uint NumberOfRvaAndSizes;
		}

		[Serializable]
		protected struct IMAGE_OPTIONAL_HEADER64
		{
			internal ushort Magic;

			internal byte MajorLinkerVersion;

			internal byte MinorLinkerVersion;

			internal uint SizeOfCode;

			internal uint SizeOfInitializedData;

			internal uint SizeOfUninitializedData;

			internal uint AddressOfEntryPoint;

			internal uint BaseOfCode;

			internal ulong ImageBase;

			internal uint SectionAlignment;

			internal uint FileAlignment;

			internal ushort MajorOperatingSystemVersion;

			internal ushort MinorOperatingSystemVersion;

			internal ushort MajorImageVersion;

			internal ushort MinorImageVersion;

			internal ushort MajorSubsystemVersion;

			internal ushort MinorSubsystemVersion;

			internal uint Win32VersionValue;

			internal uint SizeOfImage;

			internal uint SizeOfHeaders;

			internal uint CheckSum;

			internal ushort Subsystem;

			internal ushort DllCharacteristics;

			internal ulong SizeOfStackReserve;

			internal ulong SizeOfStackCommit;

			internal ulong SizeOfHeapReserve;

			internal ulong SizeOfHeapCommit;

			internal uint LoaderFlags;

			internal uint NumberOfRvaAndSizes;
		}

		[Serializable]
		protected struct IMAGE_DATA_DIRECTORY
		{
			public uint VirtualAddress;

			public uint Size;
		}

		[Serializable]
		protected struct IMAGE_SECTION_HEADER
		{
			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
			public byte[] Name;

			public uint VirtualSize;

			public uint VirtualAddress;

			public uint SizeOfRawData;

			public uint PointerToRawData;

			public uint PointerToRelocations;

			public uint PointerToLinenumbers;

			public ushort NumberOfRelocations;

			public ushort NumberOfLinenumbers;

			public uint Characteristics;
		}

		[Serializable]
		protected struct IMAGE_RESOURCE_DIRECTORY
		{
			public uint Characteristics;

			public uint TimeDateStamp;

			public ushort MajorVersion;

			public ushort MinorVersion;

			public ushort NumberOfNamedEntries;

			public ushort NumberOfIdEntries;
		}

		[Serializable]
		protected struct IMAGE_RESOURCE_DATA_ENTRY
		{
			public uint OffsetToData;

			public uint Size;

			public uint CodePage;

			public uint Reserved;
		}

		[Serializable]
		protected struct IMAGE_RESOURCE_DIRECTORY_ENTRY
		{
			public uint Name;

			public uint OffsetToData;
		}

		protected class PEComponent
		{
			protected long _address;

			protected long _size;

			protected object _data;

			public long Address => _address;

			public long Size => _size;

			public PEComponent()
			{
				_address = 0L;
				_size = 0L;
				_data = null;
			}

			public PEComponent(FileStream file, long address, long size)
			{
				_address = address;
				_size = size;
				_data = new DiskDataBlock(file, address, size);
			}

			public virtual int Read(byte[] buffer, int bufferOffset, long sourceOffset, int count)
			{
				int num = 0;
				if (_data is DataComponent)
				{
					DataComponent dataComponent = (DataComponent)_data;
					long num2 = Math.Min(count, _size - sourceOffset);
					if (num2 < 0)
					{
						throw new ArgumentException(Resources.GetString("Ex_InvalidCopyRequest"));
					}
					return dataComponent.Read(buffer, bufferOffset, sourceOffset, (int)num2);
				}
				byte[] array = ToByteArray(_data);
				long num3 = Math.Min(count, array.Length - sourceOffset);
				if (num3 < 0)
				{
					throw new ArgumentException(Resources.GetString("Ex_InvalidCopyRequest"));
				}
				Array.Copy(array, (int)sourceOffset, buffer, bufferOffset, (int)num3);
				return (int)num3;
			}

			protected static byte[] ToByteArray(object data)
			{
				int num = Marshal.SizeOf(data);
				IntPtr intPtr = Marshal.AllocCoTaskMem(num);
				Marshal.StructureToPtr(data, intPtr, fDeleteOld: false);
				byte[] array = new byte[num];
				Marshal.Copy(intPtr, array, 0, array.Length);
				Marshal.FreeCoTaskMem(intPtr);
				return array;
			}

			protected static object ReadData(FileStream file, long position, Type dataType)
			{
				int num = Marshal.SizeOf(dataType);
				byte[] array = new byte[num];
				long num2 = file.Seek(position, SeekOrigin.Begin);
				if (num2 != position)
				{
					throw new IOException(Resources.GetString("Ex_NotEnoughDataInFile"));
				}
				int num3 = file.Read(array, 0, array.Length);
				if (num3 < num)
				{
					throw new IOException(Resources.GetString("Ex_NotEnoughDataInFile"));
				}
				IntPtr intPtr = Marshal.AllocCoTaskMem(num);
				Marshal.Copy(array, 0, intPtr, num);
				object result = Marshal.PtrToStructure(intPtr, dataType);
				Marshal.FreeCoTaskMem(intPtr);
				return result;
			}

			protected long CalculateSize(object data)
			{
				return Marshal.SizeOf(data);
			}
		}

		protected class DosHeader : PEComponent
		{
			protected IMAGE_DOS_HEADER _dosHeader;

			public uint NtHeaderPosition => _dosHeader.e_lfanew;

			public DosHeader(FileStream file)
			{
				file.Seek(0L, SeekOrigin.Begin);
				_dosHeader = (IMAGE_DOS_HEADER)PEComponent.ReadData(file, 0L, _dosHeader.GetType());
				if (_dosHeader.e_magic != 23117)
				{
					throw new Win32Exception(11, Resources.GetString("Ex_InvalidPEImage"));
				}
				_data = _dosHeader;
				_address = 0L;
				_size = CalculateSize(_dosHeader);
			}
		}

		protected class DosStub : PEComponent
		{
			public DosStub(FileStream file, long startAddress, long size)
			{
				_address = startAddress;
				_size = size;
				_data = new DiskDataBlock(file, _address, _size);
			}
		}

		protected class NtSignature : PEComponent
		{
			public NtSignature(FileStream file, long address)
			{
				uint num = 0u;
				num = (uint)PEComponent.ReadData(file, address, num.GetType());
				if (num != 17744)
				{
					throw new Win32Exception(11, Resources.GetString("Ex_InvalidPEFormat"));
				}
				_address = address;
				_size = CalculateSize(num);
				_data = num;
			}
		}

		protected class FileHeader : PEComponent
		{
			protected IMAGE_FILE_HEADER _fileHeader;

			public ushort SizeOfOptionalHeader => _fileHeader.SizeOfOptionalHeader;

			public ushort NumberOfSections => _fileHeader.NumberOfSections;

			public bool IsImageFileDll => (_fileHeader.Characteristics & 0x2000) != 0;

			public FileHeader(FileStream file, long address)
			{
				_fileHeader = (IMAGE_FILE_HEADER)PEComponent.ReadData(file, address, _fileHeader.GetType());
				_address = address;
				_size = CalculateSize(_fileHeader);
				_data = _fileHeader;
			}
		}

		protected class OptionalHeader : PEComponent
		{
			protected IMAGE_OPTIONAL_HEADER32 _optionalHeader32;

			protected IMAGE_OPTIONAL_HEADER64 _optionalHeader64;

			protected bool _is64Bit;

			public uint CheckSum
			{
				set
				{
					if (_is64Bit)
					{
						_optionalHeader64.CheckSum = value;
						_data = _optionalHeader64;
					}
					else
					{
						_optionalHeader32.CheckSum = value;
						_data = _optionalHeader32;
					}
				}
			}

			public uint NumberOfRvaAndSizes
			{
				get
				{
					if (_is64Bit)
					{
						return _optionalHeader64.NumberOfRvaAndSizes;
					}
					return _optionalHeader32.NumberOfRvaAndSizes;
				}
			}

			public OptionalHeader(FileStream file, long address)
			{
				_optionalHeader32 = (IMAGE_OPTIONAL_HEADER32)PEComponent.ReadData(file, address, _optionalHeader32.GetType());
				if (_optionalHeader32.Magic == 523)
				{
					_is64Bit = true;
					_optionalHeader64 = (IMAGE_OPTIONAL_HEADER64)PEComponent.ReadData(file, address, _optionalHeader64.GetType());
					_size = CalculateSize(_optionalHeader64);
					_data = _optionalHeader64;
				}
				else
				{
					if (_optionalHeader32.Magic != 267)
					{
						throw new NotSupportedException(Resources.GetString("Ex_PEImageTypeNotSupported"));
					}
					_is64Bit = false;
					_size = CalculateSize(_optionalHeader32);
					_data = _optionalHeader32;
				}
				_address = address;
			}
		}

		protected class DataDirectory : PEComponent
		{
			private IMAGE_DATA_DIRECTORY _dataDirectory;

			public uint VirtualAddress => _dataDirectory.VirtualAddress;

			public DataDirectory(FileStream file, long address)
			{
				_dataDirectory = (IMAGE_DATA_DIRECTORY)PEComponent.ReadData(file, address, _dataDirectory.GetType());
				_address = address;
				_size = CalculateSize(_dataDirectory);
				_data = _dataDirectory;
			}
		}

		protected class SectionHeader : PEComponent
		{
			protected IMAGE_SECTION_HEADER _imageSectionHeader;

			protected Section _section;

			public Section Section
			{
				set
				{
					_section = value;
				}
			}

			public uint VirtualAddress => _imageSectionHeader.VirtualAddress;

			public uint PointerToRawData => _imageSectionHeader.PointerToRawData;

			public uint SizeOfRawData => _imageSectionHeader.SizeOfRawData;

			public SectionHeader(FileStream file, long address)
			{
				_imageSectionHeader = (IMAGE_SECTION_HEADER)PEComponent.ReadData(file, address, _imageSectionHeader.GetType());
				_address = address;
				_size = CalculateSize(_imageSectionHeader);
				_data = _imageSectionHeader;
			}
		}

		protected class Section : PEComponent
		{
			public SectionHeader _sectionHeader;

			public Section(FileStream file, SectionHeader sectionHeader)
			{
				_address = sectionHeader.PointerToRawData;
				_size = sectionHeader.SizeOfRawData;
				_data = new DiskDataBlock(file, _address, _size);
				_sectionHeader = sectionHeader;
			}

			public virtual void AddComponentsToStream(StreamComponentList stream)
			{
				stream.Add(this);
			}
		}

		protected class ResourceComponent : PEComponent
		{
			public virtual void AddComponentsToStream(StreamComponentList stream)
			{
				stream.Add(this);
			}
		}

		protected class ResourceDirectory : ResourceComponent
		{
			protected IMAGE_RESOURCE_DIRECTORY _imageResourceDirectory;

			protected Hashtable _resourceDirectoryItems = new Hashtable();

			protected ArrayList _resourceDirectoryEntries = new ArrayList();

			public ResourceComponent this[object key]
			{
				get
				{
					if (_resourceDirectoryItems.Contains(key))
					{
						return (ResourceComponent)_resourceDirectoryItems[key];
					}
					return null;
				}
			}

			public int ResourceComponentCount => _resourceDirectoryItems.Count;

			public ResourceDirectory(ResourceSection resourceSection, FileStream file, long rootResourceAddress, long resourceAddress, long addressDelta, bool partialConstruct)
			{
				_imageResourceDirectory = (IMAGE_RESOURCE_DIRECTORY)PEComponent.ReadData(file, resourceAddress, _imageResourceDirectory.GetType());
				_address = resourceAddress;
				_size = CalculateSize(_imageResourceDirectory);
				_data = _imageResourceDirectory;
				long num = _address + _size;
				int num2 = 0;
				for (num2 = 0; num2 < _imageResourceDirectory.NumberOfIdEntries; num2++)
				{
					ResourceDirectoryEntry resourceDirectoryEntry = new ResourceDirectoryEntry(file, num);
					_resourceDirectoryEntries.Add(resourceDirectoryEntry);
					num += resourceDirectoryEntry.Size;
				}
				for (num2 = 0; num2 < _imageResourceDirectory.NumberOfNamedEntries; num2++)
				{
					ResourceDirectoryEntry resourceDirectoryEntry2 = new ResourceDirectoryEntry(file, num);
					_resourceDirectoryEntries.Add(resourceDirectoryEntry2);
					num += resourceDirectoryEntry2.Size;
				}
				foreach (ResourceDirectoryEntry resourceDirectoryEntry3 in _resourceDirectoryEntries)
				{
					bool flag = false;
					object obj = null;
					if (resourceDirectoryEntry3.NameIsString)
					{
						ResourceDirectoryString resourceDirectoryString = resourceSection.CreateResourceDirectoryString(file, rootResourceAddress + resourceDirectoryEntry3.NameOffset);
						obj = resourceDirectoryString.NameString;
					}
					else
					{
						obj = resourceDirectoryEntry3.Id;
						if (rootResourceAddress == resourceAddress && resourceDirectoryEntry3.Id == 24)
						{
							flag = true;
						}
					}
					resourceDirectoryEntry3.Key = obj;
					object obj2 = null;
					if (resourceDirectoryEntry3.IsDirectory)
					{
						if (!partialConstruct || (partialConstruct && flag))
						{
							obj2 = new ResourceDirectory(resourceSection, file, rootResourceAddress, rootResourceAddress + resourceDirectoryEntry3.OffsetToData, addressDelta, partialConstruct: false);
						}
					}
					else
					{
						obj2 = new ResourceData(file, rootResourceAddress, rootResourceAddress + resourceDirectoryEntry3.OffsetToData, addressDelta);
					}
					if (obj2 != null)
					{
						_resourceDirectoryItems.Add(obj, obj2);
					}
				}
			}

			public override void AddComponentsToStream(StreamComponentList stream)
			{
				stream.Add(this);
				foreach (ResourceDirectoryEntry resourceDirectoryEntry in _resourceDirectoryEntries)
				{
					resourceDirectoryEntry.AddComponentsToStream(stream);
				}
				foreach (ResourceComponent value in _resourceDirectoryItems.Values)
				{
					value.AddComponentsToStream(stream);
				}
			}

			public ResourceComponent GetResourceComponent(int index)
			{
				ResourceDirectoryEntry resourceDirectoryEntry = (ResourceDirectoryEntry)_resourceDirectoryEntries[index];
				return this[resourceDirectoryEntry.Key];
			}
		}

		protected class ResourceDirectoryEntry : ResourceComponent
		{
			protected IMAGE_RESOURCE_DIRECTORY_ENTRY _imageResourceDirectoryEntry;

			protected object _key;

			public long NameOffset => _imageResourceDirectoryEntry.Name & 0x7FFFFFFF;

			public bool NameIsString => (_imageResourceDirectoryEntry.Name & 0x80000000u) != 0;

			public ushort Id => (ushort)(_imageResourceDirectoryEntry.Name & 0xFFFFu);

			public long OffsetToData => _imageResourceDirectoryEntry.OffsetToData & 0x7FFFFFFF;

			public bool IsDirectory => (_imageResourceDirectoryEntry.OffsetToData & 0x80000000u) != 0;

			public object Key
			{
				get
				{
					return _key;
				}
				set
				{
					_key = value;
				}
			}

			public ResourceDirectoryEntry(FileStream file, long address)
			{
				_imageResourceDirectoryEntry = (IMAGE_RESOURCE_DIRECTORY_ENTRY)PEComponent.ReadData(file, address, _imageResourceDirectoryEntry.GetType());
				_address = address;
				_size = CalculateSize(_imageResourceDirectoryEntry);
				_data = _imageResourceDirectoryEntry;
			}
		}

		protected class ResourceDirectoryString : ResourceComponent
		{
			protected ushort _length;

			protected byte[] _nameStringBuffer;

			protected string _nameString;

			public string NameString => _nameString;

			public ResourceDirectoryString(FileStream file, long offset)
			{
				_length = (ushort)PEComponent.ReadData(file, offset, _length.GetType());
				if (_length > 0)
				{
					long num = _length * Marshal.SizeOf(typeof(ushort));
					_nameStringBuffer = new byte[num];
					long num2 = offset + CalculateSize(_length);
					long num3 = file.Seek(num2, SeekOrigin.Begin);
					if (num3 != num2)
					{
						throw new IOException(Resources.GetString("Ex_NotEnoughDataInFile"));
					}
					int num4 = file.Read(_nameStringBuffer, 0, _nameStringBuffer.Length);
					if (num4 < num)
					{
						throw new IOException(Resources.GetString("Ex_NotEnoughDataInFile"));
					}
					_nameString = Encoding.Unicode.GetString(_nameStringBuffer);
					_address = offset;
					_size = num + CalculateSize(_length);
				}
				else
				{
					_nameStringBuffer = null;
					_nameString = null;
					_address = offset;
					_size = CalculateSize(_length);
				}
				_data = new DiskDataBlock(file, _address, _size);
			}
		}

		protected class ResourceData : ResourceComponent
		{
			protected IMAGE_RESOURCE_DATA_ENTRY _resourceDataEntry;

			protected ResourceRawData _resourceRawData;

			public byte[] Data => _resourceRawData.Data;

			public ResourceData(FileStream file, long rootResourceAddress, long address, long addressDelta)
			{
				_resourceDataEntry = (IMAGE_RESOURCE_DATA_ENTRY)PEComponent.ReadData(file, address, _resourceDataEntry.GetType());
				_resourceRawData = new ResourceRawData(file, _resourceDataEntry.OffsetToData - addressDelta, _resourceDataEntry.Size);
				_address = address;
				_size = CalculateSize(_resourceDataEntry);
				_data = _resourceDataEntry;
			}

			public override void AddComponentsToStream(StreamComponentList stream)
			{
				stream.Add(this);
				stream.Add(_resourceRawData);
			}

			public void ZeroData()
			{
				_resourceRawData.ZeroData();
			}
		}

		protected class ResourceRawData : ResourceComponent
		{
			public byte[] Data
			{
				get
				{
					byte[] array = new byte[_size];
					if (_data is DataComponent)
					{
						((DataComponent)_data).Read(array, 0, 0L, array.Length);
						return array;
					}
					throw new NotSupportedException();
				}
			}

			public ResourceRawData(FileStream file, long address, long size)
			{
				_address = address;
				_size = size;
				_data = new DiskDataBlock(file, address, size);
			}

			public void ZeroData()
			{
				_data = new BlankDataBlock(_size);
			}
		}

		protected class ResourceSection : Section
		{
			protected ResourceDirectory _resourceDirectory;

			protected ArrayList _resourceDirectoryStrings = new ArrayList();

			public ResourceDirectory RootResourceDirectory => _resourceDirectory;

			public ResourceSection(FileStream file, SectionHeader sectionHeader, bool partialConstruct)
				: base(file, sectionHeader)
			{
				_resourceDirectory = new ResourceDirectory(this, file, sectionHeader.PointerToRawData, sectionHeader.PointerToRawData, (long)sectionHeader.VirtualAddress - (long)sectionHeader.PointerToRawData, partialConstruct);
				_address = 0L;
				_size = 0L;
				_data = null;
			}

			public ResourceDirectoryString CreateResourceDirectoryString(FileStream file, long offset)
			{
				foreach (ResourceDirectoryString resourceDirectoryString3 in _resourceDirectoryStrings)
				{
					if (resourceDirectoryString3.Address == offset)
					{
						return resourceDirectoryString3;
					}
				}
				ResourceDirectoryString resourceDirectoryString2 = new ResourceDirectoryString(file, offset);
				_resourceDirectoryStrings.Add(resourceDirectoryString2);
				return resourceDirectoryString2;
			}

			public override void AddComponentsToStream(StreamComponentList stream)
			{
				_resourceDirectory.AddComponentsToStream(stream);
				foreach (ResourceDirectoryString resourceDirectoryString in _resourceDirectoryStrings)
				{
					resourceDirectoryString.AddComponentsToStream(stream);
				}
			}
		}

		protected abstract class DataComponent
		{
			public abstract int Read(byte[] buffer, int bufferOffset, long sourceOffset, int count);
		}

		protected class DiskDataBlock : DataComponent
		{
			public long _address;

			public long _size;

			public FileStream _file;

			public DiskDataBlock(FileStream file, long address, long size)
			{
				_address = address;
				_size = size;
				_file = file;
			}

			public override int Read(byte[] buffer, int bufferOffset, long sourceOffset, int count)
			{
				int num = 0;
				num = (int)Math.Min(count, _size - sourceOffset);
				if (num < 0)
				{
					throw new ArgumentException(Resources.GetString("Ex_InvalidCopyRequest"));
				}
				_file.Seek(_address + sourceOffset, SeekOrigin.Begin);
				return _file.Read(buffer, bufferOffset, num);
			}
		}

		protected class BlankDataBlock : DataComponent
		{
			public long _size;

			public BlankDataBlock(long size)
			{
				_size = size;
			}

			public override int Read(byte[] buffer, int bufferOffset, long sourceOffset, int count)
			{
				int num = 0;
				num = (int)Math.Min(count, _size - sourceOffset);
				if (num < 0)
				{
					throw new ArgumentException(Resources.GetString("Ex_InvalidCopyRequest"));
				}
				int num2 = 0;
				for (num2 = 0; num2 < num; num2++)
				{
					buffer[bufferOffset + num2] = 0;
				}
				return num;
			}
		}

		protected bool _canRead;

		protected bool _canSeek;

		protected FileStream _peFile;

		protected long _length;

		protected long _position;

		protected const ushort _id1ManifestId = 1;

		protected const ushort _id1ManifestLanguageId = 1033;

		protected StreamComponentList _streamComponents = new StreamComponentList();

		internal const ushort IMAGE_DOS_SIGNATURE = 23117;

		internal const uint IMAGE_NT_SIGNATURE = 17744u;

		internal const uint IMAGE_NT_OPTIONAL_HDR32_MAGIC = 267u;

		internal const uint IMAGE_NT_OPTIONAL_HDR64_MAGIC = 523u;

		internal const uint IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16u;

		internal const uint IMAGE_FILE_DLL = 8192u;

		protected const uint IMAGE_DIRECTORY_ENTRY_EXPORT = 0u;

		protected const uint IMAGE_DIRECTORY_ENTRY_IMPORT = 1u;

		protected const uint IMAGE_DIRECTORY_ENTRY_RESOURCE = 2u;

		protected const uint IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3u;

		protected const uint IMAGE_DIRECTORY_ENTRY_SECURITY = 4u;

		protected const uint IMAGE_DIRECTORY_ENTRY_BASERELOC = 5u;

		protected const uint IMAGE_DIRECTORY_ENTRY_DEBUG = 6u;

		protected const uint IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 7u;

		protected const uint IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8u;

		protected const uint IMAGE_DIRECTORY_ENTRY_TLS = 9u;

		protected const uint IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10u;

		protected const uint IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11u;

		protected const uint IMAGE_DIRECTORY_ENTRY_IAT = 12u;

		protected const uint IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13u;

		protected const uint IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14u;

		protected const uint IMAGE_RESOURCE_NAME_IS_STRING = 2147483648u;

		protected const uint IMAGE_RESOURCE_DATA_IS_DIRECTORY = 2147483648u;

		protected DosHeader _dosHeader;

		protected DosStub _dosStub;

		protected NtSignature _ntSignature;

		protected FileHeader _fileHeader;

		protected OptionalHeader _optionalHeader;

		protected ArrayList _dataDirectories = new ArrayList();

		protected ArrayList _sectionHeaders = new ArrayList();

		protected ArrayList _sections = new ArrayList();

		protected ResourceSection _resourceSection;

		protected bool _partialConstruct;

		protected const ushort ManifestDirId = 24;

		protected const int ErrorBadFormat = 11;

		public override bool CanRead => _canRead;

		public override bool CanSeek => _canSeek;

		public override bool CanWrite => false;

		public override long Length => _length;

		public override long Position
		{
			get
			{
				return _position;
			}
			set
			{
				Seek(value, SeekOrigin.Begin);
			}
		}

		public bool IsImageFileDll => _fileHeader.IsImageFileDll;

		public static ushort Id1ManifestId => 1;

		public static ushort Id1ManifestLanguageId => 1033;

		public PEStream(string filePath)
		{
			ConstructFromFile(filePath, partialConstruct: true);
		}

		public PEStream(string filePath, bool partialConstruct)
		{
			ConstructFromFile(filePath, partialConstruct);
		}

		private void ConstructFromFile(string filePath, bool partialConstruct)
		{
			string fileName = Path.GetFileName(filePath);
			bool flag = false;
			try
			{
				_peFile = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
				ConstructPEImage(_peFile, partialConstruct);
				flag = true;
			}
			catch (IOException innerException)
			{
				throw new IOException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidPEImage"), new object[1] { fileName }), innerException);
			}
			catch (Win32Exception innerException2)
			{
				throw new IOException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidPEImage"), new object[1] { fileName }), innerException2);
			}
			catch (NotSupportedException innerException3)
			{
				throw new IOException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidPEImage"), new object[1] { fileName }), innerException3);
			}
			finally
			{
				if (!flag && _peFile != null)
				{
					_peFile.Close();
				}
			}
		}

		public override void Flush()
		{
			throw new NotImplementedException();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			bool flag = false;
			long num = 0L;
			int num2 = 0;
			int num3 = count;
			long num4 = 0L;
			int num5 = offset;
			foreach (PEComponent streamComponent in _streamComponents)
			{
				if (!flag)
				{
					num = streamComponent.Address + streamComponent.Size - 1;
					if (_position <= num)
					{
						num4 = _position - streamComponent.Address;
						if (num4 < 0)
						{
							throw new Win32Exception(11, Resources.GetString("Ex_InvalidPEImage"));
						}
						flag = true;
					}
				}
				if (flag)
				{
					num2 = streamComponent.Read(buffer, num5, num4, num3);
					num5 += num2;
					_position += num2;
					num3 -= num2;
					num4 = 0L;
				}
				if (num3 <= 0)
				{
					break;
				}
			}
			return count - num3;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			switch (origin)
			{
			case SeekOrigin.Begin:
				_position = offset;
				break;
			case SeekOrigin.Current:
				_position += offset;
				break;
			case SeekOrigin.End:
				_position = _length + offset;
				break;
			}
			if (_position < 0)
			{
				_position = 0L;
			}
			if (_position > _length)
			{
				_position = _length;
			}
			return _position;
		}

		public override void SetLength(long value)
		{
			throw new NotImplementedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			throw new NotImplementedException();
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (disposing && _peFile != null)
				{
					_peFile.Close();
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		public void ZeroOutOptionalHeaderCheckSum()
		{
			_optionalHeader.CheckSum = 0u;
		}

		public void ZeroOutManifestResource(ushort manifestId, ushort languageId)
		{
			ResourceComponent resourceComponent = RetrieveResource(new object[3]
			{
				(ushort)24,
				manifestId,
				languageId
			});
			if (resourceComponent != null && resourceComponent is ResourceData)
			{
				((ResourceData)resourceComponent).ZeroData();
			}
		}

		public byte[] GetManifestResource(ushort manifestId, ushort languageId)
		{
			ResourceComponent resourceComponent = RetrieveResource(new object[3]
			{
				(ushort)24,
				manifestId,
				languageId
			});
			if (resourceComponent != null && resourceComponent is ResourceData)
			{
				return ((ResourceData)resourceComponent).Data;
			}
			return null;
		}

		public byte[] GetDefaultId1ManifestResource()
		{
			return GetId1ManifestResource()?.Data;
		}

		public void ZeroOutDefaultId1ManifestResource()
		{
			GetId1ManifestResource()?.ZeroData();
		}

		protected ResourceData GetId1ManifestResource()
		{
			ResourceComponent resourceComponent = RetrieveResource(new object[2]
			{
				(ushort)24,
				Id1ManifestId
			});
			if (resourceComponent != null && resourceComponent is ResourceDirectory)
			{
				ResourceDirectory resourceDirectory = (ResourceDirectory)resourceComponent;
				if (resourceDirectory.ResourceComponentCount > 1)
				{
					throw new Win32Exception(11, Resources.GetString("Ex_MultipleId1Manifest"));
				}
				if (resourceDirectory.ResourceComponentCount == 1)
				{
					ResourceComponent resourceComponent2 = resourceDirectory.GetResourceComponent(0);
					if (resourceComponent2 != null && resourceComponent2 is ResourceData)
					{
						return (ResourceData)resourceComponent2;
					}
				}
			}
			return null;
		}

		protected ResourceComponent RetrieveResource(object[] keys)
		{
			if (_resourceSection == null)
			{
				return null;
			}
			ResourceDirectory rootResourceDirectory = _resourceSection.RootResourceDirectory;
			if (rootResourceDirectory == null)
			{
				return null;
			}
			return RetrieveResource(rootResourceDirectory, keys, 0u);
		}

		protected ResourceComponent RetrieveResource(ResourceDirectory resourcesDirectory, object[] keys, uint keyIndex)
		{
			ResourceComponent resourceComponent = resourcesDirectory[keys[keyIndex]];
			if (keyIndex == keys.Length - 1)
			{
				return resourceComponent;
			}
			if (resourceComponent is ResourceDirectory)
			{
				return RetrieveResource((ResourceDirectory)resourceComponent, keys, keyIndex + 1);
			}
			return null;
		}

		protected void ConstructPEImage(FileStream file, bool partialConstruct)
		{
			_partialConstruct = partialConstruct;
			_dosHeader = new DosHeader(file);
			long num = _dosHeader.NtHeaderPosition - (_dosHeader.Address + _dosHeader.Size);
			if (num < 0)
			{
				throw new Win32Exception(11, Resources.GetString("Ex_InvalidPEFormat"));
			}
			_dosStub = new DosStub(file, _dosHeader.Address + _dosHeader.Size, num);
			_ntSignature = new NtSignature(file, _dosHeader.NtHeaderPosition);
			_fileHeader = new FileHeader(file, _ntSignature.Address + _ntSignature.Size);
			_optionalHeader = new OptionalHeader(file, _fileHeader.Address + _fileHeader.Size);
			long num2 = _optionalHeader.Address + _optionalHeader.Size;
			int num3 = 0;
			for (num3 = 0; num3 < _optionalHeader.NumberOfRvaAndSizes; num3++)
			{
				DataDirectory dataDirectory = new DataDirectory(file, num2);
				num2 += dataDirectory.Size;
				_dataDirectories.Add(dataDirectory);
			}
			if (_fileHeader.SizeOfOptionalHeader < _optionalHeader.Size + _optionalHeader.NumberOfRvaAndSizes * Marshal.SizeOf(typeof(IMAGE_DATA_DIRECTORY)))
			{
				throw new Win32Exception(11, Resources.GetString("Ex_InvalidPEFormat"));
			}
			bool flag = false;
			uint num4 = 0u;
			if (_optionalHeader.NumberOfRvaAndSizes > 2)
			{
				num4 = ((DataDirectory)_dataDirectories[2]).VirtualAddress;
				flag = true;
			}
			long num5 = _optionalHeader.Address + _fileHeader.SizeOfOptionalHeader;
			for (num3 = 0; num3 < _fileHeader.NumberOfSections; num3++)
			{
				SectionHeader sectionHeader = new SectionHeader(file, num5);
				Section section = null;
				section = (sectionHeader.Section = ((!flag || sectionHeader.VirtualAddress != num4) ? new Section(file, sectionHeader) : (_resourceSection = new ResourceSection(file, sectionHeader, partialConstruct))));
				_sectionHeaders.Add(sectionHeader);
				_sections.Add(section);
				num5 += sectionHeader.Size;
			}
			ConstructStream();
			ArrayList arrayList = new ArrayList();
			long num6 = 0L;
			foreach (PEComponent streamComponent in _streamComponents)
			{
				if (streamComponent.Address < num6)
				{
					throw new Win32Exception(11, Resources.GetString("Ex_InvalidPEFormat"));
				}
				if (streamComponent.Address > num6)
				{
					PEComponent value = new PEComponent(file, num6, streamComponent.Address - num6);
					arrayList.Add(value);
				}
				num6 = streamComponent.Address + streamComponent.Size;
			}
			if (num6 < file.Length)
			{
				PEComponent value2 = new PEComponent(file, num6, file.Length - num6);
				arrayList.Add(value2);
			}
			_streamComponents.AddRange(arrayList);
			_streamComponents.Sort(new PEComponentComparer());
			_canRead = true;
			_canSeek = true;
			_length = file.Length;
			_position = 0L;
		}

		protected void ConstructStream()
		{
			_streamComponents.Clear();
			_streamComponents.Add(_dosHeader);
			_streamComponents.Add(_dosStub);
			_streamComponents.Add(_ntSignature);
			_streamComponents.Add(_fileHeader);
			_streamComponents.Add(_optionalHeader);
			foreach (DataDirectory dataDirectory in _dataDirectories)
			{
				_streamComponents.Add(dataDirectory);
			}
			foreach (SectionHeader sectionHeader in _sectionHeaders)
			{
				_streamComponents.Add(sectionHeader);
			}
			foreach (Section section in _sections)
			{
				section.AddComponentsToStream(_streamComponents);
			}
			_streamComponents.Sort(new PEComponentComparer());
		}
	}
	internal static class PlatformDetector
	{
		private enum NetFX35SP1SKU
		{
			No35SP1,
			Client35SP1,
			Full35SP1
		}

		public class OSDependency
		{
			public uint dwMajorVersion;

			public uint dwMinorVersion;

			public uint dwBuildNumber;

			public ushort wServicePackMajor;

			public ushort wServicePackMinor;

			public string suiteName;

			public string productName;

			public OSDependency()
			{
			}

			public OSDependency(uint dwMajorVersion, uint dwMinorVersion, uint dwBuildNumber, ushort wServicePackMajor, ushort wServicePackMinor, string suiteName, string productName)
			{
				this.dwMajorVersion = dwMajorVersion;
				this.dwMinorVersion = dwMinorVersion;
				this.dwBuildNumber = dwBuildNumber;
				this.wServicePackMajor = wServicePackMajor;
				this.wServicePackMinor = wServicePackMinor;
				this.suiteName = suiteName;
				this.productName = productName;
			}

			public OSDependency(NativeMethods.OSVersionInfoEx osvi)
			{
				dwMajorVersion = osvi.dwMajorVersion;
				dwMinorVersion = osvi.dwMinorVersion;
				dwMajorVersion = osvi.dwBuildNumber;
				dwMajorVersion = osvi.wServicePackMajor;
				dwMajorVersion = osvi.wServicePackMinor;
				ushort wSuiteMask = osvi.wSuiteMask;
				NameMap[] suites = Suites;
				suiteName = NameMap.MapMaskToName(wSuiteMask, suites);
				byte bProductType = osvi.bProductType;
				suites = Products;
				productName = NameMap.MapMaskToName(bProductType, suites);
			}
		}

		public class NameMap
		{
			public string name;

			public uint mask;

			public NameMap(string Name, uint Mask)
			{
				name = Name;
				mask = Mask;
			}

			public static uint MapNameToMask(string name, NameMap[] nmArray)
			{
				foreach (NameMap nameMap in nmArray)
				{
					if (nameMap.name == name)
					{
						return nameMap.mask;
					}
				}
				return 0u;
			}

			public static string MapMaskToName(uint mask, NameMap[] nmArray)
			{
				foreach (NameMap nameMap in nmArray)
				{
					if (nameMap.mask == mask)
					{
						return nameMap.name;
					}
				}
				return null;
			}
		}

		public class Suite : NameMap
		{
			public Suite(string Name, uint Mask)
				: base(Name, Mask)
			{
			}
		}

		public class Product : NameMap
		{
			public Product(string Name, uint Mask)
				: base(Name, Mask)
			{
			}
		}

		private const int MAX_PATH = 260;

		private const byte VER_EQUAL = 1;

		private const byte VER_GREATER = 2;

		private const byte VER_GREATER_EQUAL = 3;

		private const byte VER_LESS = 4;

		private const byte VER_LESS_EQUAL = 5;

		private const byte VER_AND = 6;

		private const byte VER_OR = 7;

		private const uint VER_MINORVERSION = 1u;

		private const uint VER_MAJORVERSION = 2u;

		private const uint VER_BUILDNUMBER = 4u;

		private const uint VER_PLATFORMID = 8u;

		private const uint VER_SERVICEPACKMINOR = 16u;

		private const uint VER_SERVICEPACKMAJOR = 32u;

		private const uint VER_SUITENAME = 64u;

		private const uint VER_PRODUCT_TYPE = 128u;

		private const uint VER_SERVER_NT = 2147483648u;

		private const uint VER_WORKSTATION_NT = 1073741824u;

		private const uint VER_SUITE_SMALLBUSINESS = 1u;

		private const uint VER_SUITE_ENTERPRISE = 2u;

		private const uint VER_SUITE_BACKOFFICE = 4u;

		private const uint VER_SUITE_COMMUNICATIONS = 8u;

		private const uint VER_SUITE_TERMINAL = 16u;

		private const uint VER_SUITE_SMALLBUSINESS_RESTRICTED = 32u;

		private const uint VER_SUITE_EMBEDDEDNT = 64u;

		private const uint VER_SUITE_DATACENTER = 128u;

		private const uint VER_SUITE_SINGLEUSERTS = 256u;

		private const uint VER_SUITE_PERSONAL = 512u;

		private const uint VER_SUITE_BLADE = 1024u;

		private const uint VER_SUITE_EMBEDDED_RESTRICTED = 2048u;

		private const uint VER_NT_WORKSTATION = 1u;

		private const uint VER_NT_DOMAIN_CONTROLLER = 2u;

		private const uint VER_NT_SERVER = 3u;

		private const uint Windows9XMajorVersion = 4u;

		private const uint RUNTIME_INFO_UPGRADE_VERSION = 1u;

		private const uint RUNTIME_INFO_REQUEST_IA64 = 2u;

		private const uint RUNTIME_INFO_REQUEST_AMD64 = 4u;

		private const uint RUNTIME_INFO_REQUEST_X86 = 8u;

		private const uint RUNTIME_INFO_DONT_RETURN_DIRECTORY = 16u;

		private const uint RUNTIME_INFO_DONT_RETURN_VERSION = 32u;

		private const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 64u;

		private const uint RUNTIME_INFO_CONSIDER_POST_2_0 = 128u;

		private const uint RUNTIME_INFO_EMULATE_EXE_LAUNCH = 256u;

		private const uint RUNTIME_INFO_DONT_SHOW_INSTALL_DIALOG = 65536u;

		private static Suite[] Suites = new Suite[14]
		{
			new Suite("server", 2147483648u),
			new Suite("workstation", 1073741824u),
			new Suite("smallbusiness", 1u),
			new Suite("enterprise", 2u),
			new Suite("backoffice", 4u),
			new Suite("communications", 8u),
			new Suite("terminal", 16u),
			new Suite("smallbusinessRestricted", 32u),
			new Suite("embeddednt", 64u),
			new Suite("datacenter", 128u),
			new Suite("singleuserts", 256u),
			new Suite("personal", 512u),
			new Suite("blade", 1024u),
			new Suite("embeddedrestricted", 2048u)
		};

		private static Product[] Products = new Product[3]
		{
			new Product("workstation", 1u),
			new Product("domainController", 2u),
			new Product("server", 3u)
		};

		public static string FormatFrameworkString(CompatibleFramework framework)
		{
			if (string.IsNullOrEmpty(framework.Profile))
			{
				return string.Format(CultureInfo.CurrentUICulture, Resources.GetString("FrameworkNameNoProfile"), new object[1] { framework.TargetVersion });
			}
			return string.Format(CultureInfo.CurrentUICulture, Resources.GetString("FrameworkNameWithProfile"), new object[2] { framework.TargetVersion, framework.Profile });
		}

		public static bool DetectFrameworkInRegistry(string setupKeyPath, string setupValueName, Version versionRequired, bool detectInstallValue)
		{
			Logger.AddMethodCall("DetectFrameworkInRegistry(" + setupKeyPath + ", " + setupValueName + ", " + versionRequired.ToString() + ", " + detectInstallValue + ") called");
			using (RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(setupKeyPath))
			{
				if (registryKey != null)
				{
					object value = registryKey.GetValue(setupValueName);
					if (detectInstallValue)
					{
						if (value is int && (int)value != 0)
						{
							return true;
						}
					}
					else if (value is string)
					{
						Version version = new Version((string)value);
						if (version >= versionRequired)
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		public static bool DetectTFMInRegistry(string clrVersion, string frameworkVersion, string profile)
		{
			string text = "SOFTWARE\\Microsoft\\.NETFramework\\v" + clrVersion + "\\SKUs\\";
			text += Utilities.BuildTFM(frameworkVersion, profile);
			return Utilities.DoesRegistryKeyExist(Registry.LocalMachine, text);
		}

		public static bool CheckCompatibleFramework(CompatibleFramework framework, ref Version clrVersion, ref string clrVersionString, string clrProcArch)
		{
			Logger.AddMethodCall("CheckCompatibleFramework called targetVersion:" + framework.TargetVersion + " profile:" + framework.Profile);
			Version version = new Version(framework.TargetVersion);
			string text = null;
			string text2 = null;
			string text3 = null;
			bool detectInstallValue = false;
			bool flag = false;
			switch (version.Major)
			{
			case 2:
				text = "SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v" + framework.TargetVersion;
				text3 = "Install";
				detectInstallValue = true;
				break;
			case 3:
				if (version.Minor == 0)
				{
					text = "SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v3.0\\Setup";
					text3 = "InstallSuccess";
					detectInstallValue = true;
					break;
				}
				text = "SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v" + version.ToString(2);
				text3 = "Version";
				if ("Client".Equals(framework.Profile, StringComparison.OrdinalIgnoreCase))
				{
					text2 = "SOFTWARE\\Microsoft\\NET Framework Setup\\DotNetClient\\v" + version.ToString(2);
				}
				break;
			default:
				text = "SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v" + version.ToString(1);
				if (!string.IsNullOrEmpty(framework.Profile))
				{
					text = text + "\\" + framework.Profile;
				}
				text3 = "TargetVersion";
				break;
			}
			flag = DetectFrameworkInRegistry(text, text3, version, detectInstallValue) || (text2 != null && DetectFrameworkInRegistry(text2, text3, version, detectInstallValue));
			if (!flag && version.Major >= 4)
			{
				flag = DetectTFMInRegistry(framework.SupportedRuntime, framework.TargetVersion, framework.Profile);
			}
			if (flag)
			{
				Version v = new Version(framework.SupportedRuntime);
				if (!NativeMethods.VerifyCLRVersionInfo(v, clrProcArch))
				{
					Logger.AddWarningInformation(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("CLRMissingForFoundFramework"), new object[2]
					{
						framework.SupportedRuntime,
						FormatFrameworkString(framework)
					}));
					return false;
				}
				clrVersionString = framework.SupportedRuntime;
				clrVersion = new Version(clrVersionString);
				return true;
			}
			return false;
		}

		public static bool IsCLRDependencyText(string clrTextName)
		{
			if (string.Compare(clrTextName, "Microsoft-Windows-CLRCoreComp", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(clrTextName, "Microsoft.Windows.CommonLanguageRuntime", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return true;
			}
			return false;
		}

		public static bool IsSupportedProcessorArchitecture(string arch)
		{
			if (string.Compare(arch, "msil", StringComparison.OrdinalIgnoreCase) == 0 || string.Compare(arch, "x86", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return true;
			}
			NativeMethods.SYSTEM_INFO sysInfo = default(NativeMethods.SYSTEM_INFO);
			bool flag = false;
			try
			{
				if (NativeMethods.IsWow64Process2(new IntPtr(-1), out var _, out var nativeMachine))
				{
					switch (nativeMachine)
					{
					case 332:
						sysInfo.uProcessorInfo.wProcessorArchitecture = 0;
						flag = true;
						break;
					case 34404:
						sysInfo.uProcessorInfo.wProcessorArchitecture = 9;
						flag = true;
						break;
					case 43620:
						sysInfo.uProcessorInfo.wProcessorArchitecture = 12;
						flag = true;
						break;
					}
				}
			}
			catch (EntryPointNotFoundException)
			{
				Logger.AddInternalState("In IsSupportedProcessorArchitecture: GetNativeSystemInfo API from kernel32.dll is not found.");
				flag = false;
			}
			if (!flag)
			{
				try
				{
					NativeMethods.GetNativeSystemInfo(ref sysInfo);
					flag = true;
				}
				catch (EntryPointNotFoundException)
				{
					Logger.AddInternalState("In IsSupportedProcessorArchitecture: GetNativeSystemInfo API from kernel32.dll is not found.");
					flag = false;
				}
			}
			if (!flag)
			{
				NativeMethods.GetSystemInfo(ref sysInfo);
				Logger.AddInternalState("In IsSupportedProcessorArchitecture: GetSystemInfo called.");
			}
			switch (sysInfo.uProcessorInfo.wProcessorArchitecture)
			{
			case 6:
				return string.Compare(arch, "ia64", StringComparison.OrdinalIgnoreCase) == 0;
			case 9:
				return string.Compare(arch, "amd64", StringComparison.OrdinalIgnoreCase) == 0;
			case 12:
				if (string.Compare(arch, "arm64", StringComparison.OrdinalIgnoreCase) != 0)
				{
					return string.Compare(arch, "amd64", StringComparison.OrdinalIgnoreCase) == 0;
				}
				return true;
			default:
				return false;
			}
		}

		public static bool VerifyOSDependency(ref OSDependency osd)
		{
			OperatingSystem oSVersion = Environment.OSVersion;
			if ((long)oSVersion.Version.Major == 4)
			{
				if (oSVersion.Version.Major < osd.dwMajorVersion)
				{
					return false;
				}
				return true;
			}
			NativeMethods.OSVersionInfoEx oSVersionInfoEx = new NativeMethods.OSVersionInfoEx();
			oSVersionInfoEx.dwOSVersionInfoSize = (uint)Marshal.SizeOf((object)oSVersionInfoEx);
			oSVersionInfoEx.dwMajorVersion = osd.dwMajorVersion;
			oSVersionInfoEx.dwMinorVersion = osd.dwMinorVersion;
			oSVersionInfoEx.dwBuildNumber = osd.dwBuildNumber;
			oSVersionInfoEx.dwPlatformId = 0u;
			oSVersionInfoEx.szCSDVersion = null;
			oSVersionInfoEx.wServicePackMajor = osd.wServicePackMajor;
			oSVersionInfoEx.wServicePackMinor = osd.wServicePackMinor;
			int num;
			if (osd.suiteName == null)
			{
				num = 0;
			}
			else
			{
				string suiteName = osd.suiteName;
				NameMap[] suites = Suites;
				num = (int)NameMap.MapNameToMask(suiteName, suites);
			}
			oSVersionInfoEx.wSuiteMask = (ushort)num;
			int num2;
			if (osd.productName == null)
			{
				num2 = 0;
			}
			else
			{
				string productName = osd.productName;
				NameMap[] suites = Products;
				num2 = (int)NameMap.MapNameToMask(productName, suites);
			}
			oSVersionInfoEx.bProductType = (byte)num2;
			oSVersionInfoEx.bReserved = 0;
			ulong conditionMask = 0uL;
			uint dwTypeMask = 2u | ((osd.dwMinorVersion != 0) ? 1u : 0u) | ((osd.dwBuildNumber != 0) ? 4u : 0u) | ((osd.suiteName != null) ? 64u : 0u) | ((osd.productName != null) ? 128u : 0u) | ((osd.wServicePackMajor != 0) ? 32u : 0u) | ((osd.wServicePackMinor != 0) ? 16u : 0u);
			conditionMask = NativeMethods.VerSetConditionMask(conditionMask, 2u, 3);
			if (osd.dwMinorVersion != 0)
			{
				conditionMask = NativeMethods.VerSetConditionMask(conditionMask, 1u, 3);
			}
			if (osd.dwBuildNumber != 0)
			{
				conditionMask = NativeMethods.VerSetConditionMask(conditionMask, 4u, 3);
			}
			if (osd.suiteName != null)
			{
				conditionMask = NativeMethods.VerSetConditionMask(conditionMask, 64u, 6);
			}
			if (osd.productName != null)
			{
				conditionMask = NativeMethods.VerSetConditionMask(conditionMask, 128u, 1);
			}
			if (osd.wServicePackMajor != 0)
			{
				conditionMask = NativeMethods.VerSetConditionMask(conditionMask, 32u, 3);
			}
			if (osd.wServicePackMinor != 0)
			{
				conditionMask = NativeMethods.VerSetConditionMask(conditionMask, 16u, 3);
			}
			bool flag = NativeMethods.VerifyVersionInfo(oSVersionInfoEx, dwTypeMask, conditionMask);
			if (!flag)
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error != 1150)
				{
					throw new Win32Exception(lastWin32Error);
				}
			}
			return flag;
		}

		public static bool VerifyGACDependency(NativeMethods.IAssemblyCache AssemblyCache, bool targetOtherClr, NativeMethods.CCorRuntimeHost RuntimeHost, ReferenceIdentity refId, string tempDir)
		{
			if (string.Compare(refId.ProcessorArchitecture, "msil", StringComparison.OrdinalIgnoreCase) == 0)
			{
				return VerifyGACDependencyWhidbey(AssemblyCache, targetOtherClr, RuntimeHost, refId);
			}
			if (!VerifyGACDependencyXP(refId, tempDir))
			{
				return VerifyGACDependencyWhidbey(AssemblyCache, targetOtherClr, RuntimeHost, refId);
			}
			return true;
		}

		public static bool VerifyGACDependencyWhidbey(NativeMethods.IAssemblyCache AssemblyCache, bool targetOtherClr, NativeMethods.CCorRuntimeHost RuntimeHost, ReferenceIdentity refId)
		{
			string text = refId.ToString();
			string text2 = null;
			if (targetOtherClr)
			{
				try
				{
					text2 = RuntimeHost.ApplyPolicyInOtherRuntime(text);
				}
				catch (ArgumentException)
				{
					return false;
				}
				catch (COMException)
				{
					return false;
				}
			}
			else
			{
				try
				{
					text2 = AppDomain.CurrentDomain.ApplyPolicy(text);
				}
				catch (ArgumentException)
				{
					return false;
				}
				catch (COMException)
				{
					return false;
				}
			}
			ReferenceIdentity referenceIdentity = new ReferenceIdentity(text2);
			referenceIdentity.ProcessorArchitecture = refId.ProcessorArchitecture;
			string text3 = referenceIdentity.ToString();
			Logger.AddPhaseInformation(Resources.GetString("DetectingDependentAssembly"), text, text3);
			SystemUtils.AssemblyInfo assemblyInfo = null;
			assemblyInfo = SystemUtils.QueryAssemblyInfo(AssemblyCache, SystemUtils.QueryAssemblyInfoFlags.All, text3);
			if (assemblyInfo == null && referenceIdentity.ProcessorArchitecture == null)
			{
				NativeMethods.CreateAssemblyNameObject(out var ppEnum, referenceIdentity.ToString(), 1u, IntPtr.Zero);
				NativeMethods.CreateAssemblyEnum(out var ppEnum2, null, ppEnum, 2u, IntPtr.Zero);
				if (ppEnum2.GetNextAssembly(null, out ppEnum, 0u) == 0)
				{
					return true;
				}
				return false;
			}
			return assemblyInfo != null;
		}

		public static bool VerifyGACDependencyXP(ReferenceIdentity refId, string tempDir)
		{
			if (!PlatformSpecific.OnXPOrAbove)
			{
				return false;
			}
			using TempFile tempFile = new TempFile(tempDir, ".manifest");
			ManifestGenerator.GenerateGACDetectionManifest(refId, tempFile.Path);
			NativeMethods.ACTCTXW actCtx = new NativeMethods.ACTCTXW(tempFile.Path);
			IntPtr intPtr = NativeMethods.CreateActCtxW(actCtx);
			if (intPtr != NativeMethods.INVALID_HANDLE_VALUE)
			{
				NativeMethods.ReleaseActCtx(intPtr);
				return true;
			}
			return false;
		}

		public static bool IsWin8orLater()
		{
			OSDependency osd = new OSDependency(6u, 2u, 0u, 0, 0, null, null);
			return VerifyOSDependency(ref osd);
		}

		public static void VerifyPlatformDependencies(AssemblyManifest appManifest, AssemblyManifest deployManifest, string tempDir)
		{
			Logger.AddMethodCall("VerifyPlatformDependencies called.");
			string text = null;
			Uri uri = deployManifest.Description.SupportUri;
			bool flag = false;
			DependentOS dependentOS = appManifest.DependentOS;
			if (dependentOS != null)
			{
				OSDependency osd = new OSDependency(dependentOS.MajorVersion, dependentOS.MinorVersion, dependentOS.BuildNumber, dependentOS.ServicePackMajor, dependentOS.ServicePackMinor, null, null);
				if (!VerifyOSDependency(ref osd))
				{
					StringBuilder stringBuilder = new StringBuilder();
					string arg = dependentOS.MajorVersion + "." + dependentOS.MinorVersion + "." + dependentOS.BuildNumber + "." + dependentOS.ServicePackMajor + dependentOS.ServicePackMinor;
					stringBuilder.AppendFormat(Resources.GetString("PlatformMicrosoftWindowsOperatingSystem"), arg);
					text = stringBuilder.ToString();
					if (dependentOS.SupportUrl != null)
					{
						uri = dependentOS.SupportUrl;
					}
					throw new DependentPlatformMissingException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("ErrorMessage_PlatformDetectionFailed"), new object[1] { text }), uri);
				}
			}
			if (IsWin8orLater() && !appManifest.EntryPoints[0].HostInBrowser)
			{
				flag = true;
			}
			Version clrVersion = Constants.V2CLRVersion;
			string clrVersionString = clrVersion.ToString(3);
			string processorArchitecture = appManifest.Identity.ProcessorArchitecture;
			Uri uri2 = uri;
			if (appManifest.CLRDependentAssembly != null)
			{
				clrVersion = appManifest.CLRDependentAssembly.Identity.Version;
				clrVersionString = clrVersion.ToString(3);
				processorArchitecture = appManifest.CLRDependentAssembly.Identity.ProcessorArchitecture;
				if (appManifest.CLRDependentAssembly.SupportUrl != null)
				{
					uri2 = appManifest.CLRDependentAssembly.SupportUrl;
				}
				if (appManifest.CLRDependentAssembly.Description != null)
				{
					text = appManifest.CLRDependentAssembly.Description;
				}
			}
			if (deployManifest.CompatibleFrameworks != null)
			{
				bool flag2 = false;
				for (int i = 0; i < deployManifest.CompatibleFrameworks.Frameworks.Count; i++)
				{
					if (CheckCompatibleFramework(deployManifest.CompatibleFrameworks.Frameworks[i], ref clrVersion, ref clrVersionString, processorArchitecture))
					{
						flag2 = true;
						break;
					}
				}
				if (!flag2)
				{
					uri = ((!(deployManifest.CompatibleFrameworks.SupportUrl != null)) ? uri2 : deployManifest.CompatibleFrameworks.SupportUrl);
					if (flag)
					{
						return;
					}
					throw new CompatibleFrameworkMissingException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("ErrorMessage_CompatiblePlatformDetectionFailed"), new object[1] { FormatFrameworkString(deployManifest.CompatibleFrameworks.Frameworks[0]) }), uri, deployManifest.CompatibleFrameworks);
				}
			}
			else
			{
				if (clrVersion >= Constants.V4CLRVersion)
				{
					throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_SemanticallyInvalidDeploymentManifest"), new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepMissingCompatibleFrameworks")));
				}
				if (!NativeMethods.VerifyCLRVersionInfo(clrVersion, processorArchitecture))
				{
					StringBuilder stringBuilder2 = new StringBuilder();
					if (text == null)
					{
						stringBuilder2.AppendFormat(Resources.GetString("PlatformMicrosoftCommonLanguageRuntime"), clrVersionString);
						text = stringBuilder2.ToString();
					}
					uri = uri2;
					if (flag)
					{
						return;
					}
					throw new SupportedRuntimeMissingException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("ErrorMessage_PlatformDetectionFailed"), new object[1] { text }), uri, clrVersionString);
				}
			}
			Logger.AddPhaseInformation(Resources.GetString("CompatibleRuntimeFound"), clrVersionString);
			bool flag3 = false;
			if (clrVersion < Constants.V4CLRVersion)
			{
				flag3 = true;
			}
			NativeMethods.CCorRuntimeHost RuntimeHost = null;
			try
			{
				NativeMethods.IAssemblyCache assemblyCacheInterface = NativeMethods.GetAssemblyCacheInterface(clrVersionString, flag3, out RuntimeHost);
				if (assemblyCacheInterface == null || (flag3 && RuntimeHost == null))
				{
					StringBuilder stringBuilder3 = new StringBuilder();
					stringBuilder3.AppendFormat(Resources.GetString("PlatformMicrosoftCommonLanguageRuntime"), clrVersionString);
					text = stringBuilder3.ToString();
					uri = uri2;
					throw new DependentPlatformMissingException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("ErrorMessage_PlatformDetectionFailed"), new object[1] { text }), uri);
				}
				bool flag4 = false;
				bool flag5 = false;
				if (flag3 && !PolicyKeys.SkipSKUDetection())
				{
					DependentAssembly[] dependentAssemblies = appManifest.DependentAssemblies;
					foreach (DependentAssembly dependentAssembly in dependentAssemblies)
					{
						if (dependentAssembly.IsPreRequisite && IsNetFX35SP1ClientSignatureAsm(dependentAssembly.Identity))
						{
							flag4 = true;
						}
						if (dependentAssembly.IsPreRequisite && IsNetFX35SP1FullSignatureAsm(dependentAssembly.Identity))
						{
							flag5 = true;
						}
					}
					NetFX35SP1SKU netFX35SP1SKU = NetFX35SP1SKU.No35SP1;
					netFX35SP1SKU = GetPlatformNetFx35SKU(assemblyCacheInterface, flag3, RuntimeHost, tempDir);
					if (netFX35SP1SKU == NetFX35SP1SKU.Client35SP1 && !flag4 && !flag5)
					{
						text = ".NET Framework 3.5 SP1";
						throw new DependentPlatformMissingException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("ErrorMessage_PlatformDetectionFailed"), new object[1] { text }));
					}
				}
				DependentAssembly[] dependentAssemblies2 = appManifest.DependentAssemblies;
				foreach (DependentAssembly dependentAssembly2 in dependentAssemblies2)
				{
					if (!dependentAssembly2.IsPreRequisite || IsCLRDependencyText(dependentAssembly2.Identity.Name))
					{
						continue;
					}
					if (!flag3 && (IsNetFX35SP1ClientSignatureAsm(dependentAssembly2.Identity) || IsNetFX35SP1FullSignatureAsm(dependentAssembly2.Identity) || "framework".Equals(dependentAssembly2.Group, StringComparison.OrdinalIgnoreCase)))
					{
						Logger.AddPhaseInformation(Resources.GetString("SkippingSentinalDependentAssembly"), dependentAssembly2.Identity.ToString());
					}
					else if (!VerifyGACDependency(assemblyCacheInterface, flag3, RuntimeHost, dependentAssembly2.Identity, tempDir))
					{
						if (dependentAssembly2.Description != null)
						{
							text = dependentAssembly2.Description;
						}
						else
						{
							ReferenceIdentity identity = dependentAssembly2.Identity;
							StringBuilder stringBuilder4 = new StringBuilder();
							stringBuilder4.AppendFormat(Resources.GetString("PlatformDependentAssemblyVersion"), identity.Name, identity.Version);
							text = stringBuilder4.ToString();
						}
						if (dependentAssembly2.SupportUrl != null)
						{
							uri = dependentAssembly2.SupportUrl;
						}
						throw new DependentPlatformMissingException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("ErrorMessage_PlatformGACDetectionFailed"), new object[1] { text }), uri);
					}
				}
			}
			finally
			{
				RuntimeHost?.Dispose();
			}
		}

		private static bool IsNetFX35SP1ClientSignatureAsm(ReferenceIdentity ra)
		{
			DefinitionIdentity definitionIdentity = new DefinitionIdentity("Sentinel.v3.5Client, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a,processorArchitecture=msil");
			if (definitionIdentity.Matches(ra, exact: true))
			{
				return true;
			}
			return false;
		}

		private static bool IsNetFX35SP1FullSignatureAsm(ReferenceIdentity ra)
		{
			DefinitionIdentity definitionIdentity = new DefinitionIdentity("System.Data.Entity, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089,processorArchitecture=msil");
			if (definitionIdentity.Matches(ra, exact: true))
			{
				return true;
			}
			return false;
		}

		private static NetFX35SP1SKU GetPlatformNetFx35SKU(NativeMethods.IAssemblyCache AssemblyCache, bool targetOtherCLR, NativeMethods.CCorRuntimeHost RuntimeHost, string tempDir)
		{
			ReferenceIdentity refId = new ReferenceIdentity("Sentinel.v3.5Client, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a,processorArchitecture=msil");
			ReferenceIdentity refId2 = new ReferenceIdentity("System.Data.Entity, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089,processorArchitecture=msil");
			bool flag = false;
			bool flag2 = false;
			if (VerifyGACDependency(AssemblyCache, targetOtherCLR, RuntimeHost, refId, tempDir))
			{
				flag = true;
			}
			if (VerifyGACDependency(AssemblyCache, targetOtherCLR, RuntimeHost, refId2, tempDir))
			{
				flag2 = true;
			}
			if (flag && !flag2)
			{
				return NetFX35SP1SKU.Client35SP1;
			}
			if (flag && flag2)
			{
				return NetFX35SP1SKU.Full35SP1;
			}
			return NetFX35SP1SKU.No35SP1;
		}
	}
	internal class PlatformPiece : ModalPiece
	{
		private Label lblMessage;

		private PictureBox pictureIcon;

		private LinkLabel linkSupport;

		private Button btnOk;

		private TableLayoutPanel overarchingTableLayoutPanel;

		private string _errorMessage;

		private Uri _supportUrl;

		public PlatformPiece(UserInterfaceForm parentForm, string platformDetectionErrorMsg, Uri supportUrl, ManualResetEvent modalEvent)
		{
			_errorMessage = platformDetectionErrorMsg;
			_supportUrl = supportUrl;
			_modalResult = UserInterfaceModalResult.Ok;
			_modalEvent = modalEvent;
			SuspendLayout();
			InitializeComponent();
			InitializeContent();
			ResumeLayout(performLayout: false);
			parentForm.SuspendLayout();
			parentForm.SwitchUserInterfacePiece(this);
			parentForm.Text = Resources.GetString("UI_PlatformDetectionFailedTitle");
			parentForm.MinimizeBox = false;
			parentForm.MaximizeBox = false;
			parentForm.ControlBox = true;
			parentForm.ActiveControl = btnOk;
			parentForm.ResumeLayout(performLayout: false);
			parentForm.PerformLayout();
			parentForm.Visible = true;
		}

		private void InitializeComponent()
		{
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(System.Deployment.Application.PlatformPiece));
			this.lblMessage = new System.Windows.Forms.Label();
			this.pictureIcon = new System.Windows.Forms.PictureBox();
			this.btnOk = new System.Windows.Forms.Button();
			this.linkSupport = new System.Windows.Forms.LinkLabel();
			this.overarchingTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			((System.ComponentModel.ISupportInitialize)this.pictureIcon).BeginInit();
			this.overarchingTableLayoutPanel.SuspendLayout();
			base.SuspendLayout();
			resources.ApplyResources(this.lblMessage, "lblMessage");
			this.lblMessage.Name = "lblMessage";
			resources.ApplyResources(this.pictureIcon, "pictureIcon");
			this.pictureIcon.Name = "pictureIcon";
			this.pictureIcon.TabStop = false;
			this.pictureIcon.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits32 + System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits32 + System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3);
			this.pictureIcon.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			this.pictureIcon.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			resources.ApplyResources(this.btnOk, "btnOk");
			this.overarchingTableLayoutPanel.SetColumnSpan(this.btnOk, 2);
			this.btnOk.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeWidth, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeHeight);
			this.btnOk.Name = "btnOk";
			this.btnOk.Click += new System.EventHandler(btnOk_Click);
			resources.ApplyResources(this.linkSupport, "linkSupport");
			this.linkSupport.Name = "linkSupport";
			this.linkSupport.TabStop = true;
			this.linkSupport.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(linkSupport_LinkClicked);
			resources.ApplyResources(this.overarchingTableLayoutPanel, "overarchingTableLayoutPanel");
			this.overarchingTableLayoutPanel.Controls.Add(this.pictureIcon, 0, 0);
			this.overarchingTableLayoutPanel.Controls.Add(this.btnOk, 0, 2);
			this.overarchingTableLayoutPanel.Controls.Add(this.linkSupport, 1, 1);
			this.overarchingTableLayoutPanel.Controls.Add(this.lblMessage, 1, 0);
			this.overarchingTableLayoutPanel.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits349, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits88);
			this.overarchingTableLayoutPanel.Name = "overarchingTableLayoutPanel";
			resources.ApplyResources(this, "$this");
			base.Controls.Add(this.overarchingTableLayoutPanel);
			this.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits373, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits112);
			base.Name = "PlatformPiece";
			((System.ComponentModel.ISupportInitialize)this.pictureIcon).EndInit();
			this.overarchingTableLayoutPanel.ResumeLayout(false);
			this.overarchingTableLayoutPanel.PerformLayout();
			base.ResumeLayout(false);
			base.PerformLayout();
		}

		private void InitializeContent()
		{
			SuspendLayout();
			pictureIcon.Image = Resources.GetIcon("information.ico").ToBitmap();
			linkSupport.Links.Clear();
			if (_supportUrl == null)
			{
				linkSupport.Text = Resources.GetString("UI_PlatformContactAdmin");
			}
			else
			{
				string @string = Resources.GetString("UI_PlatformClickHere");
				string string2 = Resources.GetString("UI_PlatformClickHereHere");
				int start = @string.LastIndexOf(string2, StringComparison.Ordinal);
				linkSupport.Text = @string;
				linkSupport.Links.Add(start, string2.Length, _supportUrl.AbsoluteUri);
			}
			lblMessage.Text = _errorMessage;
			ResumeLayout(performLayout: false);
		}

		private void btnOk_Click(object sender, EventArgs e)
		{
			_modalResult = UserInterfaceModalResult.Ok;
			_modalEvent.Set();
			base.Enabled = false;
		}

		private void linkSupport_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			linkSupport.Links[linkSupport.Links.IndexOf(e.Link)].Visited = true;
			if (_supportUrl != null && UserInterface.IsValidHttpUrl(_supportUrl.AbsoluteUri))
			{
				UserInterface.LaunchUrlInBrowser(e.Link.LinkData.ToString());
			}
		}
	}
	internal static class PlatformSpecific
	{
		public static bool OnWin9x
		{
			get
			{
				OperatingSystem oSVersion = Environment.OSVersion;
				return oSVersion.Platform == PlatformID.Win32Windows;
			}
		}

		public static bool OnWinMe
		{
			get
			{
				OperatingSystem oSVersion = Environment.OSVersion;
				if (oSVersion.Platform == PlatformID.Win32Windows && oSVersion.Version.Major == 4 && oSVersion.Version.Minor == 90)
				{
					return true;
				}
				return false;
			}
		}

		public static bool OnXPOrAbove
		{
			get
			{
				OperatingSystem oSVersion = Environment.OSVersion;
				if (oSVersion.Platform == PlatformID.Win32NT)
				{
					if (oSVersion.Version.Major != 5 || oSVersion.Version.Minor < 1)
					{
						return oSVersion.Version.Major >= 6;
					}
					return true;
				}
				return false;
			}
		}

		public static bool OnWindows2003
		{
			get
			{
				OperatingSystem oSVersion = Environment.OSVersion;
				if (oSVersion.Platform == PlatformID.Win32NT)
				{
					if (oSVersion.Version.Major == 5)
					{
						return oSVersion.Version.Minor == 2;
					}
					return false;
				}
				return false;
			}
		}

		public static bool OnVistaOrAbove
		{
			get
			{
				OperatingSystem oSVersion = Environment.OSVersion;
				if (oSVersion.Platform == PlatformID.Win32NT)
				{
					return oSVersion.Version.Major >= 6;
				}
				return false;
			}
		}
	}
	internal class ProgressPiece : FormPiece, IDownloadNotification
	{
		private Label lblHeader;

		private Label lblSubHeader;

		private PictureBox pictureDesktop;

		private PictureBox pictureAppIcon;

		private Label lblApplication;

		private LinkLabel linkAppId;

		private Label lblFrom;

		private Label lblFromId;

		private ProgressBar progress;

		private Label lblProgressText;

		private GroupBox groupRule;

		private GroupBox groupDivider;

		private Button btnCancel;

		private TableLayoutPanel topTextTableLayoutPanel;

		private TableLayoutPanel overarchingTableLayoutPanel;

		private TableLayoutPanel contentTableLayoutPanel;

		private UserInterfaceInfo _info;

		private bool _userCancelling;

		private DownloadEventArgs _downloadData;

		private Bitmap _appIconBitmap;

		private bool _appIconShown;

		private UserInterfaceForm _parentForm;

		private MethodInvoker disableMethodInvoker;

		private MethodInvoker updateUIMethodInvoker;

		private static long[] _bytesFormatRanges = new long[9] { 1024L, 10240L, 102400L, 1048576L, 10485760L, 104857600L, 1073741824L, 10737418240L, 107374182400L };

		private static string[] _bytesFormatStrings = new string[10] { "UI_ProgressBytesInBytes", "UI_ProgressBytesIn1KB", "UI_ProgressBytesIn10KB", "UI_ProgressBytesIn100KB", "UI_ProgressBytesIn1MB", "UI_ProgressBytesIn10MB", "UI_ProgressBytesIn100MB", "UI_ProgressBytesIn1GB", "UI_ProgressBytesIn10GB", "UI_ProgressBytesIn100GB" };

		public ProgressPiece(UserInterfaceForm parentForm, UserInterfaceInfo info)
		{
			_info = info;
			SuspendLayout();
			InitializeComponent();
			InitializeContent();
			ResumeLayout(performLayout: false);
			parentForm.SuspendLayout();
			parentForm.SwitchUserInterfacePiece(this);
			parentForm.Text = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("UI_ProgressTitle"), new object[2] { 0, _info.formTitle });
			parentForm.MinimizeBox = true;
			parentForm.MaximizeBox = false;
			parentForm.ControlBox = true;
			lblHeader.Font = new Font(lblHeader.Font, lblHeader.Font.Style | FontStyle.Bold);
			linkAppId.Font = new Font(linkAppId.Font, linkAppId.Font.Style | FontStyle.Bold);
			lblFromId.Font = new Font(lblFromId.Font, lblFromId.Font.Style | FontStyle.Bold);
			parentForm.ActiveControl = btnCancel;
			parentForm.Visible = true;
			parentForm.ResumeLayout(performLayout: false);
			parentForm.PerformLayout();
			updateUIMethodInvoker = UpdateUI;
			disableMethodInvoker = Disable;
			_parentForm = parentForm;
			progress.Minimum = 0;
			progress.Maximum = 100;
			groupRule.AccessibleName = (groupDivider.AccessibleName = string.Empty);
			groupRule.AccessibleRole = (groupDivider.AccessibleRole = AccessibleRole.Separator);
		}

		public void DownloadModified(object sender, DownloadEventArgs e)
		{
			if (_userCancelling)
			{
				FileDownloader fileDownloader = (FileDownloader)sender;
				fileDownloader.Cancel();
				return;
			}
			_downloadData = e;
			if (_info.iconFilePath != null && _appIconBitmap == null && e.Cookie != null && System.IO.File.Exists(_info.iconFilePath))
			{
				using Icon icon = Icon.ExtractAssociatedIcon(_info.iconFilePath);
				if ((double)base.DeviceDpi != 96.0)
				{
					int value = 32;
					Icon icon2 = new Icon(icon, LogicalToDeviceUnits(value), LogicalToDeviceUnits(value));
					Bitmap bitmap = icon2.ToBitmap();
					bitmap.MakeTransparent();
					_appIconBitmap = bitmap;
				}
				else
				{
					_appIconBitmap = TryGet32x32Bitmap(icon);
				}
			}
			BeginInvoke(updateUIMethodInvoker);
		}

		public void DownloadCompleted(object sender, DownloadEventArgs e)
		{
			BeginInvoke(disableMethodInvoker);
		}

		public override bool OnClosing()
		{
			bool result = base.OnClosing();
			if (!base.Enabled)
			{
				return false;
			}
			_userCancelling = true;
			return result;
		}

		private void InitializeComponent()
		{
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(System.Deployment.Application.ProgressPiece));
			this.topTextTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.pictureDesktop = new System.Windows.Forms.PictureBox();
			this.lblSubHeader = new System.Windows.Forms.Label();
			this.lblHeader = new System.Windows.Forms.Label();
			this.pictureAppIcon = new System.Windows.Forms.PictureBox();
			this.lblApplication = new System.Windows.Forms.Label();
			this.linkAppId = new System.Windows.Forms.LinkLabel();
			this.lblFrom = new System.Windows.Forms.Label();
			this.lblFromId = new System.Windows.Forms.Label();
			this.progress = new System.Windows.Forms.ProgressBar();
			this.lblProgressText = new System.Windows.Forms.Label();
			this.groupRule = new System.Windows.Forms.GroupBox();
			this.groupDivider = new System.Windows.Forms.GroupBox();
			this.btnCancel = new System.Windows.Forms.Button();
			this.overarchingTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.contentTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.topTextTableLayoutPanel.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)this.pictureDesktop).BeginInit();
			((System.ComponentModel.ISupportInitialize)this.pictureAppIcon).BeginInit();
			this.overarchingTableLayoutPanel.SuspendLayout();
			this.contentTableLayoutPanel.SuspendLayout();
			base.SuspendLayout();
			resources.ApplyResources(this.topTextTableLayoutPanel, "topTextTableLayoutPanel");
			this.topTextTableLayoutPanel.BackColor = System.Drawing.SystemColors.Window;
			this.topTextTableLayoutPanel.Controls.Add(this.lblHeader, 0, 0);
			this.topTextTableLayoutPanel.Controls.Add(this.lblSubHeader, 0, 1);
			this.topTextTableLayoutPanel.Controls.Add(this.pictureDesktop, 1, 0);
			this.topTextTableLayoutPanel.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits498, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits61);
			this.topTextTableLayoutPanel.Name = "topTextTableLayoutPanel";
			resources.ApplyResources(this.pictureDesktop, "pictureDesktop");
			this.pictureDesktop.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits61, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits61);
			this.pictureDesktop.Name = "pictureDesktop";
			this.topTextTableLayoutPanel.SetRowSpan(this.pictureDesktop, 2);
			this.pictureDesktop.TabStop = false;
			this.pictureDesktop.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			resources.ApplyResources(this.lblSubHeader, "lblSubHeader");
			this.lblSubHeader.Name = "lblSubHeader";
			resources.ApplyResources(this.lblHeader, "lblHeader");
			this.lblHeader.AutoEllipsis = true;
			this.lblHeader.Name = "lblHeader";
			this.lblHeader.UseMnemonic = false;
			resources.ApplyResources(this.pictureAppIcon, "pictureAppIcon");
			this.pictureAppIcon.Name = "pictureAppIcon";
			this.pictureAppIcon.TabStop = false;
			this.pictureAppIcon.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			resources.ApplyResources(this.lblApplication, "lblApplication");
			this.lblApplication.Name = "lblApplication";
			resources.ApplyResources(this.linkAppId, "linkAppId");
			this.linkAppId.AutoEllipsis = true;
			this.linkAppId.Name = "linkAppId";
			this.linkAppId.UseMnemonic = false;
			this.linkAppId.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(linkAppId_LinkClicked);
			resources.ApplyResources(this.lblFrom, "lblFrom");
			this.lblFrom.Name = "lblFrom";
			resources.ApplyResources(this.lblFromId, "lblFromId");
			this.lblFromId.AutoEllipsis = true;
			this.lblFromId.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits384, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits32);
			this.lblFromId.Name = "lblFromId";
			this.lblFromId.UseMnemonic = false;
			resources.ApplyResources(this.progress, "progress");
			this.contentTableLayoutPanel.SetColumnSpan(this.progress, 2);
			this.progress.Name = "progress";
			this.progress.TabStop = false;
			this.progress.Height = base.LogicalToDeviceUnits(this.progress.Height);
			resources.ApplyResources(this.lblProgressText, "lblProgressText");
			this.contentTableLayoutPanel.SetColumnSpan(this.lblProgressText, 2);
			this.lblProgressText.Name = "lblProgressText";
			resources.ApplyResources(this.groupRule, "groupRule");
			this.groupRule.BackColor = System.Drawing.SystemColors.ControlDark;
			this.groupRule.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
			this.groupRule.Name = "groupRule";
			this.groupRule.TabStop = false;
			resources.ApplyResources(this.groupDivider, "groupDivider");
			this.groupDivider.BackColor = System.Drawing.SystemColors.ControlDark;
			this.groupDivider.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
			this.groupDivider.Name = "groupDivider";
			this.groupDivider.TabStop = false;
			resources.ApplyResources(this.btnCancel, "btnCancel");
			this.btnCancel.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeWidth, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeHeight);
			this.btnCancel.Name = "btnCancel";
			this.btnCancel.Click += new System.EventHandler(btnCancel_Click);
			resources.ApplyResources(this.overarchingTableLayoutPanel, "overarchingTableLayoutPanel");
			this.overarchingTableLayoutPanel.Controls.Add(this.topTextTableLayoutPanel, 0, 0);
			this.overarchingTableLayoutPanel.Controls.Add(this.groupRule, 0, 1);
			this.overarchingTableLayoutPanel.Controls.Add(this.contentTableLayoutPanel, 0, 2);
			this.overarchingTableLayoutPanel.Controls.Add(this.groupDivider, 0, 3);
			this.overarchingTableLayoutPanel.Controls.Add(this.btnCancel, 0, 4);
			this.overarchingTableLayoutPanel.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits515, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits240);
			this.overarchingTableLayoutPanel.Name = "overarchingTableLayoutPanel";
			resources.ApplyResources(this.contentTableLayoutPanel, "contentTableLayoutPanel");
			this.contentTableLayoutPanel.Controls.Add(this.pictureAppIcon, 0, 0);
			this.contentTableLayoutPanel.Controls.Add(this.lblApplication, 1, 0);
			this.contentTableLayoutPanel.Controls.Add(this.linkAppId, 2, 0);
			this.contentTableLayoutPanel.Controls.Add(this.lblFrom, 1, 1);
			this.contentTableLayoutPanel.Controls.Add(this.lblFromId, 2, 1);
			this.contentTableLayoutPanel.Controls.Add(this.progress, 1, 2);
			this.contentTableLayoutPanel.Controls.Add(this.lblProgressText, 1, 3);
			this.contentTableLayoutPanel.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits466, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits123);
			this.contentTableLayoutPanel.Name = "contentTableLayoutPanel";
			resources.ApplyResources(this, "$this");
			base.Controls.Add(this.overarchingTableLayoutPanel);
			this.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits498, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumSizeUnits240);
			base.Name = "ProgressPiece";
			if (System.Deployment.Application.Resources.GetString("RTL") != "RTL_False")
			{
				this.progress.RightToLeft = System.Windows.Forms.RightToLeft.Yes;
				this.progress.RightToLeftLayout = true;
			}
			if (System.AccessibilityImprovements.Level3)
			{
				this.pictureAppIcon.AccessibleName = System.Deployment.Application.Resources.GetString("ClickOnceAppIcon");
				this.pictureAppIcon.AccessibleRole = System.Windows.Forms.AccessibleRole.Graphic;
				this.pictureDesktop.AccessibleName = System.Deployment.Application.Resources.GetString("ClickOnceGlobeIcon");
				this.pictureDesktop.AccessibleRole = System.Windows.Forms.AccessibleRole.Graphic;
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.topTextTableLayoutPanel, 0);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.groupRule, 1);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.contentTableLayoutPanel, 2);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.groupDivider, 3);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.btnCancel, 4);
			}
			this.topTextTableLayoutPanel.ResumeLayout(false);
			this.topTextTableLayoutPanel.PerformLayout();
			((System.ComponentModel.ISupportInitialize)this.pictureDesktop).EndInit();
			((System.ComponentModel.ISupportInitialize)this.pictureAppIcon).EndInit();
			this.overarchingTableLayoutPanel.ResumeLayout(false);
			this.overarchingTableLayoutPanel.PerformLayout();
			this.contentTableLayoutPanel.ResumeLayout(false);
			this.contentTableLayoutPanel.PerformLayout();
			base.ResumeLayout(false);
			base.PerformLayout();
		}

		private void InitializeContent()
		{
			pictureDesktop.Image = Resources.GetIcon("form.ico").ToBitmap();
			lblHeader.Text = _info.formTitle;
			pictureAppIcon.Image = Resources.GetIcon("defaultappicon.ico").ToBitmap();
			linkAppId.Text = _info.productName;
			linkAppId.Links.Clear();
			if (UserInterface.IsValidHttpUrl(_info.supportUrl))
			{
				linkAppId.Links.Add(0, _info.productName.Length, _info.supportUrl);
			}
			lblFromId.Text = _info.sourceSite;
		}

		private void linkAppId_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			linkAppId.LinkVisited = true;
			UserInterface.LaunchUrlInBrowser(e.Link.LinkData.ToString());
		}

		private void btnCancel_Click(object sender, EventArgs e)
		{
			_userCancelling = true;
			Disable();
			_parentForm.Visible = false;
		}

		private void Disable()
		{
			SuspendLayout();
			lblProgressText.Text = Resources.GetString("UI_ProgressDone");
			base.Enabled = false;
			ResumeLayout(performLayout: false);
		}

		private Bitmap TryGet32x32Bitmap(Icon icon)
		{
			using Icon icon2 = new Icon(icon, 32, 32);
			Bitmap bitmap = icon2.ToBitmap();
			bitmap.MakeTransparent();
			return bitmap;
		}

		private void UpdateUI()
		{
			if (!base.IsDisposed)
			{
				SuspendLayout();
				lblProgressText.Text = FormatProgressText(_downloadData.BytesCompleted, _downloadData.BytesTotal);
				progress.Value = _downloadData.Progress;
				Form form = FindForm();
				form.Text = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("UI_ProgressTitle"), new object[2] { _downloadData.Progress, _info.formTitle });
				if (!_appIconShown && _appIconBitmap != null)
				{
					pictureAppIcon.Image = _appIconBitmap;
					_appIconShown = true;
				}
				ResumeLayout(performLayout: false);
			}
		}

		private static string FormatProgressText(long completed, long total)
		{
			return string.Format(CultureInfo.CurrentUICulture, Resources.GetString("UI_ProgressText"), new object[2]
			{
				FormatBytes(completed),
				FormatBytes(total)
			});
		}

		private static string FormatBytes(long bytes)
		{
			int num = Array.BinarySearch(_bytesFormatRanges, bytes);
			num = ((num >= 0) ? (num + 1) : (~num));
			return string.Format(CultureInfo.CurrentUICulture, Resources.GetString(_bytesFormatStrings[num]), new object[1] { (num == 0) ? ((float)bytes) : ((float)bytes / (float)_bytesFormatRanges[(num - 1) / 3 * 3]) });
		}
	}
	internal static class ShellExposure
	{
		public class ShellExposureInformation
		{
			private string _applicationFolderPath;

			private string _applicationRootFolderPath;

			private string _applicationShortcutPath;

			private string _desktopShortcutPath;

			private string _supportShortcutPath;

			private string _appVendor;

			private string _appProduct;

			private string _appSuiteName;

			private string _appSupportShortcut;

			private string _shortcutAppId;

			public string ApplicationFolderPath => _applicationFolderPath;

			public string ApplicationRootFolderPath => _applicationRootFolderPath;

			public string ApplicationShortcutPath => _applicationShortcutPath;

			public string SupportShortcutPath => _supportShortcutPath;

			public string DesktopShortcutPath => _desktopShortcutPath;

			public string ARPDisplayName
			{
				get
				{
					StringBuilder stringBuilder = new StringBuilder();
					stringBuilder.Append(_appProduct);
					if (PlatformSpecific.OnWin9x && stringBuilder.Length > 63)
					{
						stringBuilder.Length = 60;
						stringBuilder.Append("...");
					}
					return stringBuilder.ToString();
				}
			}

			public string AppVendor => _appVendor;

			public string AppProduct => _appProduct;

			public string AppSuiteName => _appSuiteName;

			public string AppSupportShortcut => _appSupportShortcut;

			public string ShortcutAppId
			{
				get
				{
					return _shortcutAppId;
				}
				set
				{
					_shortcutAppId = value;
				}
			}

			public static ShellExposureInformation CreateShellExposureInformation(DefinitionIdentity subscriptionIdentity)
			{
				ShellExposureInformation shellExposureInformation = null;
				string text = null;
				string text2 = null;
				string text3 = null;
				string text4 = null;
				string shortcutAppId = "";
				using (RegistryKey registryKey = UninstallRoot.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"))
				{
					if (registryKey != null)
					{
						using RegistryKey registryKey2 = registryKey.OpenSubKey(GenerateArpKeyName(subscriptionIdentity));
						if (registryKey2 != null)
						{
							text = registryKey2.GetValue("ShortcutFolderName") as string;
							text2 = registryKey2.GetValue("ShortcutFileName") as string;
							text3 = ((registryKey2.GetValue("ShortcutSuiteName") == null) ? "" : (registryKey2.GetValue("ShortcutSuiteName") as string));
							text4 = registryKey2.GetValue("SupportShortcutFileName") as string;
							shortcutAppId = ((registryKey2.GetValue("ShortcutAppId") == null) ? "" : (registryKey2.GetValue("ShortcutAppId") as string));
						}
					}
				}
				if (text != null && text2 != null && text4 != null)
				{
					shellExposureInformation = new ShellExposureInformation();
					shellExposureInformation._applicationRootFolderPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Programs), text);
					if (string.IsNullOrEmpty(text3))
					{
						shellExposureInformation._applicationFolderPath = shellExposureInformation._applicationRootFolderPath;
					}
					else
					{
						shellExposureInformation._applicationFolderPath = Path.Combine(shellExposureInformation._applicationRootFolderPath, text3);
					}
					shellExposureInformation._applicationShortcutPath = Path.Combine(shellExposureInformation._applicationFolderPath, text2 + ".appref-ms");
					shellExposureInformation._supportShortcutPath = Path.Combine(shellExposureInformation._applicationFolderPath, text4 + ".url");
					shellExposureInformation._desktopShortcutPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), text2 + ".appref-ms");
					shellExposureInformation._appVendor = text;
					shellExposureInformation._appProduct = text2;
					shellExposureInformation._appSupportShortcut = text4;
					shellExposureInformation._shortcutAppId = shortcutAppId;
					shellExposureInformation._appSuiteName = text3;
				}
				return shellExposureInformation;
			}

			public static ShellExposureInformation CreateShellExposureInformation(string publisher, string suiteName, string product, string shortcutAppId)
			{
				ShellExposureInformation shellExposureInformation = new ShellExposureInformation();
				string text = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Programs), publisher);
				string text2 = text;
				if (!string.IsNullOrEmpty(suiteName))
				{
					text2 = Path.Combine(text, suiteName);
				}
				string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
				string text3 = null;
				string text4 = null;
				string text5 = null;
				int num = 0;
				num = 0;
				while (true)
				{
					text3 = num switch
					{
						int.MaxValue => throw new OverflowException(), 
						0 => string.Format(CultureInfo.CurrentUICulture, Resources.GetString("ShellExposure_DisplayStringNoIndex"), new object[1] { product }), 
						_ => string.Format(CultureInfo.CurrentUICulture, Resources.GetString("ShellExposure_DisplayStringWithIndex"), new object[2] { product, num }), 
					};
					text4 = Path.Combine(text2, text3 + ".appref-ms");
					text5 = Path.Combine(folderPath, text3 + ".appref-ms");
					if (!System.IO.File.Exists(text4) && !System.IO.File.Exists(text5))
					{
						break;
					}
					num++;
				}
				shellExposureInformation._appVendor = publisher;
				shellExposureInformation._appProduct = text3;
				shellExposureInformation._appSuiteName = suiteName;
				shellExposureInformation._applicationFolderPath = text2;
				shellExposureInformation._applicationRootFolderPath = text;
				shellExposureInformation._applicationShortcutPath = text4;
				shellExposureInformation._desktopShortcutPath = text5;
				shellExposureInformation._appSupportShortcut = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("SupportUrlFormatter"), new object[1] { text3 });
				shellExposureInformation._supportShortcutPath = Path.Combine(text2, shellExposureInformation._appSupportShortcut + ".url");
				shellExposureInformation._shortcutAppId = shortcutAppId;
				return shellExposureInformation;
			}

			protected ShellExposureInformation()
			{
			}
		}

		private static RegistryKey UninstallRoot
		{
			get
			{
				if (!PlatformSpecific.OnWin9x)
				{
					return Registry.CurrentUser;
				}
				return Registry.LocalMachine;
			}
		}

		public static void UpdateSubscriptionShellExposure(SubscriptionState subState)
		{
			using (subState.SubscriptionStore.AcquireStoreWriterLock())
			{
				ShellExposureInformation shellExposureInformation = ShellExposureInformation.CreateShellExposureInformation(subState.SubscriptionId);
				UpdateShortcuts(subState, ref shellExposureInformation);
				UpdateShellExtensions(subState, ref shellExposureInformation);
				UpdateArpEntry(subState, shellExposureInformation);
			}
		}

		public static void RemoveSubscriptionShellExposure(SubscriptionState subState)
		{
			using (subState.SubscriptionStore.AcquireStoreWriterLock())
			{
				DefinitionIdentity subscriptionId = subState.SubscriptionId;
				bool flag = false;
				ShellExposureInformation shellExposureInformation = ShellExposureInformation.CreateShellExposureInformation(subscriptionId);
				if (shellExposureInformation == null)
				{
					flag = true;
				}
				else
				{
					for (int i = 1; i <= 2; i++)
					{
						try
						{
							RemoveShortcuts(shellExposureInformation);
						}
						catch (DeploymentException ex)
						{
							Logger.AddInternalState("Remove shortcut entries Failed: " + shellExposureInformation.ApplicationShortcutPath + "," + shellExposureInformation.SupportShortcutPath + "," + shellExposureInformation.DesktopShortcutPath + "," + shellExposureInformation.ApplicationFolderPath + "," + shellExposureInformation.ApplicationRootFolderPath);
							if (i < 2)
							{
								Thread.Sleep(1000);
							}
							else if (!(ex.InnerException is UnauthorizedAccessException))
							{
								throw;
							}
							continue;
						}
						break;
					}
				}
				RemoveArpEntry(subscriptionId);
				if (flag)
				{
					throw new DeploymentException(ExceptionTypes.Subscription, Resources.GetString("Ex_ShortcutRemovalFailureDueToInvalidPublisherProduct"));
				}
			}
		}

		public static void RemoveShellExtensions(DefinitionIdentity subId, AssemblyManifest appManifest, string productName)
		{
			FileAssociation[] fileAssociations = appManifest.FileAssociations;
			foreach (FileAssociation fileAssociation in fileAssociations)
			{
				RemoveFileAssociation(fileAssociation, subId, productName);
			}
			NativeMethods.SHChangeNotify(134217728, 0u, IntPtr.Zero, IntPtr.Zero);
		}

		public static void ParseAppShortcut(string shortcutFile, out DefinitionIdentity subId, out Uri providerUri)
		{
			FileInfo fileInfo = new FileInfo(shortcutFile);
			if (fileInfo.Length > 65536)
			{
				throw new DeploymentException(ExceptionTypes.InvalidShortcut, Resources.GetString("Ex_ShortcutTooLarge"));
			}
			using StreamReader streamReader = new StreamReader(shortcutFile, Encoding.Unicode);
			string text;
			try
			{
				text = streamReader.ReadToEnd();
			}
			catch (IOException innerException)
			{
				throw new DeploymentException(ExceptionTypes.InvalidShortcut, Resources.GetString("Ex_InvalidShortcutFormat"), innerException);
			}
			Logger.AddInternalState("Shortcut Text=" + text);
			if (text == null)
			{
				throw new DeploymentException(ExceptionTypes.InvalidShortcut, Resources.GetString("Ex_InvalidShortcutFormat"));
			}
			int num = text.IndexOf('#');
			if (num < 0)
			{
				throw new DeploymentException(ExceptionTypes.InvalidShortcut, Resources.GetString("Ex_InvalidShortcutFormat"));
			}
			try
			{
				subId = new DefinitionIdentity(text.Substring(num + 1));
			}
			catch (COMException innerException2)
			{
				throw new DeploymentException(ExceptionTypes.InvalidShortcut, Resources.GetString("Ex_InvalidShortcutFormat"), innerException2);
			}
			catch (SEHException innerException3)
			{
				throw new DeploymentException(ExceptionTypes.InvalidShortcut, Resources.GetString("Ex_InvalidShortcutFormat"), innerException3);
			}
			try
			{
				providerUri = new Uri(text.Substring(0, num));
			}
			catch (UriFormatException innerException4)
			{
				throw new DeploymentException(ExceptionTypes.InvalidShortcut, Resources.GetString("Ex_InvalidShortcutFormat"), innerException4);
			}
		}

		private static void MoveDeleteFile(string filePath)
		{
			if (!System.IO.File.Exists(filePath))
			{
				return;
			}
			string path = filePath;
			string text = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
			try
			{
				System.IO.File.Move(filePath, text);
				path = text;
			}
			catch (IOException)
			{
			}
			catch (UnauthorizedAccessException)
			{
			}
			try
			{
				System.IO.File.Delete(path);
			}
			catch (IOException)
			{
			}
			catch (UnauthorizedAccessException)
			{
			}
		}

		private static void MoveDeleteEmptyFolder(string folderPath)
		{
			if (!Directory.Exists(folderPath))
			{
				return;
			}
			string[] files = Directory.GetFiles(folderPath);
			if (files.Length != 0)
			{
				return;
			}
			string text = folderPath;
			string text2 = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
			try
			{
				Directory.Move(folderPath, text2);
				text = text2;
			}
			catch (IOException)
			{
			}
			catch (UnauthorizedAccessException)
			{
			}
			try
			{
				Directory.Delete(text);
				Logger.AddInternalState("Deleted successfully: " + text);
			}
			catch (IOException ex3)
			{
				Logger.AddInternalState("Exception thrown deleting " + text + ":" + ex3.GetType().ToString() + ":" + ex3.Message);
			}
			catch (UnauthorizedAccessException ex4)
			{
				Logger.AddInternalState("Exception thrown deleting " + text + ":" + ex4.GetType().ToString() + ":" + ex4.Message);
			}
		}

		private static void UpdateShortcuts(SubscriptionState subState, ref ShellExposureInformation shellExposureInformation)
		{
			string text = $"{subState.DeploymentProviderUri.AbsoluteUri}#{subState.SubscriptionId.ToString()}";
			Description effectiveDescription = subState.EffectiveDescription;
			if (shellExposureInformation != null)
			{
				bool flag = true;
				bool flag2 = true;
				bool flag3 = true;
				bool flag4 = true;
				if (string.Compare(effectiveDescription.FilteredPublisher, shellExposureInformation.AppVendor, StringComparison.Ordinal) == 0)
				{
					flag = false;
					if (Utilities.CompareWithNullEqEmpty(effectiveDescription.FilteredSuiteName, shellExposureInformation.AppSuiteName, StringComparison.Ordinal) == 0)
					{
						flag2 = false;
						if (string.Compare(effectiveDescription.FilteredProduct, shellExposureInformation.AppProduct, StringComparison.Ordinal) == 0)
						{
							flag3 = false;
							if (string.Compare(text, shellExposureInformation.ShortcutAppId, StringComparison.Ordinal) == 0)
							{
								flag4 = false;
							}
						}
					}
				}
				if (!flag && !flag2 && !flag3 && !flag4 && System.IO.File.Exists(shellExposureInformation.ApplicationShortcutPath))
				{
					Logger.AddInternalState("Shortcut folder and files are not updated and application shortcut file already exists: " + shellExposureInformation.ApplicationShortcutPath);
					return;
				}
				if (flag3)
				{
					UnpinShortcut(shellExposureInformation.ApplicationShortcutPath);
					MoveDeleteFile(shellExposureInformation.ApplicationShortcutPath);
					MoveDeleteFile(shellExposureInformation.SupportShortcutPath);
					MoveDeleteFile(shellExposureInformation.DesktopShortcutPath);
					Logger.AddInternalState("Shortcut files deleted:" + shellExposureInformation.ApplicationShortcutPath + "," + shellExposureInformation.SupportShortcutPath + "," + shellExposureInformation.DesktopShortcutPath);
				}
				if (flag2)
				{
					Logger.AddInternalState("Attempt deleting shortcut folder:" + shellExposureInformation.ApplicationFolderPath);
					MoveDeleteEmptyFolder(shellExposureInformation.ApplicationFolderPath);
				}
				if (flag)
				{
					Logger.AddInternalState("Attempt deleting shortcut root folder:" + shellExposureInformation.ApplicationRootFolderPath);
					MoveDeleteEmptyFolder(shellExposureInformation.ApplicationRootFolderPath);
				}
				if (flag || flag2 || flag3)
				{
					shellExposureInformation = ShellExposureInformation.CreateShellExposureInformation(effectiveDescription.FilteredPublisher, effectiveDescription.FilteredSuiteName, effectiveDescription.FilteredProduct, text);
				}
				else
				{
					Logger.AddInternalState("Shortcut app id has changed. Old value=" + shellExposureInformation.ShortcutAppId + ",New value=" + text);
					shellExposureInformation.ShortcutAppId = text;
				}
			}
			else
			{
				shellExposureInformation = ShellExposureInformation.CreateShellExposureInformation(effectiveDescription.FilteredPublisher, effectiveDescription.FilteredSuiteName, effectiveDescription.FilteredProduct, text);
			}
			try
			{
				Logger.AddInternalState("Create the shortcut directory : " + shellExposureInformation.ApplicationFolderPath);
				Directory.CreateDirectory(shellExposureInformation.ApplicationFolderPath);
				GenerateAppShortcut(subState, shellExposureInformation);
				GenerateSupportShortcut(subState, shellExposureInformation);
			}
			catch (Exception)
			{
				RemoveShortcuts(shellExposureInformation);
				throw;
			}
		}

		private static void GenerateAppShortcut(SubscriptionState subState, ShellExposureInformation shellExposureInformation)
		{
			using (StreamWriter streamWriter = new StreamWriter(shellExposureInformation.ApplicationShortcutPath, append: false, Encoding.Unicode))
			{
				streamWriter.Write("{0}#{1}", subState.DeploymentProviderUri.AbsoluteUri, subState.SubscriptionId.ToString());
			}
			Logger.AddInternalState("Shortcut file created: " + shellExposureInformation.ApplicationShortcutPath);
			if (subState.CurrentDeploymentManifest.Deployment.CreateDesktopShortcut)
			{
				using (StreamWriter streamWriter2 = new StreamWriter(shellExposureInformation.DesktopShortcutPath, append: false, Encoding.Unicode))
				{
					streamWriter2.Write("{0}#{1}", subState.DeploymentProviderUri.AbsoluteUri, subState.SubscriptionId.ToString());
				}
				Logger.AddInternalState("Desktop Shortcut file created: " + shellExposureInformation.DesktopShortcutPath);
			}
		}

		private static void GenerateSupportShortcut(SubscriptionState subState, ShellExposureInformation shellExposureInformation)
		{
			Description effectiveDescription = subState.EffectiveDescription;
			if (effectiveDescription.SupportUri != null)
			{
				using (StreamWriter streamWriter = new StreamWriter(shellExposureInformation.SupportShortcutPath, append: false, Encoding.ASCII))
				{
					streamWriter.WriteLine("[Default]");
					streamWriter.WriteLine("BASEURL=" + effectiveDescription.SupportUri.AbsoluteUri);
					streamWriter.WriteLine("[InternetShortcut]");
					streamWriter.WriteLine("URL=" + effectiveDescription.SupportUri.AbsoluteUri);
					streamWriter.WriteLine();
					streamWriter.WriteLine("IconFile=" + PathHelper.ShortShimDllPath);
					streamWriter.WriteLine("IconIndex=" + 0.ToString(CultureInfo.InvariantCulture));
					streamWriter.WriteLine();
				}
				Logger.AddInternalState("Support shortcut file created: " + shellExposureInformation.SupportShortcutPath);
			}
		}

		private static void RemoveShortcuts(ShellExposureInformation shellExposureInformation)
		{
			try
			{
				if (System.IO.File.Exists(shellExposureInformation.ApplicationShortcutPath))
				{
					System.IO.File.Delete(shellExposureInformation.ApplicationShortcutPath);
				}
				if (System.IO.File.Exists(shellExposureInformation.SupportShortcutPath))
				{
					System.IO.File.Delete(shellExposureInformation.SupportShortcutPath);
				}
				if (System.IO.File.Exists(shellExposureInformation.DesktopShortcutPath))
				{
					System.IO.File.Delete(shellExposureInformation.DesktopShortcutPath);
				}
				if (Directory.Exists(shellExposureInformation.ApplicationFolderPath))
				{
					string[] files = Directory.GetFiles(shellExposureInformation.ApplicationFolderPath);
					string[] directories = Directory.GetDirectories(shellExposureInformation.ApplicationFolderPath);
					if (files.Length == 0 && directories.Length == 0)
					{
						Directory.Delete(shellExposureInformation.ApplicationFolderPath);
					}
				}
				if (Directory.Exists(shellExposureInformation.ApplicationRootFolderPath))
				{
					string[] files2 = Directory.GetFiles(shellExposureInformation.ApplicationRootFolderPath);
					string[] directories2 = Directory.GetDirectories(shellExposureInformation.ApplicationRootFolderPath);
					if (files2.Length == 0 && directories2.Length == 0)
					{
						Directory.Delete(shellExposureInformation.ApplicationRootFolderPath);
					}
				}
				Logger.AddInternalState("Removed shortcut entries : " + shellExposureInformation.ApplicationShortcutPath + "," + shellExposureInformation.SupportShortcutPath + "," + shellExposureInformation.DesktopShortcutPath + "," + shellExposureInformation.ApplicationFolderPath + "," + shellExposureInformation.ApplicationRootFolderPath);
			}
			catch (IOException innerException)
			{
				throw new DeploymentException(ExceptionTypes.InvalidShortcut, Resources.GetString("Ex_ShortcutRemovalFailure"), innerException);
			}
			catch (UnauthorizedAccessException innerException2)
			{
				throw new DeploymentException(ExceptionTypes.InvalidShortcut, Resources.GetString("Ex_ShortcutRemovalFailure"), innerException2);
			}
		}

		internal static void RemovePins(SubscriptionState subState)
		{
			Logger.AddInternalState("Attempting to remove shell pins.");
			DefinitionIdentity subscriptionId = subState.SubscriptionId;
			ShellExposureInformation shellExposureInformation = ShellExposureInformation.CreateShellExposureInformation(subscriptionId);
			if (shellExposureInformation == null)
			{
				Logger.AddInternalState("shellExposureInformation is null.");
			}
			else if (System.IO.File.Exists(shellExposureInformation.ApplicationShortcutPath))
			{
				UnpinShortcut(shellExposureInformation.ApplicationShortcutPath);
			}
		}

		public static void UpdateShellExtensions(SubscriptionState subState, ref ShellExposureInformation shellExposureInformation)
		{
			string text = null;
			if (shellExposureInformation != null)
			{
				text = shellExposureInformation.AppProduct;
			}
			if (text == null)
			{
				text = subState.SubscriptionId.Name;
			}
			if (subState.PreviousBind != null)
			{
				Logger.AddInternalState("Removing file associations if existed for the previous version.");
				RemoveShellExtensions(subState.SubscriptionId, subState.PreviousApplicationManifest, text);
			}
			Logger.AddInternalState("Registering file associations if there is any in the manifest for the new version. ");
			AddShellExtensions(subState.SubscriptionId, subState.DeploymentProviderUri, subState.CurrentApplicationManifest);
			NativeMethods.SHChangeNotify(134217728, 0u, IntPtr.Zero, IntPtr.Zero);
		}

		private static void UnpinShortcut(string shortcutPath)
		{
			uint num = 0u;
			NativeMethods.IShellItem shellItem = null;
			NativeMethods.IStartMenuPinnedList startMenuPinnedList = null;
			try
			{
				object ppv = null;
				object o = null;
				if (NativeMethods.SHCreateItemFromParsingName(shortcutPath, IntPtr.Zero, Constants.uuid, out ppv) == 0)
				{
					shellItem = ppv as NativeMethods.IShellItem;
					if (NativeMethods.CoCreateInstance(ref Constants.CLSID_StartMenuPin, null, 1, ref Constants.IID_IUnknown, out o) == 0)
					{
						startMenuPinnedList = o as NativeMethods.IStartMenuPinnedList;
						startMenuPinnedList.RemoveFromList(shellItem);
					}
				}
			}
			catch (EntryPointNotFoundException)
			{
			}
			catch (UnauthorizedAccessException)
			{
			}
			finally
			{
				if (shellItem != null)
				{
					Marshal.ReleaseComObject(shellItem);
				}
				if (startMenuPinnedList != null)
				{
					Marshal.ReleaseComObject(startMenuPinnedList);
				}
			}
		}

		private static void AddShellExtensions(DefinitionIdentity subId, Uri deploymentProviderUri, AssemblyManifest appManifest)
		{
			FileAssociation[] fileAssociations = appManifest.FileAssociations;
			foreach (FileAssociation fileAssociation in fileAssociations)
			{
				AddFileAssociation(fileAssociation, subId, deploymentProviderUri);
			}
		}

		private static bool CanAddFileAssociation(FileAssociation fileAssociation)
		{
			try
			{
				using RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("Software\\Classes");
				using RegistryKey registryKey2 = registryKey.OpenSubKey(fileAssociation.Extension);
				using RegistryKey registryKey3 = registryKey.OpenSubKey(fileAssociation.ProgID);
				if (registryKey2 != null || registryKey3 != null)
				{
					Logger.AddWarningInformation(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("SkippedFileAssoc"), new object[1] { fileAssociation.Extension }));
					Logger.AddInternalState("File association for " + fileAssociation.Extension + " skipped, since another application is using it.");
					return false;
				}
			}
			catch (SecurityException ex)
			{
				Logger.AddInternalState("Exception reading registry key : " + ex.StackTrace);
				Logger.AddInternalState("File association for " + fileAssociation.Extension + " skipped");
				return false;
			}
			return true;
		}

		private static void AddFileAssociation(FileAssociation fileAssociation, DefinitionIdentity subId, Uri deploymentProviderUri)
		{
			if (!CanAddFileAssociation(fileAssociation))
			{
				return;
			}
			string text = Guid.NewGuid().ToString("B");
			string value = subId.ToString();
			using RegistryKey registryKey = Registry.CurrentUser.CreateSubKey("Software\\Classes");
			using (RegistryKey registryKey2 = registryKey.CreateSubKey(fileAssociation.Extension))
			{
				registryKey2.SetValue(null, fileAssociation.ProgID);
				registryKey2.SetValue("AppId", value);
				registryKey2.SetValue("Guid", text);
				registryKey2.SetValue("DeploymentProviderUrl", deploymentProviderUri.AbsoluteUri);
			}
			using (RegistryKey registryKey3 = registryKey.CreateSubKey(fileAssociation.ProgID))
			{
				registryKey3.SetValue(null, fileAssociation.Description);
				registryKey3.SetValue("AppId", value);
				registryKey3.SetValue("Guid", text);
				registryKey3.SetValue("DeploymentProviderUrl", deploymentProviderUri.AbsoluteUri);
				using RegistryKey registryKey4 = registryKey3.CreateSubKey("shell");
				registryKey4.SetValue(null, "open");
				using (RegistryKey registryKey5 = registryKey4.CreateSubKey("open\\command"))
				{
					registryKey5.SetValue(null, "rundll32.exe dfshim.dll, ShOpenVerbExtension " + text + " %1");
					Logger.AddInternalState("File association created. Extension=" + fileAssociation.Extension + " value=rundll32.exe dfshim.dll, ShOpenVerbExtension " + text + " %1");
				}
				using RegistryKey registryKey6 = registryKey3.CreateSubKey("shellex\\IconHandler");
				registryKey6.SetValue(null, text);
				Logger.AddInternalState("File association icon handler created. Extension=" + fileAssociation.Extension + " value=" + text);
			}
			using RegistryKey registryKey7 = registryKey.CreateSubKey("CLSID");
			using RegistryKey registryKey8 = registryKey7.CreateSubKey(text);
			registryKey8.SetValue(null, "Shell Icon Handler For " + fileAssociation.Description);
			registryKey8.SetValue("AppId", value);
			registryKey8.SetValue("DeploymentProviderUrl", deploymentProviderUri.AbsoluteUri);
			registryKey8.SetValue("IconFile", fileAssociation.DefaultIcon);
			using RegistryKey registryKey9 = registryKey8.CreateSubKey("InProcServer32");
			registryKey9.SetValue(null, "dfshim.dll");
			registryKey9.SetValue("ThreadingModel", "Apartment");
		}

		private static void RemoveFileAssociation(FileAssociation fileAssociation, DefinitionIdentity subId, string productName)
		{
			using RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("Software\\Classes", writable: true);
			if (registryKey != null)
			{
				Logger.AddMethodCall("RemoveFileAssociation(" + fileAssociation.ToString() + ") called.");
				RemoveFileAssociationExtentionInfo(fileAssociation, subId, registryKey, productName);
				string text = RemoveFileAssociationProgIDInfo(fileAssociation, subId, registryKey, productName);
				if (text != null)
				{
					RemoveFileAssociationCLSIDInfo(fileAssociation, subId, registryKey, text, productName);
				}
			}
		}

		private static void RemoveFileAssociationExtentionInfo(FileAssociation fileAssociation, DefinitionIdentity subId, RegistryKey classesKey, string productName)
		{
			using RegistryKey registryKey = classesKey.OpenSubKey(fileAssociation.Extension, writable: true);
			if (registryKey == null)
			{
				return;
			}
			object value = registryKey.GetValue("AppId");
			if (!(value is string))
			{
				return;
			}
			string a = (string)value;
			if (!string.Equals(a, subId.ToString(), StringComparison.Ordinal))
			{
				return;
			}
			try
			{
				classesKey.DeleteSubKeyTree(fileAssociation.Extension);
			}
			catch (ArgumentException innerException)
			{
				throw new DeploymentException(ExceptionTypes.InvalidARPEntry, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileAssocExtDeleteFailed"), new object[2] { fileAssociation.Extension, productName }), innerException);
			}
		}

		private static string RemoveFileAssociationProgIDInfo(FileAssociation fileAssociation, DefinitionIdentity subId, RegistryKey classesKey, string productName)
		{
			string text = null;
			using RegistryKey registryKey = classesKey.OpenSubKey(fileAssociation.ProgID, writable: true);
			if (registryKey == null)
			{
				return null;
			}
			object value = registryKey.GetValue("AppId");
			if (!(value is string))
			{
				return null;
			}
			string a = (string)value;
			if (!string.Equals(a, subId.ToString(), StringComparison.Ordinal))
			{
				return null;
			}
			text = (string)registryKey.GetValue("Guid");
			try
			{
				classesKey.DeleteSubKeyTree(fileAssociation.ProgID);
				return text;
			}
			catch (ArgumentException innerException)
			{
				throw new DeploymentException(ExceptionTypes.InvalidARPEntry, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileAssocProgIdDeleteFailed"), new object[2] { fileAssociation.ProgID, productName }), innerException);
			}
		}

		private static void RemoveFileAssociationCLSIDInfo(FileAssociation fileAssociation, DefinitionIdentity subId, RegistryKey classesKey, string clsIdString, string productName)
		{
			using RegistryKey registryKey = classesKey.OpenSubKey("CLSID", writable: true);
			if (registryKey == null)
			{
				return;
			}
			using RegistryKey registryKey2 = registryKey.OpenSubKey(clsIdString);
			if (registryKey2 == null)
			{
				return;
			}
			object value = registryKey2.GetValue("AppId");
			if (!(value is string))
			{
				return;
			}
			string a = (string)value;
			if (!string.Equals(a, subId.ToString(), StringComparison.Ordinal))
			{
				return;
			}
			try
			{
				registryKey.DeleteSubKeyTree(clsIdString);
			}
			catch (ArgumentException innerException)
			{
				throw new DeploymentException(ExceptionTypes.InvalidARPEntry, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileAssocCLSIDDeleteFailed"), new object[2] { clsIdString, productName }), innerException);
			}
		}

		private static void UpdateArpEntry(SubscriptionState subState, ShellExposureInformation shellExposureInformation)
		{
			DefinitionIdentity subscriptionId = subState.SubscriptionId;
			string text = string.Format(CultureInfo.InvariantCulture, "rundll32.exe dfshim.dll,ShArpMaintain {0}", new object[1] { subscriptionId.ToString() });
			string text2 = string.Format(CultureInfo.InvariantCulture, "dfshim.dll,2");
			AssemblyManifest currentDeploymentManifest = subState.CurrentDeploymentManifest;
			Description effectiveDescription = subState.EffectiveDescription;
			using RegistryKey registryKey = UninstallRoot.CreateSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
			using RegistryKey registryKey2 = registryKey.CreateSubKey(GenerateArpKeyName(subscriptionId));
			string[] array = new string[24]
			{
				"DisplayName",
				shellExposureInformation.ARPDisplayName,
				"DisplayIcon",
				text2,
				"DisplayVersion",
				currentDeploymentManifest.Identity.Version.ToString(),
				"Publisher",
				effectiveDescription.FilteredPublisher,
				"UninstallString",
				text,
				"HelpLink",
				effectiveDescription.SupportUrl,
				"UrlUpdateInfo",
				subState.DeploymentProviderUri.AbsoluteUri,
				"ShortcutFolderName",
				shellExposureInformation.AppVendor,
				"ShortcutFileName",
				shellExposureInformation.AppProduct,
				"ShortcutSuiteName",
				shellExposureInformation.AppSuiteName,
				"SupportShortcutFileName",
				shellExposureInformation.AppSupportShortcut,
				"ShortcutAppId",
				shellExposureInformation.ShortcutAppId
			};
			Logger.AddInternalState("Updating ARP entry.");
			for (int num = array.Length - 2; num >= 0; num -= 2)
			{
				string name = array[num];
				string text3 = array[num + 1];
				if (text3 != null)
				{
					registryKey2.SetValue(name, text3);
				}
				else
				{
					registryKey2.DeleteValue(name, throwOnMissingValue: false);
				}
			}
		}

		private static void RemoveArpEntry(DefinitionIdentity subId)
		{
			using RegistryKey registryKey = UninstallRoot.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", writable: true);
			string text = null;
			try
			{
				if (registryKey != null)
				{
					text = GenerateArpKeyName(subId);
					registryKey.DeleteSubKeyTree(text);
				}
			}
			catch (ArgumentException innerException)
			{
				throw new DeploymentException(ExceptionTypes.InvalidARPEntry, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ArpEntryRemovalFailure"), new object[1] { text }), innerException);
			}
		}

		private static string GenerateArpKeyName(DefinitionIdentity subId)
		{
			return string.Format(CultureInfo.InvariantCulture, "{0:x16}", new object[1] { subId.Hash });
		}
	}
	internal class SplashPiece : FormPiece
	{
		private PictureBox pictureWait;

		private Label lblNote;

		private System.Windows.Forms.Timer splashTimer;

		private TableLayoutPanel overarchingTableLayoutPanel;

		private SplashInfo info;

		private const int initialDelay = 2500;

		private const int showDelay = 1000;

		public SplashPiece(UserInterfaceForm parentForm, SplashInfo info)
		{
			this.info = info;
			SuspendLayout();
			InitializeComponent();
			InitializeContent();
			ResumeLayout(performLayout: false);
			parentForm.SuspendLayout();
			parentForm.Text = Resources.GetString("UI_SplashTitle");
			parentForm.MinimizeBox = false;
			parentForm.MaximizeBox = false;
			parentForm.ControlBox = true;
			parentForm.ResumeLayout(performLayout: false);
			splashTimer = new System.Windows.Forms.Timer();
			splashTimer.Tick += SplashTimer_Tick;
			if (info.initializedAsWait)
			{
				splashTimer.Interval = 2500;
				splashTimer.Tag = null;
				splashTimer.Enabled = true;
			}
			else
			{
				ShowSplash(parentForm);
			}
		}

		public override bool OnClosing()
		{
			bool result = base.OnClosing();
			info.cancelled = true;
			End();
			return result;
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				End();
			}
		}

		private void InitializeComponent()
		{
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(System.Deployment.Application.SplashPiece));
			this.pictureWait = new System.Windows.Forms.PictureBox();
			this.lblNote = new System.Windows.Forms.Label();
			this.overarchingTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			((System.ComponentModel.ISupportInitialize)this.pictureWait).BeginInit();
			this.overarchingTableLayoutPanel.SuspendLayout();
			base.SuspendLayout();
			resources.ApplyResources(this.pictureWait, "pictureWait");
			this.pictureWait.Name = "pictureWait";
			this.pictureWait.TabStop = false;
			if (System.AccessibilityImprovements.Level3)
			{
				this.pictureWait.AccessibleName = System.Deployment.Application.Resources.GetString("ClickOnceSplashAnimation");
				this.pictureWait.AccessibleRole = System.Windows.Forms.AccessibleRole.Graphic;
			}
			resources.ApplyResources(this.lblNote, "lblNote");
			this.lblNote.Name = "lblNote";
			resources.ApplyResources(this.overarchingTableLayoutPanel, "overarchingTableLayoutPanel");
			this.overarchingTableLayoutPanel.Controls.Add(this.pictureWait, 0, 0);
			this.overarchingTableLayoutPanel.Controls.Add(this.lblNote, 0, 1);
			this.overarchingTableLayoutPanel.Name = "overarchingTableLayoutPanel";
			resources.ApplyResources(this, "$this");
			base.Controls.Add(this.overarchingTableLayoutPanel);
			base.Name = "SplashPiece";
			((System.ComponentModel.ISupportInitialize)this.pictureWait).EndInit();
			this.overarchingTableLayoutPanel.ResumeLayout(false);
			this.overarchingTableLayoutPanel.PerformLayout();
			base.ResumeLayout(false);
			base.PerformLayout();
		}

		private void InitializeContent()
		{
			double num = Math.Floor((double)base.DeviceDpi / 96.0);
			if (Resources.GetString("RTL") != "RTL_False")
			{
				if (num <= 1.0)
				{
					pictureWait.Image = Resources.GetImage("splash_mirror.gif");
				}
				else if (num <= 2.0)
				{
					pictureWait.Image = Resources.GetImage("splash_mirror_200.gif");
				}
				else if (num <= 3.0)
				{
					pictureWait.Image = Resources.GetImage("splash_mirror_300.gif");
				}
				else
				{
					pictureWait.Image = Resources.GetImage("splash_mirror_400.gif");
				}
			}
			else if (num <= 1.0)
			{
				pictureWait.Image = Resources.GetImage("splash.gif");
			}
			else if (num <= 2.0)
			{
				pictureWait.Image = Resources.GetImage("splash_200.gif");
			}
			else if (num <= 3.0)
			{
				pictureWait.Image = Resources.GetImage("splash_300.gif");
			}
			else
			{
				pictureWait.Image = Resources.GetImage("splash_400.gif");
			}
		}

		private void End()
		{
			info.initializedAsWait = false;
			splashTimer.Tag = this;
			splashTimer.Dispose();
			info.pieceReady.Set();
		}

		private void ShowSplash(Form parentForm)
		{
			info.initializedAsWait = false;
			parentForm.Visible = true;
			splashTimer.Interval = 1000;
			splashTimer.Tag = this;
			splashTimer.Enabled = true;
			info.pieceReady.Reset();
		}

		private void SplashTimer_Tick(object sender, EventArgs e)
		{
			if (splashTimer.Enabled)
			{
				splashTimer.Enabled = false;
				if (splashTimer.Tag != null)
				{
					info.pieceReady.Set();
				}
				else
				{
					ShowSplash(FindForm());
				}
			}
		}
	}
	internal class SubscriptionState
	{
		private SubscriptionStore _subStore;

		private DefinitionIdentity _subId;

		private bool _stateIsValid;

		private SubscriptionStateInternal state;

		public DefinitionIdentity SubscriptionId => _subId;

		public SubscriptionStore SubscriptionStore => _subStore;

		public bool IsInstalled
		{
			get
			{
				Validate();
				return state.IsInstalled;
			}
		}

		public bool IsShellVisible
		{
			get
			{
				Validate();
				return state.IsShellVisible;
			}
		}

		public DefinitionAppId CurrentBind
		{
			get
			{
				Validate();
				return state.CurrentBind;
			}
		}

		public DefinitionAppId PreviousBind
		{
			get
			{
				Validate();
				return state.PreviousBind;
			}
		}

		public DefinitionAppId PendingBind
		{
			get
			{
				Validate();
				return state.PendingBind;
			}
		}

		public DefinitionIdentity PendingDeployment
		{
			get
			{
				Validate();
				return state.PendingDeployment;
			}
		}

		public DefinitionIdentity ExcludedDeployment
		{
			get
			{
				Validate();
				return state.ExcludedDeployment;
			}
		}

		public Uri DeploymentProviderUri
		{
			get
			{
				Validate();
				return state.DeploymentProviderUri;
			}
		}

		public Version MinimumRequiredVersion
		{
			get
			{
				Validate();
				return state.MinimumRequiredVersion;
			}
		}

		public DateTime LastCheckTime
		{
			get
			{
				Validate();
				return state.LastCheckTime;
			}
		}

		public DefinitionIdentity UpdateSkippedDeployment
		{
			get
			{
				Validate();
				return state.UpdateSkippedDeployment;
			}
		}

		public DateTime UpdateSkipTime
		{
			get
			{
				Validate();
				return state.UpdateSkipTime;
			}
		}

		public AppType appType
		{
			get
			{
				Validate();
				return state.appType;
			}
		}

		public DefinitionIdentity CurrentDeployment
		{
			get
			{
				Validate();
				return state.CurrentDeployment;
			}
		}

		public DefinitionIdentity RollbackDeployment
		{
			get
			{
				Validate();
				return state.RollbackDeployment;
			}
		}

		public AssemblyManifest CurrentDeploymentManifest
		{
			get
			{
				Validate();
				return state.CurrentDeploymentManifest;
			}
		}

		public Uri CurrentDeploymentSourceUri
		{
			get
			{
				Validate();
				return state.CurrentDeploymentSourceUri;
			}
		}

		public AssemblyManifest CurrentApplicationManifest
		{
			get
			{
				Validate();
				return state.CurrentApplicationManifest;
			}
		}

		public Uri CurrentApplicationSourceUri
		{
			get
			{
				Validate();
				return state.CurrentApplicationSourceUri;
			}
		}

		public AssemblyManifest PreviousApplicationManifest
		{
			get
			{
				Validate();
				return state.PreviousApplicationManifest;
			}
		}

		public DefinitionIdentity PKTGroupId
		{
			get
			{
				DefinitionIdentity definitionIdentity = (DefinitionIdentity)_subId.Clone();
				definitionIdentity["publicKeyToken"] = null;
				return definitionIdentity;
			}
		}

		public Description EffectiveDescription
		{
			get
			{
				if (CurrentApplicationManifest != null && CurrentApplicationManifest.UseManifestForTrust)
				{
					return CurrentApplicationManifest.Description;
				}
				if (CurrentDeploymentManifest == null)
				{
					return null;
				}
				return CurrentDeploymentManifest.Description;
			}
		}

		public string EffectiveCertificatePublicKeyToken
		{
			get
			{
				if (CurrentApplicationManifest != null && CurrentApplicationManifest.UseManifestForTrust)
				{
					return CurrentApplicationManifest.Identity.PublicKeyToken;
				}
				if (CurrentDeploymentManifest == null)
				{
					return null;
				}
				return CurrentDeploymentManifest.Identity.PublicKeyToken;
			}
		}

		public SubscriptionState(SubscriptionStore subStore, DefinitionIdentity subId)
		{
			Initialize(subStore, subId);
		}

		public SubscriptionState(SubscriptionStore subStore, AssemblyManifest deployment)
		{
			Initialize(subStore, deployment.Identity.ToSubscriptionId());
		}

		public void Invalidate()
		{
			_stateIsValid = false;
		}

		private void Validate()
		{
			if (!_stateIsValid)
			{
				state = _subStore.GetSubscriptionStateInternal(this);
				_stateIsValid = true;
			}
		}

		private void Initialize(SubscriptionStore subStore, DefinitionIdentity subId)
		{
			_subStore = subStore;
			_subId = subId;
			Invalidate();
		}

		public override string ToString()
		{
			Validate();
			return state.ToString();
		}
	}
	internal class SubscriptionStore
	{
		private static SubscriptionStore _userStore;

		private string _deployPath;

		private string _tempPath;

		private ComponentStore _compStore;

		private object _subscriptionStoreLock;

		private static object _currentUserLock = new object();

		public static SubscriptionStore CurrentUser
		{
			get
			{
				if (_userStore == null)
				{
					lock (_currentUserLock)
					{
						if (_userStore == null)
						{
							string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
							string deployPath = Path.Combine(folderPath, "Deployment");
							string tempPath = Path.Combine(Path.GetTempPath(), "Deployment");
							_userStore = new SubscriptionStore(deployPath, tempPath, ComponentStoreType.UserStore);
						}
					}
				}
				return _userStore;
			}
		}

		private DefinitionIdentity SubscriptionStoreLock
		{
			get
			{
				if (_subscriptionStoreLock == null)
				{
					Interlocked.CompareExchange(ref _subscriptionStoreLock, new DefinitionIdentity("__SubscriptionStoreLock__"), null);
				}
				return (DefinitionIdentity)_subscriptionStoreLock;
			}
		}

		private SubscriptionStore(string deployPath, string tempPath, ComponentStoreType storeType)
		{
			_deployPath = deployPath;
			_tempPath = tempPath;
			Directory.CreateDirectory(_deployPath);
			Directory.CreateDirectory(_tempPath);
			using (AcquireStoreWriterLock())
			{
				_compStore = ComponentStore.GetStore(storeType, this);
			}
		}

		public void RefreshStorePointer()
		{
			using (AcquireStoreWriterLock())
			{
				_compStore.RefreshStorePointer();
			}
		}

		public void CleanOnlineAppCache()
		{
			using (AcquireStoreWriterLock())
			{
				_compStore.RefreshStorePointer();
				_compStore.CleanOnlineAppCache();
			}
		}

		public void CommitApplication(ref SubscriptionState subState, CommitApplicationParams commitParams)
		{
			Logger.AddMethodCall("CommitApplication called.");
			using (AcquireSubscriptionWriterLock(subState))
			{
				if (commitParams.CommitDeploy)
				{
					Logger.AddInternalState("Commiting Deployment :  subscription metadata.");
					UriHelper.ValidateSupportedScheme(commitParams.DeploySourceUri);
					CheckDeploymentSubscriptionState(subState, commitParams.DeployManifest);
					ValidateFileAssoctiation(subState, commitParams);
					if (commitParams.IsUpdate && !commitParams.IsUpdateInPKTGroup)
					{
						CheckInstalled(subState);
					}
				}
				if (commitParams.CommitApp)
				{
					Logger.AddInternalState("Commiting Application:  application binaries.");
					UriHelper.ValidateSupportedScheme(commitParams.AppSourceUri);
					if (commitParams.AppGroup != null)
					{
						CheckInstalled(subState);
					}
					CheckApplicationPayload(commitParams);
				}
				bool flag = false;
				bool identityGroupFound = false;
				bool locationGroupFound = false;
				string identityGroupProductName = "";
				ArrayList arrayList = _compStore.CollectCrossGroupApplications(commitParams.DeploySourceUri, commitParams.DeployManifest.Identity, ref identityGroupFound, ref locationGroupFound, ref identityGroupProductName);
				if (arrayList.Count > 0)
				{
					flag = true;
					Logger.AddInternalState("This installation is a Cross Group: identityGroupFound=" + identityGroupFound + ",locationGroupFound=" + locationGroupFound);
				}
				if (subState.IsShellVisible && identityGroupFound && locationGroupFound)
				{
					throw new DeploymentException(ExceptionTypes.GroupMultipleMatch, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_GroupMultipleMatch"), new object[1] { identityGroupProductName }));
				}
				subState = GetSubscriptionState(commitParams.DeployManifest);
				_compStore.CommitApplication(subState, commitParams);
				if (flag)
				{
					Logger.AddInternalState("Performing cross group migration.");
					System.Deployment.Internal.Isolation.IActContext actContext = System.Deployment.Internal.Isolation.IsolationInterop.CreateActContext(subState.CurrentBind.ComPointer);
					actContext.PrepareForExecution(IntPtr.Zero, IntPtr.Zero);
					actContext.SetApplicationRunningState(0u, 1u, out var ulDisposition);
					actContext.SetApplicationRunningState(0u, 2u, out ulDisposition);
					Logger.AddInternalState("Uninstalling all cross groups.");
					foreach (ComponentStore.CrossGroupApplicationData item in arrayList)
					{
						if (item.CrossGroupType == ComponentStore.CrossGroupApplicationData.GroupType.LocationGroup)
						{
							if (item.SubState.appType == AppType.CustomHostSpecified)
							{
								Logger.AddInternalState("UninstallCustomHostSpecifiedSubscription : " + ((item.SubState.SubscriptionId != null) ? item.SubState.SubscriptionId.ToString() : "null"));
								UninstallCustomHostSpecifiedSubscription(item.SubState);
							}
							else if (item.SubState.appType == AppType.CustomUX)
							{
								Logger.AddInternalState("UninstallCustomUXSubscription : " + ((item.SubState.SubscriptionId != null) ? item.SubState.SubscriptionId.ToString() : "null"));
								UninstallCustomUXSubscription(item.SubState);
							}
							else if (item.SubState.IsShellVisible)
							{
								Logger.AddInternalState("UninstallSubscription : " + ((item.SubState.SubscriptionId != null) ? item.SubState.SubscriptionId.ToString() : "null"));
								UninstallSubscription(item.SubState);
							}
						}
						else if (item.CrossGroupType == ComponentStore.CrossGroupApplicationData.GroupType.IdentityGroup)
						{
							Logger.AddInternalState("Not uninstalled :" + ((item.SubState.SubscriptionId != null) ? item.SubState.SubscriptionId.ToString() : "null") + ". It is in the identity group.");
						}
					}
				}
				if (commitParams.IsConfirmed && subState.IsInstalled && subState.IsShellVisible && commitParams.appType != AppType.CustomUX)
				{
					UpdateSubscriptionExposure(subState);
				}
				if (commitParams.appType == AppType.CustomUX)
				{
					ShellExposure.ShellExposureInformation shellExposureInformation = ShellExposure.ShellExposureInformation.CreateShellExposureInformation(subState.SubscriptionId);
					ShellExposure.UpdateShellExtensions(subState, ref shellExposureInformation);
				}
				OnDeploymentAdded(subState);
			}
		}

		public void RollbackSubscription(SubscriptionState subState)
		{
			using (AcquireSubscriptionWriterLock(subState))
			{
				CheckInstalledAndShellVisible(subState);
				if (subState.RollbackDeployment == null)
				{
					throw new DeploymentException(ExceptionTypes.SubscriptionState, Resources.GetString("Ex_SubNoRollbackDeployment"));
				}
				if (subState.CurrentApplicationManifest != null)
				{
					string text = null;
					if (subState.CurrentDeploymentManifest != null && subState.CurrentDeploymentManifest.Description != null)
					{
						text = subState.CurrentDeploymentManifest.Description.Product;
					}
					if (text == null)
					{
						text = subState.SubscriptionId.Name;
					}
					ShellExposure.RemoveShellExtensions(subState.SubscriptionId, subState.CurrentApplicationManifest, text);
				}
				_compStore.RollbackSubscription(subState);
				UpdateSubscriptionExposure(subState);
				OnDeploymentRemoved(subState);
			}
		}

		public void UninstallSubscription(SubscriptionState subState)
		{
			using (AcquireSubscriptionWriterLock(subState))
			{
				CheckInstalledAndShellVisible(subState);
				if (subState.CurrentApplicationManifest != null)
				{
					string text = null;
					if (subState.CurrentDeploymentManifest != null && subState.CurrentDeploymentManifest.Description != null)
					{
						text = subState.CurrentDeploymentManifest.Description.Product;
					}
					if (text == null)
					{
						text = subState.SubscriptionId.Name;
					}
					ShellExposure.RemoveShellExtensions(subState.SubscriptionId, subState.CurrentApplicationManifest, text);
					ShellExposure.RemovePins(subState);
				}
				_compStore.RemoveSubscription(subState);
				RemoveSubscriptionExposure(subState);
				OnDeploymentRemoved(subState);
			}
		}

		public void UninstallCustomUXSubscription(SubscriptionState subState)
		{
			using (AcquireSubscriptionWriterLock(subState))
			{
				CheckInstalled(subState);
				if (subState.appType != AppType.CustomUX)
				{
					throw new InvalidOperationException(Resources.GetString("Ex_CannotCallUninstallCustomUXApplication"));
				}
				if (subState.CurrentApplicationManifest != null)
				{
					string text = null;
					if (subState.CurrentDeploymentManifest != null && subState.CurrentDeploymentManifest.Description != null)
					{
						text = subState.CurrentDeploymentManifest.Description.Product;
					}
					if (text == null)
					{
						text = subState.SubscriptionId.Name;
					}
					ShellExposure.RemoveShellExtensions(subState.SubscriptionId, subState.CurrentApplicationManifest, text);
				}
				_compStore.RemoveSubscription(subState);
				OnDeploymentRemoved(subState);
			}
		}

		public void UninstallCustomHostSpecifiedSubscription(SubscriptionState subState)
		{
			using (AcquireSubscriptionWriterLock(subState))
			{
				CheckInstalled(subState);
				if (subState.appType != AppType.CustomHostSpecified)
				{
					throw new InvalidOperationException(Resources.GetString("Ex_CannotCallUninstallCustomAddIn"));
				}
				_compStore.RemoveSubscription(subState);
				OnDeploymentRemoved(subState);
			}
		}

		public void SetPendingDeployment(SubscriptionState subState, DefinitionIdentity deployId, DateTime checkTime)
		{
			using (AcquireSubscriptionWriterLock(subState))
			{
				CheckInstalledAndShellVisible(subState);
				_compStore.SetPendingDeployment(subState, deployId, checkTime);
			}
		}

		public void SetLastCheckTimeToNow(SubscriptionState subState)
		{
			using (AcquireSubscriptionWriterLock(subState))
			{
				CheckInstalled(subState);
				_compStore.SetPendingDeployment(subState, null, DateTime.UtcNow);
			}
		}

		public void SetUpdateSkipTime(SubscriptionState subState, DefinitionIdentity updateSkippedDeployment, DateTime updateSkipTime)
		{
			using (AcquireSubscriptionWriterLock(subState))
			{
				CheckInstalledAndShellVisible(subState);
				_compStore.SetUpdateSkipTime(subState, updateSkippedDeployment, updateSkipTime);
			}
		}

		public bool CheckAndReferenceApplication(SubscriptionState subState, DefinitionAppId appId, long transactionId)
		{
			DefinitionIdentity deploymentIdentity = appId.DeploymentIdentity;
			DefinitionIdentity applicationIdentity = appId.ApplicationIdentity;
			if (subState.IsInstalled && IsAssemblyInstalled(deploymentIdentity))
			{
				if (IsAssemblyInstalled(applicationIdentity))
				{
					if (!appId.Equals(subState.CurrentBind))
					{
						return appId.Equals(subState.PreviousBind);
					}
					return true;
				}
				throw new DeploymentException(ExceptionTypes.Subscription, Resources.GetString("Ex_IllegalApplicationId"));
			}
			return false;
		}

		public void ActivateApplication(DefinitionAppId appId, string activationParameter, bool useActivationParameter)
		{
			using (AcquireStoreReaderLock())
			{
				_compStore.ActivateApplication(appId, activationParameter, useActivationParameter);
			}
		}

		public FileStream AcquireReferenceTransaction(out long transactionId)
		{
			transactionId = 0L;
			return null;
		}

		public SubscriptionState GetSubscriptionState(DefinitionIdentity subId)
		{
			return new SubscriptionState(this, subId);
		}

		public SubscriptionState GetSubscriptionState(AssemblyManifest deployment)
		{
			return new SubscriptionState(this, deployment);
		}

		public SubscriptionStateInternal GetSubscriptionStateInternal(SubscriptionState subState)
		{
			using (AcquireSubscriptionReaderLock(subState))
			{
				return _compStore.GetSubscriptionStateInternal(subState);
			}
		}

		public void CheckForDeploymentUpdate(SubscriptionState subState)
		{
			CheckInstalledAndShellVisible(subState);
			Uri sourceUri = subState.DeploymentProviderUri;
			TempFile tempFile = null;
			try
			{
				AssemblyManifest assemblyManifest = DownloadManager.DownloadDeploymentManifest(subState.SubscriptionStore, ref sourceUri, out tempFile);
				Version version = CheckUpdateInManifest(subState, sourceUri, assemblyManifest, subState.CurrentDeployment.Version);
				DefinitionIdentity deployId = ((version != null) ? assemblyManifest.Identity : null);
				SetPendingDeployment(subState, deployId, DateTime.UtcNow);
				if (version != null && assemblyManifest.Identity.Equals(subState.PendingDeployment))
				{
					Logger.AddPhaseInformation(Resources.GetString("Upd_FoundUpdate"), subState.SubscriptionId.ToString(), assemblyManifest.Identity.Version.ToString(), sourceUri.AbsoluteUri);
				}
			}
			finally
			{
				tempFile?.Dispose();
			}
		}

		public Version CheckUpdateInManifest(SubscriptionState subState, Uri updateCodebaseUri, AssemblyManifest deployment, Version currentVersion)
		{
			bool bUpdateInPKTGroup = false;
			return CheckUpdateInManifest(subState, updateCodebaseUri, deployment, currentVersion, ref bUpdateInPKTGroup);
		}

		public Version CheckUpdateInManifest(SubscriptionState subState, Uri updateCodebaseUri, AssemblyManifest deployment, Version currentVersion, ref bool bUpdateInPKTGroup)
		{
			CheckOnlineShellVisibleConflict(subState, deployment);
			CheckInstalledAndUpdateableConflict(subState, deployment);
			CheckMinimumRequiredVersion(subState, deployment);
			SubscriptionState subscriptionState = GetSubscriptionState(deployment);
			if (!subscriptionState.SubscriptionId.Equals(subState.SubscriptionId))
			{
				Logger.AddInternalState("Cross family update detected. Check if only PKT has changed between versions.");
				Logger.AddInternalState("updateCodebaseUri=" + updateCodebaseUri?.ToString() + ", subState.DeploymentProviderUri=" + subState.DeploymentProviderUri);
				Logger.AddInternalState("subState=" + subState.SubscriptionId?.ToString() + ", manSubState.SubscriptionId=" + subscriptionState.SubscriptionId);
				if (!updateCodebaseUri.Equals(subState.DeploymentProviderUri) || !subState.PKTGroupId.Equals(subscriptionState.PKTGroupId))
				{
					throw new DeploymentException(ExceptionTypes.SubscriptionState, Resources.GetString("Ex_DeploymentIdentityNotInSubscription"));
				}
				Logger.AddInternalState("PKT has changed.");
				bUpdateInPKTGroup = true;
			}
			Version version = deployment.Identity.Version;
			if (version.CompareTo(currentVersion) == 0)
			{
				return null;
			}
			return version;
		}

		public void CheckDeploymentSubscriptionState(SubscriptionState subState, AssemblyManifest deployment)
		{
			if (subState.IsInstalled)
			{
				CheckOnlineShellVisibleConflict(subState, deployment);
				CheckInstalledAndUpdateableConflict(subState, deployment);
				CheckMinimumRequiredVersion(subState, deployment);
			}
		}

		public void CheckCustomUXFlag(SubscriptionState subState, AssemblyManifest application)
		{
			if (subState.IsInstalled)
			{
				if (application.EntryPoints[0].CustomUX && subState.appType != AppType.CustomUX)
				{
					throw new DeploymentException(Resources.GetString("Ex_CustomUXAlready"));
				}
				if (!application.EntryPoints[0].CustomUX && subState.appType == AppType.CustomUX)
				{
					throw new DeploymentException(Resources.GetString("Ex_NotCustomUXAlready"));
				}
			}
		}

		public void ValidateFileAssoctiation(SubscriptionState subState, CommitApplicationParams commitParams)
		{
			if (commitParams.DeployManifest != null && commitParams.AppManifest != null && !commitParams.DeployManifest.Deployment.Install && commitParams.AppManifest.FileAssociations.Length != 0)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, Resources.GetString("Ex_OnlineAppWithFileAssociation"));
			}
		}

		public void CheckInstalledAndShellVisible(SubscriptionState subState)
		{
			CheckInstalled(subState);
			CheckShellVisible(subState);
		}

		public static void CheckInstalled(SubscriptionState subState)
		{
			if (!subState.IsInstalled)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, Resources.GetString("Ex_SubNotInstalled"));
			}
		}

		public static void CheckShellVisible(SubscriptionState subState)
		{
			if (!subState.IsShellVisible)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, Resources.GetString("Ex_SubNotShellVisible"));
			}
		}

		public bool CheckGroupInstalled(SubscriptionState subState, DefinitionAppId appId, string groupName)
		{
			using (AcquireSubscriptionReaderLock(subState))
			{
				return _compStore.CheckGroupInstalled(appId, groupName);
			}
		}

		public bool CheckGroupInstalled(SubscriptionState subState, DefinitionAppId appId, AssemblyManifest appManifest, string groupName)
		{
			using (AcquireSubscriptionReaderLock(subState))
			{
				return _compStore.CheckGroupInstalled(appId, appManifest, groupName);
			}
		}

		public IDisposable AcquireSubscriptionReaderLock(SubscriptionState subState)
		{
			subState.Invalidate();
			return AcquireStoreReaderLock();
		}

		public IDisposable AcquireSubscriptionWriterLock(SubscriptionState subState)
		{
			subState.Invalidate();
			return AcquireStoreWriterLock();
		}

		public IDisposable AcquireStoreReaderLock()
		{
			return AcquireLock(SubscriptionStoreLock, writer: false);
		}

		public IDisposable AcquireStoreWriterLock()
		{
			return AcquireLock(SubscriptionStoreLock, writer: true);
		}

		public TempDirectory AcquireTempDirectory()
		{
			return new TempDirectory(_tempPath);
		}

		public TempFile AcquireTempFile(string suffix)
		{
			return new TempFile(_tempPath, suffix);
		}

		internal ulong GetPrivateSize(DefinitionAppId appId)
		{
			ArrayList arrayList = new ArrayList();
			arrayList.Add(appId);
			using (AcquireStoreReaderLock())
			{
				return _compStore.GetPrivateSize(arrayList);
			}
		}

		internal ulong GetSharedSize(DefinitionAppId appId)
		{
			ArrayList arrayList = new ArrayList();
			arrayList.Add(appId);
			using (AcquireStoreReaderLock())
			{
				return _compStore.GetSharedSize(arrayList);
			}
		}

		internal ulong GetOnlineAppQuotaInBytes()
		{
			return _compStore.GetOnlineAppQuotaInBytes();
		}

		internal ulong GetSizeLimitInBytesForSemiTrustApps()
		{
			ulong onlineAppQuotaInBytes = GetOnlineAppQuotaInBytes();
			return onlineAppQuotaInBytes / 2uL;
		}

		internal System.Deployment.Internal.Isolation.Store.IPathLock LockApplicationPath(DefinitionAppId definitionAppId)
		{
			using (AcquireStoreReaderLock())
			{
				return _compStore.LockApplicationPath(definitionAppId);
			}
		}

		private static void CheckOnlineShellVisibleConflict(SubscriptionState subState, AssemblyManifest deployment)
		{
			if (!deployment.Deployment.Install && subState.IsShellVisible)
			{
				throw new DeploymentException(ExceptionTypes.SubscriptionState, Resources.GetString("Ex_OnlineAlreadyShellVisible"));
			}
		}

		private static void CheckInstalledAndUpdateableConflict(SubscriptionState subState, AssemblyManifest deployment)
		{
		}

		private static void CheckMinimumRequiredVersion(SubscriptionState subState, AssemblyManifest deployment)
		{
			if (subState.MinimumRequiredVersion != null)
			{
				if (deployment.Identity.Version < subState.MinimumRequiredVersion)
				{
					throw new DeploymentException(ExceptionTypes.SubscriptionState, Resources.GetString("Ex_DeploymentBelowMinimumRequiredVersion"));
				}
				if (deployment.Deployment.MinimumRequiredVersion != null && deployment.Deployment.MinimumRequiredVersion < subState.MinimumRequiredVersion)
				{
					throw new DeploymentException(ExceptionTypes.SubscriptionState, Resources.GetString("Ex_DecreasingMinimumRequiredVersion"));
				}
			}
		}

		private void CheckApplicationPayload(CommitApplicationParams commitParams)
		{
			if (commitParams.AppGroup == null && commitParams.appType != AppType.CustomHostSpecified)
			{
				string path = Path.Combine(commitParams.AppPayloadPath, commitParams.AppManifest.EntryPoints[0].CommandFile);
				if (!PlatformDetector.IsWin8orLater())
				{
					SystemUtils.CheckSupportedImageAndCLRVersions(path);
				}
			}
			string text = null;
			System.Deployment.Internal.Isolation.Store.IPathLock pathLock = null;
			try
			{
				pathLock = _compStore.LockAssemblyPath(commitParams.AppManifest.Identity);
				text = Path.GetDirectoryName(pathLock.Path);
				text = Path.Combine(text, "manifests");
				text = Path.Combine(text, Path.GetFileName(pathLock.Path) + ".manifest");
			}
			catch (DeploymentException)
			{
			}
			catch (COMException)
			{
			}
			finally
			{
				pathLock?.Dispose();
			}
			if (string.IsNullOrEmpty(text) || !System.IO.File.Exists(text) || string.IsNullOrEmpty(commitParams.AppManifestPath) || !System.IO.File.Exists(commitParams.AppManifestPath))
			{
				return;
			}
			byte[] array = ComponentVerifier.GenerateDigestValue(text, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA1, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM.CMS_HASH_TRANSFORM_IDENTITY);
			byte[] array2 = ComponentVerifier.GenerateDigestValue(commitParams.AppManifestPath, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA1, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM.CMS_HASH_TRANSFORM_IDENTITY);
			bool flag = false;
			Logger.AddInternalState("In-place update check. Existing manifest path = " + text + ", Existing manifest hash=" + Encoding.UTF8.GetString(array) + ", New manifest path=" + commitParams.AppManifestPath + ", New manifest hash=" + Encoding.UTF8.GetString(array2));
			if (array.Length == array2.Length)
			{
				int i;
				for (i = 0; i < array.Length && array[i] == array2[i]; i++)
				{
				}
				if (i >= array.Length)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				throw new DeploymentException(ExceptionTypes.Subscription, Resources.GetString("Ex_ApplicationInplaceUpdate"));
			}
		}

		private void UpdateSubscriptionExposure(SubscriptionState subState)
		{
			CheckInstalledAndShellVisible(subState);
			ShellExposure.UpdateSubscriptionShellExposure(subState);
		}

		private static void RemoveSubscriptionExposure(SubscriptionState subState)
		{
			ShellExposure.RemoveSubscriptionShellExposure(subState);
		}

		private bool IsAssemblyInstalled(DefinitionIdentity asmId)
		{
			using (AcquireStoreReaderLock())
			{
				return _compStore.IsAssemblyInstalled(asmId);
			}
		}

		private IDisposable AcquireLock(DefinitionIdentity asmId, bool writer)
		{
			string keyForm = asmId.KeyForm;
			Directory.CreateDirectory(_deployPath);
			return LockedFile.AcquireLock(Path.Combine(_deployPath, keyForm), Constants.LockTimeout, writer);
		}

		private static void OnDeploymentAdded(SubscriptionState subState)
		{
		}

		private static void OnDeploymentRemoved(SubscriptionState subState)
		{
		}
	}
	internal enum AppType
	{
		None,
		Installed,
		Online,
		CustomHostSpecified,
		CustomUX
	}
	internal class CommitApplicationParams
	{
		public DefinitionAppId AppId;

		public bool CommitApp;

		public AssemblyManifest AppManifest;

		public Uri AppSourceUri;

		public string AppManifestPath;

		public string AppPayloadPath;

		public string AppGroup;

		public bool CommitDeploy;

		public AssemblyManifest DeployManifest;

		public Uri DeploySourceUri;

		public string DeployManifestPath;

		public DateTime TimeStamp = DateTime.MinValue;

		public bool IsConfirmed;

		public bool IsUpdate;

		public bool IsRequiredUpdate;

		public bool IsUpdateInPKTGroup;

		public bool IsFullTrustRequested;

		public AppType appType;

		public System.Security.Policy.ApplicationTrust Trust;

		public Description EffectiveDescription
		{
			get
			{
				if (AppManifest != null && AppManifest.UseManifestForTrust)
				{
					return AppManifest.Description;
				}
				if (DeployManifest == null)
				{
					return null;
				}
				return DeployManifest.Description;
			}
		}

		public string EffectiveCertificatePublicKeyToken
		{
			get
			{
				if (AppManifest != null && AppManifest.UseManifestForTrust)
				{
					return AppManifest.Identity.PublicKeyToken;
				}
				if (DeployManifest == null)
				{
					return null;
				}
				return DeployManifest.Identity.PublicKeyToken;
			}
		}

		public CommitApplicationParams()
		{
		}

		public CommitApplicationParams(CommitApplicationParams src)
		{
			AppId = src.AppId;
			CommitApp = src.CommitApp;
			AppManifest = src.AppManifest;
			AppSourceUri = src.AppSourceUri;
			AppManifestPath = src.AppManifestPath;
			AppPayloadPath = src.AppPayloadPath;
			AppGroup = src.AppGroup;
			CommitDeploy = src.CommitDeploy;
			DeployManifest = src.DeployManifest;
			DeploySourceUri = src.DeploySourceUri;
			DeployManifestPath = src.DeployManifestPath;
			TimeStamp = src.TimeStamp;
			IsConfirmed = src.IsConfirmed;
			IsUpdate = src.IsUpdate;
			IsRequiredUpdate = src.IsRequiredUpdate;
			IsUpdateInPKTGroup = src.IsUpdateInPKTGroup;
			IsFullTrustRequested = src.IsFullTrustRequested;
			appType = src.appType;
			Trust = src.Trust;
		}
	}
	internal class SystemNetDownloader : FileDownloader
	{
		private static Stream GetOutputFileStream(string targetPath)
		{
			return new FileStream(targetPath, FileMode.CreateNew, FileAccess.Write, FileShare.Read);
		}

		private WebRequest CreateWebRequest(Uri uri)
		{
			WebRequest webRequest = WebRequest.Create(uri);
			SecurityZone securityZone = Zone.CreateFromUrl(uri.AbsoluteUri).SecurityZone;
			bool flag = securityZone == SecurityZone.Intranet || securityZone == SecurityZone.Trusted || securityZone == SecurityZone.MyComputer;
			if (flag)
			{
				Logger.AddInternalState($"Adding credentials to the {webRequest.GetType().Name} because we trust {securityZone} zone.");
				webRequest.Credentials = CredentialCache.DefaultCredentials;
			}
			else
			{
				Logger.AddInternalState($"We don't trust {uri.AbsoluteUri} because it's in {securityZone} zone.");
			}
			RequestCachePolicy requestCachePolicy2 = (webRequest.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache));
			if (webRequest is HttpWebRequest httpWebRequest)
			{
				httpWebRequest.UnsafeAuthenticatedConnectionSharing = true;
				httpWebRequest.AutomaticDecompression = DecompressionMethods.GZip;
				httpWebRequest.CookieContainer = GetUriCookieContainer(httpWebRequest.RequestUri);
				IWebProxy defaultWebProxy = WebRequest.DefaultWebProxy;
				if (defaultWebProxy != null && flag)
				{
					Logger.AddInternalState($"Adding credentials to proxy because we trust {securityZone} zone.");
					defaultWebProxy.Credentials = CredentialCache.DefaultCredentials;
				}
				Logger.AddInternalState("HttpWebRequest=" + Logger.Serialize(httpWebRequest));
			}
			return webRequest;
		}

		protected void DownloadSingleFile(DownloadQueueItem next)
		{
			Logger.AddMethodCall("DownloadSingleFile called");
			Logger.AddInternalState("DownloadQueueItem : " + ((next != null) ? next.ToString() : "null"));
			WebRequest webRequest = CreateWebRequest(next._sourceUri);
			if (_fCancelPending)
			{
				return;
			}
			WebResponse webResponse = null;
			try
			{
				if (base.ClientCertificate == null)
				{
					try
					{
						webResponse = webRequest.GetResponse();
					}
					catch (WebException ex)
					{
						if (!(ex.Response is HttpWebResponse httpWebResponse))
						{
							throw;
						}
						switch (httpWebResponse.StatusCode)
						{
						case HttpStatusCode.Forbidden:
							base.ClientCertificate = GetClientCertificate();
							if (base.ClientCertificate == null)
							{
								throw;
							}
							webRequest = CreateWebRequest(next._sourceUri);
							goto end_IL_0058;
						case HttpStatusCode.Unauthorized:
							try
							{
								string text = httpWebResponse.Headers[HttpResponseHeader.WwwAuthenticate];
								if (!string.IsNullOrEmpty(text))
								{
									Logger.AddInternalState("Server requires " + text + " authentication method.");
								}
							}
							catch
							{
							}
							break;
						}
						throw;
						end_IL_0058:;
					}
				}
				if (base.ClientCertificate != null)
				{
					if (webRequest is HttpWebRequest httpWebRequest)
					{
						httpWebRequest.ClientCertificates.Add(base.ClientCertificate);
					}
					webResponse = webRequest.GetResponse();
				}
				UriHelper.ValidateSupportedScheme(webResponse.ResponseUri);
				if (_fCancelPending)
				{
					return;
				}
				_eventArgs._fileSourceUri = next._sourceUri;
				_eventArgs._fileResponseUri = webResponse.ResponseUri;
				_eventArgs.FileLocalPath = next._targetPath;
				_eventArgs.Cookie = null;
				if (webResponse.ContentLength > 0)
				{
					CheckForSizeLimit((ulong)webResponse.ContentLength, addToSize: false);
					_accumulatedBytesTotal += webResponse.ContentLength;
				}
				SetBytesTotal();
				OnModified();
				Stream stream = null;
				Stream stream2 = null;
				int lastTick = Environment.TickCount;
				try
				{
					stream = webResponse.GetResponseStream();
					Directory.CreateDirectory(Path.GetDirectoryName(next._targetPath));
					stream2 = GetOutputFileStream(next._targetPath);
					if (stream2 != null)
					{
						long num = 0L;
						if (webResponse.ContentLength > 0)
						{
							stream2.SetLength(webResponse.ContentLength);
						}
						int num2;
						do
						{
							if (_fCancelPending)
							{
								return;
							}
							num2 = stream.Read(_buffer, 0, _buffer.Length);
							if (num2 > 0)
							{
								stream2.Write(_buffer, 0, num2);
							}
							_eventArgs._bytesCompleted += num2;
							if (webResponse.ContentLength <= 0)
							{
								_accumulatedBytesTotal += num2;
								SetBytesTotal();
							}
							num += num2;
							if (next._maxFileSize != -1 && num > next._maxFileSize)
							{
								throw new InvalidDeploymentException(ExceptionTypes.FileSizeValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileBeingDownloadedTooLarge"), new object[2]
								{
									next._sourceUri.ToString(),
									next._maxFileSize
								}));
							}
							CheckForSizeLimit((ulong)num2, addToSize: true);
							if (_eventArgs._bytesTotal > 0)
							{
								_eventArgs._progress = (int)(_eventArgs._bytesCompleted * 100 / _eventArgs._bytesTotal);
							}
							OnModifiedWithThrottle(ref lastTick);
						}
						while (num2 > 0);
						if (webResponse.ContentLength != num)
						{
							stream2.SetLength(num);
						}
					}
				}
				finally
				{
					stream?.Close();
					stream2?.Close();
				}
				_eventArgs.Cookie = next._cookie;
				_eventArgs._filesCompleted++;
				Logger.AddInternalState("HttpWebResponse=" + Logger.Serialize(webResponse));
				OnModified();
				DownloadResult downloadResult = new DownloadResult();
				downloadResult.ResponseUri = webResponse.ResponseUri;
				downloadResult.ServerInformation.Server = webResponse.Headers["Server"];
				downloadResult.ServerInformation.PoweredBy = webResponse.Headers["X-Powered-By"];
				downloadResult.ServerInformation.AspNetVersion = webResponse.Headers["X-AspNet-Version"];
				_downloadResults.Add(downloadResult);
			}
			catch (InvalidOperationException innerException)
			{
				string message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FailedWhileDownloading"), new object[1] { next._sourceUri });
				throw new DeploymentDownloadException(message, innerException);
			}
			catch (IOException innerException2)
			{
				string message2 = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FailedWhileDownloading"), new object[1] { next._sourceUri });
				throw new DeploymentDownloadException(message2, innerException2);
			}
			catch (UnauthorizedAccessException innerException3)
			{
				string message3 = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FailedWhileDownloading"), new object[1] { next._sourceUri });
				throw new DeploymentDownloadException(message3, innerException3);
			}
			finally
			{
				webResponse?.Close();
			}
		}

		private X509Certificate2 GetClientCertificate()
		{
			X509Certificate2 result = null;
			X509Store x509Store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
			x509Store.Open(OpenFlags.OpenExistingOnly);
			X509Certificate2Collection certificates = x509Store.Certificates;
			X509Certificate2Collection certificates2 = certificates.Find(X509FindType.FindByApplicationPolicy, "1.3.6.1.5.5.7.3.2", validOnly: false);
			X509Certificate2Collection x509Certificate2Collection = X509Certificate2UI.SelectFromCollection(certificates2, null, null, X509SelectionFlag.SingleSelection);
			if (x509Certificate2Collection.Count > 0)
			{
				result = x509Certificate2Collection[0];
			}
			return result;
		}

		protected override void DownloadAllFiles()
		{
			if (ServicePointManager.SecurityProtocol != (ServicePointManager.SecurityProtocol | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12))
			{
				Logger.AddInternalState(" Current TLS Protocol = " + ServicePointManager.SecurityProtocol);
				ServicePointManager.SecurityProtocol = ServicePointManager.SecurityProtocol | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12;
				Logger.AddInternalState($" Default TLS protocol is changed to = {ServicePointManager.SecurityProtocol.ToString()} with implicit fallback ");
			}
			do
			{
				DownloadQueueItem downloadQueueItem = null;
				lock (_fileQueue)
				{
					if (_fileQueue.Count > 0)
					{
						downloadQueueItem = (DownloadQueueItem)_fileQueue.Dequeue();
					}
				}
				if (downloadQueueItem == null)
				{
					break;
				}
				DownloadSingleFile(downloadQueueItem);
			}
			while (!_fCancelPending);
			if (_fCancelPending)
			{
				throw new DownloadCancelledException();
			}
		}

		private static CookieContainer GetUriCookieContainer(Uri uri)
		{
			CookieContainer result = null;
			uint bytes = 0u;
			if (NativeMethods.InternetGetCookieW(uri.ToString(), null, null, ref bytes))
			{
				StringBuilder stringBuilder = new StringBuilder((int)(bytes / 2u));
				if (NativeMethods.InternetGetCookieW(uri.ToString(), null, stringBuilder, ref bytes) && stringBuilder.Length > 0)
				{
					try
					{
						result = new CookieContainer();
						result.SetCookies(uri, stringBuilder.ToString().Replace(';', ','));
						return result;
					}
					catch (CookieException)
					{
						return null;
					}
				}
			}
			return result;
		}
	}
	internal class TempDirectory : DisposableBase
	{
		private string _thePath;

		private const uint _directorySegmentCount = 2u;

		public string Path => _thePath;

		public TempDirectory()
			: this(System.IO.Path.GetTempPath())
		{
		}

		public TempDirectory(string basePath)
		{
			do
			{
				_thePath = System.IO.Path.Combine(basePath, PathHelper.GenerateRandomPath(2u));
			}
			while (Directory.Exists(_thePath) || System.IO.File.Exists(_thePath));
			Directory.CreateDirectory(_thePath);
		}

		protected override void DisposeUnmanagedResources()
		{
			string rootSegmentPath = PathHelper.GetRootSegmentPath(_thePath, 2u);
			for (int i = 0; i < 2; i++)
			{
				if (!Directory.Exists(rootSegmentPath))
				{
					break;
				}
				try
				{
					Directory.Delete(rootSegmentPath, recursive: true);
					break;
				}
				catch (IOException)
				{
				}
				catch (UnauthorizedAccessException)
				{
				}
				Thread.Sleep(10);
			}
		}
	}
	internal class TempFile : DisposableBase
	{
		private string _thePath;

		private const uint _filePathSegmentCount = 2u;

		public string Path => _thePath;

		public TempFile()
			: this(System.IO.Path.GetTempPath())
		{
		}

		public TempFile(string basePath)
			: this(basePath, string.Empty)
		{
		}

		public TempFile(string basePath, string suffix)
		{
			do
			{
				_thePath = System.IO.Path.Combine(basePath, PathHelper.GenerateRandomPath(2u) + suffix);
			}
			while (System.IO.File.Exists(_thePath) || Directory.Exists(_thePath));
			string directoryName = System.IO.Path.GetDirectoryName(_thePath);
			Directory.CreateDirectory(directoryName);
		}

		protected override void DisposeUnmanagedResources()
		{
			string rootSegmentPath = PathHelper.GetRootSegmentPath(_thePath, 2u);
			if (!Directory.Exists(rootSegmentPath))
			{
				return;
			}
			try
			{
				Directory.Delete(rootSegmentPath, recursive: true);
			}
			catch (IOException)
			{
				Thread.Sleep(10);
				try
				{
					Directory.Delete(rootSegmentPath, recursive: true);
				}
				catch (IOException)
				{
				}
			}
		}
	}
	internal class UpdatePiece : ModalPiece
	{
		private Label lblHeader;

		private Label lblSubHeader;

		private PictureBox pictureDesktop;

		private Label lblApplication;

		private LinkLabel linkAppId;

		private Label lblFrom;

		private Label lblFromId;

		private GroupBox groupRule;

		private GroupBox groupDivider;

		private Button btnOk;

		private Button btnSkip;

		private TableLayoutPanel contentTableLayoutPanel;

		private TableLayoutPanel descriptionTableLayoutPanel;

		private TableLayoutPanel okSkipTableLayoutPanel;

		private TableLayoutPanel overarchingTableLayoutPanel;

		private UserInterfaceInfo _info;

		public UpdatePiece(UserInterfaceForm parentForm, UserInterfaceInfo info, ManualResetEvent modalEvent)
		{
			_info = info;
			_modalEvent = modalEvent;
			_modalResult = UserInterfaceModalResult.Cancel;
			SuspendLayout();
			InitializeComponent();
			InitializeContent();
			ResumeLayout(performLayout: false);
			parentForm.SuspendLayout();
			parentForm.SwitchUserInterfacePiece(this);
			parentForm.Text = _info.formTitle;
			parentForm.MinimizeBox = false;
			parentForm.MaximizeBox = false;
			parentForm.ControlBox = true;
			lblHeader.Font = new Font(lblHeader.Font, lblHeader.Font.Style | FontStyle.Bold);
			linkAppId.Font = new Font(linkAppId.Font, linkAppId.Font.Style | FontStyle.Bold);
			lblFromId.Font = new Font(lblFromId.Font, lblFromId.Font.Style | FontStyle.Bold);
			parentForm.ActiveControl = btnOk;
			parentForm.ResumeLayout(performLayout: false);
			parentForm.PerformLayout();
			parentForm.Visible = true;
		}

		private void InitializeComponent()
		{
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(System.Deployment.Application.UpdatePiece));
			this.descriptionTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.pictureDesktop = new System.Windows.Forms.PictureBox();
			this.lblSubHeader = new System.Windows.Forms.Label();
			this.lblHeader = new System.Windows.Forms.Label();
			this.lblApplication = new System.Windows.Forms.Label();
			this.linkAppId = new System.Windows.Forms.LinkLabel();
			this.lblFrom = new System.Windows.Forms.Label();
			this.lblFromId = new System.Windows.Forms.Label();
			this.groupRule = new System.Windows.Forms.GroupBox();
			this.groupDivider = new System.Windows.Forms.GroupBox();
			this.btnOk = new System.Windows.Forms.Button();
			this.btnSkip = new System.Windows.Forms.Button();
			this.contentTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.okSkipTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.overarchingTableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
			this.descriptionTableLayoutPanel.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)this.pictureDesktop).BeginInit();
			this.contentTableLayoutPanel.SuspendLayout();
			this.okSkipTableLayoutPanel.SuspendLayout();
			this.overarchingTableLayoutPanel.SuspendLayout();
			base.SuspendLayout();
			resources.ApplyResources(this.descriptionTableLayoutPanel, "descriptionTableLayoutPanel");
			this.descriptionTableLayoutPanel.BackColor = System.Drawing.SystemColors.Window;
			this.descriptionTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.AutoSize));
			this.descriptionTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.AutoSize));
			this.descriptionTableLayoutPanel.Controls.Add(this.pictureDesktop, 1, 0);
			this.descriptionTableLayoutPanel.Controls.Add(this.lblSubHeader, 0, 1);
			this.descriptionTableLayoutPanel.Controls.Add(this.lblHeader, 0, 0);
			this.descriptionTableLayoutPanel.Margin = new System.Windows.Forms.Padding(0);
			this.descriptionTableLayoutPanel.Name = "descriptionTableLayoutPanel";
			this.descriptionTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.descriptionTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			resources.ApplyResources(this.pictureDesktop, "pictureDesktop");
			this.pictureDesktop.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			this.pictureDesktop.Name = "pictureDesktop";
			this.descriptionTableLayoutPanel.SetRowSpan(this.pictureDesktop, 2);
			this.pictureDesktop.TabStop = false;
			this.pictureDesktop.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			resources.ApplyResources(this.lblSubHeader, "lblSubHeader");
			this.lblSubHeader.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits29, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits8);
			this.lblSubHeader.Name = "lblSubHeader";
			resources.ApplyResources(this.lblHeader, "lblHeader");
			this.lblHeader.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits11, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			this.lblHeader.Name = "lblHeader";
			resources.ApplyResources(this.lblApplication, "lblApplication");
			this.lblApplication.Margin = new System.Windows.Forms.Padding(0, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3);
			this.lblApplication.Name = "lblApplication";
			resources.ApplyResources(this.linkAppId, "linkAppId");
			this.linkAppId.AutoEllipsis = true;
			this.linkAppId.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3);
			this.linkAppId.Name = "linkAppId";
			this.linkAppId.TabStop = true;
			this.linkAppId.UseMnemonic = false;
			this.linkAppId.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(linkAppId_LinkClicked);
			resources.ApplyResources(this.lblFrom, "lblFrom");
			this.lblFrom.Margin = new System.Windows.Forms.Padding(0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			this.lblFrom.Name = "lblFrom";
			resources.ApplyResources(this.lblFromId, "lblFromId");
			this.lblFromId.AutoEllipsis = true;
			this.lblFromId.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0, 0);
			this.lblFromId.Name = "lblFromId";
			this.lblFromId.UseMnemonic = false;
			resources.ApplyResources(this.groupRule, "groupRule");
			this.groupRule.Margin = new System.Windows.Forms.Padding(0, 0, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3);
			this.groupRule.BackColor = System.Drawing.SystemColors.ControlDark;
			this.groupRule.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
			this.groupRule.Name = "groupRule";
			this.groupRule.TabStop = false;
			resources.ApplyResources(this.groupDivider, "groupDivider");
			this.groupDivider.Margin = new System.Windows.Forms.Padding(0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3);
			this.groupDivider.BackColor = System.Drawing.SystemColors.ControlDark;
			this.groupDivider.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
			this.groupDivider.Name = "groupDivider";
			this.groupDivider.TabStop = false;
			resources.ApplyResources(this.btnOk, "btnOk");
			this.btnOk.Margin = new System.Windows.Forms.Padding(0, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0);
			this.btnOk.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeWidth, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeHeight);
			this.btnOk.Name = "btnOk";
			this.btnOk.Padding = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, 0);
			this.btnOk.Click += new System.EventHandler(btnOk_Click);
			resources.ApplyResources(this.btnSkip, "btnSkip");
			this.btnSkip.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits3, 0, 0, 0);
			this.btnSkip.MinimumSize = new System.Drawing.Size(System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeWidth, System.Deployment.Application.ClickOnceConstants.DpiScaledMinimumButtonSizeHeight);
			this.btnSkip.Name = "btnSkip";
			this.btnSkip.Padding = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, 0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits10, 0);
			this.btnSkip.Click += new System.EventHandler(btnSkip_Click);
			resources.ApplyResources(this.contentTableLayoutPanel, "contentTableLayoutPanel");
			this.contentTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
			this.contentTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50f));
			this.contentTableLayoutPanel.Controls.Add(this.lblApplication, 0, 0);
			this.contentTableLayoutPanel.Controls.Add(this.lblFrom, 0, 1);
			this.contentTableLayoutPanel.Controls.Add(this.linkAppId, 1, 0);
			this.contentTableLayoutPanel.Controls.Add(this.lblFromId, 1, 1);
			this.contentTableLayoutPanel.Margin = new System.Windows.Forms.Padding(System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits20, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits15, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits12, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits18);
			this.contentTableLayoutPanel.Name = "contentTableLayoutPanel";
			this.contentTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.contentTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			resources.ApplyResources(this.okSkipTableLayoutPanel, "okSkipTableLayoutPanel");
			this.okSkipTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50f));
			this.okSkipTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50f));
			this.okSkipTableLayoutPanel.Controls.Add(this.btnOk, 0, 0);
			this.okSkipTableLayoutPanel.Controls.Add(this.btnSkip, 1, 0);
			this.okSkipTableLayoutPanel.Margin = new System.Windows.Forms.Padding(0, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits7, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits8, System.Deployment.Application.ClickOnceConstants.DpiScaledPaddingUnits6);
			this.okSkipTableLayoutPanel.Name = "okSkipTableLayoutPanel";
			this.okSkipTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50f));
			resources.ApplyResources(this.overarchingTableLayoutPanel, "overarchingTableLayoutPanel");
			this.overarchingTableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100f));
			this.overarchingTableLayoutPanel.Controls.Add(this.descriptionTableLayoutPanel, 0, 0);
			this.overarchingTableLayoutPanel.Controls.Add(this.okSkipTableLayoutPanel, 0, 4);
			this.overarchingTableLayoutPanel.Controls.Add(this.contentTableLayoutPanel, 0, 2);
			this.overarchingTableLayoutPanel.Controls.Add(this.groupRule, 0, 1);
			this.overarchingTableLayoutPanel.Controls.Add(this.groupDivider, 0, 3);
			this.overarchingTableLayoutPanel.Margin = new System.Windows.Forms.Padding(0);
			this.overarchingTableLayoutPanel.Name = "overarchingTableLayoutPanel";
			this.overarchingTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.overarchingTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.overarchingTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.overarchingTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			this.overarchingTableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle());
			if (System.AccessibilityImprovements.Level3)
			{
				this.pictureDesktop.AccessibleName = System.Deployment.Application.Resources.GetString("ClickOnceGlobeIcon");
				this.pictureDesktop.AccessibleRole = System.Windows.Forms.AccessibleRole.Graphic;
				this.descriptionTableLayoutPanel.AccessibleName = string.Empty;
				this.contentTableLayoutPanel.AccessibleName = string.Empty;
				this.okSkipTableLayoutPanel.AccessibleName = string.Empty;
				string text2 = (this.groupRule.AccessibleName = (this.groupDivider.AccessibleName = string.Empty));
				System.Windows.Forms.AccessibleRole accessibleRole3 = (this.groupRule.AccessibleRole = (this.groupDivider.AccessibleRole = System.Windows.Forms.AccessibleRole.Separator));
				this.descriptionTableLayoutPanel.Controls.SetChildIndex(this.lblHeader, 0);
				this.descriptionTableLayoutPanel.Controls.SetChildIndex(this.lblSubHeader, 1);
				this.descriptionTableLayoutPanel.Controls.SetChildIndex(this.pictureDesktop, 2);
				this.contentTableLayoutPanel.Controls.SetChildIndex(this.lblApplication, 0);
				this.contentTableLayoutPanel.Controls.SetChildIndex(this.linkAppId, 1);
				this.contentTableLayoutPanel.Controls.SetChildIndex(this.lblFrom, 2);
				this.contentTableLayoutPanel.Controls.SetChildIndex(this.lblFromId, 3);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.descriptionTableLayoutPanel, 0);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.groupRule, 1);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.contentTableLayoutPanel, 2);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.groupDivider, 3);
				this.overarchingTableLayoutPanel.Controls.SetChildIndex(this.okSkipTableLayoutPanel, 4);
			}
			resources.ApplyResources(this, "$this");
			base.Controls.Add(this.overarchingTableLayoutPanel);
			base.Name = "UpdatePiece";
			this.descriptionTableLayoutPanel.ResumeLayout(false);
			this.descriptionTableLayoutPanel.PerformLayout();
			((System.ComponentModel.ISupportInitialize)this.pictureDesktop).EndInit();
			this.contentTableLayoutPanel.ResumeLayout(false);
			this.contentTableLayoutPanel.PerformLayout();
			this.okSkipTableLayoutPanel.ResumeLayout(false);
			this.okSkipTableLayoutPanel.PerformLayout();
			this.overarchingTableLayoutPanel.ResumeLayout(false);
			this.overarchingTableLayoutPanel.PerformLayout();
			base.ResumeLayout(false);
			base.PerformLayout();
		}

		private void InitializeContent()
		{
			pictureDesktop.Image = Resources.GetIcon("form.ico").ToBitmap();
			lblSubHeader.Text = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("UI_UpdateSubHeader"), new object[1] { UserInterface.LimitDisplayTextLength(_info.productName) });
			linkAppId.Text = _info.productName;
			linkAppId.Links.Clear();
			if (UserInterface.IsValidHttpUrl(_info.supportUrl))
			{
				linkAppId.Links.Add(0, _info.productName.Length, _info.supportUrl);
			}
			lblFromId.Text = _info.sourceSite;
		}

		private void linkAppId_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			linkAppId.LinkVisited = true;
			UserInterface.LaunchUrlInBrowser(e.Link.LinkData.ToString());
		}

		private void btnOk_Click(object sender, EventArgs e)
		{
			_modalResult = UserInterfaceModalResult.Ok;
			_modalEvent.Set();
			base.Enabled = false;
		}

		private void btnSkip_Click(object sender, EventArgs e)
		{
			_modalResult = UserInterfaceModalResult.Skip;
			_modalEvent.Set();
			base.Enabled = false;
		}
	}
	internal static class UriHelper
	{
		private static object _invalidRelativePathChars;

		private static char[] _directorySeparators = new char[2]
		{
			Path.DirectorySeparatorChar,
			Path.AltDirectorySeparatorChar
		};

		private static char[] InvalidRelativePathChars
		{
			get
			{
				if (_invalidRelativePathChars == null)
				{
					char[] invalidPathChars = Path.GetInvalidPathChars();
					char[] array = new char[invalidPathChars.Length + 3];
					invalidPathChars.CopyTo(array, 0);
					int num = invalidPathChars.Length;
					array[num++] = Path.VolumeSeparatorChar;
					array[num++] = '*';
					array[num++] = '?';
					Interlocked.CompareExchange(ref _invalidRelativePathChars, array, null);
				}
				return (char[])_invalidRelativePathChars;
			}
		}

		public static void ValidateSupportedScheme(Uri uri)
		{
			if (!IsSupportedScheme(uri))
			{
				throw new InvalidDeploymentException(ExceptionTypes.UriSchemeNotSupported, Resources.GetString("Ex_NotSupportedUriScheme"));
			}
		}

		public static void ValidateSupportedSchemeInArgument(Uri uri, string argumentName)
		{
			if (!IsSupportedScheme(uri))
			{
				throw new ArgumentException(Resources.GetString("Ex_NotSupportedUriScheme"), argumentName);
			}
		}

		public static bool IsSupportedScheme(Uri uri)
		{
			if (!(uri.Scheme == Uri.UriSchemeFile) && !(uri.Scheme == Uri.UriSchemeHttp))
			{
				return uri.Scheme == Uri.UriSchemeHttps;
			}
			return true;
		}

		public static Uri UriFromRelativeFilePath(Uri baseUri, string path)
		{
			if (!IsValidRelativeFilePath(path))
			{
				throw new ArgumentException(Resources.GetString("Ex_InvalidRelativePath"));
			}
			if (path.IndexOf('%') >= 0)
			{
				path = path.Replace("%", Uri.HexEscape('%'));
			}
			if (path.IndexOf('#') >= 0)
			{
				path = path.Replace("#", Uri.HexEscape('#'));
			}
			Uri uri = new Uri(baseUri, path);
			ValidateSupportedScheme(uri);
			return uri;
		}

		public static bool IsValidRelativeFilePath(string path)
		{
			if (path == null || path.Length == 0 || path.IndexOfAny(InvalidRelativePathChars) >= 0)
			{
				return false;
			}
			if (Path.IsPathRooted(path))
			{
				return false;
			}
			string text = path.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
			string path2 = Path.Combine(Path.DirectorySeparatorChar.ToString(), text);
			string fullPath = Path.GetFullPath(path2);
			string pathRoot = Path.GetPathRoot(fullPath);
			string text2 = fullPath.Substring(pathRoot.Length);
			if (text2.Length > 0 && text2[0] == '\\')
			{
				text2 = text2.Substring(1);
			}
			if (string.Compare(text2, text, StringComparison.Ordinal) == 0)
			{
				return true;
			}
			return false;
		}

		public static string NormalizePathDirectorySeparators(string path)
		{
			return path?.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
		}

		public static bool PathContainDirectorySeparators(string path)
		{
			if (path == null)
			{
				return false;
			}
			return path.IndexOfAny(_directorySeparators) >= 0;
		}
	}
	internal class UserInterface : IDisposable
	{
		private UserInterfaceForm _uiForm;

		private ApplicationContext _appctx;

		private ManualResetEvent _appctxExitThreadFinished = new ManualResetEvent(initialState: false);

		private Thread _uiThread;

		private ManualResetEvent _uiConstructed = new ManualResetEvent(initialState: false);

		private ManualResetEvent _uiReady = new ManualResetEvent(initialState: false);

		private SplashInfo _splashInfo;

		private bool _disposed;

		private static string DefaultBrowserExePath
		{
			get
			{
				string result = null;
				RegistryKey registryKey = Registry.ClassesRoot.OpenSubKey("http\\shell\\open\\command");
				if (registryKey != null)
				{
					string text = (string)registryKey.GetValue(string.Empty);
					if (text != null)
					{
						text = text.Trim();
						if (text.Length != 0)
						{
							if (text[0] == '"')
							{
								int num = text.IndexOf('"', 1);
								if (num != -1)
								{
									result = text.Substring(1, num - 1);
								}
							}
							else
							{
								int num2 = text.IndexOf(' ');
								result = ((num2 == -1) ? text : text.Substring(0, num2));
							}
						}
					}
				}
				return result;
			}
		}

		public UserInterface(bool wait)
		{
			_splashInfo = new SplashInfo();
			_splashInfo.initializedAsWait = wait;
			_uiThread = new Thread(UIThread);
			_uiThread.SetApartmentState(ApartmentState.STA);
			_uiThread.Name = "UIThread";
			_uiThread.Start();
		}

		public UserInterface()
			: this(wait: true)
		{
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		public ProgressPiece ShowProgress(UserInterfaceInfo info)
		{
			WaitReady();
			return (ProgressPiece)_uiForm.Invoke(new UserInterfaceForm.ConstructProgressPieceDelegate(_uiForm.ConstructProgressPiece), info);
		}

		public UserInterfaceModalResult ShowUpdate(UserInterfaceInfo info)
		{
			WaitReady();
			ManualResetEvent manualResetEvent = new ManualResetEvent(initialState: false);
			UpdatePiece updatePiece = (UpdatePiece)_uiForm.Invoke(new UserInterfaceForm.ConstructUpdatePieceDelegate(_uiForm.ConstructUpdatePiece), info, manualResetEvent);
			manualResetEvent.WaitOne();
			return updatePiece.ModalResult;
		}

		public UserInterfaceModalResult ShowMaintenance(UserInterfaceInfo info, MaintenanceInfo maintenanceInfo)
		{
			WaitReady();
			ManualResetEvent manualResetEvent = new ManualResetEvent(initialState: false);
			MaintenancePiece maintenancePiece = (MaintenancePiece)_uiForm.Invoke(new UserInterfaceForm.ConstructMaintenancePieceDelegate(_uiForm.ConstructMaintenancePiece), info, maintenanceInfo, manualResetEvent);
			manualResetEvent.WaitOne();
			return maintenancePiece.ModalResult;
		}

		public void ShowMessage(string message, string caption)
		{
			WaitReady();
			_uiForm.Invoke(new UserInterfaceForm.ShowSimpleMessageBoxDelegate(_uiForm.ShowSimpleMessageBox), message, caption);
		}

		public void ShowPlatform(string platformDetectionErrorMsg, Uri supportUrl)
		{
			WaitReady();
			ManualResetEvent manualResetEvent = new ManualResetEvent(initialState: false);
			_uiForm.BeginInvoke(new UserInterfaceForm.ConstructPlatformPieceDelegate(_uiForm.ConstructPlatformPiece), platformDetectionErrorMsg, supportUrl, manualResetEvent);
			manualResetEvent.WaitOne();
		}

		public void ShowError(string title, string message, string logFileLocation, string linkUrl, string linkUrlMessage)
		{
			WaitReady();
			ManualResetEvent manualResetEvent = new ManualResetEvent(initialState: false);
			_uiForm.BeginInvoke(new UserInterfaceForm.ConstructErrorPieceDelegate(_uiForm.ConstructErrorPiece), title, message, logFileLocation, linkUrl, linkUrlMessage, manualResetEvent);
			manualResetEvent.WaitOne();
		}

		public void Hide()
		{
			WaitReady();
			_uiForm.BeginInvoke(new MethodInvoker(_uiForm.Hide));
		}

		public void Activate()
		{
			WaitReady();
			_uiForm.BeginInvoke(new MethodInvoker(_uiForm.Activate));
		}

		public bool SplashCancelled()
		{
			return _splashInfo.cancelled;
		}

		private void WaitReady()
		{
			_uiConstructed.WaitOne();
			_uiReady.WaitOne();
			_splashInfo.pieceReady.WaitOne();
		}

		private void UIThread()
		{
			System.Windows.Forms.Application.EnableVisualStyles();
			System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(defaultValue: false);
			using (_uiForm = new UserInterfaceForm(_uiReady, _splashInfo))
			{
				_uiConstructed.Set();
				_appctx = new ApplicationContext(_uiForm);
				System.Windows.Forms.Application.Run(_appctx);
				_appctxExitThreadFinished.WaitOne();
				System.Windows.Forms.Application.ExitThread();
			}
		}

		private void Dispose(bool disposing)
		{
			if (!_disposed)
			{
				if (disposing)
				{
					WaitReady();
					_appctx.ExitThread();
					_appctxExitThreadFinished.Set();
				}
				_disposed = true;
			}
		}

		public static string GetDisplaySite(Uri sourceUri)
		{
			string result = null;
			if (sourceUri.IsUnc)
			{
				try
				{
					result = Path.GetDirectoryName(sourceUri.LocalPath);
					return result;
				}
				catch (ArgumentException)
				{
					return result;
				}
			}
			result = sourceUri.Host;
			if (string.IsNullOrEmpty(result))
			{
				try
				{
					result = Path.GetDirectoryName(sourceUri.LocalPath);
					return result;
				}
				catch (ArgumentException)
				{
					return result;
				}
			}
			return result;
		}

		public static string LimitDisplayTextLength(string displayText)
		{
			if (displayText.Length > 50)
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(displayText, 0, 47);
				stringBuilder.Append("...");
				return stringBuilder.ToString();
			}
			return displayText;
		}

		public static bool IsValidHttpUrl(string url)
		{
			bool result = false;
			if (url != null && url.Length > 0 && (url.StartsWith(Uri.UriSchemeHttp + Uri.SchemeDelimiter, StringComparison.Ordinal) || url.StartsWith(Uri.UriSchemeHttps + Uri.SchemeDelimiter, StringComparison.Ordinal)))
			{
				result = true;
			}
			return result;
		}

		public static void LaunchUrlInBrowser(string url)
		{
			try
			{
				Process.Start(DefaultBrowserExePath, url);
			}
			catch (Win32Exception)
			{
			}
		}
	}
	internal class UserInterfaceForm : Form
	{
		public delegate ProgressPiece ConstructProgressPieceDelegate(UserInterfaceInfo info);

		public delegate UpdatePiece ConstructUpdatePieceDelegate(UserInterfaceInfo info, ManualResetEvent modalEvent);

		public delegate ErrorPiece ConstructErrorPieceDelegate(string title, string message, string logFileLocation, string linkUrl, string linkUrlMessage, ManualResetEvent modalEvent);

		public delegate PlatformPiece ConstructPlatformPieceDelegate(string platformDetectionErrorMsg, Uri supportUrl, ManualResetEvent modalEvent);

		public delegate MaintenancePiece ConstructMaintenancePieceDelegate(UserInterfaceInfo info, MaintenanceInfo maintenanceInfo, ManualResetEvent modalEvent);

		public delegate void ShowSimpleMessageBoxDelegate(string messsage, string caption);

		private FormPiece currentPiece;

		private SplashInfo splashPieceInfo;

		private ManualResetEvent onLoadEvent;

		public UserInterfaceForm(ManualResetEvent readyEvent, SplashInfo splashInfo)
		{
			onLoadEvent = readyEvent;
			splashPieceInfo = splashInfo;
			SuspendLayout();
			InitializeComponent();
			InitializeContent();
			ResumeLayout(performLayout: false);
			PerformLayout();
			Font = SystemFonts.MessageBoxFont;
		}

		public ProgressPiece ConstructProgressPiece(UserInterfaceInfo info)
		{
			return new ProgressPiece(this, info);
		}

		public UpdatePiece ConstructUpdatePiece(UserInterfaceInfo info, ManualResetEvent modalEvent)
		{
			return new UpdatePiece(this, info, modalEvent);
		}

		public ErrorPiece ConstructErrorPiece(string title, string message, string logFileLocation, string linkUrl, string linkUrlMessage, ManualResetEvent modalEvent)
		{
			return new ErrorPiece(this, title, message, logFileLocation, linkUrl, linkUrlMessage, modalEvent);
		}

		public PlatformPiece ConstructPlatformPiece(string platformDetectionErrorMsg, Uri supportUrl, ManualResetEvent modalEvent)
		{
			return new PlatformPiece(this, platformDetectionErrorMsg, supportUrl, modalEvent);
		}

		public MaintenancePiece ConstructMaintenancePiece(UserInterfaceInfo info, MaintenanceInfo maintenanceInfo, ManualResetEvent modalEvent)
		{
			return new MaintenancePiece(this, info, maintenanceInfo, modalEvent);
		}

		public void ShowSimpleMessageBox(string message, string caption)
		{
			MessageBoxOptions messageBoxOptions = (MessageBoxOptions)0;
			if (IsRightToLeft(this))
			{
				messageBoxOptions |= MessageBoxOptions.RightAlign | MessageBoxOptions.RtlReading;
			}
			MessageBox.Show(this, message, caption, MessageBoxButtons.OK, MessageBoxIcon.Asterisk, MessageBoxDefaultButton.Button1, messageBoxOptions);
		}

		public void SwitchUserInterfacePiece(FormPiece piece)
		{
			FormPiece formPiece = null;
			formPiece = currentPiece;
			currentPiece = piece;
			currentPiece.Dock = DockStyle.Fill;
			SuspendLayout();
			base.Controls.Add(currentPiece);
			if (formPiece != null)
			{
				base.Controls.Remove(formPiece);
				formPiece.Dispose();
			}
			base.ClientSize = currentPiece.ClientSize;
			ResumeLayout(performLayout: false);
			PerformLayout();
		}

		protected override void OnLoad(EventArgs e)
		{
			base.OnLoad(e);
			onLoadEvent.Set();
		}

		protected override void OnVisibleChanged(EventArgs e)
		{
			base.OnVisibleChanged(e);
			if (base.Visible && Form.ActiveForm != this)
			{
				Activate();
			}
		}

		protected override void OnClosing(CancelEventArgs e)
		{
			base.OnClosing(e);
			if (!currentPiece.OnClosing())
			{
				e.Cancel = true;
				return;
			}
			e.Cancel = true;
			Hide();
		}

		protected override void SetVisibleCore(bool value)
		{
			if (splashPieceInfo.initializedAsWait)
			{
				base.SetVisibleCore(value: false);
			}
			else
			{
				base.SetVisibleCore(value);
			}
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (disposing)
			{
				base.Icon.Dispose();
				base.Icon = null;
				if (currentPiece != null)
				{
					currentPiece.Dispose();
				}
			}
		}

		private void InitializeComponent()
		{
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(System.Deployment.Application.UserInterfaceForm));
			base.SuspendLayout();
			resources.ApplyResources(this, "$this");
			base.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			base.ControlBox = false;
			base.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			base.MaximizeBox = false;
			base.MinimizeBox = false;
			base.Name = "UserInterfaceForm";
			base.ShowIcon = false;
			if (System.Deployment.Application.Resources.GetString("RTL") != "RTL_False")
			{
				this.RightToLeft = System.Windows.Forms.RightToLeft.Yes;
				this.RightToLeftLayout = true;
			}
			base.ResumeLayout(false);
		}

		private void InitializeContent()
		{
			base.Icon = Resources.GetIcon("form.ico");
			currentPiece = new SplashPiece(this, splashPieceInfo);
			base.Controls.Add(currentPiece);
		}

		private bool IsRightToLeft(Control control)
		{
			if (control.RightToLeft == RightToLeft.Yes)
			{
				return true;
			}
			if (control.RightToLeft == RightToLeft.No)
			{
				return false;
			}
			if (control.RightToLeft == RightToLeft.Inherit && control.Parent != null)
			{
				return IsRightToLeft(control.Parent);
			}
			return false;
		}
	}
	internal enum UserInterfaceModalResult
	{
		Unknown,
		Ok,
		Cancel,
		Skip
	}
	internal static class ClickOnceConstants
	{
		private const int minimumButtonSizeWidth = 75;

		private const int minimumButtonSizeHeight = 23;

		private const int paddingUnits2 = 2;

		private const int paddingUnits3 = 3;

		private const int paddingUnits4 = 4;

		private const int paddingUnits6 = 6;

		private const int paddingUnits7 = 7;

		private const int paddingUnits8 = 8;

		private const int paddingUnits9 = 9;

		private const int paddingUnits10 = 10;

		private const int paddingUnits11 = 11;

		private const int paddingUnits12 = 12;

		private const int paddingUnits15 = 15;

		private const int paddingUnits18 = 18;

		private const int paddingUnits20 = 20;

		private const int paddingUnits22 = 22;

		private const int paddingUnits29 = 29;

		private const int minimumSizeUnits28 = 28;

		private const int minimumSizeUnits32 = 32;

		private const int minimumSizeUnits78 = 78;

		private const int minimumSizeUnits61 = 61;

		private const int minimumSizeUnits88 = 88;

		private const int minimumSizeUnits112 = 112;

		private const int minimumSizeUnits123 = 123;

		private const int minimumSizeUnits240 = 240;

		private const int minimumSizeUnits280 = 280;

		private const int minimumSizeUnits349 = 349;

		private const int minimumSizeUnits373 = 373;

		private const int minimumSizeUnits384 = 384;

		private const int minimumSizeUnits466 = 466;

		private const int minimumSizeUnits498 = 498;

		private const int minimumSizeUnits515 = 515;

		private static double scalingFactor = 1.0;

		private static bool areConstantsScaled = false;

		public const double LogicalDpi = 96.0;

		public static int DpiScaledMinimumButtonSizeWidth = 75;

		public static int DpiScaledMinimumButtonSizeHeight = 23;

		public static int DpiScaledPaddingUnits2 = 2;

		public static int DpiScaledPaddingUnits3 = 3;

		public static int DpiScaledPaddingUnits4 = 4;

		public static int DpiScaledPaddingUnits6 = 6;

		public static int DpiScaledPaddingUnits7 = 7;

		public static int DpiScaledPaddingUnits8 = 8;

		public static int DpiScaledPaddingUnits9 = 9;

		public static int DpiScaledPaddingUnits10 = 10;

		public static int DpiScaledPaddingUnits11 = 11;

		public static int DpiScaledPaddingUnits12 = 12;

		public static int DpiScaledPaddingUnits15 = 15;

		public static int DpiScaledPaddingUnits18 = 18;

		public static int DpiScaledPaddingUnits20 = 20;

		public static int DpiScaledPaddingUnits22 = 22;

		public static int DpiScaledPaddingUnits29 = 29;

		public static int DpiScaledMinimumSizeUnits28 = 28;

		public static int DpiScaledMinimumSizeUnits32 = 32;

		public static int DpiScaledMinimumSizeUnits78 = 78;

		public static int DpiScaledMinimumSizeUnits61 = 61;

		public static int DpiScaledMinimumSizeUnits88 = 88;

		public static int DpiScaledMinimumSizeUnits112 = 112;

		public static int DpiScaledMinimumSizeUnits123 = 123;

		public static int DpiScaledMinimumSizeUnits240 = 240;

		public static int DpiScaledMinimumSizeUnits280 = 280;

		public static int DpiScaledMinimumSizeUnits349 = 349;

		public static int DpiScaledMinimumSizeUnits373 = 373;

		public static int DpiScaledMinimumSizeUnits384 = 384;

		public static int DpiScaledMinimumSizeUnits466 = 466;

		public static int DpiScaledMinimumSizeUnits498 = 498;

		public static int DpiScaledMinimumSizeUnits515 = 515;

		public static void ScaleConstantsToMatchDpi(int deviceDpi)
		{
			if (!areConstantsScaled)
			{
				scalingFactor = (double)deviceDpi / 96.0;
				if (scalingFactor > 1.0 && !areConstantsScaled)
				{
					DpiScaledMinimumButtonSizeWidth = (int)Math.Round(scalingFactor * 75.0);
					DpiScaledMinimumButtonSizeHeight = (int)Math.Round(scalingFactor * 23.0);
					DpiScaledPaddingUnits2 = (int)Math.Round(scalingFactor * 2.0);
					DpiScaledPaddingUnits3 = (int)Math.Round(scalingFactor * 3.0);
					DpiScaledPaddingUnits4 = (int)Math.Round(scalingFactor * 4.0);
					DpiScaledPaddingUnits6 = (int)Math.Round(scalingFactor * 6.0);
					DpiScaledPaddingUnits7 = (int)Math.Round(scalingFactor * 7.0);
					DpiScaledPaddingUnits8 = (int)Math.Round(scalingFactor * 8.0);
					DpiScaledPaddingUnits9 = (int)Math.Round(scalingFactor * 9.0);
					DpiScaledPaddingUnits10 = (int)Math.Round(scalingFactor * 10.0);
					DpiScaledPaddingUnits11 = (int)Math.Round(scalingFactor * 11.0);
					DpiScaledPaddingUnits12 = (int)Math.Round(scalingFactor * 12.0);
					DpiScaledPaddingUnits20 = (int)Math.Round(scalingFactor * 20.0);
					DpiScaledPaddingUnits22 = (int)Math.Round(scalingFactor * 22.0);
					DpiScaledPaddingUnits29 = (int)Math.Round(scalingFactor * 29.0);
					DpiScaledMinimumSizeUnits28 = (int)Math.Round(scalingFactor * 28.0);
					DpiScaledMinimumSizeUnits32 = (int)Math.Round(scalingFactor * 32.0);
					DpiScaledMinimumSizeUnits78 = (int)Math.Round(scalingFactor * 78.0);
					DpiScaledMinimumSizeUnits61 = (int)Math.Round(scalingFactor * 61.0);
					DpiScaledMinimumSizeUnits88 = (int)Math.Round(scalingFactor * 88.0);
					DpiScaledMinimumSizeUnits112 = (int)Math.Round(scalingFactor * 112.0);
					DpiScaledMinimumSizeUnits123 = (int)Math.Round(scalingFactor * 123.0);
					DpiScaledMinimumSizeUnits240 = (int)Math.Round(scalingFactor * 240.0);
					DpiScaledMinimumSizeUnits280 = (int)Math.Round(scalingFactor * 280.0);
					DpiScaledMinimumSizeUnits349 = (int)Math.Round(scalingFactor * 349.0);
					DpiScaledMinimumSizeUnits373 = (int)Math.Round(scalingFactor * 373.0);
					DpiScaledMinimumSizeUnits384 = (int)Math.Round(scalingFactor * 384.0);
					DpiScaledMinimumSizeUnits466 = (int)Math.Round(scalingFactor * 466.0);
					DpiScaledMinimumSizeUnits498 = (int)Math.Round(scalingFactor * 498.0);
					DpiScaledMinimumSizeUnits515 = (int)Math.Round(scalingFactor * 515.0);
					areConstantsScaled = true;
				}
			}
		}
	}
	internal class FormPiece : Panel
	{
		public FormPiece()
		{
			ClickOnceConstants.ScaleConstantsToMatchDpi(base.DeviceDpi);
		}

		public virtual bool OnClosing()
		{
			return true;
		}
	}
	internal class ModalPiece : FormPiece
	{
		protected ManualResetEvent _modalEvent;

		protected UserInterfaceModalResult _modalResult;

		public UserInterfaceModalResult ModalResult => _modalResult;

		public override bool OnClosing()
		{
			bool result = base.OnClosing();
			_modalEvent.Set();
			return result;
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			_modalEvent.Set();
		}
	}
	internal class UserInterfaceInfo
	{
		public string formTitle;

		public string productName;

		public string sourceSite;

		public string supportUrl;

		public string iconFilePath;
	}
	internal class SplashInfo
	{
		public bool initializedAsWait = true;

		public ManualResetEvent pieceReady = new ManualResetEvent(initialState: true);

		public bool cancelled;
	}
	internal static class DFServiceEntryPoint
	{
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		internal delegate IManagedDeploymentServiceCom CreateDeploymentServiceComDelegate();

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate int RegisterDeploymentServiceComDelegate([MarshalAs(UnmanagedType.FunctionPtr)] CreateDeploymentServiceComDelegate createDeploymentServiceComDelegate);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate int UnregisterDeploymentServiceComDelegate();

		private class DfsvcForm : Form
		{
			public delegate void CloseFormDelegate(bool lifetimeManagerAlreadyTerminated);

			private Container components;

			private object _lock;

			private bool _lifetimeManagerTerminated;

			private bool _formClosed;

			public DfsvcForm()
			{
				_lock = new object();
				InitializeComponent();
			}

			protected override void Dispose(bool disposing)
			{
				if (disposing && components != null)
				{
					components.Dispose();
				}
				base.Dispose(disposing);
			}

			private void InitializeComponent()
			{
				base.ClientSize = new System.Drawing.Size(292, 266);
				base.ShowInTaskbar = false;
				base.WindowState = System.Windows.Forms.FormWindowState.Minimized;
				base.TopMost = true;
				base.Closing += new System.ComponentModel.CancelEventHandler(DfsvcForm_Closing);
				base.Closed += new System.EventHandler(DfsvcForm_Closed);
			}

			private void DfsvcForm_Closing(object sender, CancelEventArgs e)
			{
				e.Cancel = false;
				TerminateLifetimeManager(formAlreadyClosed: true);
			}

			private void DfsvcForm_Closed(object sender, EventArgs e)
			{
				TerminateLifetimeManager(formAlreadyClosed: true);
			}

			public void SessionEndedEventHandler(object sender, SessionEndedEventArgs e)
			{
				TerminateLifetimeManager(formAlreadyClosed: false);
			}

			public void SessionEndingEventHandler(object sender, SessionEndingEventArgs e)
			{
				e.Cancel = false;
				TerminateLifetimeManager(formAlreadyClosed: false);
			}

			public void CloseForm(bool lifetimeManagerAlreadyTerminated)
			{
				if (_formClosed)
				{
					return;
				}
				lock (_lock)
				{
					if (lifetimeManagerAlreadyTerminated)
					{
						_lifetimeManagerTerminated = true;
					}
					if (!_formClosed)
					{
						_formClosed = true;
						Close();
					}
				}
			}

			private void TerminateLifetimeManager(bool formAlreadyClosed)
			{
				if (_lifetimeManagerTerminated)
				{
					return;
				}
				lock (_lock)
				{
					if (formAlreadyClosed)
					{
						_formClosed = true;
					}
					if (!_lifetimeManagerTerminated)
					{
						_lifetimeManagerTerminated = true;
						LifetimeManager.EndImmediately();
					}
				}
			}
		}

		private static CreateDeploymentServiceComDelegate s_createDeploymentServiceComDelegate;

		private static RegisterDeploymentServiceComDelegate RegisterDeploymentServiceCom;

		private static UnregisterDeploymentServiceComDelegate UnregisterDeploymentServiceCom;

		private static IntPtr DfdllHandle;

		private static DfsvcForm _dfsvcForm;

		private static void MessageLoopThread()
		{
			if (_dfsvcForm == null)
			{
				_dfsvcForm = new DfsvcForm();
				SystemEvents.SessionEnded += _dfsvcForm.SessionEndedEventHandler;
				SystemEvents.SessionEnding += _dfsvcForm.SessionEndingEventHandler;
				System.Windows.Forms.Application.Run(_dfsvcForm);
			}
		}

		private static object GetMethodDelegate(IntPtr handle, string methodName, Type methodDelegateType)
		{
			IntPtr procAddress = NativeMethods.GetProcAddress(handle, methodName);
			if (procAddress == IntPtr.Zero)
			{
				throw new Win32Exception(Marshal.GetLastWin32Error());
			}
			return Marshal.GetDelegateForFunctionPointer(procAddress, methodDelegateType);
		}

		private static void ObtainDfdllExports()
		{
			DfdllHandle = NativeMethods.LoadLibrary(Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "dfdll.dll"));
			if (DfdllHandle == IntPtr.Zero)
			{
				throw new Win32Exception(Marshal.GetLastWin32Error());
			}
			RegisterDeploymentServiceCom = (RegisterDeploymentServiceComDelegate)GetMethodDelegate(DfdllHandle, "RegisterDeploymentServiceCom", typeof(RegisterDeploymentServiceComDelegate));
			UnregisterDeploymentServiceCom = (UnregisterDeploymentServiceComDelegate)GetMethodDelegate(DfdllHandle, "UnregisterDeploymentServiceCom", typeof(UnregisterDeploymentServiceComDelegate));
		}

		public static void Initialize(string[] args)
		{
			CodeMarker_Singleton.Instance.CodeMarker(523);
			if (PlatformSpecific.OnWin9x)
			{
				Thread thread = new Thread(MessageLoopThread);
				thread.Start();
			}
			ObtainDfdllExports();
			s_createDeploymentServiceComDelegate = () => new DeploymentServiceComWrapper();
			int num = RegisterDeploymentServiceCom(s_createDeploymentServiceComDelegate);
			if (num < 0)
			{
				throw Marshal.GetExceptionForHR(num);
			}
			CodeMarker_Singleton.Instance.CodeMarker(524);
			bool flag = LifetimeManager.WaitForEnd();
			if (_dfsvcForm != null)
			{
				_dfsvcForm.Invoke(new DfsvcForm.CloseFormDelegate(_dfsvcForm.CloseForm), true);
			}
			UnregisterDeploymentServiceCom();
			if (!flag && PlatformSpecific.OnWin9x)
			{
				Thread.Sleep(5000);
			}
			CodeMarker_Singleton.Instance.UninitializePerformanceDLL(63);
			Environment.Exit(0);
		}
	}
	internal static class CodeMarker_Singleton
	{
		private static CodeMarkers codemarkers = null;

		private static object syncObject = new object();

		public static CodeMarkers Instance
		{
			get
			{
				if (codemarkers == null)
				{
					lock (syncObject)
					{
						if (codemarkers == null)
						{
							CodeMarkers instance = CodeMarkers.Instance;
							instance.InitPerformanceDll(63, "Software\\Microsoft\\VisualStudio\\8.0");
							Thread.MemoryBarrier();
							codemarkers = instance;
						}
					}
				}
				return codemarkers;
			}
		}
	}
	internal static class PathTwiddler
	{
		private static object _invalidFileDirNameChars;

		private static char[] InvalidFileDirNameChars
		{
			get
			{
				if (_invalidFileDirNameChars == null)
				{
					Interlocked.CompareExchange(ref _invalidFileDirNameChars, Path.GetInvalidFileNameChars(), null);
				}
				return (char[])_invalidFileDirNameChars;
			}
		}

		public static string FilterString(string input, char chReplace, bool fMultiReplace)
		{
			return FilterString(input, InvalidFileDirNameChars, chReplace, fMultiReplace);
		}

		private static string FilterString(string input, char[] toFilter, char chReplacement, bool fMultiReplace)
		{
			int num = 0;
			bool flag = false;
			bool flag2 = false;
			if (input == null)
			{
				return null;
			}
			char[] array = input.ToCharArray();
			char[] array2 = new char[array.Length];
			Array.Sort(toFilter);
			for (int i = 0; i < array.Length; i++)
			{
				int num2 = Array.BinarySearch(toFilter, array[i]);
				if (num2 < 0)
				{
					array2[num++] = array[i];
					flag2 = true;
					if (flag)
					{
						flag = false;
					}
				}
				else if (fMultiReplace || !flag)
				{
					array2[num++] = chReplacement;
					flag = true;
				}
			}
			if (!flag2 || num <= 0)
			{
				return null;
			}
			return new string(array2, 0, num);
		}
	}
	internal static class PathHelper
	{
		private const int MAX_PATH = 260;

		private const int ERROR_FILE_NOT_FOUND = 2;

		private const int ERROR_INVALID_PARAMETER = 87;

		private static object _shortShimDllPath;

		public static string ShortShimDllPath
		{
			get
			{
				if (_shortShimDllPath == null)
				{
					string longPath = Path.Combine(Environment.SystemDirectory, "dfshim.dll");
					Interlocked.CompareExchange(ref _shortShimDllPath, GetShortPath(longPath), null);
				}
				return (string)_shortShimDllPath;
			}
		}

		public static string GetShortPath(string longPath)
		{
			StringBuilder stringBuilder = new StringBuilder(260);
			int shortPathName = NativeMethods.GetShortPathName(longPath, stringBuilder, stringBuilder.Capacity);
			if (shortPathName == 0)
			{
				GetShortPathNameThrowExceptionForLastError(longPath);
			}
			if (shortPathName >= stringBuilder.Capacity)
			{
				stringBuilder.Capacity = shortPathName + 1;
				if (NativeMethods.GetShortPathName(longPath, stringBuilder, stringBuilder.Capacity) == 0)
				{
					GetShortPathNameThrowExceptionForLastError(longPath);
				}
			}
			return stringBuilder.ToString();
		}

		public static string GenerateRandomPath(uint segmentCount)
		{
			if (segmentCount == 0)
			{
				return null;
			}
			uint num = 11 * segmentCount;
			uint num2 = (uint)Math.Ceiling((double)num * 0.625);
			byte[] array = new byte[num2];
			RNGCryptoServiceProvider rNGCryptoServiceProvider = new RNGCryptoServiceProvider();
			rNGCryptoServiceProvider.GetBytes(array);
			string text = Base32String.FromBytes(array);
			if (text.Length < num)
			{
				throw new DeploymentException(Resources.GetString("Ex_TempPathRandomStringTooShort"));
			}
			if (text.IndexOf('\\') >= 0)
			{
				throw new DeploymentException(Resources.GetString("Ex_TempPathRandomStringInvalid"));
			}
			for (int num3 = (int)(segmentCount - 1); num3 > 0; num3--)
			{
				int num4 = num3 * 11;
				if (num4 >= text.Length)
				{
					throw new DeploymentException(Resources.GetString("Ex_TempPathRandomStringInvalid"));
				}
				text = text.Insert(num4, "\\");
			}
			string[] array2 = text.Split('\\');
			if (array2.Length < segmentCount)
			{
				throw new DeploymentException(Resources.GetString("Ex_TempPathRandomStringInvalid"));
			}
			string text2 = null;
			for (uint num5 = 0u; num5 < segmentCount; num5++)
			{
				if (array2[num5].Length < 11)
				{
					throw new DeploymentException(Resources.GetString("Ex_TempPathRandomStringInvalid"));
				}
				string text3 = array2[num5].Substring(0, 11);
				text3 = text3.Insert(8, ".");
				text2 = ((text2 != null) ? Path.Combine(text2, text3) : text3);
			}
			return text2;
		}

		public static string GetRootSegmentPath(string path, uint segmentCount)
		{
			return segmentCount switch
			{
				0u => throw new ArgumentException("segmentCount"), 
				1u => path, 
				_ => GetRootSegmentPath(Path.GetDirectoryName(path), segmentCount - 1), 
			};
		}

		private static void GetShortPathNameThrowExceptionForLastError(string path)
		{
			int lastWin32Error = Marshal.GetLastWin32Error();
			switch (lastWin32Error)
			{
			case 2:
				throw new FileNotFoundException(path);
			case 87:
				throw new InvalidOperationException(Resources.GetString("Ex_ShortFileNameNotSupported"));
			default:
				throw new Win32Exception(lastWin32Error);
			}
		}
	}
	internal static class HexString
	{
		public static string FromBytes(byte[] bytes)
		{
			StringBuilder stringBuilder = new StringBuilder(bytes.Length * 2);
			for (int i = 0; i < bytes.Length; i++)
			{
				stringBuilder.AppendFormat(CultureInfo.InvariantCulture, "{0:x2}", new object[1] { bytes[i] });
			}
			return stringBuilder.ToString();
		}
	}
	internal class Base32String
	{
		protected static char[] charList = new char[32]
		{
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
			'A', 'B', 'C', 'D', 'E', 'G', 'H', 'J', 'K', 'L',
			'M', 'N', 'O', 'P', 'Q', 'R', 'T', 'V', 'W', 'X',
			'Y', 'Z'
		};

		public static string FromBytes(byte[] bytes)
		{
			int num = bytes.Length;
			if (num <= 0)
			{
				return null;
			}
			int num2 = num << 3;
			int num3 = num2 / 5 << 3;
			if (num2 % 5 != 0)
			{
				num3 += 8;
			}
			int capacity = num3 >> 3;
			StringBuilder stringBuilder = new StringBuilder(capacity);
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			for (num4 = 0; num4 < num; num4++)
			{
				num6 = (num6 << 8) | bytes[num4];
				num5 += 8;
				while (num5 >= 5)
				{
					num5 -= 5;
					stringBuilder.Append(charList[(num6 >> num5) & 0x1F]);
				}
			}
			if (num5 > 0)
			{
				stringBuilder.Append(charList[(num6 << 5 - num5) & 0x1F]);
			}
			return stringBuilder.ToString();
		}
	}
	internal static class Resources
	{
		private static object lockObject = new object();

		private static ResourceManager _resources = null;

		private static Assembly _assembly = null;

		public static string GetString(string s)
		{
			if (_resources == null)
			{
				lock (lockObject)
				{
					if (_resources == null)
					{
						InitializeReferenceToAssembly();
						_resources = new ResourceManager("System.Deployment", _assembly);
					}
				}
			}
			return _resources.GetString(s);
		}

		public static Image GetImage(string imageName)
		{
			InitializeReferenceToAssembly();
			Stream stream = null;
			try
			{
				stream = _assembly.GetManifestResourceStream(imageName);
				return Image.FromStream(stream);
			}
			catch
			{
				stream?.Close();
				throw;
			}
		}

		public static Icon GetIcon(string iconName, int width = 0, int height = 0)
		{
			InitializeReferenceToAssembly();
			using Stream stream = _assembly.GetManifestResourceStream(iconName);
			if (width != 0 || height != 0)
			{
				return new Icon(stream, width, height);
			}
			return new Icon(stream);
		}

		private static void InitializeReferenceToAssembly()
		{
			if (!(_assembly == null))
			{
				return;
			}
			lock (lockObject)
			{
				if (_assembly == null)
				{
					_assembly = Assembly.GetExecutingAssembly();
				}
			}
		}
	}
	internal static class Utilities
	{
		public static int CompareWithNullEqEmpty(string s1, string s2, StringComparison comparisonType)
		{
			if (string.IsNullOrEmpty(s1) && string.IsNullOrEmpty(s2))
			{
				return 0;
			}
			return string.Compare(s1, s2, comparisonType);
		}

		public static bool DoesRegistryKeyExist(RegistryKey regRoot, string regKey)
		{
			bool result = false;
			using RegistryKey registryKey = regRoot.OpenSubKey(regKey, writable: false);
			if (registryKey != null)
			{
				return true;
			}
			return result;
		}

		public static string BuildTFM(string targetVersion, string profile)
		{
			string text = null;
			if (string.IsNullOrEmpty(profile) || "Full".Equals(profile, StringComparison.OrdinalIgnoreCase))
			{
				return $".NETFramework,Version=v{targetVersion}";
			}
			return $".NETFramework,Version=v{targetVersion},Profile={profile}";
		}

		public static void SetMarkOfTheWeb(string path)
		{
			if (!System.IO.File.Exists(path))
			{
				return;
			}
			string lpFileName = path + ":Zone.Identifier";
			SafeFileHandle safeFileHandle = null;
			Stream stream = null;
			TextWriter textWriter = null;
			try
			{
				safeFileHandle = NativeMethods.CreateFile(lpFileName, 1073741824u, 2u, IntPtr.Zero, 2u, 0u, IntPtr.Zero);
				if (!safeFileHandle.IsInvalid)
				{
					stream = new FileStream(safeFileHandle, FileAccess.Write);
					textWriter = new StreamWriter(stream);
					textWriter.WriteLine("[ZoneTransfer]");
					textWriter.WriteLine("ZoneId=3");
					Logger.AddInternalState($"Set \"MOTW\" for file: {path}");
				}
				else
				{
					int lastWin32Error = Marshal.GetLastWin32Error();
					Logger.AddWarningInformation($"Failed to create alternate file stream, with error {lastWin32Error}");
				}
			}
			catch (Exception)
			{
				Logger.AddWarningInformation($"Failed to set \"MOTW\" for file: {path}");
			}
			finally
			{
				textWriter?.Close();
				stream?.Close();
				safeFileHandle?.Close();
			}
		}

		public static bool IsAppRepCheckRequired(string url)
		{
			Zone zone = Zone.CreateFromUrl(url);
			if (zone.SecurityZone == SecurityZone.Internet)
			{
				Logger.AddInternalState("AppRep is required.");
				return true;
			}
			return false;
		}
	}
	internal static class PolicyKeys
	{
		public enum HostType
		{
			Default,
			AppLaunch,
			Cor
		}

		public static bool RequireSignedManifests()
		{
			if (CheckDeploymentBoolString("RequireSignedManifests", compare: true, defaultIfNotSet: false))
			{
				return true;
			}
			return false;
		}

		public static bool RequireHashInManifests()
		{
			if (CheckDeploymentBoolString("RequireHashInManifests", compare: true, defaultIfNotSet: false))
			{
				return true;
			}
			return false;
		}

		public static bool SkipDeploymentProvider()
		{
			if (CheckDeploymentBoolString("SkipDeploymentProvider", compare: true, defaultIfNotSet: false))
			{
				Logger.AddWarningInformation(Resources.GetString("SkipDeploymentProvider"));
				return true;
			}
			return false;
		}

		public static bool SkipApplicationDependencyHashCheck()
		{
			if (CheckDeploymentBoolString("SkipApplicationDependencyHashCheck", compare: true, defaultIfNotSet: false))
			{
				Logger.AddWarningInformation(Resources.GetString("SkipApplicationDependencyHashCheck"));
				return true;
			}
			return false;
		}

		public static bool SkipSignatureValidation()
		{
			if (CheckDeploymentBoolString("SkipSignatureValidation", compare: true, defaultIfNotSet: false))
			{
				Logger.AddWarningInformation(Resources.GetString("SkipAllSigValidation"));
				return true;
			}
			return false;
		}

		public static bool SkipSchemaValidation()
		{
			if (CheckDeploymentBoolString("SkipSchemaValidation", compare: true, defaultIfNotSet: false))
			{
				Logger.AddWarningInformation(Resources.GetString("SkipSchemaValidation"));
				return true;
			}
			return false;
		}

		public static bool SkipSemanticValidation()
		{
			if (CheckDeploymentBoolString("SkipSemanticValidation", compare: true, defaultIfNotSet: false))
			{
				Logger.AddWarningInformation(Resources.GetString("SkipAllSemanticValidation"));
				return true;
			}
			return false;
		}

		public static bool SuppressLimitOnNumberOfActivations()
		{
			if (CheckDeploymentBoolString("SuppressLimitOnNumberOfActivations", compare: true, defaultIfNotSet: false))
			{
				Logger.AddWarningInformation(Resources.GetString("SuppressLimitOnNumberOfActivations"));
				return true;
			}
			return false;
		}

		public static bool DisableGenericExceptionHandler()
		{
			if (CheckDeploymentBoolString("DisableGenericExceptionHandler", compare: true, defaultIfNotSet: false))
			{
				Logger.AddWarningInformation(Resources.GetString("DisableGenericExceptionHandler"));
				return true;
			}
			return false;
		}

		public static ushort GetLogVerbosityLevel()
		{
			ushort result = 0;
			try
			{
				using RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Classes\\Software\\Microsoft\\Windows\\CurrentVersion\\Deployment", writable: false);
				if (registryKey != null)
				{
					object value = registryKey.GetValue("LogVerbosityLevel");
					if (value is string)
					{
						Logger.AddWarningInformation(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("LogVerbosityLevelSet"), new object[1] { value }));
						return Convert.ToUInt16(value, CultureInfo.InvariantCulture);
					}
					return result;
				}
				return result;
			}
			catch (Exception exception)
			{
				if (ExceptionUtility.IsHardException(exception))
				{
					throw;
				}
				return 0;
			}
		}

		public static bool ProduceDetailedExecutionSectionInLog()
		{
			ushort logVerbosityLevel = GetLogVerbosityLevel();
			if (logVerbosityLevel > 0)
			{
				return true;
			}
			return false;
		}

		public static HostType ClrHostType()
		{
			int num = 0;
			using (RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\.NETFramework\\DeploymentFramework", writable: false))
			{
				if (registryKey != null)
				{
					object value = registryKey.GetValue("ClickOnceHost");
					num = ((value != null) ? ((int)value) : 0);
				}
			}
			switch (num)
			{
			case 1:
				Logger.AddWarningInformation(Resources.GetString("ForceAppLaunch"));
				break;
			case 2:
				Logger.AddWarningInformation(Resources.GetString("ForceCor"));
				break;
			}
			return (HostType)num;
		}

		private static bool CheckDeploymentBoolString(string keyName, bool compare, bool defaultIfNotSet)
		{
			bool flag = false;
			bool flag2 = false;
			using (RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\.NETFramework\\DeploymentFramework", writable: false))
			{
				if (registryKey != null && registryKey.GetValue(keyName) is string @string)
				{
					flag2 = true;
					CompareInfo compareInfo = CultureInfo.InvariantCulture.CompareInfo;
					if (compareInfo.Compare(@string, "true", CompareOptions.IgnoreCase) == 0)
					{
						flag = true;
					}
					else if (compareInfo.Compare(@string, "false", CompareOptions.IgnoreCase) == 0)
					{
						flag = false;
					}
				}
			}
			if (!flag2)
			{
				return defaultIfNotSet;
			}
			return flag == compare;
		}

		private static bool CheckRegistryBoolString(RegistryKey registryKey, string valueName, bool compare, bool defaultIfNotSet)
		{
			bool flag = false;
			bool flag2 = false;
			if (registryKey != null && registryKey.GetValue(valueName) is string @string)
			{
				flag2 = true;
				CompareInfo compareInfo = CultureInfo.InvariantCulture.CompareInfo;
				if (compareInfo.Compare(@string, "true", CompareOptions.IgnoreCase) == 0)
				{
					flag = true;
				}
				else if (compareInfo.Compare(@string, "false", CompareOptions.IgnoreCase) == 0)
				{
					flag = false;
				}
			}
			if (!flag2)
			{
				return defaultIfNotSet;
			}
			return flag == compare;
		}

		public static bool SkipSKUDetection()
		{
			bool result = false;
			try
			{
				using RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Fusion", writable: false);
				if (registryKey != null)
				{
					object value = registryKey.GetValue("NoClientChecks");
					if (value != null)
					{
						if (Convert.ToUInt32(value) != 0)
						{
							Logger.AddWarningInformation(Resources.GetString("SkippedSKUDetection"));
							return true;
						}
						return result;
					}
					return result;
				}
				return result;
			}
			catch (OverflowException)
			{
				return false;
			}
			catch (InvalidCastException)
			{
				return false;
			}
			catch (IOException)
			{
				return false;
			}
		}
	}
}
namespace System.Deployment.Application.Win32InterOp
{
	internal class SystemUtils
	{
		private enum RUNTIME_INFO_FLAGS : uint
		{
			RUNTIME_INFO_UPGRADE_VERSION = 1u,
			RUNTIME_INFO_REQUEST_IA64 = 2u,
			RUNTIME_INFO_REQUEST_AMD64 = 4u,
			RUNTIME_INFO_REQUEST_X86 = 8u,
			RUNTIME_INFO_DONT_RETURN_DIRECTORY = 0x10u,
			RUNTIME_INFO_DONT_RETURN_VERSION = 0x20u,
			RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40u,
			RUNTIME_INFO_CONSIDER_POST_2_0 = 0x80u,
			RUNTIME_INFO_EMULATE_EXE_LAUNCH = 0x100u
		}

		internal enum AssemblyInfoFlags
		{
			Installed = 1,
			PayLoadResident
		}

		[Flags]
		internal enum QueryAssemblyInfoFlags
		{
			Validate = 1,
			GetSize = 2,
			GetCurrentPath = 4,
			All = 7
		}

		internal class AssemblyInfo
		{
			private int assemblyInfoSizeInByte;

			private AssemblyInfoFlags assemblyFlags;

			private long assemblySizeInKB;

			private string currentAssemblyPath;

			internal int AssemblyInfoSizeInByte
			{
				set
				{
					assemblyInfoSizeInByte = value;
				}
			}

			internal AssemblyInfoFlags AssemblyFlags
			{
				set
				{
					assemblyFlags = value;
				}
			}

			internal long AssemblySizeInKB
			{
				set
				{
					assemblySizeInKB = value;
				}
			}

			internal string CurrentAssemblyPath
			{
				set
				{
					currentAssemblyPath = value;
				}
			}
		}

		private const int MAX_CLR_VERSION_LENGTH = 24;

		public static byte[] GetManifestFromPEResources(string filePath)
		{
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero2 = IntPtr.Zero;
			IntPtr zero3 = IntPtr.Zero;
			IntPtr hFile = new IntPtr(0);
			uint dwFlags = 2u;
			byte[] result = null;
			int num = 0;
			try
			{
				intPtr = NativeMethods.LoadLibraryEx(filePath, hFile, dwFlags);
				num = Marshal.GetLastWin32Error();
				if (intPtr == IntPtr.Zero)
				{
					Win32LoadExceptionHelper(num, "Ex_Win32LoadException", filePath);
				}
				zero = NativeMethods.FindResource(intPtr, "#1", "#24");
				if (zero != IntPtr.Zero)
				{
					uint num2 = NativeMethods.SizeofResource(intPtr, zero);
					num = Marshal.GetLastWin32Error();
					if (num2 == 0)
					{
						Win32LoadExceptionHelper(num, "Ex_Win32ResourceLoadException", filePath);
					}
					zero2 = NativeMethods.LoadResource(intPtr, zero);
					num = Marshal.GetLastWin32Error();
					if (zero2 == IntPtr.Zero)
					{
						Win32LoadExceptionHelper(num, "Ex_Win32ResourceLoadException", filePath);
					}
					zero3 = NativeMethods.LockResource(zero2);
					if (zero3 == IntPtr.Zero)
					{
						throw new Win32Exception(33);
					}
					result = new byte[num2];
					Marshal.Copy(zero3, result, 0, (int)num2);
					return result;
				}
				return result;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					bool flag = NativeMethods.FreeLibrary(intPtr);
					num = Marshal.GetLastWin32Error();
					if (!flag)
					{
						throw new Win32Exception(num);
					}
				}
			}
		}

		private static void Win32LoadExceptionHelper(int win32ErrorCode, string resourceId, string filePath)
		{
			string fileName = Path.GetFileName(filePath);
			string message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString(resourceId), new object[2]
			{
				fileName,
				Convert.ToString(win32ErrorCode, 16)
			});
			throw new Win32Exception(win32ErrorCode, message);
		}

		internal static AssemblyInfo QueryAssemblyInfo(NativeMethods.IAssemblyCache AssemblyCache, QueryAssemblyInfoFlags flags, string assemblyName)
		{
			AssemblyInfo assemblyInfo = new AssemblyInfo();
			NativeMethods.AssemblyInfoInternal assemblyInfo2 = default(NativeMethods.AssemblyInfoInternal);
			if ((flags & QueryAssemblyInfoFlags.GetCurrentPath) != 0)
			{
				assemblyInfo2.cchBuf = 1024;
				assemblyInfo2.currentAssemblyPathBuf = Marshal.AllocHGlobal(assemblyInfo2.cchBuf * 2);
			}
			else
			{
				assemblyInfo2.cchBuf = 0;
				assemblyInfo2.currentAssemblyPathBuf = (IntPtr)0;
			}
			try
			{
				AssemblyCache.QueryAssemblyInfo((int)flags, assemblyName, ref assemblyInfo2);
			}
			catch (Exception ex)
			{
				if (ExceptionUtility.IsHardException(ex))
				{
					throw;
				}
				Logger.AddInternalState("Exception thrown : " + ex.GetType().ToString() + ":" + ex.Message);
				assemblyInfo = null;
			}
			if (assemblyInfo != null)
			{
				assemblyInfo.AssemblyInfoSizeInByte = assemblyInfo2.cbAssemblyInfo;
				assemblyInfo.AssemblyFlags = (AssemblyInfoFlags)assemblyInfo2.assemblyFlags;
				assemblyInfo.AssemblySizeInKB = assemblyInfo2.assemblySizeInKB;
				if ((flags & QueryAssemblyInfoFlags.GetCurrentPath) != 0)
				{
					assemblyInfo.CurrentAssemblyPath = Marshal.PtrToStringUni(assemblyInfo2.currentAssemblyPathBuf);
					Marshal.FreeHGlobal(assemblyInfo2.currentAssemblyPathBuf);
				}
			}
			return assemblyInfo;
		}

		internal static DefinitionIdentity GetDefinitionIdentityFromManagedAssembly(string filePath)
		{
			Guid riid = System.Deployment.Internal.Isolation.IsolationInterop.GetGuidOfType(typeof(System.Deployment.Internal.Isolation.IReferenceIdentity));
			System.Deployment.Internal.Isolation.IReferenceIdentity idComPtr = (System.Deployment.Internal.Isolation.IReferenceIdentity)NativeMethods.GetAssemblyIdentityFromFile(filePath, ref riid);
			ReferenceIdentity referenceIdentity = new ReferenceIdentity(idComPtr);
			string processorArchitecture = referenceIdentity.ProcessorArchitecture;
			if (processorArchitecture != null)
			{
				referenceIdentity.ProcessorArchitecture = processorArchitecture.ToLower(CultureInfo.InvariantCulture);
			}
			DefinitionIdentity definitionIdentity = new DefinitionIdentity(referenceIdentity);
			Logger.AddInternalState("Managed Assembly Identity = " + definitionIdentity.ToString());
			return definitionIdentity;
		}

		internal static void CheckSupportedImageAndCLRVersions(string path)
		{
			Logger.AddMethodCall("CheckSupportedImageAndCLRVersions(" + path + ") called.");
			StringBuilder stringBuilder = new StringBuilder(24);
			uint dwLength;
			try
			{
				NativeMethods.GetFileVersion(path, stringBuilder, (uint)stringBuilder.Capacity, out dwLength);
			}
			catch (BadImageFormatException)
			{
				throw;
			}
			if (stringBuilder[0] != 'v')
			{
				throw new InvalidDeploymentException(ExceptionTypes.ClrValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidCLRVersionInFile"), new object[2]
				{
					stringBuilder,
					Path.GetFileName(path)
				}));
			}
			Version version = new Version(stringBuilder.ToString(1, stringBuilder.Length - 1));
			if ((long)version.Major < 2L)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ClrValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ImageVersionCLRNotSupported"), new object[2]
				{
					version,
					Path.GetFileName(path)
				}));
			}
			uint runtimeInfoFlags = 465u;
			NativeMethods.GetRequestedRuntimeInfo(path, null, null, 0u, runtimeInfoFlags, null, 0u, out var _, stringBuilder, (uint)stringBuilder.Capacity, out dwLength);
			if (stringBuilder[0] != 'v')
			{
				throw new FormatException(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidCLRVersionInFile"), new object[2]
				{
					stringBuilder,
					Path.GetFileName(path)
				}));
			}
			string text = stringBuilder.ToString(1, stringBuilder.Length - 1);
			int num = text.IndexOf(".", StringComparison.Ordinal);
			uint num2 = uint.Parse((num >= 0) ? text.Substring(0, num) : text, CultureInfo.InvariantCulture);
			if (num2 < 2)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ClrValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_RuntimeVersionCLRNotSupported"), new object[2]
				{
					text,
					Path.GetFileName(path)
				}));
			}
		}
	}
}
namespace System.Deployment.Application.Manifest
{
	internal enum timeUnitType
	{
		hours = 1,
		days,
		weeks
	}
	internal enum hashAlgorithmType
	{
		sha1 = 1,
		sha256,
		sha384,
		sha512
	}
	internal class Description
	{
		private readonly string _publisher;

		private readonly string _product;

		private readonly string _suiteName;

		private readonly Uri _supportUri;

		private readonly Uri _errorReportUri;

		private readonly string _iconFile;

		private readonly string _iconFileFS;

		private readonly string _filteredPublisher;

		private readonly string _filteredProduct;

		private readonly string _filteredSuiteName;

		public string Publisher => _publisher;

		public string Product => _product;

		public Uri SupportUri => _supportUri;

		public string SupportUrl
		{
			get
			{
				if (!(_supportUri != null))
				{
					return null;
				}
				return _supportUri.AbsoluteUri;
			}
		}

		public string IconFile => _iconFile;

		public string IconFileFS => _iconFileFS;

		public Uri ErrorReportUri => _errorReportUri;

		public string ErrorReportUrl
		{
			get
			{
				if (!(_errorReportUri != null))
				{
					return null;
				}
				return _errorReportUri.AbsoluteUri;
			}
		}

		public string FilteredPublisher => _filteredPublisher;

		public string FilteredProduct => _filteredProduct;

		public string FilteredSuiteName => _filteredSuiteName;

		public Description(System.Deployment.Internal.Isolation.Manifest.DescriptionMetadataEntry descriptionMetadataEntry)
		{
			_publisher = descriptionMetadataEntry.Publisher;
			_product = descriptionMetadataEntry.Product;
			_suiteName = descriptionMetadataEntry.SuiteName;
			if (_suiteName == null)
			{
				_suiteName = "";
			}
			_supportUri = AssemblyManifest.UriFromMetadataEntry(descriptionMetadataEntry.SupportUrl, "Ex_DescriptionSupportUrlNotValid");
			_errorReportUri = AssemblyManifest.UriFromMetadataEntry(descriptionMetadataEntry.ErrorReportUrl, "Ex_DescriptionErrorReportUrlNotValid");
			_iconFile = descriptionMetadataEntry.IconFile;
			if (_iconFile != null)
			{
				_iconFileFS = UriHelper.NormalizePathDirectorySeparators(_iconFile);
			}
			_filteredPublisher = PathTwiddler.FilterString(_publisher, ' ', fMultiReplace: false);
			_filteredProduct = PathTwiddler.FilterString(_product, ' ', fMultiReplace: false);
			_filteredSuiteName = PathTwiddler.FilterString(_suiteName, ' ', fMultiReplace: false);
		}
	}
	internal class EntryPoint
	{
		private readonly string _name;

		private readonly string _commandLineFile;

		private readonly string _commandLineParamater;

		private readonly DependentAssembly _dependentAssembly;

		private readonly bool _hostInBrowser;

		private readonly bool _customHostSpecified;

		private readonly bool _customUX;

		public DependentAssembly Assembly => _dependentAssembly;

		public string CommandFile => _commandLineFile;

		public bool HostInBrowser => _hostInBrowser;

		public bool CustomHostSpecified => _customHostSpecified;

		public bool CustomUX => _customUX;

		public string CommandParameters => _commandLineParamater;

		public EntryPoint(System.Deployment.Internal.Isolation.Manifest.EntryPointEntry entryPointEntry, AssemblyManifest manifest)
		{
			_name = entryPointEntry.Name;
			_commandLineFile = entryPointEntry.CommandLine_File;
			_commandLineParamater = entryPointEntry.CommandLine_Parameters;
			_hostInBrowser = (entryPointEntry.Flags & 1) != 0;
			_customHostSpecified = (entryPointEntry.Flags & 2) != 0;
			_customUX = (entryPointEntry.Flags & 4) != 0;
			if (!_customHostSpecified)
			{
				if (entryPointEntry.Identity != null)
				{
					_dependentAssembly = manifest.GetDependentAssemblyByIdentity(entryPointEntry.Identity);
				}
				if (_dependentAssembly == null)
				{
					throw new InvalidDeploymentException(ExceptionTypes.ManifestParse, Resources.GetString("Ex_NoMatchingAssemblyForEntryPoint"));
				}
			}
		}
	}
	internal class DependentOS
	{
		private readonly ushort _majorVersion;

		private readonly ushort _minorVersion;

		private readonly ushort _buildNumber;

		private readonly byte _servicePackMajor;

		private readonly byte _servicePackMinor;

		private readonly Uri _supportUrl;

		public ushort MajorVersion => _majorVersion;

		public ushort MinorVersion => _minorVersion;

		public ushort BuildNumber => _buildNumber;

		public byte ServicePackMajor => _servicePackMajor;

		public byte ServicePackMinor => _servicePackMinor;

		public Uri SupportUrl => _supportUrl;

		public DependentOS(System.Deployment.Internal.Isolation.Manifest.DependentOSMetadataEntry dependentOSMetadataEntry)
		{
			_majorVersion = dependentOSMetadataEntry.MajorVersion;
			_minorVersion = dependentOSMetadataEntry.MinorVersion;
			_buildNumber = dependentOSMetadataEntry.BuildNumber;
			_servicePackMajor = dependentOSMetadataEntry.ServicePackMajor;
			_servicePackMinor = dependentOSMetadataEntry.ServicePackMinor;
			_supportUrl = AssemblyManifest.UriFromMetadataEntry(dependentOSMetadataEntry.SupportUrl, "Ex_DependentOSSupportUrlNotValid");
		}
	}
	internal class Deployment
	{
		private readonly Uri _codebaseUri;

		private readonly DeploymentUpdate _update;

		private readonly Version _minimumRequiredVersion;

		private readonly bool _disallowUrlActivation;

		private readonly bool _install;

		private readonly bool _trustURLParameters;

		private readonly bool _mapFileExtensions;

		private readonly bool _createDesktopShortcut;

		public Uri ProviderCodebaseUri => _codebaseUri;

		public DeploymentUpdate DeploymentUpdate => _update;

		public Version MinimumRequiredVersion => _minimumRequiredVersion;

		public bool DisallowUrlActivation => _disallowUrlActivation;

		public bool Install => _install;

		public bool TrustURLParameters => _trustURLParameters;

		public bool MapFileExtensions => _mapFileExtensions;

		public bool CreateDesktopShortcut => _createDesktopShortcut;

		public bool IsUpdateSectionPresent
		{
			get
			{
				if (!DeploymentUpdate.BeforeApplicationStartup && !DeploymentUpdate.MaximumAgeSpecified)
				{
					return false;
				}
				return true;
			}
		}

		public bool IsInstalledAndNoDeploymentProvider
		{
			get
			{
				if (Install)
				{
					return ProviderCodebaseUri == null;
				}
				return false;
			}
		}

		public Deployment(System.Deployment.Internal.Isolation.Manifest.DeploymentMetadataEntry deploymentMetadataEntry)
		{
			_disallowUrlActivation = (deploymentMetadataEntry.DeploymentFlags & 0x80) != 0;
			_install = (deploymentMetadataEntry.DeploymentFlags & 0x20) != 0;
			_trustURLParameters = (deploymentMetadataEntry.DeploymentFlags & 0x40) != 0;
			_mapFileExtensions = (deploymentMetadataEntry.DeploymentFlags & 0x100) != 0;
			_createDesktopShortcut = (deploymentMetadataEntry.DeploymentFlags & 0x200) != 0;
			_update = new DeploymentUpdate(deploymentMetadataEntry);
			_minimumRequiredVersion = ((deploymentMetadataEntry.MinimumRequiredVersion != null) ? new Version(deploymentMetadataEntry.MinimumRequiredVersion) : null);
			_codebaseUri = AssemblyManifest.UriFromMetadataEntry(deploymentMetadataEntry.DeploymentProviderCodebase, "Ex_DepProviderNotValid");
		}
	}
	internal class DeploymentUpdate
	{
		private readonly bool _beforeApplicationStartup;

		private readonly bool _maximumAgeSpecified;

		private readonly TimeSpan _maximumAgeAllowed;

		private readonly uint _maximumAgeCount;

		private readonly timeUnitType _maximumAgeUnit;

		public bool BeforeApplicationStartup => _beforeApplicationStartup;

		public bool MaximumAgeSpecified => _maximumAgeSpecified;

		public TimeSpan MaximumAgeAllowed => _maximumAgeAllowed;

		public DeploymentUpdate(System.Deployment.Internal.Isolation.Manifest.DeploymentMetadataEntry entry)
		{
			_beforeApplicationStartup = (entry.DeploymentFlags & 4) != 0;
			_maximumAgeAllowed = GetTimeSpanFromItem(entry.MaximumAge, entry.MaximumAge_Unit, out _maximumAgeCount, out _maximumAgeUnit, out _maximumAgeSpecified);
		}

		private static TimeSpan GetTimeSpanFromItem(ushort time, byte elapsedunit, out uint count, out timeUnitType unit, out bool specified)
		{
			specified = true;
			TimeSpan result;
			switch (elapsedunit)
			{
			case 1:
				result = TimeSpan.FromHours((int)time);
				count = time;
				unit = timeUnitType.hours;
				break;
			case 2:
				result = TimeSpan.FromDays((int)time);
				count = time;
				unit = timeUnitType.days;
				break;
			case 3:
				result = TimeSpan.FromDays(time * 7);
				count = time;
				unit = timeUnitType.weeks;
				break;
			default:
				specified = false;
				result = TimeSpan.Zero;
				count = 0u;
				unit = timeUnitType.days;
				break;
			}
			return result;
		}
	}
	internal class DependentAssembly
	{
		private readonly ulong _size;

		private readonly string _codebase;

		private readonly ReferenceIdentity _identity;

		private readonly string _group;

		private readonly string _codebaseFS;

		private readonly string _description;

		private readonly Uri _supportUrl;

		private readonly string _resourceFallbackCulture;

		private readonly bool _resourceFallbackCultureInternal;

		private readonly bool _optional;

		private readonly bool _visible;

		private readonly bool _preRequisite;

		private HashCollection _hashCollection = new HashCollection();

		public ReferenceIdentity Identity => _identity;

		public string Codebase => _codebase;

		public ulong Size => _size;

		public string Group => _group;

		public string CodebaseFS => _codebaseFS;

		public string Description => _description;

		public Uri SupportUrl => _supportUrl;

		public string ResourceFallbackCulture => _resourceFallbackCulture;

		public bool IsPreRequisite => _preRequisite;

		public bool IsOptional => _optional;

		public HashCollection HashCollection => _hashCollection;

		public DependentAssembly(ReferenceIdentity refId)
		{
			_identity = refId;
		}

		public DependentAssembly(System.Deployment.Internal.Isolation.Manifest.AssemblyReferenceEntry assemblyReferenceEntry)
		{
			System.Deployment.Internal.Isolation.Manifest.AssemblyReferenceDependentAssemblyEntry dependentAssembly = assemblyReferenceEntry.DependentAssembly;
			_size = dependentAssembly.Size;
			_codebase = dependentAssembly.Codebase;
			_group = dependentAssembly.Group;
			bool flag = false;
			System.Deployment.Internal.Isolation.ISection hashElements = dependentAssembly.HashElements;
			uint num = hashElements?.Count ?? 0;
			if (num != 0)
			{
				uint celtFetched = 0u;
				System.Deployment.Internal.Isolation.Manifest.IHashElementEntry[] array = new System.Deployment.Internal.Isolation.Manifest.IHashElementEntry[num];
				System.Deployment.Internal.Isolation.IEnumUnknown enumUnknown = (System.Deployment.Internal.Isolation.IEnumUnknown)hashElements._NewEnum;
				object[] rgelt = array;
				int errorCode = enumUnknown.Next(num, rgelt, ref celtFetched);
				Marshal.ThrowExceptionForHR(errorCode);
				if (celtFetched != num)
				{
					throw new InvalidDeploymentException(ExceptionTypes.Manifest, Resources.GetString("Ex_IsoEnumFetchNotEqualToCount"));
				}
				for (uint num2 = 0u; num2 < num; num2++)
				{
					System.Deployment.Internal.Isolation.Manifest.HashElementEntry allData = array[num2].AllData;
					if (allData.DigestValueSize != 0)
					{
						byte[] array2 = new byte[allData.DigestValueSize];
						Marshal.Copy(allData.DigestValue, array2, 0, (int)allData.DigestValueSize);
						_hashCollection.AddHash(array2, (System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD)allData.DigestMethod, (System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM)allData.Transform);
						flag = true;
					}
				}
			}
			if (!flag && dependentAssembly.HashValueSize != 0)
			{
				byte[] array3 = new byte[dependentAssembly.HashValueSize];
				Marshal.Copy(dependentAssembly.HashValue, array3, 0, (int)dependentAssembly.HashValueSize);
				_hashCollection.AddHash(array3, (System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD)dependentAssembly.HashAlgorithm, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM.CMS_HASH_TRANSFORM_IDENTITY);
			}
			_preRequisite = (dependentAssembly.Flags & 4) != 0;
			_optional = (assemblyReferenceEntry.Flags & 1) != 0;
			_visible = (dependentAssembly.Flags & 2) != 0;
			_resourceFallbackCultureInternal = (dependentAssembly.Flags & 8) != 0;
			_resourceFallbackCulture = dependentAssembly.ResourceFallbackCulture;
			_description = dependentAssembly.Description;
			_supportUrl = AssemblyManifest.UriFromMetadataEntry(dependentAssembly.SupportUrl, "Ex_DependencySupportUrlNotValid");
			System.Deployment.Internal.Isolation.IReferenceIdentity referenceIdentity = assemblyReferenceEntry.ReferenceIdentity;
			_identity = new ReferenceIdentity(referenceIdentity);
			_codebaseFS = UriHelper.NormalizePathDirectorySeparators(_codebase);
		}
	}
	internal class FileAssociation
	{
		private readonly string _extension;

		private readonly string _description;

		private readonly string _progId;

		private readonly string _defaultIcon;

		private readonly string _parameter;

		public string Extension => _extension;

		public string Description => _description;

		public string ProgID => _progId;

		public string DefaultIcon => _defaultIcon;

		public string Parameter => _parameter;

		public FileAssociation(System.Deployment.Internal.Isolation.Manifest.FileAssociationEntry fileAssociationEntry)
		{
			_extension = fileAssociationEntry.Extension;
			_description = fileAssociationEntry.Description;
			_progId = fileAssociationEntry.ProgID;
			_defaultIcon = fileAssociationEntry.DefaultIcon;
			_parameter = fileAssociationEntry.Parameter;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("(" + _extension + ",");
			stringBuilder.Append(_description + ",");
			stringBuilder.Append(_progId + ",");
			stringBuilder.Append(_defaultIcon + ",");
			stringBuilder.Append(_parameter + ")");
			return stringBuilder.ToString();
		}
	}
	internal class File
	{
		private readonly string _name;

		private readonly string _loadFrom;

		private readonly ulong _size;

		private readonly string _group;

		private readonly bool _optional;

		private readonly bool _isData;

		private readonly string _nameFS;

		private HashCollection _hashCollection = new HashCollection();

		public string Name => _name;

		public ulong Size => _size;

		public string Group => _group;

		public bool IsOptional => _optional;

		public bool IsData => _isData;

		public string NameFS => _nameFS;

		public HashCollection HashCollection => _hashCollection;

		protected internal File(string name, ulong size)
		{
			_name = name;
			_size = size;
			_nameFS = UriHelper.NormalizePathDirectorySeparators(_name);
		}

		public File(string name, byte[] hash, ulong size)
		{
			_name = name;
			_hashCollection.AddHash(hash, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD.CMS_HASH_DIGESTMETHOD_SHA1, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM.CMS_HASH_TRANSFORM_IDENTITY);
			_size = size;
			_nameFS = UriHelper.NormalizePathDirectorySeparators(_name);
		}

		public File(System.Deployment.Internal.Isolation.Manifest.FileEntry fileEntry)
		{
			_name = fileEntry.Name;
			_loadFrom = fileEntry.LoadFrom;
			_size = fileEntry.Size;
			_group = fileEntry.Group;
			_optional = (fileEntry.Flags & 1) != 0;
			_isData = (fileEntry.WritableType & 2) != 0;
			bool flag = false;
			System.Deployment.Internal.Isolation.ISection hashElements = fileEntry.HashElements;
			uint num = hashElements?.Count ?? 0;
			if (num != 0)
			{
				uint celtFetched = 0u;
				System.Deployment.Internal.Isolation.Manifest.IHashElementEntry[] array = new System.Deployment.Internal.Isolation.Manifest.IHashElementEntry[num];
				System.Deployment.Internal.Isolation.IEnumUnknown enumUnknown = (System.Deployment.Internal.Isolation.IEnumUnknown)hashElements._NewEnum;
				object[] rgelt = array;
				int errorCode = enumUnknown.Next(num, rgelt, ref celtFetched);
				Marshal.ThrowExceptionForHR(errorCode);
				if (celtFetched != num)
				{
					throw new InvalidDeploymentException(ExceptionTypes.Manifest, Resources.GetString("Ex_IsoEnumFetchNotEqualToCount"));
				}
				for (uint num2 = 0u; num2 < num; num2++)
				{
					System.Deployment.Internal.Isolation.Manifest.HashElementEntry allData = array[num2].AllData;
					if (allData.DigestValueSize != 0)
					{
						byte[] array2 = new byte[allData.DigestValueSize];
						Marshal.Copy(allData.DigestValue, array2, 0, (int)allData.DigestValueSize);
						_hashCollection.AddHash(array2, (System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD)allData.DigestMethod, (System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM)allData.Transform);
						flag = true;
					}
				}
			}
			if (!flag && fileEntry.HashValueSize != 0)
			{
				byte[] array3 = new byte[fileEntry.HashValueSize];
				Marshal.Copy(fileEntry.HashValue, array3, 0, (int)fileEntry.HashValueSize);
				_hashCollection.AddHash(array3, (System.Deployment.Internal.Isolation.Manifest.CMS_HASH_DIGESTMETHOD)fileEntry.HashAlgorithm, System.Deployment.Internal.Isolation.Manifest.CMS_HASH_TRANSFORM.CMS_HASH_TRANSFORM_IDENTITY);
			}
			_nameFS = UriHelper.NormalizePathDirectorySeparators(_name);
		}
	}
	internal enum ManifestSourceFormat
	{
		XmlFile,
		CompLib,
		ID_1,
		Stream,
		Unknown
	}
	internal class AssemblyManifest
	{
		internal enum ManifestType
		{
			Application,
			Deployment
		}

		protected class ManifestParseErrors : System.Deployment.Internal.Isolation.IManifestParseErrorCallback, IEnumerable
		{
			public class ManifestParseError
			{
				public uint StartLine;

				public uint nStartColumn;

				public uint cCharacterCount;

				public int hr;

				public string ErrorStatusHostFile;

				public uint ParameterCount;

				public string[] Parameters;
			}

			public class ParseErrorEnumerator : IEnumerator
			{
				private int _index;

				private ManifestParseErrors _manifestParseErrors;

				public ManifestParseError Current => (ManifestParseError)_manifestParseErrors._parsingErrors[_index];

				object IEnumerator.Current => _manifestParseErrors._parsingErrors[_index];

				public ParseErrorEnumerator(ManifestParseErrors manifestParseErrors)
				{
					_manifestParseErrors = manifestParseErrors;
					_index = -1;
				}

				public void Reset()
				{
					_index = -1;
				}

				public bool MoveNext()
				{
					_index++;
					return _index < _manifestParseErrors._parsingErrors.Count;
				}
			}

			protected ArrayList _parsingErrors = new ArrayList();

			public void OnError(uint StartLine, uint nStartColumn, uint cCharacterCount, int hr, string ErrorStatusHostFile, uint ParameterCount, string[] Parameters)
			{
				ManifestParseError manifestParseError = new ManifestParseError();
				manifestParseError.StartLine = StartLine;
				manifestParseError.nStartColumn = nStartColumn;
				manifestParseError.cCharacterCount = cCharacterCount;
				manifestParseError.hr = hr;
				manifestParseError.ErrorStatusHostFile = ErrorStatusHostFile;
				manifestParseError.ParameterCount = ParameterCount;
				manifestParseError.Parameters = Parameters;
				_parsingErrors.Add(manifestParseError);
			}

			public ParseErrorEnumerator GetEnumerator()
			{
				return new ParseErrorEnumerator(this);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		internal enum CertificateStatus
		{
			TrustedPublisher,
			AuthenticodedNotInTrustedList,
			NoCertificate,
			DistrustedPublisher,
			RevokedCertificate,
			UnknownCertificateStatus
		}

		private string _rawXmlFilePath;

		private byte[] _rawXmlBytes;

		private System.Deployment.Internal.Isolation.Manifest.ICMS _cms;

		private object _identity;

		private object _description;

		private object _entryPoints;

		private object _dependentAssemblies;

		private object _files;

		private object _fileAssociations;

		private object _deployment;

		private object _dependentOS;

		private object _manifestFlags;

		private object _requestedExecutionLevel;

		private object _requestedExecutionLevelUIAccess;

		private object _compatibleFrameworks;

		private ManifestSourceFormat _manifestSourceFormat = ManifestSourceFormat.Unknown;

		private DefinitionIdentity _id1Identity;

		private DefinitionIdentity _complibIdentity;

		private bool _id1ManifestPresent;

		private string _id1RequestedExecutionLevel;

		private ulong _sizeInBytes;

		private bool _unhashedFilePresent;

		private bool _unhashedDependencyPresent;

		private bool _signed;

		private bool _clrDependentAssemblyChecked;

		private DependentAssembly _clrDependentAssembly;

		private static char[] SpecificInvalidIdentityChars = new char[2] { '#', '&' };

		public string RawXmlFilePath => _rawXmlFilePath;

		public byte[] RawXmlBytes => _rawXmlBytes;

		public DefinitionIdentity Identity
		{
			get
			{
				if (_identity == null && _cms != null)
				{
					DefinitionIdentity definitionIdentity = null;
					Interlocked.CompareExchange(value: (_cms.Identity != null) ? new DefinitionIdentity(_cms.Identity) : new DefinitionIdentity(), location1: ref _identity, comparand: null);
				}
				return (DefinitionIdentity)_identity;
			}
		}

		public ulong SizeInBytes => _sizeInBytes;

		public DefinitionIdentity Id1Identity => _id1Identity;

		public DefinitionIdentity ComplibIdentity => _complibIdentity;

		public bool Id1ManifestPresent => _id1ManifestPresent;

		public string Id1RequestedExecutionLevel => _id1RequestedExecutionLevel;

		public uint ManifestFlags
		{
			get
			{
				if (_manifestFlags == null && _cms != null)
				{
					System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry metadataSectionEntry = (System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry)_cms.MetadataSectionEntry;
					uint num = 0u;
					num = metadataSectionEntry.ManifestFlags;
					Interlocked.CompareExchange(ref _manifestFlags, num, null);
				}
				return (uint)_manifestFlags;
			}
		}

		public string RequestedExecutionLevel
		{
			get
			{
				if (_requestedExecutionLevel == null && _cms != null)
				{
					System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry metadataSectionEntry = (System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry)_cms.MetadataSectionEntry;
					string requestedExecutionLevel = metadataSectionEntry.RequestedExecutionLevel;
					Interlocked.CompareExchange(ref _requestedExecutionLevel, requestedExecutionLevel, null);
				}
				return (string)_requestedExecutionLevel;
			}
		}

		public bool RequestedExecutionLevelUIAccess
		{
			get
			{
				if (_requestedExecutionLevelUIAccess == null && _cms != null)
				{
					System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry metadataSectionEntry = (System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry)_cms.MetadataSectionEntry;
					bool flag = false;
					flag = metadataSectionEntry.RequestedExecutionLevelUIAccess;
					Interlocked.CompareExchange(ref _requestedExecutionLevelUIAccess, flag, null);
				}
				return (bool)_requestedExecutionLevelUIAccess;
			}
		}

		public bool Application => (ManifestFlags & 4) != 0;

		public bool UseManifestForTrust => (ManifestFlags & 8) != 0;

		public Description Description
		{
			get
			{
				if (_description == null && _cms != null)
				{
					System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry metadataSectionEntry = (System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry)_cms.MetadataSectionEntry;
					System.Deployment.Internal.Isolation.Manifest.IDescriptionMetadataEntry descriptionData = metadataSectionEntry.DescriptionData;
					if (descriptionData != null)
					{
						Description value = new Description(descriptionData.AllData);
						Interlocked.CompareExchange(ref _description, value, null);
					}
				}
				return (Description)_description;
			}
		}

		public Deployment Deployment
		{
			get
			{
				if (_deployment == null && _cms != null)
				{
					System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry metadataSectionEntry = (System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry)_cms.MetadataSectionEntry;
					System.Deployment.Internal.Isolation.Manifest.IDeploymentMetadataEntry deploymentData = metadataSectionEntry.DeploymentData;
					if (deploymentData != null)
					{
						Deployment value = new Deployment(deploymentData.AllData);
						Interlocked.CompareExchange(ref _deployment, value, null);
					}
				}
				return (Deployment)_deployment;
			}
		}

		public DependentOS DependentOS
		{
			get
			{
				if (_dependentOS == null && _cms != null)
				{
					System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry metadataSectionEntry = (System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry)_cms.MetadataSectionEntry;
					System.Deployment.Internal.Isolation.Manifest.IDependentOSMetadataEntry dependentOSData = metadataSectionEntry.DependentOSData;
					if (dependentOSData != null)
					{
						DependentOS value = new DependentOS(dependentOSData.AllData);
						Interlocked.CompareExchange(ref _dependentOS, value, null);
					}
				}
				return (DependentOS)_dependentOS;
			}
		}

		public DependentAssembly[] DependentAssemblies
		{
			get
			{
				if (_dependentAssemblies == null)
				{
					System.Deployment.Internal.Isolation.ISection section = ((_cms != null) ? _cms.AssemblyReferenceSection : null);
					uint num = section?.Count ?? 0;
					DependentAssembly[] array = new DependentAssembly[num];
					if (num != 0)
					{
						uint celtFetched = 0u;
						System.Deployment.Internal.Isolation.Manifest.IAssemblyReferenceEntry[] array2 = new System.Deployment.Internal.Isolation.Manifest.IAssemblyReferenceEntry[num];
						System.Deployment.Internal.Isolation.IEnumUnknown enumUnknown = (System.Deployment.Internal.Isolation.IEnumUnknown)section._NewEnum;
						object[] rgelt = array2;
						int errorCode = enumUnknown.Next(num, rgelt, ref celtFetched);
						Marshal.ThrowExceptionForHR(errorCode);
						if (celtFetched != num)
						{
							throw new InvalidDeploymentException(ExceptionTypes.Manifest, Resources.GetString("Ex_IsoEnumFetchNotEqualToCount"));
						}
						for (uint num2 = 0u; num2 < num; num2++)
						{
							array[num2] = new DependentAssembly(array2[num2].AllData);
						}
					}
					Interlocked.CompareExchange(ref _dependentAssemblies, array, null);
				}
				return (DependentAssembly[])_dependentAssemblies;
			}
		}

		public FileAssociation[] FileAssociations
		{
			get
			{
				if (_fileAssociations == null)
				{
					System.Deployment.Internal.Isolation.ISection section = ((_cms != null) ? _cms.FileAssociationSection : null);
					uint num = section?.Count ?? 0;
					FileAssociation[] array = new FileAssociation[num];
					if (num != 0)
					{
						uint celtFetched = 0u;
						System.Deployment.Internal.Isolation.Manifest.IFileAssociationEntry[] array2 = new System.Deployment.Internal.Isolation.Manifest.IFileAssociationEntry[num];
						System.Deployment.Internal.Isolation.IEnumUnknown enumUnknown = (System.Deployment.Internal.Isolation.IEnumUnknown)section._NewEnum;
						object[] rgelt = array2;
						int errorCode = enumUnknown.Next(num, rgelt, ref celtFetched);
						Marshal.ThrowExceptionForHR(errorCode);
						if (celtFetched != num)
						{
							throw new InvalidDeploymentException(ExceptionTypes.Manifest, Resources.GetString("Ex_IsoEnumFetchNotEqualToCount"));
						}
						for (uint num2 = 0u; num2 < num; num2++)
						{
							array[num2] = new FileAssociation(array2[num2].AllData);
						}
					}
					Interlocked.CompareExchange(ref _fileAssociations, array, null);
				}
				return (FileAssociation[])_fileAssociations;
			}
		}

		public File[] Files
		{
			get
			{
				if (_files == null)
				{
					System.Deployment.Internal.Isolation.ISection section = ((_cms != null) ? _cms.FileSection : null);
					uint num = section?.Count ?? 0;
					File[] array = new File[num];
					if (num != 0)
					{
						uint celtFetched = 0u;
						System.Deployment.Internal.Isolation.Manifest.IFileEntry[] array2 = new System.Deployment.Internal.Isolation.Manifest.IFileEntry[num];
						System.Deployment.Internal.Isolation.IEnumUnknown enumUnknown = (System.Deployment.Internal.Isolation.IEnumUnknown)section._NewEnum;
						object[] rgelt = array2;
						int errorCode = enumUnknown.Next(num, rgelt, ref celtFetched);
						Marshal.ThrowExceptionForHR(errorCode);
						if (celtFetched != num)
						{
							throw new InvalidDeploymentException(ExceptionTypes.Manifest, Resources.GetString("Ex_IsoEnumFetchNotEqualToCount"));
						}
						for (uint num2 = 0u; num2 < num; num2++)
						{
							array[num2] = new File(array2[num2].AllData);
						}
					}
					Interlocked.CompareExchange(ref _files, array, null);
				}
				return (File[])_files;
			}
		}

		public CompatibleFrameworks CompatibleFrameworks
		{
			get
			{
				if (_compatibleFrameworks == null && _cms != null)
				{
					System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry metadataSectionEntry = (System.Deployment.Internal.Isolation.Manifest.IMetadataSectionEntry)_cms.MetadataSectionEntry;
					System.Deployment.Internal.Isolation.Manifest.ICompatibleFrameworksMetadataEntry compatibleFrameworksData = metadataSectionEntry.CompatibleFrameworksData;
					if (compatibleFrameworksData != null)
					{
						System.Deployment.Internal.Isolation.ISection section = ((_cms != null) ? _cms.CompatibleFrameworksSection : null);
						uint num = section?.Count ?? 0;
						CompatibleFramework[] array = new CompatibleFramework[num];
						if (num != 0)
						{
							uint celtFetched = 0u;
							System.Deployment.Internal.Isolation.Manifest.ICompatibleFrameworkEntry[] array2 = new System.Deployment.Internal.Isolation.Manifest.ICompatibleFrameworkEntry[num];
							System.Deployment.Internal.Isolation.IEnumUnknown enumUnknown = (System.Deployment.Internal.Isolation.IEnumUnknown)section._NewEnum;
							object[] rgelt = array2;
							int errorCode = enumUnknown.Next(num, rgelt, ref celtFetched);
							Marshal.ThrowExceptionForHR(errorCode);
							if (celtFetched != num)
							{
								throw new InvalidDeploymentException(ExceptionTypes.Manifest, Resources.GetString("Ex_IsoEnumFetchNotEqualToCount"));
							}
							for (uint num2 = 0u; num2 < num; num2++)
							{
								array[num2] = new CompatibleFramework(array2[num2].AllData);
							}
						}
						CompatibleFrameworks value = new CompatibleFrameworks(compatibleFrameworksData.AllData, array);
						Interlocked.CompareExchange(ref _compatibleFrameworks, value, null);
					}
				}
				return (CompatibleFrameworks)_compatibleFrameworks;
			}
		}

		public EntryPoint[] EntryPoints
		{
			get
			{
				if (_entryPoints == null)
				{
					System.Deployment.Internal.Isolation.ISection section = ((_cms != null) ? _cms.EntryPointSection : null);
					uint num = section?.Count ?? 0;
					EntryPoint[] array = new EntryPoint[num];
					if (num != 0)
					{
						uint celtFetched = 0u;
						System.Deployment.Internal.Isolation.Manifest.IEntryPointEntry[] array2 = new System.Deployment.Internal.Isolation.Manifest.IEntryPointEntry[num];
						System.Deployment.Internal.Isolation.IEnumUnknown enumUnknown = (System.Deployment.Internal.Isolation.IEnumUnknown)section._NewEnum;
						object[] rgelt = array2;
						int errorCode = enumUnknown.Next(num, rgelt, ref celtFetched);
						Marshal.ThrowExceptionForHR(errorCode);
						if (celtFetched != num)
						{
							throw new InvalidDeploymentException(ExceptionTypes.Manifest, Resources.GetString("Ex_IsoEnumFetchNotEqualToCount"));
						}
						for (uint num2 = 0u; num2 < num; num2++)
						{
							array[num2] = new EntryPoint(array2[num2].AllData, this);
						}
					}
					Interlocked.CompareExchange(ref _entryPoints, array, null);
				}
				return (EntryPoint[])_entryPoints;
			}
		}

		public DependentAssembly MainDependentAssembly => DependentAssemblies[0];

		public DependentAssembly CLRDependentAssembly
		{
			get
			{
				if (!_clrDependentAssemblyChecked)
				{
					DependentAssembly[] dependentAssemblies = DependentAssemblies;
					foreach (DependentAssembly dependentAssembly in dependentAssemblies)
					{
						if (dependentAssembly.IsPreRequisite && PlatformDetector.IsCLRDependencyText(dependentAssembly.Identity.Name))
						{
							_clrDependentAssembly = dependentAssembly;
						}
					}
					_clrDependentAssemblyChecked = true;
				}
				return _clrDependentAssembly;
			}
		}

		public bool RequiredHashMissing
		{
			get
			{
				if (!_unhashedDependencyPresent)
				{
					return _unhashedFilePresent;
				}
				return true;
			}
		}

		public bool Signed => _signed;

		public ManifestSourceFormat ManifestSourceFormat => _manifestSourceFormat;

		public AssemblyManifest(FileStream fileStream)
		{
			LoadCMSFromStream(fileStream);
			_rawXmlFilePath = fileStream.Name;
			_manifestSourceFormat = ManifestSourceFormat.XmlFile;
			_sizeInBytes = (ulong)fileStream.Length;
		}

		public AssemblyManifest(Stream stream)
		{
			LoadCMSFromStream(stream);
			_manifestSourceFormat = ManifestSourceFormat.Stream;
			_sizeInBytes = (ulong)stream.Length;
		}

		public AssemblyManifest(string filePath)
		{
			string extension = Path.GetExtension(filePath);
			StringComparison comparisonType = StringComparison.InvariantCultureIgnoreCase;
			if (extension.Equals(".application", comparisonType) || extension.Equals(".manifest", comparisonType))
			{
				LoadFromRawXmlFile(filePath);
			}
			else if (extension.Equals(".dll", comparisonType) || extension.Equals(".exe", comparisonType))
			{
				LoadFromInternalManifestFile(filePath);
			}
			else
			{
				LoadFromUnknownFormatFile(filePath);
			}
		}

		public AssemblyManifest(System.Deployment.Internal.Isolation.Manifest.ICMS cms)
		{
			if (cms == null)
			{
				throw new ArgumentNullException("cms");
			}
			_cms = cms;
		}

		public void ValidateSemantics(ManifestType manifestType)
		{
			switch (manifestType)
			{
			case ManifestType.Deployment:
				ValidateSemanticsForDeploymentRole();
				break;
			case ManifestType.Application:
				ValidateSemanticsForApplicationRole();
				break;
			}
		}

		public File[] GetFilesInGroup(string group, bool optionalOnly)
		{
			StringComparison comparisonType = StringComparison.InvariantCultureIgnoreCase;
			ArrayList arrayList = new ArrayList();
			File[] files = Files;
			foreach (File file in files)
			{
				if ((group == null && !file.IsOptional) || (group != null && group.Equals(file.Group, comparisonType) && (file.IsOptional || !optionalOnly)))
				{
					arrayList.Add(file);
				}
			}
			return (File[])arrayList.ToArray(typeof(File));
		}

		private static bool IsResourceReference(DependentAssembly dependentAssembly)
		{
			if (dependentAssembly.ResourceFallbackCulture != null && dependentAssembly.Identity != null && dependentAssembly.Identity.Culture == null)
			{
				return true;
			}
			return false;
		}

		public DependentAssembly[] GetPrivateAssembliesInGroup(string group, bool optionalOnly)
		{
			StringComparison comparisonType = StringComparison.InvariantCultureIgnoreCase;
			Hashtable hashtable = new Hashtable();
			DependentAssembly[] dependentAssemblies = DependentAssemblies;
			foreach (DependentAssembly dependentAssembly in dependentAssemblies)
			{
				if (!dependentAssembly.IsPreRequisite && ((group == null && !dependentAssembly.IsOptional) || (group != null && group.Equals(dependentAssembly.Group, comparisonType) && (dependentAssembly.IsOptional || !optionalOnly))))
				{
					DependentAssembly dependentAssembly2 = null;
					if (IsResourceReference(dependentAssembly))
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_SatelliteResourcesNotSupported"));
					}
					dependentAssembly2 = dependentAssembly;
					if (dependentAssembly2 != null && !hashtable.Contains(dependentAssembly2.Identity))
					{
						hashtable.Add(dependentAssembly2.Identity, dependentAssembly2);
					}
				}
			}
			DependentAssembly[] array = new DependentAssembly[hashtable.Count];
			hashtable.Values.CopyTo(array, 0);
			return array;
		}

		public DependentAssembly GetDependentAssemblyByIdentity(System.Deployment.Internal.Isolation.IReferenceIdentity refid)
		{
			object ppUnknown = null;
			try
			{
				System.Deployment.Internal.Isolation.ISectionWithReferenceIdentityKey sectionWithReferenceIdentityKey = (System.Deployment.Internal.Isolation.ISectionWithReferenceIdentityKey)_cms.AssemblyReferenceSection;
				sectionWithReferenceIdentityKey.Lookup(refid, out ppUnknown);
			}
			catch (ArgumentException)
			{
				return null;
			}
			System.Deployment.Internal.Isolation.Manifest.IAssemblyReferenceEntry assemblyReferenceEntry = (System.Deployment.Internal.Isolation.Manifest.IAssemblyReferenceEntry)ppUnknown;
			return new DependentAssembly(assemblyReferenceEntry.AllData);
		}

		public File GetFileFromName(string fileName)
		{
			object ppUnknown = null;
			try
			{
				System.Deployment.Internal.Isolation.ISectionWithStringKey sectionWithStringKey = (System.Deployment.Internal.Isolation.ISectionWithStringKey)_cms.FileSection;
				sectionWithStringKey.Lookup(fileName, out ppUnknown);
			}
			catch (ArgumentException)
			{
				return null;
			}
			System.Deployment.Internal.Isolation.Manifest.IFileEntry fileEntry = (System.Deployment.Internal.Isolation.Manifest.IFileEntry)ppUnknown;
			return new File(fileEntry.AllData);
		}

		public ulong CalculateDependenciesSize()
		{
			ulong num = 0uL;
			File[] filesInGroup = GetFilesInGroup(null, optionalOnly: true);
			File[] array = filesInGroup;
			foreach (File file in array)
			{
				num += file.Size;
			}
			DependentAssembly[] privateAssembliesInGroup = GetPrivateAssembliesInGroup(null, optionalOnly: true);
			DependentAssembly[] array2 = privateAssembliesInGroup;
			foreach (DependentAssembly dependentAssembly in array2)
			{
				num += dependentAssembly.Size;
			}
			return num;
		}

		private void LoadCMSFromStream(Stream stream)
		{
			System.Deployment.Internal.Isolation.Manifest.ICMS iCMS = null;
			ManifestParseErrors manifestParseErrors = new ManifestParseErrors();
			int num;
			try
			{
				num = (int)stream.Length;
				_rawXmlBytes = new byte[num];
				if (stream.CanSeek)
				{
					stream.Seek(0L, SeekOrigin.Begin);
				}
				stream.Read(_rawXmlBytes, 0, num);
			}
			catch (IOException innerException)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestParse, Resources.GetString("Ex_ManifestReadException"), innerException);
			}
			try
			{
				iCMS = (System.Deployment.Internal.Isolation.Manifest.ICMS)System.Deployment.Internal.Isolation.IsolationInterop.CreateCMSFromXml(_rawXmlBytes, (uint)num, manifestParseErrors, ref System.Deployment.Internal.Isolation.IsolationInterop.IID_ICMS);
			}
			catch (COMException innerException2)
			{
				StringBuilder stringBuilder = new StringBuilder();
				foreach (ManifestParseErrors.ManifestParseError item in manifestParseErrors)
				{
					stringBuilder.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestParseCMSErrorMessage"), item.hr, item.StartLine, item.nStartColumn, item.ErrorStatusHostFile);
				}
				throw new InvalidDeploymentException(ExceptionTypes.ManifestParse, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestCMSParsingException"), new object[1] { stringBuilder.ToString() }), innerException2);
			}
			catch (SEHException innerException3)
			{
				StringBuilder stringBuilder2 = new StringBuilder();
				foreach (ManifestParseErrors.ManifestParseError item2 in manifestParseErrors)
				{
					stringBuilder2.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestParseCMSErrorMessage"), item2.hr, item2.StartLine, item2.nStartColumn, item2.ErrorStatusHostFile);
				}
				throw new InvalidDeploymentException(ExceptionTypes.ManifestParse, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestCMSParsingException"), new object[1] { stringBuilder2.ToString() }), innerException3);
			}
			catch (ArgumentException innerException4)
			{
				StringBuilder stringBuilder3 = new StringBuilder();
				foreach (ManifestParseErrors.ManifestParseError item3 in manifestParseErrors)
				{
					stringBuilder3.AppendFormat(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestParseCMSErrorMessage"), item3.hr, item3.StartLine, item3.nStartColumn, item3.ErrorStatusHostFile);
				}
				throw new InvalidDeploymentException(ExceptionTypes.ManifestParse, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestCMSParsingException"), new object[1] { stringBuilder3.ToString() }), innerException4);
			}
			if (iCMS == null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestParse, Resources.GetString("Ex_IsoNullCmsCreated"));
			}
			_cms = iCMS;
		}

		private void LoadFromRawXmlFile(string filePath)
		{
			using FileStream fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read);
			LoadCMSFromStream(fileStream);
			_rawXmlFilePath = filePath;
			_manifestSourceFormat = ManifestSourceFormat.XmlFile;
			_sizeInBytes = (ulong)fileStream.Length;
		}

		private bool LoadFromPEResources(string filePath)
		{
			byte[] array = null;
			try
			{
				array = SystemUtils.GetManifestFromPEResources(filePath);
			}
			catch (Win32Exception exception)
			{
				ManifestLoadExceptionHelper(exception, filePath);
			}
			if (array != null)
			{
				using (MemoryStream stream = new MemoryStream(array))
				{
					LoadCMSFromStream(stream);
				}
				_id1Identity = (DefinitionIdentity)Identity.Clone();
				_id1RequestedExecutionLevel = RequestedExecutionLevel;
				Logger.AddInternalState("_id1Identity = " + ((_id1Identity == null) ? "null" : _id1Identity.ToString()));
				_manifestSourceFormat = ManifestSourceFormat.ID_1;
				return true;
			}
			Logger.AddInternalState("File does not contain ID_1 manifest.");
			return false;
		}

		private static DefinitionIdentity ExtractIdentityFromCompLibAssembly(string filePath)
		{
			Logger.AddMethodCall("AssemblyManifest.ExtractIdentityFromCompLibAssembly(" + filePath + ") called.");
			try
			{
				using AssemblyMetaDataImport assemblyMetaDataImport = new AssemblyMetaDataImport(filePath);
				AssemblyName name = assemblyMetaDataImport.Name;
				return SystemUtils.GetDefinitionIdentityFromManagedAssembly(filePath);
			}
			catch (BadImageFormatException)
			{
				return null;
			}
			catch (COMException)
			{
				return null;
			}
			catch (SEHException)
			{
				return null;
			}
		}

		private bool LoadFromCompLibAssembly(string filePath)
		{
			try
			{
				using AssemblyMetaDataImport assemblyMetaDataImport = new AssemblyMetaDataImport(filePath);
				AssemblyName name = assemblyMetaDataImport.Name;
				_identity = SystemUtils.GetDefinitionIdentityFromManagedAssembly(filePath);
				_complibIdentity = (DefinitionIdentity)Identity.Clone();
				AssemblyModule[] files = assemblyMetaDataImport.Files;
				AssemblyReference[] references = assemblyMetaDataImport.References;
				File[] array = new File[files.Length + 1];
				array[0] = new File(Path.GetFileName(filePath), 0uL);
				for (int i = 0; i < files.Length; i++)
				{
					array[i + 1] = new File(files[i].Name, files[i].Hash, 0uL);
				}
				_files = array;
				DependentAssembly[] array2 = new DependentAssembly[references.Length];
				for (int j = 0; j < references.Length; j++)
				{
					array2[j] = new DependentAssembly(new ReferenceIdentity(references[j].Name.ToString()));
				}
				_dependentAssemblies = array2;
				_manifestSourceFormat = ManifestSourceFormat.CompLib;
				return true;
			}
			catch (BadImageFormatException)
			{
				return false;
			}
			catch (COMException)
			{
				return false;
			}
			catch (SEHException)
			{
				return false;
			}
			catch (IOException)
			{
				return false;
			}
		}

		private void LoadFromInternalManifestFile(string filePath)
		{
			byte[] array = null;
			PEStream pEStream = null;
			MemoryStream memoryStream = null;
			AssemblyManifest assemblyManifest = null;
			bool flag = true;
			try
			{
				pEStream = new PEStream(filePath, partialConstruct: true);
				array = pEStream.GetDefaultId1ManifestResource();
				if (array != null)
				{
					memoryStream = new MemoryStream(array);
					assemblyManifest = new AssemblyManifest(memoryStream);
					Logger.AddInternalState("id1Manifest is parsed successfully.");
					_id1ManifestPresent = true;
				}
				flag = pEStream.IsImageFileDll;
			}
			catch (IOException exception)
			{
				ManifestLoadExceptionHelper(exception, filePath);
			}
			catch (Win32Exception exception2)
			{
				ManifestLoadExceptionHelper(exception2, filePath);
			}
			catch (InvalidDeploymentException exception3)
			{
				ManifestLoadExceptionHelper(exception3, filePath);
			}
			finally
			{
				pEStream?.Close();
				memoryStream?.Close();
			}
			if (assemblyManifest != null)
			{
				if (!assemblyManifest.Identity.IsEmpty)
				{
					if (!LoadFromPEResources(filePath))
					{
						ManifestLoadExceptionHelper(new DeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_CannotLoadInternalManifest")), filePath);
					}
					_complibIdentity = ExtractIdentityFromCompLibAssembly(filePath);
					Logger.AddInternalState("_complibIdentity =" + ((_complibIdentity == null) ? "null" : _complibIdentity.ToString()));
				}
				else if (!flag)
				{
					if (!LoadFromCompLibAssembly(filePath))
					{
						ManifestLoadExceptionHelper(new DeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_CannotLoadInternalManifest")), filePath);
					}
					_id1Identity = assemblyManifest.Identity;
					_id1RequestedExecutionLevel = assemblyManifest.RequestedExecutionLevel;
				}
				else
				{
					ManifestLoadExceptionHelper(new DeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_EmptyIdentityInternalManifest")), filePath);
				}
			}
			else if (!LoadFromCompLibAssembly(filePath))
			{
				ManifestLoadExceptionHelper(new DeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_CannotLoadInternalManifest")), filePath);
			}
		}

		private void LoadFromUnknownFormatFile(string filePath)
		{
			try
			{
				LoadFromRawXmlFile(filePath);
			}
			catch (InvalidDeploymentException ex)
			{
				if (ex.SubType == ExceptionTypes.ManifestParse || ex.SubType == ExceptionTypes.ManifestSemanticValidation)
				{
					LoadFromInternalManifestFile(filePath);
					return;
				}
				throw;
			}
		}

		internal void ValidateSignature(Stream s)
		{
			if (string.Equals(Identity.PublicKeyToken, "0000000000000000", StringComparison.Ordinal) && !PolicyKeys.RequireSignedManifests())
			{
				Logger.AddWarningInformation(string.Format(CultureInfo.CurrentUICulture, Resources.GetString("UnsignedManifest")));
				Logger.AddInternalState("Manifest is unsigned.");
				_signed = false;
				return;
			}
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.PreserveWhitespace = true;
			if (s != null)
			{
				xmlDocument.Load(s);
			}
			else
			{
				xmlDocument.Load(_rawXmlFilePath);
			}
			try
			{
				CryptoConfig.AddAlgorithm(typeof(RSAPKCS1SHA256SignatureDescription), "http://www.w3.org/2000/09/xmldsig#rsa-sha256");
				CryptoConfig.AddAlgorithm(typeof(SHA256Cng), "http://www.w3.org/2000/09/xmldsig#sha256");
				System.Deployment.Internal.CodeSigning.SignedCmiManifest signedCmiManifest = new System.Deployment.Internal.CodeSigning.SignedCmiManifest(xmlDocument);
				signedCmiManifest.Verify(System.Deployment.Internal.CodeSigning.CmiManifestVerifyFlags.StrongNameOnly);
			}
			catch (CryptographicException innerException)
			{
				throw new InvalidDeploymentException(ExceptionTypes.SignatureValidation, Resources.GetString("Ex_InvalidXmlSignature"), innerException);
			}
			if (RequiredHashMissing)
			{
				throw new InvalidDeploymentException(ExceptionTypes.SignatureValidation, Resources.GetString("Ex_SignedManifestUnhashedComponent"));
			}
			_signed = true;
		}

		internal static void ReValidateManifestSignatures(AssemblyManifest depManifest, AssemblyManifest appManifest)
		{
			if (depManifest.Signed && !appManifest.Signed)
			{
				throw new InvalidDeploymentException(ExceptionTypes.SignatureValidation, Resources.GetString("Ex_DepSignedAppUnsigned"));
			}
			if (!depManifest.Signed && appManifest.Signed)
			{
				throw new InvalidDeploymentException(ExceptionTypes.SignatureValidation, Resources.GetString("Ex_AppSignedDepUnsigned"));
			}
		}

		internal void ValidateSemanticsForDeploymentRole()
		{
			try
			{
				ValidateAssemblyIdentity(Identity);
				if (Identity.PublicKeyToken == null)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepNotStronglyNamed"));
				}
				if (!PlatformDetector.IsSupportedProcessorArchitecture(Identity.ProcessorArchitecture))
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepProcArchNotSupported"));
				}
				if (Deployment == null)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepMissingDeploymentSection"));
				}
				if (UseManifestForTrust)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepWithUseManifestForTrust"));
				}
				if (Description == null || string.IsNullOrEmpty(Description.FilteredPublisher) || string.IsNullOrEmpty(Description.FilteredProduct))
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepPublisherProductRequired"));
				}
				if (Description.FilteredPublisher.Length + Description.FilteredProduct.Length > 260)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_PublisherProductNameTooLong"));
				}
				if (EntryPoints.Length != 0)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepEntryPointNotAllowed"));
				}
				if (Files.Length != 0)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepFileNotAllowed"));
				}
				if (FileAssociations.Length != 0)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepFileAssocNotAllowed"));
				}
				if (Description.IconFile != null)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepIconFileNotAllowed"));
				}
				if (Deployment.DisallowUrlActivation && !Deployment.Install)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepOnlineOnlyAndDisallowUrlActivation"));
				}
				if (Deployment.DisallowUrlActivation && Deployment.TrustURLParameters)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepTrustUrlAndDisallowUrlActivation"));
				}
				if (CompatibleFrameworks != null)
				{
					if (CompatibleFrameworks.SupportUrl != null)
					{
						if (!CompatibleFrameworks.SupportUrl.IsAbsoluteUri)
						{
							throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_CompatibleFrameworksSupportUrlNoAbsolute"));
						}
						if (!UriHelper.IsSupportedScheme(CompatibleFrameworks.SupportUrl))
						{
							throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_CompatibleFrameworksSupportUrlNotSupportedUriScheme"));
						}
						if (CompatibleFrameworks.SupportUrl.AbsoluteUri.Length > 16384)
						{
							throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_CompatibleFrameworksSupportUrlTooLong"));
						}
					}
					if (CompatibleFrameworks.Frameworks.Count < 1)
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepAtLeastOneFramework"));
					}
					for (int i = 0; i < CompatibleFrameworks.Frameworks.Count; i++)
					{
						CompatibleFramework compatibleFramework = CompatibleFrameworks.Frameworks[i];
						Version version = null;
						try
						{
							version = new Version(compatibleFramework.TargetVersion);
						}
						catch (SystemException ex)
						{
							if (ExceptionUtility.IsHardException(ex))
							{
								throw;
							}
							throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DepInvalidTargetVersion"), new object[1] { compatibleFramework.TargetVersion }), ex);
						}
						try
						{
							Version version2 = new Version(compatibleFramework.SupportedRuntime);
						}
						catch (SystemException ex2)
						{
							if (ExceptionUtility.IsHardException(ex2))
							{
								throw;
							}
							throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DepInvalidSupportedRuntime"), new object[1] { compatibleFramework.SupportedRuntime }), ex2);
						}
						switch (version.Major)
						{
						case 2:
							if (!string.IsNullOrEmpty(compatibleFramework.Profile))
							{
								throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DepUnsupportedFrameworkProfile"), new object[2] { compatibleFramework.Profile, compatibleFramework.TargetVersion }));
							}
							break;
						case 3:
							if (version.Minor >= 1 && version.Minor < 5)
							{
								throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DepUnsupportedFrameworkTargetVersion"), new object[1] { compatibleFramework.TargetVersion }));
							}
							if (!string.IsNullOrEmpty(compatibleFramework.Profile) && (version.Minor < 5 || !"Client".Equals(compatibleFramework.Profile, StringComparison.OrdinalIgnoreCase)))
							{
								throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DepUnsupportedFrameworkProfile"), new object[2] { compatibleFramework.Profile, compatibleFramework.TargetVersion }));
							}
							break;
						default:
							if (version.Major <= 1)
							{
								throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DepUnsupportedFrameworkTargetVersion"), new object[1] { compatibleFramework.TargetVersion }));
							}
							if (string.IsNullOrEmpty(compatibleFramework.Profile))
							{
								throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DepFrameworkProfileRequired"), new object[1] { compatibleFramework.TargetVersion }));
							}
							break;
						}
					}
				}
				if (Deployment.Install)
				{
					if (Deployment.ProviderCodebaseUri != null)
					{
						if (!Deployment.ProviderCodebaseUri.IsAbsoluteUri)
						{
							throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepProviderNotAbsolute"));
						}
						if (!UriHelper.IsSupportedScheme(Deployment.ProviderCodebaseUri))
						{
							throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepProviderNotSupportedUriScheme"));
						}
						if (Deployment.ProviderCodebaseUri.AbsoluteUri.Length > 16384)
						{
							throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepProviderTooLong"));
						}
					}
					if (Deployment.MinimumRequiredVersion != null && Deployment.MinimumRequiredVersion > Identity.Version)
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_MinimumRequiredVersionExceedDeployment"));
					}
				}
				else if (Deployment.MinimumRequiredVersion != null)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepNoMinVerForOnlineApps"));
				}
				if (DependentAssemblies.Length != 1)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepApplicationDependencyRequired"));
				}
				ValidateApplicationDependency(DependentAssemblies[0]);
				if (DependentAssemblies[0].HashCollection.Count == 0)
				{
					_unhashedDependencyPresent = true;
				}
				if (Deployment.DeploymentUpdate.BeforeApplicationStartup && Deployment.DeploymentUpdate.MaximumAgeSpecified)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepBeforeStartupMaxAgeBothPresent"));
				}
				if (Deployment.DeploymentUpdate.MaximumAgeSpecified && Deployment.DeploymentUpdate.MaximumAgeAllowed > TimeSpan.FromDays(365.0))
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_MaxAgeTooLarge"));
				}
			}
			catch (InvalidDeploymentException innerException)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_SemanticallyInvalidDeploymentManifest"), innerException);
			}
		}

		internal void ValidateSemanticsForApplicationRole()
		{
			try
			{
				ValidateAssemblyIdentity(Identity);
				if (EntryPoints.Length != 1)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_AppOneEntryPoint"));
				}
				EntryPoint entryPoint = EntryPoints[0];
				if (!entryPoint.CustomHostSpecified && (entryPoint.Assembly == null || entryPoint.Assembly.IsOptional || entryPoint.Assembly.IsPreRequisite || entryPoint.Assembly.Codebase == null || !UriHelper.IsValidRelativeFilePath(entryPoint.Assembly.Codebase) || UriHelper.PathContainDirectorySeparators(entryPoint.Assembly.Codebase) || !UriHelper.IsValidRelativeFilePath(entryPoint.CommandFile) || UriHelper.PathContainDirectorySeparators(entryPoint.CommandFile) || !entryPoint.CommandFile.Equals(entryPoint.Assembly.Codebase, StringComparison.OrdinalIgnoreCase) || string.Compare(Identity.ProcessorArchitecture, entryPoint.Assembly.Identity.ProcessorArchitecture, StringComparison.OrdinalIgnoreCase) != 0))
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_AppInvalidEntryPoint"));
				}
				if (Application && entryPoint.CommandParameters != null)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_AppInvalidEntryPointParameters"));
				}
				if (DependentAssemblies == null || DependentAssemblies.Length == 0)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_AppAtLeastOneDependency"));
				}
				if (Deployment != null)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_AppNoDeploymentAllowed"));
				}
				if (CompatibleFrameworks != null)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_AppNoCompatibleFrameworksAllowed"));
				}
				if (UseManifestForTrust)
				{
					if (Description == null || (Description != null && (Description.Publisher == null || Description.Product == null)))
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_AppNoOverridePublisherProduct"));
					}
				}
				else if (Description != null && (Description.Publisher != null || Description.Product != null))
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_AppNoPublisherProductAllowed"));
				}
				if (Description != null && Description.IconFile != null && !UriHelper.IsValidRelativeFilePath(Description.IconFile))
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_AppInvalidIconFile"));
				}
				if (Description != null && Description.SupportUri != null)
				{
					if (!Description.SupportUri.IsAbsoluteUri)
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DescriptionSupportUrlNotAbsolute"));
					}
					if (!UriHelper.IsSupportedScheme(Description.SupportUri))
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DescriptionSupportUrlNotSupportedUriScheme"));
					}
					if (Description.SupportUri.AbsoluteUri.Length > 16384)
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DescriptionSupportUrlTooLong"));
					}
				}
				if (Files.Length > 24576)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_TooManyFilesInManifest"));
				}
				Hashtable hashtable = new Hashtable();
				File[] files = Files;
				foreach (File file in files)
				{
					ValidateFile(file);
					if (!file.IsOptional && !hashtable.Contains(file.Name))
					{
						hashtable.Add(file.Name.ToLower(), file);
					}
					if (file.HashCollection.Count == 0)
					{
						_unhashedFilePresent = true;
					}
				}
				if (FileAssociations.Length != 0 && entryPoint.HostInBrowser)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_FileAssociationNotSupportedForHostInBrowser"));
				}
				if (FileAssociations.Length != 0 && entryPoint.CustomHostSpecified)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_FileAssociationNotSupportedForCustomHost"));
				}
				if (FileAssociations.Length > 8)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_TooManyFileAssociationsInManifest"), new object[1] { 8 }));
				}
				Hashtable hashtable2 = new Hashtable();
				FileAssociation[] fileAssociations = FileAssociations;
				foreach (FileAssociation fileAssociation in fileAssociations)
				{
					if (string.IsNullOrEmpty(fileAssociation.Extension) || string.IsNullOrEmpty(fileAssociation.Description) || string.IsNullOrEmpty(fileAssociation.ProgID) || string.IsNullOrEmpty(fileAssociation.DefaultIcon))
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_FileExtensionInfoMissing"));
					}
					if (fileAssociation.Extension.Length > 0)
					{
						char c = fileAssociation.Extension[0];
						if (c != '.')
						{
							throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileAssociationExtensionNoDot"), new object[1] { fileAssociation.Extension }));
						}
					}
					string path = "file" + fileAssociation.Extension;
					if (!UriHelper.IsValidRelativeFilePath(path))
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileAssociationInvalid"), new object[1] { fileAssociation.Extension }));
					}
					if (fileAssociation.Extension.Length > 24)
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileExtensionTooLong"), new object[1] { fileAssociation.Extension }));
					}
					if (!hashtable.Contains(fileAssociation.DefaultIcon.ToLower()))
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileAssociationIconFileNotFound"), new object[1] { fileAssociation.DefaultIcon }));
					}
					if (hashtable2.Contains(fileAssociation.Extension))
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_MultipleInstanceFileExtension"), new object[1] { fileAssociation.Extension }));
					}
					hashtable2.Add(fileAssociation.Extension, fileAssociation);
				}
				if (DependentAssemblies.Length > 24576)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_TooManyAssembliesInManifest"));
				}
				bool flag = false;
				DependentAssembly[] dependentAssemblies = DependentAssemblies;
				foreach (DependentAssembly dependentAssembly in dependentAssemblies)
				{
					ValidateComponentDependency(dependentAssembly);
					if (dependentAssembly.IsPreRequisite && PlatformDetector.IsCLRDependencyText(dependentAssembly.Identity.Name))
					{
						flag = true;
						_clrDependentAssembly = dependentAssembly;
					}
					if (!dependentAssembly.IsPreRequisite && dependentAssembly.HashCollection.Count == 0)
					{
						_unhashedDependencyPresent = true;
					}
				}
				_clrDependentAssemblyChecked = true;
				if (DependentOS != null && DependentOS.SupportUrl != null)
				{
					if (!DependentOS.SupportUrl.IsAbsoluteUri)
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepenedentOSSupportUrlNotAbsolute"));
					}
					if (!UriHelper.IsSupportedScheme(DependentOS.SupportUrl))
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepenedentOSSupportUrlNotSupportedUriScheme"));
					}
					if (DependentOS.SupportUrl.AbsoluteUri.Length > 16384)
					{
						throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, Resources.GetString("Ex_DepenedentOSSupportUrlTooLong"));
					}
				}
				if (!flag)
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_AppNoCLRDependency")));
				}
			}
			catch (InvalidDeploymentException innerException)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestSemanticValidation, Resources.GetString("Ex_SemanticallyInvalidApplicationManifest"), innerException);
			}
		}

		internal static CertificateStatus AnalyzeManifestCertificate(string manifestPath)
		{
			Logger.AddMethodCall("AnalyzeManifestCertificate called.");
			CertificateStatus certificateStatus = CertificateStatus.UnknownCertificateStatus;
			System.Deployment.Internal.CodeSigning.SignedCmiManifest2 signedManifest = null;
			XmlDocument xmlDocument = new XmlDocument();
			try
			{
				xmlDocument.PreserveWhitespace = true;
				xmlDocument.Load(manifestPath);
				VerifyManifestCertificate(xmlDocument, out signedManifest, out certificateStatus, useSha256: true);
			}
			catch (Exception ex)
			{
				if (ExceptionUtility.IsHardException(ex))
				{
					throw;
				}
				if (ex is CryptographicException)
				{
					if (signedManifest.StrongNameSignerInfo != null && signedManifest.StrongNameSignerInfo.ErrorCode == -2146869232)
					{
						try
						{
							VerifyManifestCertificate(xmlDocument, out signedManifest, out certificateStatus, useSha256: false);
						}
						catch (Exception ex2)
						{
							if (ExceptionUtility.IsHardException(ex2))
							{
								throw;
							}
							if (ex2 is CryptographicException && signedManifest.AuthenticodeSignerInfo != null)
							{
								certificateStatus = GetCertificateStatus(signedManifest.AuthenticodeSignerInfo.ErrorCode);
							}
							Logger.AddInternalState("Exception thrown : " + ex2.GetType().ToString() + ":" + ex2.Message);
						}
					}
					else if (signedManifest.AuthenticodeSignerInfo != null)
					{
						certificateStatus = GetCertificateStatus(signedManifest.AuthenticodeSignerInfo.ErrorCode);
					}
				}
				Logger.AddInternalState("Exception thrown : " + ex.GetType().ToString() + ":" + ex.Message);
			}
			Logger.AddInternalState("Certificate Status=" + certificateStatus);
			return certificateStatus;
		}

		private static void VerifyManifestCertificate(XmlDocument deploymentManifestXmlDom, out System.Deployment.Internal.CodeSigning.SignedCmiManifest2 signedManifest, out CertificateStatus certificateStatus, bool useSha256)
		{
			certificateStatus = CertificateStatus.UnknownCertificateStatus;
			signedManifest = new System.Deployment.Internal.CodeSigning.SignedCmiManifest2(deploymentManifestXmlDom, useSha256);
			signedManifest.Verify(System.Deployment.Internal.CodeSigning.CmiManifestVerifyFlags.None);
			if (signedManifest == null || signedManifest.AuthenticodeSignerInfo == null)
			{
				certificateStatus = CertificateStatus.NoCertificate;
			}
			else
			{
				certificateStatus = CertificateStatus.TrustedPublisher;
			}
		}

		private static CertificateStatus GetCertificateStatus(int error)
		{
			CertificateStatus certificateStatus = CertificateStatus.UnknownCertificateStatus;
			return error switch
			{
				-2146762479 => CertificateStatus.DistrustedPublisher, 
				-2146885616 => CertificateStatus.RevokedCertificate, 
				-2146762748 => CertificateStatus.AuthenticodedNotInTrustedList, 
				_ => CertificateStatus.NoCertificate, 
			};
		}

		private static void ValidateAssemblyIdentity(DefinitionIdentity identity)
		{
			if (identity.Name != null && (identity.Name.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0 || identity.Name.IndexOfAny(Path.GetInvalidPathChars()) >= 0 || identity.Name.IndexOfAny(SpecificInvalidIdentityChars) >= 0))
			{
				string text = new string(Path.GetInvalidFileNameChars()) + " " + new string(Path.GetInvalidPathChars()) + " " + new string(SpecificInvalidIdentityChars);
				Logger.AddInternalState(identity.Name + " contains an invalid character. InvalidIdentityChars=[" + text + "].");
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_IdentityWithInvalidChars"), new object[1] { identity.Name }));
			}
			try
			{
				if (identity.ToString().Length > 2048)
				{
					throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_IdentityTooLong"));
				}
			}
			catch (COMException innerException)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_IdentityIsNotValid"), innerException);
			}
			catch (SEHException innerException2)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_IdentityIsNotValid"), innerException2);
			}
		}

		private static void ValidateAssemblyIdentity(ReferenceIdentity identity)
		{
			if (identity.Name != null && (identity.Name.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0 || identity.Name.IndexOfAny(Path.GetInvalidPathChars()) >= 0 || identity.Name.IndexOfAny(SpecificInvalidIdentityChars) >= 0))
			{
				string text = new string(Path.GetInvalidFileNameChars()) + " " + new string(Path.GetInvalidPathChars()) + " " + new string(SpecificInvalidIdentityChars);
				Logger.AddInternalState(identity.Name + " contains an invalid character. InvalidIdentityChars= [" + text + "].");
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_IdentityWithInvalidChars"), new object[1] { identity.Name }));
			}
			try
			{
				if (identity.ToString().Length > 2048)
				{
					throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_IdentityTooLong"));
				}
			}
			catch (COMException innerException)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_IdentityIsNotValid"), innerException);
			}
			catch (SEHException innerException2)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_IdentityIsNotValid"), innerException2);
			}
		}

		private void ValidateApplicationDependency(DependentAssembly da)
		{
			ValidateAssemblyIdentity(da.Identity);
			if (da.Identity.PublicKeyToken == null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_DepAppRefNotStrongNamed"));
			}
			if (IsInvalidHash(da.HashCollection))
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_DepAppRefHashInvalid"));
			}
			if (string.Compare(Identity.ProcessorArchitecture, da.Identity.ProcessorArchitecture, StringComparison.OrdinalIgnoreCase) != 0)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DepAppRefProcArchMismatched"), new object[2]
				{
					da.Identity.ProcessorArchitecture,
					Identity.ProcessorArchitecture
				}));
			}
			if (da.ResourceFallbackCulture != null || da.IsPreRequisite || da.IsOptional)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_DepAppRefPrereqOrOptionalOrResourceFallback"));
			}
			Uri uri = null;
			try
			{
				uri = new Uri(da.Codebase, UriKind.RelativeOrAbsolute);
			}
			catch (UriFormatException innerException)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_DepAppRefInvalidCodebaseUri"), innerException);
			}
			if (uri.IsAbsoluteUri && !UriHelper.IsSupportedScheme(uri))
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, Resources.GetString("Ex_DepAppRefInvalidCodebaseUri"));
			}
			if (!UriHelper.IsValidRelativeFilePath(da.Identity.Name) || UriHelper.PathContainDirectorySeparators(da.Identity.Name))
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DepAppRefInvalidIdentityName"), new object[1] { da.Identity.Name }));
			}
		}

		private static void ValidateComponentDependency(DependentAssembly da)
		{
			ValidateAssemblyIdentity(da.Identity);
			if (!da.IsPreRequisite)
			{
				if (da.ResourceFallbackCulture == null)
				{
					if (IsInvalidHash(da.HashCollection))
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyInvalidHash"), new object[1] { da.Identity.ToString() }));
					}
					if (da.Codebase == null)
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyNoCodebase"), new object[1] { da.Identity.ToString() }));
					}
					if (!UriHelper.IsValidRelativeFilePath(da.Codebase))
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyNotRelativePath"), new object[1] { da.Identity.ToString() }));
					}
					if (da.IsOptional && da.Group == null)
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyOptionalButNoGroup"), new object[1] { da.Identity.ToString() }));
					}
				}
				else if (da.Identity.Culture == null)
				{
					if (da.Codebase != null)
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyResourceWithCodebase"), new object[1] { da.Identity.ToString() }));
					}
					if (da.HashCollection.Count > 0)
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyResourceWithHash"), new object[1] { da.Identity.ToString() }));
					}
				}
				else
				{
					if (IsInvalidHash(da.HashCollection))
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyInvalidHash"), new object[1] { da.Identity.ToString() }));
					}
					if (da.Codebase == null)
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyNoCodebase"), new object[1] { da.Identity.ToString() }));
					}
					if (!UriHelper.IsValidRelativeFilePath(da.Codebase))
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyNotRelativePath"), new object[1] { da.Identity.ToString() }));
					}
					if (da.ResourceFallbackCulture != null)
					{
						throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyResourceWithFallback"), new object[1] { da.Identity.ToString() }));
					}
				}
			}
			else if (!PlatformDetector.IsCLRDependencyText(da.Identity.Name) && da.Identity.PublicKeyToken == null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencyGACNoPKT"), new object[1] { da.Identity.ToString() }));
			}
			if (da.SupportUrl != null)
			{
				if (!da.SupportUrl.IsAbsoluteUri)
				{
					throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencySupportUrlNoAbsolute"), new object[1] { da.Identity.ToString() }));
				}
				if (!UriHelper.IsSupportedScheme(da.SupportUrl))
				{
					throw new InvalidDeploymentException(ExceptionTypes.InvalidManifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencySupportUrlNotSupportedUriScheme"), new object[1] { da.Identity.ToString() }));
				}
				if (da.SupportUrl.AbsoluteUri.Length > 16384)
				{
					throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_DependencySupportUrlTooLong"), new object[1] { da.Identity.ToString() }));
				}
			}
		}

		private static void ValidateFile(File f)
		{
			if (IsInvalidHash(f.HashCollection))
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_InvalidFileHash"), new object[1] { f.Name }));
			}
			if (!UriHelper.IsValidRelativeFilePath(f.Name))
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FilePathNotRelative"), new object[1] { f.Name }));
			}
			if (f.IsOptional && f.Group == null)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileOptionalButNoGroup"), new object[1] { f.Name }));
			}
			if (f.IsOptional && f.IsData)
			{
				throw new InvalidDeploymentException(ExceptionTypes.ManifestComponentSemanticValidation, string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_FileOptionalAndData"), new object[1] { f.Name }));
			}
		}

		private static bool IsInvalidHash(HashCollection hashCollection)
		{
			return !ComponentVerifier.IsVerifiableHashCollection(hashCollection);
		}

		internal static Uri UriFromMetadataEntry(string uriString, string exResourceStr)
		{
			try
			{
				return (uriString != null) ? new Uri(uriString) : null;
			}
			catch (UriFormatException innerException)
			{
				throw new InvalidDeploymentException(ExceptionTypes.Manifest, string.Format(CultureInfo.CurrentUICulture, Resources.GetString(exResourceStr), new object[1] { uriString }), innerException);
			}
		}

		private static void ManifestLoadExceptionHelper(Exception exception, string filePath)
		{
			string fileName = Path.GetFileName(filePath);
			string message = string.Format(CultureInfo.CurrentUICulture, Resources.GetString("Ex_ManifestLoadFromFile"), new object[1] { fileName });
			throw new InvalidDeploymentException(ExceptionTypes.ManifestLoad, message, exception);
		}
	}
}
namespace System.Security.Cryptography
{
	internal static class CngLightup
	{
		private const string DsaOid = "1.2.840.10040.4.1";

		private const string RsaOid = "1.2.840.113549.1.1.1";

		private const string HashAlgorithmNameTypeName = "System.Security.Cryptography.HashAlgorithmName";

		private const string RSASignaturePaddingTypeName = "System.Security.Cryptography.RSASignaturePadding";

		private const string RSAEncryptionPaddingTypeName = "System.Security.Cryptography.RSAEncryptionPadding";

		private const string RSACngTypeName = "System.Security.Cryptography.RSACng";

		private const string DSACngTypeName = "System.Security.Cryptography.DSACng";

		private static readonly Type s_hashAlgorithmNameType = typeof(object).Assembly.GetType("System.Security.Cryptography.HashAlgorithmName", throwOnError: false);

		private static readonly Type s_rsaSignaturePaddingType = typeof(object).Assembly.GetType("System.Security.Cryptography.RSASignaturePadding", throwOnError: false);

		private static readonly Type s_rsaEncryptionPaddingType = typeof(object).Assembly.GetType("System.Security.Cryptography.RSAEncryptionPadding", throwOnError: false);

		private static readonly object s_pkcs1SignaturePadding = ((s_rsaSignaturePaddingType == null) ? null : s_rsaSignaturePaddingType.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null));

		private static readonly object s_pkcs1EncryptionPadding = ((s_rsaEncryptionPaddingType == null) ? null : s_rsaEncryptionPaddingType.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null));

		private static readonly object s_oaepSha1EncryptionPadding = ((s_rsaEncryptionPaddingType == null) ? null : s_rsaEncryptionPaddingType.GetProperty("OaepSHA1", BindingFlags.Static | BindingFlags.Public).GetValue(null));

		private static readonly Lazy<bool> s_preferRsaCng = new Lazy<bool>(DetectRsaCngSupport);

		private static volatile Func<X509Certificate2, DSA> s_getDsaPublicKey;

		private static volatile Func<X509Certificate2, DSA> s_getDsaPrivateKey;

		private static volatile Func<X509Certificate2, RSA> s_getRsaPublicKey;

		private static volatile Func<X509Certificate2, RSA> s_getRsaPrivateKey;

		private static volatile Func<RSA, byte[], string, byte[]> s_rsaPkcs1SignMethod;

		private static volatile Func<RSA, byte[], byte[], string, bool> s_rsaPkcs1VerifyMethod;

		private static volatile Func<RSA, byte[], byte[]> s_rsaPkcs1EncryptMethod;

		private static volatile Func<RSA, byte[], byte[]> s_rsaPkcs1DecryptMethod;

		private static volatile Func<RSA, byte[], byte[]> s_rsaOaepSha1EncryptMethod;

		private static volatile Func<RSA, byte[], byte[]> s_rsaOaepSha1DecryptMethod;

		private static volatile Func<X509Certificate2, ECDsa> s_getECDsaPublicKey;

		private static volatile Func<X509Certificate2, ECDsa> s_getECDsaPrivateKey;

		internal static RSA GetRSAPublicKey(X509Certificate2 cert)
		{
			if (s_getRsaPublicKey == null)
			{
				if (s_preferRsaCng.Value)
				{
					s_getRsaPublicKey = BindCoreDelegate<RSA>("RSA", isPublic: true) ?? BindGetCapiPublicKey<RSA, RSACryptoServiceProvider>("1.2.840.113549.1.1.1");
				}
				else
				{
					s_getRsaPublicKey = BindGetCapiPublicKey<RSA, RSACryptoServiceProvider>("1.2.840.113549.1.1.1");
				}
			}
			return s_getRsaPublicKey(cert);
		}

		internal static RSA GetRSAPrivateKey(X509Certificate2 cert)
		{
			if (s_getRsaPrivateKey == null)
			{
				if (s_preferRsaCng.Value)
				{
					s_getRsaPrivateKey = BindCoreDelegate<RSA>("RSA", isPublic: false) ?? BindGetCapiPrivateKey("1.2.840.113549.1.1.1", (Func<CspParameters, RSA>)((CspParameters csp) => new RSACryptoServiceProvider(csp)));
				}
				else
				{
					s_getRsaPrivateKey = BindGetCapiPrivateKey("1.2.840.113549.1.1.1", (Func<CspParameters, RSA>)((CspParameters csp) => new RSACryptoServiceProvider(csp)));
				}
			}
			return s_getRsaPrivateKey(cert);
		}

		internal static DSA GetDSAPublicKey(X509Certificate2 cert)
		{
			if (s_getDsaPublicKey == null)
			{
				s_getDsaPublicKey = BindCoreDelegate<DSA>("DSA", isPublic: true) ?? BindGetCapiPublicKey<DSA, DSACryptoServiceProvider>("1.2.840.10040.4.1");
			}
			return s_getDsaPublicKey(cert);
		}

		internal static DSA GetDSAPrivateKey(X509Certificate2 cert)
		{
			if (s_getDsaPrivateKey == null)
			{
				s_getDsaPrivateKey = BindCoreDelegate<DSA>("DSA", isPublic: false) ?? BindGetCapiPrivateKey("1.2.840.10040.4.1", (Func<CspParameters, DSA>)((CspParameters csp) => new DSACryptoServiceProvider(csp)));
			}
			return s_getDsaPrivateKey(cert);
		}

		internal static ECDsa GetECDsaPublicKey(X509Certificate2 cert)
		{
			if (s_getECDsaPublicKey == null)
			{
				s_getECDsaPublicKey = BindCoreDelegate<ECDsa>("ECDsa", isPublic: true) ?? ((Func<X509Certificate2, ECDsa>)((X509Certificate2 c) => null));
			}
			return s_getECDsaPublicKey(cert);
		}

		internal static ECDsa GetECDsaPrivateKey(X509Certificate2 cert)
		{
			if (s_getECDsaPrivateKey == null)
			{
				s_getECDsaPrivateKey = BindCoreDelegate<ECDsa>("ECDsa", isPublic: false) ?? ((Func<X509Certificate2, ECDsa>)((X509Certificate2 c) => null));
			}
			return s_getECDsaPrivateKey(cert);
		}

		internal static byte[] Pkcs1SignData(RSA rsa, byte[] data, string hashAlgorithmName)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.SignData(data, hashAlgorithmName);
			}
			if (s_rsaPkcs1SignMethod == null)
			{
				Type[] types = new Type[3]
				{
					typeof(byte[]),
					s_hashAlgorithmNameType,
					s_rsaSignaturePaddingType
				};
				MethodInfo method = typeof(RSA).GetMethod("SignData", BindingFlags.Instance | BindingFlags.Public, null, types, null);
				Type type = typeof(Func<, , , , >).MakeGenericType(typeof(RSA), typeof(byte[]), s_hashAlgorithmNameType, s_rsaSignaturePaddingType, typeof(byte[]));
				Delegate openDelegate = Delegate.CreateDelegate(type, method);
				s_rsaPkcs1SignMethod = delegate(RSA delegateRsa, byte[] delegateData, string delegateAlgorithm)
				{
					object obj = Activator.CreateInstance(s_hashAlgorithmNameType, delegateAlgorithm);
					object[] args = new object[4] { delegateRsa, delegateData, obj, s_pkcs1SignaturePadding };
					return (byte[])openDelegate.DynamicInvoke(args);
				};
			}
			return s_rsaPkcs1SignMethod(rsa, data, hashAlgorithmName);
		}

		internal static bool Pkcs1VerifyData(RSA rsa, byte[] data, byte[] signature, string hashAlgorithmName)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.VerifyData(data, hashAlgorithmName, signature);
			}
			if (s_rsaPkcs1VerifyMethod == null)
			{
				Type[] types = new Type[4]
				{
					typeof(byte[]),
					typeof(byte[]),
					s_hashAlgorithmNameType,
					s_rsaSignaturePaddingType
				};
				MethodInfo method = typeof(RSA).GetMethod("VerifyData", BindingFlags.Instance | BindingFlags.Public, null, types, null);
				Type type = typeof(Func<, , , , , >).MakeGenericType(typeof(RSA), typeof(byte[]), typeof(byte[]), s_hashAlgorithmNameType, s_rsaSignaturePaddingType, typeof(bool));
				Delegate openDelegate = Delegate.CreateDelegate(type, method);
				s_rsaPkcs1VerifyMethod = delegate(RSA delegateRsa, byte[] delegateData, byte[] delegateSignature, string delegateAlgorithm)
				{
					object obj = Activator.CreateInstance(s_hashAlgorithmNameType, delegateAlgorithm);
					object[] args = new object[5] { delegateRsa, delegateData, delegateSignature, obj, s_pkcs1SignaturePadding };
					return (bool)openDelegate.DynamicInvoke(args);
				};
			}
			return s_rsaPkcs1VerifyMethod(rsa, data, signature, hashAlgorithmName);
		}

		internal static byte[] Pkcs1Encrypt(RSA rsa, byte[] data)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.Encrypt(data, fOAEP: false);
			}
			if (s_rsaPkcs1EncryptMethod == null)
			{
				Delegate openDelegate = BindRsaCryptMethod("Encrypt");
				s_rsaPkcs1EncryptMethod = (RSA delegateRsa, byte[] delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_pkcs1EncryptionPadding);
			}
			return s_rsaPkcs1EncryptMethod(rsa, data);
		}

		internal static byte[] Pkcs1Decrypt(RSA rsa, byte[] data)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.Decrypt(data, fOAEP: false);
			}
			if (s_rsaPkcs1DecryptMethod == null)
			{
				Delegate openDelegate = BindRsaCryptMethod("Decrypt");
				s_rsaPkcs1DecryptMethod = (RSA delegateRsa, byte[] delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_pkcs1EncryptionPadding);
			}
			return s_rsaPkcs1DecryptMethod(rsa, data);
		}

		internal static byte[] OaepSha1Encrypt(RSA rsa, byte[] data)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.Encrypt(data, fOAEP: true);
			}
			if (s_rsaOaepSha1EncryptMethod == null)
			{
				Delegate openDelegate = BindRsaCryptMethod("Encrypt");
				s_rsaOaepSha1EncryptMethod = (RSA delegateRsa, byte[] delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_oaepSha1EncryptionPadding);
			}
			return s_rsaOaepSha1EncryptMethod(rsa, data);
		}

		internal static byte[] OaepSha1Decrypt(RSA rsa, byte[] data)
		{
			if (rsa is RSACryptoServiceProvider rSACryptoServiceProvider)
			{
				return rSACryptoServiceProvider.Decrypt(data, fOAEP: true);
			}
			if (s_rsaOaepSha1DecryptMethod == null)
			{
				Delegate openDelegate = BindRsaCryptMethod("Decrypt");
				s_rsaOaepSha1DecryptMethod = (RSA delegateRsa, byte[] delegateData) => (byte[])openDelegate.DynamicInvoke(delegateRsa, delegateData, s_oaepSha1EncryptionPadding);
			}
			return s_rsaOaepSha1DecryptMethod(rsa, data);
		}

		private static Delegate BindRsaCryptMethod(string methodName)
		{
			Type[] types = new Type[2]
			{
				typeof(byte[]),
				s_rsaEncryptionPaddingType
			};
			MethodInfo method = typeof(RSA).GetMethod(methodName, BindingFlags.Instance | BindingFlags.Public, null, types, null);
			Type type = typeof(Func<, , , >).MakeGenericType(typeof(RSA), typeof(byte[]), s_rsaEncryptionPaddingType, typeof(byte[]));
			return Delegate.CreateDelegate(type, method);
		}

		private static bool DetectRsaCngSupport()
		{
			Type systemCoreType = GetSystemCoreType("System.Security.Cryptography.RSACng", throwOnError: false);
			if (systemCoreType == null)
			{
				return false;
			}
			Type systemCoreType2 = GetSystemCoreType("System.Security.Cryptography.DSACng", throwOnError: false);
			if (systemCoreType2 == null)
			{
				return false;
			}
			Type[] types = new Type[2]
			{
				typeof(byte[]),
				s_hashAlgorithmNameType
			};
			MethodInfo method = typeof(DSA).GetMethod("SignData", BindingFlags.Instance | BindingFlags.Public, null, types, null);
			if (method == null)
			{
				return false;
			}
			return true;
		}

		private static Func<X509Certificate2, T> BindGetCapiPublicKey<T, TCryptoServiceProvider>(string algorithmOid) where T : AsymmetricAlgorithm where TCryptoServiceProvider : T, ICspAsymmetricAlgorithm, new()
		{
			return delegate(X509Certificate2 cert)
			{
				PublicKey publicKey = cert.PublicKey;
				if (publicKey.Oid.Value != algorithmOid)
				{
					return null;
				}
				AsymmetricAlgorithm key = publicKey.Key;
				ICspAsymmetricAlgorithm cspAsymmetricAlgorithm = (ICspAsymmetricAlgorithm)key;
				byte[] rawData = cspAsymmetricAlgorithm.ExportCspBlob(includePrivateParameters: false);
				TCryptoServiceProvider val = new TCryptoServiceProvider();
				val.ImportCspBlob(rawData);
				return (T)val;
			};
		}

		private static Func<X509Certificate2, T> BindGetCapiPrivateKey<T>(string algorithmOid, Func<CspParameters, T> instanceFactory) where T : AsymmetricAlgorithm
		{
			return delegate(X509Certificate2 cert)
			{
				if (!cert.HasPrivateKey)
				{
					return null;
				}
				PublicKey publicKey = cert.PublicKey;
				if (publicKey.Oid.Value != algorithmOid)
				{
					return null;
				}
				AsymmetricAlgorithm privateKey = cert.PrivateKey;
				ICspAsymmetricAlgorithm cspAlgorithm = (ICspAsymmetricAlgorithm)privateKey;
				CspParameters arg = CopyCspParameters(cspAlgorithm);
				return instanceFactory(arg);
			};
		}

		private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmName, bool isPublic)
		{
			string namespaceQualifiedTypeName = "System.Security.Cryptography.X509Certificates." + algorithmName + "CertificateExtensions";
			Type systemCoreType = GetSystemCoreType(namespaceQualifiedTypeName, throwOnError: false);
			if (systemCoreType == null)
			{
				return null;
			}
			string name = "Get" + algorithmName + (isPublic ? "Public" : "Private") + "Key";
			MethodInfo method = systemCoreType.GetMethod(name, BindingFlags.Static | BindingFlags.Public, null, new Type[1] { typeof(X509Certificate2) }, null);
			return (Func<X509Certificate2, T>)method.CreateDelegate(typeof(Func<X509Certificate2, T>));
		}

		private static CspParameters CopyCspParameters(ICspAsymmetricAlgorithm cspAlgorithm)
		{
			CspKeyContainerInfo cspKeyContainerInfo = cspAlgorithm.CspKeyContainerInfo;
			CspParameters cspParameters = new CspParameters(cspKeyContainerInfo.ProviderType, cspKeyContainerInfo.ProviderName, cspKeyContainerInfo.KeyContainerName)
			{
				Flags = CspProviderFlags.UseExistingKey,
				KeyNumber = (int)cspKeyContainerInfo.KeyNumber
			};
			if (cspKeyContainerInfo.MachineKeyStore)
			{
				cspParameters.Flags |= CspProviderFlags.UseMachineKeyStore;
			}
			return cspParameters;
		}

		private static Type GetSystemCoreType(string namespaceQualifiedTypeName, bool throwOnError = true)
		{
			Assembly assembly = typeof(CngKey).Assembly;
			return assembly.GetType(namespaceQualifiedTypeName, throwOnError);
		}
	}
}
