
// C:\WINDOWS\Microsoft.NET\assembly\GAC_MSIL\System.Drawing\v4.0_4.0.0.0__b03f5f7f11d50a3a\System.Drawing.dll
// System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v4.0.30319
// This assembly is signed with a strong name key.
// Hash algorithm: SHA1
// Public key: 002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.ComponentModel.Design.Serialization;
using System.Configuration;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Configuration;
using System.Drawing.Design;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.Internal;
using System.Drawing.Printing;
using System.Drawing.Text;
using System.Globalization;
using System.Internal;
using System.IO;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using Microsoft.Win32;

[assembly: CompilationRelaxations(8)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: Dependency("System,", LoadHint.Always)]
[assembly: TypeLibVersion(2, 4)]
[assembly: BitmapSuffixInSatelliteAssembly]
[assembly: ComVisible(false)]
[assembly: CLSCompliant(true)]
[assembly: AllowPartiallyTrustedCallers]
[assembly: SecurityRules(SecurityRuleSet.Level1, SkipVerificationInFullTrust = true)]
[assembly: AssemblyTitle("System.Drawing.dll")]
[assembly: AssemblyDescription("System.Drawing.dll")]
[assembly: AssemblyDefaultAlias("System.Drawing.dll")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyFileVersion("4.8.9037.0")]
[assembly: AssemblyInformationalVersion("4.8.9037.0")]
[assembly: SatelliteContractVersion("4.0.0.0")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: AssemblyDelaySign(true)]
[assembly: AssemblyKeyFile("f:\\dd\\tools\\devdiv\\FinalPublicKey.snk")]
[assembly: AssemblySignatureKey("002400000c800000140100000602000000240000525341310008000001000100613399aff18ef1a2c2514a273a42d9042b72321f1757102df9ebada69923e2738406c21e5b801552ab8d200a65a235e001ac9adc25f2d811eb09496a4c6a59d4619589c69f5baf0c4179a47311d92555cd006acc8b5959f2bd6e10e360c34537a1d266da8085856583c85d81da7f3ec01ed9564c58d93d713cd0172c8e23a10f0239b80c96b07736f5d8b022542a4e74251a5f432824318b3539a5a087f8e53d2f135f9ca47f3bb2e10aff0af0849504fb7cea3ff192dc8de0edad64c68efde34c56d302ad55fd6e80f302d5efcdeae953658d3452561b5f36c542efdbdd9f888538d374cef106acf7d93a4445c3c73cd911f0571aaf3d54da12b11ddec375b3", "a5a866e1ee186f807668209f3b11236ace5e21f117803a3143abb126dd035d7d2f876b6938aaf2ee3414d5420d753621400db44a49c486ce134300a2106adb6bdb433590fef8ad5c43cba82290dc49530effd86523d9483c00f458af46890036b0e2c61d077d7fbac467a506eba29e467a87198b053c749aa2a4d2840c784e6d")]
[assembly: ComCompatibleVersion(1, 0, 3300, 0)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: DefaultDllImportSearchPaths(DllImportSearchPath.System32 | DllImportSearchPath.AssemblyDirectory)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("4.0.0.0")]
[module: UnverifiableCode]
internal static class FXAssembly
{
	internal const string Version = "4.0.0.0";
}
internal static class ThisAssembly
{
	internal const string Title = "System.Drawing.dll";

	internal const string Description = "System.Drawing.dll";

	internal const string DefaultAlias = "System.Drawing.dll";

	internal const string Copyright = "© Microsoft Corporation.  All rights reserved.";

	internal const string Version = "4.0.0.0";

	internal const string InformationalVersion = "4.8.9037.0";

	internal const string DailyBuildNumberStr = "30319";

	internal const string BuildRevisionStr = "0";

	internal const int DailyBuildNumber = 30319;
}
internal static class AssemblyRef
{
	internal const string EcmaPublicKey = "b77a5c561934e089";

	internal const string EcmaPublicKeyToken = "b77a5c561934e089";

	internal const string EcmaPublicKeyFull = "00000000000000000400000000000000";

	internal const string SilverlightPublicKey = "31bf3856ad364e35";

	internal const string SilverlightPublicKeyToken = "31bf3856ad364e35";

	internal const string SilverlightPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9";

	internal const string SilverlightPlatformPublicKey = "7cec85d7bea7798e";

	internal const string SilverlightPlatformPublicKeyToken = "7cec85d7bea7798e";

	internal const string SilverlightPlatformPublicKeyFull = "00240000048000009400000006020000002400005253413100040000010001008D56C76F9E8649383049F383C44BE0EC204181822A6C31CF5EB7EF486944D032188EA1D3920763712CCB12D75FB77E9811149E6148E5D32FBAAB37611C1878DDC19E20EF135D0CB2CFF2BFEC3D115810C3D9069638FE4BE215DBF795861920E5AB6F7DB2E2CEEF136AC23D5DD2BF031700AEC232F6C6B1C785B4305C123B37AB";

	internal const string PlatformPublicKey = "b77a5c561934e089";

	internal const string PlatformPublicKeyToken = "b77a5c561934e089";

	internal const string PlatformPublicKeyFull = "00000000000000000400000000000000";

	internal const string Mscorlib = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemData = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemDataOracleClient = "System.Data.OracleClient, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string System = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemCore = "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemNumerics = "System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeRemoting = "System.Runtime.Remoting, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemThreadingTasksDataflow = "System.Threading.Tasks.Dataflow, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWindowsForms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemXml = "System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string MicrosoftPublicKey = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyToken = "b03f5f7f11d50a3a";

	internal const string MicrosoftPublicKeyFull = "002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293";

	internal const string SharedLibPublicKey = "31bf3856ad364e35";

	internal const string SharedLibPublicKeyToken = "31bf3856ad364e35";

	internal const string SharedLibPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9";

	internal const string SystemComponentModelDataAnnotations = "System.ComponentModel.DataAnnotations, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemConfiguration = "System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemConfigurationInstall = "System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDeployment = "System.Deployment, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDesign = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDirectoryServices = "System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawingDesign = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemDrawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemEnterpriseServices = "System.EnterpriseServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemManagement = "System.Management, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemMessaging = "System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemNetHttp = "System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemNetHttpWebRequest = "System.Net.Http.WebRequest, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeSerializationFormattersSoap = "System.Runtime.Serialization.Formatters.Soap, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemRuntimeWindowsRuntime = "System.Runtime.WindowsRuntime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemRuntimeWindowsRuntimeUIXaml = "System.Runtime.WindowsRuntimeUIXaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemSecurity = "System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemServiceModelWeb = "System.ServiceModel.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemServiceProcess = "System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWeb = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebAbstractions = "System.Web.Abstractions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebDynamicData = "System.Web.DynamicData, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebDynamicDataDesign = "System.Web.DynamicData.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebEntityDesign = "System.Web.Entity.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	internal const string SystemWebExtensions = "System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebExtensionsDesign = "System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebMobile = "System.Web.Mobile, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRegularExpressions = "System.Web.RegularExpressions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string SystemWebRouting = "System.Web.Routing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string SystemWebServices = "System.Web.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string WindowsBase = "WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	internal const string MicrosoftVisualStudio = "Microsoft.VisualStudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWindowsForms = "Microsoft.VisualStudio.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string VJSharpCodeProvider = "VJSharpCodeProvider, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string ASPBrowserCapsPublicKey = "b7bd7678b977bd8f";

	internal const string ASPBrowserCapsFactory = "ASP.BrowserCapsFactory, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b7bd7678b977bd8f";

	internal const string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVisualStudioWeb = "Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftWebDesign = "Microsoft.Web.Design.Client, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftVSDesignerMobile = "Microsoft.VSDesigner.Mobile, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	internal const string MicrosoftJScript = "Microsoft.JScript, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
}
namespace System
{
	internal static class ExternDll
	{
		public const string Activeds = "activeds.dll";

		public const string Advapi32 = "advapi32.dll";

		public const string Comctl32 = "comctl32.dll";

		public const string Comdlg32 = "comdlg32.dll";

		public const string Gdi32 = "gdi32.dll";

		public const string Gdiplus = "gdiplus.dll";

		public const string Hhctrl = "hhctrl.ocx";

		public const string Imm32 = "imm32.dll";

		public const string Kernel32 = "kernel32.dll";

		public const string Loadperf = "Loadperf.dll";

		public const string Mscoree = "mscoree.dll";

		public const string Clr = "clr.dll";

		public const string Msi = "msi.dll";

		public const string Mqrt = "mqrt.dll";

		public const string Ntdll = "ntdll.dll";

		public const string Ole32 = "ole32.dll";

		public const string Oleacc = "oleacc.dll";

		public const string Oleaut32 = "oleaut32.dll";

		public const string Olepro32 = "olepro32.dll";

		public const string PerfCounter = "perfcounter.dll";

		public const string Powrprof = "Powrprof.dll";

		public const string Psapi = "psapi.dll";

		public const string Shell32 = "shell32.dll";

		public const string User32 = "user32.dll";

		public const string Uxtheme = "uxtheme.dll";

		public const string WinMM = "winmm.dll";

		public const string Winspool = "winspool.drv";

		public const string Wtsapi32 = "wtsapi32.dll";

		public const string Version = "version.dll";

		public const string Vsassert = "vsassert.dll";

		public const string Fxassert = "Fxassert.dll";

		public const string Shlwapi = "shlwapi.dll";

		public const string Crypt32 = "crypt32.dll";

		public const string ShCore = "SHCore.dll";

		public const string Wldp = "wldp.dll";

		internal const string Odbc32 = "odbc32.dll";

		internal const string SNI = "System.Data.dll";

		internal const string OciDll = "oci.dll";

		internal const string OraMtsDll = "oramts.dll";

		internal const string UiaCore = "UIAutomationCore.dll";
	}
	[Serializable]
	internal class InvariantComparer : IComparer
	{
		private CompareInfo m_compareInfo;

		internal static readonly InvariantComparer Default = new InvariantComparer();

		internal InvariantComparer()
		{
			m_compareInfo = CultureInfo.InvariantCulture.CompareInfo;
		}

		public int Compare(object a, object b)
		{
			string text = a as string;
			string text2 = b as string;
			if (text != null && text2 != null)
			{
				return m_compareInfo.Compare(text, text2);
			}
			return Comparer.Default.Compare(a, b);
		}
	}
	internal static class AppContextDefaultValues
	{
		public static void PopulateDefaultValues()
		{
			ParseTargetFrameworkName(out var identifier, out var profile, out var version);
			PopulateDefaultValuesPartial(identifier, profile, version);
		}

		private static void ParseTargetFrameworkName(out string identifier, out string profile, out int version)
		{
			string targetFrameworkName = AppDomain.CurrentDomain.SetupInformation.TargetFrameworkName;
			if (!TryParseFrameworkName(targetFrameworkName, out identifier, out version, out profile))
			{
				identifier = ".NETFramework";
				version = 40000;
				profile = string.Empty;
			}
		}

		private static bool TryParseFrameworkName(string frameworkName, out string identifier, out int version, out string profile)
		{
			identifier = (profile = string.Empty);
			version = 0;
			if (frameworkName == null || frameworkName.Length == 0)
			{
				return false;
			}
			string[] array = frameworkName.Split(',');
			version = 0;
			if (array.Length < 2 || array.Length > 3)
			{
				return false;
			}
			identifier = array[0].Trim();
			if (identifier.Length == 0)
			{
				return false;
			}
			bool flag = false;
			profile = null;
			for (int i = 1; i < array.Length; i++)
			{
				string[] array2 = array[i].Split('=');
				if (array2.Length != 2)
				{
					return false;
				}
				string text = array2[0].Trim();
				string text2 = array2[1].Trim();
				if (text.Equals("Version", StringComparison.OrdinalIgnoreCase))
				{
					flag = true;
					if (text2.Length > 0 && (text2[0] == 'v' || text2[0] == 'V'))
					{
						text2 = text2.Substring(1);
					}
					Version version2 = new Version(text2);
					version = version2.Major * 10000;
					if (version2.Minor > 0)
					{
						version += version2.Minor * 100;
					}
					if (version2.Build > 0)
					{
						version += version2.Build;
					}
				}
				else
				{
					if (!text.Equals("Profile", StringComparison.OrdinalIgnoreCase))
					{
						return false;
					}
					if (!string.IsNullOrEmpty(text2))
					{
						profile = text2;
					}
				}
			}
			if (!flag)
			{
				return false;
			}
			return true;
		}

		private static void PopulateDefaultValuesPartial(string platformIdentifier, string profile, int version)
		{
			if (platformIdentifier == ".NETCore" || platformIdentifier == ".NETFramework")
			{
				if (version <= 40502)
				{
					LocalAppContext.DefineSwitchDefault("Switch.System.Drawing.DontSupportPngFramesInIcons", initialValue: true);
				}
				if (version <= 40701)
				{
					LocalAppContext.DefineSwitchDefault("Switch.System.Drawing.Text.DoNotRemoveGdiFontsResourcesFromFontCollection", initialValue: true);
				}
			}
		}
	}
	internal static class LocalAppContext
	{
		private delegate bool TryGetSwitchDelegate(string switchName, out bool value);

		private static TryGetSwitchDelegate TryGetSwitchFromCentralAppContext;

		private static bool s_canForwardCalls;

		private static Dictionary<string, bool> s_switchMap;

		private static readonly object s_syncLock;

		private static bool DisableCaching { get; set; }

		static LocalAppContext()
		{
			s_switchMap = new Dictionary<string, bool>();
			s_syncLock = new object();
			s_canForwardCalls = SetupDelegate();
			AppContextDefaultValues.PopulateDefaultValues();
			DisableCaching = IsSwitchEnabled("TestSwitch.LocalAppContext.DisableCaching");
		}

		public static bool IsSwitchEnabled(string switchName)
		{
			if (s_canForwardCalls && TryGetSwitchFromCentralAppContext(switchName, out var value))
			{
				return value;
			}
			return IsSwitchEnabledLocal(switchName);
		}

		private static bool IsSwitchEnabledLocal(string switchName)
		{
			bool flag;
			bool value;
			lock (s_switchMap)
			{
				flag = s_switchMap.TryGetValue(switchName, out value);
			}
			if (flag)
			{
				return value;
			}
			return false;
		}

		private static bool SetupDelegate()
		{
			Type type = typeof(object).Assembly.GetType("System.AppContext");
			if (type == null)
			{
				return false;
			}
			MethodInfo method = type.GetMethod("TryGetSwitch", BindingFlags.Static | BindingFlags.Public, null, new Type[2]
			{
				typeof(string),
				typeof(bool).MakeByRefType()
			}, null);
			if (method == null)
			{
				return false;
			}
			TryGetSwitchFromCentralAppContext = (TryGetSwitchDelegate)Delegate.CreateDelegate(typeof(TryGetSwitchDelegate), method);
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool GetCachedSwitchValue(string switchName, ref int switchValue)
		{
			if (switchValue < 0)
			{
				return false;
			}
			if (switchValue > 0)
			{
				return true;
			}
			return GetCachedSwitchValueInternal(switchName, ref switchValue);
		}

		private static bool GetCachedSwitchValueInternal(string switchName, ref int switchValue)
		{
			if (DisableCaching)
			{
				return IsSwitchEnabled(switchName);
			}
			bool flag = IsSwitchEnabled(switchName);
			switchValue = (flag ? 1 : (-1));
			return flag;
		}

		internal static void DefineSwitchDefault(string switchName, bool initialValue)
		{
			s_switchMap[switchName] = initialValue;
		}
	}
}
namespace System.Configuration
{
	internal static class ConfigurationStringConstants
	{
		internal const string WinformsApplicationConfigurationSectionName = "System.Windows.Forms.ApplicationConfigurationSection";

		internal const string DpiAwarenessKeyName = "DpiAwareness";

		internal const string EnableWindowsFormsHighDpiAutoResizingKeyName = "EnableWindowsFormsHighDpiAutoResizing";

		internal const string ToolStripDisableHighDpiImprovementsKeyName = "ToolStrip.DisableHighDpiImprovements";

		internal const string CheckedListBoxDisableHighDpiImprovementsKeyName = "CheckedListBox.DisableHighDpiImprovements";

		internal const string DataGridViewControlDisableHighDpiImprovements = "DataGridView.DisableHighDpiImprovements";

		internal const string FormDisableSinglePassScalingOfDpiFormsKeyName = "Form.DisableSinglePassScalingOfDpiForms";

		internal const string DisableDpiChangedMessageHandlingKeyName = "DisableDpiChangedMessageHandling";

		internal const string DisableDpiChangedHighDpiImprovementsKeyName = "DisableDpiChangedHighDpiImprovements";

		internal const string AnchorLayoutDisableHighDpiImprovementsKeyName = "AnchorLayout.DisableHighDpiImprovements";

		internal const string MonthCalendarDisableHighDpiImprovementsKeyName = "MonthCalendar.DisableHighDpiImprovements";
	}
}
namespace System.Windows.Forms
{
	internal static class ConfigurationOptions
	{
		private static NameValueCollection applicationConfigOptions;

		private static Version netFrameworkVersion;

		private static readonly Version featureSupportedMinimumFrameworkVersion;

		internal static Version OSVersion;

		internal static readonly Version RS2Version;

		public static Version NetFrameworkVersion
		{
			get
			{
				if (netFrameworkVersion == null)
				{
					netFrameworkVersion = new Version(0, 0, 0, 0);
					try
					{
						string targetFrameworkName = AppDomain.CurrentDomain.SetupInformation.TargetFrameworkName;
						if (!string.IsNullOrEmpty(targetFrameworkName))
						{
							FrameworkName frameworkName = new FrameworkName(targetFrameworkName);
							if (string.Equals(frameworkName.Identifier, ".NETFramework"))
							{
								netFrameworkVersion = frameworkName.Version;
							}
						}
					}
					catch (Exception)
					{
					}
				}
				return netFrameworkVersion;
			}
		}

		static ConfigurationOptions()
		{
			applicationConfigOptions = null;
			netFrameworkVersion = null;
			featureSupportedMinimumFrameworkVersion = new Version(4, 7);
			OSVersion = Environment.OSVersion.Version;
			RS2Version = new Version(10, 0, 14933, 0);
			PopulateWinformsSection();
		}

		private static void PopulateWinformsSection()
		{
			if (NetFrameworkVersion.CompareTo(featureSupportedMinimumFrameworkVersion) >= 0)
			{
				try
				{
					applicationConfigOptions = ConfigurationManager.GetSection("System.Windows.Forms.ApplicationConfigurationSection") as NameValueCollection;
				}
				catch (Exception)
				{
				}
			}
		}

		public static string GetConfigSettingValue(string settingName)
		{
			if (applicationConfigOptions != null && !string.IsNullOrEmpty(settingName))
			{
				return applicationConfigOptions.Get(settingName);
			}
			return null;
		}
	}
	internal static class DpiHelper
	{
		internal const double LogicalDpi = 96.0;

		private static bool isInitialized = false;

		private static double deviceDpi = 96.0;

		private static double logicalToDeviceUnitsScalingFactor = 0.0;

		private static bool enableHighDpi = false;

		private static string dpiAwarenessValue = null;

		private static InterpolationMode interpolationMode = InterpolationMode.Invalid;

		internal static int DeviceDpi
		{
			get
			{
				Initialize();
				return (int)deviceDpi;
			}
		}

		private static double LogicalToDeviceUnitsScalingFactor
		{
			get
			{
				if (logicalToDeviceUnitsScalingFactor == 0.0)
				{
					Initialize();
					logicalToDeviceUnitsScalingFactor = deviceDpi / 96.0;
				}
				return logicalToDeviceUnitsScalingFactor;
			}
		}

		private static InterpolationMode InterpolationMode
		{
			get
			{
				if (interpolationMode == InterpolationMode.Invalid)
				{
					int num = (int)Math.Round(LogicalToDeviceUnitsScalingFactor * 100.0);
					if (num % 100 == 0)
					{
						interpolationMode = InterpolationMode.NearestNeighbor;
					}
					else if (num < 100)
					{
						interpolationMode = InterpolationMode.HighQualityBilinear;
					}
					else
					{
						interpolationMode = InterpolationMode.HighQualityBicubic;
					}
				}
				return interpolationMode;
			}
		}

		public static bool IsScalingRequired
		{
			get
			{
				Initialize();
				return deviceDpi != 96.0;
			}
		}

		private static void Initialize()
		{
			if (isInitialized)
			{
				return;
			}
			if (IsDpiAwarenessValueSet())
			{
				enableHighDpi = true;
			}
			else
			{
				try
				{
					string text = ConfigurationManager.AppSettings.Get("EnableWindowsFormsHighDpiAutoResizing");
					if (!string.IsNullOrEmpty(text) && string.Equals(text, "true", StringComparison.InvariantCultureIgnoreCase))
					{
						enableHighDpi = true;
					}
				}
				catch
				{
				}
			}
			if (enableHighDpi)
			{
				IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
				if (dC != IntPtr.Zero)
				{
					deviceDpi = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dC), 88);
					UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
				}
			}
			isInitialized = true;
		}

		internal static bool IsDpiAwarenessValueSet()
		{
			bool result = false;
			try
			{
				if (string.IsNullOrEmpty(dpiAwarenessValue))
				{
					dpiAwarenessValue = ConfigurationOptions.GetConfigSettingValue("DpiAwareness");
				}
			}
			catch
			{
			}
			if (!string.IsNullOrEmpty(dpiAwarenessValue))
			{
				switch (dpiAwarenessValue.ToLowerInvariant())
				{
				case "true":
				case "system":
				case "true/pm":
				case "permonitor":
				case "permonitorv2":
					result = true;
					break;
				}
			}
			return result;
		}

		private static Bitmap ScaleBitmapToSize(Bitmap logicalImage, Size deviceImageSize)
		{
			Bitmap bitmap = new Bitmap(deviceImageSize.Width, deviceImageSize.Height, logicalImage.PixelFormat);
			using Graphics graphics = Graphics.FromImage(bitmap);
			graphics.InterpolationMode = InterpolationMode;
			RectangleF srcRect = new RectangleF(0f, 0f, logicalImage.Size.Width, logicalImage.Size.Height);
			RectangleF destRect = new RectangleF(0f, 0f, deviceImageSize.Width, deviceImageSize.Height);
			srcRect.Offset(-0.5f, -0.5f);
			graphics.DrawImage(logicalImage, destRect, srcRect, GraphicsUnit.Pixel);
			return bitmap;
		}

		private static Bitmap CreateScaledBitmap(Bitmap logicalImage, int deviceDpi = 0)
		{
			Size deviceImageSize = LogicalToDeviceUnits(logicalImage.Size, deviceDpi);
			return ScaleBitmapToSize(logicalImage, deviceImageSize);
		}

		public static int LogicalToDeviceUnits(int value, int devicePixels = 0)
		{
			if (devicePixels == 0)
			{
				return (int)Math.Round(LogicalToDeviceUnitsScalingFactor * (double)value);
			}
			double num = (double)devicePixels / 96.0;
			return (int)Math.Round(num * (double)value);
		}

		public static double LogicalToDeviceUnits(double value, int devicePixels = 0)
		{
			if (devicePixels == 0)
			{
				return LogicalToDeviceUnitsScalingFactor * value;
			}
			double num = (double)devicePixels / 96.0;
			return num * value;
		}

		public static int LogicalToDeviceUnitsX(int value)
		{
			return LogicalToDeviceUnits(value);
		}

		public static int LogicalToDeviceUnitsY(int value)
		{
			return LogicalToDeviceUnits(value);
		}

		public static Size LogicalToDeviceUnits(Size logicalSize, int deviceDpi = 0)
		{
			return new Size(LogicalToDeviceUnits(logicalSize.Width, deviceDpi), LogicalToDeviceUnits(logicalSize.Height, deviceDpi));
		}

		public static Bitmap CreateResizedBitmap(Bitmap logicalImage, Size targetImageSize)
		{
			if (logicalImage == null)
			{
				return null;
			}
			return ScaleBitmapToSize(logicalImage, targetImageSize);
		}

		public static void ScaleBitmapLogicalToDevice(ref Bitmap logicalBitmap, int deviceDpi = 0)
		{
			if (logicalBitmap != null)
			{
				Bitmap bitmap = CreateScaledBitmap(logicalBitmap, deviceDpi);
				if (bitmap != null)
				{
					logicalBitmap.Dispose();
					logicalBitmap = bitmap;
				}
			}
		}

		public static int ConvertToGivenDpiPixel(int value, double pixelFactor)
		{
			int num = (int)Math.Round((double)value * pixelFactor);
			if (num != 0)
			{
				return num;
			}
			return 1;
		}
	}
	internal enum DpiAwarenessContext
	{
		DPI_AWARENESS_CONTEXT_UNSPECIFIED = 0,
		DPI_AWARENESS_CONTEXT_UNAWARE = -1,
		DPI_AWARENESS_CONTEXT_SYSTEM_AWARE = -2,
		DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE = -3,
		DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 = -4
	}
}
namespace System.Drawing
{
	internal static class ClientUtils
	{
		internal class WeakRefCollection : IList, ICollection, IEnumerable
		{
			internal class WeakRefObject
			{
				private int hash;

				private WeakReference weakHolder;

				internal bool IsAlive => weakHolder.IsAlive;

				internal object Target => weakHolder.Target;

				internal WeakRefObject(object obj)
				{
					weakHolder = new WeakReference(obj);
					hash = obj.GetHashCode();
				}

				public override int GetHashCode()
				{
					return hash;
				}

				public override bool Equals(object obj)
				{
					WeakRefObject weakRefObject = obj as WeakRefObject;
					if (weakRefObject == this)
					{
						return true;
					}
					if (weakRefObject == null)
					{
						return false;
					}
					if (weakRefObject.Target != Target && (Target == null || !Target.Equals(weakRefObject.Target)))
					{
						return false;
					}
					return true;
				}
			}

			private int refCheckThreshold = int.MaxValue;

			private ArrayList _innerList;

			internal ArrayList InnerList => _innerList;

			public int RefCheckThreshold
			{
				get
				{
					return refCheckThreshold;
				}
				set
				{
					refCheckThreshold = value;
				}
			}

			public object this[int index]
			{
				get
				{
					if (InnerList[index] is WeakRefObject weakRefObject && weakRefObject.IsAlive)
					{
						return weakRefObject.Target;
					}
					return null;
				}
				set
				{
					InnerList[index] = CreateWeakRefObject(value);
				}
			}

			public bool IsFixedSize => InnerList.IsFixedSize;

			public int Count => InnerList.Count;

			object ICollection.SyncRoot => InnerList.SyncRoot;

			public bool IsReadOnly => InnerList.IsReadOnly;

			bool ICollection.IsSynchronized => InnerList.IsSynchronized;

			internal WeakRefCollection()
			{
				_innerList = new ArrayList(4);
			}

			internal WeakRefCollection(int size)
			{
				_innerList = new ArrayList(size);
			}

			public void ScavengeReferences()
			{
				int num = 0;
				int count = Count;
				for (int i = 0; i < count; i++)
				{
					object obj = this[num];
					if (obj == null)
					{
						InnerList.RemoveAt(num);
					}
					else
					{
						num++;
					}
				}
			}

			public override bool Equals(object obj)
			{
				WeakRefCollection weakRefCollection = obj as WeakRefCollection;
				if (weakRefCollection == this)
				{
					return true;
				}
				if (weakRefCollection == null || Count != weakRefCollection.Count)
				{
					return false;
				}
				for (int i = 0; i < Count; i++)
				{
					if (InnerList[i] != weakRefCollection.InnerList[i] && (InnerList[i] == null || !InnerList[i].Equals(weakRefCollection.InnerList[i])))
					{
						return false;
					}
				}
				return true;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}

			private WeakRefObject CreateWeakRefObject(object value)
			{
				if (value == null)
				{
					return null;
				}
				return new WeakRefObject(value);
			}

			private static void Copy(WeakRefCollection sourceList, int sourceIndex, WeakRefCollection destinationList, int destinationIndex, int length)
			{
				if (sourceIndex < destinationIndex)
				{
					sourceIndex += length;
					destinationIndex += length;
					while (length > 0)
					{
						destinationList.InnerList[--destinationIndex] = sourceList.InnerList[--sourceIndex];
						length--;
					}
				}
				else
				{
					while (length > 0)
					{
						destinationList.InnerList[destinationIndex++] = sourceList.InnerList[sourceIndex++];
						length--;
					}
				}
			}

			public void RemoveByHashCode(object value)
			{
				if (value == null)
				{
					return;
				}
				int hashCode = value.GetHashCode();
				for (int i = 0; i < InnerList.Count; i++)
				{
					if (InnerList[i] != null && InnerList[i].GetHashCode() == hashCode)
					{
						RemoveAt(i);
						break;
					}
				}
			}

			public void Clear()
			{
				InnerList.Clear();
			}

			public bool Contains(object value)
			{
				return InnerList.Contains(CreateWeakRefObject(value));
			}

			public void RemoveAt(int index)
			{
				InnerList.RemoveAt(index);
			}

			public void Remove(object value)
			{
				InnerList.Remove(CreateWeakRefObject(value));
			}

			public int IndexOf(object value)
			{
				return InnerList.IndexOf(CreateWeakRefObject(value));
			}

			public void Insert(int index, object value)
			{
				InnerList.Insert(index, CreateWeakRefObject(value));
			}

			public int Add(object value)
			{
				if (Count > RefCheckThreshold)
				{
					ScavengeReferences();
				}
				return InnerList.Add(CreateWeakRefObject(value));
			}

			public void CopyTo(Array array, int index)
			{
				InnerList.CopyTo(array, index);
			}

			public IEnumerator GetEnumerator()
			{
				return InnerList.GetEnumerator();
			}
		}

		public static bool IsCriticalException(Exception ex)
		{
			if (!(ex is NullReferenceException) && !(ex is StackOverflowException) && !(ex is OutOfMemoryException) && !(ex is ThreadAbortException) && !(ex is ExecutionEngineException) && !(ex is IndexOutOfRangeException))
			{
				return ex is AccessViolationException;
			}
			return true;
		}

		public static bool IsSecurityOrCriticalException(Exception ex)
		{
			if (!(ex is SecurityException))
			{
				return IsCriticalException(ex);
			}
			return true;
		}

		public static int GetBitCount(uint x)
		{
			int num = 0;
			while (x != 0)
			{
				x &= x - 1;
				num++;
			}
			return num;
		}

		public static bool IsEnumValid(Enum enumValue, int value, int minValue, int maxValue)
		{
			return value >= minValue && value <= maxValue;
		}

		public static bool IsEnumValid(Enum enumValue, int value, int minValue, int maxValue, int maxNumberOfBitsOn)
		{
			return value >= minValue && value <= maxValue && GetBitCount((uint)value) <= maxNumberOfBitsOn;
		}

		public static bool IsEnumValid_Masked(Enum enumValue, int value, uint mask)
		{
			return (value & mask) == value;
		}

		public static bool IsEnumValid_NotSequential(Enum enumValue, int value, params int[] enumValues)
		{
			for (int i = 0; i < enumValues.Length; i++)
			{
				if (enumValues[i] == value)
				{
					return true;
				}
			}
			return false;
		}
	}
	/// <summary>Encapsulates a GDI+ bitmap, which consists of the pixel data for a graphics image and its attributes. A <see cref="T:System.Drawing.Bitmap" /> is an object used to work with images defined by pixel data.</summary>
	[Serializable]
	[Editor("System.Drawing.Design.BitmapEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	[ComVisible(true)]
	public sealed class Bitmap : Image
	{
		private static Color defaultTransparentColor = Color.LightGray;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified file.</summary>
		/// <param name="filename">The bitmap file name and path.</param>
		/// <exception cref="T:System.IO.FileNotFoundException">The specified file is not found.</exception>
		public Bitmap(string filename)
		{
			IntSecurity.DemandReadFileIO(filename);
			filename = Path.GetFullPath(filename);
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromFile(filename, out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, bitmap));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, bitmap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
			Image.EnsureSave(this, filename, null);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified file.</summary>
		/// <param name="filename">The name of the bitmap file.</param>
		/// <param name="useIcm">
		///   <see langword="true" /> to use color correction for this <see cref="T:System.Drawing.Bitmap" />; otherwise, <see langword="false" />.</param>
		public Bitmap(string filename, bool useIcm)
		{
			IntSecurity.DemandReadFileIO(filename);
			filename = Path.GetFullPath(filename);
			IntPtr bitmap = IntPtr.Zero;
			int num = ((!useIcm) ? SafeNativeMethods.Gdip.GdipCreateBitmapFromFile(filename, out bitmap) : SafeNativeMethods.Gdip.GdipCreateBitmapFromFileICM(filename, out bitmap));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, bitmap));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, bitmap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
			Image.EnsureSave(this, filename, null);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from a specified resource.</summary>
		/// <param name="type">The class used to extract the resource.</param>
		/// <param name="resource">The name of the resource.</param>
		public Bitmap(Type type, string resource)
		{
			Stream manifestResourceStream = type.Module.Assembly.GetManifestResourceStream(type, resource);
			if (manifestResourceStream == null)
			{
				throw new ArgumentException(SR.GetString("ResourceNotFound", type, resource));
			}
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromStream(new GPStream(manifestResourceStream), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, bitmap));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, bitmap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
			Image.EnsureSave(this, null, manifestResourceStream);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified data stream.</summary>
		/// <param name="stream">The data stream used to load the image.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="stream" /> does not contain image data or is <see langword="null" />.  
		/// -or-  
		/// <paramref name="stream" /> contains a PNG image file with a single dimension greater than 65,535 pixels.</exception>
		public Bitmap(Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "stream", "null"));
			}
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromStream(new GPStream(stream), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, bitmap));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, bitmap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
			Image.EnsureSave(this, null, stream);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified data stream.</summary>
		/// <param name="stream">The data stream used to load the image.</param>
		/// <param name="useIcm">
		///   <see langword="true" /> to use color correction for this <see cref="T:System.Drawing.Bitmap" />; otherwise, <see langword="false" />.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="stream" /> does not contain image data or is <see langword="null" />.  
		/// -or-  
		/// <paramref name="stream" /> contains a PNG image file with a single dimension greater than 65,535 pixels.</exception>
		public Bitmap(Stream stream, bool useIcm)
		{
			if (stream == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "stream", "null"));
			}
			IntPtr bitmap = IntPtr.Zero;
			int num = ((!useIcm) ? SafeNativeMethods.Gdip.GdipCreateBitmapFromStream(new GPStream(stream), out bitmap) : SafeNativeMethods.Gdip.GdipCreateBitmapFromStreamICM(new GPStream(stream), out bitmap));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, bitmap));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, bitmap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
			Image.EnsureSave(this, null, stream);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class with the specified size, pixel format, and pixel data.</summary>
		/// <param name="width">The width, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="height">The height, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="stride">Integer that specifies the byte offset between the beginning of one scan line and the next. This is usually (but not necessarily) the number of bytes in the pixel format (for example, 2 for 16 bits per pixel) multiplied by the width of the bitmap. The value passed to this parameter must be a multiple of four.</param>
		/// <param name="format">The pixel format for the new <see cref="T:System.Drawing.Bitmap" />. This must specify a value that begins with Format.</param>
		/// <param name="scan0">Pointer to an array of bytes that contains the pixel data.</param>
		/// <exception cref="T:System.ArgumentException">A <see cref="T:System.Drawing.Imaging.PixelFormat" /> value is specified whose name does not start with Format. For example, specifying <see cref="F:System.Drawing.Imaging.PixelFormat.Gdi" /> will cause an <see cref="T:System.ArgumentException" />, but <see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb" /> will not.</exception>
		public Bitmap(int width, int height, int stride, PixelFormat format, IntPtr scan0)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromScan0(width, height, stride, (int)format, new HandleRef(null, scan0), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class with the specified size and format.</summary>
		/// <param name="width">The width, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="height">The height, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="format">The pixel format for the new <see cref="T:System.Drawing.Bitmap" />. This must specify a value that begins with Format.</param>
		/// <exception cref="T:System.ArgumentException">A <see cref="T:System.Drawing.Imaging.PixelFormat" /> value is specified whose name does not start with Format. For example, specifying <see cref="F:System.Drawing.Imaging.PixelFormat.Gdi" /> will cause an <see cref="T:System.ArgumentException" />, but <see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb" /> will not.</exception>
		public Bitmap(int width, int height, PixelFormat format)
		{
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromScan0(width, height, 0, (int)format, NativeMethods.NullHandleRef, out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class with the specified size.</summary>
		/// <param name="width">The width, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="height">The height, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public Bitmap(int width, int height)
			: this(width, height, PixelFormat.Format32bppArgb)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class with the specified size and with the resolution of the specified <see cref="T:System.Drawing.Graphics" /> object.</summary>
		/// <param name="width">The width, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="height">The height, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="g">The <see cref="T:System.Drawing.Graphics" /> object that specifies the resolution for the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> is <see langword="null" />.</exception>
		public Bitmap(int width, int height, Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException(SR.GetString("InvalidArgument", "g", "null"));
			}
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromGraphics(width, height, new HandleRef(g, g.NativeGraphics), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(bitmap);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified existing image.</summary>
		/// <param name="original">The <see cref="T:System.Drawing.Image" /> from which to create the new <see cref="T:System.Drawing.Bitmap" />.</param>
		public Bitmap(Image original)
			: this(original, original.Width, original.Height)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified existing image, scaled to the specified size.</summary>
		/// <param name="original">The <see cref="T:System.Drawing.Image" /> from which to create the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="width">The width, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="height">The height, in pixels, of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public Bitmap(Image original, int width, int height)
			: this(width, height)
		{
			Graphics graphics = null;
			try
			{
				graphics = Graphics.FromImage(this);
				graphics.Clear(Color.Transparent);
				graphics.DrawImage(original, 0, 0, width, height);
			}
			finally
			{
				graphics?.Dispose();
			}
		}

		private Bitmap(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Bitmap" /> from a Windows handle to an icon.</summary>
		/// <param name="hicon">A handle to an icon.</param>
		/// <returns>The <see cref="T:System.Drawing.Bitmap" /> that this method creates.</returns>
		public static Bitmap FromHicon(IntPtr hicon)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromHICON(new HandleRef(null, hicon), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return FromGDIplus(bitmap);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Bitmap" /> from the specified Windows resource.</summary>
		/// <param name="hinstance">A handle to an instance of the executable file that contains the resource.</param>
		/// <param name="bitmapName">A string that contains the name of the resource bitmap.</param>
		/// <returns>The <see cref="T:System.Drawing.Bitmap" /> that this method creates.</returns>
		public static Bitmap FromResource(IntPtr hinstance, string bitmapName)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr intPtr = Marshal.StringToHGlobalUni(bitmapName);
			IntPtr bitmap;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromResource(new HandleRef(null, hinstance), new HandleRef(null, intPtr), out bitmap);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return FromGDIplus(bitmap);
		}

		/// <summary>Creates a GDI bitmap object from this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <returns>A handle to the GDI bitmap object that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The height or width of the bitmap is greater than <see cref="F:System.Int16.MaxValue" />.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public IntPtr GetHbitmap()
		{
			return GetHbitmap(Color.LightGray);
		}

		/// <summary>Creates a GDI bitmap object from this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <param name="background">A <see cref="T:System.Drawing.Color" /> structure that specifies the background color. This parameter is ignored if the bitmap is totally opaque.</param>
		/// <returns>A handle to the GDI bitmap object that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The height or width of the bitmap is greater than <see cref="F:System.Int16.MaxValue" />.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public IntPtr GetHbitmap(Color background)
		{
			IntPtr hbitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateHBITMAPFromBitmap(new HandleRef(this, nativeImage), out hbitmap, ColorTranslator.ToWin32(background));
			if (num == 2 && (base.Width >= 32767 || base.Height >= 32767))
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidSize"));
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return hbitmap;
		}

		/// <summary>Returns the handle to an icon.</summary>
		/// <returns>A Windows handle to an icon with the same image as the <see cref="T:System.Drawing.Bitmap" />.</returns>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public IntPtr GetHicon()
		{
			IntPtr hicon = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateHICONFromBitmap(new HandleRef(this, nativeImage), out hicon);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return hicon;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Bitmap" /> class from the specified existing image, scaled to the specified size.</summary>
		/// <param name="original">The <see cref="T:System.Drawing.Image" /> from which to create the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="newSize">The <see cref="T:System.Drawing.Size" /> structure that represent the size of the new <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public Bitmap(Image original, Size newSize)
			: this(original, ((object)newSize != null) ? newSize.Width : 0, ((object)newSize != null) ? newSize.Height : 0)
		{
		}

		private Bitmap()
		{
		}

		internal static Bitmap FromGDIplus(IntPtr handle)
		{
			Bitmap bitmap = new Bitmap();
			bitmap.SetNativeImage(handle);
			return bitmap;
		}

		/// <summary>Creates a copy of the section of this <see cref="T:System.Drawing.Bitmap" /> defined by <see cref="T:System.Drawing.Rectangle" /> structure and with a specified <see cref="T:System.Drawing.Imaging.PixelFormat" /> enumeration.</summary>
		/// <param name="rect">Defines the portion of this <see cref="T:System.Drawing.Bitmap" /> to copy. Coordinates are relative to this <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="format">The pixel format for the new <see cref="T:System.Drawing.Bitmap" />. This must specify a value that begins with Format.</param>
		/// <returns>The new <see cref="T:System.Drawing.Bitmap" /> that this method creates.</returns>
		/// <exception cref="T:System.OutOfMemoryException">
		///   <paramref name="rect" /> is outside of the source bitmap bounds.</exception>
		/// <exception cref="T:System.ArgumentException">The height or width of <paramref name="rect" /> is 0.  
		///  -or-  
		///  A <see cref="T:System.Drawing.Imaging.PixelFormat" /> value is specified whose name does not start with Format. For example, specifying <see cref="F:System.Drawing.Imaging.PixelFormat.Gdi" /> will cause an <see cref="T:System.ArgumentException" />, but <see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb" /> will not.</exception>
		public Bitmap Clone(Rectangle rect, PixelFormat format)
		{
			if (rect.Width == 0 || rect.Height == 0)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			IntPtr dstbitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBitmapAreaI(rect.X, rect.Y, rect.Width, rect.Height, (int)format, new HandleRef(this, nativeImage), out dstbitmap);
			if (num != 0 || dstbitmap == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return FromGDIplus(dstbitmap);
		}

		/// <summary>Creates a copy of the section of this <see cref="T:System.Drawing.Bitmap" /> defined with a specified <see cref="T:System.Drawing.Imaging.PixelFormat" /> enumeration.</summary>
		/// <param name="rect">Defines the portion of this <see cref="T:System.Drawing.Bitmap" /> to copy.</param>
		/// <param name="format">Specifies the <see cref="T:System.Drawing.Imaging.PixelFormat" /> enumeration for the destination <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Bitmap" /> that this method creates.</returns>
		/// <exception cref="T:System.OutOfMemoryException">
		///   <paramref name="rect" /> is outside of the source bitmap bounds.</exception>
		/// <exception cref="T:System.ArgumentException">The height or width of <paramref name="rect" /> is 0.</exception>
		public Bitmap Clone(RectangleF rect, PixelFormat format)
		{
			if (rect.Width == 0f || rect.Height == 0f)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			IntPtr dstbitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBitmapArea(rect.X, rect.Y, rect.Width, rect.Height, (int)format, new HandleRef(this, nativeImage), out dstbitmap);
			if (num != 0 || dstbitmap == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return FromGDIplus(dstbitmap);
		}

		/// <summary>Makes the default transparent color transparent for this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <exception cref="T:System.InvalidOperationException">The image format of the <see cref="T:System.Drawing.Bitmap" /> is an icon format.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public void MakeTransparent()
		{
			Color pixel = defaultTransparentColor;
			if (base.Height > 0 && base.Width > 0)
			{
				pixel = GetPixel(0, base.Size.Height - 1);
			}
			if (pixel.A >= byte.MaxValue)
			{
				MakeTransparent(pixel);
			}
		}

		/// <summary>Makes the specified color transparent for this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <param name="transparentColor">The <see cref="T:System.Drawing.Color" /> structure that represents the color to make transparent.</param>
		/// <exception cref="T:System.InvalidOperationException">The image format of the <see cref="T:System.Drawing.Bitmap" /> is an icon format.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public void MakeTransparent(Color transparentColor)
		{
			if (base.RawFormat.Guid == ImageFormat.Icon.Guid)
			{
				throw new InvalidOperationException(SR.GetString("CantMakeIconTransparent"));
			}
			Size size = base.Size;
			Bitmap bitmap = null;
			Graphics graphics = null;
			try
			{
				bitmap = new Bitmap(size.Width, size.Height, PixelFormat.Format32bppArgb);
				try
				{
					graphics = Graphics.FromImage(bitmap);
					graphics.Clear(Color.Transparent);
					Rectangle destRect = new Rectangle(0, 0, size.Width, size.Height);
					ImageAttributes imageAttributes = null;
					try
					{
						imageAttributes = new ImageAttributes();
						imageAttributes.SetColorKey(transparentColor, transparentColor);
						graphics.DrawImage(this, destRect, 0, 0, size.Width, size.Height, GraphicsUnit.Pixel, imageAttributes, null, IntPtr.Zero);
					}
					finally
					{
						imageAttributes?.Dispose();
					}
				}
				finally
				{
					graphics?.Dispose();
				}
				IntPtr intPtr = nativeImage;
				nativeImage = bitmap.nativeImage;
				bitmap.nativeImage = intPtr;
			}
			finally
			{
				bitmap?.Dispose();
			}
		}

		/// <summary>Locks a <see cref="T:System.Drawing.Bitmap" /> into system memory.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <see cref="T:System.Drawing.Bitmap" /> to lock.</param>
		/// <param name="flags">An <see cref="T:System.Drawing.Imaging.ImageLockMode" /> enumeration that specifies the access level (read/write) for the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="format">A <see cref="T:System.Drawing.Imaging.PixelFormat" /> enumeration that specifies the data format of this <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <returns>A <see cref="T:System.Drawing.Imaging.BitmapData" /> that contains information about this lock operation.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="T:System.Drawing.Imaging.PixelFormat" /> is not a specific bits-per-pixel value.  
		///  -or-  
		///  The incorrect <see cref="T:System.Drawing.Imaging.PixelFormat" /> is passed in for a bitmap.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format)
		{
			BitmapData bitmapData = new BitmapData();
			return LockBits(rect, flags, format, bitmapData);
		}

		/// <summary>Locks a <see cref="T:System.Drawing.Bitmap" /> into system memory</summary>
		/// <param name="rect">A rectangle structure that specifies the portion of the <see cref="T:System.Drawing.Bitmap" /> to lock.</param>
		/// <param name="flags">One of the <see cref="T:System.Drawing.Imaging.ImageLockMode" /> values that specifies the access level (read/write) for the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="format">One of the <see cref="T:System.Drawing.Imaging.PixelFormat" /> values that specifies the data format of the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="bitmapData">A <see cref="T:System.Drawing.Imaging.BitmapData" /> that contains information about the lock operation.</param>
		/// <returns>A <see cref="T:System.Drawing.Imaging.BitmapData" /> that contains information about the lock operation.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <see cref="T:System.Drawing.Imaging.PixelFormat" /> value is not a specific bits-per-pixel value.  
		/// -or-  
		/// The incorrect <see cref="T:System.Drawing.Imaging.PixelFormat" /> is passed in for a bitmap.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format, BitmapData bitmapData)
		{
			GPRECT rect2 = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipBitmapLockBits(new HandleRef(this, nativeImage), ref rect2, flags, format, bitmapData);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return bitmapData;
		}

		/// <summary>Unlocks this <see cref="T:System.Drawing.Bitmap" /> from system memory.</summary>
		/// <param name="bitmapdata">A <see cref="T:System.Drawing.Imaging.BitmapData" /> that specifies information about the lock operation.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public void UnlockBits(BitmapData bitmapdata)
		{
			int num = SafeNativeMethods.Gdip.GdipBitmapUnlockBits(new HandleRef(this, nativeImage), bitmapdata);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Gets the color of the specified pixel in this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <param name="x">The x-coordinate of the pixel to retrieve.</param>
		/// <param name="y">The y-coordinate of the pixel to retrieve.</param>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the color of the specified pixel.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="x" /> is less than 0, or greater than or equal to <see cref="P:System.Drawing.Image.Width" />.  
		/// -or-  
		/// <paramref name="y" /> is less than 0, or greater than or equal to <see cref="P:System.Drawing.Image.Height" />.</exception>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public Color GetPixel(int x, int y)
		{
			int argb = 0;
			if (x < 0 || x >= base.Width)
			{
				throw new ArgumentOutOfRangeException("x", SR.GetString("ValidRangeX"));
			}
			if (y < 0 || y >= base.Height)
			{
				throw new ArgumentOutOfRangeException("y", SR.GetString("ValidRangeY"));
			}
			int num = SafeNativeMethods.Gdip.GdipBitmapGetPixel(new HandleRef(this, nativeImage), x, y, out argb);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return Color.FromArgb(argb);
		}

		/// <summary>Sets the color of the specified pixel in this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <param name="x">The x-coordinate of the pixel to set.</param>
		/// <param name="y">The y-coordinate of the pixel to set.</param>
		/// <param name="color">A <see cref="T:System.Drawing.Color" /> structure that represents the color to assign to the specified pixel.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public void SetPixel(int x, int y, Color color)
		{
			if ((base.PixelFormat & PixelFormat.Indexed) != 0)
			{
				throw new InvalidOperationException(SR.GetString("GdiplusCannotSetPixelFromIndexedPixelFormat"));
			}
			if (x < 0 || x >= base.Width)
			{
				throw new ArgumentOutOfRangeException("x", SR.GetString("ValidRangeX"));
			}
			if (y < 0 || y >= base.Height)
			{
				throw new ArgumentOutOfRangeException("y", SR.GetString("ValidRangeY"));
			}
			int num = SafeNativeMethods.Gdip.GdipBitmapSetPixel(new HandleRef(this, nativeImage), x, y, color.ToArgb());
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the resolution for this <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <param name="xDpi">The horizontal resolution, in dots per inch, of the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="yDpi">The vertical resolution, in dots per inch, of the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <exception cref="T:System.Exception">The operation failed.</exception>
		public void SetResolution(float xDpi, float yDpi)
		{
			int num = SafeNativeMethods.Gdip.GdipBitmapSetResolution(new HandleRef(this, nativeImage), xDpi, yDpi);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
	/// <summary>Specifies that, when interpreting <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> declarations, the assembly should look for the indicated resources in the same assembly, but with the <see cref="P:System.Drawing.Configuration.SystemDrawingSection.BitmapSuffix" /> configuration value appended to the declared file name.</summary>
	[AttributeUsage(AttributeTargets.Assembly)]
	public class BitmapSuffixInSameAssemblyAttribute : Attribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.BitmapSuffixInSameAssemblyAttribute" /> class.</summary>
		public BitmapSuffixInSameAssemblyAttribute()
		{
		}
	}
	/// <summary>Specifies that, when interpreting <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> declarations, the assembly should look for the indicated resources in a satellite assembly, but with the <see cref="P:System.Drawing.Configuration.SystemDrawingSection.BitmapSuffix" /> configuration value appended to the declared file name.</summary>
	[AttributeUsage(AttributeTargets.Assembly)]
	public class BitmapSuffixInSatelliteAssemblyAttribute : Attribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.BitmapSuffixInSatelliteAssemblyAttribute" /> class.</summary>
		public BitmapSuffixInSatelliteAssemblyAttribute()
		{
		}
	}
	internal static class BitmapSelector
	{
		private static string _suffix;

		internal static string Suffix
		{
			get
			{
				if (_suffix == null)
				{
					_suffix = string.Empty;
					if (ConfigurationManager.GetSection("system.drawing") is SystemDrawingSection systemDrawingSection)
					{
						string bitmapSuffix = systemDrawingSection.BitmapSuffix;
						if (bitmapSuffix != null && bitmapSuffix != null)
						{
							_suffix = bitmapSuffix;
						}
					}
				}
				return _suffix;
			}
			set
			{
				_suffix = value;
			}
		}

		internal static string AppendSuffix(string filePath)
		{
			try
			{
				return Path.ChangeExtension(filePath, Suffix + Path.GetExtension(filePath));
			}
			catch (ArgumentException)
			{
				return filePath;
			}
		}

		public static string GetFileName(string originalPath)
		{
			if (Suffix == string.Empty)
			{
				return originalPath;
			}
			string text = AppendSuffix(originalPath);
			if (!File.Exists(text))
			{
				return originalPath;
			}
			return text;
		}

		private static Stream GetResourceStreamHelper(Assembly assembly, Type type, string name)
		{
			Stream result = null;
			try
			{
				result = assembly.GetManifestResourceStream(type, name);
				return result;
			}
			catch (FileNotFoundException)
			{
				return result;
			}
		}

		private static bool DoesAssemblyHaveCustomAttribute(Assembly assembly, string typeName)
		{
			return DoesAssemblyHaveCustomAttribute(assembly, assembly.GetType(typeName));
		}

		private static bool DoesAssemblyHaveCustomAttribute(Assembly assembly, Type attrType)
		{
			if (attrType != null)
			{
				object[] customAttributes = assembly.GetCustomAttributes(attrType, inherit: false);
				if (customAttributes.Length != 0)
				{
					return true;
				}
			}
			return false;
		}

		internal static bool SatelliteAssemblyOptIn(Assembly assembly)
		{
			if (DoesAssemblyHaveCustomAttribute(assembly, typeof(BitmapSuffixInSatelliteAssemblyAttribute)))
			{
				return true;
			}
			return DoesAssemblyHaveCustomAttribute(assembly, "System.Drawing.BitmapSuffixInSatelliteAssemblyAttribute");
		}

		internal static bool SameAssemblyOptIn(Assembly assembly)
		{
			if (DoesAssemblyHaveCustomAttribute(assembly, typeof(BitmapSuffixInSameAssemblyAttribute)))
			{
				return true;
			}
			return DoesAssemblyHaveCustomAttribute(assembly, "System.Drawing.BitmapSuffixInSameAssemblyAttribute");
		}

		public static Stream GetResourceStream(Assembly assembly, Type type, string originalName)
		{
			if (Suffix != string.Empty)
			{
				try
				{
					if (SameAssemblyOptIn(assembly))
					{
						string name = AppendSuffix(originalName);
						Stream resourceStreamHelper = GetResourceStreamHelper(assembly, type, name);
						if (resourceStreamHelper != null)
						{
							return resourceStreamHelper;
						}
					}
				}
				catch
				{
				}
				try
				{
					if (SatelliteAssemblyOptIn(assembly))
					{
						AssemblyName name2 = assembly.GetName();
						name2.Name += Suffix;
						name2.ProcessorArchitecture = ProcessorArchitecture.None;
						Assembly assembly2 = Assembly.Load(name2);
						if (assembly2 != null)
						{
							Stream resourceStreamHelper2 = GetResourceStreamHelper(assembly2, type, originalName);
							if (resourceStreamHelper2 != null)
							{
								return resourceStreamHelper2;
							}
						}
					}
				}
				catch
				{
				}
			}
			return assembly.GetManifestResourceStream(type, originalName);
		}

		public static Stream GetResourceStream(Type type, string originalName)
		{
			return GetResourceStream(type.Module.Assembly, type, originalName);
		}

		public static Icon CreateIcon(Type type, string originalName)
		{
			return new Icon(GetResourceStream(type, originalName));
		}

		public static Bitmap CreateBitmap(Type type, string originalName)
		{
			return new Bitmap(GetResourceStream(type, originalName));
		}
	}
	/// <summary>Defines objects used to fill the interiors of graphical shapes such as rectangles, ellipses, pies, polygons, and paths.</summary>
	public abstract class Brush : MarshalByRefObject, ICloneable, IDisposable
	{
		private IntPtr nativeBrush;

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		internal IntPtr NativeBrush => nativeBrush;

		/// <summary>When overridden in a derived class, creates an exact copy of this <see cref="T:System.Drawing.Brush" />.</summary>
		/// <returns>The new <see cref="T:System.Drawing.Brush" /> that this method creates.</returns>
		public abstract object Clone();

		/// <summary>In a derived class, sets a reference to a GDI+ brush object.</summary>
		/// <param name="brush">A pointer to the GDI+ brush object.</param>
		protected internal void SetNativeBrush(IntPtr brush)
		{
			IntSecurity.UnmanagedCode.Demand();
			SetNativeBrushInternal(brush);
		}

		internal void SetNativeBrushInternal(IntPtr brush)
		{
			nativeBrush = brush;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Brush" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.Drawing.Brush" /> and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///   <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected virtual void Dispose(bool disposing)
		{
			if (!(nativeBrush != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeleteBrush(new HandleRef(this, nativeBrush));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeBrush = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Brush()
		{
			Dispose(disposing: false);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Brush" /> class.</summary>
		protected Brush()
		{
		}
	}
	/// <summary>Brushes for all the standard colors. This class cannot be inherited.</summary>
	public sealed class Brushes
	{
		private static readonly object TransparentKey = new object();

		private static readonly object AliceBlueKey = new object();

		private static readonly object AntiqueWhiteKey = new object();

		private static readonly object AquaKey = new object();

		private static readonly object AquamarineKey = new object();

		private static readonly object AzureKey = new object();

		private static readonly object BeigeKey = new object();

		private static readonly object BisqueKey = new object();

		private static readonly object BlackKey = new object();

		private static readonly object BlanchedAlmondKey = new object();

		private static readonly object BlueKey = new object();

		private static readonly object BlueVioletKey = new object();

		private static readonly object BrownKey = new object();

		private static readonly object BurlyWoodKey = new object();

		private static readonly object CadetBlueKey = new object();

		private static readonly object ChartreuseKey = new object();

		private static readonly object ChocolateKey = new object();

		private static readonly object ChoralKey = new object();

		private static readonly object CornflowerBlueKey = new object();

		private static readonly object CornsilkKey = new object();

		private static readonly object CrimsonKey = new object();

		private static readonly object CyanKey = new object();

		private static readonly object DarkBlueKey = new object();

		private static readonly object DarkCyanKey = new object();

		private static readonly object DarkGoldenrodKey = new object();

		private static readonly object DarkGrayKey = new object();

		private static readonly object DarkGreenKey = new object();

		private static readonly object DarkKhakiKey = new object();

		private static readonly object DarkMagentaKey = new object();

		private static readonly object DarkOliveGreenKey = new object();

		private static readonly object DarkOrangeKey = new object();

		private static readonly object DarkOrchidKey = new object();

		private static readonly object DarkRedKey = new object();

		private static readonly object DarkSalmonKey = new object();

		private static readonly object DarkSeaGreenKey = new object();

		private static readonly object DarkSlateBlueKey = new object();

		private static readonly object DarkSlateGrayKey = new object();

		private static readonly object DarkTurquoiseKey = new object();

		private static readonly object DarkVioletKey = new object();

		private static readonly object DeepPinkKey = new object();

		private static readonly object DeepSkyBlueKey = new object();

		private static readonly object DimGrayKey = new object();

		private static readonly object DodgerBlueKey = new object();

		private static readonly object FirebrickKey = new object();

		private static readonly object FloralWhiteKey = new object();

		private static readonly object ForestGreenKey = new object();

		private static readonly object FuchiaKey = new object();

		private static readonly object GainsboroKey = new object();

		private static readonly object GhostWhiteKey = new object();

		private static readonly object GoldKey = new object();

		private static readonly object GoldenrodKey = new object();

		private static readonly object GrayKey = new object();

		private static readonly object GreenKey = new object();

		private static readonly object GreenYellowKey = new object();

		private static readonly object HoneydewKey = new object();

		private static readonly object HotPinkKey = new object();

		private static readonly object IndianRedKey = new object();

		private static readonly object IndigoKey = new object();

		private static readonly object IvoryKey = new object();

		private static readonly object KhakiKey = new object();

		private static readonly object LavenderKey = new object();

		private static readonly object LavenderBlushKey = new object();

		private static readonly object LawnGreenKey = new object();

		private static readonly object LemonChiffonKey = new object();

		private static readonly object LightBlueKey = new object();

		private static readonly object LightCoralKey = new object();

		private static readonly object LightCyanKey = new object();

		private static readonly object LightGoldenrodYellowKey = new object();

		private static readonly object LightGreenKey = new object();

		private static readonly object LightGrayKey = new object();

		private static readonly object LightPinkKey = new object();

		private static readonly object LightSalmonKey = new object();

		private static readonly object LightSeaGreenKey = new object();

		private static readonly object LightSkyBlueKey = new object();

		private static readonly object LightSlateGrayKey = new object();

		private static readonly object LightSteelBlueKey = new object();

		private static readonly object LightYellowKey = new object();

		private static readonly object LimeKey = new object();

		private static readonly object LimeGreenKey = new object();

		private static readonly object LinenKey = new object();

		private static readonly object MagentaKey = new object();

		private static readonly object MaroonKey = new object();

		private static readonly object MediumAquamarineKey = new object();

		private static readonly object MediumBlueKey = new object();

		private static readonly object MediumOrchidKey = new object();

		private static readonly object MediumPurpleKey = new object();

		private static readonly object MediumSeaGreenKey = new object();

		private static readonly object MediumSlateBlueKey = new object();

		private static readonly object MediumSpringGreenKey = new object();

		private static readonly object MediumTurquoiseKey = new object();

		private static readonly object MediumVioletRedKey = new object();

		private static readonly object MidnightBlueKey = new object();

		private static readonly object MintCreamKey = new object();

		private static readonly object MistyRoseKey = new object();

		private static readonly object MoccasinKey = new object();

		private static readonly object NavajoWhiteKey = new object();

		private static readonly object NavyKey = new object();

		private static readonly object OldLaceKey = new object();

		private static readonly object OliveKey = new object();

		private static readonly object OliveDrabKey = new object();

		private static readonly object OrangeKey = new object();

		private static readonly object OrangeRedKey = new object();

		private static readonly object OrchidKey = new object();

		private static readonly object PaleGoldenrodKey = new object();

		private static readonly object PaleGreenKey = new object();

		private static readonly object PaleTurquoiseKey = new object();

		private static readonly object PaleVioletRedKey = new object();

		private static readonly object PapayaWhipKey = new object();

		private static readonly object PeachPuffKey = new object();

		private static readonly object PeruKey = new object();

		private static readonly object PinkKey = new object();

		private static readonly object PlumKey = new object();

		private static readonly object PowderBlueKey = new object();

		private static readonly object PurpleKey = new object();

		private static readonly object RedKey = new object();

		private static readonly object RosyBrownKey = new object();

		private static readonly object RoyalBlueKey = new object();

		private static readonly object SaddleBrownKey = new object();

		private static readonly object SalmonKey = new object();

		private static readonly object SandyBrownKey = new object();

		private static readonly object SeaGreenKey = new object();

		private static readonly object SeaShellKey = new object();

		private static readonly object SiennaKey = new object();

		private static readonly object SilverKey = new object();

		private static readonly object SkyBlueKey = new object();

		private static readonly object SlateBlueKey = new object();

		private static readonly object SlateGrayKey = new object();

		private static readonly object SnowKey = new object();

		private static readonly object SpringGreenKey = new object();

		private static readonly object SteelBlueKey = new object();

		private static readonly object TanKey = new object();

		private static readonly object TealKey = new object();

		private static readonly object ThistleKey = new object();

		private static readonly object TomatoKey = new object();

		private static readonly object TurquoiseKey = new object();

		private static readonly object VioletKey = new object();

		private static readonly object WheatKey = new object();

		private static readonly object WhiteKey = new object();

		private static readonly object WhiteSmokeKey = new object();

		private static readonly object YellowKey = new object();

		private static readonly object YellowGreenKey = new object();

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Transparent
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[TransparentKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Transparent);
					SafeNativeMethods.Gdip.ThreadData[TransparentKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush AliceBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[AliceBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.AliceBlue);
					SafeNativeMethods.Gdip.ThreadData[AliceBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush AntiqueWhite
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[AntiqueWhiteKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.AntiqueWhite);
					SafeNativeMethods.Gdip.ThreadData[AntiqueWhiteKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Aqua
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[AquaKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Aqua);
					SafeNativeMethods.Gdip.ThreadData[AquaKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Aquamarine
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[AquamarineKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Aquamarine);
					SafeNativeMethods.Gdip.ThreadData[AquamarineKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Azure
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[AzureKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Azure);
					SafeNativeMethods.Gdip.ThreadData[AzureKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Beige
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BeigeKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Beige);
					SafeNativeMethods.Gdip.ThreadData[BeigeKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Bisque
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BisqueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Bisque);
					SafeNativeMethods.Gdip.ThreadData[BisqueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Black
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BlackKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Black);
					SafeNativeMethods.Gdip.ThreadData[BlackKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush BlanchedAlmond
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BlanchedAlmondKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.BlanchedAlmond);
					SafeNativeMethods.Gdip.ThreadData[BlanchedAlmondKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Blue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Blue);
					SafeNativeMethods.Gdip.ThreadData[BlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush BlueViolet
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BlueVioletKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.BlueViolet);
					SafeNativeMethods.Gdip.ThreadData[BlueVioletKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Brown
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BrownKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Brown);
					SafeNativeMethods.Gdip.ThreadData[BrownKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush BurlyWood
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[BurlyWoodKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.BurlyWood);
					SafeNativeMethods.Gdip.ThreadData[BurlyWoodKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush CadetBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[CadetBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.CadetBlue);
					SafeNativeMethods.Gdip.ThreadData[CadetBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Chartreuse
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[ChartreuseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Chartreuse);
					SafeNativeMethods.Gdip.ThreadData[ChartreuseKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Chocolate
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[ChocolateKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Chocolate);
					SafeNativeMethods.Gdip.ThreadData[ChocolateKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Coral
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[ChoralKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Coral);
					SafeNativeMethods.Gdip.ThreadData[ChoralKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush CornflowerBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[CornflowerBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.CornflowerBlue);
					SafeNativeMethods.Gdip.ThreadData[CornflowerBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Cornsilk
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[CornsilkKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Cornsilk);
					SafeNativeMethods.Gdip.ThreadData[CornsilkKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Crimson
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[CrimsonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Crimson);
					SafeNativeMethods.Gdip.ThreadData[CrimsonKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Cyan
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[CyanKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Cyan);
					SafeNativeMethods.Gdip.ThreadData[CyanKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkBlue);
					SafeNativeMethods.Gdip.ThreadData[DarkBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkCyan
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkCyanKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkCyan);
					SafeNativeMethods.Gdip.ThreadData[DarkCyanKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkGoldenrod
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkGoldenrodKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkGoldenrod);
					SafeNativeMethods.Gdip.ThreadData[DarkGoldenrodKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkGray);
					SafeNativeMethods.Gdip.ThreadData[DarkGrayKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkGreen);
					SafeNativeMethods.Gdip.ThreadData[DarkGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkKhaki
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkKhakiKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkKhaki);
					SafeNativeMethods.Gdip.ThreadData[DarkKhakiKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkMagenta
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkMagentaKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkMagenta);
					SafeNativeMethods.Gdip.ThreadData[DarkMagentaKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkOliveGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkOliveGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkOliveGreen);
					SafeNativeMethods.Gdip.ThreadData[DarkOliveGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkOrange
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkOrangeKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkOrange);
					SafeNativeMethods.Gdip.ThreadData[DarkOrangeKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkOrchid
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkOrchidKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkOrchid);
					SafeNativeMethods.Gdip.ThreadData[DarkOrchidKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkRed
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkRedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkRed);
					SafeNativeMethods.Gdip.ThreadData[DarkRedKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkSalmon
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkSalmonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkSalmon);
					SafeNativeMethods.Gdip.ThreadData[DarkSalmonKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkSeaGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkSeaGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkSeaGreen);
					SafeNativeMethods.Gdip.ThreadData[DarkSeaGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkSlateBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkSlateBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkSlateBlue);
					SafeNativeMethods.Gdip.ThreadData[DarkSlateBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkSlateGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkSlateGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkSlateGray);
					SafeNativeMethods.Gdip.ThreadData[DarkSlateGrayKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkTurquoise
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkTurquoiseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkTurquoise);
					SafeNativeMethods.Gdip.ThreadData[DarkTurquoiseKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DarkViolet
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DarkVioletKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DarkViolet);
					SafeNativeMethods.Gdip.ThreadData[DarkVioletKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DeepPink
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DeepPinkKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DeepPink);
					SafeNativeMethods.Gdip.ThreadData[DeepPinkKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DeepSkyBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DeepSkyBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DeepSkyBlue);
					SafeNativeMethods.Gdip.ThreadData[DeepSkyBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DimGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DimGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DimGray);
					SafeNativeMethods.Gdip.ThreadData[DimGrayKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush DodgerBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[DodgerBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.DodgerBlue);
					SafeNativeMethods.Gdip.ThreadData[DodgerBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Firebrick
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[FirebrickKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Firebrick);
					SafeNativeMethods.Gdip.ThreadData[FirebrickKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush FloralWhite
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[FloralWhiteKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.FloralWhite);
					SafeNativeMethods.Gdip.ThreadData[FloralWhiteKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush ForestGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[ForestGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.ForestGreen);
					SafeNativeMethods.Gdip.ThreadData[ForestGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Fuchsia
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[FuchiaKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Fuchsia);
					SafeNativeMethods.Gdip.ThreadData[FuchiaKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Gainsboro
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GainsboroKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Gainsboro);
					SafeNativeMethods.Gdip.ThreadData[GainsboroKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush GhostWhite
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GhostWhiteKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.GhostWhite);
					SafeNativeMethods.Gdip.ThreadData[GhostWhiteKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Gold
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GoldKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Gold);
					SafeNativeMethods.Gdip.ThreadData[GoldKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Goldenrod
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GoldenrodKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Goldenrod);
					SafeNativeMethods.Gdip.ThreadData[GoldenrodKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Gray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Gray);
					SafeNativeMethods.Gdip.ThreadData[GrayKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Green
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Green);
					SafeNativeMethods.Gdip.ThreadData[GreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush GreenYellow
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[GreenYellowKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.GreenYellow);
					SafeNativeMethods.Gdip.ThreadData[GreenYellowKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Honeydew
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[HoneydewKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Honeydew);
					SafeNativeMethods.Gdip.ThreadData[HoneydewKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush HotPink
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[HotPinkKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.HotPink);
					SafeNativeMethods.Gdip.ThreadData[HotPinkKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush IndianRed
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[IndianRedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.IndianRed);
					SafeNativeMethods.Gdip.ThreadData[IndianRedKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Indigo
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[IndigoKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Indigo);
					SafeNativeMethods.Gdip.ThreadData[IndigoKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Ivory
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[IvoryKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Ivory);
					SafeNativeMethods.Gdip.ThreadData[IvoryKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Khaki
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[KhakiKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Khaki);
					SafeNativeMethods.Gdip.ThreadData[KhakiKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Lavender
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LavenderKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Lavender);
					SafeNativeMethods.Gdip.ThreadData[LavenderKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LavenderBlush
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LavenderBlushKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LavenderBlush);
					SafeNativeMethods.Gdip.ThreadData[LavenderBlushKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LawnGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LawnGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LawnGreen);
					SafeNativeMethods.Gdip.ThreadData[LawnGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LemonChiffon
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LemonChiffonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LemonChiffon);
					SafeNativeMethods.Gdip.ThreadData[LemonChiffonKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightBlue);
					SafeNativeMethods.Gdip.ThreadData[LightBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightCoral
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightCoralKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightCoral);
					SafeNativeMethods.Gdip.ThreadData[LightCoralKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightCyan
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightCyanKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightCyan);
					SafeNativeMethods.Gdip.ThreadData[LightCyanKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightGoldenrodYellow
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightGoldenrodYellowKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightGoldenrodYellow);
					SafeNativeMethods.Gdip.ThreadData[LightGoldenrodYellowKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightGreen);
					SafeNativeMethods.Gdip.ThreadData[LightGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightGray);
					SafeNativeMethods.Gdip.ThreadData[LightGrayKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightPink
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightPinkKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightPink);
					SafeNativeMethods.Gdip.ThreadData[LightPinkKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightSalmon
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightSalmonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightSalmon);
					SafeNativeMethods.Gdip.ThreadData[LightSalmonKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightSeaGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightSeaGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightSeaGreen);
					SafeNativeMethods.Gdip.ThreadData[LightSeaGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightSkyBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightSkyBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightSkyBlue);
					SafeNativeMethods.Gdip.ThreadData[LightSkyBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightSlateGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightSlateGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightSlateGray);
					SafeNativeMethods.Gdip.ThreadData[LightSlateGrayKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightSteelBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightSteelBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightSteelBlue);
					SafeNativeMethods.Gdip.ThreadData[LightSteelBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LightYellow
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LightYellowKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LightYellow);
					SafeNativeMethods.Gdip.ThreadData[LightYellowKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Lime
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LimeKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Lime);
					SafeNativeMethods.Gdip.ThreadData[LimeKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush LimeGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LimeGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.LimeGreen);
					SafeNativeMethods.Gdip.ThreadData[LimeGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Linen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[LinenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Linen);
					SafeNativeMethods.Gdip.ThreadData[LinenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Magenta
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MagentaKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Magenta);
					SafeNativeMethods.Gdip.ThreadData[MagentaKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Maroon
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MaroonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Maroon);
					SafeNativeMethods.Gdip.ThreadData[MaroonKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumAquamarine
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumAquamarineKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumAquamarine);
					SafeNativeMethods.Gdip.ThreadData[MediumAquamarineKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumBlue);
					SafeNativeMethods.Gdip.ThreadData[MediumBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumOrchid
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumOrchidKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumOrchid);
					SafeNativeMethods.Gdip.ThreadData[MediumOrchidKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumPurple
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumPurpleKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumPurple);
					SafeNativeMethods.Gdip.ThreadData[MediumPurpleKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumSeaGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumSeaGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumSeaGreen);
					SafeNativeMethods.Gdip.ThreadData[MediumSeaGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumSlateBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumSlateBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumSlateBlue);
					SafeNativeMethods.Gdip.ThreadData[MediumSlateBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumSpringGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumSpringGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumSpringGreen);
					SafeNativeMethods.Gdip.ThreadData[MediumSpringGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumTurquoise
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumTurquoiseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumTurquoise);
					SafeNativeMethods.Gdip.ThreadData[MediumTurquoiseKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MediumVioletRed
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MediumVioletRedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MediumVioletRed);
					SafeNativeMethods.Gdip.ThreadData[MediumVioletRedKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MidnightBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MidnightBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MidnightBlue);
					SafeNativeMethods.Gdip.ThreadData[MidnightBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MintCream
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MintCreamKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MintCream);
					SafeNativeMethods.Gdip.ThreadData[MintCreamKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush MistyRose
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MistyRoseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.MistyRose);
					SafeNativeMethods.Gdip.ThreadData[MistyRoseKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Moccasin
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[MoccasinKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Moccasin);
					SafeNativeMethods.Gdip.ThreadData[MoccasinKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush NavajoWhite
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[NavajoWhiteKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.NavajoWhite);
					SafeNativeMethods.Gdip.ThreadData[NavajoWhiteKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Navy
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[NavyKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Navy);
					SafeNativeMethods.Gdip.ThreadData[NavyKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush OldLace
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OldLaceKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.OldLace);
					SafeNativeMethods.Gdip.ThreadData[OldLaceKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Olive
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OliveKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Olive);
					SafeNativeMethods.Gdip.ThreadData[OliveKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush OliveDrab
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OliveDrabKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.OliveDrab);
					SafeNativeMethods.Gdip.ThreadData[OliveDrabKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Orange
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OrangeKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Orange);
					SafeNativeMethods.Gdip.ThreadData[OrangeKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush OrangeRed
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OrangeRedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.OrangeRed);
					SafeNativeMethods.Gdip.ThreadData[OrangeRedKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Orchid
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[OrchidKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Orchid);
					SafeNativeMethods.Gdip.ThreadData[OrchidKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PaleGoldenrod
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PaleGoldenrodKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PaleGoldenrod);
					SafeNativeMethods.Gdip.ThreadData[PaleGoldenrodKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PaleGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PaleGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PaleGreen);
					SafeNativeMethods.Gdip.ThreadData[PaleGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PaleTurquoise
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PaleTurquoiseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PaleTurquoise);
					SafeNativeMethods.Gdip.ThreadData[PaleTurquoiseKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PaleVioletRed
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PaleVioletRedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PaleVioletRed);
					SafeNativeMethods.Gdip.ThreadData[PaleVioletRedKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PapayaWhip
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PapayaWhipKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PapayaWhip);
					SafeNativeMethods.Gdip.ThreadData[PapayaWhipKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PeachPuff
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PeachPuffKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PeachPuff);
					SafeNativeMethods.Gdip.ThreadData[PeachPuffKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Peru
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PeruKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Peru);
					SafeNativeMethods.Gdip.ThreadData[PeruKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Pink
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PinkKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Pink);
					SafeNativeMethods.Gdip.ThreadData[PinkKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Plum
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PlumKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Plum);
					SafeNativeMethods.Gdip.ThreadData[PlumKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush PowderBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PowderBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.PowderBlue);
					SafeNativeMethods.Gdip.ThreadData[PowderBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Purple
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[PurpleKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Purple);
					SafeNativeMethods.Gdip.ThreadData[PurpleKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Red
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[RedKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Red);
					SafeNativeMethods.Gdip.ThreadData[RedKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush RosyBrown
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[RosyBrownKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.RosyBrown);
					SafeNativeMethods.Gdip.ThreadData[RosyBrownKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush RoyalBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[RoyalBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.RoyalBlue);
					SafeNativeMethods.Gdip.ThreadData[RoyalBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SaddleBrown
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SaddleBrownKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SaddleBrown);
					SafeNativeMethods.Gdip.ThreadData[SaddleBrownKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Salmon
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SalmonKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Salmon);
					SafeNativeMethods.Gdip.ThreadData[SalmonKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SandyBrown
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SandyBrownKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SandyBrown);
					SafeNativeMethods.Gdip.ThreadData[SandyBrownKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SeaGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SeaGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SeaGreen);
					SafeNativeMethods.Gdip.ThreadData[SeaGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SeaShell
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SeaShellKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SeaShell);
					SafeNativeMethods.Gdip.ThreadData[SeaShellKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Sienna
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SiennaKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Sienna);
					SafeNativeMethods.Gdip.ThreadData[SiennaKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Silver
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SilverKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Silver);
					SafeNativeMethods.Gdip.ThreadData[SilverKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SkyBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SkyBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SkyBlue);
					SafeNativeMethods.Gdip.ThreadData[SkyBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SlateBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SlateBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SlateBlue);
					SafeNativeMethods.Gdip.ThreadData[SlateBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SlateGray
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SlateGrayKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SlateGray);
					SafeNativeMethods.Gdip.ThreadData[SlateGrayKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Snow
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SnowKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Snow);
					SafeNativeMethods.Gdip.ThreadData[SnowKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SpringGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SpringGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SpringGreen);
					SafeNativeMethods.Gdip.ThreadData[SpringGreenKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush SteelBlue
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[SteelBlueKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.SteelBlue);
					SafeNativeMethods.Gdip.ThreadData[SteelBlueKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Tan
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[TanKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Tan);
					SafeNativeMethods.Gdip.ThreadData[TanKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Teal
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[TealKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Teal);
					SafeNativeMethods.Gdip.ThreadData[TealKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Thistle
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[ThistleKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Thistle);
					SafeNativeMethods.Gdip.ThreadData[ThistleKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Tomato
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[TomatoKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Tomato);
					SafeNativeMethods.Gdip.ThreadData[TomatoKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Turquoise
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[TurquoiseKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Turquoise);
					SafeNativeMethods.Gdip.ThreadData[TurquoiseKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Violet
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[VioletKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Violet);
					SafeNativeMethods.Gdip.ThreadData[VioletKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Wheat
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[WheatKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Wheat);
					SafeNativeMethods.Gdip.ThreadData[WheatKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush White
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[WhiteKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.White);
					SafeNativeMethods.Gdip.ThreadData[WhiteKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush WhiteSmoke
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[WhiteSmokeKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.WhiteSmoke);
					SafeNativeMethods.Gdip.ThreadData[WhiteSmokeKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush Yellow
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[YellowKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.Yellow);
					SafeNativeMethods.Gdip.ThreadData[YellowKey] = brush;
				}
				return brush;
			}
		}

		/// <summary>Gets a system-defined <see cref="T:System.Drawing.Brush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> object set to a system-defined color.</returns>
		public static Brush YellowGreen
		{
			get
			{
				Brush brush = (Brush)SafeNativeMethods.Gdip.ThreadData[YellowGreenKey];
				if (brush == null)
				{
					brush = new SolidBrush(Color.YellowGreen);
					SafeNativeMethods.Gdip.ThreadData[YellowGreenKey] = brush;
				}
				return brush;
			}
		}

		private Brushes()
		{
		}
	}
	/// <summary>Provides a graphics buffer for double buffering.</summary>
	public sealed class BufferedGraphics : IDisposable
	{
		private Graphics bufferedGraphicsSurface;

		private Graphics targetGraphics;

		private BufferedGraphicsContext context;

		private IntPtr targetDC;

		private Point targetLoc;

		private Size virtualSize;

		private bool disposeContext;

		private static int rop = 13369376;

		internal bool DisposeContext
		{
			get
			{
				return disposeContext;
			}
			set
			{
				disposeContext = value;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Graphics" /> object that outputs to the graphics buffer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> object that outputs to the graphics buffer.</returns>
		public Graphics Graphics => bufferedGraphicsSurface;

		internal BufferedGraphics(Graphics bufferedGraphicsSurface, BufferedGraphicsContext context, Graphics targetGraphics, IntPtr targetDC, Point targetLoc, Size virtualSize)
		{
			this.context = context;
			this.bufferedGraphicsSurface = bufferedGraphicsSurface;
			this.targetDC = targetDC;
			this.targetGraphics = targetGraphics;
			this.targetLoc = targetLoc;
			this.virtualSize = virtualSize;
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~BufferedGraphics()
		{
			Dispose(disposing: false);
		}

		/// <summary>Releases all resources used by the <see cref="T:System.Drawing.BufferedGraphics" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (!disposing)
			{
				return;
			}
			if (context != null)
			{
				context.ReleaseBuffer(this);
				if (DisposeContext)
				{
					context.Dispose();
					context = null;
				}
			}
			if (bufferedGraphicsSurface != null)
			{
				bufferedGraphicsSurface.Dispose();
				bufferedGraphicsSurface = null;
			}
		}

		/// <summary>Writes the contents of the graphics buffer to the default device.</summary>
		public void Render()
		{
			if (targetGraphics != null)
			{
				Render(targetGraphics);
			}
			else
			{
				RenderInternal(new HandleRef(Graphics, targetDC), this);
			}
		}

		/// <summary>Writes the contents of the graphics buffer to the specified <see cref="T:System.Drawing.Graphics" /> object.</summary>
		/// <param name="target">A <see cref="T:System.Drawing.Graphics" /> object to which to write the contents of the graphics buffer.</param>
		public void Render(Graphics target)
		{
			if (target != null)
			{
				IntPtr hdc = target.GetHdc();
				try
				{
					RenderInternal(new HandleRef(target, hdc), this);
				}
				finally
				{
					target.ReleaseHdcInternal(hdc);
				}
			}
		}

		/// <summary>Writes the contents of the graphics buffer to the device context associated with the specified <see cref="T:System.IntPtr" /> handle.</summary>
		/// <param name="targetDC">An <see cref="T:System.IntPtr" /> that points to the device context to which to write the contents of the graphics buffer.</param>
		public void Render(IntPtr targetDC)
		{
			IntSecurity.UnmanagedCode.Demand();
			RenderInternal(new HandleRef(null, targetDC), this);
		}

		private void RenderInternal(HandleRef refTargetDC, BufferedGraphics buffer)
		{
			IntPtr hdc = buffer.Graphics.GetHdc();
			try
			{
				SafeNativeMethods.BitBlt(refTargetDC, targetLoc.X, targetLoc.Y, virtualSize.Width, virtualSize.Height, new HandleRef(buffer.Graphics, hdc), 0, 0, rop);
			}
			finally
			{
				buffer.Graphics.ReleaseHdcInternal(hdc);
			}
		}
	}
	/// <summary>Provides methods for creating graphics buffers that can be used for double buffering.</summary>
	public sealed class BufferedGraphicsContext : IDisposable
	{
		private Size maximumBuffer;

		private Size bufferSize;

		private Size virtualSize;

		private Point targetLoc;

		private IntPtr compatDC;

		private IntPtr dib;

		private IntPtr oldBitmap;

		private Graphics compatGraphics;

		private BufferedGraphics buffer;

		private int busy;

		private bool invalidateWhenFree;

		private const int BUFFER_FREE = 0;

		private const int BUFFER_BUSY_PAINTING = 1;

		private const int BUFFER_BUSY_DISPOSING = 2;

		private static TraceSwitch doubleBuffering;

		internal static TraceSwitch DoubleBuffering
		{
			get
			{
				if (doubleBuffering == null)
				{
					doubleBuffering = new TraceSwitch("DoubleBuffering", "Output information about double buffering");
				}
				return doubleBuffering;
			}
		}

		/// <summary>Gets or sets the maximum size of the buffer to use.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> indicating the maximum size of the buffer dimensions.</returns>
		/// <exception cref="T:System.ArgumentException">The height or width of the size is less than or equal to zero.</exception>
		public Size MaximumBuffer
		{
			get
			{
				return maximumBuffer;
			}
			[UIPermission(SecurityAction.Demand, Window = UIPermissionWindow.AllWindows)]
			set
			{
				if (value.Width <= 0 || value.Height <= 0)
				{
					throw new ArgumentException(SR.GetString("InvalidArgument", "MaximumBuffer", value));
				}
				if (value.Width * value.Height < maximumBuffer.Width * maximumBuffer.Height)
				{
					Invalidate();
				}
				maximumBuffer = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.BufferedGraphicsContext" /> class.</summary>
		public BufferedGraphicsContext()
		{
			maximumBuffer.Width = 225;
			maximumBuffer.Height = 96;
			bufferSize = Size.Empty;
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~BufferedGraphicsContext()
		{
			Dispose(disposing: false);
		}

		/// <summary>Creates a graphics buffer of the specified size using the pixel format of the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="targetGraphics">The <see cref="T:System.Drawing.Graphics" /> to match the pixel format for the new buffer to.</param>
		/// <param name="targetRectangle">A <see cref="T:System.Drawing.Rectangle" /> indicating the size of the buffer to create.</param>
		/// <returns>A <see cref="T:System.Drawing.BufferedGraphics" /> that can be used to draw to a buffer of the specified dimensions.</returns>
		public BufferedGraphics Allocate(Graphics targetGraphics, Rectangle targetRectangle)
		{
			if (ShouldUseTempManager(targetRectangle))
			{
				return AllocBufferInTempManager(targetGraphics, IntPtr.Zero, targetRectangle);
			}
			return AllocBuffer(targetGraphics, IntPtr.Zero, targetRectangle);
		}

		/// <summary>Creates a graphics buffer of the specified size using the pixel format of the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="targetDC">An <see cref="T:System.IntPtr" /> to a device context to match the pixel format of the new buffer to.</param>
		/// <param name="targetRectangle">A <see cref="T:System.Drawing.Rectangle" /> indicating the size of the buffer to create.</param>
		/// <returns>A <see cref="T:System.Drawing.BufferedGraphics" /> that can be used to draw to a buffer of the specified dimensions.</returns>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public BufferedGraphics Allocate(IntPtr targetDC, Rectangle targetRectangle)
		{
			if (ShouldUseTempManager(targetRectangle))
			{
				return AllocBufferInTempManager(null, targetDC, targetRectangle);
			}
			return AllocBuffer(null, targetDC, targetRectangle);
		}

		private BufferedGraphics AllocBuffer(Graphics targetGraphics, IntPtr targetDC, Rectangle targetRectangle)
		{
			if (Interlocked.CompareExchange(ref busy, 1, 0) != 0)
			{
				return AllocBufferInTempManager(targetGraphics, targetDC, targetRectangle);
			}
			targetLoc = new Point(targetRectangle.X, targetRectangle.Y);
			try
			{
				Graphics bufferedGraphicsSurface;
				if (targetGraphics != null)
				{
					IntPtr hdc = targetGraphics.GetHdc();
					try
					{
						bufferedGraphicsSurface = CreateBuffer(hdc, -targetLoc.X, -targetLoc.Y, targetRectangle.Width, targetRectangle.Height);
					}
					finally
					{
						targetGraphics.ReleaseHdcInternal(hdc);
					}
				}
				else
				{
					bufferedGraphicsSurface = CreateBuffer(targetDC, -targetLoc.X, -targetLoc.Y, targetRectangle.Width, targetRectangle.Height);
				}
				buffer = new BufferedGraphics(bufferedGraphicsSurface, this, targetGraphics, targetDC, targetLoc, virtualSize);
			}
			catch
			{
				busy = 0;
				throw;
			}
			return buffer;
		}

		private BufferedGraphics AllocBufferInTempManager(Graphics targetGraphics, IntPtr targetDC, Rectangle targetRectangle)
		{
			BufferedGraphicsContext bufferedGraphicsContext = null;
			BufferedGraphics bufferedGraphics = null;
			try
			{
				bufferedGraphicsContext = new BufferedGraphicsContext();
				if (bufferedGraphicsContext != null)
				{
					bufferedGraphics = bufferedGraphicsContext.AllocBuffer(targetGraphics, targetDC, targetRectangle);
					bufferedGraphics.DisposeContext = true;
				}
			}
			finally
			{
				if (bufferedGraphicsContext != null && (bufferedGraphics == null || (bufferedGraphics != null && !bufferedGraphics.DisposeContext)))
				{
					bufferedGraphicsContext.Dispose();
				}
			}
			return bufferedGraphics;
		}

		private bool bFillBitmapInfo(IntPtr hdc, IntPtr hpal, ref NativeMethods.BITMAPINFO_FLAT pbmi)
		{
			IntPtr intPtr = IntPtr.Zero;
			bool flag = false;
			try
			{
				intPtr = SafeNativeMethods.CreateCompatibleBitmap(new HandleRef(null, hdc), 1, 1);
				if (intPtr == IntPtr.Zero)
				{
					throw new OutOfMemoryException(SR.GetString("GraphicsBufferQueryFail"));
				}
				pbmi.bmiHeader_biSize = Marshal.SizeOf(typeof(NativeMethods.BITMAPINFOHEADER));
				pbmi.bmiColors = new byte[1024];
				SafeNativeMethods.GetDIBits(new HandleRef(null, hdc), new HandleRef(null, intPtr), 0, 0, IntPtr.Zero, ref pbmi, 0);
				if (pbmi.bmiHeader_biBitCount <= 8)
				{
					return bFillColorTable(hdc, hpal, ref pbmi);
				}
				if (pbmi.bmiHeader_biCompression == 3)
				{
					SafeNativeMethods.GetDIBits(new HandleRef(null, hdc), new HandleRef(null, intPtr), 0, pbmi.bmiHeader_biHeight, IntPtr.Zero, ref pbmi, 0);
				}
				return true;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					SafeNativeMethods.DeleteObject(new HandleRef(null, intPtr));
					intPtr = IntPtr.Zero;
				}
			}
		}

		private unsafe bool bFillColorTable(IntPtr hdc, IntPtr hpal, ref NativeMethods.BITMAPINFO_FLAT pbmi)
		{
			bool result = false;
			byte[] array = new byte[sizeof(NativeMethods.PALETTEENTRY) * 256];
			fixed (byte* ptr = pbmi.bmiColors)
			{
				fixed (byte* ptr3 = array)
				{
					NativeMethods.RGBQUAD* ptr2 = (NativeMethods.RGBQUAD*)ptr;
					NativeMethods.PALETTEENTRY* ptr4 = (NativeMethods.PALETTEENTRY*)ptr3;
					int num = 1 << (int)pbmi.bmiHeader_biBitCount;
					if (num <= 256)
					{
						IntPtr zero = IntPtr.Zero;
						uint paletteEntries;
						if (hpal == IntPtr.Zero)
						{
							zero = Graphics.GetHalftonePalette();
							paletteEntries = SafeNativeMethods.GetPaletteEntries(new HandleRef(null, zero), 0, num, array);
						}
						else
						{
							paletteEntries = SafeNativeMethods.GetPaletteEntries(new HandleRef(null, hpal), 0, num, array);
						}
						if (paletteEntries != 0)
						{
							for (int i = 0; i < num; i++)
							{
								ptr2[i].rgbRed = ptr4[i].peRed;
								ptr2[i].rgbGreen = ptr4[i].peGreen;
								ptr2[i].rgbBlue = ptr4[i].peBlue;
								ptr2[i].rgbReserved = 0;
							}
							result = true;
						}
					}
				}
			}
			return result;
		}

		private Graphics CreateBuffer(IntPtr src, int offsetX, int offsetY, int width, int height)
		{
			busy = 2;
			DisposeDC();
			busy = 1;
			compatDC = UnsafeNativeMethods.CreateCompatibleDC(new HandleRef(null, src));
			if (width > bufferSize.Width || height > bufferSize.Height)
			{
				int num = Math.Max(width, bufferSize.Width);
				int num2 = Math.Max(height, bufferSize.Height);
				busy = 2;
				DisposeBitmap();
				busy = 1;
				IntPtr ppvBits = IntPtr.Zero;
				dib = CreateCompatibleDIB(src, IntPtr.Zero, num, num2, ref ppvBits);
				bufferSize = new Size(num, num2);
			}
			oldBitmap = SafeNativeMethods.SelectObject(new HandleRef(this, compatDC), new HandleRef(this, dib));
			compatGraphics = Graphics.FromHdcInternal(compatDC);
			compatGraphics.TranslateTransform(-targetLoc.X, -targetLoc.Y);
			virtualSize = new Size(width, height);
			return compatGraphics;
		}

		private IntPtr CreateCompatibleDIB(IntPtr hdc, IntPtr hpal, int ulWidth, int ulHeight, ref IntPtr ppvBits)
		{
			if (hdc == IntPtr.Zero)
			{
				throw new ArgumentNullException("hdc");
			}
			IntPtr intPtr = IntPtr.Zero;
			NativeMethods.BITMAPINFO_FLAT pbmi = default(NativeMethods.BITMAPINFO_FLAT);
			int objectType = UnsafeNativeMethods.GetObjectType(new HandleRef(null, hdc));
			if ((uint)(objectType - 3) > 1u && objectType != 10 && objectType != 12)
			{
				throw new ArgumentException(SR.GetString("DCTypeInvalid"));
			}
			if (bFillBitmapInfo(hdc, hpal, ref pbmi))
			{
				pbmi.bmiHeader_biWidth = ulWidth;
				pbmi.bmiHeader_biHeight = ulHeight;
				if (pbmi.bmiHeader_biCompression == 0)
				{
					pbmi.bmiHeader_biSizeImage = 0;
				}
				else if (pbmi.bmiHeader_biBitCount == 16)
				{
					pbmi.bmiHeader_biSizeImage = ulWidth * ulHeight * 2;
				}
				else if (pbmi.bmiHeader_biBitCount == 32)
				{
					pbmi.bmiHeader_biSizeImage = ulWidth * ulHeight * 4;
				}
				else
				{
					pbmi.bmiHeader_biSizeImage = 0;
				}
				pbmi.bmiHeader_biClrUsed = 0;
				pbmi.bmiHeader_biClrImportant = 0;
				intPtr = SafeNativeMethods.CreateDIBSection(new HandleRef(null, hdc), ref pbmi, 0, ref ppvBits, IntPtr.Zero, 0);
				Win32Exception ex = null;
				if (intPtr == IntPtr.Zero)
				{
					ex = new Win32Exception(Marshal.GetLastWin32Error());
				}
				if (ex != null)
				{
					throw ex;
				}
			}
			return intPtr;
		}

		/// <summary>Releases all resources used by the <see cref="T:System.Drawing.BufferedGraphicsContext" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void DisposeDC()
		{
			if (oldBitmap != IntPtr.Zero && compatDC != IntPtr.Zero)
			{
				SafeNativeMethods.SelectObject(new HandleRef(this, compatDC), new HandleRef(this, oldBitmap));
				oldBitmap = IntPtr.Zero;
			}
			if (compatDC != IntPtr.Zero)
			{
				UnsafeNativeMethods.DeleteDC(new HandleRef(this, compatDC));
				compatDC = IntPtr.Zero;
			}
		}

		private void DisposeBitmap()
		{
			if (dib != IntPtr.Zero)
			{
				SafeNativeMethods.DeleteObject(new HandleRef(this, dib));
				dib = IntPtr.Zero;
			}
		}

		private void Dispose(bool disposing)
		{
			int num = Interlocked.CompareExchange(ref busy, 2, 0);
			if (disposing)
			{
				if (num == 1)
				{
					throw new InvalidOperationException(SR.GetString("GraphicsBufferCurrentlyBusy"));
				}
				if (compatGraphics != null)
				{
					compatGraphics.Dispose();
					compatGraphics = null;
				}
			}
			DisposeDC();
			DisposeBitmap();
			if (buffer != null)
			{
				buffer.Dispose();
				buffer = null;
			}
			bufferSize = Size.Empty;
			virtualSize = Size.Empty;
			busy = 0;
		}

		/// <summary>Disposes of the current graphics buffer, if a buffer has been allocated and has not yet been disposed.</summary>
		public void Invalidate()
		{
			if (Interlocked.CompareExchange(ref busy, 2, 0) == 0)
			{
				Dispose();
				busy = 0;
			}
			else
			{
				invalidateWhenFree = true;
			}
		}

		internal void ReleaseBuffer(BufferedGraphics buffer)
		{
			this.buffer = null;
			if (invalidateWhenFree)
			{
				busy = 2;
				Dispose();
			}
			else
			{
				busy = 2;
				DisposeDC();
			}
			busy = 0;
		}

		private bool ShouldUseTempManager(Rectangle targetBounds)
		{
			return targetBounds.Width * targetBounds.Height > MaximumBuffer.Width * MaximumBuffer.Height;
		}
	}
	/// <summary>Provides access to the main buffered graphics context object for the application domain.</summary>
	public sealed class BufferedGraphicsManager
	{
		private static BufferedGraphicsContext bufferedGraphicsContext;

		/// <summary>Gets the <see cref="T:System.Drawing.BufferedGraphicsContext" /> for the current application domain.</summary>
		/// <returns>The <see cref="T:System.Drawing.BufferedGraphicsContext" /> for the current application domain.</returns>
		public static BufferedGraphicsContext Current => bufferedGraphicsContext;

		private BufferedGraphicsManager()
		{
		}

		static BufferedGraphicsManager()
		{
			AppDomain.CurrentDomain.ProcessExit += OnShutdown;
			AppDomain.CurrentDomain.DomainUnload += OnShutdown;
			bufferedGraphicsContext = new BufferedGraphicsContext();
		}

		[PrePrepareMethod]
		private static void OnShutdown(object sender, EventArgs e)
		{
			Current.Invalidate();
		}
	}
	/// <summary>Represents an ARGB (alpha, red, green, blue) color.</summary>
	[Serializable]
	[TypeConverter(typeof(ColorConverter))]
	[DebuggerDisplay("{NameAndARGBValue}")]
	[Editor("System.Drawing.Design.ColorEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public struct Color
	{
		/// <summary>Represents a color that is <see langword="null" />.</summary>
		public static readonly Color Empty = default(Color);

		private static short StateKnownColorValid = 1;

		private static short StateARGBValueValid = 2;

		private static short StateValueMask = StateARGBValueValid;

		private static short StateNameValid = 8;

		private static long NotDefinedValue = 0L;

		private const int ARGBAlphaShift = 24;

		private const int ARGBRedShift = 16;

		private const int ARGBGreenShift = 8;

		private const int ARGBBlueShift = 0;

		private readonly string name;

		private readonly long value;

		private readonly short knownColor;

		private readonly short state;

		/// <summary>Gets a system-defined color.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Transparent => new Color(KnownColor.Transparent);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF0F8FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color AliceBlue => new Color(KnownColor.AliceBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFAEBD7.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color AntiqueWhite => new Color(KnownColor.AntiqueWhite);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00FFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Aqua => new Color(KnownColor.Aqua);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF7FFFD4.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Aquamarine => new Color(KnownColor.Aquamarine);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF0FFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Azure => new Color(KnownColor.Azure);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF5F5DC.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Beige => new Color(KnownColor.Beige);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFE4C4.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Bisque => new Color(KnownColor.Bisque);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF000000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Black => new Color(KnownColor.Black);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFEBCD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color BlanchedAlmond => new Color(KnownColor.BlanchedAlmond);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF0000FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Blue => new Color(KnownColor.Blue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF8A2BE2.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color BlueViolet => new Color(KnownColor.BlueViolet);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFA52A2A.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Brown => new Color(KnownColor.Brown);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDEB887.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color BurlyWood => new Color(KnownColor.BurlyWood);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF5F9EA0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color CadetBlue => new Color(KnownColor.CadetBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF7FFF00.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Chartreuse => new Color(KnownColor.Chartreuse);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFD2691E.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Chocolate => new Color(KnownColor.Chocolate);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF7F50.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Coral => new Color(KnownColor.Coral);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF6495ED.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color CornflowerBlue => new Color(KnownColor.CornflowerBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFF8DC.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Cornsilk => new Color(KnownColor.Cornsilk);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDC143C.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Crimson => new Color(KnownColor.Crimson);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00FFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Cyan => new Color(KnownColor.Cyan);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00008B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkBlue => new Color(KnownColor.DarkBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF008B8B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkCyan => new Color(KnownColor.DarkCyan);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFB8860B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkGoldenrod => new Color(KnownColor.DarkGoldenrod);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFA9A9A9.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkGray => new Color(KnownColor.DarkGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF006400.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkGreen => new Color(KnownColor.DarkGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFBDB76B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkKhaki => new Color(KnownColor.DarkKhaki);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF8B008B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkMagenta => new Color(KnownColor.DarkMagenta);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF556B2F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkOliveGreen => new Color(KnownColor.DarkOliveGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF8C00.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkOrange => new Color(KnownColor.DarkOrange);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF9932CC.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkOrchid => new Color(KnownColor.DarkOrchid);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF8B0000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkRed => new Color(KnownColor.DarkRed);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFE9967A.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkSalmon => new Color(KnownColor.DarkSalmon);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF8FBC8F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkSeaGreen => new Color(KnownColor.DarkSeaGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF483D8B.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkSlateBlue => new Color(KnownColor.DarkSlateBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF2F4F4F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkSlateGray => new Color(KnownColor.DarkSlateGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00CED1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkTurquoise => new Color(KnownColor.DarkTurquoise);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF9400D3.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DarkViolet => new Color(KnownColor.DarkViolet);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF1493.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DeepPink => new Color(KnownColor.DeepPink);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00BFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DeepSkyBlue => new Color(KnownColor.DeepSkyBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF696969.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DimGray => new Color(KnownColor.DimGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF1E90FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color DodgerBlue => new Color(KnownColor.DodgerBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFB22222.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Firebrick => new Color(KnownColor.Firebrick);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFAF0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color FloralWhite => new Color(KnownColor.FloralWhite);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF228B22.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color ForestGreen => new Color(KnownColor.ForestGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF00FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Fuchsia => new Color(KnownColor.Fuchsia);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDCDCDC.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Gainsboro => new Color(KnownColor.Gainsboro);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF8F8FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color GhostWhite => new Color(KnownColor.GhostWhite);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFD700.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Gold => new Color(KnownColor.Gold);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDAA520.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Goldenrod => new Color(KnownColor.Goldenrod);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF808080.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> strcture representing a system-defined color.</returns>
		public static Color Gray => new Color(KnownColor.Gray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF008000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Green => new Color(KnownColor.Green);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFADFF2F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color GreenYellow => new Color(KnownColor.GreenYellow);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF0FFF0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Honeydew => new Color(KnownColor.Honeydew);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF69B4.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color HotPink => new Color(KnownColor.HotPink);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFCD5C5C.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color IndianRed => new Color(KnownColor.IndianRed);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF4B0082.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Indigo => new Color(KnownColor.Indigo);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFFF0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Ivory => new Color(KnownColor.Ivory);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF0E68C.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Khaki => new Color(KnownColor.Khaki);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFE6E6FA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Lavender => new Color(KnownColor.Lavender);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFF0F5.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LavenderBlush => new Color(KnownColor.LavenderBlush);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF7CFC00.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LawnGreen => new Color(KnownColor.LawnGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFACD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LemonChiffon => new Color(KnownColor.LemonChiffon);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFADD8E6.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightBlue => new Color(KnownColor.LightBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF08080.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightCoral => new Color(KnownColor.LightCoral);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFE0FFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightCyan => new Color(KnownColor.LightCyan);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFAFAD2.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightGoldenrodYellow => new Color(KnownColor.LightGoldenrodYellow);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF90EE90.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightGreen => new Color(KnownColor.LightGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFD3D3D3.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightGray => new Color(KnownColor.LightGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFB6C1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightPink => new Color(KnownColor.LightPink);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFA07A.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightSalmon => new Color(KnownColor.LightSalmon);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF20B2AA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightSeaGreen => new Color(KnownColor.LightSeaGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF87CEFA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightSkyBlue => new Color(KnownColor.LightSkyBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF778899.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightSlateGray => new Color(KnownColor.LightSlateGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFB0C4DE.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightSteelBlue => new Color(KnownColor.LightSteelBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFFE0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LightYellow => new Color(KnownColor.LightYellow);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00FF00.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Lime => new Color(KnownColor.Lime);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF32CD32.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color LimeGreen => new Color(KnownColor.LimeGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFAF0E6.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Linen => new Color(KnownColor.Linen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF00FF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Magenta => new Color(KnownColor.Magenta);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF800000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Maroon => new Color(KnownColor.Maroon);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF66CDAA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumAquamarine => new Color(KnownColor.MediumAquamarine);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF0000CD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumBlue => new Color(KnownColor.MediumBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFBA55D3.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumOrchid => new Color(KnownColor.MediumOrchid);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF9370DB.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumPurple => new Color(KnownColor.MediumPurple);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF3CB371.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumSeaGreen => new Color(KnownColor.MediumSeaGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF7B68EE.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumSlateBlue => new Color(KnownColor.MediumSlateBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00FA9A.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumSpringGreen => new Color(KnownColor.MediumSpringGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF48D1CC.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumTurquoise => new Color(KnownColor.MediumTurquoise);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFC71585.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MediumVioletRed => new Color(KnownColor.MediumVioletRed);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF191970.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MidnightBlue => new Color(KnownColor.MidnightBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF5FFFA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MintCream => new Color(KnownColor.MintCream);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFE4E1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color MistyRose => new Color(KnownColor.MistyRose);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFE4B5.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Moccasin => new Color(KnownColor.Moccasin);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFDEAD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color NavajoWhite => new Color(KnownColor.NavajoWhite);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF000080.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Navy => new Color(KnownColor.Navy);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFDF5E6.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color OldLace => new Color(KnownColor.OldLace);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF808000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Olive => new Color(KnownColor.Olive);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF6B8E23.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color OliveDrab => new Color(KnownColor.OliveDrab);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFA500.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Orange => new Color(KnownColor.Orange);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF4500.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color OrangeRed => new Color(KnownColor.OrangeRed);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDA70D6.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Orchid => new Color(KnownColor.Orchid);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFEEE8AA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PaleGoldenrod => new Color(KnownColor.PaleGoldenrod);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF98FB98.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PaleGreen => new Color(KnownColor.PaleGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFAFEEEE.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PaleTurquoise => new Color(KnownColor.PaleTurquoise);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDB7093.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PaleVioletRed => new Color(KnownColor.PaleVioletRed);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFEFD5.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PapayaWhip => new Color(KnownColor.PapayaWhip);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFDAB9.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PeachPuff => new Color(KnownColor.PeachPuff);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFCD853F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Peru => new Color(KnownColor.Peru);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFC0CB.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Pink => new Color(KnownColor.Pink);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFDDA0DD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Plum => new Color(KnownColor.Plum);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFB0E0E6.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color PowderBlue => new Color(KnownColor.PowderBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF800080.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Purple => new Color(KnownColor.Purple);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF0000.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Red => new Color(KnownColor.Red);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFBC8F8F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color RosyBrown => new Color(KnownColor.RosyBrown);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF4169E1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color RoyalBlue => new Color(KnownColor.RoyalBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF8B4513.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SaddleBrown => new Color(KnownColor.SaddleBrown);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFA8072.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Salmon => new Color(KnownColor.Salmon);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF4A460.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SandyBrown => new Color(KnownColor.SandyBrown);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF2E8B57.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SeaGreen => new Color(KnownColor.SeaGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFF5EE.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SeaShell => new Color(KnownColor.SeaShell);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFA0522D.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Sienna => new Color(KnownColor.Sienna);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFC0C0C0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Silver => new Color(KnownColor.Silver);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF87CEEB.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SkyBlue => new Color(KnownColor.SkyBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF6A5ACD.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SlateBlue => new Color(KnownColor.SlateBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF708090.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SlateGray => new Color(KnownColor.SlateGray);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFAFA.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Snow => new Color(KnownColor.Snow);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF00FF7F.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SpringGreen => new Color(KnownColor.SpringGreen);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF4682B4.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color SteelBlue => new Color(KnownColor.SteelBlue);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFD2B48C.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Tan => new Color(KnownColor.Tan);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF008080.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Teal => new Color(KnownColor.Teal);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFD8BFD8.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Thistle => new Color(KnownColor.Thistle);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFF6347.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Tomato => new Color(KnownColor.Tomato);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF40E0D0.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Turquoise => new Color(KnownColor.Turquoise);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFEE82EE.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Violet => new Color(KnownColor.Violet);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF5DEB3.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Wheat => new Color(KnownColor.Wheat);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFFFF.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color White => new Color(KnownColor.White);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFF5F5F5.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color WhiteSmoke => new Color(KnownColor.WhiteSmoke);

		/// <summary>Gets a system-defined color that has an ARGB value of #FFFFFF00.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color Yellow => new Color(KnownColor.Yellow);

		/// <summary>Gets a system-defined color that has an ARGB value of #FF9ACD32.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> representing a system-defined color.</returns>
		public static Color YellowGreen => new Color(KnownColor.YellowGreen);

		/// <summary>Gets the red component value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The red component value of this <see cref="T:System.Drawing.Color" />.</returns>
		public byte R => (byte)((Value >> 16) & 0xFF);

		/// <summary>Gets the green component value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The green component value of this <see cref="T:System.Drawing.Color" />.</returns>
		public byte G => (byte)((Value >> 8) & 0xFF);

		/// <summary>Gets the blue component value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The blue component value of this <see cref="T:System.Drawing.Color" />.</returns>
		public byte B => (byte)(Value & 0xFF);

		/// <summary>Gets the alpha component value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The alpha component value of this <see cref="T:System.Drawing.Color" />.</returns>
		public byte A => (byte)((Value >> 24) & 0xFF);

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Color" /> structure is a predefined color. Predefined colors are represented by the elements of the <see cref="T:System.Drawing.KnownColor" /> enumeration.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Color" /> was created from a predefined color by using either the <see cref="M:System.Drawing.Color.FromName(System.String)" /> method or the <see cref="M:System.Drawing.Color.FromKnownColor(System.Drawing.KnownColor)" /> method; otherwise, <see langword="false" />.</returns>
		public bool IsKnownColor => (state & StateKnownColorValid) != 0;

		/// <summary>Specifies whether this <see cref="T:System.Drawing.Color" /> structure is uninitialized.</summary>
		/// <returns>This property returns <see langword="true" /> if this color is uninitialized; otherwise, <see langword="false" />.</returns>
		public bool IsEmpty => state == 0;

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Color" /> structure is a named color or a member of the <see cref="T:System.Drawing.KnownColor" /> enumeration.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Color" /> was created by using either the <see cref="M:System.Drawing.Color.FromName(System.String)" /> method or the <see cref="M:System.Drawing.Color.FromKnownColor(System.Drawing.KnownColor)" /> method; otherwise, <see langword="false" />.</returns>
		public bool IsNamedColor
		{
			get
			{
				if ((state & StateNameValid) == 0)
				{
					return IsKnownColor;
				}
				return true;
			}
		}

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Color" /> structure is a system color. A system color is a color that is used in a Windows display element. System colors are represented by elements of the <see cref="T:System.Drawing.KnownColor" /> enumeration.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Color" /> was created from a system color by using either the <see cref="M:System.Drawing.Color.FromName(System.String)" /> method or the <see cref="M:System.Drawing.Color.FromKnownColor(System.Drawing.KnownColor)" /> method; otherwise, <see langword="false" />.</returns>
		public bool IsSystemColor
		{
			get
			{
				if (IsKnownColor)
				{
					if (knownColor > 26)
					{
						return knownColor > 167;
					}
					return true;
				}
				return false;
			}
		}

		private string NameAndARGBValue => string.Format(CultureInfo.CurrentCulture, "{{Name={0}, ARGB=({1}, {2}, {3}, {4})}}", Name, A, R, G, B);

		/// <summary>Gets the name of this <see cref="T:System.Drawing.Color" />.</summary>
		/// <returns>The name of this <see cref="T:System.Drawing.Color" />.</returns>
		public string Name
		{
			get
			{
				if ((state & StateNameValid) != 0)
				{
					return name;
				}
				if (IsKnownColor)
				{
					string text = KnownColorTable.KnownColorToName((KnownColor)this.knownColor);
					if (text != null)
					{
						return text;
					}
					KnownColor knownColor = (KnownColor)this.knownColor;
					return knownColor.ToString();
				}
				return Convert.ToString(value, 16);
			}
		}

		private long Value
		{
			get
			{
				if ((state & StateValueMask) != 0)
				{
					return value;
				}
				if (IsKnownColor)
				{
					return KnownColorTable.KnownColorToArgb((KnownColor)knownColor);
				}
				return NotDefinedValue;
			}
		}

		internal Color(KnownColor knownColor)
		{
			value = 0L;
			state = StateKnownColorValid;
			name = null;
			this.knownColor = (short)knownColor;
		}

		private Color(long value, short state, string name, KnownColor knownColor)
		{
			this.value = value;
			this.state = state;
			this.name = name;
			this.knownColor = (short)knownColor;
		}

		private static void CheckByte(int value, string name)
		{
			if (value < 0 || value > 255)
			{
				throw new ArgumentException(SR.GetString("InvalidEx2BoundArgument", name, value, 0, 255));
			}
		}

		private static long MakeArgb(byte alpha, byte red, byte green, byte blue)
		{
			return (long)(uint)((red << 16) | (green << 8) | blue | (alpha << 24)) & 0xFFFFFFFFL;
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from a 32-bit ARGB value.</summary>
		/// <param name="argb">A value specifying the 32-bit ARGB value.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> structure that this method creates.</returns>
		public static Color FromArgb(int argb)
		{
			return new Color(argb & 0xFFFFFFFFu, StateARGBValueValid, null, (KnownColor)0);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from the four ARGB component (alpha, red, green, and blue) values. Although this method allows a 32-bit value to be passed for each component, the value of each component is limited to 8 bits.</summary>
		/// <param name="alpha">The alpha component. Valid values are 0 through 255.</param>
		/// <param name="red">The red component. Valid values are 0 through 255.</param>
		/// <param name="green">The green component. Valid values are 0 through 255.</param>
		/// <param name="blue">The blue component. Valid values are 0 through 255.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="alpha" />, <paramref name="red" />, <paramref name="green" />, or <paramref name="blue" /> is less than 0 or greater than 255.</exception>
		public static Color FromArgb(int alpha, int red, int green, int blue)
		{
			CheckByte(alpha, "alpha");
			CheckByte(red, "red");
			CheckByte(green, "green");
			CheckByte(blue, "blue");
			return new Color(MakeArgb((byte)alpha, (byte)red, (byte)green, (byte)blue), StateARGBValueValid, null, (KnownColor)0);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from the specified <see cref="T:System.Drawing.Color" /> structure, but with the new specified alpha value. Although this method allows a 32-bit value to be passed for the alpha value, the value is limited to 8 bits.</summary>
		/// <param name="alpha">The alpha value for the new <see cref="T:System.Drawing.Color" />. Valid values are 0 through 255.</param>
		/// <param name="baseColor">The <see cref="T:System.Drawing.Color" /> from which to create the new <see cref="T:System.Drawing.Color" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="alpha" /> is less than 0 or greater than 255.</exception>
		public static Color FromArgb(int alpha, Color baseColor)
		{
			CheckByte(alpha, "alpha");
			return new Color(MakeArgb((byte)alpha, baseColor.R, baseColor.G, baseColor.B), StateARGBValueValid, null, (KnownColor)0);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from the specified 8-bit color values (red, green, and blue). The alpha value is implicitly 255 (fully opaque). Although this method allows a 32-bit value to be passed for each color component, the value of each component is limited to 8 bits.</summary>
		/// <param name="red">The red component value for the new <see cref="T:System.Drawing.Color" />. Valid values are 0 through 255.</param>
		/// <param name="green">The green component value for the new <see cref="T:System.Drawing.Color" />. Valid values are 0 through 255.</param>
		/// <param name="blue">The blue component value for the new <see cref="T:System.Drawing.Color" />. Valid values are 0 through 255.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="red" />, <paramref name="green" />, or <paramref name="blue" /> is less than 0 or greater than 255.</exception>
		public static Color FromArgb(int red, int green, int blue)
		{
			return FromArgb(255, red, green, blue);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from the specified predefined color.</summary>
		/// <param name="color">An element of the <see cref="T:System.Drawing.KnownColor" /> enumeration.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> that this method creates.</returns>
		public static Color FromKnownColor(KnownColor color)
		{
			if (!ClientUtils.IsEnumValid(color, (int)color, 1, 174))
			{
				return FromName(color.ToString());
			}
			return new Color(color);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Color" /> structure from the specified name of a predefined color.</summary>
		/// <param name="name">A string that is the name of a predefined color. Valid names are the same as the names of the elements of the <see cref="T:System.Drawing.KnownColor" /> enumeration.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> that this method creates.</returns>
		public static Color FromName(string name)
		{
			object namedColor = ColorConverter.GetNamedColor(name);
			if (namedColor != null)
			{
				return (Color)namedColor;
			}
			return new Color(NotDefinedValue, StateNameValid, name, (KnownColor)0);
		}

		/// <summary>Gets the hue-saturation-lightness (HSL) lightness value for this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The lightness of this <see cref="T:System.Drawing.Color" />. The lightness ranges from 0.0 through 1.0, where 0.0 represents black and 1.0 represents white.</returns>
		public float GetBrightness()
		{
			float num = (float)(int)R / 255f;
			float num2 = (float)(int)G / 255f;
			float num3 = (float)(int)B / 255f;
			float num4 = num;
			float num5 = num;
			if (num2 > num4)
			{
				num4 = num2;
			}
			if (num3 > num4)
			{
				num4 = num3;
			}
			if (num2 < num5)
			{
				num5 = num2;
			}
			if (num3 < num5)
			{
				num5 = num3;
			}
			return (num4 + num5) / 2f;
		}

		/// <summary>Gets the hue-saturation-lightness (HSL) hue value, in degrees, for this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The hue, in degrees, of this <see cref="T:System.Drawing.Color" />. The hue is measured in degrees, ranging from 0.0 through 360.0, in HSL color space.</returns>
		public float GetHue()
		{
			if (R == G && G == B)
			{
				return 0f;
			}
			float num = (float)(int)R / 255f;
			float num2 = (float)(int)G / 255f;
			float num3 = (float)(int)B / 255f;
			float num4 = 0f;
			float num5 = num;
			float num6 = num;
			if (num2 > num5)
			{
				num5 = num2;
			}
			if (num3 > num5)
			{
				num5 = num3;
			}
			if (num2 < num6)
			{
				num6 = num2;
			}
			if (num3 < num6)
			{
				num6 = num3;
			}
			float num7 = num5 - num6;
			if (num == num5)
			{
				num4 = (num2 - num3) / num7;
			}
			else if (num2 == num5)
			{
				num4 = 2f + (num3 - num) / num7;
			}
			else if (num3 == num5)
			{
				num4 = 4f + (num - num2) / num7;
			}
			num4 *= 60f;
			if (num4 < 0f)
			{
				num4 += 360f;
			}
			return num4;
		}

		/// <summary>Gets the hue-saturation-lightness (HSL) saturation value for this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The saturation of this <see cref="T:System.Drawing.Color" />. The saturation ranges from 0.0 through 1.0, where 0.0 is grayscale and 1.0 is the most saturated.</returns>
		public float GetSaturation()
		{
			float num = (float)(int)R / 255f;
			float num2 = (float)(int)G / 255f;
			float num3 = (float)(int)B / 255f;
			float result = 0f;
			float num4 = num;
			float num5 = num;
			if (num2 > num4)
			{
				num4 = num2;
			}
			if (num3 > num4)
			{
				num4 = num3;
			}
			if (num2 < num5)
			{
				num5 = num2;
			}
			if (num3 < num5)
			{
				num5 = num3;
			}
			if (num4 != num5)
			{
				float num6 = (num4 + num5) / 2f;
				result = ((!((double)num6 <= 0.5)) ? ((num4 - num5) / (2f - num4 - num5)) : ((num4 - num5) / (num4 + num5)));
			}
			return result;
		}

		/// <summary>Gets the 32-bit ARGB value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>The 32-bit ARGB value of this <see cref="T:System.Drawing.Color" />.</returns>
		public int ToArgb()
		{
			return (int)Value;
		}

		/// <summary>Gets the <see cref="T:System.Drawing.KnownColor" /> value of this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>An element of the <see cref="T:System.Drawing.KnownColor" /> enumeration, if the <see cref="T:System.Drawing.Color" /> is created from a predefined color by using either the <see cref="M:System.Drawing.Color.FromName(System.String)" /> method or the <see cref="M:System.Drawing.Color.FromKnownColor(System.Drawing.KnownColor)" /> method; otherwise, 0.</returns>
		public KnownColor ToKnownColor()
		{
			return (KnownColor)knownColor;
		}

		/// <summary>Converts this <see cref="T:System.Drawing.Color" /> structure to a human-readable string.</summary>
		/// <returns>A string that is the name of this <see cref="T:System.Drawing.Color" />, if the <see cref="T:System.Drawing.Color" /> is created from a predefined color by using either the <see cref="M:System.Drawing.Color.FromName(System.String)" /> method or the <see cref="M:System.Drawing.Color.FromKnownColor(System.Drawing.KnownColor)" /> method; otherwise, a string that consists of the ARGB component names and their values.</returns>
		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder(32);
			stringBuilder.Append(GetType().Name);
			stringBuilder.Append(" [");
			if ((state & StateNameValid) != 0)
			{
				stringBuilder.Append(Name);
			}
			else if ((state & StateKnownColorValid) != 0)
			{
				stringBuilder.Append(Name);
			}
			else if ((state & StateValueMask) != 0)
			{
				stringBuilder.Append("A=");
				stringBuilder.Append(A);
				stringBuilder.Append(", R=");
				stringBuilder.Append(R);
				stringBuilder.Append(", G=");
				stringBuilder.Append(G);
				stringBuilder.Append(", B=");
				stringBuilder.Append(B);
			}
			else
			{
				stringBuilder.Append("Empty");
			}
			stringBuilder.Append("]");
			return stringBuilder.ToString();
		}

		/// <summary>Tests whether two specified <see cref="T:System.Drawing.Color" /> structures are equivalent.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.Color" /> that is to the left of the equality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.Color" /> that is to the right of the equality operator.</param>
		/// <returns>
		///   <see langword="true" /> if the two <see cref="T:System.Drawing.Color" /> structures are equal; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(Color left, Color right)
		{
			if (left.value == right.value && left.state == right.state && left.knownColor == right.knownColor)
			{
				if (left.name == right.name)
				{
					return true;
				}
				if (left.name == null || right.name == null)
				{
					return false;
				}
				return left.name.Equals(right.name);
			}
			return false;
		}

		/// <summary>Tests whether two specified <see cref="T:System.Drawing.Color" /> structures are different.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.Color" /> that is to the left of the inequality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.Color" /> that is to the right of the inequality operator.</param>
		/// <returns>
		///   <see langword="true" /> if the two <see cref="T:System.Drawing.Color" /> structures are different; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(Color left, Color right)
		{
			return !(left == right);
		}

		/// <summary>Tests whether the specified object is a <see cref="T:System.Drawing.Color" /> structure and is equivalent to this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="obj">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.Color" /> structure equivalent to this <see cref="T:System.Drawing.Color" /> structure; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Color color && value == color.value && state == color.state && knownColor == color.knownColor)
			{
				if (name == color.name)
				{
					return true;
				}
				if (name == null || color.name == null)
				{
					return false;
				}
				return name.Equals(name);
			}
			return false;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <returns>An integer value that specifies the hash code for this <see cref="T:System.Drawing.Color" />.</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode() ^ state.GetHashCode() ^ knownColor.GetHashCode();
		}
	}
	/// <summary>Converts colors from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" />.</summary>
	public class ColorConverter : TypeConverter
	{
		private class ColorComparer : IComparer
		{
			public int Compare(object left, object right)
			{
				Color color = (Color)left;
				return string.Compare(strB: ((Color)right).Name, strA: color.Name, ignoreCase: false, culture: CultureInfo.InvariantCulture);
			}
		}

		private static string ColorConstantsLock = "colorConstants";

		private static Hashtable colorConstants;

		private static string SystemColorConstantsLock = "systemColorConstants";

		private static Hashtable systemColorConstants;

		private static string ValuesLock = "values";

		private static StandardValuesCollection values;

		private static Hashtable Colors
		{
			get
			{
				if (colorConstants == null)
				{
					lock (ColorConstantsLock)
					{
						if (colorConstants == null)
						{
							Hashtable hash = new Hashtable(StringComparer.OrdinalIgnoreCase);
							FillConstants(hash, typeof(Color));
							colorConstants = hash;
						}
					}
				}
				return colorConstants;
			}
		}

		private static Hashtable SystemColors
		{
			get
			{
				if (systemColorConstants == null)
				{
					lock (SystemColorConstantsLock)
					{
						if (systemColorConstants == null)
						{
							Hashtable hash = new Hashtable(StringComparer.OrdinalIgnoreCase);
							FillConstants(hash, typeof(SystemColors));
							systemColorConstants = hash;
						}
					}
				}
				return systemColorConstants;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.ColorConverter" /> class.</summary>
		public ColorConverter()
		{
		}

		/// <summary>Determines if this converter can convert an object in the given source type to the native type of the converter.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. You can use this object to get additional information about the environment from which this converter is being invoked.</param>
		/// <param name="sourceType">The type from which you want to convert.</param>
		/// <returns>
		///   <see langword="true" /> if this object can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Returns a value indicating whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that represents the type to which you want to convert.</param>
		/// <returns>
		///   <see langword="true" /> if this converter can perform the operation; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		internal static object GetNamedColor(string name)
		{
			object obj = null;
			obj = Colors[name];
			if (obj != null)
			{
				return obj;
			}
			return SystemColors[name];
		}

		/// <summary>Converts the given object to the converter's native type.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> that provides a format context. You can use this object to get additional information about the environment from which this converter is being invoked.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that specifies the culture to represent the color.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>An <see cref="T:System.Object" /> representing the converted value.</returns>
		/// <exception cref="T:System.ArgumentException">The conversion cannot be performed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				object obj = null;
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					obj = Color.Empty;
				}
				else
				{
					obj = GetNamedColor(text2);
					if (obj == null)
					{
						if (culture == null)
						{
							culture = CultureInfo.CurrentCulture;
						}
						char c = culture.TextInfo.ListSeparator[0];
						bool flag = true;
						TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
						if (text2.IndexOf(c) == -1)
						{
							if (text2.Length >= 2 && (text2[0] == '\'' || text2[0] == '"') && text2[0] == text2[text2.Length - 1])
							{
								string name = text2.Substring(1, text2.Length - 2);
								obj = Color.FromName(name);
								flag = false;
							}
							else if ((text2.Length == 7 && text2[0] == '#') || (text2.Length == 8 && (text2.StartsWith("0x") || text2.StartsWith("0X"))) || (text2.Length == 8 && (text2.StartsWith("&h") || text2.StartsWith("&H"))))
							{
								obj = Color.FromArgb(-16777216 | (int)converter.ConvertFromString(context, culture, text2));
							}
						}
						if (obj == null)
						{
							string[] array = text2.Split(c);
							int[] array2 = new int[array.Length];
							for (int i = 0; i < array2.Length; i++)
							{
								array2[i] = (int)converter.ConvertFromString(context, culture, array[i]);
							}
							switch (array2.Length)
							{
							case 1:
								obj = Color.FromArgb(array2[0]);
								break;
							case 3:
								obj = Color.FromArgb(array2[0], array2[1], array2[2]);
								break;
							case 4:
								obj = Color.FromArgb(array2[0], array2[1], array2[2], array2[3]);
								break;
							}
							flag = true;
						}
						if (obj != null && flag)
						{
							int num = ((Color)obj).ToArgb();
							foreach (Color value2 in Colors.Values)
							{
								if (value2.ToArgb() == num)
								{
									obj = value2;
									break;
								}
							}
						}
					}
					if (obj == null)
					{
						throw new ArgumentException(SR.GetString("InvalidColor", text2));
					}
				}
				return obj;
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts the specified object to another type.</summary>
		/// <param name="context">A formatter context. Use this object to extract additional information about the environment from which this converter is being invoked. Always check whether this value is <see langword="null" />. Also, properties on the context object may return <see langword="null" />.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that specifies the culture to represent the color.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The type to convert the object to.</param>
		/// <returns>An <see cref="T:System.Object" /> representing the converted value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="destinationtype" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be performed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is Color)
			{
				if (destinationType == typeof(string))
				{
					Color color = (Color)value;
					if (color == Color.Empty)
					{
						return string.Empty;
					}
					if (color.IsKnownColor)
					{
						return color.Name;
					}
					if (color.IsNamedColor)
					{
						return "'" + color.Name + "'";
					}
					if (culture == null)
					{
						culture = CultureInfo.CurrentCulture;
					}
					string separator = culture.TextInfo.ListSeparator + " ";
					TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
					int num = 0;
					string[] array;
					if (color.A < byte.MaxValue)
					{
						array = new string[4];
						array[num++] = converter.ConvertToString(context, culture, color.A);
					}
					else
					{
						array = new string[3];
					}
					array[num++] = converter.ConvertToString(context, culture, color.R);
					array[num++] = converter.ConvertToString(context, culture, color.G);
					array[num++] = converter.ConvertToString(context, culture, color.B);
					return string.Join(separator, array);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					MemberInfo memberInfo = null;
					object[] arguments = null;
					Color color2 = (Color)value;
					if (color2.IsEmpty)
					{
						memberInfo = typeof(Color).GetField("Empty");
					}
					else if (color2.IsSystemColor)
					{
						memberInfo = typeof(SystemColors).GetProperty(color2.Name);
					}
					else if (color2.IsKnownColor)
					{
						memberInfo = typeof(Color).GetProperty(color2.Name);
					}
					else if (color2.A != byte.MaxValue)
					{
						memberInfo = typeof(Color).GetMethod("FromArgb", new Type[4]
						{
							typeof(int),
							typeof(int),
							typeof(int),
							typeof(int)
						});
						arguments = new object[4] { color2.A, color2.R, color2.G, color2.B };
					}
					else if (color2.IsNamedColor)
					{
						memberInfo = typeof(Color).GetMethod("FromName", new Type[1] { typeof(string) });
						arguments = new object[1] { color2.Name };
					}
					else
					{
						memberInfo = typeof(Color).GetMethod("FromArgb", new Type[3]
						{
							typeof(int),
							typeof(int),
							typeof(int)
						});
						arguments = new object[3] { color2.R, color2.G, color2.B };
					}
					if (memberInfo != null)
					{
						return new InstanceDescriptor(memberInfo, arguments);
					}
					return null;
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		private static void FillConstants(Hashtable hash, Type enumType)
		{
			MethodAttributes methodAttributes = MethodAttributes.Public | MethodAttributes.Static;
			PropertyInfo[] properties = enumType.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (propertyInfo.PropertyType == typeof(Color))
				{
					MethodInfo getMethod = propertyInfo.GetGetMethod();
					if (getMethod != null && (getMethod.Attributes & methodAttributes) == methodAttributes)
					{
						object[] index = null;
						hash[propertyInfo.Name] = propertyInfo.GetValue(null, index);
					}
				}
			}
		}

		/// <summary>Retrieves a collection containing a set of standard values for the data type for which this validator is designed. This will return <see langword="null" /> if the data type does not support a standard set of values.</summary>
		/// <param name="context">A formatter context. Use this object to extract additional information about the environment from which this converter is being invoked. Always check whether this value is <see langword="null" />. Also, properties on the context object may return <see langword="null" />.</param>
		/// <returns>A collection containing <see langword="null" /> or a standard set of valid values. The default implementation always returns <see langword="null" />.</returns>
		public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
		{
			if (values == null)
			{
				lock (ValuesLock)
				{
					if (values == null)
					{
						ArrayList arrayList = new ArrayList();
						arrayList.AddRange(Colors.Values);
						arrayList.AddRange(SystemColors.Values);
						int num = arrayList.Count;
						for (int i = 0; i < num - 1; i++)
						{
							for (int j = i + 1; j < num; j++)
							{
								if (arrayList[i].Equals(arrayList[j]))
								{
									arrayList.RemoveAt(j);
									num--;
									j--;
								}
							}
						}
						arrayList.Sort(0, arrayList.Count, new ColorComparer());
						values = new StandardValuesCollection(arrayList.ToArray());
					}
				}
			}
			return values;
		}

		/// <summary>Determines if this object supports a standard set of values that can be chosen from a list.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <returns>
		///   <see langword="true" /> if <see cref="Overload:System.Drawing.ColorConverter.GetStandardValues" /> must be called to find a common set of values the object supports; otherwise, <see langword="false" />.</returns>
		public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	/// <summary>Specifies alignment of content on the drawing surface.</summary>
	[Editor("System.Drawing.Design.ContentAlignmentEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public enum ContentAlignment
	{
		/// <summary>Content is vertically aligned at the top, and horizontally aligned on the left.</summary>
		TopLeft = 1,
		/// <summary>Content is vertically aligned at the top, and horizontally aligned at the center.</summary>
		TopCenter = 2,
		/// <summary>Content is vertically aligned at the top, and horizontally aligned on the right.</summary>
		TopRight = 4,
		/// <summary>Content is vertically aligned in the middle, and horizontally aligned on the left.</summary>
		MiddleLeft = 0x10,
		/// <summary>Content is vertically aligned in the middle, and horizontally aligned at the center.</summary>
		MiddleCenter = 0x20,
		/// <summary>Content is vertically aligned in the middle, and horizontally aligned on the right.</summary>
		MiddleRight = 0x40,
		/// <summary>Content is vertically aligned at the bottom, and horizontally aligned on the left.</summary>
		BottomLeft = 0x100,
		/// <summary>Content is vertically aligned at the bottom, and horizontally aligned at the center.</summary>
		BottomCenter = 0x200,
		/// <summary>Content is vertically aligned at the bottom, and horizontally aligned on the right.</summary>
		BottomRight = 0x400
	}
	/// <summary>Determines how the source color in a copy pixel operation is combined with the destination color to result in a final color.</summary>
	[ComVisible(true)]
	public enum CopyPixelOperation
	{
		/// <summary>The destination area is filled by using the color associated with index 0 in the physical palette. (This color is black for the default physical palette.)</summary>
		Blackness = 66,
		/// <summary>Windows that are layered on top of your window are included in the resulting image. By default, the image contains only your window. Note that this generally cannot be used for printing device contexts.</summary>
		CaptureBlt = 1073741824,
		/// <summary>The destination area is inverted.</summary>
		DestinationInvert = 5570569,
		/// <summary>The colors of the source area are merged with the colors of the selected brush of the destination device context using the Boolean <see langword="AND" /> operator.</summary>
		MergeCopy = 12583114,
		/// <summary>The colors of the inverted source area are merged with the colors of the destination area by using the Boolean <see langword="OR" /> operator.</summary>
		MergePaint = 12255782,
		/// <summary>The bitmap is not mirrored.</summary>
		NoMirrorBitmap = int.MinValue,
		/// <summary>The inverted source area is copied to the destination.</summary>
		NotSourceCopy = 3342344,
		/// <summary>The source and destination colors are combined using the Boolean <see langword="OR" /> operator, and then resultant color is then inverted.</summary>
		NotSourceErase = 1114278,
		/// <summary>The brush currently selected in the destination device context is copied to the destination bitmap.</summary>
		PatCopy = 15728673,
		/// <summary>The colors of the brush currently selected in the destination device context are combined with the colors of the destination are using the Boolean <see langword="XOR" /> operator.</summary>
		PatInvert = 5898313,
		/// <summary>The colors of the brush currently selected in the destination device context are combined with the colors of the inverted source area using the Boolean <see langword="OR" /> operator. The result of this operation is combined with the colors of the destination area using the Boolean <see langword="OR" /> operator.</summary>
		PatPaint = 16452105,
		/// <summary>The colors of the source and destination areas are combined using the Boolean <see langword="AND" /> operator.</summary>
		SourceAnd = 8913094,
		/// <summary>The source area is copied directly to the destination area.</summary>
		SourceCopy = 13369376,
		/// <summary>The inverted colors of the destination area are combined with the colors of the source area using the Boolean <see langword="AND" /> operator.</summary>
		SourceErase = 4457256,
		/// <summary>The colors of the source and destination areas are combined using the Boolean <see langword="XOR" /> operator.</summary>
		SourceInvert = 6684742,
		/// <summary>The colors of the source and destination areas are combined using the Boolean <see langword="OR" /> operator.</summary>
		SourcePaint = 15597702,
		/// <summary>The destination area is filled by using the color associated with index 1 in the physical palette. (This color is white for the default physical palette.)</summary>
		Whiteness = 16711778
	}
	/// <summary>Converts <see cref="T:System.Drawing.Font" /> objects from one data type to another.</summary>
	public class FontConverter : TypeConverter
	{
		internal class UnitName
		{
			internal string name;

			internal GraphicsUnit unit;

			internal static readonly UnitName[] names = new UnitName[7]
			{
				new UnitName("world", GraphicsUnit.World),
				new UnitName("display", GraphicsUnit.Display),
				new UnitName("px", GraphicsUnit.Pixel),
				new UnitName("pt", GraphicsUnit.Point),
				new UnitName("in", GraphicsUnit.Inch),
				new UnitName("doc", GraphicsUnit.Document),
				new UnitName("mm", GraphicsUnit.Millimeter)
			};

			internal UnitName(string name, GraphicsUnit unit)
			{
				this.name = name;
				this.unit = unit;
			}
		}

		/// <summary>
		///   <see cref="T:System.Drawing.FontConverter.FontNameConverter" /> is a type converter that is used to convert a font name to and from various other representations.</summary>
		public sealed class FontNameConverter : TypeConverter, IDisposable
		{
			private StandardValuesCollection values;

			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.FontConverter.FontNameConverter" /> class.</summary>
			public FontNameConverter()
			{
				SystemEvents.InstalledFontsChanged += OnInstalledFontsChanged;
			}

			/// <summary>Determines if this converter can convert an object in the given source type to the native type of the converter.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to extract additional information about the environment this converter is being invoked from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may return <see langword="null" />.</param>
			/// <param name="sourceType">The type you wish to convert from.</param>
			/// <returns>
			///   <see langword="true" /> if the converter can perform the conversion; otherwise, <see langword="false" />.</returns>
			public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
			{
				if (sourceType == typeof(string))
				{
					return true;
				}
				return base.CanConvertFrom(context, sourceType);
			}

			/// <summary>Converts the given object to the converter's native type.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to extract additional information about the environment this converter is being invoked from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may return <see langword="null" />.</param>
			/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> to use to perform the conversion</param>
			/// <param name="value">The object to convert.</param>
			/// <returns>The converted object.</returns>
			/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
			public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
			{
				if (value is string)
				{
					return MatchFontName((string)value, context);
				}
				return base.ConvertFrom(context, culture, value);
			}

			/// <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
			void IDisposable.Dispose()
			{
				SystemEvents.InstalledFontsChanged -= OnInstalledFontsChanged;
			}

			/// <summary>Retrieves a collection containing a set of standard values for the data type this converter is designed for.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to extract additional information about the environment this converter is being invoked from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may return <see langword="null" />.</param>
			/// <returns>A collection containing a standard set of valid values, or <see langword="null" />. The default is <see langword="null" />.</returns>
			public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
			{
				if (values == null)
				{
					FontFamily[] families = FontFamily.Families;
					Hashtable hashtable = new Hashtable();
					for (int i = 0; i < families.Length; i++)
					{
						string name = families[i].Name;
						hashtable[name.ToLower(CultureInfo.InvariantCulture)] = name;
					}
					object[] array = new object[hashtable.Values.Count];
					hashtable.Values.CopyTo(array, 0);
					Array.Sort(array, Comparer.Default);
					values = new StandardValuesCollection(array);
				}
				return values;
			}

			/// <summary>Determines if the list of standard values returned from the <see cref="Overload:System.Drawing.FontConverter.FontNameConverter.GetStandardValues" /> method is an exclusive list.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to extract additional information about the environment this converter is being invoked from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may return <see langword="null" />.</param>
			/// <returns>
			///   <see langword="true" /> if the collection returned from <see cref="Overload:System.Drawing.FontConverter.FontNameConverter.GetStandardValues" /> is an exclusive list of possible values; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
			public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
			{
				return false;
			}

			/// <summary>Determines if this object supports a standard set of values that can be picked from a list.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to extract additional information about the environment this converter is being invoked from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may return <see langword="null" />.</param>
			/// <returns>
			///   <see langword="true" /> if <see cref="Overload:System.Drawing.FontConverter.FontNameConverter.GetStandardValues" /> should be called to find a common set of values the object supports; otherwise, <see langword="false" />.</returns>
			public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
			{
				return true;
			}

			private string MatchFontName(string name, ITypeDescriptorContext context)
			{
				string text = null;
				name = name.ToLower(CultureInfo.InvariantCulture);
				IEnumerator enumerator = GetStandardValues(context).GetEnumerator();
				while (enumerator.MoveNext())
				{
					string text2 = enumerator.Current.ToString().ToLower(CultureInfo.InvariantCulture);
					if (text2.Equals(name))
					{
						return enumerator.Current.ToString();
					}
					if (text2.StartsWith(name) && (text == null || text2.Length <= text.Length))
					{
						text = enumerator.Current.ToString();
					}
				}
				if (text == null)
				{
					text = name;
				}
				return text;
			}

			private void OnInstalledFontsChanged(object sender, EventArgs e)
			{
				values = null;
			}
		}

		/// <summary>Converts font units to and from other unit types.</summary>
		public class FontUnitConverter : EnumConverter
		{
			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.FontConverter.FontUnitConverter" /> class.</summary>
			public FontUnitConverter()
				: base(typeof(GraphicsUnit))
			{
			}

			/// <summary>Returns a collection of standard values valid for the <see cref="T:System.Drawing.Font" /> type.</summary>
			/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
			public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
			{
				if (base.Values == null)
				{
					base.GetStandardValues(context);
					ArrayList arrayList = new ArrayList(base.Values);
					arrayList.Remove(GraphicsUnit.Display);
					base.Values = new StandardValuesCollection(arrayList);
				}
				return base.Values;
			}
		}

		private FontNameConverter fontNameConverter;

		private const string styleHdr = "style=";

		/// <summary>Allows the <see cref="T:System.Drawing.FontConverter" /> to attempt to free resources and perform other cleanup operations before the <see cref="T:System.Drawing.FontConverter" /> is reclaimed by garbage collection.</summary>
		~FontConverter()
		{
			if (fontNameConverter != null)
			{
				((IDisposable)fontNameConverter).Dispose();
			}
		}

		/// <summary>Determines whether this converter can convert an object in the specified source type to the native type of the converter.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="sourceType">The type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this object can perform the conversion.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Gets a value indicating whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">An <see langword="ITypeDescriptorContext" /> object that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> object that represents the type you want to convert to.</param>
		/// <returns>This method returns <see langword="true" /> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the specified object to the native type of the converter.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">A <see langword="CultureInfo" /> object that specifies the culture used to represent the font.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion could not be performed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string value2 = text2;
				string text3 = null;
				string text4 = null;
				float emSize = 8.25f;
				FontStyle fontStyle = FontStyle.Regular;
				GraphicsUnit unit = GraphicsUnit.Point;
				int num = text2.IndexOf(c);
				if (num > 0)
				{
					value2 = text2.Substring(0, num);
					if (num < text2.Length - 1)
					{
						int num2 = text2.IndexOf("style=");
						if (num2 != -1)
						{
							text3 = text2.Substring(num2, text2.Length - num2);
							if (!text3.StartsWith("style="))
							{
								throw GetFormatException(text2, c);
							}
							text4 = text2.Substring(num + 1, num2 - num - 1);
						}
						else
						{
							text4 = text2.Substring(num + 1, text2.Length - num - 1);
						}
						string[] array = ParseSizeTokens(text4, c);
						if (array[0] != null)
						{
							try
							{
								emSize = (float)TypeDescriptor.GetConverter(typeof(float)).ConvertFromString(context, culture, array[0]);
							}
							catch
							{
								throw GetFormatException(text2, c);
							}
						}
						if (array[1] != null)
						{
							unit = ParseGraphicsUnits(array[1]);
						}
						if (text3 != null)
						{
							int num3 = text3.IndexOf("=");
							text3 = text3.Substring(num3 + 1, text3.Length - "style=".Length);
							string[] array2 = text3.Split(c);
							for (int i = 0; i < array2.Length; i++)
							{
								string text5 = array2[i];
								text5 = text5.Trim();
								try
								{
									fontStyle |= (FontStyle)Enum.Parse(typeof(FontStyle), text5, ignoreCase: true);
								}
								catch (Exception ex)
								{
									if (ex is InvalidEnumArgumentException)
									{
										throw;
									}
									throw GetFormatException(text2, c);
								}
								FontStyle fontStyle2 = FontStyle.Bold | FontStyle.Italic | FontStyle.Underline | FontStyle.Strikeout;
								if ((fontStyle | fontStyle2) != fontStyle2)
								{
									throw new InvalidEnumArgumentException("style", (int)fontStyle, typeof(FontStyle));
								}
							}
						}
					}
				}
				if (fontNameConverter == null)
				{
					fontNameConverter = new FontNameConverter();
				}
				value2 = (string)fontNameConverter.ConvertFrom(context, culture, value2);
				return new Font(value2, emSize, fontStyle, unit);
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts the specified object to another type.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> object that specifies the culture used to represent the object.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The data type to convert the object to.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion was not successful.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == typeof(string))
			{
				if (!(value is Font font))
				{
					return SR.GetString("toStringNone");
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				string separator = culture.TextInfo.ListSeparator + " ";
				int num = 2;
				if (font.Style != 0)
				{
					num++;
				}
				string[] array = new string[num];
				int num2 = 0;
				array[num2++] = font.Name;
				array[num2++] = TypeDescriptor.GetConverter(font.Size).ConvertToString(context, culture, font.Size) + GetGraphicsUnitText(font.Unit);
				if (font.Style != 0)
				{
					array[num2++] = "style=" + font.Style.ToString("G");
				}
				return string.Join(separator, array);
			}
			if (destinationType == typeof(InstanceDescriptor) && value is Font)
			{
				Font font2 = (Font)value;
				int num3 = 2;
				if (font2.GdiVerticalFont)
				{
					num3 = 6;
				}
				else if (font2.GdiCharSet != 1)
				{
					num3 = 5;
				}
				else if (font2.Unit != GraphicsUnit.Point)
				{
					num3 = 4;
				}
				else if (font2.Style != 0)
				{
					num3++;
				}
				object[] array2 = new object[num3];
				Type[] array3 = new Type[num3];
				array2[0] = font2.Name;
				array3[0] = typeof(string);
				array2[1] = font2.Size;
				array3[1] = typeof(float);
				if (num3 > 2)
				{
					array2[2] = font2.Style;
					array3[2] = typeof(FontStyle);
				}
				if (num3 > 3)
				{
					array2[3] = font2.Unit;
					array3[3] = typeof(GraphicsUnit);
				}
				if (num3 > 4)
				{
					array2[4] = font2.GdiCharSet;
					array3[4] = typeof(byte);
				}
				if (num3 > 5)
				{
					array2[5] = font2.GdiVerticalFont;
					array3[5] = typeof(bool);
				}
				MemberInfo constructor = typeof(Font).GetConstructor(array3);
				if (constructor != null)
				{
					return new InstanceDescriptor(constructor, array2);
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Creates an object of this type by using a specified set of property values for the object.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <param name="propertyValues">A dictionary of new property values. The dictionary contains a series of name-value pairs, one for each property returned from the <see cref="Overload:System.Drawing.FontConverter.GetProperties" /> method.</param>
		/// <returns>The newly created object, or <see langword="null" /> if the object could not be created. The default implementation returns <see langword="null" />.  
		///  <see cref="M:System.Drawing.FontConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> useful for creating non-changeable objects that have changeable properties.</returns>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			if (propertyValues == null)
			{
				throw new ArgumentNullException("propertyValues");
			}
			object obj = propertyValues["Name"];
			object obj2 = propertyValues["Size"];
			object obj3 = propertyValues["Unit"];
			object obj4 = propertyValues["Bold"];
			object obj5 = propertyValues["Italic"];
			object obj6 = propertyValues["Strikeout"];
			object obj7 = propertyValues["Underline"];
			object obj8 = propertyValues["GdiCharSet"];
			object obj9 = propertyValues["GdiVerticalFont"];
			if (obj == null)
			{
				obj = "Tahoma";
			}
			if (obj2 == null)
			{
				obj2 = 8f;
			}
			if (obj3 == null)
			{
				obj3 = GraphicsUnit.Point;
			}
			if (obj4 == null)
			{
				obj4 = false;
			}
			if (obj5 == null)
			{
				obj5 = false;
			}
			if (obj6 == null)
			{
				obj6 = false;
			}
			if (obj7 == null)
			{
				obj7 = false;
			}
			if (obj8 == null)
			{
				obj8 = (byte)0;
			}
			if (obj9 == null)
			{
				obj9 = false;
			}
			if (!(obj is string) || !(obj2 is float) || !(obj8 is byte) || !(obj3 is GraphicsUnit) || !(obj4 is bool) || !(obj5 is bool) || !(obj6 is bool) || !(obj7 is bool) || !(obj9 is bool))
			{
				throw new ArgumentException(SR.GetString("PropertyValueInvalidEntry"));
			}
			FontStyle fontStyle = FontStyle.Regular;
			if (obj4 != null && (bool)obj4)
			{
				fontStyle |= FontStyle.Bold;
			}
			if (obj5 != null && (bool)obj5)
			{
				fontStyle |= FontStyle.Italic;
			}
			if (obj6 != null && (bool)obj6)
			{
				fontStyle |= FontStyle.Strikeout;
			}
			if (obj7 != null && (bool)obj7)
			{
				fontStyle |= FontStyle.Underline;
			}
			return new Font((string)obj, (float)obj2, fontStyle, (GraphicsUnit)obj3, (byte)obj8, (bool)obj9);
		}

		/// <summary>Determines whether changing a value on this object should require a call to the <see cref="Overload:System.Drawing.FontConverter.CreateInstance" /> method to create a new value.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if the <see langword="CreateInstance" /> object should be called when a change is made to one or more properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		private ArgumentException GetFormatException(string text, char separator)
		{
			string text2 = string.Format(CultureInfo.CurrentCulture, "name{0} size[units[{0} style=style1[{0} style2{0} ...]]]", new object[1] { separator });
			return new ArgumentException(SR.GetString("TextParseFailedFormat", text, text2));
		}

		private string GetGraphicsUnitText(GraphicsUnit units)
		{
			string result = "";
			for (int i = 0; i < UnitName.names.Length; i++)
			{
				if (UnitName.names[i].unit == units)
				{
					result = UnitName.names[i].name;
					break;
				}
			}
			return result;
		}

		/// <summary>Retrieves the set of properties for this type. By default, a type does not have any properties to return.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <param name="value">The value of the object to get the properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>The set of properties that should be exposed for this data type. If no properties should be exposed, this may return <see langword="null" />. The default implementation always returns <see langword="null" />.  
		///  An easy implementation of this method can call the <see cref="Overload:System.ComponentModel.TypeConverter.GetProperties" /> method for the correct data type.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(Font), attributes);
			return properties.Sort(new string[4] { "Name", "Size", "Unit", "Weight" });
		}

		/// <summary>Determines whether this object supports properties. The default is <see langword="false" />.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if the <see cref="M:System.Drawing.FontConverter.GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext)" /> method should be called to find the properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		private string[] ParseSizeTokens(string text, char separator)
		{
			string text2 = null;
			string text3 = null;
			text = text.Trim();
			int length = text.Length;
			if (length > 0)
			{
				int i;
				for (i = 0; i < length && !char.IsLetter(text[i]); i++)
				{
				}
				char[] trimChars = new char[2] { separator, ' ' };
				if (i > 0)
				{
					text2 = text.Substring(0, i);
					text2 = text2.Trim(trimChars);
				}
				if (i < length)
				{
					text3 = text.Substring(i);
					text3 = text3.TrimEnd(trimChars);
				}
			}
			return new string[2] { text2, text3 };
		}

		private GraphicsUnit ParseGraphicsUnits(string units)
		{
			UnitName unitName = null;
			for (int i = 0; i < UnitName.names.Length; i++)
			{
				if (string.Equals(UnitName.names[i].name, units, StringComparison.OrdinalIgnoreCase))
				{
					unitName = UnitName.names[i];
					break;
				}
			}
			if (unitName == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "units", units));
			}
			return unitName.unit;
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.FontConverter" /> object.</summary>
		public FontConverter()
		{
		}
	}
	internal class GraphicsContext : IDisposable
	{
		private int contextState;

		private PointF transformOffset;

		private Region clipRegion;

		private GraphicsContext nextContext;

		private GraphicsContext prevContext;

		private bool isCumulative;

		public int State
		{
			get
			{
				return contextState;
			}
			set
			{
				contextState = value;
			}
		}

		public PointF TransformOffset => transformOffset;

		public Region Clip => clipRegion;

		public GraphicsContext Next
		{
			get
			{
				return nextContext;
			}
			set
			{
				nextContext = value;
			}
		}

		public GraphicsContext Previous
		{
			get
			{
				return prevContext;
			}
			set
			{
				prevContext = value;
			}
		}

		public bool IsCumulative
		{
			get
			{
				return isCumulative;
			}
			set
			{
				isCumulative = value;
			}
		}

		private GraphicsContext()
		{
		}

		public GraphicsContext(Graphics g)
		{
			Matrix transform = g.Transform;
			if (!transform.IsIdentity)
			{
				float[] elements = transform.Elements;
				transformOffset.X = elements[4];
				transformOffset.Y = elements[5];
			}
			transform.Dispose();
			Region clip = g.Clip;
			if (clip.IsInfinite(g))
			{
				clip.Dispose();
			}
			else
			{
				clipRegion = clip;
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		public void Dispose(bool disposing)
		{
			if (nextContext != null)
			{
				nextContext.Dispose();
				nextContext = null;
			}
			if (clipRegion != null)
			{
				clipRegion.Dispose();
				clipRegion = null;
			}
		}
	}
	/// <summary>Encapsulates a GDI+ drawing surface. This class cannot be inherited.</summary>
	public sealed class Graphics : MarshalByRefObject, IDisposable, IDeviceContext
	{
		/// <summary>Provides a callback method for deciding when the <see cref="Overload:System.Drawing.Graphics.DrawImage" /> method should prematurely cancel execution and stop drawing an image.</summary>
		/// <param name="callbackdata">Internal pointer that specifies data for the callback method. This parameter is not passed by all <see cref="Overload:System.Drawing.Graphics.DrawImage" /> overloads. You can test for its absence by checking for the value <see cref="F:System.IntPtr.Zero" />.</param>
		/// <returns>This method returns <see langword="true" /> if it decides that the <see cref="Overload:System.Drawing.Graphics.DrawImage" /> method should prematurely stop execution. Otherwise it returns <see langword="false" /> to indicate that the <see cref="Overload:System.Drawing.Graphics.DrawImage" /> method should continue execution.</returns>
		public delegate bool DrawImageAbort(IntPtr callbackdata);

		/// <summary>Provides a callback method for the <see cref="Overload:System.Drawing.Graphics.EnumerateMetafile" /> method.</summary>
		/// <param name="recordType">Member of the <see cref="T:System.Drawing.Imaging.EmfPlusRecordType" /> enumeration that specifies the type of metafile record.</param>
		/// <param name="flags">Set of flags that specify attributes of the record.</param>
		/// <param name="dataSize">Number of bytes in the record data.</param>
		/// <param name="data">Pointer to a buffer that contains the record data.</param>
		/// <param name="callbackData">Not used.</param>
		/// <returns>Return <see langword="true" /> if you want to continue enumerating records; otherwise, <see langword="false" />.</returns>
		public delegate bool EnumerateMetafileProc(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr data, PlayRecordCallback callbackData);

		private GraphicsContext previousContext;

		private static readonly object syncObject = new object();

		private IntPtr nativeGraphics;

		private IntPtr nativeHdc;

		private object printingHelper;

		private static IntPtr halftonePalette;

		private Image backingImage;

		internal IntPtr NativeGraphics => nativeGraphics;

		/// <summary>Gets a value that specifies how composited images are drawn to this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>This property specifies a member of the <see cref="T:System.Drawing.Drawing2D.CompositingMode" /> enumeration. The default is <see cref="F:System.Drawing.Drawing2D.CompositingMode.SourceOver" />.</returns>
		public CompositingMode CompositingMode
		{
			get
			{
				int compositeMode = 0;
				int num = SafeNativeMethods.Gdip.GdipGetCompositingMode(new HandleRef(this, NativeGraphics), out compositeMode);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (CompositingMode)compositeMode;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 1))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(CompositingMode));
				}
				int num = SafeNativeMethods.Gdip.GdipSetCompositingMode(new HandleRef(this, NativeGraphics), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the rendering origin of this <see cref="T:System.Drawing.Graphics" /> for dithering and for hatch brushes.</summary>
		/// <returns>A <see cref="T:System.Drawing.Point" /> structure that represents the dither origin for 8-bits-per-pixel and 16-bits-per-pixel dithering and is also used to set the origin for hatch brushes.</returns>
		public Point RenderingOrigin
		{
			get
			{
				int x;
				int y;
				int num = SafeNativeMethods.Gdip.GdipGetRenderingOrigin(new HandleRef(this, NativeGraphics), out x, out y);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return new Point(x, y);
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetRenderingOrigin(new HandleRef(this, NativeGraphics), value.X, value.Y);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the rendering quality of composited images drawn to this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>This property specifies a member of the <see cref="T:System.Drawing.Drawing2D.CompositingQuality" /> enumeration. The default is <see cref="F:System.Drawing.Drawing2D.CompositingQuality.Default" />.</returns>
		public CompositingQuality CompositingQuality
		{
			get
			{
				CompositingQuality quality;
				int num = SafeNativeMethods.Gdip.GdipGetCompositingQuality(new HandleRef(this, NativeGraphics), out quality);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return quality;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -1, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(CompositingQuality));
				}
				int num = SafeNativeMethods.Gdip.GdipSetCompositingQuality(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the rendering mode for text associated with this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Text.TextRenderingHint" /> values.</returns>
		public TextRenderingHint TextRenderingHint
		{
			get
			{
				TextRenderingHint textRenderingHint = TextRenderingHint.SystemDefault;
				int num = SafeNativeMethods.Gdip.GdipGetTextRenderingHint(new HandleRef(this, NativeGraphics), out textRenderingHint);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return textRenderingHint;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 5))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(TextRenderingHint));
				}
				int num = SafeNativeMethods.Gdip.GdipSetTextRenderingHint(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the gamma correction value for rendering text.</summary>
		/// <returns>The gamma correction value used for rendering antialiased and ClearType text.</returns>
		public int TextContrast
		{
			get
			{
				int textContrast = 0;
				int num = SafeNativeMethods.Gdip.GdipGetTextContrast(new HandleRef(this, NativeGraphics), out textContrast);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return textContrast;
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetTextContrast(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the rendering quality for this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.SmoothingMode" /> values.</returns>
		public SmoothingMode SmoothingMode
		{
			get
			{
				SmoothingMode smoothingMode = SmoothingMode.Default;
				int num = SafeNativeMethods.Gdip.GdipGetSmoothingMode(new HandleRef(this, NativeGraphics), out smoothingMode);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return smoothingMode;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -1, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(SmoothingMode));
				}
				int num = SafeNativeMethods.Gdip.GdipSetSmoothingMode(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets a value specifying how pixels are offset during rendering of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>This property specifies a member of the <see cref="T:System.Drawing.Drawing2D.PixelOffsetMode" /> enumeration</returns>
		public PixelOffsetMode PixelOffsetMode
		{
			get
			{
				PixelOffsetMode pixelOffsetMode = PixelOffsetMode.Default;
				int num = SafeNativeMethods.Gdip.GdipGetPixelOffsetMode(new HandleRef(this, NativeGraphics), out pixelOffsetMode);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return pixelOffsetMode;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -1, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PixelOffsetMode));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPixelOffsetMode(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		internal object PrintingHelper
		{
			get
			{
				return printingHelper;
			}
			set
			{
				printingHelper = value;
			}
		}

		/// <summary>Gets or sets the interpolation mode associated with this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.InterpolationMode" /> values.</returns>
		public InterpolationMode InterpolationMode
		{
			get
			{
				int mode = 0;
				int num = SafeNativeMethods.Gdip.GdipGetInterpolationMode(new HandleRef(this, NativeGraphics), out mode);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (InterpolationMode)mode;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -1, 7))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(InterpolationMode));
				}
				int num = SafeNativeMethods.Gdip.GdipSetInterpolationMode(new HandleRef(this, NativeGraphics), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets a copy of the geometric world transformation for this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>A copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents the geometric world transformation for this <see cref="T:System.Drawing.Graphics" />.</returns>
		public Matrix Transform
		{
			get
			{
				Matrix matrix = new Matrix();
				int num = SafeNativeMethods.Gdip.GdipGetWorldTransform(new HandleRef(this, NativeGraphics), new HandleRef(matrix, matrix.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return matrix;
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetWorldTransform(new HandleRef(this, NativeGraphics), new HandleRef(value, value.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the unit of measure used for page coordinates in this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.GraphicsUnit" /> values other than <see cref="F:System.Drawing.GraphicsUnit.World" />.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
		///   <see cref="P:System.Drawing.Graphics.PageUnit" /> is set to <see cref="F:System.Drawing.GraphicsUnit.World" />, which is not a physical unit.</exception>
		public GraphicsUnit PageUnit
		{
			get
			{
				int unit = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPageUnit(new HandleRef(this, NativeGraphics), out unit);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (GraphicsUnit)unit;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 6))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(GraphicsUnit));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPageUnit(new HandleRef(this, NativeGraphics), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the scaling between world units and page units for this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>This property specifies a value for the scaling between world units and page units for this <see cref="T:System.Drawing.Graphics" />.</returns>
		public float PageScale
		{
			get
			{
				float[] array = new float[1];
				int num = SafeNativeMethods.Gdip.GdipGetPageScale(new HandleRef(this, NativeGraphics), array);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array[0];
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetPageScale(new HandleRef(this, NativeGraphics), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets the horizontal resolution of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>The value, in dots per inch, for the horizontal resolution supported by this <see cref="T:System.Drawing.Graphics" />.</returns>
		public float DpiX
		{
			get
			{
				float[] array = new float[1];
				int num = SafeNativeMethods.Gdip.GdipGetDpiX(new HandleRef(this, NativeGraphics), array);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array[0];
			}
		}

		/// <summary>Gets the vertical resolution of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>The value, in dots per inch, for the vertical resolution supported by this <see cref="T:System.Drawing.Graphics" />.</returns>
		public float DpiY
		{
			get
			{
				float[] array = new float[1];
				int num = SafeNativeMethods.Gdip.GdipGetDpiY(new HandleRef(this, NativeGraphics), array);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array[0];
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Region" /> that limits the drawing region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Region" /> that limits the portion of this <see cref="T:System.Drawing.Graphics" /> that is currently available for drawing.</returns>
		public Region Clip
		{
			get
			{
				Region region = new Region();
				int num = SafeNativeMethods.Gdip.GdipGetClip(new HandleRef(this, NativeGraphics), new HandleRef(region, region.nativeRegion));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return region;
			}
			set
			{
				SetClip(value, CombineMode.Replace);
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.RectangleF" /> structure that bounds the clipping region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> structure that represents a bounding rectangle for the clipping region of this <see cref="T:System.Drawing.Graphics" />.</returns>
		public RectangleF ClipBounds
		{
			get
			{
				GPRECTF rect = default(GPRECTF);
				int num = SafeNativeMethods.Gdip.GdipGetClipBounds(new HandleRef(this, NativeGraphics), ref rect);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return rect.ToRectangleF();
			}
		}

		/// <summary>Gets a value indicating whether the clipping region of this <see cref="T:System.Drawing.Graphics" /> is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if the clipping region of this <see cref="T:System.Drawing.Graphics" /> is empty; otherwise, <see langword="false" />.</returns>
		public bool IsClipEmpty
		{
			get
			{
				int boolean;
				int num = SafeNativeMethods.Gdip.GdipIsClipEmpty(new HandleRef(this, NativeGraphics), out boolean);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return boolean != 0;
			}
		}

		/// <summary>Gets the bounding rectangle of the visible clipping region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> structure that represents a bounding rectangle for the visible clipping region of this <see cref="T:System.Drawing.Graphics" />.</returns>
		public RectangleF VisibleClipBounds
		{
			get
			{
				if (PrintingHelper != null && PrintingHelper is PrintPreviewGraphics printPreviewGraphics)
				{
					return printPreviewGraphics.VisibleClipBounds;
				}
				GPRECTF rect = default(GPRECTF);
				int num = SafeNativeMethods.Gdip.GdipGetVisibleClipBounds(new HandleRef(this, NativeGraphics), ref rect);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return rect.ToRectangleF();
			}
		}

		/// <summary>Gets a value indicating whether the visible clipping region of this <see cref="T:System.Drawing.Graphics" /> is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if the visible portion of the clipping region of this <see cref="T:System.Drawing.Graphics" /> is empty; otherwise, <see langword="false" />.</returns>
		public bool IsVisibleClipEmpty
		{
			get
			{
				int boolean;
				int num = SafeNativeMethods.Gdip.GdipIsVisibleClipEmpty(new HandleRef(this, NativeGraphics), out boolean);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return boolean != 0;
			}
		}

		private Graphics(IntPtr gdipNativeGraphics)
		{
			if (gdipNativeGraphics == IntPtr.Zero)
			{
				throw new ArgumentNullException("gdipNativeGraphics");
			}
			nativeGraphics = gdipNativeGraphics;
		}

		/// <summary>Creates a new <see cref="T:System.Drawing.Graphics" /> from the specified handle to a device context.</summary>
		/// <param name="hdc">Handle to a device context.</param>
		/// <returns>This method returns a new <see cref="T:System.Drawing.Graphics" /> for the specified device context.</returns>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static Graphics FromHdc(IntPtr hdc)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			if (hdc == IntPtr.Zero)
			{
				throw new ArgumentNullException("hdc");
			}
			return FromHdcInternal(hdc);
		}

		/// <summary>Returns a <see cref="T:System.Drawing.Graphics" /> for the specified device context.</summary>
		/// <param name="hdc">Handle to a device context.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> for the specified device context.</returns>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public static Graphics FromHdcInternal(IntPtr hdc)
		{
			IntPtr graphics = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateFromHDC(new HandleRef(null, hdc), out graphics);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Graphics(graphics);
		}

		/// <summary>Creates a new <see cref="T:System.Drawing.Graphics" /> from the specified handle to a device context and handle to a device.</summary>
		/// <param name="hdc">Handle to a device context.</param>
		/// <param name="hdevice">Handle to a device.</param>
		/// <returns>This method returns a new <see cref="T:System.Drawing.Graphics" /> for the specified device context and device.</returns>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static Graphics FromHdc(IntPtr hdc, IntPtr hdevice)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr graphics = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateFromHDC2(new HandleRef(null, hdc), new HandleRef(null, hdevice), out graphics);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Graphics(graphics);
		}

		/// <summary>Creates a new <see cref="T:System.Drawing.Graphics" /> from the specified handle to a window.</summary>
		/// <param name="hwnd">Handle to a window.</param>
		/// <returns>This method returns a new <see cref="T:System.Drawing.Graphics" /> for the specified window handle.</returns>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static Graphics FromHwnd(IntPtr hwnd)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			return FromHwndInternal(hwnd);
		}

		/// <summary>Creates a new <see cref="T:System.Drawing.Graphics" /> for the specified windows handle.</summary>
		/// <param name="hwnd">Handle to a window.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> for the specified window handle.</returns>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public static Graphics FromHwndInternal(IntPtr hwnd)
		{
			IntPtr graphics = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateFromHWND(new HandleRef(null, hwnd), out graphics);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Graphics(graphics);
		}

		/// <summary>Creates a new <see cref="T:System.Drawing.Graphics" /> from the specified <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> from which to create the new <see cref="T:System.Drawing.Graphics" />.</param>
		/// <returns>This method returns a new <see cref="T:System.Drawing.Graphics" /> for the specified <see cref="T:System.Drawing.Image" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Exception">
		///   <paramref name="image" /> has an indexed pixel format or its format is undefined.</exception>
		public static Graphics FromImage(Image image)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if ((image.PixelFormat & PixelFormat.Indexed) != 0)
			{
				throw new Exception(SR.GetString("GdiplusCannotCreateGraphicsFromIndexedPixelFormat"));
			}
			IntPtr graphics = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetImageGraphicsContext(new HandleRef(image, image.nativeImage), out graphics);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			Graphics graphics2 = new Graphics(graphics);
			graphics2.backingImage = image;
			return graphics2;
		}

		/// <summary>Gets the handle to the device context associated with this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <returns>Handle to the device context associated with this <see cref="T:System.Drawing.Graphics" />.</returns>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public IntPtr GetHdc()
		{
			IntPtr hdc = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetDC(new HandleRef(this, NativeGraphics), out hdc);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeHdc = hdc;
			return nativeHdc;
		}

		/// <summary>Releases a device context handle obtained by a previous call to the <see cref="M:System.Drawing.Graphics.GetHdc" /> method of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="hdc">Handle to a device context obtained by a previous call to the <see cref="M:System.Drawing.Graphics.GetHdc" /> method of this <see cref="T:System.Drawing.Graphics" />.</param>
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public void ReleaseHdc(IntPtr hdc)
		{
			IntSecurity.Win32HandleManipulation.Demand();
			ReleaseHdcInternal(hdc);
		}

		/// <summary>Releases a device context handle obtained by a previous call to the <see cref="M:System.Drawing.Graphics.GetHdc" /> method of this <see cref="T:System.Drawing.Graphics" />.</summary>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public void ReleaseHdc()
		{
			ReleaseHdcInternal(nativeHdc);
		}

		/// <summary>Releases a handle to a device context.</summary>
		/// <param name="hdc">Handle to a device context.</param>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public void ReleaseHdcInternal(IntPtr hdc)
		{
			int num = SafeNativeMethods.Gdip.GdipReleaseDC(new HandleRef(this, NativeGraphics), new HandleRef(null, hdc));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeHdc = IntPtr.Zero;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Graphics" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			while (previousContext != null)
			{
				GraphicsContext previous = previousContext.Previous;
				previousContext.Dispose();
				previousContext = previous;
			}
			if (!(nativeGraphics != IntPtr.Zero))
			{
				return;
			}
			try
			{
				if (nativeHdc != IntPtr.Zero)
				{
					ReleaseHdc();
				}
				if (PrintingHelper != null && PrintingHelper is DeviceContext deviceContext)
				{
					deviceContext.Dispose();
					printingHelper = null;
				}
				SafeNativeMethods.Gdip.GdipDeleteGraphics(new HandleRef(this, nativeGraphics));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeGraphics = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Graphics()
		{
			Dispose(disposing: false);
		}

		/// <summary>Forces execution of all pending graphics operations and returns immediately without waiting for the operations to finish.</summary>
		public void Flush()
		{
			Flush(FlushIntention.Flush);
		}

		/// <summary>Forces execution of all pending graphics operations with the method waiting or not waiting, as specified, to return before the operations finish.</summary>
		/// <param name="intention">Member of the <see cref="T:System.Drawing.Drawing2D.FlushIntention" /> enumeration that specifies whether the method returns immediately or waits for any existing operations to finish.</param>
		public void Flush(FlushIntention intention)
		{
			int num = SafeNativeMethods.Gdip.GdipFlush(new HandleRef(this, NativeGraphics), intention);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Performs a bit-block transfer of color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="upperLeftSource">The point at the upper-left corner of the source rectangle.</param>
		/// <param name="upperLeftDestination">The point at the upper-left corner of the destination rectangle.</param>
		/// <param name="blockRegionSize">The size of the area to be transferred.</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The operation failed.</exception>
		public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize)
		{
			CopyFromScreen(upperLeftSource.X, upperLeftSource.Y, upperLeftDestination.X, upperLeftDestination.Y, blockRegionSize);
		}

		/// <summary>Performs a bit-block transfer of the color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="sourceX">The x-coordinate of the point at the upper-left corner of the source rectangle.</param>
		/// <param name="sourceY">The y-coordinate of the point at the upper-left corner of the source rectangle.</param>
		/// <param name="destinationX">The x-coordinate of the point at the upper-left corner of the destination rectangle.</param>
		/// <param name="destinationY">The y-coordinate of the point at the upper-left corner of the destination rectangle.</param>
		/// <param name="blockRegionSize">The size of the area to be transferred.</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The operation failed.</exception>
		public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize)
		{
			CopyFromScreen(sourceX, sourceY, destinationX, destinationY, blockRegionSize, CopyPixelOperation.SourceCopy);
		}

		/// <summary>Performs a bit-block transfer of color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="upperLeftSource">The point at the upper-left corner of the source rectangle.</param>
		/// <param name="upperLeftDestination">The point at the upper-left corner of the destination rectangle.</param>
		/// <param name="blockRegionSize">The size of the area to be transferred.</param>
		/// <param name="copyPixelOperation">One of the <see cref="T:System.Drawing.CopyPixelOperation" /> values.</param>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
		///   <paramref name="copyPixelOperation" /> is not a member of <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The operation failed.</exception>
		public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize, CopyPixelOperation copyPixelOperation)
		{
			CopyFromScreen(upperLeftSource.X, upperLeftSource.Y, upperLeftDestination.X, upperLeftDestination.Y, blockRegionSize, copyPixelOperation);
		}

		/// <summary>Performs a bit-block transfer of the color data, corresponding to a rectangle of pixels, from the screen to the drawing surface of the <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="sourceX">The x-coordinate of the point at the upper-left corner of the source rectangle.</param>
		/// <param name="sourceY">The y-coordinate of the point at the upper-left corner of the source rectangle</param>
		/// <param name="destinationX">The x-coordinate of the point at the upper-left corner of the destination rectangle.</param>
		/// <param name="destinationY">The y-coordinate of the point at the upper-left corner of the destination rectangle.</param>
		/// <param name="blockRegionSize">The size of the area to be transferred.</param>
		/// <param name="copyPixelOperation">One of the <see cref="T:System.Drawing.CopyPixelOperation" /> values.</param>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
		///   <paramref name="copyPixelOperation" /> is not a member of <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The operation failed.</exception>
		public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation)
		{
			switch (copyPixelOperation)
			{
			default:
				throw new InvalidEnumArgumentException("value", (int)copyPixelOperation, typeof(CopyPixelOperation));
			case CopyPixelOperation.NoMirrorBitmap:
			case CopyPixelOperation.Blackness:
			case CopyPixelOperation.NotSourceErase:
			case CopyPixelOperation.NotSourceCopy:
			case CopyPixelOperation.SourceErase:
			case CopyPixelOperation.DestinationInvert:
			case CopyPixelOperation.PatInvert:
			case CopyPixelOperation.SourceInvert:
			case CopyPixelOperation.SourceAnd:
			case CopyPixelOperation.MergePaint:
			case CopyPixelOperation.MergeCopy:
			case CopyPixelOperation.SourceCopy:
			case CopyPixelOperation.SourcePaint:
			case CopyPixelOperation.PatCopy:
			case CopyPixelOperation.PatPaint:
			case CopyPixelOperation.Whiteness:
			case CopyPixelOperation.CaptureBlt:
			{
				new UIPermission(UIPermissionWindow.AllWindows).Demand();
				int width = blockRegionSize.Width;
				int height = blockRegionSize.Height;
				using DeviceContext deviceContext = DeviceContext.FromHwnd(IntPtr.Zero);
				HandleRef hSrcDC = new HandleRef(null, deviceContext.Hdc);
				HandleRef hDC = new HandleRef(null, GetHdc());
				try
				{
					if (SafeNativeMethods.BitBlt(hDC, destinationX, destinationY, width, height, hSrcDC, sourceX, sourceY, (int)copyPixelOperation) == 0)
					{
						throw new Win32Exception();
					}
					break;
				}
				finally
				{
					ReleaseHdc();
				}
			}
			}
		}

		/// <summary>Resets the world transformation matrix of this <see cref="T:System.Drawing.Graphics" /> to the identity matrix.</summary>
		public void ResetTransform()
		{
			int num = SafeNativeMethods.Gdip.GdipResetWorldTransform(new HandleRef(this, NativeGraphics));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Multiplies the world transformation of this <see cref="T:System.Drawing.Graphics" /> and specified the <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" /> that multiplies the world transformation.</param>
		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Multiplies the world transformation of this <see cref="T:System.Drawing.Graphics" /> and specified the <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="matrix">4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" /> that multiplies the world transformation.</param>
		/// <param name="order">Member of the <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that determines the order of the multiplication.</param>
		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipMultiplyWorldTransform(new HandleRef(this, NativeGraphics), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Changes the origin of the coordinate system by prepending the specified translation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="dx">The x-coordinate of the translation.</param>
		/// <param name="dy">The y-coordinate of the translation.</param>
		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		/// <summary>Changes the origin of the coordinate system by applying the specified translation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" /> in the specified order.</summary>
		/// <param name="dx">The x-coordinate of the translation.</param>
		/// <param name="dy">The y-coordinate of the translation.</param>
		/// <param name="order">Member of the <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies whether the translation is prepended or appended to the transformation matrix.</param>
		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateWorldTransform(new HandleRef(this, NativeGraphics), dx, dy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Applies the specified scaling operation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" /> by prepending it to the object's transformation matrix.</summary>
		/// <param name="sx">Scale factor in the x direction.</param>
		/// <param name="sy">Scale factor in the y direction.</param>
		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified scaling operation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" /> in the specified order.</summary>
		/// <param name="sx">Scale factor in the x direction.</param>
		/// <param name="sy">Scale factor in the y direction.</param>
		/// <param name="order">Member of the <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies whether the scaling operation is prepended or appended to the transformation matrix.</param>
		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScaleWorldTransform(new HandleRef(this, NativeGraphics), sx, sy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Applies the specified rotation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="angle">Angle of rotation in degrees.</param>
		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified rotation to the transformation matrix of this <see cref="T:System.Drawing.Graphics" /> in the specified order.</summary>
		/// <param name="angle">Angle of rotation in degrees.</param>
		/// <param name="order">Member of the <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies whether the rotation is appended or prepended to the matrix transformation.</param>
		public void RotateTransform(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotateWorldTransform(new HandleRef(this, NativeGraphics), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Transforms an array of points from one coordinate space to another using the current world and page transformations of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="destSpace">Member of the <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> enumeration that specifies the destination coordinate space.</param>
		/// <param name="srcSpace">Member of the <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> enumeration that specifies the source coordinate space.</param>
		/// <param name="pts">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the points to transform.</param>
		public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, PointF[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			int num = SafeNativeMethods.Gdip.GdipTransformPoints(new HandleRef(this, NativeGraphics), (int)destSpace, (int)srcSpace, intPtr, pts.Length);
			try
			{
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				PointF[] array = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					pts[i] = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Transforms an array of points from one coordinate space to another using the current world and page transformations of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="destSpace">Member of the <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> enumeration that specifies the destination coordinate space.</param>
		/// <param name="srcSpace">Member of the <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> enumeration that specifies the source coordinate space.</param>
		/// <param name="pts">Array of <see cref="T:System.Drawing.Point" /> structures that represents the points to transformation.</param>
		public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, Point[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			int num = SafeNativeMethods.Gdip.GdipTransformPointsI(new HandleRef(this, NativeGraphics), (int)destSpace, (int)srcSpace, intPtr, pts.Length);
			try
			{
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Point[] array = SafeNativeMethods.Gdip.ConvertGPPOINTArray(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					pts[i] = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Gets the nearest color to the specified <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="color">
		///   <see cref="T:System.Drawing.Color" /> structure for which to find a match.</param>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the nearest color to the one specified with the <paramref name="color" /> parameter.</returns>
		public Color GetNearestColor(Color color)
		{
			int color2 = color.ToArgb();
			int num = SafeNativeMethods.Gdip.GdipGetNearestColor(new HandleRef(this, NativeGraphics), ref color2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return Color.FromArgb(color2);
		}

		/// <summary>Draws a line connecting the two points specified by the coordinate pairs.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line.</param>
		/// <param name="x1">The x-coordinate of the first point.</param>
		/// <param name="y1">The y-coordinate of the first point.</param>
		/// <param name="x2">The x-coordinate of the second point.</param>
		/// <param name="y2">The y-coordinate of the second point.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawLine(Pen pen, float x1, float y1, float x2, float y2)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawLine(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x1, y1, x2, y2);
			CheckErrorStatus(status);
		}

		/// <summary>Draws a line connecting two <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line.</param>
		/// <param name="pt1">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the first point to connect.</param>
		/// <param name="pt2">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the second point to connect.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawLine(Pen pen, PointF pt1, PointF pt2)
		{
			DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
		}

		/// <summary>Draws a series of line segments that connect an array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line segments.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the points to connect.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawLines(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawLines(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a line connecting the two points specified by the coordinate pairs.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line.</param>
		/// <param name="x1">The x-coordinate of the first point.</param>
		/// <param name="y1">The y-coordinate of the first point.</param>
		/// <param name="x2">The x-coordinate of the second point.</param>
		/// <param name="y2">The y-coordinate of the second point.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawLine(Pen pen, int x1, int y1, int x2, int y2)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawLineI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x1, y1, x2, y2);
			CheckErrorStatus(status);
		}

		/// <summary>Draws a line connecting two <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line.</param>
		/// <param name="pt1">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the first point to connect.</param>
		/// <param name="pt2">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the second point to connect.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawLine(Pen pen, Point pt1, Point pt2)
		{
			DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
		}

		/// <summary>Draws a series of line segments that connect an array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the line segments.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that represent the points to connect.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawLines(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawLinesI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws an arc representing a portion of an ellipse specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the arc.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the rectangle that defines the ellipse.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of the arc.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to ending point of the arc.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawArc(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawArc(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		/// <summary>Draws an arc representing a portion of an ellipse specified by a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the arc.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that defines the boundaries of the ellipse.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of the arc.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to ending point of the arc.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" /></exception>
		public void DrawArc(Pen pen, RectangleF rect, float startAngle, float sweepAngle)
		{
			DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Draws an arc representing a portion of an ellipse specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the arc.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the rectangle that defines the ellipse.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of the arc.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to ending point of the arc.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawArc(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawArcI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		/// <summary>Draws an arc representing a portion of an ellipse specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the arc.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that defines the boundaries of the ellipse.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of the arc.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to ending point of the arc.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawArc(Pen pen, Rectangle rect, float startAngle, float sweepAngle)
		{
			DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Draws a Bézier spline defined by four ordered pairs of coordinates that represent points.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="x1">The x-coordinate of the starting point of the curve.</param>
		/// <param name="y1">The y-coordinate of the starting point of the curve.</param>
		/// <param name="x2">The x-coordinate of the first control point of the curve.</param>
		/// <param name="y2">The y-coordinate of the first control point of the curve.</param>
		/// <param name="x3">The x-coordinate of the second control point of the curve.</param>
		/// <param name="y3">The y-coordinate of the second control point of the curve.</param>
		/// <param name="x4">The x-coordinate of the ending point of the curve.</param>
		/// <param name="y4">The y-coordinate of the ending point of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawBezier(Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawBezier(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x1, y1, x2, y2, x3, y3, x4, y4);
			CheckErrorStatus(status);
		}

		/// <summary>Draws a Bézier spline defined by four <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="pt1">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the starting point of the curve.</param>
		/// <param name="pt2">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the first control point for the curve.</param>
		/// <param name="pt3">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the second control point for the curve.</param>
		/// <param name="pt4">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the ending point of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawBezier(Pen pen, PointF pt1, PointF pt2, PointF pt3, PointF pt4)
		{
			DrawBezier(pen, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
		}

		/// <summary>Draws a series of Bézier splines from an array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the points that determine the curve. The number of points in the array should be a multiple of 3 plus 1, such as 4, 7, or 10.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawBeziers(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawBeziers(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a Bézier spline defined by four <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> structure that determines the color, width, and style of the curve.</param>
		/// <param name="pt1">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the starting point of the curve.</param>
		/// <param name="pt2">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the first control point for the curve.</param>
		/// <param name="pt3">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the second control point for the curve.</param>
		/// <param name="pt4">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the ending point of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawBezier(Pen pen, Point pt1, Point pt2, Point pt3, Point pt4)
		{
			DrawBezier(pen, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
		}

		/// <summary>Draws a series of Bézier splines from an array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that represent the points that determine the curve. The number of points in the array should be a multiple of 3 plus 1, such as 4, 7, or 10.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawBeziers(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawBeziersI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="pen">A <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the rectangle.</param>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawRectangle(Pen pen, Rectangle rect)
		{
			DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Draws a rectangle specified by a coordinate pair, a width, and a height.</summary>
		/// <param name="pen">A <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the rectangle.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to draw.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to draw.</param>
		/// <param name="width">The width of the rectangle to draw.</param>
		/// <param name="height">The height of the rectangle to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawRectangle(Pen pen, float x, float y, float width, float height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawRectangle(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height);
			CheckErrorStatus(status);
		}

		/// <summary>Draws a rectangle specified by a coordinate pair, a width, and a height.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the rectangle.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to draw.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to draw.</param>
		/// <param name="width">Width of the rectangle to draw.</param>
		/// <param name="height">Height of the rectangle to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawRectangle(Pen pen, int x, int y, int width, int height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawRectangleI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height);
			CheckErrorStatus(status);
		}

		/// <summary>Draws a series of rectangles specified by <see cref="T:System.Drawing.RectangleF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the outlines of the rectangles.</param>
		/// <param name="rects">Array of <see cref="T:System.Drawing.RectangleF" /> structures that represent the rectangles to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="rects" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="rects" /> is a zero-length array.</exception>
		public void DrawRectangles(Pen pen, RectangleF[] rects)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawRectangles(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), rects.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a series of rectangles specified by <see cref="T:System.Drawing.Rectangle" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the outlines of the rectangles.</param>
		/// <param name="rects">Array of <see cref="T:System.Drawing.Rectangle" /> structures that represent the rectangles to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="rects" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="rects" /> is a zero-length array.</exception>
		public void DrawRectangles(Pen pen, Rectangle[] rects)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawRectanglesI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), rects.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws an ellipse defined by a bounding <see cref="T:System.Drawing.RectangleF" />.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the ellipse.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that defines the boundaries of the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawEllipse(Pen pen, RectangleF rect)
		{
			DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Draws an ellipse defined by a bounding rectangle specified by a pair of coordinates, a height, and a width.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the ellipse.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawEllipse(Pen pen, float x, float y, float width, float height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawEllipse(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height);
			CheckErrorStatus(status);
		}

		/// <summary>Draws an ellipse specified by a bounding <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the ellipse.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that defines the boundaries of the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawEllipse(Pen pen, Rectangle rect)
		{
			DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Draws an ellipse defined by a bounding rectangle specified by coordinates for the upper-left corner of the rectangle, a height, and a width.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the ellipse.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawEllipse(Pen pen, int x, int y, int width, int height)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawEllipseI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height);
			CheckErrorStatus(status);
		}

		/// <summary>Draws a pie shape defined by an ellipse specified by a <see cref="T:System.Drawing.RectangleF" /> structure and two radial lines.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the pie shape.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="startAngle">Angle measured in degrees clockwise from the x-axis to the first side of the pie shape.</param>
		/// <param name="sweepAngle">Angle measured in degrees clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie shape.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawPie(Pen pen, RectangleF rect, float startAngle, float sweepAngle)
		{
			DrawPie(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Draws a pie shape defined by an ellipse specified by a coordinate pair, a width, a height, and two radial lines.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the pie shape.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="startAngle">Angle measured in degrees clockwise from the x-axis to the first side of the pie shape.</param>
		/// <param name="sweepAngle">Angle measured in degrees clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie shape.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawPie(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawPie(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		/// <summary>Draws a pie shape defined by an ellipse specified by a <see cref="T:System.Drawing.Rectangle" /> structure and two radial lines.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the pie shape.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="startAngle">Angle measured in degrees clockwise from the x-axis to the first side of the pie shape.</param>
		/// <param name="sweepAngle">Angle measured in degrees clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie shape.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawPie(Pen pen, Rectangle rect, float startAngle, float sweepAngle)
		{
			DrawPie(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Draws a pie shape defined by an ellipse specified by a coordinate pair, a width, a height, and two radial lines.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the pie shape.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse from which the pie shape comes.</param>
		/// <param name="startAngle">Angle measured in degrees clockwise from the x-axis to the first side of the pie shape.</param>
		/// <param name="sweepAngle">Angle measured in degrees clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie shape.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawPie(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawPieI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		/// <summary>Draws a polygon defined by an array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the polygon.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the vertices of the polygon.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawPolygon(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawPolygon(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a polygon defined by an array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the polygon.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that represent the vertices of the polygon.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.</exception>
		public void DrawPolygon(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawPolygonI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the path.</param>
		/// <param name="path">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to draw.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="path" /> is <see langword="null" />.</exception>
		public void DrawPath(Pen pen, GraphicsPath path)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int status = SafeNativeMethods.Gdip.GdipDrawPath(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(path, path.nativePath));
			CheckErrorStatus(status);
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawCurve(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.PointF" /> structures using a specified tension.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the points that define the curve.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, PointF[] points, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawCurve2(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, tension);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.PointF" /> structures. The drawing begins offset from the beginning of the array.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <param name="offset">Offset from the first element in the array of the <paramref name="points" /> parameter to the starting point in the curve.</param>
		/// <param name="numberOfSegments">Number of segments after the starting point to include in the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments)
		{
			DrawCurve(pen, points, offset, numberOfSegments, 0.5f);
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.PointF" /> structures using a specified tension. The drawing begins offset from the beginning of the array.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <param name="offset">Offset from the first element in the array of the <paramref name="points" /> parameter to the starting point in the curve.</param>
		/// <param name="numberOfSegments">Number of segments after the starting point to include in the curve.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawCurve3(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, offset, numberOfSegments, tension);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and height of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawCurveI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.Point" /> structures using a specified tension.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, Point[] points, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawCurve2I(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, tension);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a cardinal spline through a specified array of <see cref="T:System.Drawing.Point" /> structures using a specified tension.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and style of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <param name="offset">Offset from the first element in the array of the <paramref name="points" /> parameter to the starting point in the curve.</param>
		/// <param name="numberOfSegments">Number of segments after the starting point to include in the curve.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawCurve(Pen pen, Point[] points, int offset, int numberOfSegments, float tension)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawCurve3I(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, offset, numberOfSegments, tension);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a closed cardinal spline defined by an array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and height of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawClosedCurve(Pen pen, PointF[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawClosedCurve(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a closed cardinal spline defined by an array of <see cref="T:System.Drawing.PointF" /> structures using a specified tension.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and height of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled. This parameter is required but is ignored.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawClosedCurve(Pen pen, PointF[] points, float tension, FillMode fillmode)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawClosedCurve2(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, tension);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a closed cardinal spline defined by an array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and height of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawClosedCurve(Pen pen, Point[] points)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawClosedCurveI(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a closed cardinal spline defined by an array of <see cref="T:System.Drawing.Point" /> structures using a specified tension.</summary>
		/// <param name="pen">
		///   <see cref="T:System.Drawing.Pen" /> that determines the color, width, and height of the curve.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled. This parameter is required but ignored.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="pen" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void DrawClosedCurve(Pen pen, Point[] points, float tension, FillMode fillmode)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipDrawClosedCurve2I(new HandleRef(this, NativeGraphics), new HandleRef(pen, pen.NativePen), new HandleRef(this, intPtr), points.Length, tension);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Clears the entire drawing surface and fills it with the specified background color.</summary>
		/// <param name="color">
		///   <see cref="T:System.Drawing.Color" /> structure that represents the background color of the drawing surface.</param>
		public void Clear(Color color)
		{
			int num = SafeNativeMethods.Gdip.GdipGraphicsClear(new HandleRef(this, NativeGraphics), color.ToArgb());
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Fills the interior of a rectangle specified by a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillRectangle(Brush brush, RectangleF rect)
		{
			FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Fills the interior of a rectangle specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to fill.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to fill.</param>
		/// <param name="width">Width of the rectangle to fill.</param>
		/// <param name="height">Height of the rectangle to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillRectangle(Brush brush, float x, float y, float width, float height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillRectangle(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height);
			CheckErrorStatus(status);
		}

		/// <summary>Fills the interior of a rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillRectangle(Brush brush, Rectangle rect)
		{
			FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Fills the interior of a rectangle specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to fill.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to fill.</param>
		/// <param name="width">Width of the rectangle to fill.</param>
		/// <param name="height">Height of the rectangle to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillRectangle(Brush brush, int x, int y, int width, int height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillRectangleI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height);
			CheckErrorStatus(status);
		}

		/// <summary>Fills the interiors of a series of rectangles specified by <see cref="T:System.Drawing.RectangleF" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rects">Array of <see cref="T:System.Drawing.RectangleF" /> structures that represent the rectangles to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="rects" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="Rects" /> is a zero-length array.</exception>
		public void FillRectangles(Brush brush, RectangleF[] rects)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipFillRectangles(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), rects.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Fills the interiors of a series of rectangles specified by <see cref="T:System.Drawing.Rectangle" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rects">Array of <see cref="T:System.Drawing.Rectangle" /> structures that represent the rectangles to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="rects" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="rects" /> is a zero-length array.</exception>
		public void FillRectangles(Brush brush, Rectangle[] rects)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipFillRectanglesI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), rects.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Fills the interior of a polygon defined by an array of points specified by <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the vertices of the polygon to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillPolygon(Brush brush, PointF[] points)
		{
			FillPolygon(brush, points, FillMode.Alternate);
		}

		/// <summary>Fills the interior of a polygon defined by an array of points specified by <see cref="T:System.Drawing.PointF" /> structures using the specified fill mode.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that represent the vertices of the polygon to fill.</param>
		/// <param name="fillMode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines the style of the fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillPolygon(Brush brush, PointF[] points, FillMode fillMode)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipFillPolygon(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length, (int)fillMode);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Fills the interior of a polygon defined by an array of points specified by <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that represent the vertices of the polygon to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillPolygon(Brush brush, Point[] points)
		{
			FillPolygon(brush, points, FillMode.Alternate);
		}

		/// <summary>Fills the interior of a polygon defined by an array of points specified by <see cref="T:System.Drawing.Point" /> structures using the specified fill mode.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that represent the vertices of the polygon to fill.</param>
		/// <param name="fillMode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines the style of the fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillPolygon(Brush brush, Point[] points, FillMode fillMode)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipFillPolygonI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length, (int)fillMode);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Fills the interior of an ellipse defined by a bounding rectangle specified by a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillEllipse(Brush brush, RectangleF rect)
		{
			FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Fills the interior of an ellipse defined by a bounding rectangle specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillEllipse(Brush brush, float x, float y, float width, float height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillEllipse(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height);
			CheckErrorStatus(status);
		}

		/// <summary>Fills the interior of an ellipse defined by a bounding rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillEllipse(Brush brush, Rectangle rect)
		{
			FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Fills the interior of an ellipse defined by a bounding rectangle specified by a pair of coordinates, a width, and a height.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillEllipse(Brush brush, int x, int y, int width, int height)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillEllipseI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height);
			CheckErrorStatus(status);
		}

		/// <summary>Fills the interior of a pie section defined by an ellipse specified by a <see cref="T:System.Drawing.RectangleF" /> structure and two radial lines.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the first side of the pie section.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie section.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillPie(Brush brush, Rectangle rect, float startAngle, float sweepAngle)
		{
			FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Fills the interior of a pie section defined by an ellipse specified by a pair of coordinates, a width, a height, and two radial lines.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the first side of the pie section.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie section.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillPie(Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillPie(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		/// <summary>Fills the interior of a pie section defined by an ellipse specified by a pair of coordinates, a width, a height, and two radial lines.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="width">Width of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="height">Height of the bounding rectangle that defines the ellipse from which the pie section comes.</param>
		/// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the first side of the pie section.</param>
		/// <param name="sweepAngle">Angle in degrees measured clockwise from the <paramref name="startAngle" /> parameter to the second side of the pie section.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public void FillPie(Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int status = SafeNativeMethods.Gdip.GdipFillPieI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), x, y, width, height, startAngle, sweepAngle);
			CheckErrorStatus(status);
		}

		/// <summary>Fills the interior of a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="path">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that represents the path to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="path" /> is <see langword="null" />.</exception>
		public void FillPath(Brush brush, GraphicsPath path)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int status = SafeNativeMethods.Gdip.GdipFillPath(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(path, path.nativePath));
			CheckErrorStatus(status);
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.PointF" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, PointF[] points)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipFillClosedCurve(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.PointF" /> structures using the specified fill mode.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode)
		{
			FillClosedCurve(brush, points, fillmode, 0.5f);
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.PointF" /> structures using the specified fill mode and tension.</summary>
		/// <param name="brush">A <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.PointF" /> structures that define the spline.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode, float tension)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipFillClosedCurve2(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length, tension, (int)fillmode);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.Point" /> structures.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, Point[] points)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipFillClosedCurveI(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.Point" /> structures using the specified fill mode.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode)
		{
			FillClosedCurve(brush, points, fillmode, 0.5f);
		}

		/// <summary>Fills the interior of a closed cardinal spline curve defined by an array of <see cref="T:System.Drawing.Point" /> structures using the specified fill mode and tension.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="points">Array of <see cref="T:System.Drawing.Point" /> structures that define the spline.</param>
		/// <param name="fillmode">Member of the <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the curve is filled.</param>
		/// <param name="tension">Value greater than or equal to 0.0F that specifies the tension of the curve.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="points" /> is <see langword="null" />.</exception>
		public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode, float tension)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int status = SafeNativeMethods.Gdip.GdipFillClosedCurve2I(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(this, intPtr), points.Length, tension, (int)fillmode);
				CheckErrorStatus(status);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Fills the interior of a <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the characteristics of the fill.</param>
		/// <param name="region">
		///   <see cref="T:System.Drawing.Region" /> that represents the area to fill.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="region" /> is <see langword="null" />.</exception>
		public void FillRegion(Brush brush, Region region)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int status = SafeNativeMethods.Gdip.GdipFillRegion(new HandleRef(this, NativeGraphics), new HandleRef(brush, brush.NativeBrush), new HandleRef(region, region.nativeRegion));
			CheckErrorStatus(status);
		}

		/// <summary>Draws the specified text string at the specified location with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn text.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, float x, float y)
		{
			DrawString(s, font, brush, new RectangleF(x, y, 0f, 0f), null);
		}

		/// <summary>Draws the specified text string at the specified location with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="point">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the upper-left corner of the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, PointF point)
		{
			DrawString(s, font, brush, new RectangleF(point.X, point.Y, 0f, 0f), null);
		}

		/// <summary>Draws the specified text string at the specified location with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects using the formatting attributes of the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn text.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn text.</param>
		/// <param name="format">
		///   <see cref="T:System.Drawing.StringFormat" /> that specifies formatting attributes, such as line spacing and alignment, that are applied to the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, float x, float y, StringFormat format)
		{
			DrawString(s, font, brush, new RectangleF(x, y, 0f, 0f), format);
		}

		/// <summary>Draws the specified text string at the specified location with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects using the formatting attributes of the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="point">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the upper-left corner of the drawn text.</param>
		/// <param name="format">
		///   <see cref="T:System.Drawing.StringFormat" /> that specifies formatting attributes, such as line spacing and alignment, that are applied to the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, PointF point, StringFormat format)
		{
			DrawString(s, font, brush, new RectangleF(point.X, point.Y, 0f, 0f), format);
		}

		/// <summary>Draws the specified text string in the specified rectangle with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="layoutRectangle">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location of the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle)
		{
			DrawString(s, font, brush, layoutRectangle, null);
		}

		/// <summary>Draws the specified text string in the specified rectangle with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="T:System.Drawing.Font" /> objects using the formatting attributes of the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="s">String to draw.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="brush">
		///   <see cref="T:System.Drawing.Brush" /> that determines the color and texture of the drawn text.</param>
		/// <param name="layoutRectangle">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location of the drawn text.</param>
		/// <param name="format">
		///   <see cref="T:System.Drawing.StringFormat" /> that specifies formatting attributes, such as line spacing and alignment, that are applied to the drawn text.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.  
		/// -or-  
		/// <paramref name="s" /> is <see langword="null" />.</exception>
		public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle, StringFormat format)
		{
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			if (s != null && s.Length != 0)
			{
				if (font == null)
				{
					throw new ArgumentNullException("font");
				}
				GPRECTF layoutRect = new GPRECTF(layoutRectangle);
				IntPtr handle = format?.nativeFormat ?? IntPtr.Zero;
				int status = SafeNativeMethods.Gdip.GdipDrawString(new HandleRef(this, NativeGraphics), s, s.Length, new HandleRef(font, font.NativeFont), ref layoutRect, new HandleRef(format, handle), new HandleRef(brush, brush.NativeBrush));
				CheckErrorStatus(status);
			}
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" /> and formatted with the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="layoutArea">
		///   <see cref="T:System.Drawing.SizeF" /> structure that specifies the maximum layout area for the text.</param>
		/// <param name="stringFormat">
		///   <see cref="T:System.Drawing.StringFormat" /> that represents formatting information, such as line spacing, for the string.</param>
		/// <param name="charactersFitted">Number of characters in the string.</param>
		/// <param name="linesFilled">Number of text lines in the string.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size of the string, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter and the <paramref name="stringFormat" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat, out int charactersFitted, out int linesFilled)
		{
			if (text == null || text.Length == 0)
			{
				charactersFitted = 0;
				linesFilled = 0;
				return new SizeF(0f, 0f);
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			GPRECTF layoutRect = new GPRECTF(0f, 0f, layoutArea.Width, layoutArea.Height);
			GPRECTF boundingBox = default(GPRECTF);
			int num = SafeNativeMethods.Gdip.GdipMeasureString(new HandleRef(this, NativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), ref layoutRect, new HandleRef(stringFormat, stringFormat?.nativeFormat ?? IntPtr.Zero), ref boundingBox, out charactersFitted, out linesFilled);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boundingBox.SizeF;
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" /> and formatted with the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> defines the text format of the string.</param>
		/// <param name="origin">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the upper-left corner of the string.</param>
		/// <param name="stringFormat">
		///   <see cref="T:System.Drawing.StringFormat" /> that represents formatting information, such as line spacing, for the string.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified by the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter and the <paramref name="stringFormat" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, PointF origin, StringFormat stringFormat)
		{
			if (text == null || text.Length == 0)
			{
				return new SizeF(0f, 0f);
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			GPRECTF layoutRect = default(GPRECTF);
			GPRECTF boundingBox = default(GPRECTF);
			layoutRect.X = origin.X;
			layoutRect.Y = origin.Y;
			layoutRect.Width = 0f;
			layoutRect.Height = 0f;
			int codepointsFitted;
			int linesFilled;
			int num = SafeNativeMethods.Gdip.GdipMeasureString(new HandleRef(this, NativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), ref layoutRect, new HandleRef(stringFormat, stringFormat?.nativeFormat ?? IntPtr.Zero), ref boundingBox, out codepointsFitted, out linesFilled);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boundingBox.SizeF;
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" /> within the specified layout area.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> defines the text format of the string.</param>
		/// <param name="layoutArea">
		///   <see cref="T:System.Drawing.SizeF" /> structure that specifies the maximum layout area for the text.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified by the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, SizeF layoutArea)
		{
			return MeasureString(text, font, layoutArea, null);
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" /> and formatted with the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> defines the text format of the string.</param>
		/// <param name="layoutArea">
		///   <see cref="T:System.Drawing.SizeF" /> structure that specifies the maximum layout area for the text.</param>
		/// <param name="stringFormat">
		///   <see cref="T:System.Drawing.StringFormat" /> that represents formatting information, such as line spacing, for the string.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified in the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter and the <paramref name="stringFormat" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat)
		{
			if (text == null || text.Length == 0)
			{
				return new SizeF(0f, 0f);
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			GPRECTF layoutRect = new GPRECTF(0f, 0f, layoutArea.Width, layoutArea.Height);
			GPRECTF boundingBox = default(GPRECTF);
			int codepointsFitted;
			int linesFilled;
			int num = SafeNativeMethods.Gdip.GdipMeasureString(new HandleRef(this, NativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), ref layoutRect, new HandleRef(stringFormat, stringFormat?.nativeFormat ?? IntPtr.Zero), ref boundingBox, out codepointsFitted, out linesFilled);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boundingBox.SizeF;
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified by the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font)
		{
			return MeasureString(text, font, new SizeF(0f, 0f));
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the format of the string.</param>
		/// <param name="width">Maximum width of the string in pixels.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified in the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, int width)
		{
			return MeasureString(text, font, new SizeF(width, 999999f));
		}

		/// <summary>Measures the specified string when drawn with the specified <see cref="T:System.Drawing.Font" /> and formatted with the specified <see cref="T:System.Drawing.StringFormat" />.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="width">Maximum width of the string.</param>
		/// <param name="format">
		///   <see cref="T:System.Drawing.StringFormat" /> that represents formatting information, such as line spacing, for the string.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.SizeF" /> structure that represents the size, in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, of the string specified in the <paramref name="text" /> parameter as drawn with the <paramref name="font" /> parameter and the <paramref name="stringFormat" /> parameter.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="font" /> is <see langword="null" />.</exception>
		public SizeF MeasureString(string text, Font font, int width, StringFormat format)
		{
			return MeasureString(text, font, new SizeF(width, 999999f), format);
		}

		/// <summary>Gets an array of <see cref="T:System.Drawing.Region" /> objects, each of which bounds a range of character positions within the specified string.</summary>
		/// <param name="text">String to measure.</param>
		/// <param name="font">
		///   <see cref="T:System.Drawing.Font" /> that defines the text format of the string.</param>
		/// <param name="layoutRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the layout rectangle for the string.</param>
		/// <param name="stringFormat">
		///   <see cref="T:System.Drawing.StringFormat" /> that represents formatting information, such as line spacing, for the string.</param>
		/// <returns>This method returns an array of <see cref="T:System.Drawing.Region" /> objects, each of which bounds a range of character positions within the specified string.</returns>
		public Region[] MeasureCharacterRanges(string text, Font font, RectangleF layoutRect, StringFormat stringFormat)
		{
			if (text == null || text.Length == 0)
			{
				return new Region[0];
			}
			if (font == null)
			{
				throw new ArgumentNullException("font");
			}
			int num = SafeNativeMethods.Gdip.GdipGetStringFormatMeasurableCharacterRangeCount(new HandleRef(stringFormat, stringFormat?.nativeFormat ?? IntPtr.Zero), out var count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			IntPtr[] array = new IntPtr[count];
			GPRECTF layoutRect2 = new GPRECTF(layoutRect);
			Region[] array2 = new Region[count];
			for (int i = 0; i < count; i++)
			{
				array2[i] = new Region();
				array[i] = array2[i].nativeRegion;
			}
			num = SafeNativeMethods.Gdip.GdipMeasureCharacterRanges(new HandleRef(this, NativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), ref layoutRect2, new HandleRef(stringFormat, stringFormat?.nativeFormat ?? IntPtr.Zero), count, array);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return array2;
		}

		/// <summary>Draws the image represented by the specified <see cref="T:System.Drawing.Icon" /> at the specified coordinates.</summary>
		/// <param name="icon">
		///   <see cref="T:System.Drawing.Icon" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="icon" /> is <see langword="null" />.</exception>
		public void DrawIcon(Icon icon, int x, int y)
		{
			if (icon == null)
			{
				throw new ArgumentNullException("icon");
			}
			if (backingImage != null)
			{
				DrawImage(icon.ToBitmap(), x, y);
			}
			else
			{
				icon.Draw(this, x, y);
			}
		}

		/// <summary>Draws the image represented by the specified <see cref="T:System.Drawing.Icon" /> within the area specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="icon">
		///   <see cref="T:System.Drawing.Icon" /> to draw.</param>
		/// <param name="targetRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the resulting image on the display surface. The image contained in the <paramref name="icon" /> parameter is scaled to the dimensions of this rectangular area.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="icon" /> is <see langword="null" />.</exception>
		public void DrawIcon(Icon icon, Rectangle targetRect)
		{
			if (icon == null)
			{
				throw new ArgumentNullException("icon");
			}
			if (backingImage != null)
			{
				DrawImage(icon.ToBitmap(), targetRect);
			}
			else
			{
				icon.Draw(this, targetRect);
			}
		}

		/// <summary>Draws the image represented by the specified <see cref="T:System.Drawing.Icon" /> without scaling the image.</summary>
		/// <param name="icon">
		///   <see cref="T:System.Drawing.Icon" /> to draw.</param>
		/// <param name="targetRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the resulting image. The image is not scaled to fit this rectangle, but retains its original size. If the image is larger than the rectangle, it is clipped to fit inside it.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="icon" /> is <see langword="null" />.</exception>
		public void DrawIconUnstretched(Icon icon, Rectangle targetRect)
		{
			if (icon == null)
			{
				throw new ArgumentNullException("icon");
			}
			if (backingImage != null)
			{
				DrawImageUnscaled(icon.ToBitmap(), targetRect);
			}
			else
			{
				icon.DrawUnstretched(this, targetRect);
			}
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" />, using its original physical size, at the specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="point">
		///   <see cref="T:System.Drawing.PointF" /> structure that represents the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF point)
		{
			DrawImage(image, point.X, point.Y);
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" />, using its original physical size, at the specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, float x, float y)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImage(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, RectangleF rect)
		{
			DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="width">Width of the drawn image.</param>
		/// <param name="height">Height of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, float x, float y, float width, float height)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y, width, height);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" />, using its original physical size, at the specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="point">
		///   <see cref="T:System.Drawing.Point" /> structure that represents the location of the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Point point)
		{
			DrawImage(image, point.X, point.Y);
		}

		/// <summary>Draws the specified image, using its original physical size, at the location specified by a coordinate pair.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, int x, int y)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle rect)
		{
			DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="width">Width of the drawn image.</param>
		/// <param name="height">Height of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, int x, int y, int width, int height)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRectI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y, width, height);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		/// <summary>Draws a specified image using its original physical size at a specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="point">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImageUnscaled(Image image, Point point)
		{
			DrawImage(image, point.X, point.Y);
		}

		/// <summary>Draws the specified image using its original physical size at the location specified by a coordinate pair.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImageUnscaled(Image image, int x, int y)
		{
			DrawImage(image, x, y);
		}

		/// <summary>Draws a specified image using its original physical size at a specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> that specifies the upper-left corner of the drawn image. The X and Y properties of the rectangle specify the upper-left corner. The Width and Height properties are ignored.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImageUnscaled(Image image, Rectangle rect)
		{
			DrawImage(image, rect.X, rect.Y);
		}

		/// <summary>Draws a specified image using its original physical size at a specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="width">Not used.</param>
		/// <param name="height">Not used.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImageUnscaled(Image image, int x, int y, int width, int height)
		{
			DrawImage(image, x, y);
		}

		/// <summary>Draws the specified image without scaling and clips it, if necessary, to fit in the specified rectangle.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> in which to draw the image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImageUnscaledAndClipped(Image image, Rectangle rect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int srcWidth = Math.Min(rect.Width, image.Width);
			int srcHeight = Math.Min(rect.Height, image.Height);
			DrawImage(image, rect, 0, 0, srcWidth, srcHeight, GraphicsUnit.Pixel);
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified shape and size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF[] destPoints)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int num = destPoints.Length;
			if (num != 3 && num != 4)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidLength"));
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			try
			{
				int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePoints(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), new HandleRef(this, intPtr), num);
				IgnoreMetafileErrors(image, ref errorStatus);
				CheckErrorStatus(errorStatus);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified shape and size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Point[] destPoints)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int num = destPoints.Length;
			if (num != 3 && num != 4)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidLength"));
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			try
			{
				int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointsI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), new HandleRef(this, intPtr), num);
				IgnoreMetafileErrors(image, ref errorStatus);
				CheckErrorStatus(errorStatus);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws a portion of an image at a specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, float x, float y, RectangleF srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		/// <summary>Draws a portion of an image at a specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="x">The x-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the drawn image.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, int x, int y, Rectangle srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointRectI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), x, y, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRectRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), destRect.X, destRect.Y, destRect.Width, destRect.Height, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit, NativeMethods.NullHandleRef, null, NativeMethods.NullHandleRef);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRectRectI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), destRect.X, destRect.Y, destRect.Width, destRect.Height, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit, NativeMethods.NullHandleRef, null, NativeMethods.NullHandleRef);
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int num = destPoints.Length;
			if (num != 3 && num != 4)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidLength"));
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			try
			{
				int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointsRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), new HandleRef(this, intPtr), destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit, NativeMethods.NullHandleRef, null, NativeMethods.NullHandleRef);
				IgnoreMetafileErrors(image, ref errorStatus);
				CheckErrorStatus(errorStatus);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr)
		{
			DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, null, 0);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> method according to application-determined criteria.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback)
		{
			DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, callback, 0);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> method according to application-determined criteria.</param>
		/// <param name="callbackData">Value specifying additional data for the <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate to use when checking whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> method.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback, int callbackData)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int num = destPoints.Length;
			if (num != 3 && num != 4)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidLength"));
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			try
			{
				int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointsRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), new HandleRef(this, intPtr), destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit, new HandleRef(imageAttr, imageAttr?.nativeImageAttributes ?? IntPtr.Zero), callback, new HandleRef(null, (IntPtr)callbackData));
				IgnoreMetafileErrors(image, ref errorStatus);
				CheckErrorStatus(errorStatus);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit)
		{
			DrawImage(image, destPoints, srcRect, srcUnit, null, null, 0);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr)
		{
			DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, null, 0);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> method according to application-determined criteria.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback)
		{
			DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, callback, 0);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the <paramref name="image" /> object to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used by the <paramref name="srcRect" /> parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> method according to application-determined criteria.</param>
		/// <param name="callbackData">Value specifying additional data for the <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate to use when checking whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> method.</param>
		public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback, int callbackData)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int num = destPoints.Length;
			if (num != 3 && num != 4)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidLength"));
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			try
			{
				int errorStatus = SafeNativeMethods.Gdip.GdipDrawImagePointsRectI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), new HandleRef(this, intPtr), destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, (int)srcUnit, new HandleRef(imageAttr, imageAttr?.nativeImageAttributes ?? IntPtr.Zero), callback, new HandleRef(null, (IntPtr)callbackData));
				IgnoreMetafileErrors(image, ref errorStatus);
				CheckErrorStatus(errorStatus);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, null);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttrs">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, null);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttrs">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> method according to application-determined criteria.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, IntPtr.Zero);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttrs">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" /> method according to application-determined criteria.</param>
		/// <param name="callbackData">Value specifying additional data for the <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate to use when checking whether to stop execution of the <see langword="DrawImage" /> method.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback, IntPtr callbackData)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRectRect(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, (int)srcUnit, new HandleRef(imageAttrs, imageAttrs?.nativeImageAttributes ?? IntPtr.Zero), callback, new HandleRef(null, callbackData));
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, null);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, null);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for <paramref name="image" />.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> method according to application-determined criteria.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback)
		{
			DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, callback, IntPtr.Zero);
		}

		/// <summary>Draws the specified portion of the specified <see cref="T:System.Drawing.Image" /> at the specified location and with the specified size.</summary>
		/// <param name="image">
		///   <see cref="T:System.Drawing.Image" /> to draw.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn image. The image is scaled to fit the rectangle.</param>
		/// <param name="srcX">The x-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcY">The y-coordinate of the upper-left corner of the portion of the source image to draw.</param>
		/// <param name="srcWidth">Width of the portion of the source image to draw.</param>
		/// <param name="srcHeight">Height of the portion of the source image to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the units of measure used to determine the source rectangle.</param>
		/// <param name="imageAttrs">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies recoloring and gamma information for the <paramref name="image" /> object.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate that specifies a method to call during the drawing of the image. This method is called frequently to check whether to stop execution of the <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" /> method according to application-determined criteria.</param>
		/// <param name="callbackData">Value specifying additional data for the <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> delegate to use when checking whether to stop execution of the <see langword="DrawImage" /> method.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback, IntPtr callbackData)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			int errorStatus = SafeNativeMethods.Gdip.GdipDrawImageRectRectI(new HandleRef(this, NativeGraphics), new HandleRef(image, image.nativeImage), destRect.X, destRect.Y, destRect.Width, destRect.Height, srcX, srcY, srcWidth, srcHeight, (int)srcUnit, new HandleRef(imageAttrs, imageAttrs?.nativeImageAttributes ?? IntPtr.Zero), callback, new HandleRef(null, callbackData));
			IgnoreMetafileErrors(image, ref errorStatus);
			CheckErrorStatus(errorStatus);
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoint, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoint, callback, callbackData, null);
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestPoint(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), new GPPOINTF(destPoint), callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoint, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoint, callback, callbackData, null);
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestPointI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), new GPPOINT(destPoint), callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destRect, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destRect, callback, callbackData, null);
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPRECTF destRect2 = new GPRECTF(destRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestRect(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), ref destRect2, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destRect, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destRect, callback, callbackData, null);
		}

		/// <summary>Sends the records of the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPRECT destRect2 = new GPRECT(destRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestRectI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), ref destRect2, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoints, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoints, callback, IntPtr.Zero, null);
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (destPoints.Length != 3)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidParallelogram"));
			}
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestPoints(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), intPtr, destPoints.Length, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoints, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoints, callback, callbackData, null);
		}

		/// <summary>Sends the records in the specified <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (destPoints.Length != 3)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidParallelogram"));
			}
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileDestPointsI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), intPtr, destPoints.Length, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, callbackData, null);
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.PointF" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPRECTF srcRect2 = new GPRECTF(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestPoint(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), new GPPOINTF(destPoint), ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, callbackData, null);
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display at a specified point using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoint">
		///   <see cref="T:System.Drawing.Point" /> structure that specifies the location of the upper-left corner of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPPOINT destPoint2 = new GPPOINT(destPoint);
			GPRECT srcRect2 = new GPRECT(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestPointI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), destPoint2, ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, callbackData, null);
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPRECTF destRect2 = new GPRECTF(destRect);
			GPRECTF srcRect2 = new GPRECTF(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestRect(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), ref destRect2, ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, callbackData, null);
		}

		/// <summary>Sends the records of a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified rectangle using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the location and size of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			GPRECT destRect2 = new GPRECT(destRect);
			GPRECT srcRect2 = new GPRECT(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestRectI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), ref destRect2, ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structures that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, callbackData, null);
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (destPoints.Length != 3)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidParallelogram"));
			}
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			GPRECTF srcRect2 = new GPRECTF(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestPoints(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), intPtr, destPoints.Length, ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback)
		{
			EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, IntPtr.Zero);
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="srcUnit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData)
		{
			EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, callbackData, null);
		}

		/// <summary>Sends the records in a selected rectangle from a <see cref="T:System.Drawing.Imaging.Metafile" />, one at a time, to a callback method for display in a specified parallelogram using specified image attributes.</summary>
		/// <param name="metafile">
		///   <see cref="T:System.Drawing.Imaging.Metafile" /> to enumerate.</param>
		/// <param name="destPoints">Array of three <see cref="T:System.Drawing.Point" /> structures that define a parallelogram that determines the size and location of the drawn metafile.</param>
		/// <param name="srcRect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the portion of the metafile, relative to its upper-left corner, to draw.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure used to determine the portion of the metafile that the rectangle specified by the <paramref name="srcRect" /> parameter contains.</param>
		/// <param name="callback">
		///   <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> delegate that specifies the method to which the metafile records are sent.</param>
		/// <param name="callbackData">Internal pointer that is required, but ignored. You can pass <see cref="F:System.IntPtr.Zero" /> for this parameter.</param>
		/// <param name="imageAttr">
		///   <see cref="T:System.Drawing.Imaging.ImageAttributes" /> that specifies image attribute information for the drawn image.</param>
		public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			if (destPoints.Length != 3)
			{
				throw new ArgumentException(SR.GetString("GdiplusDestPointsInvalidParallelogram"));
			}
			IntPtr handle = metafile?.nativeImage ?? IntPtr.Zero;
			IntPtr handle2 = imageAttr?.nativeImageAttributes ?? IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			GPRECT srcRect2 = new GPRECT(srcRect);
			int num = SafeNativeMethods.Gdip.GdipEnumerateMetafileSrcRectDestPointsI(new HandleRef(this, NativeGraphics), new HandleRef(metafile, handle), intPtr, destPoints.Length, ref srcRect2, (int)unit, callback, new HandleRef(null, callbackData), new HandleRef(imageAttr, handle2));
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the <see langword="Clip" /> property of the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="g">
		///   <see cref="T:System.Drawing.Graphics" /> from which to take the new clip region.</param>
		public void SetClip(Graphics g)
		{
			SetClip(g, CombineMode.Replace);
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the result of the specified combining operation of the current clip region and the <see cref="P:System.Drawing.Graphics.Clip" /> property of the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="g">
		///   <see cref="T:System.Drawing.Graphics" /> that specifies the clip region to combine.</param>
		/// <param name="combineMode">Member of the <see cref="T:System.Drawing.Drawing2D.CombineMode" /> enumeration that specifies the combining operation to use.</param>
		public void SetClip(Graphics g, CombineMode combineMode)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			int num = SafeNativeMethods.Gdip.GdipSetClipGraphics(new HandleRef(this, NativeGraphics), new HandleRef(g, g.NativeGraphics), combineMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that represents the new clip region.</param>
		public void SetClip(Rectangle rect)
		{
			SetClip(rect, CombineMode.Replace);
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the result of the specified operation combining the current clip region and the rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure to combine.</param>
		/// <param name="combineMode">Member of the <see cref="T:System.Drawing.Drawing2D.CombineMode" /> enumeration that specifies the combining operation to use.</param>
		public void SetClip(Rectangle rect, CombineMode combineMode)
		{
			int num = SafeNativeMethods.Gdip.GdipSetClipRectI(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, combineMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the rectangle specified by a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that represents the new clip region.</param>
		public void SetClip(RectangleF rect)
		{
			SetClip(rect, CombineMode.Replace);
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the result of the specified operation combining the current clip region and the rectangle specified by a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure to combine.</param>
		/// <param name="combineMode">Member of the <see cref="T:System.Drawing.Drawing2D.CombineMode" /> enumeration that specifies the combining operation to use.</param>
		public void SetClip(RectangleF rect, CombineMode combineMode)
		{
			int num = SafeNativeMethods.Gdip.GdipSetClipRect(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, combineMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that represents the new clip region.</param>
		public void SetClip(GraphicsPath path)
		{
			SetClip(path, CombineMode.Replace);
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the result of the specified operation combining the current clip region and the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to combine.</param>
		/// <param name="combineMode">Member of the <see cref="T:System.Drawing.Drawing2D.CombineMode" /> enumeration that specifies the combining operation to use.</param>
		public void SetClip(GraphicsPath path, CombineMode combineMode)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipSetClipPath(new HandleRef(this, NativeGraphics), new HandleRef(path, path.nativePath), combineMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the clipping region of this <see cref="T:System.Drawing.Graphics" /> to the result of the specified operation combining the current clip region and the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">
		///   <see cref="T:System.Drawing.Region" /> to combine.</param>
		/// <param name="combineMode">Member from the <see cref="T:System.Drawing.Drawing2D.CombineMode" /> enumeration that specifies the combining operation to use.</param>
		public void SetClip(Region region, CombineMode combineMode)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipSetClipRegion(new HandleRef(this, NativeGraphics), new HandleRef(region, region.nativeRegion), combineMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates the clip region of this <see cref="T:System.Drawing.Graphics" /> to the intersection of the current clip region and the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure to intersect with the current clip region.</param>
		public void IntersectClip(Rectangle rect)
		{
			int num = SafeNativeMethods.Gdip.GdipSetClipRectI(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates the clip region of this <see cref="T:System.Drawing.Graphics" /> to the intersection of the current clip region and the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure to intersect with the current clip region.</param>
		public void IntersectClip(RectangleF rect)
		{
			int num = SafeNativeMethods.Gdip.GdipSetClipRect(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates the clip region of this <see cref="T:System.Drawing.Graphics" /> to the intersection of the current clip region and the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">
		///   <see cref="T:System.Drawing.Region" /> to intersect with the current region.</param>
		public void IntersectClip(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipSetClipRegion(new HandleRef(this, NativeGraphics), new HandleRef(region, region.nativeRegion), CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates the clip region of this <see cref="T:System.Drawing.Graphics" /> to exclude the area specified by a <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that specifies the rectangle to exclude from the clip region.</param>
		public void ExcludeClip(Rectangle rect)
		{
			int num = SafeNativeMethods.Gdip.GdipSetClipRectI(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates the clip region of this <see cref="T:System.Drawing.Graphics" /> to exclude the area specified by a <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">
		///   <see cref="T:System.Drawing.Region" /> that specifies the region to exclude from the clip region.</param>
		public void ExcludeClip(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipSetClipRegion(new HandleRef(this, NativeGraphics), new HandleRef(region, region.nativeRegion), CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Resets the clip region of this <see cref="T:System.Drawing.Graphics" /> to an infinite region.</summary>
		public void ResetClip()
		{
			int num = SafeNativeMethods.Gdip.GdipResetClip(new HandleRef(this, NativeGraphics));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Translates the clipping region of this <see cref="T:System.Drawing.Graphics" /> by specified amounts in the horizontal and vertical directions.</summary>
		/// <param name="dx">The x-coordinate of the translation.</param>
		/// <param name="dy">The y-coordinate of the translation.</param>
		public void TranslateClip(float dx, float dy)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateClip(new HandleRef(this, NativeGraphics), dx, dy);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Translates the clipping region of this <see cref="T:System.Drawing.Graphics" /> by specified amounts in the horizontal and vertical directions.</summary>
		/// <param name="dx">The x-coordinate of the translation.</param>
		/// <param name="dy">The y-coordinate of the translation.</param>
		public void TranslateClip(int dx, int dy)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateClip(new HandleRef(this, NativeGraphics), dx, dy);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Gets the cumulative graphics context.</summary>
		/// <returns>An <see cref="T:System.Object" /> representing the cumulative graphics context.</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[StrongNameIdentityPermission(SecurityAction.LinkDemand, Name = "System.Windows.Forms", PublicKey = "0x00000000000000000400000000000000")]
		public object GetContextInfo()
		{
			Region clip = Clip;
			Matrix transform = Transform;
			PointF pointF = PointF.Empty;
			PointF empty = PointF.Empty;
			if (!transform.IsIdentity)
			{
				float[] elements = transform.Elements;
				pointF.X = elements[4];
				pointF.Y = elements[5];
			}
			GraphicsContext previous = previousContext;
			while (previous != null)
			{
				if (!previous.TransformOffset.IsEmpty)
				{
					transform.Translate(previous.TransformOffset.X, previous.TransformOffset.Y);
				}
				if (!pointF.IsEmpty)
				{
					clip.Translate(pointF.X, pointF.Y);
					empty.X += pointF.X;
					empty.Y += pointF.Y;
				}
				if (previous.Clip != null)
				{
					clip.Intersect(previous.Clip);
				}
				pointF = previous.TransformOffset;
				do
				{
					previous = previous.Previous;
				}
				while (previous != null && previous.Next.IsCumulative && previous.IsCumulative);
			}
			if (!empty.IsEmpty)
			{
				clip.Translate(0f - empty.X, 0f - empty.Y);
			}
			return new object[2] { clip, transform };
		}

		/// <summary>Indicates whether the point specified by a pair of coordinates is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test for visibility.</param>
		/// <param name="y">The y-coordinate of the point to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the point defined by the <paramref name="x" /> and <paramref name="y" /> parameters is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y)
		{
			return IsVisible(new Point(x, y));
		}

		/// <summary>Indicates whether the specified <see cref="T:System.Drawing.Point" /> structure is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="point">
		///   <see cref="T:System.Drawing.Point" /> structure to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the point specified by the <paramref name="point" /> parameter is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Point point)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisiblePointI(new HandleRef(this, NativeGraphics), point.X, point.Y, out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Indicates whether the point specified by a pair of coordinates is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test for visibility.</param>
		/// <param name="y">The y-coordinate of the point to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the point defined by the <paramref name="x" /> and <paramref name="y" /> parameters is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y)
		{
			return IsVisible(new PointF(x, y));
		}

		/// <summary>Indicates whether the specified <see cref="T:System.Drawing.PointF" /> structure is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="point">
		///   <see cref="T:System.Drawing.PointF" /> structure to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the point specified by the <paramref name="point" /> parameter is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(PointF point)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisiblePoint(new HandleRef(this, NativeGraphics), point.X, point.Y, out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Indicates whether the rectangle specified by a pair of coordinates, a width, and a height is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test for visibility.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test for visibility.</param>
		/// <param name="width">Width of the rectangle to test for visibility.</param>
		/// <param name="height">Height of the rectangle to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the rectangle defined by the <paramref name="x" />, <paramref name="y" />, <paramref name="width" />, and <paramref name="height" /> parameters is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y, int width, int height)
		{
			return IsVisible(new Rectangle(x, y, width, height));
		}

		/// <summary>Indicates whether the rectangle specified by a <see cref="T:System.Drawing.Rectangle" /> structure is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the rectangle specified by the <paramref name="rect" /> parameter is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Rectangle rect)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRectI(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Indicates whether the rectangle specified by a pair of coordinates, a width, and a height is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test for visibility.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test for visibility.</param>
		/// <param name="width">Width of the rectangle to test for visibility.</param>
		/// <param name="height">Height of the rectangle to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the rectangle defined by the <paramref name="x" />, <paramref name="y" />, <paramref name="width" />, and <paramref name="height" /> parameters is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y, float width, float height)
		{
			return IsVisible(new RectangleF(x, y, width, height));
		}

		/// <summary>Indicates whether the rectangle specified by a <see cref="T:System.Drawing.RectangleF" /> structure is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="rect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure to test for visibility.</param>
		/// <returns>
		///   <see langword="true" /> if the rectangle specified by the <paramref name="rect" /> parameter is contained within the visible clip region of this <see cref="T:System.Drawing.Graphics" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(RectangleF rect)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRect(new HandleRef(this, NativeGraphics), rect.X, rect.Y, rect.Width, rect.Height, out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		private void PushContext(GraphicsContext context)
		{
			if (previousContext != null)
			{
				context.Previous = previousContext;
				previousContext.Next = context;
			}
			previousContext = context;
		}

		private void PopContext(int currentContextState)
		{
			for (GraphicsContext previous = previousContext; previous != null; previous = previous.Previous)
			{
				if (previous.State == currentContextState)
				{
					previousContext = previous.Previous;
					previous.Dispose();
					break;
				}
			}
		}

		/// <summary>Saves the current state of this <see cref="T:System.Drawing.Graphics" /> and identifies the saved state with a <see cref="T:System.Drawing.Drawing2D.GraphicsState" />.</summary>
		/// <returns>This method returns a <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> that represents the saved state of this <see cref="T:System.Drawing.Graphics" />.</returns>
		public GraphicsState Save()
		{
			GraphicsContext graphicsContext = new GraphicsContext(this);
			int state = 0;
			int num = SafeNativeMethods.Gdip.GdipSaveGraphics(new HandleRef(this, NativeGraphics), out state);
			if (num != 0)
			{
				graphicsContext.Dispose();
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			graphicsContext.State = state;
			graphicsContext.IsCumulative = true;
			PushContext(graphicsContext);
			return new GraphicsState(state);
		}

		/// <summary>Restores the state of this <see cref="T:System.Drawing.Graphics" /> to the state represented by a <see cref="T:System.Drawing.Drawing2D.GraphicsState" />.</summary>
		/// <param name="gstate">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> that represents the state to which to restore this <see cref="T:System.Drawing.Graphics" />.</param>
		public void Restore(GraphicsState gstate)
		{
			int num = SafeNativeMethods.Gdip.GdipRestoreGraphics(new HandleRef(this, NativeGraphics), gstate.nativeState);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			PopContext(gstate.nativeState);
		}

		/// <summary>Saves a graphics container with the current state of this <see cref="T:System.Drawing.Graphics" /> and opens and uses a new graphics container with the specified scale transformation.</summary>
		/// <param name="dstrect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that, together with the <paramref name="srcrect" /> parameter, specifies a scale transformation for the new graphics container.</param>
		/// <param name="srcrect">
		///   <see cref="T:System.Drawing.RectangleF" /> structure that, together with the <paramref name="dstrect" /> parameter, specifies a scale transformation for the new graphics container.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure for the container.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> that represents the state of this <see cref="T:System.Drawing.Graphics" /> at the time of the method call.</returns>
		public GraphicsContainer BeginContainer(RectangleF dstrect, RectangleF srcrect, GraphicsUnit unit)
		{
			GraphicsContext graphicsContext = new GraphicsContext(this);
			int state = 0;
			GPRECTF dstRect = dstrect.ToGPRECTF();
			GPRECTF srcRect = srcrect.ToGPRECTF();
			int num = SafeNativeMethods.Gdip.GdipBeginContainer(new HandleRef(this, NativeGraphics), ref dstRect, ref srcRect, (int)unit, out state);
			if (num != 0)
			{
				graphicsContext.Dispose();
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			graphicsContext.State = state;
			PushContext(graphicsContext);
			return new GraphicsContainer(state);
		}

		/// <summary>Saves a graphics container with the current state of this <see cref="T:System.Drawing.Graphics" /> and opens and uses a new graphics container.</summary>
		/// <returns>This method returns a <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> that represents the state of this <see cref="T:System.Drawing.Graphics" /> at the time of the method call.</returns>
		public GraphicsContainer BeginContainer()
		{
			GraphicsContext graphicsContext = new GraphicsContext(this);
			int state = 0;
			int num = SafeNativeMethods.Gdip.GdipBeginContainer2(new HandleRef(this, NativeGraphics), out state);
			if (num != 0)
			{
				graphicsContext.Dispose();
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			graphicsContext.State = state;
			PushContext(graphicsContext);
			return new GraphicsContainer(state);
		}

		/// <summary>Closes the current graphics container and restores the state of this <see cref="T:System.Drawing.Graphics" /> to the state saved by a call to the <see cref="M:System.Drawing.Graphics.BeginContainer" /> method.</summary>
		/// <param name="container">
		///   <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> that represents the container this method restores.</param>
		public void EndContainer(GraphicsContainer container)
		{
			if (container == null)
			{
				throw new ArgumentNullException("container");
			}
			int num = SafeNativeMethods.Gdip.GdipEndContainer(new HandleRef(this, NativeGraphics), container.nativeGraphicsContainer);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			PopContext(container.nativeGraphicsContainer);
		}

		/// <summary>Saves a graphics container with the current state of this <see cref="T:System.Drawing.Graphics" /> and opens and uses a new graphics container with the specified scale transformation.</summary>
		/// <param name="dstrect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that, together with the <paramref name="srcrect" /> parameter, specifies a scale transformation for the container.</param>
		/// <param name="srcrect">
		///   <see cref="T:System.Drawing.Rectangle" /> structure that, together with the <paramref name="dstrect" /> parameter, specifies a scale transformation for the container.</param>
		/// <param name="unit">Member of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration that specifies the unit of measure for the container.</param>
		/// <returns>This method returns a <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> that represents the state of this <see cref="T:System.Drawing.Graphics" /> at the time of the method call.</returns>
		public GraphicsContainer BeginContainer(Rectangle dstrect, Rectangle srcrect, GraphicsUnit unit)
		{
			GraphicsContext graphicsContext = new GraphicsContext(this);
			int state = 0;
			GPRECT dstRect = new GPRECT(dstrect);
			GPRECT srcRect = new GPRECT(srcrect);
			int num = SafeNativeMethods.Gdip.GdipBeginContainerI(new HandleRef(this, NativeGraphics), ref dstRect, ref srcRect, (int)unit, out state);
			if (num != 0)
			{
				graphicsContext.Dispose();
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			graphicsContext.State = state;
			PushContext(graphicsContext);
			return new GraphicsContainer(state);
		}

		/// <summary>Adds a comment to the current <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="data">Array of bytes that contains the comment.</param>
		public void AddMetafileComment(byte[] data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			int num = SafeNativeMethods.Gdip.GdipComment(new HandleRef(this, NativeGraphics), data.Length, data);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Gets a handle to the current Windows halftone palette.</summary>
		/// <returns>Internal pointer that specifies the handle to the palette.</returns>
		public static IntPtr GetHalftonePalette()
		{
			if (halftonePalette == IntPtr.Zero)
			{
				lock (syncObject)
				{
					if (halftonePalette == IntPtr.Zero)
					{
						if (Environment.OSVersion.Platform != PlatformID.Win32Windows)
						{
							AppDomain.CurrentDomain.DomainUnload += OnDomainUnload;
						}
						AppDomain.CurrentDomain.ProcessExit += OnDomainUnload;
						halftonePalette = SafeNativeMethods.Gdip.GdipCreateHalftonePalette();
					}
				}
			}
			return halftonePalette;
		}

		[PrePrepareMethod]
		private static void OnDomainUnload(object sender, EventArgs e)
		{
			if (halftonePalette != IntPtr.Zero)
			{
				SafeNativeMethods.IntDeleteObject(new HandleRef(null, halftonePalette));
				halftonePalette = IntPtr.Zero;
			}
		}

		private void CheckErrorStatus(int status)
		{
			switch (status)
			{
			case 1:
			case 7:
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error == 5 || lastWin32Error == 127 || (((uint)UnsafeNativeMethods.GetSystemMetrics(4096) & (true ? 1u : 0u)) != 0 && lastWin32Error == 0))
				{
					return;
				}
				break;
			}
			case 0:
				return;
			}
			throw SafeNativeMethods.Gdip.StatusException(status);
		}

		private void IgnoreMetafileErrors(Image image, ref int errorStatus)
		{
			if (errorStatus != 0 && image.RawFormat.Equals(ImageFormat.Emf))
			{
				errorStatus = 0;
			}
		}
	}
	/// <summary>Represents a Windows icon, which is a small bitmap image that is used to represent an object. Icons can be thought of as transparent bitmaps, although their size is determined by the system.</summary>
	[Serializable]
	[TypeConverter(typeof(IconConverter))]
	[Editor("System.Drawing.Design.IconEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public sealed class Icon : MarshalByRefObject, ISerializable, ICloneable, IDisposable
	{
		private static int bitDepth;

		private const int PNGSignature1 = 1196314761;

		private const int PNGSignature2 = 169478669;

		private byte[] iconData;

		private int bestImageOffset;

		private int bestBitDepth;

		private int bestBytesInRes;

		private bool? isBestImagePng;

		private Size iconSize = Size.Empty;

		private IntPtr handle = IntPtr.Zero;

		private bool ownHandle = true;

		/// <summary>Gets the Windows handle for this <see cref="T:System.Drawing.Icon" />. This is not a copy of the handle; do not free it.</summary>
		/// <returns>The Windows handle for the icon.</returns>
		[Browsable(false)]
		public IntPtr Handle
		{
			get
			{
				if (handle == IntPtr.Zero)
				{
					throw new ObjectDisposedException(GetType().Name);
				}
				return handle;
			}
		}

		/// <summary>Gets the height of this <see cref="T:System.Drawing.Icon" />.</summary>
		/// <returns>The height of this <see cref="T:System.Drawing.Icon" />.</returns>
		[Browsable(false)]
		public int Height => Size.Height;

		/// <summary>Gets the size of this <see cref="T:System.Drawing.Icon" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that specifies the width and height of this <see cref="T:System.Drawing.Icon" />.</returns>
		public Size Size
		{
			get
			{
				if (iconSize.IsEmpty)
				{
					SafeNativeMethods.ICONINFO iCONINFO = new SafeNativeMethods.ICONINFO();
					SafeNativeMethods.GetIconInfo(new HandleRef(this, Handle), iCONINFO);
					SafeNativeMethods.BITMAP bITMAP = new SafeNativeMethods.BITMAP();
					if (iCONINFO.hbmColor != IntPtr.Zero)
					{
						SafeNativeMethods.GetObject(new HandleRef(null, iCONINFO.hbmColor), Marshal.SizeOf(typeof(SafeNativeMethods.BITMAP)), bITMAP);
						SafeNativeMethods.IntDeleteObject(new HandleRef(null, iCONINFO.hbmColor));
						iconSize = new Size(bITMAP.bmWidth, bITMAP.bmHeight);
					}
					else if (iCONINFO.hbmMask != IntPtr.Zero)
					{
						SafeNativeMethods.GetObject(new HandleRef(null, iCONINFO.hbmMask), Marshal.SizeOf(typeof(SafeNativeMethods.BITMAP)), bITMAP);
						iconSize = new Size(bITMAP.bmWidth, bITMAP.bmHeight / 2);
					}
					if (iCONINFO.hbmMask != IntPtr.Zero)
					{
						SafeNativeMethods.IntDeleteObject(new HandleRef(null, iCONINFO.hbmMask));
					}
				}
				return iconSize;
			}
		}

		/// <summary>Gets the width of this <see cref="T:System.Drawing.Icon" />.</summary>
		/// <returns>The width of this <see cref="T:System.Drawing.Icon" />.</returns>
		[Browsable(false)]
		public int Width => Size.Width;

		private Icon()
		{
		}

		internal Icon(IntPtr handle)
			: this(handle, takeOwnership: false)
		{
		}

		internal Icon(IntPtr handle, bool takeOwnership)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentException(SR.GetString("InvalidGDIHandle", typeof(Icon).Name));
			}
			this.handle = handle;
			ownHandle = takeOwnership;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class from the specified file name.</summary>
		/// <param name="fileName">The file to load the <see cref="T:System.Drawing.Icon" /> from.</param>
		public Icon(string fileName)
			: this(fileName, 0, 0)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class of the specified size from the specified file.</summary>
		/// <param name="fileName">The name and path to the file that contains the icon data.</param>
		/// <param name="size">The desired size of the icon.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="string" /> is <see langword="null" /> or does not contain image data.</exception>
		public Icon(string fileName, Size size)
			: this(fileName, size.Width, size.Height)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class with the specified width and height from the specified file.</summary>
		/// <param name="fileName">The name and path to the file that contains the <see cref="T:System.Drawing.Icon" /> data.</param>
		/// <param name="width">The desired width of the <see cref="T:System.Drawing.Icon" />.</param>
		/// <param name="height">The desired height of the <see cref="T:System.Drawing.Icon" />.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="string" /> is <see langword="null" /> or does not contain image data.</exception>
		public Icon(string fileName, int width, int height)
			: this()
		{
			using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				iconData = new byte[(int)fileStream.Length];
				fileStream.Read(iconData, 0, iconData.Length);
			}
			Initialize(width, height);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class and attempts to find a version of the icon that matches the requested size.</summary>
		/// <param name="original">The <see cref="T:System.Drawing.Icon" /> from which to load the newly sized icon.</param>
		/// <param name="size">A <see cref="T:System.Drawing.Size" /> structure that specifies the height and width of the new <see cref="T:System.Drawing.Icon" />.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="original" /> parameter is <see langword="null" />.</exception>
		public Icon(Icon original, Size size)
			: this(original, size.Width, size.Height)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class and attempts to find a version of the icon that matches the requested size.</summary>
		/// <param name="original">The icon to load the different size from.</param>
		/// <param name="width">The width of the new icon.</param>
		/// <param name="height">The height of the new icon.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="original" /> parameter is <see langword="null" />.</exception>
		public Icon(Icon original, int width, int height)
			: this()
		{
			if (original == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "original", "null"));
			}
			iconData = original.iconData;
			if (iconData == null)
			{
				iconSize = original.Size;
				handle = SafeNativeMethods.CopyImage(new HandleRef(original, original.Handle), 1, iconSize.Width, iconSize.Height, 0);
			}
			else
			{
				Initialize(width, height);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class from a resource in the specified assembly.</summary>
		/// <param name="type">A <see cref="T:System.Type" /> that specifies the assembly in which to look for the resource.</param>
		/// <param name="resource">The resource name to load.</param>
		/// <exception cref="T:System.ArgumentException">An icon specified by <paramref name="resource" /> cannot be found in the assembly that contains the specified <paramref name="type" />.</exception>
		public Icon(Type type, string resource)
			: this()
		{
			Stream manifestResourceStream = type.Module.Assembly.GetManifestResourceStream(type, resource);
			if (manifestResourceStream == null)
			{
				throw new ArgumentException(SR.GetString("ResourceNotFound", type, resource));
			}
			iconData = new byte[(int)manifestResourceStream.Length];
			manifestResourceStream.Read(iconData, 0, iconData.Length);
			Initialize(0, 0);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class from the specified data stream.</summary>
		/// <param name="stream">The data stream from which to load the <see cref="T:System.Drawing.Icon" />.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="stream" /> parameter is <see langword="null" />.</exception>
		public Icon(Stream stream)
			: this(stream, 0, 0)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class of the specified size from the specified stream.</summary>
		/// <param name="stream">The stream that contains the icon data.</param>
		/// <param name="size">The desired size of the icon.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="stream" /> is <see langword="null" /> or does not contain image data.</exception>
		public Icon(Stream stream, Size size)
			: this(stream, size.Width, size.Height)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Icon" /> class from the specified data stream and with the specified width and height.</summary>
		/// <param name="stream">The data stream from which to load the icon.</param>
		/// <param name="width">The width, in pixels, of the icon.</param>
		/// <param name="height">The height, in pixels, of the icon.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="stream" /> parameter is <see langword="null" />.</exception>
		public Icon(Stream stream, int width, int height)
			: this()
		{
			if (stream == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "stream", "null"));
			}
			iconData = new byte[(int)stream.Length];
			stream.Read(iconData, 0, iconData.Length);
			Initialize(width, height);
		}

		private Icon(SerializationInfo info, StreamingContext context)
		{
			iconData = (byte[])info.GetValue("IconData", typeof(byte[]));
			iconSize = (Size)info.GetValue("IconSize", typeof(Size));
			if (iconSize.IsEmpty)
			{
				Initialize(0, 0);
			}
			else
			{
				Initialize(iconSize.Width, iconSize.Height);
			}
		}

		/// <summary>Returns an icon representation of an image that is contained in the specified file.</summary>
		/// <param name="filePath">The path to the file that contains an image.</param>
		/// <returns>The <see cref="T:System.Drawing.Icon" /> representation of the image that is contained in the specified file.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="filePath" /> does not indicate a valid file.  
		///  -or-  
		///  The <paramref name="filePath" /> indicates a Universal Naming Convention (UNC) path.</exception>
		public static Icon ExtractAssociatedIcon(string filePath)
		{
			return ExtractAssociatedIcon(filePath, 0);
		}

		private static Icon ExtractAssociatedIcon(string filePath, int index)
		{
			if (filePath == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "filePath", "null"));
			}
			Uri uri;
			try
			{
				uri = new Uri(filePath);
			}
			catch (UriFormatException)
			{
				filePath = Path.GetFullPath(filePath);
				uri = new Uri(filePath);
			}
			if (uri.IsUnc)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "filePath", filePath));
			}
			if (uri.IsFile)
			{
				if (!File.Exists(filePath))
				{
					IntSecurity.DemandReadFileIO(filePath);
					throw new FileNotFoundException(filePath);
				}
				Icon icon = new Icon();
				StringBuilder stringBuilder = new StringBuilder(260);
				stringBuilder.Append(filePath);
				IntPtr intPtr = SafeNativeMethods.ExtractAssociatedIcon(NativeMethods.NullHandleRef, stringBuilder, ref index);
				if (intPtr != IntPtr.Zero)
				{
					IntSecurity.ObjectFromWin32Handle.Demand();
					return new Icon(intPtr, takeOwnership: true);
				}
			}
			return null;
		}

		/// <summary>Clones the <see cref="T:System.Drawing.Icon" />, creating a duplicate image.</summary>
		/// <returns>An object that can be cast to an <see cref="T:System.Drawing.Icon" />.</returns>
		public object Clone()
		{
			return new Icon(this, Size.Width, Size.Height);
		}

		internal void DestroyHandle()
		{
			if (ownHandle)
			{
				SafeNativeMethods.DestroyIcon(new HandleRef(this, handle));
				handle = IntPtr.Zero;
			}
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Icon" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (handle != IntPtr.Zero)
			{
				DestroyHandle();
			}
		}

		private void DrawIcon(IntPtr dc, Rectangle imageRect, Rectangle targetRect, bool stretch)
		{
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			Size size = Size;
			int width;
			int height;
			if (!imageRect.IsEmpty)
			{
				num = imageRect.X;
				num2 = imageRect.Y;
				width = imageRect.Width;
				height = imageRect.Height;
			}
			else
			{
				width = size.Width;
				height = size.Height;
			}
			if (!targetRect.IsEmpty)
			{
				num3 = targetRect.X;
				num4 = targetRect.Y;
				num5 = targetRect.Width;
				num6 = targetRect.Height;
			}
			else
			{
				num5 = size.Width;
				num6 = size.Height;
			}
			int width2;
			int height2;
			int num7;
			int num8;
			if (stretch)
			{
				width2 = size.Width * num5 / width;
				height2 = size.Height * num6 / height;
				num7 = num5;
				num8 = num6;
			}
			else
			{
				width2 = size.Width;
				height2 = size.Height;
				num7 = ((num5 < width) ? num5 : width);
				num8 = ((num6 < height) ? num6 : height);
			}
			IntPtr hRgn = SafeNativeMethods.SaveClipRgn(dc);
			try
			{
				SafeNativeMethods.IntersectClipRect(new HandleRef(this, dc), num3, num4, num3 + num7, num4 + num8);
				SafeNativeMethods.DrawIconEx(new HandleRef(null, dc), num3 - num, num4 - num2, new HandleRef(this, handle), width2, height2, 0, NativeMethods.NullHandleRef, 3);
			}
			finally
			{
				SafeNativeMethods.RestoreClipRgn(dc, hRgn);
			}
		}

		internal void Draw(Graphics graphics, int x, int y)
		{
			Size size = Size;
			Draw(graphics, new Rectangle(x, y, size.Width, size.Height));
		}

		internal void Draw(Graphics graphics, Rectangle targetRect)
		{
			Rectangle targetRect2 = targetRect;
			targetRect2.X += (int)graphics.Transform.OffsetX;
			targetRect2.Y += (int)graphics.Transform.OffsetY;
			WindowsGraphics windowsGraphics = WindowsGraphics.FromGraphics(graphics, ApplyGraphicsProperties.Clipping);
			IntPtr hdc = windowsGraphics.GetHdc();
			try
			{
				DrawIcon(hdc, Rectangle.Empty, targetRect2, stretch: true);
			}
			finally
			{
				windowsGraphics.Dispose();
			}
		}

		internal void DrawUnstretched(Graphics graphics, Rectangle targetRect)
		{
			Rectangle targetRect2 = targetRect;
			targetRect2.X += (int)graphics.Transform.OffsetX;
			targetRect2.Y += (int)graphics.Transform.OffsetY;
			WindowsGraphics windowsGraphics = WindowsGraphics.FromGraphics(graphics, ApplyGraphicsProperties.Clipping);
			IntPtr hdc = windowsGraphics.GetHdc();
			try
			{
				DrawIcon(hdc, Rectangle.Empty, targetRect2, stretch: false);
			}
			finally
			{
				windowsGraphics.Dispose();
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Icon()
		{
			Dispose(disposing: false);
		}

		/// <summary>Creates a GDI+ <see cref="T:System.Drawing.Icon" /> from the specified Windows handle to an icon (<see langword="HICON" />).</summary>
		/// <param name="handle">A Windows handle to an icon.</param>
		/// <returns>The <see cref="T:System.Drawing.Icon" /> this method creates.</returns>
		public static Icon FromHandle(IntPtr handle)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			return new Icon(handle);
		}

		private unsafe short GetShort(byte* pb)
		{
			int num = 0;
			if (((uint)(byte)pb & (true ? 1u : 0u)) != 0)
			{
				num = *pb;
				pb++;
				num |= *pb << 8;
			}
			else
			{
				num = *(short*)pb;
			}
			return (short)num;
		}

		private unsafe int GetInt(byte* pb)
		{
			int num = 0;
			if (((byte)pb & 3u) != 0)
			{
				num = *pb;
				pb++;
				num |= *pb << 8;
				pb++;
				num |= *pb << 16;
				pb++;
				return num | (*pb << 24);
			}
			return *(int*)pb;
		}

		private unsafe void Initialize(int width, int height)
		{
			if (iconData == null || handle != IntPtr.Zero)
			{
				throw new InvalidOperationException(SR.GetString("IllegalState", GetType().Name));
			}
			int num = Marshal.SizeOf(typeof(SafeNativeMethods.ICONDIR));
			if (iconData.Length < num)
			{
				throw new ArgumentException(SR.GetString("InvalidPictureType", "picture", "Icon"));
			}
			if (width == 0)
			{
				width = UnsafeNativeMethods.GetSystemMetrics(11);
			}
			if (height == 0)
			{
				height = UnsafeNativeMethods.GetSystemMetrics(12);
			}
			if (bitDepth == 0)
			{
				IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
				bitDepth = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dC), 12);
				bitDepth *= UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dC), 14);
				UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
				if (bitDepth == 8)
				{
					bitDepth = 4;
				}
			}
			fixed (byte* ptr = iconData)
			{
				short @short = GetShort(ptr);
				short short2 = GetShort(ptr + 2);
				short short3 = GetShort(ptr + 4);
				if (@short != 0 || short2 != 1 || short3 == 0)
				{
					throw new ArgumentException(SR.GetString("InvalidPictureType", "picture", "Icon"));
				}
				byte b = 0;
				byte b2 = 0;
				byte* ptr2 = ptr + 6;
				int num2 = Marshal.SizeOf(typeof(SafeNativeMethods.ICONDIRENTRY));
				if (num2 * (short3 - 1) + num > iconData.Length)
				{
					throw new ArgumentException(SR.GetString("InvalidPictureType", "picture", "Icon"));
				}
				SafeNativeMethods.ICONDIRENTRY iCONDIRENTRY = default(SafeNativeMethods.ICONDIRENTRY);
				for (int i = 0; i < short3; i++)
				{
					iCONDIRENTRY.bWidth = *ptr2;
					iCONDIRENTRY.bHeight = ptr2[1];
					iCONDIRENTRY.bColorCount = ptr2[2];
					iCONDIRENTRY.bReserved = ptr2[3];
					iCONDIRENTRY.wPlanes = GetShort(ptr2 + 4);
					iCONDIRENTRY.wBitCount = GetShort(ptr2 + 6);
					iCONDIRENTRY.dwBytesInRes = GetInt(ptr2 + 8);
					iCONDIRENTRY.dwImageOffset = GetInt(ptr2 + 12);
					bool flag = false;
					int num3 = 0;
					if (iCONDIRENTRY.bColorCount != 0)
					{
						num3 = 4;
						if (iCONDIRENTRY.bColorCount < 16)
						{
							num3 = 1;
						}
					}
					else
					{
						num3 = iCONDIRENTRY.wBitCount;
					}
					if (num3 == 0)
					{
						num3 = 8;
					}
					if (bestBytesInRes == 0)
					{
						flag = true;
					}
					else
					{
						int num4 = Math.Abs(b - width) + Math.Abs(b2 - height);
						int num5 = Math.Abs(iCONDIRENTRY.bWidth - width) + Math.Abs(iCONDIRENTRY.bHeight - height);
						if (num5 < num4 || (num5 == num4 && ((num3 <= bitDepth && num3 > bestBitDepth) || (bestBitDepth > bitDepth && num3 < bestBitDepth))))
						{
							flag = true;
						}
					}
					if (flag)
					{
						b = iCONDIRENTRY.bWidth;
						b2 = iCONDIRENTRY.bHeight;
						bestImageOffset = iCONDIRENTRY.dwImageOffset;
						bestBytesInRes = iCONDIRENTRY.dwBytesInRes;
						bestBitDepth = num3;
					}
					ptr2 += num2;
				}
				if (bestImageOffset < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidPictureType", "picture", "Icon"));
				}
				if (bestBytesInRes < 0)
				{
					throw new Win32Exception(87);
				}
				int num6;
				try
				{
					num6 = checked(bestImageOffset + bestBytesInRes);
				}
				catch (OverflowException)
				{
					throw new Win32Exception(87);
				}
				if (num6 > iconData.Length)
				{
					throw new ArgumentException(SR.GetString("InvalidPictureType", "picture", "Icon"));
				}
				if (bestImageOffset % IntPtr.Size != 0)
				{
					byte[] array = new byte[bestBytesInRes];
					Array.Copy(iconData, bestImageOffset, array, 0, bestBytesInRes);
					fixed (byte* pbIconBits = array)
					{
						handle = SafeNativeMethods.CreateIconFromResourceEx(pbIconBits, bestBytesInRes, fIcon: true, 196608, 0, 0, 0);
					}
				}
				else
				{
					try
					{
						handle = SafeNativeMethods.CreateIconFromResourceEx((byte*)checked(unchecked((ulong)ptr) + unchecked((ulong)bestImageOffset)), bestBytesInRes, fIcon: true, 196608, 0, 0, 0);
					}
					catch (OverflowException)
					{
						throw new Win32Exception(87);
					}
				}
				if (handle == IntPtr.Zero)
				{
					throw new Win32Exception();
				}
			}
		}

		/// <summary>Saves this <see cref="T:System.Drawing.Icon" /> to the specified output <see cref="T:System.IO.Stream" />.</summary>
		/// <param name="outputStream">The <see cref="T:System.IO.Stream" /> to save to.</param>
		public void Save(Stream outputStream)
		{
			if (iconData != null)
			{
				outputStream.Write(iconData, 0, iconData.Length);
				return;
			}
			SafeNativeMethods.PICTDESC pictdesc = SafeNativeMethods.PICTDESC.CreateIconPICTDESC(Handle);
			Guid refiid = typeof(SafeNativeMethods.IPicture).GUID;
			SafeNativeMethods.IPicture picture = SafeNativeMethods.OleCreatePictureIndirect(pictdesc, ref refiid, fOwn: false);
			if (picture == null)
			{
				return;
			}
			try
			{
				picture.SaveAsFile(new UnsafeNativeMethods.ComStreamFromDataStream(outputStream), -1, out var _);
			}
			finally
			{
				Marshal.ReleaseComObject(picture);
			}
		}

		private void CopyBitmapData(BitmapData sourceData, BitmapData targetData)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < Math.Min(sourceData.Height, targetData.Height); i++)
			{
				IntPtr intPtr;
				IntPtr intPtr2;
				if (IntPtr.Size == 4)
				{
					intPtr = new IntPtr(sourceData.Scan0.ToInt32() + num);
					intPtr2 = new IntPtr(targetData.Scan0.ToInt32() + num2);
				}
				else
				{
					intPtr = new IntPtr(sourceData.Scan0.ToInt64() + num);
					intPtr2 = new IntPtr(targetData.Scan0.ToInt64() + num2);
				}
				UnsafeNativeMethods.CopyMemory(new HandleRef(this, intPtr2), new HandleRef(this, intPtr), Math.Abs(targetData.Stride));
				num += sourceData.Stride;
				num2 += targetData.Stride;
			}
		}

		private unsafe static bool BitmapHasAlpha(BitmapData bmpData)
		{
			bool result = false;
			for (int i = 0; i < bmpData.Height; i++)
			{
				int num = 3;
				while (num < Math.Abs(bmpData.Stride))
				{
					byte* ptr = (byte*)bmpData.Scan0.ToPointer() + i * bmpData.Stride + num;
					if (*ptr == 0)
					{
						num += 4;
						continue;
					}
					goto IL_0029;
				}
				continue;
				IL_0029:
				result = true;
				break;
			}
			return result;
		}

		/// <summary>Converts this <see cref="T:System.Drawing.Icon" /> to a GDI+ <see cref="T:System.Drawing.Bitmap" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Bitmap" /> that represents the converted <see cref="T:System.Drawing.Icon" />.</returns>
		public Bitmap ToBitmap()
		{
			if (HasPngSignature() && !LocalAppContextSwitches.DontSupportPngFramesInIcons)
			{
				return PngFrame();
			}
			return BmpFrame();
		}

		private unsafe Bitmap BmpFrame()
		{
			Bitmap bitmap = null;
			if (iconData != null && bestBitDepth == 32)
			{
				bitmap = new Bitmap(Size.Width, Size.Height, PixelFormat.Format32bppArgb);
				BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, Size.Width, Size.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
				try
				{
					uint* ptr = (uint*)bitmapData.Scan0.ToPointer();
					int num = bestImageOffset + Marshal.SizeOf(typeof(SafeNativeMethods.BITMAPINFOHEADER));
					int length = Size.Width * 4;
					int width = Size.Width;
					for (int num2 = (Size.Height - 1) * 4; num2 >= 0; num2 -= 4)
					{
						Marshal.Copy(iconData, num + num2 * width, (IntPtr)ptr, length);
						ptr += width;
					}
				}
				finally
				{
					bitmap.UnlockBits(bitmapData);
				}
			}
			else if (bestBitDepth == 0 || bestBitDepth == 32)
			{
				SafeNativeMethods.ICONINFO iCONINFO = new SafeNativeMethods.ICONINFO();
				SafeNativeMethods.GetIconInfo(new HandleRef(this, handle), iCONINFO);
				SafeNativeMethods.BITMAP bITMAP = new SafeNativeMethods.BITMAP();
				try
				{
					if (iCONINFO.hbmColor != IntPtr.Zero)
					{
						SafeNativeMethods.GetObject(new HandleRef(null, iCONINFO.hbmColor), Marshal.SizeOf(typeof(SafeNativeMethods.BITMAP)), bITMAP);
						if (bITMAP.bmBitsPixel == 32)
						{
							Bitmap bitmap2 = null;
							BitmapData bitmapData2 = null;
							BitmapData bitmapData3 = null;
							IntSecurity.ObjectFromWin32Handle.Assert();
							try
							{
								bitmap2 = Image.FromHbitmap(iCONINFO.hbmColor);
								bitmapData2 = bitmap2.LockBits(new Rectangle(0, 0, bitmap2.Width, bitmap2.Height), ImageLockMode.ReadOnly, bitmap2.PixelFormat);
								if (BitmapHasAlpha(bitmapData2))
								{
									bitmap = new Bitmap(bitmapData2.Width, bitmapData2.Height, PixelFormat.Format32bppArgb);
									bitmapData3 = bitmap.LockBits(new Rectangle(0, 0, bitmapData2.Width, bitmapData2.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
									CopyBitmapData(bitmapData2, bitmapData3);
								}
							}
							finally
							{
								CodeAccessPermission.RevertAssert();
								if (bitmap2 != null && bitmapData2 != null)
								{
									bitmap2.UnlockBits(bitmapData2);
								}
								if (bitmap != null && bitmapData3 != null)
								{
									bitmap.UnlockBits(bitmapData3);
								}
							}
							bitmap2.Dispose();
						}
					}
				}
				finally
				{
					if (iCONINFO.hbmColor != IntPtr.Zero)
					{
						SafeNativeMethods.IntDeleteObject(new HandleRef(null, iCONINFO.hbmColor));
					}
					if (iCONINFO.hbmMask != IntPtr.Zero)
					{
						SafeNativeMethods.IntDeleteObject(new HandleRef(null, iCONINFO.hbmMask));
					}
				}
			}
			if (bitmap == null)
			{
				Size size = Size;
				bitmap = new Bitmap(size.Width, size.Height);
				Graphics graphics = null;
				try
				{
					graphics = Graphics.FromImage(bitmap);
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						using Bitmap image = Bitmap.FromHicon(Handle);
						graphics.DrawImage(image, new Rectangle(0, 0, size.Width, size.Height));
					}
					catch (ArgumentException)
					{
						Draw(graphics, new Rectangle(0, 0, size.Width, size.Height));
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
				}
				finally
				{
					graphics?.Dispose();
				}
				Color transparentColor = Color.FromArgb(13, 11, 12);
				bitmap.MakeTransparent(transparentColor);
			}
			return bitmap;
		}

		private Bitmap PngFrame()
		{
			Bitmap result = null;
			if (iconData != null)
			{
				using (MemoryStream memoryStream = new MemoryStream())
				{
					memoryStream.Write(iconData, bestImageOffset, bestBytesInRes);
					return new Bitmap(memoryStream);
				}
			}
			return result;
		}

		private bool HasPngSignature()
		{
			if (!isBestImagePng.HasValue)
			{
				if (iconData != null && iconData.Length >= bestImageOffset + 8)
				{
					int num = BitConverter.ToInt32(iconData, bestImageOffset);
					int num2 = BitConverter.ToInt32(iconData, bestImageOffset + 4);
					isBestImagePng = num == 1196314761 && num2 == 169478669;
				}
				else
				{
					isBestImagePng = false;
				}
			}
			return isBestImagePng.Value;
		}

		/// <summary>Gets a human-readable string that describes the <see cref="T:System.Drawing.Icon" />.</summary>
		/// <returns>A string that describes the <see cref="T:System.Drawing.Icon" />.</returns>
		public override string ToString()
		{
			return SR.GetString("toStringIcon");
		}

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data that is required to serialize the target object.</summary>
		/// <param name="si">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
		{
			if (iconData != null)
			{
				si.AddValue("IconData", iconData, typeof(byte[]));
			}
			else
			{
				MemoryStream memoryStream = new MemoryStream();
				Save(memoryStream);
				si.AddValue("IconData", memoryStream.ToArray(), typeof(byte[]));
			}
			si.AddValue("IconSize", iconSize, typeof(Size));
		}
	}
	/// <summary>Converts an <see cref="T:System.Drawing.Icon" /> object from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" /> object.</summary>
	public class IconConverter : ExpandableObjectConverter
	{
		/// <summary>Determines whether this <see cref="T:System.Drawing.IconConverter" /> can convert an instance of a specified type to an <see cref="T:System.Drawing.Icon" />, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="sourceType">A <see cref="T:System.Type" /> that specifies the type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this <see cref="T:System.Drawing.IconConverter" /> can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(byte[]))
			{
				return true;
			}
			if (sourceType == typeof(InstanceDescriptor))
			{
				return false;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Determines whether this <see cref="T:System.Drawing.IconConverter" /> can convert an <see cref="T:System.Drawing.Icon" /> to an instance of a specified type, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that specifies the type you want to convert to.</param>
		/// <returns>This method returns <see langword="true" /> if this <see cref="T:System.Drawing.IconConverter" /> can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(Image) || destinationType == typeof(Bitmap))
			{
				return true;
			}
			if (destinationType == typeof(byte[]))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts a specified object to an <see cref="T:System.Drawing.Icon" />.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that holds information about a specific culture.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to be converted.</param>
		/// <returns>If this method succeeds, it returns the <see cref="T:System.Drawing.Icon" /> that it created by converting the specified object. Otherwise, it throws an exception.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion could not be performed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is byte[])
			{
				MemoryStream stream = new MemoryStream((byte[])value);
				return new Icon(stream);
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts an <see cref="T:System.Drawing.Icon" /> (or an object that can be cast to an <see cref="T:System.Drawing.Icon" />) to a specified type.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> object that specifies formatting conventions used by a particular culture.</param>
		/// <param name="value">The object to convert. This object should be of type icon or some type that can be cast to <see cref="T:System.Drawing.Icon" />.</param>
		/// <param name="destinationType">The type to convert the icon to.</param>
		/// <returns>This method returns the converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion could not be performed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if ((destinationType == typeof(Image) || destinationType == typeof(Bitmap)) && value is Icon icon)
			{
				return icon.ToBitmap();
			}
			if (destinationType == typeof(string))
			{
				if (value != null)
				{
					return value.ToString();
				}
				return SR.GetString("toStringNone");
			}
			if (destinationType == typeof(byte[]))
			{
				if (value != null)
				{
					MemoryStream memoryStream = null;
					try
					{
						memoryStream = new MemoryStream();
						if (value is Icon icon2)
						{
							icon2.Save(memoryStream);
						}
					}
					finally
					{
						memoryStream?.Close();
					}
					return memoryStream?.ToArray();
				}
				return new byte[0];
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.IconConverter" /> class.</summary>
		public IconConverter()
		{
		}
	}
	/// <summary>An abstract base class that provides functionality for the <see cref="T:System.Drawing.Bitmap" /> and <see cref="T:System.Drawing.Imaging.Metafile" /> descended classes.</summary>
	[Serializable]
	[TypeConverter(typeof(ImageConverter))]
	[Editor("System.Drawing.Design.ImageEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	[ImmutableObject(true)]
	[ComVisible(true)]
	public abstract class Image : MarshalByRefObject, ISerializable, ICloneable, IDisposable
	{
		/// <summary>Provides a callback method for determining when the <see cref="M:System.Drawing.Image.GetThumbnailImage(System.Int32,System.Int32,System.Drawing.Image.GetThumbnailImageAbort,System.IntPtr)" /> method should prematurely cancel execution.</summary>
		/// <returns>This method returns <see langword="true" /> if it decides that the <see cref="M:System.Drawing.Image.GetThumbnailImage(System.Int32,System.Int32,System.Drawing.Image.GetThumbnailImageAbort,System.IntPtr)" /> method should prematurely stop execution; otherwise, it returns <see langword="false" />.</returns>
		public delegate bool GetThumbnailImageAbort();

		private enum ImageTypeEnum
		{
			Bitmap = 1,
			Metafile
		}

		internal IntPtr nativeImage;

		private byte[] rawData;

		private object userData;

		/// <summary>Gets or sets an object that provides additional data about the image.</summary>
		/// <returns>The <see cref="T:System.Object" /> that provides additional data about the image.</returns>
		[Localizable(false)]
		[Bindable(true)]
		[DefaultValue(null)]
		[TypeConverter(typeof(StringConverter))]
		public object Tag
		{
			get
			{
				return userData;
			}
			set
			{
				userData = value;
			}
		}

		/// <summary>Gets the width and height of this image.</summary>
		/// <returns>A <see cref="T:System.Drawing.SizeF" /> structure that represents the width and height of this <see cref="T:System.Drawing.Image" />.</returns>
		public SizeF PhysicalDimension => _GetPhysicalDimension();

		/// <summary>Gets the width and height, in pixels, of this image.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that represents the width and height, in pixels, of this image.</returns>
		public Size Size => new Size(Width, Height);

		/// <summary>Gets the width, in pixels, of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The width, in pixels, of this <see cref="T:System.Drawing.Image" />.</returns>
		[DefaultValue(false)]
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public int Width
		{
			get
			{
				int width;
				int num = SafeNativeMethods.Gdip.GdipGetImageWidth(new HandleRef(this, nativeImage), out width);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return width;
			}
		}

		/// <summary>Gets the height, in pixels, of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The height, in pixels, of this <see cref="T:System.Drawing.Image" />.</returns>
		[DefaultValue(false)]
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public int Height
		{
			get
			{
				int height;
				int num = SafeNativeMethods.Gdip.GdipGetImageHeight(new HandleRef(this, nativeImage), out height);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return height;
			}
		}

		/// <summary>Gets the horizontal resolution, in pixels per inch, of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The horizontal resolution, in pixels per inch, of this <see cref="T:System.Drawing.Image" />.</returns>
		public float HorizontalResolution
		{
			get
			{
				float horzRes;
				int num = SafeNativeMethods.Gdip.GdipGetImageHorizontalResolution(new HandleRef(this, nativeImage), out horzRes);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return horzRes;
			}
		}

		/// <summary>Gets the vertical resolution, in pixels per inch, of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The vertical resolution, in pixels per inch, of this <see cref="T:System.Drawing.Image" />.</returns>
		public float VerticalResolution
		{
			get
			{
				float vertRes;
				int num = SafeNativeMethods.Gdip.GdipGetImageVerticalResolution(new HandleRef(this, nativeImage), out vertRes);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return vertRes;
			}
		}

		/// <summary>Gets attribute flags for the pixel data of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The integer representing a bitwise combination of <see cref="T:System.Drawing.Imaging.ImageFlags" /> for this <see cref="T:System.Drawing.Image" />.</returns>
		[Browsable(false)]
		public int Flags
		{
			get
			{
				int flags;
				int num = SafeNativeMethods.Gdip.GdipGetImageFlags(new HandleRef(this, nativeImage), out flags);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return flags;
			}
		}

		/// <summary>Gets the file format of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Imaging.ImageFormat" /> that represents the file format of this <see cref="T:System.Drawing.Image" />.</returns>
		public ImageFormat RawFormat
		{
			get
			{
				Guid format = default(Guid);
				int num = SafeNativeMethods.Gdip.GdipGetImageRawFormat(new HandleRef(this, nativeImage), ref format);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return new ImageFormat(format);
			}
		}

		/// <summary>Gets the pixel format for this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Imaging.PixelFormat" /> that represents the pixel format for this <see cref="T:System.Drawing.Image" />.</returns>
		public PixelFormat PixelFormat
		{
			get
			{
				if (SafeNativeMethods.Gdip.GdipGetImagePixelFormat(new HandleRef(this, nativeImage), out var format) != 0)
				{
					return PixelFormat.Undefined;
				}
				return (PixelFormat)format;
			}
		}

		/// <summary>Gets or sets the color palette used for this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Imaging.ColorPalette" /> that represents the color palette used for this <see cref="T:System.Drawing.Image" />.</returns>
		[Browsable(false)]
		public ColorPalette Palette
		{
			get
			{
				return _GetColorPalette();
			}
			set
			{
				_SetColorPalette(value);
			}
		}

		/// <summary>Gets an array of GUIDs that represent the dimensions of frames within this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>An array of GUIDs that specify the dimensions of frames within this <see cref="T:System.Drawing.Image" /> from most significant to least significant.</returns>
		[Browsable(false)]
		public Guid[] FrameDimensionsList
		{
			get
			{
				int num = SafeNativeMethods.Gdip.GdipImageGetFrameDimensionsCount(new HandleRef(this, nativeImage), out var count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				if (count <= 0)
				{
					return new Guid[0];
				}
				int num2 = Marshal.SizeOf(typeof(Guid));
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * count));
				if (intPtr == IntPtr.Zero)
				{
					throw SafeNativeMethods.Gdip.StatusException(3);
				}
				num = SafeNativeMethods.Gdip.GdipImageGetFrameDimensionsList(new HandleRef(this, nativeImage), intPtr, count);
				if (num != 0)
				{
					Marshal.FreeHGlobal(intPtr);
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Guid[] array = new Guid[count];
				try
				{
					for (int i = 0; i < count; i++)
					{
						array[i] = (Guid)UnsafeNativeMethods.PtrToStructure((IntPtr)((long)intPtr + num2 * i), typeof(Guid));
					}
					return array;
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		/// <summary>Gets IDs of the property items stored in this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>An array of the property IDs, one for each property item stored in this image.</returns>
		[Browsable(false)]
		public int[] PropertyIdList
		{
			get
			{
				int num = SafeNativeMethods.Gdip.GdipGetPropertyCount(new HandleRef(this, nativeImage), out var count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				int[] array = new int[count];
				if (count == 0)
				{
					return array;
				}
				num = SafeNativeMethods.Gdip.GdipGetPropertyIdList(new HandleRef(this, nativeImage), count, array);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array;
			}
		}

		/// <summary>Gets all the property items (pieces of metadata) stored in this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.Imaging.PropertyItem" /> objects, one for each property item stored in the image.</returns>
		[Browsable(false)]
		public PropertyItem[] PropertyItems
		{
			get
			{
				int num = SafeNativeMethods.Gdip.GdipGetPropertyCount(new HandleRef(this, nativeImage), out var count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				num = SafeNativeMethods.Gdip.GdipGetPropertySize(new HandleRef(this, nativeImage), out var totalSize, ref count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				if (totalSize == 0 || count == 0)
				{
					return new PropertyItem[0];
				}
				IntPtr intPtr = Marshal.AllocHGlobal(totalSize);
				num = SafeNativeMethods.Gdip.GdipGetAllPropertyItems(new HandleRef(this, nativeImage), totalSize, count, intPtr);
				PropertyItem[] array = null;
				try
				{
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					return PropertyItemInternal.ConvertFromMemory(intPtr, count);
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		internal Image()
		{
		}

		internal Image(SerializationInfo info, StreamingContext context)
		{
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			if (enumerator == null)
			{
				return;
			}
			while (enumerator.MoveNext())
			{
				if (!string.Equals(enumerator.Name, "Data", StringComparison.OrdinalIgnoreCase))
				{
					continue;
				}
				try
				{
					byte[] array = (byte[])enumerator.Value;
					if (array != null)
					{
						InitializeFromStream(new MemoryStream(array));
					}
				}
				catch (ExternalException)
				{
				}
				catch (ArgumentException)
				{
				}
				catch (OutOfMemoryException)
				{
				}
				catch (InvalidOperationException)
				{
				}
				catch (NotImplementedException)
				{
				}
				catch (FileNotFoundException)
				{
				}
			}
		}

		/// <summary>Creates an <see cref="T:System.Drawing.Image" /> from the specified file.</summary>
		/// <param name="filename">A string that contains the name of the file from which to create the <see cref="T:System.Drawing.Image" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates.</returns>
		/// <exception cref="T:System.OutOfMemoryException">The file does not have a valid image format.  
		///  -or-  
		///  GDI+ does not support the pixel format of the file.</exception>
		/// <exception cref="T:System.IO.FileNotFoundException">The specified file does not exist.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="filename" /> is a <see cref="T:System.Uri" />.</exception>
		public static Image FromFile(string filename)
		{
			return FromFile(filename, useEmbeddedColorManagement: false);
		}

		/// <summary>Creates an <see cref="T:System.Drawing.Image" /> from the specified file using embedded color management information in that file.</summary>
		/// <param name="filename">A string that contains the name of the file from which to create the <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="useEmbeddedColorManagement">Set to <see langword="true" /> to use color management information embedded in the image file; otherwise, <see langword="false" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates.</returns>
		/// <exception cref="T:System.OutOfMemoryException">The file does not have a valid image format.  
		///  -or-  
		///  GDI+ does not support the pixel format of the file.</exception>
		/// <exception cref="T:System.IO.FileNotFoundException">The specified file does not exist.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="filename" /> is a <see cref="T:System.Uri" />.</exception>
		public static Image FromFile(string filename, bool useEmbeddedColorManagement)
		{
			if (!File.Exists(filename))
			{
				IntSecurity.DemandReadFileIO(filename);
				throw new FileNotFoundException(filename);
			}
			filename = Path.GetFullPath(filename);
			IntPtr image = IntPtr.Zero;
			int num = ((!useEmbeddedColorManagement) ? SafeNativeMethods.Gdip.GdipLoadImageFromFile(filename, out image) : SafeNativeMethods.Gdip.GdipLoadImageFromFileICM(filename, out image));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, image));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, image));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			Image image2 = CreateImageObject(image);
			EnsureSave(image2, filename, null);
			return image2;
		}

		/// <summary>Creates an <see cref="T:System.Drawing.Image" /> from the specified data stream.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Image" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The stream does not have a valid image format  
		///  -or-  
		///  <paramref name="stream" /> is <see langword="null" />.</exception>
		public static Image FromStream(Stream stream)
		{
			return FromStream(stream, useEmbeddedColorManagement: false);
		}

		/// <summary>Creates an <see cref="T:System.Drawing.Image" /> from the specified data stream, optionally using embedded color management information in that stream.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="useEmbeddedColorManagement">
		///   <see langword="true" /> to use color management information embedded in the data stream; otherwise, <see langword="false" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The stream does not have a valid image format  
		///  -or-  
		///  <paramref name="stream" /> is <see langword="null" />.</exception>
		public static Image FromStream(Stream stream, bool useEmbeddedColorManagement)
		{
			return FromStream(stream, useEmbeddedColorManagement, validateImageData: true);
		}

		/// <summary>Creates an <see cref="T:System.Drawing.Image" /> from the specified data stream, optionally using embedded color management information and validating the image data.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="useEmbeddedColorManagement">
		///   <see langword="true" /> to use color management information embedded in the data stream; otherwise, <see langword="false" />.</param>
		/// <param name="validateImageData">
		///   <see langword="true" /> to validate the image data; otherwise, <see langword="false" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The stream does not have a valid image format.</exception>
		public static Image FromStream(Stream stream, bool useEmbeddedColorManagement, bool validateImageData)
		{
			if (!validateImageData)
			{
				IntSecurity.UnmanagedCode.Demand();
			}
			if (stream == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "stream", "null"));
			}
			IntPtr image = IntPtr.Zero;
			int num = ((!useEmbeddedColorManagement) ? SafeNativeMethods.Gdip.GdipLoadImageFromStream(new GPStream(stream), out image) : SafeNativeMethods.Gdip.GdipLoadImageFromStreamICM(new GPStream(stream), out image));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (validateImageData)
			{
				num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, image));
				if (num != 0)
				{
					SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, image));
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			Image image2 = CreateImageObject(image);
			EnsureSave(image2, null, stream);
			return image2;
		}

		private void InitializeFromStream(Stream stream)
		{
			IntPtr image = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipLoadImageFromStream(new GPStream(stream), out image);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, image));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, image));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeImage = image;
			int type = -1;
			num = SafeNativeMethods.Gdip.GdipGetImageType(new HandleRef(this, nativeImage), out type);
			EnsureSave(this, null, stream);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		internal Image(IntPtr nativeImage)
		{
			SetNativeImage(nativeImage);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Image" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Image" /> this method creates, cast as an object.</returns>
		public object Clone()
		{
			IntPtr cloneimage = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneImage(new HandleRef(this, nativeImage), out cloneimage);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipImageForceValidation(new HandleRef(null, cloneimage));
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(null, cloneimage));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CreateImageObject(cloneimage);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Image" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.Drawing.Image" /> and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///   <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected virtual void Dispose(bool disposing)
		{
			if (!(nativeImage != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDisposeImage(new HandleRef(this, nativeImage));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeImage = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Image()
		{
			Dispose(disposing: false);
		}

		internal static void EnsureSave(Image image, string filename, Stream dataStream)
		{
			if (!image.RawFormat.Equals(ImageFormat.Gif))
			{
				return;
			}
			bool flag = false;
			Guid[] frameDimensionsList = image.FrameDimensionsList;
			Guid[] array = frameDimensionsList;
			foreach (Guid guid in array)
			{
				FrameDimension frameDimension = new FrameDimension(guid);
				if (frameDimension.Equals(FrameDimension.Time))
				{
					flag = image.GetFrameCount(FrameDimension.Time) > 1;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
			try
			{
				Stream stream = null;
				long position = 0L;
				if (dataStream != null)
				{
					position = dataStream.Position;
					dataStream.Position = 0L;
				}
				try
				{
					if (dataStream == null)
					{
						stream = (dataStream = File.OpenRead(filename));
					}
					image.rawData = new byte[(int)dataStream.Length];
					dataStream.Read(image.rawData, 0, (int)dataStream.Length);
				}
				finally
				{
					if (stream != null)
					{
						stream.Close();
					}
					else
					{
						dataStream.Position = position;
					}
				}
			}
			catch (UnauthorizedAccessException)
			{
			}
			catch (DirectoryNotFoundException)
			{
			}
			catch (IOException)
			{
			}
			catch (NotSupportedException)
			{
			}
			catch (ObjectDisposedException)
			{
			}
			catch (ArgumentException)
			{
			}
		}

		internal static Image CreateImageObject(IntPtr nativeImage)
		{
			int type = -1;
			int num = SafeNativeMethods.Gdip.GdipGetImageType(new HandleRef(null, nativeImage), out type);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return type switch
			{
				1 => Bitmap.FromGDIplus(nativeImage), 
				2 => Metafile.FromGDIplus(nativeImage), 
				_ => throw new ArgumentException(SR.GetString("InvalidImage")), 
			};
		}

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.</summary>
		/// <param name="si">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Save(memoryStream);
			si.AddValue("Data", memoryStream.ToArray(), typeof(byte[]));
		}

		/// <summary>Returns information about the parameters supported by the specified image encoder.</summary>
		/// <param name="encoder">A GUID that specifies the image encoder.</param>
		/// <returns>An <see cref="T:System.Drawing.Imaging.EncoderParameters" /> that contains an array of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects. Each <see cref="T:System.Drawing.Imaging.EncoderParameter" /> contains information about one of the parameters supported by the specified image encoder.</returns>
		public EncoderParameters GetEncoderParameterList(Guid encoder)
		{
			int num = SafeNativeMethods.Gdip.GdipGetEncoderParameterListSize(new HandleRef(this, nativeImage), ref encoder, out var size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (size <= 0)
			{
				return null;
			}
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			num = SafeNativeMethods.Gdip.GdipGetEncoderParameterList(new HandleRef(this, nativeImage), ref encoder, size, intPtr);
			try
			{
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return EncoderParameters.ConvertFromMemory(intPtr);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Saves this <see cref="T:System.Drawing.Image" /> to the specified file or stream.</summary>
		/// <param name="filename">A string that contains the name of the file to which to save this <see cref="T:System.Drawing.Image" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="filename" /> is <see langword="null." /></exception>
		/// <exception cref="T:System.Runtime.InteropServices.ExternalException">The image was saved with the wrong image format.  
		///  -or-  
		///  The image was saved to the same file it was created from.</exception>
		public void Save(string filename)
		{
			Save(filename, RawFormat);
		}

		/// <summary>Saves this <see cref="T:System.Drawing.Image" /> to the specified file in the specified format.</summary>
		/// <param name="filename">A string that contains the name of the file to which to save this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="format">The <see cref="T:System.Drawing.Imaging.ImageFormat" /> for this <see cref="T:System.Drawing.Image" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="filename" /> or <paramref name="format" /> is <see langword="null." /></exception>
		/// <exception cref="T:System.Runtime.InteropServices.ExternalException">The image was saved with the wrong image format.  
		///  -or-  
		///  The image was saved to the same file it was created from.</exception>
		public void Save(string filename, ImageFormat format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			ImageCodecInfo imageCodecInfo = format.FindEncoder();
			if (imageCodecInfo == null)
			{
				imageCodecInfo = ImageFormat.Png.FindEncoder();
			}
			Save(filename, imageCodecInfo, null);
		}

		/// <summary>Saves this <see cref="T:System.Drawing.Image" /> to the specified file, with the specified encoder and image-encoder parameters.</summary>
		/// <param name="filename">A string that contains the name of the file to which to save this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="encoder">The <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> for this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="encoderParams">An <see cref="T:System.Drawing.Imaging.EncoderParameters" /> to use for this <see cref="T:System.Drawing.Image" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="filename" /> or <paramref name="encoder" /> is <see langword="null." /></exception>
		/// <exception cref="T:System.Runtime.InteropServices.ExternalException">The image was saved with the wrong image format.  
		///  -or-  
		///  The image was saved to the same file it was created from.</exception>
		public void Save(string filename, ImageCodecInfo encoder, EncoderParameters encoderParams)
		{
			if (filename == null)
			{
				throw new ArgumentNullException("filename");
			}
			if (encoder == null)
			{
				throw new ArgumentNullException("encoder");
			}
			IntSecurity.DemandWriteFileIO(filename);
			IntPtr intPtr = IntPtr.Zero;
			if (encoderParams != null)
			{
				rawData = null;
				intPtr = encoderParams.ConvertToMemory();
			}
			int num = 0;
			try
			{
				Guid classId = encoder.Clsid;
				bool flag = false;
				if (rawData != null)
				{
					ImageCodecInfo imageCodecInfo = RawFormat.FindEncoder();
					if (imageCodecInfo != null && imageCodecInfo.Clsid == classId)
					{
						using FileStream fileStream = File.OpenWrite(filename);
						fileStream.Write(rawData, 0, rawData.Length);
						flag = true;
					}
				}
				if (!flag)
				{
					num = SafeNativeMethods.Gdip.GdipSaveImageToFile(new HandleRef(this, nativeImage), filename, ref classId, new HandleRef(encoderParams, intPtr));
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		internal void Save(MemoryStream stream)
		{
			ImageFormat imageFormat = RawFormat;
			if (imageFormat == ImageFormat.Jpeg)
			{
				imageFormat = ImageFormat.Png;
			}
			ImageCodecInfo imageCodecInfo = imageFormat.FindEncoder();
			if (imageCodecInfo == null)
			{
				imageCodecInfo = ImageFormat.Png.FindEncoder();
			}
			Save(stream, imageCodecInfo, null);
		}

		/// <summary>Saves this image to the specified stream in the specified format.</summary>
		/// <param name="stream">The <see cref="T:System.IO.Stream" /> where the image will be saved.</param>
		/// <param name="format">An <see cref="T:System.Drawing.Imaging.ImageFormat" /> that specifies the format of the saved image.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="stream" /> or <paramref name="format" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Runtime.InteropServices.ExternalException">The image was saved with the wrong image format</exception>
		public void Save(Stream stream, ImageFormat format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			ImageCodecInfo encoder = format.FindEncoder();
			Save(stream, encoder, null);
		}

		/// <summary>Saves this image to the specified stream, with the specified encoder and image encoder parameters.</summary>
		/// <param name="stream">The <see cref="T:System.IO.Stream" /> where the image will be saved.</param>
		/// <param name="encoder">The <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> for this <see cref="T:System.Drawing.Image" />.</param>
		/// <param name="encoderParams">An <see cref="T:System.Drawing.Imaging.EncoderParameters" /> that specifies parameters used by the image encoder.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="stream" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Runtime.InteropServices.ExternalException">The image was saved with the wrong image format.</exception>
		public void Save(Stream stream, ImageCodecInfo encoder, EncoderParameters encoderParams)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
			if (encoder == null)
			{
				throw new ArgumentNullException("encoder");
			}
			IntPtr intPtr = IntPtr.Zero;
			if (encoderParams != null)
			{
				rawData = null;
				intPtr = encoderParams.ConvertToMemory();
			}
			int num = 0;
			try
			{
				Guid classId = encoder.Clsid;
				bool flag = false;
				if (rawData != null)
				{
					ImageCodecInfo imageCodecInfo = RawFormat.FindEncoder();
					if (imageCodecInfo != null && imageCodecInfo.Clsid == classId)
					{
						stream.Write(rawData, 0, rawData.Length);
						flag = true;
					}
				}
				if (!flag)
				{
					num = SafeNativeMethods.Gdip.GdipSaveImageToStream(new HandleRef(this, nativeImage), new UnsafeNativeMethods.ComStreamFromDataStream(stream), ref classId, new HandleRef(encoderParams, intPtr));
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a frame to the file or stream specified in a previous call to the <see cref="Overload:System.Drawing.Image.Save" /> method. Use this method to save selected frames from a multiple-frame image to another multiple-frame image.</summary>
		/// <param name="encoderParams">An <see cref="T:System.Drawing.Imaging.EncoderParameters" /> that holds parameters required by the image encoder that is used by the save-add operation.</param>
		public void SaveAdd(EncoderParameters encoderParams)
		{
			IntPtr intPtr = IntPtr.Zero;
			if (encoderParams != null)
			{
				intPtr = encoderParams.ConvertToMemory();
			}
			rawData = null;
			int num = SafeNativeMethods.Gdip.GdipSaveAdd(new HandleRef(this, nativeImage), new HandleRef(encoderParams, intPtr));
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a frame to the file or stream specified in a previous call to the <see cref="Overload:System.Drawing.Image.Save" /> method.</summary>
		/// <param name="image">An <see cref="T:System.Drawing.Image" /> that contains the frame to add.</param>
		/// <param name="encoderParams">An <see cref="T:System.Drawing.Imaging.EncoderParameters" /> that holds parameters required by the image encoder that is used by the save-add operation.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="image" /> is <see langword="null" />.</exception>
		public void SaveAdd(Image image, EncoderParameters encoderParams)
		{
			IntPtr intPtr = IntPtr.Zero;
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (encoderParams != null)
			{
				intPtr = encoderParams.ConvertToMemory();
			}
			rawData = null;
			int num = SafeNativeMethods.Gdip.GdipSaveAddImage(new HandleRef(this, nativeImage), new HandleRef(image, image.nativeImage), new HandleRef(encoderParams, intPtr));
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private SizeF _GetPhysicalDimension()
		{
			float width;
			float height;
			int num = SafeNativeMethods.Gdip.GdipGetImageDimension(new HandleRef(this, nativeImage), out width, out height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new SizeF(width, height);
		}

		/// <summary>Gets the bounds of the image in the specified unit.</summary>
		/// <param name="pageUnit">One of the <see cref="T:System.Drawing.GraphicsUnit" /> values indicating the unit of measure for the bounding rectangle.</param>
		/// <returns>The <see cref="T:System.Drawing.RectangleF" /> that represents the bounds of the image, in the specified unit.</returns>
		public RectangleF GetBounds(ref GraphicsUnit pageUnit)
		{
			GPRECTF gprectf = default(GPRECTF);
			int num = SafeNativeMethods.Gdip.GdipGetImageBounds(new HandleRef(this, nativeImage), ref gprectf, out pageUnit);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gprectf.ToRectangleF();
		}

		private ColorPalette _GetColorPalette()
		{
			int size = -1;
			int num = SafeNativeMethods.Gdip.GdipGetImagePaletteSize(new HandleRef(this, nativeImage), out size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			ColorPalette colorPalette = new ColorPalette(size);
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			num = SafeNativeMethods.Gdip.GdipGetImagePalette(new HandleRef(this, nativeImage), intPtr, size);
			try
			{
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				colorPalette.ConvertFromMemory(intPtr);
				return colorPalette;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		private void _SetColorPalette(ColorPalette palette)
		{
			IntPtr intPtr = palette.ConvertToMemory();
			int num = SafeNativeMethods.Gdip.GdipSetImagePalette(new HandleRef(this, nativeImage), intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Returns a thumbnail for this <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="thumbWidth">The width, in pixels, of the requested thumbnail image.</param>
		/// <param name="thumbHeight">The height, in pixels, of the requested thumbnail image.</param>
		/// <param name="callback">A <see cref="T:System.Drawing.Image.GetThumbnailImageAbort" /> delegate.  
		///  Note You must create a delegate and pass a reference to the delegate as the <paramref name="callback" /> parameter, but the delegate is not used.</param>
		/// <param name="callbackData">Must be <see cref="F:System.IntPtr.Zero" />.</param>
		/// <returns>An <see cref="T:System.Drawing.Image" /> that represents the thumbnail.</returns>
		public Image GetThumbnailImage(int thumbWidth, int thumbHeight, GetThumbnailImageAbort callback, IntPtr callbackData)
		{
			IntPtr thumbImage = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetImageThumbnail(new HandleRef(this, nativeImage), thumbWidth, thumbHeight, out thumbImage, callback, callbackData);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CreateImageObject(thumbImage);
		}

		/// <summary>Returns the number of frames of the specified dimension.</summary>
		/// <param name="dimension">A <see cref="T:System.Drawing.Imaging.FrameDimension" /> that specifies the identity of the dimension type.</param>
		/// <returns>The number of frames in the specified dimension.</returns>
		public int GetFrameCount(FrameDimension dimension)
		{
			int[] array = new int[1];
			Guid dimensionID = dimension.Guid;
			int num = SafeNativeMethods.Gdip.GdipImageGetFrameCount(new HandleRef(this, nativeImage), ref dimensionID, array);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return array[0];
		}

		/// <summary>Selects the frame specified by the dimension and index.</summary>
		/// <param name="dimension">A <see cref="T:System.Drawing.Imaging.FrameDimension" /> that specifies the identity of the dimension type.</param>
		/// <param name="frameIndex">The index of the active frame.</param>
		/// <returns>Always returns 0.</returns>
		public int SelectActiveFrame(FrameDimension dimension, int frameIndex)
		{
			int[] array = new int[1];
			Guid dimensionID = dimension.Guid;
			int num = SafeNativeMethods.Gdip.GdipImageSelectActiveFrame(new HandleRef(this, nativeImage), ref dimensionID, frameIndex);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return array[0];
		}

		/// <summary>Rotates, flips, or rotates and flips the <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="rotateFlipType">A <see cref="T:System.Drawing.RotateFlipType" /> member that specifies the type of rotation and flip to apply to the image.</param>
		public void RotateFlip(RotateFlipType rotateFlipType)
		{
			int num = SafeNativeMethods.Gdip.GdipImageRotateFlip(new HandleRef(this, nativeImage), (int)rotateFlipType);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Gets the specified property item from this <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="propid">The ID of the property item to get.</param>
		/// <returns>The <see cref="T:System.Drawing.Imaging.PropertyItem" /> this method gets.</returns>
		/// <exception cref="T:System.ArgumentException">The image format of this image does not support property items.</exception>
		public PropertyItem GetPropertyItem(int propid)
		{
			int num = SafeNativeMethods.Gdip.GdipGetPropertyItemSize(new HandleRef(this, nativeImage), propid, out var size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (size == 0)
			{
				return null;
			}
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			if (intPtr == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			num = SafeNativeMethods.Gdip.GdipGetPropertyItem(new HandleRef(this, nativeImage), propid, size, intPtr);
			try
			{
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return PropertyItemInternal.ConvertFromMemory(intPtr, 1)[0];
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Removes the specified property item from this <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="propid">The ID of the property item to remove.</param>
		/// <exception cref="T:System.ArgumentException">The image does not contain the requested property item.  
		///  -or-  
		///  The image format for this image does not support property items.</exception>
		public void RemovePropertyItem(int propid)
		{
			int num = SafeNativeMethods.Gdip.GdipRemovePropertyItem(new HandleRef(this, nativeImage), propid);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Stores a property item (piece of metadata) in this <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="propitem">The <see cref="T:System.Drawing.Imaging.PropertyItem" /> to be stored.</param>
		/// <exception cref="T:System.ArgumentException">The image format of this image does not support property items.</exception>
		public void SetPropertyItem(PropertyItem propitem)
		{
			PropertyItemInternal propertyItemInternal = PropertyItemInternal.ConvertFromPropertyItem(propitem);
			using (propertyItemInternal)
			{
				int num = SafeNativeMethods.Gdip.GdipSetPropertyItem(new HandleRef(this, nativeImage), propertyItemInternal);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		internal void SetNativeImage(IntPtr handle)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentException(SR.GetString("NativeHandle0"), "handle");
			}
			nativeImage = handle;
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Bitmap" /> from a handle to a GDI bitmap.</summary>
		/// <param name="hbitmap">The GDI bitmap handle from which to create the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Bitmap" /> this method creates.</returns>
		public static Bitmap FromHbitmap(IntPtr hbitmap)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			return FromHbitmap(hbitmap, IntPtr.Zero);
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Bitmap" /> from a handle to a GDI bitmap and a handle to a GDI palette.</summary>
		/// <param name="hbitmap">The GDI bitmap handle from which to create the <see cref="T:System.Drawing.Bitmap" />.</param>
		/// <param name="hpalette">A handle to a GDI palette used to define the bitmap colors if the bitmap specified in the <paramref name="hbitmap" /> parameter is not a device-independent bitmap (DIB).</param>
		/// <returns>The <see cref="T:System.Drawing.Bitmap" /> this method creates.</returns>
		public static Bitmap FromHbitmap(IntPtr hbitmap, IntPtr hpalette)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr bitmap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateBitmapFromHBITMAP(new HandleRef(null, hbitmap), new HandleRef(null, hpalette), out bitmap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return Bitmap.FromGDIplus(bitmap);
		}

		/// <summary>Returns the color depth, in number of bits per pixel, of the specified pixel format.</summary>
		/// <param name="pixfmt">The <see cref="T:System.Drawing.Imaging.PixelFormat" /> member that specifies the format for which to find the size.</param>
		/// <returns>The color depth of the specified pixel format.</returns>
		public static int GetPixelFormatSize(PixelFormat pixfmt)
		{
			return ((int)pixfmt >> 8) & 0xFF;
		}

		/// <summary>Returns a value that indicates whether the pixel format for this <see cref="T:System.Drawing.Image" /> contains alpha information.</summary>
		/// <param name="pixfmt">The <see cref="T:System.Drawing.Imaging.PixelFormat" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="pixfmt" /> contains alpha information; otherwise, <see langword="false" />.</returns>
		public static bool IsAlphaPixelFormat(PixelFormat pixfmt)
		{
			return (pixfmt & PixelFormat.Alpha) != 0;
		}

		/// <summary>Returns a value that indicates whether the pixel format is 64 bits per pixel.</summary>
		/// <param name="pixfmt">The <see cref="T:System.Drawing.Imaging.PixelFormat" /> enumeration to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="pixfmt" /> is extended; otherwise, <see langword="false" />.</returns>
		public static bool IsExtendedPixelFormat(PixelFormat pixfmt)
		{
			return (pixfmt & PixelFormat.Extended) != 0;
		}

		/// <summary>Returns a value that indicates whether the pixel format is 32 bits per pixel.</summary>
		/// <param name="pixfmt">The <see cref="T:System.Drawing.Imaging.PixelFormat" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="pixfmt" /> is canonical; otherwise, <see langword="false" />.</returns>
		public static bool IsCanonicalPixelFormat(PixelFormat pixfmt)
		{
			return (pixfmt & PixelFormat.Canonical) != 0;
		}
	}
	/// <summary>Animates an image that has time-based frames.</summary>
	public sealed class ImageAnimator
	{
		private class ImageInfo
		{
			private const int PropertyTagFrameDelay = 20736;

			private Image image;

			private int frame;

			private int frameCount;

			private bool frameDirty;

			private bool animated;

			private EventHandler onFrameChangedHandler;

			private int[] frameDelay;

			private int frameTimer;

			public bool Animated => animated;

			public int Frame
			{
				get
				{
					return frame;
				}
				set
				{
					if (frame != value)
					{
						if (value < 0 || value >= FrameCount)
						{
							throw new ArgumentException(SR.GetString("InvalidFrame"), "value");
						}
						if (Animated)
						{
							frame = value;
							frameDirty = true;
							OnFrameChanged(EventArgs.Empty);
						}
					}
				}
			}

			public bool FrameDirty => frameDirty;

			public EventHandler FrameChangedHandler
			{
				get
				{
					return onFrameChangedHandler;
				}
				set
				{
					onFrameChangedHandler = value;
				}
			}

			public int FrameCount => frameCount;

			internal int FrameTimer
			{
				get
				{
					return frameTimer;
				}
				set
				{
					frameTimer = value;
				}
			}

			internal Image Image => image;

			public ImageInfo(Image image)
			{
				this.image = image;
				animated = CanAnimate(image);
				if (animated)
				{
					frameCount = image.GetFrameCount(FrameDimension.Time);
					PropertyItem propertyItem = image.GetPropertyItem(20736);
					if (propertyItem != null)
					{
						byte[] value = propertyItem.Value;
						frameDelay = new int[FrameCount];
						for (int i = 0; i < FrameCount; i++)
						{
							frameDelay[i] = value[i * 4] + 256 * value[i * 4 + 1] + 65536 * value[i * 4 + 2] + 16777216 * value[i * 4 + 3];
						}
					}
				}
				else
				{
					frameCount = 1;
				}
				if (frameDelay == null)
				{
					frameDelay = new int[FrameCount];
				}
			}

			public int FrameDelay(int frame)
			{
				return frameDelay[frame];
			}

			internal void UpdateFrame()
			{
				if (frameDirty)
				{
					image.SelectActiveFrame(FrameDimension.Time, Frame);
					frameDirty = false;
				}
			}

			protected void OnFrameChanged(EventArgs e)
			{
				if (onFrameChangedHandler != null)
				{
					onFrameChangedHandler(image, e);
				}
			}
		}

		private static List<ImageInfo> imageInfoList;

		private static bool anyFrameDirty;

		private static Thread animationThread;

		private static ReaderWriterLock rwImgListLock = new ReaderWriterLock();

		[ThreadStatic]
		private static int threadWriterLockWaitCount;

		private ImageAnimator()
		{
		}

		/// <summary>Advances the frame in the specified image. The new frame is drawn the next time the image is rendered. This method applies only to images with time-based frames.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object for which to update frames.</param>
		public static void UpdateFrames(Image image)
		{
			if (!anyFrameDirty || image == null || imageInfoList == null || threadWriterLockWaitCount > 0)
			{
				return;
			}
			rwImgListLock.AcquireReaderLock(-1);
			try
			{
				bool flag = false;
				bool flag2 = false;
				foreach (ImageInfo imageInfo in imageInfoList)
				{
					if (imageInfo.Image == image)
					{
						if (imageInfo.FrameDirty)
						{
							lock (imageInfo.Image)
							{
								imageInfo.UpdateFrame();
							}
						}
						flag2 = true;
					}
					if (imageInfo.FrameDirty)
					{
						flag = true;
					}
					if (flag && flag2)
					{
						break;
					}
				}
				anyFrameDirty = flag;
			}
			finally
			{
				rwImgListLock.ReleaseReaderLock();
			}
		}

		/// <summary>Advances the frame in all images currently being animated. The new frame is drawn the next time the image is rendered.</summary>
		public static void UpdateFrames()
		{
			if (!anyFrameDirty || imageInfoList == null || threadWriterLockWaitCount > 0)
			{
				return;
			}
			rwImgListLock.AcquireReaderLock(-1);
			try
			{
				foreach (ImageInfo imageInfo in imageInfoList)
				{
					lock (imageInfo.Image)
					{
						imageInfo.UpdateFrame();
					}
				}
				anyFrameDirty = false;
			}
			finally
			{
				rwImgListLock.ReleaseReaderLock();
			}
		}

		/// <summary>Displays a multiple-frame image as an animation.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object to animate.</param>
		/// <param name="onFrameChangedHandler">An <see langword="EventHandler" /> object that specifies the method that is called when the animation frame changes.</param>
		public static void Animate(Image image, EventHandler onFrameChangedHandler)
		{
			if (image == null)
			{
				return;
			}
			ImageInfo imageInfo = null;
			lock (image)
			{
				imageInfo = new ImageInfo(image);
			}
			StopAnimate(image, onFrameChangedHandler);
			bool isReaderLockHeld = rwImgListLock.IsReaderLockHeld;
			LockCookie lockCookie = default(LockCookie);
			threadWriterLockWaitCount++;
			try
			{
				if (isReaderLockHeld)
				{
					lockCookie = rwImgListLock.UpgradeToWriterLock(-1);
				}
				else
				{
					rwImgListLock.AcquireWriterLock(-1);
				}
			}
			finally
			{
				threadWriterLockWaitCount--;
			}
			try
			{
				if (imageInfo.Animated)
				{
					if (imageInfoList == null)
					{
						imageInfoList = new List<ImageInfo>();
					}
					imageInfo.FrameChangedHandler = onFrameChangedHandler;
					imageInfoList.Add(imageInfo);
					if (animationThread == null)
					{
						animationThread = new Thread(AnimateImages50ms);
						animationThread.Name = typeof(ImageAnimator).Name;
						animationThread.IsBackground = true;
						animationThread.Start();
					}
				}
			}
			finally
			{
				if (isReaderLockHeld)
				{
					rwImgListLock.DowngradeFromWriterLock(ref lockCookie);
				}
				else
				{
					rwImgListLock.ReleaseWriterLock();
				}
			}
		}

		/// <summary>Returns a Boolean value indicating whether the specified image contains time-based frames.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified image contains time-based frames; otherwise, <see langword="false" />.</returns>
		public static bool CanAnimate(Image image)
		{
			if (image == null)
			{
				return false;
			}
			lock (image)
			{
				Guid[] frameDimensionsList = image.FrameDimensionsList;
				Guid[] array = frameDimensionsList;
				foreach (Guid guid in array)
				{
					FrameDimension frameDimension = new FrameDimension(guid);
					if (frameDimension.Equals(FrameDimension.Time))
					{
						return image.GetFrameCount(FrameDimension.Time) > 1;
					}
				}
			}
			return false;
		}

		/// <summary>Terminates a running animation.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object to stop animating.</param>
		/// <param name="onFrameChangedHandler">An <see langword="EventHandler" /> object that specifies the method that is called when the animation frame changes.</param>
		public static void StopAnimate(Image image, EventHandler onFrameChangedHandler)
		{
			if (image == null || imageInfoList == null)
			{
				return;
			}
			bool isReaderLockHeld = rwImgListLock.IsReaderLockHeld;
			LockCookie lockCookie = default(LockCookie);
			threadWriterLockWaitCount++;
			try
			{
				if (isReaderLockHeld)
				{
					lockCookie = rwImgListLock.UpgradeToWriterLock(-1);
				}
				else
				{
					rwImgListLock.AcquireWriterLock(-1);
				}
			}
			finally
			{
				threadWriterLockWaitCount--;
			}
			try
			{
				for (int i = 0; i < imageInfoList.Count; i++)
				{
					ImageInfo imageInfo = imageInfoList[i];
					if (image == imageInfo.Image)
					{
						if (onFrameChangedHandler == imageInfo.FrameChangedHandler || (onFrameChangedHandler != null && onFrameChangedHandler.Equals(imageInfo.FrameChangedHandler)))
						{
							imageInfoList.Remove(imageInfo);
						}
						break;
					}
				}
			}
			finally
			{
				if (isReaderLockHeld)
				{
					rwImgListLock.DowngradeFromWriterLock(ref lockCookie);
				}
				else
				{
					rwImgListLock.ReleaseWriterLock();
				}
			}
		}

		private static void AnimateImages50ms()
		{
			while (true)
			{
				rwImgListLock.AcquireReaderLock(-1);
				try
				{
					for (int i = 0; i < imageInfoList.Count; i++)
					{
						ImageInfo imageInfo = imageInfoList[i];
						imageInfo.FrameTimer += 5;
						if (imageInfo.FrameTimer >= imageInfo.FrameDelay(imageInfo.Frame))
						{
							imageInfo.FrameTimer = 0;
							if (imageInfo.Frame + 1 < imageInfo.FrameCount)
							{
								imageInfo.Frame++;
							}
							else
							{
								imageInfo.Frame = 0;
							}
							if (imageInfo.FrameDirty)
							{
								anyFrameDirty = true;
							}
						}
					}
				}
				finally
				{
					rwImgListLock.ReleaseReaderLock();
				}
				Thread.Sleep(50);
			}
		}
	}
	/// <summary>
	///   <see cref="T:System.Drawing.ImageConverter" /> is a class that can be used to convert <see cref="T:System.Drawing.Image" /> objects from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" /> object.</summary>
	public class ImageConverter : TypeConverter
	{
		private Type iconType = typeof(Icon);

		/// <summary>Determines whether this <see cref="T:System.Drawing.ImageConverter" /> can convert an instance of a specified type to an <see cref="T:System.Drawing.Image" />, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="sourceType">A <see cref="T:System.Type" /> that specifies the type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this <see cref="T:System.Drawing.ImageConverter" /> can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == iconType)
			{
				return true;
			}
			if (sourceType == typeof(byte[]))
			{
				return true;
			}
			if (sourceType == typeof(InstanceDescriptor))
			{
				return false;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Determines whether this <see cref="T:System.Drawing.ImageConverter" /> can convert an <see cref="T:System.Drawing.Image" /> to an instance of a specified type, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that specifies the type you want to convert to.</param>
		/// <returns>This method returns <see langword="true" /> if this <see cref="T:System.Drawing.ImageConverter" /> can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(byte[]))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts a specified object to an <see cref="T:System.Drawing.Image" />.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that holds information about a specific culture.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to be converted.</param>
		/// <returns>If this method succeeds, it returns the <see cref="T:System.Drawing.Image" /> that it created by converting the specified object. Otherwise, it throws an exception.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is Icon)
			{
				Icon icon = (Icon)value;
				return icon.ToBitmap();
			}
			if (value is byte[] array)
			{
				Stream stream = null;
				stream = GetBitmapStream(array);
				if (stream == null)
				{
					stream = new MemoryStream(array);
				}
				return Image.FromStream(stream);
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts an <see cref="T:System.Drawing.Image" /> (or an object that can be cast to an <see cref="T:System.Drawing.Image" />) to the specified type.</summary>
		/// <param name="context">A formatter context. This object can be used to get more information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> object that specifies formatting conventions used by a particular culture.</param>
		/// <param name="value">The <see cref="T:System.Drawing.Image" /> to convert.</param>
		/// <param name="destinationType">The <see cref="T:System.Type" /> to convert the <see cref="T:System.Drawing.Image" /> to.</param>
		/// <returns>This method returns the converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == typeof(string))
			{
				if (value != null)
				{
					Image image = (Image)value;
					return image.ToString();
				}
				return SR.GetString("toStringNone");
			}
			if (destinationType == typeof(byte[]))
			{
				if (value != null)
				{
					bool flag = false;
					MemoryStream memoryStream = null;
					Image image2 = null;
					try
					{
						memoryStream = new MemoryStream();
						image2 = (Image)value;
						if (image2.RawFormat.Equals(ImageFormat.Icon))
						{
							flag = true;
							image2 = new Bitmap(image2, image2.Width, image2.Height);
						}
						image2.Save(memoryStream);
					}
					finally
					{
						memoryStream?.Close();
						if (flag)
						{
							image2?.Dispose();
						}
					}
					return memoryStream?.ToArray();
				}
				return new byte[0];
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		private unsafe Stream GetBitmapStream(byte[] rawData)
		{
			try
			{
				try
				{
					fixed (byte* ptr = rawData)
					{
						IntPtr intPtr = (IntPtr)ptr;
						if (intPtr == IntPtr.Zero)
						{
							return null;
						}
						if (rawData.Length <= sizeof(SafeNativeMethods.OBJECTHEADER) || Marshal.ReadInt16(intPtr) != 7189)
						{
							return null;
						}
						SafeNativeMethods.OBJECTHEADER oBJECTHEADER = (SafeNativeMethods.OBJECTHEADER)Marshal.PtrToStructure(intPtr, typeof(SafeNativeMethods.OBJECTHEADER));
						if (rawData.Length <= oBJECTHEADER.headersize + 18)
						{
							return null;
						}
						string @string = Encoding.ASCII.GetString(rawData, oBJECTHEADER.headersize + 12, 6);
						if (@string != "PBrush")
						{
							return null;
						}
						byte[] bytes = Encoding.ASCII.GetBytes("BM");
						for (int i = oBJECTHEADER.headersize + 18; i < oBJECTHEADER.headersize + 510 && i + 1 < rawData.Length; i++)
						{
							if (bytes[0] == ptr[i] && bytes[1] == ptr[i + 1])
							{
								return new MemoryStream(rawData, i, rawData.Length - i);
							}
						}
					}
				}
				finally
				{
				}
			}
			catch (OutOfMemoryException)
			{
			}
			catch (ArgumentException)
			{
			}
			return null;
		}

		/// <summary>Gets the set of properties for this type.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <param name="value">The value of the object to get the properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>The set of properties that should be exposed for this data type. If no properties should be exposed, this can return <see langword="null" />. The default implementation always returns <see langword="null" />.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			return TypeDescriptor.GetProperties(typeof(Image), attributes);
		}

		/// <summary>Indicates whether this object supports properties. By default, this is <see langword="false" />.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if the <see cref="Overload:System.Drawing.ImageConverter.GetProperties" /> method should be called to find the properties of this object.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.ImageConverter" /> class.</summary>
		public ImageConverter()
		{
		}
	}
	internal static class IntSecurity
	{
		private static readonly UIPermission AllWindows = new UIPermission(UIPermissionWindow.AllWindows);

		private static readonly UIPermission SafeSubWindows = new UIPermission(UIPermissionWindow.SafeSubWindows);

		public static readonly CodeAccessPermission UnmanagedCode = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

		public static readonly CodeAccessPermission ObjectFromWin32Handle = UnmanagedCode;

		public static readonly CodeAccessPermission Win32HandleManipulation = UnmanagedCode;

		public static readonly PrintingPermission NoPrinting = new PrintingPermission(PrintingPermissionLevel.NoPrinting);

		public static readonly PrintingPermission SafePrinting = new PrintingPermission(PrintingPermissionLevel.SafePrinting);

		public static readonly PrintingPermission DefaultPrinting = new PrintingPermission(PrintingPermissionLevel.DefaultPrinting);

		public static readonly PrintingPermission AllPrinting = new PrintingPermission(PrintingPermissionLevel.AllPrinting);

		private static PermissionSet allPrintingAndUnmanagedCode;

		public static PermissionSet AllPrintingAndUnmanagedCode
		{
			get
			{
				if (allPrintingAndUnmanagedCode == null)
				{
					PermissionSet permissionSet = new PermissionSet(PermissionState.None);
					permissionSet.SetPermission(UnmanagedCode);
					permissionSet.SetPermission(AllPrinting);
					allPrintingAndUnmanagedCode = permissionSet;
				}
				return allPrintingAndUnmanagedCode;
			}
		}

		internal static void DemandReadFileIO(string fileName)
		{
			string text = fileName;
			text = UnsafeGetFullPath(fileName);
			new FileIOPermission(FileIOPermissionAccess.Read, text).Demand();
		}

		internal static void DemandWriteFileIO(string fileName)
		{
			string text = fileName;
			text = UnsafeGetFullPath(fileName);
			new FileIOPermission(FileIOPermissionAccess.Write, text).Demand();
		}

		internal static string UnsafeGetFullPath(string fileName)
		{
			FileIOPermission fileIOPermission = new FileIOPermission(PermissionState.None);
			fileIOPermission.AllFiles = FileIOPermissionAccess.PathDiscovery;
			fileIOPermission.Assert();
			try
			{
				return Path.GetFullPath(fileName);
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
		}

		internal static bool HasPermission(PrintingPermission permission)
		{
			try
			{
				permission.Demand();
				return true;
			}
			catch (SecurityException)
			{
				return false;
			}
		}
	}
	/// <summary>Specifies the known system colors.</summary>
	public enum KnownColor
	{
		/// <summary>The system-defined color of the active window's border.</summary>
		ActiveBorder = 1,
		/// <summary>The system-defined color of the background of the active window's title bar.</summary>
		ActiveCaption,
		/// <summary>The system-defined color of the text in the active window's title bar.</summary>
		ActiveCaptionText,
		/// <summary>The system-defined color of the application workspace. The application workspace is the area in a multiple-document view that is not being occupied by documents.</summary>
		AppWorkspace,
		/// <summary>The system-defined face color of a 3-D element.</summary>
		Control,
		/// <summary>The system-defined shadow color of a 3-D element. The shadow color is applied to parts of a 3-D element that face away from the light source.</summary>
		ControlDark,
		/// <summary>The system-defined color that is the dark shadow color of a 3-D element. The dark shadow color is applied to the parts of a 3-D element that are the darkest color.</summary>
		ControlDarkDark,
		/// <summary>The system-defined color that is the light color of a 3-D element. The light color is applied to parts of a 3-D element that face the light source.</summary>
		ControlLight,
		/// <summary>The system-defined highlight color of a 3-D element. The highlight color is applied to the parts of a 3-D element that are the lightest color.</summary>
		ControlLightLight,
		/// <summary>The system-defined color of text in a 3-D element.</summary>
		ControlText,
		/// <summary>The system-defined color of the desktop.</summary>
		Desktop,
		/// <summary>The system-defined color of dimmed text. Items in a list that are disabled are displayed in dimmed text.</summary>
		GrayText,
		/// <summary>The system-defined color of the background of selected items. This includes selected menu items as well as selected text.</summary>
		Highlight,
		/// <summary>The system-defined color of the text of selected items.</summary>
		HighlightText,
		/// <summary>The system-defined color used to designate a hot-tracked item. Single-clicking a hot-tracked item executes the item.</summary>
		HotTrack,
		/// <summary>The system-defined color of an inactive window's border.</summary>
		InactiveBorder,
		/// <summary>The system-defined color of the background of an inactive window's title bar.</summary>
		InactiveCaption,
		/// <summary>The system-defined color of the text in an inactive window's title bar.</summary>
		InactiveCaptionText,
		/// <summary>The system-defined color of the background of a ToolTip.</summary>
		Info,
		/// <summary>The system-defined color of the text of a ToolTip.</summary>
		InfoText,
		/// <summary>The system-defined color of a menu's background.</summary>
		Menu,
		/// <summary>The system-defined color of a menu's text.</summary>
		MenuText,
		/// <summary>The system-defined color of the background of a scroll bar.</summary>
		ScrollBar,
		/// <summary>The system-defined color of the background in the client area of a window.</summary>
		Window,
		/// <summary>The system-defined color of a window frame.</summary>
		WindowFrame,
		/// <summary>The system-defined color of the text in the client area of a window.</summary>
		WindowText,
		/// <summary>A system-defined color.</summary>
		Transparent,
		/// <summary>A system-defined color.</summary>
		AliceBlue,
		/// <summary>A system-defined color.</summary>
		AntiqueWhite,
		/// <summary>A system-defined color.</summary>
		Aqua,
		/// <summary>A system-defined color.</summary>
		Aquamarine,
		/// <summary>A system-defined color.</summary>
		Azure,
		/// <summary>A system-defined color.</summary>
		Beige,
		/// <summary>A system-defined color.</summary>
		Bisque,
		/// <summary>A system-defined color.</summary>
		Black,
		/// <summary>A system-defined color.</summary>
		BlanchedAlmond,
		/// <summary>A system-defined color.</summary>
		Blue,
		/// <summary>A system-defined color.</summary>
		BlueViolet,
		/// <summary>A system-defined color.</summary>
		Brown,
		/// <summary>A system-defined color.</summary>
		BurlyWood,
		/// <summary>A system-defined color.</summary>
		CadetBlue,
		/// <summary>A system-defined color.</summary>
		Chartreuse,
		/// <summary>A system-defined color.</summary>
		Chocolate,
		/// <summary>A system-defined color.</summary>
		Coral,
		/// <summary>A system-defined color.</summary>
		CornflowerBlue,
		/// <summary>A system-defined color.</summary>
		Cornsilk,
		/// <summary>A system-defined color.</summary>
		Crimson,
		/// <summary>A system-defined color.</summary>
		Cyan,
		/// <summary>A system-defined color.</summary>
		DarkBlue,
		/// <summary>A system-defined color.</summary>
		DarkCyan,
		/// <summary>A system-defined color.</summary>
		DarkGoldenrod,
		/// <summary>A system-defined color.</summary>
		DarkGray,
		/// <summary>A system-defined color.</summary>
		DarkGreen,
		/// <summary>A system-defined color.</summary>
		DarkKhaki,
		/// <summary>A system-defined color.</summary>
		DarkMagenta,
		/// <summary>A system-defined color.</summary>
		DarkOliveGreen,
		/// <summary>A system-defined color.</summary>
		DarkOrange,
		/// <summary>A system-defined color.</summary>
		DarkOrchid,
		/// <summary>A system-defined color.</summary>
		DarkRed,
		/// <summary>A system-defined color.</summary>
		DarkSalmon,
		/// <summary>A system-defined color.</summary>
		DarkSeaGreen,
		/// <summary>A system-defined color.</summary>
		DarkSlateBlue,
		/// <summary>A system-defined color.</summary>
		DarkSlateGray,
		/// <summary>A system-defined color.</summary>
		DarkTurquoise,
		/// <summary>A system-defined color.</summary>
		DarkViolet,
		/// <summary>A system-defined color.</summary>
		DeepPink,
		/// <summary>A system-defined color.</summary>
		DeepSkyBlue,
		/// <summary>A system-defined color.</summary>
		DimGray,
		/// <summary>A system-defined color.</summary>
		DodgerBlue,
		/// <summary>A system-defined color.</summary>
		Firebrick,
		/// <summary>A system-defined color.</summary>
		FloralWhite,
		/// <summary>A system-defined color.</summary>
		ForestGreen,
		/// <summary>A system-defined color.</summary>
		Fuchsia,
		/// <summary>A system-defined color.</summary>
		Gainsboro,
		/// <summary>A system-defined color.</summary>
		GhostWhite,
		/// <summary>A system-defined color.</summary>
		Gold,
		/// <summary>A system-defined color.</summary>
		Goldenrod,
		/// <summary>A system-defined color.</summary>
		Gray,
		/// <summary>A system-defined color.</summary>
		Green,
		/// <summary>A system-defined color.</summary>
		GreenYellow,
		/// <summary>A system-defined color.</summary>
		Honeydew,
		/// <summary>A system-defined color.</summary>
		HotPink,
		/// <summary>A system-defined color.</summary>
		IndianRed,
		/// <summary>A system-defined color.</summary>
		Indigo,
		/// <summary>A system-defined color.</summary>
		Ivory,
		/// <summary>A system-defined color.</summary>
		Khaki,
		/// <summary>A system-defined color.</summary>
		Lavender,
		/// <summary>A system-defined color.</summary>
		LavenderBlush,
		/// <summary>A system-defined color.</summary>
		LawnGreen,
		/// <summary>A system-defined color.</summary>
		LemonChiffon,
		/// <summary>A system-defined color.</summary>
		LightBlue,
		/// <summary>A system-defined color.</summary>
		LightCoral,
		/// <summary>A system-defined color.</summary>
		LightCyan,
		/// <summary>A system-defined color.</summary>
		LightGoldenrodYellow,
		/// <summary>A system-defined color.</summary>
		LightGray,
		/// <summary>A system-defined color.</summary>
		LightGreen,
		/// <summary>A system-defined color.</summary>
		LightPink,
		/// <summary>A system-defined color.</summary>
		LightSalmon,
		/// <summary>A system-defined color.</summary>
		LightSeaGreen,
		/// <summary>A system-defined color.</summary>
		LightSkyBlue,
		/// <summary>A system-defined color.</summary>
		LightSlateGray,
		/// <summary>A system-defined color.</summary>
		LightSteelBlue,
		/// <summary>A system-defined color.</summary>
		LightYellow,
		/// <summary>A system-defined color.</summary>
		Lime,
		/// <summary>A system-defined color.</summary>
		LimeGreen,
		/// <summary>A system-defined color.</summary>
		Linen,
		/// <summary>A system-defined color.</summary>
		Magenta,
		/// <summary>A system-defined color.</summary>
		Maroon,
		/// <summary>A system-defined color.</summary>
		MediumAquamarine,
		/// <summary>A system-defined color.</summary>
		MediumBlue,
		/// <summary>A system-defined color.</summary>
		MediumOrchid,
		/// <summary>A system-defined color.</summary>
		MediumPurple,
		/// <summary>A system-defined color.</summary>
		MediumSeaGreen,
		/// <summary>A system-defined color.</summary>
		MediumSlateBlue,
		/// <summary>A system-defined color.</summary>
		MediumSpringGreen,
		/// <summary>A system-defined color.</summary>
		MediumTurquoise,
		/// <summary>A system-defined color.</summary>
		MediumVioletRed,
		/// <summary>A system-defined color.</summary>
		MidnightBlue,
		/// <summary>A system-defined color.</summary>
		MintCream,
		/// <summary>A system-defined color.</summary>
		MistyRose,
		/// <summary>A system-defined color.</summary>
		Moccasin,
		/// <summary>A system-defined color.</summary>
		NavajoWhite,
		/// <summary>A system-defined color.</summary>
		Navy,
		/// <summary>A system-defined color.</summary>
		OldLace,
		/// <summary>A system-defined color.</summary>
		Olive,
		/// <summary>A system-defined color.</summary>
		OliveDrab,
		/// <summary>A system-defined color.</summary>
		Orange,
		/// <summary>A system-defined color.</summary>
		OrangeRed,
		/// <summary>A system-defined color.</summary>
		Orchid,
		/// <summary>A system-defined color.</summary>
		PaleGoldenrod,
		/// <summary>A system-defined color.</summary>
		PaleGreen,
		/// <summary>A system-defined color.</summary>
		PaleTurquoise,
		/// <summary>A system-defined color.</summary>
		PaleVioletRed,
		/// <summary>A system-defined color.</summary>
		PapayaWhip,
		/// <summary>A system-defined color.</summary>
		PeachPuff,
		/// <summary>A system-defined color.</summary>
		Peru,
		/// <summary>A system-defined color.</summary>
		Pink,
		/// <summary>A system-defined color.</summary>
		Plum,
		/// <summary>A system-defined color.</summary>
		PowderBlue,
		/// <summary>A system-defined color.</summary>
		Purple,
		/// <summary>A system-defined color.</summary>
		Red,
		/// <summary>A system-defined color.</summary>
		RosyBrown,
		/// <summary>A system-defined color.</summary>
		RoyalBlue,
		/// <summary>A system-defined color.</summary>
		SaddleBrown,
		/// <summary>A system-defined color.</summary>
		Salmon,
		/// <summary>A system-defined color.</summary>
		SandyBrown,
		/// <summary>A system-defined color.</summary>
		SeaGreen,
		/// <summary>A system-defined color.</summary>
		SeaShell,
		/// <summary>A system-defined color.</summary>
		Sienna,
		/// <summary>A system-defined color.</summary>
		Silver,
		/// <summary>A system-defined color.</summary>
		SkyBlue,
		/// <summary>A system-defined color.</summary>
		SlateBlue,
		/// <summary>A system-defined color.</summary>
		SlateGray,
		/// <summary>A system-defined color.</summary>
		Snow,
		/// <summary>A system-defined color.</summary>
		SpringGreen,
		/// <summary>A system-defined color.</summary>
		SteelBlue,
		/// <summary>A system-defined color.</summary>
		Tan,
		/// <summary>A system-defined color.</summary>
		Teal,
		/// <summary>A system-defined color.</summary>
		Thistle,
		/// <summary>A system-defined color.</summary>
		Tomato,
		/// <summary>A system-defined color.</summary>
		Turquoise,
		/// <summary>A system-defined color.</summary>
		Violet,
		/// <summary>A system-defined color.</summary>
		Wheat,
		/// <summary>A system-defined color.</summary>
		White,
		/// <summary>A system-defined color.</summary>
		WhiteSmoke,
		/// <summary>A system-defined color.</summary>
		Yellow,
		/// <summary>A system-defined color.</summary>
		YellowGreen,
		/// <summary>The system-defined face color of a 3-D element.</summary>
		ButtonFace,
		/// <summary>The system-defined color that is the highlight color of a 3-D element. This color is applied to parts of a 3-D element that face the light source.</summary>
		ButtonHighlight,
		/// <summary>The system-defined color that is the shadow color of a 3-D element. This color is applied to parts of a 3-D element that face away from the light source.</summary>
		ButtonShadow,
		/// <summary>The system-defined color of the lightest color in the color gradient of an active window's title bar.</summary>
		GradientActiveCaption,
		/// <summary>The system-defined color of the lightest color in the color gradient of an inactive window's title bar.</summary>
		GradientInactiveCaption,
		/// <summary>The system-defined color of the background of a menu bar.</summary>
		MenuBar,
		/// <summary>The system-defined color used to highlight menu items when the menu appears as a flat menu.</summary>
		MenuHighlight
	}
	internal static class KnownColorTable
	{
		private static int[] colorTable;

		private static string[] colorNameTable;

		private const int AlphaShift = 24;

		private const int RedShift = 16;

		private const int GreenShift = 8;

		private const int BlueShift = 0;

		private const int Win32RedShift = 0;

		private const int Win32GreenShift = 8;

		private const int Win32BlueShift = 16;

		public static Color ArgbToKnownColor(int targetARGB)
		{
			EnsureColorTable();
			for (int i = 0; i < colorTable.Length; i++)
			{
				int num = colorTable[i];
				if (num == targetARGB)
				{
					Color result = Color.FromKnownColor((KnownColor)i);
					if (!result.IsSystemColor)
					{
						return result;
					}
				}
			}
			return Color.FromArgb(targetARGB);
		}

		private static void EnsureColorTable()
		{
			if (colorTable == null)
			{
				InitColorTable();
			}
		}

		private static void InitColorTable()
		{
			int[] array = new int[175];
			SystemEvents.UserPreferenceChanging += OnUserPreferenceChanging;
			UpdateSystemColors(array);
			array[27] = 16777215;
			array[28] = -984833;
			array[29] = -332841;
			array[30] = -16711681;
			array[31] = -8388652;
			array[32] = -983041;
			array[33] = -657956;
			array[34] = -6972;
			array[35] = -16777216;
			array[36] = -5171;
			array[37] = -16776961;
			array[38] = -7722014;
			array[39] = -5952982;
			array[40] = -2180985;
			array[41] = -10510688;
			array[42] = -8388864;
			array[43] = -2987746;
			array[44] = -32944;
			array[45] = -10185235;
			array[46] = -1828;
			array[47] = -2354116;
			array[48] = -16711681;
			array[49] = -16777077;
			array[50] = -16741493;
			array[51] = -4684277;
			array[52] = -5658199;
			array[53] = -16751616;
			array[54] = -4343957;
			array[55] = -7667573;
			array[56] = -11179217;
			array[57] = -29696;
			array[58] = -6737204;
			array[59] = -7667712;
			array[60] = -1468806;
			array[61] = -7357301;
			array[62] = -12042869;
			array[63] = -13676721;
			array[64] = -16724271;
			array[65] = -7077677;
			array[66] = -60269;
			array[67] = -16728065;
			array[68] = -9868951;
			array[69] = -14774017;
			array[70] = -5103070;
			array[71] = -1296;
			array[72] = -14513374;
			array[73] = -65281;
			array[74] = -2302756;
			array[75] = -460545;
			array[76] = -10496;
			array[77] = -2448096;
			array[78] = -8355712;
			array[79] = -16744448;
			array[80] = -5374161;
			array[81] = -983056;
			array[82] = -38476;
			array[83] = -3318692;
			array[84] = -11861886;
			array[85] = -16;
			array[86] = -989556;
			array[87] = -1644806;
			array[88] = -3851;
			array[89] = -8586240;
			array[90] = -1331;
			array[91] = -5383962;
			array[92] = -1015680;
			array[93] = -2031617;
			array[94] = -329006;
			array[95] = -2894893;
			array[96] = -7278960;
			array[97] = -18751;
			array[98] = -24454;
			array[99] = -14634326;
			array[100] = -7876870;
			array[101] = -8943463;
			array[102] = -5192482;
			array[103] = -32;
			array[104] = -16711936;
			array[105] = -13447886;
			array[106] = -331546;
			array[107] = -65281;
			array[108] = -8388608;
			array[109] = -10039894;
			array[110] = -16777011;
			array[111] = -4565549;
			array[112] = -7114533;
			array[113] = -12799119;
			array[114] = -8689426;
			array[115] = -16713062;
			array[116] = -12004916;
			array[117] = -3730043;
			array[118] = -15132304;
			array[119] = -655366;
			array[120] = -6943;
			array[121] = -6987;
			array[122] = -8531;
			array[123] = -16777088;
			array[124] = -133658;
			array[125] = -8355840;
			array[126] = -9728477;
			array[127] = -23296;
			array[128] = -47872;
			array[129] = -2461482;
			array[130] = -1120086;
			array[131] = -6751336;
			array[132] = -5247250;
			array[133] = -2396013;
			array[134] = -4139;
			array[135] = -9543;
			array[136] = -3308225;
			array[137] = -16181;
			array[138] = -2252579;
			array[139] = -5185306;
			array[140] = -8388480;
			array[141] = -65536;
			array[142] = -4419697;
			array[143] = -12490271;
			array[144] = -7650029;
			array[145] = -360334;
			array[146] = -744352;
			array[147] = -13726889;
			array[148] = -2578;
			array[149] = -6270419;
			array[150] = -4144960;
			array[151] = -7876885;
			array[152] = -9807155;
			array[153] = -9404272;
			array[154] = -1286;
			array[155] = -16711809;
			array[156] = -12156236;
			array[157] = -2968436;
			array[158] = -16744320;
			array[159] = -2572328;
			array[160] = -40121;
			array[161] = -12525360;
			array[162] = -1146130;
			array[163] = -663885;
			array[164] = -1;
			array[165] = -657931;
			array[166] = -256;
			array[167] = -6632142;
			colorTable = array;
		}

		private static void EnsureColorNameTable()
		{
			if (colorNameTable == null)
			{
				InitColorNameTable();
			}
		}

		private static void InitColorNameTable()
		{
			string[] array = new string[175];
			array[1] = "ActiveBorder";
			array[2] = "ActiveCaption";
			array[3] = "ActiveCaptionText";
			array[4] = "AppWorkspace";
			array[168] = "ButtonFace";
			array[169] = "ButtonHighlight";
			array[170] = "ButtonShadow";
			array[5] = "Control";
			array[6] = "ControlDark";
			array[7] = "ControlDarkDark";
			array[8] = "ControlLight";
			array[9] = "ControlLightLight";
			array[10] = "ControlText";
			array[11] = "Desktop";
			array[171] = "GradientActiveCaption";
			array[172] = "GradientInactiveCaption";
			array[12] = "GrayText";
			array[13] = "Highlight";
			array[14] = "HighlightText";
			array[15] = "HotTrack";
			array[16] = "InactiveBorder";
			array[17] = "InactiveCaption";
			array[18] = "InactiveCaptionText";
			array[19] = "Info";
			array[20] = "InfoText";
			array[21] = "Menu";
			array[173] = "MenuBar";
			array[174] = "MenuHighlight";
			array[22] = "MenuText";
			array[23] = "ScrollBar";
			array[24] = "Window";
			array[25] = "WindowFrame";
			array[26] = "WindowText";
			array[27] = "Transparent";
			array[28] = "AliceBlue";
			array[29] = "AntiqueWhite";
			array[30] = "Aqua";
			array[31] = "Aquamarine";
			array[32] = "Azure";
			array[33] = "Beige";
			array[34] = "Bisque";
			array[35] = "Black";
			array[36] = "BlanchedAlmond";
			array[37] = "Blue";
			array[38] = "BlueViolet";
			array[39] = "Brown";
			array[40] = "BurlyWood";
			array[41] = "CadetBlue";
			array[42] = "Chartreuse";
			array[43] = "Chocolate";
			array[44] = "Coral";
			array[45] = "CornflowerBlue";
			array[46] = "Cornsilk";
			array[47] = "Crimson";
			array[48] = "Cyan";
			array[49] = "DarkBlue";
			array[50] = "DarkCyan";
			array[51] = "DarkGoldenrod";
			array[52] = "DarkGray";
			array[53] = "DarkGreen";
			array[54] = "DarkKhaki";
			array[55] = "DarkMagenta";
			array[56] = "DarkOliveGreen";
			array[57] = "DarkOrange";
			array[58] = "DarkOrchid";
			array[59] = "DarkRed";
			array[60] = "DarkSalmon";
			array[61] = "DarkSeaGreen";
			array[62] = "DarkSlateBlue";
			array[63] = "DarkSlateGray";
			array[64] = "DarkTurquoise";
			array[65] = "DarkViolet";
			array[66] = "DeepPink";
			array[67] = "DeepSkyBlue";
			array[68] = "DimGray";
			array[69] = "DodgerBlue";
			array[70] = "Firebrick";
			array[71] = "FloralWhite";
			array[72] = "ForestGreen";
			array[73] = "Fuchsia";
			array[74] = "Gainsboro";
			array[75] = "GhostWhite";
			array[76] = "Gold";
			array[77] = "Goldenrod";
			array[78] = "Gray";
			array[79] = "Green";
			array[80] = "GreenYellow";
			array[81] = "Honeydew";
			array[82] = "HotPink";
			array[83] = "IndianRed";
			array[84] = "Indigo";
			array[85] = "Ivory";
			array[86] = "Khaki";
			array[87] = "Lavender";
			array[88] = "LavenderBlush";
			array[89] = "LawnGreen";
			array[90] = "LemonChiffon";
			array[91] = "LightBlue";
			array[92] = "LightCoral";
			array[93] = "LightCyan";
			array[94] = "LightGoldenrodYellow";
			array[95] = "LightGray";
			array[96] = "LightGreen";
			array[97] = "LightPink";
			array[98] = "LightSalmon";
			array[99] = "LightSeaGreen";
			array[100] = "LightSkyBlue";
			array[101] = "LightSlateGray";
			array[102] = "LightSteelBlue";
			array[103] = "LightYellow";
			array[104] = "Lime";
			array[105] = "LimeGreen";
			array[106] = "Linen";
			array[107] = "Magenta";
			array[108] = "Maroon";
			array[109] = "MediumAquamarine";
			array[110] = "MediumBlue";
			array[111] = "MediumOrchid";
			array[112] = "MediumPurple";
			array[113] = "MediumSeaGreen";
			array[114] = "MediumSlateBlue";
			array[115] = "MediumSpringGreen";
			array[116] = "MediumTurquoise";
			array[117] = "MediumVioletRed";
			array[118] = "MidnightBlue";
			array[119] = "MintCream";
			array[120] = "MistyRose";
			array[121] = "Moccasin";
			array[122] = "NavajoWhite";
			array[123] = "Navy";
			array[124] = "OldLace";
			array[125] = "Olive";
			array[126] = "OliveDrab";
			array[127] = "Orange";
			array[128] = "OrangeRed";
			array[129] = "Orchid";
			array[130] = "PaleGoldenrod";
			array[131] = "PaleGreen";
			array[132] = "PaleTurquoise";
			array[133] = "PaleVioletRed";
			array[134] = "PapayaWhip";
			array[135] = "PeachPuff";
			array[136] = "Peru";
			array[137] = "Pink";
			array[138] = "Plum";
			array[139] = "PowderBlue";
			array[140] = "Purple";
			array[141] = "Red";
			array[142] = "RosyBrown";
			array[143] = "RoyalBlue";
			array[144] = "SaddleBrown";
			array[145] = "Salmon";
			array[146] = "SandyBrown";
			array[147] = "SeaGreen";
			array[148] = "SeaShell";
			array[149] = "Sienna";
			array[150] = "Silver";
			array[151] = "SkyBlue";
			array[152] = "SlateBlue";
			array[153] = "SlateGray";
			array[154] = "Snow";
			array[155] = "SpringGreen";
			array[156] = "SteelBlue";
			array[157] = "Tan";
			array[158] = "Teal";
			array[159] = "Thistle";
			array[160] = "Tomato";
			array[161] = "Turquoise";
			array[162] = "Violet";
			array[163] = "Wheat";
			array[164] = "White";
			array[165] = "WhiteSmoke";
			array[166] = "Yellow";
			array[167] = "YellowGreen";
			colorNameTable = array;
		}

		public static int KnownColorToArgb(KnownColor color)
		{
			EnsureColorTable();
			if (color <= KnownColor.MenuHighlight)
			{
				return colorTable[(int)color];
			}
			return 0;
		}

		public static string KnownColorToName(KnownColor color)
		{
			EnsureColorNameTable();
			if (color <= KnownColor.MenuHighlight)
			{
				return colorNameTable[(int)color];
			}
			return null;
		}

		private static int SystemColorToArgb(int index)
		{
			return FromWin32Value(SafeNativeMethods.GetSysColor(index));
		}

		private static int Encode(int alpha, int red, int green, int blue)
		{
			return (red << 16) | (green << 8) | blue | (alpha << 24);
		}

		private static int FromWin32Value(int value)
		{
			return Encode(255, value & 0xFF, (value >> 8) & 0xFF, (value >> 16) & 0xFF);
		}

		private static void OnUserPreferenceChanging(object sender, UserPreferenceChangingEventArgs e)
		{
			if (e.Category == UserPreferenceCategory.Color && colorTable != null)
			{
				UpdateSystemColors(colorTable);
			}
		}

		private static void UpdateSystemColors(int[] colorTable)
		{
			colorTable[1] = SystemColorToArgb(10);
			colorTable[2] = SystemColorToArgb(2);
			colorTable[3] = SystemColorToArgb(9);
			colorTable[4] = SystemColorToArgb(12);
			colorTable[168] = SystemColorToArgb(15);
			colorTable[169] = SystemColorToArgb(20);
			colorTable[170] = SystemColorToArgb(16);
			colorTable[5] = SystemColorToArgb(15);
			colorTable[6] = SystemColorToArgb(16);
			colorTable[7] = SystemColorToArgb(21);
			colorTable[8] = SystemColorToArgb(22);
			colorTable[9] = SystemColorToArgb(20);
			colorTable[10] = SystemColorToArgb(18);
			colorTable[11] = SystemColorToArgb(1);
			colorTable[171] = SystemColorToArgb(27);
			colorTable[172] = SystemColorToArgb(28);
			colorTable[12] = SystemColorToArgb(17);
			colorTable[13] = SystemColorToArgb(13);
			colorTable[14] = SystemColorToArgb(14);
			colorTable[15] = SystemColorToArgb(26);
			colorTable[16] = SystemColorToArgb(11);
			colorTable[17] = SystemColorToArgb(3);
			colorTable[18] = SystemColorToArgb(19);
			colorTable[19] = SystemColorToArgb(24);
			colorTable[20] = SystemColorToArgb(23);
			colorTable[21] = SystemColorToArgb(4);
			colorTable[173] = SystemColorToArgb(30);
			colorTable[174] = SystemColorToArgb(29);
			colorTable[22] = SystemColorToArgb(7);
			colorTable[23] = SystemColorToArgb(0);
			colorTable[24] = SystemColorToArgb(5);
			colorTable[25] = SystemColorToArgb(6);
			colorTable[26] = SystemColorToArgb(8);
		}
	}
	internal static class LocalAppContextSwitches
	{
		private static int dontSupportPngFramesInIcons;

		private static int optimizePrintPreview;

		private static int doNotRemoveGdiFontsResourcesFromFontCollection;

		private static int freeCopyToDevModeOnFailure;

		public static bool DontSupportPngFramesInIcons
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return LocalAppContext.GetCachedSwitchValue("Switch.System.Drawing.DontSupportPngFramesInIcons", ref dontSupportPngFramesInIcons);
			}
		}

		public static bool OptimizePrintPreview
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return LocalAppContext.GetCachedSwitchValue("Switch.System.Drawing.Printing.OptimizePrintPreview", ref optimizePrintPreview);
			}
		}

		public static bool DoNotRemoveGdiFontsResourcesFromFontCollection
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return LocalAppContext.GetCachedSwitchValue("Switch.System.Drawing.Text.DoNotRemoveGdiFontsResourcesFromFontCollection", ref doNotRemoveGdiFontsResourcesFromFontCollection);
			}
		}

		public static bool FreeCopyToDevModeOnFailure
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return LocalAppContext.GetCachedSwitchValue("Switch.System.Drawing.Printing.CopyToDevModeFreeOnFailure", ref freeCopyToDevModeOnFailure);
			}
		}
	}
	internal class NativeMethods
	{
		public enum RegionFlags
		{
			ERROR,
			NULLREGION,
			SIMPLEREGION,
			COMPLEXREGION
		}

		internal struct BITMAPINFO_FLAT
		{
			public int bmiHeader_biSize;

			public int bmiHeader_biWidth;

			public int bmiHeader_biHeight;

			public short bmiHeader_biPlanes;

			public short bmiHeader_biBitCount;

			public int bmiHeader_biCompression;

			public int bmiHeader_biSizeImage;

			public int bmiHeader_biXPelsPerMeter;

			public int bmiHeader_biYPelsPerMeter;

			public int bmiHeader_biClrUsed;

			public int bmiHeader_biClrImportant;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1024)]
			public byte[] bmiColors;
		}

		[StructLayout(LayoutKind.Sequential)]
		internal class BITMAPINFOHEADER
		{
			public int biSize = 40;

			public int biWidth;

			public int biHeight;

			public short biPlanes;

			public short biBitCount;

			public int biCompression;

			public int biSizeImage;

			public int biXPelsPerMeter;

			public int biYPelsPerMeter;

			public int biClrUsed;

			public int biClrImportant;
		}

		internal struct PALETTEENTRY
		{
			public byte peRed;

			public byte peGreen;

			public byte peBlue;

			public byte peFlags;
		}

		internal struct RGBQUAD
		{
			public byte rgbBlue;

			public byte rgbGreen;

			public byte rgbRed;

			public byte rgbReserved;
		}

		[StructLayout(LayoutKind.Sequential)]
		internal class NONCLIENTMETRICS
		{
			public int cbSize = Marshal.SizeOf(typeof(NONCLIENTMETRICS));

			public int iBorderWidth;

			public int iScrollWidth;

			public int iScrollHeight;

			public int iCaptionWidth;

			public int iCaptionHeight;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfCaptionFont;

			public int iSmCaptionWidth;

			public int iSmCaptionHeight;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfSmCaptionFont;

			public int iMenuWidth;

			public int iMenuHeight;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfMenuFont;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfStatusFont;

			[MarshalAs(UnmanagedType.Struct)]
			public SafeNativeMethods.LOGFONT lfMessageFont;
		}

		internal static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);

		public const byte PC_NOCOLLAPSE = 4;

		public const int MAX_PATH = 260;

		internal const int SM_REMOTESESSION = 4096;

		internal const int OBJ_DC = 3;

		internal const int OBJ_METADC = 4;

		internal const int OBJ_MEMDC = 10;

		internal const int OBJ_ENHMETADC = 12;

		internal const int DIB_RGB_COLORS = 0;

		internal const int BI_BITFIELDS = 3;

		internal const int BI_RGB = 0;

		internal const int BITMAPINFO_MAX_COLORSIZE = 256;

		internal const int SPI_GETICONTITLELOGFONT = 31;

		internal const int SPI_GETNONCLIENTMETRICS = 41;

		internal const int DEFAULT_GUI_FONT = 17;
	}
	/// <summary>Defines an object used to draw lines and curves. This class cannot be inherited.</summary>
	public sealed class Pen : MarshalByRefObject, ISystemColorTracker, ICloneable, IDisposable
	{
		private IntPtr nativePen;

		private Color color;

		private bool immutable;

		[Browsable(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		internal IntPtr NativePen => nativePen;

		/// <summary>Gets or sets the width of this <see cref="T:System.Drawing.Pen" />, in units of the <see cref="T:System.Drawing.Graphics" /> object used for drawing.</summary>
		/// <returns>The width of this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.Width" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public float Width
		{
			get
			{
				float[] array = new float[1];
				int num = SafeNativeMethods.Gdip.GdipGetPenWidth(new HandleRef(this, NativePen), array);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array[0];
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenWidth(new HandleRef(this, NativePen), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the cap style used at the beginning of lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.LineCap" /> values that represents the cap style used at the beginning of lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The specified value is not a member of <see cref="T:System.Drawing.Drawing2D.LineCap" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.StartCap" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public LineCap StartCap
		{
			get
			{
				int startCap = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenStartCap(new HandleRef(this, NativePen), out startCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (LineCap)startCap;
			}
			set
			{
				switch (value)
				{
				default:
					throw new InvalidEnumArgumentException("value", (int)value, typeof(LineCap));
				case LineCap.Flat:
				case LineCap.Square:
				case LineCap.Round:
				case LineCap.Triangle:
				case LineCap.NoAnchor:
				case LineCap.SquareAnchor:
				case LineCap.RoundAnchor:
				case LineCap.DiamondAnchor:
				case LineCap.ArrowAnchor:
				case LineCap.AnchorMask:
				case LineCap.Custom:
				{
					if (immutable)
					{
						throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
					}
					int num = SafeNativeMethods.Gdip.GdipSetPenStartCap(new HandleRef(this, NativePen), (int)value);
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					break;
				}
				}
			}
		}

		/// <summary>Gets or sets the cap style used at the end of lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.LineCap" /> values that represents the cap style used at the end of lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The specified value is not a member of <see cref="T:System.Drawing.Drawing2D.LineCap" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.EndCap" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public LineCap EndCap
		{
			get
			{
				int endCap = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenEndCap(new HandleRef(this, NativePen), out endCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (LineCap)endCap;
			}
			set
			{
				switch (value)
				{
				default:
					throw new InvalidEnumArgumentException("value", (int)value, typeof(LineCap));
				case LineCap.Flat:
				case LineCap.Square:
				case LineCap.Round:
				case LineCap.Triangle:
				case LineCap.NoAnchor:
				case LineCap.SquareAnchor:
				case LineCap.RoundAnchor:
				case LineCap.DiamondAnchor:
				case LineCap.ArrowAnchor:
				case LineCap.AnchorMask:
				case LineCap.Custom:
				{
					if (immutable)
					{
						throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
					}
					int num = SafeNativeMethods.Gdip.GdipSetPenEndCap(new HandleRef(this, NativePen), (int)value);
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					break;
				}
				}
			}
		}

		/// <summary>Gets or sets the cap style used at the end of the dashes that make up dashed lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.DashCap" /> values that represents the cap style used at the beginning and end of the dashes that make up dashed lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The specified value is not a member of <see cref="T:System.Drawing.Drawing2D.DashCap" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.DashCap" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public DashCap DashCap
		{
			get
			{
				int dashCap = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenDashCap197819(new HandleRef(this, NativePen), out dashCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (DashCap)dashCap;
			}
			set
			{
				if (!ClientUtils.IsEnumValid_NotSequential(value, (int)value, 0, 2, 3))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(DashCap));
				}
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenDashCap197819(new HandleRef(this, NativePen), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the join style for the ends of two consecutive lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.LineJoin" /> that represents the join style for the ends of two consecutive lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.LineJoin" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public LineJoin LineJoin
		{
			get
			{
				int lineJoin = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenLineJoin(new HandleRef(this, NativePen), out lineJoin);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (LineJoin)lineJoin;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 3))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(LineJoin));
				}
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenLineJoin(new HandleRef(this, NativePen), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets a custom cap to use at the beginning of lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> that represents the cap used at the beginning of lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.CustomStartCap" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public CustomLineCap CustomStartCap
		{
			get
			{
				IntPtr customCap = IntPtr.Zero;
				int num = SafeNativeMethods.Gdip.GdipGetPenCustomStartCap(new HandleRef(this, NativePen), out customCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return CustomLineCap.CreateCustomLineCapObject(customCap);
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenCustomStartCap(new HandleRef(this, NativePen), new HandleRef(value, (value == null) ? IntPtr.Zero : ((IntPtr)value.nativeCap)));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets a custom cap to use at the end of lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> that represents the cap used at the end of lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.CustomEndCap" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public CustomLineCap CustomEndCap
		{
			get
			{
				IntPtr customCap = IntPtr.Zero;
				int num = SafeNativeMethods.Gdip.GdipGetPenCustomEndCap(new HandleRef(this, NativePen), out customCap);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return CustomLineCap.CreateCustomLineCapObject(customCap);
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenCustomEndCap(new HandleRef(this, NativePen), new HandleRef(value, (value == null) ? IntPtr.Zero : ((IntPtr)value.nativeCap)));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the limit of the thickness of the join on a mitered corner.</summary>
		/// <returns>The limit of the thickness of the join on a mitered corner.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.MiterLimit" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public float MiterLimit
		{
			get
			{
				float[] array = new float[1];
				int num = SafeNativeMethods.Gdip.GdipGetPenMiterLimit(new HandleRef(this, NativePen), array);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array[0];
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenMiterLimit(new HandleRef(this, NativePen), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the alignment for this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.PenAlignment" /> that represents the alignment for this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The specified value is not a member of <see cref="T:System.Drawing.Drawing2D.PenAlignment" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.Alignment" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public PenAlignment Alignment
		{
			get
			{
				PenAlignment penAlign = PenAlignment.Center;
				int num = SafeNativeMethods.Gdip.GdipGetPenMode(new HandleRef(this, NativePen), out penAlign);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return penAlign;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PenAlignment));
				}
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenMode(new HandleRef(this, NativePen), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets a copy of the geometric transformation for this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents the geometric transformation for this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.Transform" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public Matrix Transform
		{
			get
			{
				Matrix matrix = new Matrix();
				int num = SafeNativeMethods.Gdip.GdipGetPenTransform(new HandleRef(this, NativePen), new HandleRef(matrix, matrix.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return matrix;
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenTransform(new HandleRef(this, NativePen), new HandleRef(value, value.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets the style of lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.PenType" /> enumeration that specifies the style of lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		public PenType PenType
		{
			get
			{
				int pentype = -1;
				int num = SafeNativeMethods.Gdip.GdipGetPenFillType(new HandleRef(this, NativePen), out pentype);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (PenType)pentype;
			}
		}

		/// <summary>Gets or sets the color of this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the color of this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.Color" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public Color Color
		{
			get
			{
				if (color == Color.Empty)
				{
					int argb = 0;
					int num = SafeNativeMethods.Gdip.GdipGetPenColor(new HandleRef(this, NativePen), out argb);
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					color = Color.FromArgb(argb);
				}
				return color;
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				if (value != this.color)
				{
					Color color = this.color;
					this.color = value;
					InternalSetColor(value);
					if (value.IsSystemColor && !color.IsSystemColor)
					{
						SystemColorTracker.Add(this);
					}
				}
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Drawing.Brush" /> that determines attributes of this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Brush" /> that determines attributes of this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.Brush" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public Brush Brush
		{
			get
			{
				Brush result = null;
				switch (PenType)
				{
				case PenType.SolidColor:
					result = new SolidBrush(GetNativeBrush());
					break;
				case PenType.HatchFill:
					result = new HatchBrush(GetNativeBrush());
					break;
				case PenType.TextureFill:
					result = new TextureBrush(GetNativeBrush());
					break;
				case PenType.PathGradient:
					result = new PathGradientBrush(GetNativeBrush());
					break;
				case PenType.LinearGradient:
					result = new LinearGradientBrush(GetNativeBrush());
					break;
				}
				return result;
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenBrushFill(new HandleRef(this, NativePen), new HandleRef(value, value.NativeBrush));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the style used for dashed lines drawn with this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.DashStyle" /> that represents the style used for dashed lines drawn with this <see cref="T:System.Drawing.Pen" />.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.DashStyle" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public DashStyle DashStyle
		{
			get
			{
				int dashstyle = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenDashStyle(new HandleRef(this, NativePen), out dashstyle);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (DashStyle)dashstyle;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 5))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(DashStyle));
				}
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenDashStyle(new HandleRef(this, NativePen), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				if (value == DashStyle.Custom)
				{
					EnsureValidDashPattern();
				}
			}
		}

		/// <summary>Gets or sets the distance from the start of a line to the beginning of a dash pattern.</summary>
		/// <returns>The distance from the start of a line to the beginning of a dash pattern.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.DashOffset" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public float DashOffset
		{
			get
			{
				float[] array = new float[1];
				int num = SafeNativeMethods.Gdip.GdipGetPenDashOffset(new HandleRef(this, NativePen), array);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array[0];
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenDashOffset(new HandleRef(this, NativePen), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets an array of custom dashes and spaces.</summary>
		/// <returns>An array of real numbers that specifies the lengths of alternating dashes and spaces in dashed lines.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.DashPattern" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public float[] DashPattern
		{
			get
			{
				int dashcount = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenDashCount(new HandleRef(this, NativePen), out dashcount);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				int num2 = dashcount;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(4 * num2));
				num = SafeNativeMethods.Gdip.GdipGetPenDashArray(new HandleRef(this, NativePen), intPtr, num2);
				try
				{
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					float[] array = new float[num2];
					Marshal.Copy(intPtr, array, 0, num2);
					return array;
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				if (value == null || value.Length == 0)
				{
					throw new ArgumentException(SR.GetString("InvalidDashPattern"));
				}
				int num = value.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(4 * num));
				try
				{
					Marshal.Copy(value, 0, intPtr, num);
					int num2 = SafeNativeMethods.Gdip.GdipSetPenDashArray(new HandleRef(this, NativePen), new HandleRef(intPtr, intPtr), num);
					if (num2 != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num2);
					}
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		/// <summary>Gets or sets an array of values that specifies a compound pen. A compound pen draws a compound line made up of parallel lines and spaces.</summary>
		/// <returns>An array of real numbers that specifies the compound array. The elements in the array must be in increasing order, not less than 0, and not greater than 1.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Pen.CompoundArray" /> property is set on an immutable <see cref="T:System.Drawing.Pen" />, such as those returned by the <see cref="T:System.Drawing.Pens" /> class.</exception>
		public float[] CompoundArray
		{
			get
			{
				int count = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPenCompoundCount(new HandleRef(this, NativePen), out count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				float[] array = new float[count];
				num = SafeNativeMethods.Gdip.GdipGetPenCompoundArray(new HandleRef(this, NativePen), array, count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array;
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPenCompoundArray(new HandleRef(this, NativePen), value, value.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		private Pen(IntPtr nativePen)
		{
			SetNativePen(nativePen);
		}

		internal Pen(Color color, bool immutable)
			: this(color)
		{
			this.immutable = immutable;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Pen" /> class with the specified color.</summary>
		/// <param name="color">A <see cref="T:System.Drawing.Color" /> structure that indicates the color of this <see cref="T:System.Drawing.Pen" />.</param>
		public Pen(Color color)
			: this(color, 1f)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Pen" /> class with the specified <see cref="T:System.Drawing.Color" /> and <see cref="P:System.Drawing.Pen.Width" /> properties.</summary>
		/// <param name="color">A <see cref="T:System.Drawing.Color" /> structure that indicates the color of this <see cref="T:System.Drawing.Pen" />.</param>
		/// <param name="width">A value indicating the width of this <see cref="T:System.Drawing.Pen" />.</param>
		public Pen(Color color, float width)
		{
			this.color = color;
			IntPtr pen = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreatePen1(color.ToArgb(), width, 0, out pen);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativePen(pen);
			if (this.color.IsSystemColor)
			{
				SystemColorTracker.Add(this);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Pen" /> class with the specified <see cref="T:System.Drawing.Brush" />.</summary>
		/// <param name="brush">A <see cref="T:System.Drawing.Brush" /> that determines the fill properties of this <see cref="T:System.Drawing.Pen" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public Pen(Brush brush)
			: this(brush, 1f)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Pen" /> class with the specified <see cref="T:System.Drawing.Brush" /> and <see cref="P:System.Drawing.Pen.Width" />.</summary>
		/// <param name="brush">A <see cref="T:System.Drawing.Brush" /> that determines the characteristics of this <see cref="T:System.Drawing.Pen" />.</param>
		/// <param name="width">The width of the new <see cref="T:System.Drawing.Pen" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="brush" /> is <see langword="null" />.</exception>
		public Pen(Brush brush, float width)
		{
			IntPtr pen = IntPtr.Zero;
			if (brush == null)
			{
				throw new ArgumentNullException("brush");
			}
			int num = SafeNativeMethods.Gdip.GdipCreatePen2(new HandleRef(brush, brush.NativeBrush), width, 0, out pen);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativePen(pen);
		}

		internal void SetNativePen(IntPtr nativePen)
		{
			if (nativePen == IntPtr.Zero)
			{
				throw new ArgumentNullException("nativePen");
			}
			this.nativePen = nativePen;
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <returns>An <see cref="T:System.Object" /> that can be cast to a <see cref="T:System.Drawing.Pen" />.</returns>
		public object Clone()
		{
			IntPtr clonepen = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipClonePen(new HandleRef(this, NativePen), out clonepen);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Pen(clonepen);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Pen" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!disposing)
			{
				immutable = false;
			}
			else if (immutable)
			{
				throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Brush"));
			}
			if (!(nativePen != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeletePen(new HandleRef(this, NativePen));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativePen = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Pen()
		{
			Dispose(disposing: false);
		}

		/// <summary>Sets the values that determine the style of cap used to end lines drawn by this <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="startCap">A <see cref="T:System.Drawing.Drawing2D.LineCap" /> that represents the cap style to use at the beginning of lines drawn with this <see cref="T:System.Drawing.Pen" />.</param>
		/// <param name="endCap">A <see cref="T:System.Drawing.Drawing2D.LineCap" /> that represents the cap style to use at the end of lines drawn with this <see cref="T:System.Drawing.Pen" />.</param>
		/// <param name="dashCap">A <see cref="T:System.Drawing.Drawing2D.LineCap" /> that represents the cap style to use at the beginning or end of dashed lines drawn with this <see cref="T:System.Drawing.Pen" />.</param>
		public void SetLineCap(LineCap startCap, LineCap endCap, DashCap dashCap)
		{
			if (immutable)
			{
				throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Pen"));
			}
			int num = SafeNativeMethods.Gdip.GdipSetPenLineCap197819(new HandleRef(this, NativePen), (int)startCap, (int)endCap, (int)dashCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Resets the geometric transformation matrix for this <see cref="T:System.Drawing.Pen" /> to identity.</summary>
		public void ResetTransform()
		{
			int num = SafeNativeMethods.Gdip.GdipResetPenTransform(new HandleRef(this, NativePen));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Multiplies the transformation matrix for this <see cref="T:System.Drawing.Pen" /> by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> object by which to multiply the transformation matrix.</param>
		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Multiplies the transformation matrix for this <see cref="T:System.Drawing.Pen" /> by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to multiply the transformation matrix.</param>
		/// <param name="order">The order in which to perform the multiplication operation.</param>
		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipMultiplyPenTransform(new HandleRef(this, NativePen), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Translates the local geometric transformation by the specified dimensions. This method prepends the translation to the transformation.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		/// <summary>Translates the local geometric transformation by the specified dimensions in the specified order.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		/// <param name="order">The order (prepend or append) in which to apply the translation.</param>
		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslatePenTransform(new HandleRef(this, NativePen), dx, dy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Scales the local geometric transformation by the specified factors. This method prepends the scaling matrix to the transformation.</summary>
		/// <param name="sx">The factor by which to scale the transformation in the x-axis direction.</param>
		/// <param name="sy">The factor by which to scale the transformation in the y-axis direction.</param>
		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		/// <summary>Scales the local geometric transformation by the specified factors in the specified order.</summary>
		/// <param name="sx">The factor by which to scale the transformation in the x-axis direction.</param>
		/// <param name="sy">The factor by which to scale the transformation in the y-axis direction.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the scaling matrix.</param>
		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScalePenTransform(new HandleRef(this, NativePen), sx, sy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Rotates the local geometric transformation by the specified angle. This method prepends the rotation to the transformation.</summary>
		/// <param name="angle">The angle of rotation.</param>
		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		/// <summary>Rotates the local geometric transformation by the specified angle in the specified order.</summary>
		/// <param name="angle">The angle of rotation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the rotation matrix.</param>
		public void RotateTransform(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotatePenTransform(new HandleRef(this, NativePen), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private void InternalSetColor(Color value)
		{
			int num = SafeNativeMethods.Gdip.GdipSetPenColor(new HandleRef(this, NativePen), color.ToArgb());
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			color = value;
		}

		private IntPtr GetNativeBrush()
		{
			IntPtr brush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetPenBrushFill(new HandleRef(this, NativePen), out brush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return brush;
		}

		private void EnsureValidDashPattern()
		{
			int dashcount = 0;
			int num = SafeNativeMethods.Gdip.GdipGetPenDashCount(new HandleRef(this, NativePen), out dashcount);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (dashcount == 0)
			{
				DashPattern = new float[1] { 1f };
			}
		}

		void ISystemColorTracker.OnSystemColorChanged()
		{
			if (NativePen != IntPtr.Zero)
			{
				InternalSetColor(color);
			}
		}
	}
	/// <summary>Pens for all the standard colors. This class cannot be inherited.</summary>
	public sealed class Pens
	{
		private static readonly object TransparentKey = new object();

		private static readonly object AliceBlueKey = new object();

		private static readonly object AntiqueWhiteKey = new object();

		private static readonly object AquaKey = new object();

		private static readonly object AquamarineKey = new object();

		private static readonly object AzureKey = new object();

		private static readonly object BeigeKey = new object();

		private static readonly object BisqueKey = new object();

		private static readonly object BlackKey = new object();

		private static readonly object BlanchedAlmondKey = new object();

		private static readonly object BlueKey = new object();

		private static readonly object BlueVioletKey = new object();

		private static readonly object BrownKey = new object();

		private static readonly object BurlyWoodKey = new object();

		private static readonly object CadetBlueKey = new object();

		private static readonly object ChartreuseKey = new object();

		private static readonly object ChocolateKey = new object();

		private static readonly object ChoralKey = new object();

		private static readonly object CornflowerBlueKey = new object();

		private static readonly object CornsilkKey = new object();

		private static readonly object CrimsonKey = new object();

		private static readonly object CyanKey = new object();

		private static readonly object DarkBlueKey = new object();

		private static readonly object DarkCyanKey = new object();

		private static readonly object DarkGoldenrodKey = new object();

		private static readonly object DarkGrayKey = new object();

		private static readonly object DarkGreenKey = new object();

		private static readonly object DarkKhakiKey = new object();

		private static readonly object DarkMagentaKey = new object();

		private static readonly object DarkOliveGreenKey = new object();

		private static readonly object DarkOrangeKey = new object();

		private static readonly object DarkOrchidKey = new object();

		private static readonly object DarkRedKey = new object();

		private static readonly object DarkSalmonKey = new object();

		private static readonly object DarkSeaGreenKey = new object();

		private static readonly object DarkSlateBlueKey = new object();

		private static readonly object DarkSlateGrayKey = new object();

		private static readonly object DarkTurquoiseKey = new object();

		private static readonly object DarkVioletKey = new object();

		private static readonly object DeepPinkKey = new object();

		private static readonly object DeepSkyBlueKey = new object();

		private static readonly object DimGrayKey = new object();

		private static readonly object DodgerBlueKey = new object();

		private static readonly object FirebrickKey = new object();

		private static readonly object FloralWhiteKey = new object();

		private static readonly object ForestGreenKey = new object();

		private static readonly object FuchiaKey = new object();

		private static readonly object GainsboroKey = new object();

		private static readonly object GhostWhiteKey = new object();

		private static readonly object GoldKey = new object();

		private static readonly object GoldenrodKey = new object();

		private static readonly object GrayKey = new object();

		private static readonly object GreenKey = new object();

		private static readonly object GreenYellowKey = new object();

		private static readonly object HoneydewKey = new object();

		private static readonly object HotPinkKey = new object();

		private static readonly object IndianRedKey = new object();

		private static readonly object IndigoKey = new object();

		private static readonly object IvoryKey = new object();

		private static readonly object KhakiKey = new object();

		private static readonly object LavenderKey = new object();

		private static readonly object LavenderBlushKey = new object();

		private static readonly object LawnGreenKey = new object();

		private static readonly object LemonChiffonKey = new object();

		private static readonly object LightBlueKey = new object();

		private static readonly object LightCoralKey = new object();

		private static readonly object LightCyanKey = new object();

		private static readonly object LightGoldenrodYellowKey = new object();

		private static readonly object LightGreenKey = new object();

		private static readonly object LightGrayKey = new object();

		private static readonly object LightPinkKey = new object();

		private static readonly object LightSalmonKey = new object();

		private static readonly object LightSeaGreenKey = new object();

		private static readonly object LightSkyBlueKey = new object();

		private static readonly object LightSlateGrayKey = new object();

		private static readonly object LightSteelBlueKey = new object();

		private static readonly object LightYellowKey = new object();

		private static readonly object LimeKey = new object();

		private static readonly object LimeGreenKey = new object();

		private static readonly object LinenKey = new object();

		private static readonly object MagentaKey = new object();

		private static readonly object MaroonKey = new object();

		private static readonly object MediumAquamarineKey = new object();

		private static readonly object MediumBlueKey = new object();

		private static readonly object MediumOrchidKey = new object();

		private static readonly object MediumPurpleKey = new object();

		private static readonly object MediumSeaGreenKey = new object();

		private static readonly object MediumSlateBlueKey = new object();

		private static readonly object MediumSpringGreenKey = new object();

		private static readonly object MediumTurquoiseKey = new object();

		private static readonly object MediumVioletRedKey = new object();

		private static readonly object MidnightBlueKey = new object();

		private static readonly object MintCreamKey = new object();

		private static readonly object MistyRoseKey = new object();

		private static readonly object MoccasinKey = new object();

		private static readonly object NavajoWhiteKey = new object();

		private static readonly object NavyKey = new object();

		private static readonly object OldLaceKey = new object();

		private static readonly object OliveKey = new object();

		private static readonly object OliveDrabKey = new object();

		private static readonly object OrangeKey = new object();

		private static readonly object OrangeRedKey = new object();

		private static readonly object OrchidKey = new object();

		private static readonly object PaleGoldenrodKey = new object();

		private static readonly object PaleGreenKey = new object();

		private static readonly object PaleTurquoiseKey = new object();

		private static readonly object PaleVioletRedKey = new object();

		private static readonly object PapayaWhipKey = new object();

		private static readonly object PeachPuffKey = new object();

		private static readonly object PeruKey = new object();

		private static readonly object PinkKey = new object();

		private static readonly object PlumKey = new object();

		private static readonly object PowderBlueKey = new object();

		private static readonly object PurpleKey = new object();

		private static readonly object RedKey = new object();

		private static readonly object RosyBrownKey = new object();

		private static readonly object RoyalBlueKey = new object();

		private static readonly object SaddleBrownKey = new object();

		private static readonly object SalmonKey = new object();

		private static readonly object SandyBrownKey = new object();

		private static readonly object SeaGreenKey = new object();

		private static readonly object SeaShellKey = new object();

		private static readonly object SiennaKey = new object();

		private static readonly object SilverKey = new object();

		private static readonly object SkyBlueKey = new object();

		private static readonly object SlateBlueKey = new object();

		private static readonly object SlateGrayKey = new object();

		private static readonly object SnowKey = new object();

		private static readonly object SpringGreenKey = new object();

		private static readonly object SteelBlueKey = new object();

		private static readonly object TanKey = new object();

		private static readonly object TealKey = new object();

		private static readonly object ThistleKey = new object();

		private static readonly object TomatoKey = new object();

		private static readonly object TurquoiseKey = new object();

		private static readonly object VioletKey = new object();

		private static readonly object WheatKey = new object();

		private static readonly object WhiteKey = new object();

		private static readonly object WhiteSmokeKey = new object();

		private static readonly object YellowKey = new object();

		private static readonly object YellowGreenKey = new object();

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Transparent
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[TransparentKey];
				if (pen == null)
				{
					pen = new Pen(Color.Transparent, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[TransparentKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen AliceBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[AliceBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.AliceBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[AliceBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen AntiqueWhite
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[AntiqueWhiteKey];
				if (pen == null)
				{
					pen = new Pen(Color.AntiqueWhite, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[AntiqueWhiteKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Aqua
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[AquaKey];
				if (pen == null)
				{
					pen = new Pen(Color.Aqua, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[AquaKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Aquamarine
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[AquamarineKey];
				if (pen == null)
				{
					pen = new Pen(Color.Aquamarine, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[AquamarineKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Azure
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[AzureKey];
				if (pen == null)
				{
					pen = new Pen(Color.Azure, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[AzureKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Beige
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BeigeKey];
				if (pen == null)
				{
					pen = new Pen(Color.Beige, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BeigeKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Bisque
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BisqueKey];
				if (pen == null)
				{
					pen = new Pen(Color.Bisque, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BisqueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Black
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BlackKey];
				if (pen == null)
				{
					pen = new Pen(Color.Black, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BlackKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen BlanchedAlmond
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BlanchedAlmondKey];
				if (pen == null)
				{
					pen = new Pen(Color.BlanchedAlmond, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BlanchedAlmondKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Blue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.Blue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen BlueViolet
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BlueVioletKey];
				if (pen == null)
				{
					pen = new Pen(Color.BlueViolet, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BlueVioletKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Brown
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BrownKey];
				if (pen == null)
				{
					pen = new Pen(Color.Brown, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BrownKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen BurlyWood
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[BurlyWoodKey];
				if (pen == null)
				{
					pen = new Pen(Color.BurlyWood, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[BurlyWoodKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen CadetBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[CadetBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.CadetBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[CadetBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Chartreuse
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[ChartreuseKey];
				if (pen == null)
				{
					pen = new Pen(Color.Chartreuse, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[ChartreuseKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Chocolate
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[ChocolateKey];
				if (pen == null)
				{
					pen = new Pen(Color.Chocolate, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[ChocolateKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Coral
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[ChoralKey];
				if (pen == null)
				{
					pen = new Pen(Color.Coral, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[ChoralKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen CornflowerBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[CornflowerBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.CornflowerBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[CornflowerBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Cornsilk
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[CornsilkKey];
				if (pen == null)
				{
					pen = new Pen(Color.Cornsilk, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[CornsilkKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Crimson
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[CrimsonKey];
				if (pen == null)
				{
					pen = new Pen(Color.Crimson, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[CrimsonKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Cyan
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[CyanKey];
				if (pen == null)
				{
					pen = new Pen(Color.Cyan, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[CyanKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkCyan
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkCyanKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkCyan, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkCyanKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkGoldenrod
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkGoldenrodKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkGoldenrod, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkGoldenrodKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkGrayKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkKhaki
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkKhakiKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkKhaki, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkKhakiKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkMagenta
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkMagentaKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkMagenta, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkMagentaKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkOliveGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkOliveGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkOliveGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkOliveGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkOrange
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkOrangeKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkOrange, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkOrangeKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkOrchid
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkOrchidKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkOrchid, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkOrchidKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkRed
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkRedKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkRed, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkRedKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkSalmon
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkSalmonKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkSalmon, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkSalmonKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkSeaGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkSeaGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkSeaGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkSeaGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkSlateBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkSlateBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkSlateBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkSlateBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkSlateGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkSlateGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkSlateGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkSlateGrayKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkTurquoise
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkTurquoiseKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkTurquoise, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkTurquoiseKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DarkViolet
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DarkVioletKey];
				if (pen == null)
				{
					pen = new Pen(Color.DarkViolet, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DarkVioletKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DeepPink
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DeepPinkKey];
				if (pen == null)
				{
					pen = new Pen(Color.DeepPink, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DeepPinkKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DeepSkyBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DeepSkyBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.DeepSkyBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DeepSkyBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DimGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DimGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.DimGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DimGrayKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen DodgerBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[DodgerBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.DodgerBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[DodgerBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Firebrick
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[FirebrickKey];
				if (pen == null)
				{
					pen = new Pen(Color.Firebrick, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[FirebrickKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen FloralWhite
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[FloralWhiteKey];
				if (pen == null)
				{
					pen = new Pen(Color.FloralWhite, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[FloralWhiteKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen ForestGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[ForestGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.ForestGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[ForestGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Fuchsia
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[FuchiaKey];
				if (pen == null)
				{
					pen = new Pen(Color.Fuchsia, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[FuchiaKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Gainsboro
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GainsboroKey];
				if (pen == null)
				{
					pen = new Pen(Color.Gainsboro, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GainsboroKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen GhostWhite
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GhostWhiteKey];
				if (pen == null)
				{
					pen = new Pen(Color.GhostWhite, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GhostWhiteKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Gold
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GoldKey];
				if (pen == null)
				{
					pen = new Pen(Color.Gold, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GoldKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Goldenrod
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GoldenrodKey];
				if (pen == null)
				{
					pen = new Pen(Color.Goldenrod, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GoldenrodKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Gray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.Gray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GrayKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Green
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.Green, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen GreenYellow
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[GreenYellowKey];
				if (pen == null)
				{
					pen = new Pen(Color.GreenYellow, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[GreenYellowKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Honeydew
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[HoneydewKey];
				if (pen == null)
				{
					pen = new Pen(Color.Honeydew, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[HoneydewKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen HotPink
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[HotPinkKey];
				if (pen == null)
				{
					pen = new Pen(Color.HotPink, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[HotPinkKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen IndianRed
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[IndianRedKey];
				if (pen == null)
				{
					pen = new Pen(Color.IndianRed, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[IndianRedKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Indigo
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[IndigoKey];
				if (pen == null)
				{
					pen = new Pen(Color.Indigo, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[IndigoKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Ivory
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[IvoryKey];
				if (pen == null)
				{
					pen = new Pen(Color.Ivory, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[IvoryKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Khaki
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[KhakiKey];
				if (pen == null)
				{
					pen = new Pen(Color.Khaki, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[KhakiKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Lavender
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LavenderKey];
				if (pen == null)
				{
					pen = new Pen(Color.Lavender, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LavenderKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LavenderBlush
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LavenderBlushKey];
				if (pen == null)
				{
					pen = new Pen(Color.LavenderBlush, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LavenderBlushKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LawnGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LawnGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.LawnGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LawnGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LemonChiffon
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LemonChiffonKey];
				if (pen == null)
				{
					pen = new Pen(Color.LemonChiffon, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LemonChiffonKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightCoral
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightCoralKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightCoral, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightCoralKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightCyan
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightCyanKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightCyan, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightCyanKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightGoldenrodYellow
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightGoldenrodYellowKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightGoldenrodYellow, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightGoldenrodYellowKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightGrayKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightPink
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightPinkKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightPink, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightPinkKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightSalmon
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightSalmonKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightSalmon, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightSalmonKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightSeaGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightSeaGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightSeaGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightSeaGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightSkyBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightSkyBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightSkyBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightSkyBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightSlateGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightSlateGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightSlateGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightSlateGrayKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightSteelBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightSteelBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightSteelBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightSteelBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LightYellow
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LightYellowKey];
				if (pen == null)
				{
					pen = new Pen(Color.LightYellow, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LightYellowKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Lime
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LimeKey];
				if (pen == null)
				{
					pen = new Pen(Color.Lime, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LimeKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen LimeGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LimeGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.LimeGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LimeGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Linen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[LinenKey];
				if (pen == null)
				{
					pen = new Pen(Color.Linen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[LinenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Magenta
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MagentaKey];
				if (pen == null)
				{
					pen = new Pen(Color.Magenta, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MagentaKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Maroon
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MaroonKey];
				if (pen == null)
				{
					pen = new Pen(Color.Maroon, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MaroonKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumAquamarine
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumAquamarineKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumAquamarine, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumAquamarineKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumOrchid
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumOrchidKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumOrchid, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumOrchidKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumPurple
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumPurpleKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumPurple, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumPurpleKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumSeaGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumSeaGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumSeaGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumSeaGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumSlateBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumSlateBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumSlateBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumSlateBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumSpringGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumSpringGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumSpringGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumSpringGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumTurquoise
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumTurquoiseKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumTurquoise, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumTurquoiseKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MediumVioletRed
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MediumVioletRedKey];
				if (pen == null)
				{
					pen = new Pen(Color.MediumVioletRed, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MediumVioletRedKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MidnightBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MidnightBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.MidnightBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MidnightBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MintCream
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MintCreamKey];
				if (pen == null)
				{
					pen = new Pen(Color.MintCream, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MintCreamKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen MistyRose
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MistyRoseKey];
				if (pen == null)
				{
					pen = new Pen(Color.MistyRose, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MistyRoseKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Moccasin
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[MoccasinKey];
				if (pen == null)
				{
					pen = new Pen(Color.Moccasin, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[MoccasinKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen NavajoWhite
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[NavajoWhiteKey];
				if (pen == null)
				{
					pen = new Pen(Color.NavajoWhite, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[NavajoWhiteKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Navy
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[NavyKey];
				if (pen == null)
				{
					pen = new Pen(Color.Navy, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[NavyKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen OldLace
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OldLaceKey];
				if (pen == null)
				{
					pen = new Pen(Color.OldLace, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OldLaceKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Olive
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OliveKey];
				if (pen == null)
				{
					pen = new Pen(Color.Olive, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OliveKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen OliveDrab
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OliveDrabKey];
				if (pen == null)
				{
					pen = new Pen(Color.OliveDrab, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OliveDrabKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Orange
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OrangeKey];
				if (pen == null)
				{
					pen = new Pen(Color.Orange, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OrangeKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen OrangeRed
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OrangeRedKey];
				if (pen == null)
				{
					pen = new Pen(Color.OrangeRed, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OrangeRedKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Orchid
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[OrchidKey];
				if (pen == null)
				{
					pen = new Pen(Color.Orchid, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[OrchidKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PaleGoldenrod
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PaleGoldenrodKey];
				if (pen == null)
				{
					pen = new Pen(Color.PaleGoldenrod, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PaleGoldenrodKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PaleGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PaleGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.PaleGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PaleGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PaleTurquoise
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PaleTurquoiseKey];
				if (pen == null)
				{
					pen = new Pen(Color.PaleTurquoise, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PaleTurquoiseKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PaleVioletRed
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PaleVioletRedKey];
				if (pen == null)
				{
					pen = new Pen(Color.PaleVioletRed, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PaleVioletRedKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PapayaWhip
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PapayaWhipKey];
				if (pen == null)
				{
					pen = new Pen(Color.PapayaWhip, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PapayaWhipKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PeachPuff
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PeachPuffKey];
				if (pen == null)
				{
					pen = new Pen(Color.PeachPuff, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PeachPuffKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Peru
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PeruKey];
				if (pen == null)
				{
					pen = new Pen(Color.Peru, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PeruKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Pink
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PinkKey];
				if (pen == null)
				{
					pen = new Pen(Color.Pink, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PinkKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Plum
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PlumKey];
				if (pen == null)
				{
					pen = new Pen(Color.Plum, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PlumKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen PowderBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PowderBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.PowderBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PowderBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Purple
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[PurpleKey];
				if (pen == null)
				{
					pen = new Pen(Color.Purple, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[PurpleKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Red
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[RedKey];
				if (pen == null)
				{
					pen = new Pen(Color.Red, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[RedKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen RosyBrown
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[RosyBrownKey];
				if (pen == null)
				{
					pen = new Pen(Color.RosyBrown, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[RosyBrownKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen RoyalBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[RoyalBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.RoyalBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[RoyalBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SaddleBrown
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SaddleBrownKey];
				if (pen == null)
				{
					pen = new Pen(Color.SaddleBrown, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SaddleBrownKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Salmon
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SalmonKey];
				if (pen == null)
				{
					pen = new Pen(Color.Salmon, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SalmonKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SandyBrown
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SandyBrownKey];
				if (pen == null)
				{
					pen = new Pen(Color.SandyBrown, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SandyBrownKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SeaGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SeaGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.SeaGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SeaGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SeaShell
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SeaShellKey];
				if (pen == null)
				{
					pen = new Pen(Color.SeaShell, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SeaShellKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Sienna
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SiennaKey];
				if (pen == null)
				{
					pen = new Pen(Color.Sienna, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SiennaKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Silver
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SilverKey];
				if (pen == null)
				{
					pen = new Pen(Color.Silver, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SilverKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SkyBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SkyBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.SkyBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SkyBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SlateBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SlateBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.SlateBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SlateBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SlateGray
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SlateGrayKey];
				if (pen == null)
				{
					pen = new Pen(Color.SlateGray, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SlateGrayKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Snow
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SnowKey];
				if (pen == null)
				{
					pen = new Pen(Color.Snow, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SnowKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SpringGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SpringGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.SpringGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SpringGreenKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen SteelBlue
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[SteelBlueKey];
				if (pen == null)
				{
					pen = new Pen(Color.SteelBlue, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[SteelBlueKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Tan
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[TanKey];
				if (pen == null)
				{
					pen = new Pen(Color.Tan, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[TanKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Teal
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[TealKey];
				if (pen == null)
				{
					pen = new Pen(Color.Teal, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[TealKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Thistle
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[ThistleKey];
				if (pen == null)
				{
					pen = new Pen(Color.Thistle, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[ThistleKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Tomato
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[TomatoKey];
				if (pen == null)
				{
					pen = new Pen(Color.Tomato, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[TomatoKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Turquoise
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[TurquoiseKey];
				if (pen == null)
				{
					pen = new Pen(Color.Turquoise, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[TurquoiseKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Violet
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[VioletKey];
				if (pen == null)
				{
					pen = new Pen(Color.Violet, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[VioletKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Wheat
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[WheatKey];
				if (pen == null)
				{
					pen = new Pen(Color.Wheat, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[WheatKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen White
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[WhiteKey];
				if (pen == null)
				{
					pen = new Pen(Color.White, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[WhiteKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen WhiteSmoke
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[WhiteSmokeKey];
				if (pen == null)
				{
					pen = new Pen(Color.WhiteSmoke, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[WhiteSmokeKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen Yellow
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[YellowKey];
				if (pen == null)
				{
					pen = new Pen(Color.Yellow, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[YellowKey] = pen;
				}
				return pen;
			}
		}

		/// <summary>A system-defined <see cref="T:System.Drawing.Pen" /> object with a width of 1.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> object set to a system-defined color.</returns>
		public static Pen YellowGreen
		{
			get
			{
				Pen pen = (Pen)SafeNativeMethods.Gdip.ThreadData[YellowGreenKey];
				if (pen == null)
				{
					pen = new Pen(Color.YellowGreen, immutable: true);
					SafeNativeMethods.Gdip.ThreadData[YellowGreenKey] = pen;
				}
				return pen;
			}
		}

		private Pens()
		{
		}
	}
	/// <summary>Represents an ordered pair of integer x- and y-coordinates that defines a point in a two-dimensional plane.</summary>
	[Serializable]
	[TypeConverter(typeof(PointConverter))]
	[ComVisible(true)]
	public struct Point
	{
		/// <summary>Represents a <see cref="T:System.Drawing.Point" /> that has <see cref="P:System.Drawing.Point.X" /> and <see cref="P:System.Drawing.Point.Y" /> values set to zero.</summary>
		public static readonly Point Empty;

		private int x;

		private int y;

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Point" /> is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if both <see cref="P:System.Drawing.Point.X" /> and <see cref="P:System.Drawing.Point.Y" /> are 0; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (x == 0)
				{
					return y == 0;
				}
				return false;
			}
		}

		/// <summary>Gets or sets the x-coordinate of this <see cref="T:System.Drawing.Point" />.</summary>
		/// <returns>The x-coordinate of this <see cref="T:System.Drawing.Point" />.</returns>
		public int X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of this <see cref="T:System.Drawing.Point" />.</summary>
		/// <returns>The y-coordinate of this <see cref="T:System.Drawing.Point" />.</returns>
		public int Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Point" /> class with the specified coordinates.</summary>
		/// <param name="x">The horizontal position of the point.</param>
		/// <param name="y">The vertical position of the point.</param>
		public Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Point" /> class from a <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="sz">A <see cref="T:System.Drawing.Size" /> that specifies the coordinates for the new <see cref="T:System.Drawing.Point" />.</param>
		public Point(Size sz)
		{
			x = sz.Width;
			y = sz.Height;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Point" /> class using coordinates specified by an integer value.</summary>
		/// <param name="dw">A 32-bit integer that specifies the coordinates for the new <see cref="T:System.Drawing.Point" />.</param>
		public Point(int dw)
		{
			x = (short)LOWORD(dw);
			y = (short)HIWORD(dw);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.Point" /> structure to a <see cref="T:System.Drawing.PointF" /> structure.</summary>
		/// <param name="p">The <see cref="T:System.Drawing.Point" /> to be converted.</param>
		/// <returns>The <see cref="T:System.Drawing.PointF" /> that results from the conversion.</returns>
		public static implicit operator PointF(Point p)
		{
			return new PointF(p.X, p.Y);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.Point" /> structure to a <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="p">The <see cref="T:System.Drawing.Point" /> to be converted.</param>
		/// <returns>The <see cref="T:System.Drawing.Size" /> that results from the conversion.</returns>
		public static explicit operator Size(Point p)
		{
			return new Size(p.X, p.Y);
		}

		/// <summary>Translates a <see cref="T:System.Drawing.Point" /> by a given <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> to translate.</param>
		/// <param name="sz">A <see cref="T:System.Drawing.Size" /> that specifies the pair of numbers to add to the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.Point" />.</returns>
		public static Point operator +(Point pt, Size sz)
		{
			return Add(pt, sz);
		}

		/// <summary>Translates a <see cref="T:System.Drawing.Point" /> by the negative of a given <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> to translate.</param>
		/// <param name="sz">A <see cref="T:System.Drawing.Size" /> that specifies the pair of numbers to subtract from the coordinates of <paramref name="pt" />.</param>
		/// <returns>A <see cref="T:System.Drawing.Point" /> structure that is translated by the negative of a given <see cref="T:System.Drawing.Size" /> structure.</returns>
		public static Point operator -(Point pt, Size sz)
		{
			return Subtract(pt, sz);
		}

		/// <summary>Compares two <see cref="T:System.Drawing.Point" /> objects. The result specifies whether the values of the <see cref="P:System.Drawing.Point.X" /> and <see cref="P:System.Drawing.Point.Y" /> properties of the two <see cref="T:System.Drawing.Point" /> objects are equal.</summary>
		/// <param name="left">A <see cref="T:System.Drawing.Point" /> to compare.</param>
		/// <param name="right">A <see cref="T:System.Drawing.Point" /> to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Drawing.Point.X" /> and <see cref="P:System.Drawing.Point.Y" /> values of <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(Point left, Point right)
		{
			if (left.X == right.X)
			{
				return left.Y == right.Y;
			}
			return false;
		}

		/// <summary>Compares two <see cref="T:System.Drawing.Point" /> objects. The result specifies whether the values of the <see cref="P:System.Drawing.Point.X" /> or <see cref="P:System.Drawing.Point.Y" /> properties of the two <see cref="T:System.Drawing.Point" /> objects are unequal.</summary>
		/// <param name="left">A <see cref="T:System.Drawing.Point" /> to compare.</param>
		/// <param name="right">A <see cref="T:System.Drawing.Point" /> to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the values of either the <see cref="P:System.Drawing.Point.X" /> properties or the <see cref="P:System.Drawing.Point.Y" /> properties of <paramref name="left" /> and <paramref name="right" /> differ; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(Point left, Point right)
		{
			return !(left == right);
		}

		/// <summary>Adds the specified <see cref="T:System.Drawing.Size" /> to the specified <see cref="T:System.Drawing.Point" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> to add.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.Size" /> to add</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> that is the result of the addition operation.</returns>
		public static Point Add(Point pt, Size sz)
		{
			return new Point(pt.X + sz.Width, pt.Y + sz.Height);
		}

		/// <summary>Returns the result of subtracting specified <see cref="T:System.Drawing.Size" /> from the specified <see cref="T:System.Drawing.Point" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> to be subtracted from.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.Size" /> to subtract from the <see cref="T:System.Drawing.Point" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> that is the result of the subtraction operation.</returns>
		public static Point Subtract(Point pt, Size sz)
		{
			return new Point(pt.X - sz.Width, pt.Y - sz.Height);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.PointF" /> to a <see cref="T:System.Drawing.Point" /> by rounding the values of the <see cref="T:System.Drawing.PointF" /> to the next higher integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.PointF" /> to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> this method converts to.</returns>
		public static Point Ceiling(PointF value)
		{
			return new Point((int)Math.Ceiling(value.X), (int)Math.Ceiling(value.Y));
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.PointF" /> to a <see cref="T:System.Drawing.Point" /> by truncating the values of the <see cref="T:System.Drawing.Point" />.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.PointF" /> to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> this method converts to.</returns>
		public static Point Truncate(PointF value)
		{
			return new Point((int)value.X, (int)value.Y);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.PointF" /> to a <see cref="T:System.Drawing.Point" /> object by rounding the <see cref="T:System.Drawing.Point" /> values to the nearest integer.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.PointF" /> to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> this method converts to.</returns>
		public static Point Round(PointF value)
		{
			return new Point((int)Math.Round(value.X), (int)Math.Round(value.Y));
		}

		/// <summary>Specifies whether this <see cref="T:System.Drawing.Point" /> contains the same coordinates as the specified <see cref="T:System.Object" />.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.Point" /> and has the same coordinates as this <see cref="T:System.Drawing.Point" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Point point))
			{
				return false;
			}
			if (point.X == X)
			{
				return point.Y == Y;
			}
			return false;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.Point" />.</summary>
		/// <returns>An integer value that specifies a hash value for this <see cref="T:System.Drawing.Point" />.</returns>
		public override int GetHashCode()
		{
			return x ^ y;
		}

		/// <summary>Translates this <see cref="T:System.Drawing.Point" /> by the specified amount.</summary>
		/// <param name="dx">The amount to offset the x-coordinate.</param>
		/// <param name="dy">The amount to offset the y-coordinate.</param>
		public void Offset(int dx, int dy)
		{
			X += dx;
			Y += dy;
		}

		/// <summary>Translates this <see cref="T:System.Drawing.Point" /> by the specified <see cref="T:System.Drawing.Point" />.</summary>
		/// <param name="p">The <see cref="T:System.Drawing.Point" /> used offset this <see cref="T:System.Drawing.Point" />.</param>
		public void Offset(Point p)
		{
			Offset(p.X, p.Y);
		}

		/// <summary>Converts this <see cref="T:System.Drawing.Point" /> to a human-readable string.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.Point" />.</returns>
		public override string ToString()
		{
			return "{X=" + X.ToString(CultureInfo.CurrentCulture) + ",Y=" + Y.ToString(CultureInfo.CurrentCulture) + "}";
		}

		private static int HIWORD(int n)
		{
			return (n >> 16) & 0xFFFF;
		}

		private static int LOWORD(int n)
		{
			return n & 0xFFFF;
		}
	}
	/// <summary>Converts a <see cref="T:System.Drawing.Point" /> object from one data type to another.</summary>
	public class PointConverter : TypeConverter
	{
		/// <summary>Determines if this converter can convert an object in the given source type to the native type of the converter.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="sourceType">The type you want to convert from.</param>
		/// <returns>
		///   <see langword="true" /> if this object can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Gets a value indicating whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> object that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> object that represents the type you want to convert to.</param>
		/// <returns>
		///   <see langword="true" /> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the specified object to a <see cref="T:System.Drawing.Point" /> object.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An object that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string[] array = text2.Split(c);
				int[] array2 = new int[array.Length];
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (int)converter.ConvertFromString(context, culture, array[i]);
				}
				if (array2.Length == 2)
				{
					return new Point(array2[0], array2[1]);
				}
				throw new ArgumentException(SR.GetString("TextParseFailedFormat", text2, "x, y"));
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts the specified object to the specified type.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An object that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The type to convert the object to.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is Point)
			{
				if (destinationType == typeof(string))
				{
					Point point = (Point)value;
					if (culture == null)
					{
						culture = CultureInfo.CurrentCulture;
					}
					string separator = culture.TextInfo.ListSeparator + " ";
					TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
					string[] array = new string[2];
					int num = 0;
					array[num++] = converter.ConvertToString(context, culture, point.X);
					array[num++] = converter.ConvertToString(context, culture, point.Y);
					return string.Join(separator, array);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					Point point2 = (Point)value;
					ConstructorInfo constructor = typeof(Point).GetConstructor(new Type[2]
					{
						typeof(int),
						typeof(int)
					});
					if (constructor != null)
					{
						return new InstanceDescriptor(constructor, new object[2] { point2.X, point2.Y });
					}
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Creates an instance of this type given a set of property values for the object.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <param name="propertyValues">A dictionary of new property values. The dictionary contains a series of name-value pairs, one for each property returned from <see cref="M:System.Drawing.PointConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" />.</param>
		/// <returns>The newly created object, or <see langword="null" /> if the object could not be created. The default implementation returns <see langword="null" />.</returns>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			if (propertyValues == null)
			{
				throw new ArgumentNullException("propertyValues");
			}
			object obj = propertyValues["X"];
			object obj2 = propertyValues["Y"];
			if (obj == null || obj2 == null || !(obj is int) || !(obj2 is int))
			{
				throw new ArgumentException(SR.GetString("PropertyValueInvalidEntry"));
			}
			return new Point((int)obj, (int)obj2);
		}

		/// <summary>Determines if changing a value on this object should require a call to <see cref="M:System.Drawing.PointConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> to create a new value.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="M:System.Drawing.PointConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> method should be called when a change is made to one or more properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Retrieves the set of properties for this type. By default, a type does not return any properties.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <param name="value">The value of the object to get the properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>The set of properties that are exposed for this data type. If no properties are exposed, this method might return <see langword="null" />. The default implementation always returns <see langword="null" />.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(Point), attributes);
			return properties.Sort(new string[2] { "X", "Y" });
		}

		/// <summary>Determines if this object supports properties. By default, this is <see langword="false" />.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <returns>
		///   <see langword="true" /> if <see cref="M:System.Drawing.PointConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> should be called to find the properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.PointConverter" /> class.</summary>
		public PointConverter()
		{
		}
	}
	/// <summary>Stores a set of four integers that represent the location and size of a rectangle</summary>
	[Serializable]
	[TypeConverter(typeof(RectangleConverter))]
	[ComVisible(true)]
	public struct Rectangle
	{
		/// <summary>Represents a <see cref="T:System.Drawing.Rectangle" /> structure with its properties left uninitialized.</summary>
		public static readonly Rectangle Empty;

		private int x;

		private int y;

		private int width;

		private int height;

		/// <summary>Gets or sets the coordinates of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>A <see cref="T:System.Drawing.Point" /> that represents the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</returns>
		[Browsable(false)]
		public Point Location
		{
			get
			{
				return new Point(X, Y);
			}
			set
			{
				X = value.X;
				Y = value.Y;
			}
		}

		/// <summary>Gets or sets the size of this <see cref="T:System.Drawing.Rectangle" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> that represents the width and height of this <see cref="T:System.Drawing.Rectangle" /> structure.</returns>
		[Browsable(false)]
		public Size Size
		{
			get
			{
				return new Size(Width, Height);
			}
			set
			{
				Width = value.Width;
				Height = value.Height;
			}
		}

		/// <summary>Gets or sets the x-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The x-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure. The default is 0.</returns>
		public int X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The y-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure. The default is 0.</returns>
		public int Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		/// <summary>Gets or sets the width of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The width of this <see cref="T:System.Drawing.Rectangle" /> structure. The default is 0.</returns>
		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		/// <summary>Gets or sets the height of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The height of this <see cref="T:System.Drawing.Rectangle" /> structure. The default is 0.</returns>
		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		/// <summary>Gets the x-coordinate of the left edge of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The x-coordinate of the left edge of this <see cref="T:System.Drawing.Rectangle" /> structure.</returns>
		[Browsable(false)]
		public int Left => X;

		/// <summary>Gets the y-coordinate of the top edge of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The y-coordinate of the top edge of this <see cref="T:System.Drawing.Rectangle" /> structure.</returns>
		[Browsable(false)]
		public int Top => Y;

		/// <summary>Gets the x-coordinate that is the sum of <see cref="P:System.Drawing.Rectangle.X" /> and <see cref="P:System.Drawing.Rectangle.Width" /> property values of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The x-coordinate that is the sum of <see cref="P:System.Drawing.Rectangle.X" /> and <see cref="P:System.Drawing.Rectangle.Width" /> of this <see cref="T:System.Drawing.Rectangle" />.</returns>
		[Browsable(false)]
		public int Right => X + Width;

		/// <summary>Gets the y-coordinate that is the sum of the <see cref="P:System.Drawing.Rectangle.Y" /> and <see cref="P:System.Drawing.Rectangle.Height" /> property values of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <returns>The y-coordinate that is the sum of <see cref="P:System.Drawing.Rectangle.Y" /> and <see cref="P:System.Drawing.Rectangle.Height" /> of this <see cref="T:System.Drawing.Rectangle" />.</returns>
		[Browsable(false)]
		public int Bottom => Y + Height;

		/// <summary>Tests whether all numeric properties of this <see cref="T:System.Drawing.Rectangle" /> have values of zero.</summary>
		/// <returns>This property returns <see langword="true" /> if the <see cref="P:System.Drawing.Rectangle.Width" />, <see cref="P:System.Drawing.Rectangle.Height" />, <see cref="P:System.Drawing.Rectangle.X" />, and <see cref="P:System.Drawing.Rectangle.Y" /> properties of this <see cref="T:System.Drawing.Rectangle" /> all have values of zero; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (height == 0 && width == 0 && x == 0)
				{
					return y == 0;
				}
				return false;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Rectangle" /> class with the specified location and size.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle.</param>
		/// <param name="width">The width of the rectangle.</param>
		/// <param name="height">The height of the rectangle.</param>
		public Rectangle(int x, int y, int width, int height)
		{
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Rectangle" /> class with the specified location and size.</summary>
		/// <param name="location">A <see cref="T:System.Drawing.Point" /> that represents the upper-left corner of the rectangular region.</param>
		/// <param name="size">A <see cref="T:System.Drawing.Size" /> that represents the width and height of the rectangular region.</param>
		public Rectangle(Point location, Size size)
		{
			x = location.X;
			y = location.Y;
			width = size.Width;
			height = size.Height;
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Rectangle" /> structure with the specified edge locations.</summary>
		/// <param name="left">The x-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</param>
		/// <param name="top">The y-coordinate of the upper-left corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</param>
		/// <param name="right">The x-coordinate of the lower-right corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</param>
		/// <param name="bottom">The y-coordinate of the lower-right corner of this <see cref="T:System.Drawing.Rectangle" /> structure.</param>
		/// <returns>The new <see cref="T:System.Drawing.Rectangle" /> that this method creates.</returns>
		public static Rectangle FromLTRB(int left, int top, int right, int bottom)
		{
			return new Rectangle(left, top, right - left, bottom - top);
		}

		/// <summary>Tests whether <paramref name="obj" /> is a <see cref="T:System.Drawing.Rectangle" /> structure with the same location and size of this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.Rectangle" /> structure and its <see cref="P:System.Drawing.Rectangle.X" />, <see cref="P:System.Drawing.Rectangle.Y" />, <see cref="P:System.Drawing.Rectangle.Width" />, and <see cref="P:System.Drawing.Rectangle.Height" /> properties are equal to the corresponding properties of this <see cref="T:System.Drawing.Rectangle" /> structure; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Rectangle rectangle))
			{
				return false;
			}
			if (rectangle.X == X && rectangle.Y == Y && rectangle.Width == Width)
			{
				return rectangle.Height == Height;
			}
			return false;
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.Rectangle" /> structures have equal location and size.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.Rectangle" /> structure that is to the left of the equality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.Rectangle" /> structure that is to the right of the equality operator.</param>
		/// <returns>This operator returns <see langword="true" /> if the two <see cref="T:System.Drawing.Rectangle" /> structures have equal <see cref="P:System.Drawing.Rectangle.X" />, <see cref="P:System.Drawing.Rectangle.Y" />, <see cref="P:System.Drawing.Rectangle.Width" />, and <see cref="P:System.Drawing.Rectangle.Height" /> properties.</returns>
		public static bool operator ==(Rectangle left, Rectangle right)
		{
			if (left.X == right.X && left.Y == right.Y && left.Width == right.Width)
			{
				return left.Height == right.Height;
			}
			return false;
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.Rectangle" /> structures differ in location or size.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.Rectangle" /> structure that is to the left of the inequality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.Rectangle" /> structure that is to the right of the inequality operator.</param>
		/// <returns>This operator returns <see langword="true" /> if any of the <see cref="P:System.Drawing.Rectangle.X" />, <see cref="P:System.Drawing.Rectangle.Y" />, <see cref="P:System.Drawing.Rectangle.Width" /> or <see cref="P:System.Drawing.Rectangle.Height" /> properties of the two <see cref="T:System.Drawing.Rectangle" /> structures are unequal; otherwise <see langword="false" />.</returns>
		public static bool operator !=(Rectangle left, Rectangle right)
		{
			return !(left == right);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.RectangleF" /> structure to a <see cref="T:System.Drawing.Rectangle" /> structure by rounding the <see cref="T:System.Drawing.RectangleF" /> values to the next higher integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.RectangleF" /> structure to be converted.</param>
		/// <returns>Returns a <see cref="T:System.Drawing.Rectangle" />.</returns>
		public static Rectangle Ceiling(RectangleF value)
		{
			return new Rectangle((int)Math.Ceiling(value.X), (int)Math.Ceiling(value.Y), (int)Math.Ceiling(value.Width), (int)Math.Ceiling(value.Height));
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.RectangleF" /> to a <see cref="T:System.Drawing.Rectangle" /> by truncating the <see cref="T:System.Drawing.RectangleF" /> values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.RectangleF" /> to be converted.</param>
		/// <returns>The truncated value of the  <see cref="T:System.Drawing.Rectangle" />.</returns>
		public static Rectangle Truncate(RectangleF value)
		{
			return new Rectangle((int)value.X, (int)value.Y, (int)value.Width, (int)value.Height);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.RectangleF" /> to a <see cref="T:System.Drawing.Rectangle" /> by rounding the <see cref="T:System.Drawing.RectangleF" /> values to the nearest integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.RectangleF" /> to be converted.</param>
		/// <returns>The rounded interger value of the <see cref="T:System.Drawing.Rectangle" />.</returns>
		public static Rectangle Round(RectangleF value)
		{
			return new Rectangle((int)Math.Round(value.X), (int)Math.Round(value.Y), (int)Math.Round(value.Width), (int)Math.Round(value.Height));
		}

		/// <summary>Determines if the specified point is contained within this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <returns>This method returns <see langword="true" /> if the point defined by <paramref name="x" /> and <paramref name="y" /> is contained within this <see cref="T:System.Drawing.Rectangle" /> structure; otherwise <see langword="false" />.</returns>
		public bool Contains(int x, int y)
		{
			if (X <= x && x < X + Width && Y <= y)
			{
				return y < Y + Height;
			}
			return false;
		}

		/// <summary>Determines if the specified point is contained within this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the point represented by <paramref name="pt" /> is contained within this <see cref="T:System.Drawing.Rectangle" /> structure; otherwise <see langword="false" />.</returns>
		public bool Contains(Point pt)
		{
			return Contains(pt.X, pt.Y);
		}

		/// <summary>Determines if the rectangular region represented by <paramref name="rect" /> is entirely contained within this <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the rectangular region represented by <paramref name="rect" /> is entirely contained within this <see cref="T:System.Drawing.Rectangle" /> structure; otherwise <see langword="false" />.</returns>
		public bool Contains(Rectangle rect)
		{
			if (X <= rect.X && rect.X + rect.Width <= X + Width && Y <= rect.Y)
			{
				return rect.Y + rect.Height <= Y + Height;
			}
			return false;
		}

		/// <summary>Returns the hash code for this <see cref="T:System.Drawing.Rectangle" /> structure. For information about the use of hash codes, see <see cref="M:System.Object.GetHashCode" /> .</summary>
		/// <returns>An integer that represents the hash code for this rectangle.</returns>
		public override int GetHashCode()
		{
			return X ^ ((Y << 13) | (int)((uint)Y >> 19)) ^ ((Width << 26) | (int)((uint)Width >> 6)) ^ ((Height << 7) | (int)((uint)Height >> 25));
		}

		/// <summary>Enlarges this <see cref="T:System.Drawing.Rectangle" /> by the specified amount.</summary>
		/// <param name="width">The amount to inflate this <see cref="T:System.Drawing.Rectangle" /> horizontally.</param>
		/// <param name="height">The amount to inflate this <see cref="T:System.Drawing.Rectangle" /> vertically.</param>
		public void Inflate(int width, int height)
		{
			X -= width;
			Y -= height;
			Width += 2 * width;
			Height += 2 * height;
		}

		/// <summary>Enlarges this <see cref="T:System.Drawing.Rectangle" /> by the specified amount.</summary>
		/// <param name="size">The amount to inflate this rectangle.</param>
		public void Inflate(Size size)
		{
			Inflate(size.Width, size.Height);
		}

		/// <summary>Creates and returns an enlarged copy of the specified <see cref="T:System.Drawing.Rectangle" /> structure. The copy is enlarged by the specified amount. The original <see cref="T:System.Drawing.Rectangle" /> structure remains unmodified.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> with which to start. This rectangle is not modified.</param>
		/// <param name="x">The amount to inflate this <see cref="T:System.Drawing.Rectangle" /> horizontally.</param>
		/// <param name="y">The amount to inflate this <see cref="T:System.Drawing.Rectangle" /> vertically.</param>
		/// <returns>The enlarged <see cref="T:System.Drawing.Rectangle" />.</returns>
		public static Rectangle Inflate(Rectangle rect, int x, int y)
		{
			Rectangle result = rect;
			result.Inflate(x, y);
			return result;
		}

		/// <summary>Replaces this <see cref="T:System.Drawing.Rectangle" /> with the intersection of itself and the specified <see cref="T:System.Drawing.Rectangle" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> with which to intersect.</param>
		public void Intersect(Rectangle rect)
		{
			Rectangle rectangle = Intersect(rect, this);
			X = rectangle.X;
			Y = rectangle.Y;
			Width = rectangle.Width;
			Height = rectangle.Height;
		}

		/// <summary>Returns a third <see cref="T:System.Drawing.Rectangle" /> structure that represents the intersection of two other <see cref="T:System.Drawing.Rectangle" /> structures. If there is no intersection, an empty <see cref="T:System.Drawing.Rectangle" /> is returned.</summary>
		/// <param name="a">A rectangle to intersect.</param>
		/// <param name="b">A rectangle to intersect.</param>
		/// <returns>A <see cref="T:System.Drawing.Rectangle" /> that represents the intersection of <paramref name="a" /> and <paramref name="b" />.</returns>
		public static Rectangle Intersect(Rectangle a, Rectangle b)
		{
			int num = Math.Max(a.X, b.X);
			int num2 = Math.Min(a.X + a.Width, b.X + b.Width);
			int num3 = Math.Max(a.Y, b.Y);
			int num4 = Math.Min(a.Y + a.Height, b.Y + b.Height);
			if (num2 >= num && num4 >= num3)
			{
				return new Rectangle(num, num3, num2 - num, num4 - num3);
			}
			return Empty;
		}

		/// <summary>Determines if this rectangle intersects with <paramref name="rect" />.</summary>
		/// <param name="rect">The rectangle to test.</param>
		/// <returns>This method returns <see langword="true" /> if there is any intersection, otherwise <see langword="false" />.</returns>
		public bool IntersectsWith(Rectangle rect)
		{
			if (rect.X < X + Width && X < rect.X + rect.Width && rect.Y < Y + Height)
			{
				return Y < rect.Y + rect.Height;
			}
			return false;
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Rectangle" /> structure that contains the union of two <see cref="T:System.Drawing.Rectangle" /> structures.</summary>
		/// <param name="a">A rectangle to union.</param>
		/// <param name="b">A rectangle to union.</param>
		/// <returns>A <see cref="T:System.Drawing.Rectangle" /> structure that bounds the union of the two <see cref="T:System.Drawing.Rectangle" /> structures.</returns>
		public static Rectangle Union(Rectangle a, Rectangle b)
		{
			int num = Math.Min(a.X, b.X);
			int num2 = Math.Max(a.X + a.Width, b.X + b.Width);
			int num3 = Math.Min(a.Y, b.Y);
			int num4 = Math.Max(a.Y + a.Height, b.Y + b.Height);
			return new Rectangle(num, num3, num2 - num, num4 - num3);
		}

		/// <summary>Adjusts the location of this rectangle by the specified amount.</summary>
		/// <param name="pos">Amount to offset the location.</param>
		public void Offset(Point pos)
		{
			Offset(pos.X, pos.Y);
		}

		/// <summary>Adjusts the location of this rectangle by the specified amount.</summary>
		/// <param name="x">The horizontal offset.</param>
		/// <param name="y">The vertical offset.</param>
		public void Offset(int x, int y)
		{
			X += x;
			Y += y;
		}

		/// <summary>Converts the attributes of this <see cref="T:System.Drawing.Rectangle" /> to a human-readable string.</summary>
		/// <returns>A string that contains the position, width, and height of this <see cref="T:System.Drawing.Rectangle" /> structure ¾ for example, {X=20, Y=20, Width=100, Height=50}</returns>
		public override string ToString()
		{
			return "{X=" + X.ToString(CultureInfo.CurrentCulture) + ",Y=" + Y.ToString(CultureInfo.CurrentCulture) + ",Width=" + Width.ToString(CultureInfo.CurrentCulture) + ",Height=" + Height.ToString(CultureInfo.CurrentCulture) + "}";
		}
	}
	/// <summary>Converts rectangles from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" />.</summary>
	public class RectangleConverter : TypeConverter
	{
		/// <summary>Determines if this converter can convert an object in the given source type to the native type of the converter.</summary>
		/// <param name="context">A formatter context. This object can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="sourceType">The type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this object can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Gets a value indicating whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> object that provides a format context. This can be <see langword="null" />, so you should always check. Also, properties on the context object can also return <see langword="null" />.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> object that represents the type you want to convert to.</param>
		/// <returns>This method returns <see langword="true" /> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the given object to a <see cref="T:System.Drawing.Rectangle" /> object.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An <see cref="T:System.Globalization.CultureInfo" /> that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string[] array = text2.Split(c);
				int[] array2 = new int[array.Length];
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (int)converter.ConvertFromString(context, culture, array[i]);
				}
				if (array2.Length == 4)
				{
					return new Rectangle(array2[0], array2[1], array2[2], array2[3]);
				}
				throw new ArgumentException(SR.GetString("TextParseFailedFormat", "text", text2, "x, y, width, height"));
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts the specified object to the specified type.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An <see cref="T:System.Globalization.CultureInfo" /> that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The type to convert the object to.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is Rectangle)
			{
				if (destinationType == typeof(string))
				{
					Rectangle rectangle = (Rectangle)value;
					if (culture == null)
					{
						culture = CultureInfo.CurrentCulture;
					}
					string separator = culture.TextInfo.ListSeparator + " ";
					TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
					string[] array = new string[4];
					int num = 0;
					array[num++] = converter.ConvertToString(context, culture, rectangle.X);
					array[num++] = converter.ConvertToString(context, culture, rectangle.Y);
					array[num++] = converter.ConvertToString(context, culture, rectangle.Width);
					array[num++] = converter.ConvertToString(context, culture, rectangle.Height);
					return string.Join(separator, array);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					Rectangle rectangle2 = (Rectangle)value;
					ConstructorInfo constructor = typeof(Rectangle).GetConstructor(new Type[4]
					{
						typeof(int),
						typeof(int),
						typeof(int),
						typeof(int)
					});
					if (constructor != null)
					{
						return new InstanceDescriptor(constructor, new object[4] { rectangle2.X, rectangle2.Y, rectangle2.Width, rectangle2.Height });
					}
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Creates an instance of this type given a set of property values for the object. This is useful for objects that are immutable but still want to provide changeable properties.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be provided.</param>
		/// <param name="propertyValues">A dictionary of new property values. The dictionary contains a series of name-value pairs, one for each property returned from a call to the <see cref="M:System.Drawing.RectangleConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> method.</param>
		/// <returns>The newly created object, or <see langword="null" /> if the object could not be created. The default implementation returns <see langword="null" />.</returns>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			if (propertyValues == null)
			{
				throw new ArgumentNullException("propertyValues");
			}
			object obj = propertyValues["X"];
			object obj2 = propertyValues["Y"];
			object obj3 = propertyValues["Width"];
			object obj4 = propertyValues["Height"];
			if (obj == null || obj2 == null || obj3 == null || obj4 == null || !(obj is int) || !(obj2 is int) || !(obj3 is int) || !(obj4 is int))
			{
				throw new ArgumentException(SR.GetString("PropertyValueInvalidEntry"));
			}
			return new Rectangle((int)obj, (int)obj2, (int)obj3, (int)obj4);
		}

		/// <summary>Determines if changing a value on this object should require a call to <see cref="M:System.Drawing.RectangleConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> to create a new value.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if <see cref="M:System.Drawing.RectangleConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> should be called when a change is made to one or more properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Retrieves the set of properties for this type. By default, a type does not return any properties.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be provided.</param>
		/// <param name="value">The value of the object to get the properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>The set of properties that should be exposed for this data type. If no properties should be exposed, this may return <see langword="null" />. The default implementation always returns <see langword="null" />.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(Rectangle), attributes);
			return properties.Sort(new string[4] { "X", "Y", "Width", "Height" });
		}

		/// <summary>Determines if this object supports properties. By default, this is <see langword="false" />.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if <see cref="M:System.Drawing.RectangleConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> should be called to find the properties of this object; otherwise, <see langword="false" />.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.RectangleConverter" /> class.</summary>
		public RectangleConverter()
		{
		}
	}
	/// <summary>Describes the interior of a graphics shape composed of rectangles and paths. This class cannot be inherited.</summary>
	public sealed class Region : MarshalByRefObject, IDisposable
	{
		internal IntPtr nativeRegion;

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" />.</summary>
		public Region()
		{
			IntPtr region = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateRegion(out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeRegion(region);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" /> from the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> structure that defines the interior of the new <see cref="T:System.Drawing.Region" />.</param>
		public Region(RectangleF rect)
		{
			IntPtr region = IntPtr.Zero;
			GPRECTF gprectf = rect.ToGPRECTF();
			int num = SafeNativeMethods.Gdip.GdipCreateRegionRect(ref gprectf, out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeRegion(region);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" /> from the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that defines the interior of the new <see cref="T:System.Drawing.Region" />.</param>
		public Region(Rectangle rect)
		{
			IntPtr region = IntPtr.Zero;
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCreateRegionRectI(ref gprect, out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeRegion(region);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" /> with the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that defines the new <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="path" /> is <see langword="null" />.</exception>
		public Region(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			IntPtr region = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateRegionPath(new HandleRef(path, path.nativePath), out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeRegion(region);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" /> from the specified data.</summary>
		/// <param name="rgnData">A <see cref="T:System.Drawing.Drawing2D.RegionData" /> that defines the interior of the new <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="rgnData" /> is <see langword="null" />.</exception>
		public Region(RegionData rgnData)
		{
			if (rgnData == null)
			{
				throw new ArgumentNullException("rgnData");
			}
			IntPtr region = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateRegionRgnData(rgnData.Data, rgnData.Data.Length, out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeRegion(region);
		}

		internal Region(IntPtr nativeRegion)
		{
			SetNativeRegion(nativeRegion);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Region" /> from a handle to the specified existing GDI region.</summary>
		/// <param name="hrgn">A handle to an existing <see cref="T:System.Drawing.Region" />.</param>
		/// <returns>The new <see cref="T:System.Drawing.Region" />.</returns>
		public static Region FromHrgn(IntPtr hrgn)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr region = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateRegionHrgn(new HandleRef(null, hrgn), out region);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Region(region);
		}

		private void SetNativeRegion(IntPtr nativeRegion)
		{
			if (nativeRegion == IntPtr.Zero)
			{
				throw new ArgumentNullException("nativeRegion");
			}
			this.nativeRegion = nativeRegion;
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Region" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Region" /> that this method creates.</returns>
		public Region Clone()
		{
			IntPtr cloneregion = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneRegion(new HandleRef(this, nativeRegion), out cloneregion);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Region(cloneregion);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Region" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeRegion != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeleteRegion(new HandleRef(this, nativeRegion));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeRegion = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Region()
		{
			Dispose(disposing: false);
		}

		/// <summary>Initializes this <see cref="T:System.Drawing.Region" /> object to an infinite interior.</summary>
		public void MakeInfinite()
		{
			int num = SafeNativeMethods.Gdip.GdipSetInfinite(new HandleRef(this, nativeRegion));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Initializes this <see cref="T:System.Drawing.Region" /> to an empty interior.</summary>
		public void MakeEmpty()
		{
			int num = SafeNativeMethods.Gdip.GdipSetEmpty(new HandleRef(this, nativeRegion));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the intersection of itself with the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to intersect with this <see cref="T:System.Drawing.Region" />.</param>
		public void Intersect(RectangleF rect)
		{
			GPRECTF gprectf = rect.ToGPRECTF();
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the intersection of itself with the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to intersect with this <see cref="T:System.Drawing.Region" />.</param>
		public void Intersect(Rectangle rect)
		{
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the intersection of itself with the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to intersect with this <see cref="T:System.Drawing.Region" />.</param>
		public void Intersect(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the intersection of itself with the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> to intersect with this <see cref="T:System.Drawing.Region" />.</param>
		public void Intersect(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Intersect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Releases the handle of the <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="regionHandle">The handle to the <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="regionHandle" /> is <see langword="null" />.</exception>
		public void ReleaseHrgn(IntPtr regionHandle)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			if (regionHandle == IntPtr.Zero)
			{
				throw new ArgumentNullException("regionHandle");
			}
			SafeNativeMethods.IntDeleteObject(new HandleRef(this, regionHandle));
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union of itself and the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to unite with this <see cref="T:System.Drawing.Region" />.</param>
		public void Union(RectangleF rect)
		{
			GPRECTF gprectf = new GPRECTF(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Union);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union of itself and the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to unite with this <see cref="T:System.Drawing.Region" />.</param>
		public void Union(Rectangle rect)
		{
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Union);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union of itself and the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to unite with this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="path" /> is <see langword="null" />.</exception>
		public void Union(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Union);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union of itself and the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> to unite with this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="region" /> is <see langword="null" />.</exception>
		public void Union(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Union);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union minus the intersection of itself with the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to <see cref="M:System.Drawing.Region.Xor(System.Drawing.Drawing2D.GraphicsPath)" /> with this <see cref="T:System.Drawing.Region" />.</param>
		public void Xor(RectangleF rect)
		{
			GPRECTF gprectf = new GPRECTF(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Xor);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union minus the intersection of itself with the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to <see cref="Overload:System.Drawing.Region.Xor" /> with this <see cref="T:System.Drawing.Region" />.</param>
		public void Xor(Rectangle rect)
		{
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Xor);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union minus the intersection of itself with the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to <see cref="Overload:System.Drawing.Region.Xor" /> with this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="path" /> is <see langword="null" />.</exception>
		public void Xor(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Xor);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to the union minus the intersection of itself with the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> to <see cref="Overload:System.Drawing.Region.Xor" /> with this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="region" /> is <see langword="null" />.</exception>
		public void Xor(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Xor);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain only the portion of its interior that does not intersect with the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to exclude from this <see cref="T:System.Drawing.Region" />.</param>
		public void Exclude(RectangleF rect)
		{
			GPRECTF gprectf = new GPRECTF(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain only the portion of its interior that does not intersect with the specified <see cref="T:System.Drawing.Rectangle" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to exclude from this <see cref="T:System.Drawing.Region" />.</param>
		public void Exclude(Rectangle rect)
		{
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain only the portion of its interior that does not intersect with the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to exclude from this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="path" /> is <see langword="null" />.</exception>
		public void Exclude(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain only the portion of its interior that does not intersect with the specified <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> to exclude from this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="region" /> is <see langword="null" />.</exception>
		public void Exclude(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Exclude);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain the portion of the specified <see cref="T:System.Drawing.RectangleF" /> structure that does not intersect with this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to complement this <see cref="T:System.Drawing.Region" />.</param>
		public void Complement(RectangleF rect)
		{
			GPRECTF gprectf = rect.ToGPRECTF();
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Complement);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain the portion of the specified <see cref="T:System.Drawing.Rectangle" /> structure that does not intersect with this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to complement this <see cref="T:System.Drawing.Region" />.</param>
		public void Complement(Rectangle rect)
		{
			GPRECT gprect = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Complement);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain the portion of the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that does not intersect with this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to complement this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="path" /> is <see langword="null" />.</exception>
		public void Complement(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Complement);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates this <see cref="T:System.Drawing.Region" /> to contain the portion of the specified <see cref="T:System.Drawing.Region" /> that does not intersect with this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> object to complement this <see cref="T:System.Drawing.Region" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="region" /> is <see langword="null" />.</exception>
		public void Complement(Region region)
		{
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int num = SafeNativeMethods.Gdip.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Complement);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Offsets the coordinates of this <see cref="T:System.Drawing.Region" /> by the specified amount.</summary>
		/// <param name="dx">The amount to offset this <see cref="T:System.Drawing.Region" /> horizontally.</param>
		/// <param name="dy">The amount to offset this <see cref="T:System.Drawing.Region" /> vertically.</param>
		public void Translate(float dx, float dy)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateRegion(new HandleRef(this, nativeRegion), dx, dy);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Offsets the coordinates of this <see cref="T:System.Drawing.Region" /> by the specified amount.</summary>
		/// <param name="dx">The amount to offset this <see cref="T:System.Drawing.Region" /> horizontally.</param>
		/// <param name="dy">The amount to offset this <see cref="T:System.Drawing.Region" /> vertically.</param>
		public void Translate(int dx, int dy)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateRegionI(new HandleRef(this, nativeRegion), dx, dy);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Transforms this <see cref="T:System.Drawing.Region" /> by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to transform this <see cref="T:System.Drawing.Region" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="matrix" /> is <see langword="null" />.</exception>
		public void Transform(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipTransformRegion(new HandleRef(this, nativeRegion), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.RectangleF" /> structure that represents a rectangle that bounds this <see cref="T:System.Drawing.Region" /> on the drawing surface of a <see cref="T:System.Drawing.Graphics" /> object.</summary>
		/// <param name="g">The <see cref="T:System.Drawing.Graphics" /> on which this <see cref="T:System.Drawing.Region" /> is drawn.</param>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.Region" /> on the specified drawing surface.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> is <see langword="null" />.</exception>
		public RectangleF GetBounds(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			GPRECTF gprectf = default(GPRECTF);
			int num = SafeNativeMethods.Gdip.GdipGetRegionBounds(new HandleRef(this, nativeRegion), new HandleRef(g, g.NativeGraphics), ref gprectf);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gprectf.ToRectangleF();
		}

		/// <summary>Returns a Windows handle to this <see cref="T:System.Drawing.Region" /> in the specified graphics context.</summary>
		/// <param name="g">The <see cref="T:System.Drawing.Graphics" /> on which this <see cref="T:System.Drawing.Region" /> is drawn.</param>
		/// <returns>A Windows handle to this <see cref="T:System.Drawing.Region" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> is <see langword="null" />.</exception>
		public IntPtr GetHrgn(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			IntPtr hrgn = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetRegionHRgn(new HandleRef(this, nativeRegion), new HandleRef(g, g.NativeGraphics), out hrgn);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return hrgn;
		}

		/// <summary>Tests whether this <see cref="T:System.Drawing.Region" /> has an empty interior on the specified drawing surface.</summary>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a drawing surface.</param>
		/// <returns>
		///   <see langword="true" /> if the interior of this <see cref="T:System.Drawing.Region" /> is empty when the transformation associated with <paramref name="g" /> is applied; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> is <see langword="null" />.</exception>
		public bool IsEmpty(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsEmptyRegion(new HandleRef(this, nativeRegion), new HandleRef(g, g.NativeGraphics), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Tests whether this <see cref="T:System.Drawing.Region" /> has an infinite interior on the specified drawing surface.</summary>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a drawing surface.</param>
		/// <returns>
		///   <see langword="true" /> if the interior of this <see cref="T:System.Drawing.Region" /> is infinite when the transformation associated with <paramref name="g" /> is applied; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> is <see langword="null" />.</exception>
		public bool IsInfinite(Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsInfiniteRegion(new HandleRef(this, nativeRegion), new HandleRef(g, g.NativeGraphics), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Tests whether the specified <see cref="T:System.Drawing.Region" /> is identical to this <see cref="T:System.Drawing.Region" /> on the specified drawing surface.</summary>
		/// <param name="region">The <see cref="T:System.Drawing.Region" /> to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a drawing surface.</param>
		/// <returns>
		///   <see langword="true" /> if the interior of region is identical to the interior of this region when the transformation associated with the <paramref name="g" /> parameter is applied; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="g" /> or <paramref name="region" /> is <see langword="null" />.</exception>
		public bool Equals(Region region, Graphics g)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			if (region == null)
			{
				throw new ArgumentNullException("region");
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsEqualRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), new HandleRef(g, g.NativeGraphics), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Returns a <see cref="T:System.Drawing.Drawing2D.RegionData" /> that represents the information that describes this <see cref="T:System.Drawing.Region" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.RegionData" /> that represents the information that describes this <see cref="T:System.Drawing.Region" />.</returns>
		public RegionData GetRegionData()
		{
			int bufferSize = 0;
			int num = SafeNativeMethods.Gdip.GdipGetRegionDataSize(new HandleRef(this, nativeRegion), out bufferSize);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (bufferSize == 0)
			{
				return null;
			}
			byte[] array = new byte[bufferSize];
			num = SafeNativeMethods.Gdip.GdipGetRegionData(new HandleRef(this, nativeRegion), array, bufferSize, out bufferSize);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new RegionData(array);
		}

		/// <summary>Tests whether the specified point is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <returns>
		///   <see langword="true" /> when the specified point is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y)
		{
			return IsVisible(new PointF(x, y), null);
		}

		/// <summary>Tests whether the specified <see cref="T:System.Drawing.PointF" /> structure is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="point">The <see cref="T:System.Drawing.PointF" /> structure to test.</param>
		/// <returns>
		///   <see langword="true" /> when <paramref name="point" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(PointF point)
		{
			return IsVisible(point, null);
		}

		/// <summary>Tests whether the specified point is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when the specified point is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y, Graphics g)
		{
			return IsVisible(new PointF(x, y), g);
		}

		/// <summary>Tests whether the specified <see cref="T:System.Drawing.PointF" /> structure is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="point">The <see cref="T:System.Drawing.PointF" /> structure to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when <paramref name="point" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(PointF point, Graphics g)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRegionPoint(new HandleRef(this, nativeRegion), point.X, point.Y, new HandleRef(g, g?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Tests whether any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="width">The width of the rectangle to test.</param>
		/// <param name="height">The height of the rectangle to test.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" /> object; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y, float width, float height)
		{
			return IsVisible(new RectangleF(x, y, width, height), null);
		}

		/// <summary>Tests whether any portion of the specified <see cref="T:System.Drawing.RectangleF" /> structure is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to test.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of <paramref name="rect" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(RectangleF rect)
		{
			return IsVisible(rect, null);
		}

		/// <summary>Tests whether any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="width">The width of the rectangle to test.</param>
		/// <param name="height">The height of the rectangle to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y, float width, float height, Graphics g)
		{
			return IsVisible(new RectangleF(x, y, width, height), g);
		}

		/// <summary>Tests whether any portion of the specified <see cref="T:System.Drawing.RectangleF" /> structure is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> structure to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when <paramref name="rect" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(RectangleF rect, Graphics g)
		{
			int boolean = 0;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRegionRect(new HandleRef(this, nativeRegion), rect.X, rect.Y, rect.Width, rect.Height, new HandleRef(g, g?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Tests whether the specified point is contained within this <see cref="T:System.Drawing.Region" /> object when drawn using the specified <see cref="T:System.Drawing.Graphics" /> object.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when the specified point is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y, Graphics g)
		{
			return IsVisible(new Point(x, y), g);
		}

		/// <summary>Tests whether the specified <see cref="T:System.Drawing.Point" /> structure is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="point">The <see cref="T:System.Drawing.Point" /> structure to test.</param>
		/// <returns>
		///   <see langword="true" /> when <paramref name="point" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Point point)
		{
			return IsVisible(point, null);
		}

		/// <summary>Tests whether the specified <see cref="T:System.Drawing.Point" /> structure is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="point">The <see cref="T:System.Drawing.Point" /> structure to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when <paramref name="point" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Point point, Graphics g)
		{
			int boolean = 0;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRegionPointI(new HandleRef(this, nativeRegion), point.X, point.Y, new HandleRef(g, g?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Tests whether any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="width">The width of the rectangle to test.</param>
		/// <param name="height">The height of the rectangle to test.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y, int width, int height)
		{
			return IsVisible(new Rectangle(x, y, width, height), null);
		}

		/// <summary>Tests whether any portion of the specified <see cref="T:System.Drawing.Rectangle" /> structure is contained within this <see cref="T:System.Drawing.Region" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to test.</param>
		/// <returns>This method returns <see langword="true" /> when any portion of <paramref name="rect" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Rectangle rect)
		{
			return IsVisible(rect, null);
		}

		/// <summary>Tests whether any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle to test.</param>
		/// <param name="width">The width of the rectangle to test.</param>
		/// <param name="height">The height of the rectangle to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of the specified rectangle is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y, int width, int height, Graphics g)
		{
			return IsVisible(new Rectangle(x, y, width, height), g);
		}

		/// <summary>Tests whether any portion of the specified <see cref="T:System.Drawing.Rectangle" /> structure is contained within this <see cref="T:System.Drawing.Region" /> when drawn using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.Rectangle" /> structure to test.</param>
		/// <param name="g">A <see cref="T:System.Drawing.Graphics" /> that represents a graphics context.</param>
		/// <returns>
		///   <see langword="true" /> when any portion of the <paramref name="rect" /> is contained within this <see cref="T:System.Drawing.Region" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Rectangle rect, Graphics g)
		{
			int boolean = 0;
			int num = SafeNativeMethods.Gdip.GdipIsVisibleRegionRectI(new HandleRef(this, nativeRegion), rect.X, rect.Y, rect.Width, rect.Height, new HandleRef(g, g?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Returns an array of <see cref="T:System.Drawing.RectangleF" /> structures that approximate this <see cref="T:System.Drawing.Region" /> after the specified matrix transformation is applied.</summary>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents a geometric transformation to apply to the region.</param>
		/// <returns>An array of <see cref="T:System.Drawing.RectangleF" /> structures that approximate this <see cref="T:System.Drawing.Region" /> after the specified matrix transformation is applied.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="matrix" /> is <see langword="null" />.</exception>
		public RectangleF[] GetRegionScans(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetRegionScansCount(new HandleRef(this, nativeRegion), out count, new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			int num2 = Marshal.SizeOf(typeof(GPRECTF));
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * count));
			try
			{
				num = SafeNativeMethods.Gdip.GdipGetRegionScans(new HandleRef(this, nativeRegion), intPtr, out count, new HandleRef(matrix, matrix.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				GPRECTF gPRECTF = default(GPRECTF);
				RectangleF[] array = new RectangleF[count];
				for (int i = 0; i < count; i++)
				{
					array[i] = ((GPRECTF)UnsafeNativeMethods.PtrToStructure((IntPtr)checked((long)intPtr + num2 * i), typeof(GPRECTF))).ToRectangleF();
				}
				return array;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}
	}
	/// <summary>Specifies how much an image is rotated and the axis used to flip the image.</summary>
	public enum RotateFlipType
	{
		/// <summary>Specifies no clockwise rotation and no flipping.</summary>
		RotateNoneFlipNone = 0,
		/// <summary>Specifies a 90-degree clockwise rotation without flipping.</summary>
		Rotate90FlipNone = 1,
		/// <summary>Specifies a 180-degree clockwise rotation without flipping.</summary>
		Rotate180FlipNone = 2,
		/// <summary>Specifies a 270-degree clockwise rotation without flipping.</summary>
		Rotate270FlipNone = 3,
		/// <summary>Specifies no clockwise rotation followed by a horizontal flip.</summary>
		RotateNoneFlipX = 4,
		/// <summary>Specifies a 90-degree clockwise rotation followed by a horizontal flip.</summary>
		Rotate90FlipX = 5,
		/// <summary>Specifies a 180-degree clockwise rotation followed by a horizontal flip.</summary>
		Rotate180FlipX = 6,
		/// <summary>Specifies a 270-degree clockwise rotation followed by a horizontal flip.</summary>
		Rotate270FlipX = 7,
		/// <summary>Specifies no clockwise rotation followed by a vertical flip.</summary>
		RotateNoneFlipY = 6,
		/// <summary>Specifies a 90-degree clockwise rotation followed by a vertical flip.</summary>
		Rotate90FlipY = 7,
		/// <summary>Specifies a 180-degree clockwise rotation followed by a vertical flip.</summary>
		Rotate180FlipY = 4,
		/// <summary>Specifies a 270-degree clockwise rotation followed by a vertical flip.</summary>
		Rotate270FlipY = 5,
		/// <summary>Specifies no clockwise rotation followed by a horizontal and vertical flip.</summary>
		RotateNoneFlipXY = 2,
		/// <summary>Specifies a 90-degree clockwise rotation followed by a horizontal and vertical flip.</summary>
		Rotate90FlipXY = 3,
		/// <summary>Specifies a 180-degree clockwise rotation followed by a horizontal and vertical flip.</summary>
		Rotate180FlipXY = 0,
		/// <summary>Specifies a 270-degree clockwise rotation followed by a horizontal and vertical flip.</summary>
		Rotate270FlipXY = 1
	}
	/// <summary>Stores an ordered pair of integers, which specify a <see cref="P:System.Drawing.Size.Height" /> and <see cref="P:System.Drawing.Size.Width" />.</summary>
	[Serializable]
	[TypeConverter(typeof(SizeConverter))]
	[ComVisible(true)]
	public struct Size
	{
		/// <summary>Gets a <see cref="T:System.Drawing.Size" /> structure that has a <see cref="P:System.Drawing.Size.Height" /> and <see cref="P:System.Drawing.Size.Width" /> value of 0.</summary>
		public static readonly Size Empty;

		private int width;

		private int height;

		/// <summary>Tests whether this <see cref="T:System.Drawing.Size" /> structure has width and height of 0.</summary>
		/// <returns>This property returns <see langword="true" /> when this <see cref="T:System.Drawing.Size" /> structure has both a width and height of 0; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (width == 0)
				{
					return height == 0;
				}
				return false;
			}
		}

		/// <summary>Gets or sets the horizontal component of this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>The horizontal component of this <see cref="T:System.Drawing.Size" /> structure, typically measured in pixels.</returns>
		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		/// <summary>Gets or sets the vertical component of this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>The vertical component of this <see cref="T:System.Drawing.Size" /> structure, typically measured in pixels.</returns>
		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Size" /> structure from the specified <see cref="T:System.Drawing.Point" /> structure.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.Point" /> structure from which to initialize this <see cref="T:System.Drawing.Size" /> structure.</param>
		public Size(Point pt)
		{
			width = pt.X;
			height = pt.Y;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Size" /> structure from the specified dimensions.</summary>
		/// <param name="width">The width component of the new <see cref="T:System.Drawing.Size" />.</param>
		/// <param name="height">The height component of the new <see cref="T:System.Drawing.Size" />.</param>
		public Size(int width, int height)
		{
			this.width = width;
			this.height = height;
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.Size" /> structure to a <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="p">The <see cref="T:System.Drawing.Size" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.SizeF" /> structure to which this operator converts.</returns>
		public static implicit operator SizeF(Size p)
		{
			return new SizeF(p.Width, p.Height);
		}

		/// <summary>Adds the width and height of one <see cref="T:System.Drawing.Size" /> structure to the width and height of another <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="sz1">The first <see cref="T:System.Drawing.Size" /> to add.</param>
		/// <param name="sz2">The second <see cref="T:System.Drawing.Size" /> to add.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that is the result of the addition operation.</returns>
		public static Size operator +(Size sz1, Size sz2)
		{
			return Add(sz1, sz2);
		}

		/// <summary>Subtracts the width and height of one <see cref="T:System.Drawing.Size" /> structure from the width and height of another <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.Size" /> structure on the left side of the subtraction operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.Size" /> structure on the right side of the subtraction operator.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that is the result of the subtraction operation.</returns>
		public static Size operator -(Size sz1, Size sz2)
		{
			return Subtract(sz1, sz2);
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.Size" /> structures are equal.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.Size" /> structure on the left side of the equality operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.Size" /> structure on the right of the equality operator.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="sz1" /> and <paramref name="sz2" /> have equal width and height; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(Size sz1, Size sz2)
		{
			if (sz1.Width == sz2.Width)
			{
				return sz1.Height == sz2.Height;
			}
			return false;
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.Size" /> structures are different.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.Size" /> structure on the left of the inequality operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.Size" /> structure on the right of the inequality operator.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="sz1" /> and <paramref name="sz2" /> differ either in width or height; <see langword="false" /> if <paramref name="sz1" /> and <paramref name="sz2" /> are equal.</returns>
		public static bool operator !=(Size sz1, Size sz2)
		{
			return !(sz1 == sz2);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.Size" /> structure to a <see cref="T:System.Drawing.Point" /> structure.</summary>
		/// <param name="size">The <see cref="T:System.Drawing.Size" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Point" /> structure to which this operator converts.</returns>
		public static explicit operator Point(Size size)
		{
			return new Point(size.Width, size.Height);
		}

		/// <summary>Adds the width and height of one <see cref="T:System.Drawing.Size" /> structure to the width and height of another <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="sz1">The first <see cref="T:System.Drawing.Size" /> structure to add.</param>
		/// <param name="sz2">The second <see cref="T:System.Drawing.Size" /> structure to add.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that is the result of the addition operation.</returns>
		public static Size Add(Size sz1, Size sz2)
		{
			return new Size(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.Size" /> structure by rounding the values of the <see cref="T:System.Drawing.Size" /> structure to the next higher integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.SizeF" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Size" /> structure this method converts to.</returns>
		public static Size Ceiling(SizeF value)
		{
			return new Size((int)Math.Ceiling(value.Width), (int)Math.Ceiling(value.Height));
		}

		/// <summary>Subtracts the width and height of one <see cref="T:System.Drawing.Size" /> structure from the width and height of another <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.Size" /> structure on the left side of the subtraction operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.Size" /> structure on the right side of the subtraction operator.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that is a result of the subtraction operation.</returns>
		public static Size Subtract(Size sz1, Size sz2)
		{
			return new Size(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.Size" /> structure by truncating the values of the <see cref="T:System.Drawing.SizeF" /> structure to the next lower integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.SizeF" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Size" /> structure this method converts to.</returns>
		public static Size Truncate(SizeF value)
		{
			return new Size((int)value.Width, (int)value.Height);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.Size" /> structure by rounding the values of the <see cref="T:System.Drawing.SizeF" /> structure to the nearest integer values.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.SizeF" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.Size" /> structure this method converts to.</returns>
		public static Size Round(SizeF value)
		{
			return new Size((int)Math.Round(value.Width), (int)Math.Round(value.Height));
		}

		/// <summary>Tests to see whether the specified object is a <see cref="T:System.Drawing.Size" /> structure with the same dimensions as this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.Size" /> and has the same width and height as this <see cref="T:System.Drawing.Size" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Size size))
			{
				return false;
			}
			if (size.width == width)
			{
				return size.height == height;
			}
			return false;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>An integer value that specifies a hash value for this <see cref="T:System.Drawing.Size" /> structure.</returns>
		public override int GetHashCode()
		{
			return width ^ height;
		}

		/// <summary>Creates a human-readable string that represents this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.Size" />.</returns>
		public override string ToString()
		{
			return "{Width=" + width.ToString(CultureInfo.CurrentCulture) + ", Height=" + height.ToString(CultureInfo.CurrentCulture) + "}";
		}
	}
	/// <summary>The <see cref="T:System.Drawing.SizeConverter" /> class is used to convert from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" /> object.</summary>
	public class SizeConverter : TypeConverter
	{
		/// <summary>Determines whether this converter can convert an object in the specified source type to the native type of the converter.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="sourceType">The type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this object can perform the conversion.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Gets a value indicating whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This can be <see langword="null" />, so always check. Also, properties on the context object can return <see langword="null" />.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that represents the type you want to convert to.</param>
		/// <returns>This method returns <see langword="true" /> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the specified object to the converter's native type.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An <see cref="T:System.Globalization.CultureInfo" /> object that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string[] array = text2.Split(c);
				int[] array2 = new int[array.Length];
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (int)converter.ConvertFromString(context, culture, array[i]);
				}
				if (array2.Length == 2)
				{
					return new Size(array2[0], array2[1]);
				}
				throw new ArgumentException(SR.GetString("TextParseFailedFormat", text2, "Width,Height"));
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts the specified object to the specified type.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to get additional information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">An <see cref="T:System.Globalization.CultureInfo" /> object that contains culture specific information, such as the language, calendar, and cultural conventions associated with a specific culture. It is based on the RFC 1766 standard.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The type to convert the object to.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is Size)
			{
				if (destinationType == typeof(string))
				{
					Size size = (Size)value;
					if (culture == null)
					{
						culture = CultureInfo.CurrentCulture;
					}
					string separator = culture.TextInfo.ListSeparator + " ";
					TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
					string[] array = new string[2];
					int num = 0;
					array[num++] = converter.ConvertToString(context, culture, size.Width);
					array[num++] = converter.ConvertToString(context, culture, size.Height);
					return string.Join(separator, array);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					Size size2 = (Size)value;
					ConstructorInfo constructor = typeof(Size).GetConstructor(new Type[2]
					{
						typeof(int),
						typeof(int)
					});
					if (constructor != null)
					{
						return new InstanceDescriptor(constructor, new object[2] { size2.Width, size2.Height });
					}
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Creates an object of this type by using a specified set of property values for the object. This is useful for creating non-changeable objects that have changeable properties.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <param name="propertyValues">A dictionary of new property values. The dictionary contains a series of name-value pairs, one for each property returned from the <see cref="M:System.Drawing.SizeConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> method.</param>
		/// <returns>The newly created object, or <see langword="null" /> if the object could not be created. The default implementation returns <see langword="null" />.</returns>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			if (propertyValues == null)
			{
				throw new ArgumentNullException("propertyValues");
			}
			object obj = propertyValues["Width"];
			object obj2 = propertyValues["Height"];
			if (obj == null || obj2 == null || !(obj is int) || !(obj2 is int))
			{
				throw new ArgumentException(SR.GetString("PropertyValueInvalidEntry"));
			}
			return new Size((int)obj, (int)obj2);
		}

		/// <summary>Determines whether changing a value on this object should require a call to the <see cref="M:System.Drawing.SizeConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> method to create a new value.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="M:System.Drawing.SizeConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> object should be called when a change is made to one or more properties of this object.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Retrieves the set of properties for this type. By default, a type does not have any properties to return.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <param name="value">The value of the object to get the properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>The set of properties that should be exposed for this data type. If no properties should be exposed, this may return <see langword="null" />. The default implementation always returns <see langword="null" />.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(Size), attributes);
			return properties.Sort(new string[2] { "Width", "Height" });
		}

		/// <summary>Determines whether this object supports properties. By default, this is <see langword="false" />.</summary>
		/// <param name="context">A <see cref="T:System.ComponentModel.TypeDescriptor" /> through which additional context can be provided.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="M:System.Drawing.SizeConverter.GetProperties(System.ComponentModel.ITypeDescriptorContext,System.Object,System.Attribute[])" /> method should be called to find the properties of this object.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.SizeConverter" /> object.</summary>
		public SizeConverter()
		{
		}
	}
	/// <summary>Defines a brush of a single color. Brushes are used to fill graphics shapes, such as rectangles, ellipses, pies, polygons, and paths. This class cannot be inherited.</summary>
	public sealed class SolidBrush : Brush, ISystemColorTracker
	{
		private Color color = Color.Empty;

		private bool immutable;

		/// <summary>Gets or sets the color of this <see cref="T:System.Drawing.SolidBrush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the color of this brush.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.SolidBrush.Color" /> property is set on an immutable <see cref="T:System.Drawing.SolidBrush" />.</exception>
		public Color Color
		{
			get
			{
				if (color == Color.Empty)
				{
					int argb = 0;
					int num = SafeNativeMethods.Gdip.GdipGetSolidFillColor(new HandleRef(this, base.NativeBrush), out argb);
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					color = Color.FromArgb(argb);
				}
				return color;
			}
			set
			{
				if (immutable)
				{
					throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Brush"));
				}
				if (this.color != value)
				{
					Color color = this.color;
					InternalSetColor(value);
					if (value.IsSystemColor && !color.IsSystemColor)
					{
						SystemColorTracker.Add(this);
					}
				}
			}
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.SolidBrush" /> object of the specified color.</summary>
		/// <param name="color">A <see cref="T:System.Drawing.Color" /> structure that represents the color of this brush.</param>
		public SolidBrush(Color color)
		{
			this.color = color;
			IntPtr brush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateSolidFill(this.color.ToArgb(), out brush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(brush);
			if (color.IsSystemColor)
			{
				SystemColorTracker.Add(this);
			}
		}

		internal SolidBrush(Color color, bool immutable)
			: this(color)
		{
			this.immutable = immutable;
		}

		internal SolidBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.SolidBrush" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.SolidBrush" /> object that this method creates.</returns>
		public override object Clone()
		{
			IntPtr clonebrush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonebrush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new SolidBrush(clonebrush);
		}

		protected override void Dispose(bool disposing)
		{
			if (!disposing)
			{
				immutable = false;
			}
			else if (immutable)
			{
				throw new ArgumentException(SR.GetString("CantChangeImmutableObjects", "Brush"));
			}
			base.Dispose(disposing);
		}

		private void InternalSetColor(Color value)
		{
			int num = SafeNativeMethods.Gdip.GdipSetSolidFillColor(new HandleRef(this, base.NativeBrush), value.ToArgb());
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			color = value;
		}

		void ISystemColorTracker.OnSystemColorChanged()
		{
			if (base.NativeBrush != IntPtr.Zero)
			{
				InternalSetColor(color);
			}
		}
	}
	/// <summary>Each property of the <see cref="T:System.Drawing.SystemBrushes" /> class is a <see cref="T:System.Drawing.SolidBrush" /> that is the color of a Windows display element.</summary>
	public sealed class SystemBrushes
	{
		private static readonly object SystemBrushesKey = new object();

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the active window's border.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the active window's border.</returns>
		public static Brush ActiveBorder => FromSystemColor(SystemColors.ActiveBorder);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of the active window's title bar.</returns>
		public static Brush ActiveCaption => FromSystemColor(SystemColors.ActiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text in the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of the active window's title bar.</returns>
		public static Brush ActiveCaptionText => FromSystemColor(SystemColors.ActiveCaptionText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the application workspace.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the application workspace.</returns>
		public static Brush AppWorkspace => FromSystemColor(SystemColors.AppWorkspace);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the face color of a 3-D element.</returns>
		public static Brush ButtonFace => FromSystemColor(SystemColors.ButtonFace);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the highlight color of a 3-D element.</returns>
		public static Brush ButtonHighlight => FromSystemColor(SystemColors.ButtonHighlight);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the shadow color of a 3-D element.</returns>
		public static Brush ButtonShadow => FromSystemColor(SystemColors.ButtonShadow);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the face color of a 3-D element.</returns>
		public static Brush Control => FromSystemColor(SystemColors.Control);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the highlight color of a 3-D element.</returns>
		public static Brush ControlLightLight => FromSystemColor(SystemColors.ControlLightLight);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the light color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the light color of a 3-D element.</returns>
		public static Brush ControlLight => FromSystemColor(SystemColors.ControlLight);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the shadow color of a 3-D element.</returns>
		public static Brush ControlDark => FromSystemColor(SystemColors.ControlDark);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the dark shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the dark shadow color of a 3-D element.</returns>
		public static Brush ControlDarkDark => FromSystemColor(SystemColors.ControlDarkDark);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of text in a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of text in a 3-D element.</returns>
		public static Brush ControlText => FromSystemColor(SystemColors.ControlText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the desktop.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the desktop.</returns>
		public static Brush Desktop => FromSystemColor(SystemColors.Desktop);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the lightest color in the color gradient of an active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the lightest color in the color gradient of an active window's title bar.</returns>
		public static Brush GradientActiveCaption => FromSystemColor(SystemColors.GradientActiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the lightest color in the color gradient of an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the lightest color in the color gradient of an inactive window's title bar.</returns>
		public static Brush GradientInactiveCaption => FromSystemColor(SystemColors.GradientInactiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of dimmed text.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of dimmed text.</returns>
		public static Brush GrayText => FromSystemColor(SystemColors.GrayText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of selected items.</returns>
		public static Brush Highlight => FromSystemColor(SystemColors.Highlight);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text of selected items.</returns>
		public static Brush HighlightText => FromSystemColor(SystemColors.HighlightText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color used to designate a hot-tracked item.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color used to designate a hot-tracked item.</returns>
		public static Brush HotTrack => FromSystemColor(SystemColors.HotTrack);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of an inactive window's title bar.</returns>
		public static Brush InactiveCaption => FromSystemColor(SystemColors.InactiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of an inactive window's border.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of an inactive window's border.</returns>
		public static Brush InactiveBorder => FromSystemColor(SystemColors.InactiveBorder);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text in an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text in an inactive window's title bar.</returns>
		public static Brush InactiveCaptionText => FromSystemColor(SystemColors.InactiveCaptionText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a ToolTip.</returns>
		public static Brush Info => FromSystemColor(SystemColors.Info);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> is the color of the text of a ToolTip.</returns>
		public static Brush InfoText => FromSystemColor(SystemColors.InfoText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of a menu's background.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of a menu's background.</returns>
		public static Brush Menu => FromSystemColor(SystemColors.Menu);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a menu bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a menu bar.</returns>
		public static Brush MenuBar => FromSystemColor(SystemColors.MenuBar);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color used to highlight menu items when the menu appears as a flat menu.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color used to highlight menu items when the menu appears as a flat menu.</returns>
		public static Brush MenuHighlight => FromSystemColor(SystemColors.MenuHighlight);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of a menu's text.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of a menu's text.</returns>
		public static Brush MenuText => FromSystemColor(SystemColors.MenuText);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a scroll bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background of a scroll bar.</returns>
		public static Brush ScrollBar => FromSystemColor(SystemColors.ScrollBar);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the background in the client area of a window.</returns>
		public static Brush Window => FromSystemColor(SystemColors.Window);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of a window frame.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of a window frame.</returns>
		public static Brush WindowFrame => FromSystemColor(SystemColors.WindowFrame);

		/// <summary>Gets a <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.SolidBrush" /> that is the color of the text in the client area of a window.</returns>
		public static Brush WindowText => FromSystemColor(SystemColors.WindowText);

		private SystemBrushes()
		{
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Brush" /> from the specified <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="c">The <see cref="T:System.Drawing.Color" /> structure from which to create the <see cref="T:System.Drawing.Brush" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Brush" /> this method creates.</returns>
		public static Brush FromSystemColor(Color c)
		{
			if (!c.IsSystemColor)
			{
				throw new ArgumentException(SR.GetString("ColorNotSystemColor", c.ToString()));
			}
			Brush[] array = (Brush[])SafeNativeMethods.Gdip.ThreadData[SystemBrushesKey];
			if (array == null)
			{
				array = new Brush[33];
				SafeNativeMethods.Gdip.ThreadData[SystemBrushesKey] = array;
			}
			int num = (int)c.ToKnownColor();
			if (num > 167)
			{
				num -= 141;
			}
			num--;
			if (array[num] == null)
			{
				array[num] = new SolidBrush(c, immutable: true);
			}
			return array[num];
		}
	}
	/// <summary>Each property of the <see cref="T:System.Drawing.SystemColors" /> class is a <see cref="T:System.Drawing.Color" /> structure that is the color of a Windows display element.</summary>
	public sealed class SystemColors
	{
		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the active window's border.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the active window's border.</returns>
		public static Color ActiveBorder => new Color(KnownColor.ActiveBorder);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the active window's title bar.</returns>
		public static Color ActiveCaption => new Color(KnownColor.ActiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the text in the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the text in the active window's title bar.</returns>
		public static Color ActiveCaptionText => new Color(KnownColor.ActiveCaptionText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the application workspace.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the application workspace.</returns>
		public static Color AppWorkspace => new Color(KnownColor.AppWorkspace);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the face color of a 3-D element.</returns>
		public static Color ButtonFace => new Color(KnownColor.ButtonFace);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the highlight color of a 3-D element.</returns>
		public static Color ButtonHighlight => new Color(KnownColor.ButtonHighlight);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the shadow color of a 3-D element.</returns>
		public static Color ButtonShadow => new Color(KnownColor.ButtonShadow);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the face color of a 3-D element.</returns>
		public static Color Control => new Color(KnownColor.Control);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the shadow color of a 3-D element.</returns>
		public static Color ControlDark => new Color(KnownColor.ControlDark);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the dark shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the dark shadow color of a 3-D element.</returns>
		public static Color ControlDarkDark => new Color(KnownColor.ControlDarkDark);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the light color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the light color of a 3-D element.</returns>
		public static Color ControlLight => new Color(KnownColor.ControlLight);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the highlight color of a 3-D element.</returns>
		public static Color ControlLightLight => new Color(KnownColor.ControlLightLight);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of text in a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of text in a 3-D element.</returns>
		public static Color ControlText => new Color(KnownColor.ControlText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the desktop.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the desktop.</returns>
		public static Color Desktop => new Color(KnownColor.Desktop);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the lightest color in the color gradient of an active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the lightest color in the color gradient of an active window's title bar.</returns>
		public static Color GradientActiveCaption => new Color(KnownColor.GradientActiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the lightest color in the color gradient of an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the lightest color in the color gradient of an inactive window's title bar.</returns>
		public static Color GradientInactiveCaption => new Color(KnownColor.GradientInactiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of dimmed text.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of dimmed text.</returns>
		public static Color GrayText => new Color(KnownColor.GrayText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background of selected items.</returns>
		public static Color Highlight => new Color(KnownColor.Highlight);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the text of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the text of selected items.</returns>
		public static Color HighlightText => new Color(KnownColor.HighlightText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color used to designate a hot-tracked item.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color used to designate a hot-tracked item.</returns>
		public static Color HotTrack => new Color(KnownColor.HotTrack);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of an inactive window's border.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of an inactive window's border.</returns>
		public static Color InactiveBorder => new Color(KnownColor.InactiveBorder);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background of an inactive window's title bar.</returns>
		public static Color InactiveCaption => new Color(KnownColor.InactiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the text in an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the text in an inactive window's title bar.</returns>
		public static Color InactiveCaptionText => new Color(KnownColor.InactiveCaptionText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background of a ToolTip.</returns>
		public static Color Info => new Color(KnownColor.Info);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the text of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the text of a ToolTip.</returns>
		public static Color InfoText => new Color(KnownColor.InfoText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of a menu's background.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of a menu's background.</returns>
		public static Color Menu => new Color(KnownColor.Menu);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of a menu bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background of a menu bar.</returns>
		public static Color MenuBar => new Color(KnownColor.MenuBar);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color used to highlight menu items when the menu appears as a flat menu.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color used to highlight menu items when the menu appears as a flat menu.</returns>
		public static Color MenuHighlight => new Color(KnownColor.MenuHighlight);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of a menu's text.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of a menu's text.</returns>
		public static Color MenuText => new Color(KnownColor.MenuText);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background of a scroll bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background of a scroll bar.</returns>
		public static Color ScrollBar => new Color(KnownColor.ScrollBar);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the background in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the background in the client area of a window.</returns>
		public static Color Window => new Color(KnownColor.Window);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of a window frame.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of a window frame.</returns>
		public static Color WindowFrame => new Color(KnownColor.WindowFrame);

		/// <summary>Gets a <see cref="T:System.Drawing.Color" /> structure that is the color of the text in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that is the color of the text in the client area of a window.</returns>
		public static Color WindowText => new Color(KnownColor.WindowText);

		private SystemColors()
		{
		}
	}
	/// <summary>Specifies the fonts used to display text in Windows display elements.</summary>
	public sealed class SystemFonts
	{
		private static readonly object SystemFontsKey = new object();

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used to display text in the title bars of windows.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used to display text in the title bars of windows.</returns>
		public static Font CaptionFont
		{
			get
			{
				Font font = null;
				NativeMethods.NONCLIENTMETRICS nONCLIENTMETRICS = new NativeMethods.NONCLIENTMETRICS();
				if (UnsafeNativeMethods.SystemParametersInfo(41, nONCLIENTMETRICS.cbSize, nONCLIENTMETRICS, 0) && nONCLIENTMETRICS.lfCaptionFont != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(nONCLIENTMETRICS.lfCaptionFont);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("CaptionFont");
				return font;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used to display text in the title bars of small windows, such as tool windows.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used to display text in the title bars of small windows, such as tool windows.</returns>
		public static Font SmallCaptionFont
		{
			get
			{
				Font font = null;
				NativeMethods.NONCLIENTMETRICS nONCLIENTMETRICS = new NativeMethods.NONCLIENTMETRICS();
				if (UnsafeNativeMethods.SystemParametersInfo(41, nONCLIENTMETRICS.cbSize, nONCLIENTMETRICS, 0) && nONCLIENTMETRICS.lfSmCaptionFont != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(nONCLIENTMETRICS.lfSmCaptionFont);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("SmallCaptionFont");
				return font;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used for menus.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used for menus.</returns>
		public static Font MenuFont
		{
			get
			{
				Font font = null;
				NativeMethods.NONCLIENTMETRICS nONCLIENTMETRICS = new NativeMethods.NONCLIENTMETRICS();
				if (UnsafeNativeMethods.SystemParametersInfo(41, nONCLIENTMETRICS.cbSize, nONCLIENTMETRICS, 0) && nONCLIENTMETRICS.lfMenuFont != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(nONCLIENTMETRICS.lfMenuFont);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("MenuFont");
				return font;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used to display text in the status bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used to display text in the status bar.</returns>
		public static Font StatusFont
		{
			get
			{
				Font font = null;
				NativeMethods.NONCLIENTMETRICS nONCLIENTMETRICS = new NativeMethods.NONCLIENTMETRICS();
				if (UnsafeNativeMethods.SystemParametersInfo(41, nONCLIENTMETRICS.cbSize, nONCLIENTMETRICS, 0) && nONCLIENTMETRICS.lfStatusFont != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(nONCLIENTMETRICS.lfStatusFont);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("StatusFont");
				return font;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used for message boxes.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used for message boxes</returns>
		public static Font MessageBoxFont
		{
			get
			{
				Font font = null;
				NativeMethods.NONCLIENTMETRICS nONCLIENTMETRICS = new NativeMethods.NONCLIENTMETRICS();
				if (UnsafeNativeMethods.SystemParametersInfo(41, nONCLIENTMETRICS.cbSize, nONCLIENTMETRICS, 0) && nONCLIENTMETRICS.lfMessageFont != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(nONCLIENTMETRICS.lfMessageFont);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("MessageBoxFont");
				return font;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Font" /> that is used for icon titles.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that is used for icon titles.</returns>
		public static Font IconTitleFont
		{
			get
			{
				Font font = null;
				SafeNativeMethods.LOGFONT lOGFONT = new SafeNativeMethods.LOGFONT();
				if (UnsafeNativeMethods.SystemParametersInfo(31, Marshal.SizeOf((object)lOGFONT), lOGFONT, 0) && lOGFONT != null)
				{
					IntSecurity.ObjectFromWin32Handle.Assert();
					try
					{
						font = Font.FromLogFont(lOGFONT);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
					if (font == null)
					{
						font = DefaultFont;
					}
					else if (font.Unit != GraphicsUnit.Point)
					{
						font = FontInPoints(font);
					}
				}
				font.SetSystemFontName("IconTitleFont");
				return font;
			}
		}

		/// <summary>Gets the default font that applications can use for dialog boxes and forms.</summary>
		/// <returns>The default <see cref="T:System.Drawing.Font" /> of the system. The value returned will vary depending on the user's operating system and the local culture setting of their system.</returns>
		public static Font DefaultFont
		{
			get
			{
				Font font = null;
				bool flag = false;
				if (Environment.OSVersion.Platform == PlatformID.Win32NT && Environment.OSVersion.Version.Major <= 4 && (UnsafeNativeMethods.GetSystemDefaultLCID() & 0x3FF) == 17)
				{
					try
					{
						font = new Font("MS UI Gothic", 9f);
					}
					catch (Exception ex)
					{
						if (IsCriticalFontException(ex))
						{
							throw;
						}
					}
				}
				if (font == null)
				{
					flag = (UnsafeNativeMethods.GetSystemDefaultLCID() & 0x3FF) == 1;
				}
				if (flag)
				{
					try
					{
						font = new Font("Tahoma", 8f);
					}
					catch (Exception ex2)
					{
						if (IsCriticalFontException(ex2))
						{
							throw;
						}
					}
				}
				if (font == null)
				{
					IntPtr stockObject = UnsafeNativeMethods.GetStockObject(17);
					try
					{
						Font font2 = null;
						IntSecurity.ObjectFromWin32Handle.Assert();
						try
						{
							font2 = Font.FromHfont(stockObject);
						}
						finally
						{
							CodeAccessPermission.RevertAssert();
						}
						try
						{
							font = FontInPoints(font2);
						}
						finally
						{
							font2.Dispose();
						}
					}
					catch (ArgumentException)
					{
					}
				}
				if (font == null)
				{
					try
					{
						font = new Font("Tahoma", 8f);
					}
					catch (ArgumentException)
					{
					}
				}
				if (font == null)
				{
					font = new Font(FontFamily.GenericSansSerif, 8f);
				}
				if (font.Unit != GraphicsUnit.Point)
				{
					font = FontInPoints(font);
				}
				font.SetSystemFontName("DefaultFont");
				return font;
			}
		}

		/// <summary>Gets a font that applications can use for dialog boxes and forms.</summary>
		/// <returns>A <see cref="T:System.Drawing.Font" /> that can be used for dialog boxes and forms, depending on the operating system and local culture setting of the system.</returns>
		public static Font DialogFont
		{
			get
			{
				Font font = null;
				if ((UnsafeNativeMethods.GetSystemDefaultLCID() & 0x3FF) == 17)
				{
					font = DefaultFont;
				}
				else if (Environment.OSVersion.Platform == PlatformID.Win32Windows)
				{
					font = DefaultFont;
				}
				else
				{
					try
					{
						font = new Font("MS Shell Dlg 2", 8f);
					}
					catch (ArgumentException)
					{
					}
				}
				if (font == null)
				{
					font = DefaultFont;
				}
				else if (font.Unit != GraphicsUnit.Point)
				{
					font = FontInPoints(font);
				}
				font.SetSystemFontName("DialogFont");
				return font;
			}
		}

		private SystemFonts()
		{
		}

		private static bool IsCriticalFontException(Exception ex)
		{
			if (!(ex is ExternalException) && !(ex is ArgumentException) && !(ex is OutOfMemoryException) && !(ex is InvalidOperationException) && !(ex is NotImplementedException))
			{
				return !(ex is FileNotFoundException);
			}
			return false;
		}

		private static Font FontInPoints(Font font)
		{
			return new Font(font.FontFamily, font.SizeInPoints, font.Style, GraphicsUnit.Point, font.GdiCharSet, font.GdiVerticalFont);
		}

		/// <summary>Returns a font object that corresponds to the specified system font name.</summary>
		/// <param name="systemFontName">The name of the system font you need a font object for.</param>
		/// <returns>A <see cref="T:System.Drawing.Font" /> if the specified name matches a value in <see cref="T:System.Drawing.SystemFonts" />; otherwise, <see langword="null" />.</returns>
		public static Font GetFontByName(string systemFontName)
		{
			if ("CaptionFont".Equals(systemFontName))
			{
				return CaptionFont;
			}
			if ("DefaultFont".Equals(systemFontName))
			{
				return DefaultFont;
			}
			if ("DialogFont".Equals(systemFontName))
			{
				return DialogFont;
			}
			if ("IconTitleFont".Equals(systemFontName))
			{
				return IconTitleFont;
			}
			if ("MenuFont".Equals(systemFontName))
			{
				return MenuFont;
			}
			if ("MessageBoxFont".Equals(systemFontName))
			{
				return MessageBoxFont;
			}
			if ("SmallCaptionFont".Equals(systemFontName))
			{
				return SmallCaptionFont;
			}
			if ("StatusFont".Equals(systemFontName))
			{
				return StatusFont;
			}
			return null;
		}
	}
	/// <summary>Each property of the <see cref="T:System.Drawing.SystemIcons" /> class is an <see cref="T:System.Drawing.Icon" /> object for Windows system-wide icons. This class cannot be inherited.</summary>
	public sealed class SystemIcons
	{
		private static Icon _application;

		private static Icon _asterisk;

		private static Icon _error;

		private static Icon _exclamation;

		private static Icon _hand;

		private static Icon _information;

		private static Icon _question;

		private static Icon _warning;

		private static Icon _winlogo;

		private static Icon _shield;

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the default application icon (WIN32: IDI_APPLICATION).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the default application icon.</returns>
		public static Icon Application
		{
			get
			{
				if (_application == null)
				{
					_application = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32512));
				}
				return _application;
			}
		}

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system asterisk icon (WIN32: IDI_ASTERISK).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system asterisk icon.</returns>
		public static Icon Asterisk
		{
			get
			{
				if (_asterisk == null)
				{
					_asterisk = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32516));
				}
				return _asterisk;
			}
		}

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system error icon (WIN32: IDI_ERROR).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system error icon.</returns>
		public static Icon Error
		{
			get
			{
				if (_error == null)
				{
					_error = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32513));
				}
				return _error;
			}
		}

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system exclamation icon (WIN32: IDI_EXCLAMATION).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system exclamation icon.</returns>
		public static Icon Exclamation
		{
			get
			{
				if (_exclamation == null)
				{
					_exclamation = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32515));
				}
				return _exclamation;
			}
		}

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system hand icon (WIN32: IDI_HAND).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system hand icon.</returns>
		public static Icon Hand
		{
			get
			{
				if (_hand == null)
				{
					_hand = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32513));
				}
				return _hand;
			}
		}

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system information icon (WIN32: IDI_INFORMATION).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system information icon.</returns>
		public static Icon Information
		{
			get
			{
				if (_information == null)
				{
					_information = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32516));
				}
				return _information;
			}
		}

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system question icon (WIN32: IDI_QUESTION).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system question icon.</returns>
		public static Icon Question
		{
			get
			{
				if (_question == null)
				{
					_question = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32514));
				}
				return _question;
			}
		}

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the system warning icon (WIN32: IDI_WARNING).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the system warning icon.</returns>
		public static Icon Warning
		{
			get
			{
				if (_warning == null)
				{
					_warning = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32515));
				}
				return _warning;
			}
		}

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the Windows logo icon (WIN32: IDI_WINLOGO).</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the Windows logo icon.</returns>
		public static Icon WinLogo
		{
			get
			{
				if (_winlogo == null)
				{
					_winlogo = new Icon(SafeNativeMethods.LoadIcon(NativeMethods.NullHandleRef, 32517));
				}
				return _winlogo;
			}
		}

		/// <summary>Gets an <see cref="T:System.Drawing.Icon" /> object that contains the shield icon.</summary>
		/// <returns>An <see cref="T:System.Drawing.Icon" /> object that contains the shield icon.</returns>
		public static Icon Shield
		{
			get
			{
				if (_shield == null)
				{
					try
					{
						if (Environment.OSVersion.Version.Major >= 6)
						{
							IntPtr phico = IntPtr.Zero;
							if (SafeNativeMethods.LoadIconWithScaleDown(NativeMethods.NullHandleRef, 32518, 32, 32, ref phico) == 0)
							{
								_shield = new Icon(phico);
							}
						}
					}
					catch
					{
					}
				}
				if (_shield == null)
				{
					_shield = new Icon(typeof(SystemIcons), "ShieldIcon.ico");
				}
				return _shield;
			}
		}

		private SystemIcons()
		{
		}
	}
	/// <summary>Each property of the <see cref="T:System.Drawing.SystemPens" /> class is a <see cref="T:System.Drawing.Pen" /> that is the color of a Windows display element and that has a width of 1 pixel.</summary>
	public sealed class SystemPens
	{
		private static readonly object SystemPensKey = new object();

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the active window's border.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the active window's border.</returns>
		public static Pen ActiveBorder => FromSystemColor(SystemColors.ActiveBorder);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background of the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background of the active window's title bar.</returns>
		public static Pen ActiveCaption => FromSystemColor(SystemColors.ActiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the text in the active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the text in the active window's title bar.</returns>
		public static Pen ActiveCaptionText => FromSystemColor(SystemColors.ActiveCaptionText);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the application workspace.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the application workspace.</returns>
		public static Pen AppWorkspace => FromSystemColor(SystemColors.AppWorkspace);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the face color of a 3-D element.</returns>
		public static Pen ButtonFace => FromSystemColor(SystemColors.ButtonFace);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the highlight color of a 3-D element.</returns>
		public static Pen ButtonHighlight => FromSystemColor(SystemColors.ButtonHighlight);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the shadow color of a 3-D element.</returns>
		public static Pen ButtonShadow => FromSystemColor(SystemColors.ButtonShadow);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the face color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the face color of a 3-D element.</returns>
		public static Pen Control => FromSystemColor(SystemColors.Control);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of text in a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of text in a 3-D element.</returns>
		public static Pen ControlText => FromSystemColor(SystemColors.ControlText);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the shadow color of a 3-D element.</returns>
		public static Pen ControlDark => FromSystemColor(SystemColors.ControlDark);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the dark shadow color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the dark shadow color of a 3-D element.</returns>
		public static Pen ControlDarkDark => FromSystemColor(SystemColors.ControlDarkDark);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the light color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the light color of a 3-D element.</returns>
		public static Pen ControlLight => FromSystemColor(SystemColors.ControlLight);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the highlight color of a 3-D element.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the highlight color of a 3-D element.</returns>
		public static Pen ControlLightLight => FromSystemColor(SystemColors.ControlLightLight);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the Windows desktop.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the Windows desktop.</returns>
		public static Pen Desktop => FromSystemColor(SystemColors.Desktop);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the lightest color in the color gradient of an active window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the lightest color in the color gradient of an active window's title bar.</returns>
		public static Pen GradientActiveCaption => FromSystemColor(SystemColors.GradientActiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the lightest color in the color gradient of an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the lightest color in the color gradient of an inactive window's title bar.</returns>
		public static Pen GradientInactiveCaption => FromSystemColor(SystemColors.GradientInactiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of dimmed text.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of dimmed text.</returns>
		public static Pen GrayText => FromSystemColor(SystemColors.GrayText);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background of selected items.</returns>
		public static Pen Highlight => FromSystemColor(SystemColors.Highlight);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the text of selected items.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the text of selected items.</returns>
		public static Pen HighlightText => FromSystemColor(SystemColors.HighlightText);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color used to designate a hot-tracked item.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color used to designate a hot-tracked item.</returns>
		public static Pen HotTrack => FromSystemColor(SystemColors.HotTrack);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> is the color of the border of an inactive window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the border of an inactive window.</returns>
		public static Pen InactiveBorder => FromSystemColor(SystemColors.InactiveBorder);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the title bar caption of an inactive window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the title bar caption of an inactive window.</returns>
		public static Pen InactiveCaption => FromSystemColor(SystemColors.InactiveCaption);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the text in an inactive window's title bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the text in an inactive window's title bar.</returns>
		public static Pen InactiveCaptionText => FromSystemColor(SystemColors.InactiveCaptionText);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background of a ToolTip.</returns>
		public static Pen Info => FromSystemColor(SystemColors.Info);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the text of a ToolTip.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the text of a ToolTip.</returns>
		public static Pen InfoText => FromSystemColor(SystemColors.InfoText);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of a menu's background.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of a menu's background.</returns>
		public static Pen Menu => FromSystemColor(SystemColors.Menu);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background of a menu bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background of a menu bar.</returns>
		public static Pen MenuBar => FromSystemColor(SystemColors.MenuBar);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color used to highlight menu items when the menu appears as a flat menu.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color used to highlight menu items when the menu appears as a flat menu.</returns>
		public static Pen MenuHighlight => FromSystemColor(SystemColors.MenuHighlight);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of a menu's text.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of a menu's text.</returns>
		public static Pen MenuText => FromSystemColor(SystemColors.MenuText);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background of a scroll bar.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background of a scroll bar.</returns>
		public static Pen ScrollBar => FromSystemColor(SystemColors.ScrollBar);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the background in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the background in the client area of a window.</returns>
		public static Pen Window => FromSystemColor(SystemColors.Window);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of a window frame.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of a window frame.</returns>
		public static Pen WindowFrame => FromSystemColor(SystemColors.WindowFrame);

		/// <summary>Gets a <see cref="T:System.Drawing.Pen" /> that is the color of the text in the client area of a window.</summary>
		/// <returns>A <see cref="T:System.Drawing.Pen" /> that is the color of the text in the client area of a window.</returns>
		public static Pen WindowText => FromSystemColor(SystemColors.WindowText);

		private SystemPens()
		{
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Pen" /> from the specified <see cref="T:System.Drawing.Color" />.</summary>
		/// <param name="c">The <see cref="T:System.Drawing.Color" /> for the new <see cref="T:System.Drawing.Pen" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Pen" /> this method creates.</returns>
		public static Pen FromSystemColor(Color c)
		{
			if (!c.IsSystemColor)
			{
				throw new ArgumentException(SR.GetString("ColorNotSystemColor", c.ToString()));
			}
			Pen[] array = (Pen[])SafeNativeMethods.Gdip.ThreadData[SystemPensKey];
			if (array == null)
			{
				array = new Pen[33];
				SafeNativeMethods.Gdip.ThreadData[SystemPensKey] = array;
			}
			int num = (int)c.ToKnownColor();
			if (num > 167)
			{
				num -= 141;
			}
			num--;
			if (array[num] == null)
			{
				array[num] = new Pen(c, immutable: true);
			}
			return array[num];
		}
	}
	/// <summary>Allows you to specify an icon to represent a control in a container, such as the Microsoft Visual Studio Form Designer.</summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class ToolboxBitmapAttribute : Attribute
	{
		private Image smallImage;

		private Image largeImage;

		private Bitmap originalBitmap;

		private string imageFile;

		private Type imageType;

		private string imageName;

		private static readonly Size largeSize;

		private static readonly Size smallSize;

		private static string lastOriginalFileName;

		private static string lastUpdatedFileName;

		/// <summary>A <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object that has its small image and its large image set to <see langword="null" />.</summary>
		public static readonly ToolboxBitmapAttribute Default;

		private static readonly ToolboxBitmapAttribute DefaultComponent;

		/// <summary>Initializes a new <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object with an image from a specified file.</summary>
		/// <param name="imageFile">The name of a file that contains a 16 by 16 bitmap.</param>
		public ToolboxBitmapAttribute(string imageFile)
			: this(GetImageFromFile(imageFile, large: false), GetImageFromFile(imageFile, large: true))
		{
			this.imageFile = imageFile;
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object based on a 16 x 16 bitmap that is embedded as a resource in a specified assembly.</summary>
		/// <param name="t">A <see cref="T:System.Type" /> whose defining assembly is searched for the bitmap resource.</param>
		public ToolboxBitmapAttribute(Type t)
			: this(GetImageFromResource(t, null, large: false), GetImageFromResource(t, null, large: true))
		{
			imageType = t;
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object based on a 16 by 16 bitmap that is embedded as a resource in a specified assembly.</summary>
		/// <param name="t">A <see cref="T:System.Type" /> whose defining assembly is searched for the bitmap resource.</param>
		/// <param name="name">The name of the embedded bitmap resource.</param>
		public ToolboxBitmapAttribute(Type t, string name)
			: this(GetImageFromResource(t, name, large: false), GetImageFromResource(t, name, large: true))
		{
			imageType = t;
			imageName = name;
		}

		private ToolboxBitmapAttribute(Image smallImage, Image largeImage)
		{
			this.smallImage = smallImage;
			this.largeImage = largeImage;
		}

		/// <summary>Indicates whether the specified object is a <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object and is identical to this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="value">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if <paramref name="value" /> is both a <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object and is identical to this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public override bool Equals(object value)
		{
			if (value == this)
			{
				return true;
			}
			if (value is ToolboxBitmapAttribute toolboxBitmapAttribute)
			{
				if (toolboxBitmapAttribute.smallImage == smallImage)
				{
					return toolboxBitmapAttribute.largeImage == largeImage;
				}
				return false;
			}
			return false;
		}

		/// <summary>Gets a hash code for this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <returns>The hash code for this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		/// <summary>Gets the small <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="component">If this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object does not already have a small image, this method searches for a bitmap resource in the assembly that defines the type of the object specified by the component parameter. For example, if you pass an object of type ControlA to the component parameter, then this method searches the assembly that defines ControlA.</param>
		/// <returns>The small <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public Image GetImage(object component)
		{
			return GetImage(component, large: true);
		}

		/// <summary>Gets the small or large <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="component">If this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object does not already have a small image, this method searches for a bitmap resource in the assembly that defines the type of the object specified by the component parameter. For example, if you pass an object of type ControlA to the component parameter, then this method searches the assembly that defines ControlA.</param>
		/// <param name="large">Specifies whether this method returns a large image (<see langword="true" />) or a small image (<see langword="false" />). The small image is 16 by 16, and the large image is 32 by 32.</param>
		/// <returns>An <see cref="T:System.Drawing.Image" /> object associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public Image GetImage(object component, bool large)
		{
			if (component != null)
			{
				return GetImage(component.GetType(), large);
			}
			return null;
		}

		/// <summary>Gets the small <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="type">If this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object does not already have a small image, this method searches for a bitmap resource in the assembly that defines the type specified by the type parameter. For example, if you pass typeof(ControlA) to the type parameter, then this method searches the assembly that defines ControlA.</param>
		/// <returns>The small <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public Image GetImage(Type type)
		{
			return GetImage(type, large: false);
		}

		/// <summary>Gets the small or large <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="type">If this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object does not already have a small image, this method searches for a bitmap resource in the assembly that defines the type specified by the component type. For example, if you pass typeof(ControlA) to the type parameter, then this method searches the assembly that defines ControlA.</param>
		/// <param name="large">Specifies whether this method returns a large image (<see langword="true" />) or a small image (<see langword="false" />). The small image is 16 by 16, and the large image is 32 by 32.</param>
		/// <returns>An <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public Image GetImage(Type type, bool large)
		{
			return GetImage(type, null, large);
		}

		/// <summary>Gets the small or large <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</summary>
		/// <param name="type">If this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object does not already have a small image, this method searches for an embedded bitmap resource in the assembly that defines the type specified by the component type. For example, if you pass typeof(ControlA) to the type parameter, then this method searches the assembly that defines ControlA.</param>
		/// <param name="imgName">The name of the embedded bitmap resource.</param>
		/// <param name="large">Specifies whether this method returns a large image (<see langword="true" />) or a small image (<see langword="false" />). The small image is 16 by 16, and the large image is 32 by 32.</param>
		/// <returns>An <see cref="T:System.Drawing.Image" /> associated with this <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> object.</returns>
		public Image GetImage(Type type, string imgName, bool large)
		{
			if ((large && largeImage == null) || (!large && smallImage == null))
			{
				Image image = null;
				image = ((!large) ? smallImage : largeImage);
				if (image == null)
				{
					image = GetImageFromResource(type, imgName, large);
				}
				if (large && largeImage == null && smallImage != null)
				{
					image = new Bitmap((Bitmap)smallImage, largeSize.Width, largeSize.Height);
				}
				if (image is Bitmap img)
				{
					MakeBackgroundAlphaZero(img);
				}
				if (image == null)
				{
					image = DefaultComponent.GetImage(type, large);
				}
				if (large)
				{
					largeImage = image;
				}
				else
				{
					smallImage = image;
				}
			}
			Image result = (large ? largeImage : smallImage);
			if (Equals(Default))
			{
				largeImage = null;
				smallImage = null;
			}
			return result;
		}

		internal Bitmap GetOriginalBitmap()
		{
			if (originalBitmap != null)
			{
				return originalBitmap;
			}
			if (smallImage == null)
			{
				return null;
			}
			if (!DpiHelper.IsScalingRequired)
			{
				return null;
			}
			if (!string.IsNullOrEmpty(imageFile))
			{
				originalBitmap = GetImageFromFile(imageFile, large: false, scaled: false) as Bitmap;
			}
			else if (imageType != null)
			{
				originalBitmap = GetImageFromResource(imageType, imageName, large: false, scaled: false) as Bitmap;
			}
			return originalBitmap;
		}

		private static Image GetIconFromStream(Stream stream, bool large, bool scaled)
		{
			if (stream == null)
			{
				return null;
			}
			Icon original = new Icon(stream);
			Icon icon = new Icon(original, large ? largeSize : smallSize);
			Bitmap logicalBitmap = icon.ToBitmap();
			if (DpiHelper.IsScalingRequired && scaled)
			{
				DpiHelper.ScaleBitmapLogicalToDevice(ref logicalBitmap);
			}
			return logicalBitmap;
		}

		private static string GetFileNameFromBitmapSelector(string originalName)
		{
			if (originalName != lastOriginalFileName)
			{
				lastOriginalFileName = originalName;
				lastUpdatedFileName = BitmapSelector.GetFileName(originalName);
			}
			return lastUpdatedFileName;
		}

		private static Image GetImageFromFile(string imageFile, bool large, bool scaled = true)
		{
			Image image = null;
			try
			{
				if (imageFile != null)
				{
					imageFile = GetFileNameFromBitmapSelector(imageFile);
					string extension = Path.GetExtension(imageFile);
					if (extension != null && string.Equals(extension, ".ico", StringComparison.OrdinalIgnoreCase))
					{
						FileStream fileStream = File.Open(imageFile, FileMode.Open);
						if (fileStream != null)
						{
							try
							{
								image = GetIconFromStream(fileStream, large, scaled);
								return image;
							}
							finally
							{
								fileStream.Close();
							}
						}
						return image;
					}
					if (!large)
					{
						image = Image.FromFile(imageFile);
						Bitmap logicalBitmap = image as Bitmap;
						if (DpiHelper.IsScalingRequired && scaled)
						{
							DpiHelper.ScaleBitmapLogicalToDevice(ref logicalBitmap);
							return image;
						}
						return image;
					}
					return image;
				}
				return image;
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsCriticalException(ex))
				{
					throw;
				}
				return image;
			}
		}

		private static Image GetBitmapFromResource(Type t, string bitmapname, bool large, bool scaled)
		{
			if (bitmapname == null)
			{
				return null;
			}
			Image image = null;
			Stream resourceStream = BitmapSelector.GetResourceStream(t, bitmapname);
			if (resourceStream != null)
			{
				Bitmap bitmap = new Bitmap(resourceStream);
				image = bitmap;
				MakeBackgroundAlphaZero(bitmap);
				if (large)
				{
					image = new Bitmap(bitmap, largeSize.Width, largeSize.Height);
				}
				if (DpiHelper.IsScalingRequired && scaled)
				{
					bitmap = (Bitmap)image;
					DpiHelper.ScaleBitmapLogicalToDevice(ref bitmap);
					image = bitmap;
				}
			}
			return image;
		}

		private static Image GetIconFromResource(Type t, string bitmapname, bool large, bool scaled)
		{
			if (bitmapname == null)
			{
				return null;
			}
			return GetIconFromStream(BitmapSelector.GetResourceStream(t, bitmapname), large, scaled);
		}

		/// <summary>Returns an <see cref="T:System.Drawing.Image" /> object based on a bitmap resource that is embedded in an assembly.</summary>
		/// <param name="t">This method searches for an embedded bitmap resource in the assembly that defines the type specified by the t parameter. For example, if you pass typeof(ControlA) to the t parameter, then this method searches the assembly that defines ControlA.</param>
		/// <param name="imageName">The name of the embedded bitmap resource.</param>
		/// <param name="large">Specifies whether this method returns a large image (true) or a small image (false). The small image is 16 by 16, and the large image is 32 x 32.</param>
		/// <returns>An <see cref="T:System.Drawing.Image" /> object based on the retrieved bitmap.</returns>
		public static Image GetImageFromResource(Type t, string imageName, bool large)
		{
			return GetImageFromResource(t, imageName, large, scaled: true);
		}

		internal static Image GetImageFromResource(Type t, string imageName, bool large, bool scaled)
		{
			Image image = null;
			try
			{
				string text = imageName;
				string text2 = null;
				string text3 = null;
				string text4 = null;
				if (text == null)
				{
					text = t.FullName;
					int num = text.LastIndexOf('.');
					if (num != -1)
					{
						text = text.Substring(num + 1);
					}
					text2 = text + ".ico";
					text3 = text + ".bmp";
				}
				else if (string.Compare(Path.GetExtension(imageName), ".ico", ignoreCase: true, CultureInfo.CurrentCulture) == 0)
				{
					text2 = text;
				}
				else if (string.Compare(Path.GetExtension(imageName), ".bmp", ignoreCase: true, CultureInfo.CurrentCulture) == 0)
				{
					text3 = text;
				}
				else
				{
					text4 = text;
					text3 = text + ".bmp";
					text2 = text + ".ico";
				}
				if (text4 != null)
				{
					image = GetBitmapFromResource(t, text4, large, scaled);
				}
				if (image == null && text3 != null)
				{
					image = GetBitmapFromResource(t, text3, large, scaled);
				}
				if (image == null)
				{
					if (text2 != null)
					{
						image = GetIconFromResource(t, text2, large, scaled);
						return image;
					}
					return image;
				}
				return image;
			}
			catch (Exception)
			{
				_ = t == null;
				return image;
			}
		}

		private static void MakeBackgroundAlphaZero(Bitmap img)
		{
			Color pixel = img.GetPixel(0, img.Height - 1);
			img.MakeTransparent();
			Color color = Color.FromArgb(0, pixel);
			img.SetPixel(0, img.Height - 1, color);
		}

		static ToolboxBitmapAttribute()
		{
			largeSize = new Size(32, 32);
			smallSize = new Size(16, 16);
			Default = new ToolboxBitmapAttribute((Image)null, (Image)null);
			SafeNativeMethods.Gdip.DummyFunction();
			Bitmap img = null;
			Stream resourceStream = BitmapSelector.GetResourceStream(typeof(ToolboxBitmapAttribute), "DefaultComponent.bmp");
			if (resourceStream != null)
			{
				img = new Bitmap(resourceStream);
				MakeBackgroundAlphaZero(img);
			}
			DefaultComponent = new ToolboxBitmapAttribute(img, null);
		}
	}
	[SuppressUnmanagedCodeSecurity]
	internal class UnsafeNativeMethods
	{
		[ComImport]
		[Guid("0000000C-0000-0000-C000-000000000046")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		public interface IStream
		{
			int Read([In] IntPtr buf, [In] int len);

			int Write([In] IntPtr buf, [In] int len);

			[return: MarshalAs(UnmanagedType.I8)]
			long Seek([In][MarshalAs(UnmanagedType.I8)] long dlibMove, [In] int dwOrigin);

			void SetSize([In][MarshalAs(UnmanagedType.I8)] long libNewSize);

			[return: MarshalAs(UnmanagedType.I8)]
			long CopyTo([In][MarshalAs(UnmanagedType.Interface)] IStream pstm, [In][MarshalAs(UnmanagedType.I8)] long cb, [Out][MarshalAs(UnmanagedType.LPArray)] long[] pcbRead);

			void Commit([In] int grfCommitFlags);

			void Revert();

			void LockRegion([In][MarshalAs(UnmanagedType.I8)] long libOffset, [In][MarshalAs(UnmanagedType.I8)] long cb, [In] int dwLockType);

			void UnlockRegion([In][MarshalAs(UnmanagedType.I8)] long libOffset, [In][MarshalAs(UnmanagedType.I8)] long cb, [In] int dwLockType);

			void Stat([In] IntPtr pStatstg, [In] int grfStatFlag);

			[return: MarshalAs(UnmanagedType.Interface)]
			IStream Clone();
		}

		internal class ComStreamFromDataStream : IStream
		{
			protected Stream dataStream;

			private long virtualPosition = -1L;

			internal ComStreamFromDataStream(Stream dataStream)
			{
				if (dataStream == null)
				{
					throw new ArgumentNullException("dataStream");
				}
				this.dataStream = dataStream;
			}

			private void ActualizeVirtualPosition()
			{
				if (virtualPosition != -1)
				{
					if (virtualPosition > dataStream.Length)
					{
						dataStream.SetLength(virtualPosition);
					}
					dataStream.Position = virtualPosition;
					virtualPosition = -1L;
				}
			}

			public virtual IStream Clone()
			{
				NotImplemented();
				return null;
			}

			public virtual void Commit(int grfCommitFlags)
			{
				dataStream.Flush();
				ActualizeVirtualPosition();
			}

			public virtual long CopyTo(IStream pstm, long cb, long[] pcbRead)
			{
				int num = 4096;
				IntPtr intPtr = Marshal.AllocHGlobal(num);
				if (intPtr == IntPtr.Zero)
				{
					throw new OutOfMemoryException();
				}
				long num2 = 0L;
				try
				{
					int num4;
					for (; num2 < cb; num2 += num4)
					{
						int num3 = num;
						if (num2 + num3 > cb)
						{
							num3 = (int)(cb - num2);
						}
						num4 = Read(intPtr, num3);
						if (num4 == 0)
						{
							break;
						}
						if (pstm.Write(intPtr, num4) != num4)
						{
							throw EFail("Wrote an incorrect number of bytes");
						}
					}
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (pcbRead != null && pcbRead.Length != 0)
				{
					pcbRead[0] = num2;
				}
				return num2;
			}

			public virtual Stream GetDataStream()
			{
				return dataStream;
			}

			public virtual void LockRegion(long libOffset, long cb, int dwLockType)
			{
			}

			protected static ExternalException EFail(string msg)
			{
				throw new ExternalException(msg, -2147467259);
			}

			protected static void NotImplemented()
			{
				throw new ExternalException(SR.GetString("NotImplemented"), -2147467263);
			}

			public virtual int Read(IntPtr buf, int length)
			{
				byte[] array = new byte[length];
				int result = Read(array, length);
				Marshal.Copy(array, 0, buf, length);
				return result;
			}

			public virtual int Read(byte[] buffer, int length)
			{
				ActualizeVirtualPosition();
				return dataStream.Read(buffer, 0, length);
			}

			public virtual void Revert()
			{
				NotImplemented();
			}

			public virtual long Seek(long offset, int origin)
			{
				long position = virtualPosition;
				if (virtualPosition == -1)
				{
					position = dataStream.Position;
				}
				long length = dataStream.Length;
				switch (origin)
				{
				case 0:
					if (offset <= length)
					{
						dataStream.Position = offset;
						virtualPosition = -1L;
					}
					else
					{
						virtualPosition = offset;
					}
					break;
				case 2:
					if (offset <= 0)
					{
						dataStream.Position = length + offset;
						virtualPosition = -1L;
					}
					else
					{
						virtualPosition = length + offset;
					}
					break;
				case 1:
					if (offset + position <= length)
					{
						dataStream.Position = position + offset;
						virtualPosition = -1L;
					}
					else
					{
						virtualPosition = offset + position;
					}
					break;
				}
				if (virtualPosition != -1)
				{
					return virtualPosition;
				}
				return dataStream.Position;
			}

			public virtual void SetSize(long value)
			{
				dataStream.SetLength(value);
			}

			public virtual void Stat(IntPtr pstatstg, int grfStatFlag)
			{
				NotImplemented();
			}

			public virtual void UnlockRegion(long libOffset, long cb, int dwLockType)
			{
			}

			public virtual int Write(IntPtr buf, int length)
			{
				byte[] array = new byte[length];
				Marshal.Copy(buf, array, 0, length);
				return Write(array, length);
			}

			public virtual int Write(byte[] buffer, int length)
			{
				ActualizeVirtualPosition();
				dataStream.Write(buffer, 0, length);
				return length;
			}
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, EntryPoint = "RtlMoveMemory", ExactSpelling = true, SetLastError = true)]
		public static extern void CopyMemory(HandleRef destData, HandleRef srcData, int size);

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "GetDC", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntGetDC(HandleRef hWnd);

		public static IntPtr GetDC(HandleRef hWnd)
		{
			return System.Internal.HandleCollector.Add(IntGetDC(hWnd), SafeNativeMethods.CommonHandles.HDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "DeleteDC", ExactSpelling = true, SetLastError = true)]
		private static extern bool IntDeleteDC(HandleRef hDC);

		public static bool DeleteDC(HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, SafeNativeMethods.CommonHandles.GDI);
			return IntDeleteDC(hDC);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "ReleaseDC", ExactSpelling = true, SetLastError = true)]
		private static extern int IntReleaseDC(HandleRef hWnd, HandleRef hDC);

		public static int ReleaseDC(HandleRef hWnd, HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, SafeNativeMethods.CommonHandles.HDC);
			return IntReleaseDC(hWnd, hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateCompatibleDC", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCreateCompatibleDC(HandleRef hDC);

		public static IntPtr CreateCompatibleDC(HandleRef hDC)
		{
			return System.Internal.HandleCollector.Add(IntCreateCompatibleDC(hDC), SafeNativeMethods.CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr GetStockObject(int nIndex);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetSystemDefaultLCID();

		[DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetSystemMetrics(int nIndex);

		[DllImport("user32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool SystemParametersInfo(int uiAction, int uiParam, [In][Out] NativeMethods.NONCLIENTMETRICS pvParam, int fWinIni);

		[DllImport("user32.dll", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool SystemParametersInfo(int uiAction, int uiParam, [In][Out] SafeNativeMethods.LOGFONT pvParam, int fWinIni);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetDeviceCaps(HandleRef hDC, int nIndex);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetObjectType(HandleRef hObject);

		[ReflectionPermission(SecurityAction.Assert, Unrestricted = true)]
		[SecurityPermission(SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public static object PtrToStructure(IntPtr lparam, Type cls)
		{
			return Marshal.PtrToStructure(lparam, cls);
		}

		[ReflectionPermission(SecurityAction.Assert, Unrestricted = true)]
		[SecurityPermission(SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public static void PtrToStructure(IntPtr lparam, object data)
		{
			Marshal.PtrToStructure(lparam, data);
		}
	}
	/// <summary>Translates colors to and from GDI+ <see cref="T:System.Drawing.Color" /> structures. This class cannot be inherited.</summary>
	public sealed class ColorTranslator
	{
		private const int Win32RedShift = 0;

		private const int Win32GreenShift = 8;

		private const int Win32BlueShift = 16;

		private static Hashtable htmlSysColorTable;

		private ColorTranslator()
		{
		}

		/// <summary>Translates the specified <see cref="T:System.Drawing.Color" /> structure to a Windows color.</summary>
		/// <param name="c">The <see cref="T:System.Drawing.Color" /> structure to translate.</param>
		/// <returns>The Windows color value.</returns>
		public static int ToWin32(Color c)
		{
			return c.R | (c.G << 8) | (c.B << 16);
		}

		/// <summary>Translates the specified <see cref="T:System.Drawing.Color" /> structure to an OLE color.</summary>
		/// <param name="c">The <see cref="T:System.Drawing.Color" /> structure to translate.</param>
		/// <returns>The OLE color value.</returns>
		public static int ToOle(Color c)
		{
			if (c.IsKnownColor)
			{
				switch (c.ToKnownColor())
				{
				case KnownColor.ActiveBorder:
					return -2147483638;
				case KnownColor.ActiveCaption:
					return -2147483646;
				case KnownColor.ActiveCaptionText:
					return -2147483639;
				case KnownColor.AppWorkspace:
					return -2147483636;
				case KnownColor.ButtonFace:
					return -2147483633;
				case KnownColor.ButtonHighlight:
					return -2147483628;
				case KnownColor.ButtonShadow:
					return -2147483632;
				case KnownColor.Control:
					return -2147483633;
				case KnownColor.ControlDark:
					return -2147483632;
				case KnownColor.ControlDarkDark:
					return -2147483627;
				case KnownColor.ControlLight:
					return -2147483626;
				case KnownColor.ControlLightLight:
					return -2147483628;
				case KnownColor.ControlText:
					return -2147483630;
				case KnownColor.Desktop:
					return -2147483647;
				case KnownColor.GradientActiveCaption:
					return -2147483621;
				case KnownColor.GradientInactiveCaption:
					return -2147483620;
				case KnownColor.GrayText:
					return -2147483631;
				case KnownColor.Highlight:
					return -2147483635;
				case KnownColor.HighlightText:
					return -2147483634;
				case KnownColor.HotTrack:
					return -2147483622;
				case KnownColor.InactiveBorder:
					return -2147483637;
				case KnownColor.InactiveCaption:
					return -2147483645;
				case KnownColor.InactiveCaptionText:
					return -2147483629;
				case KnownColor.Info:
					return -2147483624;
				case KnownColor.InfoText:
					return -2147483625;
				case KnownColor.Menu:
					return -2147483644;
				case KnownColor.MenuBar:
					return -2147483618;
				case KnownColor.MenuHighlight:
					return -2147483619;
				case KnownColor.MenuText:
					return -2147483641;
				case KnownColor.ScrollBar:
					return int.MinValue;
				case KnownColor.Window:
					return -2147483643;
				case KnownColor.WindowFrame:
					return -2147483642;
				case KnownColor.WindowText:
					return -2147483640;
				}
			}
			return ToWin32(c);
		}

		/// <summary>Translates an OLE color value to a GDI+ <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="oleColor">The OLE color to translate.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> structure that represents the translated OLE color.</returns>
		public static Color FromOle(int oleColor)
		{
			if ((int)(oleColor & 0xFF000000u) == int.MinValue && (oleColor & 0xFFFFFF) <= 30)
			{
				switch (oleColor)
				{
				case -2147483638:
					return Color.FromKnownColor(KnownColor.ActiveBorder);
				case -2147483646:
					return Color.FromKnownColor(KnownColor.ActiveCaption);
				case -2147483639:
					return Color.FromKnownColor(KnownColor.ActiveCaptionText);
				case -2147483636:
					return Color.FromKnownColor(KnownColor.AppWorkspace);
				case -2147483633:
					return Color.FromKnownColor(KnownColor.Control);
				case -2147483632:
					return Color.FromKnownColor(KnownColor.ControlDark);
				case -2147483627:
					return Color.FromKnownColor(KnownColor.ControlDarkDark);
				case -2147483626:
					return Color.FromKnownColor(KnownColor.ControlLight);
				case -2147483628:
					return Color.FromKnownColor(KnownColor.ControlLightLight);
				case -2147483630:
					return Color.FromKnownColor(KnownColor.ControlText);
				case -2147483647:
					return Color.FromKnownColor(KnownColor.Desktop);
				case -2147483621:
					return Color.FromKnownColor(KnownColor.GradientActiveCaption);
				case -2147483620:
					return Color.FromKnownColor(KnownColor.GradientInactiveCaption);
				case -2147483631:
					return Color.FromKnownColor(KnownColor.GrayText);
				case -2147483635:
					return Color.FromKnownColor(KnownColor.Highlight);
				case -2147483634:
					return Color.FromKnownColor(KnownColor.HighlightText);
				case -2147483622:
					return Color.FromKnownColor(KnownColor.HotTrack);
				case -2147483637:
					return Color.FromKnownColor(KnownColor.InactiveBorder);
				case -2147483645:
					return Color.FromKnownColor(KnownColor.InactiveCaption);
				case -2147483629:
					return Color.FromKnownColor(KnownColor.InactiveCaptionText);
				case -2147483624:
					return Color.FromKnownColor(KnownColor.Info);
				case -2147483625:
					return Color.FromKnownColor(KnownColor.InfoText);
				case -2147483644:
					return Color.FromKnownColor(KnownColor.Menu);
				case -2147483618:
					return Color.FromKnownColor(KnownColor.MenuBar);
				case -2147483619:
					return Color.FromKnownColor(KnownColor.MenuHighlight);
				case -2147483641:
					return Color.FromKnownColor(KnownColor.MenuText);
				case int.MinValue:
					return Color.FromKnownColor(KnownColor.ScrollBar);
				case -2147483643:
					return Color.FromKnownColor(KnownColor.Window);
				case -2147483642:
					return Color.FromKnownColor(KnownColor.WindowFrame);
				case -2147483640:
					return Color.FromKnownColor(KnownColor.WindowText);
				}
			}
			return KnownColorTable.ArgbToKnownColor(Color.FromArgb((byte)(oleColor & 0xFF), (byte)((oleColor >> 8) & 0xFF), (byte)((oleColor >> 16) & 0xFF)).ToArgb());
		}

		/// <summary>Translates a Windows color value to a GDI+ <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="win32Color">The Windows color to translate.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> structure that represents the translated Windows color.</returns>
		public static Color FromWin32(int win32Color)
		{
			return FromOle(win32Color);
		}

		/// <summary>Translates an HTML color representation to a GDI+ <see cref="T:System.Drawing.Color" /> structure.</summary>
		/// <param name="htmlColor">The string representation of the Html color to translate.</param>
		/// <returns>The <see cref="T:System.Drawing.Color" /> structure that represents the translated HTML color or <see cref="F:System.Drawing.Color.Empty" /> if <paramref name="htmlColor" /> is <see langword="null" />.</returns>
		/// <exception cref="T:System.Exception">
		///   <paramref name="htmlColor" /> is not a valid HTML color name.</exception>
		public static Color FromHtml(string htmlColor)
		{
			Color result = Color.Empty;
			if (htmlColor == null || htmlColor.Length == 0)
			{
				return result;
			}
			if (htmlColor[0] == '#' && (htmlColor.Length == 7 || htmlColor.Length == 4))
			{
				if (htmlColor.Length == 7)
				{
					result = Color.FromArgb(Convert.ToInt32(htmlColor.Substring(1, 2), 16), Convert.ToInt32(htmlColor.Substring(3, 2), 16), Convert.ToInt32(htmlColor.Substring(5, 2), 16));
				}
				else
				{
					string text = char.ToString(htmlColor[1]);
					string text2 = char.ToString(htmlColor[2]);
					string text3 = char.ToString(htmlColor[3]);
					result = Color.FromArgb(Convert.ToInt32(text + text, 16), Convert.ToInt32(text2 + text2, 16), Convert.ToInt32(text3 + text3, 16));
				}
			}
			if (result.IsEmpty && string.Equals(htmlColor, "LightGrey", StringComparison.OrdinalIgnoreCase))
			{
				result = Color.LightGray;
			}
			if (result.IsEmpty)
			{
				if (htmlSysColorTable == null)
				{
					InitializeHtmlSysColorTable();
				}
				object obj = htmlSysColorTable[htmlColor.ToLower(CultureInfo.InvariantCulture)];
				if (obj != null)
				{
					result = (Color)obj;
				}
			}
			if (result.IsEmpty)
			{
				result = (Color)TypeDescriptor.GetConverter(typeof(Color)).ConvertFromString(htmlColor);
			}
			return result;
		}

		/// <summary>Translates the specified <see cref="T:System.Drawing.Color" /> structure to an HTML string color representation.</summary>
		/// <param name="c">The <see cref="T:System.Drawing.Color" /> structure to translate.</param>
		/// <returns>The string that represents the HTML color.</returns>
		public static string ToHtml(Color c)
		{
			string result = string.Empty;
			if (c.IsEmpty)
			{
				return result;
			}
			if (!c.IsSystemColor)
			{
				result = ((!c.IsNamedColor) ? ("#" + c.R.ToString("X2", null) + c.G.ToString("X2", null) + c.B.ToString("X2", null)) : ((!(c == Color.LightGray)) ? c.Name : "LightGrey"));
			}
			else
			{
				switch (c.ToKnownColor())
				{
				case KnownColor.ActiveBorder:
					result = "activeborder";
					break;
				case KnownColor.ActiveCaption:
				case KnownColor.GradientActiveCaption:
					result = "activecaption";
					break;
				case KnownColor.AppWorkspace:
					result = "appworkspace";
					break;
				case KnownColor.Desktop:
					result = "background";
					break;
				case KnownColor.Control:
					result = "buttonface";
					break;
				case KnownColor.ControlLight:
					result = "buttonface";
					break;
				case KnownColor.ControlDark:
					result = "buttonshadow";
					break;
				case KnownColor.ControlText:
					result = "buttontext";
					break;
				case KnownColor.ActiveCaptionText:
					result = "captiontext";
					break;
				case KnownColor.GrayText:
					result = "graytext";
					break;
				case KnownColor.Highlight:
				case KnownColor.HotTrack:
					result = "highlight";
					break;
				case KnownColor.HighlightText:
				case KnownColor.MenuHighlight:
					result = "highlighttext";
					break;
				case KnownColor.InactiveBorder:
					result = "inactiveborder";
					break;
				case KnownColor.InactiveCaption:
				case KnownColor.GradientInactiveCaption:
					result = "inactivecaption";
					break;
				case KnownColor.InactiveCaptionText:
					result = "inactivecaptiontext";
					break;
				case KnownColor.Info:
					result = "infobackground";
					break;
				case KnownColor.InfoText:
					result = "infotext";
					break;
				case KnownColor.Menu:
				case KnownColor.MenuBar:
					result = "menu";
					break;
				case KnownColor.MenuText:
					result = "menutext";
					break;
				case KnownColor.ScrollBar:
					result = "scrollbar";
					break;
				case KnownColor.ControlDarkDark:
					result = "threeddarkshadow";
					break;
				case KnownColor.ControlLightLight:
					result = "buttonhighlight";
					break;
				case KnownColor.Window:
					result = "window";
					break;
				case KnownColor.WindowFrame:
					result = "windowframe";
					break;
				case KnownColor.WindowText:
					result = "windowtext";
					break;
				}
			}
			return result;
		}

		private static void InitializeHtmlSysColorTable()
		{
			htmlSysColorTable = new Hashtable(26);
			htmlSysColorTable["activeborder"] = Color.FromKnownColor(KnownColor.ActiveBorder);
			htmlSysColorTable["activecaption"] = Color.FromKnownColor(KnownColor.ActiveCaption);
			htmlSysColorTable["appworkspace"] = Color.FromKnownColor(KnownColor.AppWorkspace);
			htmlSysColorTable["background"] = Color.FromKnownColor(KnownColor.Desktop);
			htmlSysColorTable["buttonface"] = Color.FromKnownColor(KnownColor.Control);
			htmlSysColorTable["buttonhighlight"] = Color.FromKnownColor(KnownColor.ControlLightLight);
			htmlSysColorTable["buttonshadow"] = Color.FromKnownColor(KnownColor.ControlDark);
			htmlSysColorTable["buttontext"] = Color.FromKnownColor(KnownColor.ControlText);
			htmlSysColorTable["captiontext"] = Color.FromKnownColor(KnownColor.ActiveCaptionText);
			htmlSysColorTable["graytext"] = Color.FromKnownColor(KnownColor.GrayText);
			htmlSysColorTable["highlight"] = Color.FromKnownColor(KnownColor.Highlight);
			htmlSysColorTable["highlighttext"] = Color.FromKnownColor(KnownColor.HighlightText);
			htmlSysColorTable["inactiveborder"] = Color.FromKnownColor(KnownColor.InactiveBorder);
			htmlSysColorTable["inactivecaption"] = Color.FromKnownColor(KnownColor.InactiveCaption);
			htmlSysColorTable["inactivecaptiontext"] = Color.FromKnownColor(KnownColor.InactiveCaptionText);
			htmlSysColorTable["infobackground"] = Color.FromKnownColor(KnownColor.Info);
			htmlSysColorTable["infotext"] = Color.FromKnownColor(KnownColor.InfoText);
			htmlSysColorTable["menu"] = Color.FromKnownColor(KnownColor.Menu);
			htmlSysColorTable["menutext"] = Color.FromKnownColor(KnownColor.MenuText);
			htmlSysColorTable["scrollbar"] = Color.FromKnownColor(KnownColor.ScrollBar);
			htmlSysColorTable["threeddarkshadow"] = Color.FromKnownColor(KnownColor.ControlDarkDark);
			htmlSysColorTable["threedface"] = Color.FromKnownColor(KnownColor.Control);
			htmlSysColorTable["threedhighlight"] = Color.FromKnownColor(KnownColor.ControlLight);
			htmlSysColorTable["threedlightshadow"] = Color.FromKnownColor(KnownColor.ControlLightLight);
			htmlSysColorTable["window"] = Color.FromKnownColor(KnownColor.Window);
			htmlSysColorTable["windowframe"] = Color.FromKnownColor(KnownColor.WindowFrame);
			htmlSysColorTable["windowtext"] = Color.FromKnownColor(KnownColor.WindowText);
		}
	}
	/// <summary>Defines a particular format for text, including font face, size, and style attributes. This class cannot be inherited.</summary>
	[Serializable]
	[TypeConverter(typeof(FontConverter))]
	[Editor("System.Drawing.Design.FontEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	[ComVisible(true)]
	public sealed class Font : MarshalByRefObject, ICloneable, ISerializable, IDisposable
	{
		private const int LogFontCharSetOffset = 23;

		private const int LogFontNameOffset = 28;

		private IntPtr nativeFont;

		private float fontSize;

		private FontStyle fontStyle;

		private FontFamily fontFamily;

		private GraphicsUnit fontUnit;

		private byte gdiCharSet = 1;

		private bool gdiVerticalFont;

		private string systemFontName = "";

		private string originalFontName;

		internal IntPtr NativeFont => nativeFont;

		/// <summary>Gets the <see cref="T:System.Drawing.FontFamily" /> associated with this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.FontFamily" /> associated with this <see cref="T:System.Drawing.Font" />.</returns>
		[Browsable(false)]
		public FontFamily FontFamily => fontFamily;

		/// <summary>Gets a value that indicates whether this <see cref="T:System.Drawing.Font" /> is bold.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Font" /> is bold; otherwise, <see langword="false" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Bold => (Style & FontStyle.Bold) != 0;

		/// <summary>Gets a byte value that specifies the GDI character set that this <see cref="T:System.Drawing.Font" /> uses.</summary>
		/// <returns>A byte value that specifies the GDI character set that this <see cref="T:System.Drawing.Font" /> uses. The default is 1.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public byte GdiCharSet => gdiCharSet;

		/// <summary>Gets a Boolean value that indicates whether this <see cref="T:System.Drawing.Font" /> is derived from a GDI vertical font.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Font" /> is derived from a GDI vertical font; otherwise, <see langword="false" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool GdiVerticalFont => gdiVerticalFont;

		/// <summary>Gets a value that indicates whether this font has the italic style applied.</summary>
		/// <returns>
		///   <see langword="true" /> to indicate this font has the italic style applied; otherwise, <see langword="false" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Italic => (Style & FontStyle.Italic) != 0;

		/// <summary>Gets the face name of this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>A string representation of the face name of this <see cref="T:System.Drawing.Font" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[Editor("System.Drawing.Design.FontNameEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
		[TypeConverter(typeof(FontConverter.FontNameConverter))]
		public string Name => FontFamily.Name;

		/// <summary>Gets the name of the font originally specified.</summary>
		/// <returns>The string representing the name of the font originally specified.</returns>
		[Browsable(false)]
		public string OriginalFontName => originalFontName;

		/// <summary>Gets a value that indicates whether this <see cref="T:System.Drawing.Font" /> specifies a horizontal line through the font.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Font" /> has a horizontal line through it; otherwise, <see langword="false" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Strikeout => (Style & FontStyle.Strikeout) != 0;

		/// <summary>Gets a value that indicates whether this <see cref="T:System.Drawing.Font" /> is underlined.</summary>
		/// <returns>
		///   <see langword="true" /> if this <see cref="T:System.Drawing.Font" /> is underlined; otherwise, <see langword="false" />.</returns>
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		public bool Underline => (Style & FontStyle.Underline) != 0;

		/// <summary>Gets style information for this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.FontStyle" /> enumeration that contains style information for this <see cref="T:System.Drawing.Font" />.</returns>
		[Browsable(false)]
		public FontStyle Style => fontStyle;

		/// <summary>Gets the em-size of this <see cref="T:System.Drawing.Font" /> measured in the units specified by the <see cref="P:System.Drawing.Font.Unit" /> property.</summary>
		/// <returns>The em-size of this <see cref="T:System.Drawing.Font" />.</returns>
		public float Size => fontSize;

		/// <summary>Gets the em-size, in points, of this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>The em-size, in points, of this <see cref="T:System.Drawing.Font" />.</returns>
		[Browsable(false)]
		public float SizeInPoints
		{
			get
			{
				if (Unit == GraphicsUnit.Point)
				{
					return Size;
				}
				IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
				try
				{
					using Graphics graphics = Graphics.FromHdcInternal(dC);
					float num = (float)((double)graphics.DpiY / 72.0);
					float height = GetHeight(graphics);
					float num2 = height * (float)FontFamily.GetEmHeight(Style) / (float)FontFamily.GetLineSpacing(Style);
					return num2 / num;
				}
				finally
				{
					UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
				}
			}
		}

		/// <summary>Gets the unit of measure for this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.GraphicsUnit" /> that represents the unit of measure for this <see cref="T:System.Drawing.Font" />.</returns>
		[TypeConverter(typeof(FontConverter.FontUnitConverter))]
		public GraphicsUnit Unit => fontUnit;

		/// <summary>Gets the line spacing of this font.</summary>
		/// <returns>The line spacing, in pixels, of this font.</returns>
		[Browsable(false)]
		public int Height => (int)Math.Ceiling(GetHeight());

		/// <summary>Gets a value indicating whether the font is a member of <see cref="T:System.Drawing.SystemFonts" />.</summary>
		/// <returns>
		///   <see langword="true" /> if the font is a member of <see cref="T:System.Drawing.SystemFonts" />; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsSystemFont => !string.IsNullOrEmpty(systemFontName);

		/// <summary>Gets the name of the system font if the <see cref="P:System.Drawing.Font.IsSystemFont" /> property returns <see langword="true" />.</summary>
		/// <returns>The name of the system font, if <see cref="P:System.Drawing.Font.IsSystemFont" /> returns <see langword="true" />; otherwise, an empty string ("").</returns>
		[Browsable(false)]
		public string SystemFontName => systemFontName;

		private void CreateNativeFont()
		{
			int num = SafeNativeMethods.Gdip.GdipCreateFont(new HandleRef(this, fontFamily.NativeFamily), fontSize, fontStyle, fontUnit, out nativeFont);
			switch (num)
			{
			case 15:
				throw new ArgumentException(SR.GetString("GdiplusFontStyleNotFound", fontFamily.Name, fontStyle.ToString()));
			default:
				throw SafeNativeMethods.Gdip.StatusException(num);
			case 0:
				break;
			}
		}

		private Font(SerializationInfo info, StreamingContext context)
		{
			string familyName = null;
			float emSize = -1f;
			FontStyle style = FontStyle.Regular;
			GraphicsUnit unit = GraphicsUnit.Point;
			SingleConverter singleConverter = new SingleConverter();
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (string.Equals(enumerator.Name, "Name", StringComparison.OrdinalIgnoreCase))
				{
					familyName = (string)enumerator.Value;
				}
				else if (string.Equals(enumerator.Name, "Size", StringComparison.OrdinalIgnoreCase))
				{
					emSize = ((!(enumerator.Value is string)) ? ((float)enumerator.Value) : ((float)singleConverter.ConvertFrom(enumerator.Value)));
				}
				else if (string.Compare(enumerator.Name, "Style", ignoreCase: true, CultureInfo.InvariantCulture) == 0)
				{
					style = (FontStyle)enumerator.Value;
				}
				else if (string.Compare(enumerator.Name, "Unit", ignoreCase: true, CultureInfo.InvariantCulture) == 0)
				{
					unit = (GraphicsUnit)enumerator.Value;
				}
			}
			Initialize(familyName, emSize, style, unit, 1, IsVerticalName(familyName));
		}

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.</summary>
		/// <param name="si">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
		{
			si.AddValue("Name", string.IsNullOrEmpty(OriginalFontName) ? Name : OriginalFontName);
			si.AddValue("Size", Size);
			si.AddValue("Style", Style);
			si.AddValue("Unit", Unit);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> that uses the specified existing <see cref="T:System.Drawing.Font" /> and <see cref="T:System.Drawing.FontStyle" /> enumeration.</summary>
		/// <param name="prototype">The existing <see cref="T:System.Drawing.Font" /> from which to create the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="newStyle">The <see cref="T:System.Drawing.FontStyle" /> to apply to the new <see cref="T:System.Drawing.Font" />. Multiple values of the <see cref="T:System.Drawing.FontStyle" /> enumeration can be combined with the <see langword="OR" /> operator.</param>
		public Font(Font prototype, FontStyle newStyle)
		{
			originalFontName = prototype.OriginalFontName;
			Initialize(prototype.FontFamily, prototype.Size, newStyle, prototype.Unit, 1, gdiVerticalFont: false);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size, style, and unit.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="family" /> is <see langword="null" />.</exception>
		public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit)
		{
			Initialize(family, emSize, style, unit, 1, gdiVerticalFont: false);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size, style, unit, and character set.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <param name="gdiCharSet">A <see cref="T:System.Byte" /> that specifies a  
		///  GDI character set to use for the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="family" /> is <see langword="null" />.</exception>
		public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet)
		{
			Initialize(family, emSize, style, unit, gdiCharSet, gdiVerticalFont: false);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size, style, unit, and character set.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <param name="gdiCharSet">A <see cref="T:System.Byte" /> that specifies a  
		///  GDI character set to use for this font.</param>
		/// <param name="gdiVerticalFont">A Boolean value indicating whether the new font is derived from a GDI vertical font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="family" /> is <see langword="null" /></exception>
		public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont)
		{
			Initialize(family, emSize, style, unit, gdiCharSet, gdiVerticalFont);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size, style, unit, and character set.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <param name="gdiCharSet">A <see cref="T:System.Byte" /> that specifies a GDI character set to use for this font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet)
		{
			Initialize(familyName, emSize, style, unit, gdiCharSet, IsVerticalName(familyName));
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using the specified size, style, unit, and character set.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <param name="gdiCharSet">A <see cref="T:System.Byte" /> that specifies a GDI character set to use for this font.</param>
		/// <param name="gdiVerticalFont">A Boolean value indicating whether the new <see cref="T:System.Drawing.Font" /> is derived from a GDI vertical font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont)
		{
			if (float.IsNaN(emSize) || float.IsInfinity(emSize) || emSize <= 0f)
			{
				throw new ArgumentException(SR.GetString("InvalidBoundArgument", "emSize", emSize, 0, "System.Single.MaxValue"), "emSize");
			}
			Initialize(familyName, emSize, style, unit, gdiCharSet, gdiVerticalFont);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size and style.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size, in points, of the new font.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="family" /> is <see langword="null" />.</exception>
		public Font(FontFamily family, float emSize, FontStyle style)
		{
			Initialize(family, emSize, style, GraphicsUnit.Point, 1, gdiVerticalFont: false);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size and unit. Sets the style to <see cref="F:System.Drawing.FontStyle.Regular" />.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="family" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(FontFamily family, float emSize, GraphicsUnit unit)
		{
			Initialize(family, emSize, FontStyle.Regular, unit, 1, gdiVerticalFont: false);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size.</summary>
		/// <param name="family">The <see cref="T:System.Drawing.FontFamily" /> of the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size, in points, of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(FontFamily family, float emSize)
		{
			Initialize(family, emSize, FontStyle.Regular, GraphicsUnit.Point, 1, gdiVerticalFont: false);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size, style, and unit.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity or is not a valid number.</exception>
		public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit)
		{
			Initialize(familyName, emSize, style, unit, 1, IsVerticalName(familyName));
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size and style.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size, in points, of the new font.</param>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(string familyName, float emSize, FontStyle style)
		{
			Initialize(familyName, emSize, style, GraphicsUnit.Point, 1, IsVerticalName(familyName));
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size and unit. The style is set to <see cref="F:System.Drawing.FontStyle.Regular" />.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size of the new font in the units specified by the <paramref name="unit" /> parameter.</param>
		/// <param name="unit">The <see cref="T:System.Drawing.GraphicsUnit" /> of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity, or is not a valid number.</exception>
		public Font(string familyName, float emSize, GraphicsUnit unit)
		{
			Initialize(familyName, emSize, FontStyle.Regular, unit, 1, IsVerticalName(familyName));
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.Font" /> using a specified size.</summary>
		/// <param name="familyName">A string representation of the <see cref="T:System.Drawing.FontFamily" /> for the new <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="emSize">The em-size, in points, of the new font.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="emSize" /> is less than or equal to 0, evaluates to infinity or is not a valid number.</exception>
		public Font(string familyName, float emSize)
		{
			Initialize(familyName, emSize, FontStyle.Regular, GraphicsUnit.Point, 1, IsVerticalName(familyName));
		}

		private Font(IntPtr nativeFont, byte gdiCharSet, bool gdiVerticalFont)
		{
			int num = 0;
			float size = 0f;
			GraphicsUnit unit = GraphicsUnit.Point;
			FontStyle style = FontStyle.Regular;
			IntPtr family = IntPtr.Zero;
			this.nativeFont = nativeFont;
			num = SafeNativeMethods.Gdip.GdipGetFontUnit(new HandleRef(this, nativeFont), out unit);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipGetFontSize(new HandleRef(this, nativeFont), out size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipGetFontStyle(new HandleRef(this, nativeFont), out style);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			num = SafeNativeMethods.Gdip.GdipGetFamily(new HandleRef(this, nativeFont), out family);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetFontFamily(new FontFamily(family));
			Initialize(fontFamily, size, style, unit, gdiCharSet, gdiVerticalFont);
		}

		private void Initialize(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont)
		{
			originalFontName = familyName;
			SetFontFamily(new FontFamily(StripVerticalName(familyName), createDefaultOnFail: true));
			Initialize(fontFamily, emSize, style, unit, gdiCharSet, gdiVerticalFont);
		}

		private void Initialize(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont)
		{
			if (family == null)
			{
				throw new ArgumentNullException("family");
			}
			if (float.IsNaN(emSize) || float.IsInfinity(emSize) || emSize <= 0f)
			{
				throw new ArgumentException(SR.GetString("InvalidBoundArgument", "emSize", emSize, 0, "System.Single.MaxValue"), "emSize");
			}
			fontSize = emSize;
			fontStyle = style;
			fontUnit = unit;
			this.gdiCharSet = gdiCharSet;
			this.gdiVerticalFont = gdiVerticalFont;
			if (fontFamily == null)
			{
				SetFontFamily(new FontFamily(family.NativeFamily));
			}
			if (nativeFont == IntPtr.Zero)
			{
				CreateNativeFont();
			}
			int num = SafeNativeMethods.Gdip.GdipGetFontSize(new HandleRef(this, nativeFont), out fontSize);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Font" /> from the specified Windows handle.</summary>
		/// <param name="hfont">A Windows handle to a GDI font.</param>
		/// <returns>The <see cref="T:System.Drawing.Font" /> this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="hfont" /> points to an object that is not a TrueType font.</exception>
		public static Font FromHfont(IntPtr hfont)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			SafeNativeMethods.LOGFONT lOGFONT = new SafeNativeMethods.LOGFONT();
			SafeNativeMethods.GetObject(new HandleRef(null, hfont), lOGFONT);
			IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
			try
			{
				return FromLogFont(lOGFONT, dC);
			}
			finally
			{
				UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
			}
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Font" /> from the specified GDI logical font (LOGFONT) structure.</summary>
		/// <param name="lf">An <see cref="T:System.Object" /> that represents the GDI <see langword="LOGFONT" /> structure from which to create the <see cref="T:System.Drawing.Font" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Font" /> that this method creates.</returns>
		public static Font FromLogFont(object lf)
		{
			IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
			try
			{
				return FromLogFont(lf, dC);
			}
			finally
			{
				UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
			}
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Font" /> from the specified GDI logical font (LOGFONT) structure.</summary>
		/// <param name="lf">An <see cref="T:System.Object" /> that represents the GDI <see langword="LOGFONT" /> structure from which to create the <see cref="T:System.Drawing.Font" />.</param>
		/// <param name="hdc">A handle to a device context that contains additional information about the <paramref name="lf" /> structure.</param>
		/// <returns>The <see cref="T:System.Drawing.Font" /> that this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The font is not a TrueType font.</exception>
		public static Font FromLogFont(object lf, IntPtr hdc)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr font = IntPtr.Zero;
			int num = ((Marshal.SystemDefaultCharSize != 1) ? SafeNativeMethods.Gdip.GdipCreateFontFromLogfontW(new HandleRef(null, hdc), lf, out font) : SafeNativeMethods.Gdip.GdipCreateFontFromLogfontA(new HandleRef(null, hdc), lf, out font));
			switch (num)
			{
			case 16:
				throw new ArgumentException(SR.GetString("GdiplusNotTrueTypeFont_NoName"));
			default:
				throw SafeNativeMethods.Gdip.StatusException(num);
			case 0:
				if (font == IntPtr.Zero)
				{
					throw new ArgumentException(SR.GetString("GdiplusNotTrueTypeFont", lf.ToString()));
				}
				return new Font(gdiVerticalFont: (Marshal.SystemDefaultCharSize != 1) ? (Marshal.ReadInt16(lf, 28) == 64) : (Marshal.ReadByte(lf, 28) == 64), nativeFont: font, gdiCharSet: Marshal.ReadByte(lf, 23));
			}
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Font" /> from the specified Windows handle to a device context.</summary>
		/// <param name="hdc">A handle to a device context.</param>
		/// <returns>The <see cref="T:System.Drawing.Font" /> this method creates.</returns>
		/// <exception cref="T:System.ArgumentException">The font for the specified device context is not a TrueType font.</exception>
		public static Font FromHdc(IntPtr hdc)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr font = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateFontFromDC(new HandleRef(null, hdc), ref font);
			return num switch
			{
				16 => throw new ArgumentException(SR.GetString("GdiplusNotTrueTypeFont_NoName")), 
				0 => new Font(font, 0, gdiVerticalFont: false), 
				_ => throw SafeNativeMethods.Gdip.StatusException(num), 
			};
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Font" /> this method creates, cast as an <see cref="T:System.Object" />.</returns>
		public object Clone()
		{
			IntPtr cloneFont = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneFont(new HandleRef(this, nativeFont), out cloneFont);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Font(cloneFont, gdiCharSet, gdiVerticalFont);
		}

		private void SetFontFamily(FontFamily family)
		{
			fontFamily = family;
			new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
			GC.SuppressFinalize(fontFamily);
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Font()
		{
			Dispose(disposing: false);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Font" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeFont != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeleteFont(new HandleRef(this, nativeFont));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeFont = IntPtr.Zero;
			}
		}

		private static bool IsVerticalName(string familyName)
		{
			if (familyName != null && familyName.Length > 0)
			{
				return familyName[0] == '@';
			}
			return false;
		}

		/// <summary>Indicates whether the specified object is a <see cref="T:System.Drawing.Font" /> and has the same <see cref="P:System.Drawing.Font.FontFamily" />, <see cref="P:System.Drawing.Font.GdiVerticalFont" />, <see cref="P:System.Drawing.Font.GdiCharSet" />, <see cref="P:System.Drawing.Font.Style" />, <see cref="P:System.Drawing.Font.Size" />, and <see cref="P:System.Drawing.Font.Unit" /> property values as this <see cref="T:System.Drawing.Font" />.</summary>
		/// <param name="obj">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Drawing.Font" /> and has the same <see cref="P:System.Drawing.Font.FontFamily" />, <see cref="P:System.Drawing.Font.GdiVerticalFont" />, <see cref="P:System.Drawing.Font.GdiCharSet" />, <see cref="P:System.Drawing.Font.Style" />, <see cref="P:System.Drawing.Font.Size" />, and <see cref="P:System.Drawing.Font.Unit" /> property values as this <see cref="T:System.Drawing.Font" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (obj == this)
			{
				return true;
			}
			if (!(obj is Font font))
			{
				return false;
			}
			if (font.FontFamily.Equals(FontFamily) && font.GdiVerticalFont == GdiVerticalFont && font.GdiCharSet == GdiCharSet && font.Style == Style && font.Size == Size)
			{
				return font.Unit == Unit;
			}
			return false;
		}

		/// <summary>Gets the hash code for this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>The hash code for this <see cref="T:System.Drawing.Font" />.</returns>
		public override int GetHashCode()
		{
			return (((int)fontStyle << 13) | (int)((uint)fontStyle >> 19)) ^ (((int)fontUnit << 26) | (int)((uint)fontUnit >> 6)) ^ (int)(((uint)fontSize << 7) | ((uint)fontSize >> 25));
		}

		private static string StripVerticalName(string familyName)
		{
			if (familyName != null && familyName.Length > 1 && familyName[0] == '@')
			{
				return familyName.Substring(1);
			}
			return familyName;
		}

		/// <summary>Returns a human-readable string representation of this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.Font" />.</returns>
		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "[{0}: Name={1}, Size={2}, Units={3}, GdiCharSet={4}, GdiVerticalFont={5}]", GetType().Name, FontFamily.Name, fontSize, (int)fontUnit, gdiCharSet, gdiVerticalFont);
		}

		/// <summary>Creates a GDI logical font (LOGFONT) structure from this <see cref="T:System.Drawing.Font" />.</summary>
		/// <param name="logFont">An <see cref="T:System.Object" /> to represent the <see langword="LOGFONT" /> structure that this method creates.</param>
		public void ToLogFont(object logFont)
		{
			IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
			try
			{
				Graphics graphics = Graphics.FromHdcInternal(dC);
				try
				{
					ToLogFont(logFont, graphics);
				}
				finally
				{
					graphics.Dispose();
				}
			}
			finally
			{
				UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
			}
		}

		/// <summary>Creates a GDI logical font (LOGFONT) structure from this <see cref="T:System.Drawing.Font" />.</summary>
		/// <param name="logFont">An <see cref="T:System.Object" /> to represent the <see langword="LOGFONT" /> structure that this method creates.</param>
		/// <param name="graphics">A <see cref="T:System.Drawing.Graphics" /> that provides additional information for the <see langword="LOGFONT" /> structure.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="graphics" /> is <see langword="null" />.</exception>
		public void ToLogFont(object logFont, Graphics graphics)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			int num = ((Marshal.SystemDefaultCharSize != 1) ? SafeNativeMethods.Gdip.GdipGetLogFontW(new HandleRef(this, NativeFont), new HandleRef(graphics, graphics.NativeGraphics), logFont) : SafeNativeMethods.Gdip.GdipGetLogFontA(new HandleRef(this, NativeFont), new HandleRef(graphics, graphics.NativeGraphics), logFont));
			if (gdiVerticalFont)
			{
				if (Marshal.SystemDefaultCharSize == 1)
				{
					for (int num2 = 30; num2 >= 0; num2--)
					{
						Marshal.WriteByte(logFont, 28 + num2 + 1, Marshal.ReadByte(logFont, 28 + num2));
					}
					Marshal.WriteByte(logFont, 28, 64);
				}
				else
				{
					for (int num3 = 60; num3 >= 0; num3 -= 2)
					{
						Marshal.WriteInt16(logFont, 28 + num3 + 2, Marshal.ReadInt16(logFont, 28 + num3));
					}
					Marshal.WriteInt16(logFont, 28, 64);
				}
			}
			if (Marshal.ReadByte(logFont, 23) == 0)
			{
				Marshal.WriteByte(logFont, 23, gdiCharSet);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Returns a handle to this <see cref="T:System.Drawing.Font" />.</summary>
		/// <returns>A Windows handle to this <see cref="T:System.Drawing.Font" />.</returns>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The operation was unsuccessful.</exception>
		public IntPtr ToHfont()
		{
			SafeNativeMethods.LOGFONT lOGFONT = new SafeNativeMethods.LOGFONT();
			IntSecurity.ObjectFromWin32Handle.Assert();
			try
			{
				ToLogFont(lOGFONT);
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
			IntPtr intPtr = IntUnsafeNativeMethods.IntCreateFontIndirect(lOGFONT);
			if (intPtr == IntPtr.Zero)
			{
				throw new Win32Exception();
			}
			return intPtr;
		}

		/// <summary>Returns the line spacing, in the current unit of a specified <see cref="T:System.Drawing.Graphics" />, of this font.</summary>
		/// <param name="graphics">A <see cref="T:System.Drawing.Graphics" /> that holds the vertical resolution, in dots per inch, of the display device as well as settings for page unit and page scale.</param>
		/// <returns>The line spacing, in pixels, of this font.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="graphics" /> is <see langword="null" />.</exception>
		public float GetHeight(Graphics graphics)
		{
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			float size;
			int num = SafeNativeMethods.Gdip.GdipGetFontHeight(new HandleRef(this, NativeFont), new HandleRef(graphics, graphics.NativeGraphics), out size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return size;
		}

		/// <summary>Returns the line spacing, in pixels, of this font.</summary>
		/// <returns>The line spacing, in pixels, of this font.</returns>
		public float GetHeight()
		{
			IntPtr dC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
			float num = 0f;
			try
			{
				using Graphics graphics = Graphics.FromHdcInternal(dC);
				return GetHeight(graphics);
			}
			finally
			{
				UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dC));
			}
		}

		/// <summary>Returns the height, in pixels, of this <see cref="T:System.Drawing.Font" /> when drawn to a device with the specified vertical resolution.</summary>
		/// <param name="dpi">The vertical resolution, in dots per inch, used to calculate the height of the font.</param>
		/// <returns>The height, in pixels, of this <see cref="T:System.Drawing.Font" />.</returns>
		public float GetHeight(float dpi)
		{
			float size;
			int num = SafeNativeMethods.Gdip.GdipGetFontHeightGivenDPI(new HandleRef(this, NativeFont), dpi, out size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return size;
		}

		internal void SetSystemFontName(string systemFontName)
		{
			this.systemFontName = systemFontName;
		}
	}
	/// <summary>Defines a group of type faces having a similar basic design and certain variations in styles. This class cannot be inherited.</summary>
	public sealed class FontFamily : MarshalByRefObject, IDisposable
	{
		private const int LANG_NEUTRAL = 0;

		private IntPtr nativeFamily;

		private bool createDefaultOnFail;

		internal IntPtr NativeFamily => nativeFamily;

		private static int CurrentLanguage => CultureInfo.CurrentUICulture.LCID;

		/// <summary>Gets the name of this <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that represents the name of this <see cref="T:System.Drawing.FontFamily" />.</returns>
		public string Name => GetName(CurrentLanguage);

		/// <summary>Returns an array that contains all the <see cref="T:System.Drawing.FontFamily" /> objects associated with the current graphics context.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.FontFamily" /> objects associated with the current graphics context.</returns>
		public static FontFamily[] Families => new InstalledFontCollection().Families;

		/// <summary>Gets a generic sans serif <see cref="T:System.Drawing.FontFamily" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.FontFamily" /> object that represents a generic sans serif font.</returns>
		public static FontFamily GenericSansSerif => new FontFamily(GetGdipGenericSansSerif());

		/// <summary>Gets a generic serif <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.FontFamily" /> that represents a generic serif font.</returns>
		public static FontFamily GenericSerif => new FontFamily(GetNativeGenericSerif());

		/// <summary>Gets a generic monospace <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.FontFamily" /> that represents a generic monospace font.</returns>
		public static FontFamily GenericMonospace => new FontFamily(GetNativeGenericMonospace());

		private void SetNativeFamily(IntPtr family)
		{
			nativeFamily = family;
		}

		internal FontFamily(IntPtr family)
		{
			SetNativeFamily(family);
		}

		internal FontFamily(string name, bool createDefaultOnFail)
		{
			this.createDefaultOnFail = createDefaultOnFail;
			CreateFontFamily(name, null);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.FontFamily" /> with the specified name.</summary>
		/// <param name="name">The name of the new <see cref="T:System.Drawing.FontFamily" />.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="name" /> is an empty string ("").  
		/// -or-  
		/// <paramref name="name" /> specifies a font that is not installed on the computer running the application.  
		/// -or-  
		/// <paramref name="name" /> specifies a font that is not a TrueType font.</exception>
		public FontFamily(string name)
		{
			CreateFontFamily(name, null);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.FontFamily" /> in the specified <see cref="T:System.Drawing.Text.FontCollection" /> with the specified name.</summary>
		/// <param name="name">A <see cref="T:System.String" /> that represents the name of the new <see cref="T:System.Drawing.FontFamily" />.</param>
		/// <param name="fontCollection">The <see cref="T:System.Drawing.Text.FontCollection" /> that contains this <see cref="T:System.Drawing.FontFamily" />.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="name" /> is an empty string ("").  
		/// -or-  
		/// <paramref name="name" /> specifies a font that is not installed on the computer running the application.  
		/// -or-  
		/// <paramref name="name" /> specifies a font that is not a TrueType font.</exception>
		public FontFamily(string name, FontCollection fontCollection)
		{
			CreateFontFamily(name, fontCollection);
		}

		private void CreateFontFamily(string name, FontCollection fontCollection)
		{
			IntPtr FontFamily = IntPtr.Zero;
			IntPtr handle = fontCollection?.nativeFontCollection ?? IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateFontFamilyFromName(name, new HandleRef(fontCollection, handle), out FontFamily);
			if (num != 0)
			{
				if (!createDefaultOnFail)
				{
					switch (num)
					{
					case 14:
						throw new ArgumentException(SR.GetString("GdiplusFontFamilyNotFound", name));
					case 16:
						throw new ArgumentException(SR.GetString("GdiplusNotTrueTypeFont", name));
					default:
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
				}
				FontFamily = GetGdipGenericSansSerif();
			}
			SetNativeFamily(FontFamily);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.FontFamily" /> from the specified generic font family.</summary>
		/// <param name="genericFamily">The <see cref="T:System.Drawing.Text.GenericFontFamilies" /> from which to create the new <see cref="T:System.Drawing.FontFamily" />.</param>
		public FontFamily(GenericFontFamilies genericFamily)
		{
			IntPtr fontfamily = IntPtr.Zero;
			int num = genericFamily switch
			{
				GenericFontFamilies.Serif => SafeNativeMethods.Gdip.GdipGetGenericFontFamilySerif(out fontfamily), 
				GenericFontFamilies.SansSerif => SafeNativeMethods.Gdip.GdipGetGenericFontFamilySansSerif(out fontfamily), 
				_ => SafeNativeMethods.Gdip.GdipGetGenericFontFamilyMonospace(out fontfamily), 
			};
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeFamily(fontfamily);
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~FontFamily()
		{
			Dispose(disposing: false);
		}

		/// <summary>Indicates whether the specified object is a <see cref="T:System.Drawing.FontFamily" /> and is identical to this <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <param name="obj">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.FontFamily" /> and is identical to this <see cref="T:System.Drawing.FontFamily" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (obj == this)
			{
				return true;
			}
			if (!(obj is FontFamily fontFamily))
			{
				return false;
			}
			return fontFamily.NativeFamily == NativeFamily;
		}

		/// <summary>Converts this <see cref="T:System.Drawing.FontFamily" /> to a human-readable string representation.</summary>
		/// <returns>The string that represents this <see cref="T:System.Drawing.FontFamily" />.</returns>
		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "[{0}: Name={1}]", new object[2]
			{
				GetType().Name,
				Name
			});
		}

		/// <summary>Gets a hash code for this <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <returns>The hash code for this <see cref="T:System.Drawing.FontFamily" />.</returns>
		public override int GetHashCode()
		{
			return GetName(0).GetHashCode();
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.FontFamily" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeFamily != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeleteFontFamily(new HandleRef(this, nativeFamily));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeFamily = IntPtr.Zero;
			}
		}

		/// <summary>Returns the name, in the specified language, of this <see cref="T:System.Drawing.FontFamily" />.</summary>
		/// <param name="language">The language in which the name is returned.</param>
		/// <returns>A <see cref="T:System.String" /> that represents the name, in the specified language, of this <see cref="T:System.Drawing.FontFamily" />.</returns>
		public string GetName(int language)
		{
			StringBuilder stringBuilder = new StringBuilder(32);
			int num = SafeNativeMethods.Gdip.GdipGetFamilyName(new HandleRef(this, NativeFamily), stringBuilder, language);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return stringBuilder.ToString();
		}

		private static IntPtr GetGdipGenericSansSerif()
		{
			IntPtr fontfamily = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetGenericFontFamilySansSerif(out fontfamily);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return fontfamily;
		}

		private static IntPtr GetNativeGenericSerif()
		{
			IntPtr fontfamily = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetGenericFontFamilySerif(out fontfamily);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return fontfamily;
		}

		private static IntPtr GetNativeGenericMonospace()
		{
			IntPtr fontfamily = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetGenericFontFamilyMonospace(out fontfamily);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return fontfamily;
		}

		/// <summary>Returns an array that contains all the <see cref="T:System.Drawing.FontFamily" /> objects available for the specified graphics context.</summary>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> object from which to return <see cref="T:System.Drawing.FontFamily" /> objects.</param>
		/// <returns>An array of <see cref="T:System.Drawing.FontFamily" /> objects available for the specified <see cref="T:System.Drawing.Graphics" /> object.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="graphics" /> is <see langword="null" />.</exception>
		[Obsolete("Do not use method GetFamilies, use property Families instead")]
		public static FontFamily[] GetFamilies(Graphics graphics)
		{
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			return new InstalledFontCollection().Families;
		}

		/// <summary>Indicates whether the specified <see cref="T:System.Drawing.FontStyle" /> enumeration is available.</summary>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if the specified <see cref="T:System.Drawing.FontStyle" /> is available; otherwise, <see langword="false" />.</returns>
		public bool IsStyleAvailable(FontStyle style)
		{
			int isStyleAvailable;
			int num = SafeNativeMethods.Gdip.GdipIsStyleAvailable(new HandleRef(this, NativeFamily), style, out isStyleAvailable);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return isStyleAvailable != 0;
		}

		/// <summary>Gets the height, in font design units, of the em square for the specified style.</summary>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> for which to get the em height.</param>
		/// <returns>The height of the em square.</returns>
		public int GetEmHeight(FontStyle style)
		{
			int EmHeight = 0;
			int num = SafeNativeMethods.Gdip.GdipGetEmHeight(new HandleRef(this, NativeFamily), style, out EmHeight);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return EmHeight;
		}

		/// <summary>Returns the cell ascent, in design units, of the <see cref="T:System.Drawing.FontFamily" /> of the specified style.</summary>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> that contains style information for the font.</param>
		/// <returns>The cell ascent for this <see cref="T:System.Drawing.FontFamily" /> that uses the specified <see cref="T:System.Drawing.FontStyle" />.</returns>
		public int GetCellAscent(FontStyle style)
		{
			int CellAscent = 0;
			int num = SafeNativeMethods.Gdip.GdipGetCellAscent(new HandleRef(this, NativeFamily), style, out CellAscent);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CellAscent;
		}

		/// <summary>Returns the cell descent, in design units, of the <see cref="T:System.Drawing.FontFamily" /> of the specified style.</summary>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> that contains style information for the font.</param>
		/// <returns>The cell descent metric for this <see cref="T:System.Drawing.FontFamily" /> that uses the specified <see cref="T:System.Drawing.FontStyle" />.</returns>
		public int GetCellDescent(FontStyle style)
		{
			int CellDescent = 0;
			int num = SafeNativeMethods.Gdip.GdipGetCellDescent(new HandleRef(this, NativeFamily), style, out CellDescent);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CellDescent;
		}

		/// <summary>Returns the line spacing, in design units, of the <see cref="T:System.Drawing.FontFamily" /> of the specified style. The line spacing is the vertical distance between the base lines of two consecutive lines of text.</summary>
		/// <param name="style">The <see cref="T:System.Drawing.FontStyle" /> to apply.</param>
		/// <returns>The distance between two consecutive lines of text.</returns>
		public int GetLineSpacing(FontStyle style)
		{
			int LineSpaceing = 0;
			int num = SafeNativeMethods.Gdip.GdipGetLineSpacing(new HandleRef(this, NativeFamily), style, out LineSpaceing);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return LineSpaceing;
		}
	}
	/// <summary>Specifies style information applied to text.</summary>
	[Flags]
	public enum FontStyle
	{
		/// <summary>Normal text.</summary>
		Regular = 0,
		/// <summary>Bold text.</summary>
		Bold = 1,
		/// <summary>Italic text.</summary>
		Italic = 2,
		/// <summary>Underlined text.</summary>
		Underline = 4,
		/// <summary>Text with a line through the middle.</summary>
		Strikeout = 8
	}
	[SuppressUnmanagedCodeSecurity]
	internal class SafeNativeMethods
	{
		[SuppressUnmanagedCodeSecurity]
		internal class Gdip
		{
			private struct StartupInput
			{
				public int GdiplusVersion;

				public IntPtr DebugEventCallback;

				public bool SuppressBackgroundThread;

				public bool SuppressExternalCodecs;

				public static StartupInput GetDefault()
				{
					StartupInput result = default(StartupInput);
					result.GdiplusVersion = 1;
					result.SuppressBackgroundThread = false;
					result.SuppressExternalCodecs = false;
					return result;
				}
			}

			private struct StartupOutput
			{
				public IntPtr hook;

				public IntPtr unhook;
			}

			private enum DebugEventLevel
			{
				Fatal,
				Warning
			}

			private static readonly TraceSwitch GdiPlusInitialization;

			private static IntPtr initToken;

			private const string ThreadDataSlotName = "system.drawing.threaddata";

			internal const int Ok = 0;

			internal const int GenericError = 1;

			internal const int InvalidParameter = 2;

			internal const int OutOfMemory = 3;

			internal const int ObjectBusy = 4;

			internal const int InsufficientBuffer = 5;

			internal const int NotImplemented = 6;

			internal const int Win32Error = 7;

			internal const int WrongState = 8;

			internal const int Aborted = 9;

			internal const int FileNotFound = 10;

			internal const int ValueOverflow = 11;

			internal const int AccessDenied = 12;

			internal const int UnknownImageFormat = 13;

			internal const int FontFamilyNotFound = 14;

			internal const int FontStyleNotFound = 15;

			internal const int NotTrueTypeFont = 16;

			internal const int UnsupportedGdiplusVersion = 17;

			internal const int GdiplusNotInitialized = 18;

			internal const int PropertyNotFound = 19;

			internal const int PropertyNotSupported = 20;

			private static bool Initialized => initToken != IntPtr.Zero;

			internal static IDictionary ThreadData
			{
				get
				{
					LocalDataStoreSlot namedDataSlot = Thread.GetNamedDataSlot("system.drawing.threaddata");
					IDictionary dictionary = (IDictionary)Thread.GetData(namedDataSlot);
					if (dictionary == null)
					{
						dictionary = new Hashtable();
						Thread.SetData(namedDataSlot, dictionary);
					}
					return dictionary;
				}
			}

			static Gdip()
			{
				GdiPlusInitialization = new TraceSwitch("GdiPlusInitialization", "Tracks GDI+ initialization and teardown");
				Initialize();
			}

			[MethodImpl(MethodImplOptions.NoInlining)]
			private static void ClearThreadData()
			{
				LocalDataStoreSlot namedDataSlot = Thread.GetNamedDataSlot("system.drawing.threaddata");
				Thread.SetData(namedDataSlot, null);
			}

			private static void Initialize()
			{
				StartupInput input = StartupInput.GetDefault();
				StartupOutput output;
				int num = GdiplusStartup(out initToken, ref input, out output);
				if (num != 0)
				{
					throw StatusException(num);
				}
				AppDomain currentDomain = AppDomain.CurrentDomain;
				currentDomain.ProcessExit += OnProcessExit;
				if (!currentDomain.IsDefaultAppDomain())
				{
					currentDomain.DomainUnload += OnProcessExit;
				}
			}

			private static void Shutdown()
			{
				if (Initialized)
				{
					ClearThreadData();
					AppDomain currentDomain = AppDomain.CurrentDomain;
					currentDomain.ProcessExit -= OnProcessExit;
					if (!currentDomain.IsDefaultAppDomain())
					{
						currentDomain.DomainUnload -= OnProcessExit;
					}
				}
			}

			[PrePrepareMethod]
			private static void OnProcessExit(object sender, EventArgs e)
			{
				Shutdown();
			}

			internal static void DummyFunction()
			{
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			private static extern int GdiplusStartup(out IntPtr token, ref StartupInput input, out StartupOutput output);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			private static extern void GdiplusShutdown(HandleRef token);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePath(int brushMode, out IntPtr path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePath2(HandleRef points, HandleRef types, int count, int brushMode, out IntPtr path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePath2I(HandleRef points, HandleRef types, int count, int brushMode, out IntPtr path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipClonePath(HandleRef path, out IntPtr clonepath);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeletePath", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeletePath(HandleRef path);

			internal static int GdipDeletePath(HandleRef path)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeletePath(path);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetPath(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPointCount(HandleRef path, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathTypes(HandleRef path, byte[] types, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathPoints(HandleRef path, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathFillMode(HandleRef path, out int fillmode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathFillMode(HandleRef path, int fillmode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathData(HandleRef path, IntPtr pathData);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipStartPathFigure(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipClosePathFigure(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipClosePathFigures(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathMarker(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipClearPathMarkers(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipReversePath(HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathLastPoint(HandleRef path, GPPOINTF lastPoint);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathLine(HandleRef path, float x1, float y1, float x2, float y2);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathLine2(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathArc(HandleRef path, float x, float y, float width, float height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathBezier(HandleRef path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathBeziers(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurve(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurve2(HandleRef path, HandleRef memorypts, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurve3(HandleRef path, HandleRef memorypts, int count, int offset, int numberOfSegments, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathClosedCurve(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathClosedCurve2(HandleRef path, HandleRef memorypts, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathRectangle(HandleRef path, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathRectangles(HandleRef path, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathEllipse(HandleRef path, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathPie(HandleRef path, float x, float y, float width, float height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathPolygon(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathPath(HandleRef path, HandleRef addingPath, bool connect);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathString(HandleRef path, string s, int length, HandleRef fontFamily, int style, float emSize, ref GPRECTF layoutRect, HandleRef format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathStringI(HandleRef path, string s, int length, HandleRef fontFamily, int style, float emSize, ref GPRECT layoutRect, HandleRef format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathLineI(HandleRef path, int x1, int y1, int x2, int y2);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathLine2I(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathArcI(HandleRef path, int x, int y, int width, int height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathBezierI(HandleRef path, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathBeziersI(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurveI(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurve2I(HandleRef path, HandleRef memorypts, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathCurve3I(HandleRef path, HandleRef memorypts, int count, int offset, int numberOfSegments, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathClosedCurveI(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathClosedCurve2I(HandleRef path, HandleRef memorypts, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathRectangleI(HandleRef path, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathRectanglesI(HandleRef path, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathEllipseI(HandleRef path, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathPieI(HandleRef path, int x, int y, int width, int height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipAddPathPolygonI(HandleRef path, HandleRef memorypts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFlattenPath(HandleRef path, HandleRef matrixfloat, float flatness);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipWidenPath(HandleRef path, HandleRef pen, HandleRef matrix, float flatness);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipWarpPath(HandleRef path, HandleRef matrix, HandleRef points, int count, float srcX, float srcY, float srcWidth, float srcHeight, WarpMode warpMode, float flatness);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformPath(HandleRef path, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathWorldBounds(HandleRef path, ref GPRECTF gprectf, HandleRef matrix, HandleRef pen);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisiblePathPoint(HandleRef path, float x, float y, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisiblePathPointI(HandleRef path, int x, int y, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsOutlineVisiblePathPoint(HandleRef path, float x, float y, HandleRef pen, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsOutlineVisiblePathPointI(HandleRef path, int x, int y, HandleRef pen, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePathIter(out IntPtr pathIter, HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeletePathIter", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeletePathIter(HandleRef pathIter);

			internal static int GdipDeletePathIter(HandleRef pathIter)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeletePathIter(pathIter);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterNextSubpath(HandleRef pathIter, out int resultCount, out int startIndex, out int endIndex, out bool isClosed);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterNextSubpathPath(HandleRef pathIter, out int resultCount, HandleRef path, out bool isClosed);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterNextPathType(HandleRef pathIter, out int resultCount, out byte pathType, out int startIndex, out int endIndex);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterNextMarker(HandleRef pathIter, out int resultCount, out int startIndex, out int endIndex);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterNextMarkerPath(HandleRef pathIter, out int resultCount, HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterGetCount(HandleRef pathIter, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterGetSubpathCount(HandleRef pathIter, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterHasCurve(HandleRef pathIter, out bool hasCurve);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterRewind(HandleRef pathIter);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterEnumerate(HandleRef pathIter, out int resultCount, IntPtr memoryPts, [In][Out] byte[] types, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPathIterCopyData(HandleRef pathIter, out int resultCount, IntPtr memoryPts, [In][Out] byte[] types, int startIndex, int endIndex);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMatrix(out IntPtr matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMatrix2(float m11, float m12, float m21, float m22, float dx, float dy, out IntPtr matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMatrix3(ref GPRECTF rect, HandleRef dstplg, out IntPtr matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMatrix3I(ref GPRECT rect, HandleRef dstplg, out IntPtr matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneMatrix(HandleRef matrix, out IntPtr cloneMatrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteMatrix", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteMatrix(HandleRef matrix);

			internal static int GdipDeleteMatrix(HandleRef matrix)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeleteMatrix(matrix);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetMatrixElements(HandleRef matrix, float m11, float m12, float m21, float m22, float dx, float dy);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyMatrix(HandleRef matrix, HandleRef matrix2, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateMatrix(HandleRef matrix, float offsetX, float offsetY, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScaleMatrix(HandleRef matrix, float scaleX, float scaleY, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotateMatrix(HandleRef matrix, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipShearMatrix(HandleRef matrix, float shearX, float shearY, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipInvertMatrix(HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformMatrixPoints(HandleRef matrix, HandleRef pts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformMatrixPointsI(HandleRef matrix, HandleRef pts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipVectorTransformMatrixPoints(HandleRef matrix, HandleRef pts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipVectorTransformMatrixPointsI(HandleRef matrix, HandleRef pts, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMatrixElements(HandleRef matrix, IntPtr m);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsMatrixInvertible(HandleRef matrix, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsMatrixIdentity(HandleRef matrix, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsMatrixEqual(HandleRef matrix, HandleRef matrix2, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegion(out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegionRect(ref GPRECTF gprectf, out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegionRectI(ref GPRECT gprect, out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegionPath(HandleRef path, out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegionRgnData(byte[] rgndata, int size, out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateRegionHrgn(HandleRef hRgn, out IntPtr region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneRegion(HandleRef region, out IntPtr cloneregion);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteRegion", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteRegion(HandleRef region);

			internal static int GdipDeleteRegion(HandleRef region)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeleteRegion(region);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetInfinite(HandleRef region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetEmpty(HandleRef region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCombineRegionRect(HandleRef region, ref GPRECTF gprectf, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCombineRegionRectI(HandleRef region, ref GPRECT gprect, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCombineRegionPath(HandleRef region, HandleRef path, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCombineRegionRegion(HandleRef region, HandleRef region2, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateRegion(HandleRef region, float dx, float dy);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateRegionI(HandleRef region, int dx, int dy);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformRegion(HandleRef region, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionBounds(HandleRef region, HandleRef graphics, ref GPRECTF gprectf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionHRgn(HandleRef region, HandleRef graphics, out IntPtr hrgn);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsEmptyRegion(HandleRef region, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsInfiniteRegion(HandleRef region, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsEqualRegion(HandleRef region, HandleRef region2, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionDataSize(HandleRef region, out int bufferSize);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionData(HandleRef region, byte[] regionData, int bufferSize, out int sizeFilled);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRegionPoint(HandleRef region, float X, float Y, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRegionPointI(HandleRef region, int X, int Y, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRegionRect(HandleRef region, float X, float Y, float width, float height, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRegionRectI(HandleRef region, int X, int Y, int width, int height, HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionScansCount(HandleRef region, out int count, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRegionScans(HandleRef region, IntPtr rects, out int count, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneBrush(HandleRef brush, out IntPtr clonebrush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteBrush", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteBrush(HandleRef brush);

			internal static int GdipDeleteBrush(HandleRef brush)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeleteBrush(brush);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateHatchBrush(int hatchstyle, int forecol, int backcol, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetHatchStyle(HandleRef brush, out int hatchstyle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetHatchForegroundColor(HandleRef brush, out int forecol);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetHatchBackgroundColor(HandleRef brush, out int backcol);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateTexture(HandleRef bitmap, int wrapmode, out IntPtr texture);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateTexture2(HandleRef bitmap, int wrapmode, float x, float y, float width, float height, out IntPtr texture);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateTextureIA(HandleRef bitmap, HandleRef imageAttrib, float x, float y, float width, float height, out IntPtr texture);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateTexture2I(HandleRef bitmap, int wrapmode, int x, int y, int width, int height, out IntPtr texture);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateTextureIAI(HandleRef bitmap, HandleRef imageAttrib, int x, int y, int width, int height, out IntPtr texture);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetTextureTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetTextureTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetTextureTransform(HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyTextureTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateTextureTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScaleTextureTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotateTextureTransform(HandleRef brush, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetTextureWrapMode(HandleRef brush, int wrapMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetTextureWrapMode(HandleRef brush, out int wrapMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetTextureImage(HandleRef brush, out IntPtr image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateSolidFill(int color, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetSolidFillColor(HandleRef brush, int color);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetSolidFillColor(HandleRef brush, out int color);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrush(GPPOINTF point1, GPPOINTF point2, int color1, int color2, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrushI(GPPOINT point1, GPPOINT point2, int color1, int color2, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrushFromRect(ref GPRECTF rect, int color1, int color2, int lineGradientMode, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrushFromRectI(ref GPRECT rect, int color1, int color2, int lineGradientMode, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrushFromRectWithAngle(ref GPRECTF rect, int color1, int color2, float angle, bool isAngleScaleable, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateLineBrushFromRectWithAngleI(ref GPRECT rect, int color1, int color2, float angle, bool isAngleScaleable, int wrapMode, out IntPtr lineGradient);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineColors(HandleRef brush, int color1, int color2);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineColors(HandleRef brush, int[] colors);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineRect(HandleRef brush, ref GPRECTF gprectf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineGammaCorrection(HandleRef brush, out bool useGammaCorrection);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineGammaCorrection(HandleRef brush, bool useGammaCorrection);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineSigmaBlend(HandleRef brush, float focus, float scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineLinearBlend(HandleRef brush, float focus, float scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineBlendCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineBlend(HandleRef brush, IntPtr blend, IntPtr positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineBlend(HandleRef brush, HandleRef blend, HandleRef positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLinePresetBlendCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLinePresetBlend(HandleRef brush, IntPtr blend, IntPtr positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLinePresetBlend(HandleRef brush, HandleRef blend, HandleRef positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineWrapMode(HandleRef brush, int wrapMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineWrapMode(HandleRef brush, out int wrapMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetLineTransform(HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyLineTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetLineTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateLineTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScaleLineTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotateLineTransform(HandleRef brush, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePathGradient(HandleRef points, int count, int wrapMode, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePathGradientI(HandleRef points, int count, int wrapMode, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePathGradientFromPath(HandleRef path, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientCenterColor(HandleRef brush, out int color);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientCenterColor(HandleRef brush, int color);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientSurroundColorsWithCount(HandleRef brush, int[] color, ref int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientSurroundColorsWithCount(HandleRef brush, int[] argb, ref int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientCenterPoint(HandleRef brush, GPPOINTF point);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientCenterPoint(HandleRef brush, GPPOINTF point);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientRect(HandleRef brush, ref GPRECTF gprectf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientPointCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientSurroundColorCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientBlendCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientBlend(HandleRef brush, IntPtr blend, IntPtr positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientBlend(HandleRef brush, HandleRef blend, HandleRef positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientPresetBlendCount(HandleRef brush, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientPresetBlend(HandleRef brush, IntPtr blend, IntPtr positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientPresetBlend(HandleRef brush, HandleRef blend, HandleRef positions, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientSigmaBlend(HandleRef brush, float focus, float scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientLinearBlend(HandleRef brush, float focus, float scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientWrapMode(HandleRef brush, int wrapmode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientWrapMode(HandleRef brush, out int wrapmode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientTransform(HandleRef brush, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetPathGradientTransform(HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyPathGradientTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslatePathGradientTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScalePathGradientTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotatePathGradientTransform(HandleRef brush, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPathGradientFocusScales(HandleRef brush, float[] xScale, float[] yScale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPathGradientFocusScales(HandleRef brush, float xScale, float yScale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePen1(int argb, float width, int unit, out IntPtr pen);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreatePen2(HandleRef brush, float width, int unit, out IntPtr pen);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipClonePen(HandleRef pen, out IntPtr clonepen);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeletePen", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeletePen(HandleRef Pen);

			internal static int GdipDeletePen(HandleRef pen)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeletePen(pen);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenMode(HandleRef pen, PenAlignment penAlign);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenMode(HandleRef pen, out PenAlignment penAlign);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenWidth(HandleRef pen, float width);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenWidth(HandleRef pen, float[] width);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenLineCap197819(HandleRef pen, int startCap, int endCap, int dashCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenStartCap(HandleRef pen, int startCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenEndCap(HandleRef pen, int endCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenStartCap(HandleRef pen, out int startCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenEndCap(HandleRef pen, out int endCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenDashCap197819(HandleRef pen, out int dashCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenDashCap197819(HandleRef pen, int dashCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenLineJoin(HandleRef pen, int lineJoin);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenLineJoin(HandleRef pen, out int lineJoin);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenCustomStartCap(HandleRef pen, HandleRef customCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenCustomStartCap(HandleRef pen, out IntPtr customCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenCustomEndCap(HandleRef pen, HandleRef customCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenCustomEndCap(HandleRef pen, out IntPtr customCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenMiterLimit(HandleRef pen, float miterLimit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenMiterLimit(HandleRef pen, float[] miterLimit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenTransform(HandleRef pen, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenTransform(HandleRef pen, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetPenTransform(HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyPenTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslatePenTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScalePenTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotatePenTransform(HandleRef brush, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenColor(HandleRef pen, int argb);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenColor(HandleRef pen, out int argb);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenBrushFill(HandleRef pen, HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenBrushFill(HandleRef pen, out IntPtr brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenFillType(HandleRef pen, out int pentype);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenDashStyle(HandleRef pen, out int dashstyle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenDashStyle(HandleRef pen, int dashstyle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenDashArray(HandleRef pen, HandleRef memorydash, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenDashOffset(HandleRef pen, float[] dashoffset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenDashOffset(HandleRef pen, float dashoffset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenDashCount(HandleRef pen, out int dashcount);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenDashArray(HandleRef pen, IntPtr memorydash, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenCompoundCount(HandleRef pen, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPenCompoundArray(HandleRef pen, float[] array, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPenCompoundArray(HandleRef pen, float[] array, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateCustomLineCap(HandleRef fillpath, HandleRef strokepath, LineCap baseCap, float baseInset, out IntPtr customCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteCustomLineCap", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteCustomLineCap(HandleRef customCap);

			internal static int GdipDeleteCustomLineCap(HandleRef customCap)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeleteCustomLineCap(customCap);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneCustomLineCap(HandleRef customCap, out IntPtr clonedCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapType(HandleRef customCap, out CustomLineCapType capType);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCustomLineCapStrokeCaps(HandleRef customCap, LineCap startCap, LineCap endCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapStrokeCaps(HandleRef customCap, out LineCap startCap, out LineCap endCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCustomLineCapStrokeJoin(HandleRef customCap, LineJoin lineJoin);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapStrokeJoin(HandleRef customCap, out LineJoin lineJoin);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCustomLineCapBaseCap(HandleRef customCap, LineCap baseCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapBaseCap(HandleRef customCap, out LineCap baseCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCustomLineCapBaseInset(HandleRef customCap, float inset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapBaseInset(HandleRef customCap, out float inset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCustomLineCapWidthScale(HandleRef customCap, float widthScale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCustomLineCapWidthScale(HandleRef customCap, out float widthScale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateAdjustableArrowCap(float height, float width, bool isFilled, out IntPtr adjustableArrowCap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetAdjustableArrowCapHeight(HandleRef adjustableArrowCap, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetAdjustableArrowCapHeight(HandleRef adjustableArrowCap, out float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetAdjustableArrowCapWidth(HandleRef adjustableArrowCap, float width);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetAdjustableArrowCapWidth(HandleRef adjustableArrowCap, out float width);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetAdjustableArrowCapMiddleInset(HandleRef adjustableArrowCap, float middleInset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetAdjustableArrowCapMiddleInset(HandleRef adjustableArrowCap, out float middleInset);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetAdjustableArrowCapFillState(HandleRef adjustableArrowCap, bool fillState);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetAdjustableArrowCapFillState(HandleRef adjustableArrowCap, out bool fillState);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipLoadImageFromStream(UnsafeNativeMethods.IStream stream, out IntPtr image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipLoadImageFromFile(string filename, out IntPtr image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipLoadImageFromStreamICM(UnsafeNativeMethods.IStream stream, out IntPtr image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipLoadImageFromFileICM(string filename, out IntPtr image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneImage(HandleRef image, out IntPtr cloneimage);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDisposeImage", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDisposeImage(HandleRef image);

			internal static int GdipDisposeImage(HandleRef image)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDisposeImage(image);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSaveImageToFile(HandleRef image, string filename, ref Guid classId, HandleRef encoderParams);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSaveImageToStream(HandleRef image, UnsafeNativeMethods.IStream stream, ref Guid classId, HandleRef encoderParams);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSaveAdd(HandleRef image, HandleRef encoderParams);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSaveAddImage(HandleRef image, HandleRef newImage, HandleRef encoderParams);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageGraphicsContext(HandleRef image, out IntPtr graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageBounds(HandleRef image, ref GPRECTF gprectf, out GraphicsUnit unit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageDimension(HandleRef image, out float width, out float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageType(HandleRef image, out int type);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageWidth(HandleRef image, out int width);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageHeight(HandleRef image, out int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageHorizontalResolution(HandleRef image, out float horzRes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageVerticalResolution(HandleRef image, out float vertRes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageFlags(HandleRef image, out int flags);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageRawFormat(HandleRef image, ref Guid format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImagePixelFormat(HandleRef image, out int format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageThumbnail(HandleRef image, int thumbWidth, int thumbHeight, out IntPtr thumbImage, Image.GetThumbnailImageAbort callback, IntPtr callbackdata);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetEncoderParameterListSize(HandleRef image, ref Guid clsid, out int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetEncoderParameterList(HandleRef image, ref Guid clsid, int size, IntPtr buffer);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageGetFrameDimensionsCount(HandleRef image, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageGetFrameDimensionsList(HandleRef image, IntPtr buffer, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageGetFrameCount(HandleRef image, ref Guid dimensionID, int[] count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageSelectActiveFrame(HandleRef image, ref Guid dimensionID, int frameIndex);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageRotateFlip(HandleRef image, int rotateFlipType);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImagePalette(HandleRef image, IntPtr palette, int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImagePalette(HandleRef image, IntPtr palette);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImagePaletteSize(HandleRef image, out int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPropertyCount(HandleRef image, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPropertyIdList(HandleRef image, int count, int[] list);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPropertyItemSize(HandleRef image, int propid, out int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPropertyItem(HandleRef image, int propid, int size, IntPtr buffer);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPropertySize(HandleRef image, out int totalSize, ref int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetAllPropertyItems(HandleRef image, int totalSize, int count, IntPtr buffer);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRemovePropertyItem(HandleRef image, int propid);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPropertyItem(HandleRef image, PropertyItemInternal propitem);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipImageForceValidation(HandleRef image);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageDecodersSize(out int numDecoders, out int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageDecoders(int numDecoders, int size, IntPtr decoders);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageEncodersSize(out int numEncoders, out int size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageEncoders(int numEncoders, int size, IntPtr encoders);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromStream(UnsafeNativeMethods.IStream stream, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromFile(string filename, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromStreamICM(UnsafeNativeMethods.IStream stream, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromFileICM(string filename, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromScan0(int width, int height, int stride, int format, HandleRef scan0, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromGraphics(int width, int height, HandleRef graphics, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromHBITMAP(HandleRef hbitmap, HandleRef hpalette, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromHICON(HandleRef hicon, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateBitmapFromResource(HandleRef hresource, HandleRef name, out IntPtr bitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateHBITMAPFromBitmap(HandleRef nativeBitmap, out IntPtr hbitmap, int argbBackground);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateHICONFromBitmap(HandleRef nativeBitmap, out IntPtr hicon);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneBitmapArea(float x, float y, float width, float height, int format, HandleRef srcbitmap, out IntPtr dstbitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneBitmapAreaI(int x, int y, int width, int height, int format, HandleRef srcbitmap, out IntPtr dstbitmap);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBitmapLockBits(HandleRef bitmap, ref GPRECT rect, ImageLockMode flags, PixelFormat format, [In][Out] BitmapData lockedBitmapData);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBitmapUnlockBits(HandleRef bitmap, BitmapData lockedBitmapData);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBitmapGetPixel(HandleRef bitmap, int x, int y, out int argb);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBitmapSetPixel(HandleRef bitmap, int x, int y, int argb);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBitmapSetResolution(HandleRef bitmap, float dpix, float dpiy);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateImageAttributes(out IntPtr imageattr);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneImageAttributes(HandleRef imageattr, out IntPtr cloneImageattr);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDisposeImageAttributes", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDisposeImageAttributes(HandleRef imageattr);

			internal static int GdipDisposeImageAttributes(HandleRef imageattr)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDisposeImageAttributes(imageattr);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesColorMatrix(HandleRef imageattr, ColorAdjustType type, bool enableFlag, ColorMatrix colorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesThreshold(HandleRef imageattr, ColorAdjustType type, bool enableFlag, float threshold);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesGamma(HandleRef imageattr, ColorAdjustType type, bool enableFlag, float gamma);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesNoOp(HandleRef imageattr, ColorAdjustType type, bool enableFlag);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesColorKeys(HandleRef imageattr, ColorAdjustType type, bool enableFlag, int colorLow, int colorHigh);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesOutputChannel(HandleRef imageattr, ColorAdjustType type, bool enableFlag, ColorChannelFlag flags);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesOutputChannelColorProfile(HandleRef imageattr, ColorAdjustType type, bool enableFlag, string colorProfileFilename);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesRemapTable(HandleRef imageattr, ColorAdjustType type, bool enableFlag, int mapSize, HandleRef map);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetImageAttributesWrapMode(HandleRef imageattr, int wrapmode, int argb, bool clamp);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetImageAttributesAdjustedPalette(HandleRef imageattr, HandleRef palette, ColorAdjustType type);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFlush(HandleRef graphics, FlushIntention intention);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFromHDC(HandleRef hdc, out IntPtr graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFromHDC2(HandleRef hdc, HandleRef hdevice, out IntPtr graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFromHWND(HandleRef hwnd, out IntPtr graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteGraphics", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteGraphics(HandleRef graphics);

			internal static int GdipDeleteGraphics(HandleRef graphics)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeleteGraphics(graphics);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetDC(HandleRef graphics, out IntPtr hdc);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipReleaseDC", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipReleaseDC(HandleRef graphics, HandleRef hdc);

			internal static int GdipReleaseDC(HandleRef graphics, HandleRef hdc)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipReleaseDC(graphics, hdc);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCompositingMode(HandleRef graphics, int compositeMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetTextRenderingHint(HandleRef graphics, TextRenderingHint textRenderingHint);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetTextContrast(HandleRef graphics, int textContrast);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetInterpolationMode(HandleRef graphics, int mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCompositingMode(HandleRef graphics, out int compositeMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetRenderingOrigin(HandleRef graphics, int x, int y);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetRenderingOrigin(HandleRef graphics, out int x, out int y);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetCompositingQuality(HandleRef graphics, CompositingQuality quality);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCompositingQuality(HandleRef graphics, out CompositingQuality quality);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetSmoothingMode(HandleRef graphics, SmoothingMode smoothingMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetSmoothingMode(HandleRef graphics, out SmoothingMode smoothingMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPixelOffsetMode(HandleRef graphics, PixelOffsetMode pixelOffsetMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPixelOffsetMode(HandleRef graphics, out PixelOffsetMode pixelOffsetMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetTextRenderingHint(HandleRef graphics, out TextRenderingHint textRenderingHint);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetTextContrast(HandleRef graphics, out int textContrast);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetInterpolationMode(HandleRef graphics, out int mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetWorldTransform(HandleRef graphics, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetWorldTransform(HandleRef graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMultiplyWorldTransform(HandleRef graphics, HandleRef matrix, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateWorldTransform(HandleRef graphics, float dx, float dy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipScaleWorldTransform(HandleRef graphics, float sx, float sy, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRotateWorldTransform(HandleRef graphics, float angle, MatrixOrder order);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetWorldTransform(HandleRef graphics, HandleRef matrix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPageUnit(HandleRef graphics, out int unit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetPageScale(HandleRef graphics, float[] scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPageUnit(HandleRef graphics, int unit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetPageScale(HandleRef graphics, float scale);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetDpiX(HandleRef graphics, float[] dpi);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetDpiY(HandleRef graphics, float[] dpi);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformPoints(HandleRef graphics, int destSpace, int srcSpace, IntPtr points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTransformPointsI(HandleRef graphics, int destSpace, int srcSpace, IntPtr points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetNearestColor(HandleRef graphics, ref int color);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern IntPtr GdipCreateHalftonePalette();

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawLine(HandleRef graphics, HandleRef pen, float x1, float y1, float x2, float y2);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawLineI(HandleRef graphics, HandleRef pen, int x1, int y1, int x2, int y2);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawLines(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawLinesI(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawArc(HandleRef graphics, HandleRef pen, float x, float y, float width, float height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawArcI(HandleRef graphics, HandleRef pen, int x, int y, int width, int height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawBezier(HandleRef graphics, HandleRef pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawBeziers(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawBeziersI(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawRectangle(HandleRef graphics, HandleRef pen, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawRectangleI(HandleRef graphics, HandleRef pen, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawRectangles(HandleRef graphics, HandleRef pen, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawRectanglesI(HandleRef graphics, HandleRef pen, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawEllipse(HandleRef graphics, HandleRef pen, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawEllipseI(HandleRef graphics, HandleRef pen, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawPie(HandleRef graphics, HandleRef pen, float x, float y, float width, float height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawPieI(HandleRef graphics, HandleRef pen, int x, int y, int width, int height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawPolygon(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawPolygonI(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawPath(HandleRef graphics, HandleRef pen, HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurve(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurveI(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurve2(HandleRef graphics, HandleRef pen, HandleRef points, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurve2I(HandleRef graphics, HandleRef pen, HandleRef points, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurve3(HandleRef graphics, HandleRef pen, HandleRef points, int count, int offset, int numberOfSegments, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawCurve3I(HandleRef graphics, HandleRef pen, HandleRef points, int count, int offset, int numberOfSegments, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawClosedCurve(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawClosedCurveI(HandleRef graphics, HandleRef pen, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawClosedCurve2(HandleRef graphics, HandleRef pen, HandleRef points, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawClosedCurve2I(HandleRef graphics, HandleRef pen, HandleRef points, int count, float tension);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGraphicsClear(HandleRef graphics, int argb);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillRectangle(HandleRef graphics, HandleRef brush, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillRectangleI(HandleRef graphics, HandleRef brush, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillRectangles(HandleRef graphics, HandleRef brush, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillRectanglesI(HandleRef graphics, HandleRef brush, HandleRef rects, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillPolygon(HandleRef graphics, HandleRef brush, HandleRef points, int count, int brushMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillPolygonI(HandleRef graphics, HandleRef brush, HandleRef points, int count, int brushMode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillEllipse(HandleRef graphics, HandleRef brush, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillEllipseI(HandleRef graphics, HandleRef brush, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillPie(HandleRef graphics, HandleRef brush, float x, float y, float width, float height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillPieI(HandleRef graphics, HandleRef brush, int x, int y, int width, int height, float startAngle, float sweepAngle);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillPath(HandleRef graphics, HandleRef brush, HandleRef path);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillClosedCurve(HandleRef graphics, HandleRef brush, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillClosedCurveI(HandleRef graphics, HandleRef brush, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillClosedCurve2(HandleRef graphics, HandleRef brush, HandleRef points, int count, float tension, int mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillClosedCurve2I(HandleRef graphics, HandleRef brush, HandleRef points, int count, float tension, int mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipFillRegion(HandleRef graphics, HandleRef brush, HandleRef region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImage(HandleRef graphics, HandleRef image, float x, float y);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImageI(HandleRef graphics, HandleRef image, int x, int y);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImageRect(HandleRef graphics, HandleRef image, float x, float y, float width, float height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImageRectI(HandleRef graphics, HandleRef image, int x, int y, int width, int height);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePoints(HandleRef graphics, HandleRef image, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePointsI(HandleRef graphics, HandleRef image, HandleRef points, int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePointRect(HandleRef graphics, HandleRef image, float x, float y, float srcx, float srcy, float srcwidth, float srcheight, int srcunit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePointRectI(HandleRef graphics, HandleRef image, int x, int y, int srcx, int srcy, int srcwidth, int srcheight, int srcunit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImageRectRect(HandleRef graphics, HandleRef image, float dstx, float dsty, float dstwidth, float dstheight, float srcx, float srcy, float srcwidth, float srcheight, int srcunit, HandleRef imageAttributes, Graphics.DrawImageAbort callback, HandleRef callbackdata);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImageRectRectI(HandleRef graphics, HandleRef image, int dstx, int dsty, int dstwidth, int dstheight, int srcx, int srcy, int srcwidth, int srcheight, int srcunit, HandleRef imageAttributes, Graphics.DrawImageAbort callback, HandleRef callbackdata);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePointsRect(HandleRef graphics, HandleRef image, HandleRef points, int count, float srcx, float srcy, float srcwidth, float srcheight, int srcunit, HandleRef imageAttributes, Graphics.DrawImageAbort callback, HandleRef callbackdata);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawImagePointsRectI(HandleRef graphics, HandleRef image, HandleRef points, int count, int srcx, int srcy, int srcwidth, int srcheight, int srcunit, HandleRef imageAttributes, Graphics.DrawImageAbort callback, HandleRef callbackdata);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestPoint(HandleRef graphics, HandleRef metafile, GPPOINTF destPoint, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestPointI(HandleRef graphics, HandleRef metafile, GPPOINT destPoint, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestRect(HandleRef graphics, HandleRef metafile, ref GPRECTF destRect, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestRectI(HandleRef graphics, HandleRef metafile, ref GPRECT destRect, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestPoints(HandleRef graphics, HandleRef metafile, IntPtr destPoints, int count, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileDestPointsI(HandleRef graphics, HandleRef metafile, IntPtr destPoints, int count, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestPoint(HandleRef graphics, HandleRef metafile, GPPOINTF destPoint, ref GPRECTF srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestPointI(HandleRef graphics, HandleRef metafile, GPPOINT destPoint, ref GPRECT srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestRect(HandleRef graphics, HandleRef metafile, ref GPRECTF destRect, ref GPRECTF srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestRectI(HandleRef graphics, HandleRef metafile, ref GPRECT destRect, ref GPRECT srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestPoints(HandleRef graphics, HandleRef metafile, IntPtr destPoints, int count, ref GPRECTF srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEnumerateMetafileSrcRectDestPointsI(HandleRef graphics, HandleRef metafile, IntPtr destPoints, int count, ref GPRECT srcRect, int pageUnit, Graphics.EnumerateMetafileProc callback, HandleRef callbackdata, HandleRef imageattributes);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPlayMetafileRecord(HandleRef graphics, EmfPlusRecordType recordType, int flags, int dataSize, byte[] data);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetClipGraphics(HandleRef graphics, HandleRef srcgraphics, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetClipRect(HandleRef graphics, float x, float y, float width, float height, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetClipRectI(HandleRef graphics, int x, int y, int width, int height, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetClipPath(HandleRef graphics, HandleRef path, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetClipRegion(HandleRef graphics, HandleRef region, CombineMode mode);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipResetClip(HandleRef graphics);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipTranslateClip(HandleRef graphics, float dx, float dy);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetClip(HandleRef graphics, HandleRef region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetClipBounds(HandleRef graphics, ref GPRECTF rect);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsClipEmpty(HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetVisibleClipBounds(HandleRef graphics, ref GPRECTF rect);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleClipEmpty(HandleRef graphics, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisiblePoint(HandleRef graphics, float x, float y, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisiblePointI(HandleRef graphics, int x, int y, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRect(HandleRef graphics, float x, float y, float width, float height, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsVisibleRectI(HandleRef graphics, int x, int y, int width, int height, out int boolean);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSaveGraphics(HandleRef graphics, out int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRestoreGraphics(HandleRef graphics, int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBeginContainer(HandleRef graphics, ref GPRECTF dstRect, ref GPRECTF srcRect, int unit, out int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBeginContainer2(HandleRef graphics, out int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipBeginContainerI(HandleRef graphics, ref GPRECT dstRect, ref GPRECT srcRect, int unit, out int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipEndContainer(HandleRef graphics, int state);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMetafileHeaderFromWmf(HandleRef hMetafile, WmfPlaceableFileHeader wmfplaceable, [In][Out] MetafileHeaderWmf metafileHeaderWmf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMetafileHeaderFromEmf(HandleRef hEnhMetafile, [In][Out] MetafileHeaderEmf metafileHeaderEmf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMetafileHeaderFromFile(string filename, IntPtr header);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMetafileHeaderFromStream(UnsafeNativeMethods.IStream stream, IntPtr header);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetMetafileHeaderFromMetafile(HandleRef metafile, IntPtr header);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetHemfFromMetafile(HandleRef metafile, out IntPtr hEnhMetafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMetafileFromWmf(HandleRef hMetafile, [MarshalAs(UnmanagedType.Bool)] bool deleteWmf, WmfPlaceableFileHeader wmfplacealbeHeader, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMetafileFromEmf(HandleRef hEnhMetafile, bool deleteEmf, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMetafileFromFile(string file, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateMetafileFromStream(UnsafeNativeMethods.IStream stream, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafile(HandleRef referenceHdc, int emfType, ref GPRECTF frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafile(HandleRef referenceHdc, int emfType, HandleRef pframeRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileI(HandleRef referenceHdc, int emfType, ref GPRECT frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileFileName(string fileName, HandleRef referenceHdc, int emfType, ref GPRECTF frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileFileName(string fileName, HandleRef referenceHdc, int emfType, HandleRef pframeRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileFileNameI(string fileName, HandleRef referenceHdc, int emfType, ref GPRECT frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileStream(UnsafeNativeMethods.IStream stream, HandleRef referenceHdc, int emfType, ref GPRECTF frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileStream(UnsafeNativeMethods.IStream stream, HandleRef referenceHdc, int emfType, HandleRef pframeRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipRecordMetafileStreamI(UnsafeNativeMethods.IStream stream, HandleRef referenceHdc, int emfType, ref GPRECT frameRect, int frameUnit, string description, out IntPtr metafile);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipComment(HandleRef graphics, int sizeData, byte[] data);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipNewInstalledFontCollection(out IntPtr fontCollection);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipNewPrivateFontCollection(out IntPtr fontCollection);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeletePrivateFontCollection", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeletePrivateFontCollection(out IntPtr fontCollection);

			internal static int GdipDeletePrivateFontCollection(out IntPtr fontCollection)
			{
				if (!Initialized)
				{
					fontCollection = IntPtr.Zero;
					return 0;
				}
				return IntGdipDeletePrivateFontCollection(out fontCollection);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontCollectionFamilyCount(HandleRef fontCollection, out int numFound);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontCollectionFamilyList(HandleRef fontCollection, int numSought, IntPtr[] gpfamilies, out int numFound);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPrivateAddFontFile(HandleRef fontCollection, string filename);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipPrivateAddMemoryFont(HandleRef fontCollection, HandleRef memory, int length);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFontFamilyFromName(string name, HandleRef fontCollection, out IntPtr FontFamily);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetGenericFontFamilySansSerif(out IntPtr fontfamily);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetGenericFontFamilySerif(out IntPtr fontfamily);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetGenericFontFamilyMonospace(out IntPtr fontfamily);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteFontFamily", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteFontFamily(HandleRef fontFamily);

			internal static int GdipDeleteFontFamily(HandleRef fontFamily)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeleteFontFamily(fontFamily);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneFontFamily(HandleRef fontfamily, out IntPtr clonefontfamily);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFamilyName(HandleRef family, StringBuilder name, int language);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipIsStyleAvailable(HandleRef family, FontStyle style, out int isStyleAvailable);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetEmHeight(HandleRef family, FontStyle style, out int EmHeight);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCellAscent(HandleRef family, FontStyle style, out int CellAscent);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetCellDescent(HandleRef family, FontStyle style, out int CellDescent);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLineSpacing(HandleRef family, FontStyle style, out int LineSpaceing);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFontFromDC(HandleRef hdc, ref IntPtr font);

			[DllImport("gdiplus.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFontFromLogfontA(HandleRef hdc, [In][Out][MarshalAs(UnmanagedType.AsAny)] object lf, out IntPtr font);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFontFromLogfontW(HandleRef hdc, [In][Out][MarshalAs(UnmanagedType.AsAny)] object lf, out IntPtr font);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateFont(HandleRef fontFamily, float emSize, FontStyle style, GraphicsUnit unit, out IntPtr font);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLogFontW(HandleRef font, HandleRef graphics, [In][Out][MarshalAs(UnmanagedType.AsAny)] object lf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetLogFontA(HandleRef font, HandleRef graphics, [In][Out][MarshalAs(UnmanagedType.AsAny)] object lf);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneFont(HandleRef font, out IntPtr cloneFont);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteFont", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteFont(HandleRef font);

			internal static int GdipDeleteFont(HandleRef font)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeleteFont(font);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFamily(HandleRef font, out IntPtr family);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontStyle(HandleRef font, out FontStyle style);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontSize(HandleRef font, out float size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontHeight(HandleRef font, HandleRef graphics, out float size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontHeightGivenDPI(HandleRef font, float dpi, out float size);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetFontUnit(HandleRef font, out GraphicsUnit unit);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipDrawString(HandleRef graphics, string textString, int length, HandleRef font, ref GPRECTF layoutRect, HandleRef stringFormat, HandleRef brush);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMeasureString(HandleRef graphics, string textString, int length, HandleRef font, ref GPRECTF layoutRect, HandleRef stringFormat, [In][Out] ref GPRECTF boundingBox, out int codepointsFitted, out int linesFilled);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipMeasureCharacterRanges(HandleRef graphics, string textString, int length, HandleRef font, ref GPRECTF layoutRect, HandleRef stringFormat, int characterCount, [In][Out] IntPtr[] region);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatMeasurableCharacterRanges(HandleRef format, int rangeCount, [In][Out] CharacterRange[] range);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCreateStringFormat(StringFormatFlags options, int language, out IntPtr format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipStringFormatGetGenericDefault(out IntPtr format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipStringFormatGetGenericTypographic(out IntPtr format);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, EntryPoint = "GdipDeleteStringFormat", ExactSpelling = true, SetLastError = true)]
			private static extern int IntGdipDeleteStringFormat(HandleRef format);

			internal static int GdipDeleteStringFormat(HandleRef format)
			{
				if (!Initialized)
				{
					return 0;
				}
				return IntGdipDeleteStringFormat(format);
			}

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipCloneStringFormat(HandleRef format, out IntPtr newFormat);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatFlags(HandleRef format, StringFormatFlags options);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatFlags(HandleRef format, out StringFormatFlags result);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatAlign(HandleRef format, StringAlignment align);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatAlign(HandleRef format, out StringAlignment align);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatLineAlign(HandleRef format, StringAlignment align);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatLineAlign(HandleRef format, out StringAlignment align);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatHotkeyPrefix(HandleRef format, HotkeyPrefix hotkeyPrefix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatHotkeyPrefix(HandleRef format, out HotkeyPrefix hotkeyPrefix);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatTabStops(HandleRef format, float firstTabOffset, int count, float[] tabStops);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatTabStops(HandleRef format, int count, out float firstTabOffset, [In][Out] float[] tabStops);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatTabStopCount(HandleRef format, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatMeasurableCharacterRangeCount(HandleRef format, out int count);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatTrimming(HandleRef format, StringTrimming trimming);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatTrimming(HandleRef format, out StringTrimming trimming);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipSetStringFormatDigitSubstitution(HandleRef format, int langID, StringDigitSubstitute sds);

			[DllImport("gdiplus.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
			internal static extern int GdipGetStringFormatDigitSubstitution(HandleRef format, out int langID, out StringDigitSubstitute sds);

			internal static Exception StatusException(int status)
			{
				return status switch
				{
					1 => new ExternalException(SR.GetString("GdiplusGenericError"), -2147467259), 
					2 => new ArgumentException(SR.GetString("GdiplusInvalidParameter")), 
					3 => new OutOfMemoryException(SR.GetString("GdiplusOutOfMemory")), 
					4 => new InvalidOperationException(SR.GetString("GdiplusObjectBusy")), 
					5 => new OutOfMemoryException(SR.GetString("GdiplusInsufficientBuffer")), 
					6 => new NotImplementedException(SR.GetString("GdiplusNotImplemented")), 
					7 => new ExternalException(SR.GetString("GdiplusGenericError"), -2147467259), 
					8 => new InvalidOperationException(SR.GetString("GdiplusWrongState")), 
					9 => new ExternalException(SR.GetString("GdiplusAborted"), -2147467260), 
					10 => new FileNotFoundException(SR.GetString("GdiplusFileNotFound")), 
					11 => new OverflowException(SR.GetString("GdiplusOverflow")), 
					12 => new ExternalException(SR.GetString("GdiplusAccessDenied"), -2147024891), 
					13 => new ArgumentException(SR.GetString("GdiplusUnknownImageFormat")), 
					19 => new ArgumentException(SR.GetString("GdiplusPropertyNotFoundError")), 
					20 => new ArgumentException(SR.GetString("GdiplusPropertyNotSupportedError")), 
					14 => new ArgumentException(SR.GetString("GdiplusFontFamilyNotFound", "?")), 
					15 => new ArgumentException(SR.GetString("GdiplusFontStyleNotFound", "?", "?")), 
					16 => new ArgumentException(SR.GetString("GdiplusNotTrueTypeFont_NoName")), 
					17 => new ExternalException(SR.GetString("GdiplusUnsupportedGdiplusVersion"), -2147467259), 
					18 => new ExternalException(SR.GetString("GdiplusNotInitialized"), -2147467259), 
					_ => new ExternalException(SR.GetString("GdiplusUnknown"), -2147418113), 
				};
			}

			internal static PointF[] ConvertGPPOINTFArrayF(IntPtr memory, int count)
			{
				if (memory == IntPtr.Zero)
				{
					throw new ArgumentNullException("memory");
				}
				PointF[] array = new PointF[count];
				GPPOINTF gPPOINTF = new GPPOINTF();
				int num = Marshal.SizeOf(gPPOINTF.GetType());
				for (int i = 0; i < count; i++)
				{
					gPPOINTF = (GPPOINTF)UnsafeNativeMethods.PtrToStructure((IntPtr)((long)memory + i * num), gPPOINTF.GetType());
					array[i] = new PointF(gPPOINTF.X, gPPOINTF.Y);
				}
				return array;
			}

			internal static Point[] ConvertGPPOINTArray(IntPtr memory, int count)
			{
				if (memory == IntPtr.Zero)
				{
					throw new ArgumentNullException("memory");
				}
				Point[] array = new Point[count];
				GPPOINT gPPOINT = new GPPOINT();
				int num = Marshal.SizeOf(gPPOINT.GetType());
				for (int i = 0; i < count; i++)
				{
					gPPOINT = (GPPOINT)UnsafeNativeMethods.PtrToStructure((IntPtr)((long)memory + i * num), gPPOINT.GetType());
					array[i] = new Point(gPPOINT.X, gPPOINT.Y);
				}
				return array;
			}

			internal static IntPtr ConvertPointToMemory(PointF[] points)
			{
				if (points == null)
				{
					throw new ArgumentNullException("points");
				}
				int num = Marshal.SizeOf(typeof(GPPOINTF));
				int num2 = points.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr((object)new GPPOINTF(points[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}

			internal static IntPtr ConvertPointToMemory(Point[] points)
			{
				if (points == null)
				{
					throw new ArgumentNullException("points");
				}
				int num = Marshal.SizeOf(typeof(GPPOINT));
				int num2 = points.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr((object)new GPPOINT(points[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}

			internal static IntPtr ConvertRectangleToMemory(RectangleF[] rect)
			{
				if (rect == null)
				{
					throw new ArgumentNullException("rect");
				}
				int num = Marshal.SizeOf(typeof(GPRECTF));
				int num2 = rect.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr((object)new GPRECTF(rect[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}

			internal static IntPtr ConvertRectangleToMemory(Rectangle[] rect)
			{
				if (rect == null)
				{
					throw new ArgumentNullException("rect");
				}
				int num = Marshal.SizeOf(typeof(GPRECT));
				int num2 = rect.Length;
				IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
				for (int i = 0; i < num2; i++)
				{
					Marshal.StructureToPtr((object)new GPRECT(rect[i]), (IntPtr)checked((long)intPtr + i * num), fDeleteOld: false);
				}
				return intPtr;
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public class ENHMETAHEADER
		{
			public int iType;

			public int nSize = 40;

			public int rclBounds_left;

			public int rclBounds_top;

			public int rclBounds_right;

			public int rclBounds_bottom;

			public int rclFrame_left;

			public int rclFrame_top;

			public int rclFrame_right;

			public int rclFrame_bottom;

			public int dSignature;

			public int nVersion;

			public int nBytes;

			public int nRecords;

			public short nHandles;

			public short sReserved;

			public int nDescription;

			public int offDescription;

			public int nPalEntries;

			public int szlDevice_cx;

			public int szlDevice_cy;

			public int szlMillimeters_cx;

			public int szlMillimeters_cy;

			public int cbPixelFormat;

			public int offPixelFormat;

			public int bOpenGL;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class DOCINFO
		{
			public int cbSize = 20;

			public string lpszDocName;

			public string lpszOutput;

			public string lpszDatatype;

			public int fwType;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class PRINTDLG
		{
			public int lStructSize;

			public IntPtr hwndOwner;

			public IntPtr hDevMode;

			public IntPtr hDevNames;

			public IntPtr hDC;

			public int Flags;

			public short nFromPage;

			public short nToPage;

			public short nMinPage;

			public short nMaxPage;

			public short nCopies;

			public IntPtr hInstance;

			public IntPtr lCustData;

			public IntPtr lpfnPrintHook;

			public IntPtr lpfnSetupHook;

			public string lpPrintTemplateName;

			public string lpSetupTemplateName;

			public IntPtr hPrintTemplate;

			public IntPtr hSetupTemplate;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto, Pack = 1)]
		public class PRINTDLGX86
		{
			public int lStructSize;

			public IntPtr hwndOwner;

			public IntPtr hDevMode;

			public IntPtr hDevNames;

			public IntPtr hDC;

			public int Flags;

			public short nFromPage;

			public short nToPage;

			public short nMinPage;

			public short nMaxPage;

			public short nCopies;

			public IntPtr hInstance;

			public IntPtr lCustData;

			public IntPtr lpfnPrintHook;

			public IntPtr lpfnSetupHook;

			public string lpPrintTemplateName;

			public string lpSetupTemplateName;

			public IntPtr hPrintTemplate;

			public IntPtr hSetupTemplate;
		}

		public enum StructFormat
		{
			Ansi = 1,
			Unicode,
			Auto
		}

		public struct RECT
		{
			public int left;

			public int top;

			public int right;

			public int bottom;
		}

		public struct MSG
		{
			public IntPtr hwnd;

			public int message;

			public IntPtr wParam;

			public IntPtr lParam;

			public int time;

			public int pt_x;

			public int pt_y;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class ICONINFO
		{
			public int fIcon;

			public int xHotspot;

			public int yHotspot;

			public IntPtr hbmMask = IntPtr.Zero;

			public IntPtr hbmColor = IntPtr.Zero;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class BITMAP
		{
			public int bmType;

			public int bmWidth;

			public int bmHeight;

			public int bmWidthBytes;

			public short bmPlanes;

			public short bmBitsPixel;

			public IntPtr bmBits = IntPtr.Zero;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class BITMAPINFOHEADER
		{
			public int biSize = 40;

			public int biWidth;

			public int biHeight;

			public short biPlanes;

			public short biBitCount;

			public int biCompression;

			public int biSizeImage;

			public int biXPelsPerMeter;

			public int biYPelsPerMeter;

			public int biClrUsed;

			public int biClrImportant;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class LOGFONT
		{
			public int lfHeight;

			public int lfWidth;

			public int lfEscapement;

			public int lfOrientation;

			public int lfWeight;

			public byte lfItalic;

			public byte lfUnderline;

			public byte lfStrikeOut;

			public byte lfCharSet;

			public byte lfOutPrecision;

			public byte lfClipPrecision;

			public byte lfQuality;

			public byte lfPitchAndFamily;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string lfFaceName;

			public LOGFONT()
			{
			}

			public LOGFONT(LOGFONT lf)
			{
				lfHeight = lf.lfHeight;
				lfWidth = lf.lfWidth;
				lfEscapement = lf.lfEscapement;
				lfOrientation = lf.lfOrientation;
				lfWeight = lf.lfWeight;
				lfItalic = lf.lfItalic;
				lfUnderline = lf.lfUnderline;
				lfStrikeOut = lf.lfStrikeOut;
				lfCharSet = lf.lfCharSet;
				lfOutPrecision = lf.lfOutPrecision;
				lfClipPrecision = lf.lfClipPrecision;
				lfQuality = lf.lfQuality;
				lfPitchAndFamily = lf.lfPitchAndFamily;
				lfFaceName = lf.lfFaceName;
			}

			public override string ToString()
			{
				return "lfHeight=" + lfHeight + ", lfWidth=" + lfWidth + ", lfEscapement=" + lfEscapement + ", lfOrientation=" + lfOrientation + ", lfWeight=" + lfWeight + ", lfItalic=" + lfItalic + ", lfUnderline=" + lfUnderline + ", lfStrikeOut=" + lfStrikeOut + ", lfCharSet=" + lfCharSet + ", lfOutPrecision=" + lfOutPrecision + ", lfClipPrecision=" + lfClipPrecision + ", lfQuality=" + lfQuality + ", lfPitchAndFamily=" + lfPitchAndFamily + ", lfFaceName=" + lfFaceName;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		public struct TEXTMETRIC
		{
			public int tmHeight;

			public int tmAscent;

			public int tmDescent;

			public int tmInternalLeading;

			public int tmExternalLeading;

			public int tmAveCharWidth;

			public int tmMaxCharWidth;

			public int tmWeight;

			public int tmOverhang;

			public int tmDigitizedAspectX;

			public int tmDigitizedAspectY;

			public char tmFirstChar;

			public char tmLastChar;

			public char tmDefaultChar;

			public char tmBreakChar;

			public byte tmItalic;

			public byte tmUnderlined;

			public byte tmStruckOut;

			public byte tmPitchAndFamily;

			public byte tmCharSet;
		}

		public struct TEXTMETRICA
		{
			public int tmHeight;

			public int tmAscent;

			public int tmDescent;

			public int tmInternalLeading;

			public int tmExternalLeading;

			public int tmAveCharWidth;

			public int tmMaxCharWidth;

			public int tmWeight;

			public int tmOverhang;

			public int tmDigitizedAspectX;

			public int tmDigitizedAspectY;

			public byte tmFirstChar;

			public byte tmLastChar;

			public byte tmDefaultChar;

			public byte tmBreakChar;

			public byte tmItalic;

			public byte tmUnderlined;

			public byte tmStruckOut;

			public byte tmPitchAndFamily;

			public byte tmCharSet;
		}

		[StructLayout(LayoutKind.Sequential, Pack = 2)]
		public struct ICONDIR
		{
			public short idReserved;

			public short idType;

			public short idCount;

			public ICONDIRENTRY idEntries;
		}

		public struct ICONDIRENTRY
		{
			public byte bWidth;

			public byte bHeight;

			public byte bColorCount;

			public byte bReserved;

			public short wPlanes;

			public short wBitCount;

			public int dwBytesInRes;

			public int dwImageOffset;
		}

		public class Ole
		{
			public const int PICTYPE_UNINITIALIZED = -1;

			public const int PICTYPE_NONE = 0;

			public const int PICTYPE_BITMAP = 1;

			public const int PICTYPE_METAFILE = 2;

			public const int PICTYPE_ICON = 3;

			public const int PICTYPE_ENHMETAFILE = 4;

			public const int STATFLAG_DEFAULT = 0;

			public const int STATFLAG_NONAME = 1;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class PICTDESC
		{
			internal int cbSizeOfStruct;

			public int picType;

			internal IntPtr union1;

			internal int union2;

			internal int union3;

			public static PICTDESC CreateIconPICTDESC(IntPtr hicon)
			{
				PICTDESC pICTDESC = new PICTDESC();
				pICTDESC.cbSizeOfStruct = 12;
				pICTDESC.picType = 3;
				pICTDESC.union1 = hicon;
				return pICTDESC;
			}

			public virtual IntPtr GetHandle()
			{
				return union1;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class DEVMODE
		{
			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string dmDeviceName;

			public short dmSpecVersion;

			public short dmDriverVersion;

			public short dmSize;

			public short dmDriverExtra;

			public int dmFields;

			public short dmOrientation;

			public short dmPaperSize;

			public short dmPaperLength;

			public short dmPaperWidth;

			public short dmScale;

			public short dmCopies;

			public short dmDefaultSource;

			public short dmPrintQuality;

			public short dmColor;

			public short dmDuplex;

			public short dmYResolution;

			public short dmTTOption;

			public short dmCollate;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string dmFormName;

			public short dmLogPixels;

			public int dmBitsPerPel;

			public int dmPelsWidth;

			public int dmPelsHeight;

			public int dmDisplayFlags;

			public int dmDisplayFrequency;

			public int dmICMMethod;

			public int dmICMIntent;

			public int dmMediaType;

			public int dmDitherType;

			public int dmICCManufacturer;

			public int dmICCModel;

			public int dmPanningWidth;

			public int dmPanningHeight;

			public override string ToString()
			{
				return "[DEVMODE: dmDeviceName=" + dmDeviceName + ", dmSpecVersion=" + dmSpecVersion + ", dmDriverVersion=" + dmDriverVersion + ", dmSize=" + dmSize + ", dmDriverExtra=" + dmDriverExtra + ", dmFields=" + dmFields + ", dmOrientation=" + dmOrientation + ", dmPaperSize=" + dmPaperSize + ", dmPaperLength=" + dmPaperLength + ", dmPaperWidth=" + dmPaperWidth + ", dmScale=" + dmScale + ", dmCopies=" + dmCopies + ", dmDefaultSource=" + dmDefaultSource + ", dmPrintQuality=" + dmPrintQuality + ", dmColor=" + dmColor + ", dmDuplex=" + dmDuplex + ", dmYResolution=" + dmYResolution + ", dmTTOption=" + dmTTOption + ", dmCollate=" + dmCollate + ", dmFormName=" + dmFormName + ", dmLogPixels=" + dmLogPixels + ", dmBitsPerPel=" + dmBitsPerPel + ", dmPelsWidth=" + dmPelsWidth + ", dmPelsHeight=" + dmPelsHeight + ", dmDisplayFlags=" + dmDisplayFlags + ", dmDisplayFrequency=" + dmDisplayFrequency + ", dmICMMethod=" + dmICMMethod + ", dmICMIntent=" + dmICMIntent + ", dmMediaType=" + dmMediaType + ", dmDitherType=" + dmDitherType + ", dmICCManufacturer=" + dmICCManufacturer + ", dmICCModel=" + dmICCModel + ", dmPanningWidth=" + dmPanningWidth + ", dmPanningHeight=" + dmPanningHeight + "]";
			}
		}

		public sealed class CommonHandles
		{
			public static readonly int Accelerator;

			public static readonly int Cursor;

			public static readonly int EMF;

			public static readonly int Find;

			public static readonly int GDI;

			public static readonly int HDC;

			public static readonly int Icon;

			public static readonly int Kernel;

			public static readonly int Menu;

			public static readonly int Window;

			static CommonHandles()
			{
				Accelerator = System.Internal.HandleCollector.RegisterType("Accelerator", 80, 50);
				Cursor = System.Internal.HandleCollector.RegisterType("Cursor", 20, 500);
				EMF = System.Internal.HandleCollector.RegisterType("EnhancedMetaFile", 20, 500);
				Find = System.Internal.HandleCollector.RegisterType("Find", 0, 1000);
				GDI = System.Internal.HandleCollector.RegisterType("GDI", 50, 500);
				HDC = System.Internal.HandleCollector.RegisterType("HDC", 100, 2);
				Icon = System.Internal.HandleCollector.RegisterType("Icon", 20, 500);
				Kernel = System.Internal.HandleCollector.RegisterType("Kernel", 0, 1000);
				Menu = System.Internal.HandleCollector.RegisterType("Menu", 30, 1000);
				Window = System.Internal.HandleCollector.RegisterType("Window", 5, 1000);
			}
		}

		public class StreamConsts
		{
			public const int LOCK_WRITE = 1;

			public const int LOCK_EXCLUSIVE = 2;

			public const int LOCK_ONLYONCE = 4;

			public const int STATFLAG_DEFAULT = 0;

			public const int STATFLAG_NONAME = 1;

			public const int STATFLAG_NOOPEN = 2;

			public const int STGC_DEFAULT = 0;

			public const int STGC_OVERWRITE = 1;

			public const int STGC_ONLYIFCURRENT = 2;

			public const int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4;

			public const int STREAM_SEEK_SET = 0;

			public const int STREAM_SEEK_CUR = 1;

			public const int STREAM_SEEK_END = 2;
		}

		[ComImport]
		[Guid("7BF80980-BF32-101A-8BBB-00AA00300CAB")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		public interface IPicture
		{
			[SuppressUnmanagedCodeSecurity]
			IntPtr GetHandle();

			[SuppressUnmanagedCodeSecurity]
			IntPtr GetHPal();

			[SuppressUnmanagedCodeSecurity]
			[return: MarshalAs(UnmanagedType.I2)]
			short GetPictureType();

			[SuppressUnmanagedCodeSecurity]
			int GetWidth();

			[SuppressUnmanagedCodeSecurity]
			int GetHeight();

			[SuppressUnmanagedCodeSecurity]
			void Render();

			[SuppressUnmanagedCodeSecurity]
			void SetHPal([In] IntPtr phpal);

			[SuppressUnmanagedCodeSecurity]
			IntPtr GetCurDC();

			[SuppressUnmanagedCodeSecurity]
			void SelectPicture([In] IntPtr hdcIn, [Out][MarshalAs(UnmanagedType.LPArray)] int[] phdcOut, [Out][MarshalAs(UnmanagedType.LPArray)] int[] phbmpOut);

			[SuppressUnmanagedCodeSecurity]
			[return: MarshalAs(UnmanagedType.Bool)]
			bool GetKeepOriginalFormat();

			[SuppressUnmanagedCodeSecurity]
			void SetKeepOriginalFormat([In][MarshalAs(UnmanagedType.Bool)] bool pfkeep);

			[SuppressUnmanagedCodeSecurity]
			void PictureChanged();

			[PreserveSig]
			[SuppressUnmanagedCodeSecurity]
			int SaveAsFile([In][MarshalAs(UnmanagedType.Interface)] UnsafeNativeMethods.IStream pstm, [In] int fSaveMemCopy, out int pcbSize);

			[SuppressUnmanagedCodeSecurity]
			int GetAttributes();

			[SuppressUnmanagedCodeSecurity]
			void SetHdc([In] IntPtr hdc);
		}

		public struct OBJECTHEADER
		{
			public short signature;

			public short headersize;

			public short objectType;

			public short nameLen;

			public short classLen;

			public short nameOffset;

			public short classOffset;

			public short width;

			public short height;

			public IntPtr pInfo;
		}

		internal enum Win32SystemColors
		{
			ActiveBorder = 10,
			ActiveCaption = 2,
			ActiveCaptionText = 9,
			AppWorkspace = 12,
			ButtonFace = 15,
			ButtonHighlight = 20,
			ButtonShadow = 16,
			Control = 15,
			ControlDark = 16,
			ControlDarkDark = 21,
			ControlLight = 22,
			ControlLightLight = 20,
			ControlText = 18,
			Desktop = 1,
			GradientActiveCaption = 27,
			GradientInactiveCaption = 28,
			GrayText = 17,
			Highlight = 13,
			HighlightText = 14,
			HotTrack = 26,
			InactiveBorder = 11,
			InactiveCaption = 3,
			InactiveCaptionText = 19,
			Info = 24,
			InfoText = 23,
			Menu = 4,
			MenuBar = 30,
			MenuHighlight = 29,
			MenuText = 7,
			ScrollBar = 0,
			Window = 5,
			WindowFrame = 6,
			WindowText = 8
		}

		public enum BackgroundMode
		{
			TRANSPARENT = 1,
			OPAQUE
		}

		public static IntPtr InvalidIntPtr = (IntPtr)(-1);

		public const int ERROR_CANCELLED = 1223;

		public const int RASTERCAPS = 38;

		public const int RC_PALETTE = 256;

		public const int SIZEPALETTE = 104;

		public const int SYSPAL_STATIC = 1;

		public const int BS_SOLID = 0;

		public const int HOLLOW_BRUSH = 5;

		public const int R2_BLACK = 1;

		public const int R2_NOTMERGEPEN = 2;

		public const int R2_MASKNOTPEN = 3;

		public const int R2_NOTCOPYPEN = 4;

		public const int R2_MASKPENNOT = 5;

		public const int R2_NOT = 6;

		public const int R2_XORPEN = 7;

		public const int R2_NOTMASKPEN = 8;

		public const int R2_MASKPEN = 9;

		public const int R2_NOTXORPEN = 10;

		public const int R2_NOP = 11;

		public const int R2_MERGENOTPEN = 12;

		public const int R2_COPYPEN = 13;

		public const int R2_MERGEPENNOT = 14;

		public const int R2_MERGEPEN = 15;

		public const int R2_WHITE = 16;

		public const int UOI_FLAGS = 1;

		public const int WSF_VISIBLE = 1;

		public const int E_UNEXPECTED = -2147418113;

		public const int E_NOTIMPL = -2147467263;

		public const int E_OUTOFMEMORY = -2147024882;

		public const int E_INVALIDARG = -2147024809;

		public const int E_NOINTERFACE = -2147467262;

		public const int E_POINTER = -2147467261;

		public const int E_HANDLE = -2147024890;

		public const int E_ABORT = -2147467260;

		public const int E_FAIL = -2147467259;

		public const int E_ACCESSDENIED = -2147024891;

		public const int PM_NOREMOVE = 0;

		public const int PM_REMOVE = 1;

		public const int PM_NOYIELD = 2;

		public const int GMEM_FIXED = 0;

		public const int GMEM_MOVEABLE = 2;

		public const int GMEM_NOCOMPACT = 16;

		public const int GMEM_NODISCARD = 32;

		public const int GMEM_ZEROINIT = 64;

		public const int GMEM_MODIFY = 128;

		public const int GMEM_DISCARDABLE = 256;

		public const int GMEM_NOT_BANKED = 4096;

		public const int GMEM_SHARE = 8192;

		public const int GMEM_DDESHARE = 8192;

		public const int GMEM_NOTIFY = 16384;

		public const int GMEM_LOWER = 4096;

		public const int GMEM_VALID_FLAGS = 32626;

		public const int GMEM_INVALID_HANDLE = 32768;

		public const int DM_UPDATE = 1;

		public const int DM_COPY = 2;

		public const int DM_PROMPT = 4;

		public const int DM_MODIFY = 8;

		public const int DM_IN_BUFFER = 8;

		public const int DM_IN_PROMPT = 4;

		public const int DM_OUT_BUFFER = 2;

		public const int DM_OUT_DEFAULT = 1;

		public const int DT_PLOTTER = 0;

		public const int DT_RASDISPLAY = 1;

		public const int DT_RASPRINTER = 2;

		public const int DT_RASCAMERA = 3;

		public const int DT_CHARSTREAM = 4;

		public const int DT_METAFILE = 5;

		public const int DT_DISPFILE = 6;

		public const int TECHNOLOGY = 2;

		public const int DC_FIELDS = 1;

		public const int DC_PAPERS = 2;

		public const int DC_PAPERSIZE = 3;

		public const int DC_MINEXTENT = 4;

		public const int DC_MAXEXTENT = 5;

		public const int DC_BINS = 6;

		public const int DC_DUPLEX = 7;

		public const int DC_SIZE = 8;

		public const int DC_EXTRA = 9;

		public const int DC_VERSION = 10;

		public const int DC_DRIVER = 11;

		public const int DC_BINNAMES = 12;

		public const int DC_ENUMRESOLUTIONS = 13;

		public const int DC_FILEDEPENDENCIES = 14;

		public const int DC_TRUETYPE = 15;

		public const int DC_PAPERNAMES = 16;

		public const int DC_ORIENTATION = 17;

		public const int DC_COPIES = 18;

		public const int PD_ALLPAGES = 0;

		public const int PD_SELECTION = 1;

		public const int PD_PAGENUMS = 2;

		public const int PD_CURRENTPAGE = 4194304;

		public const int PD_NOSELECTION = 4;

		public const int PD_NOPAGENUMS = 8;

		public const int PD_NOCURRENTPAGE = 8388608;

		public const int PD_COLLATE = 16;

		public const int PD_PRINTTOFILE = 32;

		public const int PD_PRINTSETUP = 64;

		public const int PD_NOWARNING = 128;

		public const int PD_RETURNDC = 256;

		public const int PD_RETURNIC = 512;

		public const int PD_RETURNDEFAULT = 1024;

		public const int PD_SHOWHELP = 2048;

		public const int PD_ENABLEPRINTHOOK = 4096;

		public const int PD_ENABLESETUPHOOK = 8192;

		public const int PD_ENABLEPRINTTEMPLATE = 16384;

		public const int PD_ENABLESETUPTEMPLATE = 32768;

		public const int PD_ENABLEPRINTTEMPLATEHANDLE = 65536;

		public const int PD_ENABLESETUPTEMPLATEHANDLE = 131072;

		public const int PD_USEDEVMODECOPIES = 262144;

		public const int PD_USEDEVMODECOPIESANDCOLLATE = 262144;

		public const int PD_DISABLEPRINTTOFILE = 524288;

		public const int PD_HIDEPRINTTOFILE = 1048576;

		public const int PD_NONETWORKBUTTON = 2097152;

		public const int DI_MASK = 1;

		public const int DI_IMAGE = 2;

		public const int DI_NORMAL = 3;

		public const int DI_COMPAT = 4;

		public const int DI_DEFAULTSIZE = 8;

		public const int IDC_ARROW = 32512;

		public const int IDC_IBEAM = 32513;

		public const int IDC_WAIT = 32514;

		public const int IDC_CROSS = 32515;

		public const int IDC_UPARROW = 32516;

		public const int IDC_SIZE = 32640;

		public const int IDC_ICON = 32641;

		public const int IDC_SIZENWSE = 32642;

		public const int IDC_SIZENESW = 32643;

		public const int IDC_SIZEWE = 32644;

		public const int IDC_SIZENS = 32645;

		public const int IDC_SIZEALL = 32646;

		public const int IDC_NO = 32648;

		public const int IDC_APPSTARTING = 32650;

		public const int IDC_HELP = 32651;

		public const int IMAGE_BITMAP = 0;

		public const int IMAGE_ICON = 1;

		public const int IMAGE_CURSOR = 2;

		public const int IMAGE_ENHMETAFILE = 3;

		public const int IDI_APPLICATION = 32512;

		public const int IDI_HAND = 32513;

		public const int IDI_QUESTION = 32514;

		public const int IDI_EXCLAMATION = 32515;

		public const int IDI_ASTERISK = 32516;

		public const int IDI_WINLOGO = 32517;

		public const int IDI_WARNING = 32515;

		public const int IDI_ERROR = 32513;

		public const int IDI_INFORMATION = 32516;

		public const int IDI_SHIELD = 32518;

		public const int SRCCOPY = 13369376;

		public const int PLANES = 14;

		public const int PS_SOLID = 0;

		public const int PS_DASH = 1;

		public const int PS_DOT = 2;

		public const int PS_DASHDOT = 3;

		public const int PS_DASHDOTDOT = 4;

		public const int PS_NULL = 5;

		public const int PS_INSIDEFRAME = 6;

		public const int PS_USERSTYLE = 7;

		public const int PS_ALTERNATE = 8;

		public const int PS_STYLE_MASK = 15;

		public const int PS_ENDCAP_ROUND = 0;

		public const int PS_ENDCAP_SQUARE = 256;

		public const int PS_ENDCAP_FLAT = 512;

		public const int PS_ENDCAP_MASK = 3840;

		public const int PS_JOIN_ROUND = 0;

		public const int PS_JOIN_BEVEL = 4096;

		public const int PS_JOIN_MITER = 8192;

		public const int PS_JOIN_MASK = 61440;

		public const int PS_COSMETIC = 0;

		public const int PS_GEOMETRIC = 65536;

		public const int PS_TYPE_MASK = 983040;

		public const int BITSPIXEL = 12;

		public const int ALTERNATE = 1;

		public const int LOGPIXELSX = 88;

		public const int LOGPIXELSY = 90;

		public const int PHYSICALWIDTH = 110;

		public const int PHYSICALHEIGHT = 111;

		public const int PHYSICALOFFSETX = 112;

		public const int PHYSICALOFFSETY = 113;

		public const int WINDING = 2;

		public const int VERTRES = 10;

		public const int HORZRES = 8;

		public const int DM_SPECVERSION = 1025;

		public const int DM_ORIENTATION = 1;

		public const int DM_PAPERSIZE = 2;

		public const int DM_PAPERLENGTH = 4;

		public const int DM_PAPERWIDTH = 8;

		public const int DM_SCALE = 16;

		public const int DM_COPIES = 256;

		public const int DM_DEFAULTSOURCE = 512;

		public const int DM_PRINTQUALITY = 1024;

		public const int DM_COLOR = 2048;

		public const int DM_DUPLEX = 4096;

		public const int DM_YRESOLUTION = 8192;

		public const int DM_TTOPTION = 16384;

		public const int DM_COLLATE = 32768;

		public const int DM_FORMNAME = 65536;

		public const int DM_LOGPIXELS = 131072;

		public const int DM_BITSPERPEL = 262144;

		public const int DM_PELSWIDTH = 524288;

		public const int DM_PELSHEIGHT = 1048576;

		public const int DM_DISPLAYFLAGS = 2097152;

		public const int DM_DISPLAYFREQUENCY = 4194304;

		public const int DM_PANNINGWIDTH = 8388608;

		public const int DM_PANNINGHEIGHT = 16777216;

		public const int DM_ICMMETHOD = 33554432;

		public const int DM_ICMINTENT = 67108864;

		public const int DM_MEDIATYPE = 134217728;

		public const int DM_DITHERTYPE = 268435456;

		public const int DM_ICCMANUFACTURER = 536870912;

		public const int DM_ICCMODEL = 1073741824;

		public const int DMORIENT_PORTRAIT = 1;

		public const int DMORIENT_LANDSCAPE = 2;

		public const int DMPAPER_LETTER = 1;

		public const int DMPAPER_LETTERSMALL = 2;

		public const int DMPAPER_TABLOID = 3;

		public const int DMPAPER_LEDGER = 4;

		public const int DMPAPER_LEGAL = 5;

		public const int DMPAPER_STATEMENT = 6;

		public const int DMPAPER_EXECUTIVE = 7;

		public const int DMPAPER_A3 = 8;

		public const int DMPAPER_A4 = 9;

		public const int DMPAPER_A4SMALL = 10;

		public const int DMPAPER_A5 = 11;

		public const int DMPAPER_B4 = 12;

		public const int DMPAPER_B5 = 13;

		public const int DMPAPER_FOLIO = 14;

		public const int DMPAPER_QUARTO = 15;

		public const int DMPAPER_10X14 = 16;

		public const int DMPAPER_11X17 = 17;

		public const int DMPAPER_NOTE = 18;

		public const int DMPAPER_ENV_9 = 19;

		public const int DMPAPER_ENV_10 = 20;

		public const int DMPAPER_ENV_11 = 21;

		public const int DMPAPER_ENV_12 = 22;

		public const int DMPAPER_ENV_14 = 23;

		public const int DMPAPER_CSHEET = 24;

		public const int DMPAPER_DSHEET = 25;

		public const int DMPAPER_ESHEET = 26;

		public const int DMPAPER_ENV_DL = 27;

		public const int DMPAPER_ENV_C5 = 28;

		public const int DMPAPER_ENV_C3 = 29;

		public const int DMPAPER_ENV_C4 = 30;

		public const int DMPAPER_ENV_C6 = 31;

		public const int DMPAPER_ENV_C65 = 32;

		public const int DMPAPER_ENV_B4 = 33;

		public const int DMPAPER_ENV_B5 = 34;

		public const int DMPAPER_ENV_B6 = 35;

		public const int DMPAPER_ENV_ITALY = 36;

		public const int DMPAPER_ENV_MONARCH = 37;

		public const int DMPAPER_ENV_PERSONAL = 38;

		public const int DMPAPER_FANFOLD_US = 39;

		public const int DMPAPER_FANFOLD_STD_GERMAN = 40;

		public const int DMPAPER_FANFOLD_LGL_GERMAN = 41;

		public const int DMPAPER_ISO_B4 = 42;

		public const int DMPAPER_JAPANESE_POSTCARD = 43;

		public const int DMPAPER_9X11 = 44;

		public const int DMPAPER_10X11 = 45;

		public const int DMPAPER_15X11 = 46;

		public const int DMPAPER_ENV_INVITE = 47;

		public const int DMPAPER_RESERVED_48 = 48;

		public const int DMPAPER_RESERVED_49 = 49;

		public const int DMPAPER_LETTER_EXTRA = 50;

		public const int DMPAPER_LEGAL_EXTRA = 51;

		public const int DMPAPER_TABLOID_EXTRA = 52;

		public const int DMPAPER_A4_EXTRA = 53;

		public const int DMPAPER_LETTER_TRANSVERSE = 54;

		public const int DMPAPER_A4_TRANSVERSE = 55;

		public const int DMPAPER_LETTER_EXTRA_TRANSVERSE = 56;

		public const int DMPAPER_A_PLUS = 57;

		public const int DMPAPER_B_PLUS = 58;

		public const int DMPAPER_LETTER_PLUS = 59;

		public const int DMPAPER_A4_PLUS = 60;

		public const int DMPAPER_A5_TRANSVERSE = 61;

		public const int DMPAPER_B5_TRANSVERSE = 62;

		public const int DMPAPER_A3_EXTRA = 63;

		public const int DMPAPER_A5_EXTRA = 64;

		public const int DMPAPER_B5_EXTRA = 65;

		public const int DMPAPER_A2 = 66;

		public const int DMPAPER_A3_TRANSVERSE = 67;

		public const int DMPAPER_A3_EXTRA_TRANSVERSE = 68;

		public const int DMPAPER_DBL_JAPANESE_POSTCARD = 69;

		public const int DMPAPER_A6 = 70;

		public const int DMPAPER_JENV_KAKU2 = 71;

		public const int DMPAPER_JENV_KAKU3 = 72;

		public const int DMPAPER_JENV_CHOU3 = 73;

		public const int DMPAPER_JENV_CHOU4 = 74;

		public const int DMPAPER_LETTER_ROTATED = 75;

		public const int DMPAPER_A3_ROTATED = 76;

		public const int DMPAPER_A4_ROTATED = 77;

		public const int DMPAPER_A5_ROTATED = 78;

		public const int DMPAPER_B4_JIS_ROTATED = 79;

		public const int DMPAPER_B5_JIS_ROTATED = 80;

		public const int DMPAPER_JAPANESE_POSTCARD_ROTATED = 81;

		public const int DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82;

		public const int DMPAPER_A6_ROTATED = 83;

		public const int DMPAPER_JENV_KAKU2_ROTATED = 84;

		public const int DMPAPER_JENV_KAKU3_ROTATED = 85;

		public const int DMPAPER_JENV_CHOU3_ROTATED = 86;

		public const int DMPAPER_JENV_CHOU4_ROTATED = 87;

		public const int DMPAPER_B6_JIS = 88;

		public const int DMPAPER_B6_JIS_ROTATED = 89;

		public const int DMPAPER_12X11 = 90;

		public const int DMPAPER_JENV_YOU4 = 91;

		public const int DMPAPER_JENV_YOU4_ROTATED = 92;

		public const int DMPAPER_P16K = 93;

		public const int DMPAPER_P32K = 94;

		public const int DMPAPER_P32KBIG = 95;

		public const int DMPAPER_PENV_1 = 96;

		public const int DMPAPER_PENV_2 = 97;

		public const int DMPAPER_PENV_3 = 98;

		public const int DMPAPER_PENV_4 = 99;

		public const int DMPAPER_PENV_5 = 100;

		public const int DMPAPER_PENV_6 = 101;

		public const int DMPAPER_PENV_7 = 102;

		public const int DMPAPER_PENV_8 = 103;

		public const int DMPAPER_PENV_9 = 104;

		public const int DMPAPER_PENV_10 = 105;

		public const int DMPAPER_P16K_ROTATED = 106;

		public const int DMPAPER_P32K_ROTATED = 107;

		public const int DMPAPER_P32KBIG_ROTATED = 108;

		public const int DMPAPER_PENV_1_ROTATED = 109;

		public const int DMPAPER_PENV_2_ROTATED = 110;

		public const int DMPAPER_PENV_3_ROTATED = 111;

		public const int DMPAPER_PENV_4_ROTATED = 112;

		public const int DMPAPER_PENV_5_ROTATED = 113;

		public const int DMPAPER_PENV_6_ROTATED = 114;

		public const int DMPAPER_PENV_7_ROTATED = 115;

		public const int DMPAPER_PENV_8_ROTATED = 116;

		public const int DMPAPER_PENV_9_ROTATED = 117;

		public const int DMPAPER_PENV_10_ROTATED = 118;

		public const int DMPAPER_LAST = 118;

		public const int DMPAPER_USER = 256;

		public const int DMBIN_UPPER = 1;

		public const int DMBIN_ONLYONE = 1;

		public const int DMBIN_LOWER = 2;

		public const int DMBIN_MIDDLE = 3;

		public const int DMBIN_MANUAL = 4;

		public const int DMBIN_ENVELOPE = 5;

		public const int DMBIN_ENVMANUAL = 6;

		public const int DMBIN_AUTO = 7;

		public const int DMBIN_TRACTOR = 8;

		public const int DMBIN_SMALLFMT = 9;

		public const int DMBIN_LARGEFMT = 10;

		public const int DMBIN_LARGECAPACITY = 11;

		public const int DMBIN_CASSETTE = 14;

		public const int DMBIN_FORMSOURCE = 15;

		public const int DMBIN_LAST = 15;

		public const int DMBIN_USER = 256;

		public const int DMRES_DRAFT = -1;

		public const int DMRES_LOW = -2;

		public const int DMRES_MEDIUM = -3;

		public const int DMRES_HIGH = -4;

		public const int DMCOLOR_MONOCHROME = 1;

		public const int DMCOLOR_COLOR = 2;

		public const int DMDUP_SIMPLEX = 1;

		public const int DMDUP_VERTICAL = 2;

		public const int DMDUP_HORIZONTAL = 3;

		public const int DMTT_BITMAP = 1;

		public const int DMTT_DOWNLOAD = 2;

		public const int DMTT_SUBDEV = 3;

		public const int DMTT_DOWNLOAD_OUTLINE = 4;

		public const int DMCOLLATE_FALSE = 0;

		public const int DMCOLLATE_TRUE = 1;

		public const int DMDISPLAYFLAGS_TEXTMODE = 4;

		public const int DMICMMETHOD_NONE = 1;

		public const int DMICMMETHOD_SYSTEM = 2;

		public const int DMICMMETHOD_DRIVER = 3;

		public const int DMICMMETHOD_DEVICE = 4;

		public const int DMICMMETHOD_USER = 256;

		public const int DMICM_SATURATE = 1;

		public const int DMICM_CONTRAST = 2;

		public const int DMICM_COLORMETRIC = 3;

		public const int DMICM_USER = 256;

		public const int DMMEDIA_STANDARD = 1;

		public const int DMMEDIA_TRANSPARENCY = 2;

		public const int DMMEDIA_GLOSSY = 3;

		public const int DMMEDIA_USER = 256;

		public const int DMDITHER_NONE = 1;

		public const int DMDITHER_COARSE = 2;

		public const int DMDITHER_FINE = 3;

		public const int DMDITHER_LINEART = 4;

		public const int DMDITHER_GRAYSCALE = 5;

		public const int DMDITHER_USER = 256;

		public const int PRINTER_ENUM_DEFAULT = 1;

		public const int PRINTER_ENUM_LOCAL = 2;

		public const int PRINTER_ENUM_CONNECTIONS = 4;

		public const int PRINTER_ENUM_FAVORITE = 4;

		public const int PRINTER_ENUM_NAME = 8;

		public const int PRINTER_ENUM_REMOTE = 16;

		public const int PRINTER_ENUM_SHARED = 32;

		public const int PRINTER_ENUM_NETWORK = 64;

		public const int PRINTER_ENUM_EXPAND = 16384;

		public const int PRINTER_ENUM_CONTAINER = 32768;

		public const int PRINTER_ENUM_ICONMASK = 16711680;

		public const int PRINTER_ENUM_ICON1 = 65536;

		public const int PRINTER_ENUM_ICON2 = 131072;

		public const int PRINTER_ENUM_ICON3 = 262144;

		public const int PRINTER_ENUM_ICON4 = 524288;

		public const int PRINTER_ENUM_ICON5 = 1048576;

		public const int PRINTER_ENUM_ICON6 = 2097152;

		public const int PRINTER_ENUM_ICON7 = 4194304;

		public const int PRINTER_ENUM_ICON8 = 8388608;

		public const int DC_BINADJUST = 19;

		public const int DC_EMF_COMPLIANT = 20;

		public const int DC_DATATYPE_PRODUCED = 21;

		public const int DC_COLLATE = 22;

		public const int DCTT_BITMAP = 1;

		public const int DCTT_DOWNLOAD = 2;

		public const int DCTT_SUBDEV = 4;

		public const int DCTT_DOWNLOAD_OUTLINE = 8;

		public const int DCBA_FACEUPNONE = 0;

		public const int DCBA_FACEUPCENTER = 1;

		public const int DCBA_FACEUPLEFT = 2;

		public const int DCBA_FACEUPRIGHT = 3;

		public const int DCBA_FACEDOWNNONE = 256;

		public const int DCBA_FACEDOWNCENTER = 257;

		public const int DCBA_FACEDOWNLEFT = 258;

		public const int DCBA_FACEDOWNRIGHT = 259;

		public const int SRCPAINT = 15597702;

		public const int SRCAND = 8913094;

		public const int SRCINVERT = 6684742;

		public const int SRCERASE = 4457256;

		public const int NOTSRCCOPY = 3342344;

		public const int NOTSRCERASE = 1114278;

		public const int MERGECOPY = 12583114;

		public const int MERGEPAINT = 12255782;

		public const int PATCOPY = 15728673;

		public const int PATPAINT = 16452105;

		public const int PATINVERT = 5898313;

		public const int DSTINVERT = 5570569;

		public const int BLACKNESS = 66;

		public const int WHITENESS = 16711778;

		public const int CAPTUREBLT = 1073741824;

		public const int SM_CXSCREEN = 0;

		public const int SM_CYSCREEN = 1;

		public const int SM_CXVSCROLL = 2;

		public const int SM_CYHSCROLL = 3;

		public const int SM_CYCAPTION = 4;

		public const int SM_CXBORDER = 5;

		public const int SM_CYBORDER = 6;

		public const int SM_CXDLGFRAME = 7;

		public const int SM_CYDLGFRAME = 8;

		public const int SM_CYVTHUMB = 9;

		public const int SM_CXHTHUMB = 10;

		public const int SM_CXICON = 11;

		public const int SM_CYICON = 12;

		public const int SM_CXCURSOR = 13;

		public const int SM_CYCURSOR = 14;

		public const int SM_CYMENU = 15;

		public const int SM_CXFULLSCREEN = 16;

		public const int SM_CYFULLSCREEN = 17;

		public const int SM_CYKANJIWINDOW = 18;

		public const int SM_MOUSEPRESENT = 19;

		public const int SM_CYVSCROLL = 20;

		public const int SM_CXHSCROLL = 21;

		public const int SM_DEBUG = 22;

		public const int SM_SWAPBUTTON = 23;

		public const int SM_RESERVED1 = 24;

		public const int SM_RESERVED2 = 25;

		public const int SM_RESERVED3 = 26;

		public const int SM_RESERVED4 = 27;

		public const int SM_CXMIN = 28;

		public const int SM_CYMIN = 29;

		public const int SM_CXSIZE = 30;

		public const int SM_CYSIZE = 31;

		public const int SM_CXFRAME = 32;

		public const int SM_CYFRAME = 33;

		public const int SM_CXMINTRACK = 34;

		public const int SM_CYMINTRACK = 35;

		public const int SM_CXDOUBLECLK = 36;

		public const int SM_CYDOUBLECLK = 37;

		public const int SM_CXICONSPACING = 38;

		public const int SM_CYICONSPACING = 39;

		public const int SM_MENUDROPALIGNMENT = 40;

		public const int SM_PENWINDOWS = 41;

		public const int SM_DBCSENABLED = 42;

		public const int SM_CMOUSEBUTTONS = 43;

		public const int SM_CXFIXEDFRAME = 7;

		public const int SM_CYFIXEDFRAME = 8;

		public const int SM_CXSIZEFRAME = 32;

		public const int SM_CYSIZEFRAME = 33;

		public const int SM_SECURE = 44;

		public const int SM_CXEDGE = 45;

		public const int SM_CYEDGE = 46;

		public const int SM_CXMINSPACING = 47;

		public const int SM_CYMINSPACING = 48;

		public const int SM_CXSMICON = 49;

		public const int SM_CYSMICON = 50;

		public const int SM_CYSMCAPTION = 51;

		public const int SM_CXSMSIZE = 52;

		public const int SM_CYSMSIZE = 53;

		public const int SM_CXMENUSIZE = 54;

		public const int SM_CYMENUSIZE = 55;

		public const int SM_ARRANGE = 56;

		public const int SM_CXMINIMIZED = 57;

		public const int SM_CYMINIMIZED = 58;

		public const int SM_CXMAXTRACK = 59;

		public const int SM_CYMAXTRACK = 60;

		public const int SM_CXMAXIMIZED = 61;

		public const int SM_CYMAXIMIZED = 62;

		public const int SM_NETWORK = 63;

		public const int SM_CLEANBOOT = 67;

		public const int SM_CXDRAG = 68;

		public const int SM_CYDRAG = 69;

		public const int SM_SHOWSOUNDS = 70;

		public const int SM_CXMENUCHECK = 71;

		public const int SM_CYMENUCHECK = 72;

		public const int SM_SLOWMACHINE = 73;

		public const int SM_MIDEASTENABLED = 74;

		public const int SM_MOUSEWHEELPRESENT = 75;

		public const int SM_XVIRTUALSCREEN = 76;

		public const int SM_YVIRTUALSCREEN = 77;

		public const int SM_CXVIRTUALSCREEN = 78;

		public const int SM_CYVIRTUALSCREEN = 79;

		public const int SM_CMONITORS = 80;

		public const int SM_SAMEDISPLAYFORMAT = 81;

		public const int SM_CMETRICS = 83;

		public const int GM_COMPATIBLE = 1;

		public const int GM_ADVANCED = 2;

		public const int MWT_IDENTITY = 1;

		public const int FW_DONTCARE = 0;

		public const int FW_NORMAL = 400;

		public const int FW_BOLD = 700;

		public const int ANSI_CHARSET = 0;

		public const int DEFAULT_CHARSET = 1;

		public const int OUT_DEFAULT_PRECIS = 0;

		public const int OUT_TT_PRECIS = 4;

		public const int OUT_TT_ONLY_PRECIS = 7;

		public const int CLIP_DEFAULT_PRECIS = 0;

		public const int DEFAULT_QUALITY = 0;

		public const int MM_TEXT = 1;

		public const int OBJ_FONT = 6;

		public const int TA_DEFAULT = 0;

		public const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 256;

		public const int FORMAT_MESSAGE_IGNORE_INSERTS = 512;

		public const int FORMAT_MESSAGE_FROM_SYSTEM = 4096;

		public const int FORMAT_MESSAGE_DEFAULT = 4608;

		public const int NOMIRRORBITMAP = int.MinValue;

		public const int QUERYESCSUPPORT = 8;

		public const int CHECKJPEGFORMAT = 4119;

		public const int CHECKPNGFORMAT = 4120;

		public const int ERROR_ACCESS_DENIED = 5;

		public const int ERROR_INVALID_PARAMETER = 87;

		public const int ERROR_PROC_NOT_FOUND = 127;

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateCompatibleBitmap", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateCompatibleBitmap(HandleRef hDC, int width, int height);

		public static IntPtr CreateCompatibleBitmap(HandleRef hDC, int width, int height)
		{
			return System.Internal.HandleCollector.Add(IntCreateCompatibleBitmap(hDC, width, height), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateBitmap", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateBitmap(int width, int height, int planes, int bpp, IntPtr bitmapData);

		public static IntPtr CreateBitmap(int width, int height, int planes, int bpp, IntPtr bitmapData)
		{
			return System.Internal.HandleCollector.Add(IntCreateBitmap(width, height, planes, bpp, bitmapData), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int BitBlt(HandleRef hDC, int x, int y, int nWidth, int nHeight, HandleRef hSrcDC, int xSrc, int ySrc, int dwRop);

		[DllImport("gdi32.dll")]
		public static extern int GetDIBits(HandleRef hdc, HandleRef hbm, int arg1, int arg2, IntPtr arg3, ref NativeMethods.BITMAPINFO_FLAT bmi, int arg5);

		[DllImport("gdi32.dll")]
		public static extern uint GetPaletteEntries(HandleRef hpal, int iStartIndex, int nEntries, byte[] lppe);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateDIBSection", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateDIBSection(HandleRef hdc, ref NativeMethods.BITMAPINFO_FLAT bmi, int iUsage, ref IntPtr ppvBits, IntPtr hSection, int dwOffset);

		public static IntPtr CreateDIBSection(HandleRef hdc, ref NativeMethods.BITMAPINFO_FLAT bmi, int iUsage, ref IntPtr ppvBits, IntPtr hSection, int dwOffset)
		{
			return System.Internal.HandleCollector.Add(IntCreateDIBSection(hdc, ref bmi, iUsage, ref ppvBits, hSection, dwOffset), CommonHandles.GDI);
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr GlobalFree(HandleRef handle);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int StartDoc(HandleRef hDC, DOCINFO lpDocInfo);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int StartPage(HandleRef hDC);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int EndPage(HandleRef hDC);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int AbortDoc(HandleRef hDC);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int EndDoc(HandleRef hDC);

		[DllImport("comdlg32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool PrintDlg([In][Out] PRINTDLG lppd);

		[DllImport("comdlg32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern bool PrintDlg([In][Out] PRINTDLGX86 lppd);

		[DllImport("winspool.drv", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int DeviceCapabilities(string pDevice, string pPort, short fwCapabilities, IntPtr pOutput, IntPtr pDevMode);

		[DllImport("winspool.drv", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int DocumentProperties(HandleRef hwnd, HandleRef hPrinter, string pDeviceName, IntPtr pDevModeOutput, HandleRef pDevModeInput, int fMode);

		[DllImport("winspool.drv", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int DocumentProperties(HandleRef hwnd, HandleRef hPrinter, string pDeviceName, IntPtr pDevModeOutput, IntPtr pDevModeInput, int fMode);

		[DllImport("winspool.drv", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int EnumPrinters(int flags, string name, int level, IntPtr pPrinterEnum, int cbBuf, out int pcbNeeded, out int pcReturned);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr GlobalLock(HandleRef handle);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern IntPtr ResetDC(HandleRef hDC, HandleRef lpDevMode);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool GlobalUnlock(HandleRef handle);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateRectRgn", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCreateRectRgn(int x1, int y1, int x2, int y2);

		public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2)
		{
			return System.Internal.HandleCollector.Add(IntCreateRectRgn(x1, y1, x2, y2), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetClipRgn(HandleRef hDC, HandleRef hRgn);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SelectClipRgn(HandleRef hDC, HandleRef hRgn);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int AddFontResourceEx(string lpszFilename, int fl, IntPtr pdv);

		public static int AddFontFile(string fileName)
		{
			if (Marshal.SystemDefaultCharSize == 1)
			{
				return 0;
			}
			return AddFontResourceEx(fileName, 16, IntPtr.Zero);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
		public static extern int RemoveFontResourceEx(string lpszFilename, int fl, IntPtr pdv);

		public static int RemoveFontFile(string fileName)
		{
			return RemoveFontResourceEx(fileName, 16, IntPtr.Zero);
		}

		internal static IntPtr SaveClipRgn(IntPtr hDC)
		{
			IntPtr intPtr = CreateRectRgn(0, 0, 0, 0);
			IntPtr zero = IntPtr.Zero;
			try
			{
				int clipRgn = GetClipRgn(new HandleRef(null, hDC), new HandleRef(null, intPtr));
				if (clipRgn > 0)
				{
					zero = intPtr;
					intPtr = IntPtr.Zero;
					return zero;
				}
				return zero;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					DeleteObject(new HandleRef(null, intPtr));
				}
			}
		}

		internal static void RestoreClipRgn(IntPtr hDC, IntPtr hRgn)
		{
			try
			{
				SelectClipRgn(new HandleRef(null, hDC), new HandleRef(null, hRgn));
			}
			finally
			{
				if (hRgn != IntPtr.Zero)
				{
					DeleteObject(new HandleRef(null, hRgn));
				}
			}
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int ExtEscape(HandleRef hDC, int nEscape, int cbInput, ref int inData, int cbOutput, out int outData);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int ExtEscape(HandleRef hDC, int nEscape, int cbInput, byte[] inData, int cbOutput, out int outData);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int IntersectClipRect(HandleRef hDC, int x1, int y1, int x2, int y2);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, EntryPoint = "GlobalAlloc", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntGlobalAlloc(int uFlags, UIntPtr dwBytes);

		public static IntPtr GlobalAlloc(int uFlags, uint dwBytes)
		{
			return IntGlobalAlloc(uFlags, new UIntPtr(dwBytes));
		}

		[DllImport("kernel32.dll")]
		internal static extern void ZeroMemory(IntPtr destination, UIntPtr length);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "DeleteObject", ExactSpelling = true, SetLastError = true)]
		internal static extern int IntDeleteObject(HandleRef hObject);

		public static int DeleteObject(HandleRef hObject)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hObject, CommonHandles.GDI);
			return IntDeleteObject(hObject);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr SelectObject(HandleRef hdc, HandleRef obj);

		[DllImport("user32.dll", EntryPoint = "CreateIconFromResourceEx", SetLastError = true)]
		private unsafe static extern IntPtr IntCreateIconFromResourceEx(byte* pbIconBits, int cbIconBits, bool fIcon, int dwVersion, int csDesired, int cyDesired, int flags);

		public unsafe static IntPtr CreateIconFromResourceEx(byte* pbIconBits, int cbIconBits, bool fIcon, int dwVersion, int csDesired, int cyDesired, int flags)
		{
			return System.Internal.HandleCollector.Add(IntCreateIconFromResourceEx(pbIconBits, cbIconBits, fIcon, dwVersion, csDesired, cyDesired, flags), CommonHandles.Icon);
		}

		[DllImport("shell32.dll", BestFitMapping = false, CharSet = CharSet.Auto, EntryPoint = "ExtractAssociatedIcon")]
		public static extern IntPtr IntExtractAssociatedIcon(HandleRef hInst, StringBuilder iconPath, ref int index);

		public static IntPtr ExtractAssociatedIcon(HandleRef hInst, StringBuilder iconPath, ref int index)
		{
			return System.Internal.HandleCollector.Add(IntExtractAssociatedIcon(hInst, iconPath, ref index), CommonHandles.Icon);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "LoadIcon", SetLastError = true)]
		private static extern IntPtr IntLoadIcon(HandleRef hInst, IntPtr iconId);

		public static IntPtr LoadIcon(HandleRef hInst, int iconId)
		{
			return IntLoadIcon(hInst, new IntPtr(iconId));
		}

		[DllImport("comctl32.dll", CharSet = CharSet.Auto, EntryPoint = "LoadIconWithScaleDown", SetLastError = true)]
		private static extern int IntLoadIconWithScaleDown(HandleRef hInst, IntPtr iconId, int cx, int cy, ref IntPtr phico);

		public static int LoadIconWithScaleDown(HandleRef hInst, int iconId, int cx, int cy, ref IntPtr phico)
		{
			return IntLoadIconWithScaleDown(hInst, new IntPtr(iconId), cx, cy, ref phico);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "DestroyIcon", ExactSpelling = true, SetLastError = true)]
		private static extern bool IntDestroyIcon(HandleRef hIcon);

		public static bool DestroyIcon(HandleRef hIcon)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hIcon, CommonHandles.Icon);
			return IntDestroyIcon(hIcon);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "CopyImage", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags);

		public static IntPtr CopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags)
		{
			return System.Internal.HandleCollector.Add(type: (uType != 1) ? CommonHandles.GDI : CommonHandles.Icon, handle: IntCopyImage(hImage, uType, cxDesired, cyDesired, fuFlags));
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetObject(HandleRef hObject, int nSize, [In][Out] BITMAP bm);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetObject(HandleRef hObject, int nSize, [In][Out] LOGFONT lf);

		public static int GetObject(HandleRef hObject, LOGFONT lp)
		{
			return GetObject(hObject, Marshal.SizeOf(typeof(LOGFONT)), lp);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool GetIconInfo(HandleRef hIcon, [In][Out] ICONINFO info);

		[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetSysColor(int nIndex);

		[DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool DrawIconEx(HandleRef hDC, int x, int y, HandleRef hIcon, int width, int height, int iStepIfAniCursor, HandleRef hBrushFlickerFree, int diFlags);

		[DllImport("oleaut32.dll", PreserveSig = false)]
		public static extern IPicture OleCreatePictureIndirect(PICTDESC pictdesc, [In] ref Guid refiid, bool fOwn);
	}
	/// <summary>
	///   <see cref="T:System.Drawing.ImageFormatConverter" /> is a class that can be used to convert <see cref="T:System.Drawing.Imaging.ImageFormat" /> objects from one data type to another. Access this class through the <see cref="T:System.ComponentModel.TypeDescriptor" /> object.</summary>
	public class ImageFormatConverter : TypeConverter
	{
		private StandardValuesCollection values;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.ImageFormatConverter" /> class.</summary>
		public ImageFormatConverter()
		{
		}

		/// <summary>Indicates whether this converter can convert an object in the specified source type to the native type of the converter.</summary>
		/// <param name="context">A formatter context. This object can be used to get more information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="sourceType">The type you want to convert from.</param>
		/// <returns>This method returns <see langword="true" /> if this object can perform the conversion.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Gets a value indicating whether this converter can convert an object to the specified destination type using the context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that specifies the context for this type conversion.</param>
		/// <param name="destinationType">The <see cref="T:System.Type" /> that represents the type to which you want to convert this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</param>
		/// <returns>This method returns <see langword="true" /> if this object can perform the conversion.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the specified object to an <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</summary>
		/// <param name="context">A formatter context. This object can be used to get more information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> object that specifies formatting conventions for a particular culture.</param>
		/// <param name="value">The object to convert.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string b = text.Trim();
				PropertyInfo[] properties = GetProperties();
				foreach (PropertyInfo propertyInfo in properties)
				{
					if (string.Equals(propertyInfo.Name, b, StringComparison.OrdinalIgnoreCase))
					{
						object[] index = null;
						return propertyInfo.GetValue(null, index);
					}
				}
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts the specified object to the specified type.</summary>
		/// <param name="context">A formatter context. This object can be used to get more information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> object that specifies formatting conventions for a particular culture.</param>
		/// <param name="value">The object to convert.</param>
		/// <param name="destinationType">The type to convert the object to.</param>
		/// <returns>The converted object.</returns>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be completed.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="destinationType" /> is <see langword="null." /></exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is ImageFormat)
			{
				PropertyInfo propertyInfo = null;
				PropertyInfo[] properties = GetProperties();
				PropertyInfo[] array = properties;
				foreach (PropertyInfo propertyInfo2 in array)
				{
					if (propertyInfo2.GetValue(null, null).Equals(value))
					{
						propertyInfo = propertyInfo2;
						break;
					}
				}
				if (propertyInfo != null)
				{
					if (destinationType == typeof(string))
					{
						return propertyInfo.Name;
					}
					if (destinationType == typeof(InstanceDescriptor))
					{
						return new InstanceDescriptor(propertyInfo, null);
					}
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		private PropertyInfo[] GetProperties()
		{
			return typeof(ImageFormat).GetProperties(BindingFlags.Static | BindingFlags.Public);
		}

		/// <summary>Gets a collection that contains a set of standard values for the data type this validator is designed for. Returns <see langword="null" /> if the data type does not support a standard set of values.</summary>
		/// <param name="context">A formatter context. This object can be used to get more information about the environment this converter is being called from. This may be <see langword="null" />, so you should always check. Also, properties on the context object may also return <see langword="null" />.</param>
		/// <returns>A collection that contains a standard set of valid values, or <see langword="null" />. The default implementation always returns <see langword="null" />.</returns>
		public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
		{
			if (values == null)
			{
				ArrayList arrayList = new ArrayList();
				PropertyInfo[] properties = GetProperties();
				foreach (PropertyInfo propertyInfo in properties)
				{
					object[] index = null;
					arrayList.Add(propertyInfo.GetValue(null, index));
				}
				values = new StandardValuesCollection(arrayList.ToArray());
			}
			return values;
		}

		/// <summary>Indicates whether this object supports a standard set of values that can be picked from a list.</summary>
		/// <param name="context">A type descriptor through which additional context can be provided.</param>
		/// <returns>This method returns <see langword="true" /> if the <see cref="Overload:System.Drawing.ImageFormatConverter.GetStandardValues" /> method should be called to find a common set of values the object supports.</returns>
		public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
		{
			return true;
		}
	}
	/// <summary>Represents an ordered pair of floating-point x- and y-coordinates that defines a point in a two-dimensional plane.</summary>
	[Serializable]
	[ComVisible(true)]
	public struct PointF
	{
		/// <summary>Represents a new instance of the <see cref="T:System.Drawing.PointF" /> class with member data left uninitialized.</summary>
		public static readonly PointF Empty;

		private float x;

		private float y;

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.PointF" /> is empty.</summary>
		/// <returns>
		///   <see langword="true" /> if both <see cref="P:System.Drawing.PointF.X" /> and <see cref="P:System.Drawing.PointF.Y" /> are 0; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (x == 0f)
				{
					return y == 0f;
				}
				return false;
			}
		}

		/// <summary>Gets or sets the x-coordinate of this <see cref="T:System.Drawing.PointF" />.</summary>
		/// <returns>The x-coordinate of this <see cref="T:System.Drawing.PointF" />.</returns>
		public float X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of this <see cref="T:System.Drawing.PointF" />.</summary>
		/// <returns>The y-coordinate of this <see cref="T:System.Drawing.PointF" />.</returns>
		public float Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.PointF" /> class with the specified coordinates.</summary>
		/// <param name="x">The horizontal position of the point.</param>
		/// <param name="y">The vertical position of the point.</param>
		public PointF(float x, float y)
		{
			this.x = x;
			this.y = y;
		}

		/// <summary>Translates a <see cref="T:System.Drawing.PointF" /> by a given <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">A <see cref="T:System.Drawing.Size" /> that specifies the pair of numbers to add to the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF operator +(PointF pt, Size sz)
		{
			return Add(pt, sz);
		}

		/// <summary>Translates a <see cref="T:System.Drawing.PointF" /> by the negative of a given <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.Size" /> that specifies the numbers to subtract from the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF operator -(PointF pt, Size sz)
		{
			return Subtract(pt, sz);
		}

		/// <summary>Translates the <see cref="T:System.Drawing.PointF" /> by the specified <see cref="T:System.Drawing.SizeF" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.SizeF" /> that specifies the numbers to add to the x- and y-coordinates of the <see cref="T:System.Drawing.PointF" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF operator +(PointF pt, SizeF sz)
		{
			return Add(pt, sz);
		}

		/// <summary>Translates a <see cref="T:System.Drawing.PointF" /> by the negative of a specified <see cref="T:System.Drawing.SizeF" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.SizeF" /> that specifies the numbers to subtract from the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF operator -(PointF pt, SizeF sz)
		{
			return Subtract(pt, sz);
		}

		/// <summary>Compares two <see cref="T:System.Drawing.PointF" /> structures. The result specifies whether the values of the <see cref="P:System.Drawing.PointF.X" /> and <see cref="P:System.Drawing.PointF.Y" /> properties of the two <see cref="T:System.Drawing.PointF" /> structures are equal.</summary>
		/// <param name="left">A <see cref="T:System.Drawing.PointF" /> to compare.</param>
		/// <param name="right">A <see cref="T:System.Drawing.PointF" /> to compare.</param>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Drawing.PointF.X" /> and <see cref="P:System.Drawing.PointF.Y" /> values of the left and right <see cref="T:System.Drawing.PointF" /> structures are equal; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(PointF left, PointF right)
		{
			if (left.X == right.X)
			{
				return left.Y == right.Y;
			}
			return false;
		}

		/// <summary>Determines whether the coordinates of the specified points are not equal.</summary>
		/// <param name="left">A <see cref="T:System.Drawing.PointF" /> to compare.</param>
		/// <param name="right">A <see cref="T:System.Drawing.PointF" /> to compare.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the <see cref="P:System.Drawing.PointF.X" /> and <see cref="P:System.Drawing.PointF.Y" /> values of <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(PointF left, PointF right)
		{
			return !(left == right);
		}

		/// <summary>Translates a given <see cref="T:System.Drawing.PointF" /> by the specified <see cref="T:System.Drawing.Size" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.Size" /> that specifies the numbers to add to the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF Add(PointF pt, Size sz)
		{
			return new PointF(pt.X + (float)sz.Width, pt.Y + (float)sz.Height);
		}

		/// <summary>Translates a <see cref="T:System.Drawing.PointF" /> by the negative of a specified size.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.Size" /> that specifies the numbers to subtract from the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF Subtract(PointF pt, Size sz)
		{
			return new PointF(pt.X - (float)sz.Width, pt.Y - (float)sz.Height);
		}

		/// <summary>Translates a given <see cref="T:System.Drawing.PointF" /> by a specified <see cref="T:System.Drawing.SizeF" />.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.SizeF" /> that specifies the numbers to add to the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF Add(PointF pt, SizeF sz)
		{
			return new PointF(pt.X + sz.Width, pt.Y + sz.Height);
		}

		/// <summary>Translates a <see cref="T:System.Drawing.PointF" /> by the negative of a specified size.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to translate.</param>
		/// <param name="sz">The <see cref="T:System.Drawing.SizeF" /> that specifies the numbers to subtract from the coordinates of <paramref name="pt" />.</param>
		/// <returns>The translated <see cref="T:System.Drawing.PointF" />.</returns>
		public static PointF Subtract(PointF pt, SizeF sz)
		{
			return new PointF(pt.X - sz.Width, pt.Y - sz.Height);
		}

		/// <summary>Specifies whether this <see cref="T:System.Drawing.PointF" /> contains the same coordinates as the specified <see cref="T:System.Object" />.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.PointF" /> and has the same coordinates as this <see cref="T:System.Drawing.Point" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is PointF pointF))
			{
				return false;
			}
			if (pointF.X == X && pointF.Y == Y)
			{
				return pointF.GetType().Equals(GetType());
			}
			return false;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.PointF" /> structure.</summary>
		/// <returns>An integer value that specifies a hash value for this <see cref="T:System.Drawing.PointF" /> structure.</returns>
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		/// <summary>Converts this <see cref="T:System.Drawing.PointF" /> to a human readable string.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.PointF" />.</returns>
		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "{{X={0}, Y={1}}}", new object[2] { x, y });
		}
	}
	/// <summary>Stores a set of four floating-point numbers that represent the location and size of a rectangle. For more advanced region functions, use a <see cref="T:System.Drawing.Region" /> object.</summary>
	[Serializable]
	public struct RectangleF
	{
		/// <summary>Represents an instance of the <see cref="T:System.Drawing.RectangleF" /> class with its members uninitialized.</summary>
		public static readonly RectangleF Empty;

		private float x;

		private float y;

		private float width;

		private float height;

		/// <summary>Gets or sets the coordinates of the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>A <see cref="T:System.Drawing.PointF" /> that represents the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public PointF Location
		{
			get
			{
				return new PointF(X, Y);
			}
			set
			{
				X = value.X;
				Y = value.Y;
			}
		}

		/// <summary>Gets or sets the size of this <see cref="T:System.Drawing.RectangleF" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.SizeF" /> that represents the width and height of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public SizeF Size
		{
			get
			{
				return new SizeF(Width, Height);
			}
			set
			{
				Width = value.Width;
				Height = value.Height;
			}
		}

		/// <summary>Gets or sets the x-coordinate of the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The x-coordinate of the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure. The default is 0.</returns>
		public float X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The y-coordinate of the upper-left corner of this <see cref="T:System.Drawing.RectangleF" /> structure. The default is 0.</returns>
		public float Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		/// <summary>Gets or sets the width of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The width of this <see cref="T:System.Drawing.RectangleF" /> structure. The default is 0.</returns>
		public float Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		/// <summary>Gets or sets the height of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The height of this <see cref="T:System.Drawing.RectangleF" /> structure. The default is 0.</returns>
		public float Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		/// <summary>Gets the x-coordinate of the left edge of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The x-coordinate of the left edge of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public float Left => X;

		/// <summary>Gets the y-coordinate of the top edge of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The y-coordinate of the top edge of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public float Top => Y;

		/// <summary>Gets the x-coordinate that is the sum of <see cref="P:System.Drawing.RectangleF.X" /> and <see cref="P:System.Drawing.RectangleF.Width" /> of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The x-coordinate that is the sum of <see cref="P:System.Drawing.RectangleF.X" /> and <see cref="P:System.Drawing.RectangleF.Width" /> of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public float Right => X + Width;

		/// <summary>Gets the y-coordinate that is the sum of <see cref="P:System.Drawing.RectangleF.Y" /> and <see cref="P:System.Drawing.RectangleF.Height" /> of this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <returns>The y-coordinate that is the sum of <see cref="P:System.Drawing.RectangleF.Y" /> and <see cref="P:System.Drawing.RectangleF.Height" /> of this <see cref="T:System.Drawing.RectangleF" /> structure.</returns>
		[Browsable(false)]
		public float Bottom => Y + Height;

		/// <summary>Gets a value that indicates whether the <see cref="P:System.Drawing.RectangleF.Width" /> or <see cref="P:System.Drawing.RectangleF.Height" /> property of this <see cref="T:System.Drawing.RectangleF" /> has a value of zero.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Drawing.RectangleF.Width" /> or <see cref="P:System.Drawing.RectangleF.Height" /> property of this <see cref="T:System.Drawing.RectangleF" /> has a value of zero; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (!(Width <= 0f))
				{
					return Height <= 0f;
				}
				return true;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.RectangleF" /> class with the specified location and size.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangle.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangle.</param>
		/// <param name="width">The width of the rectangle.</param>
		/// <param name="height">The height of the rectangle.</param>
		public RectangleF(float x, float y, float width, float height)
		{
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.RectangleF" /> class with the specified location and size.</summary>
		/// <param name="location">A <see cref="T:System.Drawing.PointF" /> that represents the upper-left corner of the rectangular region.</param>
		/// <param name="size">A <see cref="T:System.Drawing.SizeF" /> that represents the width and height of the rectangular region.</param>
		public RectangleF(PointF location, SizeF size)
		{
			x = location.X;
			y = location.Y;
			width = size.Width;
			height = size.Height;
		}

		/// <summary>Creates a <see cref="T:System.Drawing.RectangleF" /> structure with upper-left corner and lower-right corner at the specified locations.</summary>
		/// <param name="left">The x-coordinate of the upper-left corner of the rectangular region.</param>
		/// <param name="top">The y-coordinate of the upper-left corner of the rectangular region.</param>
		/// <param name="right">The x-coordinate of the lower-right corner of the rectangular region.</param>
		/// <param name="bottom">The y-coordinate of the lower-right corner of the rectangular region.</param>
		/// <returns>The new <see cref="T:System.Drawing.RectangleF" /> that this method creates.</returns>
		public static RectangleF FromLTRB(float left, float top, float right, float bottom)
		{
			return new RectangleF(left, top, right - left, bottom - top);
		}

		/// <summary>Tests whether <paramref name="obj" /> is a <see cref="T:System.Drawing.RectangleF" /> with the same location and size of this <see cref="T:System.Drawing.RectangleF" />.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.RectangleF" /> and its <see langword="X" />, <see langword="Y" />, <see langword="Width" />, and <see langword="Height" /> properties are equal to the corresponding properties of this <see cref="T:System.Drawing.RectangleF" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is RectangleF rectangleF))
			{
				return false;
			}
			if (rectangleF.X == X && rectangleF.Y == Y && rectangleF.Width == Width)
			{
				return rectangleF.Height == Height;
			}
			return false;
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.RectangleF" /> structures have equal location and size.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.RectangleF" /> structure that is to the left of the equality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.RectangleF" /> structure that is to the right of the equality operator.</param>
		/// <returns>
		///   <see langword="true" /> if the two specified <see cref="T:System.Drawing.RectangleF" /> structures have equal <see cref="P:System.Drawing.RectangleF.X" />, <see cref="P:System.Drawing.RectangleF.Y" />, <see cref="P:System.Drawing.RectangleF.Width" />, and <see cref="P:System.Drawing.RectangleF.Height" /> properties; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(RectangleF left, RectangleF right)
		{
			if (left.X == right.X && left.Y == right.Y && left.Width == right.Width)
			{
				return left.Height == right.Height;
			}
			return false;
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.RectangleF" /> structures differ in location or size.</summary>
		/// <param name="left">The <see cref="T:System.Drawing.RectangleF" /> structure that is to the left of the inequality operator.</param>
		/// <param name="right">The <see cref="T:System.Drawing.RectangleF" /> structure that is to the right of the inequality operator.</param>
		/// <returns>
		///   <see langword="true" /> if any of the <see cref="P:System.Drawing.RectangleF.X" /> , <see cref="P:System.Drawing.RectangleF.Y" />, <see cref="P:System.Drawing.RectangleF.Width" />, or <see cref="P:System.Drawing.RectangleF.Height" /> properties of the two <see cref="T:System.Drawing.Rectangle" /> structures are unequal; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(RectangleF left, RectangleF right)
		{
			return !(left == right);
		}

		/// <summary>Determines if the specified point is contained within this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <returns>
		///   <see langword="true" /> if the point defined by <paramref name="x" /> and <paramref name="y" /> is contained within this <see cref="T:System.Drawing.RectangleF" /> structure; otherwise, <see langword="false" />.</returns>
		public bool Contains(float x, float y)
		{
			if (X <= x && x < X + Width && Y <= y)
			{
				return y < Y + Height;
			}
			return false;
		}

		/// <summary>Determines if the specified point is contained within this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if the point represented by the <paramref name="pt" /> parameter is contained within this <see cref="T:System.Drawing.RectangleF" /> structure; otherwise, <see langword="false" />.</returns>
		public bool Contains(PointF pt)
		{
			return Contains(pt.X, pt.Y);
		}

		/// <summary>Determines if the rectangular region represented by <paramref name="rect" /> is entirely contained within this <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if the rectangular region represented by <paramref name="rect" /> is entirely contained within the rectangular region represented by this <see cref="T:System.Drawing.RectangleF" />; otherwise, <see langword="false" />.</returns>
		public bool Contains(RectangleF rect)
		{
			if (X <= rect.X && rect.X + rect.Width <= X + Width && Y <= rect.Y)
			{
				return rect.Y + rect.Height <= Y + Height;
			}
			return false;
		}

		/// <summary>Gets the hash code for this <see cref="T:System.Drawing.RectangleF" /> structure. For information about the use of hash codes, see <see langword="Object.GetHashCode" />.</summary>
		/// <returns>The hash code for this <see cref="T:System.Drawing.RectangleF" />.</returns>
		public override int GetHashCode()
		{
			return (int)((uint)X ^ (((uint)Y << 13) | ((uint)Y >> 19)) ^ (((uint)Width << 26) | ((uint)Width >> 6)) ^ (((uint)Height << 7) | ((uint)Height >> 25)));
		}

		/// <summary>Enlarges this <see cref="T:System.Drawing.RectangleF" /> structure by the specified amount.</summary>
		/// <param name="x">The amount to inflate this <see cref="T:System.Drawing.RectangleF" /> structure horizontally.</param>
		/// <param name="y">The amount to inflate this <see cref="T:System.Drawing.RectangleF" /> structure vertically.</param>
		public void Inflate(float x, float y)
		{
			X -= x;
			Y -= y;
			Width += 2f * x;
			Height += 2f * y;
		}

		/// <summary>Enlarges this <see cref="T:System.Drawing.RectangleF" /> by the specified amount.</summary>
		/// <param name="size">The amount to inflate this rectangle.</param>
		public void Inflate(SizeF size)
		{
			Inflate(size.Width, size.Height);
		}

		/// <summary>Creates and returns an enlarged copy of the specified <see cref="T:System.Drawing.RectangleF" /> structure. The copy is enlarged by the specified amount and the original rectangle remains unmodified.</summary>
		/// <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> to be copied. This rectangle is not modified.</param>
		/// <param name="x">The amount to enlarge the copy of the rectangle horizontally.</param>
		/// <param name="y">The amount to enlarge the copy of the rectangle vertically.</param>
		/// <returns>The enlarged <see cref="T:System.Drawing.RectangleF" />.</returns>
		public static RectangleF Inflate(RectangleF rect, float x, float y)
		{
			RectangleF result = rect;
			result.Inflate(x, y);
			return result;
		}

		/// <summary>Replaces this <see cref="T:System.Drawing.RectangleF" /> structure with the intersection of itself and the specified <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="rect">The rectangle to intersect.</param>
		public void Intersect(RectangleF rect)
		{
			RectangleF rectangleF = Intersect(rect, this);
			X = rectangleF.X;
			Y = rectangleF.Y;
			Width = rectangleF.Width;
			Height = rectangleF.Height;
		}

		/// <summary>Returns a <see cref="T:System.Drawing.RectangleF" /> structure that represents the intersection of two rectangles. If there is no intersection, and empty <see cref="T:System.Drawing.RectangleF" /> is returned.</summary>
		/// <param name="a">A rectangle to intersect.</param>
		/// <param name="b">A rectangle to intersect.</param>
		/// <returns>A third <see cref="T:System.Drawing.RectangleF" /> structure the size of which represents the overlapped area of the two specified rectangles.</returns>
		public static RectangleF Intersect(RectangleF a, RectangleF b)
		{
			float num = Math.Max(a.X, b.X);
			float num2 = Math.Min(a.X + a.Width, b.X + b.Width);
			float num3 = Math.Max(a.Y, b.Y);
			float num4 = Math.Min(a.Y + a.Height, b.Y + b.Height);
			if (num2 >= num && num4 >= num3)
			{
				return new RectangleF(num, num3, num2 - num, num4 - num3);
			}
			return Empty;
		}

		/// <summary>Determines if this rectangle intersects with <paramref name="rect" />.</summary>
		/// <param name="rect">The rectangle to test.</param>
		/// <returns>
		///   <see langword="true" /> if there is any intersection; otherwise, <see langword="false" />.</returns>
		public bool IntersectsWith(RectangleF rect)
		{
			if (rect.X < X + Width && X < rect.X + rect.Width && rect.Y < Y + Height)
			{
				return Y < rect.Y + rect.Height;
			}
			return false;
		}

		/// <summary>Creates the smallest possible third rectangle that can contain both of two rectangles that form a union.</summary>
		/// <param name="a">A rectangle to union.</param>
		/// <param name="b">A rectangle to union.</param>
		/// <returns>A third <see cref="T:System.Drawing.RectangleF" /> structure that contains both of the two rectangles that form the union.</returns>
		public static RectangleF Union(RectangleF a, RectangleF b)
		{
			float num = Math.Min(a.X, b.X);
			float num2 = Math.Max(a.X + a.Width, b.X + b.Width);
			float num3 = Math.Min(a.Y, b.Y);
			float num4 = Math.Max(a.Y + a.Height, b.Y + b.Height);
			return new RectangleF(num, num3, num2 - num, num4 - num3);
		}

		/// <summary>Adjusts the location of this rectangle by the specified amount.</summary>
		/// <param name="pos">The amount to offset the location.</param>
		public void Offset(PointF pos)
		{
			Offset(pos.X, pos.Y);
		}

		/// <summary>Adjusts the location of this rectangle by the specified amount.</summary>
		/// <param name="x">The amount to offset the location horizontally.</param>
		/// <param name="y">The amount to offset the location vertically.</param>
		public void Offset(float x, float y)
		{
			X += x;
			Y += y;
		}

		internal GPRECTF ToGPRECTF()
		{
			return new GPRECTF(X, Y, Width, Height);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.Rectangle" /> structure to a <see cref="T:System.Drawing.RectangleF" /> structure.</summary>
		/// <param name="r">The <see cref="T:System.Drawing.Rectangle" /> structure to convert.</param>
		/// <returns>The <see cref="T:System.Drawing.RectangleF" /> structure that is converted from the specified <see cref="T:System.Drawing.Rectangle" /> structure.</returns>
		public static implicit operator RectangleF(Rectangle r)
		{
			return new RectangleF(r.X, r.Y, r.Width, r.Height);
		}

		/// <summary>Converts the <see langword="Location" /> and <see cref="T:System.Drawing.Size" /> of this <see cref="T:System.Drawing.RectangleF" /> to a human-readable string.</summary>
		/// <returns>A string that contains the position, width, and height of this <see cref="T:System.Drawing.RectangleF" /> structure. For example, "{X=20, Y=20, Width=100, Height=50}".</returns>
		public override string ToString()
		{
			return "{X=" + X.ToString(CultureInfo.CurrentCulture) + ",Y=" + Y.ToString(CultureInfo.CurrentCulture) + ",Width=" + Width.ToString(CultureInfo.CurrentCulture) + ",Height=" + Height.ToString(CultureInfo.CurrentCulture) + "}";
		}
	}
	/// <summary>Stores an ordered pair of floating-point numbers, typically the width and height of a rectangle.</summary>
	[Serializable]
	[ComVisible(true)]
	[TypeConverter(typeof(SizeFConverter))]
	public struct SizeF
	{
		/// <summary>Gets a <see cref="T:System.Drawing.SizeF" /> structure that has a <see cref="P:System.Drawing.SizeF.Height" /> and <see cref="P:System.Drawing.SizeF.Width" /> value of 0.</summary>
		public static readonly SizeF Empty;

		private float width;

		private float height;

		/// <summary>Gets a value that indicates whether this <see cref="T:System.Drawing.SizeF" /> structure has zero width and height.</summary>
		/// <returns>
		///   <see langword="true" /> when this <see cref="T:System.Drawing.SizeF" /> structure has both a width and height of zero; otherwise, <see langword="false" />.</returns>
		[Browsable(false)]
		public bool IsEmpty
		{
			get
			{
				if (width == 0f)
				{
					return height == 0f;
				}
				return false;
			}
		}

		/// <summary>Gets or sets the horizontal component of this <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <returns>The horizontal component of this <see cref="T:System.Drawing.SizeF" /> structure, typically measured in pixels.</returns>
		public float Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		/// <summary>Gets or sets the vertical component of this <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <returns>The vertical component of this <see cref="T:System.Drawing.SizeF" /> structure, typically measured in pixels.</returns>
		public float Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.SizeF" /> structure from the specified existing <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="size">The <see cref="T:System.Drawing.SizeF" /> structure from which to create the new <see cref="T:System.Drawing.SizeF" /> structure.</param>
		public SizeF(SizeF size)
		{
			width = size.width;
			height = size.height;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.SizeF" /> structure from the specified <see cref="T:System.Drawing.PointF" /> structure.</summary>
		/// <param name="pt">The <see cref="T:System.Drawing.PointF" /> structure from which to initialize this <see cref="T:System.Drawing.SizeF" /> structure.</param>
		public SizeF(PointF pt)
		{
			width = pt.X;
			height = pt.Y;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.SizeF" /> structure from the specified dimensions.</summary>
		/// <param name="width">The width component of the new <see cref="T:System.Drawing.SizeF" /> structure.</param>
		/// <param name="height">The height component of the new <see cref="T:System.Drawing.SizeF" /> structure.</param>
		public SizeF(float width, float height)
		{
			this.width = width;
			this.height = height;
		}

		/// <summary>Adds the width and height of one <see cref="T:System.Drawing.SizeF" /> structure to the width and height of another <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="sz1">The first <see cref="T:System.Drawing.SizeF" /> structure to add.</param>
		/// <param name="sz2">The second <see cref="T:System.Drawing.SizeF" /> structure to add.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure that is the result of the addition operation.</returns>
		public static SizeF operator +(SizeF sz1, SizeF sz2)
		{
			return Add(sz1, sz2);
		}

		/// <summary>Subtracts the width and height of one <see cref="T:System.Drawing.SizeF" /> structure from the width and height of another <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.SizeF" /> structure on the left side of the subtraction operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.SizeF" /> structure on the right side of the subtraction operator.</param>
		/// <returns>A <see cref="T:System.Drawing.SizeF" /> that is the result of the subtraction operation.</returns>
		public static SizeF operator -(SizeF sz1, SizeF sz2)
		{
			return Subtract(sz1, sz2);
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.SizeF" /> structures are equal.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.SizeF" /> structure on the left side of the equality operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.SizeF" /> structure on the right of the equality operator.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="sz1" /> and <paramref name="sz2" /> have equal width and height; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(SizeF sz1, SizeF sz2)
		{
			if (sz1.Width == sz2.Width)
			{
				return sz1.Height == sz2.Height;
			}
			return false;
		}

		/// <summary>Tests whether two <see cref="T:System.Drawing.SizeF" /> structures are different.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.SizeF" /> structure on the left of the inequality operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.SizeF" /> structure on the right of the inequality operator.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="sz1" /> and <paramref name="sz2" /> differ either in width or height; <see langword="false" /> if <paramref name="sz1" /> and <paramref name="sz2" /> are equal.</returns>
		public static bool operator !=(SizeF sz1, SizeF sz2)
		{
			return !(sz1 == sz2);
		}

		/// <summary>Converts the specified <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.PointF" /> structure.</summary>
		/// <param name="size">The <see cref="T:System.Drawing.SizeF" /> structure to be converted</param>
		/// <returns>The <see cref="T:System.Drawing.PointF" /> structure to which this operator converts.</returns>
		public static explicit operator PointF(SizeF size)
		{
			return new PointF(size.Width, size.Height);
		}

		/// <summary>Adds the width and height of one <see cref="T:System.Drawing.SizeF" /> structure to the width and height of another <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="sz1">The first <see cref="T:System.Drawing.SizeF" /> structure to add.</param>
		/// <param name="sz2">The second <see cref="T:System.Drawing.SizeF" /> structure to add.</param>
		/// <returns>A <see cref="T:System.Drawing.SizeF" /> structure that is the result of the addition operation.</returns>
		public static SizeF Add(SizeF sz1, SizeF sz2)
		{
			return new SizeF(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
		}

		/// <summary>Subtracts the width and height of one <see cref="T:System.Drawing.SizeF" /> structure from the width and height of another <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="sz1">The <see cref="T:System.Drawing.SizeF" /> structure on the left side of the subtraction operator.</param>
		/// <param name="sz2">The <see cref="T:System.Drawing.SizeF" /> structure on the right side of the subtraction operator.</param>
		/// <returns>A <see cref="T:System.Drawing.SizeF" /> structure that is a result of the subtraction operation.</returns>
		public static SizeF Subtract(SizeF sz1, SizeF sz2)
		{
			return new SizeF(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
		}

		/// <summary>Tests to see whether the specified object is a <see cref="T:System.Drawing.SizeF" /> structure with the same dimensions as this <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <param name="obj">The <see cref="T:System.Object" /> to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.Drawing.SizeF" /> and has the same width and height as this <see cref="T:System.Drawing.SizeF" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is SizeF sizeF))
			{
				return false;
			}
			if (sizeF.Width == Width && sizeF.Height == Height)
			{
				return sizeF.GetType().Equals(GetType());
			}
			return false;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>An integer value that specifies a hash value for this <see cref="T:System.Drawing.Size" /> structure.</returns>
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		/// <summary>Converts a <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.PointF" /> structure.</summary>
		/// <returns>A <see cref="T:System.Drawing.PointF" /> structure.</returns>
		public PointF ToPointF()
		{
			return (PointF)this;
		}

		/// <summary>Converts a <see cref="T:System.Drawing.SizeF" /> structure to a <see cref="T:System.Drawing.Size" /> structure.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> structure.</returns>
		public Size ToSize()
		{
			return Size.Truncate(this);
		}

		/// <summary>Creates a human-readable string that represents this <see cref="T:System.Drawing.SizeF" /> structure.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.SizeF" /> structure.</returns>
		public override string ToString()
		{
			return "{Width=" + width.ToString(CultureInfo.CurrentCulture) + ", Height=" + height.ToString(CultureInfo.CurrentCulture) + "}";
		}
	}
	/// <summary>Converts <see cref="T:System.Drawing.SizeF" /> objects from one type to another.</summary>
	public class SizeFConverter : TypeConverter
	{
		/// <summary>Returns a value indicating whether the converter can convert from the type specified to the <see cref="T:System.Drawing.SizeF" /> type, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be supplied.</param>
		/// <param name="sourceType">A <see cref="T:System.Type" /> the represents the type you wish to convert from.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the conversion can be performed; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Returns a value indicating whether the <see cref="T:System.Drawing.SizeFConverter" /> can convert a <see cref="T:System.Drawing.SizeF" /> to the specified type.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be supplied.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that represents the type you want to convert from.</param>
		/// <returns>
		///   <see langword="true" /> if this converter can perform the conversion otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the given object to the type of this converter, using the specified context and culture information.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">The <see cref="T:System.Globalization.CultureInfo" /> to use as the current culture.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to convert.</param>
		/// <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string[] array = text2.Split(c);
				float[] array2 = new float[array.Length];
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(float));
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (float)converter.ConvertFromString(context, culture, array[i]);
				}
				if (array2.Length == 2)
				{
					return new SizeF(array2[0], array2[1]);
				}
				throw new ArgumentException(SR.GetString("TextParseFailedFormat", text2, "Width,Height"));
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts the given value object to the specified type, using the specified context and culture information.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" />. If null is passed, the current culture is assumed.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to convert.</param>
		/// <param name="destinationType">The <see cref="T:System.Type" /> to convert the value parameter to.</param>
		/// <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (destinationType == typeof(string) && value is SizeF sizeF)
			{
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				string separator = culture.TextInfo.ListSeparator + " ";
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(float));
				string[] array = new string[2];
				int num = 0;
				array[num++] = converter.ConvertToString(context, culture, sizeF.Width);
				array[num++] = converter.ConvertToString(context, culture, sizeF.Height);
				return string.Join(separator, array);
			}
			if (destinationType == typeof(InstanceDescriptor) && value is SizeF sizeF2)
			{
				ConstructorInfo constructor = typeof(SizeF).GetConstructor(new Type[2]
				{
					typeof(float),
					typeof(float)
				});
				if (constructor != null)
				{
					return new InstanceDescriptor(constructor, new object[2] { sizeF2.Width, sizeF2.Height });
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Creates an instance of a <see cref="T:System.Drawing.SizeF" /> with the specified property values using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be supplied.</param>
		/// <param name="propertyValues">An <see cref="T:System.Collections.IDictionary" /> containing property names and values.</param>
		/// <returns>An <see cref="T:System.Object" /> representing the new <see cref="T:System.Drawing.SizeF" />, or <see langword="null" /> if the object cannot be created.</returns>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			return new SizeF((float)propertyValues["Width"], (float)propertyValues["Height"]);
		}

		/// <summary>Returns a value indicating whether changing a value on this object requires a call to the <see cref="Overload:System.Drawing.SizeFConverter.CreateInstance" /> method to create a new value.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context. This may be <see langword="null" />.</param>
		/// <returns>Always returns <see langword="true" />.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Retrieves a set of properties for the <see cref="T:System.Drawing.SizeF" /> type using the specified context and attributes.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be supplied.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to return properties for.</param>
		/// <param name="attributes">An array of <see cref="T:System.Attribute" /> objects that describe the properties.</param>
		/// <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> containing the properties.</returns>
		public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
		{
			PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(typeof(SizeF), attributes);
			return properties.Sort(new string[2] { "Width", "Height" });
		}

		/// <summary>Returns whether the <see cref="T:System.Drawing.SizeF" /> type supports properties.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> through which additional context can be supplied.</param>
		/// <returns>Always returns <see langword="true" />.</returns>
		public override bool GetPropertiesSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.SizeFConverter" /> class.</summary>
		public SizeFConverter()
		{
		}
	}
	/// <summary>Specifies the alignment of a text string relative to its layout rectangle.</summary>
	public enum StringAlignment
	{
		/// <summary>Specifies the text be aligned near the layout. In a left-to-right layout, the near position is left. In a right-to-left layout, the near position is right.</summary>
		Near,
		/// <summary>Specifies that text is aligned in the center of the layout rectangle.</summary>
		Center,
		/// <summary>Specifies that text is aligned far from the origin position of the layout rectangle. In a left-to-right layout, the far position is right. In a right-to-left layout, the far position is left.</summary>
		Far
	}
	/// <summary>The <see cref="T:System.Drawing.StringDigitSubstitute" /> enumeration specifies how to substitute digits in a string according to a user's locale or language.</summary>
	public enum StringDigitSubstitute
	{
		/// <summary>Specifies a user-defined substitution scheme.</summary>
		User,
		/// <summary>Specifies to disable substitutions.</summary>
		None,
		/// <summary>Specifies substitution digits that correspond with the official national language of the user's locale.</summary>
		National,
		/// <summary>Specifies substitution digits that correspond with the user's native script or language, which may be different from the official national language of the user's locale.</summary>
		Traditional
	}
	/// <summary>Specifies a range of character positions within a string.</summary>
	public struct CharacterRange
	{
		private int first;

		private int length;

		/// <summary>Gets or sets the position in the string of the first character of this <see cref="T:System.Drawing.CharacterRange" />.</summary>
		/// <returns>The first position of this <see cref="T:System.Drawing.CharacterRange" />.</returns>
		public int First
		{
			get
			{
				return first;
			}
			set
			{
				first = value;
			}
		}

		/// <summary>Gets or sets the number of positions in this <see cref="T:System.Drawing.CharacterRange" />.</summary>
		/// <returns>The number of positions in this <see cref="T:System.Drawing.CharacterRange" />.</returns>
		public int Length
		{
			get
			{
				return length;
			}
			set
			{
				length = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.CharacterRange" /> structure, specifying a range of character positions within a string.</summary>
		/// <param name="First">The position of the first character in the range. For example, if <paramref name="First" /> is set to 0, the first position of the range is position 0 in the string.</param>
		/// <param name="Length">The number of positions in the range.</param>
		public CharacterRange(int First, int Length)
		{
			first = First;
			length = Length;
		}

		/// <summary>Gets a value indicating whether this object is equivalent to the specified object.</summary>
		/// <param name="obj">The object to compare to for equality.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the specified object is an instance with the same <see cref="P:System.Drawing.CharacterRange.First" /> and <see cref="P:System.Drawing.CharacterRange.Length" /> value as this instance; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (obj.GetType() != typeof(CharacterRange))
			{
				return false;
			}
			CharacterRange characterRange = (CharacterRange)obj;
			if (first == characterRange.First)
			{
				return length == characterRange.Length;
			}
			return false;
		}

		/// <summary>Compares two <see cref="T:System.Drawing.CharacterRange" /> objects. Gets a value indicating whether the <see cref="P:System.Drawing.CharacterRange.First" /> and <see cref="P:System.Drawing.CharacterRange.Length" /> values of the two <see cref="T:System.Drawing.CharacterRange" /> objects are equal.</summary>
		/// <param name="cr1">A <see cref="T:System.Drawing.CharacterRange" /> to compare for equality.</param>
		/// <param name="cr2">A <see cref="T:System.Drawing.CharacterRange" /> to compare for equality.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the two <see cref="T:System.Drawing.CharacterRange" /> objects have the same <see cref="P:System.Drawing.CharacterRange.First" /> and <see cref="P:System.Drawing.CharacterRange.Length" /> values; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(CharacterRange cr1, CharacterRange cr2)
		{
			if (cr1.First == cr2.First)
			{
				return cr1.Length == cr2.Length;
			}
			return false;
		}

		/// <summary>Compares two <see cref="T:System.Drawing.CharacterRange" /> objects. Gets a value indicating whether the <see cref="P:System.Drawing.CharacterRange.First" /> or <see cref="P:System.Drawing.CharacterRange.Length" /> values of the two <see cref="T:System.Drawing.CharacterRange" /> objects are not equal.</summary>
		/// <param name="cr1">A <see cref="T:System.Drawing.CharacterRange" /> to compare for inequality.</param>
		/// <param name="cr2">A <see cref="T:System.Drawing.CharacterRange" /> to compare for inequality.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the either the <see cref="P:System.Drawing.CharacterRange.First" /> or <see cref="P:System.Drawing.CharacterRange.Length" /> values of the two <see cref="T:System.Drawing.CharacterRange" /> objects differ; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(CharacterRange cr1, CharacterRange cr2)
		{
			return !(cr1 == cr2);
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
		public override int GetHashCode()
		{
			return first << 8 + length;
		}
	}
	/// <summary>Encapsulates text layout information (such as alignment, orientation and tab stops) display manipulations (such as ellipsis insertion and national digit substitution) and OpenType features. This class cannot be inherited.</summary>
	public sealed class StringFormat : MarshalByRefObject, ICloneable, IDisposable
	{
		internal IntPtr nativeFormat;

		/// <summary>Gets or sets a <see cref="T:System.Drawing.StringFormatFlags" /> enumeration that contains formatting information.</summary>
		/// <returns>A <see cref="T:System.Drawing.StringFormatFlags" /> enumeration that contains formatting information.</returns>
		public StringFormatFlags FormatFlags
		{
			get
			{
				StringFormatFlags result;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatFlags(new HandleRef(this, nativeFormat), out result);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return result;
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetStringFormatFlags(new HandleRef(this, nativeFormat), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets horizontal alignment of the string.</summary>
		/// <returns>A <see cref="T:System.Drawing.StringAlignment" /> enumeration that specifies the horizontal  alignment of the string.</returns>
		public StringAlignment Alignment
		{
			get
			{
				StringAlignment align = StringAlignment.Near;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatAlign(new HandleRef(this, nativeFormat), out align);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return align;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 2))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(StringAlignment));
				}
				int num = SafeNativeMethods.Gdip.GdipSetStringFormatAlign(new HandleRef(this, nativeFormat), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the vertical alignment of the string.</summary>
		/// <returns>A <see cref="T:System.Drawing.StringAlignment" /> enumeration that represents the vertical line alignment.</returns>
		public StringAlignment LineAlignment
		{
			get
			{
				StringAlignment align = StringAlignment.Near;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatLineAlign(new HandleRef(this, nativeFormat), out align);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return align;
			}
			set
			{
				if (value < StringAlignment.Near || value > StringAlignment.Far)
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(StringAlignment));
				}
				int num = SafeNativeMethods.Gdip.GdipSetStringFormatLineAlign(new HandleRef(this, nativeFormat), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Drawing.Text.HotkeyPrefix" /> object for this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.Text.HotkeyPrefix" /> object for this <see cref="T:System.Drawing.StringFormat" /> object, the default is <see cref="F:System.Drawing.Text.HotkeyPrefix.None" />.</returns>
		public HotkeyPrefix HotkeyPrefix
		{
			get
			{
				HotkeyPrefix hotkeyPrefix;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatHotkeyPrefix(new HandleRef(this, nativeFormat), out hotkeyPrefix);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return hotkeyPrefix;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 2))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(HotkeyPrefix));
				}
				int num = SafeNativeMethods.Gdip.GdipSetStringFormatHotkeyPrefix(new HandleRef(this, nativeFormat), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Drawing.StringTrimming" /> enumeration for this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.StringTrimming" /> enumeration that indicates how text drawn with this <see cref="T:System.Drawing.StringFormat" /> object is trimmed when it exceeds the edges of the layout rectangle.</returns>
		public StringTrimming Trimming
		{
			get
			{
				StringTrimming trimming;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatTrimming(new HandleRef(this, nativeFormat), out trimming);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return trimming;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 5))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(StringTrimming));
				}
				int num = SafeNativeMethods.Gdip.GdipSetStringFormatTrimming(new HandleRef(this, nativeFormat), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets a generic default <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <returns>The generic default <see cref="T:System.Drawing.StringFormat" /> object.</returns>
		public static StringFormat GenericDefault
		{
			get
			{
				IntPtr format;
				int num = SafeNativeMethods.Gdip.GdipStringFormatGetGenericDefault(out format);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return new StringFormat(format);
			}
		}

		/// <summary>Gets a generic typographic <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <returns>A generic typographic <see cref="T:System.Drawing.StringFormat" /> object.</returns>
		public static StringFormat GenericTypographic
		{
			get
			{
				IntPtr format;
				int num = SafeNativeMethods.Gdip.GdipStringFormatGetGenericTypographic(out format);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return new StringFormat(format);
			}
		}

		/// <summary>Gets the method to be used for digit substitution.</summary>
		/// <returns>A <see cref="T:System.Drawing.StringDigitSubstitute" /> enumeration value that specifies how to substitute characters in a string that cannot be displayed because they are not supported by the current font.</returns>
		public StringDigitSubstitute DigitSubstitutionMethod
		{
			get
			{
				int langID = 0;
				StringDigitSubstitute sds;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatDigitSubstitution(new HandleRef(this, nativeFormat), out langID, out sds);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return sds;
			}
		}

		/// <summary>Gets the language that is used when local digits are substituted for western digits.</summary>
		/// <returns>A National Language Support (NLS) language identifier that identifies the language that will be used when local digits are substituted for western digits. You can pass the <see cref="P:System.Globalization.CultureInfo.LCID" /> property of a <see cref="T:System.Globalization.CultureInfo" /> object as the NLS language identifier. For example, suppose you create a <see cref="T:System.Globalization.CultureInfo" /> object by passing the string "ar-EG" to a <see cref="T:System.Globalization.CultureInfo" /> constructor. If you pass the <see cref="P:System.Globalization.CultureInfo.LCID" /> property of that <see cref="T:System.Globalization.CultureInfo" /> object along with <see cref="F:System.Drawing.StringDigitSubstitute.Traditional" /> to the <see cref="M:System.Drawing.StringFormat.SetDigitSubstitution(System.Int32,System.Drawing.StringDigitSubstitute)" /> method, then Arabic-Indic digits will be substituted for western digits at display time.</returns>
		public int DigitSubstitutionLanguage
		{
			get
			{
				int langID = 0;
				StringDigitSubstitute sds;
				int num = SafeNativeMethods.Gdip.GdipGetStringFormatDigitSubstitution(new HandleRef(this, nativeFormat), out langID, out sds);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return langID;
			}
		}

		private StringFormat(IntPtr format)
		{
			nativeFormat = format;
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		public StringFormat()
			: this((StringFormatFlags)0, 0)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.StringFormat" /> object with the specified <see cref="T:System.Drawing.StringFormatFlags" /> enumeration.</summary>
		/// <param name="options">The <see cref="T:System.Drawing.StringFormatFlags" /> enumeration for the new <see cref="T:System.Drawing.StringFormat" /> object.</param>
		public StringFormat(StringFormatFlags options)
			: this(options, 0)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.StringFormat" /> object with the specified <see cref="T:System.Drawing.StringFormatFlags" /> enumeration and language.</summary>
		/// <param name="options">The <see cref="T:System.Drawing.StringFormatFlags" /> enumeration for the new <see cref="T:System.Drawing.StringFormat" /> object.</param>
		/// <param name="language">A value that indicates the language of the text.</param>
		public StringFormat(StringFormatFlags options, int language)
		{
			int num = SafeNativeMethods.Gdip.GdipCreateStringFormat(options, language, out nativeFormat);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.StringFormat" /> object from the specified existing <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <param name="format">The <see cref="T:System.Drawing.StringFormat" /> object from which to initialize the new <see cref="T:System.Drawing.StringFormat" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="format" /> is <see langword="null" />.</exception>
		public StringFormat(StringFormat format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			int num = SafeNativeMethods.Gdip.GdipCloneStringFormat(new HandleRef(format, format.nativeFormat), out nativeFormat);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeFormat != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeleteStringFormat(new HandleRef(this, nativeFormat));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeFormat = IntPtr.Zero;
			}
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.StringFormat" /> object this method creates.</returns>
		public object Clone()
		{
			IntPtr newFormat = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneStringFormat(new HandleRef(this, nativeFormat), out newFormat);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new StringFormat(newFormat);
		}

		/// <summary>Specifies an array of <see cref="T:System.Drawing.CharacterRange" /> structures that represent the ranges of characters measured by a call to the <see cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" /> method.</summary>
		/// <param name="ranges">An array of <see cref="T:System.Drawing.CharacterRange" /> structures that specifies the ranges of characters measured by a call to the <see cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" /> method.</param>
		/// <exception cref="T:System.OverflowException">More than 32 character ranges are set.</exception>
		public void SetMeasurableCharacterRanges(CharacterRange[] ranges)
		{
			int num = SafeNativeMethods.Gdip.GdipSetStringFormatMeasurableCharacterRanges(new HandleRef(this, nativeFormat), ranges.Length, ranges);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets tab stops for this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <param name="firstTabOffset">The number of spaces between the beginning of a line of text and the first tab stop.</param>
		/// <param name="tabStops">An array of distances between tab stops in the units specified by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property.</param>
		public void SetTabStops(float firstTabOffset, float[] tabStops)
		{
			if (firstTabOffset < 0f)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "firstTabOffset", firstTabOffset));
			}
			int num = SafeNativeMethods.Gdip.GdipSetStringFormatTabStops(new HandleRef(this, nativeFormat), firstTabOffset, tabStops.Length, tabStops);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Gets the tab stops for this <see cref="T:System.Drawing.StringFormat" /> object.</summary>
		/// <param name="firstTabOffset">The number of spaces between the beginning of a text line and the first tab stop.</param>
		/// <returns>An array of distances (in number of spaces) between tab stops.</returns>
		public float[] GetTabStops(out float firstTabOffset)
		{
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetStringFormatTabStopCount(new HandleRef(this, nativeFormat), out count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			float[] array = new float[count];
			num = SafeNativeMethods.Gdip.GdipGetStringFormatTabStops(new HandleRef(this, nativeFormat), count, out firstTabOffset, array);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return array;
		}

		/// <summary>Specifies the language and method to be used when local digits are substituted for western digits.</summary>
		/// <param name="language">A National Language Support (NLS) language identifier that identifies the language that will be used when local digits are substituted for western digits. You can pass the <see cref="P:System.Globalization.CultureInfo.LCID" /> property of a <see cref="T:System.Globalization.CultureInfo" /> object as the NLS language identifier. For example, suppose you create a <see cref="T:System.Globalization.CultureInfo" /> object by passing the string "ar-EG" to a <see cref="T:System.Globalization.CultureInfo" /> constructor. If you pass the <see cref="P:System.Globalization.CultureInfo.LCID" /> property of that <see cref="T:System.Globalization.CultureInfo" /> object along with <see cref="F:System.Drawing.StringDigitSubstitute.Traditional" /> to the <see cref="M:System.Drawing.StringFormat.SetDigitSubstitution(System.Int32,System.Drawing.StringDigitSubstitute)" /> method, then Arabic-Indic digits will be substituted for western digits at display time.</param>
		/// <param name="substitute">An element of the <see cref="T:System.Drawing.StringDigitSubstitute" /> enumeration that specifies how digits are displayed.</param>
		public void SetDigitSubstitution(int language, StringDigitSubstitute substitute)
		{
			int num = SafeNativeMethods.Gdip.GdipSetStringFormatDigitSubstitution(new HandleRef(this, nativeFormat), language, substitute);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~StringFormat()
		{
			Dispose(disposing: false);
		}

		/// <summary>Converts this <see cref="T:System.Drawing.StringFormat" /> object to a human-readable string.</summary>
		/// <returns>A string representation of this <see cref="T:System.Drawing.StringFormat" /> object.</returns>
		public override string ToString()
		{
			return "[StringFormat, FormatFlags=" + FormatFlags.ToString() + "]";
		}
	}
	/// <summary>Specifies the display and layout information for text strings.</summary>
	[Flags]
	public enum StringFormatFlags
	{
		/// <summary>Text is displayed from right to left.</summary>
		DirectionRightToLeft = 1,
		/// <summary>Text is vertically aligned.</summary>
		DirectionVertical = 2,
		/// <summary>Parts of characters are allowed to overhang the string's layout rectangle. By default, characters are repositioned to avoid any overhang.</summary>
		FitBlackBox = 4,
		/// <summary>Control characters such as the left-to-right mark are shown in the output with a representative glyph.</summary>
		DisplayFormatControl = 0x20,
		/// <summary>Fallback to alternate fonts for characters not supported in the requested font is disabled. Any missing characters are displayed with the fonts missing glyph, usually an open square.</summary>
		NoFontFallback = 0x400,
		/// <summary>Includes the trailing space at the end of each line. By default the boundary rectangle returned by the <see cref="Overload:System.Drawing.Graphics.MeasureString" /> method excludes the space at the end of each line. Set this flag to include that space in measurement.</summary>
		MeasureTrailingSpaces = 0x800,
		/// <summary>Text wrapping between lines when formatting within a rectangle is disabled. This flag is implied when a point is passed instead of a rectangle, or when the specified rectangle has a zero line length.</summary>
		NoWrap = 0x1000,
		/// <summary>Only entire lines are laid out in the formatting rectangle. By default layout continues until the end of the text, or until no more lines are visible as a result of clipping, whichever comes first. Note that the default settings allow the last line to be partially obscured by a formatting rectangle that is not a whole multiple of the line height. To ensure that only whole lines are seen, specify this value and be careful to provide a formatting rectangle at least as tall as the height of one line.</summary>
		LineLimit = 0x2000,
		/// <summary>Overhanging parts of glyphs, and unwrapped text reaching outside the formatting rectangle are allowed to show. By default all text and glyph parts reaching outside the formatting rectangle are clipped.</summary>
		NoClip = 0x4000
	}
	/// <summary>Specifies how to trim characters from a string that does not completely fit into a layout shape.</summary>
	public enum StringTrimming
	{
		/// <summary>Specifies no trimming.</summary>
		None,
		/// <summary>Specifies that the text is trimmed to the nearest character.</summary>
		Character,
		/// <summary>Specifies that text is trimmed to the nearest word.</summary>
		Word,
		/// <summary>Specifies that the text is trimmed to the nearest character, and an ellipsis is inserted at the end of a trimmed line.</summary>
		EllipsisCharacter,
		/// <summary>Specifies that text is trimmed to the nearest word, and an ellipsis is inserted at the end of a trimmed line.</summary>
		EllipsisWord,
		/// <summary>The center is removed from trimmed lines and replaced by an ellipsis. The algorithm keeps as much of the last slash-delimited segment of the line as possible.</summary>
		EllipsisPath
	}
	/// <summary>Specifies the units of measure for a text string.</summary>
	public enum StringUnit
	{
		/// <summary>Specifies world units as the unit of measure.</summary>
		World = 0,
		/// <summary>Specifies the device unit as the unit of measure.</summary>
		Display = 1,
		/// <summary>Specifies a pixel as the unit of measure.</summary>
		Pixel = 2,
		/// <summary>Specifies a printer's point (1/72 inch) as the unit of measure.</summary>
		Point = 3,
		/// <summary>Specifies an inch as the unit of measure.</summary>
		Inch = 4,
		/// <summary>Specifies 1/300 of an inch as the unit of measure.</summary>
		Document = 5,
		/// <summary>Specifies a millimeter as the unit of measure</summary>
		Millimeter = 6,
		/// <summary>Specifies a printer's em size of 32 as the unit of measure.</summary>
		Em = 32
	}
	/// <summary>Each property of the <see cref="T:System.Drawing.TextureBrush" /> class is a <see cref="T:System.Drawing.Brush" /> object that uses an image to fill the interior of a shape. This class cannot be inherited.</summary>
	public sealed class TextureBrush : Brush
	{
		/// <summary>Gets or sets a copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> object that defines a local geometric transformation for the image associated with this <see cref="T:System.Drawing.TextureBrush" /> object.</summary>
		/// <returns>A copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> object that defines a geometric transformation that applies only to fills drawn by using this <see cref="T:System.Drawing.TextureBrush" /> object.</returns>
		public Matrix Transform
		{
			get
			{
				return _GetTransform();
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				_SetTransform(value);
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that indicates the wrap mode for this <see cref="T:System.Drawing.TextureBrush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that specifies how fills drawn by using this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> object are tiled.</returns>
		public WrapMode WrapMode
		{
			get
			{
				return _GetWrapMode();
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(WrapMode));
				}
				_SetWrapMode(value);
			}
		}

		/// <summary>Gets the <see cref="T:System.Drawing.Image" /> object associated with this <see cref="T:System.Drawing.TextureBrush" /> object.</summary>
		/// <returns>An <see cref="T:System.Drawing.Image" /> object that represents the image with which this <see cref="T:System.Drawing.TextureBrush" /> object fills shapes.</returns>
		public Image Image
		{
			get
			{
				IntPtr image;
				int num = SafeNativeMethods.Gdip.GdipGetTextureImage(new HandleRef(this, base.NativeBrush), out image);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return Image.CreateImageObject(image);
			}
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image.</summary>
		/// <param name="bitmap">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		public TextureBrush(Image bitmap)
			: this(bitmap, WrapMode.Tile)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image and wrap mode.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="wrapMode">A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that specifies how this <see cref="T:System.Drawing.TextureBrush" /> object is tiled.</param>
		public TextureBrush(Image image, WrapMode wrapMode)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (!ClientUtils.IsEnumValid(wrapMode, (int)wrapMode, 0, 4))
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr texture = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateTexture(new HandleRef(image, image.nativeImage), (int)wrapMode, out texture);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(texture);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image, wrap mode, and bounding rectangle.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="wrapMode">A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that specifies how this <see cref="T:System.Drawing.TextureBrush" /> object is tiled.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, WrapMode wrapMode, RectangleF dstRect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (!ClientUtils.IsEnumValid(wrapMode, (int)wrapMode, 0, 4))
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr texture = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateTexture2(new HandleRef(image, image.nativeImage), (int)wrapMode, dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(texture);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image, wrap mode, and bounding rectangle.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="wrapMode">A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that specifies how this <see cref="T:System.Drawing.TextureBrush" /> object is tiled.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, WrapMode wrapMode, Rectangle dstRect)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			if (!ClientUtils.IsEnumValid(wrapMode, (int)wrapMode, 0, 4))
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr texture = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateTexture2I(new HandleRef(image, image.nativeImage), (int)wrapMode, dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(texture);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image and bounding rectangle.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, RectangleF dstRect)
			: this(image, dstRect, null)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image, bounding rectangle, and image attributes.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.RectangleF" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		/// <param name="imageAttr">An <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object that contains additional information about the image used by this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, RectangleF dstRect, ImageAttributes imageAttr)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			IntPtr texture = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateTextureIA(new HandleRef(image, image.nativeImage), new HandleRef(imageAttr, imageAttr?.nativeImageAttributes ?? IntPtr.Zero), dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(texture);
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image and bounding rectangle.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, Rectangle dstRect)
			: this(image, dstRect, null)
		{
		}

		/// <summary>Initializes a new <see cref="T:System.Drawing.TextureBrush" /> object that uses the specified image, bounding rectangle, and image attributes.</summary>
		/// <param name="image">The <see cref="T:System.Drawing.Image" /> object with which this <see cref="T:System.Drawing.TextureBrush" /> object fills interiors.</param>
		/// <param name="dstRect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the bounding rectangle for this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		/// <param name="imageAttr">An <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object that contains additional information about the image used by this <see cref="T:System.Drawing.TextureBrush" /> object.</param>
		public TextureBrush(Image image, Rectangle dstRect, ImageAttributes imageAttr)
		{
			if (image == null)
			{
				throw new ArgumentNullException("image");
			}
			IntPtr texture = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateTextureIAI(new HandleRef(image, image.nativeImage), new HandleRef(imageAttr, imageAttr?.nativeImageAttributes ?? IntPtr.Zero), dstRect.X, dstRect.Y, dstRect.Width, dstRect.Height, out texture);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(texture);
		}

		internal TextureBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.TextureBrush" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.TextureBrush" /> object this method creates, cast as an <see cref="T:System.Object" /> object.</returns>
		public override object Clone()
		{
			IntPtr clonebrush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonebrush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new TextureBrush(clonebrush);
		}

		private void _SetTransform(Matrix matrix)
		{
			int num = SafeNativeMethods.Gdip.GdipSetTextureTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private Matrix _GetTransform()
		{
			Matrix matrix = new Matrix();
			int num = SafeNativeMethods.Gdip.GdipGetTextureTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return matrix;
		}

		private void _SetWrapMode(WrapMode wrapMode)
		{
			int num = SafeNativeMethods.Gdip.GdipSetTextureWrapMode(new HandleRef(this, base.NativeBrush), (int)wrapMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private WrapMode _GetWrapMode()
		{
			int wrapMode = 0;
			int num = SafeNativeMethods.Gdip.GdipGetTextureWrapMode(new HandleRef(this, base.NativeBrush), out wrapMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return (WrapMode)wrapMode;
		}

		/// <summary>Resets the <see langword="Transform" /> property of this <see cref="T:System.Drawing.TextureBrush" /> object to identity.</summary>
		public void ResetTransform()
		{
			int num = SafeNativeMethods.Gdip.GdipResetTextureTransform(new HandleRef(this, base.NativeBrush));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Multiplies the <see cref="T:System.Drawing.Drawing2D.Matrix" /> object that represents the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> object by prepending the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> object.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> object by which to multiply the geometric transformation.</param>
		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Multiplies the <see cref="T:System.Drawing.Drawing2D.Matrix" /> object that represents the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> object in the specified order.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> object by which to multiply the geometric transformation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies the order in which to multiply the two matrices.</param>
		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipMultiplyTextureTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Translates the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified dimensions. This method prepends the translation to the transformation.</summary>
		/// <param name="dx">The dimension by which to translate the transformation in the x direction.</param>
		/// <param name="dy">The dimension by which to translate the transformation in the y direction.</param>
		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		/// <summary>Translates the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified dimensions in the specified order.</summary>
		/// <param name="dx">The dimension by which to translate the transformation in the x direction.</param>
		/// <param name="dy">The dimension by which to translate the transformation in the y direction.</param>
		/// <param name="order">The order (prepend or append) in which to apply the translation.</param>
		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateTextureTransform(new HandleRef(this, base.NativeBrush), dx, dy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Scales the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified amounts. This method prepends the scaling matrix to the transformation.</summary>
		/// <param name="sx">The amount by which to scale the transformation in the x direction.</param>
		/// <param name="sy">The amount by which to scale the transformation in the y direction.</param>
		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		/// <summary>Scales the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified amounts in the specified order.</summary>
		/// <param name="sx">The amount by which to scale the transformation in the x direction.</param>
		/// <param name="sy">The amount by which to scale the transformation in the y direction.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies whether to append or prepend the scaling matrix.</param>
		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScaleTextureTransform(new HandleRef(this, base.NativeBrush), sx, sy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Rotates the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified amount. This method prepends the rotation to the transformation.</summary>
		/// <param name="angle">The angle of rotation.</param>
		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		/// <summary>Rotates the local geometric transformation of this <see cref="T:System.Drawing.TextureBrush" /> object by the specified amount in the specified order.</summary>
		/// <param name="angle">The angle of rotation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> enumeration that specifies whether to append or prepend the rotation matrix.</param>
		public void RotateTransform(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotateTextureTransform(new HandleRef(this, base.NativeBrush), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
	/// <summary>Specifies the unit of measure for the given data.</summary>
	public enum GraphicsUnit
	{
		/// <summary>Specifies the world coordinate system unit as the unit of measure.</summary>
		World,
		/// <summary>Specifies the unit of measure of the display device. Typically pixels for video displays, and 1/100 inch for printers.</summary>
		Display,
		/// <summary>Specifies a device pixel as the unit of measure.</summary>
		Pixel,
		/// <summary>Specifies a printer's point (1/72 inch) as the unit of measure.</summary>
		Point,
		/// <summary>Specifies the inch as the unit of measure.</summary>
		Inch,
		/// <summary>Specifies the document unit (1/300 inch) as the unit of measure.</summary>
		Document,
		/// <summary>Specifies the millimeter as the unit of measure.</summary>
		Millimeter
	}
	/// <summary>Defines methods for obtaining and releasing an existing handle to a Windows device context.</summary>
	public interface IDeviceContext : IDisposable
	{
		/// <summary>Returns the handle to a Windows device context.</summary>
		/// <returns>An <see cref="T:System.IntPtr" /> representing the handle of a device context.</returns>
		[SecurityPermission(SecurityAction.InheritanceDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		IntPtr GetHdc();

		/// <summary>Releases the handle of a Windows device context.</summary>
		[SecurityPermission(SecurityAction.InheritanceDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
		void ReleaseHdc();
	}
	internal class PrintPreviewGraphics
	{
		private PrintPageEventArgs printPageEventArgs;

		private PrintDocument printDocument;

		public RectangleF VisibleClipBounds
		{
			get
			{
				IntPtr hdevmodeInternal = printPageEventArgs.PageSettings.PrinterSettings.GetHdevmodeInternal();
				using DeviceContext deviceContext = printPageEventArgs.PageSettings.PrinterSettings.CreateDeviceContext(hdevmodeInternal);
				using Graphics graphics = Graphics.FromHdcInternal(deviceContext.Hdc);
				if (printDocument.OriginAtMargins)
				{
					int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 88);
					int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 90);
					int deviceCaps3 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 112);
					int deviceCaps4 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 113);
					float num = deviceCaps3 * 100 / deviceCaps;
					float num2 = deviceCaps4 * 100 / deviceCaps2;
					graphics.TranslateTransform(0f - num, 0f - num2);
					graphics.TranslateTransform(printDocument.DefaultPageSettings.Margins.Left, printDocument.DefaultPageSettings.Margins.Top);
				}
				return graphics.VisibleClipBounds;
			}
		}

		public PrintPreviewGraphics(PrintDocument document, PrintPageEventArgs e)
		{
			printPageEventArgs = e;
			printDocument = document;
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRDescriptionAttribute : DescriptionAttribute
	{
		private bool replaced;

		public override string Description
		{
			get
			{
				if (!replaced)
				{
					replaced = true;
					base.DescriptionValue = SR.GetString(base.Description);
				}
				return base.Description;
			}
		}

		public SRDescriptionAttribute(string description)
			: base(description)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	internal sealed class SRCategoryAttribute : CategoryAttribute
	{
		public SRCategoryAttribute(string category)
			: base(category)
		{
		}

		protected override string GetLocalizedString(string value)
		{
			return SR.GetString(value);
		}
	}
	internal sealed class SR
	{
		internal const string CantTellPrinterName = "CantTellPrinterName";

		internal const string CantChangeImmutableObjects = "CantChangeImmutableObjects";

		internal const string CantMakeIconTransparent = "CantMakeIconTransparent";

		internal const string ColorNotSystemColor = "ColorNotSystemColor";

		internal const string DotNET_ComponentType = "DotNET_ComponentType";

		internal const string GdiplusAborted = "GdiplusAborted";

		internal const string GdiplusAccessDenied = "GdiplusAccessDenied";

		internal const string GdiplusCannotCreateGraphicsFromIndexedPixelFormat = "GdiplusCannotCreateGraphicsFromIndexedPixelFormat";

		internal const string GdiplusCannotSetPixelFromIndexedPixelFormat = "GdiplusCannotSetPixelFromIndexedPixelFormat";

		internal const string GdiplusDestPointsInvalidParallelogram = "GdiplusDestPointsInvalidParallelogram";

		internal const string GdiplusDestPointsInvalidLength = "GdiplusDestPointsInvalidLength";

		internal const string GdiplusFileNotFound = "GdiplusFileNotFound";

		internal const string GdiplusFontFamilyNotFound = "GdiplusFontFamilyNotFound";

		internal const string GdiplusFontStyleNotFound = "GdiplusFontStyleNotFound";

		internal const string GdiplusGenericError = "GdiplusGenericError";

		internal const string GdiplusInsufficientBuffer = "GdiplusInsufficientBuffer";

		internal const string GdiplusInvalidParameter = "GdiplusInvalidParameter";

		internal const string GdiplusInvalidRectangle = "GdiplusInvalidRectangle";

		internal const string GdiplusInvalidSize = "GdiplusInvalidSize";

		internal const string GdiplusOutOfMemory = "GdiplusOutOfMemory";

		internal const string GdiplusNotImplemented = "GdiplusNotImplemented";

		internal const string GdiplusNotInitialized = "GdiplusNotInitialized";

		internal const string GdiplusNotTrueTypeFont = "GdiplusNotTrueTypeFont";

		internal const string GdiplusNotTrueTypeFont_NoName = "GdiplusNotTrueTypeFont_NoName";

		internal const string GdiplusObjectBusy = "GdiplusObjectBusy";

		internal const string GdiplusOverflow = "GdiplusOverflow";

		internal const string GdiplusPropertyNotFoundError = "GdiplusPropertyNotFoundError";

		internal const string GdiplusPropertyNotSupportedError = "GdiplusPropertyNotSupportedError";

		internal const string GdiplusUnknown = "GdiplusUnknown";

		internal const string GdiplusUnknownImageFormat = "GdiplusUnknownImageFormat";

		internal const string GdiplusUnsupportedGdiplusVersion = "GdiplusUnsupportedGdiplusVersion";

		internal const string GdiplusWrongState = "GdiplusWrongState";

		internal const string GlobalAssemblyCache = "GlobalAssemblyCache";

		internal const string GraphicsBufferCurrentlyBusy = "GraphicsBufferCurrentlyBusy";

		internal const string GraphicsBufferQueryFail = "GraphicsBufferQueryFail";

		internal const string ToolboxItemLocked = "ToolboxItemLocked";

		internal const string ToolboxItemInvalidPropertyType = "ToolboxItemInvalidPropertyType";

		internal const string ToolboxItemValueNotSerializable = "ToolboxItemValueNotSerializable";

		internal const string ToolboxItemInvalidKey = "ToolboxItemInvalidKey";

		internal const string IllegalState = "IllegalState";

		internal const string InterpolationColorsColorBlendNotSet = "InterpolationColorsColorBlendNotSet";

		internal const string InterpolationColorsCommon = "InterpolationColorsCommon";

		internal const string InterpolationColorsInvalidColorBlendObject = "InterpolationColorsInvalidColorBlendObject";

		internal const string InterpolationColorsInvalidStartPosition = "InterpolationColorsInvalidStartPosition";

		internal const string InterpolationColorsInvalidEndPosition = "InterpolationColorsInvalidEndPosition";

		internal const string InterpolationColorsLength = "InterpolationColorsLength";

		internal const string InterpolationColorsLengthsDiffer = "InterpolationColorsLengthsDiffer";

		internal const string InvalidArgument = "InvalidArgument";

		internal const string InvalidBoundArgument = "InvalidBoundArgument";

		internal const string InvalidClassName = "InvalidClassName";

		internal const string InvalidColor = "InvalidColor";

		internal const string InvalidDashPattern = "InvalidDashPattern";

		internal const string InvalidEx2BoundArgument = "InvalidEx2BoundArgument";

		internal const string InvalidFrame = "InvalidFrame";

		internal const string InvalidGDIHandle = "InvalidGDIHandle";

		internal const string InvalidImage = "InvalidImage";

		internal const string InvalidLowBoundArgumentEx = "InvalidLowBoundArgumentEx";

		internal const string InvalidPermissionLevel = "InvalidPermissionLevel";

		internal const string InvalidPermissionState = "InvalidPermissionState";

		internal const string InvalidPictureType = "InvalidPictureType";

		internal const string InvalidPrinterException_InvalidPrinter = "InvalidPrinterException_InvalidPrinter";

		internal const string InvalidPrinterException_NoDefaultPrinter = "InvalidPrinterException_NoDefaultPrinter";

		internal const string InvalidPrinterHandle = "InvalidPrinterHandle";

		internal const string ValidRangeX = "ValidRangeX";

		internal const string ValidRangeY = "ValidRangeY";

		internal const string NativeHandle0 = "NativeHandle0";

		internal const string NoDefaultPrinter = "NoDefaultPrinter";

		internal const string NotImplemented = "NotImplemented";

		internal const string PDOCbeginPrintDescr = "PDOCbeginPrintDescr";

		internal const string PDOCdocumentNameDescr = "PDOCdocumentNameDescr";

		internal const string PDOCdocumentPageSettingsDescr = "PDOCdocumentPageSettingsDescr";

		internal const string PDOCendPrintDescr = "PDOCendPrintDescr";

		internal const string PDOCoriginAtMarginsDescr = "PDOCoriginAtMarginsDescr";

		internal const string PDOCprintControllerDescr = "PDOCprintControllerDescr";

		internal const string PDOCprintPageDescr = "PDOCprintPageDescr";

		internal const string PDOCprinterSettingsDescr = "PDOCprinterSettingsDescr";

		internal const string PDOCqueryPageSettingsDescr = "PDOCqueryPageSettingsDescr";

		internal const string PrintDocumentDesc = "PrintDocumentDesc";

		internal const string PrintingPermissionBadXml = "PrintingPermissionBadXml";

		internal const string PrintingPermissionAttributeInvalidPermissionLevel = "PrintingPermissionAttributeInvalidPermissionLevel";

		internal const string PropertyValueInvalidEntry = "PropertyValueInvalidEntry";

		internal const string PSizeNotCustom = "PSizeNotCustom";

		internal const string ResourceNotFound = "ResourceNotFound";

		internal const string TargetNotPrintingPermission = "TargetNotPrintingPermission";

		internal const string TextParseFailedFormat = "TextParseFailedFormat";

		internal const string TriStateCompareError = "TriStateCompareError";

		internal const string toStringIcon = "toStringIcon";

		internal const string toStringNone = "toStringNone";

		internal const string DCTypeInvalid = "DCTypeInvalid";

		private static SR loader;

		private ResourceManager resources;

		private static CultureInfo Culture => null;

		public static ResourceManager Resources => GetLoader().resources;

		internal SR()
		{
			resources = new ResourceManager("System.Drawing.Res", GetType().Assembly);
		}

		private static SR GetLoader()
		{
			if (loader == null)
			{
				SR value = new SR();
				Interlocked.CompareExchange(ref loader, value, null);
			}
			return loader;
		}

		public static string GetString(string name, params object[] args)
		{
			SR sR = GetLoader();
			if (sR == null)
			{
				return null;
			}
			string @string = sR.resources.GetString(name, Culture);
			if (args != null && args.Length != 0)
			{
				for (int i = 0; i < args.Length; i++)
				{
					if (args[i] is string text && text.Length > 1024)
					{
						args[i] = text.Substring(0, 1021) + "...";
					}
				}
				return string.Format(CultureInfo.CurrentCulture, @string, args);
			}
			return @string;
		}

		public static string GetString(string name)
		{
			return GetLoader()?.resources.GetString(name, Culture);
		}

		public static string GetString(string name, out bool usedFallback)
		{
			usedFallback = false;
			return GetString(name);
		}

		public static object GetObject(string name)
		{
			return GetLoader()?.resources.GetObject(name, Culture);
		}
	}
}
namespace System.Drawing.Printing
{
	/// <summary>Specifies a print controller that sends information to a printer.</summary>
	public class StandardPrintController : PrintController
	{
		private DeviceContext dc;

		private Graphics graphics;

		private void CheckSecurity(PrintDocument document)
		{
			if (document.PrinterSettings.PrintDialogDisplayed)
			{
				IntSecurity.SafePrinting.Demand();
			}
			else if (document.PrinterSettings.IsDefaultPrinter)
			{
				IntSecurity.DefaultPrinting.Demand();
			}
			else
			{
				IntSecurity.AllPrinting.Demand();
			}
		}

		/// <summary>Begins the control sequence that determines when and how to print a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains data about how to print the document.</param>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer settings are not valid.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The native Win32 Application Programming Interface (API) could not start a print job.</exception>
		public override void OnStartPrint(PrintDocument document, PrintEventArgs e)
		{
			CheckSecurity(document);
			base.OnStartPrint(document, e);
			if (!document.PrinterSettings.IsValid)
			{
				throw new InvalidPrinterException(document.PrinterSettings);
			}
			dc = document.PrinterSettings.CreateDeviceContext(modeHandle);
			SafeNativeMethods.DOCINFO dOCINFO = new SafeNativeMethods.DOCINFO();
			dOCINFO.lpszDocName = document.DocumentName;
			if (document.PrinterSettings.PrintToFile)
			{
				dOCINFO.lpszOutput = document.PrinterSettings.OutputPort;
			}
			else
			{
				dOCINFO.lpszOutput = null;
			}
			dOCINFO.lpszDatatype = null;
			dOCINFO.fwType = 0;
			int num = SafeNativeMethods.StartDoc(new HandleRef(dc, dc.Hdc), dOCINFO);
			if (num <= 0)
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error != 1223)
				{
					throw new Win32Exception(lastWin32Error);
				}
				e.Cancel = true;
			}
		}

		/// <summary>Begins the control sequence that determines when and how to print a page in a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains data about how to print a page in the document. Initially, the <see cref="P:System.Drawing.Printing.PrintPageEventArgs.Graphics" /> property of this parameter will be <see langword="null" />. The value returned from the <see cref="M:System.Drawing.Printing.StandardPrintController.OnStartPage(System.Drawing.Printing.PrintDocument,System.Drawing.Printing.PrintPageEventArgs)" /> method will be used to set this property.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> object that represents a page from a <see cref="T:System.Drawing.Printing.PrintDocument" />.</returns>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The native Win32 Application Programming Interface (API) could not prepare the printer driver to accept data.  
		///  -or-  
		///  The native Win32 API could not update the specified printer or plotter device context (DC) using the specified information.</exception>
		public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e)
		{
			CheckSecurity(document);
			base.OnStartPage(document, e);
			try
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				e.PageSettings.CopyToHdevmode(modeHandle);
				IntPtr handle = SafeNativeMethods.GlobalLock(new HandleRef(this, modeHandle));
				try
				{
					IntPtr intPtr = SafeNativeMethods.ResetDC(new HandleRef(dc, dc.Hdc), new HandleRef(null, handle));
				}
				finally
				{
					SafeNativeMethods.GlobalUnlock(new HandleRef(this, modeHandle));
				}
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
			graphics = Graphics.FromHdcInternal(dc.Hdc);
			if (graphics != null && document.OriginAtMargins)
			{
				int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 88);
				int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 90);
				int deviceCaps3 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 112);
				int deviceCaps4 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 113);
				float num = deviceCaps3 * 100 / deviceCaps;
				float num2 = deviceCaps4 * 100 / deviceCaps2;
				graphics.TranslateTransform(0f - num, 0f - num2);
				graphics.TranslateTransform(document.DefaultPageSettings.Margins.Left, document.DefaultPageSettings.Margins.Top);
			}
			int num3 = SafeNativeMethods.StartPage(new HandleRef(dc, dc.Hdc));
			if (num3 <= 0)
			{
				throw new Win32Exception();
			}
			return graphics;
		}

		/// <summary>Completes the control sequence that determines when and how to print a page of a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains data about how to print a page in the document.</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The native Win32 Application Programming Interface (API) could not finish writing to a page.</exception>
		public override void OnEndPage(PrintDocument document, PrintPageEventArgs e)
		{
			CheckSecurity(document);
			IntSecurity.UnmanagedCode.Assert();
			try
			{
				int num = SafeNativeMethods.EndPage(new HandleRef(dc, dc.Hdc));
				if (num <= 0)
				{
					throw new Win32Exception();
				}
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
				graphics.Dispose();
				graphics = null;
			}
			base.OnEndPage(document, e);
		}

		/// <summary>Completes the control sequence that determines when and how to print a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains data about how to print the document.</param>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The native Win32 Application Programming Interface (API) could not complete the print job.  
		///  -or-  
		///  The native Win32 API could not delete the specified device context (DC).</exception>
		public override void OnEndPrint(PrintDocument document, PrintEventArgs e)
		{
			CheckSecurity(document);
			IntSecurity.UnmanagedCode.Assert();
			try
			{
				if (dc != null)
				{
					try
					{
						int num = (e.Cancel ? SafeNativeMethods.AbortDoc(new HandleRef(dc, dc.Hdc)) : SafeNativeMethods.EndDoc(new HandleRef(dc, dc.Hdc)));
						if (num <= 0)
						{
							throw new Win32Exception();
						}
					}
					finally
					{
						dc.Dispose();
						dc = null;
					}
				}
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
			base.OnEndPrint(document, e);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.StandardPrintController" /> class.</summary>
		public StandardPrintController()
		{
		}
	}
	/// <summary>Specifies the printer's duplex setting.</summary>
	[Serializable]
	public enum Duplex
	{
		/// <summary>The printer's default duplex setting.</summary>
		Default = -1,
		/// <summary>Single-sided printing.</summary>
		Simplex = 1,
		/// <summary>Double-sided, horizontal printing.</summary>
		Horizontal = 3,
		/// <summary>Double-sided, vertical printing.</summary>
		Vertical = 2
	}
	/// <summary>Represents the exception that is thrown when you try to access a printer using printer settings that are not valid.</summary>
	[Serializable]
	public class InvalidPrinterException : SystemException
	{
		private PrinterSettings settings;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.InvalidPrinterException" /> class.</summary>
		/// <param name="settings">A <see cref="T:System.Drawing.Printing.PrinterSettings" /> that specifies the settings for a printer.</param>
		public InvalidPrinterException(PrinterSettings settings)
			: base(GenerateMessage(settings))
		{
			this.settings = settings;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.InvalidPrinterException" /> class with serialized data.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
		/// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="info" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is <see langword="null" /> or <see cref="P:System.Exception.HResult" /> is 0.</exception>
		protected InvalidPrinterException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			settings = (PrinterSettings)info.GetValue("settings", typeof(PrinterSettings));
		}

		/// <summary>Overridden. Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
		/// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="info" /> is <see langword="null" />.</exception>
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			IntSecurity.AllPrinting.Demand();
			info.AddValue("settings", settings);
			base.GetObjectData(info, context);
		}

		private static string GenerateMessage(PrinterSettings settings)
		{
			if (settings.IsDefaultPrinter)
			{
				return SR.GetString("InvalidPrinterException_NoDefaultPrinter");
			}
			try
			{
				return SR.GetString("InvalidPrinterException_InvalidPrinter", settings.PrinterName);
			}
			catch (SecurityException)
			{
				return SR.GetString("InvalidPrinterException_InvalidPrinter", SR.GetString("CantTellPrinterName"));
			}
		}
	}
	/// <summary>Specifies the dimensions of the margins of a printed page.</summary>
	[Serializable]
	[TypeConverter(typeof(MarginsConverter))]
	public class Margins : ICloneable
	{
		private int left;

		private int right;

		private int top;

		private int bottom;

		[OptionalField]
		private double doubleLeft;

		[OptionalField]
		private double doubleRight;

		[OptionalField]
		private double doubleTop;

		[OptionalField]
		private double doubleBottom;

		/// <summary>Gets or sets the left margin width, in hundredths of an inch.</summary>
		/// <returns>The left margin width, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.Margins.Left" /> property is set to a value that is less than 0.</exception>
		public int Left
		{
			get
			{
				return left;
			}
			set
			{
				CheckMargin(value, "Left");
				left = value;
				doubleLeft = value;
			}
		}

		/// <summary>Gets or sets the right margin width, in hundredths of an inch.</summary>
		/// <returns>The right margin width, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.Margins.Right" /> property is set to a value that is less than 0.</exception>
		public int Right
		{
			get
			{
				return right;
			}
			set
			{
				CheckMargin(value, "Right");
				right = value;
				doubleRight = value;
			}
		}

		/// <summary>Gets or sets the top margin width, in hundredths of an inch.</summary>
		/// <returns>The top margin width, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.Margins.Top" /> property is set to a value that is less than 0.</exception>
		public int Top
		{
			get
			{
				return top;
			}
			set
			{
				CheckMargin(value, "Top");
				top = value;
				doubleTop = value;
			}
		}

		/// <summary>Gets or sets the bottom margin, in hundredths of an inch.</summary>
		/// <returns>The bottom margin, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.Margins.Bottom" /> property is set to a value that is less than 0.</exception>
		public int Bottom
		{
			get
			{
				return bottom;
			}
			set
			{
				CheckMargin(value, "Bottom");
				bottom = value;
				doubleBottom = value;
			}
		}

		internal double DoubleLeft
		{
			get
			{
				return doubleLeft;
			}
			set
			{
				Left = (int)Math.Round(value);
				doubleLeft = value;
			}
		}

		internal double DoubleRight
		{
			get
			{
				return doubleRight;
			}
			set
			{
				Right = (int)Math.Round(value);
				doubleRight = value;
			}
		}

		internal double DoubleTop
		{
			get
			{
				return doubleTop;
			}
			set
			{
				Top = (int)Math.Round(value);
				doubleTop = value;
			}
		}

		internal double DoubleBottom
		{
			get
			{
				return doubleBottom;
			}
			set
			{
				Bottom = (int)Math.Round(value);
				doubleBottom = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.Margins" /> class with 1-inch wide margins.</summary>
		public Margins()
			: this(100, 100, 100, 100)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.Margins" /> class with the specified left, right, top, and bottom margins.</summary>
		/// <param name="left">The left margin, in hundredths of an inch.</param>
		/// <param name="right">The right margin, in hundredths of an inch.</param>
		/// <param name="top">The top margin, in hundredths of an inch.</param>
		/// <param name="bottom">The bottom margin, in hundredths of an inch.</param>
		/// <exception cref="T:System.ArgumentException">The <paramref name="left" /> parameter value is less than 0.  
		///  -or-  
		///  The <paramref name="right" /> parameter value is less than 0.  
		///  -or-  
		///  The <paramref name="top" /> parameter value is less than 0.  
		///  -or-  
		///  The <paramref name="bottom" /> parameter value is less than 0.</exception>
		public Margins(int left, int right, int top, int bottom)
		{
			CheckMargin(left, "left");
			CheckMargin(right, "right");
			CheckMargin(top, "top");
			CheckMargin(bottom, "bottom");
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
			doubleLeft = left;
			doubleRight = right;
			doubleTop = top;
			doubleBottom = bottom;
		}

		[OnDeserialized]
		private void OnDeserializedMethod(StreamingContext context)
		{
			if (doubleLeft == 0.0 && left != 0)
			{
				doubleLeft = left;
			}
			if (doubleRight == 0.0 && right != 0)
			{
				doubleRight = right;
			}
			if (doubleTop == 0.0 && top != 0)
			{
				doubleTop = top;
			}
			if (doubleBottom == 0.0 && bottom != 0)
			{
				doubleBottom = bottom;
			}
		}

		private void CheckMargin(int margin, string name)
		{
			if (margin < 0)
			{
				throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", name, margin, "0"));
			}
		}

		/// <summary>Retrieves a duplicate of this object, member by member.</summary>
		/// <returns>A duplicate of this object.</returns>
		public object Clone()
		{
			return MemberwiseClone();
		}

		/// <summary>Compares this <see cref="T:System.Drawing.Printing.Margins" /> to the specified <see cref="T:System.Object" /> to determine whether they have the same dimensions.</summary>
		/// <param name="obj">The object to which to compare this <see cref="T:System.Drawing.Printing.Margins" />.</param>
		/// <returns>
		///   <see langword="true" /> if the specified object is a <see cref="T:System.Drawing.Printing.Margins" /> and has the same <see cref="P:System.Drawing.Printing.Margins.Top" />, <see cref="P:System.Drawing.Printing.Margins.Bottom" />, <see cref="P:System.Drawing.Printing.Margins.Right" /> and <see cref="P:System.Drawing.Printing.Margins.Left" /> values as this <see cref="T:System.Drawing.Printing.Margins" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			Margins margins = obj as Margins;
			if (margins == this)
			{
				return true;
			}
			if (margins == null)
			{
				return false;
			}
			if (margins.Left == Left && margins.Right == Right && margins.Top == Top)
			{
				return margins.Bottom == Bottom;
			}
			return false;
		}

		/// <summary>Calculates and retrieves a hash code based on the width of the left, right, top, and bottom margins.</summary>
		/// <returns>A hash code based on the left, right, top, and bottom margins.</returns>
		public override int GetHashCode()
		{
			uint num = (uint)Left;
			uint num2 = (uint)Right;
			uint num3 = (uint)Top;
			uint num4 = (uint)Bottom;
			return (int)(num ^ ((num2 << 13) | (num2 >> 19)) ^ ((num3 << 26) | (num3 >> 6)) ^ ((num4 << 7) | (num4 >> 25)));
		}

		/// <summary>Compares two <see cref="T:System.Drawing.Printing.Margins" /> to determine if they have the same dimensions.</summary>
		/// <param name="m1">The first <see cref="T:System.Drawing.Printing.Margins" /> to compare for equality.</param>
		/// <param name="m2">The second <see cref="T:System.Drawing.Printing.Margins" /> to compare for equality.</param>
		/// <returns>
		///   <see langword="true" /> to indicate the <see cref="P:System.Drawing.Printing.Margins.Left" />, <see cref="P:System.Drawing.Printing.Margins.Right" />, <see cref="P:System.Drawing.Printing.Margins.Top" />, and <see cref="P:System.Drawing.Printing.Margins.Bottom" /> properties of both margins have the same value; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(Margins m1, Margins m2)
		{
			if ((object)m1 == null != ((object)m2 == null))
			{
				return false;
			}
			if ((object)m1 != null)
			{
				if (m1.Left == m2.Left && m1.Top == m2.Top && m1.Right == m2.Right)
				{
					return m1.Bottom == m2.Bottom;
				}
				return false;
			}
			return true;
		}

		/// <summary>Compares two <see cref="T:System.Drawing.Printing.Margins" /> to determine whether they are of unequal width.</summary>
		/// <param name="m1">The first <see cref="T:System.Drawing.Printing.Margins" /> to compare for inequality.</param>
		/// <param name="m2">The second <see cref="T:System.Drawing.Printing.Margins" /> to compare for inequality.</param>
		/// <returns>
		///   <see langword="true" /> to indicate if the <see cref="P:System.Drawing.Printing.Margins.Left" />, <see cref="P:System.Drawing.Printing.Margins.Right" />, <see cref="P:System.Drawing.Printing.Margins.Top" />, or <see cref="P:System.Drawing.Printing.Margins.Bottom" /> properties of both margins are not equal; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(Margins m1, Margins m2)
		{
			return !(m1 == m2);
		}

		/// <summary>Converts the <see cref="T:System.Drawing.Printing.Margins" /> to a string.</summary>
		/// <returns>A <see cref="T:System.String" /> representation of the <see cref="T:System.Drawing.Printing.Margins" />.</returns>
		public override string ToString()
		{
			return "[Margins Left=" + Left.ToString(CultureInfo.InvariantCulture) + " Right=" + Right.ToString(CultureInfo.InvariantCulture) + " Top=" + Top.ToString(CultureInfo.InvariantCulture) + " Bottom=" + Bottom.ToString(CultureInfo.InvariantCulture) + "]";
		}
	}
	/// <summary>Provides a <see cref="T:System.Drawing.Printing.MarginsConverter" /> for <see cref="T:System.Drawing.Printing.Margins" />.</summary>
	public class MarginsConverter : ExpandableObjectConverter
	{
		/// <summary>Returns whether this converter can convert an object of the specified source type to the native type of the converter using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="sourceType">A <see cref="T:System.Type" /> that represents the type from which you want to convert.</param>
		/// <returns>
		///   <see langword="true" /> if an object can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			if (sourceType == typeof(string))
			{
				return true;
			}
			return base.CanConvertFrom(context, sourceType);
		}

		/// <summary>Returns whether this converter can convert an object to the given destination type using the context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="destinationType">A <see cref="T:System.Type" /> that represents the type to which you want to convert.</param>
		/// <returns>
		///   <see langword="true" /> if this converter can perform the conversion; otherwise, <see langword="false" />.</returns>
		public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
		{
			if (destinationType == typeof(InstanceDescriptor))
			{
				return true;
			}
			return base.CanConvertTo(context, destinationType);
		}

		/// <summary>Converts the specified object to the converter's native type.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that provides the language to convert to.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to convert.</param>
		/// <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="value" /> does not contain values for all four margins. For example, "100,100,100,100" specifies 1 inch for the left, right, top, and bottom margins.</exception>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be performed.</exception>
		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			if (value is string text)
			{
				string text2 = text.Trim();
				if (text2.Length == 0)
				{
					return null;
				}
				if (culture == null)
				{
					culture = CultureInfo.CurrentCulture;
				}
				char c = culture.TextInfo.ListSeparator[0];
				string[] array = text2.Split(c);
				int[] array2 = new int[array.Length];
				TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = (int)converter.ConvertFromString(context, culture, array[i]);
				}
				if (array2.Length != 4)
				{
					throw new ArgumentException(SR.GetString("TextParseFailedFormat", text2, "left, right, top, bottom"));
				}
				return new Margins(array2[0], array2[1], array2[2], array2[3]);
			}
			return base.ConvertFrom(context, culture, value);
		}

		/// <summary>Converts the given value object to the specified destination type using the specified context and arguments.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="culture">A <see cref="T:System.Globalization.CultureInfo" /> that provides the language to convert to.</param>
		/// <param name="value">The <see cref="T:System.Object" /> to convert.</param>
		/// <param name="destinationType">The <see cref="T:System.Type" /> to which to convert the value.</param>
		/// <returns>An <see cref="T:System.Object" /> that represents the converted value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="destinationType" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.NotSupportedException">The conversion cannot be performed.</exception>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
		{
			if (destinationType == null)
			{
				throw new ArgumentNullException("destinationType");
			}
			if (value is Margins)
			{
				if (destinationType == typeof(string))
				{
					Margins margins = (Margins)value;
					if (culture == null)
					{
						culture = CultureInfo.CurrentCulture;
					}
					string separator = culture.TextInfo.ListSeparator + " ";
					TypeConverter converter = TypeDescriptor.GetConverter(typeof(int));
					string[] array = new string[4];
					int num = 0;
					array[num++] = converter.ConvertToString(context, culture, margins.Left);
					array[num++] = converter.ConvertToString(context, culture, margins.Right);
					array[num++] = converter.ConvertToString(context, culture, margins.Top);
					array[num++] = converter.ConvertToString(context, culture, margins.Bottom);
					return string.Join(separator, array);
				}
				if (destinationType == typeof(InstanceDescriptor))
				{
					Margins margins2 = (Margins)value;
					ConstructorInfo constructor = typeof(Margins).GetConstructor(new Type[4]
					{
						typeof(int),
						typeof(int),
						typeof(int),
						typeof(int)
					});
					if (constructor != null)
					{
						return new InstanceDescriptor(constructor, new object[4] { margins2.Left, margins2.Right, margins2.Top, margins2.Bottom });
					}
				}
			}
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <summary>Creates an <see cref="T:System.Object" /> given a set of property values for the object.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <param name="propertyValues">An <see cref="T:System.Collections.IDictionary" /> of new property values.</param>
		/// <returns>An <see cref="T:System.Object" /> representing the specified <see cref="T:System.Collections.IDictionary" />, or <see langword="null" /> if the object cannot be created.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="propertyValues" /> is <see langword="null" />.</exception>
		public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues)
		{
			if (propertyValues == null)
			{
				throw new ArgumentNullException("propertyValues");
			}
			object obj = propertyValues["Left"];
			object obj2 = propertyValues["Right"];
			object obj3 = propertyValues["Top"];
			object obj4 = propertyValues["Bottom"];
			if (obj == null || obj2 == null || obj4 == null || obj3 == null || !(obj is int) || !(obj2 is int) || !(obj4 is int) || !(obj3 is int))
			{
				throw new ArgumentException(SR.GetString("PropertyValueInvalidEntry"));
			}
			return new Margins((int)obj, (int)obj2, (int)obj3, (int)obj4);
		}

		/// <summary>Returns whether changing a value on this object requires a call to the <see cref="M:System.Drawing.Printing.MarginsConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> method to create a new value, using the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
		/// <returns>
		///   <see langword="true" /> if changing a property on this object requires a call to <see cref="M:System.Drawing.Printing.MarginsConverter.CreateInstance(System.ComponentModel.ITypeDescriptorContext,System.Collections.IDictionary)" /> to create a new value; otherwise, <see langword="false" />. This method always returns <see langword="true" />.</returns>
		public override bool GetCreateInstanceSupported(ITypeDescriptorContext context)
		{
			return true;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.MarginsConverter" /> class.</summary>
		public MarginsConverter()
		{
		}
	}
	internal enum ModeField
	{
		Orientation,
		PaperSize,
		PaperLength,
		PaperWidth,
		Copies,
		DefaultSource,
		PrintQuality,
		Color,
		Duplex,
		YResolution,
		TTOption,
		Collate
	}
	/// <summary>Specifies settings that apply to a single, printed page.</summary>
	[Serializable]
	public class PageSettings : ICloneable
	{
		internal PrinterSettings printerSettings;

		private TriState color = TriState.Default;

		private PaperSize paperSize;

		private PaperSource paperSource;

		private PrinterResolution printerResolution;

		private TriState landscape = TriState.Default;

		private Margins margins = new Margins();

		/// <summary>Gets the size of the page, taking into account the page orientation specified by the <see cref="P:System.Drawing.Printing.PageSettings.Landscape" /> property.</summary>
		/// <returns>A <see cref="T:System.Drawing.Rectangle" /> that represents the length and width, in hundredths of an inch, of the page.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public Rectangle Bounds
		{
			get
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				IntPtr hdevmode = printerSettings.GetHdevmode();
				Rectangle bounds = GetBounds(hdevmode);
				SafeNativeMethods.GlobalFree(new HandleRef(this, hdevmode));
				return bounds;
			}
		}

		/// <summary>Gets or sets a value indicating whether the page should be printed in color.</summary>
		/// <returns>
		///   <see langword="true" /> if the page should be printed in color; otherwise, <see langword="false" />. The default is determined by the printer.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public bool Color
		{
			get
			{
				if (color.IsDefault)
				{
					return printerSettings.GetModeField(ModeField.Color, 1) == 2;
				}
				return (bool)color;
			}
			set
			{
				color = value;
			}
		}

		/// <summary>Gets the x-coordinate, in hundredths of an inch, of the hard margin at the left of the page.</summary>
		/// <returns>The x-coordinate, in hundredths of an inch, of the left-hand hard margin.</returns>
		public float HardMarginX
		{
			get
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				float num = 0f;
				DeviceContext deviceContext = printerSettings.CreateDeviceContext(this);
				try
				{
					int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 88);
					int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 112);
					return deviceCaps2 * 100 / deviceCaps;
				}
				finally
				{
					deviceContext.Dispose();
				}
			}
		}

		/// <summary>Gets the y-coordinate, in hundredths of an inch, of the hard margin at the top of the page.</summary>
		/// <returns>The y-coordinate, in hundredths of an inch, of the hard margin at the top of the page.</returns>
		public float HardMarginY
		{
			get
			{
				float num = 0f;
				DeviceContext deviceContext = printerSettings.CreateDeviceContext(this);
				try
				{
					int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 90);
					int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), 113);
					return deviceCaps2 * 100 / deviceCaps;
				}
				finally
				{
					deviceContext.Dispose();
				}
			}
		}

		/// <summary>Gets or sets a value indicating whether the page is printed in landscape or portrait orientation.</summary>
		/// <returns>
		///   <see langword="true" /> if the page should be printed in landscape orientation; otherwise, <see langword="false" />. The default is determined by the printer.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public bool Landscape
		{
			get
			{
				if (landscape.IsDefault)
				{
					return printerSettings.GetModeField(ModeField.Orientation, 1) == 2;
				}
				return (bool)landscape;
			}
			set
			{
				landscape = value;
			}
		}

		/// <summary>Gets or sets the margins for this page.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.Margins" /> that represents the margins, in hundredths of an inch, for the page. The default is 1-inch margins on all sides.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public Margins Margins
		{
			get
			{
				return margins;
			}
			set
			{
				margins = value;
			}
		}

		/// <summary>Gets or sets the paper size for the page.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PaperSize" /> that represents the size of the paper. The default is the printer's default paper size.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist or there is no default printer installed.</exception>
		public PaperSize PaperSize
		{
			get
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				return GetPaperSize(IntPtr.Zero);
			}
			set
			{
				paperSize = value;
			}
		}

		/// <summary>Gets or sets the page's paper source; for example, the printer's upper tray.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PaperSource" /> that specifies the source of the paper. The default is the printer's default paper source.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist or there is no default printer installed.</exception>
		public PaperSource PaperSource
		{
			get
			{
				if (paperSource == null)
				{
					IntSecurity.AllPrintingAndUnmanagedCode.Assert();
					IntPtr hdevmode = printerSettings.GetHdevmode();
					IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(this, hdevmode));
					SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
					PaperSource result = PaperSourceFromMode(mode);
					SafeNativeMethods.GlobalUnlock(new HandleRef(this, hdevmode));
					SafeNativeMethods.GlobalFree(new HandleRef(this, hdevmode));
					return result;
				}
				return paperSource;
			}
			set
			{
				paperSource = value;
			}
		}

		/// <summary>Gets the bounds of the printable area of the page for the printer.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> representing the length and width, in hundredths of an inch, of the area the printer is capable of printing in.</returns>
		public RectangleF PrintableArea
		{
			get
			{
				RectangleF result = default(RectangleF);
				DeviceContext deviceContext = printerSettings.CreateInformationContext(this);
				HandleRef hDC = new HandleRef(deviceContext, deviceContext.Hdc);
				try
				{
					int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(hDC, 88);
					int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(hDC, 90);
					if (!Landscape)
					{
						result.X = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 112) * 100f / (float)deviceCaps;
						result.Y = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 113) * 100f / (float)deviceCaps2;
						result.Width = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 8) * 100f / (float)deviceCaps;
						result.Height = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 10) * 100f / (float)deviceCaps2;
						return result;
					}
					result.Y = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 112) * 100f / (float)deviceCaps;
					result.X = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 113) * 100f / (float)deviceCaps2;
					result.Height = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 8) * 100f / (float)deviceCaps;
					result.Width = (float)UnsafeNativeMethods.GetDeviceCaps(hDC, 10) * 100f / (float)deviceCaps2;
					return result;
				}
				finally
				{
					deviceContext.Dispose();
				}
			}
		}

		/// <summary>Gets or sets the printer resolution for the page.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterResolution" /> that specifies the printer resolution for the page. The default is the printer's default resolution.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist or there is no default printer installed.</exception>
		public PrinterResolution PrinterResolution
		{
			get
			{
				if (printerResolution == null)
				{
					IntSecurity.AllPrintingAndUnmanagedCode.Assert();
					IntPtr hdevmode = printerSettings.GetHdevmode();
					IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(this, hdevmode));
					SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
					PrinterResolution result = PrinterResolutionFromMode(mode);
					SafeNativeMethods.GlobalUnlock(new HandleRef(this, hdevmode));
					SafeNativeMethods.GlobalFree(new HandleRef(this, hdevmode));
					return result;
				}
				return printerResolution;
			}
			set
			{
				printerResolution = value;
			}
		}

		/// <summary>Gets or sets the printer settings associated with the page.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings" /> that represents the printer settings associated with the page.</returns>
		public PrinterSettings PrinterSettings
		{
			get
			{
				return printerSettings;
			}
			set
			{
				if (value == null)
				{
					value = new PrinterSettings();
				}
				printerSettings = value;
			}
		}

		private short ExtraBytes
		{
			get
			{
				IntPtr hdevmodeInternal = printerSettings.GetHdevmodeInternal();
				IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(this, hdevmodeInternal));
				SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
				short dmDriverExtra = dEVMODE.dmDriverExtra;
				SafeNativeMethods.GlobalUnlock(new HandleRef(this, hdevmodeInternal));
				SafeNativeMethods.GlobalFree(new HandleRef(this, hdevmodeInternal));
				return dmDriverExtra;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PageSettings" /> class using the default printer.</summary>
		public PageSettings()
			: this(new PrinterSettings())
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PageSettings" /> class using a specified printer.</summary>
		/// <param name="printerSettings">The <see cref="T:System.Drawing.Printing.PrinterSettings" /> that describes the printer to use.</param>
		public PageSettings(PrinterSettings printerSettings)
		{
			this.printerSettings = printerSettings;
		}

		/// <summary>Creates a copy of this <see cref="T:System.Drawing.Printing.PageSettings" />.</summary>
		/// <returns>A copy of this object.</returns>
		public object Clone()
		{
			PageSettings pageSettings = (PageSettings)MemberwiseClone();
			pageSettings.margins = (Margins)margins.Clone();
			return pageSettings;
		}

		/// <summary>Copies the relevant information from the <see cref="T:System.Drawing.Printing.PageSettings" /> to the specified <see langword="DEVMODE" /> structure.</summary>
		/// <param name="hdevmode">The handle to a Win32 <see langword="DEVMODE" /> structure.</param>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist or there is no default printer installed.</exception>
		public void CopyToHdevmode(IntPtr hdevmode)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			IntPtr intPtr = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
			SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(SafeNativeMethods.DEVMODE));
			if (color.IsNotDefault && (dEVMODE.dmFields & 0x800) == 2048)
			{
				dEVMODE.dmColor = (short)((!(bool)color) ? 1 : 2);
			}
			if (landscape.IsNotDefault && (dEVMODE.dmFields & 1) == 1)
			{
				dEVMODE.dmOrientation = (short)((!(bool)landscape) ? 1 : 2);
			}
			if (paperSize != null)
			{
				if ((dEVMODE.dmFields & 2) == 2)
				{
					dEVMODE.dmPaperSize = (short)paperSize.RawKind;
				}
				bool flag = false;
				bool flag2 = false;
				if ((dEVMODE.dmFields & 4) == 4)
				{
					int num = PrinterUnitConvert.Convert(paperSize.Height, PrinterUnit.Display, PrinterUnit.TenthsOfAMillimeter);
					dEVMODE.dmPaperLength = (short)num;
					flag2 = true;
				}
				if ((dEVMODE.dmFields & 8) == 8)
				{
					int num2 = PrinterUnitConvert.Convert(paperSize.Width, PrinterUnit.Display, PrinterUnit.TenthsOfAMillimeter);
					dEVMODE.dmPaperWidth = (short)num2;
					flag = true;
				}
				if (paperSize.Kind == PaperKind.Custom)
				{
					if (!flag2)
					{
						dEVMODE.dmFields |= 4;
						int num3 = PrinterUnitConvert.Convert(paperSize.Height, PrinterUnit.Display, PrinterUnit.TenthsOfAMillimeter);
						dEVMODE.dmPaperLength = (short)num3;
					}
					if (!flag)
					{
						dEVMODE.dmFields |= 8;
						int num4 = PrinterUnitConvert.Convert(paperSize.Width, PrinterUnit.Display, PrinterUnit.TenthsOfAMillimeter);
						dEVMODE.dmPaperWidth = (short)num4;
					}
				}
			}
			if (paperSource != null && (dEVMODE.dmFields & 0x200) == 512)
			{
				dEVMODE.dmDefaultSource = (short)paperSource.RawKind;
			}
			if (printerResolution != null)
			{
				if (printerResolution.Kind == PrinterResolutionKind.Custom)
				{
					if ((dEVMODE.dmFields & 0x400) == 1024)
					{
						dEVMODE.dmPrintQuality = (short)printerResolution.X;
					}
					if ((dEVMODE.dmFields & 0x2000) == 8192)
					{
						dEVMODE.dmYResolution = (short)printerResolution.Y;
					}
				}
				else if ((dEVMODE.dmFields & 0x400) == 1024)
				{
					dEVMODE.dmPrintQuality = (short)printerResolution.Kind;
				}
			}
			Marshal.StructureToPtr((object)dEVMODE, intPtr, fDeleteOld: false);
			if (dEVMODE.dmDriverExtra >= ExtraBytes)
			{
				int num5 = SafeNativeMethods.DocumentProperties(NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, printerSettings.PrinterName, intPtr, intPtr, 10);
				if (num5 < 0 && LocalAppContextSwitches.FreeCopyToDevModeOnFailure)
				{
					SafeNativeMethods.GlobalFree(new HandleRef(null, intPtr));
				}
			}
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
		}

		internal Rectangle GetBounds(IntPtr modeHandle)
		{
			PaperSize paperSize = GetPaperSize(modeHandle);
			return (!GetLandscape(modeHandle)) ? new Rectangle(0, 0, paperSize.Width, paperSize.Height) : new Rectangle(0, 0, paperSize.Height, paperSize.Width);
		}

		private bool GetLandscape(IntPtr modeHandle)
		{
			if (landscape.IsDefault)
			{
				return printerSettings.GetModeField(ModeField.Orientation, 1, modeHandle) == 2;
			}
			return (bool)landscape;
		}

		private PaperSize GetPaperSize(IntPtr modeHandle)
		{
			if (paperSize == null)
			{
				bool flag = false;
				if (modeHandle == IntPtr.Zero)
				{
					modeHandle = printerSettings.GetHdevmode();
					flag = true;
				}
				IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(null, modeHandle));
				SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
				PaperSize result = PaperSizeFromMode(mode);
				SafeNativeMethods.GlobalUnlock(new HandleRef(null, modeHandle));
				if (flag)
				{
					SafeNativeMethods.GlobalFree(new HandleRef(null, modeHandle));
				}
				return result;
			}
			return paperSize;
		}

		private PaperSize PaperSizeFromMode(SafeNativeMethods.DEVMODE mode)
		{
			PaperSize[] paperSizes = printerSettings.Get_PaperSizes();
			if ((mode.dmFields & 2) == 2)
			{
				for (int i = 0; i < paperSizes.Length; i++)
				{
					if (paperSizes[i].RawKind == mode.dmPaperSize)
					{
						return paperSizes[i];
					}
				}
			}
			return new PaperSize(PaperKind.Custom, "custom", PrinterUnitConvert.Convert(mode.dmPaperWidth, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display), PrinterUnitConvert.Convert(mode.dmPaperLength, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display));
		}

		private PaperSource PaperSourceFromMode(SafeNativeMethods.DEVMODE mode)
		{
			PaperSource[] paperSources = printerSettings.Get_PaperSources();
			if ((mode.dmFields & 0x200) == 512)
			{
				for (int i = 0; i < paperSources.Length; i++)
				{
					if ((short)paperSources[i].RawKind == mode.dmDefaultSource)
					{
						return paperSources[i];
					}
				}
			}
			return new PaperSource((PaperSourceKind)mode.dmDefaultSource, "unknown");
		}

		private PrinterResolution PrinterResolutionFromMode(SafeNativeMethods.DEVMODE mode)
		{
			PrinterResolution[] printerResolutions = printerSettings.Get_PrinterResolutions();
			for (int i = 0; i < printerResolutions.Length; i++)
			{
				if (mode.dmPrintQuality >= 0 && (mode.dmFields & 0x400) == 1024 && (mode.dmFields & 0x2000) == 8192)
				{
					if (printerResolutions[i].X == mode.dmPrintQuality && printerResolutions[i].Y == mode.dmYResolution)
					{
						return printerResolutions[i];
					}
				}
				else if ((mode.dmFields & 0x400) == 1024 && printerResolutions[i].Kind == (PrinterResolutionKind)mode.dmPrintQuality)
				{
					return printerResolutions[i];
				}
			}
			return new PrinterResolution(PrinterResolutionKind.Custom, mode.dmPrintQuality, mode.dmYResolution);
		}

		/// <summary>Copies relevant information to the <see cref="T:System.Drawing.Printing.PageSettings" /> from the specified <see langword="DEVMODE" /> structure.</summary>
		/// <param name="hdevmode">The handle to a Win32 <see langword="DEVMODE" /> structure.</param>
		/// <exception cref="T:System.ArgumentException">The printer handle is not valid.</exception>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist or there is no default printer installed.</exception>
		public void SetHdevmode(IntPtr hdevmode)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			if (hdevmode == IntPtr.Zero)
			{
				throw new ArgumentException(SR.GetString("InvalidPrinterHandle", hdevmode));
			}
			IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
			SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
			if ((dEVMODE.dmFields & 0x800) == 2048)
			{
				color = dEVMODE.dmColor == 2;
			}
			if ((dEVMODE.dmFields & 1) == 1)
			{
				landscape = dEVMODE.dmOrientation == 2;
			}
			paperSize = PaperSizeFromMode(dEVMODE);
			paperSource = PaperSourceFromMode(dEVMODE);
			printerResolution = PrinterResolutionFromMode(dEVMODE);
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
		}

		/// <summary>Converts the <see cref="T:System.Drawing.Printing.PageSettings" /> to string form.</summary>
		/// <returns>A string showing the various property settings for the <see cref="T:System.Drawing.Printing.PageSettings" />.</returns>
		public override string ToString()
		{
			return "[PageSettings: Color=" + Color + ", Landscape=" + Landscape + ", Margins=" + Margins.ToString() + ", PaperSize=" + PaperSize.ToString() + ", PaperSource=" + PaperSource.ToString() + ", PrinterResolution=" + PrinterResolution.ToString() + "]";
		}
	}
	/// <summary>Specifies the standard paper sizes.</summary>
	[Serializable]
	public enum PaperKind
	{
		/// <summary>The paper size is defined by the user.</summary>
		Custom = 0,
		/// <summary>Letter paper (8.5 in. by 11 in.).</summary>
		Letter = 1,
		/// <summary>Legal paper (8.5 in. by 14 in.).</summary>
		Legal = 5,
		/// <summary>A4 paper (210 mm by 297 mm).</summary>
		A4 = 9,
		/// <summary>C paper (17 in. by 22 in.).</summary>
		CSheet = 24,
		/// <summary>D paper (22 in. by 34 in.).</summary>
		DSheet = 25,
		/// <summary>E paper (34 in. by 44 in.).</summary>
		ESheet = 26,
		/// <summary>Letter small paper (8.5 in. by 11 in.).</summary>
		LetterSmall = 2,
		/// <summary>Tabloid paper (11 in. by 17 in.).</summary>
		Tabloid = 3,
		/// <summary>Ledger paper (17 in. by 11 in.).</summary>
		Ledger = 4,
		/// <summary>Statement paper (5.5 in. by 8.5 in.).</summary>
		Statement = 6,
		/// <summary>Executive paper (7.25 in. by 10.5 in.).</summary>
		Executive = 7,
		/// <summary>A3 paper (297 mm by 420 mm).</summary>
		A3 = 8,
		/// <summary>A4 small paper (210 mm by 297 mm).</summary>
		A4Small = 10,
		/// <summary>A5 paper (148 mm by 210 mm).</summary>
		A5 = 11,
		/// <summary>B4 paper (250 mm by 353 mm).</summary>
		B4 = 12,
		/// <summary>B5 paper (176 mm by 250 mm).</summary>
		B5 = 13,
		/// <summary>Folio paper (8.5 in. by 13 in.).</summary>
		Folio = 14,
		/// <summary>Quarto paper (215 mm by 275 mm).</summary>
		Quarto = 15,
		/// <summary>Standard paper (10 in. by 14 in.).</summary>
		Standard10x14 = 16,
		/// <summary>Standard paper (11 in. by 17 in.).</summary>
		Standard11x17 = 17,
		/// <summary>Note paper (8.5 in. by 11 in.).</summary>
		Note = 18,
		/// <summary>#9 envelope (3.875 in. by 8.875 in.).</summary>
		Number9Envelope = 19,
		/// <summary>#10 envelope (4.125 in. by 9.5 in.).</summary>
		Number10Envelope = 20,
		/// <summary>#11 envelope (4.5 in. by 10.375 in.).</summary>
		Number11Envelope = 21,
		/// <summary>#12 envelope (4.75 in. by 11 in.).</summary>
		Number12Envelope = 22,
		/// <summary>#14 envelope (5 in. by 11.5 in.).</summary>
		Number14Envelope = 23,
		/// <summary>DL envelope (110 mm by 220 mm).</summary>
		DLEnvelope = 27,
		/// <summary>C5 envelope (162 mm by 229 mm).</summary>
		C5Envelope = 28,
		/// <summary>C3 envelope (324 mm by 458 mm).</summary>
		C3Envelope = 29,
		/// <summary>C4 envelope (229 mm by 324 mm).</summary>
		C4Envelope = 30,
		/// <summary>C6 envelope (114 mm by 162 mm).</summary>
		C6Envelope = 31,
		/// <summary>C65 envelope (114 mm by 229 mm).</summary>
		C65Envelope = 32,
		/// <summary>B4 envelope (250 mm by 353 mm).</summary>
		B4Envelope = 33,
		/// <summary>B5 envelope (176 mm by 250 mm).</summary>
		B5Envelope = 34,
		/// <summary>B6 envelope (176 mm by 125 mm).</summary>
		B6Envelope = 35,
		/// <summary>Italy envelope (110 mm by 230 mm).</summary>
		ItalyEnvelope = 36,
		/// <summary>Monarch envelope (3.875 in. by 7.5 in.).</summary>
		MonarchEnvelope = 37,
		/// <summary>6 3/4 envelope (3.625 in. by 6.5 in.).</summary>
		PersonalEnvelope = 38,
		/// <summary>US standard fanfold (14.875 in. by 11 in.).</summary>
		USStandardFanfold = 39,
		/// <summary>German standard fanfold (8.5 in. by 12 in.).</summary>
		GermanStandardFanfold = 40,
		/// <summary>German legal fanfold (8.5 in. by 13 in.).</summary>
		GermanLegalFanfold = 41,
		/// <summary>ISO B4 (250 mm by 353 mm).</summary>
		IsoB4 = 42,
		/// <summary>Japanese postcard (100 mm by 148 mm).</summary>
		JapanesePostcard = 43,
		/// <summary>Standard paper (9 in. by 11 in.).</summary>
		Standard9x11 = 44,
		/// <summary>Standard paper (10 in. by 11 in.).</summary>
		Standard10x11 = 45,
		/// <summary>Standard paper (15 in. by 11 in.).</summary>
		Standard15x11 = 46,
		/// <summary>Invitation envelope (220 mm by 220 mm).</summary>
		InviteEnvelope = 47,
		/// <summary>Letter extra paper (9.275 in. by 12 in.). This value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.</summary>
		LetterExtra = 50,
		/// <summary>Legal extra paper (9.275 in. by 15 in.). This value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.</summary>
		LegalExtra = 51,
		/// <summary>Tabloid extra paper (11.69 in. by 18 in.). This value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.</summary>
		TabloidExtra = 52,
		/// <summary>A4 extra paper (236 mm by 322 mm). This value is specific to the PostScript driver and is used only by Linotronic printers to help save paper.</summary>
		A4Extra = 53,
		/// <summary>Letter transverse paper (8.275 in. by 11 in.).</summary>
		LetterTransverse = 54,
		/// <summary>A4 transverse paper (210 mm by 297 mm).</summary>
		A4Transverse = 55,
		/// <summary>Letter extra transverse paper (9.275 in. by 12 in.).</summary>
		LetterExtraTransverse = 56,
		/// <summary>SuperA/SuperA/A4 paper (227 mm by 356 mm).</summary>
		APlus = 57,
		/// <summary>SuperB/SuperB/A3 paper (305 mm by 487 mm).</summary>
		BPlus = 58,
		/// <summary>Letter plus paper (8.5 in. by 12.69 in.).</summary>
		LetterPlus = 59,
		/// <summary>A4 plus paper (210 mm by 330 mm).</summary>
		A4Plus = 60,
		/// <summary>A5 transverse paper (148 mm by 210 mm).</summary>
		A5Transverse = 61,
		/// <summary>JIS B5 transverse paper (182 mm by 257 mm).</summary>
		B5Transverse = 62,
		/// <summary>A3 extra paper (322 mm by 445 mm).</summary>
		A3Extra = 63,
		/// <summary>A5 extra paper (174 mm by 235 mm).</summary>
		A5Extra = 64,
		/// <summary>ISO B5 extra paper (201 mm by 276 mm).</summary>
		B5Extra = 65,
		/// <summary>A2 paper (420 mm by 594 mm).</summary>
		A2 = 66,
		/// <summary>A3 transverse paper (297 mm by 420 mm).</summary>
		A3Transverse = 67,
		/// <summary>A3 extra transverse paper (322 mm by 445 mm).</summary>
		A3ExtraTransverse = 68,
		/// <summary>Japanese double postcard (200 mm by 148 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseDoublePostcard = 69,
		/// <summary>A6 paper (105 mm by 148 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		A6 = 70,
		/// <summary>Japanese Kaku #2 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeKakuNumber2 = 71,
		/// <summary>Japanese Kaku #3 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeKakuNumber3 = 72,
		/// <summary>Japanese Chou #3 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeChouNumber3 = 73,
		/// <summary>Japanese Chou #4 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeChouNumber4 = 74,
		/// <summary>Letter rotated paper (11 in. by 8.5 in.).</summary>
		LetterRotated = 75,
		/// <summary>A3 rotated paper (420 mm by 297 mm).</summary>
		A3Rotated = 76,
		/// <summary>A4 rotated paper (297 mm by 210 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		A4Rotated = 77,
		/// <summary>A5 rotated paper (210 mm by 148 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		A5Rotated = 78,
		/// <summary>JIS B4 rotated paper (364 mm by 257 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		B4JisRotated = 79,
		/// <summary>JIS B5 rotated paper (257 mm by 182 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		B5JisRotated = 80,
		/// <summary>Japanese rotated postcard (148 mm by 100 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapanesePostcardRotated = 81,
		/// <summary>Japanese rotated double postcard (148 mm by 200 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseDoublePostcardRotated = 82,
		/// <summary>A6 rotated paper (148 mm by 105 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		A6Rotated = 83,
		/// <summary>Japanese rotated Kaku #2 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeKakuNumber2Rotated = 84,
		/// <summary>Japanese rotated Kaku #3 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeKakuNumber3Rotated = 85,
		/// <summary>Japanese rotated Chou #3 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeChouNumber3Rotated = 86,
		/// <summary>Japanese rotated Chou #4 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeChouNumber4Rotated = 87,
		/// <summary>JIS B6 paper (128 mm by 182 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		B6Jis = 88,
		/// <summary>JIS B6 rotated paper (182 mm by 128 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		B6JisRotated = 89,
		/// <summary>Standard paper (12 in. by 11 in.). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Standard12x11 = 90,
		/// <summary>Japanese You #4 envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeYouNumber4 = 91,
		/// <summary>Japanese You #4 rotated envelope. Requires Windows 98, Windows NT 4.0, or later.</summary>
		JapaneseEnvelopeYouNumber4Rotated = 92,
		/// <summary>16K paper (146 mm by 215 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc16K = 93,
		/// <summary>32K paper (97 mm by 151 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc32K = 94,
		/// <summary>32K big paper (97 mm by 151 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc32KBig = 95,
		/// <summary>#1 envelope (102 mm by 165 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber1 = 96,
		/// <summary>#2 envelope (102 mm by 176 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber2 = 97,
		/// <summary>#3 envelope (125 mm by 176 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber3 = 98,
		/// <summary>#4 envelope (110 mm by 208 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber4 = 99,
		/// <summary>#5 envelope (110 mm by 220 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber5 = 100,
		/// <summary>#6 envelope (120 mm by 230 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber6 = 101,
		/// <summary>#7 envelope (160 mm by 230 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber7 = 102,
		/// <summary>#8 envelope (120 mm by 309 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber8 = 103,
		/// <summary>#9 envelope (229 mm by 324 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber9 = 104,
		/// <summary>#10 envelope (324 mm by 458 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber10 = 105,
		/// <summary>16K rotated paper (146 mm by 215 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc16KRotated = 106,
		/// <summary>32K rotated paper (97 mm by 151 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc32KRotated = 107,
		/// <summary>32K big rotated paper (97 mm by 151 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		Prc32KBigRotated = 108,
		/// <summary>#1 rotated envelope (165 mm by 102 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber1Rotated = 109,
		/// <summary>#2 rotated envelope (176 mm by 102 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber2Rotated = 110,
		/// <summary>#3 rotated envelope (176 mm by 125 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber3Rotated = 111,
		/// <summary>#4 rotated envelope (208 mm by 110 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber4Rotated = 112,
		/// <summary>Envelope #5 rotated envelope (220 mm by 110 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber5Rotated = 113,
		/// <summary>#6 rotated envelope (230 mm by 120 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber6Rotated = 114,
		/// <summary>#7 rotated envelope (230 mm by 160 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber7Rotated = 115,
		/// <summary>#8 rotated envelope (309 mm by 120 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber8Rotated = 116,
		/// <summary>#9 rotated envelope (324 mm by 229 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber9Rotated = 117,
		/// <summary>#10 rotated envelope (458 mm by 324 mm). Requires Windows 98, Windows NT 4.0, or later.</summary>
		PrcEnvelopeNumber10Rotated = 118
	}
	/// <summary>Specifies the size of a piece of paper.</summary>
	[Serializable]
	public class PaperSize
	{
		private PaperKind kind;

		private string name;

		private int width;

		private int height;

		private bool createdByDefaultConstructor;

		/// <summary>Gets or sets the height of the paper, in hundredths of an inch.</summary>
		/// <returns>The height of the paper, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.PaperSize.Kind" /> property is not set to <see cref="F:System.Drawing.Printing.PaperKind.Custom" />.</exception>
		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				if (kind != 0 && !createdByDefaultConstructor)
				{
					throw new ArgumentException(SR.GetString("PSizeNotCustom"));
				}
				height = value;
			}
		}

		/// <summary>Gets the type of paper.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PaperKind" /> values.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.PaperSize.Kind" /> property is not set to <see cref="F:System.Drawing.Printing.PaperKind.Custom" />.</exception>
		public PaperKind Kind
		{
			get
			{
				if (kind <= PaperKind.PrcEnvelopeNumber10Rotated && kind != (PaperKind)48 && kind != (PaperKind)49)
				{
					return kind;
				}
				return PaperKind.Custom;
			}
		}

		/// <summary>Gets or sets the name of the type of paper.</summary>
		/// <returns>The name of the type of paper.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.PaperSize.Kind" /> property is not set to <see cref="F:System.Drawing.Printing.PaperKind.Custom" />.</exception>
		public string PaperName
		{
			get
			{
				return name;
			}
			set
			{
				if (kind != 0 && !createdByDefaultConstructor)
				{
					throw new ArgumentException(SR.GetString("PSizeNotCustom"));
				}
				name = value;
			}
		}

		/// <summary>Gets or sets an integer representing one of the <see cref="T:System.Drawing.Printing.PaperSize" /> values or a custom value.</summary>
		/// <returns>An integer representing one of the <see cref="T:System.Drawing.Printing.PaperSize" /> values, or a custom value.</returns>
		public int RawKind
		{
			get
			{
				return (int)kind;
			}
			set
			{
				kind = (PaperKind)value;
			}
		}

		/// <summary>Gets or sets the width of the paper, in hundredths of an inch.</summary>
		/// <returns>The width of the paper, in hundredths of an inch.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.PaperSize.Kind" /> property is not set to <see cref="F:System.Drawing.Printing.PaperKind.Custom" />.</exception>
		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				if (kind != 0 && !createdByDefaultConstructor)
				{
					throw new ArgumentException(SR.GetString("PSizeNotCustom"));
				}
				width = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PaperSize" /> class.</summary>
		public PaperSize()
		{
			kind = PaperKind.Custom;
			name = string.Empty;
			createdByDefaultConstructor = true;
		}

		internal PaperSize(PaperKind kind, string name, int width, int height)
		{
			this.kind = kind;
			this.name = name;
			this.width = width;
			this.height = height;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PaperSize" /> class.</summary>
		/// <param name="name">The name of the paper.</param>
		/// <param name="width">The width of the paper, in hundredths of an inch.</param>
		/// <param name="height">The height of the paper, in hundredths of an inch.</param>
		public PaperSize(string name, int width, int height)
		{
			kind = PaperKind.Custom;
			this.name = name;
			this.width = width;
			this.height = height;
		}

		/// <summary>Provides information about the <see cref="T:System.Drawing.Printing.PaperSize" /> in string form.</summary>
		/// <returns>A string.</returns>
		public override string ToString()
		{
			return "[PaperSize " + PaperName + " Kind=" + TypeDescriptor.GetConverter(typeof(PaperKind)).ConvertToString((int)Kind) + " Height=" + Height.ToString(CultureInfo.InvariantCulture) + " Width=" + Width.ToString(CultureInfo.InvariantCulture) + "]";
		}
	}
	/// <summary>Specifies the paper tray from which the printer gets paper.</summary>
	[Serializable]
	public class PaperSource
	{
		private string name;

		private PaperSourceKind kind;

		/// <summary>Gets the paper source.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PaperSourceKind" /> values.</returns>
		public PaperSourceKind Kind
		{
			get
			{
				if (kind >= (PaperSourceKind)256)
				{
					return PaperSourceKind.Custom;
				}
				return kind;
			}
		}

		/// <summary>Gets or sets the integer representing one of the <see cref="T:System.Drawing.Printing.PaperSourceKind" /> values or a custom value.</summary>
		/// <returns>The integer value representing one of the <see cref="T:System.Drawing.Printing.PaperSourceKind" /> values or a custom value.</returns>
		public int RawKind
		{
			get
			{
				return (int)kind;
			}
			set
			{
				kind = (PaperSourceKind)value;
			}
		}

		/// <summary>Gets or sets the name of the paper source.</summary>
		/// <returns>The name of the paper source.</returns>
		public string SourceName
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PaperSource" /> class.</summary>
		public PaperSource()
		{
			kind = PaperSourceKind.Custom;
			name = string.Empty;
		}

		internal PaperSource(PaperSourceKind kind, string name)
		{
			this.kind = kind;
			this.name = name;
		}

		/// <summary>Provides information about the <see cref="T:System.Drawing.Printing.PaperSource" /> in string form.</summary>
		/// <returns>A string.</returns>
		public override string ToString()
		{
			return "[PaperSource " + SourceName + " Kind=" + TypeDescriptor.GetConverter(typeof(PaperSourceKind)).ConvertToString(Kind) + "]";
		}
	}
	/// <summary>Standard paper sources.</summary>
	[Serializable]
	public enum PaperSourceKind
	{
		/// <summary>The upper bin of a printer (or the default bin, if the printer only has one bin).</summary>
		Upper = 1,
		/// <summary>The lower bin of a printer.</summary>
		Lower = 2,
		/// <summary>The middle bin of a printer.</summary>
		Middle = 3,
		/// <summary>Manually fed paper.</summary>
		Manual = 4,
		/// <summary>An envelope.</summary>
		Envelope = 5,
		/// <summary>Manually fed envelope.</summary>
		ManualFeed = 6,
		/// <summary>Automatically fed paper.</summary>
		AutomaticFeed = 7,
		/// <summary>A tractor feed.</summary>
		TractorFeed = 8,
		/// <summary>Small-format paper.</summary>
		SmallFormat = 9,
		/// <summary>Large-format paper.</summary>
		LargeFormat = 10,
		/// <summary>The printer's large-capacity bin.</summary>
		LargeCapacity = 11,
		/// <summary>A paper cassette.</summary>
		Cassette = 14,
		/// <summary>The printer's default input bin.</summary>
		FormSource = 15,
		/// <summary>A printer-specific paper source.</summary>
		Custom = 257
	}
	/// <summary>Specifies print preview information for a single page. This class cannot be inherited.</summary>
	public sealed class PreviewPageInfo
	{
		private Image image;

		private Size physicalSize = Size.Empty;

		/// <summary>Gets the image of the printed page.</summary>
		/// <returns>An <see cref="T:System.Drawing.Image" /> representing the printed page.</returns>
		public Image Image => image;

		/// <summary>Gets the size of the printed page, in hundredths of an inch.</summary>
		/// <returns>A <see cref="T:System.Drawing.Size" /> that specifies the size of the printed page, in hundredths of an inch.</returns>
		public Size PhysicalSize => physicalSize;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PreviewPageInfo" /> class.</summary>
		/// <param name="image">The image of the printed page.</param>
		/// <param name="physicalSize">The size of the printed page, in hundredths of an inch.</param>
		public PreviewPageInfo(Image image, Size physicalSize)
		{
			this.image = image;
			this.physicalSize = physicalSize;
		}
	}
	/// <summary>Specifies a print controller that displays a document on a screen as a series of images.</summary>
	public class PreviewPrintController : PrintController
	{
		private IList list = new ArrayList();

		private Graphics graphics;

		private DeviceContext dc;

		private bool antiAlias;

		/// <summary>Gets a value indicating whether this controller is used for print preview.</summary>
		/// <returns>
		///   <see langword="true" /> in all cases.</returns>
		public override bool IsPreview => true;

		/// <summary>Gets or sets a value indicating whether to use anti-aliasing when displaying the print preview.</summary>
		/// <returns>
		///   <see langword="true" /> if the print preview uses anti-aliasing; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
		public virtual bool UseAntiAlias
		{
			get
			{
				return antiAlias;
			}
			set
			{
				antiAlias = value;
			}
		}

		private void CheckSecurity()
		{
			IntSecurity.SafePrinting.Demand();
		}

		/// <summary>Begins the control sequence that determines when and how to preview a print document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being previewed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains data about how to print the document.</param>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public override void OnStartPrint(PrintDocument document, PrintEventArgs e)
		{
			CheckSecurity();
			base.OnStartPrint(document, e);
			try
			{
				if (!document.PrinterSettings.IsValid)
				{
					throw new InvalidPrinterException(document.PrinterSettings);
				}
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				dc = document.PrinterSettings.CreateInformationContext(modeHandle);
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
		}

		/// <summary>Begins the control sequence that determines when and how to preview a page in a print document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being previewed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains data about how to preview a page in the print document. Initially, the <see cref="P:System.Drawing.Printing.PrintPageEventArgs.Graphics" /> property of this parameter will be <see langword="null" />. The value returned from this method will be used to set this property.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that represents a page from a <see cref="T:System.Drawing.Printing.PrintDocument" />.</returns>
		public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e)
		{
			CheckSecurity();
			base.OnStartPage(document, e);
			try
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				if (e.CopySettingsToDevMode)
				{
					e.PageSettings.CopyToHdevmode(modeHandle);
				}
				Size size = e.PageBounds.Size;
				Size size2 = PrinterUnitConvert.Convert(size, PrinterUnit.Display, PrinterUnit.HundredthsOfAMillimeter);
				Metafile image = new Metafile(dc.Hdc, new Rectangle(0, 0, size2.Width, size2.Height), MetafileFrameUnit.GdiCompatible, EmfType.EmfPlusOnly);
				PreviewPageInfo value = new PreviewPageInfo(image, size);
				list.Add(value);
				PrintPreviewGraphics printingHelper = new PrintPreviewGraphics(document, e);
				graphics = Graphics.FromImage(image);
				if (graphics != null && document.OriginAtMargins)
				{
					int deviceCaps = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 88);
					int deviceCaps2 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 90);
					int deviceCaps3 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 112);
					int deviceCaps4 = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(dc, dc.Hdc), 113);
					float num = deviceCaps3 * 100 / deviceCaps;
					float num2 = deviceCaps4 * 100 / deviceCaps2;
					graphics.TranslateTransform(0f - num, 0f - num2);
					graphics.TranslateTransform(document.DefaultPageSettings.Margins.Left, document.DefaultPageSettings.Margins.Top);
				}
				graphics.PrintingHelper = printingHelper;
				if (antiAlias)
				{
					graphics.TextRenderingHint = TextRenderingHint.AntiAlias;
					graphics.SmoothingMode = SmoothingMode.AntiAlias;
				}
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
			return graphics;
		}

		/// <summary>Completes the control sequence that determines when and how to preview a page in a print document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being previewed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains data about how to preview a page in the print document.</param>
		public override void OnEndPage(PrintDocument document, PrintPageEventArgs e)
		{
			CheckSecurity();
			graphics.Dispose();
			graphics = null;
			base.OnEndPage(document, e);
		}

		/// <summary>Completes the control sequence that determines when and how to preview a print document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document being previewed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains data about how to preview the print document.</param>
		public override void OnEndPrint(PrintDocument document, PrintEventArgs e)
		{
			CheckSecurity();
			dc.Dispose();
			dc = null;
			base.OnEndPrint(document, e);
		}

		/// <summary>Captures the pages of a document as a series of images.</summary>
		/// <returns>An array of type <see cref="T:System.Drawing.Printing.PreviewPageInfo" /> that contains the pages of a <see cref="T:System.Drawing.Printing.PrintDocument" /> as a series of images.</returns>
		public PreviewPageInfo[] GetPreviewPageInfo()
		{
			CheckSecurity();
			PreviewPageInfo[] array = new PreviewPageInfo[list.Count];
			list.CopyTo(array, 0);
			return array;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PreviewPrintController" /> class.</summary>
		public PreviewPrintController()
		{
		}
	}
	/// <summary>Specifies the type of print operation occurring.</summary>
	public enum PrintAction
	{
		/// <summary>The print operation is printing to a file.</summary>
		PrintToFile,
		/// <summary>The print operation is a print preview.</summary>
		PrintToPreview,
		/// <summary>The print operation is printing to a printer.</summary>
		PrintToPrinter
	}
	/// <summary>Controls how a document is printed, when printing from a Windows Forms application.</summary>
	public abstract class PrintController
	{
		[SecurityCritical]
		internal sealed class SafeDeviceModeHandle : SafeHandle
		{
			public override bool IsInvalid => handle == IntPtr.Zero;

			private SafeDeviceModeHandle()
				: base(IntPtr.Zero, ownsHandle: true)
			{
			}

			internal SafeDeviceModeHandle(IntPtr handle)
				: base(IntPtr.Zero, ownsHandle: true)
			{
				SetHandle(handle);
			}

			[SecurityCritical]
			protected override bool ReleaseHandle()
			{
				if (!IsInvalid)
				{
					SafeNativeMethods.GlobalFree(new HandleRef(this, handle));
				}
				handle = IntPtr.Zero;
				return true;
			}

			public static implicit operator IntPtr(SafeDeviceModeHandle handle)
			{
				return handle?.handle ?? IntPtr.Zero;
			}

			public static explicit operator SafeDeviceModeHandle(IntPtr handle)
			{
				return new SafeDeviceModeHandle(handle);
			}
		}

		internal SafeDeviceModeHandle modeHandle;

		/// <summary>Gets a value indicating whether the <see cref="T:System.Drawing.Printing.PrintController" /> is used for print preview.</summary>
		/// <returns>
		///   <see langword="false" /> in all cases.</returns>
		public virtual bool IsPreview => false;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintController" /> class.</summary>
		protected PrintController()
		{
			IntSecurity.SafePrinting.Demand();
		}

		internal void Print(PrintDocument document)
		{
			IntSecurity.SafePrinting.Demand();
			PrintAction action = (IsPreview ? PrintAction.PrintToPreview : ((!document.PrinterSettings.PrintToFile) ? PrintAction.PrintToPrinter : PrintAction.PrintToFile));
			PrintEventArgs printEventArgs = new PrintEventArgs(action);
			document._OnBeginPrint(printEventArgs);
			if (printEventArgs.Cancel)
			{
				document._OnEndPrint(printEventArgs);
				return;
			}
			OnStartPrint(document, printEventArgs);
			if (printEventArgs.Cancel)
			{
				document._OnEndPrint(printEventArgs);
				OnEndPrint(document, printEventArgs);
				return;
			}
			bool flag = true;
			try
			{
				flag = (LocalAppContextSwitches.OptimizePrintPreview ? PrintLoopOptimized(document) : PrintLoop(document));
			}
			finally
			{
				try
				{
					try
					{
						document._OnEndPrint(printEventArgs);
						printEventArgs.Cancel = flag | printEventArgs.Cancel;
					}
					finally
					{
						OnEndPrint(document, printEventArgs);
					}
				}
				finally
				{
					if (!IntSecurity.HasPermission(IntSecurity.AllPrinting))
					{
						IntSecurity.AllPrinting.Assert();
						document.PrinterSettings.PrintDialogDisplayed = false;
					}
				}
			}
		}

		private bool PrintLoop(PrintDocument document)
		{
			QueryPageSettingsEventArgs queryPageSettingsEventArgs = new QueryPageSettingsEventArgs((PageSettings)document.DefaultPageSettings.Clone());
			PrintPageEventArgs printPageEventArgs;
			do
			{
				document._OnQueryPageSettings(queryPageSettingsEventArgs);
				if (queryPageSettingsEventArgs.Cancel)
				{
					return true;
				}
				printPageEventArgs = CreatePrintPageEvent(queryPageSettingsEventArgs.PageSettings);
				Graphics graphics = OnStartPage(document, printPageEventArgs);
				printPageEventArgs.SetGraphics(graphics);
				try
				{
					document._OnPrintPage(printPageEventArgs);
					OnEndPage(document, printPageEventArgs);
				}
				finally
				{
					printPageEventArgs.Dispose();
				}
				if (printPageEventArgs.Cancel)
				{
					return true;
				}
			}
			while (printPageEventArgs.HasMorePages);
			return false;
		}

		private bool PrintLoopOptimized(PrintDocument document)
		{
			PrintPageEventArgs printPageEventArgs = null;
			PageSettings pageSettings = (PageSettings)document.DefaultPageSettings.Clone();
			QueryPageSettingsEventArgs queryPageSettingsEventArgs = new QueryPageSettingsEventArgs(pageSettings);
			do
			{
				queryPageSettingsEventArgs.PageSettingsChanged = false;
				document._OnQueryPageSettings(queryPageSettingsEventArgs);
				if (queryPageSettingsEventArgs.Cancel)
				{
					return true;
				}
				if (!queryPageSettingsEventArgs.PageSettingsChanged)
				{
					if (printPageEventArgs == null)
					{
						printPageEventArgs = CreatePrintPageEvent(queryPageSettingsEventArgs.PageSettings);
					}
					else
					{
						printPageEventArgs.CopySettingsToDevMode = false;
					}
					Graphics graphics = OnStartPage(document, printPageEventArgs);
					printPageEventArgs.SetGraphics(graphics);
				}
				else
				{
					printPageEventArgs = CreatePrintPageEvent(queryPageSettingsEventArgs.PageSettings);
					Graphics graphics2 = OnStartPage(document, printPageEventArgs);
					printPageEventArgs.SetGraphics(graphics2);
				}
				try
				{
					document._OnPrintPage(printPageEventArgs);
					OnEndPage(document, printPageEventArgs);
				}
				finally
				{
					printPageEventArgs.Graphics.Dispose();
					printPageEventArgs.SetGraphics(null);
				}
				if (printPageEventArgs.Cancel)
				{
					return true;
				}
			}
			while (printPageEventArgs.HasMorePages);
			return false;
		}

		private PrintPageEventArgs CreatePrintPageEvent(PageSettings pageSettings)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Assert();
			Rectangle bounds = pageSettings.GetBounds(modeHandle);
			Rectangle marginBounds = new Rectangle(pageSettings.Margins.Left, pageSettings.Margins.Top, bounds.Width - (pageSettings.Margins.Left + pageSettings.Margins.Right), bounds.Height - (pageSettings.Margins.Top + pageSettings.Margins.Bottom));
			return new PrintPageEventArgs(null, marginBounds, bounds, pageSettings);
		}

		/// <summary>When overridden in a derived class, begins the control sequence that determines when and how to print a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document currently being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains the event data.</param>
		public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Assert();
			modeHandle = (SafeDeviceModeHandle)document.PrinterSettings.GetHdevmode(document.DefaultPageSettings);
		}

		/// <summary>When overridden in a derived class, begins the control sequence that determines when and how to print a page of a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document currently being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains the event data.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that represents a page from a <see cref="T:System.Drawing.Printing.PrintDocument" />.</returns>
		public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e)
		{
			return null;
		}

		/// <summary>When overridden in a derived class, completes the control sequence that determines when and how to print a page of a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document currently being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains the event data.</param>
		public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e)
		{
		}

		/// <summary>When overridden in a derived class, completes the control sequence that determines when and how to print a document.</summary>
		/// <param name="document">A <see cref="T:System.Drawing.Printing.PrintDocument" /> that represents the document currently being printed.</param>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains the event data.</param>
		public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e)
		{
			IntSecurity.UnmanagedCode.Assert();
			if (modeHandle != null)
			{
				modeHandle.Close();
			}
		}
	}
	/// <summary>Defines a reusable object that sends output to a printer, when printing from a Windows Forms application.</summary>
	[ToolboxItemFilter("System.Drawing.Printing")]
	[DefaultProperty("DocumentName")]
	[SRDescription("PrintDocumentDesc")]
	[DefaultEvent("PrintPage")]
	public class PrintDocument : Component
	{
		private string documentName = "document";

		private PrintEventHandler beginPrintHandler;

		private PrintEventHandler endPrintHandler;

		private PrintPageEventHandler printPageHandler;

		private QueryPageSettingsEventHandler queryHandler;

		private PrinterSettings printerSettings = new PrinterSettings();

		private PageSettings defaultPageSettings;

		private PrintController printController;

		private bool originAtMargins;

		private bool userSetPageSettings;

		/// <summary>Gets or sets page settings that are used as defaults for all pages to be printed.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PageSettings" /> that specifies the default page settings for the document.</returns>
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[SRDescription("PDOCdocumentPageSettingsDescr")]
		public PageSettings DefaultPageSettings
		{
			get
			{
				return defaultPageSettings;
			}
			set
			{
				if (value == null)
				{
					value = new PageSettings();
				}
				defaultPageSettings = value;
				userSetPageSettings = true;
			}
		}

		/// <summary>Gets or sets the document name to display (for example, in a print status dialog box or printer queue) while printing the document.</summary>
		/// <returns>The document name to display while printing the document. The default is "document".</returns>
		[DefaultValue("document")]
		[SRDescription("PDOCdocumentNameDescr")]
		public string DocumentName
		{
			get
			{
				return documentName;
			}
			set
			{
				if (value == null)
				{
					value = "";
				}
				documentName = value;
			}
		}

		/// <summary>Gets or sets a value indicating whether the position of a graphics object associated with a page is located just inside the user-specified margins or at the top-left corner of the printable area of the page.</summary>
		/// <returns>
		///   <see langword="true" /> if the graphics origin starts at the page margins; <see langword="false" /> if the graphics origin is at the top-left corner of the printable page. The default is <see langword="false" />.</returns>
		[DefaultValue(false)]
		[SRDescription("PDOCoriginAtMarginsDescr")]
		public bool OriginAtMargins
		{
			get
			{
				return originAtMargins;
			}
			set
			{
				originAtMargins = value;
			}
		}

		/// <summary>Gets or sets the print controller that guides the printing process.</summary>
		/// <returns>The <see cref="T:System.Drawing.Printing.PrintController" /> that guides the printing process. The default is a new instance of the <see cref="T:System.Windows.Forms.PrintControllerWithStatusDialog" /> class.</returns>
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[SRDescription("PDOCprintControllerDescr")]
		public PrintController PrintController
		{
			get
			{
				IntSecurity.SafePrinting.Demand();
				if (printController == null)
				{
					printController = new StandardPrintController();
					new ReflectionPermission(PermissionState.Unrestricted).Assert();
					try
					{
						Type type = Type.GetType("System.Windows.Forms.PrintControllerWithStatusDialog, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
						printController = (PrintController)Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, new object[1] { printController }, null);
					}
					catch (TypeLoadException)
					{
					}
					catch (TargetInvocationException)
					{
					}
					catch (MissingMethodException)
					{
					}
					catch (MethodAccessException)
					{
					}
					catch (MemberAccessException)
					{
					}
					catch (FileNotFoundException)
					{
					}
					finally
					{
						CodeAccessPermission.RevertAssert();
					}
				}
				return printController;
			}
			set
			{
				IntSecurity.SafePrinting.Demand();
				printController = value;
			}
		}

		/// <summary>Gets or sets the printer that prints the document.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings" /> that specifies where and how the document is printed. The default is a <see cref="T:System.Drawing.Printing.PrinterSettings" /> with its properties set to their default values.</returns>
		[Browsable(false)]
		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
		[SRDescription("PDOCprinterSettingsDescr")]
		public PrinterSettings PrinterSettings
		{
			get
			{
				return printerSettings;
			}
			set
			{
				if (value == null)
				{
					value = new PrinterSettings();
				}
				printerSettings = value;
				if (!userSetPageSettings)
				{
					defaultPageSettings = printerSettings.DefaultPageSettings;
				}
			}
		}

		/// <summary>Occurs when the <see cref="M:System.Drawing.Printing.PrintDocument.Print" /> method is called and before the first page of the document prints.</summary>
		[SRDescription("PDOCbeginPrintDescr")]
		public event PrintEventHandler BeginPrint
		{
			add
			{
				beginPrintHandler = (PrintEventHandler)Delegate.Combine(beginPrintHandler, value);
			}
			remove
			{
				beginPrintHandler = (PrintEventHandler)Delegate.Remove(beginPrintHandler, value);
			}
		}

		/// <summary>Occurs when the last page of the document has printed.</summary>
		[SRDescription("PDOCendPrintDescr")]
		public event PrintEventHandler EndPrint
		{
			add
			{
				endPrintHandler = (PrintEventHandler)Delegate.Combine(endPrintHandler, value);
			}
			remove
			{
				endPrintHandler = (PrintEventHandler)Delegate.Remove(endPrintHandler, value);
			}
		}

		/// <summary>Occurs when the output to print for the current page is needed.</summary>
		[SRDescription("PDOCprintPageDescr")]
		public event PrintPageEventHandler PrintPage
		{
			add
			{
				printPageHandler = (PrintPageEventHandler)Delegate.Combine(printPageHandler, value);
			}
			remove
			{
				printPageHandler = (PrintPageEventHandler)Delegate.Remove(printPageHandler, value);
			}
		}

		/// <summary>Occurs immediately before each <see cref="E:System.Drawing.Printing.PrintDocument.PrintPage" /> event.</summary>
		[SRDescription("PDOCqueryPageSettingsDescr")]
		public event QueryPageSettingsEventHandler QueryPageSettings
		{
			add
			{
				queryHandler = (QueryPageSettingsEventHandler)Delegate.Combine(queryHandler, value);
			}
			remove
			{
				queryHandler = (QueryPageSettingsEventHandler)Delegate.Remove(queryHandler, value);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintDocument" /> class.</summary>
		public PrintDocument()
		{
			defaultPageSettings = new PageSettings(printerSettings);
		}

		internal void _OnBeginPrint(PrintEventArgs e)
		{
			OnBeginPrint(e);
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Printing.PrintDocument.BeginPrint" /> event. It is called after the <see cref="M:System.Drawing.Printing.PrintDocument.Print" /> method is called and before the first page of the document prints.</summary>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains the event data.</param>
		protected virtual void OnBeginPrint(PrintEventArgs e)
		{
			if (beginPrintHandler != null)
			{
				beginPrintHandler(this, e);
			}
		}

		internal void _OnEndPrint(PrintEventArgs e)
		{
			OnEndPrint(e);
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Printing.PrintDocument.EndPrint" /> event. It is called when the last page of the document has printed.</summary>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains the event data.</param>
		protected virtual void OnEndPrint(PrintEventArgs e)
		{
			if (endPrintHandler != null)
			{
				endPrintHandler(this, e);
			}
		}

		internal void _OnPrintPage(PrintPageEventArgs e)
		{
			OnPrintPage(e);
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Printing.PrintDocument.PrintPage" /> event. It is called before a page prints.</summary>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains the event data.</param>
		protected virtual void OnPrintPage(PrintPageEventArgs e)
		{
			if (printPageHandler != null)
			{
				printPageHandler(this, e);
			}
		}

		internal void _OnQueryPageSettings(QueryPageSettingsEventArgs e)
		{
			OnQueryPageSettings(e);
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Printing.PrintDocument.QueryPageSettings" /> event. It is called immediately before each <see cref="E:System.Drawing.Printing.PrintDocument.PrintPage" /> event.</summary>
		/// <param name="e">A <see cref="T:System.Drawing.Printing.QueryPageSettingsEventArgs" /> that contains the event data.</param>
		protected virtual void OnQueryPageSettings(QueryPageSettingsEventArgs e)
		{
			if (queryHandler != null)
			{
				queryHandler(this, e);
			}
		}

		/// <summary>Starts the document's printing process.</summary>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public void Print()
		{
			if (!PrinterSettings.IsDefaultPrinter && !PrinterSettings.PrintDialogDisplayed)
			{
				IntSecurity.AllPrinting.Demand();
			}
			PrintController printController = PrintController;
			printController.Print(this);
		}

		/// <summary>Provides information about the print document, in string form.</summary>
		/// <returns>A string.</returns>
		public override string ToString()
		{
			return "[PrintDocument " + DocumentName + "]";
		}
	}
	/// <summary>Represents the resolution supported by a printer.</summary>
	[Serializable]
	public class PrinterResolution
	{
		private int x;

		private int y;

		private PrinterResolutionKind kind;

		/// <summary>Gets or sets the printer resolution.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PrinterResolutionKind" /> values.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value assigned is not a member of the <see cref="T:System.Drawing.Printing.PrinterResolutionKind" /> enumeration.</exception>
		public PrinterResolutionKind Kind
		{
			get
			{
				return kind;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -4, 0))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PrinterResolutionKind));
				}
				kind = value;
			}
		}

		/// <summary>Gets the horizontal printer resolution, in dots per inch.</summary>
		/// <returns>The horizontal printer resolution, in dots per inch, if <see cref="P:System.Drawing.Printing.PrinterResolution.Kind" /> is set to <see cref="F:System.Drawing.Printing.PrinterResolutionKind.Custom" />; otherwise, a <see langword="dmPrintQuality" /> value.</returns>
		public int X
		{
			get
			{
				return x;
			}
			set
			{
				x = value;
			}
		}

		/// <summary>Gets the vertical printer resolution, in dots per inch.</summary>
		/// <returns>The vertical printer resolution, in dots per inch.</returns>
		public int Y
		{
			get
			{
				return y;
			}
			set
			{
				y = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterResolution" /> class.</summary>
		public PrinterResolution()
		{
			kind = PrinterResolutionKind.Custom;
		}

		internal PrinterResolution(PrinterResolutionKind kind, int x, int y)
		{
			this.kind = kind;
			this.x = x;
			this.y = y;
		}

		/// <summary>This member overrides the <see cref="M:System.Object.ToString" /> method.</summary>
		/// <returns>A <see cref="T:System.String" /> that contains information about the <see cref="T:System.Drawing.Printing.PrinterResolution" />.</returns>
		public override string ToString()
		{
			if (kind != 0)
			{
				return "[PrinterResolution " + TypeDescriptor.GetConverter(typeof(PrinterResolutionKind)).ConvertToString((int)Kind) + "]";
			}
			return "[PrinterResolution X=" + X.ToString(CultureInfo.InvariantCulture) + " Y=" + Y.ToString(CultureInfo.InvariantCulture) + "]";
		}
	}
	/// <summary>Specifies a printer resolution.</summary>
	[Serializable]
	public enum PrinterResolutionKind
	{
		/// <summary>High resolution.</summary>
		High = -4,
		/// <summary>Medium resolution.</summary>
		Medium,
		/// <summary>Low resolution.</summary>
		Low,
		/// <summary>Draft-quality resolution.</summary>
		Draft,
		/// <summary>Custom resolution.</summary>
		Custom
	}
	/// <summary>Specifies information about how a document is printed, including the printer that prints it, when printing from a Windows Forms application.</summary>
	[Serializable]
	public class PrinterSettings : ICloneable
	{
		/// <summary>Contains a collection of <see cref="T:System.Drawing.Printing.PaperSize" /> objects.</summary>
		public class PaperSizeCollection : ICollection, IEnumerable
		{
			private PaperSize[] array;

			/// <summary>Gets the number of different paper sizes in the collection.</summary>
			/// <returns>The number of different paper sizes in the collection.</returns>
			public int Count => array.Length;

			/// <summary>Gets the <see cref="T:System.Drawing.Printing.PaperSize" /> at a specified index.</summary>
			/// <param name="index">The index of the <see cref="T:System.Drawing.Printing.PaperSize" /> to get.</param>
			/// <returns>The <see cref="T:System.Drawing.Printing.PaperSize" /> at the specified index.</returns>
			public virtual PaperSize this[int index] => array[index];

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.Count" />.</summary>
			int ICollection.Count => Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
			bool ICollection.IsSynchronized => false;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
			object ICollection.SyncRoot => this;

			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSizeCollection" /> class.</summary>
			/// <param name="array">An array of type <see cref="T:System.Drawing.Printing.PaperSize" />.</param>
			public PaperSizeCollection(PaperSize[] array)
			{
				this.array = array;
			}

			/// <summary>Returns an enumerator that can iterate through the collection.</summary>
			/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSizeCollection" />.</returns>
			public IEnumerator GetEnumerator()
			{
				object[] array = this.array;
				return new ArrayEnumerator(array, 0, Count);
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
			/// <param name="array">A zero-based array that receives the items copied from the collection.</param>
			/// <param name="index">The index at which to start copying items.</param>
			void ICollection.CopyTo(Array array, int index)
			{
				Array.Copy(this.array, index, array, 0, this.array.Length);
			}

			/// <summary>Copies the contents of the current <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSizeCollection" /> to the specified array, starting at the specified index.</summary>
			/// <param name="paperSizes">A zero-based array that receives the items copied from the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSizeCollection" />.</param>
			/// <param name="index">The index at which to start copying items.</param>
			public void CopyTo(PaperSize[] paperSizes, int index)
			{
				Array.Copy(array, index, paperSizes, 0, array.Length);
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
			/// <returns>An enumerator associated with the collection.</returns>
			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			/// <summary>Adds a <see cref="T:System.Drawing.Printing.PrinterResolution" /> to the end of the collection.</summary>
			/// <param name="paperSize">The <see cref="T:System.Drawing.Printing.PaperSize" /> to add to the collection.</param>
			/// <returns>The zero-based index of the newly added item.</returns>
			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(PaperSize paperSize)
			{
				PaperSize[] array = new PaperSize[Count + 1];
				((ICollection)this).CopyTo((Array)array, 0);
				array[Count] = paperSize;
				this.array = array;
				return Count;
			}
		}

		/// <summary>Contains a collection of <see cref="T:System.Drawing.Printing.PaperSource" /> objects.</summary>
		public class PaperSourceCollection : ICollection, IEnumerable
		{
			private PaperSource[] array;

			/// <summary>Gets the number of different paper sources in the collection.</summary>
			/// <returns>The number of different paper sources in the collection.</returns>
			public int Count => array.Length;

			/// <summary>Gets the <see cref="T:System.Drawing.Printing.PaperSource" /> at a specified index.</summary>
			/// <param name="index">The index of the <see cref="T:System.Drawing.Printing.PaperSource" /> to get.</param>
			/// <returns>The <see cref="T:System.Drawing.Printing.PaperSource" /> at the specified index.</returns>
			public virtual PaperSource this[int index] => array[index];

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.Count" />.</summary>
			int ICollection.Count => Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
			bool ICollection.IsSynchronized => false;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
			object ICollection.SyncRoot => this;

			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" /> class.</summary>
			/// <param name="array">An array of type <see cref="T:System.Drawing.Printing.PaperSource" />.</param>
			public PaperSourceCollection(PaperSource[] array)
			{
				this.array = array;
			}

			/// <summary>Returns an enumerator that can iterate through the collection.</summary>
			/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" />.</returns>
			public IEnumerator GetEnumerator()
			{
				object[] array = this.array;
				return new ArrayEnumerator(array, 0, Count);
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
			/// <param name="array">The destination array for the contents of the collection.</param>
			/// <param name="index">The index at which to start the copy operation.</param>
			void ICollection.CopyTo(Array array, int index)
			{
				Array.Copy(this.array, index, array, 0, this.array.Length);
			}

			/// <summary>Copies the contents of the current <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" /> to the specified array, starting at the specified index.</summary>
			/// <param name="paperSources">A zero-based array that receives the items copied from the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" />.</param>
			/// <param name="index">The index at which to start copying items.</param>
			public void CopyTo(PaperSource[] paperSources, int index)
			{
				Array.Copy(array, index, paperSources, 0, array.Length);
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			/// <summary>Adds the specified <see cref="T:System.Drawing.Printing.PaperSource" /> to end of the <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" />.</summary>
			/// <param name="paperSource">The <see cref="T:System.Drawing.Printing.PaperSource" /> to add to the collection.</param>
			/// <returns>The zero-based index where the <see cref="T:System.Drawing.Printing.PaperSource" /> was added.</returns>
			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(PaperSource paperSource)
			{
				PaperSource[] array = new PaperSource[Count + 1];
				((ICollection)this).CopyTo((Array)array, 0);
				array[Count] = paperSource;
				this.array = array;
				return Count;
			}
		}

		/// <summary>Contains a collection of <see cref="T:System.Drawing.Printing.PrinterResolution" /> objects.</summary>
		public class PrinterResolutionCollection : ICollection, IEnumerable
		{
			private PrinterResolution[] array;

			/// <summary>Gets the number of available printer resolutions in the collection.</summary>
			/// <returns>The number of available printer resolutions in the collection.</returns>
			public int Count => array.Length;

			/// <summary>Gets the <see cref="T:System.Drawing.Printing.PrinterResolution" /> at a specified index.</summary>
			/// <param name="index">The index of the <see cref="T:System.Drawing.Printing.PrinterResolution" /> to get.</param>
			/// <returns>The <see cref="T:System.Drawing.Printing.PrinterResolution" /> at the specified index.</returns>
			public virtual PrinterResolution this[int index] => array[index];

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.Count" />.</summary>
			int ICollection.Count => Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
			bool ICollection.IsSynchronized => false;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
			object ICollection.SyncRoot => this;

			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" /> class.</summary>
			/// <param name="array">An array of type <see cref="T:System.Drawing.Printing.PrinterResolution" />.</param>
			public PrinterResolutionCollection(PrinterResolution[] array)
			{
				this.array = array;
			}

			/// <summary>Returns an enumerator that can iterate through the collection.</summary>
			/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" />.</returns>
			public IEnumerator GetEnumerator()
			{
				object[] array = this.array;
				return new ArrayEnumerator(array, 0, Count);
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
			/// <param name="array">The destination array.</param>
			/// <param name="index">The index at which to start the copy operation.</param>
			void ICollection.CopyTo(Array array, int index)
			{
				Array.Copy(this.array, index, array, 0, this.array.Length);
			}

			/// <summary>Copies the contents of the current <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" /> to the specified array, starting at the specified index.</summary>
			/// <param name="printerResolutions">A zero-based array that receives the items copied from the <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" />.</param>
			/// <param name="index">The index at which to start copying items.</param>
			public void CopyTo(PrinterResolution[] printerResolutions, int index)
			{
				Array.Copy(array, index, printerResolutions, 0, array.Length);
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			/// <summary>Adds a <see cref="T:System.Drawing.Printing.PrinterResolution" /> to the end of the collection.</summary>
			/// <param name="printerResolution">The <see cref="T:System.Drawing.Printing.PrinterResolution" /> to add to the collection.</param>
			/// <returns>The zero-based index of the newly added item.</returns>
			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(PrinterResolution printerResolution)
			{
				PrinterResolution[] array = new PrinterResolution[Count + 1];
				((ICollection)this).CopyTo((Array)array, 0);
				array[Count] = printerResolution;
				this.array = array;
				return Count;
			}
		}

		/// <summary>Contains a collection of <see cref="T:System.String" /> objects.</summary>
		public class StringCollection : ICollection, IEnumerable
		{
			private string[] array;

			/// <summary>Gets the number of strings in the collection.</summary>
			/// <returns>The number of strings in the collection.</returns>
			public int Count => array.Length;

			/// <summary>Gets the <see cref="T:System.String" /> at a specified index.</summary>
			/// <param name="index">The index of the <see cref="T:System.String" /> to get.</param>
			/// <returns>The <see cref="T:System.String" /> at the specified index.</returns>
			public virtual string this[int index] => array[index];

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.Count" />.</summary>
			int ICollection.Count => Count;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.IsSynchronized" />.</summary>
			bool ICollection.IsSynchronized => false;

			/// <summary>For a description of this member, see <see cref="P:System.Collections.ICollection.SyncRoot" />.</summary>
			object ICollection.SyncRoot => this;

			/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterSettings.StringCollection" /> class.</summary>
			/// <param name="array">An array of type <see cref="T:System.String" />.</param>
			public StringCollection(string[] array)
			{
				this.array = array;
			}

			/// <summary>Returns an enumerator that can iterate through the collection.</summary>
			/// <returns>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Drawing.Printing.PrinterSettings.StringCollection" />.</returns>
			public IEnumerator GetEnumerator()
			{
				object[] array = this.array;
				return new ArrayEnumerator(array, 0, Count);
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />.</summary>
			/// <param name="array">The array for items to be copied to.</param>
			/// <param name="index">The starting index.</param>
			void ICollection.CopyTo(Array array, int index)
			{
				Array.Copy(this.array, index, array, 0, this.array.Length);
			}

			/// <summary>Copies the contents of the current <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" /> to the specified array, starting at the specified index</summary>
			/// <param name="strings">A zero-based array that receives the items copied from the <see cref="T:System.Drawing.Printing.PrinterSettings.StringCollection" />.</param>
			/// <param name="index">The index at which to start copying items.</param>
			public void CopyTo(string[] strings, int index)
			{
				Array.Copy(array, index, strings, 0, array.Length);
			}

			/// <summary>For a description of this member, see <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			/// <summary>Adds a string to the end of the collection.</summary>
			/// <param name="value">The string to add to the collection.</param>
			/// <returns>The zero-based index of the newly added item.</returns>
			[EditorBrowsable(EditorBrowsableState.Never)]
			public int Add(string value)
			{
				string[] array = new string[Count + 1];
				((ICollection)this).CopyTo((Array)array, 0);
				array[Count] = value;
				this.array = array;
				return Count;
			}
		}

		private class ArrayEnumerator : IEnumerator
		{
			private object[] array;

			private object item;

			private int index;

			private int startIndex;

			private int endIndex;

			public object Current => item;

			public ArrayEnumerator(object[] array, int startIndex, int count)
			{
				this.array = array;
				this.startIndex = startIndex;
				endIndex = index + count;
				index = this.startIndex;
			}

			public bool MoveNext()
			{
				if (index >= endIndex)
				{
					return false;
				}
				item = array[index++];
				return true;
			}

			public void Reset()
			{
				index = startIndex;
				item = null;
			}
		}

		private const int PADDING_IA64 = 4;

		private string printerName;

		private string driverName = "";

		private string outputPort = "";

		private bool printToFile;

		private bool printDialogDisplayed;

		private short extrabytes;

		private byte[] extrainfo;

		private short copies = -1;

		private Duplex duplex = Duplex.Default;

		private TriState collate = TriState.Default;

		private PageSettings defaultPageSettings;

		private int fromPage;

		private int toPage;

		private int maxPage = 9999;

		private int minPage;

		private PrintRange printRange;

		private short devmodebytes;

		private byte[] cachedDevmode;

		/// <summary>Gets a value indicating whether the printer supports double-sided printing.</summary>
		/// <returns>
		///   <see langword="true" /> if the printer supports double-sided printing; otherwise, <see langword="false" />.</returns>
		public bool CanDuplex => DeviceCapabilities(7, IntPtr.Zero, 0) == 1;

		/// <summary>Gets or sets the number of copies of the document to print.</summary>
		/// <returns>The number of copies to print. The default is 1.</returns>
		/// <exception cref="T:System.ArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.Copies" /> property is less than zero.</exception>
		public short Copies
		{
			get
			{
				if (copies != -1)
				{
					return copies;
				}
				return GetModeField(ModeField.Copies, 1);
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", "value", value.ToString(CultureInfo.CurrentCulture), 0.ToString(CultureInfo.CurrentCulture)));
				}
				IntSecurity.SafePrinting.Demand();
				copies = value;
			}
		}

		/// <summary>Gets or sets a value indicating whether the printed document is collated.</summary>
		/// <returns>
		///   <see langword="true" /> if the printed document is collated; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
		public bool Collate
		{
			get
			{
				if (!collate.IsDefault)
				{
					return (bool)collate;
				}
				return GetModeField(ModeField.Collate, 0) == 1;
			}
			set
			{
				collate = value;
			}
		}

		/// <summary>Gets the default page settings for this printer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PageSettings" /> that represents the default page settings for this printer.</returns>
		public PageSettings DefaultPageSettings => defaultPageSettings;

		internal string DriverName => driverName;

		/// <summary>Gets or sets the printer setting for double-sided printing.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.Duplex" /> values. The default is determined by the printer.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.Duplex" /> property is not one of the <see cref="T:System.Drawing.Printing.Duplex" /> values.</exception>
		public Duplex Duplex
		{
			get
			{
				if (duplex != Duplex.Default)
				{
					return duplex;
				}
				return (Duplex)GetModeField(ModeField.Duplex, 1);
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, -1, 3))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(Duplex));
				}
				duplex = value;
			}
		}

		/// <summary>Gets or sets the page number of the first page to print.</summary>
		/// <returns>The page number of the first page to print.</returns>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> property's value is less than zero.</exception>
		public int FromPage
		{
			get
			{
				return fromPage;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", "value", value.ToString(CultureInfo.CurrentCulture), 0.ToString(CultureInfo.CurrentCulture)));
				}
				fromPage = value;
			}
		}

		/// <summary>Gets the names of all printers installed on the computer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings.StringCollection" /> that represents the names of all printers installed on the computer.</returns>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The available printers could not be enumerated.</exception>
		public static StringCollection InstalledPrinters
		{
			get
			{
				IntSecurity.AllPrinting.Demand();
				int level;
				int num;
				if (Environment.OSVersion.Platform == PlatformID.Win32NT)
				{
					level = 4;
					num = ((IntPtr.Size != 8) ? (IntPtr.Size * 2 + Marshal.SizeOf(typeof(int))) : (IntPtr.Size * 2 + Marshal.SizeOf(typeof(int)) + 4));
				}
				else
				{
					level = 5;
					num = IntPtr.Size * 2 + Marshal.SizeOf(typeof(int)) * 3;
				}
				IntSecurity.UnmanagedCode.Assert();
				string[] array;
				try
				{
					SafeNativeMethods.EnumPrinters(6, null, level, IntPtr.Zero, 0, out var pcbNeeded, out var pcReturned);
					IntPtr intPtr = Marshal.AllocCoTaskMem(pcbNeeded);
					int num2 = SafeNativeMethods.EnumPrinters(6, null, level, intPtr, pcbNeeded, out pcbNeeded, out pcReturned);
					array = new string[pcReturned];
					if (num2 == 0)
					{
						Marshal.FreeCoTaskMem(intPtr);
						throw new Win32Exception();
					}
					for (int i = 0; i < pcReturned; i++)
					{
						IntPtr ptr = Marshal.ReadIntPtr((IntPtr)checked((long)intPtr + i * num));
						array[i] = Marshal.PtrToStringAuto(ptr);
					}
					Marshal.FreeCoTaskMem(intPtr);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				return new StringCollection(array);
			}
		}

		/// <summary>Gets a value indicating whether the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property designates the default printer, except when the user explicitly sets <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" />.</summary>
		/// <returns>
		///   <see langword="true" /> if <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> designates the default printer; otherwise, <see langword="false" />.</returns>
		public bool IsDefaultPrinter
		{
			get
			{
				if (printerName != null)
				{
					return printerName == GetDefaultPrinterName();
				}
				return true;
			}
		}

		/// <summary>Gets a value indicating whether the printer is a plotter.</summary>
		/// <returns>
		///   <see langword="true" /> if the printer is a plotter; <see langword="false" /> if the printer is a raster.</returns>
		public bool IsPlotter => GetDeviceCaps(2, 2) == 0;

		/// <summary>Gets a value indicating whether the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property designates a valid printer.</summary>
		/// <returns>
		///   <see langword="true" /> if the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property designates a valid printer; otherwise, <see langword="false" />.</returns>
		public bool IsValid => DeviceCapabilities(18, IntPtr.Zero, -1) != -1;

		/// <summary>Gets the angle, in degrees, that the portrait orientation is rotated to produce the landscape orientation.</summary>
		/// <returns>The angle, in degrees, that the portrait orientation is rotated to produce the landscape orientation.</returns>
		public int LandscapeAngle => DeviceCapabilities(17, IntPtr.Zero, 0);

		/// <summary>Gets the maximum number of copies that the printer enables the user to print at a time.</summary>
		/// <returns>The maximum number of copies that the printer enables the user to print at a time.</returns>
		public int MaximumCopies => DeviceCapabilities(18, IntPtr.Zero, 1);

		/// <summary>Gets or sets the maximum <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> or <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> that can be selected in a <see cref="T:System.Windows.Forms.PrintDialog" />.</summary>
		/// <returns>The maximum <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> or <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> that can be selected in a <see cref="T:System.Windows.Forms.PrintDialog" />.</returns>
		/// <exception cref="T:System.ArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.MaximumPage" /> property is less than zero.</exception>
		public int MaximumPage
		{
			get
			{
				return maxPage;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", "value", value.ToString(CultureInfo.CurrentCulture), 0.ToString(CultureInfo.CurrentCulture)));
				}
				maxPage = value;
			}
		}

		/// <summary>Gets or sets the minimum <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> or <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> that can be selected in a <see cref="T:System.Windows.Forms.PrintDialog" />.</summary>
		/// <returns>The minimum <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> or <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> that can be selected in a <see cref="T:System.Windows.Forms.PrintDialog" />.</returns>
		/// <exception cref="T:System.ArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.MinimumPage" /> property is less than zero.</exception>
		public int MinimumPage
		{
			get
			{
				return minPage;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", "value", value.ToString(CultureInfo.CurrentCulture), 0.ToString(CultureInfo.CurrentCulture)));
				}
				minPage = value;
			}
		}

		internal string OutputPort
		{
			get
			{
				return outputPort;
			}
			set
			{
				outputPort = value;
			}
		}

		/// <summary>Gets or sets the file name, when printing to a file.</summary>
		/// <returns>The file name, when printing to a file.</returns>
		public string PrintFileName
		{
			get
			{
				string text = OutputPort;
				if (!string.IsNullOrEmpty(text))
				{
					IntSecurity.DemandReadFileIO(text);
				}
				return text;
			}
			set
			{
				if (string.IsNullOrEmpty(value))
				{
					throw new ArgumentNullException(value);
				}
				IntSecurity.DemandWriteFileIO(value);
				OutputPort = value;
			}
		}

		/// <summary>Gets the paper sizes that are supported by this printer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSizeCollection" /> that represents the paper sizes that are supported by this printer.</returns>
		public PaperSizeCollection PaperSizes => new PaperSizeCollection(Get_PaperSizes());

		/// <summary>Gets the paper source trays that are available on the printer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings.PaperSourceCollection" /> that represents the paper source trays that are available on this printer.</returns>
		public PaperSourceCollection PaperSources => new PaperSourceCollection(Get_PaperSources());

		internal bool PrintDialogDisplayed
		{
			get
			{
				return printDialogDisplayed;
			}
			set
			{
				IntSecurity.AllPrinting.Demand();
				printDialogDisplayed = value;
			}
		}

		/// <summary>Gets or sets the page numbers that the user has specified to be printed.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PrintRange" /> values.</returns>
		/// <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.PrintRange" /> property is not one of the <see cref="T:System.Drawing.Printing.PrintRange" /> values.</exception>
		public PrintRange PrintRange
		{
			get
			{
				return printRange;
			}
			set
			{
				if (!Enum.IsDefined(typeof(PrintRange), value))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PrintRange));
				}
				printRange = value;
			}
		}

		/// <summary>Gets or sets a value indicating whether the printing output is sent to a file instead of a port.</summary>
		/// <returns>
		///   <see langword="true" /> if the printing output is sent to a file; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
		public bool PrintToFile
		{
			get
			{
				return printToFile;
			}
			set
			{
				printToFile = value;
			}
		}

		/// <summary>Gets or sets the name of the printer to use.</summary>
		/// <returns>The name of the printer to use.</returns>
		public string PrinterName
		{
			get
			{
				IntSecurity.AllPrinting.Demand();
				return PrinterNameInternal;
			}
			set
			{
				IntSecurity.AllPrinting.Demand();
				PrinterNameInternal = value;
			}
		}

		private string PrinterNameInternal
		{
			get
			{
				if (printerName == null)
				{
					return GetDefaultPrinterName();
				}
				return printerName;
			}
			set
			{
				cachedDevmode = null;
				extrainfo = null;
				printerName = value;
			}
		}

		/// <summary>Gets all the resolutions that are supported by this printer.</summary>
		/// <returns>A <see cref="T:System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection" /> that represents the resolutions that are supported by this printer.</returns>
		public PrinterResolutionCollection PrinterResolutions => new PrinterResolutionCollection(Get_PrinterResolutions());

		/// <summary>Gets a value indicating whether this printer supports color printing.</summary>
		/// <returns>
		///   <see langword="true" /> if this printer supports color; otherwise, <see langword="false" />.</returns>
		public bool SupportsColor => GetDeviceCaps(12, 1) > 1;

		/// <summary>Gets or sets the number of the last page to print.</summary>
		/// <returns>The number of the last page to print.</returns>
		/// <exception cref="T:System.ArgumentException">The value of the <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> property is less than zero.</exception>
		public int ToPage
		{
			get
			{
				return toPage;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException(SR.GetString("InvalidLowBoundArgumentEx", "value", value.ToString(CultureInfo.CurrentCulture), 0.ToString(CultureInfo.CurrentCulture)));
				}
				toPage = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrinterSettings" /> class.</summary>
		public PrinterSettings()
		{
			defaultPageSettings = new PageSettings(this);
		}

		/// <summary>Returns a value indicating whether the printer supports printing the specified image format.</summary>
		/// <param name="imageFormat">An <see cref="T:System.Drawing.Imaging.ImageFormat" /> to print.</param>
		/// <returns>
		///   <see langword="true" /> if the printer supports printing the specified image format; otherwise, <see langword="false" />.</returns>
		public bool IsDirectPrintingSupported(ImageFormat imageFormat)
		{
			bool result = false;
			if (imageFormat.Equals(ImageFormat.Jpeg) || imageFormat.Equals(ImageFormat.Png))
			{
				int inData = (imageFormat.Equals(ImageFormat.Jpeg) ? 4119 : 4120);
				int outData = 0;
				DeviceContext deviceContext = CreateInformationContext(DefaultPageSettings);
				HandleRef hDC = new HandleRef(deviceContext, deviceContext.Hdc);
				try
				{
					return SafeNativeMethods.ExtEscape(hDC, 8, Marshal.SizeOf(typeof(int)), ref inData, 0, out outData) > 0;
				}
				finally
				{
					deviceContext.Dispose();
				}
			}
			return result;
		}

		/// <summary>Gets a value indicating whether the printer supports printing the specified image file.</summary>
		/// <param name="image">The image to print.</param>
		/// <returns>
		///   <see langword="true" /> if the printer supports printing the specified image; otherwise, <see langword="false" />.</returns>
		public bool IsDirectPrintingSupported(Image image)
		{
			bool result = false;
			if (image.RawFormat.Equals(ImageFormat.Jpeg) || image.RawFormat.Equals(ImageFormat.Png))
			{
				MemoryStream memoryStream = new MemoryStream();
				try
				{
					image.Save(memoryStream, image.RawFormat);
					memoryStream.Position = 0L;
					using BufferedStream bufferedStream = new BufferedStream(memoryStream);
					int num = (int)bufferedStream.Length;
					byte[] array = new byte[num];
					int num2 = bufferedStream.Read(array, 0, num);
					int inData = (image.RawFormat.Equals(ImageFormat.Jpeg) ? 4119 : 4120);
					int outData = 0;
					DeviceContext deviceContext = CreateInformationContext(DefaultPageSettings);
					HandleRef hDC = new HandleRef(deviceContext, deviceContext.Hdc);
					try
					{
						if (SafeNativeMethods.ExtEscape(hDC, 8, Marshal.SizeOf(typeof(int)), ref inData, 0, out outData) > 0)
						{
							return SafeNativeMethods.ExtEscape(hDC, inData, num, array, Marshal.SizeOf(typeof(int)), out outData) > 0 && outData == 1;
						}
						return result;
					}
					finally
					{
						deviceContext.Dispose();
					}
				}
				finally
				{
					memoryStream.Close();
				}
			}
			return result;
		}

		/// <summary>Creates a copy of this <see cref="T:System.Drawing.Printing.PrinterSettings" />.</summary>
		/// <returns>A copy of this object.</returns>
		public object Clone()
		{
			PrinterSettings printerSettings = (PrinterSettings)MemberwiseClone();
			printerSettings.printDialogDisplayed = false;
			return printerSettings;
		}

		internal DeviceContext CreateDeviceContext(PageSettings pageSettings)
		{
			IntPtr hdevmodeInternal = GetHdevmodeInternal();
			DeviceContext deviceContext = null;
			try
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				try
				{
					pageSettings.CopyToHdevmode(hdevmodeInternal);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				return CreateDeviceContext(hdevmodeInternal);
			}
			finally
			{
				SafeNativeMethods.GlobalFree(new HandleRef(null, hdevmodeInternal));
			}
		}

		internal DeviceContext CreateDeviceContext(IntPtr hdevmode)
		{
			IntPtr handle = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
			DeviceContext result = DeviceContext.CreateDC(DriverName, PrinterNameInternal, null, new HandleRef(null, handle));
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
			return result;
		}

		internal DeviceContext CreateInformationContext(PageSettings pageSettings)
		{
			IntPtr hdevmodeInternal = GetHdevmodeInternal();
			try
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				try
				{
					pageSettings.CopyToHdevmode(hdevmodeInternal);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				return CreateInformationContext(hdevmodeInternal);
			}
			finally
			{
				SafeNativeMethods.GlobalFree(new HandleRef(null, hdevmodeInternal));
			}
		}

		internal DeviceContext CreateInformationContext(IntPtr hdevmode)
		{
			IntPtr handle = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
			DeviceContext result = DeviceContext.CreateIC(DriverName, PrinterNameInternal, null, new HandleRef(null, handle));
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
			return result;
		}

		/// <summary>Returns a <see cref="T:System.Drawing.Graphics" /> that contains printer information that is useful when creating a <see cref="T:System.Drawing.Printing.PrintDocument" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that contains information from a printer.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		public Graphics CreateMeasurementGraphics()
		{
			return CreateMeasurementGraphics(DefaultPageSettings);
		}

		/// <summary>Returns a <see cref="T:System.Drawing.Graphics" /> that contains printer information, optionally specifying the origin at the margins.</summary>
		/// <param name="honorOriginAtMargins">
		///   <see langword="true" /> to indicate the origin at the margins; otherwise, <see langword="false" />.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that contains printer information from the <see cref="T:System.Drawing.Printing.PageSettings" />.</returns>
		public Graphics CreateMeasurementGraphics(bool honorOriginAtMargins)
		{
			Graphics graphics = CreateMeasurementGraphics();
			if (graphics != null && honorOriginAtMargins)
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				try
				{
					graphics.TranslateTransform(0f - defaultPageSettings.HardMarginX, 0f - defaultPageSettings.HardMarginY);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				graphics.TranslateTransform(defaultPageSettings.Margins.Left, defaultPageSettings.Margins.Top);
			}
			return graphics;
		}

		/// <summary>Returns a <see cref="T:System.Drawing.Graphics" /> that contains printer information associated with the specified <see cref="T:System.Drawing.Printing.PageSettings" />.</summary>
		/// <param name="pageSettings">The <see cref="T:System.Drawing.Printing.PageSettings" /> to retrieve a graphics object for.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that contains printer information from the <see cref="T:System.Drawing.Printing.PageSettings" />.</returns>
		public Graphics CreateMeasurementGraphics(PageSettings pageSettings)
		{
			DeviceContext deviceContext = CreateDeviceContext(pageSettings);
			Graphics graphics = Graphics.FromHdcInternal(deviceContext.Hdc);
			graphics.PrintingHelper = deviceContext;
			return graphics;
		}

		/// <summary>Creates a <see cref="T:System.Drawing.Graphics" /> associated with the specified page settings and optionally specifying the origin at the margins.</summary>
		/// <param name="pageSettings">The <see cref="T:System.Drawing.Printing.PageSettings" /> to retrieve a <see cref="T:System.Drawing.Graphics" /> object for.</param>
		/// <param name="honorOriginAtMargins">
		///   <see langword="true" /> to specify the origin at the margins; otherwise, <see langword="false" />.</param>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> that contains printer information from the <see cref="T:System.Drawing.Printing.PageSettings" />.</returns>
		public Graphics CreateMeasurementGraphics(PageSettings pageSettings, bool honorOriginAtMargins)
		{
			Graphics graphics = CreateMeasurementGraphics();
			if (graphics != null && honorOriginAtMargins)
			{
				IntSecurity.AllPrintingAndUnmanagedCode.Assert();
				try
				{
					graphics.TranslateTransform(0f - pageSettings.HardMarginX, 0f - pageSettings.HardMarginY);
				}
				finally
				{
					CodeAccessPermission.RevertAssert();
				}
				graphics.TranslateTransform(pageSettings.Margins.Left, pageSettings.Margins.Top);
			}
			return graphics;
		}

		private static SafeNativeMethods.PRINTDLGX86 CreatePRINTDLGX86()
		{
			SafeNativeMethods.PRINTDLGX86 pRINTDLGX = new SafeNativeMethods.PRINTDLGX86();
			pRINTDLGX.lStructSize = Marshal.SizeOf(typeof(SafeNativeMethods.PRINTDLGX86));
			pRINTDLGX.hwndOwner = IntPtr.Zero;
			pRINTDLGX.hDevMode = IntPtr.Zero;
			pRINTDLGX.hDevNames = IntPtr.Zero;
			pRINTDLGX.Flags = 0;
			pRINTDLGX.hwndOwner = IntPtr.Zero;
			pRINTDLGX.hDC = IntPtr.Zero;
			pRINTDLGX.nFromPage = 1;
			pRINTDLGX.nToPage = 1;
			pRINTDLGX.nMinPage = 0;
			pRINTDLGX.nMaxPage = 9999;
			pRINTDLGX.nCopies = 1;
			pRINTDLGX.hInstance = IntPtr.Zero;
			pRINTDLGX.lCustData = IntPtr.Zero;
			pRINTDLGX.lpfnPrintHook = IntPtr.Zero;
			pRINTDLGX.lpfnSetupHook = IntPtr.Zero;
			pRINTDLGX.lpPrintTemplateName = null;
			pRINTDLGX.lpSetupTemplateName = null;
			pRINTDLGX.hPrintTemplate = IntPtr.Zero;
			pRINTDLGX.hSetupTemplate = IntPtr.Zero;
			return pRINTDLGX;
		}

		private static SafeNativeMethods.PRINTDLG CreatePRINTDLG()
		{
			SafeNativeMethods.PRINTDLG pRINTDLG = new SafeNativeMethods.PRINTDLG();
			pRINTDLG.lStructSize = Marshal.SizeOf(typeof(SafeNativeMethods.PRINTDLG));
			pRINTDLG.hwndOwner = IntPtr.Zero;
			pRINTDLG.hDevMode = IntPtr.Zero;
			pRINTDLG.hDevNames = IntPtr.Zero;
			pRINTDLG.Flags = 0;
			pRINTDLG.hwndOwner = IntPtr.Zero;
			pRINTDLG.hDC = IntPtr.Zero;
			pRINTDLG.nFromPage = 1;
			pRINTDLG.nToPage = 1;
			pRINTDLG.nMinPage = 0;
			pRINTDLG.nMaxPage = 9999;
			pRINTDLG.nCopies = 1;
			pRINTDLG.hInstance = IntPtr.Zero;
			pRINTDLG.lCustData = IntPtr.Zero;
			pRINTDLG.lpfnPrintHook = IntPtr.Zero;
			pRINTDLG.lpfnSetupHook = IntPtr.Zero;
			pRINTDLG.lpPrintTemplateName = null;
			pRINTDLG.lpSetupTemplateName = null;
			pRINTDLG.hPrintTemplate = IntPtr.Zero;
			pRINTDLG.hSetupTemplate = IntPtr.Zero;
			return pRINTDLG;
		}

		private int DeviceCapabilities(short capability, IntPtr pointerToBuffer, int defaultValue)
		{
			IntSecurity.AllPrinting.Assert();
			string text = PrinterName;
			CodeAccessPermission.RevertAssert();
			IntSecurity.UnmanagedCode.Assert();
			return FastDeviceCapabilities(capability, pointerToBuffer, defaultValue, text);
		}

		private static int FastDeviceCapabilities(short capability, IntPtr pointerToBuffer, int defaultValue, string printerName)
		{
			int num = SafeNativeMethods.DeviceCapabilities(printerName, GetOutputPort(), capability, pointerToBuffer, IntPtr.Zero);
			if (num == -1)
			{
				return defaultValue;
			}
			return num;
		}

		private static string GetDefaultPrinterName()
		{
			IntSecurity.UnmanagedCode.Assert();
			if (IntPtr.Size == 8)
			{
				SafeNativeMethods.PRINTDLG pRINTDLG = CreatePRINTDLG();
				pRINTDLG.Flags = 1024;
				if (!SafeNativeMethods.PrintDlg(pRINTDLG))
				{
					return SR.GetString("NoDefaultPrinter");
				}
				IntPtr hDevNames = pRINTDLG.hDevNames;
				IntPtr intPtr = SafeNativeMethods.GlobalLock(new HandleRef(pRINTDLG, hDevNames));
				if (intPtr == IntPtr.Zero)
				{
					throw new Win32Exception();
				}
				string result = ReadOneDEVNAME(intPtr, 1);
				SafeNativeMethods.GlobalUnlock(new HandleRef(pRINTDLG, hDevNames));
				intPtr = IntPtr.Zero;
				SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLG, pRINTDLG.hDevNames));
				SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLG, pRINTDLG.hDevMode));
				return result;
			}
			SafeNativeMethods.PRINTDLGX86 pRINTDLGX = CreatePRINTDLGX86();
			pRINTDLGX.Flags = 1024;
			if (!SafeNativeMethods.PrintDlg(pRINTDLGX))
			{
				return SR.GetString("NoDefaultPrinter");
			}
			IntPtr hDevNames2 = pRINTDLGX.hDevNames;
			IntPtr intPtr2 = SafeNativeMethods.GlobalLock(new HandleRef(pRINTDLGX, hDevNames2));
			if (intPtr2 == IntPtr.Zero)
			{
				throw new Win32Exception();
			}
			string result2 = ReadOneDEVNAME(intPtr2, 1);
			SafeNativeMethods.GlobalUnlock(new HandleRef(pRINTDLGX, hDevNames2));
			intPtr2 = IntPtr.Zero;
			SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLGX, pRINTDLGX.hDevNames));
			SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLGX, pRINTDLGX.hDevMode));
			return result2;
		}

		private static string GetOutputPort()
		{
			IntSecurity.UnmanagedCode.Assert();
			if (IntPtr.Size == 8)
			{
				SafeNativeMethods.PRINTDLG pRINTDLG = CreatePRINTDLG();
				pRINTDLG.Flags = 1024;
				if (!SafeNativeMethods.PrintDlg(pRINTDLG))
				{
					return SR.GetString("NoDefaultPrinter");
				}
				IntPtr hDevNames = pRINTDLG.hDevNames;
				IntPtr intPtr = SafeNativeMethods.GlobalLock(new HandleRef(pRINTDLG, hDevNames));
				if (intPtr == IntPtr.Zero)
				{
					throw new Win32Exception();
				}
				string result = ReadOneDEVNAME(intPtr, 2);
				SafeNativeMethods.GlobalUnlock(new HandleRef(pRINTDLG, hDevNames));
				intPtr = IntPtr.Zero;
				SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLG, pRINTDLG.hDevNames));
				SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLG, pRINTDLG.hDevMode));
				return result;
			}
			SafeNativeMethods.PRINTDLGX86 pRINTDLGX = CreatePRINTDLGX86();
			pRINTDLGX.Flags = 1024;
			if (!SafeNativeMethods.PrintDlg(pRINTDLGX))
			{
				return SR.GetString("NoDefaultPrinter");
			}
			IntPtr hDevNames2 = pRINTDLGX.hDevNames;
			IntPtr intPtr2 = SafeNativeMethods.GlobalLock(new HandleRef(pRINTDLGX, hDevNames2));
			if (intPtr2 == IntPtr.Zero)
			{
				throw new Win32Exception();
			}
			string result2 = ReadOneDEVNAME(intPtr2, 2);
			SafeNativeMethods.GlobalUnlock(new HandleRef(pRINTDLGX, hDevNames2));
			intPtr2 = IntPtr.Zero;
			SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLGX, pRINTDLGX.hDevNames));
			SafeNativeMethods.GlobalFree(new HandleRef(pRINTDLGX, pRINTDLGX.hDevMode));
			return result2;
		}

		private int GetDeviceCaps(int capability, int defaultValue)
		{
			DeviceContext deviceContext = CreateInformationContext(DefaultPageSettings);
			int result = defaultValue;
			try
			{
				result = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(deviceContext, deviceContext.Hdc), capability);
				return result;
			}
			catch (InvalidPrinterException)
			{
				return result;
			}
			finally
			{
				deviceContext.Dispose();
			}
		}

		/// <summary>Creates a handle to a <see langword="DEVMODE" /> structure that corresponds to the printer settings.</summary>
		/// <returns>A handle to a <see langword="DEVMODE" /> structure.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The printer's initialization information could not be retrieved.</exception>
		public IntPtr GetHdevmode()
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			IntPtr hdevmodeInternal = GetHdevmodeInternal();
			defaultPageSettings.CopyToHdevmode(hdevmodeInternal);
			return hdevmodeInternal;
		}

		internal IntPtr GetHdevmodeInternal()
		{
			return GetHdevmodeInternal(PrinterNameInternal);
		}

		private IntPtr GetHdevmodeInternal(string printer)
		{
			int num = SafeNativeMethods.DocumentProperties(NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, printer, IntPtr.Zero, NativeMethods.NullHandleRef, 0);
			if (num < 1)
			{
				throw new InvalidPrinterException(this);
			}
			IntPtr intPtr = SafeNativeMethods.GlobalAlloc(2, (uint)num);
			IntPtr intPtr2 = SafeNativeMethods.GlobalLock(new HandleRef(null, intPtr));
			if (cachedDevmode != null)
			{
				Marshal.Copy(cachedDevmode, 0, intPtr2, devmodebytes);
			}
			else
			{
				int num2 = SafeNativeMethods.DocumentProperties(NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, printer, intPtr2, NativeMethods.NullHandleRef, 2);
				if (num2 < 0)
				{
					throw new Win32Exception();
				}
			}
			SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(intPtr2, typeof(SafeNativeMethods.DEVMODE));
			if (extrainfo != null && extrabytes <= dEVMODE.dmDriverExtra)
			{
				IntPtr destination = (IntPtr)checked((long)intPtr2 + dEVMODE.dmSize);
				Marshal.Copy(extrainfo, 0, destination, extrabytes);
			}
			if ((dEVMODE.dmFields & 0x100) == 256 && copies != -1)
			{
				dEVMODE.dmCopies = copies;
			}
			if ((dEVMODE.dmFields & 0x1000) == 4096 && duplex != Duplex.Default)
			{
				dEVMODE.dmDuplex = (short)duplex;
			}
			if ((dEVMODE.dmFields & 0x8000) == 32768 && collate.IsNotDefault)
			{
				dEVMODE.dmCollate = (short)(((bool)collate) ? 1 : 0);
			}
			Marshal.StructureToPtr((object)dEVMODE, intPtr2, fDeleteOld: false);
			int num3 = SafeNativeMethods.DocumentProperties(NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, printer, intPtr2, intPtr2, 10);
			if (num3 < 0)
			{
				SafeNativeMethods.GlobalFree(new HandleRef(null, intPtr));
				SafeNativeMethods.GlobalUnlock(new HandleRef(null, intPtr));
				return IntPtr.Zero;
			}
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, intPtr));
			return intPtr;
		}

		/// <summary>Creates a handle to a <see langword="DEVMODE" /> structure that corresponds to the printer and the page settings specified through the <paramref name="pageSettings" /> parameter.</summary>
		/// <param name="pageSettings">The <see cref="T:System.Drawing.Printing.PageSettings" /> object that the <see langword="DEVMODE" /> structure's handle corresponds to.</param>
		/// <returns>A handle to a <see langword="DEVMODE" /> structure.</returns>
		/// <exception cref="T:System.Drawing.Printing.InvalidPrinterException">The printer named in the <see cref="P:System.Drawing.Printing.PrinterSettings.PrinterName" /> property does not exist.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">The printer's initialization information could not be retrieved.</exception>
		public IntPtr GetHdevmode(PageSettings pageSettings)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			IntPtr hdevmodeInternal = GetHdevmodeInternal();
			pageSettings.CopyToHdevmode(hdevmodeInternal);
			return hdevmodeInternal;
		}

		/// <summary>Creates a handle to a <see langword="DEVNAMES" /> structure that corresponds to the printer settings.</summary>
		/// <returns>A handle to a <see langword="DEVNAMES" /> structure.</returns>
		public IntPtr GetHdevnames()
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			string text = PrinterName;
			string text2 = DriverName;
			string text3 = OutputPort;
			int num = checked(4 + text.Length + text2.Length + text3.Length);
			short num2 = (short)(8 / Marshal.SystemDefaultCharSize);
			uint dwBytes = (uint)checked(Marshal.SystemDefaultCharSize * (num2 + num));
			IntPtr intPtr = SafeNativeMethods.GlobalAlloc(66, dwBytes);
			IntPtr intPtr2 = SafeNativeMethods.GlobalLock(new HandleRef(null, intPtr));
			Marshal.WriteInt16(intPtr2, num2);
			num2 = (short)(num2 + WriteOneDEVNAME(text2, intPtr2, num2));
			Marshal.WriteInt16((IntPtr)checked((long)intPtr2 + 2), num2);
			num2 = (short)(num2 + WriteOneDEVNAME(text, intPtr2, num2));
			Marshal.WriteInt16((IntPtr)checked((long)intPtr2 + 4), num2);
			num2 = (short)(num2 + WriteOneDEVNAME(text3, intPtr2, num2));
			Marshal.WriteInt16((IntPtr)checked((long)intPtr2 + 6), num2);
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, intPtr));
			return intPtr;
		}

		internal short GetModeField(ModeField field, short defaultValue)
		{
			return GetModeField(field, defaultValue, IntPtr.Zero);
		}

		internal short GetModeField(ModeField field, short defaultValue, IntPtr modeHandle)
		{
			bool flag = false;
			try
			{
				if (modeHandle == IntPtr.Zero)
				{
					try
					{
						modeHandle = GetHdevmodeInternal();
						flag = true;
					}
					catch (InvalidPrinterException)
					{
						return defaultValue;
					}
				}
				IntPtr lparam = SafeNativeMethods.GlobalLock(new HandleRef(this, modeHandle));
				SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(lparam, typeof(SafeNativeMethods.DEVMODE));
				short result = field switch
				{
					ModeField.Orientation => dEVMODE.dmOrientation, 
					ModeField.PaperSize => dEVMODE.dmPaperSize, 
					ModeField.PaperLength => dEVMODE.dmPaperLength, 
					ModeField.PaperWidth => dEVMODE.dmPaperWidth, 
					ModeField.Copies => dEVMODE.dmCopies, 
					ModeField.DefaultSource => dEVMODE.dmDefaultSource, 
					ModeField.PrintQuality => dEVMODE.dmPrintQuality, 
					ModeField.Color => dEVMODE.dmColor, 
					ModeField.Duplex => dEVMODE.dmDuplex, 
					ModeField.YResolution => dEVMODE.dmYResolution, 
					ModeField.TTOption => dEVMODE.dmTTOption, 
					ModeField.Collate => dEVMODE.dmCollate, 
					_ => defaultValue, 
				};
				SafeNativeMethods.GlobalUnlock(new HandleRef(this, modeHandle));
				return result;
			}
			finally
			{
				if (flag)
				{
					SafeNativeMethods.GlobalFree(new HandleRef(this, modeHandle));
				}
			}
		}

		internal PaperSize[] Get_PaperSizes()
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Assert();
			string text = PrinterName;
			int num = FastDeviceCapabilities(16, IntPtr.Zero, -1, text);
			if (num == -1)
			{
				return new PaperSize[0];
			}
			int num2 = Marshal.SystemDefaultCharSize * 64;
			IntPtr intPtr = Marshal.AllocCoTaskMem(checked(num2 * num));
			FastDeviceCapabilities(16, intPtr, -1, text);
			IntPtr intPtr2 = Marshal.AllocCoTaskMem(2 * num);
			FastDeviceCapabilities(2, intPtr2, -1, text);
			IntPtr intPtr3 = Marshal.AllocCoTaskMem(8 * num);
			FastDeviceCapabilities(3, intPtr3, -1, text);
			PaperSize[] array = new PaperSize[num];
			for (int i = 0; i < num; i++)
			{
				string text2;
				short kind;
				int value;
				int value2;
				checked
				{
					text2 = Marshal.PtrToStringAuto((IntPtr)((long)intPtr + num2 * i), 64);
					int num3 = text2.IndexOf('\0');
					if (num3 > -1)
					{
						text2 = text2.Substring(0, num3);
					}
					kind = Marshal.ReadInt16((IntPtr)((long)intPtr2 + i * 2));
					value = Marshal.ReadInt32((IntPtr)((long)intPtr3 + i * 8));
					value2 = Marshal.ReadInt32((IntPtr)((long)intPtr3 + i * 8 + 4));
				}
				array[i] = new PaperSize((PaperKind)kind, text2, PrinterUnitConvert.Convert(value, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display), PrinterUnitConvert.Convert(value2, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display));
			}
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return array;
		}

		internal PaperSource[] Get_PaperSources()
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Assert();
			string text = PrinterName;
			int num = FastDeviceCapabilities(12, IntPtr.Zero, -1, text);
			if (num == -1)
			{
				return new PaperSource[0];
			}
			int num2 = Marshal.SystemDefaultCharSize * 24;
			IntPtr intPtr = Marshal.AllocCoTaskMem(checked(num2 * num));
			FastDeviceCapabilities(12, intPtr, -1, text);
			IntPtr intPtr2 = Marshal.AllocCoTaskMem(2 * num);
			FastDeviceCapabilities(6, intPtr2, -1, text);
			PaperSource[] array = new PaperSource[num];
			for (int i = 0; i < num; i++)
			{
				string text2;
				short kind;
				checked
				{
					text2 = Marshal.PtrToStringAuto((IntPtr)((long)intPtr + num2 * i), 24);
					int num3 = text2.IndexOf('\0');
					if (num3 > -1)
					{
						text2 = text2.Substring(0, num3);
					}
					kind = Marshal.ReadInt16((IntPtr)((long)intPtr2 + 2 * i));
				}
				array[i] = new PaperSource((PaperSourceKind)kind, text2);
			}
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return array;
		}

		internal PrinterResolution[] Get_PrinterResolutions()
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Assert();
			string text = PrinterName;
			int num = FastDeviceCapabilities(13, IntPtr.Zero, -1, text);
			if (num == -1)
			{
				return new PrinterResolution[4]
				{
					new PrinterResolution(PrinterResolutionKind.High, -4, -1),
					new PrinterResolution(PrinterResolutionKind.Medium, -3, -1),
					new PrinterResolution(PrinterResolutionKind.Low, -2, -1),
					new PrinterResolution(PrinterResolutionKind.Draft, -1, -1)
				};
			}
			PrinterResolution[] array = new PrinterResolution[num + 4];
			array[0] = new PrinterResolution(PrinterResolutionKind.High, -4, -1);
			array[1] = new PrinterResolution(PrinterResolutionKind.Medium, -3, -1);
			array[2] = new PrinterResolution(PrinterResolutionKind.Low, -2, -1);
			array[3] = new PrinterResolution(PrinterResolutionKind.Draft, -1, -1);
			IntPtr intPtr = Marshal.AllocCoTaskMem(checked(8 * num));
			FastDeviceCapabilities(13, intPtr, -1, text);
			for (int i = 0; i < num; i++)
			{
				int x;
				int y;
				checked
				{
					x = Marshal.ReadInt32((IntPtr)((long)intPtr + i * 8));
					y = Marshal.ReadInt32((IntPtr)((long)intPtr + i * 8 + 4));
				}
				array[i + 4] = new PrinterResolution(PrinterResolutionKind.Custom, x, y);
			}
			Marshal.FreeCoTaskMem(intPtr);
			return array;
		}

		private static string ReadOneDEVNAME(IntPtr pDevnames, int slot)
		{
			checked
			{
				int num = Marshal.SystemDefaultCharSize * Marshal.ReadInt16((IntPtr)((long)pDevnames + slot * 2));
				return Marshal.PtrToStringAuto((IntPtr)((long)pDevnames + num));
			}
		}

		/// <summary>Copies the relevant information out of the given handle and into the <see cref="T:System.Drawing.Printing.PrinterSettings" />.</summary>
		/// <param name="hdevmode">The handle to a Win32 <see langword="DEVMODE" /> structure.</param>
		/// <exception cref="T:System.ArgumentException">The printer handle is not valid.</exception>
		public void SetHdevmode(IntPtr hdevmode)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			if (hdevmode == IntPtr.Zero)
			{
				throw new ArgumentException(SR.GetString("InvalidPrinterHandle", hdevmode));
			}
			IntPtr intPtr = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
			SafeNativeMethods.DEVMODE dEVMODE = (SafeNativeMethods.DEVMODE)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(SafeNativeMethods.DEVMODE));
			devmodebytes = dEVMODE.dmSize;
			if (devmodebytes > 0)
			{
				cachedDevmode = new byte[devmodebytes];
				Marshal.Copy(intPtr, cachedDevmode, 0, devmodebytes);
			}
			extrabytes = dEVMODE.dmDriverExtra;
			if (extrabytes > 0)
			{
				extrainfo = new byte[extrabytes];
				Marshal.Copy((IntPtr)checked((long)intPtr + dEVMODE.dmSize), extrainfo, 0, extrabytes);
			}
			if ((dEVMODE.dmFields & 0x100) == 256)
			{
				copies = dEVMODE.dmCopies;
			}
			if ((dEVMODE.dmFields & 0x1000) == 4096)
			{
				duplex = (Duplex)dEVMODE.dmDuplex;
			}
			if ((dEVMODE.dmFields & 0x8000) == 32768)
			{
				collate = dEVMODE.dmCollate == 1;
			}
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
		}

		/// <summary>Copies the relevant information out of the given handle and into the <see cref="T:System.Drawing.Printing.PrinterSettings" />.</summary>
		/// <param name="hdevnames">The handle to a Win32 <see langword="DEVNAMES" /> structure.</param>
		/// <exception cref="T:System.ArgumentException">The printer handle is invalid.</exception>
		public void SetHdevnames(IntPtr hdevnames)
		{
			IntSecurity.AllPrintingAndUnmanagedCode.Demand();
			if (hdevnames == IntPtr.Zero)
			{
				throw new ArgumentException(SR.GetString("InvalidPrinterHandle", hdevnames));
			}
			IntPtr pDevnames = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevnames));
			driverName = ReadOneDEVNAME(pDevnames, 0);
			printerName = ReadOneDEVNAME(pDevnames, 1);
			outputPort = ReadOneDEVNAME(pDevnames, 2);
			PrintDialogDisplayed = true;
			SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevnames));
		}

		/// <summary>Provides information about the <see cref="T:System.Drawing.Printing.PrinterSettings" /> in string form.</summary>
		/// <returns>A string.</returns>
		public override string ToString()
		{
			string text = (IntSecurity.HasPermission(IntSecurity.AllPrinting) ? PrinterName : "<printer name unavailable>");
			return "[PrinterSettings " + text + " Copies=" + Copies.ToString(CultureInfo.InvariantCulture) + " Collate=" + Collate.ToString(CultureInfo.InvariantCulture) + " Duplex=" + TypeDescriptor.GetConverter(typeof(Duplex)).ConvertToString((int)Duplex) + " FromPage=" + FromPage.ToString(CultureInfo.InvariantCulture) + " LandscapeAngle=" + LandscapeAngle.ToString(CultureInfo.InvariantCulture) + " MaximumCopies=" + MaximumCopies.ToString(CultureInfo.InvariantCulture) + " OutputPort=" + OutputPort.ToString(CultureInfo.InvariantCulture) + " ToPage=" + ToPage.ToString(CultureInfo.InvariantCulture) + "]";
		}

		private short WriteOneDEVNAME(string str, IntPtr bufferStart, int index)
		{
			if (str == null)
			{
				str = "";
			}
			checked
			{
				IntPtr intPtr = (IntPtr)((long)bufferStart + index * Marshal.SystemDefaultCharSize);
				if (Marshal.SystemDefaultCharSize == 1)
				{
					byte[] bytes = Encoding.Default.GetBytes(str);
					Marshal.Copy(bytes, 0, intPtr, bytes.Length);
					Marshal.WriteByte((IntPtr)((long)intPtr + bytes.Length), 0);
				}
				else
				{
					char[] array = str.ToCharArray();
					Marshal.Copy(array, 0, intPtr, array.Length);
					Marshal.WriteInt16((IntPtr)((long)intPtr + array.Length * 2), 0);
				}
				return (short)(str.Length + 1);
			}
		}
	}
	/// <summary>Specifies several of the units of measure used for printing.</summary>
	public enum PrinterUnit
	{
		/// <summary>The default unit (0.01 in.).</summary>
		Display,
		/// <summary>One-thousandth of an inch (0.001 in.).</summary>
		ThousandthsOfAnInch,
		/// <summary>One-hundredth of a millimeter (0.01 mm).</summary>
		HundredthsOfAMillimeter,
		/// <summary>One-tenth of a millimeter (0.1 mm).</summary>
		TenthsOfAMillimeter
	}
	/// <summary>Specifies a series of conversion methods that are useful when interoperating with the Win32 printing API. This class cannot be inherited.</summary>
	public sealed class PrinterUnitConvert
	{
		private PrinterUnitConvert()
		{
		}

		/// <summary>Converts a double-precision floating-point number from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.Point" /> being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A double-precision floating-point number that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static double Convert(double value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			double num = UnitsPerDisplay(fromUnit);
			double num2 = UnitsPerDisplay(toUnit);
			return value * num2 / num;
		}

		/// <summary>Converts a 32-bit signed integer from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The value being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A 32-bit signed integer that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static int Convert(int value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return (int)Math.Round(Convert((double)value, fromUnit, toUnit));
		}

		/// <summary>Converts a <see cref="T:System.Drawing.Point" /> from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.Point" /> being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A <see cref="T:System.Drawing.Point" /> that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static Point Convert(Point value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return new Point(Convert(value.X, fromUnit, toUnit), Convert(value.Y, fromUnit, toUnit));
		}

		/// <summary>Converts a <see cref="T:System.Drawing.Size" /> from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.Size" /> being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A <see cref="T:System.Drawing.Size" /> that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static Size Convert(Size value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return new Size(Convert(value.Width, fromUnit, toUnit), Convert(value.Height, fromUnit, toUnit));
		}

		/// <summary>Converts a <see cref="T:System.Drawing.Rectangle" /> from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.Rectangle" /> being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A <see cref="T:System.Drawing.Rectangle" /> that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static Rectangle Convert(Rectangle value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			return new Rectangle(Convert(value.X, fromUnit, toUnit), Convert(value.Y, fromUnit, toUnit), Convert(value.Width, fromUnit, toUnit), Convert(value.Height, fromUnit, toUnit));
		}

		/// <summary>Converts a <see cref="T:System.Drawing.Printing.Margins" /> from one <see cref="T:System.Drawing.Printing.PrinterUnit" /> type to another <see cref="T:System.Drawing.Printing.PrinterUnit" /> type.</summary>
		/// <param name="value">The <see cref="T:System.Drawing.Printing.Margins" /> being converted.</param>
		/// <param name="fromUnit">The unit to convert from.</param>
		/// <param name="toUnit">The unit to convert to.</param>
		/// <returns>A <see cref="T:System.Drawing.Printing.Margins" /> that represents the converted <see cref="T:System.Drawing.Printing.PrinterUnit" />.</returns>
		public static Margins Convert(Margins value, PrinterUnit fromUnit, PrinterUnit toUnit)
		{
			Margins margins = new Margins();
			margins.DoubleLeft = Convert(value.DoubleLeft, fromUnit, toUnit);
			margins.DoubleRight = Convert(value.DoubleRight, fromUnit, toUnit);
			margins.DoubleTop = Convert(value.DoubleTop, fromUnit, toUnit);
			margins.DoubleBottom = Convert(value.DoubleBottom, fromUnit, toUnit);
			return margins;
		}

		private static double UnitsPerDisplay(PrinterUnit unit)
		{
			return unit switch
			{
				PrinterUnit.Display => 1.0, 
				PrinterUnit.ThousandthsOfAnInch => 10.0, 
				PrinterUnit.HundredthsOfAMillimeter => 25.4, 
				PrinterUnit.TenthsOfAMillimeter => 2.54, 
				_ => 1.0, 
			};
		}
	}
	/// <summary>Provides data for the <see cref="E:System.Drawing.Printing.PrintDocument.BeginPrint" /> and <see cref="E:System.Drawing.Printing.PrintDocument.EndPrint" /> events.</summary>
	public class PrintEventArgs : CancelEventArgs
	{
		private PrintAction printAction;

		/// <summary>Returns <see cref="F:System.Drawing.Printing.PrintAction.PrintToFile" /> in all cases.</summary>
		/// <returns>
		///   <see cref="F:System.Drawing.Printing.PrintAction.PrintToFile" /> in all cases.</returns>
		public PrintAction PrintAction => printAction;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintEventArgs" /> class.</summary>
		public PrintEventArgs()
		{
		}

		internal PrintEventArgs(PrintAction action)
		{
			printAction = action;
		}
	}
	/// <summary>Represents the method that will handle the <see cref="E:System.Drawing.Printing.PrintDocument.BeginPrint" /> or <see cref="E:System.Drawing.Printing.PrintDocument.EndPrint" /> event of a <see cref="T:System.Drawing.Printing.PrintDocument" />.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintEventArgs" /> that contains the event data.</param>
	public delegate void PrintEventHandler(object sender, PrintEventArgs e);
	/// <summary>Controls access to printers. This class cannot be inherited.</summary>
	[Serializable]
	public sealed class PrintingPermission : CodeAccessPermission, IUnrestrictedPermission
	{
		private PrintingPermissionLevel printingLevel;

		/// <summary>Gets or sets the code's level of printing access.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PrintingPermissionLevel" /> values.</returns>
		public PrintingPermissionLevel Level
		{
			get
			{
				return printingLevel;
			}
			set
			{
				VerifyPrintingLevel(value);
				printingLevel = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintingPermission" /> class with either fully restricted or unrestricted access, as specified.</summary>
		/// <param name="state">One of the <see cref="T:System.Security.Permissions.PermissionState" /> values.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="state" /> is not a valid <see cref="T:System.Security.Permissions.PermissionState" />.</exception>
		public PrintingPermission(PermissionState state)
		{
			switch (state)
			{
			case PermissionState.Unrestricted:
				printingLevel = PrintingPermissionLevel.AllPrinting;
				break;
			case PermissionState.None:
				printingLevel = PrintingPermissionLevel.NoPrinting;
				break;
			default:
				throw new ArgumentException(SR.GetString("InvalidPermissionState"));
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintingPermission" /> class with the level of printing access specified.</summary>
		/// <param name="printingLevel">One of the <see cref="T:System.Drawing.Printing.PrintingPermissionLevel" /> values.</param>
		public PrintingPermission(PrintingPermissionLevel printingLevel)
		{
			VerifyPrintingLevel(printingLevel);
			this.printingLevel = printingLevel;
		}

		private static void VerifyPrintingLevel(PrintingPermissionLevel level)
		{
			if (level < PrintingPermissionLevel.NoPrinting || level > PrintingPermissionLevel.AllPrinting)
			{
				throw new ArgumentException(SR.GetString("InvalidPermissionLevel"));
			}
		}

		/// <summary>Gets a value indicating whether the permission is unrestricted.</summary>
		/// <returns>
		///   <see langword="true" /> if permission is unrestricted; otherwise, <see langword="false" />.</returns>
		public bool IsUnrestricted()
		{
			return printingLevel == PrintingPermissionLevel.AllPrinting;
		}

		/// <summary>Determines whether the current permission object is a subset of the specified permission.</summary>
		/// <param name="target">A permission object that is to be tested for the subset relationship. This object must be of the same type as the current permission object.</param>
		/// <returns>
		///   <see langword="true" /> if the current permission object is a subset of <paramref name="target" />; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="target" /> is an object that is not of the same type as the current permission object.</exception>
		public override bool IsSubsetOf(IPermission target)
		{
			if (target == null)
			{
				return printingLevel == PrintingPermissionLevel.NoPrinting;
			}
			if (!(target is PrintingPermission printingPermission))
			{
				throw new ArgumentException(SR.GetString("TargetNotPrintingPermission"));
			}
			return printingLevel <= printingPermission.printingLevel;
		}

		/// <summary>Creates and returns a permission that is the intersection of the current permission object and a target permission object.</summary>
		/// <param name="target">A permission object of the same type as the current permission object.</param>
		/// <returns>A new permission object that represents the intersection of the current object and the specified target. This object is <see langword="null" /> if the intersection is empty.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="target" /> is an object that is not of the same type as the current permission object.</exception>
		public override IPermission Intersect(IPermission target)
		{
			if (target == null)
			{
				return null;
			}
			if (!(target is PrintingPermission printingPermission))
			{
				throw new ArgumentException(SR.GetString("TargetNotPrintingPermission"));
			}
			PrintingPermissionLevel printingPermissionLevel = ((printingLevel < printingPermission.printingLevel) ? printingLevel : printingPermission.printingLevel);
			if (printingPermissionLevel == PrintingPermissionLevel.NoPrinting)
			{
				return null;
			}
			return new PrintingPermission(printingPermissionLevel);
		}

		/// <summary>Creates a permission that combines the permission object and the target permission object.</summary>
		/// <param name="target">A permission object of the same type as the current permission object.</param>
		/// <returns>A new permission object that represents the union of the current permission object and the specified permission object.</returns>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="target" /> is an object that is not of the same type as the current permission object.</exception>
		public override IPermission Union(IPermission target)
		{
			if (target == null)
			{
				return Copy();
			}
			if (!(target is PrintingPermission printingPermission))
			{
				throw new ArgumentException(SR.GetString("TargetNotPrintingPermission"));
			}
			PrintingPermissionLevel printingPermissionLevel = ((printingLevel > printingPermission.printingLevel) ? printingLevel : printingPermission.printingLevel);
			if (printingPermissionLevel == PrintingPermissionLevel.NoPrinting)
			{
				return null;
			}
			return new PrintingPermission(printingPermissionLevel);
		}

		/// <summary>Creates and returns an identical copy of the current permission object.</summary>
		/// <returns>A copy of the current permission object.</returns>
		public override IPermission Copy()
		{
			return new PrintingPermission(printingLevel);
		}

		/// <summary>Creates an XML encoding of the security object and its current state.</summary>
		/// <returns>An XML encoding of the security object, including any state information.</returns>
		public override SecurityElement ToXml()
		{
			SecurityElement securityElement = new SecurityElement("IPermission");
			securityElement.AddAttribute("class", GetType().FullName + ", " + GetType().Module.Assembly.FullName.Replace('"', '\''));
			securityElement.AddAttribute("version", "1");
			if (!IsUnrestricted())
			{
				securityElement.AddAttribute("Level", Enum.GetName(typeof(PrintingPermissionLevel), printingLevel));
			}
			else
			{
				securityElement.AddAttribute("Unrestricted", "true");
			}
			return securityElement;
		}

		/// <summary>Reconstructs a security object with a specified state from an XML encoding.</summary>
		/// <param name="esd">The XML encoding to use to reconstruct the security object.</param>
		public override void FromXml(SecurityElement esd)
		{
			if (esd == null)
			{
				throw new ArgumentNullException("esd");
			}
			string text = esd.Attribute("class");
			if (text == null || text.IndexOf(GetType().FullName) == -1)
			{
				throw new ArgumentException(SR.GetString("InvalidClassName"));
			}
			string text2 = esd.Attribute("Unrestricted");
			if (text2 != null && string.Equals(text2, "true", StringComparison.OrdinalIgnoreCase))
			{
				printingLevel = PrintingPermissionLevel.AllPrinting;
				return;
			}
			printingLevel = PrintingPermissionLevel.NoPrinting;
			string text3 = esd.Attribute("Level");
			if (text3 != null)
			{
				printingLevel = (PrintingPermissionLevel)Enum.Parse(typeof(PrintingPermissionLevel), text3);
			}
		}
	}
	/// <summary>Allows declarative printing permission checks.</summary>
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	public sealed class PrintingPermissionAttribute : CodeAccessSecurityAttribute
	{
		private PrintingPermissionLevel level;

		/// <summary>Gets or sets the type of printing allowed.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Printing.PrintingPermissionLevel" /> values.</returns>
		/// <exception cref="T:System.ArgumentException">The value is not one of the <see cref="T:System.Drawing.Printing.PrintingPermissionLevel" /> values.</exception>
		public PrintingPermissionLevel Level
		{
			get
			{
				return level;
			}
			set
			{
				if (value < PrintingPermissionLevel.NoPrinting || value > PrintingPermissionLevel.AllPrinting)
				{
					throw new ArgumentException(SR.GetString("PrintingPermissionAttributeInvalidPermissionLevel"), "value");
				}
				level = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintingPermissionAttribute" /> class.</summary>
		/// <param name="action">One of the <see cref="T:System.Security.Permissions.SecurityAction" /> values.</param>
		public PrintingPermissionAttribute(SecurityAction action)
			: base(action)
		{
		}

		/// <summary>Creates the permission based on the requested access levels, which are set through the <see cref="P:System.Drawing.Printing.PrintingPermissionAttribute.Level" /> property on the attribute.</summary>
		/// <returns>An <see cref="T:System.Security.IPermission" /> that represents the created permission.</returns>
		public override IPermission CreatePermission()
		{
			if (base.Unrestricted)
			{
				return new PrintingPermission(PermissionState.Unrestricted);
			}
			return new PrintingPermission(level);
		}
	}
	/// <summary>Specifies the type of printing that code is allowed to do.</summary>
	[Serializable]
	public enum PrintingPermissionLevel
	{
		/// <summary>Prevents access to printers. <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.NoPrinting" /> is a subset of <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.SafePrinting" />.</summary>
		NoPrinting,
		/// <summary>Provides printing only from a restricted dialog box. <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.SafePrinting" /> is a subset of <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.DefaultPrinting" />.</summary>
		SafePrinting,
		/// <summary>Provides printing programmatically to the default printer, along with safe printing through semirestricted dialog box. <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.DefaultPrinting" /> is a subset of <see cref="F:System.Drawing.Printing.PrintingPermissionLevel.AllPrinting" />.</summary>
		DefaultPrinting,
		/// <summary>Provides full access to all printers.</summary>
		AllPrinting
	}
	/// <summary>Provides data for the <see cref="E:System.Drawing.Printing.PrintDocument.PrintPage" /> event.</summary>
	public class PrintPageEventArgs : EventArgs
	{
		private bool hasMorePages;

		private bool cancel;

		private Graphics graphics;

		private readonly Rectangle marginBounds;

		private readonly Rectangle pageBounds;

		private readonly PageSettings pageSettings;

		internal bool CopySettingsToDevMode = true;

		/// <summary>Gets or sets a value indicating whether the print job should be canceled.</summary>
		/// <returns>
		///   <see langword="true" /> if the print job should be canceled; otherwise, <see langword="false" />.</returns>
		public bool Cancel
		{
			get
			{
				return cancel;
			}
			set
			{
				cancel = value;
			}
		}

		/// <summary>Gets the <see cref="T:System.Drawing.Graphics" /> used to paint the page.</summary>
		/// <returns>The <see cref="T:System.Drawing.Graphics" /> used to paint the page.</returns>
		public Graphics Graphics => graphics;

		/// <summary>Gets or sets a value indicating whether an additional page should be printed.</summary>
		/// <returns>
		///   <see langword="true" /> if an additional page should be printed; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
		public bool HasMorePages
		{
			get
			{
				return hasMorePages;
			}
			set
			{
				hasMorePages = value;
			}
		}

		/// <summary>Gets the rectangular area that represents the portion of the page inside the margins.</summary>
		/// <returns>The rectangular area, measured in hundredths of an inch, that represents the portion of the page inside the margins.</returns>
		public Rectangle MarginBounds => marginBounds;

		/// <summary>Gets the rectangular area that represents the total area of the page.</summary>
		/// <returns>The rectangular area that represents the total area of the page.</returns>
		public Rectangle PageBounds => pageBounds;

		/// <summary>Gets the page settings for the current page.</summary>
		/// <returns>The page settings for the current page.</returns>
		public PageSettings PageSettings => pageSettings;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> class.</summary>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> used to paint the item.</param>
		/// <param name="marginBounds">The area between the margins.</param>
		/// <param name="pageBounds">The total area of the paper.</param>
		/// <param name="pageSettings">The <see cref="T:System.Drawing.Printing.PageSettings" /> for the page.</param>
		public PrintPageEventArgs(Graphics graphics, Rectangle marginBounds, Rectangle pageBounds, PageSettings pageSettings)
		{
			this.graphics = graphics;
			this.marginBounds = marginBounds;
			this.pageBounds = pageBounds;
			this.pageSettings = pageSettings;
		}

		internal void Dispose()
		{
			graphics.Dispose();
		}

		internal void SetGraphics(Graphics value)
		{
			graphics = value;
		}
	}
	/// <summary>Represents the method that will handle the <see cref="E:System.Drawing.Printing.PrintDocument.PrintPage" /> event of a <see cref="T:System.Drawing.Printing.PrintDocument" />.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> that contains the event data.</param>
	public delegate void PrintPageEventHandler(object sender, PrintPageEventArgs e);
	/// <summary>Specifies the part of the document to print.</summary>
	[Serializable]
	public enum PrintRange
	{
		/// <summary>All pages are printed.</summary>
		AllPages = 0,
		/// <summary>The pages between <see cref="P:System.Drawing.Printing.PrinterSettings.FromPage" /> and <see cref="P:System.Drawing.Printing.PrinterSettings.ToPage" /> are printed.</summary>
		SomePages = 2,
		/// <summary>The selected pages are printed.</summary>
		Selection = 1,
		/// <summary>The currently displayed page is printed</summary>
		CurrentPage = 4194304
	}
	/// <summary>Provides data for the <see cref="E:System.Drawing.Printing.PrintDocument.QueryPageSettings" /> event.</summary>
	public class QueryPageSettingsEventArgs : PrintEventArgs
	{
		private PageSettings pageSettings;

		internal bool PageSettingsChanged;

		/// <summary>Gets or sets the page settings for the page to be printed.</summary>
		/// <returns>The page settings for the page to be printed.</returns>
		public PageSettings PageSettings
		{
			get
			{
				PageSettingsChanged = true;
				return pageSettings;
			}
			set
			{
				if (value == null)
				{
					value = new PageSettings();
				}
				pageSettings = value;
				PageSettingsChanged = true;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Printing.QueryPageSettingsEventArgs" /> class.</summary>
		/// <param name="pageSettings">The page settings for the page to be printed.</param>
		public QueryPageSettingsEventArgs(PageSettings pageSettings)
		{
			this.pageSettings = pageSettings;
		}
	}
	/// <summary>Represents the method that handles the <see cref="E:System.Drawing.Printing.PrintDocument.QueryPageSettings" /> event of a <see cref="T:System.Drawing.Printing.PrintDocument" />.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Drawing.Printing.QueryPageSettingsEventArgs" /> that contains the event data.</param>
	public delegate void QueryPageSettingsEventHandler(object sender, QueryPageSettingsEventArgs e);
	[Serializable]
	internal struct TriState
	{
		private byte value;

		public static readonly TriState Default = new TriState(0);

		public static readonly TriState False = new TriState(1);

		public static readonly TriState True = new TriState(2);

		public bool IsDefault => this == Default;

		public bool IsFalse => this == False;

		public bool IsNotDefault => this != Default;

		public bool IsTrue => this == True;

		private TriState(byte value)
		{
			this.value = value;
		}

		public static bool operator ==(TriState left, TriState right)
		{
			return left.value == right.value;
		}

		public static bool operator !=(TriState left, TriState right)
		{
			return !(left == right);
		}

		public override bool Equals(object o)
		{
			TriState triState = (TriState)o;
			return value == triState.value;
		}

		public override int GetHashCode()
		{
			return value;
		}

		public static implicit operator TriState(bool value)
		{
			if (!value)
			{
				return False;
			}
			return True;
		}

		public static explicit operator bool(TriState value)
		{
			if (value.IsDefault)
			{
				throw new InvalidCastException(SR.GetString("TriStateCompareError"));
			}
			return value == True;
		}

		public override string ToString()
		{
			if (this == Default)
			{
				return "Default";
			}
			if (this == False)
			{
				return "False";
			}
			return "True";
		}
	}
}
namespace System.Drawing.Design
{
	/// <summary>Represents a collection of category name strings.</summary>
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class CategoryNameCollection : ReadOnlyCollectionBase
	{
		/// <summary>Gets the category name at the specified index.</summary>
		/// <param name="index">The index of the collection element to access.</param>
		/// <returns>The category name at the specified index.</returns>
		public string this[int index] => (string)base.InnerList[index];

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.CategoryNameCollection" /> class using the specified collection.</summary>
		/// <param name="value">A <see cref="T:System.Drawing.Design.CategoryNameCollection" /> that contains the names to initialize the collection values to.</param>
		public CategoryNameCollection(CategoryNameCollection value)
		{
			base.InnerList.AddRange(value);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.CategoryNameCollection" /> class using the specified array of names.</summary>
		/// <param name="value">An array of strings that contains the names of the categories to initialize the collection values to.</param>
		public CategoryNameCollection(string[] value)
		{
			base.InnerList.AddRange(value);
		}

		/// <summary>Indicates whether the specified category is contained in the collection.</summary>
		/// <param name="value">The string to check for in the collection.</param>
		/// <returns>
		///   <see langword="true" /> if the specified category is contained in the collection; otherwise, <see langword="false" />.</returns>
		public bool Contains(string value)
		{
			return base.InnerList.Contains(value);
		}

		/// <summary>Copies the collection elements to the specified array at the specified index.</summary>
		/// <param name="array">The array to copy to.</param>
		/// <param name="index">The index of the destination array at which to begin copying.</param>
		public void CopyTo(string[] array, int index)
		{
			base.InnerList.CopyTo(array, index);
		}

		/// <summary>Gets the index of the specified value.</summary>
		/// <param name="value">The category name to retrieve the index of in the collection.</param>
		/// <returns>The index in the collection, or <see langword="null" /> if the string does not exist in the collection.</returns>
		public int IndexOf(string value)
		{
			return base.InnerList.IndexOf(value);
		}
	}
	/// <summary>Provides an interface to manage the images, ToolTips, and event handlers for the properties of a component displayed in a property browser.</summary>
	public interface IPropertyValueUIService
	{
		/// <summary>Occurs when the list of <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> objects is modified.</summary>
		event EventHandler PropertyUIValueItemsChanged;

		/// <summary>Adds the specified <see cref="T:System.Drawing.Design.PropertyValueUIHandler" /> to this service.</summary>
		/// <param name="newHandler">The property value UI handler to add.</param>
		void AddPropertyValueUIHandler(PropertyValueUIHandler newHandler);

		/// <summary>Gets the <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> objects that match the specified context and property descriptor characteristics.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to gain additional context information.</param>
		/// <param name="propDesc">A <see cref="T:System.ComponentModel.PropertyDescriptor" /> that indicates the property to match with the properties to return.</param>
		/// <returns>An array of <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> objects that match the specified parameters.</returns>
		PropertyValueUIItem[] GetPropertyUIValueItems(ITypeDescriptorContext context, PropertyDescriptor propDesc);

		/// <summary>Notifies the <see cref="T:System.Drawing.Design.IPropertyValueUIService" /> implementation that the global list of <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> objects has been modified.</summary>
		void NotifyPropertyValueUIItemsChanged();

		/// <summary>Removes the specified <see cref="T:System.Drawing.Design.PropertyValueUIHandler" /> from the property value UI service.</summary>
		/// <param name="newHandler">The handler to remove.</param>
		void RemovePropertyValueUIHandler(PropertyValueUIHandler newHandler);
	}
	/// <summary>Exposes a collection of toolbox items.</summary>
	public interface IToolboxItemProvider
	{
		/// <summary>Gets a collection of <see cref="T:System.Drawing.Design.ToolboxItem" /> objects.</summary>
		/// <returns>A collection of <see cref="T:System.Drawing.Design.ToolboxItem" /> objects.</returns>
		ToolboxItemCollection Items { get; }
	}
	/// <summary>Provides methods and properties to manage and query the toolbox in the development environment.</summary>
	[ComImport]
	[Guid("4BACD258-DE64-4048-BC4E-FEDBEF9ACB76")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface IToolboxService
	{
		/// <summary>Gets the names of all the tool categories currently on the toolbox.</summary>
		/// <returns>A <see cref="T:System.Drawing.Design.CategoryNameCollection" /> containing the tool categories.</returns>
		CategoryNameCollection CategoryNames { get; }

		/// <summary>Gets or sets the name of the currently selected tool category from the toolbox.</summary>
		/// <returns>The name of the currently selected category.</returns>
		string SelectedCategory { get; set; }

		/// <summary>Adds a new toolbox item creator for a specified data format.</summary>
		/// <param name="creator">A <see cref="T:System.Drawing.Design.ToolboxItemCreatorCallback" /> that can create a component when the toolbox item is invoked.</param>
		/// <param name="format">The data format that the creator handles.</param>
		void AddCreator(ToolboxItemCreatorCallback creator, string format);

		/// <summary>Adds a new toolbox item creator for a specified data format and designer host.</summary>
		/// <param name="creator">A <see cref="T:System.Drawing.Design.ToolboxItemCreatorCallback" /> that can create a component when the toolbox item is invoked.</param>
		/// <param name="format">The data format that the creator handles.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that represents the designer host to associate with the creator.</param>
		void AddCreator(ToolboxItemCreatorCallback creator, string format, IDesignerHost host);

		/// <summary>Adds the specified project-linked toolbox item to the toolbox.</summary>
		/// <param name="toolboxItem">The linked <see cref="T:System.Drawing.Design.ToolboxItem" /> to add to the toolbox.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> for the current design document.</param>
		void AddLinkedToolboxItem(ToolboxItem toolboxItem, IDesignerHost host);

		/// <summary>Adds the specified project-linked toolbox item to the toolbox in the specified category.</summary>
		/// <param name="toolboxItem">The linked <see cref="T:System.Drawing.Design.ToolboxItem" /> to add to the toolbox.</param>
		/// <param name="category">The toolbox item category to add the toolbox item to.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> for the current design document.</param>
		void AddLinkedToolboxItem(ToolboxItem toolboxItem, string category, IDesignerHost host);

		/// <summary>Adds the specified toolbox item to the toolbox.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to add to the toolbox.</param>
		void AddToolboxItem(ToolboxItem toolboxItem);

		/// <summary>Adds the specified toolbox item to the toolbox in the specified category.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to add to the toolbox.</param>
		/// <param name="category">The toolbox item category to add the <see cref="T:System.Drawing.Design.ToolboxItem" /> to.</param>
		void AddToolboxItem(ToolboxItem toolboxItem, string category);

		/// <summary>Gets a toolbox item from the specified object that represents a toolbox item in serialized form.</summary>
		/// <param name="serializedObject">The object that contains the <see cref="T:System.Drawing.Design.ToolboxItem" /> to retrieve.</param>
		/// <returns>The <see cref="T:System.Drawing.Design.ToolboxItem" /> created from the serialized object.</returns>
		ToolboxItem DeserializeToolboxItem(object serializedObject);

		/// <summary>Gets a toolbox item from the specified object that represents a toolbox item in serialized form, using the specified designer host.</summary>
		/// <param name="serializedObject">The object that contains the <see cref="T:System.Drawing.Design.ToolboxItem" /> to retrieve.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> to associate with this <see cref="T:System.Drawing.Design.ToolboxItem" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Design.ToolboxItem" /> created from deserialization.</returns>
		ToolboxItem DeserializeToolboxItem(object serializedObject, IDesignerHost host);

		/// <summary>Gets the currently selected toolbox item.</summary>
		/// <returns>The <see cref="T:System.Drawing.Design.ToolboxItem" /> that is currently selected, or <see langword="null" /> if no toolbox item has been selected.</returns>
		ToolboxItem GetSelectedToolboxItem();

		/// <summary>Gets the currently selected toolbox item if it is available to all designers, or if it supports the specified designer.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that the selected tool must be associated with for it to be returned.</param>
		/// <returns>The <see cref="T:System.Drawing.Design.ToolboxItem" /> that is currently selected, or <see langword="null" /> if no toolbox item is currently selected.</returns>
		ToolboxItem GetSelectedToolboxItem(IDesignerHost host);

		/// <summary>Gets the entire collection of toolbox items from the toolbox.</summary>
		/// <returns>A <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> that contains the current toolbox items.</returns>
		ToolboxItemCollection GetToolboxItems();

		/// <summary>Gets the collection of toolbox items that are associated with the specified designer host from the toolbox.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that is associated with the toolbox items to retrieve.</param>
		/// <returns>A <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> that contains the current toolbox items that are associated with the specified designer host.</returns>
		ToolboxItemCollection GetToolboxItems(IDesignerHost host);

		/// <summary>Gets a collection of toolbox items from the toolbox that match the specified category.</summary>
		/// <param name="category">The toolbox item category to retrieve all the toolbox items from.</param>
		/// <returns>A <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> that contains the current toolbox items that are associated with the specified category.</returns>
		ToolboxItemCollection GetToolboxItems(string category);

		/// <summary>Gets the collection of toolbox items that are associated with the specified designer host and category from the toolbox.</summary>
		/// <param name="category">The toolbox item category to retrieve the toolbox items from.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that is associated with the toolbox items to retrieve.</param>
		/// <returns>A <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> that contains the current toolbox items that are associated with the specified category and designer host.</returns>
		ToolboxItemCollection GetToolboxItems(string category, IDesignerHost host);

		/// <summary>Gets a value indicating whether the specified object which represents a serialized toolbox item can be used by the specified designer host.</summary>
		/// <param name="serializedObject">The object that contains the <see cref="T:System.Drawing.Design.ToolboxItem" /> to retrieve.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> to test for support for the <see cref="T:System.Drawing.Design.ToolboxItem" />.</param>
		/// <returns>
		///   <see langword="true" /> if the specified object is compatible with the specified designer host; otherwise, <see langword="false" />.</returns>
		bool IsSupported(object serializedObject, IDesignerHost host);

		/// <summary>Gets a value indicating whether the specified object which represents a serialized toolbox item matches the specified attributes.</summary>
		/// <param name="serializedObject">The object that contains the <see cref="T:System.Drawing.Design.ToolboxItem" /> to retrieve.</param>
		/// <param name="filterAttributes">An <see cref="T:System.Collections.ICollection" /> that contains the attributes to test the serialized object for.</param>
		/// <returns>
		///   <see langword="true" /> if the object matches the specified attributes; otherwise, <see langword="false" />.</returns>
		bool IsSupported(object serializedObject, ICollection filterAttributes);

		/// <summary>Gets a value indicating whether the specified object is a serialized toolbox item.</summary>
		/// <param name="serializedObject">The object to inspect.</param>
		/// <returns>
		///   <see langword="true" /> if the object contains a toolbox item object; otherwise, <see langword="false" />.</returns>
		bool IsToolboxItem(object serializedObject);

		/// <summary>Gets a value indicating whether the specified object is a serialized toolbox item, using the specified designer host.</summary>
		/// <param name="serializedObject">The object to inspect.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that is making this request.</param>
		/// <returns>
		///   <see langword="true" /> if the object contains a toolbox item object; otherwise, <see langword="false" />.</returns>
		bool IsToolboxItem(object serializedObject, IDesignerHost host);

		/// <summary>Refreshes the state of the toolbox items.</summary>
		void Refresh();

		/// <summary>Removes a previously added toolbox item creator of the specified data format.</summary>
		/// <param name="format">The data format of the creator to remove.</param>
		void RemoveCreator(string format);

		/// <summary>Removes a previously added toolbox creator that is associated with the specified data format and the specified designer host.</summary>
		/// <param name="format">The data format of the creator to remove.</param>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that is associated with the creator to remove.</param>
		void RemoveCreator(string format, IDesignerHost host);

		/// <summary>Removes the specified toolbox item from the toolbox.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to remove from the toolbox.</param>
		void RemoveToolboxItem(ToolboxItem toolboxItem);

		/// <summary>Removes the specified toolbox item from the toolbox.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to remove from the toolbox.</param>
		/// <param name="category">The toolbox item category to remove the <see cref="T:System.Drawing.Design.ToolboxItem" /> from.</param>
		void RemoveToolboxItem(ToolboxItem toolboxItem, string category);

		/// <summary>Notifies the toolbox service that the selected tool has been used.</summary>
		void SelectedToolboxItemUsed();

		/// <summary>Gets a serializable object that represents the specified toolbox item.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to serialize.</param>
		/// <returns>An object that represents the specified <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		object SerializeToolboxItem(ToolboxItem toolboxItem);

		/// <summary>Sets the current application's cursor to a cursor that represents the currently selected tool.</summary>
		/// <returns>
		///   <see langword="true" /> if the cursor is set by the currently selected tool, <see langword="false" /> if there is no tool selected and the cursor is set to the standard windows cursor.</returns>
		bool SetCursor();

		/// <summary>Selects the specified toolbox item.</summary>
		/// <param name="toolboxItem">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to select.</param>
		void SetSelectedToolboxItem(ToolboxItem toolboxItem);
	}
	/// <summary>Defines an interface for setting the currently selected toolbox item and indicating whether a designer supports a particular toolbox item.</summary>
	public interface IToolboxUser
	{
		/// <summary>Gets a value indicating whether the specified tool is supported by the current designer.</summary>
		/// <param name="tool">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to be tested for toolbox support.</param>
		/// <returns>
		///   <see langword="true" /> if the tool is supported by the toolbox and can be enabled; <see langword="false" /> if the document designer does not know how to use the tool.</returns>
		bool GetToolSupported(ToolboxItem tool);

		/// <summary>Selects the specified tool.</summary>
		/// <param name="tool">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to select.</param>
		void ToolPicked(ToolboxItem tool);
	}
	/// <summary>Provides data for the <see cref="M:System.Drawing.Design.UITypeEditor.PaintValue(System.Object,System.Drawing.Graphics,System.Drawing.Rectangle)" /> method.</summary>
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class PaintValueEventArgs : EventArgs
	{
		private readonly ITypeDescriptorContext context;

		private readonly object valueToPaint;

		private readonly Graphics graphics;

		private readonly Rectangle bounds;

		/// <summary>Gets the rectangle that indicates the area in which the painting should be done.</summary>
		/// <returns>The rectangle that indicates the area in which the painting should be done.</returns>
		public Rectangle Bounds => bounds;

		/// <summary>Gets the <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> interface to be used to gain additional information about the context this value appears in.</summary>
		/// <returns>An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that indicates the context of the event.</returns>
		public ITypeDescriptorContext Context => context;

		/// <summary>Gets the <see cref="T:System.Drawing.Graphics" /> object with which painting should be done.</summary>
		/// <returns>A <see cref="T:System.Drawing.Graphics" /> object to use for painting.</returns>
		public Graphics Graphics => graphics;

		/// <summary>Gets the value to paint.</summary>
		/// <returns>An object indicating what to paint.</returns>
		public object Value => valueToPaint;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.PaintValueEventArgs" /> class using the specified values.</summary>
		/// <param name="context">The context in which the value appears.</param>
		/// <param name="value">The value to paint.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> object with which drawing is to be done.</param>
		/// <param name="bounds">The <see cref="T:System.Drawing.Rectangle" /> in which drawing is to be done.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="graphics" /> is <see langword="null" />.</exception>
		public PaintValueEventArgs(ITypeDescriptorContext context, object value, Graphics graphics, Rectangle bounds)
		{
			this.context = context;
			valueToPaint = value;
			this.graphics = graphics;
			if (graphics == null)
			{
				throw new ArgumentNullException("graphics");
			}
			this.bounds = bounds;
		}
	}
	/// <summary>Represents the method that adds a delegate to an implementation of <see cref="T:System.Drawing.Design.IPropertyValueUIService" />.</summary>
	/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to obtain context information.</param>
	/// <param name="propDesc">A <see cref="T:System.ComponentModel.PropertyDescriptor" /> that represents the property being queried.</param>
	/// <param name="valueUIItemList">An <see cref="T:System.Collections.ArrayList" /> of <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> objects containing the UI items associated with the property.</param>
	public delegate void PropertyValueUIHandler(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList);
	/// <summary>Provides information about a property displayed in the Properties window, including the associated event handler, pop-up information string, and the icon to display for the property.</summary>
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class PropertyValueUIItem
	{
		private Image itemImage;

		private PropertyValueUIItemInvokeHandler handler;

		private string tooltip;

		/// <summary>Gets the 8 x 8 pixel image that will be drawn in the Properties window.</summary>
		/// <returns>The image to use for the property icon.</returns>
		public virtual Image Image => itemImage;

		/// <summary>Gets the handler that is raised when a user double-clicks this item.</summary>
		/// <returns>A <see cref="T:System.Drawing.Design.PropertyValueUIItemInvokeHandler" /> indicating the event handler for this user interface (UI) item.</returns>
		public virtual PropertyValueUIItemInvokeHandler InvokeHandler => handler;

		/// <summary>Gets or sets the information string to display for this item.</summary>
		/// <returns>A string containing the information string to display for this item.</returns>
		public virtual string ToolTip => tooltip;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> class.</summary>
		/// <param name="uiItemImage">The icon to display. The image must be 8 x 8 pixels.</param>
		/// <param name="handler">The handler to invoke when the image is double-clicked.</param>
		/// <param name="tooltip">The <see cref="P:System.Drawing.Design.PropertyValueUIItem.ToolTip" /> to display for the property that this <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> is associated with.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="uiItemImage" /> or <paramref name="handler" /> is <see langword="null" />.</exception>
		public PropertyValueUIItem(Image uiItemImage, PropertyValueUIItemInvokeHandler handler, string tooltip)
		{
			itemImage = uiItemImage;
			this.handler = handler;
			if (itemImage == null)
			{
				throw new ArgumentNullException("uiItemImage");
			}
			if (handler == null)
			{
				throw new ArgumentNullException("handler");
			}
			this.tooltip = tooltip;
		}

		/// <summary>Resets the user interface (UI) item.</summary>
		public virtual void Reset()
		{
		}
	}
	/// <summary>Represents the method that will handle the <see cref="P:System.Drawing.Design.PropertyValueUIItem.InvokeHandler" /> event of a <see cref="T:System.Drawing.Design.PropertyValueUIItem" />.</summary>
	/// <param name="context">The <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> for the property associated with the icon that was double-clicked.</param>
	/// <param name="descriptor">The property associated with the icon that was double-clicked.</param>
	/// <param name="invokedItem">The <see cref="T:System.Drawing.Design.PropertyValueUIItem" /> associated with the icon that was double-clicked.</param>
	public delegate void PropertyValueUIItemInvokeHandler(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem);
	/// <summary>Provides data for the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreated" /> event that occurs when components are added to the toolbox.</summary>
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class ToolboxComponentsCreatedEventArgs : EventArgs
	{
		private readonly IComponent[] comps;

		/// <summary>Gets or sets an array containing the components to add to the toolbox.</summary>
		/// <returns>An array of type <see cref="T:System.ComponentModel.IComponent" /> indicating the components to add to the toolbox.</returns>
		public IComponent[] Components => (IComponent[])comps.Clone();

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxComponentsCreatedEventArgs" /> class.</summary>
		/// <param name="components">The components to include in the toolbox.</param>
		public ToolboxComponentsCreatedEventArgs(IComponent[] components)
		{
			comps = components;
		}
	}
	/// <summary>Represents the method that handles the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreated" /> event.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Drawing.Design.ToolboxComponentsCreatedEventArgs" /> that provides data for the event.</param>
	public delegate void ToolboxComponentsCreatedEventHandler(object sender, ToolboxComponentsCreatedEventArgs e);
	/// <summary>Provides data for the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreating" /> event that occurs when components are added to the toolbox.</summary>
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class ToolboxComponentsCreatingEventArgs : EventArgs
	{
		private readonly IDesignerHost host;

		/// <summary>Gets or sets an instance of the <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that made the request to create toolbox components.</summary>
		/// <returns>The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> that made the request to create toolbox components, or <see langword="null" /> if no designer host was provided to the toolbox item.</returns>
		public IDesignerHost DesignerHost => host;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxComponentsCreatingEventArgs" /> class.</summary>
		/// <param name="host">The designer host that is making the request.</param>
		public ToolboxComponentsCreatingEventArgs(IDesignerHost host)
		{
			this.host = host;
		}
	}
	/// <summary>Represents the method that handles the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreating" /> event.</summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">A <see cref="T:System.Drawing.Design.ToolboxComponentsCreatingEventArgs" /> that provides data for the event.</param>
	public delegate void ToolboxComponentsCreatingEventHandler(object sender, ToolboxComponentsCreatingEventArgs e);
	/// <summary>Provides a base implementation of a toolbox item.</summary>
	[Serializable]
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class ToolboxItem : ISerializable
	{
		private class LockableDictionary : Hashtable
		{
			private ToolboxItem _item;

			public override bool IsFixedSize => _item.Locked;

			public override bool IsReadOnly => _item.Locked;

			public override object this[object key]
			{
				get
				{
					string propertyName = GetPropertyName(key);
					object value = base[propertyName];
					return _item.FilterPropertyValue(propertyName, value);
				}
				set
				{
					string propertyName = GetPropertyName(key);
					value = _item.ValidatePropertyValue(propertyName, value);
					CheckSerializable(value);
					_item.CheckUnlocked();
					base[propertyName] = value;
				}
			}

			internal LockableDictionary(ToolboxItem item, int capacity)
				: base(capacity)
			{
				_item = item;
			}

			public override void Add(object key, object value)
			{
				string propertyName = GetPropertyName(key);
				value = _item.ValidatePropertyValue(propertyName, value);
				CheckSerializable(value);
				_item.CheckUnlocked();
				base.Add(propertyName, value);
			}

			private void CheckSerializable(object value)
			{
				if (value != null && !value.GetType().IsSerializable)
				{
					throw new ArgumentException(SR.GetString("ToolboxItemValueNotSerializable", value.GetType().FullName));
				}
			}

			public override void Clear()
			{
				_item.CheckUnlocked();
				base.Clear();
			}

			private string GetPropertyName(object key)
			{
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				if (!(key is string text) || text.Length == 0)
				{
					throw new ArgumentException(SR.GetString("ToolboxItemInvalidKey"), "key");
				}
				return text;
			}

			public override void Remove(object key)
			{
				_item.CheckUnlocked();
				base.Remove(key);
			}
		}

		private static TraceSwitch ToolboxItemPersist = new TraceSwitch("ToolboxPersisting", "ToolboxItem: write data");

		private static object EventComponentsCreated = new object();

		private static object EventComponentsCreating = new object();

		private static bool isScalingInitialized = false;

		private const int ICON_DIMENSION = 16;

		private static int iconWidth = 16;

		private static int iconHeight = 16;

		private bool locked;

		private LockableDictionary properties;

		private ToolboxComponentsCreatedEventHandler componentsCreatedEvent;

		private ToolboxComponentsCreatingEventHandler componentsCreatingEvent;

		/// <summary>Gets or sets the name of the assembly that contains the type or types that the toolbox item creates.</summary>
		/// <returns>An <see cref="T:System.Reflection.AssemblyName" /> that indicates the assembly containing the type or types to create.</returns>
		public AssemblyName AssemblyName
		{
			get
			{
				return (AssemblyName)Properties["AssemblyName"];
			}
			set
			{
				Properties["AssemblyName"] = value;
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Reflection.AssemblyName" /> for the toolbox item.</summary>
		/// <returns>An array of <see cref="T:System.Reflection.AssemblyName" /> objects.</returns>
		public AssemblyName[] DependentAssemblies
		{
			get
			{
				AssemblyName[] array = (AssemblyName[])Properties["DependentAssemblies"];
				if (array != null)
				{
					return (AssemblyName[])array.Clone();
				}
				return null;
			}
			set
			{
				Properties["DependentAssemblies"] = value.Clone();
			}
		}

		/// <summary>Gets or sets a bitmap to represent the toolbox item in the toolbox.</summary>
		/// <returns>A <see cref="T:System.Drawing.Bitmap" /> that represents the toolbox item in the toolbox.</returns>
		public Bitmap Bitmap
		{
			get
			{
				return (Bitmap)Properties["Bitmap"];
			}
			set
			{
				Properties["Bitmap"] = value;
			}
		}

		/// <summary>Gets or sets the original bitmap that will be used in the toolbox for this item.</summary>
		/// <returns>A <see cref="T:System.Drawing.Bitmap" /> that represents the toolbox item in the toolbox.</returns>
		public Bitmap OriginalBitmap
		{
			get
			{
				return (Bitmap)Properties["OriginalBitmap"];
			}
			set
			{
				Properties["OriginalBitmap"] = value;
			}
		}

		/// <summary>Gets or sets the company name for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that specifies the company for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public string Company
		{
			get
			{
				return (string)Properties["Company"];
			}
			set
			{
				Properties["Company"] = value;
			}
		}

		/// <summary>Gets the component type for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that specifies the component type for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public virtual string ComponentType => SR.GetString("DotNET_ComponentType");

		/// <summary>Gets or sets the description for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that specifies the description for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public string Description
		{
			get
			{
				return (string)Properties["Description"];
			}
			set
			{
				Properties["Description"] = value;
			}
		}

		/// <summary>Gets or sets the display name for the toolbox item.</summary>
		/// <returns>The display name for the toolbox item.</returns>
		public string DisplayName
		{
			get
			{
				return (string)Properties["DisplayName"];
			}
			set
			{
				Properties["DisplayName"] = value;
			}
		}

		/// <summary>Gets or sets the filter that determines whether the toolbox item can be used on a destination component.</summary>
		/// <returns>An <see cref="T:System.Collections.ICollection" /> of <see cref="T:System.ComponentModel.ToolboxItemFilterAttribute" /> objects.</returns>
		public ICollection Filter
		{
			get
			{
				return (ICollection)Properties["Filter"];
			}
			set
			{
				Properties["Filter"] = value;
			}
		}

		/// <summary>Gets a value indicating whether the toolbox item is transient.</summary>
		/// <returns>
		///   <see langword="true" />, if this toolbox item should not be stored in any toolbox database when an application that is providing a toolbox closes; otherwise, <see langword="false" />.</returns>
		public bool IsTransient
		{
			get
			{
				return (bool)Properties["IsTransient"];
			}
			set
			{
				Properties["IsTransient"] = value;
			}
		}

		/// <summary>Gets a value indicating whether the <see cref="T:System.Drawing.Design.ToolboxItem" /> is currently locked.</summary>
		/// <returns>
		///   <see langword="true" /> if the toolbox item is locked; otherwise, <see langword="false" />.</returns>
		public virtual bool Locked => locked;

		/// <summary>Gets a dictionary of properties.</summary>
		/// <returns>A dictionary of name/value pairs (the names are property names and the values are property values).</returns>
		public IDictionary Properties
		{
			get
			{
				if (properties == null)
				{
					properties = new LockableDictionary(this, 8);
				}
				return properties;
			}
		}

		/// <summary>Gets or sets the fully qualified name of the type of <see cref="T:System.ComponentModel.IComponent" /> that the toolbox item creates when invoked.</summary>
		/// <returns>The fully qualified type name of the type of component that this toolbox item creates.</returns>
		public string TypeName
		{
			get
			{
				return (string)Properties["TypeName"];
			}
			set
			{
				Properties["TypeName"] = value;
			}
		}

		/// <summary>Gets the version for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that specifies the version for this <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public virtual string Version
		{
			get
			{
				if (AssemblyName != null)
				{
					return AssemblyName.Version.ToString();
				}
				return string.Empty;
			}
		}

		/// <summary>Occurs immediately after components are created.</summary>
		public event ToolboxComponentsCreatedEventHandler ComponentsCreated
		{
			add
			{
				componentsCreatedEvent = (ToolboxComponentsCreatedEventHandler)Delegate.Combine(componentsCreatedEvent, value);
			}
			remove
			{
				componentsCreatedEvent = (ToolboxComponentsCreatedEventHandler)Delegate.Remove(componentsCreatedEvent, value);
			}
		}

		/// <summary>Occurs when components are about to be created.</summary>
		public event ToolboxComponentsCreatingEventHandler ComponentsCreating
		{
			add
			{
				componentsCreatingEvent = (ToolboxComponentsCreatingEventHandler)Delegate.Combine(componentsCreatingEvent, value);
			}
			remove
			{
				componentsCreatingEvent = (ToolboxComponentsCreatingEventHandler)Delegate.Remove(componentsCreatingEvent, value);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxItem" /> class.</summary>
		public ToolboxItem()
		{
			if (!isScalingInitialized)
			{
				if (DpiHelper.IsScalingRequired)
				{
					iconWidth = DpiHelper.LogicalToDeviceUnitsX(16);
					iconHeight = DpiHelper.LogicalToDeviceUnitsY(16);
				}
				isScalingInitialized = true;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxItem" /> class that creates the specified type of component.</summary>
		/// <param name="toolType">The type of <see cref="T:System.ComponentModel.IComponent" /> that the toolbox item creates.</param>
		/// <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Drawing.Design.ToolboxItem" /> was locked.</exception>
		public ToolboxItem(Type toolType)
			: this()
		{
			Initialize(toolType);
		}

		private ToolboxItem(SerializationInfo info, StreamingContext context)
			: this()
		{
			Deserialize(info, context);
		}

		/// <summary>Throws an exception if the toolbox item is currently locked.</summary>
		/// <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Drawing.Design.ToolboxItem" /> is locked.</exception>
		protected void CheckUnlocked()
		{
			if (Locked)
			{
				throw new InvalidOperationException(SR.GetString("ToolboxItemLocked"));
			}
		}

		/// <summary>Creates the components that the toolbox item is configured to create.</summary>
		/// <returns>An array of created <see cref="T:System.ComponentModel.IComponent" /> objects.</returns>
		public IComponent[] CreateComponents()
		{
			return CreateComponents(null);
		}

		/// <summary>Creates the components that the toolbox item is configured to create, using the specified designer host.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> to use when creating the components.</param>
		/// <returns>An array of created <see cref="T:System.ComponentModel.IComponent" /> objects.</returns>
		public IComponent[] CreateComponents(IDesignerHost host)
		{
			OnComponentsCreating(new ToolboxComponentsCreatingEventArgs(host));
			IComponent[] array = CreateComponentsCore(host, new Hashtable());
			if (array != null && array.Length != 0)
			{
				OnComponentsCreated(new ToolboxComponentsCreatedEventArgs(array));
			}
			return array;
		}

		/// <summary>Creates the components that the toolbox item is configured to create, using the specified designer host and default values.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> to use when creating the components.</param>
		/// <param name="defaultValues">A dictionary of property name/value pairs of default values with which to initialize the component.</param>
		/// <returns>An array of created <see cref="T:System.ComponentModel.IComponent" /> objects.</returns>
		public IComponent[] CreateComponents(IDesignerHost host, IDictionary defaultValues)
		{
			OnComponentsCreating(new ToolboxComponentsCreatingEventArgs(host));
			IComponent[] array = CreateComponentsCore(host, defaultValues);
			if (array != null && array.Length != 0)
			{
				OnComponentsCreated(new ToolboxComponentsCreatedEventArgs(array));
			}
			return array;
		}

		/// <summary>Creates a component or an array of components when the toolbox item is invoked.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> to host the toolbox item.</param>
		/// <returns>An array of created <see cref="T:System.ComponentModel.IComponent" /> objects.</returns>
		protected virtual IComponent[] CreateComponentsCore(IDesignerHost host)
		{
			ArrayList arrayList = new ArrayList();
			Type type = GetType(host, AssemblyName, TypeName, reference: true);
			if (type != null)
			{
				if (host != null)
				{
					arrayList.Add(host.CreateComponent(type));
				}
				else if (typeof(IComponent).IsAssignableFrom(type))
				{
					arrayList.Add(TypeDescriptor.CreateInstance(null, type, null, null));
				}
			}
			IComponent[] array = new IComponent[arrayList.Count];
			arrayList.CopyTo(array, 0);
			return array;
		}

		/// <summary>Creates an array of components when the toolbox item is invoked.</summary>
		/// <param name="host">The designer host to use when creating components.</param>
		/// <param name="defaultValues">A dictionary of property name/value pairs of default values with which to initialize the component.</param>
		/// <returns>An array of created <see cref="T:System.ComponentModel.IComponent" /> objects.</returns>
		protected virtual IComponent[] CreateComponentsCore(IDesignerHost host, IDictionary defaultValues)
		{
			IComponent[] array = CreateComponentsCore(host);
			if (host != null)
			{
				for (int i = 0; i < array.Length; i++)
				{
					if (!(host.GetDesigner(array[i]) is IComponentInitializer componentInitializer))
					{
						continue;
					}
					bool flag = true;
					try
					{
						componentInitializer.InitializeNewComponent(defaultValues);
						flag = false;
					}
					finally
					{
						if (flag)
						{
							for (int j = 0; j < array.Length; j++)
							{
								host.DestroyComponent(array[j]);
							}
						}
					}
				}
			}
			return array;
		}

		/// <summary>Loads the state of the toolbox item from the specified serialization information object.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to load from.</param>
		/// <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that indicates the stream characteristics.</param>
		protected virtual void Deserialize(SerializationInfo info, StreamingContext context)
		{
			string[] array = null;
			SerializationInfoEnumerator enumerator = info.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				if (current.Name.Equals("PropertyNames"))
				{
					array = current.Value as string[];
					break;
				}
			}
			if (array == null)
			{
				array = new string[6] { "AssemblyName", "Bitmap", "DisplayName", "Filter", "IsTransient", "TypeName" };
			}
			SerializationInfoEnumerator enumerator2 = info.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				SerializationEntry current2 = enumerator2.Current;
				string[] array2 = array;
				foreach (string text in array2)
				{
					if (text.Equals(current2.Name))
					{
						Properties[current2.Name] = current2.Value;
						break;
					}
				}
			}
			if (info.GetBoolean("Locked"))
			{
				Lock();
			}
		}

		private static bool AreAssemblyNamesEqual(AssemblyName name1, AssemblyName name2)
		{
			if (name1 != name2)
			{
				if (name1 != null && name2 != null)
				{
					return name1.FullName == name2.FullName;
				}
				return false;
			}
			return true;
		}

		/// <summary>Determines whether two <see cref="T:System.Drawing.Design.ToolboxItem" /> instances are equal.</summary>
		/// <param name="obj">The <see cref="T:System.Drawing.Design.ToolboxItem" /> to compare with the current <see cref="T:System.Drawing.Design.ToolboxItem" />.</param>
		/// <returns>
		///   <see langword="true" /> if the specified <see cref="T:System.Drawing.Design.ToolboxItem" /> is equal to the current <see cref="T:System.Drawing.Design.ToolboxItem" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (this == obj)
			{
				return true;
			}
			if (obj == null)
			{
				return false;
			}
			if (!(obj.GetType() == GetType()))
			{
				return false;
			}
			ToolboxItem toolboxItem = (ToolboxItem)obj;
			if (TypeName == toolboxItem.TypeName && AreAssemblyNamesEqual(AssemblyName, toolboxItem.AssemblyName))
			{
				return DisplayName == toolboxItem.DisplayName;
			}
			return false;
		}

		/// <summary>Returns the hash code for this instance.</summary>
		/// <returns>A hash code for the current <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public override int GetHashCode()
		{
			int num = TypeName?.GetHashCode() ?? 0;
			return num ^ DisplayName.GetHashCode();
		}

		/// <summary>Filters a property value before returning it.</summary>
		/// <param name="propertyName">The name of the property to filter.</param>
		/// <param name="value">The value against which to filter the property.</param>
		/// <returns>A filtered property value.</returns>
		protected virtual object FilterPropertyValue(string propertyName, object value)
		{
			switch (propertyName)
			{
			case "AssemblyName":
				if (value != null)
				{
					value = ((AssemblyName)value).Clone();
				}
				break;
			case "DisplayName":
			case "TypeName":
				if (value == null)
				{
					value = string.Empty;
				}
				break;
			case "Filter":
				if (value == null)
				{
					value = new ToolboxItemFilterAttribute[0];
				}
				break;
			case "IsTransient":
				if (value == null)
				{
					value = false;
				}
				break;
			}
			return value;
		}

		/// <summary>Enables access to the type associated with the toolbox item.</summary>
		/// <param name="host">The designer host to query for <see cref="T:System.ComponentModel.Design.ITypeResolutionService" />.</param>
		/// <returns>The type associated with the toolbox item.</returns>
		public Type GetType(IDesignerHost host)
		{
			return GetType(host, AssemblyName, TypeName, reference: false);
		}

		/// <summary>Creates an instance of the specified type, optionally using a specified designer host and assembly name.</summary>
		/// <param name="host">The <see cref="T:System.ComponentModel.Design.IDesignerHost" /> for the current document. This can be <see langword="null" />.</param>
		/// <param name="assemblyName">An <see cref="T:System.Reflection.AssemblyName" /> that indicates the assembly that contains the type to load. This can be <see langword="null" />.</param>
		/// <param name="typeName">The name of the type to create an instance of.</param>
		/// <param name="reference">A value indicating whether or not to add a reference to the assembly that contains the specified type to the designer host's set of references.</param>
		/// <returns>An instance of the specified type, if it can be located.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="typeName" /> is not specified.</exception>
		protected virtual Type GetType(IDesignerHost host, AssemblyName assemblyName, string typeName, bool reference)
		{
			ITypeResolutionService typeResolutionService = null;
			Type type = null;
			if (typeName == null)
			{
				throw new ArgumentNullException("typeName");
			}
			if (host != null)
			{
				typeResolutionService = (ITypeResolutionService)host.GetService(typeof(ITypeResolutionService));
			}
			if (typeResolutionService != null)
			{
				if (reference)
				{
					if (assemblyName != null)
					{
						typeResolutionService.ReferenceAssembly(assemblyName);
						type = typeResolutionService.GetType(typeName);
					}
					else
					{
						type = typeResolutionService.GetType(typeName);
						if (type == null)
						{
							type = Type.GetType(typeName);
						}
						if (type != null)
						{
							typeResolutionService.ReferenceAssembly(type.Assembly.GetName());
						}
					}
				}
				else
				{
					if (assemblyName != null)
					{
						Assembly assembly = typeResolutionService.GetAssembly(assemblyName);
						if (assembly != null)
						{
							type = assembly.GetType(typeName);
						}
					}
					if (type == null)
					{
						type = typeResolutionService.GetType(typeName);
					}
				}
			}
			else if (!string.IsNullOrEmpty(typeName))
			{
				if (assemblyName != null)
				{
					Assembly assembly2 = null;
					try
					{
						assembly2 = Assembly.Load(assemblyName);
					}
					catch (FileNotFoundException)
					{
					}
					catch (BadImageFormatException)
					{
					}
					catch (IOException)
					{
					}
					if (assembly2 == null && assemblyName.CodeBase != null && assemblyName.CodeBase.Length > 0)
					{
						try
						{
							assembly2 = Assembly.LoadFrom(assemblyName.CodeBase);
						}
						catch (FileNotFoundException)
						{
						}
						catch (BadImageFormatException)
						{
						}
						catch (IOException)
						{
						}
					}
					if (assembly2 != null)
					{
						type = assembly2.GetType(typeName);
					}
				}
				if (type == null)
				{
					type = Type.GetType(typeName, throwOnError: false);
				}
			}
			return type;
		}

		private AssemblyName GetNonRetargetedAssemblyName(Type type, AssemblyName policiedAssemblyName)
		{
			if (type == null || policiedAssemblyName == null)
			{
				return null;
			}
			if (type.Assembly.FullName == policiedAssemblyName.FullName)
			{
				return policiedAssemblyName;
			}
			AssemblyName[] referencedAssemblies = type.Assembly.GetReferencedAssemblies();
			foreach (AssemblyName assemblyName in referencedAssemblies)
			{
				if (assemblyName.FullName == policiedAssemblyName.FullName)
				{
					return assemblyName;
				}
			}
			AssemblyName[] referencedAssemblies2 = type.Assembly.GetReferencedAssemblies();
			foreach (AssemblyName assemblyName2 in referencedAssemblies2)
			{
				if (assemblyName2.Name == policiedAssemblyName.Name)
				{
					return assemblyName2;
				}
			}
			AssemblyName[] referencedAssemblies3 = type.Assembly.GetReferencedAssemblies();
			foreach (AssemblyName assemblyName3 in referencedAssemblies3)
			{
				Assembly assembly = null;
				try
				{
					assembly = Assembly.Load(assemblyName3);
					if (assembly != null && assembly.FullName == policiedAssemblyName.FullName)
					{
						return assemblyName3;
					}
				}
				catch
				{
				}
			}
			return null;
		}

		/// <summary>Initializes the current toolbox item with the specified type to create.</summary>
		/// <param name="type">The <see cref="T:System.Type" /> that the toolbox item creates.</param>
		/// <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Drawing.Design.ToolboxItem" /> was locked.</exception>
		public virtual void Initialize(Type type)
		{
			CheckUnlocked();
			if (!(type != null))
			{
				return;
			}
			TypeName = type.FullName;
			AssemblyName name = type.Assembly.GetName(copiedName: true);
			if (type.Assembly.GlobalAssemblyCache)
			{
				name.CodeBase = null;
			}
			Dictionary<string, AssemblyName> dictionary = new Dictionary<string, AssemblyName>();
			Type type2 = type;
			while (type2 != null)
			{
				AssemblyName name2 = type2.Assembly.GetName(copiedName: true);
				AssemblyName nonRetargetedAssemblyName = GetNonRetargetedAssemblyName(type, name2);
				if (nonRetargetedAssemblyName != null && !dictionary.ContainsKey(nonRetargetedAssemblyName.FullName))
				{
					dictionary[nonRetargetedAssemblyName.FullName] = nonRetargetedAssemblyName;
				}
				type2 = type2.BaseType;
			}
			AssemblyName[] array = new AssemblyName[dictionary.Count];
			int num = 0;
			foreach (AssemblyName value in dictionary.Values)
			{
				array[num++] = value;
			}
			DependentAssemblies = array;
			AssemblyName = name;
			DisplayName = type.Name;
			if (type.Assembly.ReflectionOnly)
			{
				return;
			}
			object[] customAttributes = type.Assembly.GetCustomAttributes(typeof(AssemblyCompanyAttribute), inherit: true);
			if (customAttributes != null && customAttributes.Length != 0 && customAttributes[0] is AssemblyCompanyAttribute assemblyCompanyAttribute && assemblyCompanyAttribute.Company != null)
			{
				Company = assemblyCompanyAttribute.Company;
			}
			DescriptionAttribute descriptionAttribute = (DescriptionAttribute)TypeDescriptor.GetAttributes(type)[typeof(DescriptionAttribute)];
			if (descriptionAttribute != null)
			{
				Description = descriptionAttribute.Description;
			}
			ToolboxBitmapAttribute toolboxBitmapAttribute = (ToolboxBitmapAttribute)TypeDescriptor.GetAttributes(type)[typeof(ToolboxBitmapAttribute)];
			if (toolboxBitmapAttribute != null)
			{
				Bitmap bitmap = toolboxBitmapAttribute.GetImage(type, large: false) as Bitmap;
				if (bitmap != null)
				{
					OriginalBitmap = toolboxBitmapAttribute.GetOriginalBitmap();
					if (bitmap.Width != iconWidth || bitmap.Height != iconHeight)
					{
						bitmap = new Bitmap(bitmap, new Size(iconWidth, iconHeight));
					}
				}
				Bitmap = bitmap;
			}
			bool flag = false;
			ArrayList arrayList = new ArrayList();
			foreach (Attribute attribute in TypeDescriptor.GetAttributes(type))
			{
				if (attribute is ToolboxItemFilterAttribute toolboxItemFilterAttribute)
				{
					if (toolboxItemFilterAttribute.FilterString.Equals(TypeName))
					{
						flag = true;
					}
					arrayList.Add(toolboxItemFilterAttribute);
				}
			}
			if (!flag)
			{
				arrayList.Add(new ToolboxItemFilterAttribute(TypeName));
			}
			Filter = (ToolboxItemFilterAttribute[])arrayList.ToArray(typeof(ToolboxItemFilterAttribute));
		}

		/// <summary>Locks the toolbox item and prevents changes to its properties.</summary>
		public virtual void Lock()
		{
			locked = true;
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreated" /> event.</summary>
		/// <param name="args">A <see cref="T:System.Drawing.Design.ToolboxComponentsCreatedEventArgs" /> that provides data for the event.</param>
		protected virtual void OnComponentsCreated(ToolboxComponentsCreatedEventArgs args)
		{
			if (componentsCreatedEvent != null)
			{
				componentsCreatedEvent(this, args);
			}
		}

		/// <summary>Raises the <see cref="E:System.Drawing.Design.ToolboxItem.ComponentsCreating" /> event.</summary>
		/// <param name="args">A <see cref="T:System.Drawing.Design.ToolboxComponentsCreatingEventArgs" /> that provides data for the event.</param>
		protected virtual void OnComponentsCreating(ToolboxComponentsCreatingEventArgs args)
		{
			if (componentsCreatingEvent != null)
			{
				componentsCreatingEvent(this, args);
			}
		}

		/// <summary>Saves the state of the toolbox item to the specified serialization information object.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to save to.</param>
		/// <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that indicates the stream characteristics.</param>
		protected virtual void Serialize(SerializationInfo info, StreamingContext context)
		{
			_ = ToolboxItemPersist.TraceVerbose;
			info.AddValue("Locked", Locked);
			ArrayList arrayList = new ArrayList(Properties.Count);
			foreach (DictionaryEntry property in Properties)
			{
				arrayList.Add(property.Key);
				info.AddValue((string)property.Key, property.Value);
			}
			info.AddValue("PropertyNames", (string[])arrayList.ToArray(typeof(string)));
		}

		/// <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public override string ToString()
		{
			return DisplayName;
		}

		/// <summary>Validates that an object is of a given type.</summary>
		/// <param name="propertyName">The name of the property to validate.</param>
		/// <param name="value">Optional value against which to validate.</param>
		/// <param name="expectedType">The expected type of the property.</param>
		/// <param name="allowNull">
		///   <see langword="true" /> to allow <see langword="null" />; otherwise, <see langword="false" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="value" /> is <see langword="null" />, and <paramref name="allowNull" /> is <see langword="false" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="value" /> is not the type specified by <paramref name="expectedType" />.</exception>
		protected void ValidatePropertyType(string propertyName, object value, Type expectedType, bool allowNull)
		{
			if (value == null)
			{
				if (!allowNull)
				{
					throw new ArgumentNullException("value");
				}
			}
			else if (!expectedType.IsInstanceOfType(value))
			{
				throw new ArgumentException(SR.GetString("ToolboxItemInvalidPropertyType", propertyName, expectedType.FullName), "value");
			}
		}

		/// <summary>Validates a property before it is assigned to the property dictionary.</summary>
		/// <param name="propertyName">The name of the property to validate.</param>
		/// <param name="value">The value against which to validate.</param>
		/// <returns>The value used to perform validation.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="value" /> is <see langword="null" />, and <paramref name="propertyName" /> is "IsTransient".</exception>
		protected virtual object ValidatePropertyValue(string propertyName, object value)
		{
			switch (propertyName)
			{
			case "AssemblyName":
				ValidatePropertyType(propertyName, value, typeof(AssemblyName), allowNull: true);
				break;
			case "Bitmap":
				ValidatePropertyType(propertyName, value, typeof(Bitmap), allowNull: true);
				break;
			case "OriginalBitmap":
				ValidatePropertyType(propertyName, value, typeof(Bitmap), allowNull: true);
				break;
			case "Company":
			case "Description":
			case "DisplayName":
			case "TypeName":
				ValidatePropertyType(propertyName, value, typeof(string), allowNull: true);
				if (value == null)
				{
					value = string.Empty;
				}
				break;
			case "Filter":
			{
				ValidatePropertyType(propertyName, value, typeof(ICollection), allowNull: true);
				int num = 0;
				ICollection collection = (ICollection)value;
				if (collection != null)
				{
					foreach (object item in collection)
					{
						if (item is ToolboxItemFilterAttribute)
						{
							num++;
						}
					}
				}
				ToolboxItemFilterAttribute[] array = new ToolboxItemFilterAttribute[num];
				if (collection != null)
				{
					num = 0;
					foreach (object item2 in collection)
					{
						if (item2 is ToolboxItemFilterAttribute toolboxItemFilterAttribute)
						{
							array[num++] = toolboxItemFilterAttribute;
						}
					}
				}
				value = array;
				break;
			}
			case "IsTransient":
				ValidatePropertyType(propertyName, value, typeof(bool), allowNull: false);
				break;
			}
			return value;
		}

		/// <summary>For a description of this member, see the <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> method.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this serialization.</param>
		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
		{
			IntSecurity.UnmanagedCode.Demand();
			Serialize(info, context);
		}
	}
	/// <summary>Represents a collection of toolbox items.</summary>
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public sealed class ToolboxItemCollection : ReadOnlyCollectionBase
	{
		/// <summary>Gets the <see cref="T:System.Drawing.Design.ToolboxItem" /> at the specified index.</summary>
		/// <param name="index">The index of the object to get or set.</param>
		/// <returns>A <see cref="T:System.Drawing.Design.ToolboxItem" /> at each valid index in the collection.</returns>
		public ToolboxItem this[int index] => (ToolboxItem)base.InnerList[index];

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> class using the specified collection.</summary>
		/// <param name="value">A <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> to fill the new collection with.</param>
		public ToolboxItemCollection(ToolboxItemCollection value)
		{
			base.InnerList.AddRange(value);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.ToolboxItemCollection" /> class using the specified array of toolbox items.</summary>
		/// <param name="value">An array of type <see cref="T:System.Drawing.Design.ToolboxItem" /> containing the toolbox items to fill the collection with.</param>
		public ToolboxItemCollection(ToolboxItem[] value)
		{
			base.InnerList.AddRange(value);
		}

		/// <summary>Indicates whether the collection contains the specified <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
		/// <param name="value">A <see cref="T:System.Drawing.Design.ToolboxItem" /> to search the collection for.</param>
		/// <returns>
		///   <see langword="true" /> if the collection contains the specified object; otherwise, <see langword="false" />.</returns>
		public bool Contains(ToolboxItem value)
		{
			return base.InnerList.Contains(value);
		}

		/// <summary>Copies the collection to the specified array beginning with the specified destination index.</summary>
		/// <param name="array">The array to copy to.</param>
		/// <param name="index">The index to begin copying to.</param>
		public void CopyTo(ToolboxItem[] array, int index)
		{
			base.InnerList.CopyTo(array, index);
		}

		/// <summary>Gets the index of the specified <see cref="T:System.Drawing.Design.ToolboxItem" />, if it exists in the collection.</summary>
		/// <param name="value">A <see cref="T:System.Drawing.Design.ToolboxItem" /> to get the index of in the collection.</param>
		/// <returns>The index of the specified <see cref="T:System.Drawing.Design.ToolboxItem" />.</returns>
		public int IndexOf(ToolboxItem value)
		{
			return base.InnerList.IndexOf(value);
		}
	}
	/// <summary>Provides a callback mechanism that can create a <see cref="T:System.Drawing.Design.ToolboxItem" />.</summary>
	/// <param name="serializedObject">The object which contains the data to create a <see cref="T:System.Drawing.Design.ToolboxItem" /> for.</param>
	/// <param name="format">The name of the clipboard data format to create a <see cref="T:System.Drawing.Design.ToolboxItem" /> for.</param>
	/// <returns>The deserialized <see cref="T:System.Drawing.Design.ToolboxItem" /> object specified by <paramref name="serializedObject" />.</returns>
	public delegate ToolboxItem ToolboxItemCreatorCallback(object serializedObject, string format);
	/// <summary>Provides a base class that can be used to design value editors that can provide a user interface (UI) for representing and editing the values of objects of the supported data types.</summary>
	[PermissionSet(SecurityAction.InheritanceDemand, Name = "FullTrust")]
	[PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
	public class UITypeEditor
	{
		/// <summary>Gets a value indicating whether drop-down editors should be resizable by the user.</summary>
		/// <returns>
		///   <see langword="true" /> if drop-down editors are resizable; otherwise, <see langword="false" />.</returns>
		public virtual bool IsDropDownResizable => false;

		static UITypeEditor()
		{
			Hashtable table = new Hashtable
			{
				[typeof(DateTime)] = "System.ComponentModel.Design.DateTimeEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(Array)] = "System.ComponentModel.Design.ArrayEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(IList)] = "System.ComponentModel.Design.CollectionEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(ICollection)] = "System.ComponentModel.Design.CollectionEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(byte[])] = "System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(Stream)] = "System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(string[])] = "System.Windows.Forms.Design.StringArrayEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
				[typeof(Collection<string>)] = "System.Windows.Forms.Design.StringCollectionEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"
			};
			TypeDescriptor.AddEditorTable(typeof(UITypeEditor), table);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Design.UITypeEditor" /> class.</summary>
		public UITypeEditor()
		{
		}

		/// <summary>Edits the value of the specified object using the editor style indicated by the <see cref="M:System.Drawing.Design.UITypeEditor.GetEditStyle" /> method.</summary>
		/// <param name="provider">An <see cref="T:System.IServiceProvider" /> that this editor can use to obtain services.</param>
		/// <param name="value">The object to edit.</param>
		/// <returns>The new value of the object.</returns>
		public object EditValue(IServiceProvider provider, object value)
		{
			return EditValue(null, provider, value);
		}

		/// <summary>Edits the specified object's value using the editor style indicated by the <see cref="M:System.Drawing.Design.UITypeEditor.GetEditStyle" /> method.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to gain additional context information.</param>
		/// <param name="provider">An <see cref="T:System.IServiceProvider" /> that this editor can use to obtain services.</param>
		/// <param name="value">The object to edit.</param>
		/// <returns>The new value of the object. If the value of the object has not changed, this should return the same object it was passed.</returns>
		public virtual object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value)
		{
			return value;
		}

		/// <summary>Gets the editor style used by the <see cref="M:System.Drawing.Design.UITypeEditor.EditValue(System.IServiceProvider,System.Object)" /> method.</summary>
		/// <returns>A <see cref="T:System.Drawing.Design.UITypeEditorEditStyle" /> enumeration value that indicates the style of editor used by the current <see cref="T:System.Drawing.Design.UITypeEditor" />. By default, this method will return <see cref="F:System.Drawing.Design.UITypeEditorEditStyle.None" />.</returns>
		public UITypeEditorEditStyle GetEditStyle()
		{
			return GetEditStyle(null);
		}

		/// <summary>Indicates whether this editor supports painting a representation of an object's value.</summary>
		/// <returns>
		///   <see langword="true" /> if <see cref="M:System.Drawing.Design.UITypeEditor.PaintValue(System.Object,System.Drawing.Graphics,System.Drawing.Rectangle)" /> is implemented; otherwise, <see langword="false" />.</returns>
		public bool GetPaintValueSupported()
		{
			return GetPaintValueSupported(null);
		}

		/// <summary>Indicates whether the specified context supports painting a representation of an object's value within the specified context.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to gain additional context information.</param>
		/// <returns>
		///   <see langword="true" /> if <see cref="M:System.Drawing.Design.UITypeEditor.PaintValue(System.Object,System.Drawing.Graphics,System.Drawing.Rectangle)" /> is implemented; otherwise, <see langword="false" />.</returns>
		public virtual bool GetPaintValueSupported(ITypeDescriptorContext context)
		{
			return false;
		}

		/// <summary>Gets the editor style used by the <see cref="M:System.Drawing.Design.UITypeEditor.EditValue(System.IServiceProvider,System.Object)" /> method.</summary>
		/// <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> that can be used to gain additional context information.</param>
		/// <returns>A <see cref="T:System.Drawing.Design.UITypeEditorEditStyle" /> value that indicates the style of editor used by the <see cref="M:System.Drawing.Design.UITypeEditor.EditValue(System.IServiceProvider,System.Object)" /> method. If the <see cref="T:System.Drawing.Design.UITypeEditor" /> does not support this method, then <see cref="M:System.Drawing.Design.UITypeEditor.GetEditStyle" /> will return <see cref="F:System.Drawing.Design.UITypeEditorEditStyle.None" />.</returns>
		public virtual UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context)
		{
			return UITypeEditorEditStyle.None;
		}

		/// <summary>Paints a representation of the value of the specified object to the specified canvas.</summary>
		/// <param name="value">The object whose value this type editor will display.</param>
		/// <param name="canvas">A drawing canvas on which to paint the representation of the object's value.</param>
		/// <param name="rectangle">A <see cref="T:System.Drawing.Rectangle" /> within whose boundaries to paint the value.</param>
		public void PaintValue(object value, Graphics canvas, Rectangle rectangle)
		{
			PaintValue(new PaintValueEventArgs(null, value, canvas, rectangle));
		}

		/// <summary>Paints a representation of the value of an object using the specified <see cref="T:System.Drawing.Design.PaintValueEventArgs" />.</summary>
		/// <param name="e">A <see cref="T:System.Drawing.Design.PaintValueEventArgs" /> that indicates what to paint and where to paint it.</param>
		public virtual void PaintValue(PaintValueEventArgs e)
		{
		}
	}
	/// <summary>Specifies identifiers that indicate the value editing style of a <see cref="T:System.Drawing.Design.UITypeEditor" />.</summary>
	public enum UITypeEditorEditStyle
	{
		/// <summary>Provides no interactive user interface (UI) component.</summary>
		None = 1,
		/// <summary>Displays an ellipsis (...) button to start a modal dialog box, which requires user input before continuing a program, or a modeless dialog box, which stays on the screen and is available for use at any time but permits other user activities.</summary>
		Modal,
		/// <summary>Displays a drop-down arrow button and hosts the user interface (UI) in a drop-down dialog box.</summary>
		DropDown
	}
}
namespace System.Drawing.Configuration
{
	/// <summary>Represents the configuration section used by classes in the <see cref="N:System.Drawing" /> namespace.</summary>
	public sealed class SystemDrawingSection : ConfigurationSection
	{
		private const string BitmapSuffixSectionName = "bitmapSuffix";

		private static readonly ConfigurationPropertyCollection properties;

		private static readonly ConfigurationProperty bitmapSuffix;

		/// <summary>Gets or sets the suffix to append to a file name indicated by a <see cref="T:System.Drawing.ToolboxBitmapAttribute" /> when an assembly is declared with a <see cref="T:System.Drawing.BitmapSuffixInSameAssemblyAttribute" /> or a <see cref="T:System.Drawing.BitmapSuffixInSatelliteAssemblyAttribute" />.</summary>
		/// <returns>The bitmap suffix.</returns>
		[ConfigurationProperty("bitmapSuffix")]
		public string BitmapSuffix
		{
			get
			{
				return (string)base[bitmapSuffix];
			}
			set
			{
				base[bitmapSuffix] = value;
			}
		}

		protected internal override ConfigurationPropertyCollection Properties
		{
			protected get
			{
				return properties;
			}
		}

		static SystemDrawingSection()
		{
			properties = new ConfigurationPropertyCollection();
			bitmapSuffix = new ConfigurationProperty("bitmapSuffix", typeof(string), null, ConfigurationPropertyOptions.None);
			properties.Add(bitmapSuffix);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Configuration.SystemDrawingSection" /> class.</summary>
		public SystemDrawingSection()
		{
		}
	}
}
namespace System.Drawing.Text
{
	/// <summary>Provides a base class for installed and private font collections.</summary>
	public abstract class FontCollection : IDisposable
	{
		internal IntPtr nativeFontCollection;

		/// <summary>Gets the array of <see cref="T:System.Drawing.FontFamily" /> objects associated with this <see cref="T:System.Drawing.Text.FontCollection" />.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.FontFamily" /> objects.</returns>
		public FontFamily[] Families
		{
			get
			{
				int numFound = 0;
				int num = SafeNativeMethods.Gdip.GdipGetFontCollectionFamilyCount(new HandleRef(this, nativeFontCollection), out numFound);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				IntPtr[] array = new IntPtr[numFound];
				int numFound2 = 0;
				num = SafeNativeMethods.Gdip.GdipGetFontCollectionFamilyList(new HandleRef(this, nativeFontCollection), numFound, array, out numFound2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				FontFamily[] array2 = new FontFamily[numFound2];
				for (int i = 0; i < numFound2; i++)
				{
					SafeNativeMethods.Gdip.GdipCloneFontFamily(new HandleRef(null, array[i]), out var clonefontfamily);
					array2[i] = new FontFamily(clonefontfamily);
				}
				return array2;
			}
		}

		internal FontCollection()
		{
			nativeFontCollection = IntPtr.Zero;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Text.FontCollection" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.Drawing.Text.FontCollection" /> and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///   <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected virtual void Dispose(bool disposing)
		{
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~FontCollection()
		{
			Dispose(disposing: false);
		}
	}
	/// <summary>Specifies a generic <see cref="T:System.Drawing.FontFamily" /> object.</summary>
	public enum GenericFontFamilies
	{
		/// <summary>A generic Serif <see cref="T:System.Drawing.FontFamily" /> object.</summary>
		Serif,
		/// <summary>A generic Sans Serif <see cref="T:System.Drawing.FontFamily" /> object.</summary>
		SansSerif,
		/// <summary>A generic Monospace <see cref="T:System.Drawing.FontFamily" /> object.</summary>
		Monospace
	}
	/// <summary>Specifies the type of display for hot-key prefixes that relate to text.</summary>
	public enum HotkeyPrefix
	{
		/// <summary>No hot-key prefix.</summary>
		None,
		/// <summary>Display the hot-key prefix.</summary>
		Show,
		/// <summary>Do not display the hot-key prefix.</summary>
		Hide
	}
	/// <summary>Represents the fonts installed on the system. This class cannot be inherited.</summary>
	public sealed class InstalledFontCollection : FontCollection
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Text.InstalledFontCollection" /> class.</summary>
		public InstalledFontCollection()
		{
			nativeFontCollection = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipNewInstalledFontCollection(out nativeFontCollection);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
	/// <summary>Provides a collection of font families built from font files that are provided by the client application.</summary>
	public sealed class PrivateFontCollection : FontCollection
	{
		private List<string> gdiFonts;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Text.PrivateFontCollection" /> class.</summary>
		public PrivateFontCollection()
		{
			nativeFontCollection = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipNewPrivateFontCollection(out nativeFontCollection);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (!LocalAppContextSwitches.DoNotRemoveGdiFontsResourcesFromFontCollection)
			{
				gdiFonts = new List<string>();
			}
		}

		protected override void Dispose(bool disposing)
		{
			if (nativeFontCollection != IntPtr.Zero)
			{
				try
				{
					SafeNativeMethods.Gdip.GdipDeletePrivateFontCollection(out nativeFontCollection);
					if (gdiFonts != null)
					{
						foreach (string gdiFont in gdiFonts)
						{
							SafeNativeMethods.RemoveFontFile(gdiFont);
						}
						gdiFonts.Clear();
						gdiFonts = null;
					}
				}
				catch (Exception ex)
				{
					if (ClientUtils.IsSecurityOrCriticalException(ex))
					{
						throw;
					}
				}
				finally
				{
					nativeFontCollection = IntPtr.Zero;
				}
			}
			base.Dispose(disposing);
		}

		/// <summary>Adds a font from the specified file to this <see cref="T:System.Drawing.Text.PrivateFontCollection" />.</summary>
		/// <param name="filename">A <see cref="T:System.String" /> that contains the file name of the font to add.</param>
		/// <exception cref="T:System.IO.FileNotFoundException">The specified font is not supported or the font file cannot be found.</exception>
		public void AddFontFile(string filename)
		{
			IntSecurity.DemandReadFileIO(filename);
			int num = SafeNativeMethods.Gdip.GdipPrivateAddFontFile(new HandleRef(this, nativeFontCollection), filename);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (SafeNativeMethods.AddFontFile(filename) != 0 && gdiFonts != null)
			{
				gdiFonts.Add(filename);
			}
		}

		/// <summary>Adds a font contained in system memory to this <see cref="T:System.Drawing.Text.PrivateFontCollection" />.</summary>
		/// <param name="memory">The memory address of the font to add.</param>
		/// <param name="length">The memory length of the font to add.</param>
		public void AddMemoryFont(IntPtr memory, int length)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			int num = SafeNativeMethods.Gdip.GdipPrivateAddMemoryFont(new HandleRef(this, nativeFontCollection), new HandleRef(null, memory), length);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
	/// <summary>Specifies the quality of text rendering.</summary>
	public enum TextRenderingHint
	{
		/// <summary>Each character is drawn using its glyph bitmap, with the system default rendering hint. The text will be drawn using whatever font-smoothing settings the user has selected for the system.</summary>
		SystemDefault,
		/// <summary>Each character is drawn using its glyph bitmap. Hinting is used to improve character appearance on stems and curvature.</summary>
		SingleBitPerPixelGridFit,
		/// <summary>Each character is drawn using its glyph bitmap. Hinting is not used.</summary>
		SingleBitPerPixel,
		/// <summary>Each character is drawn using its antialiased glyph bitmap with hinting. Much better quality due to antialiasing, but at a higher performance cost.</summary>
		AntiAliasGridFit,
		/// <summary>Each character is drawn using its antialiased glyph bitmap without hinting. Better quality due to antialiasing. Stem width differences may be noticeable because hinting is turned off.</summary>
		AntiAlias,
		/// <summary>Each character is drawn using its glyph ClearType bitmap with hinting. The highest quality setting. Used to take advantage of ClearType font features.</summary>
		ClearTypeGridFit
	}
}
namespace System.Drawing.Imaging
{
	[StructLayout(LayoutKind.Sequential)]
	internal sealed class PropertyItemInternal : IDisposable
	{
		public int id;

		public int len;

		public short type;

		public IntPtr value = IntPtr.Zero;

		public byte[] Value
		{
			get
			{
				if (len == 0)
				{
					return null;
				}
				byte[] array = new byte[len];
				Marshal.Copy(value, array, 0, len);
				return array;
			}
		}

		internal PropertyItemInternal()
		{
		}

		~PropertyItemInternal()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (value != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(value);
				value = IntPtr.Zero;
			}
			if (disposing)
			{
				GC.SuppressFinalize(this);
			}
		}

		internal static PropertyItemInternal ConvertFromPropertyItem(PropertyItem propItem)
		{
			PropertyItemInternal propertyItemInternal = new PropertyItemInternal();
			propertyItemInternal.id = propItem.Id;
			propertyItemInternal.len = 0;
			propertyItemInternal.type = propItem.Type;
			byte[] array = propItem.Value;
			if (array != null)
			{
				int num = (propertyItemInternal.len = array.Length);
				propertyItemInternal.value = Marshal.AllocHGlobal(num);
				Marshal.Copy(array, 0, propertyItemInternal.value, num);
			}
			return propertyItemInternal;
		}

		internal static PropertyItem[] ConvertFromMemory(IntPtr propdata, int count)
		{
			PropertyItem[] array = new PropertyItem[count];
			for (int i = 0; i < count; i++)
			{
				PropertyItemInternal propertyItemInternal = null;
				try
				{
					propertyItemInternal = (PropertyItemInternal)UnsafeNativeMethods.PtrToStructure(propdata, typeof(PropertyItemInternal));
					array[i] = new PropertyItem();
					array[i].Id = propertyItemInternal.id;
					array[i].Len = propertyItemInternal.len;
					array[i].Type = propertyItemInternal.type;
					array[i].Value = propertyItemInternal.Value;
					propertyItemInternal.value = IntPtr.Zero;
				}
				finally
				{
					propertyItemInternal?.Dispose();
				}
				propdata = (IntPtr)((long)propdata + Marshal.SizeOf(typeof(PropertyItemInternal)));
			}
			return array;
		}
	}
	/// <summary>Specifies the attributes of a bitmap image. The <see cref="T:System.Drawing.Imaging.BitmapData" /> class is used by the <see cref="Overload:System.Drawing.Bitmap.LockBits" /> and <see cref="M:System.Drawing.Bitmap.UnlockBits(System.Drawing.Imaging.BitmapData)" /> methods of the <see cref="T:System.Drawing.Bitmap" /> class. Not inheritable.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class BitmapData
	{
		private int width;

		private int height;

		private int stride;

		private int pixelFormat;

		private IntPtr scan0;

		private int reserved;

		/// <summary>Gets or sets the pixel width of the <see cref="T:System.Drawing.Bitmap" /> object. This can also be thought of as the number of pixels in one scan line.</summary>
		/// <returns>The pixel width of the <see cref="T:System.Drawing.Bitmap" /> object.</returns>
		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		/// <summary>Gets or sets the pixel height of the <see cref="T:System.Drawing.Bitmap" /> object. Also sometimes referred to as the number of scan lines.</summary>
		/// <returns>The pixel height of the <see cref="T:System.Drawing.Bitmap" /> object.</returns>
		public int Height
		{
			get
			{
				return height;
			}
			set
			{
				height = value;
			}
		}

		/// <summary>Gets or sets the stride width (also called scan width) of the <see cref="T:System.Drawing.Bitmap" /> object.</summary>
		/// <returns>The stride width, in bytes, of the <see cref="T:System.Drawing.Bitmap" /> object.</returns>
		public int Stride
		{
			get
			{
				return stride;
			}
			set
			{
				stride = value;
			}
		}

		/// <summary>Gets or sets the format of the pixel information in the <see cref="T:System.Drawing.Bitmap" /> object that returned this <see cref="T:System.Drawing.Imaging.BitmapData" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Imaging.PixelFormat" /> that specifies the format of the pixel information in the associated <see cref="T:System.Drawing.Bitmap" /> object.</returns>
		public PixelFormat PixelFormat
		{
			get
			{
				return (PixelFormat)pixelFormat;
			}
			set
			{
				switch (value)
				{
				default:
					throw new InvalidEnumArgumentException("value", (int)value, typeof(PixelFormat));
				case PixelFormat.Undefined:
				case PixelFormat.Max:
				case PixelFormat.Indexed:
				case PixelFormat.Gdi:
				case PixelFormat.Format16bppRgb555:
				case PixelFormat.Format16bppRgb565:
				case PixelFormat.Format24bppRgb:
				case PixelFormat.Format32bppRgb:
				case PixelFormat.Format1bppIndexed:
				case PixelFormat.Format4bppIndexed:
				case PixelFormat.Format8bppIndexed:
				case PixelFormat.Alpha:
				case PixelFormat.Format16bppArgb1555:
				case PixelFormat.PAlpha:
				case PixelFormat.Format32bppPArgb:
				case PixelFormat.Extended:
				case PixelFormat.Format16bppGrayScale:
				case PixelFormat.Format48bppRgb:
				case PixelFormat.Format64bppPArgb:
				case PixelFormat.Canonical:
				case PixelFormat.Format32bppArgb:
				case PixelFormat.Format64bppArgb:
					pixelFormat = (int)value;
					break;
				}
			}
		}

		/// <summary>Gets or sets the address of the first pixel data in the bitmap. This can also be thought of as the first scan line in the bitmap.</summary>
		/// <returns>The address of the first pixel data in the bitmap.</returns>
		public IntPtr Scan0
		{
			get
			{
				return scan0;
			}
			set
			{
				scan0 = value;
			}
		}

		/// <summary>Reserved. Do not use.</summary>
		/// <returns>Reserved. Do not use.</returns>
		public int Reserved
		{
			get
			{
				return reserved;
			}
			set
			{
				reserved = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.BitmapData" /> class.</summary>
		public BitmapData()
		{
		}
	}
	/// <summary>Specifies which GDI+ objects use color adjustment information.</summary>
	public enum ColorAdjustType
	{
		/// <summary>Color adjustment information that is used by all GDI+ objects that do not have their own color adjustment information.</summary>
		Default,
		/// <summary>Color adjustment information for <see cref="T:System.Drawing.Bitmap" /> objects.</summary>
		Bitmap,
		/// <summary>Color adjustment information for <see cref="T:System.Drawing.Brush" /> objects.</summary>
		Brush,
		/// <summary>Color adjustment information for <see cref="T:System.Drawing.Pen" /> objects.</summary>
		Pen,
		/// <summary>Color adjustment information for text.</summary>
		Text,
		/// <summary>The number of types specified.</summary>
		Count,
		/// <summary>The number of types specified.</summary>
		Any
	}
	/// <summary>Specifies individual channels in the CMYK (cyan, magenta, yellow, black) color space. This enumeration is used by the <see cref="Overload:System.Drawing.Imaging.ImageAttributes.SetOutputChannel" /> methods.</summary>
	public enum ColorChannelFlag
	{
		/// <summary>The cyan color channel.</summary>
		ColorChannelC,
		/// <summary>The magenta color channel.</summary>
		ColorChannelM,
		/// <summary>The yellow color channel.</summary>
		ColorChannelY,
		/// <summary>The black color channel.</summary>
		ColorChannelK,
		/// <summary>The last selected channel should be used.</summary>
		ColorChannelLast
	}
	/// <summary>Defines a map for converting colors. Several methods of the <see cref="T:System.Drawing.Imaging.ImageAttributes" /> class adjust image colors by using a color-remap table, which is an array of <see cref="T:System.Drawing.Imaging.ColorMap" /> structures. Not inheritable.</summary>
	public sealed class ColorMap
	{
		private Color oldColor;

		private Color newColor;

		/// <summary>Gets or sets the existing <see cref="T:System.Drawing.Color" /> structure to be converted.</summary>
		/// <returns>The existing <see cref="T:System.Drawing.Color" /> structure to be converted.</returns>
		public Color OldColor
		{
			get
			{
				return oldColor;
			}
			set
			{
				oldColor = value;
			}
		}

		/// <summary>Gets or sets the new <see cref="T:System.Drawing.Color" /> structure to which to convert.</summary>
		/// <returns>The new <see cref="T:System.Drawing.Color" /> structure to which to convert.</returns>
		public Color NewColor
		{
			get
			{
				return newColor;
			}
			set
			{
				newColor = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.ColorMap" /> class.</summary>
		public ColorMap()
		{
			oldColor = default(Color);
			newColor = default(Color);
		}
	}
	/// <summary>Specifies the types of color maps.</summary>
	public enum ColorMapType
	{
		/// <summary>A default color map.</summary>
		Default,
		/// <summary>Specifies a color map for a <see cref="T:System.Drawing.Brush" />.</summary>
		Brush
	}
	/// <summary>Defines a 5 x 5 matrix that contains the coordinates for the RGBAW space. Several methods of the <see cref="T:System.Drawing.Imaging.ImageAttributes" /> class adjust image colors by using a color matrix. This class cannot be inherited.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class ColorMatrix
	{
		private float matrix00;

		private float matrix01;

		private float matrix02;

		private float matrix03;

		private float matrix04;

		private float matrix10;

		private float matrix11;

		private float matrix12;

		private float matrix13;

		private float matrix14;

		private float matrix20;

		private float matrix21;

		private float matrix22;

		private float matrix23;

		private float matrix24;

		private float matrix30;

		private float matrix31;

		private float matrix32;

		private float matrix33;

		private float matrix34;

		private float matrix40;

		private float matrix41;

		private float matrix42;

		private float matrix43;

		private float matrix44;

		/// <summary>Gets or sets the element at the 0 (zero) row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the 0 row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix00
		{
			get
			{
				return matrix00;
			}
			set
			{
				matrix00 = value;
			}
		}

		/// <summary>Gets or sets the element at the 0 (zero) row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the 0 row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" /> .</returns>
		public float Matrix01
		{
			get
			{
				return matrix01;
			}
			set
			{
				matrix01 = value;
			}
		}

		/// <summary>Gets or sets the element at the 0 (zero) row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the 0 row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix02
		{
			get
			{
				return matrix02;
			}
			set
			{
				matrix02 = value;
			}
		}

		/// <summary>Gets or sets the element at the 0 (zero) row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />. Represents the alpha component.</summary>
		/// <returns>The element at the 0 row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix03
		{
			get
			{
				return matrix03;
			}
			set
			{
				matrix03 = value;
			}
		}

		/// <summary>Gets or sets the element at the 0 (zero) row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the 0 row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix04
		{
			get
			{
				return matrix04;
			}
			set
			{
				matrix04 = value;
			}
		}

		/// <summary>Gets or sets the element at the first row and 0 (zero) column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the first row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix10
		{
			get
			{
				return matrix10;
			}
			set
			{
				matrix10 = value;
			}
		}

		/// <summary>Gets or sets the element at the first row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the first row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix11
		{
			get
			{
				return matrix11;
			}
			set
			{
				matrix11 = value;
			}
		}

		/// <summary>Gets or sets the element at the first row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the first row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix12
		{
			get
			{
				return matrix12;
			}
			set
			{
				matrix12 = value;
			}
		}

		/// <summary>Gets or sets the element at the first row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />. Represents the alpha component.</summary>
		/// <returns>The element at the first row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix13
		{
			get
			{
				return matrix13;
			}
			set
			{
				matrix13 = value;
			}
		}

		/// <summary>Gets or sets the element at the first row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the first row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix14
		{
			get
			{
				return matrix14;
			}
			set
			{
				matrix14 = value;
			}
		}

		/// <summary>Gets or sets the element at the second row and 0 (zero) column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the second row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix20
		{
			get
			{
				return matrix20;
			}
			set
			{
				matrix20 = value;
			}
		}

		/// <summary>Gets or sets the element at the second row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the second row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix21
		{
			get
			{
				return matrix21;
			}
			set
			{
				matrix21 = value;
			}
		}

		/// <summary>Gets or sets the element at the second row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the second row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix22
		{
			get
			{
				return matrix22;
			}
			set
			{
				matrix22 = value;
			}
		}

		/// <summary>Gets or sets the element at the second row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the second row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix23
		{
			get
			{
				return matrix23;
			}
			set
			{
				matrix23 = value;
			}
		}

		/// <summary>Gets or sets the element at the second row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the second row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix24
		{
			get
			{
				return matrix24;
			}
			set
			{
				matrix24 = value;
			}
		}

		/// <summary>Gets or sets the element at the third row and 0 (zero) column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the third row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix30
		{
			get
			{
				return matrix30;
			}
			set
			{
				matrix30 = value;
			}
		}

		/// <summary>Gets or sets the element at the third row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the third row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix31
		{
			get
			{
				return matrix31;
			}
			set
			{
				matrix31 = value;
			}
		}

		/// <summary>Gets or sets the element at the third row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the third row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix32
		{
			get
			{
				return matrix32;
			}
			set
			{
				matrix32 = value;
			}
		}

		/// <summary>Gets or sets the element at the third row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />. Represents the alpha component.</summary>
		/// <returns>The element at the third row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix33
		{
			get
			{
				return matrix33;
			}
			set
			{
				matrix33 = value;
			}
		}

		/// <summary>Gets or sets the element at the third row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the third row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix34
		{
			get
			{
				return matrix34;
			}
			set
			{
				matrix34 = value;
			}
		}

		/// <summary>Gets or sets the element at the fourth row and 0 (zero) column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the fourth row and 0 column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix40
		{
			get
			{
				return matrix40;
			}
			set
			{
				matrix40 = value;
			}
		}

		/// <summary>Gets or sets the element at the fourth row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the fourth row and first column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix41
		{
			get
			{
				return matrix41;
			}
			set
			{
				matrix41 = value;
			}
		}

		/// <summary>Gets or sets the element at the fourth row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the fourth row and second column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix42
		{
			get
			{
				return matrix42;
			}
			set
			{
				matrix42 = value;
			}
		}

		/// <summary>Gets or sets the element at the fourth row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />. Represents the alpha component.</summary>
		/// <returns>The element at the fourth row and third column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix43
		{
			get
			{
				return matrix43;
			}
			set
			{
				matrix43 = value;
			}
		}

		/// <summary>Gets or sets the element at the fourth row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <returns>The element at the fourth row and fourth column of this <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</returns>
		public float Matrix44
		{
			get
			{
				return matrix44;
			}
			set
			{
				matrix44 = value;
			}
		}

		/// <summary>Gets or sets the element at the specified row and column in the <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</summary>
		/// <param name="row">The row of the element.</param>
		/// <param name="column">The column of the element.</param>
		/// <returns>The element at the specified row and column.</returns>
		public float this[int row, int column]
		{
			get
			{
				return GetMatrix()[row][column];
			}
			set
			{
				float[][] matrix = GetMatrix();
				matrix[row][column] = value;
				SetMatrix(matrix);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.ColorMatrix" /> class.</summary>
		public ColorMatrix()
		{
			matrix00 = 1f;
			matrix11 = 1f;
			matrix22 = 1f;
			matrix33 = 1f;
			matrix44 = 1f;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.ColorMatrix" /> class using the elements in the specified matrix <paramref name="newColorMatrix" />.</summary>
		/// <param name="newColorMatrix">The values of the elements for the new <see cref="T:System.Drawing.Imaging.ColorMatrix" />.</param>
		[CLSCompliant(false)]
		public ColorMatrix(float[][] newColorMatrix)
		{
			SetMatrix(newColorMatrix);
		}

		internal void SetMatrix(float[][] newColorMatrix)
		{
			matrix00 = newColorMatrix[0][0];
			matrix01 = newColorMatrix[0][1];
			matrix02 = newColorMatrix[0][2];
			matrix03 = newColorMatrix[0][3];
			matrix04 = newColorMatrix[0][4];
			matrix10 = newColorMatrix[1][0];
			matrix11 = newColorMatrix[1][1];
			matrix12 = newColorMatrix[1][2];
			matrix13 = newColorMatrix[1][3];
			matrix14 = newColorMatrix[1][4];
			matrix20 = newColorMatrix[2][0];
			matrix21 = newColorMatrix[2][1];
			matrix22 = newColorMatrix[2][2];
			matrix23 = newColorMatrix[2][3];
			matrix24 = newColorMatrix[2][4];
			matrix30 = newColorMatrix[3][0];
			matrix31 = newColorMatrix[3][1];
			matrix32 = newColorMatrix[3][2];
			matrix33 = newColorMatrix[3][3];
			matrix34 = newColorMatrix[3][4];
			matrix40 = newColorMatrix[4][0];
			matrix41 = newColorMatrix[4][1];
			matrix42 = newColorMatrix[4][2];
			matrix43 = newColorMatrix[4][3];
			matrix44 = newColorMatrix[4][4];
		}

		internal float[][] GetMatrix()
		{
			float[][] array = new float[5][];
			for (int i = 0; i < 5; i++)
			{
				array[i] = new float[5];
			}
			array[0][0] = matrix00;
			array[0][1] = matrix01;
			array[0][2] = matrix02;
			array[0][3] = matrix03;
			array[0][4] = matrix04;
			array[1][0] = matrix10;
			array[1][1] = matrix11;
			array[1][2] = matrix12;
			array[1][3] = matrix13;
			array[1][4] = matrix14;
			array[2][0] = matrix20;
			array[2][1] = matrix21;
			array[2][2] = matrix22;
			array[2][3] = matrix23;
			array[2][4] = matrix24;
			array[3][0] = matrix30;
			array[3][1] = matrix31;
			array[3][2] = matrix32;
			array[3][3] = matrix33;
			array[3][4] = matrix34;
			array[4][0] = matrix40;
			array[4][1] = matrix41;
			array[4][2] = matrix42;
			array[4][3] = matrix43;
			array[4][4] = matrix44;
			return array;
		}
	}
	/// <summary>Specifies the types of images and colors that will be affected by the color and grayscale adjustment settings of an <see cref="T:System.Drawing.Imaging.ImageAttributes" />.</summary>
	public enum ColorMatrixFlag
	{
		/// <summary>All color values, including gray shades, are adjusted by the same color-adjustment matrix.</summary>
		Default,
		/// <summary>All colors are adjusted, but gray shades are not adjusted. A gray shade is any color that has the same value for its red, green, and blue components.</summary>
		SkipGrays,
		/// <summary>Only gray shades are adjusted.</summary>
		AltGrays
	}
	/// <summary>Specifies two modes for color component values.</summary>
	public enum ColorMode
	{
		/// <summary>The integer values supplied are 32-bit values.</summary>
		Argb32Mode,
		/// <summary>The integer values supplied are 64-bit values.</summary>
		Argb64Mode
	}
	/// <summary>Defines an array of colors that make up a color palette. The colors are 32-bit ARGB colors. Not inheritable.</summary>
	public sealed class ColorPalette
	{
		private int flags;

		private Color[] entries;

		/// <summary>Gets a value that specifies how to interpret the color information in the array of colors.</summary>
		/// <returns>The following flag values are valid:  
		///  0x00000001 The color values in the array contain alpha information.  
		///  0x00000002 The colors in the array are grayscale values.  
		///  0x00000004 The colors in the array are halftone values.</returns>
		public int Flags => flags;

		/// <summary>Gets an array of <see cref="T:System.Drawing.Color" /> structures.</summary>
		/// <returns>The array of <see cref="T:System.Drawing.Color" /> structure that make up this <see cref="T:System.Drawing.Imaging.ColorPalette" />.</returns>
		public Color[] Entries => entries;

		internal ColorPalette(int count)
		{
			entries = new Color[count];
		}

		internal ColorPalette()
		{
			entries = new Color[1];
		}

		internal void ConvertFromMemory(IntPtr memory)
		{
			flags = Marshal.ReadInt32(memory);
			int num = Marshal.ReadInt32((IntPtr)((long)memory + 4));
			entries = new Color[num];
			for (int i = 0; i < num; i++)
			{
				int argb = Marshal.ReadInt32((IntPtr)((long)memory + 8 + i * 4));
				entries[i] = Color.FromArgb(argb);
			}
		}

		internal IntPtr ConvertToMemory()
		{
			int num = entries.Length;
			IntPtr intPtr;
			checked
			{
				intPtr = Marshal.AllocHGlobal(4 * (2 + num));
				Marshal.WriteInt32(intPtr, 0, flags);
				Marshal.WriteInt32((IntPtr)((long)intPtr + 4), 0, num);
			}
			for (int i = 0; i < num; i++)
			{
				Marshal.WriteInt32((IntPtr)((long)intPtr + 4 * (i + 2)), 0, entries[i].ToArgb());
			}
			return intPtr;
		}
	}
	internal enum EmfPlusFlags
	{
		Display = 1,
		NonDualGdi
	}
	/// <summary>Specifies the methods available for use with a metafile to read and write graphic commands.</summary>
	public enum EmfPlusRecordType
	{
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfRecordBase = 65536,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetBkColor = 66049,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetBkMode = 65794,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetMapMode = 65795,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetROP2 = 65796,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetRelAbs = 65797,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetPolyFillMode = 65798,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetStretchBltMode = 65799,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetTextCharExtra = 65800,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetTextColor = 66057,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetTextJustification = 66058,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetWindowOrg = 66059,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetWindowExt = 66060,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetViewportOrg = 66061,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetViewportExt = 66062,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfOffsetWindowOrg = 66063,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfScaleWindowExt = 66576,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfOffsetViewportOrg = 66065,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfScaleViewportExt = 66578,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfLineTo = 66067,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfMoveTo = 66068,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfExcludeClipRect = 66581,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfIntersectClipRect = 66582,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfArc = 67607,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfEllipse = 66584,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfFloodFill = 66585,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPie = 67610,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfRectangle = 66587,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfRoundRect = 67100,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPatBlt = 67101,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSaveDC = 65566,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetPixel = 66591,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfOffsetCilpRgn = 66080,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfTextOut = 66849,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfBitBlt = 67874,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfStretchBlt = 68387,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPolygon = 66340,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPolyline = 66341,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfEscape = 67110,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfRestoreDC = 65831,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfFillRegion = 66088,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfFrameRegion = 66601,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfInvertRegion = 65834,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPaintRegion = 65835,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSelectClipRegion = 65836,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSelectObject = 65837,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetTextAlign = 65838,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfChord = 67632,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetMapperFlags = 66097,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfExtTextOut = 68146,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetDibToDev = 68915,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSelectPalette = 66100,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfRealizePalette = 65589,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfAnimatePalette = 66614,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetPalEntries = 65591,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfPolyPolygon = 66872,
		/// <summary>Increases or decreases the size of a logical palette based on the specified value.</summary>
		WmfResizePalette = 65849,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfDibBitBlt = 67904,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfDibStretchBlt = 68417,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfDibCreatePatternBrush = 65858,
		/// <summary>Copies the color data for a rectangle of pixels in a DIB to the specified destination rectangle.</summary>
		WmfStretchDib = 69443,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfExtFloodFill = 66888,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfSetLayout = 65865,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfDeleteObject = 66032,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreatePalette = 65783,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreatePatternBrush = 66041,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreatePenIndirect = 66298,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreateFontIndirect = 66299,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreateBrushIndirect = 66300,
		/// <summary>See "Windows-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		WmfCreateRegion = 67327,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfHeader = 1,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyBezier = 2,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolygon = 3,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyline = 4,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyBezierTo = 5,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyLineTo = 6,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyPolyline = 7,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyPolygon = 8,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetWindowExtEx = 9,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetWindowOrgEx = 10,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetViewportExtEx = 11,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetViewportOrgEx = 12,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetBrushOrgEx = 13,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfEof = 14,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetPixelV = 15,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetMapperFlags = 16,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetMapMode = 17,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetBkMode = 18,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetPolyFillMode = 19,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetROP2 = 20,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetStretchBltMode = 21,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetTextAlign = 22,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetColorAdjustment = 23,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetTextColor = 24,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetBkColor = 25,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfOffsetClipRgn = 26,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfMoveToEx = 27,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetMetaRgn = 28,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExcludeClipRect = 29,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfIntersectClipRect = 30,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfScaleViewportExtEx = 31,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfScaleWindowExtEx = 32,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSaveDC = 33,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfRestoreDC = 34,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetWorldTransform = 35,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfModifyWorldTransform = 36,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSelectObject = 37,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreatePen = 38,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreateBrushIndirect = 39,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfDeleteObject = 40,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfAngleArc = 41,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfEllipse = 42,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfRectangle = 43,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfRoundRect = 44,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfRoundArc = 45,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfChord = 46,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPie = 47,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSelectPalette = 48,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreatePalette = 49,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetPaletteEntries = 50,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfResizePalette = 51,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfRealizePalette = 52,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtFloodFill = 53,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfLineTo = 54,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfArcTo = 55,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyDraw = 56,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetArcDirection = 57,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetMiterLimit = 58,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfBeginPath = 59,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfEndPath = 60,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCloseFigure = 61,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfFillPath = 62,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfStrokeAndFillPath = 63,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfStrokePath = 64,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfFlattenPath = 65,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfWidenPath = 66,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSelectClipPath = 67,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfAbortPath = 68,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfReserved069 = 69,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfGdiComment = 70,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfFillRgn = 71,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfFrameRgn = 72,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfInvertRgn = 73,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPaintRgn = 74,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtSelectClipRgn = 75,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfBitBlt = 76,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfStretchBlt = 77,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfMaskBlt = 78,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPlgBlt = 79,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetDIBitsToDevice = 80,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfStretchDIBits = 81,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtCreateFontIndirect = 82,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtTextOutA = 83,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtTextOutW = 84,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyBezier16 = 85,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolygon16 = 86,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyline16 = 87,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyBezierTo16 = 88,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolylineTo16 = 89,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyPolyline16 = 90,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyPolygon16 = 91,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyDraw16 = 92,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreateMonoBrush = 93,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreateDibPatternBrushPt = 94,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtCreatePen = 95,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyTextOutA = 96,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPolyTextOutW = 97,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetIcmMode = 98,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreateColorSpace = 99,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetColorSpace = 100,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfDeleteColorSpace = 101,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfGlsRecord = 102,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfGlsBoundedRecord = 103,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPixelFormat = 104,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfDrawEscape = 105,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfExtEscape = 106,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfStartDoc = 107,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSmallTextOut = 108,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfForceUfiMapping = 109,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfNamedEscpae = 110,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfColorCorrectPalette = 111,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetIcmProfileA = 112,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetIcmProfileW = 113,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfAlphaBlend = 114,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetLayout = 115,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfTransparentBlt = 116,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfReserved117 = 117,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfGradientFill = 118,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetLinkedUfis = 119,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfSetTextJustification = 120,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfColorMatchToTargetW = 121,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfCreateColorSpaceW = 122,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfMax = 122,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfMin = 1,
		/// <summary>See "Enhanced-Format Metafiles" in the GDI section of the MSDN Library.</summary>
		EmfPlusRecordBase = 16384,
		/// <summary>Indicates invalid data.</summary>
		Invalid = 16384,
		/// <summary>Identifies a record that is the EMF+ header.</summary>
		Header = 16385,
		/// <summary>Identifies a record that marks the last EMF+ record of a metafile.</summary>
		EndOfFile = 16386,
		/// <summary>See <see cref="M:System.Drawing.Graphics.AddMetafileComment(System.Byte[])" />.</summary>
		Comment = 16387,
		/// <summary>See <see cref="M:System.Drawing.Graphics.GetHdc" />.</summary>
		GetDC = 16388,
		/// <summary>Marks the start of a multiple-format section.</summary>
		MultiFormatStart = 16389,
		/// <summary>Marks a multiple-format section.</summary>
		MultiFormatSection = 16390,
		/// <summary>Marks the end of a multiple-format section.</summary>
		MultiFormatEnd = 16391,
		/// <summary>Marks an object.</summary>
		Object = 16392,
		/// <summary>See <see cref="M:System.Drawing.Graphics.Clear(System.Drawing.Color)" />.</summary>
		Clear = 16393,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.FillRectangles" /> methods.</summary>
		FillRects = 16394,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawRectangles" /> methods.</summary>
		DrawRects = 16395,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.FillPolygon" /> methods.</summary>
		FillPolygon = 16396,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawLines" /> methods.</summary>
		DrawLines = 16397,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.FillEllipse" /> methods.</summary>
		FillEllipse = 16398,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawEllipse" /> methods.</summary>
		DrawEllipse = 16399,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.FillPie" /> methods.</summary>
		FillPie = 16400,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawPie" /> methods.</summary>
		DrawPie = 16401,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawArc" /> methods.</summary>
		DrawArc = 16402,
		/// <summary>See <see cref="M:System.Drawing.Graphics.FillRegion(System.Drawing.Brush,System.Drawing.Region)" />.</summary>
		FillRegion = 16403,
		/// <summary>See <see cref="M:System.Drawing.Graphics.FillPath(System.Drawing.Brush,System.Drawing.Drawing2D.GraphicsPath)" />.</summary>
		FillPath = 16404,
		/// <summary>See <see cref="M:System.Drawing.Graphics.DrawPath(System.Drawing.Pen,System.Drawing.Drawing2D.GraphicsPath)" />.</summary>
		DrawPath = 16405,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.FillClosedCurve" /> methods.</summary>
		FillClosedCurve = 16406,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawClosedCurve" /> methods.</summary>
		DrawClosedCurve = 16407,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawCurve" /> methods.</summary>
		DrawCurve = 16408,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawBeziers" /> methods.</summary>
		DrawBeziers = 16409,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawImage" /> methods.</summary>
		DrawImage = 16410,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawImage" /> methods.</summary>
		DrawImagePoints = 16411,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.DrawString" /> methods.</summary>
		DrawString = 16412,
		/// <summary>See <see cref="P:System.Drawing.Graphics.RenderingOrigin" />.</summary>
		SetRenderingOrigin = 16413,
		/// <summary>See <see cref="P:System.Drawing.Graphics.SmoothingMode" />.</summary>
		SetAntiAliasMode = 16414,
		/// <summary>See <see cref="P:System.Drawing.Graphics.TextRenderingHint" />.</summary>
		SetTextRenderingHint = 16415,
		/// <summary>See <see cref="P:System.Drawing.Graphics.TextContrast" />.</summary>
		SetTextContrast = 16416,
		/// <summary>See <see cref="P:System.Drawing.Graphics.InterpolationMode" />.</summary>
		SetInterpolationMode = 16417,
		/// <summary>See <see cref="P:System.Drawing.Graphics.PixelOffsetMode" />.</summary>
		SetPixelOffsetMode = 16418,
		/// <summary>See <see cref="P:System.Drawing.Graphics.CompositingMode" />.</summary>
		SetCompositingMode = 16419,
		/// <summary>See <see cref="P:System.Drawing.Graphics.CompositingQuality" />.</summary>
		SetCompositingQuality = 16420,
		/// <summary>See <see cref="M:System.Drawing.Graphics.Save" />.</summary>
		Save = 16421,
		/// <summary>See <see cref="M:System.Drawing.Graphics.Restore(System.Drawing.Drawing2D.GraphicsState)" />.</summary>
		Restore = 16422,
		/// <summary>See <see cref="M:System.Drawing.Graphics.BeginContainer" /> methods.</summary>
		BeginContainer = 16423,
		/// <summary>See <see cref="M:System.Drawing.Graphics.BeginContainer" /> methods.</summary>
		BeginContainerNoParams = 16424,
		/// <summary>See <see cref="M:System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer)" />.</summary>
		EndContainer = 16425,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.TransformPoints" /> methods.</summary>
		SetWorldTransform = 16426,
		/// <summary>See <see cref="M:System.Drawing.Graphics.ResetTransform" />.</summary>
		ResetWorldTransform = 16427,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.MultiplyTransform" /> methods.</summary>
		MultiplyWorldTransform = 16428,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.TransformPoints" /> methods.</summary>
		TranslateWorldTransform = 16429,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.ScaleTransform" /> methods.</summary>
		ScaleWorldTransform = 16430,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.RotateTransform" /> methods.</summary>
		RotateWorldTransform = 16431,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.TransformPoints" /> methods.</summary>
		SetPageTransform = 16432,
		/// <summary>See <see cref="M:System.Drawing.Graphics.ResetClip" />.</summary>
		ResetClip = 16433,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.SetClip" /> methods.</summary>
		SetClipRect = 16434,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.SetClip" /> methods.</summary>
		SetClipPath = 16435,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.SetClip" /> methods.</summary>
		SetClipRegion = 16436,
		/// <summary>See <see cref="Overload:System.Drawing.Graphics.TranslateClip" /> methods.</summary>
		OffsetClip = 16437,
		/// <summary>Specifies a character string, a location, and formatting information.</summary>
		DrawDriverString = 16438,
		/// <summary>Used internally.</summary>
		Total = 16439,
		/// <summary>The maximum value for this enumeration.</summary>
		Max = 16438,
		/// <summary>The minimum value for this enumeration.</summary>
		Min = 16385
	}
	/// <summary>Specifies the nature of the records that are placed in an Enhanced Metafile (EMF) file. This enumeration is used by several constructors in the <see cref="T:System.Drawing.Imaging.Metafile" /> class.</summary>
	public enum EmfType
	{
		/// <summary>Specifies that all the records in the metafile are EMF records, which can be displayed by GDI or GDI+.</summary>
		EmfOnly = 3,
		/// <summary>Specifies that all the records in the metafile are EMF+ records, which can be displayed by GDI+ but not by GDI.</summary>
		EmfPlusOnly,
		/// <summary>Specifies that all EMF+ records in the metafile are associated with an alternate EMF record. Metafiles of type <see cref="F:System.Drawing.Imaging.EmfType.EmfPlusDual" /> can be displayed by GDI or by GDI+.</summary>
		EmfPlusDual
	}
	/// <summary>An <see cref="T:System.Drawing.Imaging.Encoder" /> object encapsulates a globally unique identifier (GUID) that identifies the category of an image encoder parameter.</summary>
	public sealed class Encoder
	{
		/// <summary>An <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the compression parameter category.</summary>
		public static readonly Encoder Compression = new Encoder(new Guid(-526552163, -13100, 17646, new byte[8] { 142, 186, 63, 191, 139, 228, 252, 88 }));

		/// <summary>An <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the color depth parameter category.</summary>
		public static readonly Encoder ColorDepth = new Encoder(new Guid(1711829077, -21146, 19580, new byte[8] { 154, 24, 56, 162, 49, 11, 131, 55 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the scan method parameter category.</summary>
		public static readonly Encoder ScanMethod = new Encoder(new Guid(978200161, 12553, 20054, new byte[8] { 133, 54, 66, 193, 86, 231, 220, 250 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the version parameter category.</summary>
		public static readonly Encoder Version = new Encoder(new Guid(617712758, -32438, 16804, new byte[8] { 191, 83, 28, 33, 156, 204, 247, 151 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the render method parameter category.</summary>
		public static readonly Encoder RenderMethod = new Encoder(new Guid(1833092410, 8858, 18469, new byte[8] { 139, 183, 92, 153, 226, 185, 168, 184 }));

		/// <summary>Gets an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the quality parameter category.</summary>
		public static readonly Encoder Quality = new Encoder(new Guid(492561589, -1462, 17709, new byte[8] { 156, 221, 93, 179, 81, 5, 231, 235 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the transformation parameter category.</summary>
		public static readonly Encoder Transformation = new Encoder(new Guid(-1928416559, -23154, 20136, new byte[8] { 170, 20, 16, 128, 116, 183, 182, 249 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the luminance table parameter category.</summary>
		public static readonly Encoder LuminanceTable = new Encoder(new Guid(-307020850, 614, 19063, new byte[8] { 185, 4, 39, 33, 96, 153, 231, 23 }));

		/// <summary>An <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the chrominance table parameter category.</summary>
		public static readonly Encoder ChrominanceTable = new Encoder(new Guid(-219916836, 2483, 17174, new byte[8] { 130, 96, 103, 106, 218, 50, 72, 28 }));

		/// <summary>Represents an <see cref="T:System.Drawing.Imaging.Encoder" /> object that is initialized with the globally unique identifier for the save flag parameter category.</summary>
		public static readonly Encoder SaveFlag = new Encoder(new Guid(690120444, -21440, 18367, new byte[8] { 140, 252, 168, 91, 137, 166, 85, 222 }));

		private Guid guid;

		/// <summary>Gets a globally unique identifier (GUID) that identifies an image encoder parameter category.</summary>
		/// <returns>The GUID that identifies an image encoder parameter category.</returns>
		public Guid Guid => guid;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Encoder" /> class from the specified globally unique identifier (GUID). The GUID specifies an image encoder parameter category.</summary>
		/// <param name="guid">A globally unique identifier that identifies an image encoder parameter category.</param>
		public Encoder(Guid guid)
		{
			this.guid = guid;
		}
	}
	/// <summary>Used to pass a value, or an array of values, to an image encoder.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class EncoderParameter : IDisposable
	{
		[MarshalAs(UnmanagedType.Struct)]
		private Guid parameterGuid;

		private int numberOfValues;

		private EncoderParameterValueType parameterValueType;

		private IntPtr parameterValue;

		/// <summary>Gets or sets the <see cref="T:System.Drawing.Imaging.Encoder" /> object associated with this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The <see cref="T:System.Drawing.Imaging.Encoder" /> object encapsulates the globally unique identifier (GUID) that specifies the category (for example <see cref="F:System.Drawing.Imaging.Encoder.Quality" />, <see cref="F:System.Drawing.Imaging.Encoder.ColorDepth" />, or <see cref="F:System.Drawing.Imaging.Encoder.Compression" />) of the parameter stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the GUID that specifies the category of the parameter stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</returns>
		public Encoder Encoder
		{
			get
			{
				return new Encoder(parameterGuid);
			}
			set
			{
				parameterGuid = value.Guid;
			}
		}

		/// <summary>Gets the data type of the values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <returns>A member of the <see cref="T:System.Drawing.Imaging.EncoderParameterValueType" /> enumeration that indicates the data type of the values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</returns>
		public EncoderParameterValueType Type => parameterValueType;

		/// <summary>Gets the data type of the values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <returns>A member of the <see cref="T:System.Drawing.Imaging.EncoderParameterValueType" /> enumeration that indicates the data type of the values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</returns>
		public EncoderParameterValueType ValueType => parameterValueType;

		/// <summary>Gets the number of elements in the array of values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <returns>An integer that indicates the number of elements in the array of values stored in this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</returns>
		public int NumberOfValues => numberOfValues;

		/// <summary>Allows an <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object to attempt to free resources and perform other cleanup operations before the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object is reclaimed by garbage collection.</summary>
		~EncoderParameter()
		{
			Dispose(disposing: false);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.KeepAlive(this);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (parameterValue != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(parameterValue);
			}
			parameterValue = IntPtr.Zero;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and one unsigned 8-bit integer. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">An 8-bit unsigned integer that specifies the value stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public EncoderParameter(Encoder encoder, byte value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = EncoderParameterValueType.ValueTypeByte;
			numberOfValues = 1;
			parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(byte)));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteByte(parameterValue, value);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and one 8-bit value. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeUndefined" /> or <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">A byte that specifies the value stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		/// <param name="undefined">If <see langword="true" />, the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property is set to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeUndefined" />; otherwise, the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property is set to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />.</param>
		public EncoderParameter(Encoder encoder, byte value, bool undefined)
		{
			parameterGuid = encoder.Guid;
			if (undefined)
			{
				parameterValueType = EncoderParameterValueType.ValueTypeUndefined;
			}
			else
			{
				parameterValueType = EncoderParameterValueType.ValueTypeByte;
			}
			numberOfValues = 1;
			parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(byte)));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteByte(parameterValue, value);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and one, 16-bit integer. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeShort" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">A 16-bit integer that specifies the value stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. Must be nonnegative.</param>
		public EncoderParameter(Encoder encoder, short value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = EncoderParameterValueType.ValueTypeShort;
			numberOfValues = 1;
			parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(short)));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt16(parameterValue, value);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and one 64-bit integer. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeLong" /> (32 bits), and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">A 64-bit integer that specifies the value stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. Must be nonnegative. This parameter is converted to a 32-bit integer before it is stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public EncoderParameter(Encoder encoder, long value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = EncoderParameterValueType.ValueTypeLong;
			numberOfValues = 1;
			parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(int)));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(parameterValue, (int)value);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and a pair of 32-bit integers. The pair of integers represents a fraction, the first integer being the numerator, and the second integer being the denominator. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeRational" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="numerator">A 32-bit integer that represents the numerator of a fraction. Must be nonnegative.</param>
		/// <param name="denominator">A 32-bit integer that represents the denominator of a fraction. Must be nonnegative.</param>
		public EncoderParameter(Encoder encoder, int numerator, int denominator)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = EncoderParameterValueType.ValueTypeRational;
			numberOfValues = 1;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(2 * num);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(parameterValue, numerator);
			Marshal.WriteInt32(Add(parameterValue, num), denominator);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and a pair of 64-bit integers. The pair of integers represents a range of integers, the first integer being the smallest number in the range, and the second integer being the largest number in the range. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeLongRange" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="rangebegin">A 64-bit integer that represents the smallest number in a range of integers. Must be nonnegative. This parameter is converted to a 32-bit integer before it is stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		/// <param name="rangeend">A 64-bit integer that represents the largest number in a range of integers. Must be nonnegative. This parameter is converted to a 32-bit integer before it is stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public EncoderParameter(Encoder encoder, long rangebegin, long rangeend)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = EncoderParameterValueType.ValueTypeLongRange;
			numberOfValues = 1;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(2 * num);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(parameterValue, (int)rangebegin);
			Marshal.WriteInt32(Add(parameterValue, num), (int)rangeend);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and four, 32-bit integers. The four integers represent a range of fractions. The first two integers represent the smallest fraction in the range, and the remaining two integers represent the largest fraction in the range. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeRationalRange" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to 1.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="numerator1">A 32-bit integer that represents the numerator of the smallest fraction in the range. Must be nonnegative.</param>
		/// <param name="demoninator1">A 32-bit integer that represents the denominator of the smallest fraction in the range. Must be nonnegative.</param>
		/// <param name="numerator2">A 32-bit integer that represents the denominator of the smallest fraction in the range. Must be nonnegative.</param>
		/// <param name="demoninator2">A 32-bit integer that represents the numerator of the largest fraction in the range. Must be nonnegative.</param>
		public EncoderParameter(Encoder encoder, int numerator1, int demoninator1, int numerator2, int demoninator2)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = EncoderParameterValueType.ValueTypeRationalRange;
			numberOfValues = 1;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(4 * num);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.WriteInt32(parameterValue, numerator1);
			Marshal.WriteInt32(Add(parameterValue, num), demoninator1);
			Marshal.WriteInt32(Add(parameterValue, 2 * num), numerator2);
			Marshal.WriteInt32(Add(parameterValue, 3 * num), demoninator2);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and a character string. The string is converted to a null-terminated ASCII string before it is stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeAscii" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the length of the ASCII string including the NULL terminator.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">A <see cref="T:System.String" /> that specifies the value stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public EncoderParameter(Encoder encoder, string value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = EncoderParameterValueType.ValueTypeAscii;
			numberOfValues = value.Length;
			parameterValue = Marshal.StringToHGlobalAnsi(value);
			GC.KeepAlive(this);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and an array of unsigned 8-bit integers. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">An array of 8-bit unsigned integers that specifies the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public EncoderParameter(Encoder encoder, byte[] value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = EncoderParameterValueType.ValueTypeByte;
			numberOfValues = value.Length;
			parameterValue = Marshal.AllocHGlobal(numberOfValues);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.Copy(value, 0, parameterValue, numberOfValues);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and an array of bytes. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeUndefined" /> or <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">An array of bytes that specifies the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		/// <param name="undefined">If <see langword="true" />, the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property is set to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeUndefined" />; otherwise, the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property is set to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeByte" />.</param>
		public EncoderParameter(Encoder encoder, byte[] value, bool undefined)
		{
			parameterGuid = encoder.Guid;
			if (undefined)
			{
				parameterValueType = EncoderParameterValueType.ValueTypeUndefined;
			}
			else
			{
				parameterValueType = EncoderParameterValueType.ValueTypeByte;
			}
			numberOfValues = value.Length;
			parameterValue = Marshal.AllocHGlobal(numberOfValues);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.Copy(value, 0, parameterValue, numberOfValues);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and an array of 16-bit integers. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeShort" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">An array of 16-bit integers that specifies the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The integers in the array must be nonnegative.</param>
		public EncoderParameter(Encoder encoder, short[] value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = EncoderParameterValueType.ValueTypeShort;
			numberOfValues = value.Length;
			int num = Marshal.SizeOf(typeof(short));
			parameterValue = Marshal.AllocHGlobal(checked(numberOfValues * num));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			Marshal.Copy(value, 0, parameterValue, numberOfValues);
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and an array of 64-bit integers. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeLong" /> (32-bit), and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="value">An array of 64-bit integers that specifies the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The integers in the array must be nonnegative. The 64-bit integers are converted to 32-bit integers before they are stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		public unsafe EncoderParameter(Encoder encoder, long[] value)
		{
			parameterGuid = encoder.Guid;
			parameterValueType = EncoderParameterValueType.ValueTypeLong;
			numberOfValues = value.Length;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(checked(numberOfValues * num));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			int* ptr = (int*)(void*)parameterValue;
			fixed (long* ptr2 = value)
			{
				for (int i = 0; i < value.Length; i++)
				{
					ptr[i] = (int)ptr2[i];
				}
			}
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and two arrays of 32-bit integers. The two arrays represent an array of fractions. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeRational" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the <paramref name="numerator" /> array, which must be the same as the number of elements in the <paramref name="denominator" /> array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="numerator">An array of 32-bit integers that specifies the numerators of the fractions. The integers in the array must be nonnegative.</param>
		/// <param name="denominator">An array of 32-bit integers that specifies the denominators of the fractions. The integers in the array must be nonnegative. A denominator of a given index is paired with the numerator of the same index.</param>
		public EncoderParameter(Encoder encoder, int[] numerator, int[] denominator)
		{
			parameterGuid = encoder.Guid;
			if (numerator.Length != denominator.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			parameterValueType = EncoderParameterValueType.ValueTypeRational;
			numberOfValues = numerator.Length;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(checked(numberOfValues * 2 * num));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < numberOfValues; i++)
			{
				Marshal.WriteInt32(Add(i * 2 * num, parameterValue), numerator[i]);
				Marshal.WriteInt32(Add((i * 2 + 1) * num, parameterValue), denominator[i]);
			}
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and two arrays of 64-bit integers. The two arrays represent an array integer ranges. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeLongRange" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the <paramref name="rangebegin" /> array, which must be the same as the number of elements in the <paramref name="rangeend" /> array.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="rangebegin">An array of 64-bit integers that specifies the minimum values for the integer ranges. The integers in the array must be nonnegative. The 64-bit integers are converted to 32-bit integers before they are stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</param>
		/// <param name="rangeend">An array of 64-bit integers that specifies the maximum values for the integer ranges. The integers in the array must be nonnegative. The 64-bit integers are converted to 32-bit integers before they are stored in the <see cref="T:System.Drawing.Imaging.EncoderParameters" /> object. A maximum value of a given index is paired with the minimum value of the same index.</param>
		public EncoderParameter(Encoder encoder, long[] rangebegin, long[] rangeend)
		{
			parameterGuid = encoder.Guid;
			if (rangebegin.Length != rangeend.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			parameterValueType = EncoderParameterValueType.ValueTypeLongRange;
			numberOfValues = rangebegin.Length;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(checked(numberOfValues * 2 * num));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < numberOfValues; i++)
			{
				Marshal.WriteInt32(Add(i * 2 * num, parameterValue), (int)rangebegin[i]);
				Marshal.WriteInt32(Add((i * 2 + 1) * num, parameterValue), (int)rangeend[i]);
			}
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and four arrays of 32-bit integers. The four arrays represent an array rational ranges. A rational range is the set of all fractions from a minimum fractional value through a maximum fractional value. Sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> property to <see cref="F:System.Drawing.Imaging.EncoderParameterValueType.ValueTypeRationalRange" />, and sets the <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property to the number of elements in the <paramref name="numerator1" /> array, which must be the same as the number of elements in the other three arrays.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="numerator1">An array of 32-bit integers that specifies the numerators of the minimum values for the ranges. The integers in the array must be nonnegative.</param>
		/// <param name="denominator1">An array of 32-bit integers that specifies the denominators of the minimum values for the ranges. The integers in the array must be nonnegative.</param>
		/// <param name="numerator2">An array of 32-bit integers that specifies the numerators of the maximum values for the ranges. The integers in the array must be nonnegative.</param>
		/// <param name="denominator2">An array of 32-bit integers that specifies the denominators of the maximum values for the ranges. The integers in the array must be nonnegative.</param>
		public EncoderParameter(Encoder encoder, int[] numerator1, int[] denominator1, int[] numerator2, int[] denominator2)
		{
			parameterGuid = encoder.Guid;
			if (numerator1.Length != denominator1.Length || numerator1.Length != denominator2.Length || denominator1.Length != denominator2.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			parameterValueType = EncoderParameterValueType.ValueTypeRationalRange;
			numberOfValues = numerator1.Length;
			int num = Marshal.SizeOf(typeof(int));
			parameterValue = Marshal.AllocHGlobal(checked(numberOfValues * 4 * num));
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < numberOfValues; i++)
			{
				Marshal.WriteInt32(Add(parameterValue, 4 * i * num), numerator1[i]);
				Marshal.WriteInt32(Add(parameterValue, (4 * i + 1) * num), denominator1[i]);
				Marshal.WriteInt32(Add(parameterValue, (4 * i + 2) * num), numerator2[i]);
				Marshal.WriteInt32(Add(parameterValue, (4 * i + 3) * num), denominator2[i]);
			}
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object and three integers that specify the number of values, the data type of the values, and a pointer to the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="NumberOfValues">An integer that specifies the number of values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property is set to this value.</param>
		/// <param name="Type">A member of the <see cref="T:System.Drawing.Imaging.EncoderParameterValueType" /> enumeration that specifies the data type of the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The <see cref="T:System.Type" /> and <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> properties are set to this value.</param>
		/// <param name="Value">A pointer to an array of values of the type specified by the <paramref name="Type" /> parameter.</param>
		/// <exception cref="T:System.InvalidOperationException">Type is not a valid <see cref="T:System.Drawing.Imaging.EncoderParameterValueType" />.</exception>
		[Obsolete("This constructor has been deprecated. Use EncoderParameter(Encoder encoder, int numberValues, EncoderParameterValueType type, IntPtr value) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
		public EncoderParameter(Encoder encoder, int NumberOfValues, int Type, int Value)
		{
			IntSecurity.UnmanagedCode.Demand();
			int num;
			switch (Type)
			{
			case 1:
			case 2:
				num = 1;
				break;
			case 3:
				num = 2;
				break;
			case 4:
				num = 4;
				break;
			case 5:
			case 6:
				num = 8;
				break;
			case 7:
				num = 1;
				break;
			case 8:
				num = 16;
				break;
			default:
				throw SafeNativeMethods.Gdip.StatusException(8);
			}
			int num2 = checked(num * NumberOfValues);
			parameterValue = Marshal.AllocHGlobal(num2);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < num2; i++)
			{
				Marshal.WriteByte(Add(parameterValue, i), Marshal.ReadByte((IntPtr)(Value + i)));
			}
			parameterValueType = (EncoderParameterValueType)Type;
			numberOfValues = NumberOfValues;
			parameterGuid = encoder.Guid;
			GC.KeepAlive(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> class with the specified <see cref="T:System.Drawing.Imaging.Encoder" /> object, number of values, data type of the values, and a pointer to the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		/// <param name="encoder">An <see cref="T:System.Drawing.Imaging.Encoder" /> object that encapsulates the globally unique identifier of the parameter category.</param>
		/// <param name="numberValues">An integer that specifies the number of values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The <see cref="P:System.Drawing.Imaging.EncoderParameter.NumberOfValues" /> property is set to this value.</param>
		/// <param name="type">A member of the <see cref="T:System.Drawing.Imaging.EncoderParameterValueType" /> enumeration that specifies the data type of the values stored in the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object. The <see cref="T:System.Type" /> and <see cref="P:System.Drawing.Imaging.EncoderParameter.ValueType" /> properties are set to this value.</param>
		/// <param name="value">A pointer to an array of values of the type specified by the <paramref name="Type" /> parameter.</param>
		public EncoderParameter(Encoder encoder, int numberValues, EncoderParameterValueType type, IntPtr value)
		{
			IntSecurity.UnmanagedCode.Demand();
			int num;
			switch (type)
			{
			case EncoderParameterValueType.ValueTypeByte:
			case EncoderParameterValueType.ValueTypeAscii:
				num = 1;
				break;
			case EncoderParameterValueType.ValueTypeShort:
				num = 2;
				break;
			case EncoderParameterValueType.ValueTypeLong:
				num = 4;
				break;
			case EncoderParameterValueType.ValueTypeRational:
			case EncoderParameterValueType.ValueTypeLongRange:
				num = 8;
				break;
			case EncoderParameterValueType.ValueTypeUndefined:
				num = 1;
				break;
			case EncoderParameterValueType.ValueTypeRationalRange:
				num = 16;
				break;
			default:
				throw SafeNativeMethods.Gdip.StatusException(8);
			}
			int num2 = checked(num * numberValues);
			parameterValue = Marshal.AllocHGlobal(num2);
			if (parameterValue == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(3);
			}
			for (int i = 0; i < num2; i++)
			{
				Marshal.WriteByte(Add(parameterValue, i), Marshal.ReadByte(value + i));
			}
			parameterValueType = type;
			numberOfValues = numberValues;
			parameterGuid = encoder.Guid;
			GC.KeepAlive(this);
		}

		private static IntPtr Add(IntPtr a, int b)
		{
			return (IntPtr)((long)a + b);
		}

		private static IntPtr Add(int a, IntPtr b)
		{
			return (IntPtr)(a + (long)b);
		}
	}
	/// <summary>Encapsulates an array of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects.</summary>
	public sealed class EncoderParameters : IDisposable
	{
		private EncoderParameter[] param;

		/// <summary>Gets or sets an array of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects.</summary>
		/// <returns>The array of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects.</returns>
		public EncoderParameter[] Param
		{
			get
			{
				return param;
			}
			set
			{
				param = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameters" /> class that can contain the specified number of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects.</summary>
		/// <param name="count">An integer that specifies the number of <see cref="T:System.Drawing.Imaging.EncoderParameter" /> objects that the <see cref="T:System.Drawing.Imaging.EncoderParameters" /> object can contain.</param>
		public EncoderParameters(int count)
		{
			param = new EncoderParameter[count];
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.EncoderParameters" /> class that can contain one <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object.</summary>
		public EncoderParameters()
		{
			param = new EncoderParameter[1];
		}

		internal IntPtr ConvertToMemory()
		{
			int num = Marshal.SizeOf(typeof(EncoderParameter));
			int num2 = param.Length;
			IntPtr intPtr;
			long num3;
			checked
			{
				intPtr = Marshal.AllocHGlobal(num2 * num + Marshal.SizeOf(typeof(IntPtr)));
				if (intPtr == IntPtr.Zero)
				{
					throw SafeNativeMethods.Gdip.StatusException(3);
				}
				Marshal.WriteIntPtr(intPtr, (IntPtr)num2);
				num3 = (long)intPtr + Marshal.SizeOf(typeof(IntPtr));
			}
			for (int i = 0; i < num2; i++)
			{
				Marshal.StructureToPtr((object)param[i], (IntPtr)(num3 + i * num), fDeleteOld: false);
			}
			return intPtr;
		}

		internal static EncoderParameters ConvertFromMemory(IntPtr memory)
		{
			if (memory == IntPtr.Zero)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int num = Marshal.ReadIntPtr(memory).ToInt32();
			EncoderParameters encoderParameters = new EncoderParameters(num);
			int num2 = Marshal.SizeOf(typeof(EncoderParameter));
			long num3 = (long)memory + Marshal.SizeOf(typeof(IntPtr));
			IntSecurity.UnmanagedCode.Assert();
			try
			{
				for (int i = 0; i < num; i++)
				{
					Guid guid = (Guid)UnsafeNativeMethods.PtrToStructure((IntPtr)(i * num2 + num3), typeof(Guid));
					int numberValues = Marshal.ReadInt32((IntPtr)(i * num2 + num3 + 16));
					EncoderParameterValueType type = (EncoderParameterValueType)Marshal.ReadInt32((IntPtr)(i * num2 + num3 + 20));
					IntPtr value = Marshal.ReadIntPtr((IntPtr)(i * num2 + num3 + 24));
					encoderParameters.param[i] = new EncoderParameter(new Encoder(guid), numberValues, type, value);
				}
				return encoderParameters;
			}
			finally
			{
				CodeAccessPermission.RevertAssert();
			}
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Imaging.EncoderParameters" /> object.</summary>
		public void Dispose()
		{
			EncoderParameter[] array = param;
			for (int i = 0; i < array.Length; i++)
			{
				array[i]?.Dispose();
			}
			param = null;
		}
	}
	/// <summary>Used to specify the data type of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> used with the <see cref="Overload:System.Drawing.Image.Save" /> or <see cref="Overload:System.Drawing.Image.SaveAdd" /> method of an image.</summary>
	public enum EncoderParameterValueType
	{
		/// <summary>Specifies that each value in the array is an 8-bit unsigned integer.</summary>
		ValueTypeByte = 1,
		/// <summary>Specifies that the array of values is a null-terminated ASCII character string. Note that the <see langword="NumberOfValues" /> data member of the <see cref="T:System.Drawing.Imaging.EncoderParameter" /> object indicates the length of the character string including the NULL terminator.</summary>
		ValueTypeAscii,
		/// <summary>Specifies that each value in the array is a 16-bit, unsigned integer.</summary>
		ValueTypeShort,
		/// <summary>Specifies that each value in the array is a 32-bit unsigned integer.</summary>
		ValueTypeLong,
		/// <summary>Specifies that each value in the array is a pair of 32-bit unsigned integers. Each pair represents a fraction, the first integer being the numerator and the second integer being the denominator.</summary>
		ValueTypeRational,
		/// <summary>Specifies that each value in the array is a pair of 32-bit unsigned integers. Each pair represents a range of numbers.</summary>
		ValueTypeLongRange,
		/// <summary>Specifies that the array of values is an array of bytes that has no data type defined.</summary>
		ValueTypeUndefined,
		/// <summary>Specifies that each value in the array is a set of four, 32-bit unsigned integers. The first two integers represent one fraction, and the second two integers represent a second fraction. The two fractions represent a range of rational numbers. The first fraction is the smallest rational number in the range, and the second fraction is the largest rational number in the range.</summary>
		ValueTypeRationalRange
	}
	/// <summary>Used to specify the parameter value passed to a JPEG or TIFF image encoder when using the <see cref="M:System.Drawing.Image.Save(System.String,System.Drawing.Imaging.ImageCodecInfo,System.Drawing.Imaging.EncoderParameters)" /> or <see cref="M:System.Drawing.Image.SaveAdd(System.Drawing.Imaging.EncoderParameters)" /> methods.</summary>
	public enum EncoderValue
	{
		/// <summary>Not used in GDI+ version 1.0.</summary>
		ColorTypeCMYK,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		ColorTypeYCCK,
		/// <summary>Specifies the LZW compression scheme. Can be passed to the TIFF encoder as a parameter that belongs to the Compression category.</summary>
		CompressionLZW,
		/// <summary>Specifies the CCITT3 compression scheme. Can be passed to the TIFF encoder as a parameter that belongs to the compression category.</summary>
		CompressionCCITT3,
		/// <summary>Specifies the CCITT4 compression scheme. Can be passed to the TIFF encoder as a parameter that belongs to the compression category.</summary>
		CompressionCCITT4,
		/// <summary>Specifies the RLE compression scheme. Can be passed to the TIFF encoder as a parameter that belongs to the compression category.</summary>
		CompressionRle,
		/// <summary>Specifies no compression. Can be passed to the TIFF encoder as a parameter that belongs to the compression category.</summary>
		CompressionNone,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		ScanMethodInterlaced,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		ScanMethodNonInterlaced,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		VersionGif87,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		VersionGif89,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		RenderProgressive,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		RenderNonProgressive,
		/// <summary>Specifies that the image is to be rotated clockwise 90 degrees about its center. Can be passed to the JPEG encoder as a parameter that belongs to the transformation category.</summary>
		TransformRotate90,
		/// <summary>Specifies that the image is to be rotated 180 degrees about its center. Can be passed to the JPEG encoder as a parameter that belongs to the transformation category.</summary>
		TransformRotate180,
		/// <summary>Specifies that the image is to be rotated clockwise 270 degrees about its center. Can be passed to the JPEG encoder as a parameter that belongs to the transformation category.</summary>
		TransformRotate270,
		/// <summary>Specifies that the image is to be flipped horizontally (about the vertical axis). Can be passed to the JPEG encoder as a parameter that belongs to the transformation category.</summary>
		TransformFlipHorizontal,
		/// <summary>Specifies that the image is to be flipped vertically (about the horizontal axis). Can be passed to the JPEG encoder as a parameter that belongs to the transformation category.</summary>
		TransformFlipVertical,
		/// <summary>Specifies that the image has more than one frame (page). Can be passed to the TIFF encoder as a parameter that belongs to the save flag category.</summary>
		MultiFrame,
		/// <summary>Specifies the last frame in a multiple-frame image. Can be passed to the TIFF encoder as a parameter that belongs to the save flag category.</summary>
		LastFrame,
		/// <summary>Specifies that a multiple-frame file or stream should be closed. Can be passed to the TIFF encoder as a parameter that belongs to the save flag category.</summary>
		Flush,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		FrameDimensionTime,
		/// <summary>Not used in GDI+ version 1.0.</summary>
		FrameDimensionResolution,
		/// <summary>Specifies that a frame is to be added to the page dimension of an image. Can be passed to the TIFF encoder as a parameter that belongs to the save flag category.</summary>
		FrameDimensionPage
	}
	/// <summary>Provides properties that get the frame dimensions of an image. Not inheritable.</summary>
	public sealed class FrameDimension
	{
		private static FrameDimension time = new FrameDimension(new Guid("{6aedbd6d-3fb5-418a-83a6-7f45229dc872}"));

		private static FrameDimension resolution = new FrameDimension(new Guid("{84236f7b-3bd3-428f-8dab-4ea1439ca315}"));

		private static FrameDimension page = new FrameDimension(new Guid("{7462dc86-6180-4c7e-8e3f-ee7333a7a483}"));

		private Guid guid;

		/// <summary>Gets a globally unique identifier (GUID) that represents this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</summary>
		/// <returns>A <see langword="Guid" /> structure that contains a GUID that represents this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</returns>
		public Guid Guid => guid;

		/// <summary>Gets the time dimension.</summary>
		/// <returns>The time dimension.</returns>
		public static FrameDimension Time => time;

		/// <summary>Gets the resolution dimension.</summary>
		/// <returns>The resolution dimension.</returns>
		public static FrameDimension Resolution => resolution;

		/// <summary>Gets the page dimension.</summary>
		/// <returns>The page dimension.</returns>
		public static FrameDimension Page => page;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.FrameDimension" /> class using the specified <see langword="Guid" /> structure.</summary>
		/// <param name="guid">A <see langword="Guid" /> structure that contains a GUID for this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</param>
		public FrameDimension(Guid guid)
		{
			this.guid = guid;
		}

		/// <summary>Returns a value that indicates whether the specified object is a <see cref="T:System.Drawing.Imaging.FrameDimension" /> equivalent to this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</summary>
		/// <param name="o">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="o" /> is a <see cref="T:System.Drawing.Imaging.FrameDimension" /> equivalent to this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object o)
		{
			if (!(o is FrameDimension frameDimension))
			{
				return false;
			}
			return guid == frameDimension.guid;
		}

		/// <summary>Returns a hash code for this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</summary>
		/// <returns>The hash code of this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</returns>
		public override int GetHashCode()
		{
			return guid.GetHashCode();
		}

		/// <summary>Converts this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object to a human-readable string.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.Imaging.FrameDimension" /> object.</returns>
		public override string ToString()
		{
			if (this == time)
			{
				return "Time";
			}
			if (this == resolution)
			{
				return "Resolution";
			}
			if (this == page)
			{
				return "Page";
			}
			Guid guid = this.guid;
			return "[FrameDimension: " + guid.ToString() + "]";
		}
	}
	/// <summary>Contains information about how bitmap and metafile colors are manipulated during rendering.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class ImageAttributes : ICloneable, IDisposable
	{
		internal IntPtr nativeImageAttributes;

		internal void SetNativeImageAttributes(IntPtr handle)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentNullException("handle");
			}
			nativeImageAttributes = handle;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.ImageAttributes" /> class.</summary>
		public ImageAttributes()
		{
			IntPtr imageattr = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateImageAttributes(out imageattr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImageAttributes(imageattr);
		}

		internal ImageAttributes(IntPtr newNativeImageAttributes)
		{
			SetNativeImageAttributes(newNativeImageAttributes);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeImageAttributes != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDisposeImageAttributes(new HandleRef(this, nativeImageAttributes));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeImageAttributes = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~ImageAttributes()
		{
			Dispose(disposing: false);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object this class creates, cast as an object.</returns>
		public object Clone()
		{
			IntPtr cloneImageattr = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneImageAttributes(new HandleRef(this, nativeImageAttributes), out cloneImageattr);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new ImageAttributes(cloneImageattr);
		}

		/// <summary>Sets the color-adjustment matrix for the default category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		public void SetColorMatrix(ColorMatrix newColorMatrix)
		{
			SetColorMatrix(newColorMatrix, ColorMatrixFlag.Default, ColorAdjustType.Default);
		}

		/// <summary>Sets the color-adjustment matrix for the default category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		/// <param name="flags">An element of <see cref="T:System.Drawing.Imaging.ColorMatrixFlag" /> that specifies the type of image and color that will be affected by the color-adjustment matrix.</param>
		public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag flags)
		{
			SetColorMatrix(newColorMatrix, flags, ColorAdjustType.Default);
		}

		/// <summary>Sets the color-adjustment matrix for a specified category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		/// <param name="mode">An element of <see cref="T:System.Drawing.Imaging.ColorMatrixFlag" /> that specifies the type of image and color that will be affected by the color-adjustment matrix.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color-adjustment matrix is set.</param>
		public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag mode, ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesColorMatrix(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, newColorMatrix, null, mode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the color-adjustment matrix for the default category.</summary>
		public void ClearColorMatrix()
		{
			ClearColorMatrix(ColorAdjustType.Default);
		}

		/// <summary>Clears the color-adjustment matrix for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color-adjustment matrix is cleared.</param>
		public void ClearColorMatrix(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesColorMatrix(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, null, null, ColorMatrixFlag.Default);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the color-adjustment matrix and the grayscale-adjustment matrix for the default category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		/// <param name="grayMatrix">The grayscale-adjustment matrix.</param>
		public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix)
		{
			SetColorMatrices(newColorMatrix, grayMatrix, ColorMatrixFlag.Default, ColorAdjustType.Default);
		}

		/// <summary>Sets the color-adjustment matrix and the grayscale-adjustment matrix for the default category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		/// <param name="grayMatrix">The grayscale-adjustment matrix.</param>
		/// <param name="flags">An element of <see cref="T:System.Drawing.Imaging.ColorMatrixFlag" /> that specifies the type of image and color that will be affected by the color-adjustment and grayscale-adjustment matrices.</param>
		public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags)
		{
			SetColorMatrices(newColorMatrix, grayMatrix, flags, ColorAdjustType.Default);
		}

		/// <summary>Sets the color-adjustment matrix and the grayscale-adjustment matrix for a specified category.</summary>
		/// <param name="newColorMatrix">The color-adjustment matrix.</param>
		/// <param name="grayMatrix">The grayscale-adjustment matrix.</param>
		/// <param name="mode">An element of <see cref="T:System.Drawing.Imaging.ColorMatrixFlag" /> that specifies the type of image and color that will be affected by the color-adjustment and grayscale-adjustment matrices.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color-adjustment and grayscale-adjustment matrices are set.</param>
		public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag mode, ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesColorMatrix(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, newColorMatrix, grayMatrix, mode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the threshold (transparency range) for the default category.</summary>
		/// <param name="threshold">A real number that specifies the threshold value.</param>
		public void SetThreshold(float threshold)
		{
			SetThreshold(threshold, ColorAdjustType.Default);
		}

		/// <summary>Sets the threshold (transparency range) for a specified category.</summary>
		/// <param name="threshold">A threshold value from 0.0 to 1.0 that is used as a breakpoint to sort colors that will be mapped to either a maximum or a minimum value.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color threshold is set.</param>
		public void SetThreshold(float threshold, ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesThreshold(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, threshold);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the threshold value for the default category.</summary>
		public void ClearThreshold()
		{
			ClearThreshold(ColorAdjustType.Default);
		}

		/// <summary>Clears the threshold value for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the threshold is cleared.</param>
		public void ClearThreshold(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesThreshold(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, 0f);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the gamma value for the default category.</summary>
		/// <param name="gamma">The gamma correction value.</param>
		public void SetGamma(float gamma)
		{
			SetGamma(gamma, ColorAdjustType.Default);
		}

		/// <summary>Sets the gamma value for a specified category.</summary>
		/// <param name="gamma">The gamma correction value.</param>
		/// <param name="type">An element of the <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> enumeration that specifies the category for which the gamma value is set.</param>
		public void SetGamma(float gamma, ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesGamma(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, gamma);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Disables gamma correction for the default category.</summary>
		public void ClearGamma()
		{
			ClearGamma(ColorAdjustType.Default);
		}

		/// <summary>Disables gamma correction for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which gamma correction is disabled.</param>
		public void ClearGamma(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesGamma(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, 0f);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Turns off color adjustment for the default category. You can call the <see cref="Overload:System.Drawing.Imaging.ImageAttributes.ClearNoOp" /> method to reinstate the color-adjustment settings that were in place before the call to the <see cref="Overload:System.Drawing.Imaging.ImageAttributes.SetNoOp" /> method.</summary>
		public void SetNoOp()
		{
			SetNoOp(ColorAdjustType.Default);
		}

		/// <summary>Turns off color adjustment for a specified category. You can call the <see cref="Overload:System.Drawing.Imaging.ImageAttributes.ClearNoOp" /> method to reinstate the color-adjustment settings that were in place before the call to the <see cref="Overload:System.Drawing.Imaging.ImageAttributes.SetNoOp" /> method.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which color correction is turned off.</param>
		public void SetNoOp(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesNoOp(new HandleRef(this, nativeImageAttributes), type, enableFlag: true);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the <see langword="NoOp" /> setting for the default category.</summary>
		public void ClearNoOp()
		{
			ClearNoOp(ColorAdjustType.Default);
		}

		/// <summary>Clears the <see langword="NoOp" /> setting for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the <see langword="NoOp" /> setting is cleared.</param>
		public void ClearNoOp(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesNoOp(new HandleRef(this, nativeImageAttributes), type, enableFlag: false);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the color key for the default category.</summary>
		/// <param name="colorLow">The low color-key value.</param>
		/// <param name="colorHigh">The high color-key value.</param>
		public void SetColorKey(Color colorLow, Color colorHigh)
		{
			SetColorKey(colorLow, colorHigh, ColorAdjustType.Default);
		}

		/// <summary>Sets the color key (transparency range) for a specified category.</summary>
		/// <param name="colorLow">The low color-key value.</param>
		/// <param name="colorHigh">The high color-key value.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color key is set.</param>
		public void SetColorKey(Color colorLow, Color colorHigh, ColorAdjustType type)
		{
			int colorLow2 = colorLow.ToArgb();
			int colorHigh2 = colorHigh.ToArgb();
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesColorKeys(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, colorLow2, colorHigh2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the color key (transparency range) for the default category.</summary>
		public void ClearColorKey()
		{
			ClearColorKey(ColorAdjustType.Default);
		}

		/// <summary>Clears the color key (transparency range) for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color key is cleared.</param>
		public void ClearColorKey(ColorAdjustType type)
		{
			int num = 0;
			int num2 = SafeNativeMethods.Gdip.GdipSetImageAttributesColorKeys(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, num, num);
			if (num2 != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num2);
			}
		}

		/// <summary>Sets the CMYK (cyan-magenta-yellow-black) output channel for the default category.</summary>
		/// <param name="flags">An element of <see cref="T:System.Drawing.Imaging.ColorChannelFlag" /> that specifies the output channel.</param>
		public void SetOutputChannel(ColorChannelFlag flags)
		{
			SetOutputChannel(flags, ColorAdjustType.Default);
		}

		/// <summary>Sets the CMYK (cyan-magenta-yellow-black) output channel for a specified category.</summary>
		/// <param name="flags">An element of <see cref="T:System.Drawing.Imaging.ColorChannelFlag" /> that specifies the output channel.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the output channel is set.</param>
		public void SetOutputChannel(ColorChannelFlag flags, ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesOutputChannel(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, flags);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the CMYK (cyan-magenta-yellow-black) output channel setting for the default category.</summary>
		public void ClearOutputChannel()
		{
			ClearOutputChannel(ColorAdjustType.Default);
		}

		/// <summary>Clears the (cyan-magenta-yellow-black) output channel setting for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the output channel setting is cleared.</param>
		public void ClearOutputChannel(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesOutputChannel(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, ColorChannelFlag.ColorChannelLast);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the output channel color-profile file for the default category.</summary>
		/// <param name="colorProfileFilename">The path name of a color-profile file. If the color-profile file is in the %SystemRoot%\System32\Spool\Drivers\Color directory, this parameter can be the file name. Otherwise, this parameter must be the fully qualified path name.</param>
		public void SetOutputChannelColorProfile(string colorProfileFilename)
		{
			SetOutputChannelColorProfile(colorProfileFilename, ColorAdjustType.Default);
		}

		/// <summary>Sets the output channel color-profile file for a specified category.</summary>
		/// <param name="colorProfileFilename">The path name of a color-profile file. If the color-profile file is in the %SystemRoot%\System32\Spool\Drivers\Color directory, this parameter can be the file name. Otherwise, this parameter must be the fully qualified path name.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the output channel color-profile file is set.</param>
		public void SetOutputChannelColorProfile(string colorProfileFilename, ColorAdjustType type)
		{
			IntSecurity.DemandReadFileIO(colorProfileFilename);
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesOutputChannelColorProfile(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, colorProfileFilename);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears the output channel color profile setting for the default category.</summary>
		public void ClearOutputChannelColorProfile()
		{
			ClearOutputChannel(ColorAdjustType.Default);
		}

		/// <summary>Clears the output channel color profile setting for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the output channel profile setting is cleared.</param>
		public void ClearOutputChannelColorProfile(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesOutputChannel(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, ColorChannelFlag.ColorChannelLast);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the color-remap table for the default category.</summary>
		/// <param name="map">An array of color pairs of type <see cref="T:System.Drawing.Imaging.ColorMap" />. Each color pair contains an existing color (the first value) and the color that it will be mapped to (the second value).</param>
		public void SetRemapTable(ColorMap[] map)
		{
			SetRemapTable(map, ColorAdjustType.Default);
		}

		/// <summary>Sets the color-remap table for a specified category.</summary>
		/// <param name="map">An array of color pairs of type <see cref="T:System.Drawing.Imaging.ColorMap" />. Each color pair contains an existing color (the first value) and the color that it will be mapped to (the second value).</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the color-remap table is set.</param>
		public void SetRemapTable(ColorMap[] map, ColorAdjustType type)
		{
			int num = 0;
			int num2 = map.Length;
			int num3 = 4;
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num3 * 2));
			try
			{
				for (num = 0; num < num2; num++)
				{
					Marshal.StructureToPtr((object)map[num].OldColor.ToArgb(), (IntPtr)((long)intPtr + num * num3 * 2), fDeleteOld: false);
					Marshal.StructureToPtr((object)map[num].NewColor.ToArgb(), (IntPtr)((long)intPtr + num * num3 * 2 + num3), fDeleteOld: false);
				}
				int num4 = SafeNativeMethods.Gdip.GdipSetImageAttributesRemapTable(new HandleRef(this, nativeImageAttributes), type, enableFlag: true, num2, new HandleRef(null, intPtr));
				if (num4 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num4);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Clears the color-remap table for the default category.</summary>
		public void ClearRemapTable()
		{
			ClearRemapTable(ColorAdjustType.Default);
		}

		/// <summary>Clears the color-remap table for a specified category.</summary>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category for which the remap table is cleared.</param>
		public void ClearRemapTable(ColorAdjustType type)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesRemapTable(new HandleRef(this, nativeImageAttributes), type, enableFlag: false, 0, NativeMethods.NullHandleRef);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets the color-remap table for the brush category.</summary>
		/// <param name="map">An array of <see cref="T:System.Drawing.Imaging.ColorMap" /> objects.</param>
		public void SetBrushRemapTable(ColorMap[] map)
		{
			SetRemapTable(map, ColorAdjustType.Brush);
		}

		/// <summary>Clears the brush color-remap table of this <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object.</summary>
		public void ClearBrushRemapTable()
		{
			ClearRemapTable(ColorAdjustType.Brush);
		}

		/// <summary>Sets the wrap mode that is used to decide how to tile a texture across a shape, or at shape boundaries. A texture is tiled across a shape to fill it in when the texture is smaller than the shape it is filling.</summary>
		/// <param name="mode">An element of <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how repeated copies of an image are used to tile an area.</param>
		public void SetWrapMode(WrapMode mode)
		{
			SetWrapMode(mode, default(Color), clamp: false);
		}

		/// <summary>Sets the wrap mode and color used to decide how to tile a texture across a shape, or at shape boundaries. A texture is tiled across a shape to fill it in when the texture is smaller than the shape it is filling.</summary>
		/// <param name="mode">An element of <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how repeated copies of an image are used to tile an area.</param>
		/// <param name="color">An <see cref="T:System.Drawing.Imaging.ImageAttributes" /> object that specifies the color of pixels outside of a rendered image. This color is visible if the mode parameter is set to <see cref="F:System.Drawing.Drawing2D.WrapMode.Clamp" /> and the source rectangle passed to <see cref="Overload:System.Drawing.Graphics.DrawImage" /> is larger than the image itself.</param>
		public void SetWrapMode(WrapMode mode, Color color)
		{
			SetWrapMode(mode, color, clamp: false);
		}

		/// <summary>Sets the wrap mode and color used to decide how to tile a texture across a shape, or at shape boundaries. A texture is tiled across a shape to fill it in when the texture is smaller than the shape it is filling.</summary>
		/// <param name="mode">An element of <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how repeated copies of an image are used to tile an area.</param>
		/// <param name="color">A color object that specifies the color of pixels outside of a rendered image. This color is visible if the mode parameter is set to <see cref="F:System.Drawing.Drawing2D.WrapMode.Clamp" /> and the source rectangle passed to <see cref="Overload:System.Drawing.Graphics.DrawImage" /> is larger than the image itself.</param>
		/// <param name="clamp">This parameter has no effect. Set it to <see langword="false" />.</param>
		public void SetWrapMode(WrapMode mode, Color color, bool clamp)
		{
			int num = SafeNativeMethods.Gdip.GdipSetImageAttributesWrapMode(new HandleRef(this, nativeImageAttributes), (int)mode, color.ToArgb(), clamp);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adjusts the colors in a palette according to the adjustment settings of a specified category.</summary>
		/// <param name="palette">A <see cref="T:System.Drawing.Imaging.ColorPalette" /> that on input contains the palette to be adjusted, and on output contains the adjusted palette.</param>
		/// <param name="type">An element of <see cref="T:System.Drawing.Imaging.ColorAdjustType" /> that specifies the category whose adjustment settings will be applied to the palette.</param>
		public void GetAdjustedPalette(ColorPalette palette, ColorAdjustType type)
		{
			IntPtr intPtr = palette.ConvertToMemory();
			try
			{
				int num = SafeNativeMethods.Gdip.GdipGetImageAttributesAdjustedPalette(new HandleRef(this, nativeImageAttributes), new HandleRef(null, intPtr), type);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				palette.ConvertFromMemory(intPtr);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}
	}
	/// <summary>Provides attributes of an image encoder/decoder (codec).</summary>
	[Flags]
	public enum ImageCodecFlags
	{
		/// <summary>The codec supports encoding (saving).</summary>
		Encoder = 1,
		/// <summary>The codec supports decoding (reading).</summary>
		Decoder = 2,
		/// <summary>The codec supports raster images (bitmaps).</summary>
		SupportBitmap = 4,
		/// <summary>The codec supports vector images (metafiles).</summary>
		SupportVector = 8,
		/// <summary>The encoder requires a seekable output stream.</summary>
		SeekableEncode = 0x10,
		/// <summary>The decoder has blocking behavior during the decoding process.</summary>
		BlockingDecode = 0x20,
		/// <summary>The codec is built into GDI+.</summary>
		Builtin = 0x10000,
		/// <summary>Not used.</summary>
		System = 0x20000,
		/// <summary>Not used.</summary>
		User = 0x40000
	}
	/// <summary>The <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> class provides the necessary storage members and methods to retrieve all pertinent information about the installed image encoders and decoders (called codecs). Not inheritable.</summary>
	public sealed class ImageCodecInfo
	{
		private Guid clsid;

		private Guid formatID;

		private string codecName;

		private string dllName;

		private string formatDescription;

		private string filenameExtension;

		private string mimeType;

		private ImageCodecFlags flags;

		private int version;

		private byte[][] signaturePatterns;

		private byte[][] signatureMasks;

		/// <summary>Gets or sets a <see cref="T:System.Guid" /> structure that contains a GUID that identifies a specific codec.</summary>
		/// <returns>A <see cref="T:System.Guid" /> structure that contains a GUID that identifies a specific codec.</returns>
		public Guid Clsid
		{
			get
			{
				return clsid;
			}
			set
			{
				clsid = value;
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Guid" /> structure that contains a GUID that identifies the codec's format.</summary>
		/// <returns>A <see cref="T:System.Guid" /> structure that contains a GUID that identifies the codec's format.</returns>
		public Guid FormatID
		{
			get
			{
				return formatID;
			}
			set
			{
				formatID = value;
			}
		}

		/// <summary>Gets or sets a string that contains the name of the codec.</summary>
		/// <returns>A string that contains the name of the codec.</returns>
		public string CodecName
		{
			get
			{
				return codecName;
			}
			set
			{
				codecName = value;
			}
		}

		/// <summary>Gets or sets string that contains the path name of the DLL that holds the codec. If the codec is not in a DLL, this pointer is <see langword="null" />.</summary>
		/// <returns>A string that contains the path name of the DLL that holds the codec.</returns>
		public string DllName
		{
			get
			{
				if (dllName != null)
				{
					new FileIOPermission(FileIOPermissionAccess.PathDiscovery, dllName).Demand();
				}
				return dllName;
			}
			set
			{
				if (value != null)
				{
					new FileIOPermission(FileIOPermissionAccess.PathDiscovery, value).Demand();
				}
				dllName = value;
			}
		}

		/// <summary>Gets or sets a string that describes the codec's file format.</summary>
		/// <returns>A string that describes the codec's file format.</returns>
		public string FormatDescription
		{
			get
			{
				return formatDescription;
			}
			set
			{
				formatDescription = value;
			}
		}

		/// <summary>Gets or sets string that contains the file name extension(s) used in the codec. The extensions are separated by semicolons.</summary>
		/// <returns>A string that contains the file name extension(s) used in the codec.</returns>
		public string FilenameExtension
		{
			get
			{
				return filenameExtension;
			}
			set
			{
				filenameExtension = value;
			}
		}

		/// <summary>Gets or sets a string that contains the codec's Multipurpose Internet Mail Extensions (MIME) type.</summary>
		/// <returns>A string that contains the codec's Multipurpose Internet Mail Extensions (MIME) type.</returns>
		public string MimeType
		{
			get
			{
				return mimeType;
			}
			set
			{
				mimeType = value;
			}
		}

		/// <summary>Gets or sets 32-bit value used to store additional information about the codec. This property returns a combination of flags from the <see cref="T:System.Drawing.Imaging.ImageCodecFlags" /> enumeration.</summary>
		/// <returns>A 32-bit value used to store additional information about the codec.</returns>
		public ImageCodecFlags Flags
		{
			get
			{
				return flags;
			}
			set
			{
				flags = value;
			}
		}

		/// <summary>Gets or sets the version number of the codec.</summary>
		/// <returns>The version number of the codec.</returns>
		public int Version
		{
			get
			{
				return version;
			}
			set
			{
				version = value;
			}
		}

		/// <summary>Gets or sets a two dimensional array of bytes that represents the signature of the codec.</summary>
		/// <returns>A two dimensional array of bytes that represents the signature of the codec.</returns>
		[CLSCompliant(false)]
		public byte[][] SignaturePatterns
		{
			get
			{
				return signaturePatterns;
			}
			set
			{
				signaturePatterns = value;
			}
		}

		/// <summary>Gets or sets a two dimensional array of bytes that can be used as a filter.</summary>
		/// <returns>A two dimensional array of bytes that can be used as a filter.</returns>
		[CLSCompliant(false)]
		public byte[][] SignatureMasks
		{
			get
			{
				return signatureMasks;
			}
			set
			{
				signatureMasks = value;
			}
		}

		internal ImageCodecInfo()
		{
		}

		/// <summary>Returns an array of <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> objects that contain information about the image decoders built into GDI+.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> objects. Each <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> object in the array contains information about one of the built-in image decoders.</returns>
		public static ImageCodecInfo[] GetImageDecoders()
		{
			int num = SafeNativeMethods.Gdip.GdipGetImageDecodersSize(out var numDecoders, out var size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			try
			{
				num = SafeNativeMethods.Gdip.GdipGetImageDecoders(numDecoders, size, intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return ConvertFromMemory(intPtr, numDecoders);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns an array of <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> objects that contain information about the image encoders built into GDI+.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> objects. Each <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> object in the array contains information about one of the built-in image encoders.</returns>
		public static ImageCodecInfo[] GetImageEncoders()
		{
			int num = SafeNativeMethods.Gdip.GdipGetImageEncodersSize(out var numEncoders, out var size);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			IntPtr intPtr = Marshal.AllocHGlobal(size);
			try
			{
				num = SafeNativeMethods.Gdip.GdipGetImageEncoders(numEncoders, size, intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return ConvertFromMemory(intPtr, numEncoders);
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		private static ImageCodecInfo[] ConvertFromMemory(IntPtr memoryStart, int numCodecs)
		{
			ImageCodecInfo[] array = new ImageCodecInfo[numCodecs];
			for (int i = 0; i < numCodecs; i++)
			{
				IntPtr lparam = (IntPtr)((long)memoryStart + Marshal.SizeOf(typeof(ImageCodecInfoPrivate)) * i);
				ImageCodecInfoPrivate imageCodecInfoPrivate = new ImageCodecInfoPrivate();
				UnsafeNativeMethods.PtrToStructure(lparam, imageCodecInfoPrivate);
				array[i] = new ImageCodecInfo();
				array[i].Clsid = imageCodecInfoPrivate.Clsid;
				array[i].FormatID = imageCodecInfoPrivate.FormatID;
				array[i].CodecName = Marshal.PtrToStringUni(imageCodecInfoPrivate.CodecName);
				array[i].DllName = Marshal.PtrToStringUni(imageCodecInfoPrivate.DllName);
				array[i].FormatDescription = Marshal.PtrToStringUni(imageCodecInfoPrivate.FormatDescription);
				array[i].FilenameExtension = Marshal.PtrToStringUni(imageCodecInfoPrivate.FilenameExtension);
				array[i].MimeType = Marshal.PtrToStringUni(imageCodecInfoPrivate.MimeType);
				array[i].Flags = (ImageCodecFlags)imageCodecInfoPrivate.Flags;
				array[i].Version = imageCodecInfoPrivate.Version;
				array[i].SignaturePatterns = new byte[imageCodecInfoPrivate.SigCount][];
				array[i].SignatureMasks = new byte[imageCodecInfoPrivate.SigCount][];
				for (int j = 0; j < imageCodecInfoPrivate.SigCount; j++)
				{
					array[i].SignaturePatterns[j] = new byte[imageCodecInfoPrivate.SigSize];
					array[i].SignatureMasks[j] = new byte[imageCodecInfoPrivate.SigSize];
					Marshal.Copy((IntPtr)((long)imageCodecInfoPrivate.SigMask + j * imageCodecInfoPrivate.SigSize), array[i].SignatureMasks[j], 0, imageCodecInfoPrivate.SigSize);
					Marshal.Copy((IntPtr)((long)imageCodecInfoPrivate.SigPattern + j * imageCodecInfoPrivate.SigSize), array[i].SignaturePatterns[j], 0, imageCodecInfoPrivate.SigSize);
				}
			}
			return array;
		}
	}
	[StructLayout(LayoutKind.Sequential, Pack = 8)]
	internal class ImageCodecInfoPrivate
	{
		[MarshalAs(UnmanagedType.Struct)]
		public Guid Clsid;

		[MarshalAs(UnmanagedType.Struct)]
		public Guid FormatID;

		public IntPtr CodecName = IntPtr.Zero;

		public IntPtr DllName = IntPtr.Zero;

		public IntPtr FormatDescription = IntPtr.Zero;

		public IntPtr FilenameExtension = IntPtr.Zero;

		public IntPtr MimeType = IntPtr.Zero;

		public int Flags;

		public int Version;

		public int SigCount;

		public int SigSize;

		public IntPtr SigPattern = IntPtr.Zero;

		public IntPtr SigMask = IntPtr.Zero;
	}
	/// <summary>Specifies the attributes of the pixel data contained in an <see cref="T:System.Drawing.Image" /> object. The <see cref="P:System.Drawing.Image.Flags" /> property returns a member of this enumeration.</summary>
	[Flags]
	public enum ImageFlags
	{
		/// <summary>There is no format information.</summary>
		None = 0,
		/// <summary>The pixel data is scalable.</summary>
		Scalable = 1,
		/// <summary>The pixel data contains alpha information.</summary>
		HasAlpha = 2,
		/// <summary>Specifies that the pixel data has alpha values other than 0 (transparent) and 255 (opaque).</summary>
		HasTranslucent = 4,
		/// <summary>The pixel data is partially scalable, but there are some limitations.</summary>
		PartiallyScalable = 8,
		/// <summary>The pixel data uses an RGB color space.</summary>
		ColorSpaceRgb = 0x10,
		/// <summary>The pixel data uses a CMYK color space.</summary>
		ColorSpaceCmyk = 0x20,
		/// <summary>The pixel data is grayscale.</summary>
		ColorSpaceGray = 0x40,
		/// <summary>Specifies that the image is stored using a YCBCR color space.</summary>
		ColorSpaceYcbcr = 0x80,
		/// <summary>Specifies that the image is stored using a YCCK color space.</summary>
		ColorSpaceYcck = 0x100,
		/// <summary>Specifies that dots per inch information is stored in the image.</summary>
		HasRealDpi = 0x1000,
		/// <summary>Specifies that the pixel size is stored in the image.</summary>
		HasRealPixelSize = 0x2000,
		/// <summary>The pixel data is read-only.</summary>
		ReadOnly = 0x10000,
		/// <summary>The pixel data can be cached for faster access.</summary>
		Caching = 0x20000
	}
	/// <summary>Specifies the file format of the image. Not inheritable.</summary>
	[TypeConverter(typeof(ImageFormatConverter))]
	public sealed class ImageFormat
	{
		private static ImageFormat memoryBMP = new ImageFormat(new Guid("{b96b3caa-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat bmp = new ImageFormat(new Guid("{b96b3cab-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat emf = new ImageFormat(new Guid("{b96b3cac-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat wmf = new ImageFormat(new Guid("{b96b3cad-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat jpeg = new ImageFormat(new Guid("{b96b3cae-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat png = new ImageFormat(new Guid("{b96b3caf-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat gif = new ImageFormat(new Guid("{b96b3cb0-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat tiff = new ImageFormat(new Guid("{b96b3cb1-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat exif = new ImageFormat(new Guid("{b96b3cb2-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat photoCD = new ImageFormat(new Guid("{b96b3cb3-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat flashPIX = new ImageFormat(new Guid("{b96b3cb4-0728-11d3-9d7b-0000f81ef32e}"));

		private static ImageFormat icon = new ImageFormat(new Guid("{b96b3cb5-0728-11d3-9d7b-0000f81ef32e}"));

		private Guid guid;

		/// <summary>Gets a <see cref="T:System.Guid" /> structure that represents this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</summary>
		/// <returns>A <see cref="T:System.Guid" /> structure that represents this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</returns>
		public Guid Guid => guid;

		/// <summary>Gets the format of a bitmap in memory.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the format of a bitmap in memory.</returns>
		public static ImageFormat MemoryBmp => memoryBMP;

		/// <summary>Gets the bitmap (BMP) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the bitmap image format.</returns>
		public static ImageFormat Bmp => bmp;

		/// <summary>Gets the enhanced metafile (EMF) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the enhanced metafile image format.</returns>
		public static ImageFormat Emf => emf;

		/// <summary>Gets the Windows metafile (WMF) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the Windows metafile image format.</returns>
		public static ImageFormat Wmf => wmf;

		/// <summary>Gets the Graphics Interchange Format (GIF) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the GIF image format.</returns>
		public static ImageFormat Gif => gif;

		/// <summary>Gets the Joint Photographic Experts Group (JPEG) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the JPEG image format.</returns>
		public static ImageFormat Jpeg => jpeg;

		/// <summary>Gets the W3C Portable Network Graphics (PNG) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the PNG image format.</returns>
		public static ImageFormat Png => png;

		/// <summary>Gets the Tagged Image File Format (TIFF) image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the TIFF image format.</returns>
		public static ImageFormat Tiff => tiff;

		/// <summary>Gets the Exchangeable Image File (Exif) format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the Exif format.</returns>
		public static ImageFormat Exif => exif;

		/// <summary>Gets the Windows icon image format.</summary>
		/// <returns>An <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that indicates the Windows icon image format.</returns>
		public static ImageFormat Icon => icon;

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.ImageFormat" /> class by using the specified <see cref="T:System.Guid" /> structure.</summary>
		/// <param name="guid">The <see cref="T:System.Guid" /> structure that specifies a particular image format.</param>
		public ImageFormat(Guid guid)
		{
			this.guid = guid;
		}

		/// <summary>Returns a value that indicates whether the specified object is an <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that is equivalent to this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</summary>
		/// <param name="o">The object to test.</param>
		/// <returns>
		///   <see langword="true" /> if <paramref name="o" /> is an <see cref="T:System.Drawing.Imaging.ImageFormat" /> object that is equivalent to this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object o)
		{
			if (!(o is ImageFormat imageFormat))
			{
				return false;
			}
			return guid == imageFormat.guid;
		}

		/// <summary>Returns a hash code value that represents this object.</summary>
		/// <returns>A hash code that represents this object.</returns>
		public override int GetHashCode()
		{
			return guid.GetHashCode();
		}

		internal ImageCodecInfo FindEncoder()
		{
			ImageCodecInfo[] imageEncoders = ImageCodecInfo.GetImageEncoders();
			ImageCodecInfo[] array = imageEncoders;
			foreach (ImageCodecInfo imageCodecInfo in array)
			{
				if (imageCodecInfo.FormatID.Equals(guid))
				{
					return imageCodecInfo;
				}
			}
			return null;
		}

		/// <summary>Converts this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object to a human-readable string.</summary>
		/// <returns>A string that represents this <see cref="T:System.Drawing.Imaging.ImageFormat" /> object.</returns>
		public override string ToString()
		{
			if (this == memoryBMP)
			{
				return "MemoryBMP";
			}
			if (this == bmp)
			{
				return "Bmp";
			}
			if (this == emf)
			{
				return "Emf";
			}
			if (this == wmf)
			{
				return "Wmf";
			}
			if (this == gif)
			{
				return "Gif";
			}
			if (this == jpeg)
			{
				return "Jpeg";
			}
			if (this == png)
			{
				return "Png";
			}
			if (this == tiff)
			{
				return "Tiff";
			}
			if (this == exif)
			{
				return "Exif";
			}
			if (this == icon)
			{
				return "Icon";
			}
			Guid guid = this.guid;
			return "[ImageFormat: " + guid.ToString() + "]";
		}
	}
	/// <summary>Specifies flags that are passed to the flags parameter of the <see cref="Overload:System.Drawing.Bitmap.LockBits" /> method. The <see cref="Overload:System.Drawing.Bitmap.LockBits" /> method locks a portion of an image so that you can read or write the pixel data.</summary>
	public enum ImageLockMode
	{
		/// <summary>Specifies that a portion of the image is locked for reading.</summary>
		ReadOnly = 1,
		/// <summary>Specifies that a portion of the image is locked for writing.</summary>
		WriteOnly,
		/// <summary>Specifies that a portion of the image is locked for reading or writing.</summary>
		ReadWrite,
		/// <summary>Specifies that the buffer used for reading or writing pixel data is allocated by the user. If this flag is set, the <paramref name="flags" /> parameter of the <see cref="Overload:System.Drawing.Bitmap.LockBits" /> method serves as an input parameter (and possibly as an output parameter). If this flag is cleared, then the <paramref name="flags" /> parameter serves only as an output parameter.</summary>
		UserInputBuffer
	}
	/// <summary>Defines a graphic metafile. A metafile contains records that describe a sequence of graphics operations that can be recorded (constructed) and played back (displayed). This class is not inheritable.</summary>
	[Serializable]
	[Editor("System.Drawing.Design.MetafileEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor))]
	public sealed class Metafile : Image
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified handle and a <see cref="T:System.Drawing.Imaging.WmfPlaceableFileHeader" />.</summary>
		/// <param name="hmetafile">A windows handle to a <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="wmfHeader">A <see cref="T:System.Drawing.Imaging.WmfPlaceableFileHeader" />.</param>
		public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader)
			: this(hmetafile, wmfHeader, deleteWmf: false)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified handle and a <see cref="T:System.Drawing.Imaging.WmfPlaceableFileHeader" />. Also, the <paramref name="deleteWmf" /> parameter can be used to delete the handle when the metafile is deleted.</summary>
		/// <param name="hmetafile">A windows handle to a <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="wmfHeader">A <see cref="T:System.Drawing.Imaging.WmfPlaceableFileHeader" />.</param>
		/// <param name="deleteWmf">
		///   <see langword="true" /> to delete the handle to the new <see cref="T:System.Drawing.Imaging.Metafile" /> when the <see cref="T:System.Drawing.Imaging.Metafile" /> is deleted; otherwise, <see langword="false" />.</param>
		public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader, bool deleteWmf)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMetafileFromWmf(new HandleRef(null, hmetafile), deleteWmf, wmfHeader, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified handle.</summary>
		/// <param name="henhmetafile">A handle to an enhanced metafile.</param>
		/// <param name="deleteEmf">
		///   <see langword="true" /> to delete the enhanced metafile handle when the <see cref="T:System.Drawing.Imaging.Metafile" /> is deleted; otherwise, <see langword="false" />.</param>
		public Metafile(IntPtr henhmetafile, bool deleteEmf)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMetafileFromEmf(new HandleRef(null, henhmetafile), deleteEmf, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified file name.</summary>
		/// <param name="filename">A <see cref="T:System.String" /> that represents the file name from which to create the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string filename)
		{
			IntSecurity.DemandReadFileIO(filename);
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMetafileFromFile(filename, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream.</summary>
		/// <param name="stream">The <see cref="T:System.IO.Stream" /> from which to create the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="stream" /> is <see langword="null" />.</exception>
		public Metafile(Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentException(SR.GetString("InvalidArgument", "stream", "null"));
			}
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMetafileFromStream(new GPStream(stream), out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified handle to a device context and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="emfType">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, EmfType emfType)
			: this(referenceHdc, emfType, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified handle to a device context and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A string can be supplied to name the file.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="emfType">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, EmfType emfType, string description)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipRecordMetafile(new HandleRef(null, referenceHdc), (int)emfType, NativeMethods.NullHandleRef, 7, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, RectangleF frameRect)
			: this(referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit)
			: this(referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A string can be provided to name the file.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			GPRECTF frameRect2 = new GPRECTF(frameRect);
			int num = SafeNativeMethods.Gdip.GdipRecordMetafile(new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, Rectangle frameRect)
			: this(referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit)
			: this(referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified device context, bounded by the specified rectangle that uses the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A string can be provided to name the file.</summary>
		/// <param name="referenceHdc">The handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="desc">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string desc)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num;
			if (frameRect.IsEmpty)
			{
				num = SafeNativeMethods.Gdip.GdipRecordMetafile(new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, 7, desc, out metafile);
			}
			else
			{
				GPRECT frameRect2 = new GPRECT(frameRect);
				num = SafeNativeMethods.Gdip.GdipRecordMetafileI(new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, desc, out metafile);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		public Metafile(string fileName, IntPtr referenceHdc)
			: this(fileName, referenceHdc, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, EmfType type)
			: this(fileName, referenceHdc, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A descriptive string can be added, as well.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, EmfType type, string description)
		{
			IntSecurity.DemandReadFileIO(fileName);
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipRecordMetafileFileName(fileName, new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, 7, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, and a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect)
			: this(fileName, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(fileName, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure. A descriptive string can also be added.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="desc">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, string desc)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, desc)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A descriptive string can also be added.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			IntSecurity.DemandReadFileIO(fileName);
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			GPRECTF frameRect2 = new GPRECTF(frameRect);
			int num = SafeNativeMethods.Gdip.GdipRecordMetafileFileName(fileName, new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, and a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect)
			: this(fileName, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(fileName, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure. A descriptive string can also be added.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, string description)
			: this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, description)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class with the specified file name, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A descriptive string can also be added.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> that represents the file name of the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			IntSecurity.DemandReadFileIO(fileName);
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num;
			if (frameRect.IsEmpty)
			{
				num = SafeNativeMethods.Gdip.GdipRecordMetafileFileName(fileName, new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, (int)frameUnit, description, out metafile);
			}
			else
			{
				GPRECT frameRect2 = new GPRECT(frameRect);
				num = SafeNativeMethods.Gdip.GdipRecordMetafileFileNameI(fileName, new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, description, out metafile);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		public Metafile(Stream stream, IntPtr referenceHdc)
			: this(stream, referenceHdc, EmfType.EmfPlusDual, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, EmfType type)
			: this(stream, referenceHdc, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. Also, a string that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" /> can be added.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, EmfType type, string description)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipRecordMetafileStream(new GPStream(stream), new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, 7, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, and a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect)
			: this(stream, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit)
			: this(stream, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(stream, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A string that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" /> can be added.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			GPRECTF frameRect2 = new GPRECTF(frameRect);
			int num = SafeNativeMethods.Gdip.GdipRecordMetafileStream(new GPStream(stream), new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, description, out metafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, and a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect)
			: this(stream, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, and the supplied unit of measure.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit)
			: this(stream, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type)
			: this(stream, referenceHdc, frameRect, frameUnit, type, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Imaging.Metafile" /> class from the specified data stream, a Windows handle to a device context, a <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />, the supplied unit of measure, and an <see cref="T:System.Drawing.Imaging.EmfType" /> enumeration that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />. A string that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" /> can be added.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> that contains the data for this <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="referenceHdc">A Windows handle to a device context.</param>
		/// <param name="frameRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="frameUnit">A <see cref="T:System.Drawing.Imaging.MetafileFrameUnit" /> that specifies the unit of measure for <paramref name="frameRect" />.</param>
		/// <param name="type">An <see cref="T:System.Drawing.Imaging.EmfType" /> that specifies the format of the <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		/// <param name="description">A <see cref="T:System.String" /> that contains a descriptive name for the new <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
		public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			IntPtr metafile = IntPtr.Zero;
			int num;
			if (frameRect.IsEmpty)
			{
				num = SafeNativeMethods.Gdip.GdipRecordMetafileStream(new GPStream(stream), new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, (int)frameUnit, description, out metafile);
			}
			else
			{
				GPRECT frameRect2 = new GPRECT(frameRect);
				num = SafeNativeMethods.Gdip.GdipRecordMetafileStreamI(new GPStream(stream), new HandleRef(null, referenceHdc), (int)type, ref frameRect2, (int)frameUnit, description, out metafile);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeImage(metafile);
		}

		private Metafile(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		/// <summary>Returns the <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="hmetafile">The handle to the <see cref="T:System.Drawing.Imaging.Metafile" /> for which to return a header.</param>
		/// <param name="wmfHeader">A <see cref="T:System.Drawing.Imaging.WmfPlaceableFileHeader" />.</param>
		/// <returns>The <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public static MetafileHeader GetMetafileHeader(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			MetafileHeader metafileHeader = new MetafileHeader();
			metafileHeader.wmf = new MetafileHeaderWmf();
			int num = SafeNativeMethods.Gdip.GdipGetMetafileHeaderFromWmf(new HandleRef(null, hmetafile), wmfHeader, metafileHeader.wmf);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return metafileHeader;
		}

		/// <summary>Returns the <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="henhmetafile">The handle to the enhanced <see cref="T:System.Drawing.Imaging.Metafile" /> for which a header is returned.</param>
		/// <returns>The <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public static MetafileHeader GetMetafileHeader(IntPtr henhmetafile)
		{
			IntSecurity.ObjectFromWin32Handle.Demand();
			MetafileHeader metafileHeader = new MetafileHeader();
			metafileHeader.emf = new MetafileHeaderEmf();
			int num = SafeNativeMethods.Gdip.GdipGetMetafileHeaderFromEmf(new HandleRef(null, henhmetafile), metafileHeader.emf);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return metafileHeader;
		}

		/// <summary>Returns the <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> containing the name of the <see cref="T:System.Drawing.Imaging.Metafile" /> for which a header is retrieved.</param>
		/// <returns>The <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public static MetafileHeader GetMetafileHeader(string fileName)
		{
			IntSecurity.DemandReadFileIO(fileName);
			MetafileHeader metafileHeader = new MetafileHeader();
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeaderEmf)));
			try
			{
				int num = SafeNativeMethods.Gdip.GdipGetMetafileHeaderFromFile(fileName, intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				int[] array = new int[1];
				Marshal.Copy(intPtr, array, 0, 1);
				MetafileType metafileType = (MetafileType)array[0];
				if (metafileType == MetafileType.Wmf || metafileType == MetafileType.WmfPlaceable)
				{
					metafileHeader.wmf = (MetafileHeaderWmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderWmf));
					metafileHeader.emf = null;
					return metafileHeader;
				}
				metafileHeader.wmf = null;
				metafileHeader.emf = (MetafileHeaderEmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderEmf));
				return metafileHeader;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns the <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <param name="stream">A <see cref="T:System.IO.Stream" /> containing the <see cref="T:System.Drawing.Imaging.Metafile" /> for which a header is retrieved.</param>
		/// <returns>The <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with the specified <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public static MetafileHeader GetMetafileHeader(Stream stream)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeaderEmf)));
			try
			{
				int num = SafeNativeMethods.Gdip.GdipGetMetafileHeaderFromStream(new GPStream(stream), intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				int[] array = new int[1];
				Marshal.Copy(intPtr, array, 0, 1);
				MetafileType metafileType = (MetafileType)array[0];
				MetafileHeader metafileHeader = new MetafileHeader();
				if (metafileType == MetafileType.Wmf || metafileType == MetafileType.WmfPlaceable)
				{
					metafileHeader.wmf = (MetafileHeaderWmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderWmf));
					metafileHeader.emf = null;
					return metafileHeader;
				}
				metafileHeader.wmf = null;
				metafileHeader.emf = (MetafileHeaderEmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderEmf));
				return metafileHeader;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns the <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with this <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Imaging.MetafileHeader" /> associated with this <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public MetafileHeader GetMetafileHeader()
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeaderEmf)));
			try
			{
				int num = SafeNativeMethods.Gdip.GdipGetMetafileHeaderFromMetafile(new HandleRef(this, nativeImage), intPtr);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				int[] array = new int[1];
				Marshal.Copy(intPtr, array, 0, 1);
				MetafileType metafileType = (MetafileType)array[0];
				MetafileHeader metafileHeader = new MetafileHeader();
				if (metafileType == MetafileType.Wmf || metafileType == MetafileType.WmfPlaceable)
				{
					metafileHeader.wmf = (MetafileHeaderWmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderWmf));
					metafileHeader.emf = null;
					return metafileHeader;
				}
				metafileHeader.wmf = null;
				metafileHeader.emf = (MetafileHeaderEmf)UnsafeNativeMethods.PtrToStructure(intPtr, typeof(MetafileHeaderEmf));
				return metafileHeader;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Returns a Windows handle to an enhanced <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>A Windows handle to this enhanced <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public IntPtr GetHenhmetafile()
		{
			IntPtr hEnhMetafile = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipGetHemfFromMetafile(new HandleRef(this, nativeImage), out hEnhMetafile);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return hEnhMetafile;
		}

		/// <summary>Plays an individual metafile record.</summary>
		/// <param name="recordType">Element of the <see cref="T:System.Drawing.Imaging.EmfPlusRecordType" /> that specifies the type of metafile record being played.</param>
		/// <param name="flags">A set of flags that specify attributes of the record.</param>
		/// <param name="dataSize">The number of bytes in the record data.</param>
		/// <param name="data">An array of bytes that contains the record data.</param>
		public void PlayRecord(EmfPlusRecordType recordType, int flags, int dataSize, byte[] data)
		{
			int num = SafeNativeMethods.Gdip.GdipPlayMetafileRecord(new HandleRef(this, nativeImage), recordType, flags, dataSize, data);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		internal static Metafile FromGDIplus(IntPtr nativeImage)
		{
			Metafile metafile = new Metafile();
			metafile.SetNativeImage(nativeImage);
			return metafile;
		}

		private Metafile()
		{
		}
	}
	/// <summary>Specifies the unit of measurement for the rectangle used to size and position a metafile. This is specified during the creation of the <see cref="T:System.Drawing.Imaging.Metafile" /> object.</summary>
	public enum MetafileFrameUnit
	{
		/// <summary>The unit of measurement is 1 pixel.</summary>
		Pixel = 2,
		/// <summary>The unit of measurement is 1 printer's point.</summary>
		Point,
		/// <summary>The unit of measurement is 1 inch.</summary>
		Inch,
		/// <summary>The unit of measurement is 1/300 of an inch.</summary>
		Document,
		/// <summary>The unit of measurement is 1 millimeter.</summary>
		Millimeter,
		/// <summary>The unit of measurement is 0.01 millimeter. Provided for compatibility with GDI.</summary>
		GdiCompatible
	}
	/// <summary>Contains attributes of an associated <see cref="T:System.Drawing.Imaging.Metafile" />. Not inheritable.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class MetafileHeader
	{
		internal MetafileHeaderWmf wmf;

		internal MetafileHeaderEmf emf;

		/// <summary>Gets the type of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Imaging.MetafileType" /> enumeration that represents the type of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public MetafileType Type
		{
			get
			{
				if (!IsWmf())
				{
					return emf.type;
				}
				return wmf.type;
			}
		}

		/// <summary>Gets the size, in bytes, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The size, in bytes, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public int MetafileSize
		{
			get
			{
				if (!IsWmf())
				{
					return emf.size;
				}
				return wmf.size;
			}
		}

		/// <summary>Gets the version number of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The version number of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public int Version
		{
			get
			{
				if (!IsWmf())
				{
					return emf.version;
				}
				return wmf.version;
			}
		}

		/// <summary>Gets the horizontal resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The horizontal resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public float DpiX
		{
			get
			{
				if (!IsWmf())
				{
					return emf.dpiX;
				}
				return wmf.dpiX;
			}
		}

		/// <summary>Gets the vertical resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The vertical resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public float DpiY
		{
			get
			{
				if (!IsWmf())
				{
					return emf.dpiY;
				}
				return wmf.dpiY;
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Rectangle" /> that bounds the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Rectangle" /> that bounds the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public Rectangle Bounds
		{
			get
			{
				if (!IsWmf())
				{
					return new Rectangle(emf.X, emf.Y, emf.Width, emf.Height);
				}
				return new Rectangle(wmf.X, wmf.Y, wmf.Width, wmf.Height);
			}
		}

		/// <summary>Gets the Windows metafile (WMF) header file for the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Imaging.MetaHeader" /> that contains the WMF header file for the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public MetaHeader WmfHeader
		{
			get
			{
				if (wmf == null)
				{
					throw SafeNativeMethods.Gdip.StatusException(2);
				}
				return wmf.WmfHeader;
			}
		}

		/// <summary>Gets the size, in bytes, of the enhanced metafile plus header file.</summary>
		/// <returns>The size, in bytes, of the enhanced metafile plus header file.</returns>
		public int EmfPlusHeaderSize
		{
			get
			{
				if (wmf == null && emf == null)
				{
					throw SafeNativeMethods.Gdip.StatusException(2);
				}
				if (!IsWmf())
				{
					return emf.EmfPlusHeaderSize;
				}
				return wmf.EmfPlusHeaderSize;
			}
		}

		/// <summary>Gets the logical horizontal resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The logical horizontal resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public int LogicalDpiX
		{
			get
			{
				if (wmf == null && emf == null)
				{
					throw SafeNativeMethods.Gdip.StatusException(2);
				}
				if (!IsWmf())
				{
					return emf.LogicalDpiX;
				}
				return wmf.LogicalDpiX;
			}
		}

		/// <summary>Gets the logical vertical resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</summary>
		/// <returns>The logical vertical resolution, in dots per inch, of the associated <see cref="T:System.Drawing.Imaging.Metafile" />.</returns>
		public int LogicalDpiY
		{
			get
			{
				if (wmf == null && emf == null)
				{
					throw SafeNativeMethods.Gdip.StatusException(2);
				}
				if (!IsWmf())
				{
					return emf.LogicalDpiX;
				}
				return wmf.LogicalDpiY;
			}
		}

		internal MetafileHeader()
		{
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows metafile format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows metafile format; otherwise, <see langword="false" />.</returns>
		public bool IsWmf()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (wmf != null && (wmf.type == MetafileType.Wmf || wmf.type == MetafileType.WmfPlaceable))
			{
				return true;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows placeable metafile format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows placeable metafile format; otherwise, <see langword="false" />.</returns>
		public bool IsWmfPlaceable()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (wmf != null)
			{
				return wmf.type == MetafileType.WmfPlaceable;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile format; otherwise, <see langword="false" />.</returns>
		public bool IsEmf()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (emf != null)
			{
				return emf.type == MetafileType.Emf;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile format or the Windows enhanced metafile plus format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile format or the Windows enhanced metafile plus format; otherwise, <see langword="false" />.</returns>
		public bool IsEmfOrEmfPlus()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (emf != null)
			{
				return emf.type >= MetafileType.Emf;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile plus format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Windows enhanced metafile plus format; otherwise, <see langword="false" />.</returns>
		public bool IsEmfPlus()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (emf != null)
			{
				return emf.type >= MetafileType.EmfPlusOnly;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Dual enhanced metafile format. This format supports both the enhanced and the enhanced plus format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is in the Dual enhanced metafile format; otherwise, <see langword="false" />.</returns>
		public bool IsEmfPlusDual()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (emf != null)
			{
				return emf.type == MetafileType.EmfPlusDual;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> supports only the Windows enhanced metafile plus format.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> supports only the Windows enhanced metafile plus format; otherwise, <see langword="false" />.</returns>
		public bool IsEmfPlusOnly()
		{
			if (wmf == null && emf == null)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			if (emf != null)
			{
				return emf.type == MetafileType.EmfPlusOnly;
			}
			return false;
		}

		/// <summary>Returns a value that indicates whether the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is device dependent.</summary>
		/// <returns>
		///   <see langword="true" /> if the associated <see cref="T:System.Drawing.Imaging.Metafile" /> is device dependent; otherwise, <see langword="false" />.</returns>
		public bool IsDisplay()
		{
			if (IsEmfPlus())
			{
				return (emf.emfPlusFlags & EmfPlusFlags.Display) != 0;
			}
			return false;
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class MetafileHeaderEmf
	{
		public MetafileType type;

		public int size;

		public int version;

		public EmfPlusFlags emfPlusFlags;

		public float dpiX;

		public float dpiY;

		public int X;

		public int Y;

		public int Width;

		public int Height;

		public SafeNativeMethods.ENHMETAHEADER EmfHeader;

		public int EmfPlusHeaderSize;

		public int LogicalDpiX;

		public int LogicalDpiY;
	}
	[StructLayout(LayoutKind.Sequential, Pack = 8)]
	internal class MetafileHeaderWmf
	{
		public MetafileType type;

		public int size = Marshal.SizeOf(typeof(MetafileHeaderWmf));

		public int version;

		public EmfPlusFlags emfPlusFlags;

		public float dpiX;

		public float dpiY;

		public int X;

		public int Y;

		public int Width;

		public int Height;

		[MarshalAs(UnmanagedType.Struct)]
		public MetaHeader WmfHeader = new MetaHeader();

		public int dummy1;

		public int dummy2;

		public int dummy3;

		public int dummy4;

		public int dummy5;

		public int dummy6;

		public int dummy7;

		public int dummy8;

		public int dummy9;

		public int dummy10;

		public int dummy11;

		public int dummy12;

		public int dummy13;

		public int dummy14;

		public int dummy15;

		public int dummy16;

		public int EmfPlusHeaderSize;

		public int LogicalDpiX;

		public int LogicalDpiY;
	}
	/// <summary>Specifies types of metafiles. The <see cref="P:System.Drawing.Imaging.MetafileHeader.Type" /> property returns a member of this enumeration.</summary>
	public enum MetafileType
	{
		/// <summary>Specifies a metafile format that is not recognized in GDI+.</summary>
		Invalid,
		/// <summary>Specifies a WMF (Windows Metafile) file. Such a file contains only GDI records.</summary>
		Wmf,
		/// <summary>Specifies a WMF (Windows Metafile) file that has a placeable metafile header in front of it.</summary>
		WmfPlaceable,
		/// <summary>Specifies an Enhanced Metafile (EMF) file. Such a file contains only GDI records.</summary>
		Emf,
		/// <summary>Specifies an EMF+ file. Such a file contains only GDI+ records and must be displayed by using GDI+. Displaying the records using GDI may cause unpredictable results.</summary>
		EmfPlusOnly,
		/// <summary>Specifies an EMF+ Dual file. Such a file contains GDI+ records along with alternative GDI records and can be displayed by using either GDI or GDI+. Displaying the records using GDI may cause some quality degradation.</summary>
		EmfPlusDual
	}
	/// <summary>Contains information about a windows-format (WMF) metafile.</summary>
	[StructLayout(LayoutKind.Sequential, Pack = 2)]
	public sealed class MetaHeader
	{
		private short type;

		private short headerSize;

		private short version;

		private int size;

		private short noObjects;

		private int maxRecord;

		private short noParameters;

		/// <summary>Gets or sets the type of the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</summary>
		/// <returns>The type of the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</returns>
		public short Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		/// <summary>Gets or sets the size, in bytes, of the header file.</summary>
		/// <returns>The size, in bytes, of the header file.</returns>
		public short HeaderSize
		{
			get
			{
				return headerSize;
			}
			set
			{
				headerSize = value;
			}
		}

		/// <summary>Gets or sets the version number of the header format.</summary>
		/// <returns>The version number of the header format.</returns>
		public short Version
		{
			get
			{
				return version;
			}
			set
			{
				version = value;
			}
		}

		/// <summary>Gets or sets the size, in bytes, of the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</summary>
		/// <returns>The size, in bytes, of the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</returns>
		public int Size
		{
			get
			{
				return size;
			}
			set
			{
				size = value;
			}
		}

		/// <summary>Gets or sets the maximum number of objects that exist in the <see cref="T:System.Drawing.Imaging.Metafile" /> object at the same time.</summary>
		/// <returns>The maximum number of objects that exist in the <see cref="T:System.Drawing.Imaging.Metafile" /> object at the same time.</returns>
		public short NoObjects
		{
			get
			{
				return noObjects;
			}
			set
			{
				noObjects = value;
			}
		}

		/// <summary>Gets or sets the size, in bytes, of the largest record in the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</summary>
		/// <returns>The size, in bytes, of the largest record in the associated <see cref="T:System.Drawing.Imaging.Metafile" /> object.</returns>
		public int MaxRecord
		{
			get
			{
				return maxRecord;
			}
			set
			{
				maxRecord = value;
			}
		}

		/// <summary>Not used. Always returns 0.</summary>
		/// <returns>Always 0.</returns>
		public short NoParameters
		{
			get
			{
				return noParameters;
			}
			set
			{
				noParameters = value;
			}
		}

		/// <summary>Initializes a new instance of the <see langword="MetaHeader" /> class.</summary>
		public MetaHeader()
		{
		}
	}
	/// <summary>Specifies the type of color data in the system palette. The data can be color data with alpha, grayscale data only, or halftone data.</summary>
	[Flags]
	public enum PaletteFlags
	{
		/// <summary>Alpha data.</summary>
		HasAlpha = 1,
		/// <summary>Grayscale data.</summary>
		GrayScale = 2,
		/// <summary>Halftone data.</summary>
		Halftone = 4
	}
	/// <summary>Specifies the format of the color data for each pixel in the image.</summary>
	public enum PixelFormat
	{
		/// <summary>The pixel data contains color-indexed values, which means the values are an index to colors in the system color table, as opposed to individual color values.</summary>
		Indexed = 65536,
		/// <summary>The pixel data contains GDI colors.</summary>
		Gdi = 131072,
		/// <summary>The pixel data contains alpha values that are not premultiplied.</summary>
		Alpha = 262144,
		/// <summary>The pixel format contains premultiplied alpha values.</summary>
		PAlpha = 524288,
		/// <summary>Reserved.</summary>
		Extended = 1048576,
		/// <summary>The default pixel format of 32 bits per pixel. The format specifies 24-bit color depth and an 8-bit alpha channel.</summary>
		Canonical = 2097152,
		/// <summary>The pixel format is undefined.</summary>
		Undefined = 0,
		/// <summary>No pixel format is specified.</summary>
		DontCare = 0,
		/// <summary>Specifies that the pixel format is 1 bit per pixel and that it uses indexed color. The color table therefore has two colors in it.</summary>
		Format1bppIndexed = 196865,
		/// <summary>Specifies that the format is 4 bits per pixel, indexed.</summary>
		Format4bppIndexed = 197634,
		/// <summary>Specifies that the format is 8 bits per pixel, indexed. The color table therefore has 256 colors in it.</summary>
		Format8bppIndexed = 198659,
		/// <summary>The pixel format is 16 bits per pixel. The color information specifies 65536 shades of gray.</summary>
		Format16bppGrayScale = 1052676,
		/// <summary>Specifies that the format is 16 bits per pixel; 5 bits each are used for the red, green, and blue components. The remaining bit is not used.</summary>
		Format16bppRgb555 = 135173,
		/// <summary>Specifies that the format is 16 bits per pixel; 5 bits are used for the red component, 6 bits are used for the green component, and 5 bits are used for the blue component.</summary>
		Format16bppRgb565 = 135174,
		/// <summary>The pixel format is 16 bits per pixel. The color information specifies 32,768 shades of color, of which 5 bits are red, 5 bits are green, 5 bits are blue, and 1 bit is alpha.</summary>
		Format16bppArgb1555 = 397319,
		/// <summary>Specifies that the format is 24 bits per pixel; 8 bits each are used for the red, green, and blue components.</summary>
		Format24bppRgb = 137224,
		/// <summary>Specifies that the format is 32 bits per pixel; 8 bits each are used for the red, green, and blue components. The remaining 8 bits are not used.</summary>
		Format32bppRgb = 139273,
		/// <summary>Specifies that the format is 32 bits per pixel; 8 bits each are used for the alpha, red, green, and blue components.</summary>
		Format32bppArgb = 2498570,
		/// <summary>Specifies that the format is 32 bits per pixel; 8 bits each are used for the alpha, red, green, and blue components. The red, green, and blue components are premultiplied, according to the alpha component.</summary>
		Format32bppPArgb = 925707,
		/// <summary>Specifies that the format is 48 bits per pixel; 16 bits each are used for the red, green, and blue components.</summary>
		Format48bppRgb = 1060876,
		/// <summary>Specifies that the format is 64 bits per pixel; 16 bits each are used for the alpha, red, green, and blue components.</summary>
		Format64bppArgb = 3424269,
		/// <summary>Specifies that the format is 64 bits per pixel; 16 bits each are used for the alpha, red, green, and blue components. The red, green, and blue components are premultiplied according to the alpha component.</summary>
		Format64bppPArgb = 1851406,
		/// <summary>The maximum value for this enumeration.</summary>
		Max = 15
	}
	/// <summary>This delegate is not used. For an example of enumerating the records of a metafile, see <see cref="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc)" />.</summary>
	/// <param name="recordType">Not used.</param>
	/// <param name="flags">Not used.</param>
	/// <param name="dataSize">Not used.</param>
	/// <param name="recordData">Not used.</param>
	public delegate void PlayRecordCallback(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr recordData);
	/// <summary>Encapsulates a metadata property to be included in an image file. Not inheritable.</summary>
	public sealed class PropertyItem
	{
		private int id;

		private int len;

		private short type;

		private byte[] value;

		/// <summary>Gets or sets the ID of the property.</summary>
		/// <returns>The integer that represents the ID of the property.</returns>
		public int Id
		{
			get
			{
				return id;
			}
			set
			{
				id = value;
			}
		}

		/// <summary>Gets or sets the length (in bytes) of the <see cref="P:System.Drawing.Imaging.PropertyItem.Value" /> property.</summary>
		/// <returns>An integer that represents the length (in bytes) of the <see cref="P:System.Drawing.Imaging.PropertyItem.Value" /> byte array.</returns>
		public int Len
		{
			get
			{
				return len;
			}
			set
			{
				len = value;
			}
		}

		/// <summary>Gets or sets an integer that defines the type of data contained in the <see cref="P:System.Drawing.Imaging.PropertyItem.Value" /> property.</summary>
		/// <returns>An integer that defines the type of data contained in <see cref="P:System.Drawing.Imaging.PropertyItem.Value" />.</returns>
		public short Type
		{
			get
			{
				return type;
			}
			set
			{
				type = value;
			}
		}

		/// <summary>Gets or sets the value of the property item.</summary>
		/// <returns>A byte array that represents the value of the property item.</returns>
		public byte[] Value
		{
			get
			{
				return value;
			}
			set
			{
				this.value = value;
			}
		}

		internal PropertyItem()
		{
		}
	}
	/// <summary>Defines a placeable metafile. Not inheritable.</summary>
	[StructLayout(LayoutKind.Sequential)]
	public sealed class WmfPlaceableFileHeader
	{
		private int key = -1698247209;

		private short hmf;

		private short bboxLeft;

		private short bboxTop;

		private short bboxRight;

		private short bboxBottom;

		private short inch;

		private int reserved;

		private short checksum;

		/// <summary>Gets or sets a value indicating the presence of a placeable metafile header.</summary>
		/// <returns>A value indicating presence of a placeable metafile header.</returns>
		public int Key
		{
			get
			{
				return key;
			}
			set
			{
				key = value;
			}
		}

		/// <summary>Gets or sets the handle of the metafile in memory.</summary>
		/// <returns>The handle of the metafile in memory.</returns>
		public short Hmf
		{
			get
			{
				return hmf;
			}
			set
			{
				hmf = value;
			}
		}

		/// <summary>Gets or sets the x-coordinate of the upper-left corner of the bounding rectangle of the metafile image on the output device.</summary>
		/// <returns>The x-coordinate of the upper-left corner of the bounding rectangle of the metafile image on the output device.</returns>
		public short BboxLeft
		{
			get
			{
				return bboxLeft;
			}
			set
			{
				bboxLeft = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of the upper-left corner of the bounding rectangle of the metafile image on the output device.</summary>
		/// <returns>The y-coordinate of the upper-left corner of the bounding rectangle of the metafile image on the output device.</returns>
		public short BboxTop
		{
			get
			{
				return bboxTop;
			}
			set
			{
				bboxTop = value;
			}
		}

		/// <summary>Gets or sets the x-coordinate of the lower-right corner of the bounding rectangle of the metafile image on the output device.</summary>
		/// <returns>The x-coordinate of the lower-right corner of the bounding rectangle of the metafile image on the output device.</returns>
		public short BboxRight
		{
			get
			{
				return bboxRight;
			}
			set
			{
				bboxRight = value;
			}
		}

		/// <summary>Gets or sets the y-coordinate of the lower-right corner of the bounding rectangle of the metafile image on the output device.</summary>
		/// <returns>The y-coordinate of the lower-right corner of the bounding rectangle of the metafile image on the output device.</returns>
		public short BboxBottom
		{
			get
			{
				return bboxBottom;
			}
			set
			{
				bboxBottom = value;
			}
		}

		/// <summary>Gets or sets the number of twips per inch.</summary>
		/// <returns>The number of twips per inch.</returns>
		public short Inch
		{
			get
			{
				return inch;
			}
			set
			{
				inch = value;
			}
		}

		/// <summary>Reserved. Do not use.</summary>
		/// <returns>Reserved. Do not use.</returns>
		public int Reserved
		{
			get
			{
				return reserved;
			}
			set
			{
				reserved = value;
			}
		}

		/// <summary>Gets or sets the checksum value for the previous ten <see langword="WORD" /> s in the header.</summary>
		/// <returns>The checksum value for the previous ten <see langword="WORD" /> s in the header.</returns>
		public short Checksum
		{
			get
			{
				return checksum;
			}
			set
			{
				checksum = value;
			}
		}

		/// <summary>Initializes a new instance of the <see langword="WmfPlaceableFileHeader" /> class.</summary>
		public WmfPlaceableFileHeader()
		{
		}
	}
}
namespace System.Drawing.Drawing2D
{
	/// <summary>Specifies the type of graphic shape to use on both ends of each dash in a dashed line.</summary>
	public enum DashCap
	{
		/// <summary>Specifies a square cap that squares off both ends of each dash.</summary>
		Flat = 0,
		/// <summary>Specifies a circular cap that rounds off both ends of each dash.</summary>
		Round = 2,
		/// <summary>Specifies a triangular cap that points both ends of each dash.</summary>
		Triangle = 3
	}
	/// <summary>Represents an adjustable arrow-shaped line cap. This class cannot be inherited.</summary>
	public sealed class AdjustableArrowCap : CustomLineCap
	{
		/// <summary>Gets or sets the height of the arrow cap.</summary>
		/// <returns>The height of the arrow cap.</returns>
		public float Height
		{
			get
			{
				return _GetHeight();
			}
			set
			{
				_SetHeight(value);
			}
		}

		/// <summary>Gets or sets the width of the arrow cap.</summary>
		/// <returns>The width, in units, of the arrow cap.</returns>
		public float Width
		{
			get
			{
				return _GetWidth();
			}
			set
			{
				_SetWidth(value);
			}
		}

		/// <summary>Gets or sets the number of units between the outline of the arrow cap and the fill.</summary>
		/// <returns>The number of units between the outline of the arrow cap and the fill of the arrow cap.</returns>
		public float MiddleInset
		{
			get
			{
				return _GetMiddleInset();
			}
			set
			{
				_SetMiddleInset(value);
			}
		}

		/// <summary>Gets or sets whether the arrow cap is filled.</summary>
		/// <returns>This property is <see langword="true" /> if the arrow cap is filled; otherwise, <see langword="false" />.</returns>
		public bool Filled
		{
			get
			{
				return _IsFilled();
			}
			set
			{
				_SetFillState(value);
			}
		}

		internal AdjustableArrowCap(IntPtr nativeCap)
			: base(nativeCap)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.AdjustableArrowCap" /> class with the specified width and height. The arrow end caps created with this constructor are always filled.</summary>
		/// <param name="width">The width of the arrow.</param>
		/// <param name="height">The height of the arrow.</param>
		public AdjustableArrowCap(float width, float height)
			: this(width, height, isFilled: true)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.AdjustableArrowCap" /> class with the specified width, height, and fill property. Whether an arrow end cap is filled depends on the argument passed to the <paramref name="isFilled" /> parameter.</summary>
		/// <param name="width">The width of the arrow.</param>
		/// <param name="height">The height of the arrow.</param>
		/// <param name="isFilled">
		///   <see langword="true" /> to fill the arrow cap; otherwise, <see langword="false" />.</param>
		public AdjustableArrowCap(float width, float height, bool isFilled)
		{
			IntPtr adjustableArrowCap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateAdjustableArrowCap(height, width, isFilled, out adjustableArrowCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeLineCap(adjustableArrowCap);
		}

		private void _SetHeight(float height)
		{
			int num = SafeNativeMethods.Gdip.GdipSetAdjustableArrowCapHeight(new HandleRef(this, nativeCap), height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private float _GetHeight()
		{
			float height;
			int num = SafeNativeMethods.Gdip.GdipGetAdjustableArrowCapHeight(new HandleRef(this, nativeCap), out height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return height;
		}

		private void _SetWidth(float width)
		{
			int num = SafeNativeMethods.Gdip.GdipSetAdjustableArrowCapWidth(new HandleRef(this, nativeCap), width);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private float _GetWidth()
		{
			float width;
			int num = SafeNativeMethods.Gdip.GdipGetAdjustableArrowCapWidth(new HandleRef(this, nativeCap), out width);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return width;
		}

		private void _SetMiddleInset(float middleInset)
		{
			int num = SafeNativeMethods.Gdip.GdipSetAdjustableArrowCapMiddleInset(new HandleRef(this, nativeCap), middleInset);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private float _GetMiddleInset()
		{
			float middleInset;
			int num = SafeNativeMethods.Gdip.GdipGetAdjustableArrowCapMiddleInset(new HandleRef(this, nativeCap), out middleInset);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return middleInset;
		}

		private void _SetFillState(bool isFilled)
		{
			int num = SafeNativeMethods.Gdip.GdipSetAdjustableArrowCapFillState(new HandleRef(this, nativeCap), isFilled);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private bool _IsFilled()
		{
			bool fillState = false;
			int num = SafeNativeMethods.Gdip.GdipGetAdjustableArrowCapFillState(new HandleRef(this, nativeCap), out fillState);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return fillState;
		}
	}
	/// <summary>Defines a blend pattern for a <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> object. This class cannot be inherited.</summary>
	public sealed class Blend
	{
		private float[] factors;

		private float[] positions;

		/// <summary>Gets or sets an array of blend factors for the gradient.</summary>
		/// <returns>An array of blend factors that specify the percentages of the starting color and the ending color to be used at the corresponding position.</returns>
		public float[] Factors
		{
			get
			{
				return factors;
			}
			set
			{
				factors = value;
			}
		}

		/// <summary>Gets or sets an array of blend positions for the gradient.</summary>
		/// <returns>An array of blend positions that specify the percentages of distance along the gradient line.</returns>
		public float[] Positions
		{
			get
			{
				return positions;
			}
			set
			{
				positions = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Blend" /> class.</summary>
		public Blend()
		{
			factors = new float[1];
			positions = new float[1];
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Blend" /> class with the specified number of factors and positions.</summary>
		/// <param name="count">The number of elements in the <see cref="P:System.Drawing.Drawing2D.Blend.Factors" /> and <see cref="P:System.Drawing.Drawing2D.Blend.Positions" /> arrays.</param>
		public Blend(int count)
		{
			factors = new float[count];
			positions = new float[count];
		}
	}
	internal enum BrushType
	{
		SolidColor,
		HatchFill,
		TextureFill,
		PathGradient,
		LinearGradient
	}
	/// <summary>Defines arrays of colors and positions used for interpolating color blending in a multicolor gradient. This class cannot be inherited.</summary>
	public sealed class ColorBlend
	{
		private Color[] colors;

		private float[] positions;

		/// <summary>Gets or sets an array of colors that represents the colors to use at corresponding positions along a gradient.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.Color" /> structures that represents the colors to use at corresponding positions along a gradient.</returns>
		public Color[] Colors
		{
			get
			{
				return colors;
			}
			set
			{
				colors = value;
			}
		}

		/// <summary>Gets or sets the positions along a gradient line.</summary>
		/// <returns>An array of values that specify percentages of distance along the gradient line.</returns>
		public float[] Positions
		{
			get
			{
				return positions;
			}
			set
			{
				positions = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> class.</summary>
		public ColorBlend()
		{
			colors = new Color[1];
			positions = new float[1];
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> class with the specified number of colors and positions.</summary>
		/// <param name="count">The number of colors and positions in this <see cref="T:System.Drawing.Drawing2D.ColorBlend" />.</param>
		public ColorBlend(int count)
		{
			colors = new Color[count];
			positions = new float[count];
		}
	}
	/// <summary>Specifies how different clipping regions can be combined.</summary>
	public enum CombineMode
	{
		/// <summary>One clipping region is replaced by another.</summary>
		Replace,
		/// <summary>Two clipping regions are combined by taking their intersection.</summary>
		Intersect,
		/// <summary>Two clipping regions are combined by taking the union of both.</summary>
		Union,
		/// <summary>Two clipping regions are combined by taking only the areas enclosed by one or the other region, but not both.</summary>
		Xor,
		/// <summary>Specifies that the existing region is replaced by the result of the new region being removed from the existing region. Said differently, the new region is excluded from the existing region.</summary>
		Exclude,
		/// <summary>Specifies that the existing region is replaced by the result of the existing region being removed from the new region. Said differently, the existing region is excluded from the new region.</summary>
		Complement
	}
	/// <summary>Specifies how the source colors are combined with the background colors.</summary>
	public enum CompositingMode
	{
		/// <summary>Specifies that when a color is rendered, it is blended with the background color. The blend is determined by the alpha component of the color being rendered.</summary>
		SourceOver,
		/// <summary>Specifies that when a color is rendered, it overwrites the background color.</summary>
		SourceCopy
	}
	/// <summary>Specifies the quality level to use during compositing.</summary>
	public enum CompositingQuality
	{
		/// <summary>Invalid quality.</summary>
		Invalid = -1,
		/// <summary>Default quality.</summary>
		Default,
		/// <summary>High speed, low quality.</summary>
		HighSpeed,
		/// <summary>High quality, low speed compositing.</summary>
		HighQuality,
		/// <summary>Gamma correction is used.</summary>
		GammaCorrected,
		/// <summary>Assume linear values.</summary>
		AssumeLinear
	}
	/// <summary>Specifies the system to use when evaluating coordinates.</summary>
	public enum CoordinateSpace
	{
		/// <summary>Specifies that coordinates are in the world coordinate context. World coordinates are used in a nonphysical environment, such as a modeling environment.</summary>
		World,
		/// <summary>Specifies that coordinates are in the page coordinate context. Their units are defined by the <see cref="P:System.Drawing.Graphics.PageUnit" /> property, and must be one of the elements of the <see cref="T:System.Drawing.GraphicsUnit" /> enumeration.</summary>
		Page,
		/// <summary>Specifies that coordinates are in the device coordinate context. On a computer screen the device coordinates are usually measured in pixels.</summary>
		Device
	}
	/// <summary>Encapsulates a custom user-defined line cap.</summary>
	public class CustomLineCap : MarshalByRefObject, ICloneable, IDisposable
	{
		internal SafeCustomLineCapHandle nativeCap;

		private bool disposed;

		/// <summary>Gets or sets the <see cref="T:System.Drawing.Drawing2D.LineJoin" /> enumeration that determines how lines that compose this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> object are joined.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.LineJoin" /> enumeration this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> object uses to join lines.</returns>
		public LineJoin StrokeJoin
		{
			get
			{
				return _GetStrokeJoin();
			}
			set
			{
				_SetStrokeJoin(value);
			}
		}

		/// <summary>Gets or sets the <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration on which this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> is based.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration on which this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> is based.</returns>
		public LineCap BaseCap
		{
			get
			{
				return _GetBaseCap();
			}
			set
			{
				_SetBaseCap(value);
			}
		}

		/// <summary>Gets or sets the distance between the cap and the line.</summary>
		/// <returns>The distance between the beginning of the cap and the end of the line.</returns>
		public float BaseInset
		{
			get
			{
				return _GetBaseInset();
			}
			set
			{
				_SetBaseInset(value);
			}
		}

		/// <summary>Gets or sets the amount by which to scale this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> Class object with respect to the width of the <see cref="T:System.Drawing.Pen" /> object.</summary>
		/// <returns>The amount by which to scale the cap.</returns>
		public float WidthScale
		{
			get
			{
				return _GetWidthScale();
			}
			set
			{
				_SetWidthScale(value);
			}
		}

		internal CustomLineCap()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> class with the specified outline and fill.</summary>
		/// <param name="fillPath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the fill for the custom cap.</param>
		/// <param name="strokePath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the outline of the custom cap.</param>
		public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath)
			: this(fillPath, strokePath, LineCap.Flat)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> class from the specified existing <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration with the specified outline and fill.</summary>
		/// <param name="fillPath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the fill for the custom cap.</param>
		/// <param name="strokePath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the outline of the custom cap.</param>
		/// <param name="baseCap">The line cap from which to create the custom cap.</param>
		public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap)
			: this(fillPath, strokePath, baseCap, 0f)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> class from the specified existing <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration with the specified outline, fill, and inset.</summary>
		/// <param name="fillPath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the fill for the custom cap.</param>
		/// <param name="strokePath">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object that defines the outline of the custom cap.</param>
		/// <param name="baseCap">The line cap from which to create the custom cap.</param>
		/// <param name="baseInset">The distance between the cap and the line.</param>
		public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap, float baseInset)
		{
			IntPtr customCap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateCustomLineCap(new HandleRef(fillPath, fillPath?.nativePath ?? IntPtr.Zero), new HandleRef(strokePath, strokePath?.nativePath ?? IntPtr.Zero), baseCap, baseInset, out customCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeLineCap(customCap);
		}

		internal CustomLineCap(IntPtr nativeLineCap)
		{
			SetNativeLineCap(nativeLineCap);
		}

		internal void SetNativeLineCap(IntPtr handle)
		{
			if (handle == IntPtr.Zero)
			{
				throw new ArgumentNullException("handle");
			}
			nativeCap = new SafeCustomLineCapHandle(handle);
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///   <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected virtual void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (disposing && nativeCap != null)
				{
					nativeCap.Dispose();
				}
				disposed = true;
			}
		}

		/// <summary>Allows an <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> to attempt to free resources and perform other cleanup operations before the <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> is reclaimed by garbage collection.</summary>
		~CustomLineCap()
		{
			Dispose(disposing: false);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Drawing2D.CustomLineCap" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.CustomLineCap" /> this method creates, cast as an object.</returns>
		public object Clone()
		{
			IntPtr clonedCap = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneCustomLineCap(new HandleRef(this, nativeCap), out clonedCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return CreateCustomLineCapObject(clonedCap);
		}

		internal static CustomLineCap CreateCustomLineCapObject(IntPtr cap)
		{
			CustomLineCapType capType = CustomLineCapType.Default;
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapType(new HandleRef(null, cap), out capType);
			if (num != 0)
			{
				SafeNativeMethods.Gdip.GdipDeleteCustomLineCap(new HandleRef(null, cap));
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			switch (capType)
			{
			case CustomLineCapType.Default:
				return new CustomLineCap(cap);
			case CustomLineCapType.AdjustableArrowCap:
				return new AdjustableArrowCap(cap);
			default:
				SafeNativeMethods.Gdip.GdipDeleteCustomLineCap(new HandleRef(null, cap));
				throw SafeNativeMethods.Gdip.StatusException(6);
			}
		}

		/// <summary>Sets the caps used to start and end lines that make up this custom cap.</summary>
		/// <param name="startCap">The <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration used at the beginning of a line within this cap.</param>
		/// <param name="endCap">The <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration used at the end of a line within this cap.</param>
		public void SetStrokeCaps(LineCap startCap, LineCap endCap)
		{
			int num = SafeNativeMethods.Gdip.GdipSetCustomLineCapStrokeCaps(new HandleRef(this, nativeCap), startCap, endCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Gets the caps used to start and end lines that make up this custom cap.</summary>
		/// <param name="startCap">The <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration used at the beginning of a line within this cap.</param>
		/// <param name="endCap">The <see cref="T:System.Drawing.Drawing2D.LineCap" /> enumeration used at the end of a line within this cap.</param>
		public void GetStrokeCaps(out LineCap startCap, out LineCap endCap)
		{
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapStrokeCaps(new HandleRef(this, nativeCap), out startCap, out endCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private void _SetStrokeJoin(LineJoin lineJoin)
		{
			int num = SafeNativeMethods.Gdip.GdipSetCustomLineCapStrokeJoin(new HandleRef(this, nativeCap), lineJoin);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private LineJoin _GetStrokeJoin()
		{
			LineJoin lineJoin;
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapStrokeJoin(new HandleRef(this, nativeCap), out lineJoin);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return lineJoin;
		}

		private void _SetBaseCap(LineCap baseCap)
		{
			int num = SafeNativeMethods.Gdip.GdipSetCustomLineCapBaseCap(new HandleRef(this, nativeCap), baseCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private LineCap _GetBaseCap()
		{
			LineCap baseCap;
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapBaseCap(new HandleRef(this, nativeCap), out baseCap);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return baseCap;
		}

		private void _SetBaseInset(float inset)
		{
			int num = SafeNativeMethods.Gdip.GdipSetCustomLineCapBaseInset(new HandleRef(this, nativeCap), inset);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private float _GetBaseInset()
		{
			float inset;
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapBaseInset(new HandleRef(this, nativeCap), out inset);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return inset;
		}

		private void _SetWidthScale(float widthScale)
		{
			int num = SafeNativeMethods.Gdip.GdipSetCustomLineCapWidthScale(new HandleRef(this, nativeCap), widthScale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private float _GetWidthScale()
		{
			float widthScale;
			int num = SafeNativeMethods.Gdip.GdipGetCustomLineCapWidthScale(new HandleRef(this, nativeCap), out widthScale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return widthScale;
		}
	}
	internal enum CustomLineCapType
	{
		Default,
		AdjustableArrowCap
	}
	/// <summary>Specifies the style of dashed lines drawn with a <see cref="T:System.Drawing.Pen" /> object.</summary>
	public enum DashStyle
	{
		/// <summary>Specifies a solid line.</summary>
		Solid,
		/// <summary>Specifies a line consisting of dashes.</summary>
		Dash,
		/// <summary>Specifies a line consisting of dots.</summary>
		Dot,
		/// <summary>Specifies a line consisting of a repeating pattern of dash-dot.</summary>
		DashDot,
		/// <summary>Specifies a line consisting of a repeating pattern of dash-dot-dot.</summary>
		DashDotDot,
		/// <summary>Specifies a user-defined custom dash style.</summary>
		Custom
	}
	/// <summary>Specifies how the interior of a closed path is filled.</summary>
	public enum FillMode
	{
		/// <summary>Specifies the alternate fill mode.</summary>
		Alternate,
		/// <summary>Specifies the winding fill mode.</summary>
		Winding
	}
	/// <summary>Specifies whether commands in the graphics stack are terminated (flushed) immediately or executed as soon as possible.</summary>
	public enum FlushIntention
	{
		/// <summary>Specifies that the stack of all graphics operations is flushed immediately.</summary>
		Flush,
		/// <summary>Specifies that all graphics operations on the stack are executed as soon as possible. This synchronizes the graphics state.</summary>
		Sync
	}
	/// <summary>Represents the internal data of a graphics container. This class is used when saving the state of a <see cref="T:System.Drawing.Graphics" /> object using the <see cref="M:System.Drawing.Graphics.BeginContainer" /> and <see cref="M:System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer)" /> methods. This class cannot be inherited.</summary>
	public sealed class GraphicsContainer : MarshalByRefObject
	{
		internal int nativeGraphicsContainer;

		internal GraphicsContainer(int graphicsContainer)
		{
			nativeGraphicsContainer = graphicsContainer;
		}
	}
	/// <summary>Represents a series of connected lines and curves. This class cannot be inherited.</summary>
	public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable
	{
		internal IntPtr nativePath;

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the interiors of shapes in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> are filled.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that specifies how the interiors of shapes in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> are filled.</returns>
		public FillMode FillMode
		{
			get
			{
				int fillmode = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPathFillMode(new HandleRef(this, nativePath), out fillmode);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (FillMode)fillmode;
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 1))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(FillMode));
				}
				int num = SafeNativeMethods.Gdip.GdipSetPathFillMode(new HandleRef(this, nativePath), (int)value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets a <see cref="T:System.Drawing.Drawing2D.PathData" /> that encapsulates arrays of points (<paramref name="points" />) and types (<paramref name="types" />) for this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.PathData" /> that encapsulates arrays for both the points and types for this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
		public PathData PathData => _GetPathData();

		/// <summary>Gets the number of elements in the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> or the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> array.</summary>
		/// <returns>An integer that specifies the number of elements in the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> or the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> array.</returns>
		public int PointCount
		{
			get
			{
				int count = 0;
				int num = SafeNativeMethods.Gdip.GdipGetPointCount(new HandleRef(this, nativePath), out count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return count;
			}
		}

		/// <summary>Gets the types of the corresponding points in the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> array.</summary>
		/// <returns>An array of bytes that specifies the types of the corresponding points in the path.</returns>
		public byte[] PathTypes
		{
			get
			{
				int pointCount = PointCount;
				byte[] array = new byte[pointCount];
				int num = SafeNativeMethods.Gdip.GdipGetPathTypes(new HandleRef(this, nativePath), array, pointCount);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return array;
			}
		}

		/// <summary>Gets the points in the path.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.PointF" /> objects that represent the path.</returns>
		public PointF[] PathPoints
		{
			get
			{
				int pointCount = PointCount;
				int num = Marshal.SizeOf(typeof(GPPOINTF));
				IntPtr intPtr = Marshal.AllocHGlobal(checked(pointCount * num));
				try
				{
					int num2 = SafeNativeMethods.Gdip.GdipGetPathPoints(new HandleRef(this, nativePath), new HandleRef(null, intPtr), pointCount);
					if (num2 != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num2);
					}
					return SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, pointCount);
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> class with a <see cref="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" /> value of <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
		public GraphicsPath()
			: this(FillMode.Alternate)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> class with the specified <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration.</summary>
		/// <param name="fillMode">The <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that determines how the interior of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> is filled.</param>
		public GraphicsPath(FillMode fillMode)
		{
			IntPtr path = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreatePath((int)fillMode, out path);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativePath = path;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> array with the specified <see cref="T:System.Drawing.Drawing2D.PathPointType" /> and <see cref="T:System.Drawing.PointF" /> arrays.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.PointF" /> structures that defines the coordinates of the points that make up this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
		/// <param name="types">An array of <see cref="T:System.Drawing.Drawing2D.PathPointType" /> enumeration elements that specifies the type of each corresponding point in the <paramref name="pts" /> array.</param>
		public GraphicsPath(PointF[] pts, byte[] types)
			: this(pts, types, FillMode.Alternate)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> array with the specified <see cref="T:System.Drawing.Drawing2D.PathPointType" /> and <see cref="T:System.Drawing.PointF" /> arrays and with the specified <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration element.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.PointF" /> structures that defines the coordinates of the points that make up this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
		/// <param name="types">An array of <see cref="T:System.Drawing.Drawing2D.PathPointType" /> enumeration elements that specifies the type of each corresponding point in the <paramref name="pts" /> array.</param>
		/// <param name="fillMode">A <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that specifies how the interiors of shapes in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> are filled.</param>
		public GraphicsPath(PointF[] pts, byte[] types, FillMode fillMode)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr path = IntPtr.Zero;
			if (pts.Length != types.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int num = types.Length;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			IntPtr intPtr2 = Marshal.AllocHGlobal(num);
			try
			{
				Marshal.Copy(types, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipCreatePath2(new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num, (int)fillMode, out path);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
			}
			nativePath = path;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> class with the specified <see cref="T:System.Drawing.Drawing2D.PathPointType" /> and <see cref="T:System.Drawing.Point" /> arrays.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that defines the coordinates of the points that make up this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
		/// <param name="types">An array of <see cref="T:System.Drawing.Drawing2D.PathPointType" /> enumeration elements that specifies the type of each corresponding point in the <paramref name="pts" /> array.</param>
		public GraphicsPath(Point[] pts, byte[] types)
			: this(pts, types, FillMode.Alternate)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> class with the specified <see cref="T:System.Drawing.Drawing2D.PathPointType" /> and <see cref="T:System.Drawing.Point" /> arrays and with the specified <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration element.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that defines the coordinates of the points that make up this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
		/// <param name="types">An array of <see cref="T:System.Drawing.Drawing2D.PathPointType" /> enumeration elements that specifies the type of each corresponding point in the <paramref name="pts" /> array.</param>
		/// <param name="fillMode">A <see cref="T:System.Drawing.Drawing2D.FillMode" /> enumeration that specifies how the interiors of shapes in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> are filled.</param>
		public GraphicsPath(Point[] pts, byte[] types, FillMode fillMode)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr path = IntPtr.Zero;
			if (pts.Length != types.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int num = types.Length;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			IntPtr intPtr2 = Marshal.AllocHGlobal(num);
			try
			{
				Marshal.Copy(types, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipCreatePath2I(new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num, (int)fillMode, out path);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
			}
			nativePath = path;
		}

		/// <summary>Creates an exact copy of this path.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> this method creates, cast as an object.</returns>
		public object Clone()
		{
			IntPtr clonepath = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipClonePath(new HandleRef(this, nativePath), out clonepath);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new GraphicsPath(clonepath, 0);
		}

		private GraphicsPath(IntPtr nativePath, int extra)
		{
			if (nativePath == IntPtr.Zero)
			{
				throw new ArgumentNullException("nativePath");
			}
			this.nativePath = nativePath;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativePath != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeletePath(new HandleRef(this, nativePath));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativePath = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~GraphicsPath()
		{
			Dispose(disposing: false);
		}

		/// <summary>Empties the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> and <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> arrays and sets the <see cref="T:System.Drawing.Drawing2D.FillMode" /> to <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
		public void Reset()
		{
			int num = SafeNativeMethods.Gdip.GdipResetPath(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private PathData _GetPathData()
		{
			int num = Marshal.SizeOf(typeof(GPPOINTF));
			int pointCount = PointCount;
			PathData pathData = new PathData();
			pathData.Types = new byte[pointCount];
			IntPtr intPtr = Marshal.AllocHGlobal(3 * IntPtr.Size);
			IntPtr intPtr2 = Marshal.AllocHGlobal(checked(num * pointCount));
			try
			{
				GCHandle gCHandle = GCHandle.Alloc(pathData.Types, GCHandleType.Pinned);
				try
				{
					IntPtr intPtr3 = gCHandle.AddrOfPinnedObject();
					Marshal.StructureToPtr((object)pointCount, intPtr, fDeleteOld: false);
					Marshal.StructureToPtr((object)(long)intPtr2, (IntPtr)((long)intPtr + IntPtr.Size), fDeleteOld: false);
					Marshal.StructureToPtr((object)(long)intPtr3, (IntPtr)((long)intPtr + 2 * IntPtr.Size), fDeleteOld: false);
					int num2 = SafeNativeMethods.Gdip.GdipGetPathData(new HandleRef(this, nativePath), intPtr);
					if (num2 != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num2);
					}
					pathData.Points = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr2, pointCount);
					return pathData;
				}
				finally
				{
					gCHandle.Free();
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
				Marshal.FreeHGlobal(intPtr2);
			}
		}

		/// <summary>Starts a new figure without closing the current figure. All subsequent points added to the path are added to this new figure.</summary>
		public void StartFigure()
		{
			int num = SafeNativeMethods.Gdip.GdipStartPathFigure(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Closes the current figure and starts a new figure. If the current figure contains a sequence of connected lines and curves, the method closes the loop by connecting a line from the endpoint to the starting point.</summary>
		public void CloseFigure()
		{
			int num = SafeNativeMethods.Gdip.GdipClosePathFigure(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Closes all open figures in this path and starts a new figure. It closes each open figure by connecting a line from its endpoint to its starting point.</summary>
		public void CloseAllFigures()
		{
			int num = SafeNativeMethods.Gdip.GdipClosePathFigures(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Sets a marker on this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		public void SetMarkers()
		{
			int num = SafeNativeMethods.Gdip.GdipSetPathMarker(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Clears all markers from this path.</summary>
		public void ClearMarkers()
		{
			int num = SafeNativeMethods.Gdip.GdipClearPathMarkers(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Reverses the order of points in the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> array of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		public void Reverse()
		{
			int num = SafeNativeMethods.Gdip.GdipReversePath(new HandleRef(this, nativePath));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Gets the last point in the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> array of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.PointF" /> that represents the last point in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
		public PointF GetLastPoint()
		{
			GPPOINTF gPPOINTF = new GPPOINTF();
			int num = SafeNativeMethods.Gdip.GdipGetPathLastPoint(new HandleRef(this, nativePath), gPPOINTF);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gPPOINTF.ToPoint();
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y)
		{
			return IsVisible(new PointF(x, y), null);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="point">A <see cref="T:System.Drawing.PointF" /> that represents the point to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(PointF point)
		{
			return IsVisible(point, null);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> in the visible clip region of the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(float x, float y, Graphics graphics)
		{
			return IsVisible(new PointF(x, y), graphics);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pt">A <see cref="T:System.Drawing.PointF" /> that represents the point to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(PointF pt, Graphics graphics)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisiblePathPoint(new HandleRef(this, nativePath), pt.X, pt.Y, new HandleRef(graphics, graphics?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y)
		{
			return IsVisible(new Point(x, y), null);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="point">A <see cref="T:System.Drawing.Point" /> that represents the point to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Point point)
		{
			return IsVisible(point, null);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(int x, int y, Graphics graphics)
		{
			return IsVisible(new Point(x, y), graphics);
		}

		/// <summary>Indicates whether the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pt">A <see cref="T:System.Drawing.Point" /> that represents the point to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; otherwise, <see langword="false" />.</returns>
		public bool IsVisible(Point pt, Graphics graphics)
		{
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsVisiblePathPointI(new HandleRef(this, nativePath), pt.X, pt.Y, new HandleRef(graphics, graphics?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(float x, float y, Pen pen)
		{
			return IsOutlineVisible(new PointF(x, y), pen, null);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="point">A <see cref="T:System.Drawing.PointF" /> that specifies the location to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(PointF point, Pen pen)
		{
			return IsOutlineVisible(point, pen, null);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" /> and using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> as drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(float x, float y, Pen pen, Graphics graphics)
		{
			return IsOutlineVisible(new PointF(x, y), pen, graphics);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" /> and using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="pt">A <see cref="T:System.Drawing.PointF" /> that specifies the location to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> as drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(PointF pt, Pen pen, Graphics graphics)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsOutlineVisiblePathPoint(new HandleRef(this, nativePath), pt.X, pt.Y, new HandleRef(pen, pen.NativePen), new HandleRef(graphics, graphics?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(int x, int y, Pen pen)
		{
			return IsOutlineVisible(new Point(x, y), pen, null);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="point">A <see cref="T:System.Drawing.Point" /> that specifies the location to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(Point point, Pen pen)
		{
			return IsOutlineVisible(point, pen, null);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" /> and using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="x">The x-coordinate of the point to test.</param>
		/// <param name="y">The y-coordinate of the point to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> as drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(int x, int y, Pen pen, Graphics graphics)
		{
			return IsOutlineVisible(new Point(x, y), pen, graphics);
		}

		/// <summary>Indicates whether the specified point is contained within (under) the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when drawn with the specified <see cref="T:System.Drawing.Pen" /> and using the specified <see cref="T:System.Drawing.Graphics" />.</summary>
		/// <param name="pt">A <see cref="T:System.Drawing.Point" /> that specifies the location to test.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> to test.</param>
		/// <param name="graphics">The <see cref="T:System.Drawing.Graphics" /> for which to test visibility.</param>
		/// <returns>This method returns <see langword="true" /> if the specified point is contained within the outline of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> as drawn with the specified <see cref="T:System.Drawing.Pen" />; otherwise, <see langword="false" />.</returns>
		public bool IsOutlineVisible(Point pt, Pen pen, Graphics graphics)
		{
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsOutlineVisiblePathPointI(new HandleRef(this, nativePath), pt.X, pt.Y, new HandleRef(pen, pen.NativePen), new HandleRef(graphics, graphics?.NativeGraphics ?? IntPtr.Zero), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Appends a line segment to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pt1">A <see cref="T:System.Drawing.PointF" /> that represents the starting point of the line.</param>
		/// <param name="pt2">A <see cref="T:System.Drawing.PointF" /> that represents the endpoint of the line.</param>
		public void AddLine(PointF pt1, PointF pt2)
		{
			AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
		}

		/// <summary>Appends a line segment to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="x1">The x-coordinate of the starting point of the line.</param>
		/// <param name="y1">The y-coordinate of the starting point of the line.</param>
		/// <param name="x2">The x-coordinate of the endpoint of the line.</param>
		/// <param name="y2">The y-coordinate of the endpoint of the line.</param>
		public void AddLine(float x1, float y1, float x2, float y2)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathLine(new HandleRef(this, nativePath), x1, y1, x2, y2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Appends a series of connected line segments to the end of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the line segments to add.</param>
		public void AddLines(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathLine2(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Appends a line segment to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pt1">A <see cref="T:System.Drawing.Point" /> that represents the starting point of the line.</param>
		/// <param name="pt2">A <see cref="T:System.Drawing.Point" /> that represents the endpoint of the line.</param>
		public void AddLine(Point pt1, Point pt2)
		{
			AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
		}

		/// <summary>Appends a line segment to the current figure.</summary>
		/// <param name="x1">The x-coordinate of the starting point of the line.</param>
		/// <param name="y1">The y-coordinate of the starting point of the line.</param>
		/// <param name="x2">The x-coordinate of the endpoint of the line.</param>
		/// <param name="y2">The y-coordinate of the endpoint of the line.</param>
		public void AddLine(int x1, int y1, int x2, int y2)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathLineI(new HandleRef(this, nativePath), x1, y1, x2, y2);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Appends a series of connected line segments to the end of this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the line segments to add.</param>
		public void AddLines(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathLine2I(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Appends an elliptical arc to the current figure.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangular bounds of the ellipse from which the arc is taken.</param>
		/// <param name="startAngle">The starting angle of the arc, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the arc.</param>
		public void AddArc(RectangleF rect, float startAngle, float sweepAngle)
		{
			AddArc(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Appends an elliptical arc to the current figure.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="width">The width of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="height">The height of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="startAngle">The starting angle of the arc, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the arc.</param>
		public void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathArc(new HandleRef(this, nativePath), x, y, width, height, startAngle, sweepAngle);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Appends an elliptical arc to the current figure.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangular bounds of the ellipse from which the arc is taken.</param>
		/// <param name="startAngle">The starting angle of the arc, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the arc.</param>
		public void AddArc(Rectangle rect, float startAngle, float sweepAngle)
		{
			AddArc(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Appends an elliptical arc to the current figure.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="width">The width of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="height">The height of the rectangular region that defines the ellipse from which the arc is drawn.</param>
		/// <param name="startAngle">The starting angle of the arc, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the arc.</param>
		public void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathArcI(new HandleRef(this, nativePath), x, y, width, height, startAngle, sweepAngle);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a cubic Bézier curve to the current figure.</summary>
		/// <param name="pt1">A <see cref="T:System.Drawing.PointF" /> that represents the starting point of the curve.</param>
		/// <param name="pt2">A <see cref="T:System.Drawing.PointF" /> that represents the first control point for the curve.</param>
		/// <param name="pt3">A <see cref="T:System.Drawing.PointF" /> that represents the second control point for the curve.</param>
		/// <param name="pt4">A <see cref="T:System.Drawing.PointF" /> that represents the endpoint of the curve.</param>
		public void AddBezier(PointF pt1, PointF pt2, PointF pt3, PointF pt4)
		{
			AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
		}

		/// <summary>Adds a cubic Bézier curve to the current figure.</summary>
		/// <param name="x1">The x-coordinate of the starting point of the curve.</param>
		/// <param name="y1">The y-coordinate of the starting point of the curve.</param>
		/// <param name="x2">The x-coordinate of the first control point for the curve.</param>
		/// <param name="y2">The y-coordinate of the first control point for the curve.</param>
		/// <param name="x3">The x-coordinate of the second control point for the curve.</param>
		/// <param name="y3">The y-coordinate of the second control point for the curve.</param>
		/// <param name="x4">The x-coordinate of the endpoint of the curve.</param>
		/// <param name="y4">The y-coordinate of the endpoint of the curve.</param>
		public void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathBezier(new HandleRef(this, nativePath), x1, y1, x2, y2, x3, y3, x4, y4);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a sequence of connected cubic Bézier curves to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curves.</param>
		public void AddBeziers(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathBeziers(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a cubic Bézier curve to the current figure.</summary>
		/// <param name="pt1">A <see cref="T:System.Drawing.Point" /> that represents the starting point of the curve.</param>
		/// <param name="pt2">A <see cref="T:System.Drawing.Point" /> that represents the first control point for the curve.</param>
		/// <param name="pt3">A <see cref="T:System.Drawing.Point" /> that represents the second control point for the curve.</param>
		/// <param name="pt4">A <see cref="T:System.Drawing.Point" /> that represents the endpoint of the curve.</param>
		public void AddBezier(Point pt1, Point pt2, Point pt3, Point pt4)
		{
			AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
		}

		/// <summary>Adds a cubic Bézier curve to the current figure.</summary>
		/// <param name="x1">The x-coordinate of the starting point of the curve.</param>
		/// <param name="y1">The y-coordinate of the starting point of the curve.</param>
		/// <param name="x2">The x-coordinate of the first control point for the curve.</param>
		/// <param name="y2">The y-coordinate of the first control point for the curve.</param>
		/// <param name="x3">The x-coordinate of the second control point for the curve.</param>
		/// <param name="y3">The y-coordinate of the second control point for the curve.</param>
		/// <param name="x4">The x-coordinate of the endpoint of the curve.</param>
		/// <param name="y4">The y-coordinate of the endpoint of the curve.</param>
		public void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathBezierI(new HandleRef(this, nativePath), x1, y1, x2, y2, x3, y3, x4, y4);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a sequence of connected cubic Bézier curves to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curves.</param>
		public void AddBeziers(params Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathBeziersI(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a spline curve to the current figure. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curve.</param>
		public void AddCurve(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurve(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a spline curve to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curve.</param>
		/// <param name="tension">A value that specifies the amount that the curve bends between control points. Values greater than 1 produce unpredictable results.</param>
		public void AddCurve(PointF[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurve2(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a spline curve to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curve.</param>
		/// <param name="offset">The index of the element in the <paramref name="points" /> array that is used as the first point in the curve.</param>
		/// <param name="numberOfSegments">The number of segments used to draw the curve. A segment can be thought of as a line connecting two points.</param>
		/// <param name="tension">A value that specifies the amount that the curve bends between control points. Values greater than 1 produce unpredictable results.</param>
		public void AddCurve(PointF[] points, int offset, int numberOfSegments, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurve3(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, offset, numberOfSegments, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a spline curve to the current figure. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curve.</param>
		public void AddCurve(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurveI(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a spline curve to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curve.</param>
		/// <param name="tension">A value that specifies the amount that the curve bends between control points. Values greater than 1 produce unpredictable results.</param>
		public void AddCurve(Point[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurve2I(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a spline curve to the current figure.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curve.</param>
		/// <param name="offset">The index of the element in the <paramref name="points" /> array that is used as the first point in the curve.</param>
		/// <param name="numberOfSegments">A value that specifies the amount that the curve bends between control points. Values greater than 1 produce unpredictable results.</param>
		/// <param name="tension">A value that specifies the amount that the curve bends between control points. Values greater than 1 produce unpredictable results.</param>
		public void AddCurve(Point[] points, int offset, int numberOfSegments, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathCurve3I(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, offset, numberOfSegments, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a closed curve to this path. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curve.</param>
		public void AddClosedCurve(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathClosedCurve(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a closed curve to this path. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that define the curve.</param>
		/// <param name="tension">A value between from 0 through 1 that specifies the amount that the curve bends between points, with 0 being the smallest curve (sharpest corner) and 1 being the smoothest curve.</param>
		public void AddClosedCurve(PointF[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathClosedCurve2(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a closed curve to this path. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curve.</param>
		public void AddClosedCurve(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathClosedCurveI(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a closed curve to this path. A cardinal spline curve is used because the curve travels through each of the points in the array.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that define the curve.</param>
		/// <param name="tension">A value between from 0 through 1 that specifies the amount that the curve bends between points, with 0 being the smallest curve (sharpest corner) and 1 being the smoothest curve.</param>
		public void AddClosedCurve(Point[] points, float tension)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathClosedCurve2I(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length, tension);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a rectangle to this path.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle to add.</param>
		public void AddRectangle(RectangleF rect)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathRectangle(new HandleRef(this, nativePath), rect.X, rect.Y, rect.Width, rect.Height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a series of rectangles to this path.</summary>
		/// <param name="rects">An array of <see cref="T:System.Drawing.RectangleF" /> structures that represents the rectangles to add.</param>
		public void AddRectangles(RectangleF[] rects)
		{
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathRectangles(new HandleRef(this, nativePath), new HandleRef(null, intPtr), rects.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a rectangle to this path.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle to add.</param>
		public void AddRectangle(Rectangle rect)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathRectangleI(new HandleRef(this, nativePath), rect.X, rect.Y, rect.Width, rect.Height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a series of rectangles to this path.</summary>
		/// <param name="rects">An array of <see cref="T:System.Drawing.Rectangle" /> structures that represents the rectangles to add.</param>
		public void AddRectangles(Rectangle[] rects)
		{
			if (rects == null)
			{
				throw new ArgumentNullException("rects");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertRectangleToMemory(rects);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathRectanglesI(new HandleRef(this, nativePath), new HandleRef(null, intPtr), rects.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds an ellipse to the current path.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> that represents the bounding rectangle that defines the ellipse.</param>
		public void AddEllipse(RectangleF rect)
		{
			AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Adds an ellipse to the current path.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">The width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">The height of the bounding rectangle that defines the ellipse.</param>
		public void AddEllipse(float x, float y, float width, float height)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathEllipse(new HandleRef(this, nativePath), x, y, width, height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds an ellipse to the current path.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> that represents the bounding rectangle that defines the ellipse.</param>
		public void AddEllipse(Rectangle rect)
		{
			AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
		}

		/// <summary>Adds an ellipse to the current path.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse.</param>
		/// <param name="width">The width of the bounding rectangle that defines the ellipse.</param>
		/// <param name="height">The height of the bounding rectangle that defines the ellipse.</param>
		public void AddEllipse(int x, int y, int width, int height)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathEllipseI(new HandleRef(this, nativePath), x, y, width, height);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds the outline of a pie shape to this path.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> that represents the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="startAngle">The starting angle for the pie section, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the pie section, measured in degrees clockwise from <paramref name="startAngle" />.</param>
		public void AddPie(Rectangle rect, float startAngle, float sweepAngle)
		{
			AddPie(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
		}

		/// <summary>Adds the outline of a pie shape to this path.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="width">The width of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="height">The height of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="startAngle">The starting angle for the pie section, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the pie section, measured in degrees clockwise from <paramref name="startAngle" />.</param>
		public void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathPie(new HandleRef(this, nativePath), x, y, width, height, startAngle, sweepAngle);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds the outline of a pie shape to this path.</summary>
		/// <param name="x">The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="y">The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="width">The width of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="height">The height of the bounding rectangle that defines the ellipse from which the pie is drawn.</param>
		/// <param name="startAngle">The starting angle for the pie section, measured in degrees clockwise from the x-axis.</param>
		/// <param name="sweepAngle">The angle between <paramref name="startAngle" /> and the end of the pie section, measured in degrees clockwise from <paramref name="startAngle" />.</param>
		public void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle)
		{
			int num = SafeNativeMethods.Gdip.GdipAddPathPieI(new HandleRef(this, nativePath), x, y, width, height, startAngle, sweepAngle);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a polygon to this path.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that defines the polygon to add.</param>
		public void AddPolygon(PointF[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathPolygon(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Adds a polygon to this path.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that defines the polygon to add.</param>
		public void AddPolygon(Point[] points)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipAddPathPolygonI(new HandleRef(this, nativePath), new HandleRef(null, intPtr), points.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Appends the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to this path.</summary>
		/// <param name="addingPath">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to add.</param>
		/// <param name="connect">A Boolean value that specifies whether the first figure in the added path is part of the last figure in this path. A value of <see langword="true" /> specifies that (if possible) the first figure in the added path is part of the last figure in this path. A value of <see langword="false" /> specifies that the first figure in the added path is separate from the last figure in this path.</param>
		public void AddPath(GraphicsPath addingPath, bool connect)
		{
			if (addingPath == null)
			{
				throw new ArgumentNullException("addingPath");
			}
			int num = SafeNativeMethods.Gdip.GdipAddPathPath(new HandleRef(this, nativePath), new HandleRef(addingPath, addingPath.nativePath), connect);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a text string to this path.</summary>
		/// <param name="s">The <see cref="T:System.String" /> to add.</param>
		/// <param name="family">A <see cref="T:System.Drawing.FontFamily" /> that represents the name of the font with which the test is drawn.</param>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> enumeration that represents style information about the text (bold, italic, and so on). This must be cast as an integer (see the example code later in this section).</param>
		/// <param name="emSize">The height of the em square box that bounds the character.</param>
		/// <param name="origin">A <see cref="T:System.Drawing.PointF" /> that represents the point where the text starts.</param>
		/// <param name="format">A <see cref="T:System.Drawing.StringFormat" /> that specifies text formatting information, such as line spacing and alignment.</param>
		public void AddString(string s, FontFamily family, int style, float emSize, PointF origin, StringFormat format)
		{
			GPRECTF layoutRect = new GPRECTF(origin.X, origin.Y, 0f, 0f);
			int num = SafeNativeMethods.Gdip.GdipAddPathString(new HandleRef(this, nativePath), s, s.Length, new HandleRef(family, family?.NativeFamily ?? IntPtr.Zero), style, emSize, ref layoutRect, new HandleRef(format, format?.nativeFormat ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a text string to this path.</summary>
		/// <param name="s">The <see cref="T:System.String" /> to add.</param>
		/// <param name="family">A <see cref="T:System.Drawing.FontFamily" /> that represents the name of the font with which the test is drawn.</param>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> enumeration that represents style information about the text (bold, italic, and so on). This must be cast as an integer (see the example code later in this section).</param>
		/// <param name="emSize">The height of the em square box that bounds the character.</param>
		/// <param name="origin">A <see cref="T:System.Drawing.Point" /> that represents the point where the text starts.</param>
		/// <param name="format">A <see cref="T:System.Drawing.StringFormat" /> that specifies text formatting information, such as line spacing and alignment.</param>
		public void AddString(string s, FontFamily family, int style, float emSize, Point origin, StringFormat format)
		{
			GPRECT layoutRect = new GPRECT(origin.X, origin.Y, 0, 0);
			int num = SafeNativeMethods.Gdip.GdipAddPathStringI(new HandleRef(this, nativePath), s, s.Length, new HandleRef(family, family?.NativeFamily ?? IntPtr.Zero), style, emSize, ref layoutRect, new HandleRef(format, format?.nativeFormat ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a text string to this path.</summary>
		/// <param name="s">The <see cref="T:System.String" /> to add.</param>
		/// <param name="family">A <see cref="T:System.Drawing.FontFamily" /> that represents the name of the font with which the test is drawn.</param>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> enumeration that represents style information about the text (bold, italic, and so on). This must be cast as an integer (see the example code later in this section).</param>
		/// <param name="emSize">The height of the em square box that bounds the character.</param>
		/// <param name="layoutRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that bounds the text.</param>
		/// <param name="format">A <see cref="T:System.Drawing.StringFormat" /> that specifies text formatting information, such as line spacing and alignment.</param>
		public void AddString(string s, FontFamily family, int style, float emSize, RectangleF layoutRect, StringFormat format)
		{
			GPRECTF layoutRect2 = new GPRECTF(layoutRect);
			int num = SafeNativeMethods.Gdip.GdipAddPathString(new HandleRef(this, nativePath), s, s.Length, new HandleRef(family, family?.NativeFamily ?? IntPtr.Zero), style, emSize, ref layoutRect2, new HandleRef(format, format?.nativeFormat ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds a text string to this path.</summary>
		/// <param name="s">The <see cref="T:System.String" /> to add.</param>
		/// <param name="family">A <see cref="T:System.Drawing.FontFamily" /> that represents the name of the font with which the test is drawn.</param>
		/// <param name="style">A <see cref="T:System.Drawing.FontStyle" /> enumeration that represents style information about the text (bold, italic, and so on). This must be cast as an integer (see the example code later in this section).</param>
		/// <param name="emSize">The height of the em square box that bounds the character.</param>
		/// <param name="layoutRect">A <see cref="T:System.Drawing.Rectangle" /> that represents the rectangle that bounds the text.</param>
		/// <param name="format">A <see cref="T:System.Drawing.StringFormat" /> that specifies text formatting information, such as line spacing and alignment.</param>
		public void AddString(string s, FontFamily family, int style, float emSize, Rectangle layoutRect, StringFormat format)
		{
			GPRECT layoutRect2 = new GPRECT(layoutRect);
			int num = SafeNativeMethods.Gdip.GdipAddPathStringI(new HandleRef(this, nativePath), s, s.Length, new HandleRef(family, family?.NativeFamily ?? IntPtr.Zero), style, emSize, ref layoutRect2, new HandleRef(format, format?.nativeFormat ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Applies a transform matrix to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents the transformation to apply.</param>
		public void Transform(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			if (!(matrix.nativeMatrix == IntPtr.Zero))
			{
				int num = SafeNativeMethods.Gdip.GdipTransformPath(new HandleRef(this, nativePath), new HandleRef(matrix, matrix.nativeMatrix));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Returns a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> that represents a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
		public RectangleF GetBounds()
		{
			return GetBounds(null);
		}

		/// <summary>Returns a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when this path is transformed by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a transformation to be applied to this path before the bounding rectangle is calculated. This path is not permanently transformed; the transformation is used only during the process of calculating the bounding rectangle.</param>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> that represents a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
		public RectangleF GetBounds(Matrix matrix)
		{
			return GetBounds(matrix, null);
		}

		/// <summary>Returns a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> when the current path is transformed by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> and drawn with the specified <see cref="T:System.Drawing.Pen" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a transformation to be applied to this path before the bounding rectangle is calculated. This path is not permanently transformed; the transformation is used only during the process of calculating the bounding rectangle.</param>
		/// <param name="pen">The <see cref="T:System.Drawing.Pen" /> with which to draw the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> that represents a rectangle that bounds this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
		public RectangleF GetBounds(Matrix matrix, Pen pen)
		{
			GPRECTF gprectf = default(GPRECTF);
			IntPtr handle = IntPtr.Zero;
			IntPtr handle2 = IntPtr.Zero;
			if (matrix != null)
			{
				handle = matrix.nativeMatrix;
			}
			if (pen != null)
			{
				handle2 = pen.NativePen;
			}
			int num = SafeNativeMethods.Gdip.GdipGetPathWorldBounds(new HandleRef(this, nativePath), ref gprectf, new HandleRef(matrix, handle), new HandleRef(pen, handle2));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gprectf.ToRectangleF();
		}

		/// <summary>Converts each curve in this path into a sequence of connected line segments.</summary>
		public void Flatten()
		{
			Flatten(null);
		}

		/// <summary>Applies the specified transform and then converts each curve in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> into a sequence of connected line segments.</summary>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to transform this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> before flattening.</param>
		public void Flatten(Matrix matrix)
		{
			Flatten(matrix, 0.25f);
		}

		/// <summary>Converts each curve in this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> into a sequence of connected line segments.</summary>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to transform this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> before flattening.</param>
		/// <param name="flatness">Specifies the maximum permitted error between the curve and its flattened approximation. A value of 0.25 is the default. Reducing the flatness value will increase the number of line segments in the approximation.</param>
		public void Flatten(Matrix matrix, float flatness)
		{
			int num = SafeNativeMethods.Gdip.GdipFlattenPath(new HandleRef(this, nativePath), new HandleRef(matrix, matrix?.nativeMatrix ?? IntPtr.Zero), flatness);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Adds an additional outline to the path.</summary>
		/// <param name="pen">A <see cref="T:System.Drawing.Pen" /> that specifies the width between the original outline of the path and the new outline this method creates.</param>
		public void Widen(Pen pen)
		{
			float flatness = 2f / 3f;
			Widen(pen, null, flatness);
		}

		/// <summary>Adds an additional outline to the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="pen">A <see cref="T:System.Drawing.Pen" /> that specifies the width between the original outline of the path and the new outline this method creates.</param>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a transform to apply to the path before widening.</param>
		public void Widen(Pen pen, Matrix matrix)
		{
			float flatness = 2f / 3f;
			Widen(pen, matrix, flatness);
		}

		/// <summary>Replaces this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> with curves that enclose the area that is filled when this path is drawn by the specified pen.</summary>
		/// <param name="pen">A <see cref="T:System.Drawing.Pen" /> that specifies the width between the original outline of the path and the new outline this method creates.</param>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a transform to apply to the path before widening.</param>
		/// <param name="flatness">A value that specifies the flatness for curves.</param>
		public void Widen(Pen pen, Matrix matrix, float flatness)
		{
			IntPtr handle = matrix?.nativeMatrix ?? IntPtr.Zero;
			if (pen == null)
			{
				throw new ArgumentNullException("pen");
			}
			SafeNativeMethods.Gdip.GdipGetPointCount(new HandleRef(this, nativePath), out var count);
			if (count != 0)
			{
				int num = SafeNativeMethods.Gdip.GdipWidenPath(new HandleRef(this, nativePath), new HandleRef(pen, pen.NativePen), new HandleRef(matrix, handle), flatness);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Applies a warp transform, defined by a rectangle and a parallelogram, to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="destPoints">An array of <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram to which the rectangle defined by <paramref name="srcRect" /> is transformed. The array can contain either three or four elements. If the array contains three elements, the lower-right corner of the parallelogram is implied by the first three points.</param>
		/// <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that is transformed to the parallelogram defined by <paramref name="destPoints" />.</param>
		public void Warp(PointF[] destPoints, RectangleF srcRect)
		{
			Warp(destPoints, srcRect, null);
		}

		/// <summary>Applies a warp transform, defined by a rectangle and a parallelogram, to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="destPoints">An array of <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram to which the rectangle defined by <paramref name="srcRect" /> is transformed. The array can contain either three or four elements. If the array contains three elements, the lower-right corner of the parallelogram is implied by the first three points.</param>
		/// <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that is transformed to the parallelogram defined by <paramref name="destPoints" />.</param>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a geometric transform to apply to the path.</param>
		public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix)
		{
			Warp(destPoints, srcRect, matrix, WarpMode.Perspective);
		}

		/// <summary>Applies a warp transform, defined by a rectangle and a parallelogram, to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="destPoints">An array of <see cref="T:System.Drawing.PointF" /> structures that defines a parallelogram to which the rectangle defined by <paramref name="srcRect" /> is transformed. The array can contain either three or four elements. If the array contains three elements, the lower-right corner of the parallelogram is implied by the first three points.</param>
		/// <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that is transformed to the parallelogram defined by <paramref name="destPoints" />.</param>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a geometric transform to apply to the path.</param>
		/// <param name="warpMode">A <see cref="T:System.Drawing.Drawing2D.WarpMode" /> enumeration that specifies whether this warp operation uses perspective or bilinear mode.</param>
		public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode)
		{
			Warp(destPoints, srcRect, matrix, warpMode, 0.25f);
		}

		/// <summary>Applies a warp transform, defined by a rectangle and a parallelogram, to this <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
		/// <param name="destPoints">An array of <see cref="T:System.Drawing.PointF" /> structures that define a parallelogram to which the rectangle defined by <paramref name="srcRect" /> is transformed. The array can contain either three or four elements. If the array contains three elements, the lower-right corner of the parallelogram is implied by the first three points.</param>
		/// <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> that represents the rectangle that is transformed to the parallelogram defined by <paramref name="destPoints" />.</param>
		/// <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> that specifies a geometric transform to apply to the path.</param>
		/// <param name="warpMode">A <see cref="T:System.Drawing.Drawing2D.WarpMode" /> enumeration that specifies whether this warp operation uses perspective or bilinear mode.</param>
		/// <param name="flatness">A value from 0 through 1 that specifies how flat the resulting path is. For more information, see the <see cref="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" /> methods.</param>
		public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode, float flatness)
		{
			if (destPoints == null)
			{
				throw new ArgumentNullException("destPoints");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(destPoints);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipWarpPath(new HandleRef(this, nativePath), new HandleRef(matrix, matrix?.nativeMatrix ?? IntPtr.Zero), new HandleRef(null, intPtr), destPoints.Length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, warpMode, flatness);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}
	}
	/// <summary>Provides the ability to iterate through subpaths in a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> and test the types of shapes contained in each subpath. This class cannot be inherited.</summary>
	public sealed class GraphicsPathIterator : MarshalByRefObject, IDisposable
	{
		internal IntPtr nativeIter;

		/// <summary>Gets the number of points in the path.</summary>
		/// <returns>The number of points in the path.</returns>
		public int Count
		{
			get
			{
				int count = 0;
				int num = SafeNativeMethods.Gdip.GdipPathIterGetCount(new HandleRef(this, nativeIter), out count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return count;
			}
		}

		/// <summary>Gets the number of subpaths in the path.</summary>
		/// <returns>The number of subpaths in the path.</returns>
		public int SubpathCount
		{
			get
			{
				int count = 0;
				int num = SafeNativeMethods.Gdip.GdipPathIterGetSubpathCount(new HandleRef(this, nativeIter), out count);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return count;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> class with the specified <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object for which this helper class is to be initialized.</param>
		public GraphicsPathIterator(GraphicsPath path)
		{
			IntPtr pathIter = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreatePathIter(out pathIter, new HandleRef(path, path?.nativePath ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeIter = pathIter;
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> object.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!(nativeIter != IntPtr.Zero))
			{
				return;
			}
			try
			{
				SafeNativeMethods.Gdip.GdipDeletePathIter(new HandleRef(this, nativeIter));
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				nativeIter = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~GraphicsPathIterator()
		{
			Dispose(disposing: false);
		}

		/// <summary>Moves the <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> to the next subpath in the path. The start index and end index of the next subpath are contained in the [out] parameters.</summary>
		/// <param name="startIndex">[out] Receives the starting index of the next subpath.</param>
		/// <param name="endIndex">[out] Receives the ending index of the next subpath.</param>
		/// <param name="isClosed">[out] Indicates whether the subpath is closed.</param>
		/// <returns>The number of subpaths in the <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object.</returns>
		public int NextSubpath(out int startIndex, out int endIndex, out bool isClosed)
		{
			int resultCount = 0;
			int startIndex2 = 0;
			int endIndex2 = 0;
			int num = SafeNativeMethods.Gdip.GdipPathIterNextSubpath(new HandleRef(this, nativeIter), out resultCount, out startIndex2, out endIndex2, out isClosed);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			startIndex = startIndex2;
			endIndex = endIndex2;
			return resultCount;
		}

		/// <summary>Gets the next figure (subpath) from the associated path of this <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" />.</summary>
		/// <param name="path">A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that is to have its data points set to match the data points of the retrieved figure (subpath) for this iterator.</param>
		/// <param name="isClosed">[out] Indicates whether the current subpath is closed. It is <see langword="true" /> if the if the figure is closed, otherwise it is <see langword="false" />.</param>
		/// <returns>The number of data points in the retrieved figure (subpath). If there are no more figures to retrieve, zero is returned.</returns>
		public int NextSubpath(GraphicsPath path, out bool isClosed)
		{
			int resultCount = 0;
			int num = SafeNativeMethods.Gdip.GdipPathIterNextSubpathPath(new HandleRef(this, nativeIter), out resultCount, new HandleRef(path, path?.nativePath ?? IntPtr.Zero), out isClosed);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		/// <summary>Gets the starting index and the ending index of the next group of data points that all have the same type.</summary>
		/// <param name="pathType">[out] Receives the point type shared by all points in the group. Possible types can be retrieved from the <see cref="T:System.Drawing.Drawing2D.PathPointType" /> enumeration.</param>
		/// <param name="startIndex">[out] Receives the starting index of the group of points.</param>
		/// <param name="endIndex">[out] Receives the ending index of the group of points.</param>
		/// <returns>This method returns the number of data points in the group. If there are no more groups in the path, this method returns 0.</returns>
		public int NextPathType(out byte pathType, out int startIndex, out int endIndex)
		{
			int resultCount = 0;
			int num = SafeNativeMethods.Gdip.GdipPathIterNextPathType(new HandleRef(this, nativeIter), out resultCount, out pathType, out startIndex, out endIndex);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		/// <summary>Increments the <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> to the next marker in the path and returns the start and stop indexes by way of the [out] parameters.</summary>
		/// <param name="startIndex">[out] The integer reference supplied to this parameter receives the index of the point that starts a subpath.</param>
		/// <param name="endIndex">[out] The integer reference supplied to this parameter receives the index of the point that ends the subpath to which <paramref name="startIndex" /> points.</param>
		/// <returns>The number of points between this marker and the next.</returns>
		public int NextMarker(out int startIndex, out int endIndex)
		{
			int resultCount = 0;
			int num = SafeNativeMethods.Gdip.GdipPathIterNextMarker(new HandleRef(this, nativeIter), out resultCount, out startIndex, out endIndex);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		/// <summary>This <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> object has a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object associated with it. The <see cref="M:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker(System.Drawing.Drawing2D.GraphicsPath)" /> method increments the associated <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> to the next marker in its path and copies all the points contained between the current marker and the next marker (or end of path) to a second <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object passed in to the parameter.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object to which the points will be copied.</param>
		/// <returns>The number of points between this marker and the next.</returns>
		public int NextMarker(GraphicsPath path)
		{
			int resultCount = 0;
			int num = SafeNativeMethods.Gdip.GdipPathIterNextMarkerPath(new HandleRef(this, nativeIter), out resultCount, new HandleRef(path, path?.nativePath ?? IntPtr.Zero));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return resultCount;
		}

		/// <summary>Indicates whether the path associated with this <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> contains a curve.</summary>
		/// <returns>This method returns <see langword="true" /> if the current subpath contains a curve; otherwise, <see langword="false" />.</returns>
		public bool HasCurve()
		{
			bool hasCurve = false;
			int num = SafeNativeMethods.Gdip.GdipPathIterHasCurve(new HandleRef(this, nativeIter), out hasCurve);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return hasCurve;
		}

		/// <summary>Rewinds this <see cref="T:System.Drawing.Drawing2D.GraphicsPathIterator" /> to the beginning of its associated path.</summary>
		public void Rewind()
		{
			int num = SafeNativeMethods.Gdip.GdipPathIterRewind(new HandleRef(this, nativeIter));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Copies the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> property and <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> property arrays of the associated <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> into the two specified arrays.</summary>
		/// <param name="points">Upon return, contains an array of <see cref="T:System.Drawing.PointF" /> structures that represents the points in the path.</param>
		/// <param name="types">Upon return, contains an array of bytes that represents the types of points in the path.</param>
		/// <returns>The number of points copied.</returns>
		public int Enumerate(ref PointF[] points, ref byte[] types)
		{
			if (points.Length != types.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int resultCount = 0;
			int num = Marshal.SizeOf(typeof(GPPOINTF));
			int num2 = points.Length;
			byte[] array = new byte[num2];
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
			try
			{
				int num3 = SafeNativeMethods.Gdip.GdipPathIterEnumerate(new HandleRef(this, nativeIter), out resultCount, intPtr, array, num2);
				if (num3 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num3);
				}
				if (resultCount < num2)
				{
					SafeNativeMethods.ZeroMemory((IntPtr)checked((long)intPtr + resultCount * num), (UIntPtr)(ulong)((num2 - resultCount) * num));
				}
				points = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, num2);
				array.CopyTo(types, 0);
				return resultCount;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Copies the <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> property and <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> property arrays of the associated <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> into the two specified arrays.</summary>
		/// <param name="points">Upon return, contains an array of <see cref="T:System.Drawing.PointF" /> structures that represents the points in the path.</param>
		/// <param name="types">Upon return, contains an array of bytes that represents the types of points in the path.</param>
		/// <param name="startIndex">Specifies the starting index of the arrays.</param>
		/// <param name="endIndex">Specifies the ending index of the arrays.</param>
		/// <returns>The number of points copied.</returns>
		public int CopyData(ref PointF[] points, ref byte[] types, int startIndex, int endIndex)
		{
			if (points.Length != types.Length || endIndex - startIndex + 1 > points.Length)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			int resultCount = 0;
			int num = Marshal.SizeOf(typeof(GPPOINTF));
			int num2 = points.Length;
			byte[] array = new byte[num2];
			IntPtr intPtr = Marshal.AllocHGlobal(checked(num2 * num));
			try
			{
				int num3 = SafeNativeMethods.Gdip.GdipPathIterCopyData(new HandleRef(this, nativeIter), out resultCount, intPtr, array, startIndex, endIndex);
				if (num3 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num3);
				}
				if (resultCount < num2)
				{
					SafeNativeMethods.ZeroMemory((IntPtr)checked((long)intPtr + resultCount * num), (UIntPtr)(ulong)((num2 - resultCount) * num));
				}
				points = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, num2);
				array.CopyTo(types, 0);
				return resultCount;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}
	}
	/// <summary>Represents the state of a <see cref="T:System.Drawing.Graphics" /> object. This object is returned by a call to the <see cref="M:System.Drawing.Graphics.Save" /> methods. This class cannot be inherited.</summary>
	public sealed class GraphicsState : MarshalByRefObject
	{
		internal int nativeState;

		internal GraphicsState(int nativeState)
		{
			this.nativeState = nativeState;
		}
	}
	/// <summary>Defines a rectangular brush with a hatch style, a foreground color, and a background color. This class cannot be inherited.</summary>
	public sealed class HatchBrush : Brush
	{
		/// <summary>Gets the hatch style of this <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> object.</summary>
		/// <returns>One of the <see cref="T:System.Drawing.Drawing2D.HatchStyle" /> values that represents the pattern of this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</returns>
		public HatchStyle HatchStyle
		{
			get
			{
				int hatchstyle = 0;
				int num = SafeNativeMethods.Gdip.GdipGetHatchStyle(new HandleRef(this, base.NativeBrush), out hatchstyle);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return (HatchStyle)hatchstyle;
			}
		}

		/// <summary>Gets the color of hatch lines drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the foreground color for this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</returns>
		public Color ForegroundColor
		{
			get
			{
				int forecol;
				int num = SafeNativeMethods.Gdip.GdipGetHatchForegroundColor(new HandleRef(this, base.NativeBrush), out forecol);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return Color.FromArgb(forecol);
			}
		}

		/// <summary>Gets the color of spaces between the hatch lines drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> object.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> structure that represents the background color for this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</returns>
		public Color BackgroundColor
		{
			get
			{
				int backcol;
				int num = SafeNativeMethods.Gdip.GdipGetHatchBackgroundColor(new HandleRef(this, base.NativeBrush), out backcol);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return Color.FromArgb(backcol);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> class with the specified <see cref="T:System.Drawing.Drawing2D.HatchStyle" /> enumeration and foreground color.</summary>
		/// <param name="hatchstyle">One of the <see cref="T:System.Drawing.Drawing2D.HatchStyle" /> values that represents the pattern drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</param>
		/// <param name="foreColor">The <see cref="T:System.Drawing.Color" /> structure that represents the color of lines drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</param>
		public HatchBrush(HatchStyle hatchstyle, Color foreColor)
			: this(hatchstyle, foreColor, Color.FromArgb(-16777216))
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> class with the specified <see cref="T:System.Drawing.Drawing2D.HatchStyle" /> enumeration, foreground color, and background color.</summary>
		/// <param name="hatchstyle">One of the <see cref="T:System.Drawing.Drawing2D.HatchStyle" /> values that represents the pattern drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</param>
		/// <param name="foreColor">The <see cref="T:System.Drawing.Color" /> structure that represents the color of lines drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</param>
		/// <param name="backColor">The <see cref="T:System.Drawing.Color" /> structure that represents the color of spaces between the lines drawn by this <see cref="T:System.Drawing.Drawing2D.HatchBrush" />.</param>
		public HatchBrush(HatchStyle hatchstyle, Color foreColor, Color backColor)
		{
			IntPtr brush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateHatchBrush((int)hatchstyle, foreColor.ToArgb(), backColor.ToArgb(), out brush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(brush);
		}

		internal HatchBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> object.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> this method creates, cast as an object.</returns>
		public override object Clone()
		{
			IntPtr clonebrush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonebrush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new HatchBrush(clonebrush);
		}
	}
	/// <summary>Specifies the different patterns available for <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> objects.</summary>
	public enum HatchStyle
	{
		/// <summary>A pattern of horizontal lines.</summary>
		Horizontal = 0,
		/// <summary>A pattern of vertical lines.</summary>
		Vertical = 1,
		/// <summary>A pattern of lines on a diagonal from upper left to lower right.</summary>
		ForwardDiagonal = 2,
		/// <summary>A pattern of lines on a diagonal from upper right to lower left.</summary>
		BackwardDiagonal = 3,
		/// <summary>Specifies horizontal and vertical lines that cross.</summary>
		Cross = 4,
		/// <summary>A pattern of crisscross diagonal lines.</summary>
		DiagonalCross = 5,
		/// <summary>Specifies a 5-percent hatch. The ratio of foreground color to background color is 5:95.</summary>
		Percent05 = 6,
		/// <summary>Specifies a 10-percent hatch. The ratio of foreground color to background color is 10:90.</summary>
		Percent10 = 7,
		/// <summary>Specifies a 20-percent hatch. The ratio of foreground color to background color is 20:80.</summary>
		Percent20 = 8,
		/// <summary>Specifies a 25-percent hatch. The ratio of foreground color to background color is 25:75.</summary>
		Percent25 = 9,
		/// <summary>Specifies a 30-percent hatch. The ratio of foreground color to background color is 30:70.</summary>
		Percent30 = 10,
		/// <summary>Specifies a 40-percent hatch. The ratio of foreground color to background color is 40:60.</summary>
		Percent40 = 11,
		/// <summary>Specifies a 50-percent hatch. The ratio of foreground color to background color is 50:50.</summary>
		Percent50 = 12,
		/// <summary>Specifies a 60-percent hatch. The ratio of foreground color to background color is 60:40.</summary>
		Percent60 = 13,
		/// <summary>Specifies a 70-percent hatch. The ratio of foreground color to background color is 70:30.</summary>
		Percent70 = 14,
		/// <summary>Specifies a 75-percent hatch. The ratio of foreground color to background color is 75:25.</summary>
		Percent75 = 15,
		/// <summary>Specifies a 80-percent hatch. The ratio of foreground color to background color is 80:100.</summary>
		Percent80 = 16,
		/// <summary>Specifies a 90-percent hatch. The ratio of foreground color to background color is 90:10.</summary>
		Percent90 = 17,
		/// <summary>Specifies diagonal lines that slant to the right from top points to bottom points and are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal" />, but are not antialiased.</summary>
		LightDownwardDiagonal = 18,
		/// <summary>Specifies diagonal lines that slant to the left from top points to bottom points and are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal" />, but they are not antialiased.</summary>
		LightUpwardDiagonal = 19,
		/// <summary>Specifies diagonal lines that slant to the right from top points to bottom points, are spaced 50 percent closer together than, and are twice the width of <see cref="F:System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal" />. This hatch pattern is not antialiased.</summary>
		DarkDownwardDiagonal = 20,
		/// <summary>Specifies diagonal lines that slant to the left from top points to bottom points, are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal" />, and are twice its width, but the lines are not antialiased.</summary>
		DarkUpwardDiagonal = 21,
		/// <summary>Specifies diagonal lines that slant to the right from top points to bottom points, have the same spacing as hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.ForwardDiagonal" />, and are triple its width, but are not antialiased.</summary>
		WideDownwardDiagonal = 22,
		/// <summary>Specifies diagonal lines that slant to the left from top points to bottom points, have the same spacing as hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal" />, and are triple its width, but are not antialiased.</summary>
		WideUpwardDiagonal = 23,
		/// <summary>Specifies vertical lines that are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.Vertical" />.</summary>
		LightVertical = 24,
		/// <summary>Specifies horizontal lines that are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.Horizontal" />.</summary>
		LightHorizontal = 25,
		/// <summary>Specifies vertical lines that are spaced 75 percent closer together than hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.Vertical" /> (or 25 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.LightVertical" />).</summary>
		NarrowVertical = 26,
		/// <summary>Specifies horizontal lines that are spaced 75 percent closer together than hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.Horizontal" /> (or 25 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.LightHorizontal" />).</summary>
		NarrowHorizontal = 27,
		/// <summary>Specifies vertical lines that are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.Vertical" /> and are twice its width.</summary>
		DarkVertical = 28,
		/// <summary>Specifies horizontal lines that are spaced 50 percent closer together than <see cref="F:System.Drawing.Drawing2D.HatchStyle.Horizontal" /> and are twice the width of <see cref="F:System.Drawing.Drawing2D.HatchStyle.Horizontal" />.</summary>
		DarkHorizontal = 29,
		/// <summary>Specifies dashed diagonal lines, that slant to the right from top points to bottom points.</summary>
		DashedDownwardDiagonal = 30,
		/// <summary>Specifies dashed diagonal lines, that slant to the left from top points to bottom points.</summary>
		DashedUpwardDiagonal = 31,
		/// <summary>Specifies dashed horizontal lines.</summary>
		DashedHorizontal = 32,
		/// <summary>Specifies dashed vertical lines.</summary>
		DashedVertical = 33,
		/// <summary>Specifies a hatch that has the appearance of confetti.</summary>
		SmallConfetti = 34,
		/// <summary>Specifies a hatch that has the appearance of confetti, and is composed of larger pieces than <see cref="F:System.Drawing.Drawing2D.HatchStyle.SmallConfetti" />.</summary>
		LargeConfetti = 35,
		/// <summary>Specifies horizontal lines that are composed of zigzags.</summary>
		ZigZag = 36,
		/// <summary>Specifies horizontal lines that are composed of tildes.</summary>
		Wave = 37,
		/// <summary>Specifies a hatch that has the appearance of layered bricks that slant to the left from top points to bottom points.</summary>
		DiagonalBrick = 38,
		/// <summary>Specifies a hatch that has the appearance of horizontally layered bricks.</summary>
		HorizontalBrick = 39,
		/// <summary>Specifies a hatch that has the appearance of a woven material.</summary>
		Weave = 40,
		/// <summary>Specifies a hatch that has the appearance of a plaid material.</summary>
		Plaid = 41,
		/// <summary>Specifies a hatch that has the appearance of divots.</summary>
		Divot = 42,
		/// <summary>Specifies horizontal and vertical lines, each of which is composed of dots, that cross.</summary>
		DottedGrid = 43,
		/// <summary>Specifies forward diagonal and backward diagonal lines, each of which is composed of dots, that cross.</summary>
		DottedDiamond = 44,
		/// <summary>Specifies a hatch that has the appearance of diagonally layered shingles that slant to the right from top points to bottom points.</summary>
		Shingle = 45,
		/// <summary>Specifies a hatch that has the appearance of a trellis.</summary>
		Trellis = 46,
		/// <summary>Specifies a hatch that has the appearance of spheres laid adjacent to one another.</summary>
		Sphere = 47,
		/// <summary>Specifies horizontal and vertical lines that cross and are spaced 50 percent closer together than hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.Cross" />.</summary>
		SmallGrid = 48,
		/// <summary>Specifies a hatch that has the appearance of a checkerboard.</summary>
		SmallCheckerBoard = 49,
		/// <summary>Specifies a hatch that has the appearance of a checkerboard with squares that are twice the size of <see cref="F:System.Drawing.Drawing2D.HatchStyle.SmallCheckerBoard" />.</summary>
		LargeCheckerBoard = 50,
		/// <summary>Specifies forward diagonal and backward diagonal lines that cross but are not antialiased.</summary>
		OutlinedDiamond = 51,
		/// <summary>Specifies a hatch that has the appearance of a checkerboard placed diagonally.</summary>
		SolidDiamond = 52,
		/// <summary>Specifies the hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.Cross" />.</summary>
		LargeGrid = 4,
		/// <summary>Specifies hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.Horizontal" />.</summary>
		Min = 0,
		/// <summary>Specifies hatch style <see cref="F:System.Drawing.Drawing2D.HatchStyle.SolidDiamond" />.</summary>
		Max = 4
	}
	/// <summary>The <see cref="T:System.Drawing.Drawing2D.InterpolationMode" /> enumeration specifies the algorithm that is used when images are scaled or rotated.</summary>
	public enum InterpolationMode
	{
		/// <summary>Equivalent to the <see cref="F:System.Drawing.Drawing2D.QualityMode.Invalid" /> element of the <see cref="T:System.Drawing.Drawing2D.QualityMode" /> enumeration.</summary>
		Invalid = -1,
		/// <summary>Specifies default mode.</summary>
		Default,
		/// <summary>Specifies low quality interpolation.</summary>
		Low,
		/// <summary>Specifies high quality interpolation.</summary>
		High,
		/// <summary>Specifies bilinear interpolation. No prefiltering is done. This mode is not suitable for shrinking an image below 50 percent of its original size.</summary>
		Bilinear,
		/// <summary>Specifies bicubic interpolation. No prefiltering is done. This mode is not suitable for shrinking an image below 25 percent of its original size.</summary>
		Bicubic,
		/// <summary>Specifies nearest-neighbor interpolation.</summary>
		NearestNeighbor,
		/// <summary>Specifies high-quality, bilinear interpolation. Prefiltering is performed to ensure high-quality shrinking.</summary>
		HighQualityBilinear,
		/// <summary>Specifies high-quality, bicubic interpolation. Prefiltering is performed to ensure high-quality shrinking. This mode produces the highest quality transformed images.</summary>
		HighQualityBicubic
	}
	/// <summary>Encapsulates a <see cref="T:System.Drawing.Brush" /> with a linear gradient. This class cannot be inherited.</summary>
	public sealed class LinearGradientBrush : Brush
	{
		private bool interpolationColorsWasSet;

		/// <summary>Gets or sets the starting and ending colors of the gradient.</summary>
		/// <returns>An array of two <see cref="T:System.Drawing.Color" /> structures that represents the starting and ending colors of the gradient.</returns>
		public Color[] LinearColors
		{
			get
			{
				return _GetLinearColors();
			}
			set
			{
				_SetLinearColors(value[0], value[1]);
			}
		}

		/// <summary>Gets a rectangular region that defines the starting and ending points of the gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> structure that specifies the starting and ending points of the gradient.</returns>
		public RectangleF Rectangle => _GetRectangle();

		/// <summary>Gets or sets a value indicating whether gamma correction is enabled for this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />.</summary>
		/// <returns>The value is <see langword="true" /> if gamma correction is enabled for this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />; otherwise, <see langword="false" />.</returns>
		public bool GammaCorrection
		{
			get
			{
				bool useGammaCorrection;
				int num = SafeNativeMethods.Gdip.GdipGetLineGammaCorrection(new HandleRef(this, base.NativeBrush), out useGammaCorrection);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return useGammaCorrection;
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetLineGammaCorrection(new HandleRef(this, base.NativeBrush), value);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.Blend" /> that specifies positions and factors that define a custom falloff for the gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.Blend" /> that represents a custom falloff for the gradient.</returns>
		public Blend Blend
		{
			get
			{
				return _GetBlend();
			}
			set
			{
				_SetBlend(value);
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> that defines a multicolor linear gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> that defines a multicolor linear gradient.</returns>
		public ColorBlend InterpolationColors
		{
			get
			{
				return _GetInterpolationColors();
			}
			set
			{
				_SetInterpolationColors(value);
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.WrapMode" /> enumeration that indicates the wrap mode for this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how fills drawn with this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> are tiled.</returns>
		public WrapMode WrapMode
		{
			get
			{
				return _GetWrapMode();
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(WrapMode));
				}
				_SetWrapMode(value);
			}
		}

		/// <summary>Gets or sets a copy <see cref="T:System.Drawing.Drawing2D.Matrix" /> that defines a local geometric transform for this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />.</summary>
		/// <returns>A copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that defines a geometric transform that applies only to fills drawn with this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />.</returns>
		public Matrix Transform
		{
			get
			{
				return _GetTransform();
			}
			set
			{
				_SetTransform(value);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class with the specified points and colors.</summary>
		/// <param name="point1">A <see cref="T:System.Drawing.PointF" /> structure that represents the starting point of the linear gradient.</param>
		/// <param name="point2">A <see cref="T:System.Drawing.PointF" /> structure that represents the endpoint of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color of the linear gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color of the linear gradient.</param>
		public LinearGradientBrush(PointF point1, PointF point2, Color color1, Color color2)
		{
			IntPtr lineGradient = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrush(new GPPOINTF(point1), new GPPOINTF(point2), color1.ToArgb(), color2.ToArgb(), 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class with the specified points and colors.</summary>
		/// <param name="point1">A <see cref="T:System.Drawing.Point" /> structure that represents the starting point of the linear gradient.</param>
		/// <param name="point2">A <see cref="T:System.Drawing.Point" /> structure that represents the endpoint of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color of the linear gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color of the linear gradient.</param>
		public LinearGradientBrush(Point point1, Point point2, Color color1, Color color2)
		{
			IntPtr lineGradient = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrushI(new GPPOINT(point1), new GPPOINT(point2), color1.ToArgb(), color2.ToArgb(), 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> based on a rectangle, starting and ending colors, and an orientation mode.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="linearGradientMode">A <see cref="T:System.Drawing.Drawing2D.LinearGradientMode" /> enumeration element that specifies the orientation of the gradient. The orientation determines the starting and ending points of the gradient. For example, <see langword="LinearGradientMode.ForwardDiagonal" /> specifies that the starting point is the upper-left corner of the rectangle and the ending point is the lower-right corner of the rectangle.</param>
		public LinearGradientBrush(RectangleF rect, Color color1, Color color2, LinearGradientMode linearGradientMode)
		{
			if (!ClientUtils.IsEnumValid(linearGradientMode, (int)linearGradientMode, 0, 3))
			{
				throw new InvalidEnumArgumentException("linearGradientMode", (int)linearGradientMode, typeof(LinearGradientMode));
			}
			if ((double)rect.Width == 0.0 || (double)rect.Height == 0.0)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			IntPtr lineGradient = IntPtr.Zero;
			GPRECTF rect2 = new GPRECTF(rect);
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrushFromRect(ref rect2, color1.ToArgb(), color2.ToArgb(), (int)linearGradientMode, 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class based on a rectangle, starting and ending colors, and orientation.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="linearGradientMode">A <see cref="T:System.Drawing.Drawing2D.LinearGradientMode" /> enumeration element that specifies the orientation of the gradient. The orientation determines the starting and ending points of the gradient. For example, <see langword="LinearGradientMode.ForwardDiagonal" /> specifies that the starting point is the upper-left corner of the rectangle and the ending point is the lower-right corner of the rectangle.</param>
		public LinearGradientBrush(Rectangle rect, Color color1, Color color2, LinearGradientMode linearGradientMode)
		{
			if (!ClientUtils.IsEnumValid(linearGradientMode, (int)linearGradientMode, 0, 3))
			{
				throw new InvalidEnumArgumentException("linearGradientMode", (int)linearGradientMode, typeof(LinearGradientMode));
			}
			if (rect.Width == 0 || rect.Height == 0)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			IntPtr lineGradient = IntPtr.Zero;
			GPRECT rect2 = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrushFromRectI(ref rect2, color1.ToArgb(), color2.ToArgb(), (int)linearGradientMode, 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class based on a rectangle, starting and ending colors, and an orientation angle.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="angle">The angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line.</param>
		public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle)
			: this(rect, color1, color2, angle, isAngleScaleable: false)
		{
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class based on a rectangle, starting and ending colors, and an orientation angle.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="angle">The angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line.</param>
		/// <param name="isAngleScaleable">Set to <see langword="true" /> to specify that the angle is affected by the transform associated with this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />; otherwise, <see langword="false" />.</param>
		public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle, bool isAngleScaleable)
		{
			IntPtr lineGradient = IntPtr.Zero;
			if ((double)rect.Width == 0.0 || (double)rect.Height == 0.0)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			GPRECTF rect2 = new GPRECTF(rect);
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrushFromRectWithAngle(ref rect2, color1.ToArgb(), color2.ToArgb(), angle, isAngleScaleable, 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class based on a rectangle, starting and ending colors, and an orientation angle.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="angle">The angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line.</param>
		public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle)
			: this(rect, color1, color2, angle, isAngleScaleable: false)
		{
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> class based on a rectangle, starting and ending colors, and an orientation angle.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that specifies the bounds of the linear gradient.</param>
		/// <param name="color1">A <see cref="T:System.Drawing.Color" /> structure that represents the starting color for the gradient.</param>
		/// <param name="color2">A <see cref="T:System.Drawing.Color" /> structure that represents the ending color for the gradient.</param>
		/// <param name="angle">The angle, measured in degrees clockwise from the x-axis, of the gradient's orientation line.</param>
		/// <param name="isAngleScaleable">Set to <see langword="true" /> to specify that the angle is affected by the transform associated with this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />; otherwise, <see langword="false" />.</param>
		public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle, bool isAngleScaleable)
		{
			IntPtr lineGradient = IntPtr.Zero;
			if (rect.Width == 0 || rect.Height == 0)
			{
				throw new ArgumentException(SR.GetString("GdiplusInvalidRectangle", rect.ToString()));
			}
			GPRECT rect2 = new GPRECT(rect);
			int num = SafeNativeMethods.Gdip.GdipCreateLineBrushFromRectWithAngleI(ref rect2, color1.ToArgb(), color2.ToArgb(), angle, isAngleScaleable, 0, out lineGradient);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(lineGradient);
		}

		internal LinearGradientBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> this method creates, cast as an object.</returns>
		public override object Clone()
		{
			IntPtr clonebrush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonebrush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new LinearGradientBrush(clonebrush);
		}

		private void _SetLinearColors(Color color1, Color color2)
		{
			int num = SafeNativeMethods.Gdip.GdipSetLineColors(new HandleRef(this, base.NativeBrush), color1.ToArgb(), color2.ToArgb());
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private Color[] _GetLinearColors()
		{
			int[] array = new int[2];
			int num = SafeNativeMethods.Gdip.GdipGetLineColors(new HandleRef(this, base.NativeBrush), array);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Color[2]
			{
				Color.FromArgb(array[0]),
				Color.FromArgb(array[1])
			};
		}

		private RectangleF _GetRectangle()
		{
			GPRECTF gprectf = default(GPRECTF);
			int num = SafeNativeMethods.Gdip.GdipGetLineRect(new HandleRef(this, base.NativeBrush), ref gprectf);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gprectf.ToRectangleF();
		}

		private Blend _GetBlend()
		{
			if (interpolationColorsWasSet)
			{
				return null;
			}
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetLineBlendCount(new HandleRef(this, base.NativeBrush), out count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (count <= 0)
			{
				return null;
			}
			int num2 = count;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num2);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				num = SafeNativeMethods.Gdip.GdipGetLineBlend(new HandleRef(this, base.NativeBrush), intPtr, intPtr2, num2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Blend blend = new Blend(num2);
				Marshal.Copy(intPtr, blend.Factors, 0, num2);
				Marshal.Copy(intPtr2, blend.Positions, 0, num2);
				return blend;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetBlend(Blend blend)
		{
			int num = blend.Factors.Length;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				Marshal.Copy(blend.Factors, 0, intPtr, num);
				Marshal.Copy(blend.Positions, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipSetLineBlend(new HandleRef(this, base.NativeBrush), new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		/// <summary>Creates a gradient falloff based on a bell-shaped curve.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies the center of the gradient (the point where the starting color and ending color are blended equally).</param>
		public void SetSigmaBellShape(float focus)
		{
			SetSigmaBellShape(focus, 1f);
		}

		/// <summary>Creates a gradient falloff based on a bell-shaped curve.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies the center of the gradient (the point where the gradient is composed of only the ending color).</param>
		/// <param name="scale">A value from 0 through 1 that specifies how fast the colors falloff from the <paramref name="focus" />.</param>
		public void SetSigmaBellShape(float focus, float scale)
		{
			int num = SafeNativeMethods.Gdip.GdipSetLineSigmaBlend(new HandleRef(this, base.NativeBrush), focus, scale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Creates a linear gradient with a center color and a linear falloff to a single color on both ends.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies the center of the gradient (the point where the gradient is composed of only the ending color).</param>
		public void SetBlendTriangularShape(float focus)
		{
			SetBlendTriangularShape(focus, 1f);
		}

		/// <summary>Creates a linear gradient with a center color and a linear falloff to a single color on both ends.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies the center of the gradient (the point where the gradient is composed of only the ending color).</param>
		/// <param name="scale">A value from 0 through1 that specifies how fast the colors falloff from the starting color to <paramref name="focus" /> (ending color)</param>
		public void SetBlendTriangularShape(float focus, float scale)
		{
			int num = SafeNativeMethods.Gdip.GdipSetLineLinearBlend(new HandleRef(this, base.NativeBrush), focus, scale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private ColorBlend _GetInterpolationColors()
		{
			if (!interpolationColorsWasSet)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsColorBlendNotSet"), ""));
			}
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetLinePresetBlendCount(new HandleRef(this, base.NativeBrush), out count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			int num2 = count;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num2);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				num = SafeNativeMethods.Gdip.GdipGetLinePresetBlend(new HandleRef(this, base.NativeBrush), intPtr, intPtr2, num2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				ColorBlend colorBlend = new ColorBlend(num2);
				int[] array = new int[num2];
				Marshal.Copy(intPtr, array, 0, num2);
				Marshal.Copy(intPtr2, colorBlend.Positions, 0, num2);
				colorBlend.Colors = new Color[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					colorBlend.Colors[i] = Color.FromArgb(array[i]);
				}
				return colorBlend;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetInterpolationColors(ColorBlend blend)
		{
			interpolationColorsWasSet = true;
			if (blend == null)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsInvalidColorBlendObject"), ""));
			}
			if (blend.Colors.Length < 2)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsInvalidColorBlendObject"), SR.GetString("InterpolationColorsLength")));
			}
			if (blend.Colors.Length != blend.Positions.Length)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsInvalidColorBlendObject"), SR.GetString("InterpolationColorsLengthsDiffer")));
			}
			if (blend.Positions[0] != 0f)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsInvalidColorBlendObject"), SR.GetString("InterpolationColorsInvalidStartPosition")));
			}
			if (blend.Positions[blend.Positions.Length - 1] != 1f)
			{
				throw new ArgumentException(SR.GetString("InterpolationColorsCommon", SR.GetString("InterpolationColorsInvalidColorBlendObject"), SR.GetString("InterpolationColorsInvalidEndPosition")));
			}
			int num = blend.Colors.Length;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				int[] array = new int[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = blend.Colors[i].ToArgb();
				}
				Marshal.Copy(array, 0, intPtr, num);
				Marshal.Copy(blend.Positions, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipSetLinePresetBlend(new HandleRef(this, base.NativeBrush), new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetWrapMode(WrapMode wrapMode)
		{
			int num = SafeNativeMethods.Gdip.GdipSetLineWrapMode(new HandleRef(this, base.NativeBrush), (int)wrapMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private WrapMode _GetWrapMode()
		{
			int wrapMode = 0;
			int num = SafeNativeMethods.Gdip.GdipGetLineWrapMode(new HandleRef(this, base.NativeBrush), out wrapMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return (WrapMode)wrapMode;
		}

		private void _SetTransform(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipSetLineTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private Matrix _GetTransform()
		{
			Matrix matrix = new Matrix();
			int num = SafeNativeMethods.Gdip.GdipGetLineTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return matrix;
		}

		/// <summary>Resets the <see cref="P:System.Drawing.Drawing2D.LinearGradientBrush.Transform" /> property to identity.</summary>
		public void ResetTransform()
		{
			int num = SafeNativeMethods.Gdip.GdipResetLineTransform(new HandleRef(this, base.NativeBrush));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Multiplies the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents the local geometric transform of this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> by prepending the specified <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to multiply the geometric transform.</param>
		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Multiplies the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that represents the local geometric transform of this <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> by the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which to multiply the geometric transform.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies in which order to multiply the two matrices.</param>
		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipMultiplyLineTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Translates the local geometric transform by the specified dimensions. This method prepends the translation to the transform.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		/// <summary>Translates the local geometric transform by the specified dimensions in the specified order.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		/// <param name="order">The order (prepend or append) in which to apply the translation.</param>
		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateLineTransform(new HandleRef(this, base.NativeBrush), dx, dy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Scales the local geometric transform by the specified amounts. This method prepends the scaling matrix to the transform.</summary>
		/// <param name="sx">The amount by which to scale the transform in the x-axis direction.</param>
		/// <param name="sy">The amount by which to scale the transform in the y-axis direction.</param>
		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		/// <summary>Scales the local geometric transform by the specified amounts in the specified order.</summary>
		/// <param name="sx">The amount by which to scale the transform in the x-axis direction.</param>
		/// <param name="sy">The amount by which to scale the transform in the y-axis direction.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the scaling matrix.</param>
		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScaleLineTransform(new HandleRef(this, base.NativeBrush), sx, sy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Rotates the local geometric transform by the specified amount. This method prepends the rotation to the transform.</summary>
		/// <param name="angle">The angle of rotation.</param>
		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		/// <summary>Rotates the local geometric transform by the specified amount in the specified order.</summary>
		/// <param name="angle">The angle of rotation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the rotation matrix.</param>
		public void RotateTransform(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotateLineTransform(new HandleRef(this, base.NativeBrush), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}
	}
	/// <summary>Specifies the direction of a linear gradient.</summary>
	public enum LinearGradientMode
	{
		/// <summary>Specifies a gradient from left to right.</summary>
		Horizontal,
		/// <summary>Specifies a gradient from top to bottom.</summary>
		Vertical,
		/// <summary>Specifies a gradient from upper left to lower right.</summary>
		ForwardDiagonal,
		/// <summary>Specifies a gradient from upper right to lower left.</summary>
		BackwardDiagonal
	}
	/// <summary>Specifies the available cap styles with which a <see cref="T:System.Drawing.Pen" /> object can end a line.</summary>
	public enum LineCap
	{
		/// <summary>Specifies a flat line cap.</summary>
		Flat = 0,
		/// <summary>Specifies a square line cap.</summary>
		Square = 1,
		/// <summary>Specifies a round line cap.</summary>
		Round = 2,
		/// <summary>Specifies a triangular line cap.</summary>
		Triangle = 3,
		/// <summary>Specifies no anchor.</summary>
		NoAnchor = 16,
		/// <summary>Specifies a square anchor line cap.</summary>
		SquareAnchor = 17,
		/// <summary>Specifies a round anchor cap.</summary>
		RoundAnchor = 18,
		/// <summary>Specifies a diamond anchor cap.</summary>
		DiamondAnchor = 19,
		/// <summary>Specifies an arrow-shaped anchor cap.</summary>
		ArrowAnchor = 20,
		/// <summary>Specifies a custom line cap.</summary>
		Custom = 255,
		/// <summary>Specifies a mask used to check whether a line cap is an anchor cap.</summary>
		AnchorMask = 240
	}
	/// <summary>Specifies how to join consecutive line or curve segments in a figure (subpath) contained in a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object.</summary>
	public enum LineJoin
	{
		/// <summary>Specifies a mitered join. This produces a sharp corner or a clipped corner, depending on whether the length of the miter exceeds the miter limit.</summary>
		Miter,
		/// <summary>Specifies a beveled join. This produces a diagonal corner.</summary>
		Bevel,
		/// <summary>Specifies a circular join. This produces a smooth, circular arc between the lines.</summary>
		Round,
		/// <summary>Specifies a mitered join. This produces a sharp corner or a beveled corner, depending on whether the length of the miter exceeds the miter limit.</summary>
		MiterClipped
	}
	/// <summary>Encapsulates a 3-by-3 affine matrix that represents a geometric transform. This class cannot be inherited.</summary>
	public sealed class Matrix : MarshalByRefObject, IDisposable
	{
		internal IntPtr nativeMatrix;

		/// <summary>Gets an array of floating-point values that represents the elements of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <returns>An array of floating-point values that represents the elements of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</returns>
		public float[] Elements
		{
			get
			{
				IntPtr intPtr = Marshal.AllocHGlobal(48);
				try
				{
					int num = SafeNativeMethods.Gdip.GdipGetMatrixElements(new HandleRef(this, nativeMatrix), intPtr);
					if (num != 0)
					{
						throw SafeNativeMethods.Gdip.StatusException(num);
					}
					float[] array = new float[6];
					Marshal.Copy(intPtr, array, 0, 6);
					return array;
				}
				finally
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		/// <summary>Gets the x translation value (the dx value, or the element in the third row and first column) of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <returns>The x translation value of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</returns>
		public float OffsetX => Elements[4];

		/// <summary>Gets the y translation value (the dy value, or the element in the third row and second column) of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <returns>The y translation value of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</returns>
		public float OffsetY => Elements[5];

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is invertible.</summary>
		/// <returns>This property is <see langword="true" /> if this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is invertible; otherwise, <see langword="false" />.</returns>
		public bool IsInvertible
		{
			get
			{
				int boolean;
				int num = SafeNativeMethods.Gdip.GdipIsMatrixInvertible(new HandleRef(this, nativeMatrix), out boolean);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return boolean != 0;
			}
		}

		/// <summary>Gets a value indicating whether this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is the identity matrix.</summary>
		/// <returns>This property is <see langword="true" /> if this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is identity; otherwise, <see langword="false" />.</returns>
		public bool IsIdentity
		{
			get
			{
				int boolean;
				int num = SafeNativeMethods.Gdip.GdipIsMatrixIdentity(new HandleRef(this, nativeMatrix), out boolean);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return boolean != 0;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> class as the identity matrix.</summary>
		public Matrix()
		{
			IntPtr matrix = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMatrix(out matrix);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeMatrix = matrix;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> class with the specified elements.</summary>
		/// <param name="m11">The value in the first row and first column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="m12">The value in the first row and second column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="m21">The value in the second row and first column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="m22">The value in the second row and second column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="dx">The value in the third row and first column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="dy">The value in the third row and second column of the new <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		public Matrix(float m11, float m12, float m21, float m22, float dx, float dy)
		{
			IntPtr matrix = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreateMatrix2(m11, m12, m21, m22, dx, dy, out matrix);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			nativeMatrix = matrix;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> class to the geometric transform defined by the specified rectangle and array of points.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> structure that represents the rectangle to be transformed.</param>
		/// <param name="plgpts">An array of three <see cref="T:System.Drawing.PointF" /> structures that represents the points of a parallelogram to which the upper-left, upper-right, and lower-left corners of the rectangle is to be transformed. The lower-right corner of the parallelogram is implied by the first three corners.</param>
		public Matrix(RectangleF rect, PointF[] plgpts)
		{
			if (plgpts == null)
			{
				throw new ArgumentNullException("plgpts");
			}
			if (plgpts.Length != 3)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(plgpts);
			try
			{
				IntPtr matrix = IntPtr.Zero;
				GPRECTF rect2 = new GPRECTF(rect);
				int num = SafeNativeMethods.Gdip.GdipCreateMatrix3(ref rect2, new HandleRef(null, intPtr), out matrix);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				nativeMatrix = matrix;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> class to the geometric transform defined by the specified rectangle and array of points.</summary>
		/// <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> structure that represents the rectangle to be transformed.</param>
		/// <param name="plgpts">An array of three <see cref="T:System.Drawing.Point" /> structures that represents the points of a parallelogram to which the upper-left, upper-right, and lower-left corners of the rectangle is to be transformed. The lower-right corner of the parallelogram is implied by the first three corners.</param>
		public Matrix(Rectangle rect, Point[] plgpts)
		{
			if (plgpts == null)
			{
				throw new ArgumentNullException("plgpts");
			}
			if (plgpts.Length != 3)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(plgpts);
			try
			{
				IntPtr matrix = IntPtr.Zero;
				GPRECT rect2 = new GPRECT(rect);
				int num = SafeNativeMethods.Gdip.GdipCreateMatrix3I(ref rect2, new HandleRef(null, intPtr), out matrix);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				nativeMatrix = matrix;
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Releases all resources used by this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (nativeMatrix != IntPtr.Zero)
			{
				SafeNativeMethods.Gdip.GdipDeleteMatrix(new HandleRef(this, nativeMatrix));
				nativeMatrix = IntPtr.Zero;
			}
		}

		/// <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
		~Matrix()
		{
			Dispose(disposing: false);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.Matrix" /> that this method creates.</returns>
		public Matrix Clone()
		{
			IntPtr cloneMatrix = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneMatrix(new HandleRef(this, nativeMatrix), out cloneMatrix);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new Matrix(cloneMatrix);
		}

		/// <summary>Resets this <see cref="T:System.Drawing.Drawing2D.Matrix" /> to have the elements of the identity matrix.</summary>
		public void Reset()
		{
			int num = SafeNativeMethods.Gdip.GdipSetMatrixElements(new HandleRef(this, nativeMatrix), 1f, 0f, 0f, 1f, 0f, 0f);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Multiplies this <see cref="T:System.Drawing.Drawing2D.Matrix" /> by the matrix specified in the <paramref name="matrix" /> parameter, by prepending the specified <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is to be multiplied.</param>
		public void Multiply(Matrix matrix)
		{
			Multiply(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Multiplies this <see cref="T:System.Drawing.Drawing2D.Matrix" /> by the matrix specified in the <paramref name="matrix" /> parameter, and in the order specified in the <paramref name="order" /> parameter.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> by which this <see cref="T:System.Drawing.Drawing2D.Matrix" /> is to be multiplied.</param>
		/// <param name="order">The <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that represents the order of the multiplication.</param>
		public void Multiply(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipMultiplyMatrix(new HandleRef(this, nativeMatrix), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Applies the specified translation vector (<paramref name="offsetX" /> and <paramref name="offsetY" />) to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> by prepending the translation vector.</summary>
		/// <param name="offsetX">The x value by which to translate this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="offsetY">The y value by which to translate this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		public void Translate(float offsetX, float offsetY)
		{
			Translate(offsetX, offsetY, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified translation vector to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="offsetX">The x value by which to translate this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="offsetY">The y value by which to translate this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies the order (append or prepend) in which the translation is applied to this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		public void Translate(float offsetX, float offsetY, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), offsetX, offsetY, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Applies the specified scale vector to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> by prepending the scale vector.</summary>
		/// <param name="scaleX">The value by which to scale this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the x-axis direction.</param>
		/// <param name="scaleY">The value by which to scale this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the y-axis direction.</param>
		public void Scale(float scaleX, float scaleY)
		{
			Scale(scaleX, scaleY, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified scale vector (<paramref name="scaleX" /> and <paramref name="scaleY" />) to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> using the specified order.</summary>
		/// <param name="scaleX">The value by which to scale this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the x-axis direction.</param>
		/// <param name="scaleY">The value by which to scale this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the y-axis direction.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies the order (append or prepend) in which the scale vector is applied to this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		public void Scale(float scaleX, float scaleY, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScaleMatrix(new HandleRef(this, nativeMatrix), scaleX, scaleY, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Prepend to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> a clockwise rotation, around the origin and by the specified angle.</summary>
		/// <param name="angle">The angle of the rotation, in degrees.</param>
		public void Rotate(float angle)
		{
			Rotate(angle, MatrixOrder.Prepend);
		}

		/// <summary>Applies a clockwise rotation of an amount specified in the <paramref name="angle" /> parameter, around the origin (zero x and y coordinates) for this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="angle">The angle (extent) of the rotation, in degrees.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies the order (append or prepend) in which the rotation is applied to this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</param>
		public void Rotate(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotateMatrix(new HandleRef(this, nativeMatrix), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Applies a clockwise rotation to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> around the point specified in the <paramref name="point" /> parameter, and by prepending the rotation.</summary>
		/// <param name="angle">The angle (extent) of the rotation, in degrees.</param>
		/// <param name="point">A <see cref="T:System.Drawing.PointF" /> that represents the center of the rotation.</param>
		public void RotateAt(float angle, PointF point)
		{
			RotateAt(angle, point, MatrixOrder.Prepend);
		}

		/// <summary>Applies a clockwise rotation about the specified point to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="angle">The angle of the rotation, in degrees.</param>
		/// <param name="point">A <see cref="T:System.Drawing.PointF" /> that represents the center of the rotation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies the order (append or prepend) in which the rotation is applied.</param>
		public void RotateAt(float angle, PointF point, MatrixOrder order)
		{
			int num;
			if (order == MatrixOrder.Prepend)
			{
				num = SafeNativeMethods.Gdip.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), point.X, point.Y, order);
				num |= SafeNativeMethods.Gdip.GdipRotateMatrix(new HandleRef(this, nativeMatrix), angle, order);
				num |= SafeNativeMethods.Gdip.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), 0f - point.X, 0f - point.Y, order);
			}
			else
			{
				num = SafeNativeMethods.Gdip.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), 0f - point.X, 0f - point.Y, order);
				num |= SafeNativeMethods.Gdip.GdipRotateMatrix(new HandleRef(this, nativeMatrix), angle, order);
				num |= SafeNativeMethods.Gdip.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), point.X, point.Y, order);
			}
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Applies the specified shear vector to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> by prepending the shear transformation.</summary>
		/// <param name="shearX">The horizontal shear factor.</param>
		/// <param name="shearY">The vertical shear factor.</param>
		public void Shear(float shearX, float shearY)
		{
			int num = SafeNativeMethods.Gdip.GdipShearMatrix(new HandleRef(this, nativeMatrix), shearX, shearY, MatrixOrder.Prepend);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Applies the specified shear vector to this <see cref="T:System.Drawing.Drawing2D.Matrix" /> in the specified order.</summary>
		/// <param name="shearX">The horizontal shear factor.</param>
		/// <param name="shearY">The vertical shear factor.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies the order (append or prepend) in which the shear is applied.</param>
		public void Shear(float shearX, float shearY, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipShearMatrix(new HandleRef(this, nativeMatrix), shearX, shearY, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Inverts this <see cref="T:System.Drawing.Drawing2D.Matrix" />, if it is invertible.</summary>
		public void Invert()
		{
			int num = SafeNativeMethods.Gdip.GdipInvertMatrix(new HandleRef(this, nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Applies the geometric transform represented by this <see cref="T:System.Drawing.Drawing2D.Matrix" /> to a specified array of points.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points to transform.</param>
		public void TransformPoints(PointF[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipTransformMatrixPoints(new HandleRef(this, nativeMatrix), new HandleRef(null, intPtr), pts.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				PointF[] array = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					pts[i] = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Applies the geometric transform represented by this <see cref="T:System.Drawing.Drawing2D.Matrix" /> to a specified array of points.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points to transform.</param>
		public void TransformPoints(Point[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipTransformMatrixPointsI(new HandleRef(this, nativeMatrix), new HandleRef(null, intPtr), pts.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Point[] array = SafeNativeMethods.Gdip.ConvertGPPOINTArray(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					pts[i] = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Multiplies each vector in an array by the matrix. The translation elements of this matrix (third row) are ignored.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points to transform.</param>
		public void TransformVectors(PointF[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipVectorTransformMatrixPoints(new HandleRef(this, nativeMatrix), new HandleRef(null, intPtr), pts.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				PointF[] array = SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					pts[i] = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Multiplies each vector in an array by the matrix. The translation elements of this matrix (third row) are ignored.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points to transform.</param>
		public void VectorTransformPoints(Point[] pts)
		{
			TransformVectors(pts);
		}

		/// <summary>Applies only the scale and rotate components of this <see cref="T:System.Drawing.Drawing2D.Matrix" /> to the specified array of points.</summary>
		/// <param name="pts">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points to transform.</param>
		public void TransformVectors(Point[] pts)
		{
			if (pts == null)
			{
				throw new ArgumentNullException("pts");
			}
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(pts);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipVectorTransformMatrixPointsI(new HandleRef(this, nativeMatrix), new HandleRef(null, intPtr), pts.Length);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Point[] array = SafeNativeMethods.Gdip.ConvertGPPOINTArray(intPtr, pts.Length);
				for (int i = 0; i < pts.Length; i++)
				{
					pts[i] = array[i];
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
		}

		/// <summary>Tests whether the specified object is a <see cref="T:System.Drawing.Drawing2D.Matrix" /> and is identical to this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
		/// <param name="obj">The object to test.</param>
		/// <returns>This method returns <see langword="true" /> if <paramref name="obj" /> is the specified <see cref="T:System.Drawing.Drawing2D.Matrix" /> identical to this <see cref="T:System.Drawing.Drawing2D.Matrix" />; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is Matrix matrix))
			{
				return false;
			}
			int boolean;
			int num = SafeNativeMethods.Gdip.GdipIsMatrixEqual(new HandleRef(this, nativeMatrix), new HandleRef(matrix, matrix.nativeMatrix), out boolean);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return boolean != 0;
		}

		/// <summary>Returns a hash code.</summary>
		/// <returns>The hash code for this <see cref="T:System.Drawing.Drawing2D.Matrix" />.</returns>
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		internal Matrix(IntPtr nativeMatrix)
		{
			SetNativeMatrix(nativeMatrix);
		}

		internal void SetNativeMatrix(IntPtr nativeMatrix)
		{
			this.nativeMatrix = nativeMatrix;
		}
	}
	/// <summary>Specifies the order for matrix transform operations.</summary>
	public enum MatrixOrder
	{
		/// <summary>The new operation is applied before the old operation.</summary>
		Prepend,
		/// <summary>The new operation is applied after the old operation.</summary>
		Append
	}
	/// <summary>Contains the graphical data that makes up a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object. This class cannot be inherited.</summary>
	public sealed class PathData
	{
		private PointF[] points;

		private byte[] types;

		/// <summary>Gets or sets an array of <see cref="T:System.Drawing.PointF" /> structures that represents the points through which the path is constructed.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.PointF" /> objects that represents the points through which the path is constructed.</returns>
		public PointF[] Points
		{
			get
			{
				return points;
			}
			set
			{
				points = value;
			}
		}

		/// <summary>Gets or sets the types of the corresponding points in the path.</summary>
		/// <returns>An array of bytes that specify the types of the corresponding points in the path.</returns>
		public byte[] Types
		{
			get
			{
				return types;
			}
			set
			{
				types = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathData" /> class.</summary>
		public PathData()
		{
		}
	}
	/// <summary>Encapsulates a <see cref="T:System.Drawing.Brush" /> object that fills the interior of a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object with a gradient. This class cannot be inherited.</summary>
	public sealed class PathGradientBrush : Brush
	{
		/// <summary>Gets or sets the color at the center of the path gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.Color" /> that represents the color at the center of the path gradient.</returns>
		public Color CenterColor
		{
			get
			{
				int color;
				int num = SafeNativeMethods.Gdip.GdipGetPathGradientCenterColor(new HandleRef(this, base.NativeBrush), out color);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return Color.FromArgb(color);
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetPathGradientCenterColor(new HandleRef(this, base.NativeBrush), value.ToArgb());
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets an array of colors that correspond to the points in the path this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> fills.</summary>
		/// <returns>An array of <see cref="T:System.Drawing.Color" /> structures that represents the colors associated with each point in the path this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> fills.</returns>
		public Color[] SurroundColors
		{
			get
			{
				return _GetSurroundColors();
			}
			set
			{
				_SetSurroundColors(value);
			}
		}

		/// <summary>Gets or sets the center point of the path gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.PointF" /> that represents the center point of the path gradient.</returns>
		public PointF CenterPoint
		{
			get
			{
				GPPOINTF gPPOINTF = new GPPOINTF();
				int num = SafeNativeMethods.Gdip.GdipGetPathGradientCenterPoint(new HandleRef(this, base.NativeBrush), gPPOINTF);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return gPPOINTF.ToPoint();
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetPathGradientCenterPoint(new HandleRef(this, base.NativeBrush), new GPPOINTF(value));
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets a bounding rectangle for this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.RectangleF" /> that represents a rectangular region that bounds the path this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> fills.</returns>
		public RectangleF Rectangle => _GetRectangle();

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.Blend" /> that specifies positions and factors that define a custom falloff for the gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.Blend" /> that represents a custom falloff for the gradient.</returns>
		public Blend Blend
		{
			get
			{
				return _GetBlend();
			}
			set
			{
				_SetBlend(value);
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> that defines a multicolor linear gradient.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.ColorBlend" /> that defines a multicolor linear gradient.</returns>
		public ColorBlend InterpolationColors
		{
			get
			{
				return _GetInterpolationColors();
			}
			set
			{
				_SetInterpolationColors(value);
			}
		}

		/// <summary>Gets or sets a copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that defines a local geometric transform for this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</summary>
		/// <returns>A copy of the <see cref="T:System.Drawing.Drawing2D.Matrix" /> that defines a geometric transform that applies only to fills drawn with this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</returns>
		public Matrix Transform
		{
			get
			{
				return _GetTransform();
			}
			set
			{
				_SetTransform(value);
			}
		}

		/// <summary>Gets or sets the focus point for the gradient falloff.</summary>
		/// <returns>A <see cref="T:System.Drawing.PointF" /> that represents the focus point for the gradient falloff.</returns>
		public PointF FocusScales
		{
			get
			{
				float[] array = new float[1];
				float[] array2 = new float[1];
				int num = SafeNativeMethods.Gdip.GdipGetPathGradientFocusScales(new HandleRef(this, base.NativeBrush), array, array2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				return new PointF(array[0], array2[0]);
			}
			set
			{
				int num = SafeNativeMethods.Gdip.GdipSetPathGradientFocusScales(new HandleRef(this, base.NativeBrush), value.X, value.Y);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
			}
		}

		/// <summary>Gets or sets a <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that indicates the wrap mode for this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</summary>
		/// <returns>A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how fills drawn with this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> are tiled.</returns>
		public WrapMode WrapMode
		{
			get
			{
				return _GetWrapMode();
			}
			set
			{
				if (!ClientUtils.IsEnumValid(value, (int)value, 0, 4))
				{
					throw new InvalidEnumArgumentException("value", (int)value, typeof(WrapMode));
				}
				_SetWrapMode(value);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> class with the specified points.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that make up the vertices of the path.</param>
		public PathGradientBrush(PointF[] points)
			: this(points, WrapMode.Clamp)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> class with the specified points and wrap mode.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.PointF" /> structures that represents the points that make up the vertices of the path.</param>
		/// <param name="wrapMode">A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how fills drawn with this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> are tiled.</param>
		public PathGradientBrush(PointF[] points, WrapMode wrapMode)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			if (!ClientUtils.IsEnumValid(wrapMode, (int)wrapMode, 0, 4))
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr brush = IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipCreatePathGradient(new HandleRef(null, intPtr), points.Length, (int)wrapMode, out brush);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				SetNativeBrushInternal(brush);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> class with the specified points.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that make up the vertices of the path.</param>
		public PathGradientBrush(Point[] points)
			: this(points, WrapMode.Clamp)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> class with the specified points and wrap mode.</summary>
		/// <param name="points">An array of <see cref="T:System.Drawing.Point" /> structures that represents the points that make up the vertices of the path.</param>
		/// <param name="wrapMode">A <see cref="T:System.Drawing.Drawing2D.WrapMode" /> that specifies how fills drawn with this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> are tiled.</param>
		public PathGradientBrush(Point[] points, WrapMode wrapMode)
		{
			if (points == null)
			{
				throw new ArgumentNullException("points");
			}
			if (!ClientUtils.IsEnumValid(wrapMode, (int)wrapMode, 0, 4))
			{
				throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
			}
			IntPtr brush = IntPtr.Zero;
			IntPtr intPtr = SafeNativeMethods.Gdip.ConvertPointToMemory(points);
			try
			{
				int num = SafeNativeMethods.Gdip.GdipCreatePathGradientI(new HandleRef(null, intPtr), points.Length, (int)wrapMode, out brush);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				SetNativeBrushInternal(brush);
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> class with the specified path.</summary>
		/// <param name="path">The <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> that defines the area filled by this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</param>
		public PathGradientBrush(GraphicsPath path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			IntPtr brush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCreatePathGradientFromPath(new HandleRef(path, path.nativePath), out brush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			SetNativeBrushInternal(brush);
		}

		internal PathGradientBrush(IntPtr nativeBrush)
		{
			SetNativeBrushInternal(nativeBrush);
		}

		/// <summary>Creates an exact copy of this <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />.</summary>
		/// <returns>The <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" /> this method creates, cast as an object.</returns>
		public override object Clone()
		{
			IntPtr clonebrush = IntPtr.Zero;
			int num = SafeNativeMethods.Gdip.GdipCloneBrush(new HandleRef(this, base.NativeBrush), out clonebrush);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return new PathGradientBrush(clonebrush);
		}

		private void _SetSurroundColors(Color[] colors)
		{
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientSurroundColorCount(new HandleRef(this, base.NativeBrush), out var count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (colors.Length > count || count <= 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(2);
			}
			count = colors.Length;
			int[] array = new int[count];
			for (int i = 0; i < colors.Length; i++)
			{
				array[i] = colors[i].ToArgb();
			}
			num = SafeNativeMethods.Gdip.GdipSetPathGradientSurroundColorsWithCount(new HandleRef(this, base.NativeBrush), array, ref count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private Color[] _GetSurroundColors()
		{
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientSurroundColorCount(new HandleRef(this, base.NativeBrush), out var count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			int[] array = new int[count];
			num = SafeNativeMethods.Gdip.GdipGetPathGradientSurroundColorsWithCount(new HandleRef(this, base.NativeBrush), array, ref count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			Color[] array2 = new Color[count];
			for (int i = 0; i < count; i++)
			{
				array2[i] = Color.FromArgb(array[i]);
			}
			return array2;
		}

		private RectangleF _GetRectangle()
		{
			GPRECTF gprectf = default(GPRECTF);
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientRect(new HandleRef(this, base.NativeBrush), ref gprectf);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return gprectf.ToRectangleF();
		}

		private Blend _GetBlend()
		{
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientBlendCount(new HandleRef(this, base.NativeBrush), out count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			int num2 = count;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num2);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				num = SafeNativeMethods.Gdip.GdipGetPathGradientBlend(new HandleRef(this, base.NativeBrush), intPtr, intPtr2, num2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				Blend blend = new Blend(num2);
				Marshal.Copy(intPtr, blend.Factors, 0, num2);
				Marshal.Copy(intPtr2, blend.Positions, 0, num2);
				return blend;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetBlend(Blend blend)
		{
			int num = blend.Factors.Length;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				Marshal.Copy(blend.Factors, 0, intPtr, num);
				Marshal.Copy(blend.Positions, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipSetPathGradientBlend(new HandleRef(this, base.NativeBrush), new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		/// <summary>Creates a gradient brush that changes color starting from the center of the path outward to the path's boundary. The transition from one color to another is based on a bell-shaped curve.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies where, along any radial from the center of the path to the path's boundary, the center color will be at its highest intensity. A value of 1 (the default) places the highest intensity at the center of the path.</param>
		public void SetSigmaBellShape(float focus)
		{
			SetSigmaBellShape(focus, 1f);
		}

		/// <summary>Creates a gradient brush that changes color starting from the center of the path outward to the path's boundary. The transition from one color to another is based on a bell-shaped curve.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies where, along any radial from the center of the path to the path's boundary, the center color will be at its highest intensity. A value of 1 (the default) places the highest intensity at the center of the path.</param>
		/// <param name="scale">A value from 0 through 1 that specifies the maximum intensity of the center color that gets blended with the boundary color. A value of 1 causes the highest possible intensity of the center color, and it is the default value.</param>
		public void SetSigmaBellShape(float focus, float scale)
		{
			int num = SafeNativeMethods.Gdip.GdipSetPathGradientSigmaBlend(new HandleRef(this, base.NativeBrush), focus, scale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Creates a gradient with a center color and a linear falloff to one surrounding color.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies where, along any radial from the center of the path to the path's boundary, the center color will be at its highest intensity. A value of 1 (the default) places the highest intensity at the center of the path.</param>
		public void SetBlendTriangularShape(float focus)
		{
			SetBlendTriangularShape(focus, 1f);
		}

		/// <summary>Creates a gradient with a center color and a linear falloff to each surrounding color.</summary>
		/// <param name="focus">A value from 0 through 1 that specifies where, along any radial from the center of the path to the path's boundary, the center color will be at its highest intensity. A value of 1 (the default) places the highest intensity at the center of the path.</param>
		/// <param name="scale">A value from 0 through 1 that specifies the maximum intensity of the center color that gets blended with the boundary color. A value of 1 causes the highest possible intensity of the center color, and it is the default value.</param>
		public void SetBlendTriangularShape(float focus, float scale)
		{
			int num = SafeNativeMethods.Gdip.GdipSetPathGradientLinearBlend(new HandleRef(this, base.NativeBrush), focus, scale);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private ColorBlend _GetInterpolationColors()
		{
			int count = 0;
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientPresetBlendCount(new HandleRef(this, base.NativeBrush), out count);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			if (count == 0)
			{
				return new ColorBlend();
			}
			int num2 = count;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num2);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				num = SafeNativeMethods.Gdip.GdipGetPathGradientPresetBlend(new HandleRef(this, base.NativeBrush), intPtr, intPtr2, num2);
				if (num != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num);
				}
				ColorBlend colorBlend = new ColorBlend(num2);
				int[] array = new int[num2];
				Marshal.Copy(intPtr, array, 0, num2);
				Marshal.Copy(intPtr2, colorBlend.Positions, 0, num2);
				colorBlend.Colors = new Color[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					colorBlend.Colors[i] = Color.FromArgb(array[i]);
				}
				return colorBlend;
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetInterpolationColors(ColorBlend blend)
		{
			int num = blend.Colors.Length;
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			try
			{
				int cb = checked(4 * num);
				intPtr = Marshal.AllocHGlobal(cb);
				intPtr2 = Marshal.AllocHGlobal(cb);
				int[] array = new int[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = blend.Colors[i].ToArgb();
				}
				Marshal.Copy(array, 0, intPtr, num);
				Marshal.Copy(blend.Positions, 0, intPtr2, num);
				int num2 = SafeNativeMethods.Gdip.GdipSetPathGradientPresetBlend(new HandleRef(this, base.NativeBrush), new HandleRef(null, intPtr), new HandleRef(null, intPtr2), num);
				if (num2 != 0)
				{
					throw SafeNativeMethods.Gdip.StatusException(num2);
				}
			}
			finally
			{
				if (intPtr != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr);
				}
				if (intPtr2 != IntPtr.Zero)
				{
					Marshal.FreeHGlobal(intPtr2);
				}
			}
		}

		private void _SetTransform(Matrix matrix)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipSetPathGradientTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private Matrix _GetTransform()
		{
			Matrix matrix = new Matrix();
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return matrix;
		}

		/// <summary>Resets the <see cref="P:System.Drawing.Drawing2D.PathGradientBrush.Transform" /> property to identity.</summary>
		public void ResetTransform()
		{
			int num = SafeNativeMethods.Gdip.GdipResetPathGradientTransform(new HandleRef(this, base.NativeBrush));
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Updates the brush's transformation matrix with the product of brush's transformation matrix multiplied by another matrix.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> that will be multiplied by the brush's current transformation matrix.</param>
		public void MultiplyTransform(Matrix matrix)
		{
			MultiplyTransform(matrix, MatrixOrder.Prepend);
		}

		/// <summary>Updates the brush's transformation matrix with the product of the brush's transformation matrix multiplied by another matrix.</summary>
		/// <param name="matrix">The <see cref="T:System.Drawing.Drawing2D.Matrix" /> that will be multiplied by the brush's current transformation matrix.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies in which order to multiply the two matrices.</param>
		public void MultiplyTransform(Matrix matrix, MatrixOrder order)
		{
			if (matrix == null)
			{
				throw new ArgumentNullException("matrix");
			}
			int num = SafeNativeMethods.Gdip.GdipMultiplyPathGradientTransform(new HandleRef(this, base.NativeBrush), new HandleRef(matrix, matrix.nativeMatrix), order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Applies the specified translation to the local geometric transform. This method prepends the translation to the transform.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		public void TranslateTransform(float dx, float dy)
		{
			TranslateTransform(dx, dy, MatrixOrder.Prepend);
		}

		/// <summary>Applies the specified translation to the local geometric transform in the specified order.</summary>
		/// <param name="dx">The value of the translation in x.</param>
		/// <param name="dy">The value of the translation in y.</param>
		/// <param name="order">The order (prepend or append) in which to apply the translation.</param>
		public void TranslateTransform(float dx, float dy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipTranslatePathGradientTransform(new HandleRef(this, base.NativeBrush), dx, dy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Scales the local geometric transform by the specified amounts. This method prepends the scaling matrix to the transform.</summary>
		/// <param name="sx">The transform scale factor in the x-axis direction.</param>
		/// <param name="sy">The transform scale factor in the y-axis direction.</param>
		public void ScaleTransform(float sx, float sy)
		{
			ScaleTransform(sx, sy, MatrixOrder.Prepend);
		}

		/// <summary>Scales the local geometric transform by the specified amounts in the specified order.</summary>
		/// <param name="sx">The transform scale factor in the x-axis direction.</param>
		/// <param name="sy">The transform scale factor in the y-axis direction.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the scaling matrix.</param>
		public void ScaleTransform(float sx, float sy, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipScalePathGradientTransform(new HandleRef(this, base.NativeBrush), sx, sy, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		/// <summary>Rotates the local geometric transform by the specified amount. This method prepends the rotation to the transform.</summary>
		/// <param name="angle">The angle (extent) of rotation.</param>
		public void RotateTransform(float angle)
		{
			RotateTransform(angle, MatrixOrder.Prepend);
		}

		/// <summary>Rotates the local geometric transform by the specified amount in the specified order.</summary>
		/// <param name="angle">The angle (extent) of rotation.</param>
		/// <param name="order">A <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> that specifies whether to append or prepend the rotation matrix.</param>
		public void RotateTransform(float angle, MatrixOrder order)
		{
			int num = SafeNativeMethods.Gdip.GdipRotatePathGradientTransform(new HandleRef(this, base.NativeBrush), angle, order);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private void _SetWrapMode(WrapMode wrapMode)
		{
			int num = SafeNativeMethods.Gdip.GdipSetPathGradientWrapMode(new HandleRef(this, base.NativeBrush), (int)wrapMode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
		}

		private WrapMode _GetWrapMode()
		{
			int wrapmode = 0;
			int num = SafeNativeMethods.Gdip.GdipGetPathGradientWrapMode(new HandleRef(this, base.NativeBrush), out wrapmode);
			if (num != 0)
			{
				throw SafeNativeMethods.Gdip.StatusException(num);
			}
			return (WrapMode)wrapmode;
		}
	}
	/// <summary>Specifies the type of point in a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object.</summary>
	public enum PathPointType
	{
		/// <summary>The starting point of a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> object.</summary>
		Start = 0,
		/// <summary>A line segment.</summary>
		Line = 1,
		/// <summary>A default Bézier curve.</summary>
		Bezier = 3,
		/// <summary>A mask point.</summary>
		PathTypeMask = 7,
		/// <summary>The corresponding segment is dashed.</summary>
		DashMode = 16,
		/// <summary>A path marker.</summary>
		PathMarker = 32,
		/// <summary>The endpoint of a subpath.</summary>
		CloseSubpath = 128,
		/// <summary>A cubic Bézier curve.</summary>
		Bezier3 = 3
	}
	/// <summary>Specifies the alignment of a <see cref="T:System.Drawing.Pen" /> object in relation to the theoretical, zero-width line.</summary>
	public enum PenAlignment
	{
		/// <summary>Specifies that the <see cref="T:System.Drawing.Pen" /> object is centered over the theoretical line.</summary>
		Center,
		/// <summary>Specifies that the <see cref="T:System.Drawing.Pen" /> is positioned on the inside of the theoretical line.</summary>
		Inset,
		/// <summary>Specifies the <see cref="T:System.Drawing.Pen" /> is positioned on the outside of the theoretical line.</summary>
		Outset,
		/// <summary>Specifies the <see cref="T:System.Drawing.Pen" /> is positioned to the left of the theoretical line.</summary>
		Left,
		/// <summary>Specifies the <see cref="T:System.Drawing.Pen" /> is positioned to the right of the theoretical line.</summary>
		Right
	}
	/// <summary>Specifies the type of fill a <see cref="T:System.Drawing.Pen" /> object uses to fill lines.</summary>
	public enum PenType
	{
		/// <summary>Specifies a solid fill.</summary>
		SolidColor,
		/// <summary>Specifies a hatch fill.</summary>
		HatchFill,
		/// <summary>Specifies a bitmap texture fill.</summary>
		TextureFill,
		/// <summary>Specifies a path gradient fill.</summary>
		PathGradient,
		/// <summary>Specifies a linear gradient fill.</summary>
		LinearGradient
	}
	/// <summary>Specifies how pixels are offset during rendering.</summary>
	public enum PixelOffsetMode
	{
		/// <summary>Specifies an invalid mode.</summary>
		Invalid = -1,
		/// <summary>Specifies the default mode.</summary>
		Default,
		/// <summary>Specifies high speed, low quality rendering.</summary>
		HighSpeed,
		/// <summary>Specifies high quality, low speed rendering.</summary>
		HighQuality,
		/// <summary>Specifies no pixel offset.</summary>
		None,
		/// <summary>Specifies that pixels are offset by -.5 units, both horizontally and vertically, for high speed antialiasing.</summary>
		Half
	}
	/// <summary>Specifies the overall quality when rendering GDI+ objects.</summary>
	public enum QualityMode
	{
		/// <summary>Specifies an invalid mode.</summary>
		Invalid = -1,
		/// <summary>Specifies the default mode.</summary>
		Default,
		/// <summary>Specifies low quality, high speed rendering.</summary>
		Low,
		/// <summary>Specifies high quality, low speed rendering.</summary>
		High
	}
	/// <summary>Encapsulates the data that makes up a <see cref="T:System.Drawing.Region" /> object. This class cannot be inherited.</summary>
	public sealed class RegionData
	{
		private byte[] data;

		/// <summary>Gets or sets an array of bytes that specify the <see cref="T:System.Drawing.Region" /> object.</summary>
		/// <returns>An array of bytes that specify the <see cref="T:System.Drawing.Region" /> object.</returns>
		public byte[] Data
		{
			get
			{
				return data;
			}
			set
			{
				data = value;
			}
		}

		internal RegionData(byte[] data)
		{
			this.data = data;
		}
	}
	[SecurityCritical]
	internal class SafeCustomLineCapHandle : SafeHandle
	{
		public override bool IsInvalid => handle == IntPtr.Zero;

		internal SafeCustomLineCapHandle(IntPtr h)
			: base(IntPtr.Zero, ownsHandle: true)
		{
			SetHandle(h);
		}

		[SecurityCritical]
		protected override bool ReleaseHandle()
		{
			int num = 0;
			if (!IsInvalid)
			{
				try
				{
					num = SafeNativeMethods.Gdip.GdipDeleteCustomLineCap(new HandleRef(this, handle));
				}
				catch (Exception ex)
				{
					if (ClientUtils.IsSecurityOrCriticalException(ex))
					{
						throw;
					}
				}
				finally
				{
					handle = IntPtr.Zero;
				}
			}
			return num == 0;
		}

		public static implicit operator IntPtr(SafeCustomLineCapHandle handle)
		{
			return handle?.handle ?? IntPtr.Zero;
		}

		public static explicit operator SafeCustomLineCapHandle(IntPtr handle)
		{
			return new SafeCustomLineCapHandle(handle);
		}
	}
	/// <summary>Specifies whether smoothing (antialiasing) is applied to lines and curves and the edges of filled areas.</summary>
	public enum SmoothingMode
	{
		/// <summary>Specifies an invalid mode.</summary>
		Invalid = -1,
		/// <summary>Specifies no antialiasing.</summary>
		Default,
		/// <summary>Specifies no antialiasing.</summary>
		HighSpeed,
		/// <summary>Specifies antialiased rendering.</summary>
		HighQuality,
		/// <summary>Specifies no antialiasing.</summary>
		None,
		/// <summary>Specifies antialiased rendering.</summary>
		AntiAlias
	}
	/// <summary>Specifies the type of warp transformation applied in a <see cref="Overload:System.Drawing.Drawing2D.GraphicsPath.Warp" /> method.</summary>
	public enum WarpMode
	{
		/// <summary>Specifies a perspective warp.</summary>
		Perspective,
		/// <summary>Specifies a bilinear warp.</summary>
		Bilinear
	}
	/// <summary>Specifies how a texture or gradient is tiled when it is smaller than the area being filled.</summary>
	public enum WrapMode
	{
		/// <summary>Tiles the gradient or texture.</summary>
		Tile,
		/// <summary>Reverses the texture or gradient horizontally and then tiles the texture or gradient.</summary>
		TileFlipX,
		/// <summary>Reverses the texture or gradient vertically and then tiles the texture or gradient.</summary>
		TileFlipY,
		/// <summary>Reverses the texture or gradient horizontally and vertically and then tiles the texture or gradient.</summary>
		TileFlipXY,
		/// <summary>The texture or gradient is not tiled.</summary>
		Clamp
	}
}
namespace System.Drawing.Internal
{
	[ReflectionPermission(SecurityAction.Assert, MemberAccess = true)]
	[EnvironmentPermission(SecurityAction.Assert, Unrestricted = true)]
	[FileIOPermission(SecurityAction.Assert, Unrestricted = true)]
	[SecurityPermission(SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]
	[UIPermission(SecurityAction.Assert, Unrestricted = true)]
	internal sealed class DbgUtil
	{
		public const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 256;

		public const int FORMAT_MESSAGE_IGNORE_INSERTS = 512;

		public const int FORMAT_MESSAGE_FROM_SYSTEM = 4096;

		public const int FORMAT_MESSAGE_DEFAULT = 4608;

		public static int gdipInitMaxFrameCount = 8;

		public static int gdiUseMaxFrameCount = 8;

		public static int finalizeMaxFrameCount = 5;

		public static string StackTrace => Environment.StackTrace;

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetUserDefaultLCID();

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int FormatMessage(int dwFlags, HandleRef lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, HandleRef arguments);

		[Conditional("DEBUG")]
		public static void AssertFinalization(object obj, bool disposing)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string message)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string format, object arg1)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string format, object arg1, object arg2)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string format, object arg1, object arg2, object arg3)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string format, object arg1, object arg2, object arg3, object arg4)
		{
		}

		[Conditional("DEBUG")]
		public static void AssertWin32(bool expression, string format, object arg1, object arg2, object arg3, object arg4, object arg5)
		{
		}

		[Conditional("DEBUG")]
		private static void AssertWin32Impl(bool expression, string format, object[] args)
		{
		}

		public static string GetLastErrorStr()
		{
			int num = 255;
			StringBuilder stringBuilder = new StringBuilder(num);
			string empty = string.Empty;
			int num2 = 0;
			try
			{
				num2 = Marshal.GetLastWin32Error();
				empty = ((FormatMessage(4608, new HandleRef(null, IntPtr.Zero), num2, GetUserDefaultLCID(), stringBuilder, num, new HandleRef(null, IntPtr.Zero)) != 0) ? stringBuilder.ToString() : "<error returned>");
			}
			catch (Exception ex)
			{
				if (IsCriticalException(ex))
				{
					throw;
				}
				empty = ex.ToString();
			}
			return string.Format(CultureInfo.CurrentCulture, "0x{0:x8} - {1}", new object[2] { num2, empty });
		}

		private static bool IsCriticalException(Exception ex)
		{
			if (!(ex is StackOverflowException) && !(ex is OutOfMemoryException))
			{
				return ex is ThreadAbortException;
			}
			return true;
		}

		public static string StackFramesToStr(int maxFrameCount)
		{
			string text = string.Empty;
			try
			{
				StackTrace stackTrace = new StackTrace(fNeedFileInfo: true);
				int i;
				for (i = 0; i < stackTrace.FrameCount; i++)
				{
					StackFrame frame = stackTrace.GetFrame(i);
					if (frame == null || frame.GetMethod().DeclaringType != typeof(DbgUtil))
					{
						break;
					}
				}
				maxFrameCount += i;
				if (maxFrameCount > stackTrace.FrameCount)
				{
					maxFrameCount = stackTrace.FrameCount;
				}
				for (int j = i; j < maxFrameCount; j++)
				{
					StackFrame frame2 = stackTrace.GetFrame(j);
					if (frame2 == null)
					{
						continue;
					}
					MethodBase method = frame2.GetMethod();
					if (!(method == null))
					{
						string text2 = string.Empty;
						string text3 = frame2.GetFileName();
						int num = text3?.LastIndexOf('\\') ?? (-1);
						if (num != -1)
						{
							text3 = text3.Substring(num + 1, text3.Length - num - 1);
						}
						ParameterInfo[] parameters = method.GetParameters();
						foreach (ParameterInfo parameterInfo in parameters)
						{
							text2 = text2 + parameterInfo.ParameterType.Name + ", ";
						}
						if (text2.Length > 0)
						{
							text2 = text2.Substring(0, text2.Length - 2);
						}
						text += string.Format(CultureInfo.CurrentCulture, "at {0} {1}.{2}({3})\r\n", text3, method.DeclaringType, method.Name, text2);
					}
				}
			}
			catch (Exception ex)
			{
				if (IsCriticalException(ex))
				{
					throw;
				}
				text += ex.ToString();
			}
			return text.ToString();
		}

		public static string StackFramesToStr()
		{
			return StackFramesToStr(gdipInitMaxFrameCount);
		}

		public static string StackTraceToStr(string message, int frameCount)
		{
			return string.Format(CultureInfo.CurrentCulture, "{0}\r\nTop Stack Trace:\r\n{1}", new object[2]
			{
				message,
				StackFramesToStr(frameCount)
			});
		}

		public static string StackTraceToStr(string message)
		{
			return StackTraceToStr(message, gdipInitMaxFrameCount);
		}
	}
	[Flags]
	internal enum ApplyGraphicsProperties
	{
		None = 0,
		Clipping = 1,
		TranslateTransform = 2,
		All = 3
	}
	internal sealed class DeviceContext : MarshalByRefObject, IDeviceContext, IDisposable
	{
		internal class GraphicsState
		{
			internal IntPtr hBrush;

			internal IntPtr hFont;

			internal IntPtr hPen;

			internal IntPtr hBitmap;
		}

		private IntPtr hDC;

		private DeviceContextType dcType;

		private bool disposed;

		private IntPtr hWnd = (IntPtr)(-1);

		private IntPtr hInitialPen;

		private IntPtr hInitialBrush;

		private IntPtr hInitialBmp;

		private IntPtr hInitialFont;

		private IntPtr hCurrentPen;

		private IntPtr hCurrentBrush;

		private IntPtr hCurrentBmp;

		private IntPtr hCurrentFont;

		private Stack contextStack;

		public DeviceContextType DeviceContextType => dcType;

		public IntPtr Hdc
		{
			get
			{
				if (hDC == IntPtr.Zero && dcType == DeviceContextType.Display)
				{
					hDC = ((IDeviceContext)this).GetHdc();
					CacheInitialState();
				}
				return hDC;
			}
		}

		public DeviceContextGraphicsMode GraphicsMode => (DeviceContextGraphicsMode)IntUnsafeNativeMethods.GetGraphicsMode(new HandleRef(this, Hdc));

		public event EventHandler Disposing;

		private void CacheInitialState()
		{
			hCurrentPen = (hInitialPen = IntUnsafeNativeMethods.GetCurrentObject(new HandleRef(this, hDC), 1));
			hCurrentBrush = (hInitialBrush = IntUnsafeNativeMethods.GetCurrentObject(new HandleRef(this, hDC), 2));
			hCurrentBmp = (hInitialBmp = IntUnsafeNativeMethods.GetCurrentObject(new HandleRef(this, hDC), 7));
			hCurrentFont = (hInitialFont = IntUnsafeNativeMethods.GetCurrentObject(new HandleRef(this, hDC), 6));
		}

		public void DeleteObject(IntPtr handle, GdiObjectType type)
		{
			IntPtr handle2 = IntPtr.Zero;
			switch (type)
			{
			case GdiObjectType.Pen:
				if (handle == hCurrentPen)
				{
					IntPtr intPtr2 = IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(this, hInitialPen));
					hCurrentPen = IntPtr.Zero;
				}
				handle2 = handle;
				break;
			case GdiObjectType.Brush:
				if (handle == hCurrentBrush)
				{
					IntPtr intPtr3 = IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(this, hInitialBrush));
					hCurrentBrush = IntPtr.Zero;
				}
				handle2 = handle;
				break;
			case GdiObjectType.Bitmap:
				if (handle == hCurrentBmp)
				{
					IntPtr intPtr = IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(this, hInitialBmp));
					hCurrentBmp = IntPtr.Zero;
				}
				handle2 = handle;
				break;
			}
			IntUnsafeNativeMethods.DeleteObject(new HandleRef(this, handle2));
		}

		private DeviceContext(IntPtr hWnd)
		{
			this.hWnd = hWnd;
			dcType = DeviceContextType.Display;
			DeviceContexts.AddDeviceContext(this);
		}

		private DeviceContext(IntPtr hDC, DeviceContextType dcType)
		{
			this.hDC = hDC;
			this.dcType = dcType;
			CacheInitialState();
			DeviceContexts.AddDeviceContext(this);
			if (dcType == DeviceContextType.Display)
			{
				hWnd = IntUnsafeNativeMethods.WindowFromDC(new HandleRef(this, this.hDC));
			}
		}

		public static DeviceContext CreateDC(string driverName, string deviceName, string fileName, HandleRef devMode)
		{
			IntPtr intPtr = IntUnsafeNativeMethods.CreateDC(driverName, deviceName, fileName, devMode);
			return new DeviceContext(intPtr, DeviceContextType.NamedDevice);
		}

		public static DeviceContext CreateIC(string driverName, string deviceName, string fileName, HandleRef devMode)
		{
			IntPtr intPtr = IntUnsafeNativeMethods.CreateIC(driverName, deviceName, fileName, devMode);
			return new DeviceContext(intPtr, DeviceContextType.Information);
		}

		public static DeviceContext FromCompatibleDC(IntPtr hdc)
		{
			IntPtr intPtr = IntUnsafeNativeMethods.CreateCompatibleDC(new HandleRef(null, hdc));
			return new DeviceContext(intPtr, DeviceContextType.Memory);
		}

		public static DeviceContext FromHdc(IntPtr hdc)
		{
			return new DeviceContext(hdc, DeviceContextType.Unknown);
		}

		public static DeviceContext FromHwnd(IntPtr hwnd)
		{
			return new DeviceContext(hwnd);
		}

		~DeviceContext()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		internal void Dispose(bool disposing)
		{
			if (!disposed)
			{
				if (this.Disposing != null)
				{
					this.Disposing(this, EventArgs.Empty);
				}
				disposed = true;
				switch (dcType)
				{
				case DeviceContextType.Display:
					((IDeviceContext)this).ReleaseHdc();
					break;
				case DeviceContextType.NamedDevice:
				case DeviceContextType.Information:
					IntUnsafeNativeMethods.DeleteHDC(new HandleRef(this, hDC));
					hDC = IntPtr.Zero;
					break;
				case DeviceContextType.Memory:
					IntUnsafeNativeMethods.DeleteDC(new HandleRef(this, hDC));
					hDC = IntPtr.Zero;
					break;
				case DeviceContextType.Unknown:
				case DeviceContextType.NCWindow:
					break;
				}
			}
		}

		IntPtr IDeviceContext.GetHdc()
		{
			if (hDC == IntPtr.Zero)
			{
				hDC = IntUnsafeNativeMethods.GetDC(new HandleRef(this, hWnd));
			}
			return hDC;
		}

		void IDeviceContext.ReleaseHdc()
		{
			if (hDC != IntPtr.Zero && dcType == DeviceContextType.Display)
			{
				IntUnsafeNativeMethods.ReleaseDC(new HandleRef(this, hWnd), new HandleRef(this, hDC));
				hDC = IntPtr.Zero;
			}
		}

		public DeviceContextGraphicsMode SetGraphicsMode(DeviceContextGraphicsMode newMode)
		{
			return (DeviceContextGraphicsMode)IntUnsafeNativeMethods.SetGraphicsMode(new HandleRef(this, Hdc), (int)newMode);
		}

		public void RestoreHdc()
		{
			IntUnsafeNativeMethods.RestoreDC(new HandleRef(this, hDC), -1);
			if (contextStack != null)
			{
				GraphicsState graphicsState = (GraphicsState)contextStack.Pop();
				hCurrentBmp = graphicsState.hBitmap;
				hCurrentBrush = graphicsState.hBrush;
				hCurrentPen = graphicsState.hPen;
				hCurrentFont = graphicsState.hFont;
			}
		}

		public int SaveHdc()
		{
			HandleRef handleRef = new HandleRef(this, Hdc);
			int result = IntUnsafeNativeMethods.SaveDC(handleRef);
			if (contextStack == null)
			{
				contextStack = new Stack();
			}
			GraphicsState graphicsState = new GraphicsState();
			graphicsState.hBitmap = hCurrentBmp;
			graphicsState.hBrush = hCurrentBrush;
			graphicsState.hPen = hCurrentPen;
			graphicsState.hFont = hCurrentFont;
			contextStack.Push(graphicsState);
			return result;
		}

		public void SetClip(WindowsRegion region)
		{
			HandleRef handleRef = new HandleRef(this, Hdc);
			HandleRef hRgn = new HandleRef(region, region.HRegion);
			IntUnsafeNativeMethods.SelectClipRgn(handleRef, hRgn);
		}

		public void IntersectClip(WindowsRegion wr)
		{
			if (wr.HRegion == IntPtr.Zero)
			{
				return;
			}
			WindowsRegion windowsRegion = new WindowsRegion(0, 0, 0, 0);
			try
			{
				int clipRgn = IntUnsafeNativeMethods.GetClipRgn(new HandleRef(this, Hdc), new HandleRef(windowsRegion, windowsRegion.HRegion));
				if (clipRgn == 1)
				{
					wr.CombineRegion(windowsRegion, wr, RegionCombineMode.AND);
				}
				SetClip(wr);
			}
			finally
			{
				windowsRegion.Dispose();
			}
		}

		public void TranslateTransform(int dx, int dy)
		{
			IntNativeMethods.POINT point = new IntNativeMethods.POINT();
			IntUnsafeNativeMethods.OffsetViewportOrgEx(new HandleRef(this, Hdc), dx, dy, point);
		}

		public override bool Equals(object obj)
		{
			DeviceContext deviceContext = obj as DeviceContext;
			if (deviceContext == this)
			{
				return true;
			}
			if (deviceContext == null)
			{
				return false;
			}
			return deviceContext.Hdc == Hdc;
		}

		public override int GetHashCode()
		{
			return Hdc.GetHashCode();
		}
	}
	internal static class DeviceContexts
	{
		[ThreadStatic]
		private static ClientUtils.WeakRefCollection activeDeviceContexts;

		internal static void AddDeviceContext(DeviceContext dc)
		{
			if (activeDeviceContexts == null)
			{
				activeDeviceContexts = new ClientUtils.WeakRefCollection();
				activeDeviceContexts.RefCheckThreshold = 20;
			}
			if (!activeDeviceContexts.Contains(dc))
			{
				dc.Disposing += OnDcDisposing;
				activeDeviceContexts.Add(dc);
			}
		}

		private static void OnDcDisposing(object sender, EventArgs e)
		{
			if (sender is DeviceContext deviceContext)
			{
				deviceContext.Disposing -= OnDcDisposing;
				RemoveDeviceContext(deviceContext);
			}
		}

		internal static void RemoveDeviceContext(DeviceContext dc)
		{
			if (activeDeviceContexts != null)
			{
				activeDeviceContexts.RemoveByHashCode(dc);
			}
		}
	}
	internal enum DeviceContextGraphicsMode
	{
		Compatible = 1,
		Advanced = 2,
		ModifyWorldIdentity = 1
	}
	internal enum DeviceContextType
	{
		Unknown,
		Display,
		NCWindow,
		NamedDevice,
		Information,
		Memory,
		Metafile
	}
	internal enum GdiObjectType
	{
		Pen = 1,
		Brush,
		DisplayDC,
		MetafileDC,
		Palette,
		Font,
		Bitmap,
		Region,
		Metafile,
		MemoryDC,
		ExtendedPen,
		EnhancedMetafileDC,
		EnhMetafile,
		ColorSpace
	}
	internal sealed class WindowsRegion : MarshalByRefObject, ICloneable, IDisposable
	{
		private IntPtr nativeHandle;

		private bool ownHandle;

		public IntPtr HRegion => nativeHandle;

		public bool IsInfinite => nativeHandle == IntPtr.Zero;

		private WindowsRegion()
		{
		}

		public WindowsRegion(Rectangle rect)
		{
			CreateRegion(rect);
		}

		public WindowsRegion(int x, int y, int width, int height)
		{
			CreateRegion(new Rectangle(x, y, width, height));
		}

		public static WindowsRegion FromHregion(IntPtr hRegion, bool takeOwnership)
		{
			WindowsRegion windowsRegion = new WindowsRegion();
			if (hRegion != IntPtr.Zero)
			{
				windowsRegion.nativeHandle = hRegion;
				if (takeOwnership)
				{
					windowsRegion.ownHandle = true;
					System.Internal.HandleCollector.Add(hRegion, IntSafeNativeMethods.CommonHandles.GDI);
				}
			}
			return windowsRegion;
		}

		public static WindowsRegion FromRegion(Region region, Graphics g)
		{
			if (region.IsInfinite(g))
			{
				return new WindowsRegion();
			}
			return FromHregion(region.GetHrgn(g), takeOwnership: true);
		}

		public object Clone()
		{
			if (!IsInfinite)
			{
				return new WindowsRegion(ToRectangle());
			}
			return new WindowsRegion();
		}

		public IntNativeMethods.RegionFlags CombineRegion(WindowsRegion region1, WindowsRegion region2, RegionCombineMode mode)
		{
			return IntUnsafeNativeMethods.CombineRgn(new HandleRef(this, HRegion), new HandleRef(region1, region1.HRegion), new HandleRef(region2, region2.HRegion), mode);
		}

		private void CreateRegion(Rectangle rect)
		{
			nativeHandle = IntSafeNativeMethods.CreateRectRgn(rect.X, rect.Y, rect.X + rect.Width, rect.Y + rect.Height);
			ownHandle = true;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		public void Dispose(bool disposing)
		{
			if (nativeHandle != IntPtr.Zero)
			{
				if (ownHandle)
				{
					IntUnsafeNativeMethods.DeleteObject(new HandleRef(this, nativeHandle));
				}
				nativeHandle = IntPtr.Zero;
				if (disposing)
				{
					GC.SuppressFinalize(this);
				}
			}
		}

		~WindowsRegion()
		{
			Dispose(disposing: false);
		}

		public Rectangle ToRectangle()
		{
			if (IsInfinite)
			{
				return new Rectangle(-2147483647, -2147483647, int.MaxValue, int.MaxValue);
			}
			IntNativeMethods.RECT clipRect = default(IntNativeMethods.RECT);
			IntUnsafeNativeMethods.GetRgnBox(new HandleRef(this, nativeHandle), ref clipRect);
			return new Rectangle(new Point(clipRect.left, clipRect.top), clipRect.Size);
		}
	}
	internal enum RegionCombineMode
	{
		AND = 1,
		OR = 2,
		XOR = 3,
		DIFF = 4,
		COPY = 5,
		MIN = 1,
		MAX = 5
	}
	internal sealed class WindowsGraphics : MarshalByRefObject, IDisposable, IDeviceContext
	{
		private DeviceContext dc;

		private bool disposeDc;

		private Graphics graphics;

		public DeviceContext DeviceContext => dc;

		public WindowsGraphics(DeviceContext dc)
		{
			this.dc = dc;
			this.dc.SaveHdc();
		}

		public static WindowsGraphics CreateMeasurementWindowsGraphics()
		{
			DeviceContext deviceContext = DeviceContext.FromCompatibleDC(IntPtr.Zero);
			WindowsGraphics windowsGraphics = new WindowsGraphics(deviceContext);
			windowsGraphics.disposeDc = true;
			return windowsGraphics;
		}

		public static WindowsGraphics CreateMeasurementWindowsGraphics(IntPtr screenDC)
		{
			DeviceContext deviceContext = DeviceContext.FromCompatibleDC(screenDC);
			WindowsGraphics windowsGraphics = new WindowsGraphics(deviceContext);
			windowsGraphics.disposeDc = true;
			return windowsGraphics;
		}

		public static WindowsGraphics FromHwnd(IntPtr hWnd)
		{
			DeviceContext deviceContext = DeviceContext.FromHwnd(hWnd);
			WindowsGraphics windowsGraphics = new WindowsGraphics(deviceContext);
			windowsGraphics.disposeDc = true;
			return windowsGraphics;
		}

		public static WindowsGraphics FromHdc(IntPtr hDc)
		{
			DeviceContext deviceContext = DeviceContext.FromHdc(hDc);
			WindowsGraphics windowsGraphics = new WindowsGraphics(deviceContext);
			windowsGraphics.disposeDc = true;
			return windowsGraphics;
		}

		public static WindowsGraphics FromGraphics(Graphics g)
		{
			ApplyGraphicsProperties properties = ApplyGraphicsProperties.All;
			return FromGraphics(g, properties);
		}

		public static WindowsGraphics FromGraphics(Graphics g, ApplyGraphicsProperties properties)
		{
			WindowsRegion windowsRegion = null;
			float[] array = null;
			Region region = null;
			Matrix matrix = null;
			if ((properties & ApplyGraphicsProperties.TranslateTransform) != 0 || (properties & ApplyGraphicsProperties.Clipping) != 0)
			{
				if (g.GetContextInfo() is object[] array2 && array2.Length == 2)
				{
					region = array2[0] as Region;
					matrix = array2[1] as Matrix;
				}
				if (matrix != null)
				{
					if ((properties & ApplyGraphicsProperties.TranslateTransform) != 0)
					{
						array = matrix.Elements;
					}
					matrix.Dispose();
				}
				if (region != null)
				{
					if ((properties & ApplyGraphicsProperties.Clipping) != 0 && !region.IsInfinite(g))
					{
						windowsRegion = WindowsRegion.FromRegion(region, g);
					}
					region.Dispose();
				}
			}
			WindowsGraphics windowsGraphics = FromHdc(g.GetHdc());
			windowsGraphics.graphics = g;
			if (windowsRegion != null)
			{
				using (windowsRegion)
				{
					windowsGraphics.DeviceContext.IntersectClip(windowsRegion);
				}
			}
			if (array != null)
			{
				windowsGraphics.DeviceContext.TranslateTransform((int)array[4], (int)array[5]);
			}
			return windowsGraphics;
		}

		~WindowsGraphics()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		internal void Dispose(bool disposing)
		{
			if (dc == null)
			{
				return;
			}
			try
			{
				dc.RestoreHdc();
				if (disposeDc)
				{
					dc.Dispose(disposing);
				}
				if (graphics != null)
				{
					graphics.ReleaseHdcInternal(dc.Hdc);
					graphics = null;
				}
			}
			catch (Exception ex)
			{
				if (ClientUtils.IsSecurityOrCriticalException(ex))
				{
					throw;
				}
			}
			finally
			{
				dc = null;
			}
		}

		public IntPtr GetHdc()
		{
			return dc.Hdc;
		}

		public void ReleaseHdc()
		{
			dc.Dispose();
		}
	}
	internal class IntNativeMethods
	{
		public enum RegionFlags
		{
			ERROR,
			NULLREGION,
			SIMPLEREGION,
			COMPLEXREGION
		}

		public struct RECT
		{
			public int left;

			public int top;

			public int right;

			public int bottom;

			public Size Size => new Size(right - left, bottom - top);

			public RECT(int left, int top, int right, int bottom)
			{
				this.left = left;
				this.top = top;
				this.right = right;
				this.bottom = bottom;
			}

			public RECT(Rectangle r)
			{
				left = r.Left;
				top = r.Top;
				right = r.Right;
				bottom = r.Bottom;
			}

			public static RECT FromXYWH(int x, int y, int width, int height)
			{
				return new RECT(x, y, x + width, y + height);
			}

			public Rectangle ToRectangle()
			{
				return new Rectangle(left, top, right - left, bottom - top);
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public class POINT
		{
			public int x;

			public int y;

			public POINT()
			{
			}

			public POINT(int x, int y)
			{
				this.x = x;
				this.y = y;
			}

			public Point ToPoint()
			{
				return new Point(x, y);
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public class DRAWTEXTPARAMS
		{
			private int cbSize = Marshal.SizeOf(typeof(DRAWTEXTPARAMS));

			public int iTabLength;

			public int iLeftMargin;

			public int iRightMargin;

			public int uiLengthDrawn;

			public DRAWTEXTPARAMS()
			{
			}

			public DRAWTEXTPARAMS(DRAWTEXTPARAMS original)
			{
				iLeftMargin = original.iLeftMargin;
				iRightMargin = original.iRightMargin;
				iTabLength = original.iTabLength;
			}

			public DRAWTEXTPARAMS(int leftMargin, int rightMargin)
			{
				iLeftMargin = leftMargin;
				iRightMargin = rightMargin;
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public class LOGBRUSH
		{
			public int lbStyle;

			public int lbColor;

			public int lbHatch;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public class LOGFONT
		{
			public int lfHeight;

			public int lfWidth;

			public int lfEscapement;

			public int lfOrientation;

			public int lfWeight;

			public byte lfItalic;

			public byte lfUnderline;

			public byte lfStrikeOut;

			public byte lfCharSet;

			public byte lfOutPrecision;

			public byte lfClipPrecision;

			public byte lfQuality;

			public byte lfPitchAndFamily;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
			public string lfFaceName;

			public LOGFONT()
			{
			}

			public LOGFONT(LOGFONT lf)
			{
				lfHeight = lf.lfHeight;
				lfWidth = lf.lfWidth;
				lfEscapement = lf.lfEscapement;
				lfOrientation = lf.lfOrientation;
				lfWeight = lf.lfWeight;
				lfItalic = lf.lfItalic;
				lfUnderline = lf.lfUnderline;
				lfStrikeOut = lf.lfStrikeOut;
				lfCharSet = lf.lfCharSet;
				lfOutPrecision = lf.lfOutPrecision;
				lfClipPrecision = lf.lfClipPrecision;
				lfQuality = lf.lfQuality;
				lfPitchAndFamily = lf.lfPitchAndFamily;
				lfFaceName = lf.lfFaceName;
			}
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		public struct TEXTMETRIC
		{
			public int tmHeight;

			public int tmAscent;

			public int tmDescent;

			public int tmInternalLeading;

			public int tmExternalLeading;

			public int tmAveCharWidth;

			public int tmMaxCharWidth;

			public int tmWeight;

			public int tmOverhang;

			public int tmDigitizedAspectX;

			public int tmDigitizedAspectY;

			public char tmFirstChar;

			public char tmLastChar;

			public char tmDefaultChar;

			public char tmBreakChar;

			public byte tmItalic;

			public byte tmUnderlined;

			public byte tmStruckOut;

			public byte tmPitchAndFamily;

			public byte tmCharSet;
		}

		public struct TEXTMETRICA
		{
			public int tmHeight;

			public int tmAscent;

			public int tmDescent;

			public int tmInternalLeading;

			public int tmExternalLeading;

			public int tmAveCharWidth;

			public int tmMaxCharWidth;

			public int tmWeight;

			public int tmOverhang;

			public int tmDigitizedAspectX;

			public int tmDigitizedAspectY;

			public byte tmFirstChar;

			public byte tmLastChar;

			public byte tmDefaultChar;

			public byte tmBreakChar;

			public byte tmItalic;

			public byte tmUnderlined;

			public byte tmStruckOut;

			public byte tmPitchAndFamily;

			public byte tmCharSet;
		}

		[StructLayout(LayoutKind.Sequential)]
		public class SIZE
		{
			public int cx;

			public int cy;

			public SIZE()
			{
			}

			public SIZE(int cx, int cy)
			{
				this.cx = cx;
				this.cy = cy;
			}

			public Size ToSize()
			{
				return new Size(cx, cy);
			}
		}

		public const int MaxTextLengthInWin9x = 8192;

		public const int DT_TOP = 0;

		public const int DT_LEFT = 0;

		public const int DT_CENTER = 1;

		public const int DT_RIGHT = 2;

		public const int DT_VCENTER = 4;

		public const int DT_BOTTOM = 8;

		public const int DT_WORDBREAK = 16;

		public const int DT_SINGLELINE = 32;

		public const int DT_EXPANDTABS = 64;

		public const int DT_TABSTOP = 128;

		public const int DT_NOCLIP = 256;

		public const int DT_EXTERNALLEADING = 512;

		public const int DT_CALCRECT = 1024;

		public const int DT_NOPREFIX = 2048;

		public const int DT_INTERNAL = 4096;

		public const int DT_EDITCONTROL = 8192;

		public const int DT_PATH_ELLIPSIS = 16384;

		public const int DT_END_ELLIPSIS = 32768;

		public const int DT_MODIFYSTRING = 65536;

		public const int DT_RTLREADING = 131072;

		public const int DT_WORD_ELLIPSIS = 262144;

		public const int DT_NOFULLWIDTHCHARBREAK = 524288;

		public const int DT_HIDEPREFIX = 1048576;

		public const int DT_PREFIXONLY = 2097152;

		public const int DIB_RGB_COLORS = 0;

		public const int BI_BITFIELDS = 3;

		public const int BI_RGB = 0;

		public const int BITMAPINFO_MAX_COLORSIZE = 256;

		public const int SPI_GETICONTITLELOGFONT = 31;

		public const int SPI_GETNONCLIENTMETRICS = 41;

		public const int DEFAULT_GUI_FONT = 17;

		public const int HOLLOW_BRUSH = 5;

		public const int BITSPIXEL = 12;

		public const int ALTERNATE = 1;

		public const int WINDING = 2;

		public const int SRCCOPY = 13369376;

		public const int SRCPAINT = 15597702;

		public const int SRCAND = 8913094;

		public const int SRCINVERT = 6684742;

		public const int SRCERASE = 4457256;

		public const int NOTSRCCOPY = 3342344;

		public const int NOTSRCERASE = 1114278;

		public const int MERGECOPY = 12583114;

		public const int MERGEPAINT = 12255782;

		public const int PATCOPY = 15728673;

		public const int PATPAINT = 16452105;

		public const int PATINVERT = 5898313;

		public const int DSTINVERT = 5570569;

		public const int BLACKNESS = 66;

		public const int WHITENESS = 16711778;

		public const int CAPTUREBLT = 1073741824;

		public const int FW_DONTCARE = 0;

		public const int FW_NORMAL = 400;

		public const int FW_BOLD = 700;

		public const int ANSI_CHARSET = 0;

		public const int DEFAULT_CHARSET = 1;

		public const int OUT_DEFAULT_PRECIS = 0;

		public const int OUT_TT_PRECIS = 4;

		public const int OUT_TT_ONLY_PRECIS = 7;

		public const int CLIP_DEFAULT_PRECIS = 0;

		public const int DEFAULT_QUALITY = 0;

		public const int DRAFT_QUALITY = 1;

		public const int PROOF_QUALITY = 2;

		public const int NONANTIALIASED_QUALITY = 3;

		public const int ANTIALIASED_QUALITY = 4;

		public const int CLEARTYPE_QUALITY = 5;

		public const int CLEARTYPE_NATURAL_QUALITY = 6;

		public const int OBJ_PEN = 1;

		public const int OBJ_BRUSH = 2;

		public const int OBJ_DC = 3;

		public const int OBJ_METADC = 4;

		public const int OBJ_FONT = 6;

		public const int OBJ_BITMAP = 7;

		public const int OBJ_MEMDC = 10;

		public const int OBJ_EXTPEN = 11;

		public const int OBJ_ENHMETADC = 12;

		public const int BS_SOLID = 0;

		public const int BS_HATCHED = 2;

		public const int CP_ACP = 0;

		public const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 256;

		public const int FORMAT_MESSAGE_IGNORE_INSERTS = 512;

		public const int FORMAT_MESSAGE_FROM_SYSTEM = 4096;

		public const int FORMAT_MESSAGE_DEFAULT = 4608;
	}
	[SuppressUnmanagedCodeSecurity]
	internal static class IntSafeNativeMethods
	{
		public sealed class CommonHandles
		{
			public static readonly int EMF;

			public static readonly int GDI;

			public static readonly int HDC;

			static CommonHandles()
			{
				EMF = System.Internal.HandleCollector.RegisterType("EnhancedMetaFile", 20, 500);
				GDI = System.Internal.HandleCollector.RegisterType("GDI", 90, 50);
				HDC = System.Internal.HandleCollector.RegisterType("HDC", 100, 2);
			}
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateSolidBrush", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCreateSolidBrush(int crColor);

		public static IntPtr CreateSolidBrush(int crColor)
		{
			return System.Internal.HandleCollector.Add(IntCreateSolidBrush(crColor), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreatePen", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntCreatePen(int fnStyle, int nWidth, int crColor);

		public static IntPtr CreatePen(int fnStyle, int nWidth, int crColor)
		{
			return System.Internal.HandleCollector.Add(IntCreatePen(fnStyle, nWidth, crColor), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "ExtCreatePen", ExactSpelling = true, SetLastError = true)]
		private static extern IntPtr IntExtCreatePen(int fnStyle, int dwWidth, IntNativeMethods.LOGBRUSH lplb, int dwStyleCount, [MarshalAs(UnmanagedType.LPArray)] int[] lpStyle);

		public static IntPtr ExtCreatePen(int fnStyle, int dwWidth, IntNativeMethods.LOGBRUSH lplb, int dwStyleCount, int[] lpStyle)
		{
			return System.Internal.HandleCollector.Add(IntExtCreatePen(fnStyle, dwWidth, lplb, dwStyleCount, lpStyle), CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateRectRgn", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateRectRgn(int x1, int y1, int x2, int y2);

		public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2)
		{
			return System.Internal.HandleCollector.Add(IntCreateRectRgn(x1, y1, x2, y2), CommonHandles.GDI);
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetUserDefaultLCID();

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool GdiFlush();
	}
	[SuppressUnmanagedCodeSecurity]
	internal static class IntUnsafeNativeMethods
	{
		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "GetDC", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntGetDC(HandleRef hWnd);

		public static IntPtr GetDC(HandleRef hWnd)
		{
			return System.Internal.HandleCollector.Add(IntGetDC(hWnd), IntSafeNativeMethods.CommonHandles.HDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "DeleteDC", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntDeleteDC(HandleRef hDC);

		public static bool DeleteDC(HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, IntSafeNativeMethods.CommonHandles.GDI);
			return IntDeleteDC(hDC);
		}

		public static bool DeleteHDC(HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, IntSafeNativeMethods.CommonHandles.HDC);
			return IntDeleteDC(hDC);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "ReleaseDC", ExactSpelling = true, SetLastError = true)]
		public static extern int IntReleaseDC(HandleRef hWnd, HandleRef hDC);

		public static int ReleaseDC(HandleRef hWnd, HandleRef hDC)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hDC, IntSafeNativeMethods.CommonHandles.HDC);
			return IntReleaseDC(hWnd, hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateDC", SetLastError = true)]
		public static extern IntPtr IntCreateDC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef lpInitData);

		public static IntPtr CreateDC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef lpInitData)
		{
			return System.Internal.HandleCollector.Add(IntCreateDC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData), IntSafeNativeMethods.CommonHandles.HDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateIC", SetLastError = true)]
		public static extern IntPtr IntCreateIC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef lpInitData);

		public static IntPtr CreateIC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef lpInitData)
		{
			return System.Internal.HandleCollector.Add(IntCreateIC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData), IntSafeNativeMethods.CommonHandles.HDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateCompatibleDC", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntCreateCompatibleDC(HandleRef hDC);

		public static IntPtr CreateCompatibleDC(HandleRef hDC)
		{
			return System.Internal.HandleCollector.Add(IntCreateCompatibleDC(hDC), IntSafeNativeMethods.CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SaveDC", ExactSpelling = true, SetLastError = true)]
		public static extern int IntSaveDC(HandleRef hDC);

		public static int SaveDC(HandleRef hDC)
		{
			return IntSaveDC(hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "RestoreDC", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntRestoreDC(HandleRef hDC, int nSavedDC);

		public static bool RestoreDC(HandleRef hDC, int nSavedDC)
		{
			return IntRestoreDC(hDC, nSavedDC);
		}

		[DllImport("user32.dll", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr WindowFromDC(HandleRef hDC);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetDeviceCaps(HandleRef hDC, int nIndex);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "OffsetViewportOrgEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntOffsetViewportOrgEx(HandleRef hDC, int nXOffset, int nYOffset, [In][Out] IntNativeMethods.POINT point);

		public static bool OffsetViewportOrgEx(HandleRef hDC, int nXOffset, int nYOffset, [In][Out] IntNativeMethods.POINT point)
		{
			return IntOffsetViewportOrgEx(hDC, nXOffset, nYOffset, point);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SetGraphicsMode", ExactSpelling = true, SetLastError = true)]
		public static extern int IntSetGraphicsMode(HandleRef hDC, int iMode);

		public static int SetGraphicsMode(HandleRef hDC, int iMode)
		{
			iMode = IntSetGraphicsMode(hDC, iMode);
			return iMode;
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetGraphicsMode(HandleRef hDC);

		[DllImport("gdi32.dll", ExactSpelling = true, SetLastError = true)]
		public static extern int GetROP2(HandleRef hdc);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SetROP2(HandleRef hDC, int nDrawMode);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CombineRgn", ExactSpelling = true, SetLastError = true)]
		public static extern IntNativeMethods.RegionFlags IntCombineRgn(HandleRef hRgnDest, HandleRef hRgnSrc1, HandleRef hRgnSrc2, RegionCombineMode combineMode);

		public static IntNativeMethods.RegionFlags CombineRgn(HandleRef hRgnDest, HandleRef hRgnSrc1, HandleRef hRgnSrc2, RegionCombineMode combineMode)
		{
			if (hRgnDest.Wrapper == null || hRgnSrc1.Wrapper == null || hRgnSrc2.Wrapper == null)
			{
				return IntNativeMethods.RegionFlags.ERROR;
			}
			return IntCombineRgn(hRgnDest, hRgnSrc1, hRgnSrc2, combineMode);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetClipRgn", ExactSpelling = true, SetLastError = true)]
		public static extern int IntGetClipRgn(HandleRef hDC, HandleRef hRgn);

		public static int GetClipRgn(HandleRef hDC, HandleRef hRgn)
		{
			return IntGetClipRgn(hDC, hRgn);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SelectClipRgn", ExactSpelling = true, SetLastError = true)]
		public static extern IntNativeMethods.RegionFlags IntSelectClipRgn(HandleRef hDC, HandleRef hRgn);

		public static IntNativeMethods.RegionFlags SelectClipRgn(HandleRef hDC, HandleRef hRgn)
		{
			return IntSelectClipRgn(hDC, hRgn);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetRgnBox", ExactSpelling = true, SetLastError = true)]
		public static extern IntNativeMethods.RegionFlags IntGetRgnBox(HandleRef hRgn, [In][Out] ref IntNativeMethods.RECT clipRect);

		public static IntNativeMethods.RegionFlags GetRgnBox(HandleRef hRgn, [In][Out] ref IntNativeMethods.RECT clipRect)
		{
			return IntGetRgnBox(hRgn, ref clipRect);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "CreateFontIndirect", SetLastError = true)]
		public static extern IntPtr IntCreateFontIndirect([In][Out][MarshalAs(UnmanagedType.AsAny)] object lf);

		public static IntPtr CreateFontIndirect(object lf)
		{
			return System.Internal.HandleCollector.Add(IntCreateFontIndirect(lf), IntSafeNativeMethods.CommonHandles.GDI);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "DeleteObject", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntDeleteObject(HandleRef hObject);

		public static bool DeleteObject(HandleRef hObject)
		{
			System.Internal.HandleCollector.Remove((IntPtr)hObject, IntSafeNativeMethods.CommonHandles.GDI);
			return IntDeleteObject(hObject);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetObject", SetLastError = true)]
		public static extern int IntGetObject(HandleRef hBrush, int nSize, [In][Out] IntNativeMethods.LOGBRUSH lb);

		public static int GetObject(HandleRef hBrush, IntNativeMethods.LOGBRUSH lb)
		{
			return IntGetObject(hBrush, Marshal.SizeOf(typeof(IntNativeMethods.LOGBRUSH)), lb);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetObject", SetLastError = true)]
		public static extern int IntGetObject(HandleRef hFont, int nSize, [In][Out] IntNativeMethods.LOGFONT lf);

		public static int GetObject(HandleRef hFont, IntNativeMethods.LOGFONT lp)
		{
			return IntGetObject(hFont, Marshal.SizeOf(typeof(IntNativeMethods.LOGFONT)), lp);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SelectObject", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntSelectObject(HandleRef hdc, HandleRef obj);

		public static IntPtr SelectObject(HandleRef hdc, HandleRef obj)
		{
			return IntSelectObject(hdc, obj);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetCurrentObject", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntGetCurrentObject(HandleRef hDC, int uObjectType);

		public static IntPtr GetCurrentObject(HandleRef hDC, int uObjectType)
		{
			return IntGetCurrentObject(hDC, uObjectType);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetStockObject", ExactSpelling = true, SetLastError = true)]
		public static extern IntPtr IntGetStockObject(int nIndex);

		public static IntPtr GetStockObject(int nIndex)
		{
			return IntGetStockObject(nIndex);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetNearestColor(HandleRef hDC, int color);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SetTextColor(HandleRef hDC, int crColor);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextAlign(HandleRef hdc);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextColor(HandleRef hDC);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SetBkColor(HandleRef hDC, int clr);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SetBkMode", ExactSpelling = true, SetLastError = true)]
		public static extern int IntSetBkMode(HandleRef hDC, int nBkMode);

		public static int SetBkMode(HandleRef hDC, int nBkMode)
		{
			return IntSetBkMode(hDC, nBkMode);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetBkMode", ExactSpelling = true, SetLastError = true)]
		public static extern int IntGetBkMode(HandleRef hDC);

		public static int GetBkMode(HandleRef hDC)
		{
			return IntGetBkMode(hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int GetBkColor(HandleRef hDC);

		[DllImport("user32.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
		public static extern int DrawTextW(HandleRef hDC, string lpszString, int nCount, ref IntNativeMethods.RECT lpRect, int nFormat);

		[DllImport("user32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
		public static extern int DrawTextA(HandleRef hDC, byte[] lpszString, int byteCount, ref IntNativeMethods.RECT lpRect, int nFormat);

		public static int DrawText(HandleRef hDC, string text, ref IntNativeMethods.RECT lpRect, int nFormat)
		{
			if (Marshal.SystemDefaultCharSize == 1)
			{
				lpRect.top = Math.Min(32767, lpRect.top);
				lpRect.left = Math.Min(32767, lpRect.left);
				lpRect.right = Math.Min(32767, lpRect.right);
				lpRect.bottom = Math.Min(32767, lpRect.bottom);
				int num = WideCharToMultiByte(0, 0, text, text.Length, null, 0, IntPtr.Zero, IntPtr.Zero);
				byte[] array = new byte[num];
				WideCharToMultiByte(0, 0, text, text.Length, array, array.Length, IntPtr.Zero, IntPtr.Zero);
				num = Math.Min(num, 8192);
				return DrawTextA(hDC, array, num, ref lpRect, nFormat);
			}
			return DrawTextW(hDC, text, text.Length, ref lpRect, nFormat);
		}

		[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
		public static extern int DrawTextExW(HandleRef hDC, string lpszString, int nCount, ref IntNativeMethods.RECT lpRect, int nFormat, [In][Out] IntNativeMethods.DRAWTEXTPARAMS lpDTParams);

		[DllImport("user32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
		public static extern int DrawTextExA(HandleRef hDC, byte[] lpszString, int byteCount, ref IntNativeMethods.RECT lpRect, int nFormat, [In][Out] IntNativeMethods.DRAWTEXTPARAMS lpDTParams);

		public static int DrawTextEx(HandleRef hDC, string text, ref IntNativeMethods.RECT lpRect, int nFormat, [In][Out] IntNativeMethods.DRAWTEXTPARAMS lpDTParams)
		{
			if (Marshal.SystemDefaultCharSize == 1)
			{
				lpRect.top = Math.Min(32767, lpRect.top);
				lpRect.left = Math.Min(32767, lpRect.left);
				lpRect.right = Math.Min(32767, lpRect.right);
				lpRect.bottom = Math.Min(32767, lpRect.bottom);
				int num = WideCharToMultiByte(0, 0, text, text.Length, null, 0, IntPtr.Zero, IntPtr.Zero);
				byte[] array = new byte[num];
				WideCharToMultiByte(0, 0, text, text.Length, array, array.Length, IntPtr.Zero, IntPtr.Zero);
				num = Math.Min(num, 8192);
				return DrawTextExA(hDC, array, num, ref lpRect, nFormat, lpDTParams);
			}
			return DrawTextExW(hDC, text, text.Length, ref lpRect, nFormat, lpDTParams);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextExtentPoint32W(HandleRef hDC, string text, int len, [In][Out] IntNativeMethods.SIZE size);

		[DllImport("gdi32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextExtentPoint32A(HandleRef hDC, byte[] lpszString, int byteCount, [In][Out] IntNativeMethods.SIZE size);

		public static int GetTextExtentPoint32(HandleRef hDC, string text, [In][Out] IntNativeMethods.SIZE size)
		{
			int length = text.Length;
			if (Marshal.SystemDefaultCharSize == 1)
			{
				length = WideCharToMultiByte(0, 0, text, text.Length, null, 0, IntPtr.Zero, IntPtr.Zero);
				byte[] array = new byte[length];
				WideCharToMultiByte(0, 0, text, text.Length, array, array.Length, IntPtr.Zero, IntPtr.Zero);
				length = Math.Min(text.Length, 8192);
				return GetTextExtentPoint32A(hDC, array, length, size);
			}
			return GetTextExtentPoint32W(hDC, text, text.Length, size);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		internal static extern bool ExtTextOut(HandleRef hdc, int x, int y, int options, ref IntNativeMethods.RECT rect, string str, int length, int[] spacing);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "LineTo", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntLineTo(HandleRef hdc, int x, int y);

		public static bool LineTo(HandleRef hdc, int x, int y)
		{
			return IntLineTo(hdc, x, y);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "MoveToEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntMoveToEx(HandleRef hdc, int x, int y, IntNativeMethods.POINT pt);

		public static bool MoveToEx(HandleRef hdc, int x, int y, IntNativeMethods.POINT pt)
		{
			return IntMoveToEx(hdc, x, y, pt);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "Rectangle", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntRectangle(HandleRef hdc, int left, int top, int right, int bottom);

		public static bool Rectangle(HandleRef hdc, int left, int top, int right, int bottom)
		{
			return IntRectangle(hdc, left, top, right, bottom);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, EntryPoint = "FillRect", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntFillRect(HandleRef hdc, [In] ref IntNativeMethods.RECT rect, HandleRef hbrush);

		public static bool FillRect(HandleRef hDC, [In] ref IntNativeMethods.RECT rect, HandleRef hbrush)
		{
			return IntFillRect(hDC, ref rect, hbrush);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SetMapMode", ExactSpelling = true, SetLastError = true)]
		public static extern int IntSetMapMode(HandleRef hDC, int nMapMode);

		public static int SetMapMode(HandleRef hDC, int nMapMode)
		{
			return IntSetMapMode(hDC, nMapMode);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "GetMapMode", ExactSpelling = true, SetLastError = true)]
		public static extern int IntGetMapMode(HandleRef hDC);

		public static int GetMapMode(HandleRef hDC)
		{
			return IntGetMapMode(hDC);
		}

		[DllImport("gdi32.dll", EntryPoint = "GetViewportExtEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntGetViewportExtEx(HandleRef hdc, [In][Out] IntNativeMethods.SIZE lpSize);

		public static bool GetViewportExtEx(HandleRef hdc, [In][Out] IntNativeMethods.SIZE lpSize)
		{
			return IntGetViewportExtEx(hdc, lpSize);
		}

		[DllImport("gdi32.dll", EntryPoint = "GetViewportOrgEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntGetViewportOrgEx(HandleRef hdc, [In][Out] IntNativeMethods.POINT lpPoint);

		public static bool GetViewportOrgEx(HandleRef hdc, [In][Out] IntNativeMethods.POINT lpPoint)
		{
			return IntGetViewportOrgEx(hdc, lpPoint);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SetViewportExtEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntSetViewportExtEx(HandleRef hDC, int x, int y, [In][Out] IntNativeMethods.SIZE size);

		public static bool SetViewportExtEx(HandleRef hDC, int x, int y, [In][Out] IntNativeMethods.SIZE size)
		{
			return IntSetViewportExtEx(hDC, x, y, size);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "SetViewportOrgEx", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntSetViewportOrgEx(HandleRef hDC, int x, int y, [In][Out] IntNativeMethods.POINT point);

		public static bool SetViewportOrgEx(HandleRef hDC, int x, int y, [In][Out] IntNativeMethods.POINT point)
		{
			return IntSetViewportOrgEx(hDC, x, y, point);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextMetricsW(HandleRef hDC, [In][Out] ref IntNativeMethods.TEXTMETRIC lptm);

		[DllImport("gdi32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
		public static extern int GetTextMetricsA(HandleRef hDC, [In][Out] ref IntNativeMethods.TEXTMETRICA lptm);

		public static int GetTextMetrics(HandleRef hDC, ref IntNativeMethods.TEXTMETRIC lptm)
		{
			int result;
			if (Marshal.SystemDefaultCharSize == 1)
			{
				IntNativeMethods.TEXTMETRICA lptm2 = default(IntNativeMethods.TEXTMETRICA);
				result = GetTextMetricsA(hDC, ref lptm2);
				lptm.tmHeight = lptm2.tmHeight;
				lptm.tmAscent = lptm2.tmAscent;
				lptm.tmDescent = lptm2.tmDescent;
				lptm.tmInternalLeading = lptm2.tmInternalLeading;
				lptm.tmExternalLeading = lptm2.tmExternalLeading;
				lptm.tmAveCharWidth = lptm2.tmAveCharWidth;
				lptm.tmMaxCharWidth = lptm2.tmMaxCharWidth;
				lptm.tmWeight = lptm2.tmWeight;
				lptm.tmOverhang = lptm2.tmOverhang;
				lptm.tmDigitizedAspectX = lptm2.tmDigitizedAspectX;
				lptm.tmDigitizedAspectY = lptm2.tmDigitizedAspectY;
				lptm.tmFirstChar = (char)lptm2.tmFirstChar;
				lptm.tmLastChar = (char)lptm2.tmLastChar;
				lptm.tmDefaultChar = (char)lptm2.tmDefaultChar;
				lptm.tmBreakChar = (char)lptm2.tmBreakChar;
				lptm.tmItalic = lptm2.tmItalic;
				lptm.tmUnderlined = lptm2.tmUnderlined;
				lptm.tmStruckOut = lptm2.tmStruckOut;
				lptm.tmPitchAndFamily = lptm2.tmPitchAndFamily;
				lptm.tmCharSet = lptm2.tmCharSet;
			}
			else
			{
				result = GetTextMetricsW(hDC, ref lptm);
			}
			return result;
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "BeginPath", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntBeginPath(HandleRef hDC);

		public static bool BeginPath(HandleRef hDC)
		{
			return IntBeginPath(hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "EndPath", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntEndPath(HandleRef hDC);

		public static bool EndPath(HandleRef hDC)
		{
			return IntEndPath(hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "StrokePath", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntStrokePath(HandleRef hDC);

		public static bool StrokePath(HandleRef hDC)
		{
			return IntStrokePath(hDC);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "AngleArc", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntAngleArc(HandleRef hDC, int x, int y, int radius, float startAngle, float endAngle);

		public static bool AngleArc(HandleRef hDC, int x, int y, int radius, float startAngle, float endAngle)
		{
			return IntAngleArc(hDC, x, y, radius, startAngle, endAngle);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "Arc", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntArc(HandleRef hDC, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXStartArc, int nYStartArc, int nXEndArc, int nYEndArc);

		public static bool Arc(HandleRef hDC, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXStartArc, int nYStartArc, int nXEndArc, int nYEndArc)
		{
			return IntArc(hDC, nLeftRect, nTopRect, nRightRect, nBottomRect, nXStartArc, nYStartArc, nXEndArc, nYEndArc);
		}

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern int SetTextAlign(HandleRef hDC, int nMode);

		[DllImport("gdi32.dll", CharSet = CharSet.Auto, EntryPoint = "Ellipse", ExactSpelling = true, SetLastError = true)]
		public static extern bool IntEllipse(HandleRef hDc, int x1, int y1, int x2, int y2);

		public static bool Ellipse(HandleRef hDc, int x1, int y1, int x2, int y2)
		{
			return IntEllipse(hDc, x1, y1, x2, y2);
		}

		[DllImport("kernel32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		public static extern int WideCharToMultiByte(int codePage, int flags, [MarshalAs(UnmanagedType.LPWStr)] string wideStr, int chars, [In][Out] byte[] pOutBytes, int bufferBytes, IntPtr defaultChar, IntPtr pDefaultUsed);
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class GPPOINT
	{
		internal int X;

		internal int Y;

		internal GPPOINT()
		{
		}

		internal GPPOINT(PointF pt)
		{
			X = (int)pt.X;
			Y = (int)pt.Y;
		}

		internal GPPOINT(Point pt)
		{
			X = pt.X;
			Y = pt.Y;
		}

		internal PointF ToPoint()
		{
			return new PointF(X, Y);
		}
	}
	[StructLayout(LayoutKind.Sequential)]
	internal class GPPOINTF
	{
		internal float X;

		internal float Y;

		internal GPPOINTF()
		{
		}

		internal GPPOINTF(PointF pt)
		{
			X = pt.X;
			Y = pt.Y;
		}

		internal GPPOINTF(Point pt)
		{
			X = pt.X;
			Y = pt.Y;
		}

		internal PointF ToPoint()
		{
			return new PointF(X, Y);
		}
	}
	internal struct GPRECT
	{
		internal int X;

		internal int Y;

		internal int Width;

		internal int Height;

		internal GPRECT(int x, int y, int width, int height)
		{
			X = x;
			Y = y;
			Width = width;
			Height = height;
		}

		internal GPRECT(Rectangle rect)
		{
			X = rect.X;
			Y = rect.Y;
			Width = rect.Width;
			Height = rect.Height;
		}

		internal Rectangle ToRectangle()
		{
			return new Rectangle(X, Y, Width, Height);
		}
	}
	internal struct GPRECTF
	{
		internal float X;

		internal float Y;

		internal float Width;

		internal float Height;

		internal SizeF SizeF => new SizeF(Width, Height);

		internal GPRECTF(float x, float y, float width, float height)
		{
			X = x;
			Y = y;
			Width = width;
			Height = height;
		}

		internal GPRECTF(RectangleF rect)
		{
			X = rect.X;
			Y = rect.Y;
			Width = rect.Width;
			Height = rect.Height;
		}

		internal RectangleF ToRectangleF()
		{
			return new RectangleF(X, Y, Width, Height);
		}
	}
	internal class GPStream : UnsafeNativeMethods.IStream
	{
		[StructLayout(LayoutKind.Sequential)]
		public class STATSTG
		{
			public IntPtr pwcsName = IntPtr.Zero;

			public int type;

			[MarshalAs(UnmanagedType.I8)]
			public long cbSize;

			[MarshalAs(UnmanagedType.I8)]
			public long mtime;

			[MarshalAs(UnmanagedType.I8)]
			public long ctime;

			[MarshalAs(UnmanagedType.I8)]
			public long atime;

			[MarshalAs(UnmanagedType.I4)]
			public int grfMode;

			[MarshalAs(UnmanagedType.I4)]
			public int grfLocksSupported;

			public int clsid_data1;

			[MarshalAs(UnmanagedType.I2)]
			public short clsid_data2;

			[MarshalAs(UnmanagedType.I2)]
			public short clsid_data3;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b0;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b1;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b2;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b3;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b4;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b5;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b6;

			[MarshalAs(UnmanagedType.U1)]
			public byte clsid_b7;

			[MarshalAs(UnmanagedType.I4)]
			public int grfStateBits;

			[MarshalAs(UnmanagedType.I4)]
			public int reserved;
		}

		protected Stream dataStream;

		private long virtualPosition = -1L;

		internal GPStream(Stream stream)
		{
			if (!stream.CanSeek)
			{
				byte[] array = new byte[256];
				int num = 0;
				int num2;
				do
				{
					if (array.Length < num + 256)
					{
						byte[] array2 = new byte[array.Length * 2];
						Array.Copy(array, array2, array.Length);
						array = array2;
					}
					num2 = stream.Read(array, num, 256);
					num += num2;
				}
				while (num2 != 0);
				dataStream = new MemoryStream(array);
			}
			else
			{
				dataStream = stream;
			}
		}

		private void ActualizeVirtualPosition()
		{
			if (virtualPosition != -1)
			{
				if (virtualPosition > dataStream.Length)
				{
					dataStream.SetLength(virtualPosition);
				}
				dataStream.Position = virtualPosition;
				virtualPosition = -1L;
			}
		}

		public virtual UnsafeNativeMethods.IStream Clone()
		{
			NotImplemented();
			return null;
		}

		public virtual void Commit(int grfCommitFlags)
		{
			dataStream.Flush();
			ActualizeVirtualPosition();
		}

		[UIPermission(SecurityAction.Demand, Window = UIPermissionWindow.AllWindows)]
		[SecurityPermission(SecurityAction.Assert, Flags = SecurityPermissionFlag.UnmanagedCode)]
		public virtual long CopyTo(UnsafeNativeMethods.IStream pstm, long cb, long[] pcbRead)
		{
			int num = 4096;
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			if (intPtr == IntPtr.Zero)
			{
				throw new OutOfMemoryException();
			}
			long num2 = 0L;
			try
			{
				int num4;
				for (; num2 < cb; num2 += num4)
				{
					int num3 = num;
					if (num2 + num3 > cb)
					{
						num3 = (int)(cb - num2);
					}
					num4 = Read(intPtr, num3);
					if (num4 == 0)
					{
						break;
					}
					if (pstm.Write(intPtr, num4) != num4)
					{
						throw EFail("Wrote an incorrect number of bytes");
					}
				}
			}
			finally
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (pcbRead != null && pcbRead.Length != 0)
			{
				pcbRead[0] = num2;
			}
			return num2;
		}

		public virtual Stream GetDataStream()
		{
			return dataStream;
		}

		public virtual void LockRegion(long libOffset, long cb, int dwLockType)
		{
		}

		protected static ExternalException EFail(string msg)
		{
			throw new ExternalException(msg, -2147467259);
		}

		protected static void NotImplemented()
		{
			throw new ExternalException(SR.GetString("NotImplemented"), -2147467263);
		}

		public virtual int Read(IntPtr buf, int length)
		{
			byte[] array = new byte[length];
			int result = Read(array, length);
			Marshal.Copy(array, 0, buf, length);
			return result;
		}

		public virtual int Read(byte[] buffer, int length)
		{
			ActualizeVirtualPosition();
			return dataStream.Read(buffer, 0, length);
		}

		public virtual void Revert()
		{
			NotImplemented();
		}

		public virtual long Seek(long offset, int origin)
		{
			long position = virtualPosition;
			if (virtualPosition == -1)
			{
				position = dataStream.Position;
			}
			long length = dataStream.Length;
			switch (origin)
			{
			case 0:
				if (offset <= length)
				{
					dataStream.Position = offset;
					virtualPosition = -1L;
				}
				else
				{
					virtualPosition = offset;
				}
				break;
			case 2:
				if (offset <= 0)
				{
					dataStream.Position = length + offset;
					virtualPosition = -1L;
				}
				else
				{
					virtualPosition = length + offset;
				}
				break;
			case 1:
				if (offset + position <= length)
				{
					dataStream.Position = position + offset;
					virtualPosition = -1L;
				}
				else
				{
					virtualPosition = offset + position;
				}
				break;
			}
			if (virtualPosition != -1)
			{
				return virtualPosition;
			}
			return dataStream.Position;
		}

		public virtual void SetSize(long value)
		{
			dataStream.SetLength(value);
		}

		public void Stat(IntPtr pstatstg, int grfStatFlag)
		{
			STATSTG sTATSTG = new STATSTG();
			sTATSTG.cbSize = dataStream.Length;
			Marshal.StructureToPtr((object)sTATSTG, pstatstg, fDeleteOld: true);
		}

		public virtual void UnlockRegion(long libOffset, long cb, int dwLockType)
		{
		}

		public virtual int Write(IntPtr buf, int length)
		{
			byte[] array = new byte[length];
			Marshal.Copy(buf, array, 0, length);
			return Write(array, length);
		}

		public virtual int Write(byte[] buffer, int length)
		{
			ActualizeVirtualPosition();
			dataStream.Write(buffer, 0, length);
			return length;
		}
	}
	internal interface ISystemColorTracker
	{
		void OnSystemColorChanged();
	}
	internal class SystemColorTracker
	{
		private static int INITIAL_SIZE = 200;

		private static int WARNING_SIZE = 100000;

		private static float EXPAND_THRESHOLD = 0.75f;

		private static int EXPAND_FACTOR = 2;

		private static WeakReference[] list = new WeakReference[INITIAL_SIZE];

		private static int count = 0;

		private static bool addedTracker;

		private SystemColorTracker()
		{
		}

		internal static void Add(ISystemColorTracker obj)
		{
			lock (typeof(SystemColorTracker))
			{
				if (list.Length == count)
				{
					GarbageCollectList();
				}
				if (!addedTracker)
				{
					addedTracker = true;
					SystemEvents.UserPreferenceChanged += OnUserPreferenceChanged;
				}
				int num = count;
				count++;
				if (list[num] == null)
				{
					list[num] = new WeakReference(obj);
				}
				else
				{
					list[num].Target = obj;
				}
			}
		}

		private static void CleanOutBrokenLinks()
		{
			int num = list.Length - 1;
			int num2 = 0;
			int num3 = list.Length;
			while (true)
			{
				if (num2 < num3 && list[num2].Target != null)
				{
					num2++;
					continue;
				}
				while (num >= 0 && list[num].Target == null)
				{
					num--;
				}
				if (num2 >= num)
				{
					break;
				}
				WeakReference weakReference = list[num2];
				list[num2] = list[num];
				list[num] = weakReference;
				num2++;
				num--;
			}
			count = num2;
		}

		private static void GarbageCollectList()
		{
			CleanOutBrokenLinks();
			if ((float)count / (float)list.Length > EXPAND_THRESHOLD)
			{
				WeakReference[] array = new WeakReference[list.Length * EXPAND_FACTOR];
				list.CopyTo(array, 0);
				list = array;
				_ = list.Length;
				_ = WARNING_SIZE;
			}
		}

		private static void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e)
		{
			if (e.Category == UserPreferenceCategory.Color)
			{
				for (int i = 0; i < count; i++)
				{
					((ISystemColorTracker)list[i].Target)?.OnSystemColorChanged();
				}
			}
		}
	}
}
namespace System.ComponentModel
{
	internal static class CompModSwitches
	{
		private static TraceSwitch handleLeak;

		private static BooleanSwitch traceCollect;

		public static TraceSwitch HandleLeak
		{
			get
			{
				if (handleLeak == null)
				{
					handleLeak = new TraceSwitch("HANDLELEAK", "HandleCollector: Track Win32 Handle Leaks");
				}
				return handleLeak;
			}
		}

		public static BooleanSwitch TraceCollect
		{
			get
			{
				if (traceCollect == null)
				{
					traceCollect = new BooleanSwitch("TRACECOLLECT", "HandleCollector: Trace HandleCollector operations");
				}
				return traceCollect;
			}
		}
	}
	internal static class CoreSwitches
	{
		private static BooleanSwitch perfTrack;

		public static BooleanSwitch PerfTrack
		{
			get
			{
				if (perfTrack == null)
				{
					perfTrack = new BooleanSwitch("PERFTRACK", "Debug performance critical sections.");
				}
				return perfTrack;
			}
		}
	}
}
namespace System.Internal
{
	internal sealed class HandleCollector
	{
		private class HandleType
		{
			internal readonly string name;

			private int initialThreshHold;

			private int threshHold;

			private int handleCount;

			private readonly int deltaPercent;

			internal HandleType(string name, int expense, int initialThreshHold)
			{
				this.name = name;
				this.initialThreshHold = initialThreshHold;
				threshHold = initialThreshHold;
				deltaPercent = 100 - expense;
			}

			internal void Add(IntPtr handle)
			{
				if (handle == IntPtr.Zero)
				{
					return;
				}
				bool flag = false;
				int currentHandleCount = 0;
				lock (this)
				{
					handleCount++;
					flag = NeedCollection();
					currentHandleCount = handleCount;
				}
				lock (internalSyncObject)
				{
					if (HandleCollector.HandleAdded != null)
					{
						HandleCollector.HandleAdded(name, handle, currentHandleCount);
					}
				}
				if (flag && flag)
				{
					GC.Collect();
					int millisecondsTimeout = (100 - deltaPercent) / 4;
					Thread.Sleep(millisecondsTimeout);
				}
			}

			internal int GetHandleCount()
			{
				lock (this)
				{
					return handleCount;
				}
			}

			internal bool NeedCollection()
			{
				if (suspendCount > 0)
				{
					return false;
				}
				if (handleCount > threshHold)
				{
					threshHold = handleCount + handleCount * deltaPercent / 100;
					return true;
				}
				int num = 100 * threshHold / (100 + deltaPercent);
				if (num >= initialThreshHold && handleCount < (int)((float)num * 0.9f))
				{
					threshHold = num;
				}
				return false;
			}

			internal IntPtr Remove(IntPtr handle)
			{
				if (handle == IntPtr.Zero)
				{
					return handle;
				}
				int currentHandleCount = 0;
				lock (this)
				{
					handleCount--;
					if (handleCount < 0)
					{
						handleCount = 0;
					}
					currentHandleCount = handleCount;
				}
				lock (internalSyncObject)
				{
					if (HandleCollector.HandleRemoved != null)
					{
						HandleCollector.HandleRemoved(name, handle, currentHandleCount);
						return handle;
					}
					return handle;
				}
			}
		}

		private static HandleType[] handleTypes;

		private static int handleTypeCount;

		private static int suspendCount;

		private static object internalSyncObject = new object();

		internal static event HandleChangeEventHandler HandleAdded;

		internal static event HandleChangeEventHandler HandleRemoved;

		internal static IntPtr Add(IntPtr handle, int type)
		{
			handleTypes[type - 1].Add(handle);
			return handle;
		}

		internal static void SuspendCollect()
		{
			lock (internalSyncObject)
			{
				suspendCount++;
			}
		}

		internal static void ResumeCollect()
		{
			bool flag = false;
			lock (internalSyncObject)
			{
				if (suspendCount > 0)
				{
					suspendCount--;
				}
				if (suspendCount == 0)
				{
					for (int i = 0; i < handleTypeCount; i++)
					{
						lock (handleTypes[i])
						{
							if (handleTypes[i].NeedCollection())
							{
								flag = true;
							}
						}
					}
				}
			}
			if (flag)
			{
				GC.Collect();
			}
		}

		internal static int RegisterType(string typeName, int expense, int initialThreshold)
		{
			lock (internalSyncObject)
			{
				if (handleTypeCount == 0 || handleTypeCount == handleTypes.Length)
				{
					HandleType[] destinationArray = new HandleType[handleTypeCount + 10];
					if (handleTypes != null)
					{
						Array.Copy(handleTypes, 0, destinationArray, 0, handleTypeCount);
					}
					handleTypes = destinationArray;
				}
				handleTypes[handleTypeCount++] = new HandleType(typeName, expense, initialThreshold);
				return handleTypeCount;
			}
		}

		internal static IntPtr Remove(IntPtr handle, int type)
		{
			return handleTypes[type - 1].Remove(handle);
		}
	}
	internal delegate void HandleChangeEventHandler(string handleType, IntPtr handleValue, int currentHandleCount);
	internal class DebugHandleTracker
	{
		private class HandleType
		{
			private class HandleEntry
			{
				private class StackParser
				{
					internal string releventStack;

					internal int startIndex;

					internal int endIndex;

					internal int length;

					public StackParser(string callStack)
					{
						releventStack = callStack;
						length = releventStack.Length;
					}

					private static bool ContainsString(string str, string token)
					{
						int num = str.Length;
						int num2 = token.Length;
						for (int i = 0; i < num; i++)
						{
							int j;
							for (j = 0; j < num2 && str[i + j] == token[j]; j++)
							{
							}
							if (j == num2)
							{
								return true;
							}
						}
						return false;
					}

					public void DiscardNext()
					{
						GetLine();
					}

					public void DiscardTo(string discardText)
					{
						while (startIndex < length)
						{
							string line = GetLine();
							if (line == null || ContainsString(line, discardText))
							{
								break;
							}
						}
					}

					private string GetLine()
					{
						endIndex = releventStack.IndexOf('\r', startIndex);
						if (endIndex < 0)
						{
							endIndex = length - 1;
						}
						string text = releventStack.Substring(startIndex, endIndex - startIndex);
						char c;
						while (endIndex < length && ((c = releventStack[endIndex]) == '\r' || c == '\n'))
						{
							endIndex++;
						}
						if (startIndex == endIndex)
						{
							return null;
						}
						startIndex = endIndex;
						return text.Replace('\t', ' ');
					}

					public override string ToString()
					{
						return releventStack.Substring(startIndex);
					}

					public void Truncate(int lines)
					{
						string text = "";
						while (lines-- > 0 && startIndex < length)
						{
							text = ((text != null) ? (text + ": " + GetLine()) : GetLine());
							text += Environment.NewLine;
						}
						releventStack = text;
						startIndex = 0;
						endIndex = 0;
						length = releventStack.Length;
					}
				}

				public readonly IntPtr handle;

				public HandleEntry next;

				public readonly string callStack;

				public bool ignorableAsLeak;

				public HandleEntry(HandleEntry next, IntPtr handle)
				{
					this.handle = handle;
					this.next = next;
					if (System.ComponentModel.CompModSwitches.HandleLeak.Level > TraceLevel.Off)
					{
						callStack = Environment.StackTrace;
					}
					else
					{
						callStack = null;
					}
				}

				public string ToString(HandleType type)
				{
					StackParser stackParser = new StackParser(callStack);
					stackParser.DiscardTo("HandleCollector.Add");
					stackParser.DiscardNext();
					stackParser.Truncate(40);
					string text = "";
					return Convert.ToString((int)handle, 16) + text + ": " + stackParser.ToString();
				}
			}

			public readonly string name;

			private int handleCount;

			private HandleEntry[] buckets;

			private const int BUCKETS = 10;

			public HandleType(string name)
			{
				this.name = name;
				buckets = new HandleEntry[10];
			}

			public void Add(IntPtr handle)
			{
				lock (this)
				{
					int num = ComputeHash(handle);
					if (System.ComponentModel.CompModSwitches.HandleLeak.Level >= TraceLevel.Info)
					{
						_ = System.ComponentModel.CompModSwitches.HandleLeak.Level;
						_ = 4;
					}
					for (HandleEntry handleEntry = buckets[num]; handleEntry != null; handleEntry = handleEntry.next)
					{
					}
					buckets[num] = new HandleEntry(buckets[num], handle);
					handleCount++;
				}
			}

			public void CheckLeaks()
			{
				lock (this)
				{
					bool flag = false;
					if (handleCount <= 0)
					{
						return;
					}
					for (int i = 0; i < 10; i++)
					{
						for (HandleEntry handleEntry = buckets[i]; handleEntry != null; handleEntry = handleEntry.next)
						{
							if (!handleEntry.ignorableAsLeak && !flag)
							{
								flag = true;
							}
						}
					}
				}
			}

			public void IgnoreCurrentHandlesAsLeaks()
			{
				lock (this)
				{
					if (handleCount <= 0)
					{
						return;
					}
					for (int i = 0; i < 10; i++)
					{
						for (HandleEntry handleEntry = buckets[i]; handleEntry != null; handleEntry = handleEntry.next)
						{
							handleEntry.ignorableAsLeak = true;
						}
					}
				}
			}

			private int ComputeHash(IntPtr handle)
			{
				return ((int)handle & 0xFFFF) % 10;
			}

			public bool Remove(IntPtr handle)
			{
				lock (this)
				{
					int num = ComputeHash(handle);
					if (System.ComponentModel.CompModSwitches.HandleLeak.Level >= TraceLevel.Info)
					{
						_ = System.ComponentModel.CompModSwitches.HandleLeak.Level;
						_ = 4;
					}
					HandleEntry handleEntry = buckets[num];
					HandleEntry handleEntry2 = null;
					while (handleEntry != null && handleEntry.handle != handle)
					{
						handleEntry2 = handleEntry;
						handleEntry = handleEntry.next;
					}
					if (handleEntry != null)
					{
						if (handleEntry2 == null)
						{
							buckets[num] = handleEntry.next;
						}
						else
						{
							handleEntry2.next = handleEntry.next;
						}
						handleCount--;
						return true;
					}
					return false;
				}
			}
		}

		private static Hashtable handleTypes;

		private static DebugHandleTracker tracker;

		private static object internalSyncObject;

		static DebugHandleTracker()
		{
			handleTypes = new Hashtable();
			internalSyncObject = new object();
			tracker = new DebugHandleTracker();
			if (System.ComponentModel.CompModSwitches.HandleLeak.Level > TraceLevel.Off || System.ComponentModel.CompModSwitches.TraceCollect.Enabled)
			{
				HandleCollector.HandleAdded += tracker.OnHandleAdd;
				HandleCollector.HandleRemoved += tracker.OnHandleRemove;
			}
		}

		private DebugHandleTracker()
		{
		}

		public static void IgnoreCurrentHandlesAsLeaks()
		{
			lock (internalSyncObject)
			{
				if (System.ComponentModel.CompModSwitches.HandleLeak.Level < TraceLevel.Warning)
				{
					return;
				}
				HandleType[] array = new HandleType[handleTypes.Values.Count];
				handleTypes.Values.CopyTo(array, 0);
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] != null)
					{
						array[i].IgnoreCurrentHandlesAsLeaks();
					}
				}
			}
		}

		public static void CheckLeaks()
		{
			lock (internalSyncObject)
			{
				if (System.ComponentModel.CompModSwitches.HandleLeak.Level < TraceLevel.Warning)
				{
					return;
				}
				GC.Collect();
				GC.WaitForPendingFinalizers();
				HandleType[] array = new HandleType[handleTypes.Values.Count];
				handleTypes.Values.CopyTo(array, 0);
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] != null)
					{
						array[i].CheckLeaks();
					}
				}
			}
		}

		public static void Initialize()
		{
		}

		private void OnHandleAdd(string handleName, IntPtr handle, int handleCount)
		{
			HandleType handleType = (HandleType)handleTypes[handleName];
			if (handleType == null)
			{
				handleType = new HandleType(handleName);
				handleTypes[handleName] = handleType;
			}
			handleType.Add(handle);
		}

		private void OnHandleRemove(string handleName, IntPtr handle, int HandleCount)
		{
			HandleType handleType = (HandleType)handleTypes[handleName];
			bool flag = false;
			if (handleType != null)
			{
				flag = handleType.Remove(handle);
			}
			if (!flag)
			{
				_ = System.ComponentModel.CompModSwitches.HandleLeak.Level;
				_ = 1;
			}
		}
	}
}
